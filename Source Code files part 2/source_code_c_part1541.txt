ation	1998
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _CDOPT_PUBLICINTEFACES_
#define _CDOPT_PUBLICINTEFACES_

#include "objbase.h"
#include "mmsystem.h"

#ifdef __cplusplus
extern "C" {
#endif

const CLSID CLSID_CDOpt = {0xE5927147,0x521E,0x11D1,{0x9B,0x97,0x00,0xC0,0x4F,0xA3,0xB6,0x10}};

typedef struct TIMEDMETER
{
    HWND        hMeter;
    HWND        hParent;
    BOOL        fShowing;
    DWORD       dwStartTime;
    DWORD       dwShowCount;
    DWORD       dwCount;
    DWORD       dwJump;
    DWORD       dwRange;

} TIMEDMETER, *LPTIMEDMETER;

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Definitions 
//
// Defines the GUIDs / IIDs for this project:
//
// IID_IMMFWNotifySink, IMMComponent, IMMComponentAutomation
//
// These are the three interfaces for Framework / Component communications.
// All other interfaces should be private to the specific project.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define lCDOPTIIDFirst			    0xb2cd5bbd
#define DEFINE_CDOPTIID(name, x)	DEFINE_GUID(name, lCDOPTIIDFirst + x, 0x5221,0x11d1,0x9b,0x97,0x0,0xc0,0x4f,0xa3,0xb6,0xc)

DEFINE_CDOPTIID(IID_ICDOpt,	        0);
DEFINE_CDOPTIID(IID_ICDData,	    1);


///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CDOptions Interface Typedefs
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef interface ICDOpt	    	ICDOpt;
typedef ICDOpt*	    			    LPCDOPT;

typedef interface ICDData	        ICDData;
typedef ICDData*	    			LPCDDATA;

#ifndef LPUNKNOWN
typedef IUnknown*                   LPUNKNOWN;
#endif



///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CDOPTIONS common defines
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum CDDISP_MODES 
{
    CDDISP_CDTIME       =   0x0001,		
    CDDISP_CDREMAIN     =   0x0002,		
    CDDISP_TRACKTIME    =   0x0004,
    CDDISP_TRACKREMAIN  =   0x0008,
};

enum CDOPT_PAGE 
{
    CDOPT_PAGE_PLAY       =   0x0000,		
    CDOPT_PAGE_TITLE      =   0x0001,		
    CDOPT_PAGE_PLAYLIST   =   0x0002,		
};


#define CDTITLE_NODISC      (0)
#define CDSTR               (128)

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CDOptions common typedefs
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

struct CDOPTIONS;
struct CDTITLE;

typedef DWORD   (CALLBACK FAR * LPFNCDDOWNLOAD)(CDTITLE  *pTitle, LPARAM lParam, HWND hwnd);
typedef void    (CALLBACK FAR * LPFNCDOPTIONS)(CDOPTIONS *pCDOpts);


typedef struct CDUNIT
{
    TCHAR   szDriver[MAX_PATH];
    TCHAR   szDeviceDesc[MAX_PATH];
    TCHAR   szDriveName[MAX_PATH];
    TCHAR   szMixerName[MAXPNAMELEN];
    TCHAR   szVolName[MIXER_LONG_NAME_CHARS];
    TCHAR   szNetQuery[2048];
    DWORD   dwMixID;
    DWORD   dwVolID;
    DWORD   dwMuteID;
    DWORD   dwTitleID;
    DWORD   dwNumTracks;
    BOOL    fSelected;
    BOOL    fDefaultDrive;
    BOOL    fDownLoading;
    BOOL    fChanged;
    CDUNIT *pNext;

} CDUNIT, *LPCDUNIT;


typedef struct CDPROVIDER
{
    TCHAR       szProviderURL[MAX_PATH];
    TCHAR       szProviderName[MAX_PATH];
    TCHAR       szProviderHome[MAX_PATH];
    TCHAR       szProviderLogo[MAX_PATH];
    TCHAR       szProviderUpload[MAX_PATH];
    BOOL        fTimedOut;
    CDPROVIDER  *pNext;
    
} CDPROVIDER, *LPCDPROVIDER;


typedef struct CDOPTDATA
{                                  
    BYTE    fDispMode;              
    BOOL    fStartPlay;             
    BOOL    fExitStop;              
    BOOL    fTopMost; 
    BOOL    fTrayEnabled;          
    BOOL    fDownloadEnabled;      
    BOOL    fDownloadPrompt;       
    BOOL    fBatchEnabled;
    BOOL    fByArtist; 
    DWORD   dwPlayMode;        
    DWORD   dwIntroTime; 
    DWORD   dwWindowX;
    DWORD   dwWindowY;
    DWORD   dwViewMode;
            
} CDOPTDATA, *LPCDOPTDATA;



typedef struct CDMENU
{
    TCHAR       szMenuText[CDSTR];
    TCHAR       *szMenuQuery;

} CDMENU, *LPCDMENU;


typedef struct CDTRACK
{
    TCHAR       szName[CDSTR];

} CDTRACK, *LPCDTRACK;


typedef struct CDTITLE
{
    DWORD       dwTitleID;
    DWORD       dwNumTracks;
    BOOL        fDownLoading;
    LPCDTRACK   pTrackTable;
    DWORD       dwNumPlay;
    LPWORD      pPlayList;
    DWORD       dwNumMenus;
    LPCDMENU    pMenuTable;
    TCHAR       szTitle[CDSTR];
    TCHAR       szArtist[CDSTR];
    TCHAR       szLabel[CDSTR];
    TCHAR       szDate[CDSTR];
    TCHAR       szCopyright[CDSTR];
    TCHAR       *szTitleQuery;
    BOOL        dwLockCnt;
    BOOL        fLoaded;
    BOOL        fChanged;
    BOOL        fDriveExpanded;
    BOOL        fAlbumExpanded;
    BOOL        fArtistExpanded;
    BOOL        fRemove;
    CDTITLE *   pNext;

}CDTITLE, *LPCDTITLE;


typedef struct CDOPTIONS
{
    LPCDOPTDATA     pCDData;
    LPCDPROVIDER    pProviderList;
    LPCDPROVIDER    pCurrentProvider;
    LPCDPROVIDER    pDefaultProvider;
    LPCDUNIT        pCDUnitList;
    DWORD           dwBatchedTitles;
    LPFNCDDOWNLOAD  pfnDownloadTitle;
    LPFNCDOPTIONS   pfnOptionsCallback;
    LPARAM          lParam;
    UINT_PTR        pReserved;

} CDOPTIONS, *LPCDOPTIONS;


typedef struct CDBATCH
{
    DWORD           dwTitleID;
    DWORD           dwNumTracks;
    TCHAR           *szTitleQuery;
    BOOL            fRemove;
    BOOL            fFresh;
    CDBATCH         *pNext;

} CDBATCH, *LPCDBATCH;


///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CDOptions Interface Definitions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE ICDOpt
DECLARE_INTERFACE_(ICDOpt, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			    (THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			    (THIS) PURE;
    STDMETHOD_(ULONG,Release) 			    (THIS) PURE;

    //---  ICDOpt methods--- 
    STDMETHOD_(LPCDOPTIONS,GetCDOpts)       (THIS) PURE;

    STDMETHOD (CreateProviderList)          (THIS_ LPCDPROVIDER *ppProviderList) PURE;

    STDMETHOD_(void, DestroyProviderList)   (THIS_ LPCDPROVIDER *ppProviderList) PURE;

    STDMETHOD_(void, UpdateRegistry)        (THIS) PURE;

    STDMETHOD (OptionsDialog)               (THIS_ HWND hWnd, 
                                                   LPCDDATA pCDData,
                                                   CDOPT_PAGE nStartPage) PURE;

    STDMETHOD_(BOOL,VerifyProvider)         (THIS_ LPCDPROVIDER pCDProvider, 
                                                TCHAR *szCertKey) PURE;

    STDMETHOD (CreateProviderKey)           (THIS_ LPCDPROVIDER pCDProvider, 
                                                   TCHAR *szCertKey,
                                                   UINT cBytes) PURE;

    STDMETHOD_(void,DownLoadCompletion)     (THIS_ DWORD dwNumIDs,
                                                    LPDWORD pdwIDs) PURE;

    STDMETHOD_(void,DiscChanged)            (THIS_ LPCDUNIT pCDUnit) PURE;

    STDMETHOD_(void,MMDeviceChanged)        (THIS) PURE;

};


#undef INTERFACE
#define INTERFACE ICDData
DECLARE_INTERFACE_(ICDData, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;

    //---  ICDOpt methods--- 

    STDMETHOD (Initialize)              (THIS_ HWND hWnd) PURE;

    STDMETHOD (CheckDatabase)           (THIS_ HWND hWnd) PURE;

    STDMETHOD_(BOOL, QueryTitle)        (THIS_ DWORD dwTitleID) PURE;

    STDMETHOD (LockTitle)               (THIS_ LPCDTITLE *ppCDTitle,
                                               DWORD dwTitleID) PURE;


    STDMETHOD (CreateTitle)             (THIS_ LPCDTITLE *ppCDTitle,
                                               DWORD dwTitleID,                                   
                                               DWORD dwNumTracks,
                                               DWORD dwNumMenus) PURE;
    
    STDMETHOD (SetTitleQuery)           (THIS_ LPCDTITLE pCDTitle,
                                               TCHAR *szTitleQuery) PURE;

    STDMETHOD (SetMenuQuery)            (THIS_ LPCDMENU pCDMenu,
                                               TCHAR *szMenuQuery) PURE;

    STDMETHOD_(void,UnlockTitle)        (THIS_ LPCDTITLE pCDTitle, 
                                               BOOL fPresist) PURE;

    STDMETHOD (LoadTitles)              (THIS_ HWND hWnd) PURE;

    STDMETHOD (PersistTitles)           (THIS) PURE;

    STDMETHOD (UnloadTitles)            (THIS) PURE;

    STDMETHOD_(LPCDTITLE,GetTitleList)  (THIS) PURE;

    // -- Batch methods

    STDMETHOD_(BOOL, QueryBatch)        (THIS_ DWORD dwTitleID) PURE;

    STDMETHOD_(DWORD, GetNumBatched)    (THIS) PURE;

    STDMETHOD (LoadBatch)               (THIS_ HWND hWnd,
                                               LPCDBATCH *ppCDBatchList) PURE;

    STDMETHOD (UnloadBatch)             (THIS_ LPCDBATCH pCDBatchList) PURE;

    STDMETHOD (DumpBatch)               (THIS) PURE;

    STDMETHOD (AddToBatch)              (THIS_ DWORD dwTitleID, 
                                               TCHAR *szTitleQuery, 
                                               DWORD dwNumTracks) PURE;

    STDMETHOD_(void,CreateMeter)        (THIS_ LPTIMEDMETER ptm, HWND hWnd, DWORD dwCount, DWORD dwJump, UINT uStringID);
    STDMETHOD_(void,UpdateMeter)        (THIS_ LPTIMEDMETER ptm);
    STDMETHOD_(void,DestroyMeter)       (THIS_ LPTIMEDMETER ptm);

};



#ifdef __cplusplus
};
#endif

#endif  //_CDOPT_PUBLICINTEFACES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\cdoptimp.h ===
/******************************Module*Header*******************************\
* Module Name: cdoptimp.h
*
* Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#if !defined(CDOPT_COM_IMPLEMENTATION)
#define CDOPT_COM_IMPLEMENTATION

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif 

#include "cdopt.h"
#include <windows.h>
#include <windowsx.h>
#include <wincrypt.h>
#include "..\cdnet\cdnet.h"


/////////////////////////////////////////////////////////////////////////////
// Internal Defines

#define CDINFO_NOEDIT       (0x0000)
#define CDINFO_EDIT         (0x0001)
#define CDINFO_TRACK        (CDINFO_EDIT | 0x0010)
#define CDINFO_TITLE        (CDINFO_EDIT | 0x0020)
#define CDINFO_ARTIST       (CDINFO_EDIT | 0x0040)
#define CDINFO_DISC         (CDINFO_NOEDIT | 0x0020)
#define CDINFO_ALBUMS       (CDINFO_NOEDIT | 0x0080)
#define CDINFO_DRIVES       (CDINFO_NOEDIT | 0x0100)
#define CDINFO_LABEL        (CDINFO_NOEDIT | 0x0200)
#define CDINFO_CDROM        (CDINFO_NOEDIT | 0x0400)
#define CDINFO_OTHER        (CDINFO_NOEDIT | 0x0800)

#define DG_BEGINDRAG    (LB_MSGMAX+100)
#define DG_DRAGGING     (LB_MSGMAX+101)
#define DG_DROPPED      (LB_MSGMAX+102)
#define DG_CANCELDRAG   (LB_MSGMAX+103)
#define DG_CURSORSET    0
#define DG_MOVE         0
#define DG_COPY         1

#define SJE_DRAGLISTMSGSTRING "sje_DragMultiListMsg"
#define TRACK_TITLE_LENGTH 255


/////////////////////////////////////////////////////////////////////////////
// Internal Structures

typedef struct DRAGMULTILISTINFO
{
    UINT    uNotification;
    HWND    hWnd;
    POINT   ptCursor;
    DWORD   dwState;

} DRAGMULTILISTINFO, *LPDRAGMULTILISTINFO;

typedef struct LIST_INFO
{
    int      index;
    UINT_PTR dwData;
    TCHAR    chName[TRACK_TITLE_LENGTH];

} LIST_INFO, *LPLIST_INFO;


typedef struct CDTREEINFO
{
    LPCDTITLE   pCDTitle;
    DWORD       dwTrack;
    DWORD       fdwType;
    LPCDUNIT    pCDUnit;

} CDTREEINFO, *LPCDTREEINFO;

typedef struct CDCONTROL        // UI Tree node for Controls
{
    TCHAR           szName[MIXER_LONG_NAME_CHARS];
    DWORD           dwVolID;
    DWORD           dwMuteID;
    CDCONTROL       *pNext;

} CDCONTROL, *LPCDCONTROL;


typedef struct CDMIXER          // UI Tree node for mixers
{
    DWORD           dwMixID;
    TCHAR           szPname[MAXPNAMELEN];
    CDMIXER         *pNext;
    LPCDCONTROL     pControlList;
    LPCDCONTROL     pCurrentControl;
    LPCDCONTROL     pOriginalControl;
    LPCDCONTROL     pDefaultControl;

} CDMIXER, *LPCDMIXER;


typedef struct CDDRIVE          // UI Tree node for CD players
{
    TCHAR           szDriveName[MAX_PATH];
    TCHAR           szDeviceDesc[MAX_PATH];
    CDDRIVE         *pNext;
    LPCDMIXER       pMixerList;
    LPCDMIXER       pCurrentMixer;
    LPCDMIXER       pOriginalMixer;
    BOOL            fSelected;

} CDDRIVE, *LPCDDRIVE;

typedef struct CDKEY
{
    HCRYPTPROV      hProv;
    HCRYPTKEY       hKey;
    HCRYPTHASH      hHash;

} CDKEY, *LPCDKEY;


/////////////////////////////////////////////////////////////////////////////
// CCDOpt

class CCDOpt : public ICDOpt
{
public:
	CCDOpt();
    ~CCDOpt();

public:
// IUnknown
    STDMETHOD (QueryInterface)              (REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)                (void);
    STDMETHOD_(ULONG,Release)               (void);

// ICDOpt
    STDMETHOD_(LPCDOPTIONS, GetCDOpts)      (void);
    STDMETHOD (CreateProviderList)          (LPCDPROVIDER *ppProviderList);
    STDMETHOD_(void,DestroyProviderList)    (LPCDPROVIDER *ppProviderList);
    STDMETHOD_(void,UpdateRegistry)         (void);
    STDMETHOD (OptionsDialog)               (HWND hWnd, LPCDDATA pCDData, CDOPT_PAGE nStartPage);
    STDMETHOD_(BOOL,VerifyProvider)         (LPCDPROVIDER pCDProvider, TCHAR *szCertKey);
    STDMETHOD (CreateProviderKey)           (LPCDPROVIDER pCDProvider, TCHAR *szCertKey, UINT cBytes);
    STDMETHOD_(void,DownLoadCompletion)     (DWORD dwNumIDs, LPDWORD pdwIDs);
    STDMETHOD_(void,DiscChanged)            (LPCDUNIT pCDUnit);
    STDMETHOD_(void,MMDeviceChanged)        (void);


private:
    DWORD           m_dwRef;
    HINSTANCE       m_hInst;                // hInstance of caller
    LPCDOPTIONS     m_pCDOpts;              // Original Opts from reg
    LPCDOPTIONS     m_pCDCopy;              // Current Working copy while UI is up.
    LPCDDATA        m_pCDData;              // Reference to CD Database Object
    LPCDDRIVE       m_pCDTree;              // Internal tree for CD/Mixer/Control Tree (Control line picker dialog)
    LPCDDRIVE       m_pCDSelected;          // Stores originally selected drive
    HIMAGELIST      m_hImageList;           // List of icon's for treeview of titles
    LPCDTITLE       m_pCDTitle;             // Used by Title Editor Dialog
    LPCDTITLE       m_pCDUploadTitle;       // Used to upload a title to net
    LRESULT         m_dwTrack;
    HWND            m_hList;                           
    WNDPROC         m_pfnSubProc;           // Used to subclass the Tree control
    BOOL            m_fEditReturn;          // True if user ended edit with a return in treeview
    BOOL            m_fVolChanged;          // True if there has been a change to the volume configuration
    BOOL            m_fAlbumsExpanded;      // True if database is expanded in tree
    BOOL            m_fDrivesExpanded;      // True if drivelist is expanded in tree
    HWND            m_hTitleWnd;            // Title Options dialog hwnd

    HDC             m_hdcMem;               // Temporary hdc used to draw the track bitmap.
    HBITMAP         m_hbmTrack;			    // HBITMAP to be displayed beside the tracks  
    UINT            m_DragMessage;          // Message ID of drag drop interface       
    HCURSOR         m_hCursorDrop;          // Drops allowed cursor                       
    HCURSOR         m_hCursorNoDrop;        // Drops not allowed cursor               
    HCURSOR         m_hCursorDropCpy;       // Drop copies the selection               
    UINT            m_uDragListMsg;
    ICDNet *        m_pICDNet;              // Pointer to internet object for uploading title info

    // playopts.cpp
    static BOOL CALLBACK PlayerOptionsProc  (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK PlayListsProc      (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK TitleOptionsProc   (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK ListEditorProc     (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK MixerConfigProc    (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK SubProc         (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK DragListProc    (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK UploadProc         (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK ConfirmProc        (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

    STDMETHOD_(BOOL,PlayerOptions)          (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHOD_(BOOL,PlayLists)              (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHOD_(BOOL,TitleOptions)           (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

    STDMETHOD_(void,OrderProviders)         (LPCDPROVIDER *ppProviderList, LPCDPROVIDER pCurrentProvider);
    STDMETHOD_(void,ApplyCurrentSettings)   (void);
    STDMETHOD_(void,ToggleApplyButton)      (HWND hDlg);
    STDMETHOD (AcquireKey)                  (LPCDKEY pCDKey, char *szName);
    STDMETHOD_(void,ReleaseKey)             (LPCDKEY pCDKey);
    STDMETHOD (CreateCertString)            (LPCDPROVIDER pCDProvider, TCHAR *szCertStr);


    STDMETHOD_(void,RegGetByte)             (HKEY hKey, const TCHAR *szKey, LPBYTE pByte, BYTE bDefault);
    STDMETHOD_(void,RegGetDWORD)            (HKEY hKey, const TCHAR *szKey, LPDWORD pdwData, DWORD dwDefault);
    STDMETHOD_(void,RegSetByte)             (HKEY hKey, const TCHAR *szKey, BYTE bData);
    STDMETHOD_(void,RegSetDWORD)            (HKEY hKey, const TCHAR *szKey, DWORD dwData);

    STDMETHOD_(BOOL,GetUploadPrompt)        (void);
    STDMETHOD_(void,SetUploadPrompt)        (BOOL fConfirmUpload);

    STDMETHOD (GetCDData)                   (LPCDOPTDATA pCDData);
    STDMETHOD (SetCDData)                   (LPCDOPTDATA pCDData);

    STDMETHOD_(void,GetCurrentProviderURL)  (TCHAR *szProviderURL);
    STDMETHOD (GetProviderData)             (LPCDOPTIONS pCDOpts);
    STDMETHOD (SetProviderData)             (LPCDOPTIONS pCDOpts);

    STDMETHOD (CopyOptions)                 (void);
    STDMETHOD_(void,DumpOptionsCopy)        (void);
    STDMETHOD_(void,DestroyCDOptions)       (void);
    STDMETHOD_(BOOL,OptionsChanged)         (LPCDOPTIONS pCDOpts);

    STDMETHOD_(void,UsePlayerDefaults)      (HWND hDlg);
    STDMETHOD_(BOOL,InitPlayerOptions)      (HWND hDlg);
    STDMETHOD_(void,SetIntroTime)           (HWND hDlg);

    STDMETHOD_(void,ToggleInternetDownload) (HWND hDlg);
    STDMETHOD_(BOOL,InitTitleOptions)       (HWND hDlg);
    STDMETHOD_(void,RestoreTitleDefaults)   (HWND hDlg);
    STDMETHOD_(void,ChangeCDProvider)       (HWND hDlg);
    STDMETHOD_(void,DownloadNow)            (HWND hDlg);
    STDMETHOD_(void,UpdateBatched)          (HWND hDlg);

    // playlist.cpp

    STDMETHOD_(HTREEITEM,AddNameToTree)     (HWND hDlg, LPCDUNIT pCDUnit, TCHAR *szName, HTREEITEM hParent, HTREEITEM hInsertAfter, LPCDTITLE pCDTitle, DWORD fdwType, DWORD dwTrack, DWORD dwImage);
    STDMETHOD_(void,AddTracksToTree)        (HWND hDlg, LPCDTITLE pCDTitle, HTREEITEM parent);
    STDMETHOD_(void,UpdateTitleTree)        (HWND hDlg, LPCDDATA pCDData);
    STDMETHOD_(void,UpdateCachedTree)       (HWND hDlg, LPCDDATA pCDData);
    STDMETHOD_(LPCDTITLE,TranslateDirectoryToTitle) (LPWIN32_FIND_DATA lpFileData, LPCDDATA pCDData);
    STDMETHOD_(void,AddTitleByCD)           (HWND hDlg);
    STDMETHOD_(void,ToggleByArtist)         (HWND hDlg, LPCDDATA pCDData);
    STDMETHOD_(BOOL,InitPlayLists)          (HWND hDlg, LPCDDATA pCDData);
    STDMETHOD_(void,DumpMixerTree)          (HWND hDlg);
    STDMETHOD_(void,DumpRecurseTree)        (HWND hTree, HTREEITEM hItem);
    STDMETHOD_(LPCDTREEINFO,NewCDTreeInfo)  (LPCDTITLE pCDTitle, LPCDUNIT pCDUnit, DWORD fdwType, DWORD dwTrack);
    STDMETHOD_(BOOL,PlayListNotify)         (HWND hDlg, LPNMHDR pnmh);
    STDMETHOD_(void,TreeItemMenu)           (HWND hDlg);
    STDMETHOD_(void,ToggleExpand)           (HWND hDlg);
    STDMETHOD_(void,EditTreeItem)           (HWND hDlg);
    STDMETHOD_(void,DeleteTitle)            (HWND hDlg);
    STDMETHOD_(void,RefreshTreeItem)        (HWND hDlg, HTREEITEM hItem);
    STDMETHOD_(HTREEITEM,FindRecurseTree)   (HWND hDlg, HTREEITEM hItem, LPCDTITLE pCDTitle, BOOL fRefresh, DWORD dwTitleID);
    STDMETHOD_(HTREEITEM,FindTitleInDBTree) (HWND hDlg, LPCDTITLE pCDTitle);
    STDMETHOD_(BOOL,DeleteTitleItem)        (HWND hDlg, HTREEITEM hItem);
    STDMETHOD_(void,RefreshTree)            (HWND hDlg, LPCDTITLE pCDTitle, DWORD dwTitleID);
    STDMETHOD_(void,DownloadTitle)          (HWND hDlg);
    STDMETHOD_(void,EditCurrentTitle)       (HWND hDlg);
	STDMETHOD_(void,ArtistNameChange)       (HWND hDlg, HTREEITEM hItem, TCHAR *szName);
    STDMETHOD_(void,NotifyTitleChange)      (LPCDTITLE pCDTitle);
    STDMETHOD_(void,SubClassDlg)            (HWND hDlg);
    STDMETHOD_(void,UnSubClassDlg)          (HWND hDlg);
    STDMETHOD_(void,EndEditReturn)          (HWND hDlg);
    STDMETHOD_(void,SetArtistExpand)        (HWND hDlg, HTREEITEM hItem, BOOL fExpand);
    STDMETHOD_(void,CacheAlbum)             (HWND hDlg);
    STDMETHOD_(void,CacheTrack)             (HWND hDlg, HTREEITEM hTrack = NULL, LPWAVEFORMATEX lpwfx = NULL);
    STDMETHOD_(void,GetTitleDir)            (DWORD dwTitleID, LPTSTR pDirName);
    STDMETHOD_(BOOL,IsTrackCached)          (DWORD dwTitleID, DWORD dwTrack);
    STDMETHOD_(void,RemoveCachedAlbum)      (HWND hDlg);
    STDMETHOD_(void,RemoveCachedTrack)      (HWND hDlg, HTREEITEM hTrack = NULL);

    // dragdrop.cpp

    STDMETHOD_(LRESULT,DragList)            (HWND hLB, UINT uMsg, WPARAM wPara, LPARAM lParam);
    STDMETHOD_(UINT,InitDragMultiList)      (void);
    STDMETHOD_(BOOL,MakeMultiDragList)      (HWND hLB);
    STDMETHOD_(int,LBMultiItemFromPt)       (HWND hLB, POINT pt, BOOL bAutoScroll);
    STDMETHOD_(void,DrawMultiInsert)        (HWND hwndParent, HWND hLB, int nItem);


    // listedit.cpp

    STDMETHOD_(void,AddEditToPlayList)      (HWND hDlg);
    STDMETHOD_(void,TrackEditChange)        (HWND hDlg);
    STDMETHOD_(void,AddTrackToPlayList)     (HWND hDlg, UINT_PTR dwTrack);
    STDMETHOD_(void,ResetPlayList)          (HWND hDlg);
    STDMETHOD_(void,AddToPlayList)          (HWND hDlg);
    STDMETHOD_(BOOL,ListEditor)             (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHOD_(BOOL,DoListCommand)          (HWND hDlg, WPARAM wParam, LPARAM lParam);
    STDMETHOD_(void,CommitTitleChanges)     (HWND hDlg, BOOL fSave);
    STDMETHOD_(BOOL,ListEditDialog)         (HWND hDlg, LPCDTITLE pCDTitle);
    STDMETHOD_(BOOL,InitListEdit)           (HWND hDlg);
    STDMETHOD_(void,RemovePlayListSel)      (HWND hDlg);
    STDMETHOD_(void,UpdateListButtons)      (HWND hDlg);
    STDMETHOD_(void,AvailTracksNotify)      (HWND hDlg, UINT code);
    STDMETHOD_(void,CurrListNotify)         (HWND hDlg, UINT code);
    STDMETHOD_(void,UpdateAvailList)        (HWND hDlg);
    STDMETHOD_(void,UploadTitle)            (HWND hDlg);
    STDMETHOD_(BOOL,ConfirmUpload)          (HWND hDlg);
    STDMETHOD_(BOOL,Upload)                 (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHOD_(BOOL,Confirm)                (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

    STDMETHOD_(void,OnDrawItem)             (HWND hDlg, const DRAWITEMSTRUCT *lpdis);
    STDMETHOD_(void,DrawListItem)           (HWND hDlg, HDC hdc, const RECT *rItem, UINT_PTR itemIndex, BOOL selected);
    STDMETHOD_(BOOL,OnQueryDrop)            (HWND hDlg, HWND hwndDrop, HWND hwndSrc, POINT ptDrop, DWORD dwState);
    STDMETHOD_(BOOL,OnProcessDrop)          (HWND hDlg, HWND hwndDrop, HWND hwndSrc, POINT ptDrop, DWORD dwState);
    STDMETHOD_(int,InsertIndex)             (HWND hDlg, POINT pt, BOOL bDragging); 
    STDMETHOD_(BOOL,IsInListbox)            (HWND hDlg, HWND hwndListbox, POINT pt);
    STDMETHOD_(void,MoveCopySelection)      (HWND hDlg, int iInsertPos, DWORD dwState);
    STDMETHOD_(BOOL,DoDragCommand)          (HWND hDlg, LPDRAGMULTILISTINFO lpns);

    // volopt.cpp
    
    STDMETHOD_(BOOL,MixerConfig)            (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHOD_(MMRESULT,GetDefaultMixID)    (DWORD *pdwMixID);
    STDMETHOD_(void,SearchControls)         (int mxid, LPMIXERLINE pml, LPDWORD pdwVolID, LPDWORD pdwMuteID, TCHAR *szName, BOOL *pfFound, BOOL fVerify);
    STDMETHOD_(void,SearchConnections)      (int mxid, DWORD dwDestination, DWORD dwConnections, LPDWORD pdwVolID, LPDWORD pdwMuteID, TCHAR *szName, BOOL *pfFound, BOOL fVerify);
    STDMETHOD_(BOOL,SearchDevice)           (DWORD dwMixID, LPCDUNIT pCDUnit, LPDWORD pdwVolID, LPDWORD pdwMuteID, TCHAR *szName, BOOL fVerify);
    STDMETHOD_(void,GetUnitDefaults)        (LPCDUNIT pCDUnit);
    STDMETHOD_(BOOL,MapLetterToDevice)      (TCHAR DriveLetter, TCHAR *szDriver, TCHAR *szDevDesc, DWORD dwSize);
    STDMETHOD_(BOOL,TruncName)              (TCHAR *pDest, TCHAR *pSrc);
    STDMETHOD (ComputeMixID)                (LPDWORD pdwMixID, TCHAR *szMixerName);
    STDMETHOD (GetUnitRegData)              (LPCDUNIT pCDUnit);
    STDMETHOD_(void,SetUnitRegData)         (LPCDUNIT pCDUnit);
    STDMETHOD_(void,GetUnitValues)          (LPCDUNIT pCDUnit);
    STDMETHOD_(void,WriteCDList)            (LPCDUNIT pCDList);
    STDMETHOD_(void,DestroyCDList)          (LPCDUNIT *ppCDList);
    STDMETHOD_(UINT,GetDefDrive)            (void);
    STDMETHOD (CreateCDList)                (LPCDUNIT *ppCDList);

    STDMETHOD (BuildUITree)                 (LPCDDRIVE *ppCDRoot, LPCDUNIT pCDList);
    STDMETHOD_(void,DestroyUITree)          (LPCDDRIVE *ppCDRoot);
    STDMETHOD_(void,SetUIDefaults)          (LPCDDRIVE pCDTree, LPCDUNIT pCDList);
    STDMETHOD_(void,RestoreOriginals)       (void);
    STDMETHOD (AddLineControls)             (LPCDMIXER pMixer, LPCDCONTROL *ppLastControl, int mxid, LPMIXERLINE pml);
    STDMETHOD (AddConnections)              (LPCDMIXER pMixer, LPCDCONTROL *ppLastControl, int mxid, DWORD dwDestination, DWORD dwConnections);
    STDMETHOD (AddControls)                 (LPCDMIXER pMixer);
    STDMETHOD (AddMixers)                   (LPCDDRIVE pDevice);
    STDMETHOD_(BOOL,UpdateCDList)           (LPCDDRIVE pCDTree, LPCDUNIT pCDList);
    STDMETHOD_(void,InitControlUI)          (HWND hDlg, LPCDMIXER pMixer);
    STDMETHOD_(void,InitMixerUI)            (HWND hDlg, LPCDDRIVE pDevice);
    STDMETHOD_(void,InitDeviceUI)           (HWND hDlg, LPCDDRIVE pCDTree, LPCDDRIVE pCurrentDevice);
    STDMETHOD_(BOOL,InitMixerConfig)        (HWND hDlg);
    STDMETHOD_(LPCDDRIVE,GetCurrentDevice)  (HWND hDlg);
    STDMETHOD_(LPCDMIXER,GetCurrentMixer)   (HWND hDlg);
    STDMETHOD_(void,ChangeCDDrives)         (HWND hDlg);
    STDMETHOD_(void,ChangeCDMixer)          (HWND hDlg);
    STDMETHOD_(void,ChangeCDControl)        (HWND hDlg);
    STDMETHOD_(void,SetMixerDefaults)       (HWND hDlg);
    STDMETHOD_(BOOL,VolumeDialog)           (HWND hDlg);

};

#endif // !defined(CDOPT_COM_IMPLEMENTATION)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\cddata.h ===
//--------------------------------------------------------------------------;
//
//  File: cddb.h
//
//  CD Database object
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;
#if !defined(CDDATA_COM_IMPLEMENTATION)
#define CDDATA_COM_IMPLEMENTATION

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "cdopt.h"
#include <wininet.h>
#include "sqlobj.h"

/////////////////////////////////////////////////////////////////////////////
// Types

typedef struct CBTABLE
{
    SDWORD  cbTitles[10];
    SDWORD  cbTracks[3];
    SDWORD  cbMenus[4];
    SDWORD  cbBatch[3];

}CBTABLE, *LPCBTABLE;

typedef struct BOUND
{
    HENV        henv;
    HDBC        hdbc;
    CDTITLE     CDTitle;
    CDTRACK     CDTrack;
    CDMENU      CDMenu;
    TCHAR       szPlayList[255];
    TCHAR       szQuery[INTERNET_MAX_PATH_LENGTH];
    DWORD       dwTrackID;
    DWORD       dwMenuID;
    CBTABLE     cbt;

}BOUND, *LPBOUND;




#define NUMTABLES 4


/////////////////////////////////////////////////////////////////////////////
// CCDDB

class CCDData : public ICDData
{
public:
	CCDData();
    ~CCDData();

public:
// IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

// ICDData

    STDMETHOD (Initialize)                  (HWND hWnd);
    STDMETHOD (CheckDatabase)               (HWND hWnd);
    STDMETHOD_(BOOL,QueryTitle)             (DWORD dwTitleID);
    STDMETHOD (LockTitle)                   (LPCDTITLE *ppCDTitle, DWORD dwTitleID);
    STDMETHOD (CreateTitle)                 (LPCDTITLE *ppCDTitle, DWORD dwTitleID, DWORD dwNumTracks, DWORD dwNumMenus);
    STDMETHOD (SetTitleQuery)               (LPCDTITLE pCDTitle, TCHAR *szTitleQuery);
    STDMETHOD (SetMenuQuery)                (LPCDMENU pCDMenu, TCHAR *szMenuQuery);
    STDMETHOD_(void,UnlockTitle)            (LPCDTITLE pCDTitle, BOOL fPresist);
    STDMETHOD (LoadTitles)                  (HWND hWnd);
    STDMETHOD (PersistTitles)               (void);
    STDMETHOD (UnloadTitles)                (void);
    STDMETHOD_(LPCDTITLE,GetTitleList)      (void);

    STDMETHOD_(BOOL,QueryBatch)             (DWORD dwTitleID);
    STDMETHOD_(DWORD,GetNumBatched)         (void);
    STDMETHOD (LoadBatch)                   (HWND hWnd, LPCDBATCH *ppCDBatchList);
    STDMETHOD (UnloadBatch)                 (LPCDBATCH pCDBatchList);
    STDMETHOD (DumpBatch)                   (void);
    STDMETHOD (AddToBatch)                  (DWORD dwTitleID, TCHAR *szTitleQuery, DWORD dwNumTracks);
    STDMETHOD_(DWORD,GetAppDataDir)         (TCHAR* pstrDir, DWORD cchSize);

    STDMETHOD_(void,CreateMeter)            (LPTIMEDMETER ptm, HWND hWnd, DWORD dwCount, DWORD dwJump, UINT uStringID);
    STDMETHOD_(void,UpdateMeter)            (LPTIMEDMETER ptm);
    STDMETHOD_(void,DestroyMeter)           (LPTIMEDMETER ptm);

private:
    DWORD               m_dwRef;
    DWORD               m_dwLoadCnt;
    DWORD               m_dwBatchCnt;
    CRITICAL_SECTION    m_crit;
    HENV                m_henv;
    HDBC                m_hdbc;
    HSTMT               m_hstmt[NUMTABLES];
    BOUND               m_bd;
    LPCDTITLE           m_pTitleList;
    LPCDBATCH           m_pBatchList;
    SQL *               m_pSQL;
    BOOL                m_fToldUser;

    static BOOL CALLBACK MeterHandler       (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

 	STDMETHOD_(void,Enter)				    (void);
	STDMETHOD_(void,Leave)				    (void);
	STDMETHOD (GetSQLPtr)				    (BOOL fInited);

    STDMETHOD (ConnectToDatabase)           (WORD fRequest);
    STDMETHOD_(void,CreateDatabase)         (void);
    STDMETHOD (OpenDatabase)                (BOOL fCreate, HWND hWnd);
    STDMETHOD_(void,CloseDatabase)          (void);

    STDMETHOD_(void,InitCBTable)            (LPBOUND pbd);
    STDMETHOD_(void,SetCursors)             (HSTMT *hstmt);
    STDMETHOD_(void,BindTitles)             (HSTMT *hstmt, LPBOUND pbd);
    STDMETHOD_(void,BindTracks)             (HSTMT *hstmt, LPBOUND pbd);
    STDMETHOD_(void,BindMenus)              (HSTMT *hstmt, LPBOUND pbd);
    STDMETHOD_(void,BindBatch)              (HSTMT *hstmt, LPBOUND pbd);
    STDMETHOD_(void,SetBindings)            (HSTMT *hstmt, LPBOUND pbd);
    STDMETHOD_(RETCODE,AllocStmt)           (HDBC hdbc, HSTMT *hstmt);
    STDMETHOD_(void,FreeStmt)               (HSTMT *hstmt);
    STDMETHOD_(void,ReportError)            (LPBOUND pbd, HSTMT hstmt);

    STDMETHOD (GetUnknownString)            (TCHAR **ppStr, const TCHAR *szSection, const TCHAR *szEntry, DWORD dwInitialAlloc);
    STDMETHOD_(DWORD,ImportCount)           (TCHAR *pEntries);
    STDMETHOD_(void,InitDatabase)           (HSTMT *hstmt);
    STDMETHOD_(void,ImportTrack)            (TCHAR *szDiscID, DWORD dwTrack);
    STDMETHOD_(RETCODE,ImportTracks)        (HSTMT hstmt, TCHAR *szDiscID);
    STDMETHOD (ImportTitle)                 (TCHAR *szDiscID);
    STDMETHOD_(void,ImportDatabase)         (LPTIMEDMETER ptm, HSTMT *hstmt, TCHAR *szDiscID);

    STDMETHOD_(DWORD,GetNumRows)            (UCHAR *szDSN);
    STDMETHOD (ExtractTitle)                (LPCDTITLE *ppCDTitle);
    STDMETHOD (ExtractTitles)               (LPCDTITLE *ppCDTitleList, HWND hWnd);
    STDMETHOD (ExtractSingleTitle)          (LPCDTITLE *ppCDTitle, DWORD dwTitleID);
    STDMETHOD_(BOOL,QueryDatabase)          (DWORD dwTitleID, const TCHAR *szTable);

    STDMETHOD_(void,SaveTitle)              (LPCDTITLE pCDTitle, BOOL fExist);
    STDMETHOD_(void,SaveTracks)             (LPCDTITLE pCDTitle, BOOL fExist);
    STDMETHOD_(void,SaveMenus)              (LPCDTITLE pCDTitle);
	
    STDMETHOD_(LPCDTITLE,FindTitle)         (LPCDTITLE pCDTitle, DWORD dwTitleID);
	STDMETHOD (NewTitle)                    (LPCDTITLE *ppCDTitle, DWORD dwTitleID, DWORD dwNumTracks, DWORD dwNumMenus);
    STDMETHOD_(void,DestroyTitle)           (LPCDTITLE pCDTitle);
    STDMETHOD_(void,DBSaveTitle)            (LPCDTITLE pCDTitle);
    STDMETHOD_(void,DBRemoveTitle)          (LPCDTITLE pCDTitle);
    STDMETHOD_(void,DestroyTitles)          (LPCDTITLE *ppCDTitles);
    STDMETHOD_(void,SaveTitles)             (LPCDTITLE *ppCDTitles);
    STDMETHOD_(void,AddTitle)               (LPCDTITLE *ppCDTitles, LPCDTITLE pCDTitle);
    
    STDMETHOD (ExtractBatch)                (LPCDBATCH *ppCDBatchList, HWND hWnd);
    STDMETHOD_(void,DeleteBatch)            (LPCDBATCH pCDBatch);
    STDMETHOD_(void,DestroyBatch)           (LPCDBATCH *ppCDBatchList);
    STDMETHOD_(BOOL,FindBatchTitle)         (LPCDBATCH pCDBatchList, DWORD dwTitleID);
    STDMETHOD_(void,RemoveFromBatch)		(DWORD dwTitleID);

    STDMETHOD_(BOOL,IsOldFormat)            (void);
    STDMETHOD (UpgradeDatabase)             (HWND hWnd);
};

#endif // !defined(CDDATA_COM_IMPLEMENTATION)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\cdread.h ===
#ifndef _CDREAD_H
#define _CDREAD_H

#include "devioctl.h"
#include "ntddredb.h"
#include "ntddcdrm.h"

#define CDDA_SECTOR_SIZE    ( 2352 )
#define SECTORS_PER_READ   ( 26 )
#define PAGE_VAL 1024*8*8

#ifndef _ALPHA
#define PAGE_SIZE 1024*4
#else
#define PAGE_SIZE 1024*8
#endif

#define MSF_TO_LBA(Minutes,Seconds,Frames) \
                (ULONG)((60 * 75 * (Minutes)) + (75 * (Seconds)) + ((Frames) - 150))


typedef BOOL (*LPREADFUNC)(BYTE* lpData, DWORD dwSize, int iPercent);

BOOL writeHeader( FILE* pFile, int iSize );
BOOL readTOC( HANDLE hDevice, PCDROM_TOC pToc );
BOOL rawReadTrack(HANDLE device, PCDROM_TOC pTOC, int iTrack, LPREADFUNC lpReadFunc );
int getTrackSize( PCDROM_TOC pTOC, int iTrack );
BOOL StoreTrack(HWND hwndMain, TCHAR chDrive, int nTrack, TCHAR* pszFilename, LPWAVEFORMATEX lpwfxDest);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\cdoptimp.cpp ===
/******************************Module*Header*******************************\
* Module Name: cdoptimp.cpp
*
* Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#include "precomp.h"
#include "objbase.h"
#include "cdoptimp.h"
#include "cdopti.h"
#include "cddata.h"

extern HINSTANCE g_dllInst;

/////////////
// Typedefs
/////////////
typedef struct Sheet
{
    INT             iResID;
    DLGPROC         pfnDlgProc;

}SHEET,*LPSHEET;

typedef struct CDReserved
{
    LPCDOPTIONS     pCDOpts;
    BOOL            fChanged;

}CDRESERVED, *LPCDRESERVED;


/////////////
// Defines
/////////////
#define CDKEYSIZE   (20)
#define NUMKEYSRC   (2)
#define NUMPAGES    (3)


//////////										   
// Globals
//////////
TCHAR gszHelpFile[]               = TEXT("deluxcd.hlp");

const TCHAR szCDKeySet[]          = TEXT("MSDELXCD");
const TCHAR szCDPlayerPath[]      = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\DeluxeCD\\Settings");
const TCHAR szCDSysTrayPath[]     = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
const TCHAR szCDSysTray[]         = TEXT("DeluxeCD");
const TCHAR szCDTrayOption[]      = TEXT("-tray");
const TCHAR szCDStartPlay[]       = TEXT("StartPlay");   
const TCHAR szCDExitStop[]        = TEXT("ExitStop");   
const TCHAR szCDDispMode[]        = TEXT("DispMode");   
const TCHAR szCDTopMost[]         = TEXT("TopMost");  
const TCHAR szCDTray[]            = TEXT("Tray");    
const TCHAR szCDPlayMode[]        = TEXT("PlayMode"); 
const TCHAR szCDIntroTime[]       = TEXT("IntroTime"); 
const TCHAR szCDDownloadEnabled[] = TEXT("DownloadEnabled");   
const TCHAR szCDDownloadPrompt[]  = TEXT("DownloadPrompt");   
const TCHAR szCDBatchEnabled[]    = TEXT("BatchEnabled");
const TCHAR szCDByArtist[]        = TEXT("ByArtist");
const TCHAR szCDConfirmUpload[]   = TEXT("ConfirmUpload");
const TCHAR szCDWindowX[]         = TEXT("WindowX");   
const TCHAR szCDWindowY[]         = TEXT("WindowY");   
const TCHAR szCDViewMode[]        = TEXT("ViewMode");   

const TCHAR szCDCurrentProvider[] = TEXT("CurrentProvider");
            
const TCHAR szCDProviderPath[]    = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\DeluxeCD\\Providers\\");
const TCHAR szCDProviderKey[]     = TEXT("Provider");
const TCHAR szCDProviderURL[]     = TEXT("ProviderURL");
const TCHAR szCDProviderName[]    = TEXT("ProviderName");
const TCHAR szCDProviderHome[]    = TEXT("ProviderHome");
const TCHAR szCDProviderLogo[]    = TEXT("ProviderLogo");
const TCHAR szCDProviderUpload[]  = TEXT("ProviderUpload");


////////////
// IUnknown Implementation for CDOpt
////////////


CCDOpt::CCDOpt()
{
    HRESULT hr;

    m_dwRef = 0;
    m_pCDData = NULL;
    m_pCDOpts = new(CDOPTIONS);
    m_hImageList = NULL;
    m_pCDTitle = NULL;
    m_hInst = NULL;
    m_hList = NULL;
    m_uDragListMsg = 0L;
    m_pfnSubProc = NULL;
    m_fEditReturn = FALSE;
    m_fVolChanged = FALSE;
    m_fAlbumsExpanded = FALSE;
    m_fDrivesExpanded = TRUE;
    m_pICDNet = FALSE;
    m_pCDUploadTitle = NULL;
    m_hTitleWnd = NULL;

    if (m_pCDOpts == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        memset(m_pCDOpts,0,sizeof(CDOPTIONS));

        hr = CreateCDList(&(m_pCDOpts->pCDUnitList));

        if (SUCCEEDED(hr))
        {
            m_pCDOpts->pCDData = new(CDOPTDATA);

            if (m_pCDOpts->pCDData == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                memset(m_pCDOpts->pCDData, 0, sizeof(CDOPTDATA));

                hr = GetCDData(m_pCDOpts->pCDData);

                if (SUCCEEDED(hr))
                {
                    hr = GetProviderData(m_pCDOpts);
                }
            }
        }
    }

    if (FAILED(hr))
    {
        DestroyCDOptions();
    }
}


CCDOpt::~CCDOpt()
{
    DestroyCDOptions();
}


STDMETHODIMP CCDOpt::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (IID_IUnknown == riid || IID_ICDOpt == riid)
    {  
        *ppv = this;
    }

    if (NULL==*ppv)
    {
        return E_NOINTERFACE;
    }

    AddRef();

    return S_OK;
}

STDMETHODIMP_(ULONG) CCDOpt::AddRef(void)
{
    return ++m_dwRef;
}

STDMETHODIMP_(ULONG) CCDOpt::Release(void)
{
    if (0!=--m_dwRef)
        return m_dwRef;

    delete this;
    return 0;
}


////////////
// ICDOpt Public Method Implementation
////////////


STDMETHODIMP_(LPCDOPTIONS) CCDOpt::GetCDOpts(void)
{
    return(m_pCDOpts);
}


STDMETHODIMP_(void) CCDOpt::OrderProviders(LPCDPROVIDER *ppProviderList, LPCDPROVIDER pCurrentProvider)
{
    if (ppProviderList && *ppProviderList && pCurrentProvider)
    {
        LPCDPROVIDER pProvider;
        LPCDPROVIDER pLast = NULL;
        pProvider = *ppProviderList;

        while (pProvider)
        {
            if (pProvider == pCurrentProvider)
            {
                if (pLast != NULL)      // if current is not already head of list
                {
                    pLast->pNext = pProvider->pNext;                // Current is now removed from the list
                    pProvider->pNext = *ppProviderList;             // Have current point to head of list
                    *ppProviderList = pProvider;                    // Current is now head of list
                }

                break;
            }

            pLast = pProvider;
            pProvider = pProvider->pNext;
        }
    }
}

STDMETHODIMP CCDOpt::CreateProviderList(LPCDPROVIDER *ppProviderList)
{
    HRESULT hr = S_OK;

    if (ppProviderList)
    {
        LPCDPROVIDER pProvider = m_pCDOpts->pProviderList;
        LPCDPROVIDER pCurrentProvider = NULL;
        LPCDPROVIDER pNewProvider = NULL;
        LPCDPROVIDER pLast = NULL;

        while (pProvider)
        {
            pNewProvider = (LPCDPROVIDER) new(CDPROVIDER);
            
            if (pNewProvider == NULL)
            {
                hr = E_FAIL;
                break;
            }
            
            memcpy(pNewProvider, pProvider, sizeof(CDPROVIDER));
            pNewProvider->pNext = NULL;

            if (pLast)
            {
                pLast->pNext = pNewProvider;
            }
            else
            {
                *ppProviderList = pNewProvider;
            }
            
            if (pProvider == m_pCDOpts->pCurrentProvider)
            {
                pCurrentProvider = pNewProvider;
            }
                               
            pLast = pNewProvider;
            pProvider = pProvider->pNext;
        }

        if (SUCCEEDED(hr))
        {
            OrderProviders(ppProviderList, pCurrentProvider);
        }
        else
        {
            DestroyProviderList(ppProviderList);
        }
    }

    return(hr);
}

STDMETHODIMP_(void) CCDOpt::DestroyProviderList(LPCDPROVIDER *ppProviderList)
{
    if (ppProviderList)
    {
        while (*ppProviderList)
        {
            LPCDPROVIDER pTemp = *ppProviderList;
            *ppProviderList = (*ppProviderList)->pNext;
            delete pTemp;
        }
    }
}


STDMETHODIMP_(void) CCDOpt::UpdateRegistry(void)
{
    if (m_pCDOpts && m_pCDOpts->pCDData)
    {
        SetCDData(m_pCDOpts->pCDData);
    }
}


STDMETHODIMP CCDOpt::OptionsDialog(HWND hWnd, LPCDDATA pCDData, CDOPT_PAGE nStartPage)
{
    HRESULT hr = S_OK;
    PROPSHEETHEADER psh;
    PROPSHEETPAGE psp[NUMPAGES];
    int page;
    int pages;
    TCHAR str[MAX_PATH];

    if (m_pCDOpts == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LPCDOPTIONS pCDCopy = NULL;
        CDRESERVED  cdReserved;

        cdReserved.pCDOpts = m_pCDOpts;
        cdReserved.fChanged = FALSE;

        m_pCDOpts->pReserved = (UINT_PTR)&cdReserved;

        if (pCDData && SUCCEEDED(pCDData->CheckDatabase(hWnd)))
        {
            m_pCDData = pCDData;
            m_pCDData->AddRef();
        }


        hr = CopyOptions();

        if (SUCCEEDED(hr))
        {
            pages = NUMPAGES;

            if (m_pCDData == NULL)
            {
                nStartPage = CDOPT_PAGE_PLAY;
                pages = 1;
            }

            for (page = 0; page < pages; page++)
            {
                memset(&psp[page],0,sizeof(PROPSHEETPAGE));
                psp[page].dwSize = sizeof(PROPSHEETPAGE);
                psp[page].dwFlags = PSP_DEFAULT;
                psp[page].hInstance = g_dllInst;
                psp[page].lParam = (LPARAM) this;

                switch (page)
                {
                    case 0:
                        psp[page].pszTemplate = MAKEINTRESOURCE(IDD_CDPLAYEROPTIONS);
                        psp[page].pfnDlgProc = (DLGPROC) CCDOpt::PlayerOptionsProc;
                    break;

                    case 1:
                        psp[page].pszTemplate = MAKEINTRESOURCE(IDD_CDTITLEOPTIONS);
                        psp[page].pfnDlgProc = (DLGPROC) CCDOpt::TitleOptionsProc;
                    break;

                    case 2:
                        psp[page].pszTemplate = MAKEINTRESOURCE(IDD_CDPLAYLISTS);
                        psp[page].pfnDlgProc = (DLGPROC) CCDOpt::PlayListsProc;
                    break;
                }
            }

            LoadString( g_dllInst, IDS_CDOPTIONS, str, sizeof( str )/sizeof(TCHAR) );

            memset(&psh,0,sizeof(psh));
            psh.dwSize = sizeof(psh);
            psh.dwFlags = PSH_DEFAULT | PSH_PROPSHEETPAGE; 
            psh.hwndParent = hWnd;
            psh.hInstance = g_dllInst;
            psh.pszCaption = str;
            psh.nPages = pages;
            psh.nStartPage = nStartPage;
            psh.ppsp = psp;

            m_hInst = g_dllInst;

            if (PropertySheet(&psh) == -1)
            {
                hr = E_FAIL;            // Big problem.
            }

            DumpOptionsCopy();

            if (SUCCEEDED(hr))
            {
                if (!cdReserved.fChanged)
                {
                    hr = S_FALSE;       // No changes
                }
                else
                {
                    hr = S_OK;          // There have been changes
                }
            }
        }

        if (m_pCDData)
        {
            m_pCDData->Release();
            m_pCDData = NULL;
        }
    }

    return(hr);
}

STDMETHODIMP_(void) CCDOpt::DestroyCDOptions(void)
{
    if (m_pCDOpts)
    {
        if (m_pCDOpts->pCDData)
        {
            delete m_pCDOpts->pCDData;
        }

        if (m_pCDOpts->pProviderList)
        {
            DestroyProviderList(&(m_pCDOpts->pProviderList));
        }

        if (m_pCDOpts->pCDUnitList)
        {
            DestroyCDList(&(m_pCDOpts->pCDUnitList));
        }

        delete m_pCDOpts;
    }
}


STDMETHODIMP_(void) CCDOpt::RegGetByte(HKEY hKey, const TCHAR *szKey, LPBYTE pByte, BYTE bDefault)
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwByte;

    if (RegQueryValueEx(hKey, szKey, NULL, NULL, (LPBYTE) &dwByte, &dwSize) != NO_ERROR)
    {
        *pByte = bDefault;   
    }
    else
    {
        *pByte = (BYTE) dwByte;
    }
}


STDMETHODIMP_(void) CCDOpt::RegGetDWORD(HKEY hKey, const TCHAR *szKey, LPDWORD pdwData, DWORD dwDefault)
{
    DWORD dwSize = sizeof(DWORD);

    if (RegQueryValueEx(hKey, szKey, NULL, NULL, (LPBYTE) pdwData, &dwSize) != NO_ERROR)
    {
        *pdwData = dwDefault;   
    }
}


STDMETHODIMP_(void) CCDOpt::RegSetByte(HKEY hKey, const TCHAR *szKey, BYTE bData)
{
    DWORD dwData = (DWORD) bData;

    RegSetValueEx( hKey, (LPTSTR) szKey, 0, REG_DWORD, (LPBYTE) &dwData, sizeof(DWORD) );
}


STDMETHODIMP_(void) CCDOpt::RegSetDWORD(HKEY hKey, const TCHAR *szKey, DWORD dwData)
{
    RegSetValueEx( hKey, (LPTSTR) szKey, 0, REG_DWORD,(LPBYTE) &dwData, sizeof(DWORD) );
}


STDMETHODIMP_(BOOL) CCDOpt::GetUploadPrompt(void)
{
    HKEY        hKey;
    BOOL fConfirm = CDDEFAULT_CONFIRMUPLOAD;

    if (RegOpenKeyEx(HKEY_CURRENT_USER , szCDPlayerPath , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
    {
        RegGetByte(hKey,     szCDConfirmUpload,  (LPBYTE) &fConfirm,      CDDEFAULT_CONFIRMUPLOAD);
        RegCloseKey(hKey);
    }

    return fConfirm;
}


STDMETHODIMP_(void) CCDOpt::SetUploadPrompt(BOOL fConfirmUpload)
{
    HKEY        hKey;

    if (RegCreateKeyEx( HKEY_CURRENT_USER, (LPTSTR)szCDPlayerPath, 0, NULL, 0,KEY_WRITE | KEY_READ, NULL, &hKey, NULL ) == ERROR_SUCCESS)
    {            
        RegSetByte(hKey,     szCDConfirmUpload,  (BYTE) fConfirmUpload);
        RegCloseKey(hKey);
    }
}


STDMETHODIMP CCDOpt::GetCDData(LPCDOPTDATA pCDData)
{
    HRESULT     hr = S_OK;
    HKEY        hKey;

    if (pCDData)
    {
        if (RegOpenKeyEx(HKEY_CURRENT_USER , szCDPlayerPath , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
        {
            DWORD dwSize = sizeof(BOOL);
            
            RegGetByte(hKey,     szCDStartPlay,      (LPBYTE) &pCDData->fStartPlay,          CDDEFAULT_START);
            RegGetByte(hKey,     szCDExitStop,       (LPBYTE) &pCDData->fExitStop,           CDDEFAULT_EXIT);
            RegGetByte(hKey,     szCDDispMode,       (LPBYTE) &pCDData->fDispMode,           CDDEFAULT_DISP);
            RegGetByte(hKey,     szCDTopMost,        (LPBYTE) &pCDData->fTopMost,            CDDEFAULT_TOP);
            RegGetByte(hKey,     szCDTray,           (LPBYTE) &pCDData->fTrayEnabled,        CDDEFAULT_TRAY);
            RegGetDWORD(hKey,    szCDIntroTime,      (LPDWORD) &pCDData->dwIntroTime,        CDDEFAULT_INTRO);
            RegGetDWORD(hKey,    szCDPlayMode,       (LPDWORD) &pCDData->dwPlayMode,         CDDEFAULT_PLAY);
            RegGetByte(hKey,     szCDDownloadEnabled,(LPBYTE) &pCDData->fDownloadEnabled,    CDDEFAULT_DOWNLOADENABLED);
            RegGetByte(hKey,     szCDDownloadPrompt, (LPBYTE) &pCDData->fDownloadPrompt,     CDDEFAULT_DOWNLOADPROMPT);
            RegGetByte(hKey,     szCDBatchEnabled,   (LPBYTE) &pCDData->fBatchEnabled,       CDDEFAULT_BATCHENABLED);
            RegGetByte(hKey,     szCDByArtist,       (LPBYTE) &pCDData->fByArtist,           CDDEFAULT_BYARTIST);
            RegGetDWORD(hKey,    szCDWindowX,        (LPDWORD) &pCDData->dwWindowX,          CW_USEDEFAULT);
            RegGetDWORD(hKey,    szCDWindowY,        (LPDWORD) &pCDData->dwWindowY,          CW_USEDEFAULT);
            RegGetDWORD(hKey,    szCDViewMode,       (LPDWORD) &pCDData->dwViewMode,         0);

            RegCloseKey(hKey);
        }
        else     // Just use the defaults
        {
            pCDData->fStartPlay         = CDDEFAULT_START;   
            pCDData->fExitStop          = CDDEFAULT_EXIT;   
            pCDData->fDispMode          = CDDEFAULT_DISP;   
            pCDData->fTopMost           = CDDEFAULT_TOP;   
            pCDData->fTrayEnabled       = CDDEFAULT_TRAY;   
            pCDData->dwIntroTime        = CDDEFAULT_INTRO; 
            pCDData->dwPlayMode         = CDDEFAULT_PLAY; 
            pCDData->fDownloadEnabled   = CDDEFAULT_DOWNLOADENABLED;   
            pCDData->fDownloadPrompt    = CDDEFAULT_DOWNLOADPROMPT;   
            pCDData->fBatchEnabled      = CDDEFAULT_BATCHENABLED;            
            pCDData->fByArtist          = CDDEFAULT_BYARTIST;            
            pCDData->dwWindowX          = CW_USEDEFAULT ;            
            pCDData->dwWindowY          = CW_USEDEFAULT ;            
            pCDData->dwViewMode         = 0;            
        }
    }

    return(hr);
}


STDMETHODIMP CCDOpt::SetCDData(LPCDOPTDATA pCDData)
{
    HRESULT     hr = E_FAIL;
    HKEY        hKey;

    if (pCDData)
    {
        if (RegCreateKeyEx( HKEY_CURRENT_USER, (LPTSTR)szCDPlayerPath, 0, NULL, 0,KEY_WRITE | KEY_READ, NULL, &hKey, NULL ) == ERROR_SUCCESS)
        {
            DWORD dwSize = sizeof(BOOL);
            
            hr = S_OK;

            RegSetByte(hKey,     szCDStartPlay,      (BYTE) pCDData->fStartPlay);
            RegSetByte(hKey,     szCDExitStop,       (BYTE) pCDData->fExitStop);
            RegSetByte(hKey,     szCDDispMode,       (BYTE) pCDData->fDispMode);
            RegSetByte(hKey,     szCDTopMost,        (BYTE) pCDData->fTopMost);
            RegSetByte(hKey,     szCDTray,           (BYTE) pCDData->fTrayEnabled);
            RegSetDWORD(hKey,    szCDIntroTime,      (DWORD) pCDData->dwIntroTime);
            RegSetDWORD(hKey,    szCDPlayMode,       (DWORD) pCDData->dwPlayMode);
            RegSetByte(hKey,     szCDDownloadEnabled,(BYTE) pCDData->fDownloadEnabled);
            RegSetByte(hKey,     szCDDownloadPrompt, (BYTE) pCDData->fDownloadPrompt);
            RegSetByte(hKey,     szCDBatchEnabled,   (BYTE) pCDData->fBatchEnabled);
            RegSetByte(hKey,     szCDByArtist,       (BYTE) pCDData->fByArtist);
            RegSetDWORD(hKey,    szCDWindowX,        (DWORD) pCDData->dwWindowX);
            RegSetDWORD(hKey,    szCDWindowY,        (DWORD) pCDData->dwWindowY);
            RegSetDWORD(hKey,    szCDViewMode,       (DWORD) pCDData->dwViewMode);
           
            RegCloseKey(hKey);

            if (RegCreateKeyEx( HKEY_LOCAL_MACHINE, (LPTSTR)szCDSysTrayPath, 0, NULL, 0,KEY_WRITE | KEY_READ, NULL, &hKey, NULL ) == ERROR_SUCCESS)
            {
                TCHAR szPath[MAX_PATH];
                TCHAR szCommand[MAX_PATH + 5];

                if (pCDData->fTrayEnabled)
                {
                    GetModuleFileName(NULL, szPath, sizeof(szPath)/sizeof(TCHAR));
                    wsprintf(szCommand, TEXT("%s %s"), szPath, szCDTrayOption);
                    RegSetValueEx( hKey, (LPTSTR) szCDSysTray, 0, REG_SZ,(LPBYTE) szCommand, (wcslen(szCommand)*sizeof(TCHAR))+sizeof(TCHAR));
                }
                else
                {
                    RegDeleteValue( hKey, (LPTSTR) szCDSysTray);
                }

                RegCloseKey(hKey);
            }
        }
    }

    return(hr);
}



STDMETHODIMP_(void) CCDOpt::GetCurrentProviderURL(TCHAR *szProviderURL)
{
    HKEY hKey;

    if (szProviderURL)
    {
        if (RegOpenKeyEx(HKEY_CURRENT_USER , szCDPlayerPath , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
        {
            DWORD dwSize = MAX_PATH;
            
            RegQueryValueEx(hKey, szCDCurrentProvider, NULL, NULL, (LPBYTE) szProviderURL, &dwSize);

            RegCloseKey(hKey);
        }
    }
}



STDMETHODIMP CCDOpt::GetProviderData(LPCDOPTIONS pCDOpts)
{
    HRESULT         hr = S_OK;
    DWORD           dwCount = 0;
    TCHAR           szPath[MAX_PATH];
    BOOL            done = FALSE;
    LPCDPROVIDER    pProvider;
    LPCDPROVIDER    *ppLast;
    HKEY            hKey;
    TCHAR           szProviderURL[MAX_PATH];

    if (pCDOpts)
    {
        szProviderURL[0] = TEXT('\0');

        GetCurrentProviderURL(szProviderURL);

        ppLast = &(pCDOpts->pProviderList);

        while (!done)
        {
            wsprintf(szPath,TEXT("%s%s%04d"), szCDProviderPath, szCDProviderKey, dwCount);

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE , szPath , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
            {
                BOOL fGotIt = FALSE;

                pProvider = new (CDPROVIDER);
            
                if (pProvider == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    done = TRUE;
                }   
                else
                {
                    memset(pProvider, 0, sizeof(CDPROVIDER));

                    DWORD cbSize = sizeof(pProvider->szProviderURL);
        
                    if (RegQueryValueEx(hKey, szCDProviderURL, NULL, NULL, (LPBYTE) pProvider->szProviderURL, &cbSize) == NO_ERROR)
                    {
                        cbSize = sizeof(pProvider->szProviderName);

                        if (RegQueryValueEx(hKey, szCDProviderName, NULL, NULL, (LPBYTE) pProvider->szProviderName, &cbSize) == NO_ERROR)
                        {
                            cbSize = sizeof(pProvider->szProviderHome);

                            if (RegQueryValueEx(hKey, szCDProviderHome, NULL, NULL, (LPBYTE) pProvider->szProviderHome, &cbSize) == NO_ERROR)
                            {
                                TCHAR szTempLogo[MAX_PATH];
                                cbSize = sizeof(szTempLogo);

                                if (RegQueryValueEx(hKey, szCDProviderLogo, NULL, NULL, (LPBYTE) szTempLogo, &cbSize) == NO_ERROR)
                                {
                                    ExpandEnvironmentStrings(szTempLogo,pProvider->szProviderLogo,sizeof(pProvider->szProviderLogo)/sizeof(TCHAR));

                                    cbSize = sizeof(pProvider->szProviderUpload);
                                    RegQueryValueEx(hKey, szCDProviderUpload, NULL, NULL, (LPBYTE) pProvider->szProviderUpload, &cbSize);

                                    *ppLast = pProvider;
                                    ppLast = &(pProvider)->pNext;
                                    fGotIt = TRUE;

                                    if (pCDOpts->pDefaultProvider == NULL)
                                    {
                                        pCDOpts->pDefaultProvider = pProvider;
                                        pCDOpts->pCurrentProvider = pProvider;
                                    }

                                    if (!lstrcmp(szProviderURL, pProvider->szProviderURL))
                                    {
                                        pCDOpts->pCurrentProvider = pProvider;
                                    }

                                    #ifdef DEBUG

                                    char szCert[255];
    
                                    CreateProviderKey(pProvider, szCert, sizeof(szCert));

                                    char szOut[255];

                                    wsprintf(szOut,"%s = %s, Verify = %d\n", pProvider->szProviderName, szCert, VerifyProvider(pProvider, szCert));
                                    OutputDebugString(szOut);

                                    #endif
                                }
                            }
                        }
                    }

                    if (!fGotIt)
                    {
                        delete pProvider;
                        pProvider = NULL;
                    }
                }

                RegCloseKey(hKey);

                dwCount++;
            }
            else
            {
                done = TRUE;
            }
        }
    }

    return(hr);
}


STDMETHODIMP CCDOpt::SetProviderData(LPCDOPTIONS pCDOpts)
{
    HRESULT         hr = S_OK;
    DWORD           dwCount = 0;
    BOOL            done = FALSE;
    LPCDPROVIDER    pProvider;
    HKEY            hKey;

    pProvider = pCDOpts->pCurrentProvider;

    if (pProvider)
    {
        if (RegCreateKeyEx( HKEY_CURRENT_USER, (LPTSTR)szCDPlayerPath, 0, NULL, 0,KEY_WRITE | KEY_READ, NULL, &hKey, NULL ) == ERROR_SUCCESS)
        {
            RegSetValueEx( hKey, (LPTSTR) szCDCurrentProvider, 0, REG_SZ, (LPBYTE) pProvider->szProviderURL, (lstrlen(pProvider->szProviderURL)*sizeof(TCHAR))+sizeof(TCHAR));
            
            RegCloseKey(hKey);
        }
    }

    return(hr);
}




STDMETHODIMP_(void) CCDOpt::DumpOptionsCopy(void)
{ 
    if (m_pCDCopy)
    {
        if (m_pCDCopy->pCDData)
        {
            delete m_pCDCopy->pCDData;
        }

        delete m_pCDCopy;

        m_pCDCopy = NULL;
    }
}



STDMETHODIMP CCDOpt::CopyOptions(void)
{
    HRESULT hr = S_OK;

    if (m_pCDOpts)
    {
        m_pCDCopy = (LPCDOPTIONS) new(CDOPTIONS);   
  
        if (m_pCDCopy == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memcpy(m_pCDCopy, m_pCDOpts, sizeof(CDOPTIONS));

            m_pCDCopy->pCDData = new (CDOPTDATA);

            if (m_pCDCopy->pCDData == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                memcpy(m_pCDCopy->pCDData, m_pCDOpts->pCDData, sizeof(CDOPTDATA));
            }
        }
    }

    if (FAILED(hr))
    {
        DumpOptionsCopy();
    }

    return(hr);
}




STDMETHODIMP_(BOOL) CCDOpt::OptionsChanged(LPCDOPTIONS pCDOpts)
{
    BOOL fChanged = FALSE;

    if (pCDOpts)
    {
        LPCDRESERVED pCDReserved =  (LPCDRESERVED) pCDOpts->pReserved;
        LPCDOPTIONS pCDOriginal =   pCDReserved->pCDOpts;

        fChanged = m_fVolChanged;

        if (!fChanged)
        {
            if (memcmp(pCDOpts->pCDData,pCDOriginal->pCDData,sizeof(CDOPTDATA)))
            {
                fChanged = TRUE;
            }
            else if (pCDOpts->pCurrentProvider != pCDOriginal->pCurrentProvider)
            {
                fChanged = TRUE;
            }
            else if (m_pCDData)
            {
                LPCDTITLE pCDTitle = m_pCDData->GetTitleList();

                while (pCDTitle)
                {
                    if (pCDTitle->fChanged || pCDTitle->fRemove)
                    {
                        fChanged = TRUE;
                        break;
                    }

                    pCDTitle = pCDTitle->pNext;
                }
            }
        }
    }

    return(fChanged);
}


STDMETHODIMP_(void) CCDOpt::ApplyCurrentSettings(void)
{

    if (m_pCDCopy)
    {
        if (OptionsChanged(m_pCDCopy))
        {
            LPCDRESERVED pCDReserved =  (LPCDRESERVED) m_pCDCopy->pReserved;

            pCDReserved->fChanged = TRUE;

            memcpy(m_pCDOpts->pCDData, m_pCDCopy->pCDData, sizeof(CDOPTDATA));
            m_pCDOpts->pCurrentProvider = m_pCDCopy->pCurrentProvider;

            SetCDData(m_pCDCopy->pCDData);
            SetProviderData(m_pCDCopy);

            if (m_pCDData)
            {
                m_pCDData->PersistTitles();
            }

            if (m_pCDCopy->pfnOptionsCallback)
            {
                m_pCDCopy->pfnOptionsCallback(m_pCDCopy);
            }
        }
    }
}


STDMETHODIMP_(void) CCDOpt::ToggleApplyButton(HWND hDlg)
{
    HWND hwndSheet;

    if (m_pCDCopy)
    {
        hwndSheet = GetParent(hDlg);

        if (OptionsChanged(m_pCDCopy))
        {
            PropSheet_Changed(hwndSheet,hDlg);
        }
        else
        {
            PropSheet_UnChanged(hwndSheet,hDlg);
        }
    }
}



STDMETHODIMP CCDOpt::AcquireKey(LPCDKEY pCDKey, char *szName)
{
    HRESULT hr = E_FAIL;
    DWORD dwLength = strlen(szName);

    pCDKey->hProv = NULL;

    if(!CryptAcquireContext(&(pCDKey->hProv), szCDKeySet, NULL, PROV_RSA_FULL, 0 )) 
    {
        hr = GetLastError();

        if (hr == NTE_BAD_KEYSET)
        {
            if(CryptAcquireContext(&(pCDKey->hProv), szCDKeySet, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET )) 
            {
                hr = S_OK;
            }
            else
            {
                hr = GetLastError();
            }
        }
    }

    if(pCDKey->hProv) 
    {
        if(CryptCreateHash(pCDKey->hProv, CALG_MD5, 0, 0, &(pCDKey->hHash))) 
        {
            if(CryptHashData(pCDKey->hHash, (BYTE *)szName, dwLength, 0)) 
            {
                if(CryptDeriveKey(pCDKey->hProv, CALG_RC2, pCDKey->hHash, CRYPT_EXPORTABLE, &(pCDKey->hKey))) 
                {
                    hr = S_OK;
                }
            }
        }
    }

    if (FAILED(hr))
    {
        hr = GetLastError();
    }

    return(hr);
}

STDMETHODIMP_(void) CCDOpt::ReleaseKey(LPCDKEY pCDKey)
{
    if(pCDKey->hHash)
    { 
        CryptDestroyHash(pCDKey->hHash);
        pCDKey->hHash = 0;
    }

    if(pCDKey->hKey) 
    {
        CryptDestroyKey(pCDKey->hKey); 
        pCDKey->hKey = 0;
    }

    if(pCDKey->hProv)
    {   
        CryptReleaseContext(pCDKey->hProv, 0);
        pCDKey->hProv = 0;
    }
}


// This function takes a certification key, decrypts it and determines it's validity
//
// It first converts the returned data from it's re-able numeric text version, into
// it's raw encrypted data format.
//
// It then generates the data key using the current provider data, as was done when the key
// was generated
//
// It then decrypts the encrypted data and compares it to the data key, if they match, great
// if not, then this provider is not certified and was attempting to mess with us.

STDMETHODIMP_(BOOL) CCDOpt::VerifyProvider(LPCDPROVIDER pCDProvider, TCHAR *szCertKey)
{
    BOOL fCertified = FALSE;
    CDKEY cdKey;
    char  szKey[CDKEYSIZE * 2]; //note: crypto doesn't know unicode, we'll do the conversion later
    TCHAR szMatch[CDKEYSIZE];
    DWORD dwSize;
    TCHAR *szSrc;
    TCHAR szHex[3];
    LPBYTE pData;
    HRESULT hr;

    szSrc = szCertKey;
    dwSize = lstrlen(szCertKey);
    szHex[2] = TEXT('\0');
    pData = (LPBYTE) szKey;

    for (DWORD dwPos = 0; dwPos < dwSize; dwPos += 2)
    {
        szHex[0] = szSrc[0];
        szHex[1] = szSrc[1];
        szSrc += 2;
        _stscanf(szHex,TEXT("%xd"),pData);
        pData++;
    }

    dwSize = dwSize >> 1;

    memset(&cdKey,0,sizeof(cdKey));

    if (SUCCEEDED(CreateCertString(pCDProvider, szMatch)))
    {
        char chKeyName[MAX_PATH];
        #ifdef UNICODE
        WideCharToMultiByte(CP_ACP, 0, pCDProvider->szProviderName, 
									    -1, chKeyName, MAX_PATH, NULL, NULL); 
        #else
        strcpy(chKeyName,pCDProvider->szProviderName);
        #endif

        hr = AcquireKey(&cdKey, chKeyName);

        if (SUCCEEDED(hr))
        {         
            if (CryptDecrypt(cdKey.hKey, 0, TRUE, 0, (BYTE *) szKey, &dwSize))
            {
                szKey[dwSize] = TEXT('\0');

                //convert key back to unicode for string comparison
                #ifdef UNICODE
			    wchar_t wszKey[CDKEYSIZE*2];
			    MultiByteToWideChar( CP_ACP, 0, szKey, -1, wszKey, sizeof(wszKey) / sizeof(wchar_t) );
                #else
                char wszKey[CDKEYSIZE*2];
                strcpy(wszKey,szKey);
                #endif

                if (lstrcmp(szMatch, wszKey) == 0)
                {
                    fCertified = TRUE;
                }
            }
            else
            {
                hr = GetLastError();

                if (hr == NTE_PERM)
                {
                    //succeed in the case where crypto fails due to import restrictions (i.e. France)
                    fCertified = TRUE;
                }
            } 

            ReleaseKey(&cdKey);
        }
    }

    return fCertified;
}


// This function creates a string to be encrypted based on data in the provider header
//
// It takes the provider name and the provider URL and strips out any spaces and punctuation
// Of the data that remains, it only uses every other character. It fills out the key
// to exactly CDKEYSIZE characters, when it's full it stops, if it runs out of input
// characters from the header, it simply wraps back to the begining of the input data until full.
// Also, the output characters are stored in reverse order than they are found and every other
// character is capitalized, while all others are lowercased.
// This generates a key that is encrypted using crypto.  
//
// During runtime in the shipped product, the key passed down to us is decrypted, this key is
// re-generated from the provider and the strings must match, if not, well, then it's not certified.
//
STDMETHODIMP CCDOpt::CreateCertString(LPCDPROVIDER pCDProvider, TCHAR *szCertStr)
{
    HRESULT hr = S_OK;
    TCHAR *pDest = szCertStr + (CDKEYSIZE - 2);
    TCHAR *pSrc = NULL;
    TCHAR *pSrcPtrs[NUMKEYSRC];
    DWORD count = 0;
    DWORD dwSrc = 0;

    pSrcPtrs[0] = pCDProvider->szProviderName;
    pSrcPtrs[1] = pCDProvider->szProviderURL;

    pSrc = pSrcPtrs[dwSrc];

    while(count < (DWORD)(CDKEYSIZE - 1))
    {
        while(*pSrc && (_istspace(*pSrc) || _istpunct(*pSrc)))
        {
            pSrc++;
        }

        if (*pSrc == TEXT('\0'))
        {
            dwSrc = (dwSrc + 1) % NUMKEYSRC;

            if (dwSrc == 0 && count == 0)
            {
                hr = E_INVALIDARG;
                break;
            }

            pSrc = pSrcPtrs[dwSrc];
        }
        else
        {
            *pDest = *pSrc++;

            if (*pSrc != TEXT('\0'))
            {
                pSrc++;
            }

            if (count & 1)
            {
                *pDest = _totlower(*pDest);
            }
            else
            {
                *pDest = _totupper(*pDest);
            }

            *pDest--;
            count++;
        }
    }

    if (SUCCEEDED(hr))
    {
        szCertStr[CDKEYSIZE - 1] = TEXT('\0');
    }

    return(hr);
}


// This function will generate an Certification string using the provider information, 
//
// this function only operates in a build that has DEBUG defined, in the shipping version this
// function will return E_NOTIMPL.
//
// First, using the provider data, a data key is generated of a precise size.  This key is then 
// encrypted.  The raw encrypted data is then converted to a readable numeric text format and
// returned as the certification key for this provider
//
// This certification key will be provided to the provided who will download it upon request to
// allow us to verify that they are indeed a licensed cd data provider.
//
// This key does NOT expire, it's mainly here to prevent unlicensed data providers from hooking
// into this product.

STDMETHODIMP CCDOpt::CreateProviderKey(LPCDPROVIDER pCDProvider, TCHAR *szCertKey, UINT cBytes)
{
    HRESULT hr = E_NOTIMPL;

#ifdef DEBUG

    hr = S_OK;

    if (cBytes < 128 || pCDProvider == NULL || szCertKey == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        TCHAR szKey[CDKEYSIZE * 2];

        if (SUCCEEDED(CreateCertString(pCDProvider, szKey)))
        {
            CDKEY cdKey;

            memset(&cdKey,0,sizeof(cdKey));

            hr = AcquireKey(&cdKey, pCDProvider->szProviderName);

            if (SUCCEEDED(hr))
            {
                DWORD dwSize = lstrlen(szKey); 

                if (CryptEncrypt(cdKey.hKey, 0, TRUE, 0, (BYTE *) szKey, &dwSize, CDKEYSIZE * 2))
                {
                    LPBYTE pData = (LPBYTE) szKey;
                    TCHAR *szDest = szCertKey;

                    for (DWORD dwPos = 0; dwPos < dwSize; dwPos++, szDest += 2, pData++)
                    {
                        wsprintf(szDest, TEXT("%02x"), (UINT) *pData);      
                    }

                    hr = S_OK;
                }
                else
                {
                    hr = GetLastError();
                } 

                ReleaseKey(&cdKey);
            }
        }
    }

#endif // DEBUG

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\cddata.cpp ===
//--------------------------------------------------------------------------;
//
//  File: cddb.cpp
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;

#include "precomp.h"  
#include "cdopti.h"
#include "cddata.h"

#define SECTION_BUFFER      (512)
#define PLAYLIST_BUFFER     (255)
#define BUFFERINC   (128)

#define MAXNUMPLAY (127)
#define ROWSET  1

#ifndef SQL_SUCCEEDED
#define SQL_SUCCEEDED(rc) (((rc)&(~1))==0)
#endif

#ifndef SQL_W_CHAR
#define SQL_C_WCHAR		 	(-8)
#endif

#ifndef SQL_LONGCHAR_FIELD
#define SQL_LONGCHAR_FIELD (-10)
#endif

const TCHAR     gszIniFile[]     = TEXT("cdplayer.ini");
const TCHAR     gszDefault[]     = TEXT("\0");
const TCHAR     gszArtist[]      = TEXT("artist");
const TCHAR     gszTitle[]       = TEXT("title");
const TCHAR     gszNumTracks[]   = TEXT("numtracks");
const TCHAR     gszOrder[]       = TEXT("order");
const TCHAR     gszNumPlay[]     = TEXT("numplay");

const TCHAR     gszDriverName[]  = TEXT("Microsoft Access Driver (*.mdb)");
const TCHAR     gszDSNAttr[]     = TEXT("DSN=DeluxeCD%cDefaultDir=%s%cDriverID=25%cDBQ=DeluxeCD.mdb%c");
const TCHAR     gszDSNCreate[]   = TEXT("CREATE_DB=%s\\DeluxeCD.mdb%c");

const TCHAR     gszTitleTable[]  = TEXT("Titles");
const TCHAR     gszTrackTable[]  = TEXT("Tracks");
const TCHAR     gszMenuTable[]   = TEXT("Menus");
const TCHAR     gszBatchTable[]  = TEXT("Batch");

TCHAR         gszDSN[]         = TEXT("DeluxeCD");

TCHAR         gszTitlesCreate[] = TEXT("create table Titles ")
                                       TEXT("(")
                                            TEXT("TitleID long, ")
                                            TEXT("Artist longchar, ")
                                            TEXT("Title longchar, ")
                                            TEXT("Copyright longchar, ")
                                            TEXT("Label longchar, ")
                                            TEXT("ReleaseDate longchar, ")
                                            TEXT("NumTracks long, ")
                                            TEXT("NumMenus long, ")
                                            TEXT("PlayList longchar, ")
                                            TEXT("TitleQuery longchar ")
                                       TEXT(")");

TCHAR        gszTracksCreate[] = TEXT("create table Tracks ")
                                       TEXT("(")
                                            TEXT("TitleID long, ")
                                            TEXT("TrackID long, ")
                                            TEXT("TrackName longchar ")
                                       TEXT(")");

TCHAR         gszMenusCreate[] = TEXT("create table Menus ")
                                       TEXT("(")
                                            TEXT("TitleID long, ")
                                            TEXT("MenuID long, ")
                                            TEXT("MenuName longchar, ")
                                            TEXT("MenuQuery longchar ")
                                       TEXT(")");

TCHAR         gszBatchCreate[] = TEXT("create table Batch ")
                                       TEXT("(")
                                            TEXT("TitleID long, ")
                                            TEXT("NumTracks long, ")
                                            TEXT("TitleQuery longchar")
                                       TEXT(")");


SDWORD              gcbTitles[] = { 0, SQL_NTS, SQL_NTS, SQL_NTS, SQL_NTS, SQL_NTS, 0, 0, SQL_NTS, INTERNET_MAX_PATH_LENGTH };
SDWORD              gcbTracks[] = { 0, 0, SQL_NTS };
SDWORD              gcbMenus[]  = { 0, 0, SQL_NTS, INTERNET_MAX_PATH_LENGTH };
SDWORD              gcbBatch[]  = { 0, 0, INTERNET_MAX_PATH_LENGTH };



extern HINSTANCE g_dllInst;

////////////
// Functions
////////////

CCDData::CCDData()
{
    m_pTitleList = NULL;
    m_pBatchList = NULL;
    m_dwLoadCnt = 0;
    m_dwBatchCnt = 0;
    m_henv = NULL;
    m_hdbc = NULL;
    m_fToldUser = FALSE;
    m_pSQL = NULL;
    m_dwRef = 0;

    memset(&m_bd, 0, sizeof(m_bd));

	InitializeCriticalSection(&m_crit);

}


CCDData::~CCDData()
{
    CloseDatabase();

    if (m_pTitleList)
    {
        DestroyTitles(&m_pTitleList);
    }

    if (m_pSQL)
    {
        delete m_pSQL;
    }

	DeleteCriticalSection(&m_crit);
}


STDMETHODIMP CCDData::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (IID_IUnknown == riid || IID_ICDData == riid)
    {  
        *ppv = this;
    }

    if (NULL==*ppv)
    {
        return E_NOINTERFACE;
    }

    AddRef();

    return S_OK;
}


STDMETHODIMP CCDData::GetSQLPtr(BOOL fInited)
{
	HRESULT hr = S_OK;
    
	if (m_pSQL == NULL)
	{
        static BOOL fAttempt = FALSE;

        if (!fAttempt)
        {
            m_pSQL = new SQL;

            if (m_pSQL && !m_pSQL->Initialize())
            {
                delete m_pSQL;
                m_pSQL = NULL;
		        hr = E_FAIL;
            }
            else
            {
                if (!fInited)     // we must be running in shell mode, quietly initialize
                {
                    Initialize(NULL);
                    CheckDatabase(NULL);
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }

        fAttempt = TRUE;
    }

	return(hr);
}

STDMETHODIMP_(ULONG) CCDData::AddRef(void)
{
    return ++m_dwRef;
}


STDMETHODIMP_(ULONG) CCDData::Release(void)
{
    if (0!=--m_dwRef)
        return m_dwRef;

    delete this;
    return 0;
}


STDMETHODIMP_(void) CCDData::Enter(void)
{
	EnterCriticalSection(&m_crit);
}

STDMETHODIMP_(void) CCDData::Leave(void)
{
	LeaveCriticalSection(&m_crit);
}





STDMETHODIMP CCDData::GetUnknownString(TCHAR **ppStr, const TCHAR *szSection, const TCHAR *szEntry, DWORD dwInitialAlloc)
{
    TCHAR   *pStr;
    DWORD   dwSize;
    DWORD   dwResult;
    HRESULT hr = S_OK;

    dwSize = dwInitialAlloc - BUFFERINC;

    pStr = NULL;

    do 
    {
        dwSize += BUFFERINC; 

        if (pStr)
        {
            delete pStr;
        }

        pStr = new(TCHAR[dwSize]);

        if (pStr == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        dwResult = GetPrivateProfileString(szSection, szEntry, TEXT("\0"), pStr, dwSize, gszIniFile);
    }
    while (dwResult == (dwSize - 2));

    *ppStr = pStr;

    return(hr);
}




STDMETHODIMP_(void) CCDData::ImportTrack(TCHAR *szDiscID, DWORD dwTrack)
{
    TCHAR szTrack[6];

    wsprintf(szTrack,TEXT("%d"),dwTrack);
    GetPrivateProfileString(szDiscID,szTrack,gszDefault,m_bd.CDTrack.szName,CDSTR,gszIniFile);
}


STDMETHODIMP_(RETCODE) CCDData::ImportTracks(HSTMT hstmt, TCHAR *szDiscID)
{
    RETCODE rc = SQL_SUCCESS;

    for (DWORD dwTrack = 0; dwTrack < m_bd.CDTitle.dwNumTracks; dwTrack++)
    {
        ImportTrack(szDiscID, dwTrack);

        rc = m_pSQL->SetPos(hstmt, 0, SQL_ADD, SQL_LOCK_NO_CHANGE);

        if (rc == SQL_SUCCESS)
        {
            m_bd.dwTrackID++;
        }
        else
        {
            ReportError(&m_bd, hstmt);
            break;
        }
        
    }

    return(rc);
}


STDMETHODIMP CCDData::ImportTitle(TCHAR *szDiscID)
{
    HRESULT     hr = S_OK;
    DWORD       dwTitleID;

    _stscanf(szDiscID,TEXT("%xd"),&dwTitleID);

    if (dwTitleID == CDTITLE_NODISC)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_bd.CDTitle.dwTitleID      = dwTitleID;
        m_bd.CDTitle.dwNumTracks    = GetPrivateProfileInt(szDiscID,gszNumTracks,0,gszIniFile);
        m_bd.CDTitle.dwNumPlay      = GetPrivateProfileInt(szDiscID,gszNumPlay,0,gszIniFile);
        GetPrivateProfileString(szDiscID, gszArtist, gszDefault, m_bd.CDTitle.szArtist, CDSTR, gszIniFile);
        GetPrivateProfileString(szDiscID, gszTitle,  gszDefault, m_bd.CDTitle.szTitle,  CDSTR, gszIniFile);

        m_bd.szPlayList[0] = TEXT('\0');
        m_bd.szQuery[0] = TEXT('\0');

        if (m_bd.CDTitle.dwNumPlay)
        {
            TCHAR   *pPlayTable = NULL;   
            TCHAR   *pText = NULL;
            DWORD   dwIndex;
            int     iNum;
            TCHAR   *pDst = m_bd.szPlayList;

            m_bd.CDTitle.dwNumPlay = min(m_bd.CDTitle.dwNumPlay, MAXNUMPLAY);

            if (FAILED(GetUnknownString(&pPlayTable, szDiscID, gszOrder, PLAYLIST_BUFFER)))
            {
                m_bd.CDTitle.dwNumPlay = 0;
            }
            else
            {
                pText = pPlayTable;

                for (dwIndex = 0; dwIndex < m_bd.CDTitle.dwNumPlay && *pText; dwIndex++)
                {
                    _stscanf(pText,TEXT("%d"), &iNum);
                    wsprintf(pDst, TEXT("%02x"), iNum);

                    while(*pDst != TEXT('\0'))
                    {
                        pDst++;
                    }

                    while(isdigit(*pText++));
                }

                delete pPlayTable;
            }
        }
    }

    return(hr);
}


STDMETHODIMP_(void) CCDData::ImportDatabase(LPTIMEDMETER ptm, HSTMT *hstmt, TCHAR *szDiscID)
{
    DWORD   dwCount = 0;
    RETCODE rc;

    while(*szDiscID)
    {
        m_bd.dwTrackID = 0;
        m_bd.dwMenuID = 0;
       
        if (SUCCEEDED(ImportTitle(szDiscID)))    
        {
            rc = ImportTracks(hstmt[1], szDiscID);

            if (rc == SQL_SUCCESS)
            {
                rc = m_pSQL->SetPos(hstmt[0], 0, SQL_ADD, SQL_LOCK_NO_CHANGE);
                ReportError(&m_bd, hstmt);
            }
            
            if (!SQL_SUCCEEDED(rc))
            {
                break;
            }  
        }

        UpdateMeter(ptm);

        while(*szDiscID++);
    }   
}



STDMETHODIMP_(DWORD) CCDData::ImportCount(TCHAR *pEntries)
{
    TCHAR *szDiscID = pEntries;
    DWORD dwCount = 0;

    while(*szDiscID)
    {
        dwCount++;
        while(*szDiscID++);
    }

    return(dwCount);
}




STDMETHODIMP_(void) CCDData::CreateMeter(LPTIMEDMETER ptm, HWND hWnd, DWORD dwCount, DWORD dwJump, UINT uStringID)
{
    if (hWnd && ptm)
    {
        ptm->hMeter = CreateDialog(g_dllInst,MAKEINTRESOURCE(IDD_LOADSTATUS),hWnd,(DLGPROC) MeterHandler);

        if (ptm->hMeter)
        {
            ptm->hParent = hWnd;
            ptm->dwStartTime = timeGetTime();
            ptm->dwRange = dwCount;
            ptm->fShowing = FALSE;
            ptm->dwCount = 0;
            ptm->dwShowCount = 0;
            ptm->dwJump = dwJump;

            if (uStringID != 0)
            {
                TCHAR szTitle[255];
                LoadString(g_dllInst, uStringID, szTitle, sizeof(szTitle)/sizeof(TCHAR));
                SetWindowText(ptm->hMeter, szTitle);
            }
        }
    }
    else
    {
        if (ptm)
        {
            memset(ptm, 0, sizeof(TIMEDMETER));
        }
    }
}


STDMETHODIMP_(void) CCDData::UpdateMeter(LPTIMEDMETER ptm)
{
    if (ptm && ptm->hMeter)
    {
        ptm->dwCount++;

        if (ptm->fShowing)
        {
            if (ptm->hMeter && ((ptm->dwCount % ptm->dwJump) == 0))
            {
                SendDlgItemMessage( ptm->hMeter, IDC_PROGRESSMETER, PBM_SETPOS, (WPARAM) ptm->dwCount - ptm->dwShowCount, 0);
            }           
        }
        else
        {
            if ((ptm->dwCount % ptm->dwJump) == 0)
            {
                DWORD dwUsedTime = timeGetTime() - ptm->dwStartTime;               // Compute time used
                DWORD dwProjected = (ptm->dwRange / ptm->dwCount) * dwUsedTime;    // Project Time to complete
                DWORD dwProjRemain = dwProjected - dwUsedTime;                     // Compute projected remaining time

                if (dwProjRemain >= 1500)        // If it looks like it's going to take a while, put up the meter
                {
                    DWORD dwNumJumps = ptm->dwCount / ptm->dwJump;
                    DWORD dwJumpTime = dwUsedTime / dwNumJumps;

                    if (dwJumpTime > 200)       // To make sure the meter moves smoothly, re-compute jump count
                    {
                        ptm->dwJump = (ptm->dwJump / ((dwJumpTime / 200) + 1)) + 1; 
                    }

                    ptm->dwShowCount = ptm->dwCount;
                    SendDlgItemMessage( ptm->hMeter, IDC_PROGRESSMETER, PBM_SETRANGE, 0, MAKELPARAM(0, ptm->dwRange - ptm->dwShowCount));
                    SendDlgItemMessage( ptm->hMeter, IDC_PROGRESSMETER, PBM_SETPOS, (WPARAM) 0, 0);
			        ShowWindow(ptm->hMeter,SW_SHOWNORMAL);
			        UpdateWindow(ptm->hMeter);
                    ptm->fShowing = TRUE;
                }
            }
        }
    }
}



STDMETHODIMP_(void) CCDData::DestroyMeter(LPTIMEDMETER ptm)
{
    if (ptm && ptm->hMeter)
    {
        DestroyWindow(ptm->hMeter);
        SetForegroundWindow(ptm->hParent);
        memset(ptm, 0, sizeof(LPTIMEDMETER));
    }
}



STDMETHODIMP_(void) CCDData::InitDatabase(HSTMT *hstmt)
{
    m_pSQL->ExecDirect(hstmt[0], (UCHAR *) TEXT("drop table Titles"), SQL_NTS);
    m_pSQL->ExecDirect(hstmt[1], (UCHAR *) TEXT("drop table Tracks"), SQL_NTS);
    m_pSQL->ExecDirect(hstmt[2], (UCHAR *) TEXT("drop table Menus"), SQL_NTS);
    m_pSQL->ExecDirect(hstmt[3], (UCHAR *) TEXT("drop table Batch"), SQL_NTS);

    m_pSQL->ExecDirect(hstmt[0], (UCHAR *) gszTitlesCreate, SQL_NTS);
    m_pSQL->ExecDirect(hstmt[1], (UCHAR *) gszTracksCreate, SQL_NTS);
    m_pSQL->ExecDirect(hstmt[2], (UCHAR *) gszMenusCreate, SQL_NTS);
    m_pSQL->ExecDirect(hstmt[3], (UCHAR *) gszBatchCreate, SQL_NTS);

    m_pSQL->FreeStmt(hstmt[0], SQL_CLOSE); 
    m_pSQL->FreeStmt(hstmt[1], SQL_CLOSE); 
    m_pSQL->FreeStmt(hstmt[2], SQL_CLOSE); 
    m_pSQL->FreeStmt(hstmt[3], SQL_CLOSE); 
}



STDMETHODIMP_(void) CCDData::SetCursors(HSTMT *hstmt)
{
    for (DWORD dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
    {
        m_pSQL->SetStmtOption(hstmt[dwIndex], SQL_CONCURRENCY, SQL_CONCUR_VALUES); 
        m_pSQL->SetStmtOption(hstmt[dwIndex], SQL_CURSOR_TYPE, SQL_CURSOR_KEYSET_DRIVEN);
        m_pSQL->SetStmtOption(hstmt[dwIndex], SQL_ROWSET_SIZE, ROWSET);
    }
}


STDMETHODIMP_(void) CCDData::InitCBTable(LPBOUND pbd)
{
    memcpy(pbd->cbt.cbTitles, gcbTitles, sizeof(gcbTitles));
    memcpy(pbd->cbt.cbTracks, gcbTracks, sizeof(gcbTracks));
    memcpy(pbd->cbt.cbMenus,  gcbMenus,  sizeof(gcbMenus));
    memcpy(pbd->cbt.cbBatch,  gcbBatch,  sizeof(gcbBatch));
}

STDMETHODIMP_(void) CCDData::BindTitles(HSTMT *hstmt, LPBOUND pbd)
{
    m_pSQL->BindCol(hstmt[0],  1, SQL_C_ULONG,  &(pbd->CDTitle.dwTitleID),    sizeof(pbd->CDTitle.dwTitleID),     &pbd->cbt.cbTitles[0]);
    m_pSQL->BindCol(hstmt[0],  2, SQL_C_WCHAR,   pbd->CDTitle.szArtist,        sizeof(pbd->CDTitle.szArtist),      &pbd->cbt.cbTitles[1]);
    m_pSQL->BindCol(hstmt[0],  3, SQL_C_WCHAR,   pbd->CDTitle.szTitle,         sizeof(pbd->CDTitle.szTitle),       &pbd->cbt.cbTitles[2]);
    m_pSQL->BindCol(hstmt[0],  4, SQL_C_WCHAR,   pbd->CDTitle.szCopyright,     sizeof(pbd->CDTitle.szCopyright),   &pbd->cbt.cbTitles[3]);
    m_pSQL->BindCol(hstmt[0],  5, SQL_C_WCHAR,   pbd->CDTitle.szLabel,         sizeof(pbd->CDTitle.szLabel),       &pbd->cbt.cbTitles[4]);
    m_pSQL->BindCol(hstmt[0],  6, SQL_C_WCHAR,   pbd->CDTitle.szDate,          sizeof(pbd->CDTitle.szDate),        &pbd->cbt.cbTitles[5]);
    m_pSQL->BindCol(hstmt[0],  7, SQL_C_ULONG,  &(pbd->CDTitle.dwNumTracks),  sizeof(pbd->CDTitle.dwNumTracks),   &pbd->cbt.cbTitles[6]);
    m_pSQL->BindCol(hstmt[0],  8, SQL_C_ULONG,  &(pbd->CDTitle.dwNumMenus),   sizeof(pbd->CDTitle.dwNumMenus),    &pbd->cbt.cbTitles[7]);
    m_pSQL->BindCol(hstmt[0],  9, SQL_C_WCHAR,   pbd->szPlayList,              sizeof(pbd->szPlayList),            &pbd->cbt.cbTitles[8]);
    m_pSQL->BindCol(hstmt[0], 10, SQL_C_WCHAR,   pbd->szQuery,                 sizeof(pbd->szQuery),               &pbd->cbt.cbTitles[9]);
}


STDMETHODIMP_(void) CCDData::BindTracks(HSTMT *hstmt, LPBOUND pbd)
{
    m_pSQL->BindCol(hstmt[1],  1, SQL_C_ULONG,  &(pbd->CDTitle.dwTitleID),    sizeof(pbd->CDTitle.dwTitleID),     &pbd->cbt.cbTracks[0]);
    m_pSQL->BindCol(hstmt[1],  2, SQL_C_ULONG,  &(pbd->dwTrackID),            sizeof(pbd->dwTrackID),             &pbd->cbt.cbTracks[1]);
    m_pSQL->BindCol(hstmt[1],  3, SQL_C_WCHAR,   pbd->CDTrack.szName,          sizeof(pbd->CDTrack.szName),        &pbd->cbt.cbTracks[2]);
}

STDMETHODIMP_(void) CCDData::BindMenus(HSTMT *hstmt, LPBOUND pbd)
{
    m_pSQL->BindCol(hstmt[2],  1, SQL_C_ULONG,  &(pbd->CDTitle.dwTitleID),    sizeof(pbd->CDTitle.dwTitleID),     &pbd->cbt.cbMenus[0]);
    m_pSQL->BindCol(hstmt[2],  2, SQL_C_ULONG,  &(pbd->dwMenuID),             sizeof(pbd->dwMenuID),              &pbd->cbt.cbMenus[1]);
    m_pSQL->BindCol(hstmt[2],  3, SQL_C_WCHAR,   pbd->CDMenu.szMenuText,       sizeof(pbd->CDMenu.szMenuText),     &pbd->cbt.cbMenus[2]);
    m_pSQL->BindCol(hstmt[2],  4, SQL_C_WCHAR,   pbd->szQuery,                 sizeof(pbd->szQuery),               &pbd->cbt.cbMenus[3]);
}

STDMETHODIMP_(void) CCDData::BindBatch(HSTMT *hstmt, LPBOUND pbd)
{
    m_pSQL->BindCol(hstmt[3],  1, SQL_C_ULONG,  &(pbd->CDTitle.dwTitleID),    sizeof(pbd->CDTitle.dwTitleID),     &pbd->cbt.cbBatch[0]);
    m_pSQL->BindCol(hstmt[3],  2, SQL_C_ULONG,  &(pbd->CDTitle.dwNumTracks),  sizeof(pbd->CDTitle.dwNumTracks),   &pbd->cbt.cbBatch[1]);
    m_pSQL->BindCol(hstmt[3],  3, SQL_C_WCHAR, pbd->szQuery,                 sizeof(pbd->szQuery),               &pbd->cbt.cbBatch[2]);
}


STDMETHODIMP_(void) CCDData::SetBindings(HSTMT *hstmt, LPBOUND pbd)
{
    BindTitles(hstmt,pbd);
    BindTracks(hstmt,pbd);
    BindMenus(hstmt,pbd);
    BindBatch(hstmt,pbd);
}


STDMETHODIMP_(void) CCDData::ReportError(LPBOUND pbd, HSTMT hstmt)
{
#ifdef DEBUG

    UCHAR state[255];
    SDWORD dwErr;
    UCHAR szErr[SQL_MAX_MESSAGE_LENGTH];
    SWORD cbErr;

    m_pSQL->Error(pbd->henv, pbd->hdbc, hstmt, state, &dwErr, szErr, SQL_MAX_MESSAGE_LENGTH, &cbErr);

    OutputDebugString((TCHAR *) szErr);

    if (szErr[0] != TEXT('\0'))
    {
        OutputDebugString(TEXT("\n"));
    }
#endif 
}





STDMETHODIMP_(RETCODE) CCDData::AllocStmt(HDBC hdbc, HSTMT *hstmt)
{
    RETCODE rc = SQL_SUCCESS;
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
    {
        hstmt[dwIndex] = NULL;
    }

    for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
    {
        rc = m_pSQL->AllocStmt(hdbc, &hstmt[dwIndex]);

        if (rc != SQL_SUCCESS)
        {
            break;
        }
    }

    return(rc);
}

STDMETHODIMP_(void) CCDData::FreeStmt(HSTMT *hstmt)
{
    RETCODE rc = SQL_SUCCESS;
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
    {
        if (hstmt[dwIndex] != NULL)
        {
            m_pSQL->FreeStmt(hstmt[dwIndex], SQL_DROP);
            hstmt[dwIndex] = NULL;
        }
    }
}




STDMETHODIMP_(void) CCDData::CreateDatabase(void)
{
    HENV        henv;
    HDBC        hdbc;
    HSTMT       hstmt[NUMTABLES]; 
    TCHAR       szWinDir[MAX_PATH];
    TCHAR       szCreateAttr[MAX_PATH];
    TCHAR       szDSNAttr[MAX_PATH];
    
    if (GetAppDataDir(szWinDir, sizeof(szWinDir)/sizeof(TCHAR)) != 0)
    {
        wsprintf(szCreateAttr, gszDSNCreate, szWinDir, TEXT('\0'));
        wsprintf(szDSNAttr, gszDSNAttr, TEXT('\0'), szWinDir, TEXT('\0'), TEXT('\0'), TEXT('\0'));
        
        if (m_pSQL->ConfigDataSource(NULL, ODBC_ADD_DSN, gszDriverName, szCreateAttr))
        {
            if (m_pSQL->ConfigDataSource(NULL, ODBC_ADD_DSN, gszDriverName, szDSNAttr))
            {
                if (m_pSQL->AllocEnv(&henv) == SQL_SUCCESS)
                {            
                    if (m_pSQL->AllocConnect(henv, &hdbc) == SQL_SUCCESS)
                    { 
                        if (m_pSQL->Connect(hdbc, (UCHAR *) gszDSN, SQL_NTS, NULL, 0, NULL, 0) == SQL_SUCCESS)
                        {
                            if (AllocStmt(hdbc, hstmt) == SQL_SUCCESS)
                            {
                                InitDatabase(hstmt);
                            }
                            FreeStmt(hstmt);
                        }
                        m_pSQL->Disconnect(hdbc);
                    }
                    m_pSQL->FreeConnect(hdbc);
                }
                m_pSQL->FreeEnv(henv);
            }
        }
    }
}


STDMETHODIMP CCDData::CheckDatabase(HWND hWnd)
{
    HRESULT hr = S_OK;

    GetSQLPtr(FALSE);

    if (!m_pSQL)
    {
        if (!m_fToldUser)
        {
            TCHAR szTitle[255];
            TCHAR szCaption[255];
            LoadString(g_dllInst, IDS_ERROR_NO_ODBC, szTitle, sizeof(szTitle)/sizeof(TCHAR));
            LoadString(g_dllInst, IDS_ERROR_SETUP, szCaption, sizeof(szTitle)/sizeof(TCHAR));
            MessageBox(hWnd, szTitle, szCaption, MB_OK | MB_ICONEXCLAMATION);
            m_fToldUser = TRUE;
        }
        
        hr = E_FAIL;
    }

    return(hr);
}


//finds the dir for allowing roaming profiles
STDMETHODIMP_(DWORD) CCDData::GetAppDataDir(TCHAR* pstrDir, DWORD cchSize)
{
    DWORD dwRet = 0;
/*
    TCHAR szDir[MAX_PATH] = TEXT("%userprofile%\\Application Data\\Microsoft\\DeluxeCD");

    dwRet = ExpandEnvironmentStrings(szDir,pstrDir,cchSize);
    if (dwRet > 0)
    {
        CreateDirectory(pstrDir,NULL);

        //shorten the pathname, because ODBC can't handle spaces
        _tcscpy(szDir,pstrDir);
        dwRet = GetShortPathName(szDir,pstrDir,cchSize);
    }
*/

    dwRet = GetWindowsDirectory(pstrDir,cchSize);

    return (dwRet);
}

STDMETHODIMP CCDData::Initialize(HWND hWnd)
{
    TCHAR       *pEntries = NULL;
    HRESULT     hr = S_OK;
    DWORD       dwCount;
    UDWORD      row[NUMTABLES];
    UWORD       rgfRowStat[NUMTABLES][ROWSET];
    TCHAR       szWinDir[MAX_PATH];
    TCHAR       szCreateAttr[MAX_PATH];
    TIMEDMETER  tm;

    if (SUCCEEDED(GetSQLPtr(TRUE)))
    {
        if (GetAppDataDir(szWinDir, sizeof(szWinDir)/sizeof(TCHAR)) != 0)
        {
            wsprintf(szCreateAttr, gszDSNCreate, szWinDir, TEXT('\0'));

            if (m_pSQL->ConfigDataSource(NULL, ODBC_ADD_DSN, gszDriverName, szCreateAttr))  // If this fails, we assume we've already imported the file
            {
                hr = GetUnknownString(&pEntries, NULL, NULL, SECTION_BUFFER);

                if (SUCCEEDED(hr))
                {
                    dwCount = ImportCount(pEntries);

                    CreateMeter(&tm, hWnd, dwCount, 5,  IDS_IMPORTING);

                    OpenDatabase(TRUE,hWnd);

                    if (m_henv)
                    {
                        TCHAR    *szDiscID = pEntries;
                        DWORD   dwIndex;

                        memset(&m_bd, 0, sizeof(m_bd));
                        m_bd.henv = m_henv;
                        m_bd.hdbc = m_hdbc;

                        InitDatabase(m_hstmt);

                        InitCBTable(&m_bd);
                        SetCursors( m_hstmt );
                        SetBindings( m_hstmt, &m_bd);

                        m_pSQL->SetConnectOption(m_hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_OFF);

                        m_pSQL->ExecDirect(m_hstmt[0], (UCHAR *) TEXT("select * from Titles"), SQL_NTS);
                        m_pSQL->ExecDirect(m_hstmt[1], (UCHAR *) TEXT("select * from Tracks"), SQL_NTS);
                        m_pSQL->ExecDirect(m_hstmt[2], (UCHAR *) TEXT("select * from Menus"), SQL_NTS);

                        for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
                        {
                            m_pSQL->ExtendedFetch(m_hstmt[dwIndex], SQL_FETCH_FIRST, 1, &row[dwIndex], rgfRowStat[dwIndex]);
                        }

                        ImportDatabase(&tm, m_hstmt, szDiscID);

                        m_pSQL->Transact(SQL_NULL_HENV, m_hdbc, SQL_COMMIT);

                        for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
                        {
                            m_pSQL->FreeStmt(m_hstmt[dwIndex], SQL_CLOSE);
                        }
               
                        m_pSQL->ExecDirect(m_hstmt[0], (UCHAR *) TEXT("create index TitleIDx on Titles(TitleID)"), SQL_NTS);
                        m_pSQL->ExecDirect(m_hstmt[1], (UCHAR *) TEXT("create index TitleIDx on Tracks(TitleID)"), SQL_NTS);
                        m_pSQL->ExecDirect(m_hstmt[2], (UCHAR *) TEXT("create index TitleIDx on Menus(TitleID)"), SQL_NTS);
                                          
                        m_pSQL->Transact(SQL_NULL_HENV, m_hdbc, SQL_COMMIT);
                        m_pSQL->SetConnectOption(m_hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_ON);

                        CloseDatabase();
                    }

                    DestroyMeter(&tm);
                }

                if (pEntries)
                {
                    delete pEntries;
                }
            }
        
            hr = OpenDatabase(FALSE,hWnd);       // We either already have a database or we just created one, open it. (If we didn't import OpenDatabase will create new one
        }
    }

    return(hr);
}

STDMETHODIMP CCDData::ConnectToDatabase(WORD fRequest)
{
    HRESULT     hr = E_FAIL;
    TCHAR       szWinDir[MAX_PATH];
    TCHAR       szDSNAttr[MAX_PATH];
    
    if (GetAppDataDir(szWinDir, sizeof(szWinDir)/sizeof(TCHAR)) != 0)
    {
        wsprintf(szDSNAttr, gszDSNAttr, TEXT('\0'), szWinDir, TEXT('\0'), TEXT('\0'), TEXT('\0'));

        if (m_pSQL->ConfigDataSource(NULL, fRequest, gszDriverName, szDSNAttr))
        {
            if (m_pSQL->AllocEnv(&m_henv) == SQL_SUCCESS)
            {            
                if (m_pSQL->AllocConnect(m_henv, &m_hdbc) == SQL_SUCCESS)
                { 
                    if (m_pSQL->Connect(m_hdbc, (UCHAR *) gszDSN, SQL_NTS, NULL, 0, NULL, 0) == SQL_SUCCESS)
                    {
                        if (AllocStmt(m_hdbc, m_hstmt) == SQL_SUCCESS)
                        {
                            hr = S_OK;
                        }
                    }
                }
            }
        }
    }
    
    return(hr);
}


STDMETHODIMP CCDData::OpenDatabase(BOOL fCreate, HWND hWnd)
{
    HRESULT hr = E_FAIL;

    m_henv = NULL;
    m_hdbc = NULL;
    
    for (DWORD dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
    {
        m_hstmt[dwIndex] = NULL;
    }
    
    hr = ConnectToDatabase(ODBC_ADD_DSN);

    if (FAILED(hr))                 // Lets try creating the database
    {
        CreateDatabase();
        hr = ConnectToDatabase(ODBC_CONFIG_DSN);
    }
    else
    {
        //only do this if connection to database succeeded right off the bat,
        //because if we just created a new one, it is in the right format already.
        if (IsOldFormat())
        {
            hr = UpgradeDatabase(hWnd);
        }
    }

    if (FAILED(hr))
    {
        CloseDatabase();
    }

    return (hr);
}



STDMETHODIMP_(void) CCDData::CloseDatabase(void)
{
    if (m_pSQL)
    {
        FreeStmt(m_hstmt);

        if (m_hdbc)
        {
            m_pSQL->Disconnect(m_hdbc);
            m_pSQL->FreeConnect(m_hdbc);
        }

        if (m_henv)
        {
            m_pSQL->FreeEnv(m_henv);
        }
    }
}




STDMETHODIMP_(DWORD) CCDData::GetNumRows(UCHAR *szDSN)
{
    HSTMT hstmt;
    DWORD dwCount = 0;
    SWORD Type,Cardinality;
    SDWORD cbCardinality = 0, cbType = 0;
    RETCODE rc;

    if (m_pSQL->AllocStmt(m_hdbc, &hstmt) == SQL_SUCCESS)
    {
        if (m_pSQL->Statistics(hstmt, NULL, 0, NULL, 0, szDSN, SQL_NTS, SQL_INDEX_ALL, SQL_ENSURE) == SQL_SUCCESS)
        {
            rc = m_pSQL->BindCol(hstmt,  7, SQL_C_SSHORT,  &Type,        sizeof(Type),         &cbType);
            rc = m_pSQL->BindCol(hstmt, 11, SQL_C_SSHORT,  &Cardinality, sizeof(Cardinality),  &cbCardinality);

            if (rc != SQL_SUCCESS)
            {
                ReportError(&m_bd, hstmt);
            }

            while (rc == SQL_SUCCESS)
            {
                rc = m_pSQL->Fetch(hstmt);
            
                if (rc == SQL_SUCCESS)
                {
                    if (Type == SQL_TABLE_STAT)
                    {
                        dwCount = (DWORD) Cardinality;
                        break;
                    }
                }
            }
        }

        m_pSQL->FreeStmt(hstmt, SQL_DROP);
    }
    return(dwCount);
}






STDMETHODIMP CCDData::ExtractTitle(LPCDTITLE *ppCDTitle)
{
    HRESULT     hr;
    LPCDTITLE   pCDTitle = NULL;

    m_bd.CDTitle.fLoaded = FALSE;

    hr = NewTitle(&pCDTitle, m_bd.CDTitle.dwTitleID, m_bd.CDTitle.dwNumTracks, m_bd.CDTitle.dwNumMenus);

    if (SUCCEEDED(hr))
    {    
        DWORD dwTrack = 0;
        DWORD dwMenu = 0;

        m_bd.CDTitle.pTrackTable = pCDTitle->pTrackTable;
        m_bd.CDTitle.pMenuTable = pCDTitle->pMenuTable;
        m_bd.CDTitle.pPlayList = pCDTitle->pPlayList;

        memcpy(pCDTitle,&m_bd.CDTitle,sizeof(m_bd.CDTitle));
        memset(&m_bd.CDTitle, 0, sizeof(m_bd.CDTitle));

        DWORD dwSize = lstrlen(m_bd.szQuery) + 1;

        if (dwSize)
        {
            pCDTitle->szTitleQuery = new(TCHAR[dwSize]);

            if (pCDTitle->szTitleQuery)
            {
                lstrcpy(pCDTitle->szTitleQuery, m_bd.szQuery);
            }
        }

        pCDTitle->dwNumPlay = lstrlen(m_bd.szPlayList) >> 1; // Null terminated, two digits per entry (two chars) thus divide by 2

        if (pCDTitle->dwNumPlay)
        {
            pCDTitle->dwNumPlay = min(pCDTitle->dwNumPlay, MAXNUMPLAY);    

            pCDTitle->pPlayList = new(WORD[pCDTitle->dwNumPlay]);

            if (pCDTitle->pPlayList == NULL)
            {
                pCDTitle->dwNumPlay = 0;
            }
            else
            {
                TCHAR   *pText = m_bd.szPlayList;
                LPWORD  pNum = pCDTitle->pPlayList;
                DWORD   dwIndex = 0;
                TCHAR   szNum[3];
                int     iNum;

                szNum[2] = TEXT('\0');
                for (dwIndex = 0; dwIndex < pCDTitle->dwNumPlay; dwIndex++, pNum++)
                {
                    szNum[0] = *pText++;    
                    szNum[1] = *pText++;    
                    _stscanf(szNum, TEXT("%02x"), &iNum);
                    *pNum = (WORD) iNum;   
                }
            }
        }
    }

    if (SUCCEEDED(hr) && ppCDTitle)
    {
        *ppCDTitle = pCDTitle;
    }
    else if (pCDTitle)
    {
        DestroyTitle(pCDTitle);
    }

    return(hr);
}


STDMETHODIMP_(LPCDTITLE) CCDData::FindTitle(LPCDTITLE pCDTitle, DWORD dwTitleID)
{
    while (pCDTitle)
    {
        if (pCDTitle->dwTitleID == dwTitleID)
        {
            break;
        }
        
        pCDTitle = pCDTitle->pNext;
    }

    return(pCDTitle);
}



STDMETHODIMP CCDData::ExtractTitles(LPCDTITLE *ppCDTitleList, HWND hWnd)
{
    HRESULT     hr = S_OK;
    LPCDTITLE   pCDTitle = NULL;;
    TIMEDMETER  tm;

    InitCBTable(&m_bd);
    SetCursors(m_hstmt);
    SetBindings(m_hstmt, &m_bd);

    if (ppCDTitleList == NULL || m_henv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        RETCODE rc;
        DWORD dwCount = GetNumRows((UCHAR *) gszTitleTable) + GetNumRows((UCHAR *) gszTrackTable) + GetNumRows((UCHAR *) gszMenuTable);

        CreateMeter(&tm, hWnd, dwCount, 100, 0);

        dwCount = 0;

        rc = m_pSQL->ExecDirect(m_hstmt[0], (UCHAR *) TEXT("select * from Titles"), SQL_NTS);

        if (rc == SQL_SUCCESS)
        {
            m_bd.szQuery[0] = TEXT('\0');

            while (m_pSQL->Fetch(m_hstmt[0]) == SQL_SUCCESS)
            {
                hr = ExtractTitle(&pCDTitle);

                if (SUCCEEDED(hr))
                {
                    AddTitle(ppCDTitleList, pCDTitle);
                    UpdateMeter(&tm);
                }

                m_bd.szQuery[0] = TEXT('\0');
            }

            if (*ppCDTitleList)
            {
                hr = S_OK;
            }

            m_pSQL->FreeStmt(m_hstmt[0], SQL_CLOSE);

            m_pSQL->ExecDirect(m_hstmt[1], (UCHAR *) TEXT("select * from Tracks"), SQL_NTS);
            pCDTitle = NULL;

            while (m_pSQL->Fetch(m_hstmt[1]) == SQL_SUCCESS)
            {
                if (pCDTitle == NULL || pCDTitle->dwTitleID != m_bd.CDTitle.dwTitleID)
                {
                    pCDTitle = FindTitle(*ppCDTitleList, m_bd.CDTitle.dwTitleID);
                }

                if (pCDTitle)
                {
                    if (m_bd.dwTrackID < pCDTitle->dwNumTracks)
                    {
                        memcpy(&(pCDTitle->pTrackTable[m_bd.dwTrackID]), &(m_bd.CDTrack), sizeof(m_bd.CDTrack));
                        UpdateMeter(&tm);
                    }
                }
            }

            m_pSQL->FreeStmt(m_hstmt[1], SQL_CLOSE);



            m_pSQL->ExecDirect(m_hstmt[2], (UCHAR *) TEXT("select * from Menus"), SQL_NTS);
            pCDTitle = NULL;
            m_bd.szQuery[0] = TEXT('\0');

            while (m_pSQL->Fetch(m_hstmt[2]) == SQL_SUCCESS)
            {
                if (pCDTitle == NULL || pCDTitle->dwTitleID != m_bd.CDTitle.dwTitleID)
                {
                    pCDTitle = FindTitle(*ppCDTitleList, m_bd.CDTitle.dwTitleID);
                }

                if (pCDTitle)
                {
                    if (m_bd.dwMenuID < pCDTitle->dwNumMenus)
                    {
                        LPCDMENU pCDMenu = &(pCDTitle->pMenuTable[m_bd.dwMenuID]);
                        TCHAR *szMenuQuery;

                        SetMenuQuery(pCDMenu, m_bd.szQuery);
                        szMenuQuery = pCDMenu->szMenuQuery;
                        memcpy(pCDMenu, &(m_bd.CDMenu), sizeof(m_bd.CDMenu));
                        pCDMenu->szMenuQuery = szMenuQuery;
                        m_bd.szQuery[0] = TEXT('\0');

                        UpdateMeter(&tm);
                    }
                }
            }

            m_pSQL->FreeStmt(m_hstmt[2], SQL_CLOSE);
        }

        DestroyMeter(&tm);
    }

    return(hr);
}



STDMETHODIMP CCDData::ExtractSingleTitle(LPCDTITLE *ppCDTitle, DWORD dwTitleID)
{
    HRESULT     hr = S_OK;
    LPCDTITLE   pCDTitle = NULL;;

    InitCBTable(&m_bd);
    SetCursors(m_hstmt);
    SetBindings( m_hstmt, &m_bd);

    if (ppCDTitle == NULL || m_henv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        RETCODE     rc;
        UCHAR       szQuery[MAX_PATH];
        
        wsprintf((TCHAR *) szQuery, TEXT("select * from Titles where TitleID = %d"), dwTitleID);
        rc = m_pSQL->ExecDirect(m_hstmt[0], szQuery, SQL_NTS);

        if (rc != SQL_SUCCESS)
        {
            hr = E_FAIL;
        }
        else
        {
            if (m_pSQL->Fetch(m_hstmt[0]) == SQL_SUCCESS)
            {
                hr = ExtractTitle(&pCDTitle);
            }
            else
            {
                hr = E_FAIL;
            }
        
            m_pSQL->FreeStmt(m_hstmt[0], SQL_CLOSE);

            if (SUCCEEDED(hr))
            {
                wsprintf((TCHAR *) szQuery, TEXT("select * from Tracks where TitleID = %d"), dwTitleID);
                m_pSQL->ExecDirect(m_hstmt[1], szQuery, SQL_NTS);

                while (m_pSQL->Fetch(m_hstmt[1]) == SQL_SUCCESS)
                {
                    if (m_bd.dwTrackID < pCDTitle->dwNumTracks)
                    {
                        memcpy(&(pCDTitle->pTrackTable[m_bd.dwTrackID]), &(m_bd.CDTrack), sizeof(m_bd.CDTrack));
                    }
                }

                m_pSQL->FreeStmt(m_hstmt[1], SQL_CLOSE);


                wsprintf((TCHAR *) szQuery, TEXT("select * from Menus where TitleID = %d"), dwTitleID);
                m_pSQL->ExecDirect(m_hstmt[2], szQuery, SQL_NTS);

                while (m_pSQL->Fetch(m_hstmt[2]) == SQL_SUCCESS)
                {
                    if (m_bd.dwMenuID < pCDTitle->dwNumMenus)
                    {
                        LPCDMENU pCDMenu = &(pCDTitle->pMenuTable[m_bd.dwMenuID]);
                        TCHAR *szMenuQuery;

                        SetMenuQuery(pCDMenu, m_bd.szQuery);
                        szMenuQuery = pCDMenu->szMenuQuery;
                        memcpy(pCDMenu, &(m_bd.CDMenu), sizeof(m_bd.CDMenu));
                        pCDMenu->szMenuQuery = szMenuQuery;
                        m_bd.szQuery[0] = TEXT('\0');
                    }
                }

                m_pSQL->FreeStmt(m_hstmt[2], SQL_CLOSE);
            }
        } //end else main query successful
    } //end else args ok

    if (SUCCEEDED(hr))
    {
        *ppCDTitle = pCDTitle;
    }

    return(hr);
}


STDMETHODIMP_(BOOL) CCDData::QueryDatabase(DWORD dwTitleID, const TCHAR *szTable)
{
    BOOL        fResult = FALSE;
    RETCODE     rc;
    UCHAR       szQuery[MAX_PATH];
    HSTMT       hstmt;

    if (m_pSQL->AllocStmt(m_hdbc, &hstmt) == SQL_SUCCESS)
    {
        wsprintf((TCHAR *) szQuery, TEXT("select * from %s where TitleID = %d"), szTable, dwTitleID);
        rc = m_pSQL->ExecDirect(hstmt, szQuery, SQL_NTS);

        if (rc == SQL_SUCCESS)
        {
            if (m_pSQL->Fetch(hstmt) == SQL_SUCCESS)
            {
                fResult = TRUE;
            }
        }

        m_pSQL->FreeStmt(hstmt, SQL_DROP);
    }

    return (fResult);
}




STDMETHODIMP_(BOOL) CCDData::QueryTitle(DWORD dwTitleID)
{
    BOOL fResult = FALSE;
    LPCDTITLE pCDTitle;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (m_pTitleList == NULL)       // Database Not in memory, just query database directly
        {
            fResult = QueryDatabase(dwTitleID, gszTitleTable);
        }
        else                            // Database is in memory, just look here.
        {
            pCDTitle = m_pTitleList;

            while (pCDTitle)
            {
                if (pCDTitle->dwTitleID == dwTitleID)
                {
                    if (!pCDTitle->fRemove)
                    {
                        fResult = TRUE;
                    }
                    break;
                }
            
                pCDTitle = pCDTitle->pNext;
            }
        }
    }

    Leave();

    return(fResult);
}


STDMETHODIMP CCDData::LockTitle(LPCDTITLE *ppCDTitle, DWORD dwTitleID)
{
    HRESULT hr = E_INVALIDARG;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (ppCDTitle)
        {
            if (m_pTitleList == NULL)       // Database Not in memory, load explicitly
            {
                if (SUCCEEDED(ExtractSingleTitle(ppCDTitle, dwTitleID)))
                {
                    (*ppCDTitle)->fLoaded = TRUE;
                    (*ppCDTitle)->dwLockCnt = 1;
                    hr = S_OK;
                }
            }
            else                            // Database is in memory, just look here.
            {
                LPCDTITLE pCDTitle;
                pCDTitle = m_pTitleList;

                while (pCDTitle)
                {
                    if (pCDTitle->dwTitleID == dwTitleID)
                    {
                        *ppCDTitle = pCDTitle;
                        pCDTitle->fLoaded = FALSE;
                        pCDTitle->dwLockCnt++;
                        hr = S_OK;
                        break;
                    }
            
                    pCDTitle = pCDTitle->pNext;
                }
            }
        }
    }
    
    Leave();

    return(hr);
}



STDMETHODIMP_(void) CCDData::UnlockTitle(LPCDTITLE pCDTitle, BOOL fPresist)
{
    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (pCDTitle)
        {
            if (fPresist)               // They either made a new one, or made changes
            {
                DBSaveTitle(pCDTitle);  // write it to database
            }

            if (pCDTitle->fLoaded)      // This was NOT pulled from our database (Either locked while we didn't have the database, or was created.
            {
                pCDTitle->dwLockCnt--;          // they are unlocking

                if (fPresist && m_dwLoadCnt)    // This is a new item, lets add it to load database
                {
                    AddTitle(&m_pTitleList, pCDTitle);    // Insert into the loaded databased
                }
                else if (pCDTitle->dwLockCnt == 0)  // Not being saved and not in database, so nuke it
                {
                    DestroyTitle(pCDTitle);   
                }         
            }
            else                         // This title was pulled from our database, so just dec the ref
            {
                pCDTitle->dwLockCnt--;
            }
        }
    }

    Leave();
}



BOOL CALLBACK CCDData::MeterHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fReturnVal = TRUE;
	    	
    switch (msg) 
    { 
    	default:
			fReturnVal = FALSE;
		break;
		
        case WM_INITDIALOG:
        {
			fReturnVal = TRUE; 
        }		
		break;
    }

    return fReturnVal;
}




STDMETHODIMP CCDData::LoadTitles(HWND hWnd)
{
    HRESULT hr = E_FAIL;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        hr = S_OK;

        if (m_pTitleList == NULL)
        {
            hr = ExtractTitles(&m_pTitleList, hWnd);
        }

        if (SUCCEEDED(hr))
        {
            m_dwLoadCnt++;
        }
    }

    Leave();

    return(hr);
}


STDMETHODIMP CCDData::PersistTitles()
{
    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        SaveTitles(&m_pTitleList);
    }

    Leave();

    return S_OK;
}


STDMETHODIMP CCDData::UnloadTitles()
{
    HRESULT hr = E_FAIL;
    
    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (m_pTitleList)
        {
            m_dwLoadCnt--;

            if (m_dwLoadCnt == 0)
            {
                DestroyTitles(&m_pTitleList);
            }

            hr = S_OK;
        }
    }

    Leave();

    return(hr);
}

STDMETHODIMP CCDData::CreateTitle(LPCDTITLE *ppCDTitle, DWORD dwTitleID, DWORD dwNumTracks, DWORD dwNumMenus)
{
    HRESULT hr = E_FAIL;
    LPCDTITLE pCDTitle;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        hr = S_OK;

        if (!QueryTitle(dwTitleID))      // Only create a blank if it's not already in database
        {
			RemoveFromBatch(dwTitleID);

            hr = NewTitle(&pCDTitle, dwTitleID, dwNumTracks, dwNumMenus);
        }
        else
        {
            hr = LockTitle(&pCDTitle, dwTitleID);           // Let's get return the one we got

            if (SUCCEEDED(hr))                              // but first, re-fit it according to params
            {
                if (pCDTitle->dwNumTracks != dwNumTracks)
                {
                    if (pCDTitle->pTrackTable)
                    {
                        delete pCDTitle->pTrackTable;
                    }

                    pCDTitle->dwNumTracks = dwNumTracks;
                    pCDTitle->pTrackTable = new(CDTRACK[dwNumTracks]);

                    if (pCDTitle->pTrackTable == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
        
                if (SUCCEEDED(hr) && pCDTitle->dwNumMenus != dwNumMenus)
                {
                    if (pCDTitle->pMenuTable)
                    {
                        delete pCDTitle->pMenuTable;
                    }

                    pCDTitle->dwNumMenus = dwNumMenus;
                    pCDTitle->pMenuTable = new(CDMENU[dwNumMenus]);
                    ZeroMemory(pCDTitle->pMenuTable,sizeof(CDMENU)*dwNumMenus);

                    if (pCDTitle->pMenuTable == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                
                if (FAILED(hr))
                {
                    DestroyTitle(pCDTitle);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            *ppCDTitle = pCDTitle;
        }
    }
    
    Leave();

    return(hr);
}




STDMETHODIMP CCDData::SetTitleQuery(LPCDTITLE pCDTitle, TCHAR *szTitleQuery)
{
    HRESULT hr = E_FAIL;
 
    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (pCDTitle && szTitleQuery && lstrlen(szTitleQuery) < INTERNET_MAX_PATH_LENGTH)
        {
            if (pCDTitle->szTitleQuery)
            {
                delete pCDTitle->szTitleQuery;
            }

            DWORD dwSize = lstrlen(szTitleQuery) + 1;

            pCDTitle->szTitleQuery = new(TCHAR[dwSize]);

            if (pCDTitle->szTitleQuery == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                lstrcpy(pCDTitle->szTitleQuery, szTitleQuery);
                hr = S_OK;
            }
        }
    }

    return(hr);
}


STDMETHODIMP CCDData::SetMenuQuery(LPCDMENU pCDMenu, TCHAR *szMenuQuery)
{
    HRESULT hr = E_FAIL;
    
    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (pCDMenu && szMenuQuery && lstrlen(szMenuQuery) < INTERNET_MAX_PATH_LENGTH)
        {
            if (pCDMenu->szMenuQuery)
            {
                delete pCDMenu->szMenuQuery;
            }

            DWORD dwSize = lstrlen(szMenuQuery) + 1;

            pCDMenu->szMenuQuery = new(TCHAR[dwSize]);

            if (pCDMenu->szMenuQuery== NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                lstrcpy(pCDMenu->szMenuQuery, szMenuQuery);
                hr = S_OK;
            }
        }
    }

    return(hr);
}



STDMETHODIMP CCDData::NewTitle(LPCDTITLE *ppCDTitle, DWORD dwTitleID, DWORD dwNumTracks, DWORD dwNumMenus)
{
    HRESULT hr = S_OK;

    if (ppCDTitle == NULL || dwTitleID == CDTITLE_NODISC || dwNumTracks == 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LPCDTITLE pCDTitle = new(CDTITLE);

        if (pCDTitle == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memset(pCDTitle, 0, sizeof(CDTITLE));

            pCDTitle->dwTitleID = dwTitleID;
            pCDTitle->dwNumTracks = dwNumTracks;
            pCDTitle->dwNumMenus = dwNumMenus;
            pCDTitle->fLoaded = TRUE;
            pCDTitle->dwLockCnt = 1;

            pCDTitle->pTrackTable = new(CDTRACK[dwNumTracks]);

            if (pCDTitle->pTrackTable == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                memset(pCDTitle->pTrackTable, 0, sizeof(CDTRACK) * dwNumTracks);

                if (dwNumMenus)
                {
                    pCDTitle->pMenuTable = new(CDMENU[dwNumMenus]);

                    if (pCDTitle->pMenuTable == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        memset(pCDTitle->pMenuTable, 0, sizeof(CDMENU) * dwNumMenus);
                    }
                }
            }

            if (FAILED(hr))
            {
                if (pCDTitle->pMenuTable)
                {
                    delete pCDTitle->pMenuTable;
                }

                if (pCDTitle->pTrackTable)
                {
                    delete pCDTitle->pTrackTable;
                }

                delete(pCDTitle);
            }
            else
            {
                *ppCDTitle = pCDTitle;
            }
        }
    }

    return(hr);
}




STDMETHODIMP_(void) CCDData::DestroyTitle(LPCDTITLE pCDTitle)
{
    if (pCDTitle)
    {
        if (pCDTitle->szTitleQuery)
        {
            delete pCDTitle->szTitleQuery;
        }

        if (pCDTitle->pTrackTable)
        {
            delete pCDTitle->pTrackTable;
        }

        if (pCDTitle->pPlayList)
        {
            delete pCDTitle->pPlayList;
        }

        if (pCDTitle->pMenuTable)
        {
            for (DWORD dwMenu = 0; dwMenu < pCDTitle->dwNumMenus; dwMenu++)
            {
                TCHAR *szMenuQuery = pCDTitle->pMenuTable[dwMenu].szMenuQuery;

                if (szMenuQuery)
                {
                    delete szMenuQuery;
                }
            }
            delete pCDTitle->pMenuTable;
        }
    }

    delete pCDTitle;
}



STDMETHODIMP_(void) CCDData::SaveTitle(LPCDTITLE pCDTitle, BOOL fExist)
{
    UCHAR       szQuery[MAX_PATH];
    UDWORD      row[NUMTABLES];
    UWORD       rgfRowStat[NUMTABLES][ROWSET];
    RETCODE     rc;

    if (fExist)
    {
        wsprintf((TCHAR *) szQuery, TEXT("select * from Titles where TitleID = %d"), pCDTitle->dwTitleID);
        rc = m_pSQL->ExecDirect(m_hstmt[0], szQuery, SQL_NTS);
        ReportError(&m_bd, m_hstmt[0]);
    }
    else
    {
        rc = m_pSQL->ExecDirect(m_hstmt[0], (UCHAR *) TEXT("select * from Titles"), SQL_NTS);
        ReportError(&m_bd, m_hstmt[0]);
    }

    rc = m_pSQL->ExtendedFetch(m_hstmt[0], SQL_FETCH_LAST, 1, &row[0], rgfRowStat[0]);
    ReportError(&m_bd, m_hstmt[0]);

    InitCBTable(&m_bd);
    memcpy(&m_bd.CDTitle, pCDTitle, sizeof(CDTITLE));

    if (pCDTitle->szTitleQuery)
    {
        lstrcpy(m_bd.szQuery, pCDTitle->szTitleQuery);
    }
    else
    {
        m_bd.szQuery[0] = TEXT('\0');
    }

    pCDTitle->dwNumPlay = min(pCDTitle->dwNumPlay, MAXNUMPLAY);

    m_bd.szPlayList[0] = TEXT('\0');

    if (pCDTitle->dwNumPlay && pCDTitle->pPlayList)
    {
        DWORD  dwIndex;
        TCHAR  *pDst = m_bd.szPlayList;
        LPWORD pNum = pCDTitle->pPlayList;

        for (dwIndex = 0; dwIndex < pCDTitle->dwNumPlay; dwIndex++, pNum++)
        {
            wsprintf(pDst, TEXT("%02x"), *pNum);

            while(*pDst != TEXT('\0'))
            {
                pDst++;
            }
        }
    }

    if (fExist)
    {
        rc = m_pSQL->SetPos(m_hstmt[0], 0, SQL_UPDATE, SQL_LOCK_NO_CHANGE);
       // ReportError(&m_bd, m_hstmt[0]);
    }
    else
    {
        rc = m_pSQL->SetPos(m_hstmt[0], 0, SQL_ADD, SQL_LOCK_NO_CHANGE);
       // ReportError(&m_bd, m_hstmt[0]);
    }
}



STDMETHODIMP_(void) CCDData::SaveTracks(LPCDTITLE pCDTitle, BOOL fExist)
{
    UCHAR       szQuery[MAX_PATH];
    UDWORD      row[NUMTABLES];
    UWORD       rgfRowStat[NUMTABLES][ROWSET];
    RETCODE     rc;
    DWORD       dwTrack;
    DWORD       dwTitleID = pCDTitle->dwTitleID;

    if (fExist)
    {
        wsprintf((TCHAR *) szQuery, TEXT("select * from Tracks where TitleID = %d"), pCDTitle->dwTitleID);
        rc = m_pSQL->ExecDirect(m_hstmt[1], szQuery, SQL_NTS);
        ReportError(&m_bd, m_hstmt[1]);
    }
    else
    {
        rc = m_pSQL->ExecDirect(m_hstmt[1], (UCHAR *) TEXT("select * from Tracks"), SQL_NTS);
        ReportError(&m_bd, m_hstmt[1]);
    }

    if (fExist)
    {
        rc = m_pSQL->ExtendedFetch(m_hstmt[1], SQL_FETCH_FIRST, 1, &row[0], rgfRowStat[0]);
        ReportError(&m_bd, m_hstmt[1]);

        for (dwTrack = 0; dwTrack < pCDTitle->dwNumTracks; dwTrack++)
        {
            InitCBTable(&m_bd);
            m_bd.CDTitle.dwTitleID = dwTitleID;

            if (m_bd.dwTrackID < pCDTitle->dwNumTracks)
            {
                memcpy(&m_bd.CDTrack, &(pCDTitle->pTrackTable[m_bd.dwTrackID]), sizeof(CDTRACK));
                rc = m_pSQL->SetPos(m_hstmt[1], 0, SQL_UPDATE, SQL_LOCK_NO_CHANGE);
                ReportError(&m_bd, m_hstmt[1]);
            }

            rc = m_pSQL->ExtendedFetch(m_hstmt[1], SQL_FETCH_NEXT, 1, &row[0], rgfRowStat[0]);
            ReportError(&m_bd, m_hstmt[1]);

        }
    }
    else
    {
        rc = m_pSQL->ExtendedFetch(m_hstmt[1], SQL_FETCH_LAST, 1, &row[0], rgfRowStat[0]);
        ReportError(&m_bd, m_hstmt[1]);

        InitCBTable(&m_bd);
        m_bd.CDTitle.dwTitleID = dwTitleID;

        for (dwTrack = 0; dwTrack < pCDTitle->dwNumTracks; dwTrack++)
        {
            m_bd.dwTrackID = dwTrack;
            memcpy(&m_bd.CDTrack, &(pCDTitle->pTrackTable[dwTrack]), sizeof(CDTRACK));
            rc = m_pSQL->SetPos(m_hstmt[1], 0, SQL_ADD, SQL_LOCK_NO_CHANGE);
            ReportError(&m_bd, m_hstmt[1]);
        }
    }
}


STDMETHODIMP_(void) CCDData::SaveMenus(LPCDTITLE pCDTitle)
{
    UCHAR       szQuery[MAX_PATH];
    UDWORD      row[NUMTABLES];
    UWORD       rgfRowStat[NUMTABLES][ROWSET];
    RETCODE     rc;
    DWORD       dwMenu;
    DWORD       dwTitleID = pCDTitle->dwTitleID;


    wsprintf((TCHAR *) szQuery, TEXT("delete from Menus where TitleID = %d"), pCDTitle->dwTitleID);
    rc = m_pSQL->ExecDirect(m_hstmt[2], szQuery, SQL_NTS);
    
    if (pCDTitle->dwNumMenus)
    {
        rc = m_pSQL->ExecDirect(m_hstmt[2], (UCHAR *) TEXT("select * from Menus"), SQL_NTS);
        ReportError(&m_bd, m_hstmt[2]);

        rc = m_pSQL->ExtendedFetch(m_hstmt[2], SQL_FETCH_LAST, 1, &row[0], rgfRowStat[0]);
        ReportError(&m_bd, m_hstmt[2]);

        InitCBTable(&m_bd);
        m_bd.CDTitle.dwTitleID = dwTitleID;

        for (dwMenu = 0; dwMenu < pCDTitle->dwNumMenus; dwMenu++)
        {
            LPCDMENU pCDMenu = &(pCDTitle->pMenuTable[dwMenu]);

            m_bd.dwMenuID = dwMenu;
            memcpy(&m_bd.CDMenu, pCDMenu, sizeof(CDMENU));
            m_bd.szQuery[0] = TEXT('\0');

            if (pCDMenu->szMenuQuery)
            {
                lstrcpy(m_bd.szQuery, pCDMenu->szMenuQuery);
            }
            
            rc = m_pSQL->SetPos(m_hstmt[2], 0, SQL_ADD, SQL_LOCK_NO_CHANGE);
            //ReportError(&m_bd, m_hstmt[2]);
        }
    }
}



STDMETHODIMP_(void) CCDData::DBSaveTitle(LPCDTITLE pCDTitle)
{
    if (pCDTitle)
    {
        RETCODE     rc;
        DWORD       dwIndex;

        BOOL fExist = QueryDatabase(pCDTitle->dwTitleID, gszTitleTable);

        InitCBTable(&m_bd);
        SetCursors( m_hstmt );
        SetBindings( m_hstmt, &m_bd);

        rc = m_pSQL->SetConnectOption(m_hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_OFF);
        ReportError(&m_bd, m_hstmt[0]);

        SaveTitle(pCDTitle, fExist);
        SaveTracks(pCDTitle, fExist);
        SaveMenus(pCDTitle);

        rc = m_pSQL->Transact(SQL_NULL_HENV, m_hdbc, SQL_COMMIT);
//        ReportError(&m_bd, m_hstmt[0]);

        rc = m_pSQL->SetConnectOption(m_hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_ON);
//        ReportError(&m_bd, m_hstmt[0]);

        for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
        {
            m_pSQL->FreeStmt(m_hstmt[dwIndex], SQL_CLOSE);
        }
    }
}



STDMETHODIMP_(void) CCDData::DBRemoveTitle(LPCDTITLE pCDTitle)
{
    if (pCDTitle && pCDTitle->dwTitleID != CDTITLE_NODISC)
    {
        RETCODE     rc;
        UCHAR       szQuery[MAX_PATH];
        HSTMT       hstmt;

        if (m_pSQL->AllocStmt(m_hdbc, &hstmt) == SQL_SUCCESS)
        {
            wsprintf((TCHAR *) szQuery, TEXT("delete from Titles where TitleID = %d"), pCDTitle->dwTitleID);
            rc = m_pSQL->ExecDirect(hstmt, szQuery, SQL_NTS);

            wsprintf((TCHAR *) szQuery, TEXT("delete from Tracks where TitleID = %d"), pCDTitle->dwTitleID);
            rc = m_pSQL->ExecDirect(hstmt, szQuery, SQL_NTS);
  
            wsprintf((TCHAR *) szQuery, TEXT("delete from Menus where TitleID = %d"), pCDTitle->dwTitleID);
            rc = m_pSQL->ExecDirect(hstmt, szQuery, SQL_NTS);

            m_pSQL->FreeStmt(hstmt, SQL_DROP);
        }
    } 
}





STDMETHODIMP_(void) CCDData::DestroyTitles(LPCDTITLE *ppCDTitles)
{
    if (ppCDTitles && *ppCDTitles)
    {
        LPCDTITLE pNext;
        LPCDTITLE pCDTitle = *ppCDTitles;

        *ppCDTitles = NULL;

        pNext = pCDTitle;

        while (pCDTitle)
        {
            pNext = pCDTitle->pNext;

            if (pCDTitle->dwLockCnt)        // Someone locked a node that was in memory and have unloaded before unlocking
            {                               // We will abandon the node, it will be destroyed when they unlock it.
                pCDTitle->fLoaded = TRUE;
                pCDTitle->pNext = NULL;
            }
            else
            {
                DestroyTitle(pCDTitle);
            }

            pCDTitle = pNext;
        }
    }
}



STDMETHODIMP_(void) CCDData::SaveTitles(LPCDTITLE *ppCDTitles)
{
    if (ppCDTitles && *ppCDTitles)
    {
        LPCDTITLE pLast = NULL;
        LPCDTITLE pNext;
        LPCDTITLE pCDTitle = *ppCDTitles;

        pNext = pCDTitle;

        while (pCDTitle)
        {
            pNext = pCDTitle->pNext;

            if (pCDTitle->fRemove)
            {
                if (pCDTitle->dwTitleID != DWORD(-1))
                {
                    DBRemoveTitle(pCDTitle);
                }

                if (pLast == NULL)
                {
                    *ppCDTitles = pNext;
                }
                else
                {
                    pLast->pNext = pNext;
                }

                DestroyTitle(pCDTitle);
            }
            else 
            {
                if (pCDTitle->fChanged)
                {
                    DBSaveTitle(pCDTitle);
                    pCDTitle->fChanged = FALSE;
                }

                pLast = pCDTitle;
            }

            pCDTitle = pNext;
        }
    }
}





STDMETHODIMP_(void) CCDData::AddTitle(LPCDTITLE *ppCDTitles, LPCDTITLE pCDNewTitle)
{
    if (ppCDTitles && pCDNewTitle)
    {
        if (*ppCDTitles == NULL)        // Inserting into empty list
        {
            *ppCDTitles = pCDNewTitle;
            pCDNewTitle->pNext = NULL;
        }
        else                            // Insertion sort based on artist name (for view by artist feature)
        {
            LPCDTITLE pCDTitle = *ppCDTitles;
            LPCDTITLE pLast = NULL;
            TCHAR *szArtist = pCDNewTitle->szArtist;

            while (pCDTitle)
            {
                if (lstrcmp(pCDTitle->szArtist, szArtist) >= 0) // we'll only sort by artist, the tree control will sort titles for us
                {
                    if (pLast == NULL)              // insert at head of list
                    {
                        pCDNewTitle->pNext = *ppCDTitles;
                        *ppCDTitles = pCDNewTitle;
                    }
                    else
                    {
                        pCDNewTitle->pNext = pCDTitle;
                        pLast->pNext = pCDNewTitle;
                    }
                    
                    break;             
                }  
              
                if (pCDTitle->pNext == NULL)        // Insert on end of list
                {
                    pCDTitle->pNext = pCDNewTitle;
                    pCDNewTitle->pNext = NULL;
                    break;
                }

                pLast = pCDTitle;
                pCDTitle = pCDTitle->pNext;
            }
        }
    }
}


STDMETHODIMP_(LPCDTITLE) CCDData::GetTitleList(void)
{
    LPCDTITLE pCDTitle;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        pCDTitle = m_pTitleList;
    }

    Leave();

    return(pCDTitle);
}




STDMETHODIMP_(DWORD) CCDData::GetNumBatched(void)
{
    DWORD dwCount = 0;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (m_pBatchList == NULL)       // Batch Not in memory, just query Batch database directly
        {
            dwCount = GetNumRows((UCHAR *) gszBatchTable);
        }
        else                            
        {
            LPCDBATCH pCDBatch = m_pBatchList;

            while (pCDBatch)
            {
                if (!pCDBatch->fRemove)
                {
                    dwCount++;
                }
            
                pCDBatch = pCDBatch->pNext;
            }
        }
    }

    Leave();

    return(dwCount);
}




STDMETHODIMP_(BOOL) CCDData::FindBatchTitle(LPCDBATCH pCDBatchList, DWORD dwTitleID)
{
    BOOL        fFound = FALSE;
    LPCDBATCH   pCDBatch = pCDBatchList;

    while (pCDBatch)
    {
        if (pCDBatch->dwTitleID == dwTitleID)
        {
            if (!pCDBatch->fRemove)
            {
                fFound = TRUE;
            }

            break;
        }
        
        pCDBatch = pCDBatch->pNext;
    }

    return(fFound);
}



STDMETHODIMP_(BOOL) CCDData::QueryBatch(DWORD dwTitleID)
{
    BOOL        fFound = FALSE;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (m_pBatchList == NULL)       // Batch Not in memory, just query Batch database directly
        {
            fFound = QueryDatabase(dwTitleID, gszBatchTable);
        }
        else                            // Batch is in memory, just look here.
        {
            fFound = FindBatchTitle(m_pBatchList, dwTitleID);
        }
    }

    Leave();

    return(fFound);
}


STDMETHODIMP CCDData::ExtractBatch(LPCDBATCH *ppCDBatchList, HWND hWnd)
{
    HRESULT     hr = E_FAIL;
    LPCDBATCH   pCDBatch= NULL;
    TIMEDMETER  tm;

    InitCBTable(&m_bd);
    SetCursors(m_hstmt);
    SetBindings(m_hstmt, &m_bd);

    if (ppCDBatchList == NULL || m_henv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        RETCODE rc;
        DWORD dwCount = GetNumRows((UCHAR *) gszBatchTable);

        CreateMeter(&tm, hWnd, dwCount, 100, 0);

        dwCount = 0;

        rc = m_pSQL->ExecDirect(m_hstmt[3], (UCHAR *) TEXT("select * from Batch"), SQL_NTS);

        if (rc == SQL_SUCCESS)
        {
            m_bd.szQuery[0] = TEXT('\0');

            while (m_pSQL->Fetch(m_hstmt[3]) == SQL_SUCCESS)
            {
                pCDBatch = new CDBATCH;

                if (pCDBatch == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
                else
                {
                    DWORD dwSize = lstrlen(m_bd.szQuery) + 1;
                    
                    pCDBatch->szTitleQuery = new(TCHAR[dwSize]);
                    
                    if (pCDBatch->szTitleQuery == NULL)
                    {
                        delete pCDBatch;
                        hr = E_OUTOFMEMORY;
                        break;
                    }  
                    else
                    {
                        lstrcpy(pCDBatch->szTitleQuery, m_bd.szQuery);
                        pCDBatch->dwTitleID = m_bd.CDTitle.dwTitleID;
                        pCDBatch->dwNumTracks = m_bd.CDTitle.dwNumTracks;
                        pCDBatch->fRemove = FALSE;
                        pCDBatch->fFresh = TRUE;
                        pCDBatch->pNext = *ppCDBatchList;
                        *ppCDBatchList = pCDBatch;
                        
                        m_bd.szQuery[0] = TEXT('\0');
                        UpdateMeter(&tm);
                        hr = S_OK;
                    }
                }
            }

            m_pSQL->FreeStmt(m_hstmt[3], SQL_CLOSE);
        }

        DestroyMeter(&tm);
    }

    return(hr);
}








STDMETHODIMP CCDData::LoadBatch(HWND hWnd, LPCDBATCH *ppCDBatchList)
{
    HRESULT hr = E_FAIL;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (ppCDBatchList)
        {
            if (m_pBatchList == NULL)
            {
                hr = ExtractBatch(&m_pBatchList, hWnd);

                if (SUCCEEDED(hr))
                {
                    m_dwBatchCnt++;
                    *ppCDBatchList = m_pBatchList;
                }
            }
        }
    }

    Leave();

    return(hr);
}





STDMETHODIMP_(void) CCDData::DeleteBatch(LPCDBATCH pCDBatch)
{
    RETCODE     rc;
    UCHAR       szQuery[MAX_PATH];
    HSTMT       hstmt;

    if (pCDBatch->fRemove)
    {
        if (m_pSQL->AllocStmt(m_hdbc, &hstmt) == SQL_SUCCESS)
        {
            wsprintf((TCHAR *) szQuery, TEXT("delete from Batch where TitleID = %d"), pCDBatch->dwTitleID);
            rc = m_pSQL->ExecDirect(hstmt, szQuery, SQL_NTS);

            m_pSQL->FreeStmt(hstmt, SQL_DROP);
        }
    }

    if (pCDBatch->szTitleQuery)
    {
        delete pCDBatch->szTitleQuery;
    }

    delete pCDBatch;
}






STDMETHODIMP_(void) CCDData::DestroyBatch(LPCDBATCH *ppCDBatchList)
{
    if (ppCDBatchList && *ppCDBatchList)
    {
        LPCDBATCH pNext;
        LPCDBATCH pCDBatch = *ppCDBatchList;

        *ppCDBatchList = NULL;

        while (pCDBatch)
        {
            pNext = pCDBatch->pNext;           
            DeleteBatch(pCDBatch);
            pCDBatch = pNext;
        }
    }
}




STDMETHODIMP CCDData::UnloadBatch(LPCDBATCH pCDBatchList)
{    
    HRESULT hr = E_FAIL;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (pCDBatchList == m_pBatchList && m_dwBatchCnt)
        {
            m_dwBatchCnt--;

            if (m_dwBatchCnt == 0)
            {
                DestroyBatch(&m_pBatchList);
            }

            hr = S_OK;
        }
    }
    
    Leave();
    
    return(hr);
}







STDMETHODIMP CCDData::DumpBatch(void)
{
    HRESULT hr = E_FAIL;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (m_dwBatchCnt == 0)
        {
            HSTMT       hstmt;

            if (m_pSQL->AllocStmt(m_hdbc, &hstmt) == SQL_SUCCESS)
            {
                m_pSQL->ExecDirect(hstmt, (UCHAR *) TEXT("drop table Batch"), SQL_NTS);
                m_pSQL->ExecDirect(hstmt, (UCHAR *) gszBatchCreate, SQL_NTS);
                m_pSQL->FreeStmt(hstmt, SQL_CLOSE); 

                m_pSQL->FreeStmt(hstmt, SQL_DROP);

                hr = S_OK;
            }
        }
    }

    Leave();

    return (hr);
}


STDMETHODIMP_(void) CCDData::RemoveFromBatch(DWORD dwTitleID)
{
    if (QueryBatch(dwTitleID))
    {
        if (m_pBatchList)
        {
            LPCDBATCH pBatch = m_pBatchList;

            while(pBatch)
            {
                if (pBatch->dwTitleID == dwTitleID)
                {
                    pBatch->fRemove = TRUE;
                    break;
                }

                pBatch = pBatch->pNext;
            }
        }
        else
        {
            RETCODE     rc;
            UCHAR       szQuery[MAX_PATH];
            HSTMT       hstmt;

            if (m_pSQL->AllocStmt(m_hdbc, &hstmt) == SQL_SUCCESS)
            {
                wsprintf((TCHAR *) szQuery, TEXT("delete from Batch where TitleID = %d"), dwTitleID);
                rc = m_pSQL->ExecDirect(hstmt, szQuery, SQL_NTS);

                m_pSQL->FreeStmt(hstmt, SQL_DROP);
            }
        }
    }
}



STDMETHODIMP CCDData::AddToBatch(DWORD dwTitleID, TCHAR *szTitleQuery, DWORD dwNumTracks)
{
    HRESULT hr = E_FAIL;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (!QueryBatch(dwTitleID) && szTitleQuery && (UINT)lstrlen(szTitleQuery) < (sizeof(m_bd.szQuery)/sizeof(TCHAR))) 
        {
            RETCODE     rc;
            DWORD       dwIndex;
            UDWORD      row;
            UWORD       rgfRowStat[ROWSET];

            InitCBTable(&m_bd);
            SetCursors( m_hstmt );
            SetBindings( m_hstmt, &m_bd);

            m_pSQL->SetConnectOption(m_hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_OFF);

            rc = m_pSQL->ExecDirect(m_hstmt[3], (UCHAR *) TEXT("select * from Batch"), SQL_NTS);
            ReportError(&m_bd, m_hstmt[3]);

            rc = m_pSQL->ExtendedFetch(m_hstmt[3], SQL_FETCH_LAST, 1, &row, rgfRowStat);
            ReportError(&m_bd, m_hstmt[3]);

            InitCBTable(&m_bd);
            m_bd.CDTitle.dwTitleID = dwTitleID;
            m_bd.CDTitle.dwNumTracks = dwNumTracks;
        
            lstrcpy(m_bd.szQuery, szTitleQuery);

            rc = m_pSQL->SetPos(m_hstmt[3], 0, SQL_ADD, SQL_LOCK_NO_CHANGE);
 //           ReportError(&m_bd, m_hstmt[3]);

            rc = m_pSQL->Transact(SQL_NULL_HENV, m_hdbc, SQL_COMMIT);
//            ReportError(&m_bd, m_hstmt[3]);

            m_pSQL->SetConnectOption(m_hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_ON);

            for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
            {
                m_pSQL->FreeStmt(m_hstmt[dwIndex], SQL_CLOSE);
            }

            hr = S_OK;
        }
    }

    Leave();

    return(hr);
}

STDMETHODIMP_(BOOL) CCDData::IsOldFormat()
{
    BOOL fResult = FALSE;
    TCHAR szName[MAX_PATH];
    SQLSMALLINT nName;
    SQLSMALLINT sqlType;
    SQLUINTEGER dwColDef;
    SQLSMALLINT ibScale;
    SQLSMALLINT fNullable;

    RETCODE rc = SQL_SUCCESS;

    rc = m_pSQL->ExecDirect(m_hstmt[0], (UCHAR *) TEXT("select * from Titles"), SQL_NTS);

    if (SQL_SUCCEEDED(rc))
    {
        //check "artist" and "titlequery" columns to find out if this is an old-format db.
        //if either is the old type, then this is an old-format db
        rc = m_pSQL->DescribeCol(m_hstmt[0], 2, (UCHAR*)(&szName), sizeof(szName), &nName, &sqlType, &dwColDef, &ibScale, &fNullable);
        if (SQL_SUCCEEDED(rc))
        {
            if (sqlType != SQL_LONGCHAR_FIELD)
            {
                fResult = TRUE;
            }
        }

        rc = m_pSQL->DescribeCol(m_hstmt[0], 10, (UCHAR*)(&szName), sizeof(szName), &nName, &sqlType, &dwColDef, &ibScale, &fNullable);
        if (SQL_SUCCEEDED(rc))
        {
            if (sqlType == SQL_C_BINARY)
            {
                fResult = TRUE;
            }
        }
    }

    m_pSQL->FreeStmt(m_hstmt[0],SQL_CLOSE);

    return (fResult);
}

STDMETHODIMP CCDData::UpgradeDatabase(HWND hWnd)
{
    HRESULT hr = S_OK;
    HSTMT hstmt = NULL;
    TIMEDMETER tm;

    DWORD dwCount =   GetNumRows((UCHAR *) gszTitleTable)
                    + GetNumRows((UCHAR *) gszBatchTable);

    //steps:
    //1. Read values from old version of database
    //2. Delete the original database
    //3. Create new database with correct data types
    //4. Put data into new database
    //5. Clean up

    //Step 1: Read values from old version of database
    LPCDBATCH pBatchList = NULL;
    LoadTitles(hWnd); //(also gets tracks and menus)
    LoadBatch(hWnd,&pBatchList);

    //Step 2: Delete the original database
    CloseDatabase();

    TCHAR szFileName[MAX_PATH];
    GetWindowsDirectory(szFileName,sizeof(szFileName)/sizeof(TCHAR));
    _tcscat(szFileName,TEXT("\\DeluxeCD.MDB"));

    DeleteFile(szFileName);

    //Step 3: Create new database with correct data types
    CreateDatabase();
    ConnectToDatabase(ODBC_CONFIG_DSN);

    //Step 4: Put data into new database
    CreateMeter(&tm, hWnd, dwCount, 5,  IDS_IMPORTING);

    //put all the titles into the new db
    LPCDTITLE pCDTitle = m_pTitleList;
    while (pCDTitle)
    {
        DBSaveTitle(pCDTitle);
        UpdateMeter(&tm);
        pCDTitle = pCDTitle->pNext;
    }

    //put all the batches into the new db
    LPCDBATCH pBatch = pBatchList;
    while (pBatch)
    {
        AddToBatch(pBatch->dwTitleID,pBatch->szTitleQuery,pBatch->dwNumTracks);
        pBatch->fRemove = FALSE;
        UpdateMeter(&tm);
        pBatch = pBatch->pNext;
    }
   
    //Step 5: Clean up
    UnloadBatch(pBatchList);
    DestroyMeter(&tm);

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\cdread.cpp ===
// cdread.cpp
//

#include <windows.h>
#include <windowsx.h>
#include <TCHAR.H>
#include <mmsystem.h>
#include "cdread.h"
#include "cddata.h"
#include "..\main\resource.h"
#include "..\main\sink.h"
#include "mmreg.h"
#include "msacm.h"

HANDLE hFile = NULL;
LPCDDATA pData = NULL;
TIMEDMETER  tm;
DWORD dwTotalBytes = 0;
WAVEFORMATEX wfxPCM1, wfxPCM2;

DWORD cbOutBytes[3];
HACMSTREAM acmStream[3];
ACMSTREAMHEADER acmHeader[3];
BYTE sSample[CDDA_SECTOR_SIZE * SECTORS_PER_READ];
BYTE sCompBuffer[CDDA_SECTOR_SIZE * SECTORS_PER_READ];

// Write a WAV header for the selected format
BOOL writeHeader(int iSize, LPWAVEFORMATEX lpwfx)
{
    DWORD dwBytesWritten = 0;
	unsigned data, formatdata;
	WORD wData;

    WriteFile(hFile,"RIFF",4,&dwBytesWritten,NULL);

	formatdata = 16;

    if ((lpwfx->wFormatTag != WAVE_FORMAT_PCM) && (lpwfx->cbSize > 0))
    {
        formatdata += sizeof(WORD); //to write cdSize out
        formatdata += lpwfx->cbSize;
    }

	data = 0x24 + iSize + (formatdata-16);
    WriteFile(hFile,&data,sizeof(unsigned),&dwBytesWritten,NULL);
    WriteFile(hFile,"WAVE",4,&dwBytesWritten,NULL);
    WriteFile(hFile,"fmt ",4,&dwBytesWritten,NULL);

    WriteFile(hFile,&formatdata,sizeof(unsigned),&dwBytesWritten,NULL);

    WriteFile(hFile,lpwfx,formatdata,&dwBytesWritten,NULL);

	/*
    wData = lpwfx->wFormatTag;
    WriteFile(hFile,&wData,sizeof(WORD),&dwBytesWritten,NULL);

	wData = lpwfx->nChannels;
    WriteFile(hFile,&wData,sizeof(WORD),&dwBytesWritten,NULL);

	data = lpwfx->nSamplesPerSec;
    WriteFile(hFile,&data,sizeof(unsigned),&dwBytesWritten,NULL);

	data = lpwfx->nAvgBytesPerSec;
    WriteFile(hFile,&data,sizeof(unsigned),&dwBytesWritten,NULL);

	wData = lpwfx->nBlockAlign;
    WriteFile(hFile,&wData,sizeof(WORD),&dwBytesWritten,NULL);

	wData = lpwfx->wBitsPerSample;
    WriteFile(hFile,&wData,sizeof(WORD),&dwBytesWritten,NULL);

    if ((lpwfx->wFormatTag != WAVE_FORMAT_PCM) && (lpwfx->cbSize > 0))
    {
	    wData = lpwfx->cbSize;
        WriteFile(hFile,&wData,sizeof(WORD),&dwBytesWritten,NULL);
        
        pData = (BYTE*)(&(lpwfx->cbSize) + sizeof(WORD));
        WriteFile(hFile,pData,lpwfx->cbSize,&dwBytesWritten,NULL);
    }
    */

    WriteFile(hFile,"data",4,&dwBytesWritten,NULL);

	data = iSize;
    WriteFile(hFile,&data,sizeof(unsigned),&dwBytesWritten,NULL);

	return TRUE;
}


BOOL readTOC( HANDLE hDevice, PCDROM_TOC pToc )
{
    DWORD dwTocSize = sizeof(CDROM_TOC);
    DWORD dwBytesReturned  = 0;
    DWORD dwNumTracks = 0;
	
    if( !DeviceIoControl( hDevice,
                          IOCTL_CDROM_READ_TOC,
                          pToc,             // pointer to inputbuffer
                          dwTocSize,         // sizeof inputbuffer
                          pToc,             // pointer to outputbuffer
                          dwTocSize,         // sizeof outputbuffer
                          &dwBytesReturned,  // pointer to number of bytes returned
                          FALSE         
                          )
        ) 
	{
        return FALSE;
    }

    dwNumTracks = pToc->LastTrack - pToc->FirstTrack;

    //
    // number of tracks plus zero-based plus leadout track
    //

    if ( (dwNumTracks+2) * sizeof(TRACK_DATA) != dwBytesReturned - 4 )
    {
        dwNumTracks = (dwBytesReturned - 4) / sizeof(TRACK_DATA);
    }

    // parse and print the information

    PTRACK_DATA pTrack = (PTRACK_DATA) &(pToc->TrackData[0]);

    return TRUE;
}

BOOL skipRead( BYTE* buffer, DWORD dwSize, int iPercent )
{
	return TRUE;
}

BOOL writeRead( BYTE* buffer, DWORD dwSize, int iPercent )
{
    DWORD dwBytesWritten = 0;

    if (pData)
    {
        pData->UpdateMeter(&tm);
    }

    acmStreamConvert(acmStream[0],&acmHeader[0],0);
    acmStreamConvert(acmStream[1],&acmHeader[1],0);
    acmStreamConvert(acmStream[2],&acmHeader[2],0);

    WriteFile(hFile,sCompBuffer,acmHeader[2].cbDstLengthUsed,&dwBytesWritten,NULL);

    dwTotalBytes += dwBytesWritten;

	return TRUE;
}

BOOL rawReadTrack(HANDLE device, PCDROM_TOC pTOC, int iTrack, LPREADFUNC lpReadFunc )
{

    RAW_READ_INFO info;    // fill in for the read request
    DWORD   dwBytesRead; // bytes returned
    DWORD   dwStartingLBA;
    DWORD   dwNumLBA;
    DWORD   dwEndingLBA;
	DWORD   dwSectorsToRead;
	DWORD   dwError;
	PTRACK_DATA pTrack = (PTRACK_DATA) &(pTOC->TrackData[0]);
	PTRACK_DATA pTrack2;

	// Use VirtualAlloc so we get a page-aligned region since we're doing 
	// non-cached IO
/*
	sSample = (BYTE*)VirtualAlloc(NULL, PAGE_VAL, MEM_COMMIT, PAGE_READWRITE );
	if( !sSample )
	{
		//MessageBox( NULL, "Error allocating memory block.", "Error", MB_OK );
        return FALSE;
	}
*/

	pTrack += (iTrack-1);
	pTrack2 = pTrack + 1;

	dwStartingLBA = MSF_TO_LBA( pTrack->Address[1], pTrack->Address[2], pTrack->Address[3] );
	dwEndingLBA = MSF_TO_LBA( pTrack2->Address[1], pTrack2->Address[2], pTrack2->Address[3] );
	dwNumLBA = dwEndingLBA-dwStartingLBA;

    //
    // round up the num sectors to read
    //
    dwSectorsToRead = ((dwNumLBA - 1) / SECTORS_PER_READ + 1) * SECTORS_PER_READ;
    dwEndingLBA  = dwStartingLBA + dwSectorsToRead;

	// start the read loop
    for ( DWORD i = dwStartingLBA; i < dwEndingLBA; i += SECTORS_PER_READ )
    {
		int iPercent;

        info.DiskOffset.QuadPart = (unsigned __int64)(i*2048);
        info.SectorCount         = SECTORS_PER_READ;
        info.TrackMode           = CDDA;

        if( !DeviceIoControl( device,
                              IOCTL_CDROM_RAW_READ,
                              &info,                    // pointer to inputbuffer
                              sizeof(RAW_READ_INFO),    // sizeof inputbuffer
                              sSample,                   // pointer to outputbuffer
                              CDDA_SECTOR_SIZE * SECTORS_PER_READ, // sizeof outputbuffer
                              &dwBytesRead,           // pointer to number of bytes returned
                              FALSE                     // ???
                              )
            )
        {
			goto fail;
        }

		iPercent = (i-dwStartingLBA)/(dwEndingLBA-dwStartingLBA);

		if( !((*lpReadFunc)(sSample, dwBytesRead, iPercent) ) )
		{
			goto fail;
		}
    }

	//VirtualFree( sSample, PAGE_VAL, MEM_DECOMMIT );
	return TRUE;

fail:
	VirtualFree( sSample, PAGE_VAL, MEM_DECOMMIT );
	return FALSE;

}

// Find the byte size of a track
int getTrackSize( PCDROM_TOC pTOC, int iTrack )
{
	PTRACK_DATA pTrack = &(pTOC->TrackData[0]);
	DWORD dwLBA1, dwLBA2;

	pTrack += (iTrack-1);
    dwLBA1 = MSF_TO_LBA( pTrack->Address[1], pTrack->Address[2], pTrack->Address[3] );
	pTrack++;
    dwLBA2 = MSF_TO_LBA( pTrack->Address[1], pTrack->Address[2], pTrack->Address[3] );

	return (dwLBA2-dwLBA1) * CDDA_SECTOR_SIZE;
}	

BOOL StoreTrack(HWND hwndMain, TCHAR chDrive, int nTrack, TCHAR* pszFilename, LPWAVEFORMATEX lpwfxDest)
{
	HANDLE hDevice;
	TCHAR szDeviceName[MAX_PATH];
	CDROM_TOC sTOC;
    
	wsprintf( szDeviceName, TEXT("\\\\.\\%c:"), chDrive );
	hDevice = CreateFile( szDeviceName, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
	if( INVALID_HANDLE_VALUE == hDevice )
	{
		return FALSE;
	}

	readTOC( hDevice, &sTOC );

	int iSize = getTrackSize( &sTOC, nTrack );
    dwTotalBytes = 0;

    WAVEFORMATEX waveFormat;

    waveFormat.wFormatTag = WAVE_FORMAT_PCM;
    waveFormat.nChannels = 2;
    waveFormat.nSamplesPerSec = 44100;
    waveFormat.nAvgBytesPerSec = 176400;
    waveFormat.nBlockAlign = 4;
    waveFormat.wBitsPerSample = 16;
    waveFormat.cbSize = sizeof(waveFormat);

    wfxPCM1.wFormatTag      = WAVE_FORMAT_PCM;
    acmFormatSuggest(NULL, &waveFormat, &wfxPCM1, sizeof(WAVEFORMATEX),
                           ACM_FORMATSUGGESTF_WFORMATTAG);

    wfxPCM2.wFormatTag      = WAVE_FORMAT_PCM;
    acmFormatSuggest(NULL, lpwfxDest, &wfxPCM2, sizeof(WAVEFORMATEX),
                           ACM_FORMATSUGGESTF_WFORMATTAG);

    acmStreamOpen(&acmStream[0],NULL,&waveFormat,&wfxPCM1,NULL,NULL,0,ACM_STREAMOPENF_NONREALTIME);
    acmStreamOpen(&acmStream[1],NULL,&wfxPCM1,&wfxPCM2,NULL,NULL,0,ACM_STREAMOPENF_NONREALTIME);
    acmStreamOpen(&acmStream[2],NULL,&wfxPCM2,lpwfxDest,NULL,NULL,0,ACM_STREAMOPENF_NONREALTIME);

    acmStreamSize(acmStream[0],CDDA_SECTOR_SIZE * SECTORS_PER_READ,&cbOutBytes[0],ACM_STREAMSIZEF_SOURCE);
    acmStreamSize(acmStream[1],CDDA_SECTOR_SIZE * SECTORS_PER_READ,&cbOutBytes[1],ACM_STREAMSIZEF_SOURCE);
    acmStreamSize(acmStream[2],CDDA_SECTOR_SIZE * SECTORS_PER_READ,&cbOutBytes[2],ACM_STREAMSIZEF_SOURCE);

    acmHeader[0].cbStruct = sizeof(acmHeader);
    acmHeader[0].fdwStatus = 0;
    acmHeader[0].dwUser = 0;
    acmHeader[0].pbSrc = sSample;
    acmHeader[0].cbSrcLength = CDDA_SECTOR_SIZE * SECTORS_PER_READ;
    acmHeader[0].pbDst = sCompBuffer;
    acmHeader[0].cbDstLength = cbOutBytes[0];
    acmHeader[0].dwDstUser = 0;

    acmHeader[1].cbStruct = sizeof(acmHeader);
    acmHeader[1].fdwStatus = 0;
    acmHeader[1].dwUser = 0;
    acmHeader[1].pbSrc = sCompBuffer;
    acmHeader[1].cbSrcLength = cbOutBytes[0];
    acmHeader[1].pbDst = sSample;
    acmHeader[1].cbDstLength = cbOutBytes[1];
    acmHeader[1].dwDstUser = 0;

    acmHeader[2].cbStruct = sizeof(acmHeader);
    acmHeader[2].fdwStatus = 0;
    acmHeader[2].dwUser = 0;
    acmHeader[2].pbSrc = sSample;
    acmHeader[2].cbSrcLength = cbOutBytes[1];
    acmHeader[2].pbDst = sCompBuffer;
    acmHeader[2].cbDstLength = cbOutBytes[2];
    acmHeader[2].dwDstUser = 0;

    acmStreamPrepareHeader(acmStream[0],&acmHeader[0],0);
    acmStreamPrepareHeader(acmStream[1],&acmHeader[1],0);
    acmStreamPrepareHeader(acmStream[2],&acmHeader[2],0);

    hFile = CreateFile(pszFilename,GENERIC_WRITE,FILE_SHARE_WRITE,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);

    //write a temp header. we'll need to write a new one later when we know the right file size
	if( !writeHeader( iSize, lpwfxDest ) )
	{
		CloseHandle( hFile );
		return FALSE;
	}

    pData = GetCDData();

    if (pData)
    {
        pData->CreateMeter(&tm,hwndMain,(iSize / (CDDA_SECTOR_SIZE * SECTORS_PER_READ)),5,IDS_RIPPING_CD);
    }

	rawReadTrack( hDevice, &sTOC, nTrack, writeRead );

    if (pData)
    {
        pData->DestroyMeter(&tm);
    }

    acmStreamUnprepareHeader(acmStream[0],&acmHeader[0],0);
    acmStreamUnprepareHeader(acmStream[1],&acmHeader[1],0);
    acmStreamUnprepareHeader(acmStream[2],&acmHeader[2],0);

    acmStreamClose(acmStream[0],0);
    acmStreamClose(acmStream[1],0);
    acmStreamClose(acmStream[2],0);

	CloseHandle( hDevice );

    SetFilePointer(hFile,0,NULL,FILE_BEGIN);

	if( !writeHeader( dwTotalBytes, lpwfxDest ) )
	{
		CloseHandle( hFile );
		return FALSE;
	}

	CloseHandle( hFile );

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\cdopti.h ===
//--------------------------------------------------------------------------;
//
//  File: cdopti.h  (internal to this module)
//
//  CD Player Plus! options Dialog.
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;

#ifndef _CDOPTINTERNAL_PUBLICINTEFACES_
#define _CDOPTINTERNAL_PUBLICINTEFACES_

#include "optres.h"
#include "cdopt.h"

// Intro time range (for CDOPTS.dwIntroTime)
#define CDINTRO_MIN_TIME    (1)
#define CDINTRO_MAX_TIME    (20)

// Default values

#define CDDEFAULT_INTRO             (5)
#define CDDEFAULT_DISP              CDDISP_TRACKTIME
#define CDDEFAULT_START             TRUE
#define CDDEFAULT_EXIT              TRUE
#define CDDEFAULT_TOP               FALSE
#define CDDEFAULT_TRAY              FALSE
#define CDDEFAULT_PLAY              (0)
#define CDDEFAULT_DOWNLOADENABLED   TRUE
#define CDDEFAULT_DOWNLOADPROMPT    TRUE
#define CDDEFAULT_BATCHENABLED      TRUE
#define CDDEFAULT_BYARTIST          FALSE
#define CDDEFAULT_CONFIRMUPLOAD     TRUE




#endif  //_CDOPTINTERNAL_PUBLICINTEFACES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\optres.h ===
////////////////////////////////////////////
//
// Resource ID's for cdopt.h
//
////////////////////////////////////////////

#define IDS_CDOPTIONS                   1
#define IDS_SECONDS                     2
#define IDS_CDTITLES                    3
#define IDS_OTHERTITLES                 4
#define IDS_ARTIST                      5
#define IDS_TITLE                       6
#define IDS_PLAYLIST                    7
#define IDS_NODISC                      8
#define IDS_UNKNOWNTITLE                9
#define IDS_UNKNOWNARTIST               10
#define IDS_BYARTIST                    11
#define IDS_BYTITLE                     12
#define IDS_ALERTTEXT                   13
#define IDS_SAVEPROMPT                  14
#define IDS_COLLAPSE                    15
#define IDS_CREATEPLAYLIST              16
#define IDS_EDITPLAYLIST                17
#define IDS_BATCHTEXT                   18
#define IDS_TRACK                       19
#define IDS_DOWNLOADING                 20
#define IDS_NEWARTIST                   21
#define IDS_NEWTITLE                    22
#define IDS_IMPORTING                   23
#define IDS_ERROR_NO_ODBC               24
#define IDS_ERROR_SETUP                 25
#define IDS_SECOND                      26
#define IDS_ERROR_NOUPLOAD              27
#define IDS_ERROR_PARTUPLOAD            28
#define IDS_UPLOAD_SUCCESS              29
#define IDS_UPLOAD_STATUS               30
#define IDS_CACHEDTITLES                31

#define IDD_WEBCD                       101
#define IDD_CDPLAYEROPTIONS             102
#define IDI_CD                          103
#define IDD_CDPLAYLISTS                 105
#define IDD_CDHOST                      106
#define IDD_MIXERPICKER                 107
#define IDD_LOADSTATUS                  108
#define IDR_TITLEMENU                   109
#define IDI_SMALLCD                     110
#define IDI_CDSTACK                     111
#define IDI_NODISC                      112
#define IDI_TITLECLOSED                 113
#define IDI_TITLEOPEN                   114
#define IDI_CDCOLLECTION                115
#define IDI_SONG                        116
#define IDI_CDVOLUME                    117
#define IDD_DIALOG_PLAYLIST             118
#define IDD_DIALOG_UPLOAD               119
#define IDD_UPLOAD_CONFIRM              120
#define IDD_CDTITLEOPTIONS              121
#define IDI_CDQUESTION                  122
#define IDR_INSERT                      123

#define IDAPPLY                         1000
#define IDC_STARTPLAY                   1001
#define IDC_EXITSTOP                    1002
#define IDC_TOPMOST                     1003
#define IDC_CDTIME                      1004
#define IDC_TRACKTIME                   1005
#define IDC_TRACKTIMEREMAIN             1006
#define IDC_CDTIMEREMAIN                1007
#define IDC_INTROTIMESLIDER             1008
#define IDC_INTROTIMETEXT               1009
#define IDC_TITLEPICKER                 1010
#define IDC_DOWNLOADPROMPT              1011
#define IDC_DOWNLOADENABLED             1012
#define IDC_PLAYLISTRESTORE             1013
#define IDC_TITLERESTORE                1014
#define IDC_TITLETEXT                   1015
#define IDC_ARTISTTEXT                  1016
#define IDC_PLAYLIST                    1017
#define IDC_CDOPTIONS                   1018
#define IDC_OPTIONSRESTORE              1019
#define IDC_SETVOLUMECNTL               1020
#define IDC_PROVIDERPICKER              1021
#define IDC_MIXERTREE                   1022
#define IDC_DEFAULTMIXER                1023
#define IDC_BATCHENABLED                1024
#define IDC_CDDRIVE                     1025
#define IDC_AUDIOMIXER                  1026
#define IDC_AUDIOCONTROL                1027
#define IDC_EDITLIST                    1028
#define IDC_EDITPLAYLIST                1029
#define IDC_CDTREE                      1030
#define IDC_PROGRESSMETER               1031
#define IDC_BYARTIST                    1032
#define IDC_BATCHTEXT                   1033
#define IDC_DOWNLOADNOW                 1034
//#define IDC_EDIT_ARTIST                 1035
//#define IDC_EDIT_TITLE                  1036
#define IDC_CURRLIST                    1037
#define IDC_BUTTON_REMOVE               1038
#define IDC_BUTTON_CLEAR                1039
#define IDC_BUTTON_RESET                1040
#define IDC_AVAILTITLES                 1041
#define IDC_AVAILTRACKS                 1042
#define IDC_ADDTOPLAYLIST               1043
#define IDC_VOL_MSG_TEXT                1044
#define IDC_SELECTPLAYER_TEXT           1045
#define IDC_SELECTMIXER_TEXT            1046
#define IDC_SELECTCONTROL_TEXT          1047
#define IDC_VOL_CONFIG_GROUP            1048
#define IDC_PLAYBACK_GROUP              1049
#define IDC_TIMEDISPLAY_GROUP           1050
#define IDC_PREVIEWTIME_GROUP           1051
#define IDC_PREVIEWTIME_TEXT            1052
#define IDC_CURPROVIDER_TEXT            1053
#define IDC_ALBUMBATCH_GROUP            1054
#define IDC_ALBUMINFO_TEXT              1055
#define IDC_DOWNLOAD_GROUP              1056
#define IDC_ALBUMBATCH_TEXT             1057
#define IDC_DATABASE_TEXT               1058
#define IDC_VOLCONFIG_ICON              1059
#define IDC_ARTIST_TEXT                 1060
#define IDC_TITLE_TEXT                  1061
#define IDC_AVAILTRACKS_TEXT            1062
#define IDC_PLAYLIST_TEXT               1063
#define IDC_SEPLINE1                    1064
#define IDC_SEPLINE2                    1065
#define IDC_TRAYENABLE                  1066
#define IDC_UPLOADTITLE                 1067
#define IDC_UPLOADTITLE_TEXT            1068
#define IDC_CONFIRMPROMPT               1069
#define IDC_CONFIRM_TEXT                1070
#define IDC_CDQUESTION                  1071

#define ID_DELETETITLE                  40000
#define ID_EXPAND                       40001
#define ID_EDITTITLENAME                40002
#define ID_EDITTRACKNAME                40003
#define ID_EDITARTISTNAME               40004
#define ID_DOWNLOADTITLE                40005
#define ID_HELPMENU                     40006
#define ID_CACHEALBUM                   40007
#define ID_CACHETRACK                   40008
#define ID_DELETECACHEDALBUM            40009
#define ID_DELETECACHEDTRACK            40010
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\dragdrop.cpp ===
/******************************Module*Header*******************************\
* Module Name: DragDrop.c
*
* An attempt to implement dragging and dropping between Multi-selection
* listboxes.
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#define NOOLE
#define NODRAGLIST

#include "precomp.h"  
#include "cdopti.h"
#include "cdoptimp.h"


#define LONG2POINT(l, pt) ((pt).x = (SHORT)LOWORD(l), \
                           (pt).y = (SHORT)HIWORD(l))



#define DF_ACTUALLYDRAG     0x0001
#define DF_DEFERRED         0x0002

#define INITLINESPERSECOND  36
#define VERTCHANGENUMLINES  25

#define TIMERID             238
#define TIMERLEN            250
#define TIMERLEN2           50

#define DX_INSERT           16
#define DY_INSERT           16


typedef struct DRAGPROP
{
    WNDPROC  lpfnDefProc;
    HWND     hwndDrag;
    UINT     uFlags;
    DWORD    dwState;
    CCDOpt * pCDOpt;

} DRAGPROP, *PDRAGPROP;


TCHAR   szDragListMsgString[]   = TEXT(SJE_DRAGLISTMSGSTRING);
TCHAR   szDragProp[]            = TEXT("DragMultiProp");




STDMETHODIMP_(UINT) CCDOpt::InitDragMultiList(void)
{
	if (!m_uDragListMsg) {

        m_uDragListMsg = RegisterWindowMessage(szDragListMsgString);

        if (!m_uDragListMsg) {
            return 0;
        }
    }
    return m_uDragListMsg;
}


STDMETHODIMP_(LRESULT) CCDOpt::DragList(HWND hLB, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PDRAGPROP           pDragProp;
    DRAGMULTILISTINFO   sNotify;
    WNDPROC             lpfnDefProc;
    BOOL                bDragging;

    pDragProp = (PDRAGPROP)GetProp(hLB, szDragProp);
    bDragging = pDragProp->hwndDrag == hLB;

    // Save this in case anything happens to pDragProp before we return.

    lpfnDefProc = pDragProp->lpfnDefProc;

    switch (uMsg) {

    case WM_DESTROY:
        if (bDragging)
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L); // cancel drag


        // Restore the window proc just in case.

        SubclassWindow( hLB, lpfnDefProc );

        if (pDragProp) {
            LocalFree((HLOCAL)pDragProp);
            RemoveProp(hLB, szDragProp);
        }
        break;


    case WM_LBUTTONDOWN:
        {
            POINT pt;
            int nItem;


            if (bDragging)                                // nested button-down
                SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);  // cancel drag

            SetFocus(hLB);

            LONG2POINT(lParam, pt);

            ClientToScreen(hLB, &pt);
            nItem = LBMultiItemFromPt(hLB, pt, FALSE);

            if ( nItem >= 0 ) {

                //
                // We can only allow dragging if the item is selected.
                // If the item is not selected - pass the message on.
                //
                if ( ListBox_GetSel( hLB, nItem ) <= 0 ) {
                    return CallWindowProc( lpfnDefProc, hLB, uMsg,
                                           wParam, lParam );
                }

                pDragProp->dwState = (wParam & MK_CONTROL) ? DG_COPY : DG_MOVE;
                sNotify.uNotification = DG_BEGINDRAG;
                goto QueryParent;

            }
            else {
                goto FakeDrag;
            }
        }


    case WM_TIMER:
        if (wParam != TIMERID) {
            break;
        }

        {
            POINT CursorPos;

            GetCursorPos( &CursorPos );
            ScreenToClient( hLB, &CursorPos );
            lParam = MAKELPARAM((WORD)CursorPos.x, (WORD)CursorPos.y);
        }

        // Fall through

    case WM_MOUSEMOVE:
        if (bDragging) {

            HWND hwndParent;
            LRESULT lRet;

            // We may be just simulating a drag, but not actually doing
            // anything.

            if (!(pDragProp->uFlags&DF_ACTUALLYDRAG)) {
                return(0L);
            }


            if ( pDragProp->uFlags & DF_DEFERRED ) {

                pDragProp->uFlags &= ~DF_DEFERRED;
                KillTimer(hLB, TIMERID);
                SetTimer(hLB, TIMERID, TIMERLEN2, NULL);
            }

            sNotify.uNotification = DG_DRAGGING;

QueryParent:
            hwndParent = GetParent( hLB );
            sNotify.hWnd = hLB;
            sNotify.dwState = pDragProp->dwState;

            LONG2POINT( lParam, sNotify.ptCursor );

            ClientToScreen( hLB, &sNotify.ptCursor );

            lRet = SendMessage( hwndParent, m_uDragListMsg, GetDlgCtrlID(hLB),
                                 (LPARAM)(LPDRAGMULTILISTINFO)&sNotify );

            if ( uMsg == WM_LBUTTONDOWN ) {

                // Some things may not be draggable

                if (lRet) {

                    SetTimer(hLB, TIMERID, TIMERLEN, NULL);
                    pDragProp->uFlags = DF_DEFERRED | DF_ACTUALLYDRAG;
                }
                else {
FakeDrag:
                    pDragProp->uFlags = 0;
                }

                // Set capture and change mouse cursor

                pDragProp->hwndDrag = hLB;
                SetCapture( hLB );
            }

            // Don't call the def proc, since it may try to change the
            // selection or set timers or things like that.

            return 0L;
       }
       break;


    case  WM_RBUTTONDOWN:
    case  WM_LBUTTONUP:

        // if we are capturing mouse - release it and check for an
        // acceptable place where mouse is now to decide drop or not

        if (bDragging) {

            HWND hwndParent;

            pDragProp->hwndDrag = NULL;
            KillTimer(hLB, TIMERID);
            ReleaseCapture();
            SetCursor(LoadCursor(NULL, IDC_ARROW));

            hwndParent = GetParent(hLB);

            sNotify.uNotification = (uMsg == WM_LBUTTONUP)
                                        ? DG_DROPPED : DG_CANCELDRAG;
            sNotify.hWnd = hLB;
            sNotify.dwState = pDragProp->dwState;

            LONG2POINT( lParam, sNotify.ptCursor );

            ClientToScreen( hLB, &sNotify.ptCursor );

            SendMessage( hwndParent, m_uDragListMsg, GetDlgCtrlID(hLB),
                         (LPARAM)(LPDRAGMULTILISTINFO)&sNotify);

            //
            // If we didn't actually do any dragging just fake a button
            // click at the current location.
            //
            if ( pDragProp->uFlags & DF_DEFERRED ) {
                CallWindowProc(lpfnDefProc, hLB, WM_LBUTTONDOWN, wParam, lParam);
                CallWindowProc(lpfnDefProc, hLB, uMsg, wParam, lParam);
            }

            // We need to make sure to return 0 in case this is from a
            // keyboard message.

            return 0L;
        }
        break;


    case WM_GETDLGCODE:
        if (bDragging)
            return (CallWindowProc(lpfnDefProc, hLB, uMsg, wParam, lParam)
                    | DLGC_WANTMESSAGE);
        break;


    case WM_KEYDOWN:
        if (wParam == VK_ESCAPE) {
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);
        }
    case WM_CHAR:
    case WM_KEYUP:

        // We don't want the listbox processing this if we are dragging.

        if (bDragging)
            return 0L;
        break;

    default:
        break;
    }

    return CallWindowProc(lpfnDefProc, hLB, uMsg, wParam, lParam);
}

LRESULT CALLBACK CCDOpt::DragListProc(HWND hLB, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PDRAGPROP pDragProp = (PDRAGPROP)GetProp(hLB, szDragProp);

    return(pDragProp->pCDOpt->DragList(hLB, uMsg, wParam, lParam));
}



STDMETHODIMP_(BOOL) CCDOpt::MakeMultiDragList(HWND hLB)
{
    PDRAGPROP pDragProp;

    if (!m_uDragListMsg) {

        return FALSE;
    }

    //
    // Check that we have not already subclassed this window.
    //

    if (GetProp(hLB, szDragProp)) {
        return TRUE;
    }

    pDragProp = (PDRAGPROP)LocalAlloc(LPTR, sizeof(DRAGPROP));
    if (pDragProp == NULL ) {

        return FALSE;
    }

    pDragProp->pCDOpt = this;

    SetProp(hLB, szDragProp, (HANDLE)pDragProp);
    pDragProp->lpfnDefProc = SubclassWindow( hLB, DragListProc );

    return TRUE;
}



STDMETHODIMP_(int) CCDOpt::LBMultiItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll)
{
    static LONG dwLastScroll = 0;

    RECT    rc;
    DWORD   dwNow;
    int     nItem;
    WORD    wScrollDelay, wActualDelay;

    ScreenToClient(hLB, &pt);
    GetClientRect(hLB, &rc);

    nItem = ListBox_GetTopIndex( hLB );

    //
    // Is the point in the LB client area?
    //

    if ( PtInRect(&rc, pt) ) {

        //
        // Check each visible item in turn.
        //

        for ( ; ; ++nItem) {

            if ( LB_ERR == ListBox_GetItemRect( hLB, nItem, &rc) ) {
                break;
            }

            if ( PtInRect(&rc, pt) ) {

                return nItem;
            }
        }
    }
    else {

        //
        // If we want autoscroll and the point is directly above or below the
        // LB, determine the direction and if it is time to scroll yet.
        //

        if ( bAutoScroll && (UINT)pt.x < (UINT)rc.right ) {

            if (pt.y <= 0) {
                --nItem;
            }
            else {

                ++nItem;
                pt.y = rc.bottom - pt.y;
            }

            wScrollDelay = (WORD)(1000 / (INITLINESPERSECOND - pt.y/VERTCHANGENUMLINES));

            dwNow = GetTickCount();
            wActualDelay = (WORD)(dwNow - dwLastScroll);

            if (wActualDelay > wScrollDelay) {

                //
                // This will the actual number of scrolls per second to be
                // much closer to the required number.
                //

                if (wActualDelay > wScrollDelay * 2)
                    dwLastScroll = dwNow;
                else
                    dwLastScroll += wScrollDelay;

                ListBox_SetTopIndex( hLB, nItem );
            }
        }
    }

    return -1;
}


STDMETHODIMP_(void) CCDOpt::DrawMultiInsert(HWND hwndParent, HWND hLB, int nItem)
{
    static POINT ptLastInsert;
    static INT nLastInsert = -1;

    RECT rc;

    //
    // Erase the old mark if necessary
    //

    if ( nLastInsert >= 0 && nItem != nLastInsert ) {

        rc.left   = ptLastInsert.x;
        rc.top    = ptLastInsert.y;
        rc.right  = rc.left + DX_INSERT;
        rc.bottom = rc.top + DY_INSERT;

        //
        // Need to update immediately in case the insert rects overlap.
        //

        InvalidateRect( hwndParent, &rc, TRUE );
        UpdateWindow( hwndParent );

        nLastInsert = -1;
    }

    //
    // Draw a new mark if necessary
    //

    if ( nItem != nLastInsert && nItem >= 0 ) {

        static HICON hInsert = NULL;

        if ( !hInsert ) {
            hInsert = LoadIcon(m_hInst, MAKEINTRESOURCE(IDR_INSERT));
        }

        if ( hInsert ) {

            HDC     hDC;
            int     iItemHeight;

            GetWindowRect( hLB, &rc );
            ScreenToClient( hLB, (LPPOINT)&rc );
            ptLastInsert.x = rc.left - DX_INSERT;

            iItemHeight = ListBox_GetItemHeight( hLB, nItem );
            nLastInsert = nItem;

            nItem -= ListBox_GetTopIndex( hLB );
            ptLastInsert.y = (nItem * iItemHeight) - DY_INSERT / 2;

            ClientToScreen(hLB, &ptLastInsert);
            ScreenToClient(hwndParent, &ptLastInsert);

            hDC = GetDC(hwndParent);
            DrawIcon(hDC, ptLastInsert.x, ptLastInsert.y, hInsert);
            ReleaseDC(hwndParent, hDC);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\dllmain.cpp ===
// DLLMAIN: Entry points for COM object dll


#include "precomp.h"
#include "optres.h"
#include "tchar.h"
#include "cdoptimp.h"
#include "cddata.h"


extern "C"
HRESULT WINAPI CDOPT_CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj)
{
    LPUNKNOWN pObj;
    HRESULT hr = E_OUTOFMEMORY;

    *ppvObj = NULL;

    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
    {
        return CLASS_E_NOAGGREGATION;
    }

    if (IID_ICDData == riid)
    {
        pObj = (LPUNKNOWN) new CCDData();
    }
    else if (IID_ICDOpt == riid)
    {
        pObj = (LPUNKNOWN) new CCDOpt();
    }

    if (NULL==pObj)
    {
        return hr;
    }

    hr = pObj->QueryInterface(riid, ppvObj);

    if (FAILED(hr))
    {
        delete pObj;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\precomp.h ===
/****************************************************************************

    Contains the standard headers

    Copyright (c) Microsoft Corporation	1995
    
    8/11/95 Brian McDowell

*******************************************************************************/

#include <windows.h>
#include <ole2.h>
#include <windowsx.h>
#include <stdlib.h>
#include <math.h> 
#include <io.h>
#include <fcntl.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <memory.h>
#include <commctrl.h>
#include <prsht.h>
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\playlist.cpp ===
//--------------------------------------------------------------------------;
//
//  File: playlist.cpp
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;

#include "precomp.h"  
#include "cdopti.h"
#include "cdoptimp.h"
#include "cddata.h"
#include "helpids.h"
#include "cdread.h"
#include "mmreg.h"
#include "msacm.h"

//////////////
// Help ID's
//////////////

#pragma data_seg(".text")
const static DWORD aPlayListHelp[] = 
{
    IDC_EDITPLAYLIST,           IDH_EDITPLAYLIST,
    IDC_DATABASE_TEXT,          IDH_ALBUMDATABASE,
    IDC_CDTREE,                 IDH_ALBUMDATABASE,
    IDC_BYARTIST,               IDH_VIEWBYARTIST,
    0, 0
};
#pragma data_seg()


////////////
// Local constants
////////////

#define NO_IMAGE                (DWORD(-1))
#define CD_IMAGE                (0)
#define CDS_IMAGE               (1)
#define NOCD_IMAGE              (2)
#define CDCASE_IMAGE            (3)
#define CDOPEN_IMAGE            (4)
#define CDCOLLECTION_IMAGE      (5)
#define CDSONG_IMAGE            (6)

#define FORMAT_LET_NAME         TEXT("( %s )  %s")
#define FORMAT_NAME             TEXT("%s")
#define FORMAT_LET_NAME_ARTIST  TEXT("( %s )  %s (%s)")
#define FORMAT_LABEL_TYPE       TEXT("%s  (%s)")
#define FORMAT_NEW_TRACK        TEXT("%s %d")

#define MAXLABEL                (CDSTR * 4)


////////////
// Methods
////////////

STDMETHODIMP_(HTREEITEM) CCDOpt::AddNameToTree(HWND hDlg, LPCDUNIT pCDUnit, TCHAR *szName, HTREEITEM hParent, HTREEITEM hInsertAfter, LPCDTITLE pCDTitle, DWORD fdwType, DWORD dwTracks, DWORD dwImage)
{
	HTREEITEM			newItem;
	TV_INSERTSTRUCT		is;

	memset( &is, 0, sizeof( is ) );
	is.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE ;
    is.item.iImage = is.item.iSelectedImage = (int) dwImage;

	is.hParent = hParent;
	is.hInsertAfter = hInsertAfter;
    is.item.pszText = szName;
    is.item.lParam = (LPARAM) NewCDTreeInfo(pCDTitle, pCDUnit, fdwType, dwTracks);

    if (is.hInsertAfter == NULL)
    {
        is.hInsertAfter = TVI_LAST; //chk version of NT fails on NULL for this param
    }
	
	newItem = (HTREEITEM) SendDlgItemMessage( hDlg, IDC_CDTREE, TVM_INSERTITEM, 0, (LPARAM) &is );

    return(newItem);
}




STDMETHODIMP_(void) CCDOpt::AddTracksToTree(HWND hDlg, LPCDTITLE pCDTitle, HTREEITEM parent)
{
    DWORD       dwTrack;
    TCHAR       str[MAXLABEL];

    if (pCDTitle && pCDTitle->pTrackTable)
    {
        for (dwTrack = 0; dwTrack < pCDTitle->dwNumTracks; dwTrack++)
        {
            wsprintf(str, FORMAT_NAME, pCDTitle->pTrackTable[dwTrack].szName);
            AddNameToTree(hDlg, NULL, str, parent, NULL, pCDTitle, CDINFO_TRACK, dwTrack, CDSONG_IMAGE);
        }
    }
}



STDMETHODIMP_(void) CCDOpt::AddTitleByCD(HWND hDlg)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    LPCDUNIT    pCDUnit = m_pCDCopy->pCDUnitList;
    TCHAR       szUnknown[CDSTR];
    TCHAR       szNoDisc[CDSTR];
    TCHAR       szDownLoading[CDSTR];
    TCHAR       str[MAXLABEL];

    LoadString( m_hInst, IDS_NODISC, szNoDisc, sizeof( szNoDisc ) /sizeof(TCHAR));
    LoadString( m_hInst, IDS_UNKNOWNTITLE, szUnknown, sizeof( szUnknown ) /sizeof(TCHAR));
    LoadString( m_hInst, IDS_DOWNLOADING, szDownLoading, sizeof( szDownLoading ) /sizeof(TCHAR));

    if (pCDUnit)
    {
        HTREEITEM   hDisc;
        HTREEITEM   hTitle;

        LoadString( m_hInst, IDS_CDTITLES, str, sizeof( str )/sizeof(TCHAR) );
        hDisc = AddNameToTree(hDlg, NULL, str, NULL, NULL, NULL, CDINFO_DRIVES, 0, CDS_IMAGE);

        while (pCDUnit)
        {
            if (pCDUnit->dwTitleID == CDTITLE_NODISC)
            {
                wsprintf(str, FORMAT_LET_NAME, pCDUnit->szDriveName, szNoDisc);
                AddNameToTree(hDlg, pCDUnit, str, hDisc, NULL, NULL, CDINFO_CDROM, 0, NOCD_IMAGE);
            }
            else
            {
                LPCDTITLE   pCDTitle = m_pCDData->GetTitleList();
               
                while (pCDTitle)
                {
                    if (pCDTitle->dwTitleID == pCDUnit->dwTitleID && !pCDTitle->fRemove)
                    {
                        pCDTitle->fDownLoading = pCDUnit->fDownLoading;
                        break;
                    }

                    pCDTitle = pCDTitle->pNext;
                }

                if (pCDTitle || pCDUnit->fDownLoading)
                {    
                    if (pCDUnit->fDownLoading)
                    {
                        wsprintf(str, FORMAT_LET_NAME, pCDUnit->szDriveName, szDownLoading);
                        AddNameToTree(hDlg, pCDUnit, str, hDisc, NULL, pCDTitle, CDINFO_CDROM, 0, CD_IMAGE);
                    }   
                    else
                    {             
                        wsprintf(str, FORMAT_LET_NAME_ARTIST, pCDUnit->szDriveName, pCDTitle->szTitle, pCDTitle->szArtist);
                        hTitle = AddNameToTree(hDlg, pCDUnit, str, hDisc, NULL, pCDTitle, CDINFO_CDROM, 0, CD_IMAGE);
                        AddTracksToTree(hDlg, pCDTitle, hTitle);

                        if (pCDTitle->fDriveExpanded)
                        {
                            TreeView_Expand(hTree, hTitle, TVE_EXPAND);
                        }
                    }
                }
                else
                {
                    wsprintf(str,FORMAT_LET_NAME, pCDUnit->szDriveName, szUnknown);
                    hTitle = AddNameToTree(hDlg, pCDUnit, str, hDisc, NULL, NULL, CDINFO_CDROM, 0, CD_IMAGE);
                }
            }

            pCDUnit = pCDUnit->pNext;
        }

        if (m_fDrivesExpanded)
        {
            TreeView_Expand(hTree, hDisc, TVE_EXPAND);
        }
    }
}




STDMETHODIMP_(void) CCDOpt::UpdateTitleTree(HWND hDlg, LPCDDATA pCDData)
{
    if (m_pCDCopy && pCDData)
    {
        HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
        HTREEITEM   parent;
        HTREEITEM   title;
        TCHAR       str[MAXLABEL];
        TCHAR       szByArtist[CDSTR];
        TCHAR       szByTitle[CDSTR];
        TCHAR       szTitles[CDSTR];
        TCHAR       szDownLoading[CDSTR];
        BOOL        fExpandArtist = FALSE;

        LPCDTITLE   pCDTitle = pCDData->GetTitleList();

        LoadString( m_hInst, IDS_BYARTIST, szByArtist, sizeof( szByArtist )/sizeof(TCHAR) );
        LoadString( m_hInst, IDS_BYTITLE, szByTitle, sizeof( szByTitle )/sizeof(TCHAR) );
        LoadString( m_hInst, IDS_OTHERTITLES, szTitles, sizeof( szTitles )/sizeof(TCHAR) );
        LoadString( m_hInst, IDS_DOWNLOADING, szDownLoading, sizeof( szDownLoading )/sizeof(TCHAR) );

        AddTitleByCD(hDlg);
         
        while(pCDTitle && pCDTitle->fRemove)            // If we have removed titles, we don't display them, and we need to have a valid title to start here.
        {
            pCDTitle = pCDTitle->pNext;
        }         
                
        if (pCDTitle)   // There are no titles in database, don't show it.
        {
            HTREEITEM hArtist = NULL;
            TCHAR szUnknownArtist[CDSTR];
            TCHAR *szThisArtist;
            BOOL fByArtist = m_pCDCopy->pCDData->fByArtist;

            if (fByArtist)
            {
                wsprintf(str,  FORMAT_LABEL_TYPE, szTitles, szByArtist);
            }
            else
            {
                wsprintf(str,  FORMAT_LABEL_TYPE, szTitles, szByTitle);
            }

            parent = AddNameToTree(hDlg, NULL, str, NULL, NULL, NULL, CDINFO_ALBUMS, 0, CDS_IMAGE);

            if (fByArtist)
            {
                LoadString( m_hInst, IDS_UNKNOWNARTIST, szUnknownArtist, sizeof( szUnknownArtist )/sizeof(TCHAR) );

                szThisArtist = pCDTitle->szArtist;
                while(*szThisArtist != TEXT('\0') && (*szThisArtist == TEXT(' ') || *szThisArtist == TEXT('\t')))  // Unknown artist are null string or whitespace
                {
                    szThisArtist++;
                }

                if (szThisArtist[0] == TEXT('\0'))
                {
                    hArtist = AddNameToTree(hDlg, NULL, szUnknownArtist, parent, NULL, NULL, CDINFO_LABEL, 0, CDCOLLECTION_IMAGE);
                }
                else
                {
                    hArtist = AddNameToTree(hDlg, NULL, szThisArtist, parent, NULL, NULL, CDINFO_ARTIST, 0, CDCOLLECTION_IMAGE);
                }

                fExpandArtist = pCDTitle->fArtistExpanded;
            }
        

            while (pCDTitle)
            {
                if (!fByArtist)
                {
                    if (pCDTitle->fDownLoading)
                    {
                        wsprintf(str, FORMAT_NAME, szDownLoading);
                    }
                    else
                    {
                        wsprintf(str, FORMAT_LABEL_TYPE,pCDTitle->szTitle, pCDTitle->szArtist);
                    }

                    title = AddNameToTree(hDlg, NULL, str, parent, TVI_SORT, pCDTitle, CDINFO_DISC, 0, CDCASE_IMAGE);
                    
                    if (!pCDTitle->fDownLoading)
                    {
                        AddTracksToTree(hDlg, pCDTitle, title);

                        if (pCDTitle->fAlbumExpanded)
                        {
                            TreeView_Expand(hTree, title, TVE_EXPAND);
                        }

                    }
                }
                else
                {
                    TCHAR *szCurrentArtist = pCDTitle->szArtist;
                    while(*szCurrentArtist != TEXT('\0') && (*szCurrentArtist == TEXT(' ') || *szCurrentArtist == TEXT('\t')))
                    {
                        szCurrentArtist++;
                    }

                    if (lstrcmp(szThisArtist, szCurrentArtist))     // New Artist?
                    {
                        if (fExpandArtist)
                        {
                            TreeView_Expand(hTree, hArtist, TVE_EXPAND);
                        }

                        szThisArtist = szCurrentArtist;
                        hArtist = AddNameToTree(hDlg, NULL, szThisArtist, parent, NULL, NULL, CDINFO_ARTIST, 0, CDCOLLECTION_IMAGE);

                        fExpandArtist = pCDTitle->fArtistExpanded;
                    }
            
                    if (pCDTitle->fDownLoading)
                    {
                        title = AddNameToTree(hDlg, NULL, szDownLoading, hArtist, TVI_SORT, pCDTitle, CDINFO_TITLE, 0, CDCASE_IMAGE);
                    }
                    else
                    {
                        title = AddNameToTree(hDlg, NULL, pCDTitle->szTitle, hArtist, TVI_SORT, pCDTitle, CDINFO_TITLE, 0, CDCASE_IMAGE);
                        AddTracksToTree(hDlg, pCDTitle, title);

                        if (pCDTitle->fAlbumExpanded)
                        {
                            TreeView_Expand(hTree, title, TVE_EXPAND);
                        }
                    }
                }

                pCDTitle = pCDTitle->pNext;

                while (pCDTitle && pCDTitle->fRemove)   // Skip any titles that have been removed
                {
                    pCDTitle = pCDTitle->pNext;
                }
            }

            if (fByArtist && fExpandArtist)
            {
                TreeView_Expand(hTree, hArtist, TVE_EXPAND);
            }

            if (m_fAlbumsExpanded)
            {
                TreeView_Expand(hTree, parent, TVE_EXPAND);
            }

            UpdateCachedTree(hDlg,pCDData);
        }
    }
}

STDMETHODIMP_(LPCDTITLE) CCDOpt::TranslateDirectoryToTitle(LPWIN32_FIND_DATA lpFileData, LPCDDATA pCDData)
{
    LPCDTITLE pCDTitle = NULL;
    DWORD dwMediaID = 0;

    if ((lpFileData) && (pCDData))
    {
        if (lpFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if (_stscanf(lpFileData->cFileName,TEXT("%d"),&dwMediaID))
            {
                if (pCDData->QueryTitle(dwMediaID))
                {
                    HRESULT hr =  pCDData->LockTitle(&pCDTitle,dwMediaID);
                    if (FAILED(hr))
                    {
                        pCDTitle = NULL;
                    }
                    else
                    {
                        DWORD dwNotCached = 0;
                        DWORD dwTrackNameSlot = 0;

                        for (DWORD x = 0; x < pCDTitle->dwNumTracks; x++)
                        {
                            if (!IsTrackCached(dwMediaID,x))
                            {
                                dwNotCached++;
                            }
                            else
                            {
                                //move the current name into the next slot
                                _tcscpy(pCDTitle->pTrackTable[dwTrackNameSlot++].szName,pCDTitle->pTrackTable[x].szName);
                            }
                        }

                        pCDTitle->dwNumTracks -= dwNotCached;

                        if (dwNotCached == pCDTitle->dwNumTracks)
                        {
                            pCDData->UnlockTitle(pCDTitle,FALSE);
                            pCDTitle = NULL;
                        }
                    }
                } //end if query 
            } //end if scan was successful
        } //end if this is really a dir
    } //end if params are OK

    return (pCDTitle);
}

STDMETHODIMP_(void) CCDOpt::UpdateCachedTree(HWND hDlg, LPCDDATA pCDData)
{
    if (m_pCDCopy && pCDData)
    {
        HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
        HTREEITEM   parent;
        HTREEITEM   title;
        TCHAR       str[MAXLABEL];
        TCHAR       szByArtist[CDSTR];
        TCHAR       szByTitle[CDSTR];
        TCHAR       szTitles[CDSTR];
        TCHAR       szDownLoading[CDSTR];
        BOOL        fExpandArtist = FALSE;
        HANDLE      hFindHandle = INVALID_HANDLE_VALUE;
        TCHAR       szDirMain[MAX_PATH];
        WIN32_FIND_DATA FindFileData;
        LPCDTITLE   pCDTitle = NULL;

        LoadString( m_hInst, IDS_BYARTIST, szByArtist, sizeof( szByArtist )/sizeof(TCHAR) );
        LoadString( m_hInst, IDS_BYTITLE, szByTitle, sizeof( szByTitle )/sizeof(TCHAR) );
        LoadString( m_hInst, IDS_CACHEDTITLES, szTitles, sizeof( szTitles )/sizeof(TCHAR) );
        LoadString( m_hInst, IDS_DOWNLOADING, szDownLoading, sizeof( szDownLoading )/sizeof(TCHAR) );

        ExpandEnvironmentStrings(TEXT("%ProgramFiles%\\CD Player\\Music\\*."),szDirMain,MAX_PATH);
    
        hFindHandle = FindFirstFile(szDirMain,&FindFileData);

        if (hFindHandle!=INVALID_HANDLE_VALUE)   // There are no titles in database, don't show it.
        {
            HTREEITEM hArtist = NULL;
            TCHAR szUnknownArtist[CDSTR];
            TCHAR *szThisArtist;
            BOOL fByArtist = m_pCDCopy->pCDData->fByArtist;

            if (fByArtist)
            {
                wsprintf(str,  FORMAT_LABEL_TYPE, szTitles, szByArtist);
            }
            else
            {
                wsprintf(str,  FORMAT_LABEL_TYPE, szTitles, szByTitle);
            }

            parent = AddNameToTree(hDlg, NULL, str, NULL, NULL, NULL, CDINFO_ALBUMS, 0, CDS_IMAGE);

            pCDTitle = TranslateDirectoryToTitle(&FindFileData,pCDData);

            if (pCDTitle)
            {
                if (fByArtist)
                {
                    LoadString( m_hInst, IDS_UNKNOWNARTIST, szUnknownArtist, sizeof( szUnknownArtist )/sizeof(TCHAR) );

                    szThisArtist = pCDTitle->szArtist;
                    while(*szThisArtist != TEXT('\0') && (*szThisArtist == TEXT(' ') || *szThisArtist == TEXT('\t')))  // Unknown artist are null string or whitespace
                    {
                        szThisArtist++;
                    }

                    if (szThisArtist[0] == TEXT('\0'))
                    {
                        hArtist = AddNameToTree(hDlg, NULL, szUnknownArtist, parent, NULL, NULL, CDINFO_LABEL, 0, CDCOLLECTION_IMAGE);
                    }
                    else
                    {
                        hArtist = AddNameToTree(hDlg, NULL, szThisArtist, parent, NULL, NULL, CDINFO_ARTIST, 0, CDCOLLECTION_IMAGE);
                    }

                    fExpandArtist = pCDTitle->fArtistExpanded;
                }
            }
        
            BOOL fFound = (hFindHandle != INVALID_HANDLE_VALUE);

            while (fFound)
            {
                pCDTitle = TranslateDirectoryToTitle(&FindFileData,pCDData);

                if (pCDTitle)
                {
                    if (!fByArtist)
                    {
                        if (pCDTitle->fDownLoading)
                        {
                            wsprintf(str, FORMAT_NAME, szDownLoading);
                        }
                        else
                        {
                            wsprintf(str, FORMAT_LABEL_TYPE,pCDTitle->szTitle, pCDTitle->szArtist);
                        }

                        title = AddNameToTree(hDlg, NULL, str, parent, TVI_SORT, pCDTitle, CDINFO_DISC, 0, CDCASE_IMAGE);
                    
                        if (!pCDTitle->fDownLoading)
                        {
                            AddTracksToTree(hDlg, pCDTitle, title);

                            if (pCDTitle->fAlbumExpanded)
                            {
                                TreeView_Expand(hTree, title, TVE_EXPAND);
                            }

                        }
                    }
                    else
                    {
                        TCHAR *szCurrentArtist = pCDTitle->szArtist;
                        while(*szCurrentArtist != TEXT('\0') && (*szCurrentArtist == TEXT(' ') || *szCurrentArtist == TEXT('\t')))
                        {
                            szCurrentArtist++;
                        }

                        if (lstrcmp(szThisArtist, szCurrentArtist))     // New Artist?
                        {
                            if (fExpandArtist)
                            {
                                TreeView_Expand(hTree, hArtist, TVE_EXPAND);
                            }

                            szThisArtist = szCurrentArtist;
                            hArtist = AddNameToTree(hDlg, NULL, szThisArtist, parent, NULL, NULL, CDINFO_ARTIST, 0, CDCOLLECTION_IMAGE);

                            fExpandArtist = pCDTitle->fArtistExpanded;
                        }
            
                        if (pCDTitle->fDownLoading)
                        {
                            title = AddNameToTree(hDlg, NULL, szDownLoading, hArtist, TVI_SORT, pCDTitle, CDINFO_TITLE, 0, CDCASE_IMAGE);
                        }
                        else
                        {
                            title = AddNameToTree(hDlg, NULL, pCDTitle->szTitle, hArtist, TVI_SORT, pCDTitle, CDINFO_TITLE, 0, CDCASE_IMAGE);
                            AddTracksToTree(hDlg, pCDTitle, title);

                            if (pCDTitle->fAlbumExpanded)
                            {
                                TreeView_Expand(hTree, title, TVE_EXPAND);
                            }
                        }
                    }

                    pCDData->UnlockTitle(pCDTitle,FALSE);
                }

                fFound = FindNextFile(hFindHandle,&FindFileData);
            }

            if (fByArtist && fExpandArtist)
            {
                TreeView_Expand(hTree, hArtist, TVE_EXPAND);
            }

            if (m_fAlbumsExpanded)
            {
                TreeView_Expand(hTree, parent, TVE_EXPAND);
            }

            FindClose(hFindHandle);
        } //if handle not invalid
    } //if valid params
}

STDMETHODIMP_(void) CCDOpt::DumpRecurseTree(HWND hTree, HTREEITEM hItem)
{
    TV_ITEM item;

    if (hItem)
    {
        DumpRecurseTree(hTree, TreeView_GetChild(hTree, hItem));            // Kill Kids
        DumpRecurseTree(hTree, TreeView_GetNextSibling(hTree, hItem));      // Kill Sibs

        memset(&item,0,sizeof(item));                                       // Kill it.
        item.mask = TVIF_PARAM;
        item.hItem = hItem;
        item.lParam = NULL;

        if (TreeView_GetItem(hTree,&item))
        {
            if (item.lParam)
            {
                LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

                delete pCDInfo;
            }

        }

        TreeView_DeleteItem(hTree, hItem);
    }
}

STDMETHODIMP_(void) CCDOpt::DumpMixerTree(HWND hDlg)
{
    HWND    hTree = GetDlgItem(hDlg, IDC_CDTREE);
    
    SetWindowRedraw(hTree,FALSE);
    DumpRecurseTree(hTree, TreeView_GetRoot(hTree));
    SetWindowRedraw(hTree,TRUE);
}


STDMETHODIMP_(LPCDTREEINFO) CCDOpt::NewCDTreeInfo(LPCDTITLE pCDTitle, LPCDUNIT pCDUnit, DWORD fdwType, DWORD dwTrack)
{
    LPCDTREEINFO pCDInfo = new(CDTREEINFO);

    if (pCDInfo)
    {
        pCDInfo->pCDTitle = pCDTitle;
        pCDInfo->fdwType = fdwType;
        pCDInfo->dwTrack = dwTrack;
        pCDInfo->pCDUnit = pCDUnit;
    }

    return(pCDInfo);
}





STDMETHODIMP_(BOOL) CCDOpt::InitPlayLists(HWND hDlg, LPCDDATA pCDData)
{
    BOOL fResult = TRUE;

    if (m_pCDCopy && pCDData)
    {
        int cxMiniIcon = (int)GetSystemMetrics(SM_CXSMICON);
        int cyMiniIcon = (int)GetSystemMetrics(SM_CYSMICON);

        m_hImageList = ImageList_Create(cxMiniIcon,cyMiniIcon, TRUE, 6, 4);

        if (m_hImageList == NULL)
        {
            fResult = FALSE;
        }
        else
        {
            HICON hIcon;
            HWND hTree =  GetDlgItem(hDlg, IDC_CDTREE);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_SMALLCD), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_CDSTACK), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_NODISC), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_TITLECLOSED), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_TITLEOPEN), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_CDCOLLECTION), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_SONG), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            TreeView_SetImageList(hTree, m_hImageList, TVSIL_NORMAL);

            EnableWindow(GetDlgItem(hDlg, IDC_EDITPLAYLIST), FALSE);

            CheckDlgButton(hDlg, IDC_BYARTIST, m_pCDCopy->pCDData->fByArtist);

            UpdateTitleTree(hDlg, pCDData);
        }
    }

    return fResult;
}

STDMETHODIMP_(void) CCDOpt::ToggleByArtist(HWND hDlg, LPCDDATA pCDData)
{
    if (m_pCDCopy)
    {
        HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);

        DumpMixerTree(hDlg);

        SetWindowRedraw(hTree,FALSE);
        TreeView_DeleteAllItems(hTree);
        SetWindowRedraw(hTree,TRUE);

        m_pCDCopy->pCDData->fByArtist = Button_GetCheck(GetDlgItem(hDlg, IDC_BYARTIST));

        UpdateTitleTree(hDlg, pCDData);
    }
}

STDMETHODIMP_(void) CCDOpt::TreeItemMenu(HWND hDlg)
{
    DWORD           dwPos;
    POINT           pt;
    TV_HITTESTINFO  tvHit;
    HMENU           hMenu;
    HMENU           hPopup;
    TV_ITEM         item;
    int             mCmd;
    HWND            hTree = GetDlgItem(hDlg, IDC_CDTREE);
    TCHAR           szExpand[64];

    //dont bring up a menu unless click is on the item.
    dwPos = GetMessagePos();
    pt.x = LOWORD(dwPos);
    pt.y = HIWORD(dwPos);

    tvHit.pt = pt;
    ScreenToClient(hTree, &tvHit.pt);
    item.hItem = TreeView_HitTest(hTree, &tvHit);
    
    if (item.hItem && (hMenu = LoadMenu(m_hInst, MAKEINTRESOURCE(IDR_TITLEMENU))))
    {
        LPCDTREEINFO pCDInfo;
        HTREEITEM hKids = NULL;

        hPopup = GetSubMenu(hMenu, 0);

        item.mask = TVIF_STATE | TVIF_HANDLE | TVIF_CHILDREN | TVIF_PARAM;
        TreeView_GetItem(hTree, &item);

        pCDInfo = (LPCDTREEINFO) item.lParam;

        if (item.state & TVIS_EXPANDED)
        {
            LoadString( m_hInst, IDS_COLLAPSE, szExpand, sizeof( szExpand )/sizeof(TCHAR) );
            ModifyMenu(hPopup, ID_EXPAND, MF_BYCOMMAND | MF_STRING, ID_EXPAND, szExpand);
        }
        
        hKids = TreeView_GetChild(hTree, item.hItem);

        if (hKids == NULL || item.cChildren == 0)
        {
            EnableMenuItem(hPopup, ID_EXPAND, MF_GRAYED | MF_BYCOMMAND);
        }

        if ((pCDInfo->fdwType == (DWORD)CDINFO_CDROM) && (pCDInfo->pCDTitle != NULL))
        {
            //might need to put up "remove from cache" option
            BOOL fAllCached = TRUE;

            for (DWORD x = 0; x < pCDInfo->pCDTitle->dwNumTracks; x++)
            {
                if (!IsTrackCached(pCDInfo->pCDTitle->dwTitleID,x))
                {
                    fAllCached = FALSE;
                    break;
                }
            }

            if (fAllCached)
            {
                LoadString( m_hInst, ID_DELETECACHEDALBUM, szExpand, sizeof( szExpand )/sizeof(TCHAR) );
                ModifyMenu(hPopup, ID_CACHEALBUM, MF_BYCOMMAND | MF_STRING, ID_DELETECACHEDALBUM, szExpand);
            }
        }
        else
        {
            RemoveMenu(hPopup, ID_CACHEALBUM, MF_BYCOMMAND);
        }

        if (pCDInfo->fdwType != (DWORD)CDINFO_TRACK)
        {
            RemoveMenu(hPopup, ID_CACHETRACK, MF_BYCOMMAND);
        }
        else
        {
            BOOL fRemoveCacheCommand = TRUE;
            BOOL fAddDeleteCommand = FALSE;
            HTREEITEM hParent = TreeView_GetParent(hTree,item.hItem);

            if (hParent)
            {
                TV_ITEM itemParent;
                itemParent.hItem = hParent;            
                itemParent.mask = TVIF_STATE | TVIF_HANDLE | TVIF_CHILDREN | TVIF_PARAM;
                
                if (TreeView_GetItem(hTree, &itemParent))
                {
                    LPCDTREEINFO pCDInfoParent = (LPCDTREEINFO) itemParent.lParam;

                    if (pCDInfoParent)
                    {
                        if (pCDInfoParent->fdwType == (DWORD)CDINFO_CDROM)
                        {
                            if (IsTrackCached(pCDInfoParent->pCDTitle->dwTitleID,pCDInfo->dwTrack))
                            {
                                fAddDeleteCommand = TRUE;
                            }

                            fRemoveCacheCommand = FALSE;
                        }
                    } //end if parent has info
                } //end parent item
            } //end if parent

            if (fRemoveCacheCommand)
            {
                RemoveMenu(hPopup, ID_CACHETRACK, MF_BYCOMMAND);
            }

            if (fAddDeleteCommand)
            {
                LoadString( m_hInst, ID_DELETECACHEDTRACK, szExpand, sizeof( szExpand )/sizeof(TCHAR) );
                ModifyMenu(hPopup, ID_CACHETRACK, MF_BYCOMMAND | MF_STRING, ID_DELETECACHEDTRACK, szExpand);
            }
        }

        if (pCDInfo->pCDTitle == NULL)
        {
            if (pCDInfo->fdwType == (DWORD)CDINFO_CDROM && pCDInfo->pCDUnit && pCDInfo->pCDUnit->dwTitleID != (DWORD)CDTITLE_NODISC)   
            { 
                TCHAR szCreate[64];
                LoadString( m_hInst, IDS_CREATEPLAYLIST, szCreate, sizeof( szCreate )/sizeof(TCHAR) );
                ModifyMenu(hPopup, IDC_EDITPLAYLIST, MF_BYCOMMAND | MF_STRING, IDC_EDITPLAYLIST, szCreate);
            }
            else
            {
                EnableMenuItem(hPopup, ID_DOWNLOADTITLE, MF_GRAYED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDC_EDITPLAYLIST, MF_GRAYED | MF_BYCOMMAND);
            }

            RemoveMenu(hPopup, ID_EDITTITLENAME, MF_BYCOMMAND);
            RemoveMenu(hPopup, ID_EDITTRACKNAME, MF_BYCOMMAND);
            RemoveMenu(hPopup, ID_DELETETITLE, MF_BYCOMMAND);

            if (pCDInfo->fdwType != (DWORD)CDINFO_ARTIST)
            {
                RemoveMenu(hPopup, ID_EDITARTISTNAME, MF_BYCOMMAND);
            }
        }
        else
        {
            RemoveMenu(hPopup, ID_EDITARTISTNAME, MF_BYCOMMAND);

           if (pCDInfo->pCDTitle->fDownLoading)
            {
                EnableMenuItem(hPopup, ID_DOWNLOADTITLE, MF_GRAYED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDC_EDITPLAYLIST, MF_GRAYED | MF_BYCOMMAND);
            }
 
            if (!(pCDInfo->fdwType & (DWORD)CDINFO_DISC) && (pCDInfo->fdwType != (DWORD)CDINFO_CDROM))
            {
                EnableMenuItem(hPopup, ID_DOWNLOADTITLE, MF_GRAYED | MF_BYCOMMAND);
            }
            else
            {
                TCHAR *szTitleQuery = pCDInfo->pCDTitle->szTitleQuery;

                if (szTitleQuery)
                {
                    while (*szTitleQuery != TEXT('\0') && (*szTitleQuery == TEXT(' ') || *szTitleQuery == TEXT('\t')))
                    {
                        szTitleQuery++;
                    }

                    if (*szTitleQuery == TEXT('\0'))
                    {
                        EnableMenuItem(hPopup, ID_DOWNLOADTITLE, MF_GRAYED | MF_BYCOMMAND);
                    }
                }
                else
                {
                    EnableMenuItem(hPopup, ID_DOWNLOADTITLE, MF_GRAYED | MF_BYCOMMAND);
                }
            }

            if (pCDInfo->fdwType == (DWORD)CDINFO_TITLE)
            {
                RemoveMenu(hPopup, ID_EDITTRACKNAME, MF_BYCOMMAND);
            }
            else if (pCDInfo->fdwType == (DWORD)CDINFO_TRACK)
            {
                RemoveMenu(hPopup, ID_EDITTITLENAME, MF_BYCOMMAND);
                RemoveMenu(hPopup, ID_DELETETITLE, MF_BYCOMMAND);
            }
            else
            {
                RemoveMenu(hPopup, ID_EDITTITLENAME, MF_BYCOMMAND);
                RemoveMenu(hPopup, ID_EDITTRACKNAME, MF_BYCOMMAND);
            }
        }

        if (m_pCDCopy->pfnDownloadTitle == NULL)
        {
            EnableMenuItem(hPopup, ID_DOWNLOADTITLE, MF_GRAYED | MF_BYCOMMAND);
        }
        
        TreeView_SelectItem(hTree, item.hItem);

        mCmd = TrackPopupMenuEx(hPopup, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_TOPALIGN, pt.x, pt.y, hDlg, NULL);

        DestroyMenu(hMenu);
        FORWARD_WM_COMMAND(hDlg, mCmd, 0, 0, SendMessage);
    }
}



STDMETHODIMP_(void) CCDOpt::ToggleExpand(HWND hDlg)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem = TreeView_GetSelection(hTree);
    TV_ITEM     item;

    if (hItem)
    {
        item.mask = TVIF_PARAM;
        item.hItem = hItem;
        TreeView_GetItem(hTree, &item);
    }

    TreeView_Expand(hTree, hItem, TVE_TOGGLE);
}


STDMETHODIMP_(void) CCDOpt::EditTreeItem(HWND hDlg)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem = TreeView_GetSelection(hTree);
    TV_ITEM     item;

    if (hItem)
    {
        item.mask = TVIF_PARAM;
        item.hItem = hItem;
        TreeView_GetItem(hTree, &item);
    }

    TreeView_EditLabel(hTree, hItem);
}

STDMETHODIMP_(void) CCDOpt::RefreshTreeItem(HWND hDlg, HTREEITEM hItem)
{
    HWND    hTree = GetDlgItem(hDlg, IDC_CDTREE);
    TV_ITEM item;
    HTREEITEM hKid; 
    TCHAR str[MAXLABEL];

    memset(&item, 0, sizeof(item));
    item.mask = TVIF_PARAM;
    item.hItem = hItem;

    if (TreeView_GetItem(hTree, &item))
    {
        LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;
        LPCDUNIT pCDUnit = pCDInfo->pCDUnit;

        if (pCDUnit)   // This is a CD Drive, lets set the name 
        {
            TCHAR szDownLoading[CDSTR];

            LoadString( m_hInst, IDS_DOWNLOADING, szDownLoading, sizeof( szDownLoading )/sizeof(TCHAR) );

            if (pCDInfo->pCDTitle == NULL)
            {
                TCHAR szUnknown[CDSTR];

                LoadString( m_hInst, IDS_UNKNOWNTITLE, szUnknown, sizeof( szUnknown )/sizeof(TCHAR) );
                wsprintf(str, FORMAT_LET_NAME, pCDInfo->pCDUnit->szDriveName, szUnknown);
            }
            else if (pCDInfo->pCDTitle->fDownLoading)
            {
                wsprintf(str, FORMAT_LET_NAME, pCDInfo->pCDUnit->szDriveName, szDownLoading);
            }   
            else
            {             
                wsprintf(str, FORMAT_LET_NAME_ARTIST, pCDUnit->szDriveName, pCDInfo->pCDTitle->szTitle, pCDInfo->pCDTitle->szArtist);
            }
        
        }
        else
        {
            if (!m_pCDCopy->pCDData->fByArtist)
            {
                wsprintf(str, FORMAT_LABEL_TYPE,pCDInfo->pCDTitle->szTitle, pCDInfo->pCDTitle->szArtist);
            }
            else
            {
                wsprintf(str, FORMAT_NAME, pCDInfo->pCDTitle->szTitle);
            }
        }
        

        memset(&item,0,sizeof(item));
        item.mask = TVIF_TEXT;
        item.hItem = hItem;
        item.pszText = str;

        TreeView_SetItem(hTree,&item);

        hKid = TreeView_GetChild(hTree, hItem);
    
        if (!hKid)
        {
            AddTracksToTree(hDlg, pCDInfo->pCDTitle, hItem);
        }
        else
        {
            DWORD dwTrack;

            for (dwTrack = 0; dwTrack < pCDInfo->pCDTitle->dwNumTracks && (hKid != NULL) ; dwTrack++)
            {
                wsprintf(str, FORMAT_NAME, pCDInfo->pCDTitle->pTrackTable[dwTrack].szName);

                memset(&item,0,sizeof(item));
                item.mask = TVIF_TEXT;
                item.hItem = hKid;
                item.pszText = str;

                TreeView_SetItem(hTree,&item);

                hKid = TreeView_GetNextSibling(hTree, hKid);
            }
        }
    }
}


STDMETHODIMP_(HTREEITEM) CCDOpt::FindRecurseTree(HWND hDlg, HTREEITEM hItem, LPCDTITLE pCDTitle, BOOL fRefresh, DWORD dwTitleID)
{
    HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
    TV_ITEM     item;
    HTREEITEM   hMatch = NULL;
    if (hItem)
    {
        hMatch = FindRecurseTree(hDlg, TreeView_GetChild(hTree, hItem), pCDTitle, fRefresh, dwTitleID);     // Search Kids

        if (!hMatch)                                                                                        // Search Sibs
        {
            hMatch = FindRecurseTree(hDlg, TreeView_GetNextSibling(hTree, hItem), pCDTitle, fRefresh, dwTitleID);
        }
                                                                                                    
        if (!hMatch)                                                                                        // Search IT                                                                 
        {       
            memset(&item,0,sizeof(item));
            item.mask = TVIF_PARAM;
            item.hItem = hItem;
            item.lParam = NULL;

            if (TreeView_GetItem(hTree,&item))
            {
                if (item.lParam)
                {
                    LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

                    if (pCDTitle && (pCDInfo->pCDTitle == pCDTitle) && (pCDInfo->fdwType & (DWORD)CDINFO_DISC || pCDInfo->fdwType == (DWORD)CDINFO_CDROM))
                    {
                        hMatch = hItem;

                        if (fRefresh)
                        {
                            RefreshTreeItem(hDlg, hMatch);

                            hMatch = NULL;  // Find all of them, not just the first
                        }
                    }
                    else if (fRefresh && pCDInfo->pCDUnit && pCDInfo->fdwType == (DWORD)CDINFO_CDROM)  // If doing a refresh and this is a drive node with NO disc
                    {
                        if (pCDInfo->pCDUnit->dwTitleID == dwTitleID)     // Cool, a new disc has shown up.
                        {
                            pCDInfo->pCDTitle = pCDTitle;
                            pCDInfo->dwTrack = 0;
                            pCDInfo->fdwType = CDINFO_CDROM;
                           
                            memset(&item,0,sizeof(item));
                            item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                            item.hItem = hItem;
                            item.iImage = item.iSelectedImage = (int) CD_IMAGE;
                            
                            TreeView_SetItem(hTree, &item);

                            RefreshTreeItem(hDlg, hItem);

                        }   
                    }
                }
            }
        }
    }

    return(hMatch);
}


STDMETHODIMP_(HTREEITEM) CCDOpt::FindTitleInDBTree(HWND hDlg, LPCDTITLE pCDTitle)
{
    return(FindRecurseTree(hDlg, TreeView_GetRoot(GetDlgItem(hDlg, IDC_CDTREE)), pCDTitle, FALSE, 0));
}


STDMETHODIMP_(void) CCDOpt::RefreshTree(HWND hDlg, LPCDTITLE pCDTitle, DWORD dwTitleID)
{
    FindRecurseTree(hDlg, TreeView_GetRoot(GetDlgItem(hDlg, IDC_CDTREE)), pCDTitle, TRUE, dwTitleID);
}


STDMETHODIMP_(BOOL) CCDOpt::DeleteTitleItem(HWND hDlg, HTREEITEM hItem)
{
    HWND    hTree = GetDlgItem(hDlg, IDC_CDTREE);
    TV_ITEM item;
    BOOL    fResult = FALSE;

    item.mask = TVIF_PARAM;
    item.hItem = hItem;
    
    if (TreeView_GetItem(hTree, &item))
    {
        LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

        if (pCDInfo)
        {
            if (!(pCDInfo->fdwType & (DWORD)CDINFO_DISC) && (pCDInfo->fdwType != (DWORD)CDINFO_CDROM))
            {
                MessageBeep(MB_ICONASTERISK);
            }
            else if (pCDInfo->pCDTitle)
            {
                HTREEITEM hParent = TreeView_GetParent(hTree, hItem);

                pCDInfo->pCDTitle->fRemove = TRUE;
      
                if (pCDInfo->fdwType == (DWORD)CDINFO_CDROM)       // Title From CDROM
                {
                    TCHAR       szUnknown[CDSTR];
                    TCHAR       str[MAXLABEL];
                    LPCDTITLE   pOldTitle = pCDInfo->pCDTitle;

                    pCDInfo->pCDTitle = NULL;    

                    LoadString( m_hInst, IDS_UNKNOWNTITLE, szUnknown, sizeof( szUnknown )/sizeof(TCHAR) );
                    wsprintf(str, FORMAT_LET_NAME, pCDInfo->pCDUnit->szDriveName, szUnknown);
					pCDInfo->pCDUnit->fChanged = TRUE;							// Let the UI know...

                    SetWindowRedraw(hTree,FALSE);
                    DumpRecurseTree(hTree, TreeView_GetChild(hTree, hItem));    // Kill off kid and all siblings
                    SetWindowRedraw(hTree,TRUE);

                    item.mask = TVIF_TEXT | TVIF_CHILDREN;
                    item.hItem = hItem;
                    item.pszText = str;
                    item.cChildren = 0;

                    TreeView_SetItem(hTree, &item);

                    hItem = FindTitleInDBTree(hDlg, pOldTitle);          // This disc also exist in the database branch of tree
                    
                    if (hItem)
                    {
                        DeleteTitleItem(hDlg, hItem);
                    }
                    else
                    {
                        ToggleApplyButton(hDlg);
                    }

                    fResult = TRUE;
                }
                else 
                {
                    if (TreeView_DeleteItem(hTree, hItem))
                    {
                        LPCDTITLE pOldTitle = pCDInfo->pCDTitle;

                        delete pCDInfo;

                        ToggleApplyButton(hDlg);
                        fResult = TRUE;

                        if (hParent)
                        {
                            item.mask = TVIF_PARAM | TVIF_CHILDREN;
                            item.hItem = hParent;

                            if (TreeView_GetItem(hTree, &item))
                            {
                                pCDInfo = (LPCDTREEINFO) item.lParam;

                                if (pCDInfo && pCDInfo->fdwType == (DWORD)CDINFO_ARTIST && item.cChildren == 0)
                                {
                                    if (TreeView_DeleteItem(hTree, hParent))
                                    {
                                        delete pCDInfo;
                                    }   
                                }
                            }
                        }

                        if (pOldTitle)
                        {
                            hItem = FindTitleInDBTree(hDlg, pOldTitle);          // This disc also exist in the database branch of tree
                    
                            if (hItem)
                            {
                                DeleteTitleItem(hDlg, hItem);
                            }
                        }
                    }
                }
            } 
        }
    }

    return(fResult);
}


STDMETHODIMP_(void) CCDOpt::DeleteTitle(HWND hDlg)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem = TreeView_GetSelection(hTree);

    if (hItem)
    {
        if (DeleteTitleItem(hDlg, hItem))
        {
            NMHDR nmh;

            nmh.code = TVN_SELCHANGED;          // Forcing controls to update
            PlayListNotify(hDlg, &nmh);
        }
    }
}




STDMETHODIMP_(void) CCDOpt::DownloadTitle(HWND hDlg)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem = TreeView_GetSelection(hTree);
    TV_ITEM     item;

    item.mask = TVIF_PARAM;
    item.hItem = hItem;
    
    if (TreeView_GetItem(hTree, &item))
    {
        LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

        if (pCDInfo && m_pCDCopy->pfnDownloadTitle)
        {
            if ((pCDInfo->fdwType & (DWORD)CDINFO_DISC) || (pCDInfo->fdwType == (DWORD)CDINFO_CDROM))
            {
                if (pCDInfo->pCDTitle)
                {
                    m_pCDCopy->pfnDownloadTitle(pCDInfo->pCDTitle, m_pCDCopy->lParam, hDlg);  

                    pCDInfo->pCDTitle->fChanged = TRUE;

                    RefreshTree(hDlg, pCDInfo->pCDTitle, pCDInfo->pCDTitle->dwTitleID);
                }
                else if (pCDInfo->fdwType == (DWORD)CDINFO_CDROM)   // Create a new one from the internet (only for CDROM entries)
                {
                    LPCDTITLE pNewTitle = NULL;

                    if (SUCCEEDED(m_pCDData->CreateTitle(&pNewTitle, pCDInfo->pCDUnit->dwTitleID, pCDInfo->pCDUnit->dwNumTracks, 0)))
                    {
                        m_pCDCopy->pfnDownloadTitle(pNewTitle, m_pCDCopy->lParam, hDlg);

                        m_pCDData->UnlockTitle(pNewTitle, FALSE);	// Get rid of my temp title

						if (SUCCEEDED(m_pCDData->LockTitle(&pNewTitle, pCDInfo->pCDUnit->dwTitleID)))
						{
                            LPCDTITLE pCDTitle = m_pCDData->GetTitleList();  
                            
                            while (pCDTitle)
                            {
                                if(pCDTitle != pNewTitle && pCDTitle->dwTitleID == pNewTitle->dwTitleID && pCDTitle->fRemove)
                                {
                                    pCDTitle->dwTitleID = DWORD(-1);
                                    break;
                                }

                                pCDTitle = pCDTitle->pNext;
                            }

						    RefreshTree(hDlg, pNewTitle, pNewTitle->dwTitleID);
						    m_pCDData->UnlockTitle(pNewTitle, FALSE);
                        }
                    }
                }
            }
        }
    }
}



STDMETHODIMP_(void) CCDOpt::EditCurrentTitle(HWND hDlg)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem = TreeView_GetSelection(hTree);
    TV_ITEM     item;

    item.mask = TVIF_PARAM;
    item.hItem = hItem;
    
    if (TreeView_GetItem(hTree, &item))
    {
        LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

        if (pCDInfo)
        {
            LPCDTITLE pCDTitle = pCDInfo->pCDTitle;
            BOOL fCreated = FALSE;

            if (pCDTitle == NULL)            // No data, this is a create call.
            {
                if (pCDInfo->pCDUnit)        // Can only do this for CD units, we need an ID
                {
                   if (SUCCEEDED(m_pCDData->CreateTitle(&pCDTitle, pCDInfo->pCDUnit->dwTitleID, pCDInfo->pCDUnit->dwNumTracks, 0)))
                   { 
                        TCHAR szTrack[CDSTR];
                        
                        LoadString(m_hInst, IDS_NEWARTIST, pCDTitle->szArtist, sizeof (pCDTitle->szArtist)/sizeof(TCHAR));
                        LoadString(m_hInst, IDS_NEWTITLE, pCDTitle->szTitle, sizeof (pCDTitle->szTitle)/sizeof(TCHAR));
                        LoadString(m_hInst, IDS_TRACK, szTrack, sizeof (szTrack)/sizeof(TCHAR));

                        m_pCDData->SetTitleQuery(pCDTitle, pCDInfo->pCDUnit->szNetQuery);

                        pCDTitle->pPlayList = new(WORD[pCDTitle->dwNumTracks]);

                        if (pCDTitle->pPlayList)
                        {
                            LPWORD pNum = pCDTitle->pPlayList;
                            
                            pCDTitle->dwNumPlay = pCDTitle->dwNumTracks;
                            for (DWORD dwTrack = 0; dwTrack < pCDTitle->dwNumTracks; dwTrack++, pNum++)
                            {
                                wsprintf(pCDTitle->pTrackTable[dwTrack].szName, FORMAT_NEW_TRACK, szTrack, dwTrack + 1);
                                *pNum = (WORD) dwTrack;
                            }

                            fCreated = TRUE; 
                        }
                        else
                        {
                            m_pCDData->UnlockTitle(pCDTitle, FALSE);
                            pCDTitle = NULL;
                        }
                    }
                }
            }

            if (pCDTitle)
            {
                if (ListEditDialog(hDlg, pCDTitle))
                {
                    pCDTitle->fChanged = TRUE;

                    RefreshTree(hDlg, pCDTitle, pCDTitle->dwTitleID);

                    if (fCreated)       // Save in DB
                    {
                        pCDInfo->pCDTitle = pCDTitle;               // Lets reference the new title in the tree
                        m_pCDData->UnlockTitle(pCDTitle, TRUE);     // Lets save it and put it in the tree (the pointer is still valid until tree is dumped)
                    }

                    NotifyTitleChange(pCDTitle);

                    HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);

                    DumpMixerTree(hDlg);

                    SetWindowRedraw(hTree,FALSE);
                    TreeView_DeleteAllItems(hTree);
                    SetWindowRedraw(hTree,TRUE);

                    UpdateTitleTree(hDlg, m_pCDData);
                }
                else if (fCreated)      // Dump it, they didn't do anything
                {
                    m_pCDData->UnlockTitle(pCDTitle, FALSE);
                }
            }
        }
    }
}


STDMETHODIMP_(void) CCDOpt::DownLoadCompletion(DWORD dwNumIDs, LPDWORD pdwIDs)
{
    UpdateBatched(m_hTitleWnd);

    if (m_hList && m_pCDData && pdwIDs && dwNumIDs)
    {
        LPCDTITLE pCDTitleList = m_pCDData->GetTitleList();
        HWND hDlg = m_hList;
        DWORD dwID;
        LPDWORD pID = pdwIDs;
        NMHDR mhdr;

        for (dwID = 0; dwID < dwNumIDs; dwID++, pID++)      // Look at each ID
        {
            LPCDUNIT pCDUnit = m_pCDCopy->pCDUnitList;      // Only support background downloading of disc in the Drives

            while (pCDUnit)                                 // So, look at each drive for this ID               
            {
                if (pCDUnit->dwTitleID == *pID)             // This drive has a matching ID
                {
                    LPCDTITLE pCDTitle = pCDTitleList;      // Lets find the title for this CD
                    
                    while (pCDTitle)
                    {
                        if (pCDTitle->dwTitleID == *pID)
                        {
                            break;
                        }
                        pCDTitle = pCDTitle->pNext;
                    }

                    if (pCDTitle)
                    {
                        pCDTitle->fDownLoading = pCDUnit->fDownLoading = FALSE;
                    }

                    RefreshTree(hDlg, pCDTitle, *pID);

                    mhdr.code = TVN_SELCHANGED;
                    PlayListNotify(hDlg, &mhdr);
                }

                pCDUnit = pCDUnit->pNext;
            }
        }
    }
}


STDMETHODIMP_(void) CCDOpt::DiscChanged(LPCDUNIT pCDUnit)
{
    if (m_hList && m_pCDData)
    {
        HWND        hDlg = m_hList;
        HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
        HTREEITEM   hItem;
        LPCDTITLE   pCDTitleList = m_pCDData->GetTitleList();
        NMHDR mhdr;

        hItem = TreeView_GetRoot(hTree);

        if (hItem)
        {
            hItem = TreeView_GetChild(hTree,hItem);

            while(hItem)
            {
                TV_ITEM item;

                item.mask = TVIF_PARAM;
                item.hItem = hItem;
    
                if (TreeView_GetItem(hTree, &item))
                {
                    LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

                    if (pCDInfo && pCDInfo->pCDUnit)
                    {
                        if (pCDInfo->pCDUnit == pCDUnit)
                        {                            
                            if (pCDInfo->pCDUnit->dwTitleID == CDTITLE_NODISC)
                            {
                                TCHAR   szNoDisc[CDSTR];
                                TCHAR   str[MAXLABEL];

                                SetWindowRedraw(hTree,FALSE);
                                DumpRecurseTree(hTree, TreeView_GetChild(hTree, hItem));    // Kill off kids
                                SetWindowRedraw(hTree,TRUE);

                                TreeView_Expand(hTree, hItem, TVE_COLLAPSE | TVE_COLLAPSERESET);
                                
                                pCDInfo->pCDTitle = NULL;
                                pCDInfo->dwTrack = 0;
                                pCDInfo->fdwType = CDINFO_CDROM;

                                LoadString( m_hInst, IDS_NODISC, szNoDisc, sizeof( szNoDisc )/sizeof(TCHAR) );
                                
                                wsprintf(str, FORMAT_LET_NAME, pCDUnit->szDriveName, szNoDisc);

	                            item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN ;
                                item.iImage = item.iSelectedImage = (int) NOCD_IMAGE;
	                            item.pszText = str;
                                item.cChildren = 0;

                                TreeView_SetItem(hTree, &item); 

                                hItem = TreeView_GetSelection(hTree);
                                TreeView_SelectItem(hTree, NULL);
                                TreeView_SelectItem(hTree, hItem);
                            }
                            else
                            {   
                                LPCDTITLE pCDTitle = pCDTitleList;      // Lets find the title for this CD
                    
                                while (pCDTitle)
                                {
                                    if (pCDTitle->dwTitleID == pCDInfo->pCDUnit->dwTitleID && !pCDTitle->fRemove)
                                    {
                                        break;
                                    }
                                    pCDTitle = pCDTitle->pNext;
                                }

                                if (pCDTitle)
                                {
                                    pCDInfo->pCDTitle = pCDTitle;
                                    pCDInfo->dwTrack = pCDTitle->dwNumTracks;
                                    pCDInfo->fdwType = CDINFO_CDROM;

                                    pCDTitle->fDownLoading = pCDUnit->fDownLoading;
 	                                item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN;
                                    item.cChildren = pCDTitle->dwNumTracks;
                                    item.iImage = item.iSelectedImage = (int) CD_IMAGE;
                                    TreeView_SetItem(hTree, &item); 

                                    RefreshTree(hDlg, pCDTitle, pCDTitle->dwTitleID);
                                }
                                else
                                {
                                    TCHAR   szUnknown[CDSTR];
                                    TCHAR   szDownLoading[CDSTR];
                                    TCHAR   str[MAXLABEL];

                                    pCDInfo->pCDTitle = NULL;
                                    pCDInfo->dwTrack = pCDUnit->dwNumTracks;
                                    pCDInfo->fdwType = CDINFO_CDROM;

                                    if (pCDUnit->fDownLoading)
                                    {
                                        LoadString( m_hInst, IDS_DOWNLOADING, szDownLoading, sizeof( szDownLoading )/sizeof(TCHAR) );
                                        wsprintf(str, FORMAT_NAME, szDownLoading);
                                    }
                                    else
                                    {
                                        LoadString( m_hInst, IDS_UNKNOWNTITLE, szUnknown, sizeof( szUnknown )/sizeof(TCHAR) );
                                        wsprintf(str, FORMAT_LET_NAME, pCDInfo->pCDUnit->szDriveName, szUnknown);
                                    }

	                                item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE ;
                                    item.iImage = item.iSelectedImage = (int) CD_IMAGE;
	                                item.pszText = str;

                                    TreeView_SetItem(hTree, &item); 
                                }

                                mhdr.code = TVN_SELCHANGED;
                                PlayListNotify(hDlg, &mhdr);
                            }

                            break;
                        }
                    }
                }

                hItem = TreeView_GetNextSibling(hTree,hItem);
            }
        }
    }   
}


STDMETHODIMP_(void) CCDOpt::NotifyTitleChange(LPCDTITLE pCDTitle)
{
    LPCDUNIT pCDUnit = m_pCDCopy->pCDUnitList;

    while(pCDUnit)
    {
        if (pCDUnit->dwTitleID == pCDTitle->dwTitleID && m_pCDCopy->pfnOptionsCallback)
        {
            pCDUnit->fChanged = TRUE;
            m_pCDCopy->pfnOptionsCallback(m_pCDCopy);
            pCDUnit->fChanged = FALSE;
        }

        pCDUnit = pCDUnit->pNext;
    }
}


STDMETHODIMP_(void) CCDOpt::ArtistNameChange(HWND hDlg, HTREEITEM hItem, TCHAR *szName)
{
    HWND        hTree =  GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hKid = TreeView_GetChild(hTree, hItem);
    TV_ITEM     item;
 
    while (hKid)
    {
        item.mask = TVIF_PARAM;
        item.hItem = hKid;
    
        if (TreeView_GetItem(hTree, &item))
        {
            LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

            if (pCDInfo)
            {
                LPCDTITLE pCDTitle = pCDInfo->pCDTitle;

                if (pCDTitle)
                {
                    pCDTitle->fChanged = TRUE;
                    lstrcpy(pCDTitle->szArtist, szName);
                    NotifyTitleChange(pCDTitle);
                }
            }
        }

        hKid = TreeView_GetNextSibling(hTree, hKid);
    }
}


STDMETHODIMP_(void) CCDOpt::EndEditReturn(HWND hDlg)
{
    HWND        hTree =  GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem = TreeView_GetSelection(hTree);
    TV_ITEM     item;
 
    item.mask = TVIF_PARAM;
    item.hItem = hItem;
    
    if (TreeView_GetItem(hTree, &item))
    {
        LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;
        
        if (pCDInfo->fdwType == (DWORD)CDINFO_TRACK)
        {
            HTREEITEM hSib = TreeView_GetNextSibling(hTree, hItem);

            if (hSib == NULL)
            {
                HTREEITEM hPrevSib;

                hPrevSib = TreeView_GetPrevSibling(hTree, hItem);
                hSib = hPrevSib;

                while (hPrevSib)
                {
                    hPrevSib = TreeView_GetPrevSibling(hTree, hPrevSib);
                    
                    if (hPrevSib != NULL)
                    {
                        hSib = hPrevSib;
                    }    
                }
            }

            if (hSib)
            {
                TreeView_SelectItem(hTree, hSib);
                TreeView_EnsureVisible(hTree, hSib);
                TreeView_EditLabel(hTree, hSib);
            }
        }
    }
}



LRESULT CALLBACK CCDOpt::SubProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CCDOpt *pCDOpt = (CCDOpt *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    LRESULT lResult = 0;
       
    if (pCDOpt)
    {
        switch (msg)
        {
            case WM_GETDLGCODE:
            {
                LPMSG pMsg = (LPMSG) lParam;
                
                if (pMsg)
                {
                    if (wParam == VK_RETURN)
                    {
                        pCDOpt->m_fEditReturn = TRUE;
                    }
                }

                return(DLGC_WANTMESSAGE | CallWindowProc((WNDPROC) pCDOpt->m_pfnSubProc, hWnd, msg, wParam, lParam));
            }
            break;
        }

        lResult = CallWindowProc((WNDPROC) pCDOpt->m_pfnSubProc, hWnd, msg, wParam, lParam);
    }

    return (lResult);
}



STDMETHODIMP_(void) CCDOpt::SubClassDlg(HWND hDlg)
{
    if (m_pfnSubProc == NULL)
    {
        HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
        HWND hEdit = TreeView_GetEditControl(hTree);

        if (hEdit != NULL)
        {
            SetWindowLongPtr(hEdit,GWLP_USERDATA,(LONG_PTR) this);
            m_pfnSubProc = (WNDPROC)SetWindowLongPtr(hEdit,GWLP_WNDPROC,(LONG_PTR) SubProc);
        }
    }
}


STDMETHODIMP_(void) CCDOpt::UnSubClassDlg(HWND hDlg)
{
    if (m_pfnSubProc != NULL)
    {
        HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
        HWND hEdit = TreeView_GetEditControl(hTree);

        if (hEdit)
        {
            SetWindowLongPtr(hEdit,GWLP_WNDPROC,(LONG_PTR) m_pfnSubProc);
            m_pfnSubProc = NULL;
        }
    }
}


STDMETHODIMP_(void) CCDOpt::SetArtistExpand(HWND hDlg, HTREEITEM hItem, BOOL fExpand)
{
    HWND        hTree =  GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hKid = TreeView_GetChild(hTree, hItem);
    TV_ITEM     item;

    while (hKid)
    {
        item.mask = TVIF_PARAM;
        item.hItem = hKid;

        if (TreeView_GetItem(hTree, &item))
        {
            LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

            if (pCDInfo)
            {
                LPCDTITLE pCDTitle = pCDInfo->pCDTitle;

                if (pCDTitle)
                {
                    pCDTitle->fArtistExpanded = fExpand;
                }
            }
        }

        hKid = TreeView_GetNextSibling(hTree, hKid);
    }
}




STDMETHODIMP_(BOOL) CCDOpt::PlayListNotify(HWND hDlg, LPNMHDR pnmh)
{
    BOOL fReturnVal = TRUE;

    switch (pnmh->code)
    {
        case NM_RCLICK:
        {
            TreeItemMenu(hDlg);

            fReturnVal = TRUE;
        }
        break;

        case TVN_KEYDOWN:
        {   
            TV_KEYDOWN * pkd = (TV_KEYDOWN *) pnmh;
 
            switch(pkd->wVKey)
            {
                case VK_DELETE:
                {
                    DeleteTitle(hDlg);
                }
                break;
     
                case VK_F2:
                {
                    EditTreeItem(hDlg);
                }
                break;

                case VK_F5:
                {
                    if (m_pCDData)
                    {
                        HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);

                        DumpMixerTree(hDlg);

                        SetWindowRedraw(hTree,FALSE);
                        TreeView_DeleteAllItems(hTree);
                        SetWindowRedraw(hTree,TRUE);

                        m_pCDData->PersistTitles();
                        m_pCDData->UnloadTitles();
                        m_pCDData->LoadTitles(hDlg);

                        InitPlayLists(hDlg, m_pCDData);
                    }
                }

                break;
            }
        }
        break;

        case NM_DBLCLK:
        {              
            if (pnmh->idFrom == IDC_CDTREE)
            {
                HWND hTree =  GetDlgItem(hDlg, IDC_CDTREE);
                HTREEITEM hItem = TreeView_GetSelection(hTree);
                TV_HITTESTINFO  ht;

                if (hItem)
                {
                    GetCursorPos(&ht.pt);
                    ScreenToClient(hTree, &ht.pt);
                    TreeView_HitTest(hTree, &ht);

                    if ((ht.flags & TVHT_ONITEM) && (TreeView_GetChild(hTree, hItem) == NULL) && IsWindowEnabled(GetDlgItem(hDlg,IDC_EDITPLAYLIST))) 
                    {
                        FORWARD_WM_COMMAND(hDlg, IDC_EDITPLAYLIST, 0, 0, PostMessage);
                    }
                }
            }
        }
        break;

        case TVN_SELCHANGED:
        {
            HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
            TV_ITEM item;
            BOOL fEnable = FALSE;

            memset(&item, 0, sizeof(item));

            item.hItem = TreeView_GetSelection(hTree);
            item.mask = TVIF_PARAM;

            if (TreeView_GetItem(hTree, &item))
            {
                LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;
                TCHAR szButton[64];
                
                LoadString( m_hInst, IDS_EDITPLAYLIST, szButton, sizeof( szButton )/sizeof(TCHAR) );

                if (pCDInfo->pCDTitle == NULL && pCDInfo->fdwType == (DWORD)CDINFO_CDROM && pCDInfo->pCDUnit && pCDInfo->pCDUnit->dwTitleID != (DWORD)CDTITLE_NODISC)
                {
                    LoadString( m_hInst, IDS_CREATEPLAYLIST, szButton, sizeof( szButton )/sizeof(TCHAR) );
                    fEnable = TRUE;
                } 
                else if (pCDInfo->pCDTitle && !pCDInfo->pCDTitle->fDownLoading)
                {
                    fEnable = TRUE; 
                }  
                
                SetWindowText(GetDlgItem(hDlg, IDC_EDITPLAYLIST), szButton);
            }

            EnableWindow(GetDlgItem(hDlg, IDC_EDITPLAYLIST), fEnable);
        }
        break;

        case TVN_ITEMEXPANDED:
        {
            NM_TREEVIEW * ptv = (NM_TREEVIEW *) pnmh;

            HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
            TV_ITEM item;

            memset(&item,0,sizeof(item));
            item.mask = TVIF_PARAM;
            item.hItem = ptv->itemNew.hItem;

            if (TreeView_GetItem(hTree,&item))
            {
                BOOL fExpanded = (ptv->itemNew.state & TVIS_EXPANDED) ? TRUE : FALSE;

                if (item.lParam)
                {
                    LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

                    if (pCDInfo)
                    {
                        LPCDTITLE pCDTitle = pCDInfo->pCDTitle;

                        if (pCDInfo->fdwType == (DWORD)CDINFO_DRIVES)
                        {
                            m_fDrivesExpanded = fExpanded;
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_ALBUMS)
                        {
                            m_fAlbumsExpanded = fExpanded;
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_CDROM && pCDTitle)
                        {
                            pCDTitle->fDriveExpanded = fExpanded;
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_DISC && pCDTitle)
                        {
                            pCDTitle->fAlbumExpanded = fExpanded;
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_ARTIST)
                        {
                            SetArtistExpand(hDlg, ptv->itemNew.hItem, fExpanded);
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_TITLE && pCDTitle)
                        {
                            pCDTitle->fAlbumExpanded = fExpanded;
                        }
                    }
                }
            }
        }
        break;

        case TVN_ITEMEXPANDING:
        {
            NM_TREEVIEW * ptv = (NM_TREEVIEW *) pnmh;

            HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
            TV_ITEM item;

            memset(&item,0,sizeof(item));
            item.mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE ;
            item.hItem = ptv->itemNew.hItem;

            if (TreeView_GetItem(hTree,&item))
            {
                if ((ptv->itemNew.state & TVIS_EXPANDED) && item.iImage == CDOPEN_IMAGE)
                {
                    item.iImage = item.iSelectedImage = (int) CDCASE_IMAGE;
                }
                else if (!(ptv->itemNew.state & TVIS_EXPANDED) && item.iImage == CDCASE_IMAGE)
                {
                    item.iImage = item.iSelectedImage = (int) CDOPEN_IMAGE;
                }

                TreeView_SetItem(hTree, &item);
            }
        }
        break;

        case TVN_BEGINLABELEDIT:
        {
            TV_DISPINFO * ptv = (TV_DISPINFO *) pnmh;
            LPCDTREEINFO pCDInfo = (LPCDTREEINFO) ptv->item.lParam;  
            BOOL fResult = TRUE;

            if (pCDInfo->fdwType & CDINFO_EDIT)
            {
                fResult = FALSE;

                SendMessage( hDlg, DM_SETDEFID, IDC_CDTREE, 0L);
                SubClassDlg(hDlg);
            }

            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR) fResult);                
        }
        break;

        case TVN_ENDLABELEDIT:
        {
            TV_DISPINFO * ptv = (TV_DISPINFO *) pnmh;
                               
            if (ptv->item.lParam != NULL)
            {
                LPCDTREEINFO pCDInfo = (LPCDTREEINFO) ptv->item.lParam;
                BOOL fResult = TRUE;

                TCHAR *pStr = ptv->item.pszText;
            
                if (pStr)
                {
                    while(*pStr != TEXT('\0') && (*pStr == TEXT(' ') || *pStr == TEXT('\t')))  // Unknown artist are null string or whitespace
                    {
                        pStr++;
                    } 
                
                    if (lstrlen(pStr) >= CDSTR)
                    {
                        pStr[CDSTR - 1] = TEXT('\0');
                    }

                    if (*pStr == TEXT('\0'))          // Reject whitespace only responses
                    {
                        fResult = FALSE;              
                    }                       
                    else
                    {
                        TCHAR *pDst = NULL;

                        if (pCDInfo->fdwType == (DWORD)CDINFO_ARTIST)
                        {
                            if (pCDInfo->pCDTitle == NULL)
                            {
                                ArtistNameChange(hDlg, ptv->item.hItem, pStr);
                                pDst = NULL;
                            }
                            else
                            {
                                pDst = pCDInfo->pCDTitle->szArtist;
                            }
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_TITLE)
                        {
                            pDst = pCDInfo->pCDTitle->szTitle;
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_TRACK)
                        {
                            if (pCDInfo->pCDTitle->pTrackTable && pCDInfo->dwTrack < pCDInfo->pCDTitle->dwNumTracks)
                            {
                                pDst = pCDInfo->pCDTitle->pTrackTable[pCDInfo->dwTrack].szName;
                            }
                        }

                        if (pDst)
                        {
                            pCDInfo->pCDTitle->fChanged = TRUE;
                            lstrcpy(pDst, pStr);

                            RefreshTree(hDlg, pCDInfo->pCDTitle, pCDInfo->pCDTitle->dwTitleID);
                            ToggleApplyButton(hDlg);

                            NotifyTitleChange(pCDInfo->pCDTitle);
                        }
                    }
                }
                
                UnSubClassDlg(hDlg);

                if (m_fEditReturn)
                {
                    m_fEditReturn = FALSE;
                    EndEditReturn(hDlg);   
                }

                SendMessage( hDlg, DM_SETDEFID, IDOK, 0L );
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR) fResult);    
            }
        }
        break;
        
        case PSN_QUERYCANCEL:
        {
            LPCDTITLE pCDTitle = m_pCDData->GetTitleList();

            DumpMixerTree(hDlg);

            while (pCDTitle)
            {
                if (pCDTitle->fChanged || pCDTitle->fRemove)
                {
                    TCHAR szSave[CDSTR];
                    TCHAR szAlert[CDSTR];

                    LoadString( m_hInst, IDS_SAVEPROMPT, szSave, sizeof( szSave )/sizeof(TCHAR) );
                    LoadString( m_hInst, IDS_ALERTTEXT, szAlert, sizeof( szAlert )/sizeof(TCHAR) );

                    if (MessageBox(hDlg, szSave, szAlert, MB_YESNO | MB_ICONWARNING) == IDYES)
                    {
                        m_pCDData->PersistTitles();   
                    }
                    break;
                }

                pCDTitle = pCDTitle->pNext;

                fReturnVal = FALSE;
            }
        }
        break;

        case PSN_APPLY:
        {
            ApplyCurrentSettings();
        }
        break;
    }

    return (fReturnVal);
}


          
STDMETHODIMP_(BOOL) CCDOpt::PlayLists(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fResult = TRUE;
   
    switch (msg) 
    { 
        default:
            fResult = FALSE;
        break;
        
        case WM_CONTEXTMENU:
        {      
            if ((HWND)wParam != GetDlgItem(hDlg, IDC_CDTREE))
            {
                WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)aPlayListHelp);
            }
        }
        break;
           
        case WM_HELP:
        {     
            WinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPSTR)aPlayListHelp);
        }
        break;

        case WM_DESTROY:
        {  
            if (m_pCDData)
            {
                DumpMixerTree(hDlg);
                m_pCDData->UnloadTitles();
                ImageList_Destroy(m_hImageList);
                m_hImageList = NULL;
                m_hList = NULL;
            }
        }
        break;

        case WM_INITDIALOG:
        {            
            #ifdef UNICODE
            HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
            if (hTree)
            {
                TreeView_SetUnicodeFormat(hTree,TRUE);
            }
            #endif

            if (m_pCDData)
            {
                m_hList = hDlg;
                m_pCDData->LoadTitles(hDlg);
            }

            m_fDrivesExpanded = TRUE;
            m_fAlbumsExpanded = FALSE;


            fResult = InitPlayLists(hDlg, m_pCDData);
        }        
        break;


        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {  
                case ID_DOWNLOADTITLE:
                    DownloadTitle(hDlg);
                break;

                case ID_DELETETITLE:
                    DeleteTitle(hDlg);
                break;

                case ID_EDITARTISTNAME:
                case ID_EDITTITLENAME:
                case ID_EDITTRACKNAME:
                    EditTreeItem(hDlg);
                break;

                case ID_CACHEALBUM:
                    CacheAlbum(hDlg);
                break;

                case ID_CACHETRACK:
                    CacheTrack(hDlg);
                break;

                case ID_DELETECACHEDALBUM:
                    RemoveCachedAlbum(hDlg);
                break;
                
                case ID_DELETECACHEDTRACK :
                    RemoveCachedTrack(hDlg);
                break;
                  
                case ID_EXPAND:
                    ToggleExpand(hDlg);
                break;
                                                    
                case IDC_EDITPLAYLIST:
                    EditCurrentTitle(hDlg);
                break;
                
                case IDC_BYARTIST:
                    ToggleByArtist(hDlg, m_pCDData);
                break;
                
                case ID_HELPMENU:
                    WinHelp (GetDlgItem(hDlg, IDC_CDTREE), gszHelpFile, HELP_WM_HELP, (ULONG_PTR) (LPSTR) aPlayListHelp);
                break;

                default:
                    fResult = FALSE;
                break;
            }
        }
        break;

        case WM_NOTIFY:
        {
            fResult = PlayListNotify(hDlg, (LPNMHDR) lParam);
        }
        break;
    }

    return fResult;
}



///////////////////
// Dialog handler 
//
BOOL CALLBACK CCDOpt::PlayListsProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);
    
    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) ((LPPROPSHEETPAGE) lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);

    }
    
    if (pCDOpt)
    {
        fResult = pCDOpt->PlayLists(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}

MMRESULT FAR PASCAL
ChooseDestinationFormat(
    HINSTANCE       hInst,
    HWND            hwndParent,
    PWAVEFORMATEX   *ppwfxOut,
    DWORD           fdwEnum)
{
    ACMFORMATCHOOSE     cwf;
    MMRESULT            mmr;
    LPWAVEFORMATEX      pwfx;
    DWORD               dwMaxFormatSize;
    WAVEFORMATEX        wfxCD;

    wfxCD.wFormatTag = WAVE_FORMAT_PCM;
    wfxCD.nChannels = 2;
    wfxCD.nSamplesPerSec = 44100;
    wfxCD.nAvgBytesPerSec = 176400;
    wfxCD.nBlockAlign = 4;
    wfxCD.wBitsPerSample = 16;
    wfxCD.cbSize = sizeof(wfxCD);
    
    mmr = acmMetrics(NULL
                     , ACM_METRIC_MAX_SIZE_FORMAT
                     , (LPVOID)&dwMaxFormatSize);

    if (mmr != MMSYSERR_NOERROR)
        return mmr;
    
    pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, (UINT)dwMaxFormatSize);
    if (pwfx == NULL)
        return MMSYSERR_NOMEM;
    
    memset(&cwf, 0, sizeof(cwf));
    
    cwf.cbStruct    = sizeof(cwf);
    cwf.hwndOwner   = hwndParent;
    cwf.fdwStyle    = 0L;

    cwf.fdwEnum     = 0L;           // all formats!
    cwf.pwfxEnum    = NULL;         // all formats!
    
    if (fdwEnum)
    {
        cwf.fdwEnum     = fdwEnum;
        cwf.pwfxEnum    = &wfxCD;
    }
    
    cwf.pwfx        = (LPWAVEFORMATEX)pwfx;
    cwf.cbwfx       = dwMaxFormatSize;

    mmr = acmFormatChoose(&cwf);
    
    if (mmr == MMSYSERR_NOERROR)
        *ppwfxOut = pwfx;
    else
    {
        *ppwfxOut = NULL;
        GlobalFreePtr(pwfx);
    }
    return mmr;
    
}

void CCDOpt::CacheAlbum(HWND hDlg)
{
    HWND            hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM       hItem = TreeView_GetSelection(hTree);
    TV_ITEM         item;
    LPWAVEFORMATEX  lpwfx;

    if (hItem)
    {
        item.mask = TVIF_PARAM;
        item.hItem = hItem;

        if (TreeView_GetItem(hTree, &item))
        {
            LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

            if (pCDInfo)
            {
                if (pCDInfo->fdwType == CDINFO_CDROM)
                {
                    if (ChooseDestinationFormat(NULL,hDlg,&lpwfx,ACM_FORMATENUMF_CONVERT)==MMSYSERR_NOERROR)
                    {
                        HTREEITEM hTrack = NULL;
                        hTrack = TreeView_GetChild(hTree,hItem);
                        while (hTrack)
                        {
                            CacheTrack(hDlg,hTrack,lpwfx);
                            hTrack = TreeView_GetNextSibling(hTree,hTrack);
                        } //end track loop

                        GlobalFreePtr(lpwfx);
                    } //end if format chosen
                } //end sanity check
            } //end if pc info ok
        } //end if tree item data found
    } //end if tree item ok
}

STDMETHODIMP_(void) CCDOpt::GetTitleDir(DWORD dwTitleID, LPTSTR pDirName)
{
    TCHAR szDirMain[MAX_PATH];
    TCHAR szDirCache[MAX_PATH];

    ExpandEnvironmentStrings(TEXT("%ProgramFiles%\\CD Player"),szDirMain,MAX_PATH);
    CreateDirectory(szDirMain,NULL);

    wsprintf(szDirCache,TEXT("%s\\Music"),szDirMain);
    CreateDirectory(szDirCache,NULL);

    wsprintf(pDirName,TEXT("%s\\%d"),szDirCache,dwTitleID);
    CreateDirectory(pDirName,NULL);
}

STDMETHODIMP_(BOOL) CCDOpt::IsTrackCached(DWORD dwTitleID, DWORD dwTrack)
{
    BOOL fRet = FALSE;

    TCHAR szPath[MAX_PATH];
    TCHAR szFilename[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;

    GetTitleDir(dwTitleID,szPath);
    wsprintf(szFilename,TEXT("%s\\%02d.WAV"),szPath,dwTrack);

	hFile = CreateFile(szFilename, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
        fRet = TRUE;
    }

    return fRet;
}

STDMETHODIMP_(void) CCDOpt::RemoveCachedTrack(HWND hDlg, HTREEITEM hTrack)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem;
    
    if (hTrack)
    {
        hItem = hTrack;
    }
    else
    {
        hItem = TreeView_GetSelection(hTree);
    }

    TV_ITEM item;

    if (hItem)
    {
        item.mask = TVIF_PARAM;
        item.hItem = hItem;
    
        if (TreeView_GetItem(hTree, &item))
        {
            LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

            if (pCDInfo)
            {
                if (pCDInfo->fdwType == CDINFO_TRACK)
                {
                    HTREEITEM hParent = TreeView_GetParent(hTree,item.hItem);

                    if (hParent)
                    {
                        TV_ITEM itemParent;
                        itemParent.hItem = hParent;            
                        itemParent.mask = TVIF_STATE | TVIF_HANDLE | TVIF_CHILDREN | TVIF_PARAM;
                
                        if (TreeView_GetItem(hTree, &itemParent))
                        {
                            LPCDTREEINFO pCDInfoParent = (LPCDTREEINFO) itemParent.lParam;

                            if (pCDInfoParent)
                            {
                                if (pCDInfoParent->fdwType == (DWORD)CDINFO_CDROM)
                                {
                                    TCHAR szPath[MAX_PATH];
                                    TCHAR szFilename[MAX_PATH];
                                    HANDLE hFile = INVALID_HANDLE_VALUE;

                                    GetTitleDir(pCDInfoParent->pCDTitle->dwTitleID,szPath);
                                    wsprintf(szFilename,TEXT("%s\\%02d.WAV"),szPath,pCDInfo->dwTrack);

                                    DeleteFile(szFilename);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

void CCDOpt::CacheTrack(HWND hDlg, HTREEITEM hTrack, LPWAVEFORMATEX lpwfx)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem;
    
    if (hTrack)
    {
        hItem = hTrack;
    }
    else
    {
        hItem = TreeView_GetSelection(hTree);
    }

    TV_ITEM item;

    if (hItem)
    {
        item.mask = TVIF_PARAM;
        item.hItem = hItem;
    
        if (TreeView_GetItem(hTree, &item))
        {
            LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

            if (pCDInfo)
            {
                if (pCDInfo->fdwType == CDINFO_TRACK)
                {
                    HTREEITEM hParent = TreeView_GetParent(hTree,item.hItem);

                    if (hParent)
                    {
                        TV_ITEM itemParent;
                        itemParent.hItem = hParent;            
                        itemParent.mask = TVIF_STATE | TVIF_HANDLE | TVIF_CHILDREN | TVIF_PARAM;
                
                        if (TreeView_GetItem(hTree, &itemParent))
                        {
                            LPCDTREEINFO pCDInfoParent = (LPCDTREEINFO) itemParent.lParam;

                            if (pCDInfoParent)
                            {
                                if (pCDInfoParent->fdwType == (DWORD)CDINFO_CDROM)
                                {
                                    BOOL fCreated = FALSE;
                                    if (!lpwfx)
                                    {
                                        fCreated = TRUE;
                                        ChooseDestinationFormat(NULL,hDlg,&lpwfx,ACM_FORMATENUMF_CONVERT);
                                    }
                                    
                                    if (lpwfx)
                                    {
                                        TCHAR szName[MAX_PATH];
                                        TCHAR szDir[MAX_PATH];
                                        GetTitleDir(pCDInfoParent->pCDTitle->dwTitleID,szDir);
                                        wsprintf(szName,TEXT("%s\\%02d.WAV"),szDir,pCDInfo->dwTrack);
                                        StoreTrack(hDlg,pCDInfoParent->pCDUnit->szDriveName[0],pCDInfo->dwTrack+1,szName,lpwfx);
                                        if (fCreated)
                                        {
                                            GlobalFreePtr(lpwfx);
                                        }

                                        HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);

                                        DumpMixerTree(hDlg);

                                        SetWindowRedraw(hTree,FALSE);
                                        TreeView_DeleteAllItems(hTree);
                                        SetWindowRedraw(hTree,TRUE);

                                        UpdateTitleTree(hDlg, m_pCDData);
                                    }
                                }
                            } //end if parent has info
                        } //end parent item
                    } //end if parent
                } //end if track
            } //end if valid info
        } //end if get item
    } //end if hitem valid
}

STDMETHODIMP_(void) CCDOpt::RemoveCachedAlbum(HWND hDlg)
{
    HWND            hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM       hItem = TreeView_GetSelection(hTree);
    TV_ITEM         item;

    if (hItem)
    {
        item.mask = TVIF_PARAM;
        item.hItem = hItem;

        if (TreeView_GetItem(hTree, &item))
        {
            LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

            if (pCDInfo)
            {
                if (pCDInfo->fdwType == CDINFO_CDROM)
                {
                    HTREEITEM hTrack = NULL;
                    hTrack = TreeView_GetChild(hTree,hItem);
                    while (hTrack)
                    {
                        RemoveCachedTrack(hDlg,hTrack);
                        hTrack = TreeView_GetNextSibling(hTree,hTrack);
                    } //end track loop
                } //end sanity check

                //now we clean up the directory
                TCHAR szPath[MAX_PATH];
                GetTitleDir(pCDInfo->pCDTitle->dwTitleID,szPath);
                RemoveDirectory(szPath);

            } //end if pc info ok
        } //end if tree item data found
    } //end if tree item ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\helpids.h ===
// Context Help IDs deluxe CD player preference dialog         

extern TCHAR gszHelpFile[];

// PlayOpts dialog help ID's

#define IDH_PLAYBACKOPTIONS                     1100   // Options that control application behavior (startplay, exitstop, topmost)
#define IDH_STARTPLAY                           1101   // Checkbox, if checked cd starts playing when app launches
#define IDH_EXITSTOP                            1102   // Checkbox, if checked cd stops playing when app exits
#define IDH_TOPMOST                             1103   // Checkbox, if checked CD player window floats on top of all other windows
#define IDH_TIMEDISPLAY                         1104   // Options that allow you to change the default time display
#define IDH_CDTIME                              1105   // RadioButton, display current CD time
#define IDH_TRACKTIME                           1106   // RadioButton, display current track time
#define IDH_TRACKTIMEREMAIN                     1107   // RadioButton, display remaining track time
#define IDH_CDTIMEREMAIN                        1108   // RadioButton, display remaining CD time
#define IDH_PREVIEWOPTION                       1109   // Descripe Preview Feature
#define IDH_PREVIEWSLIDER                       1110   // Slider - allows you to set the preview time
#define IDH_PREVIEWDISPLAY                      1111   // display - shows your your current prview time
#define IDH_PLAYBACKDEFAULTS                    1112   // Button - Sets playback options defaults
#define IDH_SETVOLUMECONTROL                    1113   // Button - Puts up advanced volume dialog to configure volume control for cd players

// Volume configuration dialog help ID's

#define IDH_VOL_MSG                             1000   // Purpose of Advanced Volume Config Dialog
#define IDH_SELECTCDPLAYER                      1001   // ComboBox to select cd player to configure
#define IDH_SELECTCDMIXER                       1002   // ComboBox to select cd player to configure
#define IDH_SELECTCDCONTROL                     1003   // ComboBox to select cd player to configure
#define IDH_USEMIXERDEFAULTS                    1004   // Button to revert to calcuated cd line volume line and mixer

// TitleOpts dialog help ID's

#define IDH_DOWNLOADING                         1200   // Explains internet download feature
#define IDH_ABOUTALBUMS                         1201   // Explains album information
#define IDH_AUTODOWNLOADENABLED                 1202   // Checkbox, if checked the player will attempt downloading of album information
#define IDH_DOWNLOADPROMPT                      1203   // Checkbox, if checked user is prompted when downloading is attempted
#define IDH_SELECTCURRENTPROVIDER               1204   // Combobox to select primary provider
#define IDH_ABOUTBATCHING                       1205   // Explains album batching
#define IDH_BATCHENABLED                        1206   // Checkbox, if checked batching is enabled
#define IDH_NUMBATCHED                          1207   // Text - informs user how many albums are batched
#define IDH_DOWNLOADNOW                         1208   // Button - attempts to download any batched albums
#define IDH_TITLEDEFAULTS                       1209   // Button - Sets title options to default values

// PlayList dialog help ID's

#define IDH_ALBUMDATABASE                       1300   // Explains album database browser tree control
#define IDH_VIEWBYARTIST                        1301   // Checkbox - If checked, database shows albums in database by artist, if not, by album title
#define IDH_EDITPLAYLIST                        1302   // Button - puts up Playlist Editor Dialog

// PlayList Editor dialog help ID's

#define IDH_EDIT_ARTIST                         1400   // Editbox - Edit artist name
#define IDH_EDIT_TITLE                          1401   // Editbox - Edit title name
#define IDH_AVAILTRACKS                         1402   // Combobox - select/edit track names
#define IDH_ADDTOPLAYLIST                       1403   // Button - Add current selected track to playlist
#define IDH_PLAYLIST                            1404   // listbox - List current play list
#define IDH_PLAYLIST_REMOVE                     1405   // button - remove current selected tracks in playlist listbox
#define IDH_PLAYLIST_CLEAR                      1406   // button - clear all tracks in playlist listbox
#define IDH_PLAYLIST_RESET                      1407   // button - reset playlist listbox to actuall album track order playlist

#define IDH_SYSTRAY_ICON                        1500   // Checkbox - enables the systray icons for the cd player
#define IDH_SUBMIT_ALBUM_DATA                   1501   // Button - Submits modified album information to internet data providers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\listedit.cpp ===
//--------------------------------------------------------------------------;
//
//  File: listedit.cpp
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;

#include "precomp.h"  
#include <regstr.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "optres.h"
#include "..\cdplay\playres.h"
#include "cdopti.h"
#include "cdoptimp.h"
#include "helpids.h"

#include "..\main\resource.h"
#include "..\main\mmfw.h"

//////////////
// Help ID's
//////////////

#pragma data_seg(".text")
const static DWORD aListEditHelp[] = 
{
    IDC_ARTIST_TEXT,        IDH_EDIT_ARTIST,
    IDC_EDIT_ARTIST,        IDH_EDIT_ARTIST,
    IDC_TITLE_TEXT,         IDH_EDIT_TITLE,
    IDC_EDIT_TITLE,         IDH_EDIT_TITLE,
    IDC_AVAILTRACKS_TEXT,   IDH_AVAILTRACKS,
    IDC_AVAILTRACKS,        IDH_AVAILTRACKS,
    IDC_ADDTOPLAYLIST,      IDH_ADDTOPLAYLIST,
    IDC_PLAYLIST_TEXT,      IDH_PLAYLIST,
    IDC_CURRLIST,           IDH_PLAYLIST,
    IDC_BUTTON_REMOVE,      IDH_PLAYLIST_REMOVE,
    IDC_BUTTON_CLEAR,       IDH_PLAYLIST_CLEAR,
    IDC_BUTTON_RESET,       IDH_PLAYLIST_RESET,
    IDC_UPLOADTITLE,        IDH_SUBMIT_ALBUM_DATA,
    0, 0
};
#pragma data_seg()



///////////////////
// Called to init the dialog when it first appears.  
//
STDMETHODIMP_(BOOL) CCDOpt::InitListEdit(HWND hDlg)
{
    DWORD dwTrack;
    LRESULT dwItem;
    LPWORD pNum = NULL;
    DWORD dwTracks;

    // Setup the CD Net object for uploading data
    /////////////////////////////////////////////
    if (m_pICDNet)
    {
        m_pICDNet->Release();
        m_pICDNet = NULL;
    }

    if (SUCCEEDED(CDNET_CreateInstance(NULL, IID_ICDNet, (void**)&m_pICDNet)))
    {
	    m_pICDNet->SetOptionsAndData((void *) this, (void *) m_pCDData);

        if (!(m_pICDNet->CanUpload() && m_pCDTitle->szTitleQuery && lstrlen(m_pCDTitle->szTitleQuery)))
        {
            m_pICDNet->Release();
            m_pICDNet = NULL;
        }
    }

    EnableWindow(GetDlgItem(hDlg, IDC_UPLOADTITLE), m_pICDNet != NULL);

	//Drag drop interface////////
	/////////////////////////////
	m_hInst = m_hInst;
	m_DragMessage = InitDragMultiList();
	if (m_hCursorNoDrop == NULL) {
        m_hCursorNoDrop = LoadCursor(NULL, IDC_NO);
    }

    if (m_hCursorDrop == NULL) {
        m_hCursorDrop = LoadCursor(m_hInst, MAKEINTRESOURCE(IDR_DROP));
    }

	if (m_hCursorDropCpy == NULL) {
        m_hCursorDropCpy = LoadCursor(m_hInst, MAKEINTRESOURCE(IDR_DROPCPY));
    }


	MakeMultiDragList( GetDlgItem(hDlg, IDC_CURRLIST));
    
	//Setup the track bitmap
	m_hbmTrack = LoadBitmap( m_hInst, MAKEINTRESOURCE(IDR_TRACK) );
	HDC hdc = GetDC( hDlg );
    m_hdcMem = CreateCompatibleDC( hdc );
    ReleaseDC( hDlg, hdc );
    SelectObject( m_hdcMem, m_hbmTrack );
	/////////////////////////////
	/////////////////////////////

    if (m_pCDTitle)
    {
        SendDlgItemMessage(hDlg, IDC_EDIT_ARTIST, WM_SETTEXT, 0, (LPARAM) m_pCDTitle->szArtist);
        SendDlgItemMessage(hDlg, IDC_EDIT_TITLE, WM_SETTEXT, 0, (LPARAM) m_pCDTitle->szTitle);
        
        m_dwTrack = 0;

        SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_RESETCONTENT, 0, 0);

        if (m_pCDTitle->pTrackTable)
        {
            for (dwTrack = 0; dwTrack < m_pCDTitle->dwNumTracks; dwTrack++)
            {
                dwItem = SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_ADDSTRING, 0, (LPARAM) m_pCDTitle->pTrackTable[dwTrack].szName);

                if (dwItem != CB_ERR && dwItem != CB_ERRSPACE && dwItem == m_dwTrack)
                {
                    SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_SETCURSEL, (WPARAM) dwItem, 0); 
                }
            }
        }
        else if (m_pCDTitle->dwNumTracks)
        {
            TCHAR szText[CDSTR];
            TCHAR szTrack[CDSTR];

            LoadString(m_hInst, IDS_TRACK, szTrack, sizeof(szTrack)/sizeof(TCHAR));

            for (dwTrack = 0; dwTrack < m_pCDTitle->dwNumTracks; dwTrack++)
            {
                wsprintf(szText,TEXT("%s %d"), szTrack, dwTrack + 1);
            
                dwItem = SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_ADDSTRING, 0, (LPARAM) szText);

                if (dwItem != CB_ERR && dwItem != CB_ERRSPACE && dwItem == m_dwTrack)
                {
                    SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_SETCURSEL, (WPARAM) dwItem, 0); 
                }
            }
        }

		SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), FALSE);
        SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_RESETCONTENT, 0, 0);

        pNum = m_pCDTitle->pPlayList;
        dwTracks = m_pCDTitle->dwNumPlay;

        if (pNum == NULL || dwTracks == 0)
        {
            dwTracks = m_pCDTitle->dwNumTracks;       
        }

        if (dwTracks)
        {
            for (dwTrack = 0; dwTrack < dwTracks; dwTrack++)
            {
                DWORD dwNum = dwTrack;

                if (pNum)
                {
                    dwNum = *pNum;
                    pNum++;
                }

                if (dwNum < m_pCDTitle->dwNumTracks)
                {
                    dwItem = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_ADDSTRING, 0, (LPARAM) m_pCDTitle->pTrackTable[dwNum].szName);

                    if(dwItem != LB_ERR && dwItem != LB_ERRSPACE)
                    {
                         SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_SETITEMDATA,  (WPARAM) dwItem, (LPARAM) dwNum);    
                    }
                }
            }
        }

		SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), TRUE);

        UpdateListButtons(hDlg);
    }

    return(TRUE);
}


STDMETHODIMP_(void) CCDOpt::AddTrackToPlayList(HWND hDlg, UINT_PTR dwTrack)
{
    LRESULT dwItem;
    DWORD   dwSize;

    dwSize = (DWORD)SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETLBTEXTLEN,  (WPARAM) dwTrack, 0);

    if (dwSize != CB_ERR)
    {
        dwSize++;

        TCHAR *szName = new(TCHAR[dwSize]);

        if (szName)
        {
            if (SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETLBTEXT,  (WPARAM) dwTrack, (LPARAM) szName) != CB_ERR)
            {
                if (dwSize >= CDSTR)    // Truncate the name to fit in our max cd title string size
                {
                    szName[CDSTR - 1] = '\0';
                }
				
                dwItem = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_ADDSTRING, 0, (LPARAM) szName);

                if (dwItem != LB_ERR && dwItem != LB_ERRSPACE)
                {
                    SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_SETITEMDATA,  (WPARAM) dwItem, (LPARAM) dwTrack);    
                }
				
            }

            delete szName;
        }
    }
}


STDMETHODIMP_(void) CCDOpt::ResetPlayList(HWND hDlg)
{
    UINT_PTR dwTrack;

	SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), FALSE);
    SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_RESETCONTENT, 0, 0);

    for (dwTrack = 0; dwTrack < m_pCDTitle->dwNumTracks; dwTrack++)
    {
        AddTrackToPlayList(hDlg, dwTrack);
    }
	SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), TRUE);
    UpdateListButtons(hDlg);
}



STDMETHODIMP_(void) CCDOpt::UpdateAvailList(HWND hDlg)
{
    TCHAR szName[CDSTR];

    if (SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, WM_GETTEXT,  (WPARAM) CDSTR, (LPARAM) szName) != CB_ERR)
    {
        SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), FALSE);

        SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_DELETESTRING, (WPARAM) m_dwTrack, 0);
        SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_INSERTSTRING, (WPARAM) m_dwTrack, (LPARAM) szName);

        SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), TRUE);
    }
}



STDMETHODIMP_(void) CCDOpt::AddToPlayList(HWND hDlg)
{
    LRESULT dwTrack;

    dwTrack = SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETCURSEL, 0, 0);

    if (dwTrack == CB_ERR) // Must be editing, no selection while editing.
    {  
        dwTrack = m_dwTrack;
    }

	SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), FALSE);	
    AddTrackToPlayList(hDlg, m_dwTrack);
	SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), TRUE);

    UpdateListButtons(hDlg);

}


STDMETHODIMP_(void) CCDOpt::AddEditToPlayList(HWND hDlg)
{
    TCHAR szName[CDSTR];
    LRESULT dwItem;
    
    if (SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, WM_GETTEXT,  (WPARAM) CDSTR, (LPARAM) szName) != CB_ERR)
    {
        dwItem = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_ADDSTRING, 0, (LPARAM) szName);

        if (dwItem != LB_ERR && dwItem != LB_ERRSPACE)
        {
            SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_SETITEMDATA,  (WPARAM) dwItem, (LPARAM) m_dwTrack);    
        }
    }
}


STDMETHODIMP_(void) CCDOpt::TrackEditChange(HWND hDlg)
{
    TCHAR szName[CDSTR];
    LRESULT dwTrack;
    LRESULT dwCount;
    
    if (SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, WM_GETTEXT,  (WPARAM) CDSTR, (LPARAM) szName) != CB_ERR)
    {
		//Reset the combo box content. Because the Currlist takes data from there.
		HWND hAvailWnd = GetDlgItem(hDlg, IDC_AVAILTRACKS);
        DWORD dwSel;

        dwSel = ComboBox_GetEditSel(hAvailWnd);
		ComboBox_DeleteString(hAvailWnd, m_dwTrack);
		ComboBox_InsertString(hAvailWnd, m_dwTrack, szName);
		ComboBox_SetCurSel(hAvailWnd, m_dwTrack); //Reset selection
		ComboBox_SetEditSel(hAvailWnd, LOWORD(dwSel), HIWORD(dwSel)); //Reset the text edit control.

		SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), FALSE);

        dwCount = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_GETCOUNT, 0, 0);

        while (dwCount--)
        {
            dwTrack = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_GETITEMDATA, (WPARAM) dwCount, (LPARAM) 0);

            if (dwTrack != LB_ERR && dwTrack == m_dwTrack)
            {
                LRESULT dwItem;

                SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_DELETESTRING, (WPARAM) dwCount, 0);

                dwItem = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_INSERTSTRING, (WPARAM) dwCount, (LPARAM) szName);
                
                if (dwItem != LB_ERR && dwItem != LB_ERRSPACE)
                {
                    SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_SETITEMDATA,  (WPARAM) dwCount, (LPARAM) m_dwTrack);    
                }
            }
        }
       
        SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), TRUE);
    }
}


STDMETHODIMP_(void) CCDOpt::UpdateListButtons(HWND hDlg)
{
    LRESULT dwItem;
	int     num;
	HWND	hPlayWnd = GetDlgItem(hDlg, IDC_CURRLIST);

    num = ListBox_GetSelCount( hPlayWnd );
    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_REMOVE), num > 0);

    dwItem = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_GETCOUNT,  0, 0);
    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_CLEAR), (dwItem != LB_ERR && dwItem != 0) );
}


STDMETHODIMP_(void) CCDOpt::RemovePlayListSel(HWND hDlg)
{
	int     num;
    int     i;
    int     *pList;
	HWND	hPlayWnd = GetDlgItem(hDlg, IDC_CURRLIST);

    /*
    ** Get the number of tracks currently selected.  Return if an error
    ** occurrs or zero tracks selected.
    */
    num = ListBox_GetSelCount( hPlayWnd );
    if ( num <= 0 ) {
        return;
    }

	pList = new int[num];
    ListBox_GetSelItems( hPlayWnd, num, pList );

    SetWindowRedraw( hPlayWnd, FALSE );
    for ( i = num - 1; i >= 0; i-- ) {

        ListBox_DeleteString( hPlayWnd, pList[i] );

    }

    SetWindowRedraw( hPlayWnd, TRUE );
   
    DWORD dwErr = ListBox_SetSel(hPlayWnd, TRUE , pList[0]);

    if (dwErr == LB_ERR && pList[0] > 0)
    {
        pList[0]--;
        ListBox_SetSel(hPlayWnd, TRUE , pList[0]);
    }

	delete pList;
	UpdateListButtons(hDlg);

}




STDMETHODIMP_(void) CCDOpt::OnDrawItem(HWND hDlg, const DRAWITEMSTRUCT *lpdis)
{
    if ( (lpdis->itemAction & ODA_DRAWENTIRE) || (lpdis->itemAction & ODA_SELECT) ) {

        DrawListItem(hDlg, lpdis->hDC, &lpdis->rcItem,lpdis->itemData, lpdis->itemState & ODS_SELECTED );

        if ( lpdis->itemState & ODS_FOCUS ) {
            DrawFocusRect( lpdis->hDC, &lpdis->rcItem );
        }
    }
}



STDMETHODIMP_(void) CCDOpt::DrawListItem(HWND hDlg, HDC hdc, const RECT *rItem, UINT_PTR itemIndex, BOOL selected)
{
    DWORD       dwROP;
    SIZE        si;
    UINT        i;
    TCHAR       s[TRACK_TITLE_LENGTH];
    TCHAR       szDotDot[] = TEXT("... ");
    int         cxDotDot;


    /*
    ** Check selection status, and set up to draw correctly
    */
    if ( selected ) {

        SetBkColor( hdc, GetSysColor( COLOR_HIGHLIGHT ) );
        SetTextColor( hdc, GetSysColor( COLOR_HIGHLIGHTTEXT ) );
        dwROP = MERGEPAINT;

    }
    else {

        SetBkColor( hdc, GetSysColor(COLOR_WINDOW));
        SetTextColor( hdc, GetSysColor(COLOR_WINDOWTEXT));
        dwROP = SRCAND;
    }

    /*
    ** Get track string
    */
	ComboBox_GetLBText( GetDlgItem(hDlg, IDC_AVAILTRACKS), itemIndex, s );

	/*
    ** Do we need to munge track name (clip to listbox)?
    */
    GetTextExtentPoint( hdc, szDotDot, lstrlen( szDotDot ), &si );
    cxDotDot = si.cx;

    i = lstrlen( s ) + 1;
    do {
        GetTextExtentPoint( hdc, s, --i, &si );
    } while( si.cx > (rItem->right - cxDotDot - 20)  );


    /*
    ** Draw track name
    */
    ExtTextOut( hdc, rItem->left + 20, rItem->top, ETO_OPAQUE | ETO_CLIPPED,
                rItem, s, i, NULL );

    if ( lstrlen( s ) > (int) i ) {

        ExtTextOut( hdc, rItem->left + si.cx + 20, rItem->top, ETO_CLIPPED,
                    rItem, szDotDot, lstrlen(szDotDot), NULL );
    }

    /*
    ** draw cd icon for each track
    */
    BitBlt( hdc, rItem->left, rItem->top, 14, 14, m_hdcMem, 0, 0, dwROP );
}



STDMETHODIMP_(BOOL) CCDOpt::IsInListbox(HWND hDlg, HWND hwndListbox, POINT pt)
{
    RECT    rc;

    ScreenToClient(hDlg, &pt);

    if ( ChildWindowFromPoint( hDlg, pt ) == hwndListbox ) {

        GetClientRect( hwndListbox, &rc );
        MapWindowRect( hwndListbox, hDlg, &rc );

        return PtInRect( &rc, pt );
    }

    return FALSE;
}




STDMETHODIMP_(int) CCDOpt::InsertIndex(HWND hDlg, POINT pt, BOOL bDragging)
{
    int     nItem;
    int     nCount;
	HWND hPlayWnd = GetDlgItem(hDlg, IDC_CURRLIST);

    nCount = ListBox_GetCount( hPlayWnd );
    nItem = LBMultiItemFromPt( hPlayWnd, pt, bDragging );

    /*
    ** If the mouse is not over any particular list item, but it is inside
    ** the client area of the listbox just append to end of the listbox.
    */

    if ( nItem == -1 ) {

        if ( IsInListbox( hDlg, hPlayWnd, pt ) ) {
            nItem = nCount;
        }
    }

    /*
    ** Otherwise, if the mouse is over a list item and there is
    ** at least one item in the listbox determine if the inertion point is
    ** above or below the current item.
    */

    else if ( nItem > 0 && nCount > 0 ) {

        long    pt_y;
        RECT    rc;

        ListBox_GetItemRect( hPlayWnd, nItem, &rc );
        ScreenToClient( hPlayWnd, &pt );

        pt_y = rc.bottom - ((rc.bottom - rc.top) / 2);

        if ( pt.y > pt_y ) {
            nItem++;
        }
    }

    DrawMultiInsert( hDlg, hPlayWnd, bDragging ? nItem : -1 );

    return nItem;
}




STDMETHODIMP_(BOOL) CCDOpt::OnQueryDrop( HWND hDlg, HWND hwndDrop, HWND hwndSrc, POINT ptDrop, DWORD dwState)
{
    int     index;
	HWND	hPlayWnd = GetDlgItem(hDlg, IDC_CURRLIST);

    index = InsertIndex( hDlg, ptDrop, TRUE );

    if ( index >= 0  ) {

        if ( (hwndSrc == hPlayWnd) && (dwState == DG_COPY) ) {

            SetCursor( m_hCursorDropCpy );
        }
        else {

            SetCursor( m_hCursorDrop );
        }
    }
    else {

        SetCursor( m_hCursorNoDrop );
    }

    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
    return TRUE;
}





STDMETHODIMP_(void) CCDOpt::MoveCopySelection(HWND hDlg, int iInsertPos, DWORD dwState)
{
    int         num;
    int         i;
    int         *pList;
    LIST_INFO   *pInfo;
	HWND		hPlayWnd = GetDlgItem(hDlg, IDC_CURRLIST);

    /*
    ** Get the number of tracks currently selected.  Return if an error
    ** occurrs or zero tracks selected.
    */
    num = ListBox_GetSelCount( hPlayWnd );
    if ( num <= 0 ) {
        return;
    }

    pList = new int[num];
    pInfo = new LIST_INFO[num];
    ListBox_GetSelItems( hPlayWnd, num, pList );


    SetWindowRedraw( hPlayWnd, FALSE );

    for ( i = num - 1; i >= 0; i-- ) {

        ListBox_GetText( hPlayWnd, pList[i], pInfo[i].chName );
        pInfo[i].dwData = ListBox_GetItemData( hPlayWnd, pList[i] );

        if ( dwState == DG_MOVE ) {
            pInfo[i].index = pList[i];
            ListBox_DeleteString( hPlayWnd, pList[i] );
        }
    }

    if ( dwState == DG_MOVE ) {

        /*
        ** for each selected item that was above the insertion point
        ** reduce the insertion point by 1.
        */
        int iTempInsertionPt = iInsertPos;

        for ( i = 0; i < num; i++ ) {
            if ( pInfo[i].index < iInsertPos ) {
                iTempInsertionPt--;
            }
        }
        iInsertPos = iTempInsertionPt;
    }


    for ( i = 0; i < num; i++ ) {

        ListBox_InsertString( hPlayWnd, iInsertPos + i, pInfo[i].chName );
        ListBox_SetItemData( hPlayWnd, iInsertPos + i, pInfo[i].dwData );
    }

    /*
    ** Adjust the selection to reflect the move
    */
    if ( num != 0 ) {

          ListBox_SelItemRange(hPlayWnd, TRUE, iInsertPos, (iInsertPos + num) - 1);
    }

    SetWindowRedraw( hPlayWnd, TRUE );

    delete pList;
    delete pInfo;
}



STDMETHODIMP_(BOOL) CCDOpt::OnProcessDrop(HWND hDlg, HWND hwndDrop, HWND hwndSrc, POINT ptDrop, DWORD dwState)
{

    int     index;
	HWND	hPlayWnd = GetDlgItem(hDlg, IDC_CURRLIST);

    /*
    ** Are we dropping on the play list window ?
    */
    if ( hwndDrop == hPlayWnd ) {

        index = InsertIndex( hDlg, ptDrop, FALSE );

        /*
        ** Is it OK to drop here ?
        */
        if ( index >= 0 ) {

            if ( hwndSrc == hPlayWnd ) {

                MoveCopySelection( hDlg, index, dwState );
            }
        }
    }

    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
    return TRUE;
}



STDMETHODIMP_(void) CCDOpt::CommitTitleChanges(HWND hDlg, BOOL fSave)
{
    BOOL fChanges = FALSE;

	//Playlist interface
	DeleteDC(m_hdcMem);
	DeleteObject(m_hbmTrack);
    
    if (fSave)
    {
        DWORD   dwItem = 0;
        DWORD   dwTrack;
        DWORD   dwSize;
        TCHAR str[CDSTR];

        SendDlgItemMessage(hDlg, IDC_EDIT_ARTIST, WM_GETTEXT, (WPARAM) CDSTR, (LPARAM) str);
        if (lstrcmp(m_pCDTitle->szArtist, str))
        {
            fChanges = TRUE;
            lstrcpy(m_pCDTitle->szArtist, str);
        }

        SendDlgItemMessage(hDlg, IDC_EDIT_TITLE, WM_GETTEXT, (WPARAM) CDSTR, (LPARAM) str);
        if (lstrcmp(m_pCDTitle->szTitle, str))
        {
            fChanges = TRUE;
            lstrcpy(m_pCDTitle->szTitle, str);
        }
        
        for (dwTrack = 0; dwTrack < m_pCDTitle->dwNumTracks; dwTrack++)
        {
            dwSize = (DWORD)SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETLBTEXTLEN,  (WPARAM) dwTrack, 0);

            if (dwSize != CB_ERR)
            {
                dwSize++;

                TCHAR *szName = new(TCHAR[dwSize]);

                if (szName)
                {
                    if (SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETLBTEXT,  (WPARAM) dwTrack, (LPARAM) szName) != CB_ERR)
                    {
                        if (dwSize >= CDSTR)    // Truncate the name to fit in our max cd title string size
                        {
                            szName[CDSTR - 1] = '\0';
                        }

                        if (lstrcmp(m_pCDTitle->pTrackTable[dwTrack].szName, szName))
                        {
                            fChanges = TRUE;
                            lstrcpy(m_pCDTitle->pTrackTable[dwTrack].szName, szName);
                        }
                    }

                    delete szName;
                }
            }
        }

        dwSize = (DWORD)SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_GETCOUNT,  0, 0);

        if (dwSize != LB_ERR)
        {
            if (dwSize == 0 && m_pCDTitle->dwNumPlay != 0)
            {
                fChanges = TRUE;

                m_pCDTitle->dwNumPlay = 0;

                if (m_pCDTitle->pPlayList)
                {
                    delete m_pCDTitle->pPlayList;
                    m_pCDTitle->pPlayList = NULL;
                }
            }
            else
            {
                BOOL fDefaultlist = FALSE;

                if (dwSize == m_pCDTitle->dwNumTracks && m_pCDTitle->dwNumPlay == 0)
                {
                    fDefaultlist = TRUE;

                    for (dwTrack = 0; dwTrack < dwSize; dwTrack++)
                    {
                        dwItem = (DWORD)SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_GETITEMDATA,  (WPARAM) dwTrack, 0);
                        
                        if (dwItem == LB_ERR || (dwItem != dwTrack))
                        {
                            fDefaultlist = FALSE;
                            break;
                        }
                    }      
                }

                if (!fDefaultlist)
                {
                    LPWORD pList = new(WORD[dwSize]);

                    if (pList)
                    {
                        LPWORD pNum = pList;

                        for (dwTrack = 0; dwTrack < dwSize; dwTrack++, pNum++)
                        {
                            dwItem = (DWORD)SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_GETITEMDATA,  (WPARAM) dwTrack, 0);
                    
                            if (dwItem != LB_ERR)
                            {
                                *pNum =  (WORD) dwItem;
                            }
                            else
                            {
                                *pNum = 0;
                            }
                        }

                        if (dwSize != m_pCDTitle->dwNumPlay || memcmp(pList, m_pCDTitle->pPlayList, sizeof(WORD) * m_pCDTitle->dwNumPlay))
                        {
                            fChanges = TRUE;
                 
                            if (m_pCDTitle->pPlayList)
                            {
                                delete m_pCDTitle->pPlayList;
                            }

                            m_pCDTitle->pPlayList = pList; 
                            m_pCDTitle->dwNumPlay = dwSize;  
                        }
                        else
                        {   
                            delete pList;
                        }
                    }
                }
            }
        }
    }

    if (!fChanges)
    {
        m_pCDTitle = NULL;
    }
}








STDMETHODIMP_(void) CCDOpt::AvailTracksNotify(HWND hDlg, UINT code)
{
    static BOOL fMenuFixed = TRUE;

    switch (code)
    {
        case CBN_DROPDOWN:
        case CBN_SELCHANGE:
        {
            if (!fMenuFixed)
            {
                UpdateAvailList(hDlg);
                fMenuFixed = TRUE;
            }

            if (code == CBN_SELCHANGE)
            {
                m_dwTrack = SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETCURSEL, 0, 0);
            }
        }
        break;

        case CBN_EDITCHANGE:
            fMenuFixed = FALSE;
            TrackEditChange(hDlg);
        break;

        case CBN_KILLFOCUS:
            SendMessage( hDlg, DM_SETDEFID, IDOK, 0L );
        break;

        case CBN_SETFOCUS:
            SendMessage( hDlg, DM_SETDEFID, IDC_AVAILTRACKS, 0L); 
        break;

        case CB_OKAY:
        {
            UpdateAvailList(hDlg);

            m_dwTrack++;
            if ((UINT_PTR)m_dwTrack >= m_pCDTitle->dwNumTracks)
            {
                m_dwTrack = 0;
            }

            SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_SETCURSEL, (WPARAM) m_dwTrack, 0);
        }
        break;
    }
}

STDMETHODIMP_(void) CCDOpt::CurrListNotify(HWND hDlg, UINT code)
{
    switch (code)
    {
        case LBN_SELCHANGE:
        {
            UpdateListButtons(hDlg);
        }
        break;
    }
}



STDMETHODIMP_(BOOL) CCDOpt::Upload(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    static  HWND hAnim = NULL;
     
    switch (msg) 
    { 
        default:
            fResult = FALSE;
        break;
 
        case WM_INITDIALOG:
        {
            HRESULT hr = m_pICDNet->Upload(m_pCDUploadTitle, hDlg);  
            RECT mainrect;
            RECT anirect;

            if (FAILED(hr))
            {
                TCHAR szNetError[MAX_PATH];
                TCHAR szAppName[MAX_PATH];
                LoadString(m_hInst,IDS_NET_FAILURE,szNetError,sizeof(szNetError)/sizeof(TCHAR));
                LoadString(m_hInst,IDS_APPNAME,szAppName,sizeof(szAppName)/sizeof(TCHAR));
                MessageBox(hDlg,szNetError,szAppName,MB_ICONERROR|MB_OK);

                EndDialog(hDlg,FALSE);    
            }

            GetWindowRect(hDlg,&mainrect);
            mainrect.top = mainrect.top + GetSystemMetrics(SM_CYCAPTION);
            
            hAnim = Animate_Create(hDlg, IDI_ICON_ANI_DOWN, WS_CHILD|ACS_TRANSPARENT, 0);

            SendMessage(hAnim,ACM_OPEN,(WPARAM)0, (LPARAM)MAKEINTRESOURCE(IDI_ICON_ANI_DOWN));
            GetWindowRect(hAnim,&anirect);
            MoveWindow(hAnim, 11, 11, anirect.right - anirect.left, anirect.bottom - anirect.top, FALSE);  // Fixme - should hard code location

            Animate_Play(hAnim,0,-1,-1);
            ShowWindow(hAnim,SW_SHOW);
        }        
        break;

        case WM_DESTROY:
        {
            if (hAnim)
            {
                DestroyWindow(hAnim);
                hAnim = NULL;
            }
        }
        break;

        case WM_NET_DONE:
        {
            TCHAR   str[MAX_PATH];
            BOOL    fAlert = TRUE;
            DWORD   dwFlag;

            switch (lParam)
            {
                default:
                {
                    fAlert = FALSE;
                }
                break;

                case UPLOAD_STATUS_NO_PROVIDERS:
                {
                    LoadString(m_hInst, IDS_ERROR_NOUPLOAD, str, sizeof(str)/sizeof(TCHAR));
                    dwFlag = MB_ICONERROR;
                }
                break;

                case UPLOAD_STATUS_SOME_PROVIDERS:
                {
                    LoadString(m_hInst, IDS_ERROR_PARTUPLOAD, str, sizeof(str)/sizeof(TCHAR));
                    dwFlag = MB_ICONWARNING;
                }
                break;

                case UPLOAD_STATUS_ALL_PROVIDERS:
                {
                    LoadString(m_hInst, IDS_UPLOAD_SUCCESS, str, sizeof(str)/sizeof(TCHAR));
                    dwFlag = MB_ICONINFORMATION;
                }
                break;
            }

            if (fAlert)
            {
                TCHAR title[MAX_PATH];

                LoadString(m_hInst, IDS_UPLOAD_STATUS, title, sizeof(title)/sizeof(TCHAR));
                MessageBox(hDlg,str,title,MB_OK | dwFlag); 
            }

            EndDialog(hDlg,FALSE);        
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
				case IDCANCEL:
                    m_pICDNet->CancelDownload();
                    EndDialog(hDlg,FALSE);
				break;
            }
        }
        break;
    }

    return fResult;
}


BOOL CALLBACK CCDOpt::UploadProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);
    
    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);
    }
    
    if (pCDOpt)
    {
        fResult = pCDOpt->Upload(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}



STDMETHODIMP_(BOOL) CCDOpt::Confirm(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
     
    switch (msg) 
    { 
        default:
            fResult = FALSE;
        break;
 
        case WM_INITDIALOG:
        {
            CheckDlgButton(hDlg, IDC_CONFIRMPROMPT, FALSE);
        }        
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
				case IDOK:
                    SetUploadPrompt(!Button_GetCheck(GetDlgItem(hDlg, IDC_CONFIRMPROMPT)));
                    EndDialog(hDlg,TRUE);
				break;

				case IDCANCEL:
                    EndDialog(hDlg,FALSE);
				break;
            }
        }
        break;
    }

    return fResult;
}


BOOL CALLBACK CCDOpt::ConfirmProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);
    
    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);
    }
    
    if (pCDOpt)
    {
        fResult = pCDOpt->Confirm(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}


STDMETHODIMP_(BOOL) CCDOpt::ConfirmUpload(HWND hDlg)
{
    INT_PTR fContinue = TRUE;

    if (GetUploadPrompt())
    {
        fContinue = DialogBoxParam(m_hInst, MAKEINTRESOURCE(IDD_UPLOAD_CONFIRM), hDlg, (DLGPROC) CCDOpt::ConfirmProc, (LPARAM) this);
    }

    return (BOOL)fContinue;
}


STDMETHODIMP_(void) CCDOpt::UploadTitle(HWND hDlg)
{
    if (ConfirmUpload(hDlg))
    {
        if (m_pICDNet)
        {
            DWORD     dwTrack;
            DWORD       dwSize;
            LPCDTRACK   pCDTracks = (LPCDTRACK) new CDTRACK[m_pCDTitle->dwNumTracks];

            if (pCDTracks)
            {
                m_pCDUploadTitle = new CDTITLE;

                if (m_pCDUploadTitle)
                {
                    memset(m_pCDUploadTitle, 0, sizeof(CDTITLE));

                    m_pCDUploadTitle->dwTitleID = m_pCDTitle->dwTitleID;
                    m_pCDUploadTitle->dwNumTracks = m_pCDTitle->dwNumTracks;
                    m_pCDUploadTitle->pTrackTable = pCDTracks;

                    m_pCDData->SetTitleQuery(m_pCDUploadTitle, m_pCDTitle->szTitleQuery);

                    SendDlgItemMessage(hDlg, IDC_EDIT_ARTIST, WM_GETTEXT, (WPARAM) CDSTR, (LPARAM) m_pCDUploadTitle->szArtist);
                    SendDlgItemMessage(hDlg, IDC_EDIT_TITLE, WM_GETTEXT, (WPARAM) CDSTR, (LPARAM) m_pCDUploadTitle->szTitle);

                    for (dwTrack = 0; dwTrack < m_pCDTitle->dwNumTracks; dwTrack++)
                    {
                        dwSize = (DWORD)SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETLBTEXTLEN,  (WPARAM) dwTrack, 0);

                        if (dwSize != CB_ERR)
                        {
                            dwSize++;

                            TCHAR *szName = new(TCHAR[dwSize]);

                            if (szName)
                            {
                                if (SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETLBTEXT,  (WPARAM) dwTrack, (LPARAM) szName) != CB_ERR)
                                {
                                    if (dwSize >= CDSTR)    // Truncate the name to fit in our max cd title string size
                                    {
                                        szName[CDSTR - 1] = '\0';
                                    }

                                    lstrcpy(pCDTracks[dwTrack].szName, szName);
                                }

                                delete szName;
                            }
                        }
                    }
                }
                else
                {
                    delete pCDTracks;
                }
            }

            if (m_pCDUploadTitle)
            {    
                DialogBoxParam(m_hInst, MAKEINTRESOURCE(IDD_DIALOG_UPLOAD), hDlg, (DLGPROC) CCDOpt::UploadProc, (LPARAM) this);

                if (m_pCDUploadTitle->szTitleQuery)
                {
                    delete m_pCDUploadTitle->szTitleQuery;
                }

                delete m_pCDUploadTitle;
                m_pCDUploadTitle = NULL;
            }
        }
    }
}



STDMETHODIMP_(BOOL) CCDOpt::DoListCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    BOOL fResult = TRUE;
    UINT code = HIWORD(wParam);
    UINT id = LOWORD(wParam);

    switch (id) 
    {
        case IDOK:
            CommitTitleChanges(hDlg, TRUE);
	        EndDialog(hDlg, TRUE);
		break;

		case IDCANCEL:
            CommitTitleChanges(hDlg, FALSE);
			EndDialog(hDlg,FALSE);
		break;
        
        case IDC_ADDTOPLAYLIST:
            AddToPlayList(hDlg);
        break;

        case IDC_BUTTON_REMOVE:
            RemovePlayListSel(hDlg);
        break;

        case IDC_BUTTON_CLEAR:
            SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_RESETCONTENT, 0, 0);
            UpdateListButtons(hDlg);
        break;

        case IDC_BUTTON_RESET:
            ResetPlayList(hDlg);
        break;

        case IDC_UPLOADTITLE:
            UploadTitle(hDlg);
        break;

        case IDC_EDIT_TITLE:
        break;

        case IDC_EDIT_ARTIST:
        break;

        case IDC_CURRLIST:
            CurrListNotify(hDlg, code);
        break;

        case IDC_AVAILTRACKS:
            AvailTracksNotify(hDlg, code);
        break;

        default:
            fResult = FALSE;
        break;
    }

    return fResult;
}



// Process any drag/drop notifications first.
//
// wParam == The ID of the drag source.
// lParam == A pointer to a DRAGLISTINFO structure

STDMETHODIMP_(BOOL) CCDOpt::DoDragCommand(HWND hDlg, LPDRAGMULTILISTINFO lpns)
{
    HWND hwndDrop;
    BOOL fResult;

    hwndDrop = WindowFromPoint( lpns->ptCursor );

    switch (lpns->uNotification) 
    {
        case DG_BEGINDRAG:
        {
            fResult = SetDlgMsgResult( hDlg, WM_COMMAND, TRUE );
        }
        break;

        case DG_DRAGGING:
        {
            fResult = OnQueryDrop( hDlg, hwndDrop, lpns->hWnd, lpns->ptCursor, lpns->dwState);
        }
        break;

        case DG_DROPPED:
        {
            fResult = OnProcessDrop( hDlg, hwndDrop, lpns->hWnd, lpns->ptCursor, lpns->dwState );
        }
        break;

        case DG_CANCELDRAG:
        {
            InsertIndex( hDlg, lpns->ptCursor, FALSE );
        }
        default:
        {
            fResult =  SetDlgMsgResult( hDlg, WM_COMMAND, FALSE );
        }
        break;
    }

    return fResult;
}


STDMETHODIMP_(BOOL) CCDOpt::ListEditor(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fResult = TRUE;

    if (msg == m_DragMessage)
    {
        fResult = DoDragCommand(hDlg, (LPDRAGMULTILISTINFO) lParam);
    }
    else
    {
        switch (msg) 
        { 
            default:
                fResult = FALSE;
            break;
        
            case WM_DESTROY:
            {
                if (m_pICDNet)
                {
                    m_pICDNet->Release();
                    m_pICDNet = NULL;
                }
            }
            break;

            case WM_CONTEXTMENU:
            {      
                WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)aListEditHelp);
            }
            break;
           
            case WM_HELP:
            {        
                WinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPSTR)aListEditHelp);
            }
            break;

           case WM_INITDIALOG:
            {
                fResult = InitListEdit(hDlg);
            }        
            break;
            
            case WM_COMMAND:
            {
                fResult = DoListCommand(hDlg,wParam,lParam);
            }
            break;
 
            case WM_DRAWITEM:
            {
                OnDrawItem(hDlg, (LPDRAWITEMSTRUCT) lParam);
            }
            break;
        }
    }

    return fResult;
}


///////////////////
// Dialog handler 
//
BOOL CALLBACK CCDOpt::ListEditorProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);
    
    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);
    }
    
    if (pCDOpt)
    {
        fResult = pCDOpt->ListEditor(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}


////////////
// Called to put up the UI to allow the user Edit a Playlist
//
STDMETHODIMP_(BOOL) CCDOpt::ListEditDialog(HWND hDlg, LPCDTITLE pCDTitle)
{
    BOOL fResult = FALSE;

    if (pCDTitle)
    {
        m_pCDTitle = pCDTitle;  // If no changes, the commit function will clear m_pCDTitle

        if (DialogBoxParam( m_hInst, MAKEINTRESOURCE(IDD_DIALOG_PLAYLIST), hDlg, (DLGPROC) CCDOpt::ListEditorProc, (LPARAM) this) == TRUE)
        {
            if (m_pCDTitle)     // If no changes, then this will be cleared
            {
                m_pCDTitle->fChanged = TRUE;

                fResult = TRUE; // So tell caller that there were changes
            }
        }

        m_pCDTitle = NULL;
    }

    return (fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\playopts.cpp ===
//--------------------------------------------------------------------------;
//
//  File: playopts.cpp
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;

#include "precomp.h"  
#include "optres.h"
#include "cdopti.h"
#include "cdoptimp.h"
#include "mmsystem.h"
#include "helpids.h"

//////////////
// Help ID's
//////////////

#pragma data_seg(".text")
const static DWORD aPlayOptsHelp[] = 
{
    IDC_STARTPLAY,              IDH_STARTPLAY,
    IDC_EXITSTOP,               IDH_EXITSTOP,          
    IDC_TOPMOST,                IDH_TOPMOST,            
    IDC_PLAYBACK_GROUP,         IDH_PLAYBACKOPTIONS,     
    IDC_TIMEDISPLAY_GROUP,      IDH_TIMEDISPLAY,  
    IDC_CDTIME,                 IDH_CDTIME,           
    IDC_TRACKTIME,              IDH_TRACKTIME,          
    IDC_TRACKTIMEREMAIN,        IDH_TRACKTIMEREMAIN,
    IDC_CDTIMEREMAIN,           IDH_CDTIMEREMAIN,
    IDC_PREVIEWTIME_GROUP,      IDH_PREVIEWOPTION, 
    IDC_INTROTIMESLIDER,        IDH_PREVIEWSLIDER,   
    IDC_INTROTIMETEXT,          IDH_PREVIEWDISPLAY,
    IDC_PREVIEWTIME_TEXT,       IDH_PREVIEWOPTION,
    IDC_OPTIONSRESTORE,         IDH_PLAYBACKDEFAULTS,    
    IDC_SETVOLUMECNTL,          IDH_SETVOLUMECONTROL, 
    IDC_TRAYENABLE,             IDH_SYSTRAY_ICON,    
    0, 0
};
#pragma data_seg()


////////////
// Functions
////////////


STDMETHODIMP_(void) CCDOpt::SetIntroTime(HWND hDlg)
{
    TCHAR        seconds[CDSTR];
    TCHAR        str[CDSTR];

    if (m_pCDCopy)
    {
        LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

        if (pCDData->dwIntroTime == 1)
        {
            LoadString( m_hInst, IDS_SECOND, seconds, sizeof( seconds ) /sizeof(TCHAR));
        }
        else
        {
            LoadString( m_hInst, IDS_SECONDS, seconds, sizeof( seconds ) /sizeof(TCHAR));
        }

        wsprintf(str, TEXT("%d %s"), pCDData->dwIntroTime, seconds);
        SetDlgItemText(hDlg, IDC_INTROTIMETEXT, str);

        SendDlgItemMessage( hDlg, IDC_INTROTIMESLIDER, TBM_SETPOS, TRUE, pCDData->dwIntroTime);

        ToggleApplyButton(hDlg);
    }
}


STDMETHODIMP_(BOOL) CCDOpt::InitPlayerOptions(HWND hDlg)
{
    if (m_pCDCopy)
    {
        LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

        CheckDlgButton(hDlg, IDC_STARTPLAY, pCDData->fStartPlay);
        CheckDlgButton(hDlg, IDC_EXITSTOP, pCDData->fExitStop);
        CheckDlgButton(hDlg, IDC_TOPMOST, pCDData->fTopMost);
        CheckDlgButton(hDlg, IDC_TRAYENABLE, pCDData->fTrayEnabled);

        CheckDlgButton(hDlg, IDC_TRACKTIME,         pCDData->fDispMode == CDDISP_TRACKTIME);
        CheckDlgButton(hDlg, IDC_TRACKTIMEREMAIN,   pCDData->fDispMode == CDDISP_TRACKREMAIN);
        CheckDlgButton(hDlg, IDC_CDTIME,            pCDData->fDispMode == CDDISP_CDTIME);
        CheckDlgButton(hDlg, IDC_CDTIMEREMAIN,      pCDData->fDispMode == CDDISP_CDREMAIN);
        
        SendDlgItemMessage( hDlg, IDC_INTROTIMESLIDER, TBM_SETRANGE, TRUE, MAKELONG( CDINTRO_MIN_TIME, CDINTRO_MAX_TIME ) );
        SendDlgItemMessage( hDlg, IDC_INTROTIMESLIDER, TBM_SETTICFREQ , 1, 0 );
        
        SetIntroTime(hDlg);
    }

    return TRUE;
}


STDMETHODIMP_(void) CCDOpt::UsePlayerDefaults(HWND hDlg)
{
    if (m_pCDCopy)
    {
        LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

        pCDData->fStartPlay     = CDDEFAULT_START;   
        pCDData->fExitStop      = CDDEFAULT_EXIT;   
        pCDData->fDispMode      = CDDEFAULT_DISP;   
        pCDData->fTopMost       = CDDEFAULT_TOP; 
        pCDData->fTrayEnabled   = CDDEFAULT_TRAY;  
        pCDData->dwIntroTime    = CDDEFAULT_INTRO; 
    
        InitPlayerOptions(hDlg);  

        ToggleApplyButton(hDlg);
    }
}


STDMETHODIMP_(BOOL) CCDOpt::PlayerOptions(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;

    switch (msg) 
    { 
        default:
            fResult = FALSE;
        break;
        
        case WM_CONTEXTMENU:
        {      
            WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)aPlayOptsHelp);
        }
        break;
           
        case WM_HELP:
        {        
            WinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPSTR)aPlayOptsHelp);
        }
        break;

        case WM_INITDIALOG:
        {
            fResult = InitPlayerOptions(hDlg);
        }        
        break;

        case WM_COMMAND:
        {
            LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

            switch (LOWORD(wParam)) 
            {
                case IDC_OPTIONSRESTORE:
                    UsePlayerDefaults(hDlg);
                break; 

                case IDC_SETVOLUMECNTL:
                    m_fVolChanged = VolumeDialog(hDlg);
                break;
                            
                case IDC_STARTPLAY:
                    pCDData->fStartPlay = Button_GetCheck(GetDlgItem(hDlg, IDC_STARTPLAY));
                    ToggleApplyButton(hDlg);
                break;
            
                case IDC_EXITSTOP:
                    pCDData->fExitStop = Button_GetCheck(GetDlgItem(hDlg, IDC_EXITSTOP));
                    ToggleApplyButton(hDlg);
                break;
            
                case IDC_TOPMOST:
                    pCDData->fTopMost = Button_GetCheck(GetDlgItem(hDlg, IDC_TOPMOST));
                    ToggleApplyButton(hDlg);
                break;
                
                case IDC_TRAYENABLE:
                    pCDData->fTrayEnabled = Button_GetCheck(GetDlgItem(hDlg, IDC_TRAYENABLE));
                    ToggleApplyButton(hDlg);
                break;

                case IDC_TRACKTIME:
                    pCDData->fDispMode = CDDISP_TRACKTIME;
                    ToggleApplyButton(hDlg);
                break;

                case IDC_TRACKTIMEREMAIN:
                    pCDData->fDispMode = CDDISP_TRACKREMAIN;
                    ToggleApplyButton(hDlg);
                break;

                case IDC_CDTIME:
                    pCDData->fDispMode = CDDISP_CDTIME;
                    ToggleApplyButton(hDlg);
                break;
                
                case IDC_CDTIMEREMAIN:
                    pCDData->fDispMode = CDDISP_CDREMAIN;
                    ToggleApplyButton(hDlg);
                break;

                default:
                    fResult = FALSE;
                break;
            }
        }
        break;

        case WM_HSCROLL:
        {
            LPCDOPTDATA pCDData = m_pCDCopy->pCDData;
            HWND hScroll = (HWND) lParam;

            if (hScroll == GetDlgItem(hDlg, IDC_INTROTIMESLIDER))
            {
                pCDData->dwIntroTime = (DWORD) SendDlgItemMessage( hDlg, IDC_INTROTIMESLIDER, TBM_GETPOS, 0, 0 );
                SetIntroTime(hDlg);
            }
        }
        break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
                case PSN_APPLY:
                {
                    ApplyCurrentSettings();
                }
            }
        }
        break;
    }

    return fResult;
}


///////////////////
// Dialog handler 
//
BOOL CALLBACK CCDOpt::PlayerOptionsProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);
    
    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) ((LPPROPSHEETPAGE) lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);
    }
    
    if (pCDOpt)
    {
        fResult = pCDOpt->PlayerOptions(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\sqlobj.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  SQLOBJ.CPP
//
//      SQL Wrapper Object
//
//      Copyright (c) Microsoft Corporation     1998
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "sqlobj.h"





SQL::SQL(void)
{
    TCHAR path[_MAX_PATH];

    GetSystemDirectory(path, sizeof(path)/sizeof(TCHAR));
    lstrcat(path, TEXT("\\odbccp32.dll"));

    m_hODBCCP = LoadLibrary(path);
    m_hODBC = NULL;
     
    if (m_hODBCCP)
    {
        GetSystemDirectory(path, sizeof(path)/sizeof(TCHAR));
        lstrcat(path, TEXT("\\odbc32.dll"));

        m_hODBC = LoadLibrary(path);
 
        if (m_hODBC == NULL)
        {
            FreeLibrary(m_hODBCCP);
        }
    }

    if (m_hODBCCP && m_hODBC)
    {
        m_pfnSetPos             = (SQ_SETPOS)           GetProcAddress( m_hODBC,   "SQLSetPos");
        m_pfnExtendedFetch      = (SQ_EXTENDEDFETCH)    GetProcAddress( m_hODBC,   "SQLExtendedFetch");
        m_pfnFreeStmt           = (SQ_FREESTMT)         GetProcAddress( m_hODBC,   "SQLFreeStmt");
        m_pfnSetStmtOption      = (SQ_SETSTMTOPTION)    GetProcAddress( m_hODBC,   "SQLSetStmtOption");
        m_pfnBindCol            = (SQ_BINDCOL)          GetProcAddress( m_hODBC,   "SQLBindCol");
        m_pfnAllocStmt          = (SQ_ALLOCSTMT)        GetProcAddress( m_hODBC,   "SQLAllocStmt");
        m_pfnFreeConnect        = (SQ_FREECONNECT)      GetProcAddress( m_hODBC,   "SQLFreeConnect");
        m_pfnFreeEnv            = (SQ_FREEENV)          GetProcAddress( m_hODBC,   "SQLFreeEnv");
        m_pfnDisconnect         = (SQ_DISCONNECT)       GetProcAddress( m_hODBC,   "SQLDisconnect");
        m_pfnAllocConnect       = (SQ_ALLOCCONNECT)     GetProcAddress( m_hODBC,   "SQLAllocConnect");
        m_pfnAllocEnv           = (SQ_ALLOCENV)         GetProcAddress( m_hODBC,   "SQLAllocEnv");
        m_pfnTransact           = (SQ_TRANSACT)         GetProcAddress( m_hODBC,   "SQLTransact");
        m_pfnFetch              = (SQ_FETCH)            GetProcAddress( m_hODBC,   "SQLFetch");

        #ifdef UNICODE
        m_pfnConfigDataSource   = (SQ_CONFIGDATASOURCE) GetProcAddress( m_hODBCCP, "SQLConfigDataSourceW");
        m_pfnConnect            = (SQ_CONNECT)          GetProcAddress( m_hODBC,   "SQLConnectW");
        m_pfnError              = (SQ_ERROR)            GetProcAddress( m_hODBC,   "SQLErrorW");
        m_pfnExecDirect         = (SQ_EXECDIRECT)       GetProcAddress( m_hODBC,   "SQLExecDirectW");
        m_pfnSetConnectOption   = (SQ_SETCONNECTOPTION) GetProcAddress( m_hODBC,   "SQLSetConnectOptionW");
        m_pfnStatistics         = (SQ_STATISTICS)       GetProcAddress( m_hODBC,   "SQLStatisticsW");
        m_pfnDescribeCol        = (SQ_DESCRIBECOL)      GetProcAddress( m_hODBC,   "SQLDescribeColW");
        #else
        //for some reason, there is no "A" on odbc's export of SQLConfigDataSource
        m_pfnConfigDataSource   = (SQ_CONFIGDATASOURCE) GetProcAddress( m_hODBCCP, "SQLConfigDataSource");
        m_pfnConnect            = (SQ_CONNECT)          GetProcAddress( m_hODBC,   "SQLConnectA");
        m_pfnError              = (SQ_ERROR)            GetProcAddress( m_hODBC,   "SQLErrorA");
        m_pfnExecDirect         = (SQ_EXECDIRECT)       GetProcAddress( m_hODBC,   "SQLExecDirectA");
        m_pfnSetConnectOption   = (SQ_SETCONNECTOPTION) GetProcAddress( m_hODBC,   "SQLSetConnectOptionA");
        m_pfnStatistics         = (SQ_STATISTICS)       GetProcAddress( m_hODBC,   "SQLStatisticsA");
        m_pfnDescribeCol        = (SQ_DESCRIBECOL)      GetProcAddress( m_hODBC,   "SQLDescribeColA");
        #endif

        if (!m_pfnConfigDataSource  || !m_pfnSetPos         || !m_pfnExtendedFetch  || !m_pfnFreeStmt       || !m_pfnExecDirect     ||
            !m_pfnSetStmtOption     || !m_pfnBindCol        || !m_pfnError          || !m_pfnAllocStmt      || !m_pfnFreeConnect    ||
            !m_pfnFreeEnv           || !m_pfnDisconnect     || !m_pfnConnect        || !m_pfnAllocConnect   || !m_pfnAllocEnv       ||
            !m_pfnSetConnectOption  || !m_pfnTransact       || !m_pfnFetch          || !m_pfnStatistics     || !m_pfnDescribeCol)
        {
            FreeLibrary(m_hODBC);
            FreeLibrary(m_hODBCCP);
            m_hODBC = NULL;
            m_hODBCCP = NULL;
        }

    }
}



SQL::~SQL(void)
{
    if (m_hODBC)
    {
        FreeLibrary(m_hODBC);
    }

    if (m_hODBCCP)
    {
        FreeLibrary(m_hODBCCP);
    }
}


BOOL SQL::Initialize(void)
{
    return (m_hODBC != NULL);
}

BOOL INSTAPI SQL::ConfigDataSource(HWND hwndParent, WORD fRequest,LPCTSTR lpszDriver, LPCTSTR lpszAttributes)
{
    return m_pfnConfigDataSource(hwndParent, fRequest, lpszDriver, lpszAttributes);
}


SQLRETURN  SQL_API SQL::SetPos( SQLHSTMT hstmt, SQLUSMALLINT irow, SQLUSMALLINT fOption, SQLUSMALLINT fLock)
{
    return m_pfnSetPos( hstmt, irow, fOption, fLock);
}


SQLRETURN  SQL_API SQL::ExtendedFetch( SQLHSTMT hstmt, SQLUSMALLINT fFetchType, SQLINTEGER irow, SQLUINTEGER *pcrow, SQLUSMALLINT *rgfRowStatus)
{
    return m_pfnExtendedFetch( hstmt, fFetchType, irow, pcrow, rgfRowStatus);
}


SQLRETURN  SQL_API SQL::FreeStmt(SQLHSTMT StatementHandle, SQLUSMALLINT Option)
{
    return m_pfnFreeStmt(StatementHandle, Option);
}


SQLRETURN  SQL_API SQL::ExecDirect(SQLHSTMT StatementHandle, SQLCHAR *StatementText, SQLINTEGER TextLength)
{
    return m_pfnExecDirect(StatementHandle, StatementText, TextLength);
}


SQLRETURN  SQL_API SQL::SetStmtOption(SQLHSTMT StatementHandle, SQLUSMALLINT Option, SQLUINTEGER Value)
{
    return m_pfnSetStmtOption(StatementHandle, Option, Value);
}


SQLRETURN  SQL_API SQL::BindCol(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType, SQLPOINTER TargetValue, SQLINTEGER BufferLength, SQLINTEGER *StrLen_or_Ind)
{
    return m_pfnBindCol(StatementHandle, ColumnNumber, TargetType, TargetValue, BufferLength, StrLen_or_Ind);
}


SQLRETURN  SQL_API SQL::Error(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle, SQLHSTMT StatementHandle, SQLCHAR *Sqlstate, SQLINTEGER *NativeError, SQLCHAR *MessageText, SQLSMALLINT BufferLength, SQLSMALLINT *TextLength)
{
    return m_pfnError(EnvironmentHandle, ConnectionHandle, StatementHandle, Sqlstate, NativeError, MessageText, BufferLength, TextLength);
}


SQLRETURN  SQL_API SQL::AllocStmt(SQLHDBC ConnectionHandle, SQLHSTMT *StatementHandle)
{
    return m_pfnAllocStmt(ConnectionHandle, StatementHandle);
}


SQLRETURN  SQL_API SQL::FreeConnect(SQLHDBC ConnectionHandle)
{
    return m_pfnFreeConnect(ConnectionHandle);
}


SQLRETURN  SQL_API SQL::FreeEnv(SQLHENV EnvironmentHandle)
{
    return m_pfnFreeEnv(EnvironmentHandle);
}


SQLRETURN  SQL_API SQL::Disconnect(SQLHDBC ConnectionHandle)
{
    return m_pfnDisconnect(ConnectionHandle);
}


SQLRETURN  SQL_API SQL::Connect(SQLHDBC ConnectionHandle, SQLCHAR *ServerName, SQLSMALLINT NameLength1, SQLCHAR *UserName, SQLSMALLINT NameLength2, SQLCHAR *Authentication, SQLSMALLINT NameLength3)
{
    return m_pfnConnect(ConnectionHandle, ServerName, NameLength1, UserName, NameLength2, Authentication, NameLength3);
}


SQLRETURN  SQL_API SQL::AllocConnect(SQLHENV EnvironmentHandle, SQLHDBC *ConnectionHandle)
{
    return m_pfnAllocConnect(EnvironmentHandle, ConnectionHandle);
}


SQLRETURN  SQL_API SQL::AllocEnv(SQLHENV *EnvironmentHandle)
{
    return m_pfnAllocEnv(EnvironmentHandle);
}


SQLRETURN  SQL_API SQL::SetConnectOption(SQLHDBC ConnectionHandle, SQLUSMALLINT Option, SQLUINTEGER Value)
{
    return m_pfnSetConnectOption(ConnectionHandle, Option, Value);
}


SQLRETURN  SQL_API SQL::Transact(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle, SQLUSMALLINT CompletionType)
{
    return m_pfnTransact(EnvironmentHandle, ConnectionHandle, CompletionType);
}


SQLRETURN  SQL_API SQL::Fetch(SQLHSTMT StatementHandle)
{
    return m_pfnFetch(StatementHandle);
}


SQLRETURN  SQL_API SQL::Statistics(SQLHSTMT StatementHandle, SQLCHAR *CatalogName, SQLSMALLINT NameLength1, SQLCHAR *SchemaName, SQLSMALLINT NameLength2, SQLCHAR *TableName, SQLSMALLINT NameLength3, SQLUSMALLINT Unique, SQLUSMALLINT Reserved)
{
    return m_pfnStatistics(StatementHandle, CatalogName, NameLength1, SchemaName, NameLength2, TableName, NameLength3, Unique, Reserved);
}

SQLRETURN  SQL_API SQL::DescribeCol(SQLHSTMT StatementHandle, SQLSMALLINT ColumnNumber, SQLCHAR * ColumnName, SQLSMALLINT BufferLength, SQLSMALLINT * NameLengthPtr, SQLSMALLINT * DataTypePtr, SQLUINTEGER * ColumnSizePtr, SQLSMALLINT * DecimalDigitsPtr, SQLSMALLINT * NullablePtr)
{
    return m_pfnDescribeCol(StatementHandle, ColumnNumber, ColumnName, BufferLength, NameLengthPtr, DataTypePtr, ColumnSizePtr, DecimalDigitsPtr, NullablePtr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\titleopt.cpp ===
//--------------------------------------------------------------------------;
//
//  File: titleopt.cpp
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;

#include "precomp.h"  
#include "cdopti.h"
#include "cdoptimp.h"
#include "helpids.h"

//////////////
// Help ID's
//////////////

#pragma data_seg(".text")
const static DWORD aTitleOptsHelp[] = 
{
    IDC_CURPROVIDER_TEXT,       IDH_SELECTCURRENTPROVIDER,
    IDC_PROVIDERPICKER,         IDH_SELECTCURRENTPROVIDER,
    IDC_ALBUMBATCH_GROUP,       IDH_ABOUTBATCHING,
    IDC_ALBUMINFO_TEXT,         IDH_ABOUTALBUMS,
    IDC_DOWNLOADPROMPT,         IDH_DOWNLOADPROMPT,
    IDC_BATCHENABLED,           IDH_BATCHENABLED,
    IDC_TITLERESTORE,           IDH_TITLEDEFAULTS,
    IDC_BATCHTEXT,              IDH_NUMBATCHED,
    IDC_DOWNLOADENABLED,        IDH_AUTODOWNLOADENABLED,
    IDC_DOWNLOADNOW,            IDH_DOWNLOADNOW,
    IDC_DOWNLOAD_GROUP,         IDH_DOWNLOADING,
    IDC_ALBUMBATCH_TEXT,        IDH_ABOUTBATCHING,
    0, 0
};
#pragma data_seg()

////////////
// Functions
////////////

STDMETHODIMP_(void) CCDOpt::ToggleInternetDownload(HWND hDlg)
{
    if (m_pCDCopy)
    {
        LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

        pCDData->fDownloadEnabled = Button_GetCheck(GetDlgItem(hDlg, IDC_DOWNLOADENABLED));

        EnableWindow(GetDlgItem(hDlg, IDC_PROVIDERPICKER),   pCDData->fDownloadEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_CURPROVIDER_TEXT), pCDData->fDownloadEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOADPROMPT),   pCDData->fDownloadEnabled);


        ToggleApplyButton(hDlg);
    }
}   


STDMETHODIMP_(void) CCDOpt::UpdateBatched(HWND hDlg)
{
    if (hDlg != NULL)
    {
        TCHAR szNum[MAX_PATH];
        TCHAR szBatch[MAX_PATH];

        if (m_pCDOpts->dwBatchedTitles == 0 || m_pCDOpts->pfnDownloadTitle == NULL)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOADNOW), FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOADNOW), TRUE);
        }

        LoadString( m_hInst, IDS_BATCHTEXT, szBatch, sizeof( szBatch )/sizeof(TCHAR) );
        wsprintf(szNum, TEXT("%s %d"), szBatch, m_pCDOpts->dwBatchedTitles);
        SetWindowText(GetDlgItem(hDlg, IDC_BATCHTEXT), szNum);
    }
}


STDMETHODIMP_(BOOL) CCDOpt::InitTitleOptions(HWND hDlg)
{
    if (m_pCDCopy)
    {
        LPCDOPTDATA pCDData = m_pCDCopy->pCDData;
        LPCDPROVIDER pProvider;

        CheckDlgButton(hDlg, IDC_DOWNLOADENABLED,   pCDData->fDownloadEnabled);
        CheckDlgButton(hDlg, IDC_DOWNLOADPROMPT,    pCDData->fDownloadPrompt);
        CheckDlgButton(hDlg, IDC_BATCHENABLED,      pCDData->fBatchEnabled);

        m_hTitleWnd = hDlg;
        UpdateBatched(m_hTitleWnd);

        SendDlgItemMessage(hDlg, IDC_PROVIDERPICKER, CB_RESETCONTENT,0,0);

        pProvider = m_pCDCopy->pProviderList;

        while (pProvider)
        {
            LRESULT dwIndex = SendDlgItemMessage(hDlg, IDC_PROVIDERPICKER, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) pProvider->szProviderName);
         
            if (dwIndex != CB_ERR && dwIndex != CB_ERRSPACE)
            {
                SendDlgItemMessage(hDlg, IDC_PROVIDERPICKER, CB_SETITEMDATA,  (WPARAM) dwIndex, (LPARAM) pProvider);

                if (pProvider == m_pCDCopy->pCurrentProvider)
                {
                    SendDlgItemMessage(hDlg, IDC_PROVIDERPICKER, CB_SETCURSEL,  (WPARAM) dwIndex, 0);                
                }
            }

            pProvider = pProvider->pNext;
        }

        ToggleInternetDownload(hDlg);
    }

    return TRUE;
}


STDMETHODIMP_(void) CCDOpt::RestoreTitleDefaults(HWND hDlg)
{
    if (m_pCDCopy)
    {
        LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

        pCDData->fDownloadEnabled   = CDDEFAULT_DOWNLOADENABLED;   
        pCDData->fDownloadPrompt    = CDDEFAULT_DOWNLOADPROMPT;   
        pCDData->fBatchEnabled       = CDDEFAULT_BATCHENABLED;   
          
        m_pCDCopy->pCurrentProvider = m_pCDCopy->pDefaultProvider;
        
        InitTitleOptions(hDlg);  

        ToggleApplyButton(hDlg);
    }
}

   

STDMETHODIMP_(void) CCDOpt::ChangeCDProvider(HWND hDlg)
{
    if (m_pCDCopy)
    {
        LRESULT dwResult = SendDlgItemMessage(hDlg, IDC_PROVIDERPICKER, CB_GETCURSEL, 0, 0);
    
        if (dwResult != CB_ERR)
        {  
            dwResult = SendDlgItemMessage(hDlg, IDC_PROVIDERPICKER, CB_GETITEMDATA,  (WPARAM) dwResult, 0);

            if (dwResult != CB_ERR)
            {
                m_pCDCopy->pCurrentProvider = (LPCDPROVIDER) dwResult;
            }
        }

        ToggleApplyButton(hDlg);
    }
}


STDMETHODIMP_(void) CCDOpt::DownloadNow(HWND hDlg)
{
    if (m_pCDOpts->dwBatchedTitles && m_pCDOpts->pfnDownloadTitle)
    {
        TCHAR szNum[MAX_PATH];
        TCHAR szBatch[MAX_PATH];

        m_pCDOpts->dwBatchedTitles = m_pCDOpts->pfnDownloadTitle(NULL, m_pCDOpts->lParam, hDlg);  

        EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOADNOW), m_pCDOpts->dwBatchedTitles != 0);

        LoadString( m_hInst, IDS_BATCHTEXT, szBatch, sizeof( szBatch )/sizeof(TCHAR) );
        wsprintf(szNum, TEXT("%s %d"), szBatch, m_pCDOpts->dwBatchedTitles);
        SetWindowText(GetDlgItem(hDlg, IDC_BATCHTEXT), szNum);
    }
}

            
STDMETHODIMP_(BOOL) CCDOpt::TitleOptions(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fResult = TRUE;
       
    switch (msg) 
    { 
        default:
            fResult = FALSE;
        break;
        
        case WM_DESTROY:
        {
            m_hTitleWnd = NULL;
        }
        break;

        case WM_CONTEXTMENU:
        {      
            WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)aTitleOptsHelp);
        }
        break;
           
        case WM_HELP:
        {        
            WinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPSTR)aTitleOptsHelp);
        }
        break;

        case WM_INITDIALOG:
        {
            fResult = InitTitleOptions(hDlg);
        }        
        break;

        case WM_COMMAND:
        {
            LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

            switch (LOWORD(wParam)) 
            {
                case IDC_TITLERESTORE:
                    RestoreTitleDefaults(hDlg);
                break;
                            
                case IDC_DOWNLOADENABLED:
                    ToggleInternetDownload(hDlg);
                break;

                case IDC_DOWNLOADPROMPT:
                    pCDData->fDownloadPrompt = Button_GetCheck(GetDlgItem(hDlg, IDC_DOWNLOADPROMPT));
                    ToggleApplyButton(hDlg);
                break;
            
                case IDC_BATCHENABLED:
                    pCDData->fBatchEnabled = Button_GetCheck(GetDlgItem(hDlg, IDC_BATCHENABLED));
                    ToggleApplyButton(hDlg);
                break;
               
                case IDC_DOWNLOADNOW:
                    DownloadNow(hDlg);
                break;            

                case IDC_PROVIDERPICKER:
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        ChangeCDProvider(hDlg);
                    }
                }
                break;

                default:
                    fResult = FALSE;
                break;
            }
        }
        break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
                case PSN_APPLY:
                {
                    ApplyCurrentSettings();
                }
            }
        }
        break;
    }

    return fResult;
}

///////////////////
// Dialog handler 
//
BOOL CALLBACK CCDOpt::TitleOptionsProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);
    
    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) ((LPPROPSHEETPAGE) lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);
    }
    
    if (pCDOpt)
    {
        fResult = pCDOpt->TitleOptions(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\cdapi.h ===
/******************************Module*Header*******************************\
* Module Name: cdapi.h
*
*
*
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifdef USE_IOCTLS
#include <ntddcdrm.h>
#else
#include <mmsystem.h>
#endif

#define MAX_CD_DEVICES 50

/* -------------------------------------------------------------------------
** Defines for cdrom state
**
**  These are bit flags
** -------------------------------------------------------------------------
*/

#define CD_PLAYING          0x0001
#define CD_STOPPED          0x0002
#define CD_PAUSED           0x0004
#define CD_SKIP_F           0x0008
#define CD_SKIP_B           0x0010
#define CD_FF               0x0020
#define CD_RW               0x0040
#define CD_SEEKING          (CD_FF | CD_RW)
#define CD_LOADED           0x0080
#define CD_NO_CD            0x0100
#define CD_DATA_CD_LOADED   0x0200
#define CD_EDITING          0x0400
#define CD_PAUSED_AND_MOVED 0x0800
#define CD_PLAY_PENDING     0x1000
#define CD_WAS_PLAYING      0x2000
#define CD_IN_USE           0x4000
#define CD_BEING_SCANNED    0x8000


/* -------------------------------------------------------------------------
** Some MACROS
** -------------------------------------------------------------------------
*/

#ifdef USE_IOCTLS
#define CDHANDLE    HANDLE
#else
#define CDHANDLE    MCIDEVICEID
#endif

#define CDTIME(x)       g_Devices[x]->time
#define CURRTRACK(x)    g_Devices[x]->time.CurrTrack

#ifdef USE_IOCTLS
#define TRACK_M(x,y)    g_Devices[x]->toc.TrackData[y].Address[1]
#define TRACK_S(x,y)    g_Devices[x]->toc.TrackData[y].Address[2]
#define TRACK_F(x,y)    g_Devices[x]->toc.TrackData[y].Address[3]
#else
#define TRACK_M(x,y)    MCI_MSF_MINUTE(g_Devices[x]->toc.TrackData[y].Address)
#define TRACK_S(x,y)    MCI_MSF_SECOND(g_Devices[x]->toc.TrackData[y].Address)
#define TRACK_F(x,y)    MCI_MSF_FRAME(g_Devices[x]->toc.TrackData[y].Address)
#endif

#define FIRSTTRACK(x)   g_Devices[x]->toc.FirstTrack
#define LASTTRACK(x)    g_Devices[x]->toc.LastTrack
#define ALLTRACKS(x)    g_Devices[x]->CdInfo.AllTracks
#define PLAYLIST(x)     g_Devices[x]->CdInfo.PlayList
#define SAVELIST(x)     g_Devices[x]->CdInfo.SaveList
#define TITLE(x)        g_Devices[x]->CdInfo.Title
#define ARTIST(x)       g_Devices[x]->CdInfo.Artist
#define NUMTRACKS(x)    g_Devices[x]->CdInfo.NumTracks
#define STATE(x)        g_Devices[x]->State
#define g_State         (g_Devices[g_CurrCdrom]->State)
#define ABS(x)          ((x) < 0 ? (-(x)) : (x))


/* -------------------------------------------------------------------------
** Type definitions for CD database entries, etc.
**
** -------------------------------------------------------------------------
*/
#define TITLE_LENGTH        128
#define ARTIST_LENGTH       128
#define TRACK_TITLE_LENGTH  128
#define MAX_TRACKS          100
#define NEW_FRAMEOFFSET     1234567

#ifndef USE_IOCTLS
//
// Maximum CD Rom size
//

#define MAXIMUM_NUMBER_TRACKS 100
#define MAXIMUM_CDROM_SIZE 804


//
// Used with StatusTrackPos call
//
#define MCI_STATUS_TRACK_POS 0xBEEF

typedef struct
{
    DWORD   dwStatus;
    DWORD   dwTrack;
    DWORD   dwDiscTime;
} STATUSTRACKPOS, *PSTATUSTRACKPOS;

//
// CD ROM Table OF Contents (TOC)
//
// Format 0 - Get table of contents
//

typedef struct _TRACK_DATA {
    UCHAR TrackNumber;
    DWORD Address;
    DWORD AddressF;
} TRACK_DATA, *PTRACK_DATA;

typedef struct _CDROM_TOC {

    //
    // Header
    //

    UCHAR Length[2];
    UCHAR FirstTrack;
    UCHAR LastTrack;

    //
    // Track data
    //

    TRACK_DATA TrackData[MAXIMUM_NUMBER_TRACKS];
} CDROM_TOC, *PCDROM_TOC;

#define CDROM_TOC_SIZE sizeof(CDROM_TOC)
#endif

typedef struct _TRACK_INF {
    struct _TRACK_INF   *next;
    int                 TocIndex;
    TCHAR               name[TRACK_TITLE_LENGTH];
} TRACK_INF, *PTRACK_INF;

typedef struct _TRACK_PLAY {
    struct _TRACK_PLAY  *prevplay;
    struct _TRACK_PLAY  *nextplay;
    int                 TocIndex;
    int                 min;
    int                 sec;
} TRACK_PLAY, *PTRACK_PLAY;

typedef struct _TIMES {
    PTRACK_PLAY         CurrTrack;
    int                 TotalMin;
    int                 TotalSec;
    int                 RemMin;
    int                 RemSec;
    int                 TrackCurMin;
    int                 TrackCurSec;
    int                 TrackTotalMin;
    int                 TrackTotalSec;
    int                 TrackRemMin;
    int                 TrackRemSec;
} TIMES, *PTIMES;

typedef struct _ENTRY {
    PTRACK_INF          AllTracks;
    PTRACK_PLAY         PlayList;
    PTRACK_PLAY         SaveList;
    int                 NumTracks;
    DWORD               Id;
    BOOL                save;
    BOOL                IsVirginCd;
    int                 iFrameOffset;
    TCHAR               Title[TITLE_LENGTH];
    TCHAR               Artist[TITLE_LENGTH];
} ENTRY, *PENTRY;

typedef struct _CDROM {
    CDHANDLE            hCd;
    HANDLE              hThreadToc;
    BOOL                fIsTocValid;
    TCHAR               drive;
    DWORD               State;
    CDROM_TOC           toc;
    ENTRY               CdInfo;
    TIMES               time;
    BOOL                fShowLeadIn;
    BOOL                fProcessingLeadIn;
    BOOL                fKilledPlayList;  // Used to prevent bug with -track option
} CDROM, *PCDROM;

typedef struct _CURRPOS {
#ifdef USE_IOCTLS
    UCHAR               AudioStatus;
#else
    DWORD               AudioStatus;
#endif
    int                 Track;
    int                 Index;
    int                 m;
    int                 s;
    int                 f;
    int                 ab_m;
    int                 ab_s;
    int                 ab_f;
} CURRPOS, *PCURRPOS;


/* -------------------------------------------------------------------------
** High level function declarations
**
** -------------------------------------------------------------------------
*/

#ifdef __cplusplus
extern "C" {
#endif

void
CheckStatus(
    LPSTR szCaller,
    DWORD status,
    int cdrom
    );

void
NoMediaUpdate(
    int cdrom
    );

void
CheckUnitCdrom(
    int cdrom,
    BOOL fForceRescan
    );

BOOL
EjectTheCdromDisc(
    INT cdrom
    );

BOOL
PlayCurrTrack(
    int cdrom
    );

BOOL
StopTheCdromDrive(
    int cdrom
    );

BOOL
PauseTheCdromDrive(
    int cdrom
    );

BOOL
ResumeTheCdromDrive(
    int cdrom
    );

BOOL
SeekToCurrSecond(
    int cdrom
    );

BOOL
GetCurrPos(
    int cdrom,
    PCURRPOS CpPtr
    );

BOOL
SeekToTrackAndHold(
    int cdrom,
    int tindex
    );


/* -------------------------------------------------------------------------
** NT Layer Function Declarations
**
** These are the low-level functions that manipulate the specified CD-ROM
** device.
** -------------------------------------------------------------------------
*/
DWORD
GetCdromTOC(
    CDHANDLE,
    PCDROM_TOC
    );

DWORD
StopCdrom(
    CDHANDLE
    );

DWORD
PauseCdrom(
    CDHANDLE
    );


#ifdef USE_IOCTLS
DWORD
ResumeCdrom(
    CDHANDLE
    );

DWORD
PlayCdrom(
    CDHANDLE,
    PCDROM_PLAY_AUDIO_MSF
    );

DWORD
SeekCdrom(
    CDHANDLE,
    PCDROM_SEEK_AUDIO_MSF
    );

DWORD
GetCdromSubQData(
    CDHANDLE,
    PSUB_Q_CHANNEL_DATA,
    PCDROM_SUB_Q_DATA_FORMAT
    );

#else

DWORD
ResumeCdrom(
    CDHANDLE,
    int
    );

CDHANDLE
OpenCdRom(
    TCHAR chDrive,
    LPDWORD lpdwErrCode
    );

void
CloseCdRom(
    CDHANDLE DevHandle
    );

DWORD
GetCdromMode(
    CDHANDLE DevHandle
    );

DWORD
GetCdromCurrentTrack(
    CDHANDLE DevHandle
    );

BOOL
IsCdromTrackAudio(
    CDHANDLE DevHandle,
    int iTrackNumber
    );

DWORD
PlayCdrom(
    CDHANDLE DeviceHandle,
    MCI_PLAY_PARMS *mciPlay
    );

DWORD
SeekCdrom(
    CDHANDLE DeviceHandle,
    MCI_SEEK_PARMS *mciSeek
    );

DWORD
GetCdromCurrentPosition(
    CDHANDLE DevHandle,
    DWORD *lpdwPosition
    );

#endif

DWORD
EjectCdrom(
    CDHANDLE
    );

DWORD
TestUnitReadyCdrom(
    CDHANDLE DeviceHandle
    );

#if 0
DWORD
GetCdromVolume(
    CDHANDLE DeviceHandle
    );
#endif

DWORD
StatusTrackPosCdrom(
    MCIDEVICEID DevHandle,
    DWORD * pStatus,
    DWORD * pTrack,
    DWORD * pPos
    );

#ifdef __cplusplus
};
#endif

/* -------------------------------------------------------------------------
** Public Globals - Most of these should be treated as read only.
** -------------------------------------------------------------------------
*/
#ifndef GLOBAL
#define GLOBAL extern
#endif
GLOBAL  PCDROM  g_Devices[MAX_CD_DEVICES];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\sqlobj.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  SQLOBJ.H
//
//	Defines the SQL Wrapper object
//
//	Copyright (c) Microsoft Corporation	1998
//
//  protect us from the DLL's not being present and to allow us to run.
//  got to be a simplier solution.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _SQLOBJ_HEADER_
#define _SQLOBJ_HEADER_

#include <odbcinst.h>
#include <sqlext.h>

#ifdef __cplusplus
extern "C" {
#endif


typedef BOOL       (INSTAPI * SQ_CONFIGDATASOURCE) (HWND,WORD,LPCTSTR, LPCTSTR);
typedef SQLRETURN  (SQL_API * SQ_SETPOS)           (SQLHSTMT,SQLUSMALLINT,SQLUSMALLINT,SQLUSMALLINT);
typedef SQLRETURN  (SQL_API * SQ_EXTENDEDFETCH)    (SQLHSTMT,SQLUSMALLINT,SQLINTEGER,SQLUINTEGER *,SQLUSMALLINT *);
typedef SQLRETURN  (SQL_API * SQ_FREESTMT)         (SQLHSTMT,SQLUSMALLINT);
typedef SQLRETURN  (SQL_API * SQ_EXECDIRECT)       (SQLHSTMT,SQLCHAR *,SQLINTEGER);
typedef SQLRETURN  (SQL_API * SQ_SETSTMTOPTION)    (SQLHSTMT,SQLUSMALLINT,SQLUINTEGER);
typedef SQLRETURN  (SQL_API * SQ_BINDCOL)          (SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLPOINTER,SQLINTEGER,SQLINTEGER *);
typedef SQLRETURN  (SQL_API * SQ_ERROR)            (SQLHENV,SQLHDBC,SQLHSTMT,SQLCHAR *,SQLINTEGER *,SQLCHAR *,SQLSMALLINT,SQLSMALLINT *);
typedef SQLRETURN  (SQL_API * SQ_ALLOCSTMT)        (SQLHDBC,SQLHSTMT *);
typedef SQLRETURN  (SQL_API * SQ_FREECONNECT)      (SQLHDBC);
typedef SQLRETURN  (SQL_API * SQ_FREEENV)          (SQLHENV);
typedef SQLRETURN  (SQL_API * SQ_DISCONNECT)       (SQLHDBC);
typedef SQLRETURN  (SQL_API * SQ_CONNECT)          (SQLHDBC,SQLCHAR *,SQLSMALLINT,SQLCHAR *,SQLSMALLINT,SQLCHAR *,SQLSMALLINT);
typedef SQLRETURN  (SQL_API * SQ_ALLOCCONNECT)     (SQLHENV,SQLHDBC *);
typedef SQLRETURN  (SQL_API * SQ_ALLOCENV)         (SQLHENV *);
typedef SQLRETURN  (SQL_API * SQ_SETCONNECTOPTION) (SQLHDBC,SQLUSMALLINT,SQLUINTEGER);
typedef SQLRETURN  (SQL_API * SQ_TRANSACT)         (SQLHENV,SQLHDBC,SQLUSMALLINT);
typedef SQLRETURN  (SQL_API * SQ_FETCH)            (SQLHSTMT);
typedef SQLRETURN  (SQL_API * SQ_STATISTICS)       (SQLHSTMT,SQLCHAR *,SQLSMALLINT,SQLCHAR *,SQLSMALLINT,SQLCHAR *,SQLSMALLINT,SQLUSMALLINT,SQLUSMALLINT);
typedef SQLRETURN  (SQL_API * SQ_DESCRIBECOL)      (SQLHSTMT,SQLSMALLINT,SQLCHAR *,SQLSMALLINT,SQLSMALLINT *,SQLSMALLINT *,SQLUINTEGER *,SQLSMALLINT *,SQLSMALLINT *);

class SQL
{
    public:

        SQL(); 
        ~SQL();
        
        BOOL               Initialize(void);

        BOOL       INSTAPI ConfigDataSource(HWND hwndParent, WORD fRequest,LPCTSTR lpszDriver, LPCTSTR lpszAttributes);
        SQLRETURN  SQL_API SetPos( SQLHSTMT hstmt, SQLUSMALLINT irow, SQLUSMALLINT fOption, SQLUSMALLINT fLock);
        SQLRETURN  SQL_API ExtendedFetch( SQLHSTMT hstmt, SQLUSMALLINT fFetchType, SQLINTEGER irow, SQLUINTEGER *pcrow, SQLUSMALLINT *rgfRowStatus);
        SQLRETURN  SQL_API FreeStmt(SQLHSTMT StatementHandle, SQLUSMALLINT Option);
        SQLRETURN  SQL_API ExecDirect(SQLHSTMT StatementHandle, SQLCHAR *StatementText, SQLINTEGER TextLength);
        SQLRETURN  SQL_API SetStmtOption(SQLHSTMT StatementHandle, SQLUSMALLINT Option, SQLUINTEGER Value);
        SQLRETURN  SQL_API BindCol(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType, SQLPOINTER TargetValue, SQLINTEGER BufferLength, SQLINTEGER *StrLen_or_Ind);
        SQLRETURN  SQL_API Error(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle, SQLHSTMT StatementHandle, SQLCHAR *Sqlstate, SQLINTEGER *NativeError, SQLCHAR *MessageText, SQLSMALLINT BufferLength, SQLSMALLINT *TextLength);
        SQLRETURN  SQL_API AllocStmt(SQLHDBC ConnectionHandle, SQLHSTMT *StatementHandle);
        SQLRETURN  SQL_API FreeConnect(SQLHDBC ConnectionHandle);
        SQLRETURN  SQL_API FreeEnv(SQLHENV EnvironmentHandle);
        SQLRETURN  SQL_API Disconnect(SQLHDBC ConnectionHandle);
        SQLRETURN  SQL_API Connect(SQLHDBC ConnectionHandle, SQLCHAR *ServerName, SQLSMALLINT NameLength1, SQLCHAR *UserName, SQLSMALLINT NameLength2, SQLCHAR *Authentication, SQLSMALLINT NameLength3);
        SQLRETURN  SQL_API AllocConnect(SQLHENV EnvironmentHandle, SQLHDBC *ConnectionHandle);
        SQLRETURN  SQL_API AllocEnv(SQLHENV *EnvironmentHandle);
        SQLRETURN  SQL_API SetConnectOption(SQLHDBC ConnectionHandle, SQLUSMALLINT Option, SQLUINTEGER Value);
        SQLRETURN  SQL_API Transact(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle, SQLUSMALLINT CompletionType);
        SQLRETURN  SQL_API Fetch(SQLHSTMT StatementHandle);
        SQLRETURN  SQL_API Statistics(SQLHSTMT StatementHandle, SQLCHAR *CatalogName, SQLSMALLINT NameLength1, SQLCHAR *SchemaName, SQLSMALLINT NameLength2, SQLCHAR *TableName, SQLSMALLINT NameLength3, SQLUSMALLINT Unique, SQLUSMALLINT Reserved);
        SQLRETURN  SQL_API DescribeCol(SQLHSTMT StatementHandle, SQLSMALLINT ColumnNumber, SQLCHAR * ColumnName, SQLSMALLINT BufferLength, SQLSMALLINT * NameLengthPtr, SQLSMALLINT * DataTypePtr, SQLUINTEGER * ColumnSizePtr, SQLSMALLINT * DecimalDigitsPtr, SQLSMALLINT * NullablePtr);

    private:
        HMODULE                 m_hODBC;
        HMODULE                 m_hODBCCP;

        SQ_CONFIGDATASOURCE    m_pfnConfigDataSource;
        SQ_SETPOS              m_pfnSetPos;
        SQ_EXTENDEDFETCH       m_pfnExtendedFetch;
        SQ_FREESTMT            m_pfnFreeStmt;
        SQ_EXECDIRECT          m_pfnExecDirect;
        SQ_SETSTMTOPTION       m_pfnSetStmtOption;
        SQ_BINDCOL             m_pfnBindCol;
        SQ_ERROR               m_pfnError;
        SQ_ALLOCSTMT           m_pfnAllocStmt;
        SQ_FREECONNECT         m_pfnFreeConnect;
        SQ_FREEENV             m_pfnFreeEnv;
        SQ_DISCONNECT          m_pfnDisconnect;
        SQ_CONNECT             m_pfnConnect;
        SQ_ALLOCCONNECT        m_pfnAllocConnect;
        SQ_ALLOCENV            m_pfnAllocEnv;
        SQ_SETCONNECTOPTION    m_pfnSetConnectOption;
        SQ_TRANSACT            m_pfnTransact;
        SQ_FETCH               m_pfnFetch;
        SQ_STATISTICS          m_pfnStatistics;
        SQ_DESCRIBECOL         m_pfnDescribeCol;
};

#ifdef __cplusplus
};
#endif

#endif  //_SQLOBJ_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\cdapimci.cpp ===
/******************************Module*Header*******************************\
* Module Name: cdapimci.c
*
* This module encapsulates the CD-ROM device into a set of callable apis.
* The api's are implemented using the cdaudio mci interface.
*
* Created: 26-04-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 - 1995 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>    /* required for all Windows applications */
#include <windowsx.h>
#include <string.h>

#include "playres.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"
#include "..\cdopt\cdopt.h"

#ifdef __cplusplus
extern "C" {
#endif
/* -------------------------------------------------------------------------
**
** High level routines
**
** -------------------------------------------------------------------------
*/

BOOL g_fCDOpen = TRUE;

/******************************Public*Routine******************************\
* OpenCdRom
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
MCIDEVICEID
OpenCdRom(
    TCHAR chDrive,
    LPDWORD lpdwErrCode
    )
{
    MCI_OPEN_PARMS  mciOpen;
    TCHAR           szElementName[4];
    TCHAR           szAliasName[32];
    DWORD           dwFlags;
    DWORD           dwAliasCount = GetCurrentTime();
    DWORD           dwRet;

    ZeroMemory( &mciOpen, sizeof(mciOpen) );

    mciOpen.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    wsprintf( szElementName, TEXT("%c:"), chDrive );
    wsprintf( szAliasName, TEXT("SJE%lu:"), dwAliasCount );

    mciOpen.lpstrElementName = szElementName;
    mciOpen.lpstrAlias = szAliasName;

    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    GetVersionEx(&os);
    if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_SHAREABLE | MCI_OPEN_ALIAS |
                  MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;
    }
    else
    {
        dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_ALIAS |
                  MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;
    }

    dwRet = mciSendCommand(0, MCI_OPEN, dwFlags, (DWORD_PTR)(LPVOID)&mciOpen);


    if ( dwRet == MMSYSERR_NOERROR ) {

        MCI_SET_PARMS   mciSet;

        ZeroMemory( &mciSet, sizeof(mciSet) );

        mciSet.dwTimeFormat = MCI_FORMAT_MSF;
        mciSendCommand( mciOpen.wDeviceID, MCI_SET,
                        MCI_SET_TIME_FORMAT, (DWORD_PTR)(LPVOID)&mciSet );
    }
    else {

        /*
        ** Only return the error code if we have been given a valid pointer
        */
        if (lpdwErrCode != NULL) {
            *lpdwErrCode = dwRet;
        }

        mciOpen.wDeviceID = 0;
    }

    return mciOpen.wDeviceID;
}


/******************************Public*Routine******************************\
* CloseCdRom
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
CloseCdRom(
    MCIDEVICEID DevHandle
    )
{
    mciSendCommand( DevHandle, MCI_CLOSE, 0L, 0L );
}


/******************************Public*Routine******************************\
* CheckStatus
*
* Check return code for known bad codes and inform
* user how to correct (if possible) the problem.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckStatus(
    LPSTR szCaller,
    DWORD status,
    int cdrom
    )
{
#if DBG
    TCHAR   s[200];
    TCHAR   err[100];
#endif


    if (status==ERROR_SUCCESS)
        return;

/*
    switch (status)
    {
    case MCIERR_HARDWARE:
        NoMediaUpdate( cdrom );
        break;
    }
*/

#if DBG
    mciGetErrorString( status, err, sizeof(err) / sizeof(TCHAR) );
    wsprintf( s, IdStr( STR_ERR_GEN ), g_Devices[cdrom]->drive, err );

    OutputDebugString (s);
    OutputDebugString (TEXT("\r\n"));
#endif
}



/******************************Public*Routine******************************\
* CheckUnitCdrom
*
* Queries the device state, checking to see if a disc has been ejected or
* inserted.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckUnitCdrom(
    int cdrom,
    BOOL fForceRescan
    )
{
    DWORD   status;

    if ((cdrom < 0) || (cdrom >= MAX_CD_DEVICES))
    {
        return;
    }

    if (fForceRescan)
    {
        // Close Device to force read of correct TOC
        if (g_Devices[cdrom]->hCd != 0L)
        {
            CloseCdRom (g_Devices[cdrom]->hCd);
            g_Devices[cdrom]->hCd = 0L;
        }
    }

    if ( g_Devices[cdrom]->hCd == 0L ) {

        g_Devices[cdrom]->hCd = OpenCdRom( g_Devices[cdrom]->drive, NULL );

        if ( g_Devices[cdrom]->hCd == 0 ) {
            return;
        }
        else {

            /*
            ** Force a rescan of this disc.
            */
            g_Devices[cdrom]->State = CD_NO_CD;
        }

    }

    status = TestUnitReadyCdrom( g_Devices[cdrom]->hCd );

    if (g_Devices[cdrom]->State & CD_NO_CD)
    {

        if (status == ERROR_SUCCESS) {

            /*
            ** A new disc has been inserted, scan it now.
            */

            RescanDevice( g_hwndApp, cdrom );
        }
    }
    else {

        if (status != ERROR_SUCCESS) {

            /*
            ** Disc has been ejected.
            */

            NoMediaUpdate( cdrom );
        }
    }
}


/******************************Public*Routine******************************\
* NoMediaUpdate
*
* Update the user display when it is found that no media is in the device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
NoMediaUpdate(
    int cdrom
    )
{
    BOOL fChangePlayButtons;

    if ( cdrom == g_CurrCdrom )
    {
        fChangePlayButtons = TRUE;
    }
    else {
        fChangePlayButtons = FALSE;
    }

    g_Devices[cdrom]->State = (CD_NO_CD | CD_STOPPED);

    if (fChangePlayButtons)
    {
        g_pSink->OnEvent(MMEVENT_ONMEDIAUNLOADED,NULL);

        //tell the UI to gray out the button
        HWND hwndTrackButton = GetDlgItem(GetParent(g_hwndApp),IDB_TRACK);
        if (hwndTrackButton)
        {
            EnableWindow(hwndTrackButton,FALSE);
        }

        SetPlayButtonsEnableState();
    }

    //tell the playlist
	// Drive has been ejected
    if (g_pSink)
    {
        LPCDOPT pOpt = (LPCDOPT)g_pSink->GetOptions();
        LPCDOPTIONS pCDOpts = NULL;
        LPCDUNIT pUnit = NULL;

        if (pOpt)
        {
            pCDOpts = pOpt->GetCDOpts();
        }

        if (pCDOpts)
        {
            pUnit = pCDOpts->pCDUnitList;
        }

        //scan the list to find the one we want
        for (int index = 0; index < cdrom; index++)
        {
            if (pUnit)
            {
                pUnit = pUnit->pNext;
            }
        }

        if (pUnit)
        {
            pUnit->dwTitleID = CDTITLE_NODISC;
            pUnit->dwNumTracks = 0;
            pUnit->szNetQuery[0] = '\0';
            pOpt->DiscChanged(pUnit);
        }
    } //end if sink


    TimeAdjustInitialize( cdrom );
}



/******************************Public*Routine******************************\
* EjectTheCdromDisc
*
* Eject the disc from the specified cdrom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
EjectTheCdromDisc(
    int cdrom
    )
{
    DWORD status;

    /*
    ** Stop the drive first
    */

    status = StopCdrom( g_Devices[cdrom]->hCd );

    /*
    ** Eject the disc
    */

    status = EjectCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "EjectCdrom", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* PlayCurrTrack
*
* Set cdrom device playing from start MSF to end MSF of current
* track.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
PlayCurrTrack(
    int cdrom
    )
{
    DWORD status;
    MCI_PLAY_PARMS pam;
    int min,sec,endindex;
    PTRACK_PLAY tr;

    tr = CURRTRACK( cdrom );
    if (tr==NULL) {

        return( FALSE );

    }

    sec = TRACK_S(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurSec;
    min = TRACK_M(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurMin;
    min+= (sec / 60);
    sec = (sec % 60);

    pam.dwFrom = MCI_MAKE_MSF( min, sec, TRACK_F(cdrom,tr->TocIndex) );

    endindex = FindContiguousEnd( cdrom, tr );

    pam.dwTo = MCI_MAKE_MSF( TRACK_M(cdrom,endindex),
                             TRACK_S(cdrom,endindex),
                             TRACK_F(cdrom,endindex) );

#if DBG
{
    long lAddress, lEndPos, lStartPos;

    dprintf( TEXT("Playing from     : %2.2d:%2.2d:%2.2d"),
             MCI_MSF_MINUTE(pam.dwFrom),
             MCI_MSF_SECOND(pam.dwFrom),
             MCI_MSF_FRAME( pam.dwFrom) );
    dprintf( TEXT("Playing to       : %2.2d:%2.2d:%2.2d"),
             MCI_MSF_MINUTE(pam.dwTo),
             MCI_MSF_SECOND(pam.dwTo),
             MCI_MSF_FRAME( pam.dwTo) );

    lAddress = pam.dwFrom;
    lStartPos = (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
                (MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
                (MCI_MSF_FRAME(lAddress));

    lAddress = pam.dwTo;
    lEndPos   = (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
                (MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
                (MCI_MSF_FRAME(lAddress));

    lAddress = lEndPos - lStartPos;
    lStartPos =
        MCI_MAKE_MSF((lAddress / FRAMES_PER_MINUTE),
                     (lAddress % FRAMES_PER_MINUTE) / FRAMES_PER_SECOND,
                     (lAddress % FRAMES_PER_MINUTE) % FRAMES_PER_SECOND);

    lAddress = lStartPos;
    dprintf( TEXT("Play length      : %2.2d:%2.2d:%2.2d"),
             MCI_MSF_MINUTE(lAddress),
             MCI_MSF_SECOND(lAddress),
             MCI_MSF_FRAME( lAddress) );
}
#endif
    status = PlayCdrom( g_Devices[cdrom]->hCd, &pam );

    CheckStatus( "PlayCurrTrack", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* StopTheCdromDrive
*
* Tell the cdrom device to stop playing
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
StopTheCdromDrive(
    int cdrom
    )
{

    DWORD status;

    status = StopCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "StopCdrom", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* PauseTheCdromDrive
*
* Tell the cdrom device to pause playing
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
PauseTheCdromDrive(
    int cdrom
    )
{

    DWORD status;

    status = PauseCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "PauseCdrom", status, cdrom );

    return status == ERROR_SUCCESS;
}



/******************************Public*Routine******************************\
* ResumeTheCdromDrive
*
* Tell the cdrom device to resume playing
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
ResumeTheCdromDrive(
    int cdrom
    )
{

    DWORD status;

    status = ResumeCdrom( g_Devices[cdrom]->hCd, cdrom );

    CheckStatus( "ResumeCdrom", status, cdrom );

    if ( status == ERROR_NOT_READY ) {
        NoMediaUpdate( cdrom );
    }

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* SeekToCurrSecond
*
* Seek to the position on the disc represented by the
* current time (position) information in gDevices, and
* continue playing to the end of the current track.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
SeekToCurrSecond(
    int cdrom
    )
{
    DWORD       status;
    int         endindex;
    PTRACK_PLAY tr;
    UCHAR       StartingF, StartingS, StartingM;


    /*
    ** Build starting and ending positions for play
    */

    tr = CDTIME(cdrom).CurrTrack;
    if (tr == NULL) {

        return FALSE;
    }

    StartingM = (TRACK_M(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurMin);
    StartingS = (TRACK_S(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurSec);
    StartingF = (TRACK_F(cdrom,tr->TocIndex));

    if (StartingS > 59) {
        StartingM++;
        StartingS -= (UCHAR)60;
    }

    if (g_Devices[ cdrom ]->State & CD_PLAYING) {

        MCI_PLAY_PARMS mciPlay;


        endindex = FindContiguousEnd( cdrom, tr );

        mciPlay.dwFrom = MCI_MAKE_MSF( StartingM, StartingS, StartingF );
        mciPlay.dwTo   = MCI_MAKE_MSF( TRACK_M(cdrom,endindex),
                                       TRACK_S(cdrom,endindex),
                                       TRACK_F(cdrom,endindex) );
        status = PlayCdrom( g_Devices[ cdrom ]->hCd, &mciPlay );
    }
    else {

        MCI_SEEK_PARMS mciSeek;

        mciSeek.dwTo = MCI_MAKE_MSF( StartingM, StartingS, StartingF );

        status = SeekCdrom( g_Devices[ cdrom ]->hCd, &mciSeek );

    }

    CheckStatus( "SeekToCurrSec", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* GetCurrPos
*
* Query cdrom device for its current position and status
* and return information in callers buffer.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
GetCurrPos(
    int cdrom,
    PCURRPOS CpPtr
    )
{
    DWORD status;
    DWORD dwStatus;
    DWORD dwTrack;
    DWORD dwAbsPos;
    BOOL  fNT;

    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    GetVersionEx(&os);
    if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        fNT = TRUE;
    }
    else
    {
        fNT = FALSE;
    }


    /*
    ** Tell lower layer what we want it to do...in this case,
    ** we need to specify which SubQData format we want returned.
    ** This is exported from scsicdrom.sys to the user layer
    ** so that it could be implemented in one call, instead of
    ** four separate calls (there are four SubQData formats)
    */

    /*
    ** Set up for current position SubQData format.
    */

    if (CDTIME(cdrom).CurrTrack != NULL) {

        if (fNT)
        {
            status = StatusTrackPosCdrom ( g_Devices[ cdrom ]->hCd, &dwStatus, &dwTrack, &dwAbsPos);
        }
        else
        {
            status = GetCdromCurrentPosition( g_Devices[ cdrom ]->hCd, &dwAbsPos );
        }

    }
    else {

        status = MCIERR_INTERNAL;

    }

    if (status == ERROR_SUCCESS) {

        int     iTrack;
        LONG    lAbsPosF;
        LONG    lStartPos;
        LONG    lTrackPos;

        if (!fNT)
        {
            iTrack = (int)GetCdromCurrentTrack( g_Devices[ cdrom ]->hCd );
        }
        else
        {
            iTrack = (int)dwTrack;
        }

        if (!fNT)
        {
            CpPtr->AudioStatus = GetCdromMode( g_Devices[ cdrom ]->hCd );
        }
        else
        {
            CpPtr->AudioStatus = dwStatus;
        }
        CpPtr->Track = iTrack;
        CpPtr->Index = 1;

        iTrack--;

        lStartPos = (TRACK_M(cdrom, iTrack ) * FRAMES_PER_MINUTE) +
                    (TRACK_S(cdrom, iTrack ) * FRAMES_PER_SECOND) +
                    (TRACK_F(cdrom, iTrack ));

        lAbsPosF  = (MCI_MSF_MINUTE(dwAbsPos) * FRAMES_PER_MINUTE) +
                    (MCI_MSF_SECOND(dwAbsPos) * FRAMES_PER_SECOND) +
                    (MCI_MSF_FRAME(dwAbsPos));

        lTrackPos = lAbsPosF - lStartPos;

        /*
        ** Are we in the track lead in zone ?
        */
        if ( lTrackPos < 0 ) {

            /*
            ** Have we just entered the lead in zone
            */
            if (!g_Devices[cdrom]->fProcessingLeadIn) {

                g_Devices[cdrom]->fProcessingLeadIn = TRUE;

                /*
                ** Is the track that we are currently in the next track
                ** that we actually want to play.  If it is then everything is
                ** OK.  If it isn't then we need to hack the current position
                ** information so that it looks like we sre still playing the
                ** previous track.
                */
                if ( CURRTRACK(cdrom)->nextplay
                  && CURRTRACK(cdrom)->nextplay->TocIndex == iTrack) {

                    g_Devices[cdrom]->fShowLeadIn = TRUE;
                }
                else {
                    g_Devices[cdrom]->fShowLeadIn = FALSE;
                }
            }

            g_Devices[cdrom]->fShowLeadIn = FALSE;

            if (g_Devices[cdrom]->fShowLeadIn) {

                CpPtr->Index = 0;
                lTrackPos = -lTrackPos;
            }
            else {

                CpPtr->Track = iTrack;
                iTrack--;
                lTrackPos = lAbsPosF
                               - g_Devices[cdrom]->toc.TrackData[iTrack].AddressF;
            }
        }
        else {

            g_Devices[cdrom]->fShowLeadIn = FALSE;
            g_Devices[cdrom]->fProcessingLeadIn = FALSE;
        }

        CpPtr->m = (int)(lTrackPos / FRAMES_PER_MINUTE);
        CpPtr->s = (int)(lTrackPos % FRAMES_PER_MINUTE) / FRAMES_PER_SECOND;
        CpPtr->f = (int)(lTrackPos % FRAMES_PER_MINUTE) % FRAMES_PER_SECOND;

        CpPtr->ab_m = (int)MCI_MSF_MINUTE(dwAbsPos);
        CpPtr->ab_s = (int)MCI_MSF_SECOND(dwAbsPos);
        CpPtr->ab_f = (int)MCI_MSF_FRAME(dwAbsPos);

        /*
        ** Round up to the nearest second.
        */
        if (CpPtr->f > (FRAMES_PER_SECOND / 2) ) {

            if ( ++CpPtr->s > 59 ) {
                CpPtr->s = 0;
                CpPtr->m++;
            }
        }
        else {
            CpPtr->f = 0;
        }

        if (CpPtr->ab_f > (FRAMES_PER_SECOND / 2) ) {

            if ( ++CpPtr->ab_s > 59 ) {
                CpPtr->ab_s = 0;
                CpPtr->ab_m++;
            }
        }
        else {
            CpPtr->ab_f = 0;
        }

    }
    else {

        ZeroMemory( CpPtr, sizeof(*CpPtr) );
    }

    CheckStatus( "GetCurrPos", status, cdrom );

    return status==ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* SeekToTrackAndHold
*
* Seek to specified track and enter hold state.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
SeekToTrackAndHold(
    int cdrom,
    int tindex
    )
{
    DWORD status;
    MCI_SEEK_PARMS sam;

    sam.dwTo = MCI_MAKE_MSF( TRACK_M(cdrom,tindex),
                             TRACK_S(cdrom,tindex),
                             TRACK_F(cdrom,tindex) );

    status = SeekCdrom( g_Devices[ cdrom ]->hCd, &sam );

    CheckStatus( "SeekToTrackAndHold", status, cdrom );

    return status == ERROR_SUCCESS;
}



/* -------------------------------------------------------------------------
**
** Low level routines
**
** -------------------------------------------------------------------------
*/


/******************************Public*Routine******************************\
* GetCdromTOC
*
* This routine will get the table of contents from
* a CDRom device.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromTOC(
    MCIDEVICEID DevHandle,
    PCDROM_TOC TocPtr
    )
{
    MCI_STATUS_PARMS mciStatus;
    long lAddress, lStartPos, lDiskLen;
    int i;
    DWORD dwRet;

#if DBG
    dprintf( TEXT("Reading TOC for drive %d"), DevHandle );
#endif

    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;

    //
    // NOTE: none of the mciSendCommand calls below bother to check the
    //       return code.  This is asking for trouble... but if the
    //       commands fail we cannot do much about it.
    //
    dwRet = mciSendCommand( DevHandle, MCI_STATUS,
                    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus);

    TocPtr->FirstTrack = 1;
    TocPtr->LastTrack = (UCHAR)mciStatus.dwReturn;

    mciStatus.dwItem = MCI_STATUS_POSITION;
    for ( i = 0; i < TocPtr->LastTrack; i++ ) {

        mciStatus.dwTrack = i + 1;
        dwRet = mciSendCommand( DevHandle, MCI_STATUS,
                        MCI_STATUS_ITEM | MCI_TRACK,
                        (DWORD_PTR)(LPVOID)&mciStatus);

        TocPtr->TrackData[i].TrackNumber = (UCHAR)(i + 1);
        lAddress = TocPtr->TrackData[i].Address = (long)mciStatus.dwReturn;

        lStartPos = (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
                    (MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
                    (MCI_MSF_FRAME( lAddress));

        TocPtr->TrackData[i].AddressF = lStartPos;

    }


    mciStatus.dwItem = MCI_STATUS_LENGTH;
    dwRet = mciSendCommand( DevHandle, MCI_STATUS,
                    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus);

    /*
    ** Convert the absolute start address of the first track
    ** into Frames
    */
    lAddress  = TocPtr->TrackData[0].Address;
    lStartPos = TocPtr->TrackData[0].AddressF;

    /*
    ** Convert the total disk length into Frames
    */
    lAddress  = (long)mciStatus.dwReturn;
    lDiskLen  = (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
                (MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
                (MCI_MSF_FRAME(lAddress));

    /*
    ** Now, determine the absolute start position of the sentinel
    ** track.  That is, the special track that marks the end of the
    ** disk.
    */
    lAddress = lStartPos + lDiskLen;

    TocPtr->TrackData[i].TrackNumber = 0;
    TocPtr->TrackData[i].Address     =
        MCI_MAKE_MSF((lAddress / FRAMES_PER_MINUTE),
                     (lAddress % FRAMES_PER_MINUTE) / FRAMES_PER_SECOND,
                     (lAddress % FRAMES_PER_MINUTE) % FRAMES_PER_SECOND);

    return (TocPtr->LastTrack != 0) ? ERROR_SUCCESS : MCIERR_INTERNAL;
}




/******************************Public*Routine******************************\
* StopCdrom
*
* This routine will stop a CDRom device that is playing.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
StopCdrom(
    MCIDEVICEID DevHandle
    )
{
    MCI_GENERIC_PARMS mciGen;

    ZeroMemory( &mciGen, sizeof(mciGen) );

    return mciSendCommand( DevHandle, MCI_STOP, 0L, (DWORD_PTR)(LPVOID)&mciGen );
}



/******************************Public*Routine******************************\
* PauseCdrom
*
* This routine will pause a CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
PauseCdrom(
    MCIDEVICEID DevHandle
    )
{
    MCI_GENERIC_PARMS mciGen;

    ZeroMemory( &mciGen, sizeof(mciGen) );

    return mciSendCommand( DevHandle, MCI_PAUSE, 0L, (DWORD_PTR)(LPVOID)&mciGen );
}


/******************************Public*Routine******************************\
* ResumeCdrom
*
* This routine will resume a paused CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
ResumeCdrom(
    MCIDEVICEID DevHandle,
    int cdrom
    )

{
    MCI_GENERIC_PARMS   mciGen;
    DWORD               dwRet;
    static int          fCanResume = -1;

    ZeroMemory( &mciGen, sizeof(mciGen) );

    switch (fCanResume) {

    case -1:
        dwRet = mciSendCommand( DevHandle, MCI_RESUME, MCI_TO, (DWORD_PTR)(LPVOID)&mciGen );

        fCanResume = (dwRet == MMSYSERR_NOERROR ? 1 : 0);

        if (0 == fCanResume) {
            dwRet = (PlayCurrTrack( cdrom ) ? MMSYSERR_NOERROR : MCIERR_HARDWARE);
        }
        break;

    case 0:
        dwRet = (PlayCurrTrack( cdrom ) ? MMSYSERR_NOERROR : MCIERR_HARDWARE);
        break;

    case 1:
        dwRet = mciSendCommand( DevHandle, MCI_RESUME, MCI_TO, (DWORD_PTR)(LPVOID)&mciGen );
        break;
    }

    return dwRet;
}



/******************************Public*Routine******************************\
* PlayCdrom
*
* This routine plays a CDRom device starting and ending at the MSF
* positions specified in the structure passed in.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
PlayCdrom(
    MCIDEVICEID DevHandle,
    MCI_PLAY_PARMS *mciPlay
    )
{
    return mciSendCommand( DevHandle, MCI_PLAY,
                           MCI_FROM | MCI_TO, (DWORD_PTR)(LPVOID)mciPlay );
}

/******************************Public*Routine******************************\
* IsCdromTrackAudio
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
IsCdromTrackAudio(
    CDHANDLE DevHandle,
    int iTrackNumber
    )
{
    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_CDA_STATUS_TYPE_TRACK;
    mciStatus.dwTrack = iTrackNumber + 1;

    mciSendCommand( DevHandle, MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK,
                    (DWORD_PTR)(LPVOID)&mciStatus);

    return mciStatus.dwReturn == (DWORD)MCI_CDA_TRACK_AUDIO;
}


/******************************Public*Routine******************************\
* GetCdromCurrentPosition
*
* Gets the current ABSOLUTE position of the specified cdrom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromCurrentPosition(
    CDHANDLE DevHandle,
    DWORD *lpdwPosition
    )
{

    MCI_STATUS_PARMS mciStatus;
    DWORD            dwErr;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    mciStatus.dwItem = MCI_STATUS_POSITION;
    dwErr = mciSendCommand( DevHandle, MCI_STATUS,
                            MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus );
    *lpdwPosition = (long)mciStatus.dwReturn;

    return dwErr;
}



/******************************Public*Routine******************************\
* GetCdromMode
*
* Gets the current mode of the cdrom.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromMode(
    MCIDEVICEID DevHandle
    )
{

    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    mciStatus.dwItem = MCI_STATUS_MODE;
    mciSendCommand( DevHandle, MCI_STATUS,
                    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus );
    return (DWORD)mciStatus.dwReturn;
}


/******************************Public*Routine******************************\
* GetCdromCurrentTrack
*
* Gets the current track of the cdrom.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromCurrentTrack(
    MCIDEVICEID DevHandle
    )
{

    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    mciStatus.dwItem = MCI_STATUS_CURRENT_TRACK;
    mciSendCommand( DevHandle, MCI_STATUS,
                    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus );
    return (DWORD)mciStatus.dwReturn;
}


/******************************Public*Routine******************************\
* SeekCdrom
*
* This routine seek to an MSF address on the audio CD and enters
* a hold (paused) state.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
SeekCdrom(
    MCIDEVICEID DevHandle,
    MCI_SEEK_PARMS *mciSeek
    )
{
    return mciSendCommand( DevHandle, MCI_SEEK,
                           MCI_TO, (DWORD_PTR)(LPVOID)mciSeek );
}



/******************************Public*Routine******************************\
* EjectCdrom
*
* This routine will eject a disc from a CDRom device or close the tray if
* it is open.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
EjectCdrom(
    MCIDEVICEID DevHandle
    )
{
    MCI_SET_PARMS   mciSet;
    DWORD mmr = ERROR_SUCCESS;

    ZeroMemory( &mciSet, sizeof(mciSet) );

    if ((GetCdromMode(DevHandle) == (DWORD)MCI_MODE_OPEN) && g_fCDOpen)
    {
        mmr = mciSendCommand( DevHandle, MCI_SET,
                               MCI_SET_DOOR_CLOSED, (DWORD_PTR)(LPVOID)&mciSet );

        if (mmr == ERROR_SUCCESS)
        {
            g_fCDOpen = FALSE;
        }
    }
    else
    {
        mmr = mciSendCommand( DevHandle, MCI_SET,
                               MCI_SET_DOOR_OPEN, (DWORD_PTR)(LPVOID)&mciSet );

        if (mmr == ERROR_SUCCESS)
        {
            g_fCDOpen = TRUE;
        }
    }

    return (mmr);
}



/******************************Public*Routine******************************\
* TestUnitReadyCdrom
*
* This routine will retrieve the status of the CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
TestUnitReadyCdrom(
    MCIDEVICEID DevHandle
    )
{
    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    mciStatus.dwItem = MCI_STATUS_MEDIA_PRESENT;
    if ( mciSendCommand( DevHandle, MCI_STATUS, MCI_STATUS_ITEM,
                         (DWORD_PTR)(LPVOID)&mciStatus ) == MMSYSERR_NOERROR ) {

        return mciStatus.dwReturn ? ERROR_SUCCESS : ERROR_NOT_READY;
    }

    return ERROR_NOT_READY;

}



/******************************Public*Routine******************************\
* StatusTrackPosCdrom
*
* This routine will retrieve the 
* status, current track, and current position of the CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
StatusTrackPosCdrom(
    MCIDEVICEID DevHandle,
    DWORD * pStatus,
    DWORD * pTrack,
    DWORD * pPos
    )
{
    DWORD dwErr;
    MCI_STATUS_PARMS mciStatus;
    PSTATUSTRACKPOS pSTP = NULL;
    STATUSTRACKPOS stp;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    // Note:  This is a non-standard MCI call (I.E. HACK!)
    //        the only reason for this behavior is it reduces
    //        the number of IOCTL's per 1/2 second on the HeartBeat
    //        thread for updating the timer display from ~15 to only
    //        ~1 on average.   Resulting in a major reduction in
    //        system traffic on the SCSI or IDE bus.

    // Note:  we are passing down a structre to MCICDA containing
    //        the position, track, and status values which it will
    //        fill in for us and return.
    mciStatus.dwItem = MCI_STATUS_TRACK_POS;
    mciStatus.dwReturn = (DWORD_PTR)&stp;
    dwErr = mciSendCommand( DevHandle, MCI_STATUS, MCI_STATUS_ITEM,
                         (DWORD_PTR)(LPVOID)&mciStatus );
    if (dwErr == MMSYSERR_NOERROR)
    {
        pSTP = (PSTATUSTRACKPOS)mciStatus.dwReturn;
        if (pSTP)
        {
            if (pStatus)
                *pStatus = pSTP->dwStatus;
            if (pTrack)
                *pTrack = pSTP->dwTrack;
            if (pPos)
                *pPos = pSTP->dwDiscTime;

            pSTP = NULL;
        }
    }

    return dwErr;
} // End StatusTrackPosCdrom

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\volopt.cpp ===
//--------------------------------------------------------------------------;
//
//  File: volopt.cpp
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;

#include "precomp.h"  
#include <regstr.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "optres.h"
#include "cdopti.h"
#include "cdoptimp.h"
#include "helpids.h"
#include "winbase.h"

//////////////
// Help ID's
//////////////

#pragma data_seg(".text")
const static DWORD aVolOptsHelp[] = 
{
    IDC_VOL_MSG_TEXT,       IDH_VOL_MSG,
    IDC_VOL_CONFIG_GROUP,   IDH_VOL_MSG,
    IDC_DEFAULTMIXER,       IDH_USEMIXERDEFAULTS,
    IDC_SELECTPLAYER_TEXT,  IDH_SELECTCDPLAYER,
    IDC_CDDRIVE,            IDH_SELECTCDPLAYER,
    IDC_SELECTMIXER_TEXT,   IDH_SELECTCDMIXER,
    IDC_AUDIOMIXER,         IDH_SELECTCDMIXER,      
    IDC_SELECTCONTROL_TEXT, IDH_SELECTCDCONTROL,
    IDC_AUDIOCONTROL,       IDH_SELECTCDCONTROL,
    0, 0
};
#pragma data_seg()

////////////
// Types
////////////

typedef struct CDCTL            // Used to write to reg (don't change)
{
    DWORD dwVolID;
    DWORD dwMuteID;

} CDCTL, *LPCDCTL;



////////////
// Globals
////////////
#define MYREGSTR_PATH_MEDIA  TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaResources")
const TCHAR gszRegstrCDAPath[]   = MYREGSTR_PATH_MEDIA TEXT("\\mci\\cdaudio");
const TCHAR gszDefaultCDA[]      = TEXT("Default Drive");

const TCHAR szRegstrCDROMPath[]  = TEXT("System\\CurrentControlSet\\Services\\Class\\");
const TCHAR szPrefMixer[]        = TEXT("Preferred Mixer");
const TCHAR szPrefControls[]     = TEXT("Preferred Controls");
const TCHAR szSelected[]         = TEXT("Selected");

const TCHAR szMapperPath[]       = TEXT("Software\\Microsoft\\Multimedia\\Sound Mapper");
const TCHAR szPlayback[]         = TEXT("Playback");
const TCHAR szPreferredOnly[]    = TEXT("PreferredOnly");

const TCHAR szNTCDROMPath[]      = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\DeluxeCD\\Settings\\");



////////////
// Functions
////////////


/////////////
// Uses new winmm feature to get the preferred wave ID, much cleaner.
//
STDMETHODIMP_(MMRESULT) CCDOpt::GetDefaultMixID(DWORD *pdwMixID)
{
    MMRESULT        mmr;
    DWORD           dwWaveID;
    DWORD           dwFlags = 0;
    
    mmr = waveOutMessage((HWAVEOUT)WAVE_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pdwMixID)
    {
        *pdwMixID = dwWaveID;
    }

    return(mmr);
}


///////////
// A mixer line has been found with controls, this function is called to either 1) verify 
// that passed in VolID and MuteID's can be found on this mixer line and are of the right
// control type.  or 2) to find the Volume Slider and Mute ID controls that do exist on
// this mixer line.
//

STDMETHODIMP_(void) CCDOpt::SearchControls(int mxid, LPMIXERLINE pml, LPDWORD pdwVolID, LPDWORD pdwMuteID, TCHAR *szName, BOOL *pfFound, BOOL fVerify)
{
    MIXERLINECONTROLS mlc;
    DWORD dwControl;

    memset(&mlc, 0, sizeof(mlc));
    mlc.cbStruct = sizeof(mlc);
    mlc.dwLineID = pml->dwLineID;
    mlc.cControls = pml->cControls;
    mlc.cbmxctrl = sizeof(MIXERCONTROL);
    mlc.pamxctrl = (LPMIXERCONTROL) new(MIXERCONTROL[pml->cControls]);

    if (mlc.pamxctrl)
    {
        if (mixerGetLineControls((HMIXEROBJ) mxid, &mlc, MIXER_GETLINECONTROLSF_ALL) == MMSYSERR_NOERROR)
        {
            for (dwControl = 0; dwControl < pml->cControls && !(*pfFound); dwControl++)
            {
                if (mlc.pamxctrl[dwControl].dwControlType == (DWORD)MIXERCONTROL_CONTROLTYPE_VOLUME)
                { 
                    DWORD dwIndex;
                    DWORD dwVolID = DWORD(-1);
                    DWORD dwMuteID = DWORD(-1);

                    dwVolID = mlc.pamxctrl[dwControl].dwControlID;

                    for (dwIndex = 0; dwIndex < pml->cControls; dwIndex++)
                    {
                        if (mlc.pamxctrl[dwIndex].dwControlType == (DWORD)MIXERCONTROL_CONTROLTYPE_MUTE)
                        {
                            dwMuteID = mlc.pamxctrl[dwIndex].dwControlID;
                            break;
                        }
                    }

                    if (fVerify)
                    {
                        if (*pdwVolID == dwVolID && *pdwMuteID == dwMuteID)
                        {
                            if (szName)
                            {
                                lstrcpy(szName, pml->szName); // mlc.pamxctrl[dwControl].szName);
                            }

                            *pfFound = TRUE;
                        }
                    }
                    else
                    {
                        if (szName)
                        {
                            lstrcpy(szName, pml->szName); // mlc.pamxctrl[dwControl].szName);
                        }

                        *pfFound = TRUE;
                        *pdwVolID = dwVolID;
                        *pdwMuteID = dwMuteID;
                    }
                } 
            }
        }

        delete mlc.pamxctrl;
    }
}

///////////////
// If a mixer line has connects, this function is called to enumerate all lines that have controls
// that meet our criteria and then seek out the controls on those connections using the above SearchControls
// function.  
//
// NOTE: This function makes two scans over the connections, first looking for CompactDisc lines, and then
// if unsuccessful, it makes a second scan looking for other lines that might have a CD connected, like line-in 
// and aux lines.
//
STDMETHODIMP_(void) CCDOpt::SearchConnections(int mxid, DWORD dwDestination, DWORD dwConnections, LPDWORD pdwVolID, LPDWORD pdwMuteID, TCHAR *szName, BOOL *pfFound, BOOL fVerify)
{
    MIXERLINE   mlDst;
    DWORD       dwConnection;
    DWORD       dwScan;

    for (dwScan = 0; dwScan < 2 && !(*pfFound); dwScan++)  // On first scan look for CD, on second scan, look for anything else.
    {
        for (dwConnection = 0; dwConnection < dwConnections && !(*pfFound); dwConnection++) 
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwDestination  = dwDestination;
            mlDst.dwSource = dwConnection;

            if (mixerGetLineInfo((HMIXEROBJ) mxid, &mlDst, MIXER_GETLINEINFOF_SOURCE) == MMSYSERR_NOERROR)
            {
                if (mlDst.cControls)    // Make sure this source has controls on it
                {
                    if (((dwScan == 0) && (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC)) ||
                        ((dwScan == 1) && (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_LINE ||
                                           mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY || 
                                           mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_DIGITAL || 
                                           mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_ANALOG)))
                    {
                        SearchControls(mxid, &mlDst, pdwVolID, pdwMuteID, szName, pfFound, fVerify);
                    }
                }
            }
        }
    }
}


/////////////////
// Used in two modes, fVerify is TRUE,  the VolID and MuteID are inputs and will return TRUE if valid 
// if not in verification mode, this function is used to compute the default vol and mute ID's for this device.
// It scans all the destinations on the Mixer looking for output destinations (speakers, headphones, etc)
// Once it finds them, it then Searchs for controls on itself and/or any connections itself.
//
// NOTE: The current default behavior is to locate CD type connections, and then, if not finding any that
// work, to attempt to use the destination master volume.  To reverse this, look for master volume first, and then
// look for CD lines if master can't be found, Switch the two intermost If conditions and calls so that
// SearchControls on the line happens before the connections are searched.

STDMETHODIMP_(BOOL) CCDOpt::SearchDevice(DWORD dwMixID, LPCDUNIT pCDUnit, LPDWORD pdwVolID, LPDWORD pdwMuteID, TCHAR *szName, BOOL fVerify)
{
    MIXERCAPS mc;
    MMRESULT mmr;
    BOOL    fFound = FALSE;

    mmr = mixerGetDevCaps(dwMixID, &mc, sizeof(mc)); 
    
    if (mmr == MMSYSERR_NOERROR)
    {
        MIXERLINE   mlDst;
        DWORD       dwDestination;

        if (pCDUnit)
        {
            lstrcpy(pCDUnit->szMixerName, mc.szPname);
        }

        for (dwDestination = 0; dwDestination < mc.cDestinations && !fFound; dwDestination++)
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwDestination = dwDestination;

            if (mixerGetLineInfo((HMIXEROBJ) dwMixID, &mlDst, MIXER_GETLINEINFOF_DESTINATION  ) == MMSYSERR_NOERROR)
            {
                if (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_SPEAKERS ||    // needs to be a likely output destination
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_HEADPHONES ||
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT)
                {
                    // Note: To default to Master Volume (instead of CD volume) just SearchControls first.

                    if (!fFound && mlDst.cConnections)  // only look at connections if there is no master slider control.
                    {
                        SearchConnections(dwMixID, dwDestination, mlDst.cConnections, pdwVolID, pdwMuteID, szName, &fFound, fVerify);
                    }

                    if (!fFound && mlDst.cControls)     // If there are controls, we'll take the master
                    {
                        SearchControls(dwMixID, &mlDst, pdwVolID, pdwMuteID, szName, &fFound, fVerify);
                    }
                }
            }
        }
    }
    
    return(fFound);  
}


////////////////
// When a new CD is found, and there are no valid enteries in the registry for it, we compute
// defaults for that unit.  This function uses the above function SearchDevice to do just that.
// First it finds the preferred MixerID and assumes this CD is connected to it, this it finds
// the default controls on that mixer and assignes them.
//
STDMETHODIMP_(void) CCDOpt::GetUnitDefaults(LPCDUNIT pCDUnit)
{
    if (pCDUnit)
    {
        pCDUnit->dwMixID = DWORD(-1);
        pCDUnit->dwVolID = DWORD(-1);
        pCDUnit->dwMuteID = DWORD(-1);

        if (GetDefaultMixID(&pCDUnit->dwMixID) == MMSYSERR_NOERROR)
        {
            SearchDevice(pCDUnit->dwMixID, pCDUnit, &pCDUnit->dwVolID, &pCDUnit->dwMuteID, pCDUnit->szVolName, FALSE);  
        }
    }
}



//////////////
// This function enumerates installed disk devices that are of type CDROM and are installed
// It seeks out the one that matches the specified drive letter and collects information about it
// It returns the class driver path and the descriptive name of the drive.
//
// NOTE This function assumes both szDriver and szDevDesc are the dwSize bytes each.
// 
STDMETHODIMP_(BOOL) CCDOpt::MapLetterToDevice(TCHAR DriveLetter, TCHAR *szDriver, TCHAR *szDevDesc, DWORD dwSize)
{
    HKEY hkEnum;
    BOOL fResult = FALSE;

    if (!RegOpenKey(HKEY_DYN_DATA, REGSTR_PATH_DYNA_ENUM, &hkEnum))
    {
        HKEY      hkDev;
        DWORD     dwEnumDevCnt;
        TCHAR     aszCMKey[MAX_PATH];
        BOOLEAN   found = FALSE;

        for (dwEnumDevCnt = 0; !found && !RegEnumKey(hkEnum, dwEnumDevCnt, aszCMKey, sizeof(aszCMKey)/sizeof(TCHAR)); dwEnumDevCnt++)
        {
            if (!RegOpenKey(hkEnum, aszCMKey, &hkDev))
            {
                TCHAR aszDrvKey[MAX_PATH];
                TCHAR tmp;
                DWORD cb = sizeof(aszDrvKey);

                RegQueryValueEx(hkDev, REGSTR_VAL_HARDWARE_KEY, NULL, NULL, (LPBYTE)&aszDrvKey, &cb);

                tmp = aszDrvKey[5]; 
                aszDrvKey[5] = TEXT('\0');

			    if ( !lstrcmpi( REGSTR_VAL_SCSI, aszDrvKey ) )
                {
                    HKEY  hkDrv;
                    TCHAR aszEnumKey[MAX_PATH];
                    aszDrvKey[5] = tmp;

                    wsprintf(aszEnumKey, TEXT("Enum\\%s"), aszDrvKey);

                    if (!RegOpenKey(HKEY_LOCAL_MACHINE, aszEnumKey, &hkDrv))
                    {
                        TCHAR DrvLet[3];

                        cb = sizeof( DrvLet );

                        RegQueryValueEx(hkDrv, REGSTR_VAL_CURDRVLET, NULL, NULL, (LPBYTE)&DrvLet, &cb);

                        if ( DrvLet[0] == DriveLetter )
                        {
                            DWORD cb2 = dwSize;
                            cb = dwSize;
                            
                            if ((RegQueryValueEx(hkDrv, REGSTR_VAL_DEVDESC, NULL, NULL, (LPBYTE)szDevDesc, &cb) == NO_ERROR) &&
                                (RegQueryValueEx(hkDrv, REGSTR_VAL_DRIVER, NULL, NULL, (LPBYTE)szDriver, &cb2) == NO_ERROR))
                            {
                                fResult = TRUE;
                            }

                            found = TRUE;
                        }

                        RegCloseKey(hkDrv);
                    }
                }
            
                RegCloseKey(hkDev);
            }
        }

        RegCloseKey(hkEnum);        
    }

    if (!fResult)
    {
        //check to see if we're on NT
        OSVERSIONINFO os;
        os.dwOSVersionInfoSize = sizeof(os);
        GetVersionEx(&os);
        if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            TCHAR szDrive[MAX_PATH];
            TCHAR szDriverTemp[MAX_PATH*2];
            TCHAR* szGUID = NULL;
            ZeroMemory(szDriverTemp,sizeof(szDriverTemp));
            ZeroMemory(szDriver,dwSize);

            wsprintf(szDrive,TEXT("%c:\\"),DriveLetter);
            if (GetVolumeNameForVolumeMountPoint(szDrive,szDriverTemp,dwSize/sizeof(TCHAR)))
            {
                //szDriverTemp now has a string like \\?\Volume{GUID}\ ... we just want
                //the {GUID} part, as that is the drive's unique ID.
                szGUID = _tcschr(szDriverTemp,TEXT('{'));
                if (szGUID!=NULL)
                {
                    fResult = TRUE;
                    _tcscpy(szDriver,szGUID);
                    if (szDriver[_tcslen(szDriver)-1] != TEXT('}'))
                    {
                        szDriver[_tcslen(szDriver)-1] = TEXT('\0');
                    }
                }
            }
        } //end if NT
    }

    return(fResult);
}


///////////////
//  Since audio devices can come and go, the names of the devices can change since there is
//  number appended by the system inclosed in brackets at the end of the string.
//  This function attempts to truncate this appended number after copying the original into 
//  the destination buffer.
//
STDMETHODIMP_(BOOL) CCDOpt::TruncName(TCHAR *pDest, TCHAR *pSrc)
{
    BOOL fSuccess = TRUE;

    TCHAR *pTrunc;

    lstrcpy(pDest, pSrc);       

    pTrunc = pDest;
    while (*pTrunc++);

    while (pTrunc-- > pDest)
    {
        if (*pTrunc == TEXT('['))
        {
            *pTrunc = TEXT('\0');
            break;
        }
    }

    if (pTrunc == pDest)
    {
        fSuccess = FALSE;
    }

    return(fSuccess);
}


/////////////////
// After reading the preferred mixer device name from the registry, we have to locate that
// device in the system by mixer ID.  To do this, we scan thru all available mixers looking
// for an exact match of the name.  If an exact match can not be found, we then scan again
// looking for a match using truncated strings where the system appended instance number is
// removed.  If we can't find it at that point, we are in trouble and have to give up.
//
STDMETHODIMP CCDOpt::ComputeMixID(LPDWORD pdwMixID, TCHAR *szMixerName)
{
    HRESULT     hr = E_FAIL;
    DWORD       dwNumMixers;
    DWORD       dwID;
    MMRESULT    mmr;
    BOOL        fFound = FALSE;
    TCHAR       szTruncName[MAXPNAMELEN];
    TCHAR       szTruncSeek[MAXPNAMELEN];
    MIXERCAPS   mc;

    dwNumMixers = mixerGetNumDevs(); 

    for (dwID = 0; dwID < dwNumMixers && !fFound; dwID++)          // First look for EXACT match.
    {
        mmr = mixerGetDevCaps(dwID, &mc, sizeof(mc));   

        if (mmr == MMSYSERR_NOERROR)
        { 
			if (!lstrcmp(mc.szPname, szMixerName))
			{
                hr = S_OK;
                fFound = TRUE;
                *pdwMixID = dwID;
            }
        }
    }

    if (!fFound)    // Exact match isn't found, strip off (#) and look again
    {
        if (TruncName(szTruncName, szMixerName))
        {
            for (dwID = 0; dwID < dwNumMixers && !fFound; dwID++)
            {
                mmr = mixerGetDevCaps(dwID, &mc, sizeof(mc));   

                if (mmr == MMSYSERR_NOERROR)
                { 
                    TruncName(szTruncSeek, mc.szPname);

			        if (!lstrcmp(szTruncSeek, szTruncName))
			        {
                        lstrcpy(szMixerName, mc.szPname); // repair the name we matched
                        hr = S_OK;
                        fFound = TRUE;
                        *pdwMixID  = dwID;
                    }
                }
            }
        }
    }
    
    return(hr);
}

///////////////
// This function looks up this devices registry information using the driver information that
// was mapped from the drive letter.  It attempts to read in the preferred mixer ID and then
// calculate the mixerID from it, if that fails, the function fails and the unit will use default
// information calcuated by this program.  If it succeeds, it then reads in the control ID's for
// the volume and mute controls for this mixer.  If it can't find them or the ones it does find
// can not be located on the specified device, then we compute defaults.  If we can't compute defaults
// the entire function fails and the entire drive is re-computed.
//
STDMETHODIMP CCDOpt::GetUnitRegData(LPCDUNIT pCDUnit)
{
    HRESULT     hr = E_FAIL;
    TCHAR       szRegDriverStr[MAX_PATH];
    HKEY        hKey;
    DWORD       dwMixID;
    CDCTL       cdCtl;
    HKEY        hKeyRoot = HKEY_LOCAL_MACHINE;

    if (pCDUnit)
    {
        OSVERSIONINFO os;
        os.dwOSVersionInfoSize = sizeof(os);
        GetVersionEx(&os);
        if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            hKeyRoot = HKEY_CURRENT_USER;
            wsprintf(szRegDriverStr,TEXT("%s%s"),szNTCDROMPath, pCDUnit->szDriver);
        }
        else
        {
            wsprintf(szRegDriverStr,TEXT("%s%s"),szRegstrCDROMPath, pCDUnit->szDriver);
        }

        if (RegOpenKeyEx(hKeyRoot , szRegDriverStr , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
        {
            DWORD dwSize = sizeof(BOOL);
        
            RegQueryValueEx(hKey, szSelected, NULL, NULL, (LPBYTE) &(pCDUnit->fSelected), &dwSize);
            
            dwSize = MAXPNAMELEN*sizeof(TCHAR);
            
            if (RegQueryValueEx(hKey, szPrefMixer, NULL, NULL, (LPBYTE) pCDUnit->szMixerName, &dwSize) == NO_ERROR)
            {
                hr = ComputeMixID(&dwMixID, pCDUnit->szMixerName);

                if (SUCCEEDED(hr))
                {
                    BOOL fGotControls = FALSE;
                    TCHAR szVolName[MIXER_LONG_NAME_CHARS] = TEXT("\0");

                    dwSize = sizeof(cdCtl);

                    if (RegQueryValueEx(hKey, szPrefControls, NULL, NULL, (LPBYTE) &cdCtl, &dwSize) == NO_ERROR)
                    {
                        fGotControls = SearchDevice(dwMixID, NULL, &cdCtl.dwVolID, &cdCtl.dwMuteID, szVolName, TRUE); // Verify Controls
                    }
                    
                    if (!fGotControls)  // Either were not in reg or fail verification, compute defaults for this device
                    {
                        fGotControls = SearchDevice(dwMixID, NULL, &cdCtl.dwVolID, &cdCtl.dwMuteID, szVolName, FALSE); 
                    }

                    if (!fGotControls)  // If we don't have them by now, we are in trouble.
                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        pCDUnit->dwMixID = dwMixID;        
                        pCDUnit->dwVolID = cdCtl.dwVolID;
                        pCDUnit->dwMuteID = cdCtl.dwMuteID;
                        lstrcpy(pCDUnit->szVolName, szVolName);
                    }
                }
            }

            RegCloseKey(hKey);
        }
    }

    return(hr);
}


////////////////
// This function writes out the preferred mixer device name and the preferred control ID's into the
// cdrom driver registry for safe keeping.
//
STDMETHODIMP_(void) CCDOpt::SetUnitRegData(LPCDUNIT pCDUnit)
{
    HRESULT     hr = E_FAIL;
    TCHAR       szRegDriverStr[MAX_PATH];
    HKEY        hKey;
    CDCTL       cdCtl;

    //this function is very different on NT
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    GetVersionEx(&os);
    if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        if (pCDUnit)
        {
            wsprintf(szRegDriverStr,TEXT("%s%s"),szNTCDROMPath, pCDUnit->szDriver);

            if (RegCreateKeyEx(HKEY_CURRENT_USER , szRegDriverStr , 0 , NULL, 0, KEY_WRITE , NULL, &hKey, NULL) == ERROR_SUCCESS)
            {        
                cdCtl.dwVolID = pCDUnit->dwVolID;
                cdCtl.dwMuteID = pCDUnit->dwMuteID;
            
                RegSetValueEx(hKey, szPrefMixer, NULL, REG_SZ, (LPBYTE) pCDUnit->szMixerName, (sizeof(TCHAR) * lstrlen(pCDUnit->szMixerName))+sizeof(TCHAR));
                RegSetValueEx(hKey, szPrefControls, NULL, REG_BINARY, (LPBYTE) &cdCtl, sizeof(cdCtl));
                RegSetValueEx(hKey, szSelected, NULL, REG_BINARY, (LPBYTE) &(pCDUnit->fSelected), sizeof(BOOL));

                RegCloseKey(hKey);
            }
        }
    } //end if NT
    else
    {
        if (pCDUnit)
        {
            wsprintf(szRegDriverStr,TEXT("%s%s"),szRegstrCDROMPath, pCDUnit->szDriver);

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE , szRegDriverStr , 0 , KEY_WRITE , &hKey) == ERROR_SUCCESS)
            {        
                cdCtl.dwVolID = pCDUnit->dwVolID;
                cdCtl.dwMuteID = pCDUnit->dwMuteID;
            
                RegSetValueEx(hKey, szPrefMixer, NULL, REG_SZ, (LPBYTE) pCDUnit->szMixerName, (sizeof(TCHAR) * lstrlen(pCDUnit->szMixerName))+sizeof(TCHAR));
                RegSetValueEx(hKey, szPrefControls, NULL, REG_BINARY, (LPBYTE) &cdCtl, sizeof(cdCtl));
                RegSetValueEx(hKey, szSelected, NULL, REG_BINARY, (LPBYTE) &(pCDUnit->fSelected), sizeof(BOOL));

                RegCloseKey(hKey);
            }
        }
    } //end else Win9x
}


//////////////////
// Given just the drive letter of a CDROM, this function will obtain all information needed by the
// program on this drive.  Some is calcuated via the PnP registry for this drive's driver, other information
// is obtained from the registry or defaults are computed based on the installed audio components
//
STDMETHODIMP_(void) CCDOpt::GetUnitValues(LPCDUNIT pCDUnit)
{
    if (pCDUnit)
    {
        TCHAR cDriveLetter = pCDUnit->szDriveName[0];

        if (MapLetterToDevice(cDriveLetter, pCDUnit->szDriver, pCDUnit->szDeviceDesc, sizeof(pCDUnit->szDriver)))
        {
            if (FAILED(GetUnitRegData(pCDUnit)))     // Can fail if reg is empty or mixer ID can't be computed
            {
                GetUnitDefaults(pCDUnit);
            }
        }
        else
        {
            GetUnitDefaults(pCDUnit);
        }
    }
}

//////////////////
// This method is called in response to a PnP notify or a WinMM Device Change message.  It will verify
// the existance of all assigned MixerID's and the corresponding Volume and Mute ID on that device.
// In the event the device no-longer exists a default will be computed.
//
//
STDMETHODIMP_(void) CCDOpt::MMDeviceChanged(void)
{
    LPCDUNIT pCDUnit = m_pCDOpts->pCDUnitList;

    while (pCDUnit)
    {
        GetUnitValues(pCDUnit);    
        pCDUnit = pCDUnit->pNext;
    }
}


//////////////////
// This function will save all the information for all the CD drives in the system out to the registry
// it does not modify or delete any of this information.
//
STDMETHODIMP_(void) CCDOpt::WriteCDList(LPCDUNIT pCDList)
{
    if (pCDList)
    {
        LPCDUNIT pUnit = pCDList;

        while (pUnit)
        {
            SetUnitRegData(pUnit);
               
            pUnit = pUnit->pNext;
        }
    }
}

////////////////
// This function will destory the list containing all the drive information in the system
// freeing up all memory, this function does not save any information.
//
STDMETHODIMP_(void) CCDOpt::DestroyCDList(LPCDUNIT *ppCDList)
{

    if (ppCDList && *ppCDList)
    {
        while(*ppCDList)
        {
            LPCDUNIT pTemp = *ppCDList;
            *ppCDList = (*ppCDList)->pNext;
            delete pTemp;
        }
    }
}


STDMETHODIMP_(UINT) CCDOpt::GetDefDrive(void)
{
    HKEY hkTmp;
    UINT uDrive = 0;  

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, gszRegstrCDAPath, 0, KEY_READ, &hkTmp ) == ERROR_SUCCESS)
    {
        DWORD cb = sizeof(UINT);
        RegQueryValueEx(hkTmp, gszDefaultCDA, NULL, NULL, (LPBYTE)&uDrive, &cb);
        RegCloseKey(hkTmp);
    }

    return uDrive;
}

/////////////
// This function builds a list of all the CD drives in the system, the list
// is a linked list with each node containing information that is specific
// to that CD player as well as the user options for each player.
//

STDMETHODIMP CCDOpt::CreateCDList(LPCDUNIT *ppCDList)
{
    DWORD   dwBytes = 0;
    TCHAR   *szDriveNames = NULL;
    HRESULT hr = S_OK;
    UINT    uDefDrive = GetDefDrive();

    if (ppCDList == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LPCDUNIT *ppUnit = NULL;

        *ppCDList = NULL;
        ppUnit = ppCDList;
    
        dwBytes = GetLogicalDriveStrings(0, NULL);

        if (dwBytes)
        {
            szDriveNames = new(TCHAR[dwBytes]);
    
            if (szDriveNames == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                dwBytes = GetLogicalDriveStrings(dwBytes, szDriveNames);

                if (dwBytes)
                {
                    UINT uDrive = 0;

                    while (*szDriveNames)
                    {
                        if (GetDriveType(szDriveNames) == DRIVE_CDROM)
                        {                        
                            *ppUnit = new(CDUNIT);
                        
                            if (*ppUnit == NULL)
                            {
                                hr = E_OUTOFMEMORY;
                                break;
                            }
                            else
                            {
                                memset(*ppUnit,0,sizeof(CDUNIT));
                                _tcsncpy((*ppUnit)->szDriveName,szDriveNames,min(sizeof((*ppUnit)->szDriveName)/sizeof(TCHAR),(UINT)lstrlen(szDriveNames)));

                                (*ppUnit)->dwTitleID = (DWORD)CDTITLE_NODISC;

                                CharUpper((*ppUnit)->szDriveName);

                                GetUnitValues(*ppUnit);
                                
                                if (uDrive == uDefDrive)
                                {
                                    (*ppUnit)->fDefaultDrive = TRUE;
                                }

                                ppUnit = &((*ppUnit)->pNext);
                                uDrive++;
                            }  
                        }

                        while(*szDriveNames++);
                    }
                }
            }  
        }
    }

    if (FAILED(hr))
    {
        DestroyCDList(ppCDList);
    }

    return hr;
}




/////////////
// Traverse the UI Tree, destroying it as it goes.
//
STDMETHODIMP_(void) CCDOpt::DestroyUITree(LPCDDRIVE *ppCDRoot)
{
   if (ppCDRoot)
   {
        LPCDDRIVE pDriveList;

        pDriveList = *ppCDRoot;
        *ppCDRoot = NULL;

        while (pDriveList)
        {
            LPCDDRIVE pNextDrive = pDriveList->pNext;

            while (pDriveList->pMixerList)
            {
                LPCDMIXER pNextMixer = pDriveList->pMixerList->pNext;

                while(pDriveList->pMixerList->pControlList)
                {
                    LPCDCONTROL pNextControl = pDriveList->pMixerList->pControlList->pNext;
                    delete pDriveList->pMixerList->pControlList;
                    pDriveList->pMixerList->pControlList = pNextControl;
                }

                delete pDriveList->pMixerList;
                pDriveList->pMixerList = pNextMixer;
            }

            delete pDriveList;
            pDriveList = pNextDrive;
        }
    }
}


///////////////////
// Add line controls to internal tree data structure for UI
//

STDMETHODIMP CCDOpt::AddLineControls(LPCDMIXER pMixer, LPCDCONTROL *ppLastControl, int mxid, LPMIXERLINE pml)
{
    MIXERLINECONTROLS mlc;
    DWORD dwControl;
    HRESULT hr = S_OK;

    memset(&mlc, 0, sizeof(mlc));
    mlc.cbStruct = sizeof(mlc);
    mlc.dwLineID = pml->dwLineID;
    mlc.cControls = pml->cControls;
    mlc.cbmxctrl = sizeof(MIXERCONTROL);
    mlc.pamxctrl = (LPMIXERCONTROL) new(MIXERCONTROL[pml->cControls]);

    if (mlc.pamxctrl)
    {
        if (mixerGetLineControls((HMIXEROBJ) mxid, &mlc, MIXER_GETLINECONTROLSF_ALL) == MMSYSERR_NOERROR)
        {
            for (dwControl = 0; dwControl < pml->cControls; dwControl++)
            {
                if (mlc.pamxctrl[dwControl].dwControlType == (DWORD)MIXERCONTROL_CONTROLTYPE_VOLUME)
                { 
                    DWORD       dwIndex;
                    DWORD       dwVolID = mlc.pamxctrl[dwControl].dwControlID;
                    DWORD       dwMuteID = DWORD(-1);
                    LPCDCONTROL pControl;

                    for (dwIndex = 0; dwIndex < pml->cControls; dwIndex++)
                    {
                        if (mlc.pamxctrl[dwIndex].dwControlType == (DWORD)MIXERCONTROL_CONTROLTYPE_MUTE)
                        {
                            dwMuteID = mlc.pamxctrl[dwIndex].dwControlID;
                            break;
                        }
                    }

                    pControl = new (CDCONTROL);

                    if (pControl == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        memset(pControl, 0, sizeof(CDCONTROL));

                        if (pMixer->pControlList == NULL)
                        {
                            pMixer->pControlList = pControl;
                        }
                        
                        if (*ppLastControl)
                        {
                            (*ppLastControl)->pNext = pControl;
                        }

                        lstrcpy(pControl->szName, pml->szName); // mlc.pamxctrl[dwControl].szName);
                        pControl->dwVolID = dwVolID;
                        pControl->dwMuteID = dwMuteID;

                        *ppLastControl = pControl;
                    }

                    break;
                } 
            }
        }

        delete mlc.pamxctrl;
    }

    return(hr);
}

/////////////////
// Searchs connections for controls to add to UI tree
//

STDMETHODIMP CCDOpt::AddConnections(LPCDMIXER pMixer, LPCDCONTROL *ppLastControl, int mxid, DWORD dwDestination, DWORD dwConnections)
{
    MIXERLINE   mlDst;
    DWORD       dwConnection;
    HRESULT     hr = S_OK;

    for (dwConnection = 0; dwConnection < dwConnections; dwConnection++)
    {
        mlDst.cbStruct = sizeof ( mlDst );
        mlDst.dwDestination  = dwDestination;
        mlDst.dwSource = dwConnection;

        if (mixerGetLineInfo((HMIXEROBJ) mxid, &mlDst, MIXER_GETLINEINFOF_SOURCE) == MMSYSERR_NOERROR)
        {
            if (mlDst.cControls)    // Make sure this source has controls on it
            {
                if (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC ||
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_LINE ||
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY || 
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_DIGITAL || 
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_ANALOG)
                {
                    hr = AddLineControls(pMixer, ppLastControl, mxid, &mlDst);

                    if (FAILED(hr))
                    {
                        break;
                    }
                }
            }
        }
    }

    return(hr);
}


//////////////
// Adds control nodes to the UI tree for the specified device
//

STDMETHODIMP CCDOpt::AddControls(LPCDMIXER pMixer)
{
    MIXERLINE   mlDst;
    DWORD       dwDestination;
    MIXERCAPS   mc;
    LPCDCONTROL pLastControl = NULL;
    HRESULT     hr = S_OK;

    if (mixerGetDevCaps(pMixer->dwMixID, &mc, sizeof(mc)) == MMSYSERR_NOERROR)
    {   
        for (dwDestination = 0; dwDestination < mc.cDestinations; dwDestination++)
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwDestination = dwDestination;

            if (mixerGetLineInfo((HMIXEROBJ) pMixer->dwMixID, &mlDst, MIXER_GETLINEINFOF_DESTINATION  ) == MMSYSERR_NOERROR)
            {
                if (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_SPEAKERS ||    // needs to be a likely output destination
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_HEADPHONES ||
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT)
                {
                    if (mlDst.cControls)  // If there are no controls, we won't present it to the user as an option
                    {
                        hr = AddLineControls(pMixer, &pLastControl, pMixer->dwMixID, &mlDst);

                        if (FAILED(hr))
                        {
                            break;
                        }
                    }

                    if (mlDst.cConnections)  // If there are connections to this line, lets add thier controls
                    {
                        AddConnections(pMixer, &pLastControl, pMixer->dwMixID, dwDestination, mlDst.cConnections);

                        if (FAILED(hr))
                        {
                            break;
                        }
                    }
                }
            }
        }
    }

    return(hr);
}


///////////////////
// Adds audio mixers to UI tree for the cd player unit specified
//

STDMETHODIMP CCDOpt::AddMixers(LPCDDRIVE pDevice)
{
    HRESULT     hr = S_OK;
    DWORD       dwNumMixers;
    DWORD       dwID;
    MMRESULT    mmr;
    MIXERCAPS   mc;
    LPCDMIXER   pMixer;
    LPCDMIXER   pLastMixer = NULL;

    if (pDevice)
    {
        dwNumMixers = mixerGetNumDevs(); 

        for (dwID = 0; dwID < dwNumMixers; dwID++)
        {
            mmr = mixerGetDevCaps(dwID, &mc, sizeof(mc));   

            if (mmr == MMSYSERR_NOERROR && mc.cDestinations)
            {   
                pMixer = new (CDMIXER);

                if (pMixer == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
                else
                {
                    memset(pMixer, 0, sizeof(CDMIXER));

                    if (pDevice->pMixerList == NULL)
                    {
                        pDevice->pMixerList = pMixer;
                    }

                    if (pLastMixer)
                    {
                        pLastMixer->pNext = pMixer;
                    }

                    lstrcpy(pMixer->szPname, mc.szPname);
                    pMixer->dwMixID = dwID;

                    hr = AddControls(pMixer);
                
                    if (FAILED(hr))
                    {
                        break;
                    }

                    pLastMixer = pMixer;
                }
            }
        }
    }

    return(hr);  
}

//////////////
// Takes the UI tree and updates it's current and default setting links based on data
// from the CDINFO tree which was created from the registry
//

STDMETHODIMP_(void) CCDOpt::SetUIDefaults(LPCDDRIVE pCDTree, LPCDUNIT pCDList)
{
    LPCDDRIVE pDriveList;
    LPCDUNIT pCDUnit = pCDList;

    pDriveList = pCDTree;

    while(pDriveList && pCDUnit)
    {
        LPCDMIXER pMixer;

        pMixer = pDriveList->pMixerList;

        while (pMixer)
        {
            LPCDCONTROL pControl;
            DWORD dwVolID = DWORD(-1);
            DWORD dwMuteID = DWORD(-1);

            if (pMixer->dwMixID == pCDUnit->dwMixID)
            {
                pDriveList->pCurrentMixer = pMixer;
                pDriveList->pOriginalMixer = pMixer;
            }

            pControl = pMixer->pControlList;

            SearchDevice(pMixer->dwMixID, NULL, &dwVolID, &dwMuteID, NULL, FALSE);

            while (pControl)
            {
                if (pControl->dwVolID == dwVolID && pControl->dwMuteID == dwMuteID)
                {
                    pMixer->pDefaultControl = pControl;
                }

                if (pMixer->dwMixID == pCDUnit->dwMixID && pControl->dwVolID == pCDUnit->dwVolID)
                {
                    pMixer->pCurrentControl = pControl;
                    pMixer->pOriginalControl = pControl;
                }

                pControl = pControl->pNext;    
            }

            pMixer = pMixer->pNext;
        }

        pDriveList = pDriveList->pNext;
        pCDUnit = pCDUnit->pNext;
    }

}

//////////////
// Takes the UI tree and updates it's current and default setting links based on data
// from the CDINFO tree which was created from the registry
//

STDMETHODIMP_(void) CCDOpt::RestoreOriginals(void)
{
    LPCDDRIVE pDriveList;

    pDriveList = m_pCDTree;

    while(pDriveList)
    {
        LPCDMIXER pMixer;

        pMixer = pDriveList->pMixerList;

        while (pMixer)
        {
            LPCDCONTROL pControl;
            
            pDriveList->pCurrentMixer = pDriveList->pOriginalMixer;
            
            pControl = pMixer->pControlList;

            while (pControl)
            {
                pMixer->pCurrentControl = pMixer->pOriginalControl;
                pControl = pControl->pNext;    
            }

            pMixer = pMixer->pNext;
        }

        pDriveList = pDriveList->pNext;
    }
}

//////////////
// Updates the CD Tree from the UI Tree after the dialog closes (on OK), if there
// are any changes it returns true.  The caller is expected to write these changes out to reg
//

STDMETHODIMP_(BOOL) CCDOpt::UpdateCDList(LPCDDRIVE pCDTree, LPCDUNIT pCDList)
{
    BOOL        fChanged = FALSE;
    LPCDDRIVE   pDriveList;
    LPCDUNIT    pCDUnit = pCDList;

    pDriveList = pCDTree;

    while(pDriveList && pCDUnit)
    {
        if (pCDUnit->fSelected != pDriveList->fSelected)                // Selected drive has changed
        {
            pCDUnit->fSelected = pDriveList->fSelected;
            fChanged = TRUE;
        }
        
        if (pDriveList->pCurrentMixer && pDriveList->pCurrentMixer->pCurrentControl)
        {
            LPCDMIXER pMixer = pDriveList->pCurrentMixer;

            if (pMixer->dwMixID != pCDUnit->dwMixID)     // Mixer has changed
            {
                pCDUnit->dwMixID = pMixer->dwMixID;
                lstrcpy(pCDUnit->szMixerName, pMixer->szPname);

                fChanged = TRUE;
            }
            
            LPCDCONTROL pControl = pDriveList->pCurrentMixer->pCurrentControl;

            if (pControl->dwVolID != pCDUnit->dwVolID)    // Control has changed
            {
                pCDUnit->dwVolID = pControl->dwVolID;
                pCDUnit->dwMuteID = pControl->dwMuteID;
                lstrcpy(pCDUnit->szVolName, pControl->szName);

                fChanged = TRUE;
            }
        }

        pDriveList = pDriveList->pNext;
        pCDUnit = pCDUnit->pNext;
    }

    return(fChanged);
}



////////////
// Contructs UI tree for all devices/mixers/controls
//

STDMETHODIMP CCDOpt::BuildUITree(LPCDDRIVE *ppCDRoot, LPCDUNIT pCDList)
{
    LPCDUNIT    pCDUnit = pCDList;
    LPCDDRIVE   pDevice;
    LPCDDRIVE   pLastDevice;
    HRESULT     hr = S_OK;

    m_pCDSelected = NULL;

    if (ppCDRoot)
    {
        *ppCDRoot = NULL;
        pLastDevice = NULL;
        
        while (pCDUnit)
        {
            pDevice = new (CDDRIVE);
            
            if (pDevice == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }  
            else
            {
                memset(pDevice, 0, sizeof(CDDRIVE));

                if (*ppCDRoot == NULL)
                {
                    *ppCDRoot = pDevice;
                }

                if (pLastDevice)
                {
                    pLastDevice->pNext = pDevice;
                }
                
                lstrcpy(pDevice->szDriveName, pCDUnit->szDriveName);
                lstrcpy(pDevice->szDeviceDesc, pCDUnit->szDeviceDesc);
                pDevice->fSelected = pCDUnit->fSelected;

                hr = AddMixers(pDevice);

                if (FAILED(hr))
                {
                    break;
                }

                pCDUnit = pCDUnit->pNext;
                pLastDevice = pDevice;
            }
        }

        if (FAILED(hr))
        {
            if (*ppCDRoot)
            {
                DestroyUITree(ppCDRoot);
            }
        }
        else
        {
            SetUIDefaults(*ppCDRoot, pCDList);
        }
    }
    
    return(hr);
}



/////////////////
// Updates the control combo box using the mixer node of the UI tree
//

STDMETHODIMP_(void) CCDOpt::InitControlUI(HWND hDlg, LPCDMIXER pMixer)
{
    LPCDCONTROL pControl;
    LRESULT dwIndex;
    
    SendDlgItemMessage(hDlg, IDC_AUDIOCONTROL, CB_RESETCONTENT,0,0);

    pControl = pMixer->pControlList;

    if (pMixer->pCurrentControl == NULL)
    {
        pMixer->pCurrentControl = pMixer->pDefaultControl;
    }

    while(pControl)
    {
        dwIndex = SendDlgItemMessage(hDlg, IDC_AUDIOCONTROL, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) pControl->szName);

        if (dwIndex != CB_ERR && dwIndex != CB_ERRSPACE)
        {
            SendDlgItemMessage(hDlg, IDC_AUDIOCONTROL, CB_SETITEMDATA,  (WPARAM) dwIndex, (LPARAM) pControl);

            if (pMixer->pCurrentControl == pControl)
            {
                SendDlgItemMessage(hDlg, IDC_AUDIOCONTROL, CB_SETCURSEL,  (WPARAM) dwIndex, 0);                
            }
        }

        pControl = pControl->pNext;
    }
}


////////////////
// Sets up the mixer combobox using the specified device
//

STDMETHODIMP_(void) CCDOpt::InitMixerUI(HWND hDlg, LPCDDRIVE pDevice)
{
    LPCDMIXER   pMixer;
    LRESULT     dwIndex;

    SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_RESETCONTENT,0,0);
          
    pMixer = pDevice->pMixerList;
    
    while (pMixer)
    {    
        dwIndex = SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) pMixer->szPname);

        if (dwIndex != CB_ERR && dwIndex != CB_ERRSPACE)
        {
            SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_SETITEMDATA,  (WPARAM) dwIndex, (LPARAM) pMixer);  
          
            if (pDevice->pCurrentMixer == pMixer)
            {
                SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_SETCURSEL,  (WPARAM) dwIndex, 0);

                InitControlUI(hDlg, pMixer);
            }
        }

        pMixer = pMixer->pNext;                
    }
}


////////////////
// Sets up the cd device combo box
//

STDMETHODIMP_(void) CCDOpt::InitDeviceUI(HWND hDlg, LPCDDRIVE pCDTree, LPCDDRIVE pCurrentDevice)
{
    LPCDDRIVE   pDevice;
    LRESULT     dwIndex;

    SendDlgItemMessage(hDlg, IDC_CDDRIVE, CB_RESETCONTENT,0,0);

    pDevice = pCDTree;

    while (pDevice)
    {
        TCHAR str[MAX_PATH];

        wsprintf(str, TEXT("( %s ) %s"), pDevice->szDriveName, pDevice->szDeviceDesc);

        dwIndex = SendDlgItemMessage(hDlg, IDC_CDDRIVE, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) str);

        if (dwIndex != CB_ERR && dwIndex != CB_ERRSPACE)
        {
            SendDlgItemMessage(hDlg, IDC_CDDRIVE, CB_SETITEMDATA,  (WPARAM) dwIndex, (LPARAM) pDevice);
            
            if (pDevice == pCurrentDevice)
            {
                SendDlgItemMessage(hDlg, IDC_CDDRIVE, CB_SETCURSEL,  (WPARAM) dwIndex, 0);   

                InitMixerUI(hDlg, pDevice);
           }
        } 

        pDevice = pDevice->pNext; 
    }
}

///////////////////
// Called to init the dialog when it first appears.  Given a list of CD devices, this
// function fills out the dialog using the first device in the list.
//
STDMETHODIMP_(BOOL) CCDOpt::InitMixerConfig(HWND hDlg)
{
    LPCDDRIVE pDevice = m_pCDTree;

    while (pDevice)
    {
        if (pDevice->fSelected)
        {
            break;
        }

        pDevice = pDevice->pNext;
    }

    if (pDevice == NULL)
    {
        pDevice = m_pCDTree;
    }

    InitDeviceUI(hDlg, m_pCDTree, pDevice); // Init to the selected device

    return(TRUE);
}

//////////////
// This function pulls the CD Drive node out of the combo box and returns it. It returns a 
// reference into the main Drive tree.
//

STDMETHODIMP_(LPCDDRIVE) CCDOpt::GetCurrentDevice(HWND hDlg)
{
    LRESULT   dwResult;
    LPCDDRIVE pDevice = NULL;

    dwResult = SendDlgItemMessage(hDlg, IDC_CDDRIVE, CB_GETCURSEL, 0, 0);
    
    if (dwResult != CB_ERR)
    {  
        dwResult = SendDlgItemMessage(hDlg, IDC_CDDRIVE, CB_GETITEMDATA,  (WPARAM) dwResult, 0);

        if (dwResult != CB_ERR)
        {
            pDevice = (LPCDDRIVE) dwResult;    
        }
    }

    return(pDevice);
}

//////////////
// This function pulls the CD Drive mixer out of the combo box and returns it. It returns a 
// reference into the main Drive tree.
//

STDMETHODIMP_(LPCDMIXER) CCDOpt::GetCurrentMixer(HWND hDlg)
{
    LRESULT     dwResult;
    LPCDMIXER   pMixer = NULL;

    dwResult = SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_GETCURSEL, 0, 0);
    
    if (dwResult != CB_ERR)
    {  
        dwResult = SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_GETITEMDATA,  (WPARAM) dwResult, 0);

        if (dwResult != CB_ERR)
        {
            pMixer = (LPCDMIXER) dwResult;    
        }
    }

    return(pMixer);
}


//////////////
// Called when the user changes the CD Device. it pulls the CD Drive node out of the combo box and
// then resets the UI to reflect that drives current settings.
//
STDMETHODIMP_(void) CCDOpt::ChangeCDDrives(HWND hDlg)
{
    LPCDDRIVE pDevice = GetCurrentDevice(hDlg);

    if (pDevice)
    {
        LPCDDRIVE pDev = m_pCDTree;
        
        InitDeviceUI(hDlg, m_pCDTree, pDevice);   
         
        while (pDev)
        {
            pDev->fSelected = (BOOL) (pDev == pDevice);
            pDev = pDev->pNext;
        }
    }
}


//////////
// Called when the user changes the current mixer for the drive, it updates the
// display and the info for the drive.
//
STDMETHODIMP_(void) CCDOpt::ChangeCDMixer(HWND hDlg)
{
    LRESULT     dwResult;
    LPCDDRIVE   pDevice = GetCurrentDevice(hDlg);
     
    dwResult = SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_GETCURSEL, 0, 0);
    
    if (dwResult != CB_ERR)
    {  
        dwResult = SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_GETITEMDATA,  (WPARAM) dwResult, 0);

        if (dwResult != CB_ERR)
        {
            pDevice->pCurrentMixer = (LPCDMIXER) dwResult;
            
            InitMixerUI(hDlg, pDevice);
        }
    }
}

/////////////////
// Called when the user changes the current control for the mixer on the current device.
// It updates the internal data structure for that drive.
//
STDMETHODIMP_(void) CCDOpt::ChangeCDControl(HWND hDlg)
{
    LPCDMIXER   pMixer = GetCurrentMixer(hDlg);
    LRESULT     dwResult;

    dwResult = SendDlgItemMessage(hDlg, IDC_AUDIOCONTROL, CB_GETCURSEL, 0, 0);
    
    if (dwResult != CB_ERR)
    {  
        dwResult = SendDlgItemMessage(hDlg, IDC_AUDIOCONTROL, CB_GETITEMDATA,  (WPARAM) dwResult, 0);

        if (dwResult != CB_ERR)
        {
            pMixer->pCurrentControl = (LPCDCONTROL) dwResult;

            InitControlUI(hDlg, pMixer);
        }
    }
}


//////////////////
// Called to set the default control for the current mixer (lets the system pick)
//
STDMETHODIMP_(void) CCDOpt::SetMixerDefaults(HWND hDlg)
{
    LPCDMIXER   pMixer = GetCurrentMixer(hDlg);

    if (pMixer)
    {
        pMixer->pCurrentControl = NULL;

        InitControlUI(hDlg, pMixer);
    }
}


///////////////////
// Dialog handler for the mixer configuration dialog
//

STDMETHODIMP_(BOOL) CCDOpt::MixerConfig(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
     
    switch (msg) 
    { 
        default:
            fResult = FALSE;
        break;
 
        
        case WM_CONTEXTMENU:
        {      
            WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)aVolOptsHelp);
        }
        break;
           
        case WM_HELP:
        {        
            WinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPSTR)aVolOptsHelp);
        }
        break;

        case WM_INITDIALOG:
        {
            fResult = InitMixerConfig(hDlg);
        }        
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case IDOK:
	            	EndDialog(hDlg, TRUE);
				break;

				case IDCANCEL:
                    RestoreOriginals();
					EndDialog(hDlg,FALSE);
				break;

                case IDC_DEFAULTMIXER:
                    SetMixerDefaults(hDlg);
                break;

                case IDC_CDDRIVE:
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        ChangeCDDrives(hDlg);
                    }
                break;

                case IDC_AUDIOMIXER:
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        ChangeCDMixer(hDlg);
                    }
                break;
                
                case IDC_AUDIOCONTROL:
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        ChangeCDControl(hDlg);
                    }
                break;

                default:
                    fResult = FALSE;
                break;
            }
        }
        break;
    }

    return fResult;
}

///////////////////
// Dialog handler 
//
BOOL CALLBACK CCDOpt::MixerConfigProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);
    
    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);
    }
    
    if (pCDOpt)
    {
        fResult = pCDOpt->MixerConfig(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}

////////////
// Called to put up the UI to allow the user to change the CD Volume Configuration
//
STDMETHODIMP_(BOOL) CCDOpt::VolumeDialog(HWND hDlg)
{
    BOOL fChanged = FALSE;

    if (m_pCDOpts && m_pCDOpts->pCDUnitList)
    {
        if (SUCCEEDED(BuildUITree(&m_pCDTree, m_pCDOpts->pCDUnitList)))
        {
	        if(DialogBoxParam( m_hInst, MAKEINTRESOURCE(IDD_MIXERPICKER), hDlg, (DLGPROC) CCDOpt::MixerConfigProc, (LPARAM) this) == TRUE)
            {
                fChanged = UpdateCDList(m_pCDTree, m_pCDOpts->pCDUnitList);

                if (fChanged)
                {
                    WriteCDList(m_pCDOpts->pCDUnitList);
                }
            }

            DestroyUITree(&m_pCDTree);
        }
    }

    return(fChanged);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\cdplay.h ===
// cdplay.h.h : Declaration of the CCDPlay

#ifndef __CDPLAY_H_
#define __CDPLAY_H_

#include "playres.h"
#include "..\main\mmfw.h"

/////////////////////////////////////////////////////////////////////////////
// CCDPlay
class CCDPlay :	public IMMComponent, IMMComponentAutomation
{
public:
	CCDPlay();
    ~CCDPlay();

// ICDPlay
public:
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();
    STDMETHOD(GetInfo)(MMCOMPDATA* mmCompData);
    STDMETHOD(Init)(IMMFWNotifySink* pSink, HWND hwndMain, RECT* pRect, HWND* phwndComp, HMENU* phMenu);
	STDMETHOD(OnAction)(MMACTIONS mmActionID, LPVOID pAction);

private:
    STDMETHOD(QueryVolumeSupport)(BOOL* pVolume, BOOL* pPan);
	void InitIcons();
    HRESULT GetTrackInfo(LPMMTRACKORDISC pInfo);
    HRESULT GetDiscInfo(LPMMTRACKORDISC pInfo);
    void NormalizeNameForMenuDisplay(TCHAR* szInput, TCHAR* szOutput, DWORD cbLen);
    void SetTrack(int nTrack);
    void SetDisc(int nDisc);

	IMMFWNotifySink* m_pSink;
	HICON m_hIcon16;
	HICON m_hIcon32;
    HMENU m_hMenu;
    HWND  m_hwndMain;

    DWORD m_dwRef;
};

class CCDPlayClassFactory : public IClassFactory
{
public:
    CCDPlayClassFactory();

    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    STDMETHOD(CreateInstance)(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
    STDMETHOD(LockServer)(BOOL fLock);

private:
    DWORD m_dwRef;
};

#endif //__CDPLAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\cdplay.cpp ===
// CDPlay.cpp : Implementation of CCDPlay
#include "windows.h"
#include "CDPlay.h"
#include "cdapi.h"
#include "cdplayer.h"
#include "literals.h"

#include "playres.h"
#include "tchar.h"

#include "trklst.h"

extern HINSTANCE g_dllInst;
extern BOOL g_fOleInitialized;
extern TCHAR g_szTimeSep[10];

/////////////////////////////////////////////////////////////////////////////
// CCDPlay

CCDPlay::CCDPlay()
{
    m_hMenu = NULL;
    m_hwndMain = NULL;
    m_pSink = NULL;
    m_dwRef = 0;

    InitIcons();
}

CCDPlay::~CCDPlay()
{
    //close device ...

    //destroy objects
    if (m_hIcon16)
    {
        DestroyIcon(m_hIcon16);
        m_hIcon16 = NULL;
    }

    if (m_hIcon32)
    {
        DestroyIcon(m_hIcon32);
        m_hIcon32 = NULL;
    }

    if (m_hMenu)
    {
        DestroyMenu(m_hMenu);
        m_hMenu = NULL;
    }

    // Cleanup from cd player stuff
    DeleteCriticalSection (&g_csTOCSerialize);

    if (g_fOleInitialized)
    {
	    OleUninitialize();
    }
}

STDMETHODIMP CCDPlay::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (IID_IUnknown == riid || IID_IMMComponent == riid)
    {  
        *ppv = this;
    }

    if (IID_IMMComponentAutomation == riid)
    {
        *ppv = (IMMComponentAutomation*)this;
    }

    if (NULL==*ppv)
    {
        return E_NOINTERFACE;
    }

    AddRef();

    return S_OK;
}

STDMETHODIMP_(ULONG) CCDPlay::AddRef(void)
{
    return ++m_dwRef;
}

STDMETHODIMP_(ULONG) CCDPlay::Release(void)
{
    if (0!=--m_dwRef)
        return m_dwRef;

    delete this;
    return 0;
}

STDMETHODIMP CCDPlay::GetInfo(MMCOMPDATA* mmCompData)
{
    mmCompData->hiconSmall = m_hIcon16;
    mmCompData->hiconLarge = m_hIcon32;
    mmCompData->nAniResID = -1;
    mmCompData->hInst = g_dllInst;
    _tcscpy(mmCompData->szName,TEXT("CD"));
    QueryVolumeSupport(&mmCompData->fVolume, &mmCompData->fPan);

    //try to get the rect required by the ledwnd,
    //this could change if there are large fonts involved
    TCHAR szDisp[MAX_PATH];
    LoadString(g_dllInst, STR_DISPLAY_LABELS, szDisp, sizeof(szDisp)/sizeof(TCHAR));

    HWND hwndDisp = GetDlgItem(m_hwndMain,IDC_LED);
    HDC hdc = GetDC(hwndDisp);

    LOGFONT     lf;
    int         iLogPelsY;
    iLogPelsY = GetDeviceCaps( hdc, LOGPIXELSY );
    ZeroMemory( &lf, sizeof(lf) );

    HFONT hTempFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    GetObject(hTempFont,sizeof(lf),&lf);

    lf.lfHeight = (-10 * iLogPelsY) / 72;
    if (lf.lfCharSet == ANSI_CHARSET)
    {
        lf.lfWeight = FW_BOLD;
    }
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;

    HFONT hDispFont = CreateFontIndirect(&lf);

    HFONT hOrgFont = (HFONT)SelectObject(hdc,hDispFont);

    GetClientRect(hwndDisp,&(mmCompData->rect));

    DrawText( hdc,          // handle to device context
              szDisp, // pointer to string to draw
              -1,       // string length, in characters
              &(mmCompData->rect),    // pointer to struct with formatting dimensions
              DT_CALCRECT|DT_EXPANDTABS|DT_NOPREFIX);

    SelectObject(hdc,hOrgFont);
    DeleteObject(hDispFont);
    ReleaseDC(hwndDisp,hdc);

    return S_OK;
}

BOOL CALLBACK
TransDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return FALSE;
}

extern HWND PASCAL WinFake(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow, HWND hwndMain, IMMFWNotifySink* pSink);

STDMETHODIMP CCDPlay::Init(IMMFWNotifySink* pSink, HWND hwndMain, RECT* pRect, HWND* phwndComp, HMENU* phMenu)
{
    HRESULT hr = S_OK;

    //save sink pointer
    m_pSink = pSink;

    //load custom menu
    m_hMenu = LoadMenu(g_dllInst,
                       MAKEINTRESOURCE(IDR_MAINMENU));

    *phMenu = m_hMenu;

    //create the main window here
    
    //fake cd player into thinking it can go)
    m_hwndMain = WinFake(g_dllInst,NULL,"",SW_NORMAL,hwndMain,pSink);

    //set up pointer to main window of app
    *phwndComp = m_hwndMain;

	return hr;
}

void GetTOC(int cdrom, TCHAR* szNetQuery)
{
	DWORD dwRet;
    MCI_SET_PARMS   mciSet;
	unsigned long m_toc[101];

    ZeroMemory( &mciSet, sizeof(mciSet) );

    mciSet.dwTimeFormat = MCI_FORMAT_MSF;
    mciSendCommand( g_Devices[ cdrom ]->hCd, MCI_SET, MCI_SET_TIME_FORMAT, (DWORD_PTR)(LPVOID)&mciSet );

    MCI_STATUS_PARMS mciStatus;
    long lAddress, lStartPos, lDiskLen;
    int i;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;

    //
    // NOTE: none of the mciSendCommand calls below bother to check the
    //       return code.  This is asking for trouble... but if the
    //       commands fail we cannot do much about it.
    //
    dwRet = mciSendCommand( g_Devices[ cdrom ]->hCd, MCI_STATUS,
		    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus);

	int tracks = -1;
	tracks = (UCHAR)mciStatus.dwReturn;

    mciStatus.dwItem = MCI_STATUS_POSITION;
    for ( i = 0; i < tracks; i++ )
    {

	    mciStatus.dwTrack = i + 1;
	    dwRet = mciSendCommand( g_Devices[ cdrom ]->hCd, MCI_STATUS,
			    MCI_STATUS_ITEM | MCI_TRACK,
			    (DWORD_PTR)(LPVOID)&mciStatus);

	    lAddress = (long)mciStatus.dwReturn;

        //converts "packed" time into pure frames
        lAddress =  (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
					(MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
					(MCI_MSF_FRAME( lAddress));

		m_toc[i] = lAddress;

		if (i==0)
		{
			lStartPos = lAddress;
		}
    }

    mciStatus.dwItem = MCI_STATUS_LENGTH;
    dwRet = mciSendCommand( g_Devices[ cdrom ]->hCd, MCI_STATUS,
		    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus);

    /*
    ** Convert the total disk length into frames
    */
    lAddress  = (long)mciStatus.dwReturn;
    lDiskLen =  (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
				(MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
				(MCI_MSF_FRAME( lAddress));

    /*
    ** Now, determine the absolute start position of the sentinel
    ** track.  That is, the special track that marks the end of the
    ** disk.
    */
    lAddress = lStartPos + lDiskLen + 1; //dstewart: add one for true time

	m_toc[i] = lAddress;

    wsprintf(szNetQuery,TEXT("cd=%X"),tracks);
	
	//add each frame stattime to query, include end time of disc
	TCHAR tempstr[MAX_PATH];
	for (i = 0; i < tracks+1; i++)
	{
		wsprintf(tempstr,TEXT("+%X"),m_toc[i]);
		_tcscat(szNetQuery,tempstr);
	}
}

STDMETHODIMP CCDPlay::OnAction(MMACTIONS mmActionID, LPVOID pAction)
{
    HRESULT hr = S_OK;

    switch (mmActionID)
    {
        case MMACTION_PLAY:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_PLAY,0),0);
        }
        break;

        case MMACTION_STOP:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_STOP,0),0);
        }
        break;

        case MMACTION_UNLOADMEDIA: //"eject"
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_EJECT,0),0);
        }
        break;

        case MMACTION_NEXTTRACK:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_NEXTTRACK,0),0);
        }
        break;

        case MMACTION_PREVTRACK:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_PREVTRACK,0),0);
        }
        break;

        case MMACTION_PAUSE:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_PAUSE,0),0);
        }
        break;

        case MMACTION_REWIND:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_SKIPBACK,0),0);
        }
        break;

        case MMACTION_FFWD:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_SKIPFORE,0),0);
        }
        break;

        case MMACTION_NEXTMEDIA:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_EJECT,0),0);
        }
        break;

        case MMACTION_GETMEDIAID:
        {
            MMMEDIAID* pID = (MMMEDIAID*)pAction;
            if (pID->nDrive == -1)
            {
                pID->nDrive = g_CurrCdrom;
            }
            wsprintf( pID->szMediaID, g_szSectionF, g_Devices[pID->nDrive]->CdInfo.Id );
            pID->dwMediaID = g_Devices[pID->nDrive]->CdInfo.Id;
            pID->dwNumTracks = NUMTRACKS(pID->nDrive);
            _tcscpy(pID->szArtist,ARTIST(pID->nDrive));
            _tcscpy(pID->szTitle,TITLE(pID->nDrive));

            PTRACK_INF t;
            if (CURRTRACK(pID->nDrive)!=NULL)
            {
                t = FindTrackNodeFromTocIndex( CURRTRACK(pID->nDrive)->TocIndex, ALLTRACKS( pID->nDrive ) );
                if (t)
                {
                    _tcscpy(pID->szTrack,t->name);
                }
            }
        }
        break;

        case MMACTION_GETNETQUERY:
        {
            MMNETQUERY* pQuery = (MMNETQUERY*)pAction;
            if (pQuery->nDrive == -1)
            {
                pQuery->nDrive = g_CurrCdrom;
            }

            GetTOC(pQuery->nDrive,pQuery->szNetQuery);
        }
        break;

        case MMACTION_READSETTINGS :
        {
            ReadSettings((void*)pAction);
			UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME |
				       DISPLAY_UPD_TRACK_NAME );
        }
        break;

        case MMACTION_GETTRACKINFO :
        {
            LPMMTRACKORDISC pInfo = (LPMMTRACKORDISC)pAction;
            return (GetTrackInfo(pInfo));
        }
        break;

        case MMACTION_GETDISCINFO :
        {
            LPMMTRACKORDISC pInfo = (LPMMTRACKORDISC)pAction;
            return (GetDiscInfo(pInfo));
        }
        break;

        case MMACTION_SETTRACK :
        {
            LPMMCHANGETRACK pTrack = (LPMMCHANGETRACK)pAction;
            SetTrack(pTrack->nNewTrack);
        }
        break;

        case MMACTION_SETDISC :
        {
            LPMMCHANGEDISC pDisc = (LPMMCHANGEDISC)pAction;
            SetDisc(pDisc->nNewDisc);
        }
        break;

        default:
        {
            hr = E_NOTIMPL;
        }   
        break;
    }

    return hr;
}

//QueryVolumeSupport is just a helper function ... you don't have to do it this way
STDMETHODIMP CCDPlay::QueryVolumeSupport(BOOL* pVolume, BOOL* pPan)
{
    *pVolume = FALSE;
    *pPan = FALSE;

	return S_OK;
}

//InitIcons is just a helper function ... you don't have to do it this way
void CCDPlay::InitIcons()
{
    m_hIcon16 = NULL;
    m_hIcon32 = NULL;

    m_hIcon16 = (HICON)LoadImage(g_dllInst, MAKEINTRESOURCE(IDI_ICON_CDPLAY), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
    m_hIcon32 = LoadIcon(g_dllInst, MAKEINTRESOURCE(IDI_ICON_CDPLAY));
}

/*
* NormalizeNameForMenuDisplay
    This function turns a string like "Twist & Shout" into
    "Twist && Shout" because otherwise it will look like
    "Twist _Shout" in the menu due to the accelerator char
*/
void CCDPlay::NormalizeNameForMenuDisplay(TCHAR* szInput, TCHAR* szOutput, DWORD cbLen)
{
    ZeroMemory(szOutput,cbLen);
    WORD index1 = 0;
    WORD index2 = 0;
    for (; index1 < _tcslen(szInput); index1++)
    {
        szOutput[index2] = szInput[index1];
        if (szOutput[index2] == TEXT('&'))
        {
            szOutput[++index2] = TEXT('&');
        }
        index2++;
    }
}

//try to find and return the track info referenced by pInfo->nNumber
HRESULT CCDPlay::GetTrackInfo(LPMMTRACKORDISC pInfo)
{
    HRESULT hr = E_FAIL;

    if (pInfo)
    {
        int index = -1;

	    PTRACK_PLAY  playlist;
	    for( playlist = SAVELIST(g_CurrCdrom);
             playlist != NULL;
             playlist = playlist->nextplay )
	    {
            index++;
            PTRACK_INF t = NULL;
            t = FindTrackNodeFromTocIndex( playlist->TocIndex, ALLTRACKS( g_CurrCdrom ) );

            if ((t) && (index == pInfo->nNumber))
            {
    	        int mtemp, stemp;
                FigureTrackTime(g_CurrCdrom, t->TocIndex, &mtemp, &stemp );

                TCHAR szDisplayTrack[TRACK_TITLE_LENGTH*2];
                NormalizeNameForMenuDisplay(t->name,szDisplayTrack,sizeof(szDisplayTrack));
            
                wsprintf(pInfo->szName,TEXT("%i. %s (%i%s%02i)"),t->TocIndex + 1,szDisplayTrack,mtemp,g_szTimeSep,stemp);
                pInfo->nID = t->TocIndex;

                if (playlist->TocIndex == CURRTRACK(g_CurrCdrom)->TocIndex)
                {
                    pInfo->fCurrent = TRUE;
                }
                else
                {
                    pInfo->fCurrent = FALSE;
                }

                hr = S_OK; //indicate that indexed track was found
            } //end if track ok
	    } //end stepping
    } //end if pinfo valid
    return (hr);
}

HRESULT CCDPlay::GetDiscInfo(LPMMTRACKORDISC pInfo)
{
    HRESULT hr = E_FAIL;

    if (pInfo)
    {
	    for(int i = 0; i < g_NumCdDevices; i++)
	    {
            if (i == pInfo->nNumber)
            {
                TCHAR szDisplayTitle[TITLE_LENGTH*2];
                NormalizeNameForMenuDisplay(TITLE(i),szDisplayTitle,sizeof(szDisplayTitle));

                TCHAR szDisplayArtist[ARTIST_LENGTH*2];
                NormalizeNameForMenuDisplay(ARTIST(i),szDisplayArtist,sizeof(szDisplayArtist));

                if (g_Devices[i]->State & (CD_BEING_SCANNED | CD_NO_CD | CD_DATA_CD_LOADED | CD_IN_USE))
                {
	                wsprintf(pInfo->szName,TEXT("<%c:> %s"),g_Devices[i]->drive,szDisplayTitle);
                }
                else
                {
	                wsprintf(pInfo->szName,TEXT("<%c:> %s (%s)"),
                                g_Devices[i]->drive,szDisplayTitle,szDisplayArtist);
                }

                pInfo->nID = i;

                if (i == g_CurrCdrom)
                {
                    pInfo->fCurrent = TRUE;
                }
                else
                {
                    pInfo->fCurrent = FALSE;
                }
                
                hr = S_OK;
            } //end if match
	    } //end for
    } //end if pinfo valid

    return (hr);
}

void CCDPlay::SetTrack(int nTrack)
{
    PTRACK_INF tr;

    tr = ALLTRACKS( g_CurrCdrom );
    if ( tr != NULL )
    {
        PTRACK_PLAY trCurrent = CURRTRACK(g_CurrCdrom);
        tr = FindTrackNodeFromTocIndex(nTrack,ALLTRACKS(g_CurrCdrom));

        if (tr->TocIndex != trCurrent->TocIndex)
        {
            PTRACK_PLAY p = NULL;
            for (p = PLAYLIST(g_CurrCdrom); (p!=NULL) && (p->TocIndex != tr->TocIndex); p = p->nextplay);
            if (p)
            {
                TimeAdjustSkipToTrack( g_CurrCdrom, p );
            } //if not null
        } //if not equal to current
	} //if tr not null
}

void CCDPlay::SetDisc(int nDisc)
{
	SwitchToCdrom(nDisc, FALSE);
    MMONDISCCHANGED mmOnDisc;
    mmOnDisc.nNewDisc = g_CurrCdrom;
    mmOnDisc.fDisplayVolChange = TRUE;
    g_pSink->OnEvent(MMEVENT_ONDISCCHANGED,&mmOnDisc);
}

extern "C"
HRESULT WINAPI CDPLAY_CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj)
{
    CCDPlay* pObj;
    HRESULT hr = E_OUTOFMEMORY;

    *ppvObj = NULL;

    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
    {
        return CLASS_E_NOAGGREGATION;
    }

    pObj = new CCDPlay();

    if (NULL==pObj)
    {
        return hr;
    }

    hr = pObj->QueryInterface(riid, ppvObj);

    if (FAILED(hr))
    {
        delete pObj;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\commands.h ===
/******************************Module*Header*******************************\
* Module Name: commands.h
*
* Functions that execue the users commands.
*
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

void
CdPlayerEjectCmd(
    void
    );

void
CdPlayerPlayCmd(
    void
    );

void
CdPlayerPauseCmd(
    void
    );


void
CdPlayerStopCmd(
    void
    );

void
CdPlayerPrevTrackCmd(
    void
    );

void
CdPlayerNextTrackCmd(
    void
    );

void
CdPlayerSeekCmd(
    HWND    hwnd,
    BOOL    fStart,
    UINT    uDirection
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\database.h ===
/******************************Module*Header*******************************\
* Module Name: databas.h
*
* This module implements the database routines for the CD Audio app.
* The information is stored in the ini file "cdaudio.ini" which should
* be located in the nt\windows directory.
*
*
* Author:
*   Rick Turner (ricktu) 31-Jan-1992
*
*
* Revision History:
*
*   04-Aug-1992 (ricktu)    Incorperated routines from old cdaudio.c,
*                           and made work w/new child window framework.
*
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

BOOL GetInternetDatabase(
    int cdrom,
    DWORD key,
    BOOL fHitNet,
    BOOL fManual,
    HWND hwndCallback,
    void* pData
);

VOID
ErasePlayList(
    int cdrom
    );

VOID
EraseSaveList(
    int cdrom
    );

VOID
EraseTrackList(
    int cdrom
    );

PTRACK_PLAY
CopyPlayList(
    PTRACK_PLAY p
    );

VOID
ResetPlayList(
    int cdrom
    );

DWORD
ComputeNewDiscId(
    int cdrom
    );

DWORD
ComputeOrgDiscId(
    int cdrom
    );

VOID
AddFindEntry(
    int cdrom,
    DWORD key,
    PCDROM_TOC lpTOC
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\database.cpp ===
/******************************Module*Header*******************************\
* Module Name: database.c
*
* This module implements the database routines for the CD Audio app.
* The information is stored in the ini file "cdaudio.ini" which should
* be located in the nt\windows directory.
*
* Warning:
*   These functions ARE NOT THREAD safe.
*   The functions in this file MUST only be called on the UI thread.  Before
*   calling any of the functions the CALLER MUST call LockTableOfContents
*   for the specified cdrom device.
*
* Author:
*   Rick Turner (ricktu) 31-Jan-1992
*
*
* Revision History:
*
*   04-Aug-1992 (ricktu)    Incorperated routines from old cdaudio.c,
*                           and made work w/new child window framework.
*
*
* Copyright (c) 1993 - 1995 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE
#include <windows.h>
#include "playres.h"
#include "cdapi.h"
#include "cdplayer.h"
#include "database.h"
#include "literals.h"


#include <string.h>
#include <stdio.h>
#include <tchar.h>

#include "trklst.h"

#include "..\cdnet\cdnet.h"
#include "..\cdopt\cdopt.h"

/* -------------------------------------------------------------------------
** Private entry points
** -------------------------------------------------------------------------
*/
DWORD
ComputeOldDiscId(
    int cdrom
    );


BOOL
ReadEntry(
    int cdrom,
    DWORD dwId);


/*****************************Private*Routine******************************\
* ComputeOldDiscId
*
* This routine computes a unique ID based on the information
* in the table of contexts a given disc.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
DWORD
ComputeOldDiscId(
    int cdrom
    )
{
    int NumTracks,i;
    DWORD DiscId = 0;


    NumTracks = g_Devices[ cdrom ]->toc.LastTrack -
		g_Devices[ cdrom ]->toc.FirstTrack;

    for ( i = 0; i < NumTracks; i++ )  {
	DiscId += ( (TRACK_M(cdrom,i) << 16) +
		    (TRACK_S(cdrom,i) <<  8) +
		     TRACK_F(cdrom,i) );
    }

    return DiscId;

}


/******************************Public*Routine******************************\
* ComputeNewDiscId
*
* Just call mci to get the product ID.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
ComputeNewDiscId(
    int cdrom
    )
{
#ifdef USE_IOCTLS
    return ComputeOrgDiscId( cdrom );
#else

    MCI_INFO_PARMS  mciInfo;
    TCHAR           szBuffer[32];
    DWORD           dwRet;

    mciInfo.lpstrReturn = szBuffer;
    mciInfo.dwRetSize   = sizeof(szBuffer)/sizeof(TCHAR);

    dwRet = mciSendCommand( g_Devices[cdrom]->hCd, MCI_INFO,
			    MCI_INFO_MEDIA_IDENTITY,
			    (DWORD_PTR)(LPVOID)&mciInfo );

    if ( dwRet != MMSYSERR_NOERROR ) {
	return 0L;
    }

    _stscanf(szBuffer, TEXT("%ld"), &dwRet );

    return dwRet;

#endif
}



/*****************************Private*Routine******************************\
* ComputeOrgDiscId
*
* This routine computes a unique ID based on the information
* in the table of contexts a given disc. This is done by taking
* the TMSF value for each track and XOR'ing it with the previous
* quantity shifted left one bit.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
DWORD
ComputeOrgDiscId(
    int cdrom
    )
{
    int NumTracks,i;
    DWORD DiscId = 0;


    NumTracks = g_Devices[ cdrom ]->toc.LastTrack -
		g_Devices[ cdrom ]->toc.FirstTrack + 1;

    for ( i = 0; i < NumTracks; i++ ) {
	DiscId = (DiscId << 1) ^
		   ((i<<24) +
		    (TRACK_M(cdrom,i) << 16) +
		    (TRACK_S(cdrom,i) <<  8) +
		     TRACK_F(cdrom,i) );
    }

    return DiscId;

}


/*****************************Private*Routine******************************\
* ErasePlayList
*
* Erases the current play list.  This includes freeing the memory
* for the nodes in the play list, and resetting the current track
* pointer to NULL.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
ErasePlayList(
    int cdrom
    )
{

    PTRACK_PLAY temp, temp1;

    //
    // Free memory for each track in play list
    //

    temp = PLAYLIST( cdrom );
    while (temp!=NULL) {

	temp1 = temp->nextplay;
	LocalFree( (HLOCAL)temp );
	temp = temp1;

    }

    //
    // Reset pointers
    //

    PLAYLIST( cdrom ) = NULL;
    CURRTRACK( cdrom ) = NULL;
}



/******************************Public*Routine******************************\
* EraseSaveList
*
* Erases the current save list.  This includes freeing the memory
* for the nodes in the save list.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
EraseSaveList(
    int cdrom
    )
{

    PTRACK_PLAY temp, temp1;

    //
    // Free memory for each track in play list
    //


    temp = SAVELIST( cdrom );
    while ( temp != NULL ) {

	temp1 = temp->nextplay;
	LocalFree( (HLOCAL)temp );
	temp = temp1;

    }

    //
    // Reset pointers
    //

    SAVELIST( cdrom ) = NULL;

}


/*****************************Private*Routine******************************\
* EraseTrackList
*
* Erases the current track list.  This includes freeing the memory
* for the nodes in the track list, and resetting the track list
* pointer to NULL.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
EraseTrackList(
    int cdrom
    )
{

    PTRACK_INF temp, temp1;

    //
    // Free memory for each track in track list
    //

    temp = ALLTRACKS( cdrom );
    while ( temp != NULL ) {

	temp1 = temp->next;
	LocalFree( (HLOCAL)temp );
	temp = temp1;
    }

    //
    // Reset pointers
    //

    ALLTRACKS( cdrom ) = NULL;

}

/******************************Public*Routine******************************\
* CopyPlayList
*
* Returns a copy of the playlist pointed to by p.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
PTRACK_PLAY
CopyPlayList(
    PTRACK_PLAY p
    )
{

    PTRACK_PLAY t,t1,tend,tret;

    tret = tend = NULL;

    //
    // Duplicate list pointed to by p.
    //

    t = p;
    while( t!=NULL ) {

	t1 = (PTRACK_PLAY)AllocMemory( sizeof(TRACK_PLAY) );
	t1->TocIndex = t->TocIndex;
	t1->min = t->min;
	t1->sec = t->sec;
	t1->nextplay = NULL;
	t1->prevplay = tend;

	if (tret==NULL) {

	    tret = tend = t1;
	}
	else {

	    tend->nextplay = t1;
	    tend = t1;
	}

	t = t->nextplay;

    }

    return(tret);

}


/*****************************Private*Routine******************************\
* ResetPlayList
*
* Resets play order for the disc.  Used to initialize/reset
* the play list.  This is done by reseting the doubly-linked list
* of tracks in the g_Devices[...]->CdInfo.PlayList.[prevplay,nextplay]
* pointers.  All the tracks on the CD are stored in a singly linked list
* pointed to by g_Devices[...]->CdInfo.AllTracks pointer.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
ResetPlayList(
     int cdrom
    )
{
    PTRACK_INF t;
    PTRACK_PLAY temp, prev;


    //
    // Kill old play list
    //

    ErasePlayList( cdrom );
    EraseSaveList( cdrom );

    //
    // Duplicate each node in AllTracks and insert in-order
    // in SaveList list.  The SaveList is the master which is
    // used for the playlist.
    //

    t = ALLTRACKS( cdrom );
    prev = NULL;

    while (t!=NULL) {

	temp = (PTRACK_PLAY)AllocMemory( sizeof(TRACK_PLAY) );

	temp->TocIndex = t->TocIndex;
	temp->min = 0;
	temp->sec = 0;
	temp->prevplay = prev;
	temp->nextplay = NULL;

	if (prev!=NULL) {

	    prev->nextplay = temp;
	}
	else {

	    SAVELIST( cdrom ) = temp;
	}

	prev = temp;
	t=t->next;

    }

    PLAYLIST( cdrom ) = CopyPlayList( SAVELIST( cdrom) );
}

void CreateNewEntry(int cdrom, DWORD key, PCDROM_TOC lpTOC)
{
    /*
    ** This is a new entry, fill it in but don't store it in the database.
    */

    PTRACK_INF  temp, temp1;
    PTRACK_PLAY pTempCurrTrack = CURRTRACK(cdrom);
    int i, num;
    int nSaveTrack = -1;

    if (CURRTRACK(cdrom))
    {
        nSaveTrack = CURRTRACK(cdrom)->TocIndex;
    }

    ErasePlayList( cdrom );
    EraseSaveList( cdrom );
    EraseTrackList( cdrom );

    g_Devices[ cdrom ]->CdInfo.iFrameOffset = NEW_FRAMEOFFSET;
	g_Devices[ cdrom ]->CdInfo.IsVirginCd = TRUE;
    g_Devices[ cdrom ]->CdInfo.Id = key;

	wsprintf( (LPTSTR)ARTIST( cdrom ), IdStr( STR_NEW_ARTIST ) );
	wsprintf( (LPTSTR)TITLE( cdrom ), IdStr( STR_NEW_TITLE ) );

	if (lpTOC)
    {
        NUMTRACKS( cdrom ) = num = lpTOC->LastTrack - lpTOC->FirstTrack + 1;
    }
    else
    {
        num = NUMTRACKS( cdrom );
    }


	/*
	** Create generic playlist, which is all audio tracks
	** played in the order they are on the CD.  First, create
	** a singly linked list that contains all the tracks.
	** Then, create a double linked list, using the nodes of
	** from the single linked list for the play list.
	*/


	for( i = 0; i < num; i++ ) {

	    /*
	    ** Create storage for track
	    */

	    temp = (PTRACK_INF)AllocMemory( sizeof(TRACK_INF) );

	    /*
	    ** Initialize information (storage already ZERO initialized)
	    */

	    wsprintf( (LPTSTR)temp->name, IdStr( STR_INIT_TRACK ), i+1 );
	    temp->TocIndex = i;
	    temp->next = NULL;

	    /*
	    ** Add node to singly linked list of all tracks
	    */

	    if (i == 0) {

		temp1 = ALLTRACKS( cdrom ) = temp;
	    }
	    else {

		temp1->next = temp;
		temp1 = temp;
	    }
	}

	/*
	** Generate generic play list (all tracks in order)
	*/

	ResetPlayList( cdrom );

    if (nSaveTrack > -1)
    {
	    PTRACK_PLAY  playlist;
	    for( playlist = PLAYLIST(cdrom);
             playlist != NULL;
             playlist = playlist->nextplay )
	    {
            if (playlist->TocIndex == nSaveTrack)
            {
                CURRTRACK(cdrom) = playlist;
            }
        }
    }
}

void RecomputePlayTimes(int dCdrom)
{
    /*
    ** Compute PLAY length
    */
    PTRACK_PLAY pp;
    int m, s, mtemp, stemp;
    
    m = s = 0;
    for( pp = PLAYLIST(dCdrom); pp != NULL; pp = pp->nextplay )
    {

        FigureTrackTime( dCdrom, pp->TocIndex, &mtemp, &stemp );

        m+=mtemp;
        s+=stemp;

        pp->min = mtemp;
        pp->sec = stemp;
    }

    //also refresh the savelist
    for( pp = SAVELIST(dCdrom); pp != NULL; pp = pp->nextplay )
    {

        FigureTrackTime( dCdrom, pp->TocIndex, &mtemp, &stemp );

        pp->min = mtemp;
        pp->sec = stemp;
    }

    m += (s / 60);
    s =  (s % 60);

    CDTIME(dCdrom).TotalMin = m;
    CDTIME(dCdrom).TotalSec = s;

    /*
    ** Make sure that the track time displayed in the LED and the
    ** status bar is correct.  If we have a current track and the
    ** CD is playing or paused then everything is OK.  Otherwise, we
    ** have to reset the track times.
    */
    if ( CURRTRACK( dCdrom ) != NULL ) {

        if ( STATE(dCdrom) & CD_STOPPED ) {

            CDTIME(dCdrom).TrackTotalMin = CURRTRACK( dCdrom )->min;
            CDTIME(dCdrom).TrackRemMin   = CURRTRACK( dCdrom )->min;

            CDTIME(dCdrom).TrackTotalSec = CURRTRACK( dCdrom )->sec;
            CDTIME(dCdrom).TrackRemSec   = CURRTRACK( dCdrom )->sec;
        }

    }
    else {

        CDTIME(dCdrom).TrackTotalMin = 0;
        CDTIME(dCdrom).TrackRemMin   = 0;
        CDTIME(dCdrom).TrackTotalSec = 0;
        CDTIME(dCdrom).TrackRemSec   = 0;
    }

    if (dCdrom == g_CurrCdrom)
    {
        UpdateDisplay( DISPLAY_UPD_DISC_TIME );
    }
}

BOOL GetInternetDatabase(int cdrom, DWORD key, BOOL fHitNet, BOOL fManual, HWND hwndCallback, void* pData)
{
    if (!g_fBlockNetPrompt)
    {
        if (fHitNet)
        {
            ICDNet* pICDNet = NULL;
            if (SUCCEEDED(CDNET_CreateInstance(NULL, IID_ICDNet, (void**)&pICDNet)))
            {
		            pICDNet->SetOptionsAndData((void*)g_pSink->GetOptions(),(void*)g_pSink->GetData());
                    pICDNet->Download(g_Devices[ cdrom ]->hCd,g_Devices[cdrom]->drive,key,(LPCDTITLE)pData,fManual,hwndCallback);
                    pICDNet->Release();
            }
            return FALSE; //couldn't find title just now, catch it on the callback
        }
    }

    if ( ReadEntry(cdrom, key))
    {
        return TRUE;
    }

    if (!fHitNet)
    {
        CreateNewEntry(cdrom, key, NULL);
        RecomputePlayTimes(cdrom);
    }

    return FALSE;
}

/*****************************Private*Routine******************************\
* ReadEntry
*
* Try to read entry for new disc from  database ini file.
* The section name we are trying to read is a hex
* value of the disc id.  If the sections is found,
* fill in the data for the disc in the cdrom drive.
*
* This function uses over 16K of stack space !!
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
BOOL
ReadEntry(
    int cdrom,
    DWORD dwId)
{
    UINT        i;
    int         numtracks, numplay;
    PTRACK_INF  temp, curr;
    PTRACK_PLAY temp1, prev;
    BOOL        fRewriteEntry = FALSE;
    LPCDDATA    pData = NULL;

    g_Devices[ cdrom ]->CdInfo.iFrameOffset = NEW_FRAMEOFFSET;

    pData = (LPCDDATA)g_pSink->GetData();
    if( !pData )
    {
        //Can't create the options object, so fail
        return (FALSE);
    }

    pData->AddRef();
    
    //
    // Try to read in title from the options database
    //

    if (!pData->QueryTitle(dwId))
    {
        pData->Release();
        return (FALSE);
    }

    //
    // We found an entry for this disc, so copy all the information
    // from the title database

    LPCDTITLE pCDTitle = NULL;

    if (FAILED(pData->LockTitle(&pCDTitle,dwId)))
    {
        pData->Release();
        return FALSE;
    }

    _tcscpy(g_Devices[ cdrom ]->CdInfo.Title,pCDTitle->szTitle); 

    numtracks = pCDTitle->dwNumTracks;

    // Make sure there is at least one track!!!
    if (0 == numtracks)
    {
    	fRewriteEntry = TRUE;
    }

    g_Devices[ cdrom ]->CdInfo.NumTracks = numtracks;
    _tcscpy(g_Devices[ cdrom ]->CdInfo.Artist,pCDTitle->szArtist);

    //
    // Validate the stored track numbers
    //
    if (g_Devices[cdrom]->fIsTocValid)
    {
	    int    maxTracks;  // validate the high point in database

	    maxTracks = g_Devices[cdrom]->toc.LastTrack;

	    if (numtracks > maxTracks)
        {
	        // Current database contains invalid data
	        // this can result in the CD not playing at all as the end
	        // point is likely to be invalid
	        g_Devices[ cdrom ]->CdInfo.NumTracks
	          = numtracks
	          = maxTracks;
	        fRewriteEntry = TRUE;
	    }
    }

    //
    // Read the track list information
    //

    for (i=0, curr = NULL; i < (UINT)numtracks; i++)
    {
	    temp = (PTRACK_INF)AllocMemory( sizeof(TRACK_INF) );
	    temp->TocIndex = i;
	    temp->next = NULL;

        _tcscpy(temp->name,pCDTitle->pTrackTable[i].szName);

	    if (curr==NULL)
        {
	        ALLTRACKS( cdrom ) = curr = temp;

	    } else
        {

	        curr->next = temp;
	        curr = temp;

	    }
    }

    // Make sure there is at least one entry in TRACK list
    if (ALLTRACKS(cdrom) == NULL)
    {
	    fRewriteEntry = TRUE;
    }

    //
    // if we detected a problem in the ini file, or the entry is an
    // old format, rewrite the section.
    //

    if (fRewriteEntry)
    {
	    //
	    // Generate generic play list (all tracks in order)
	    //

	    ResetPlayList( cdrom );

    }
    else
    {
	    //
	    // Read play list (order) information and construct play list doubly
	    // linked list
	    //

	    numplay = pCDTitle->dwNumPlay;
        if (numplay == 0)
        {
            numplay = pCDTitle->dwNumTracks;
        }

	    prev = NULL;

        int iCurrTrack = -1;

        if (CURRTRACK(cdrom)!=NULL)
        {
            iCurrTrack = CURRTRACK(cdrom)->TocIndex;
        }

        EraseSaveList(cdrom);
        ErasePlayList(cdrom);

	    for (int tr_index = 0; tr_index < numplay; tr_index++)
        {
	        /*
	        ** Assert that i is a valid index.
	        **  ie 0 <= i <= (numtracks - 1)
	        */

            if (pCDTitle->dwNumPlay > 0)
            {
                i = pCDTitle->pPlayList[tr_index];
            }
            else
            {
                i = tr_index;
            }

	        i = min( ((UINT)numtracks - 1), max( 0, i ) );

	        temp1 = (PTRACK_PLAY)AllocMemory( sizeof(TRACK_PLAY) );
	        temp1->TocIndex = (int)i;
	        temp1->min = 0;
	        temp1->sec = 0;
	        temp1->prevplay = prev;
	        temp1->nextplay = NULL;

	        if (prev==NULL)
            {
    		    SAVELIST( cdrom ) = temp1;
	        }
            else
            {
    		    prev->nextplay  = temp1;
	        }
	        prev = temp1;
	    }

	    // Make sure there is at least one entry in SAVED list
	    if (SAVELIST(cdrom) == NULL)
	    {
	        // Nope, use default list instead
	        ResetPlayList( cdrom );
	    }

	    PLAYLIST( cdrom ) = CopyPlayList( SAVELIST( cdrom ) );

        //reset current track if necessary
        if (iCurrTrack != -1)
        {
            BOOL fFound = FALSE;

            for (PTRACK_PLAY pp = PLAYLIST(cdrom); pp != NULL; pp = pp->nextplay )
            {
                if ( pp->TocIndex == iCurrTrack )
                {
                    fFound = TRUE;
                    break;
                }
            } //end for

            if (fFound)
            {
                CURRTRACK(cdrom) = pp;
            }
            else
            {
                /*
                ** If the track was not found in the new track list and this
                ** cd is currently playing then stop it.
                */
                if ( (STATE(cdrom) & (CD_PLAYING | CD_PAUSED)) )
                {

                    SendDlgItemMessage( g_hwndApp, IDM_PLAYBAR_STOP,
                                        WM_LBUTTONDOWN, 1, 0 );

                    SendDlgItemMessage( g_hwndApp, IDM_PLAYBAR_STOP,
                                        WM_LBUTTONUP, 1, 0 );
                }

                CURRTRACK(cdrom) = PLAYLIST(cdrom);
            }
        }

        /*
        ** If we were previously in "Random" mode shuffle the new
        ** playlist.
        */
        if (!g_fSelectedOrder)
        {
            ComputeSingleShufflePlayList(cdrom);
        }

        RecomputePlayTimes(cdrom);
    }

    //unlock title data, don't persist it
    pData->UnlockTitle(pCDTitle,FALSE);
    pData->Release();

    return TRUE;
}

/******************************Public*Routine******************************\
* AddFindEntry
*
* Search the database file for the current disc,  if found, read the
* information, otherwise, generate some default artist and track names etc.
* but don't store this in the database.  A new entry is only added to the
* database after the user has used the "Edit Track Titles" dialog box.
*
* The design of this function is complicated by the fact that we have to
* support two previous attempts at generating CDplayer keys.  Also, we try
* to support the MusicBox key format now that it is compatible with the
* new CDplayer format.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
AddFindEntry(
    int cdrom,
    DWORD key,
    PCDROM_TOC lpTOC
    )
{
    /*
    ** Kill off old PlayList, Save lists if they exists.
    */

    ErasePlayList( cdrom );
    EraseSaveList( cdrom );
    EraseTrackList( cdrom );

    /*
    ** Check ini file for an existing entry
    **
    ** First Look in cdplayer.ini using the new key, return if found
    */

    // We initialize this field early, otherwise ReadEntry will not be
    // able to save any new information (or lose invalid).
    g_Devices[ cdrom ]->CdInfo.save = TRUE;

    if ( ReadEntry(cdrom, key) )
    {
	    return;
    }

    /*
    ** Initialize these fields
    */
    g_Devices[ cdrom ]->CdInfo.IsVirginCd = FALSE;
    g_Devices[ cdrom ]->CdInfo.Id = key;

	/*
	** dstewart: Try to get the info from the net
	*/
	if ( GetInternetDatabase(cdrom, key, TRUE, FALSE, GetParent(g_hwndApp),NULL) )
	{
        return;
    }
	/*
	** end dstewart
	*/

    CreateNewEntry(cdrom,key,lpTOC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\commands.cpp ===
/******************************Module*Header*******************************\
* Module Name: commands.c
*
* Executes the users commands.
*
*
* Created: 18-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>    /* required for all Windows applications */
#include <windowsx.h>
#include <string.h>
#include <malloc.h>
#include <stdarg.h>
#include <stdio.h>


#include "playres.h"
#include "cdplayer.h"
#include "ledwnd.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"
#include "database.h"
#include "commands.h"


#define PREVTRAK_TIMELIMIT 3 //seconds
extern IMMFWNotifySink* g_pSink;

/******************************Public*Routine******************************\
* CdPlayerEjectCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerEjectCmd(
    void
    )
{
    if (g_State & CD_PAUSED) {
        g_State &= (~(CD_PAUSED_AND_MOVED | CD_PAUSED));
    }

    if (g_State & CD_PLAYING) {
        g_State &= ~CD_PLAYING;
        g_State |= CD_STOPPED;
    }

    if (EjectTheCdromDisc(g_CurrCdrom))
    {
        g_State = (CD_NO_CD | CD_STOPPED);
        SetPlayButtonsEnableState();
        TimeAdjustInitialize( g_CurrCdrom );
        g_pSink->OnEvent(MMEVENT_ONMEDIAUNLOADED,NULL);
    }
}


/******************************Public*Routine******************************\
* CdPlayerPlayCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerPlayCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the play button again.
    */
    if ( LockALLTableOfContents() ) {

        if (g_State & CD_LOADED ) {

            if ((g_State & CD_STOPPED) && PlayCurrTrack( g_CurrCdrom )) {

                g_State &= ~CD_STOPPED;
                g_State |= CD_PLAYING;
            }
            else if ( g_State & CD_PAUSED ) {

                if ( g_State & CD_PAUSED_AND_MOVED ) {

                    g_State &= ~CD_PAUSED_AND_MOVED;
                    g_State |= CD_PLAYING;


                    if ( SeekToCurrSecond( g_CurrCdrom ) ) {

                        g_State &= ~CD_PAUSED;
                        g_State |= CD_PLAYING;
                    }
                    else {

                        g_State &= ~CD_PLAYING;
                    }

                }
                else if ( ResumeTheCdromDrive( g_CurrCdrom ) ) {

                    g_State &= ~CD_PAUSED;
                    g_State |= CD_PLAYING;
                }

                UpdateDisplay( DISPLAY_UPD_LED );
            }

            if (g_State & CD_PLAYING)
            {
                g_pSink->OnEvent(MMEVENT_ONPLAY,NULL);
            }
        }
        else {
#if DBG
            dprintf( TEXT("Failing play because NO disc loaded") );
#endif
        }

        SetPlayButtonsEnableState();
    }
}


/******************************Public*Routine******************************\
* CdPlayerPauseCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerPauseCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the pause button again.
    */
    if ( LockALLTableOfContents() ) {

        if ( g_State & CD_PLAYING )
        {
            if ( PauseTheCdromDrive( g_CurrCdrom ) )
            {
                g_State &= ~CD_PLAYING;
                g_State |= CD_PAUSED;
                g_pSink->OnEvent(MMEVENT_ONPAUSE,NULL);
            }
        }
        else if ( g_State & CD_PAUSED )
        {

            if ( g_State & CD_PAUSED_AND_MOVED ) {

                g_State &= ~CD_PAUSED_AND_MOVED;
                g_State |= CD_PLAYING;


                if ( SeekToCurrSecond( g_CurrCdrom ) ) {

                    g_State &= ~CD_PAUSED;
                    g_State |= CD_PLAYING;
                }
                else {

                    g_State &= ~CD_PLAYING;
                }

            }
            else if ( ResumeTheCdromDrive( g_CurrCdrom ) ) {

                g_State &= ~CD_PAUSED;
                g_State |= CD_PLAYING;
            }

            UpdateDisplay( DISPLAY_UPD_LED );

            if (g_State & CD_PLAYING)
            {
                g_pSink->OnEvent(MMEVENT_ONPLAY,NULL);
            }
        }

        SetPlayButtonsEnableState();
    }
}


/******************************Public*Routine******************************\
* CdPlayerStopCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerStopCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the stop button again.
    */
    if ( LockALLTableOfContents() ) {

        BOOL bPlaying, bPaused;

        bPlaying = g_State & CD_PLAYING;
        bPaused  = g_State & CD_PAUSED;

        if ( (bPlaying || bPaused) && StopTheCdromDrive(g_CurrCdrom) ) {

            g_State &= ~(bPlaying ? CD_PLAYING : CD_PAUSED);
            g_State |= CD_STOPPED;

            /*
            ** Stop the current play operation and seek to the first
            ** playable track.
            */
            CURRTRACK(g_CurrCdrom) = FindFirstTrack( g_CurrCdrom );
            TimeAdjustSkipToTrack( g_CurrCdrom, CURRTRACK(g_CurrCdrom) );

            UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME |
                           DISPLAY_UPD_TRACK_NAME );

            SetPlayButtonsEnableState();


            // Stop it again!!!
            // This is to prevent a strange bug with NEC 4x,6x players
            // Where a SEEK command in TimeAdjustSkipToTrack causes
            // The ejection mechanism to get locked.
            if (StopTheCdromDrive (g_CurrCdrom))
            {
                g_pSink->OnEvent(MMEVENT_ONSTOP,NULL);
            }
        }
    }
}

/******************************Public*Routine******************************\
* CdPlayerPrevTrackCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerPrevTrackCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the previous track button again.
    */
    if ( LockALLTableOfContents() ) {

        DWORD       dwOldState;
        int         i, j;
        PTRACK_PLAY tr;

        if ( (CDTIME(g_CurrCdrom).TrackCurSec <= PREVTRAK_TIMELIMIT)
          && (CDTIME(g_CurrCdrom).TrackCurMin == 0) ) {

            dwOldState = g_State;
            i = g_CurrCdrom;

            tr = FindPrevTrack( g_CurrCdrom, g_fContinuous );

            if ( tr == NULL ) {

                /*
                ** If we were Paused or Playing fake a press on the
                ** "stop" button
                */
                if ( g_State & (CD_PLAYING | CD_PAUSED) ) {
                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                                 WM_LBUTTONDOWN, 0, 0L );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                                 WM_LBUTTONUP, 0, 0L );
                }
            }
            else {

                TimeAdjustSkipToTrack( g_CurrCdrom, tr );

                if ( (i != g_CurrCdrom) && (dwOldState & CD_PLAYING) )
                {
                    j = g_CurrCdrom;
                    g_CurrCdrom = i;

                    //don't allow the ledwnd to paint
                    LockWindowUpdate(g_hwndControls[INDEX(IDC_LED)]);
                    SwitchToCdrom( j, FALSE );
                    LockWindowUpdate(NULL);

                    //switchtocdrom command stopped drive, setting us back to track 1...
                    //reset to correct track
                    TimeAdjustSkipToTrack( g_CurrCdrom, tr );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONDOWN, 0, 0L );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONUP, 0, 0L );
                }
            }
        }
        else {

            TimeAdjustSkipToTrack( g_CurrCdrom, CURRTRACK( g_CurrCdrom ) );
        }
    }
}

/******************************Public*Routine******************************\
* CdPlayerNextTrackCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerNextTrackCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the next track button again.
    */
    if ( LockALLTableOfContents() ) {

        DWORD       dwOldState;
        PTRACK_PLAY tr;

        dwOldState = g_State;

        tr = FindNextTrack( g_fContinuous );
        if ( tr == NULL ) {

            /*
            ** If the CD is playing fake a press on the "stop" button
            ** otherwise call the stop function directly.
            */
            if ( g_State & (CD_PLAYING | CD_PAUSED) ) {
                SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                             WM_LBUTTONDOWN, 0, 0L );

                SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                             WM_LBUTTONUP, 0, 0L );
            }
            else {

                /*
                ** Seek to the first playable track.
                */
                CURRTRACK(g_CurrCdrom) = FindFirstTrack( g_CurrCdrom );
                if (CURRTRACK(g_CurrCdrom) != NULL ) {

                    TimeAdjustSkipToTrack( g_CurrCdrom,
                                           CURRTRACK(g_CurrCdrom) );
                    UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME |
                                   DISPLAY_UPD_TRACK_NAME );

                    SetPlayButtonsEnableState();
                }

            }
        }
        else {

            if ( g_LastCdrom != g_CurrCdrom) {

                SwitchToCdrom( g_CurrCdrom,FALSE);
                TimeAdjustSkipToTrack( g_CurrCdrom, tr );

                if ( dwOldState & CD_PLAYING ) {

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONDOWN, 0, 0L );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONUP, 0, 0L );
                }

            }
            else {

                TimeAdjustSkipToTrack( g_CurrCdrom, tr );
            }
        }
    }
}


/******************************Public*Routine******************************\
* CdPlayerSeekCmd
*
* How Seek works.
*
* When the user presses a seek button (forwards or backwards) this function
* gets called.  The cdplayer can be in three possible states:
*
*   1. Playing
*   2. Paused
*   3. Stopped
*
* In state 1 (playing) we pause the device and alter its global state flags
* to show that it was playing (CD_WAS_PLAYING).  This is so that we can
* return to the playing state when the user stops seeking.
*
* We then start a timer.  We always call the timer function, this means
* that we will allways skip one second no matter how quickly the user
* clicks the seek button.  The timer just increments (or decrements) the
* current play position according to the currrent play list.  When the users
* releases the seek button we stop the timer and resume playing if the
* CD_WAS_PLAYING flag was set.
*
* The interesting case is when we try to seek beyond the end of the current
* play list.  We detect this by testing the state of CURRTRACK(g_CurrCdrom).
* If NULL we have come to the end of the play list.  If we were paused or
* previously playing we fake a stop command by sending a WM_LBUTTONDOWN,
* WM_LBUTTONUP message pair to the stop button.   This causes the focus
* to be moved from the currently pressed seek button, which means that
* this function will get called BEFORE the CdPlayerStopCmd function.  So
* by the time CdPlayerStopCmd gets called the correct playing state of
* the cdrom device would have been restored by the code below.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerSeekCmd(
    HWND    hwnd,
    BOOL    fStart,
    UINT    uDirection
    )
{
    UINT_PTR    rc;
    BOOL        frc;

    if ( fStart ) {

        if (g_State & CD_PLAYING) {

            g_State &= ~CD_PLAYING;
            g_State |= CD_WAS_PLAYING;

            PauseTheCdromDrive( g_CurrCdrom );
        }
        g_State |= CD_SEEKING;

        rc = SetTimer( hwnd, uDirection, SKIPBEAT_TIMER_RATE,
                       (TIMERPROC)SkipBeatTimerProc );
        ASSERT(rc != 0);

        SkipBeatTimerProc( hwnd, WM_TIMER, uDirection, 0L );
    }
    else {

        g_State &= ~CD_SEEKING;

        if (g_State & CD_WAS_PLAYING) {

            g_State &= ~CD_WAS_PLAYING;
            g_State |= CD_PLAYING;
        }

        if ( g_State & CD_PAUSED ) {
            g_State |= CD_PAUSED_AND_MOVED;
        }
        else {

           SeekToCurrSecond( g_CurrCdrom );
        }

        frc = KillTimer( hwnd, uDirection );
        ASSERT(frc != FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\dragdrop.h ===
/******************************Module*Header*******************************\
* Module Name: DragDrop.h
*
* An attempt to implement dragging and dropping between Multi-selection
* listboxes.
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifndef _INC_DRAGMULITLIST
#define _INC_DRAGMULTILIST

typedef struct {
    UINT    uNotification;
    HWND    hWnd;
    POINT   ptCursor;
    DWORD   dwState;
} DRAGMULTILISTINFO, FAR *LPDRAGMULTILISTINFO;

#define DL_BEGINDRAG    (LB_MSGMAX+100)
#define DL_DRAGGING     (LB_MSGMAX+101)
#define DL_DROPPED      (LB_MSGMAX+102)
#define DL_CANCELDRAG   (LB_MSGMAX+103)

#define DL_CURSORSET    0

#define DL_MOVE         0
#define DL_COPY         1


#define SJE_DRAGLISTMSGSTRING "sje_DragMultiListMsg"

/*---------------------------------------------------------------------
** Exported functions and variables
**---------------------------------------------------------------------
*/
UINT WINAPI
InitDragMultiList(
    void
    );

BOOL WINAPI
MakeMultiDragList(
    HWND hLB
    );

int WINAPI
LBMultiItemFromPt(
    HWND hLB,
    POINT pt,
    BOOL bAutoScroll
    );

VOID WINAPI
DrawMultiInsert(
    HWND hwndParent,
    HWND hLB,
    int nItem
    );

#endif  /* _INC_DRAGMULTILIST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\dib.cpp ===
/*----------------------------------------------------------------------------*\
|   Routines for dealing with Device independent bitmaps                       |
|                                                                              |
|   History:                                                                   |
|       06/23/89 toddla     Created                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/

#include <windows.h>
#include <stdio.h>
#include "dib.h"

#define HUGE_T

/*
 *   Open a DIB file and return a MEMORY DIB, a memory handle containing..
 *
 *   BITMAP INFO    bi
 *   palette data
 *   bits....
 *
 */
HANDLE OpenDIB(LPTSTR szFile, HFILE fh)
{
    BITMAPINFOHEADER    bi;
    LPBITMAPINFOHEADER  lpbi;
    DWORD               dwLen;
    DWORD               dwBits;
    HANDLE              hdib;
    HANDLE              h;
#ifndef UNICODE
    OFSTRUCT            of;
#endif
    BOOL fOpened = FALSE;

    if (szFile != NULL)
    {
    #ifdef UNICODE
	    fh = (HFILE)HandleToUlong(CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ,
			     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    #else
	    fh = OpenFile(szFile, &of, OF_READ);
    #endif
	    fOpened = TRUE;
    }

    if (fh == -1)
	return NULL;

    hdib = ReadDibBitmapInfo(fh);

    if (!hdib)
	return NULL;

    DibInfo((LPBITMAPINFOHEADER)GlobalLock(hdib),&bi);  GlobalUnlock(hdib);

    /* How much memory do we need to hold the DIB */

    dwBits = bi.biSizeImage;
    dwLen  = bi.biSize + PaletteSize(&bi) + dwBits;

    /* Can we get more memory? */

    h = GlobalReAlloc(hdib,dwLen,GMEM_MOVEABLE);

    if (!h)
    {
	    GlobalFree(hdib);
	    hdib = NULL;
    }
    else
    {
    	hdib = h;
    }

    if (hdib)
    {
	    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

	    /* read in the bits */
	    _lread(fh, (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi), dwBits);

	    GlobalUnlock(hdib);
    }

    if (fOpened)
	_lclose(fh);

    return hdib;
}

/*
 *  DibInfo(hbi, lpbi)
 *
 *  retrives the DIB info associated with a CF_DIB format memory block.
 */
BOOL  DibInfo(LPBITMAPINFOHEADER lpbiSource, LPBITMAPINFOHEADER lpbiTarget)
{
    if (lpbiSource)
    {
	*lpbiTarget = *lpbiSource;

	if (lpbiTarget->biSize == sizeof(BITMAPCOREHEADER))
	{
	    BITMAPCOREHEADER bc;

	    bc = *(LPBITMAPCOREHEADER)lpbiTarget;

	    lpbiTarget->biSize               = sizeof(BITMAPINFOHEADER);
	    lpbiTarget->biWidth              = (DWORD)bc.bcWidth;
	    lpbiTarget->biHeight             = (DWORD)bc.bcHeight;
	    lpbiTarget->biPlanes             =  (UINT)bc.bcPlanes;
	    lpbiTarget->biBitCount           =  (UINT)bc.bcBitCount;
	    lpbiTarget->biCompression        = BI_RGB;
	    lpbiTarget->biSizeImage          = 0;
	    lpbiTarget->biXPelsPerMeter      = 0;
	    lpbiTarget->biYPelsPerMeter      = 0;
	    lpbiTarget->biClrUsed            = 0;
	    lpbiTarget->biClrImportant       = 0;
	}

	/*
	 * fill in the default fields
	 */
	if (lpbiTarget->biSize != sizeof(BITMAPCOREHEADER))
	{
	    if (lpbiTarget->biSizeImage == 0L)
		lpbiTarget->biSizeImage = (DWORD)DIBWIDTHBYTES(*lpbiTarget) * lpbiTarget->biHeight;

	    if (lpbiTarget->biClrUsed == 0L)
		lpbiTarget->biClrUsed = DibNumColors(lpbiTarget);
	}
	return TRUE;
    }
    return FALSE;
}

/*
 *  ReadDibBitmapInfo()
 *
 *  Will read a file in DIB format and return a global HANDLE to it's
 *  BITMAPINFO.  This function will work with both "old" and "new"
 *  bitmap formats, but will always return a "new" BITMAPINFO
 *
 */
HANDLE ReadDibBitmapInfo(HFILE fh)
{
    DWORD     off;
    HANDLE    hbi = NULL;
    int       size;
    int       i;
    UINT      nNumColors;

    RGBQUAD FAR       *pRgb;
    BITMAPINFOHEADER   bi;
    BITMAPCOREHEADER   bc;
    LPBITMAPINFOHEADER lpbi;
    BITMAPFILEHEADER   bf;

    if (fh == -1)
	return NULL;

    off = _llseek(fh,0L,SEEK_CUR);

    if (sizeof(bf) != _lread(fh,(LPBYTE)&bf,sizeof(bf)))
	return FALSE;

    /*
     *  do we have a RC HEADER?
     */
    if (!ISDIB(bf.bfType))
    {
	bf.bfOffBits = 0L;
	_llseek(fh,off,SEEK_SET);
    }

    if (sizeof(bi) != _lread(fh,(LPBYTE)&bi,sizeof(bi)))
	return FALSE;

    nNumColors = DibNumColors(&bi);

    /*
     *  what type of bitmap info is this?
     */
    switch (size = (int)bi.biSize)
    {
	case sizeof(BITMAPINFOHEADER):
	    break;

	case sizeof(BITMAPCOREHEADER):
	    bc = *(BITMAPCOREHEADER*)&bi;
	    bi.biSize               = sizeof(BITMAPINFOHEADER);
	    bi.biWidth              = (DWORD)bc.bcWidth;
	    bi.biHeight             = (DWORD)bc.bcHeight;
	    bi.biPlanes             =  (UINT)bc.bcPlanes;
	    bi.biBitCount           =  (UINT)bc.bcBitCount;
	    bi.biCompression        = BI_RGB;
	    bi.biSizeImage          = 0;
	    bi.biXPelsPerMeter      = 0;
	    bi.biYPelsPerMeter      = 0;
	    bi.biClrUsed            = nNumColors;
	    bi.biClrImportant       = nNumColors;

	    _llseek(fh,(LONG)sizeof(BITMAPCOREHEADER)-sizeof(BITMAPINFOHEADER),SEEK_CUR);

	    break;

	default:
	    return NULL;       /* not a DIB */
    }

    /*
     *  fill in some default values!
     */
    if (bi.biSizeImage == 0)
    {
	bi.biSizeImage = (DWORD)DIBWIDTHBYTES(bi) * bi.biHeight;
    }

    if (bi.biXPelsPerMeter == 0)
    {
	bi.biXPelsPerMeter = 0;         // ??????????????
    }

    if (bi.biYPelsPerMeter == 0)
    {
	bi.biYPelsPerMeter = 0;         // ??????????????
    }

    if (bi.biClrUsed == 0)
    {
	bi.biClrUsed = DibNumColors(&bi);
    }

    hbi = GlobalAlloc(GMEM_MOVEABLE,(LONG)bi.biSize + nNumColors * sizeof(RGBQUAD));
    if (!hbi)
	return NULL;

    lpbi = (BITMAPINFOHEADER *)GlobalLock(hbi);
    *lpbi = bi;

    pRgb = (RGBQUAD FAR *)((LPBYTE)lpbi + bi.biSize);

    if (nNumColors)
    {
	if (size == (int)sizeof(BITMAPCOREHEADER))
	{
	    /*
	     * convert a old color table (3 byte entries) to a new
	     * color table (4 byte entries)
	     */
	    _lread(fh,(LPBYTE)pRgb,nNumColors * sizeof(RGBTRIPLE));

	    for (i=nNumColors-1; i>=0; i--)
	    {
		RGBQUAD rgb;

		rgb.rgbRed      = ((RGBTRIPLE FAR *)pRgb)[i].rgbtRed;
		rgb.rgbBlue     = ((RGBTRIPLE FAR *)pRgb)[i].rgbtBlue;
		rgb.rgbGreen    = ((RGBTRIPLE FAR *)pRgb)[i].rgbtGreen;
		rgb.rgbReserved = (BYTE)0;

		pRgb[i] = rgb;
	    }
	}
	else
	{
	    _lread(fh,(LPBYTE)pRgb,nNumColors * sizeof(RGBQUAD));
	}
    }

    if (bf.bfOffBits != 0L)
	_llseek(fh,off + bf.bfOffBits,SEEK_SET);

    GlobalUnlock(hbi);
    return hbi;
}

/*  How big is the palette? if bits per pel not 24
 *  no of bytes to read is 6 for 1 bit, 48 for 4 bits
 *  256*3 for 8 bits and 0 for 24 bits
 */
UINT PaletteSize(VOID FAR * pv)
{
    #define lpbi ((LPBITMAPINFOHEADER)pv)
    #define lpbc ((LPBITMAPCOREHEADER)pv)

    UINT    NumColors;

    NumColors = DibNumColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	return NumColors * sizeof(RGBTRIPLE);
    else
	return NumColors * sizeof(RGBQUAD);

    #undef lpbi
    #undef lpbc
}

/*  How Many colors does this DIB have?
 *  this will work on both PM and Windows bitmap info structures.
 */
UINT DibNumColors(VOID FAR * pv)
{
    #define lpbi ((LPBITMAPINFOHEADER)pv)
    #define lpbc ((LPBITMAPCOREHEADER)pv)

    int bits;

    /*
     *  with the new format headers, the size of the palette is in biClrUsed
     *  else is dependent on bits per pixel
     */
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
    {
	if (lpbi->biClrUsed != 0)
	    return (UINT)lpbi->biClrUsed;

	bits = lpbi->biBitCount;
    }
    else
    {
	bits = lpbc->bcBitCount;
    }

    switch (bits)
    {
    case 1:
	    return 2;
    case 4:
	    return 16;
    case 8:
	    return 256;
    default:
	    return 0;
    }

    #undef lpbi
    #undef lpbc
}

/*
 *  DibFromBitmap()
 *
 *  Will create a global memory block in DIB format that represents the DDB
 *  passed in
 *
 */
HANDLE DibFromBitmap(HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage)
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dwLen;
    int                  nColors;
    HANDLE               hdib;
    HANDLE               h;
    HDC                  hdc;

    if (wUsage == 0)
	wUsage = DIB_RGB_COLORS;

    if (!hbm)
	return NULL;
    if (hpal == NULL)
	hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    GetObject(hbm,sizeof(bm),(LPBYTE)&bm);
#ifdef WIN32
    nColors = 0;  // GetObject only stores two bytes
#endif
    GetObject(hpal,sizeof(nColors),(LPBYTE)&nColors);

    if (biBits == 0)
	biBits = bm.bmPlanes * bm.bmBitsPixel;

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = biStyle;
    bi.biSizeImage          = 0;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = 0;
    bi.biClrImportant       = 0;

    dwLen  = bi.biSize + PaletteSize(&bi);

    hdc = CreateCompatibleDC(NULL);
    hpal = SelectPalette(hdc,hpal,TRUE);
    RealizePalette(hdc);  // why is this needed on a MEMORY DC? GDI bug??

    hdib = GlobalAlloc(GMEM_MOVEABLE,dwLen);

    if (!hdib)
	goto exit;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    *lpbi = bi;

    /*
     *  call GetDIBits with a NULL lpBits param, so it will calculate the
     *  biSizeImage field for us
     */
    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
	NULL, (LPBITMAPINFO)lpbi, wUsage);

    bi = *lpbi;
    GlobalUnlock(hdib);

    /*
     * HACK! if the driver did not fill in the biSizeImage field, make one up
     */
    if (bi.biSizeImage == 0)
    {
	bi.biSizeImage = (DWORD)WIDTHBYTES(bm.bmWidth * biBits) * bm.bmHeight;

	if (biStyle != BI_RGB)
	    bi.biSizeImage = (bi.biSizeImage * 3) / 2;
    }

    /*
     *  realloc the buffer big enough to hold all the bits
     */
    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;
    if (h = GlobalReAlloc(hdib,dwLen,GMEM_MOVEABLE))
    {
	hdib = h;
    }
    else
    {
	GlobalFree(hdib);
	hdib = NULL;
	goto exit;
    }

    /*
     *  call GetDIBits with a NON-NULL lpBits param, and actualy get the
     *  bits this time
     */
    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
	(LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi),
	(LPBITMAPINFO)lpbi, wUsage);

    bi = *lpbi;
    lpbi->biClrUsed = DibNumColors(lpbi) ;
    GlobalUnlock(hdib);

exit:
    SelectPalette(hdc,hpal,TRUE);
    DeleteDC(hdc);
    return hdib;
}


/*
 *  DibBlt()
 *
 *  draws a bitmap in CF_DIB format, using SetDIBits to device.
 *
 *  takes the same parameters as BitBlt()
 */
BOOL DibBlt(HDC hdc, int x0, int y0, int dx, int dy, HANDLE hdib, int x1, int y1, LONG rop, UINT wUsage)
{
    LPBITMAPINFOHEADER lpbi;
    LPBYTE       pBuf;
    BOOL        f;

    if (!hdib)
	return PatBlt(hdc,x0,y0,dx,dy,rop);

    if (wUsage == 0)
	wUsage = DIB_RGB_COLORS;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    if (!lpbi)
	return FALSE;

    if (dx == -1 && dy == -1)
    {
	if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	{
	    dx = ((LPBITMAPCOREHEADER)lpbi)->bcWidth;
	    dy = ((LPBITMAPCOREHEADER)lpbi)->bcHeight;
	}
	else
	{
	    dx = (int)lpbi->biWidth;
	    dy = (int)lpbi->biHeight;
	}
    }

    pBuf = (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi);


    f = StretchDIBits (
	hdc,
	x0,y0,
	dx,dy,
	x1,y1,
	dx,dy,
	pBuf, (LPBITMAPINFO)lpbi,
	wUsage,
	rop);

    GlobalUnlock(hdib);
    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\dib.h ===
/*----------------------------------------------------------------------------*\
|   Routines for dealing with Device independent bitmaps                       |
|									       |
|   History:                                                                   |
|       06/23/89 toddla     Created                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/

HANDLE      OpenDIB(LPTSTR szFile, HFILE fh);
UINT        PaletteSize(VOID FAR * pv);
UINT        DibNumColors(VOID FAR * pv);
HANDLE      DibFromBitmap(HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage);
BOOL        DibBlt(HDC hdc, int x0, int y0, int dx, int dy, HANDLE hdib, int x1, int y1, LONG rop, UINT wUsage);
BOOL        DibInfo(LPBITMAPINFOHEADER lpbiSource, LPBITMAPINFOHEADER lpbiTarget);
HANDLE      ReadDibBitmapInfo(HFILE fh);

#define BFT_ICON   0x4349   /* 'IC' */
#define BFT_BITMAP 0x4d42   /* 'BM' */
#define BFT_CURSOR 0x5450   /* 'PT' */

#define WIDTHBYTES(i)     ((i+31)/32*4)      /* ULONG aligned ! */
#define ALIGNULONG(i)     ((i+3)/4*4)        /* ULONG aligned ! */
#define ISDIB(bft) ((bft) == BFT_BITMAP)
#define DIBWIDTHBYTES(bi) (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\cdplayer.h ===
/******************************Module*Header*******************************\
* Module Name: cdplayer.h
*
*
*
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
//#ifdef CHICAGO
#include <shellapi.h>
//#endif

#include "..\main\mmfw.h"

#define IDC_ARTIST_NAME IDC_COMBO1
#define IDC_TRACK_LIST IDC_COMBO2
#define IDC_TITLE_NAME IDC_EDIT1
#define IDB_TRACK 127

/* -------------------------------------------------------------------------
** Replace the WM_MENUSELECT message craker because it contains a bug.
** -------------------------------------------------------------------------
*/
#ifdef HANDLE_WM_MENUSELECT
#undef HANDLE_WM_MENUSELECT
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn)                  \
    ((fn)( (hwnd), (HMENU)(lParam),                                     \
           (UINT)LOWORD(wParam), NULL, (UINT)HIWORD(wParam)), 0L)
#endif

#ifndef NUMELEMS
    #define NUMELEMS(a) (sizeof((a))/sizeof((a)[0]))
#endif // NUMELEMS


#define NUM_OF_CONTROLS (IDC_CDPLAYER_LAST - IDC_CDPLAYER_FIRST + 1)
#define NUM_OF_BUTTONS  (IDC_BUTTON8 - IDC_BUTTON1 + 1)

#define INDEX( _x_ )    ((_x_) - IDC_CDPLAYER_FIRST)

#if DBG

void
dprintf(
    TCHAR *lpszFormat,
    ...
    );
void CDAssert( LPSTR x, LPSTR file, int line );
#undef ASSERT
#define ASSERT(_x_) if (!(_x_))  CDAssert( #_x_, __FILE__, __LINE__ )

#else

#undef ASSERT
#define ASSERT(_x_)

#endif

#define WM_CDPLAYER_MSG_BASE        (WM_USER + 0x1000)

#define WM_NOTIFY_CDROM_COUNT       (WM_CDPLAYER_MSG_BASE)
#define WM_NOTIFY_TOC_READ          (WM_CDPLAYER_MSG_BASE+1)
#define WM_NOTIFY_FIRST_SCAN        (WM_CDPLAYER_MSG_BASE+2)

#define HEARTBEAT_TIMER_ID          0x3243
#ifdef DAYTONA
#define HEARTBEAT_TIMER_RATE        250         /* 4 times a second */
#else
#define HEARTBEAT_TIMER_RATE        500         /* 2 times a second */
#endif

#define SKIPBEAT_TIMER_ID           0x3245
#define SKIPBEAT_TIMER_RATE         200         /* 5  times a second */
#define SKIPBEAT_TIMER_RATE2        100         /* 10 times a second */
#define SKIPBEAT_TIMER_RATE3        50          /* 20 times a second */
#define SKIP_ACCELERATOR_LIMIT1     5           /* 5  seconds        */
#define SKIP_ACCELERATOR_LIMIT2     20          /* 20 seconds        */


#define FRAMES_PER_SECOND           75
#define FRAMES_PER_MINUTE           (60*FRAMES_PER_SECOND)


#define DISPLAY_UPD_LED             0x00000001
#define DISPLAY_UPD_TITLE_NAME      0x00000002
#define DISPLAY_UPD_TRACK_NAME      0x00000004
#define DISPLAY_UPD_TRACK_TIME      0x00000008
#define DISPLAY_UPD_DISC_TIME       0x00000010
#define DISPLAY_UPD_CDROM_STATE     0x00000020
#define DISPLAY_UPD_LEADOUT_TIME    0x80000000


#define INTRO_LOWER_LEN             5
#define INTRO_DEFAULT_LEN           10
#define INTRO_UPPER_LEN             15


//  Audio Play Files consist completely of this header block.  These
//  files are readable in the root of any audio disc regardless of
//  the capabilities of the drive.
//
//  The "Unique Disk ID Number" is a calculated value consisting of
//  a combination of parameters, including the number of tracks and
//  the starting locations of those tracks.
//
//  Applications interpreting CDDA RIFF files should be advised that
//  additional RIFF file chunks may be added to this header in the
//  future in order to add information, such as the disk and song title.

#define RIFF_RIFF 0x46464952
#define RIFF_CDDA 0x41444443

typedef struct {
    DWORD   dwRIFF;         // 'RIFF'
    DWORD   dwSize;         // Chunk size = (file size - 8)
    DWORD   dwCDDA;         // 'CDDA'
    DWORD   dwFmt;          // 'fmt '
    DWORD   dwCDDASize;     // Chunk size of 'fmt ' = 24
    WORD    wFormat;        // Format tag
    WORD    wTrack;         // Track number
    DWORD   DiscID;         // Unique disk id
    DWORD   lbnTrackStart;  // Track starting sector (LBN)
    DWORD   lbnTrackLength; // Track length (LBN count)
    DWORD   msfTrackStart;  // Track starting sector (MSF)
    DWORD   msfTrackLength; // Track length (MSF)
}   RIFFCDA;


BOOL
InitInstance(
    HANDLE hInstance
    );


INT_PTR CALLBACK
MainWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
CDPlay_OnInitDialog(
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lParam
    );

void
CDPlay_OnInitMenuPopup(
    HWND hwnd,
    HMENU hMenu,
    UINT item,
    BOOL fSystemMenu
    );

void
CDPlay_OnPaint(
    HWND hwnd
    );

void
CDPlay_OnSysColorChange(
    HWND hwnd
    );

void
CDPlay_OnWinIniChange(
    HWND hwnd,
    LPCTSTR lpszSectionName
    );

LRESULT
CDPlay_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR *pnmhdr
    );

UINT
CDPlay_OnNCHitTest(
    HWND hwnd,
    int x,
    int y
    );

BOOL
CDPlay_OnCopyData(
    HWND hwnd,
    PCOPYDATASTRUCT lpcpds
    );

BOOL
CDPlay_OnTocRead(
    int iDriveRead
    );

BOOL
CDPlay_OnDeviceChange(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam);

void
CDPlay_OnDropFiles(
    HWND hwnd,
    HDROP hdrop
    );

BOOL
CDPlay_OnDrawItem(
    HWND hwnd,
    const DRAWITEMSTRUCT *lpdis
    );

void
CDPlay_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    );

void
CDPlay_OnDestroy(
    HWND hwnd
    );

BOOL
CDPlay_OnClose(
    HWND hwnd,
    BOOL fShuttingDown
    );

void
CDPlay_OnEndSession(
    HWND hwnd,
    BOOL fEnding
    );

void
CDPlay_OnSize(
    HWND hwnd,
    UINT state,
    int cx,
    int cy
    );

BOOL CALLBACK
ChildEnumProc(
    HWND hwndChild,
    LPARAM lp
    );

void
FatalApplicationError(
    INT uIdStringResource,
    ...
    );

void
LED_ToggleDisplayFont(
    HWND hwnd,
    BOOL fFont
    );

LPTSTR
IdStr(
    int idResource
    );

void
CheckMenuItemIfTrue(
    HMENU hMenu,
    UINT idItem,
    BOOL flag
    );

void
ReadSettings(
    void* pData
    );

BOOL
LockTableOfContents(
    int cdrom
    );

BOOL
LockALLTableOfContents(
    void
    );

LPVOID
AllocMemory(
    UINT uSize
    );

void
SetPlayButtonsEnableState(
    void
    );

void CALLBACK
HeartBeatTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    );

void CALLBACK
SkipBeatTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    );

void
UpdateDisplay(
    DWORD Flags
    );

HBRUSH
Common_OnCtlColor(
    HWND hwnd,
    HDC hdc,
    HWND hwndChild,
    int type
    );

BOOL
Common_OnMeasureItem(
    HWND hwnd,
    MEASUREITEMSTRUCT *lpMeasureItem
    );

void
DrawTrackItem(
    HDC hdc,
    const RECT *r,
    DWORD item,
    BOOL selected
    );

void
DrawDriveItem(
    HDC   hdc,
    const RECT *r,
    DWORD item,
    BOOL  selected
    );

void
CdPlayerAlreadyRunning(
    void
    );

void
CdPlayerStartUp(
    HWND hwndMain
    );

void
CompleteCdPlayerStartUp(
    void
    );

BOOL
IsPlayOptionGiven(
    LPTSTR lpCmdLine
    );

BOOL
IsUpdateOptionGiven(
    LPTSTR lpCmdLine
    );

/* -------------------------------------------------------------------------
** Public Globals - Most of these should be treated as read only.
** -------------------------------------------------------------------------
*/
#ifndef GLOBAL
#define GLOBAL extern
#endif

GLOBAL HWND             g_hwndApp;
GLOBAL HWND             g_hwndControls[NUM_OF_CONTROLS];
GLOBAL BOOL             g_fSelectedOrder;
GLOBAL BOOL             g_fSingleDisk;
GLOBAL BOOL             g_fIntroPlay;
GLOBAL BOOL             g_fContinuous;
GLOBAL BOOL             g_fRepeatSingle;
GLOBAL BOOL             g_fDisplayT;
GLOBAL BOOL             g_fDisplayTr;
GLOBAL BOOL             g_fDisplayDr;
GLOBAL BOOL             g_fDisplayD;
GLOBAL BOOL             g_fMultiDiskAvailable;
GLOBAL BOOL             g_fIsIconic;
GLOBAL BOOL             g_fSmallLedFont;
GLOBAL BOOL             g_fStopCDOnExit;
GLOBAL BOOL             g_fPlay;
GLOBAL BOOL             g_fStartedInTray;
GLOBAL BOOL             g_fBlockNetPrompt;

GLOBAL int              g_NumCdDevices;
GLOBAL int              g_LastCdrom;
GLOBAL int              g_CurrCdrom;
GLOBAL int              g_IntroPlayLength;

GLOBAL TCHAR            g_szArtistTxt[128];
GLOBAL TCHAR            g_szTitleTxt[128];
GLOBAL TCHAR            g_szUnknownTxt[128];
GLOBAL TCHAR            g_szTrackTxt[128];

GLOBAL BOOL             g_fFlashLed;

GLOBAL HBITMAP          g_hbmTrack;
GLOBAL HBITMAP          g_hbmInsertPoint;
GLOBAL HBITMAP          g_hbmEditBtns;

GLOBAL HFONT            hLEDFontS;
GLOBAL HFONT            hLEDFontL;
GLOBAL HFONT            hLEDFontB;
GLOBAL LPSTR            g_lpCmdLine;

extern BOOL             g_fTrackInfoVisible;
extern IMMFWNotifySink* g_pSink;

GLOBAL CRITICAL_SECTION g_csTOCSerialize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\cdplayer.cpp ===
/******************************Module*Header*******************************\
* Module Name: cdplayer.c
*
* CD Playing application
*
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 - 1995 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#include <windows.h>    /* required for all Windows applications          */
#include <shellapi.h>
#include <windowsx.h>

#include <ole2.h>
#include <shlobj.h>
#include <dbt.h>

#include "..\main\mmfw.h"
#include "..\main\resource.h"
#include "..\main\mmenu.h"
#include "..\cdopt\cdopt.h"
#include "..\cdnet\cdnet.h"

#define NOMENUHELP
#define NOBTNLIST
#define NOTRACKBAR
#define NODRAGLIST
#define NOUPDOWN
#include <commctrl.h>   /* want toolbar and status bar                    */


#include <string.h>
#include <stdio.h>
#include <tchar.h>      /* contains portable ascii/unicode macros         */
#include <stdarg.h>
#include <stdlib.h>

#define GLOBAL          /* This allocates storage for the public globals  */


#include "playres.h"
#include "cdplayer.h"
#include "ledwnd.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"
#include "database.h"
#include "commands.h"
#include "literals.h"

//#ifndef WM_CDPLAYER_COPYDATA
#define WM_CDPLAYER_COPYDATA (WM_USER+0x100)
//#endif

IMMFWNotifySink* g_pSink;
ATOM g_atomCDClass = NULL;
extern HINSTANCE g_hInst;

void GetTOC(int cdrom, TCHAR* szNetQuery);

/* -------------------------------------------------------------------------
** Private functions
** -------------------------------------------------------------------------
*/
int
CopyWord(
    TCHAR *szWord,
    TCHAR *szSource
    );

void
AppendTrackToPlayList(
    PTRACK_PLAY pHead,
    PTRACK_PLAY pInsert
    );

BOOL
IsTrackFileNameValid(
    LPTSTR lpstFileName,
    int *piCdRomIndex,
    int *piTrackIndex,
    BOOL fScanningTracks,
    BOOL fQuiet
    );

TCHAR *
ParseTrackList(
    TCHAR *szTrackList,
    int *piCdRomIndex
    );

int
ParseCommandLine(
    LPTSTR lpstr,
    int *piTrackToSeekTo,
    BOOL fQuiet
    );

void
HandlePassedCommandLine(
    LPTSTR lpCmdLine,
    BOOL   fCheckCDRom
    );

int
FindMostSuitableDrive(
    void
    );

void
AskUserToInsertCorrectDisc(
    DWORD dwID
    );

#ifndef USE_IOCTLS
BOOL CheckMCICDA (TCHAR chDrive);
#endif // ! USE_IOCTLS

BOOL
CDPlay_CopyData(
    HWND hwnd,
    PCOPYDATASTRUCT lpcpds
    );

/* -------------------------------------------------------------------------
** Private Globals
** -------------------------------------------------------------------------
*/

HBRUSH          g_hBrushBkgd;

TCHAR           g_szTimeSep[10];
int             g_AcceleratorCount;
BOOL            g_fInCopyData = FALSE;

HCURSOR         g_hcurs = NULL;

//---------------------------------------------------------------------------
// Stuff required to make drag/dropping of a shortcut file work on Chicago
//---------------------------------------------------------------------------
BOOL
ResolveLink(
    TCHAR * szFileName
    );

BOOL g_fOleInitialized = FALSE;


/*
** these values are defined by the UI gods...
*/
const int dxButton     = 24;
const int dyButton     = 22;
const int dxBitmap     = 16;
const int dyBitmap     = 16;
const int xFirstButton = 8;


/******************************Public*Routine******************************\
* WinMain
*
*
* Windows recognizes this function by name as the initial entry point
* for the program.  This function calls the application initialization
* routine, if no other instance of the program is running, and always
* calls the instance initialization routine.  It then executes a message
* retrieval and dispatch loop that is the top-level control structure
* for the remainder of execution.  The loop is terminated when a WM_QUIT
* message is received, at which time this function exits the application
* instance by returning the value passed by PostQuitMessage().
*
* If this function must abort before entering the message loop, it
* returns the conventional value NULL.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
HWND PASCAL
WinFake(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow,
    HWND hwndMain,
    IMMFWNotifySink* pSink
    )
{
    g_pSink = pSink;

    g_fBlockNetPrompt = FALSE;

    g_fSelectedOrder = TRUE;
    g_fIntroPlay = FALSE;
    g_fContinuous = FALSE;
    g_fRepeatSingle = FALSE;

#ifdef DBG
    /*
    ** This removes the Gdi batch feature.  It ensures that the screen
    ** is updated after every gdi call - very useful for debugging.
    */
    GdiSetBatchLimit(1);
#endif

    /*
    ** Save the instance handle in static variable, which will be used in
    ** many subsequence calls from this application to Windows.
    */
    g_hInst = hInstance;
    g_lpCmdLine = lpCmdLine;

    InitializeCriticalSection (&g_csTOCSerialize);

    /*
    ** Initialize the cdplayer application.
    */
    CdPlayerStartUp(hwndMain);

    return g_hwndApp;
}


/*****************************Private*Routine******************************\
* InitInstance
*
*
* This function is called at initialization time for every instance of
* this application.  This function performs initialization tasks that
* cannot be shared by multiple instances.
*
* In this case, we save the instance handle in a static variable and
* create and display the main program window.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
InitInstance(
    HANDLE hInstance,
    HWND hwndMain
    )
{
    HWND        hwnd;

    /*
    ** Load in some strings
    */

    _tcscpy( g_szArtistTxt,  IdStr( STR_HDR_ARTIST ) );
    _tcscpy( g_szTitleTxt,   IdStr( STR_HDR_TITLE ) );
    _tcscpy( g_szUnknownTxt, IdStr( STR_UNKNOWN ) );
    _tcscpy( g_szTrackTxt,   IdStr( STR_HDR_TRACK ) );

    g_szTimeSep[0] = TEXT(':');
    g_szTimeSep[1] = g_chNULL;
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_STIME, g_szTimeSep, 10 );


    /*
    ** Initialize the my classes.  We do this here because the dialog
    ** that we are about to create contains two windows on my class.
    ** The dialog would fail to be created if the classes was not registered.
    */
    g_fDisplayT = TRUE;
    InitLEDClass( g_hInst );
    Init_SJE_TextClass( g_hInst );

    WNDCLASS cls;
    cls.lpszClassName  = g_szSJE_CdPlayerClass;
    cls.hCursor        = NULL; //LoadCursor(NULL, IDC_ARROW);
    cls.hIcon          = NULL;
    cls.lpszMenuName   = NULL;
    cls.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
    cls.hInstance      = (HINSTANCE)hInstance;
    cls.style          = CS_DBLCLKS;
    cls.lpfnWndProc    = DefDlgProc;
    cls.cbClsExtra     = 0;
    cls.cbWndExtra     = DLGWINDOWEXTRA;
    if ( !RegisterClass(&cls) )
    {
	    return FALSE;
    }

    g_hcurs = LoadCursor(g_hInst,MAKEINTRESOURCE(IDC_CURSOR_HAND));

    /*
    ** Create a main window for this application instance.
    */
    hwnd = CreateDialog( g_hInst, MAKEINTRESOURCE(IDR_CDPLAYER),
			 hwndMain, (DLGPROC)MainWndProc );


    /*
    ** If window could not be created, return "failure"
    */
    if ( !hwnd )
    {
	    return FALSE;
    }

    g_hwndApp = hwnd;

    return TRUE;
}

/*****************************Private*Routine******************************\
* CdPlayerStartUp
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerStartUp(
    HWND hwndMain
    )
{
    /*
    ** Reseed random generator
    */
    srand( GetTickCount() );


    /*
    ** Set error mode popups for critical errors (like
    ** no disc in drive) OFF.
    */
    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );


    /*
    ** Scan device chain for CDROM devices...   Terminate if none found.
    */
    g_NumCdDevices = ScanForCdromDevices( );

    if ( g_NumCdDevices == 0 )
    {
	    LPTSTR lpstrTitle;
	    LPTSTR lpstrText;

	    lpstrTitle = (TCHAR*)AllocMemory( STR_MAX_STRING_LEN * sizeof(TCHAR) );
	    lpstrText  = (TCHAR*)AllocMemory( STR_MAX_STRING_LEN * sizeof(TCHAR) );

	    _tcscpy( lpstrText, IdStr(STR_NO_CDROMS) );
	    _tcscpy( lpstrTitle, IdStr(STR_CDPLAYER) );

	    MessageBox( NULL, lpstrText, lpstrTitle,
		        MB_APPLMODAL | MB_ICONINFORMATION |
		        MB_OK | MB_SETFOREGROUND );

	    LocalFree( (HLOCAL)lpstrText );
	    LocalFree( (HLOCAL)lpstrTitle );

	    ExitProcess( (UINT)-1 );
    }

#ifndef USE_IOCTLS
    // Make sure we have a functional MCI (CD Audio)
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    GetVersionEx(&os);
    if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
	    if (! CheckMCICDA (g_Devices[0]->drive))
	    {
	        ExitProcess( (UINT)-1 );
	    }
    }
#endif // ! USE_IOCTLS

    /*
    ** Perform initializations that apply to a specific instance
    ** This function actually creates the CdPlayer window.  (Note that it is
    ** not visible yet).  If we get here we know that there is a least one
    ** cdrom device detected which may have a music cd in it.  If it does
    ** contain a music cdrom the table of contents will have been read and
    ** cd database queryed to determine if the music cd is known.  Therefore
    ** on the WM_INITDIALOG message we should update the "Artist", "Title" and
    ** "Track" fields of the track info display and adjust the enable state
    ** of the play buttons.
    */

    if ( !InitInstance( g_hInst, hwndMain ) )
    {
    	FatalApplicationError( STR_TERMINATE );
    }


    /*
    ** Restore ourselves from the ini file
    */
    ReadSettings(NULL);

    /*
    ** Scan command the command line.  If we were given any valid commandline
    ** args we have to adjust the nCmdShow parameter.  (ie.  start minimized
    ** if the user just wants us to play a certain track.  ScanCommandLine can
    ** overide the default playlist for all the cd-rom devices installed.  It
    ** modifies the global flag g_fPlay and returns the index of the first
    ** CD-Rom that should be played.
    */
    g_CurrCdrom = g_LastCdrom = 0;
}

/*****************************Private*Routine******************************\
* CompleteCdPlayerStartUp
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
CompleteCdPlayerStartUp(
    void
    )
{
    int iTrackToSeekTo = -1;
    int i;

    g_fStartedInTray = FALSE;

    /*
    ** Scan command the command line.  If we were given any valid
    ** commandline args we have to adjust the nCmdShow parameter.  (ie.
    ** start minimized if the user just wants us to play a certain
    ** track.  ScanCommandLine can overide the default playlist for all
    ** the cd-rom devices installed.  It modifies the global flag
    ** g_fPlay and returns the index of the first CD-Rom that should be
    ** played.
    **
    */
    g_CurrCdrom = g_LastCdrom = ParseCommandLine( GetCommandLine(),
						  &iTrackToSeekTo, FALSE );
    /*
    ** If the message box prompting the user to insert the correct cd disc in
    ** the drive was displayed, ParseCommandLine will return -1, in which case
    ** find the most suitable drive, also make sure that we don't come up
    ** playing.
    */
    if (g_LastCdrom == -1)
    {
	    g_fPlay = FALSE;
	    g_CurrCdrom = g_LastCdrom = FindMostSuitableDrive();
    }

    for ( i = 0; i < g_NumCdDevices; i++) {

	TimeAdjustInitialize( i );
    }

    /*
    ** All the rescan threads are either dead or in the act of dying.
    ** It is now safe to initalize the time information for each
    ** cdrom drive.
    */
    if ( iTrackToSeekTo != -1 ) {

	PTRACK_PLAY tr;

	tr = PLAYLIST( g_CurrCdrom );
	if ( tr != NULL ) {

	    for( i = 0; i < iTrackToSeekTo; i++, tr = tr->nextplay );

	    TimeAdjustSkipToTrack( g_CurrCdrom, tr );
	}
    }


    /*
    ** if we are in random mode, then we need to shuffle the play lists.
    */

    if (!g_fSelectedOrder)
    {
	    ComputeAndUseShufflePlayLists();
    }
    SetPlayButtonsEnableState();


    /*
    ** Start the heart beat time.  This timer is responsible for:
    **  1. detecting new or ejected cdroms.
    **  2. flashing the LED display if we are in paused mode.
    **  3. Incrementing the LED display if we are in play mode.
    */
    UINT_PTR timerid = SetTimer( g_hwndApp, HEARTBEAT_TIMER_ID, HEARTBEAT_TIMER_RATE,
	      (TIMERPROC)HeartBeatTimerProc );

    if (!g_fPlay)
    {
        //"play" wasn't on the command line, but maybe the user wants it on startup anyway
        HKEY    hKey;
        LONG    lRet;

        lRet = RegOpenKey( HKEY_CURRENT_USER, g_szRegistryKey, &hKey );

        if ( (lRet == ERROR_SUCCESS) )
        {
	        DWORD   dwType, dwLen;

	        dwLen = sizeof( g_fPlay );
	        if ( ERROR_SUCCESS != RegQueryValueEx(hKey, g_szStartCDPlayingOnStart,
				            0L, &dwType, (LPBYTE)&g_fPlay,
				            &dwLen) )
            {
	            g_fPlay = FALSE; //default to not playing
	        }

            RegCloseKey(hKey);
        }
    }

    //Don't start if player was started in tray mode.
    //This prevents the user from getting an unexpected blast on boot.
    if (( g_fPlay ) && (!g_fStartedInTray))
    {
        CdPlayerPlayCmd();
    }

    if (g_CurrCdrom != 0)
    {
        //didn't use the default player, so jump to the new one
        MMONDISCCHANGED mmOnDisc;
        mmOnDisc.nNewDisc = g_CurrCdrom;
        mmOnDisc.fDisplayVolChange = FALSE;
        g_pSink->OnEvent(MMEVENT_ONDISCCHANGED,&mmOnDisc);
    }

    if (g_Devices[g_CurrCdrom]->State & CD_LOADED)
    {
        //need to set track button on main ui
        HWND hwndTrackButton = GetDlgItem(GetParent(g_hwndApp),IDB_TRACK);
        if (hwndTrackButton)
        {
            EnableWindow(hwndTrackButton,TRUE);
        }
    }

	//cd was already playing; let's update the main ui
	if (g_Devices[g_CurrCdrom]->State & CD_PLAYING)
	{
        g_pSink->OnEvent(MMEVENT_ONPLAY,NULL);
	}
}

/******************************Public*Routine******************************\
* MainWndProc
*
* Use the message crackers to dispatch the dialog messages to appropirate
* message handlers.  The message crackers are portable between 16 and 32
* bit versions of Windows.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
INT_PTR CALLBACK
MainWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch ( message ) {

    HANDLE_MSG( hwnd, WM_INITDIALOG,        CDPlay_OnInitDialog );
    HANDLE_MSG( hwnd, WM_DRAWITEM,          CDPlay_OnDrawItem );
    HANDLE_MSG( hwnd, WM_COMMAND,           CDPlay_OnCommand );
    HANDLE_MSG( hwnd, WM_DESTROY,           CDPlay_OnDestroy );
    HANDLE_MSG( hwnd, WM_SIZE,              CDPlay_OnSize );
    HANDLE_MSG( hwnd, WM_ENDSESSION,        CDPlay_OnEndSession );
    HANDLE_MSG( hwnd, WM_WININICHANGE,      CDPlay_OnWinIniChange );
    HANDLE_MSG( hwnd, WM_CTLCOLORSTATIC,    Common_OnCtlColor );
    HANDLE_MSG( hwnd, WM_CTLCOLORDLG,       Common_OnCtlColor );
    HANDLE_MSG( hwnd, WM_MEASUREITEM,       Common_OnMeasureItem );
    HANDLE_MSG( hwnd, WM_NOTIFY,            CDPlay_OnNotify );

    HANDLE_MSG( hwnd, WM_DROPFILES,         CDPlay_OnDropFiles );

    case WM_DEVICECHANGE:
	return CDPlay_OnDeviceChange (hwnd, wParam, lParam);

    case WM_SETFOCUS :
    {
        //move focus to next window in tab order
        HWND hwndNext = GetNextDlgTabItem(GetParent(hwnd),hwnd,FALSE);
        
        //if the next window just lost focus, we need to go the other way
        if (hwndNext == (HWND)wParam)
        {
            hwndNext = GetNextDlgTabItem(GetParent(hwnd),hwnd,TRUE);
        }
        
        SetFocus(hwndNext);

        return 0;
    }
    break;

	case WM_ERASEBKGND:
	return 1;

    case WM_CLOSE:
	return CDPlay_OnClose(hwnd, FALSE);

    case WM_COPYDATA:
	    return CDPlay_CopyData( hwnd,  (PCOPYDATASTRUCT)lParam );

    case WM_CDPLAYER_COPYDATA:
	    return CDPlay_OnCopyData( hwnd,  (PCOPYDATASTRUCT)lParam );

    case WM_NOTIFY_TOC_READ:
	return CDPlay_OnTocRead( (int)wParam );

    case WM_NOTIFY_FIRST_SCAN:
    {
        for ( int i = 0; i < g_NumCdDevices; i++ )
        {
	        RescanDevice( hwnd, i );
        }

        return TRUE;
    }
    break;

    default:
	return FALSE;
    }
}


/*****************************Private*Routine******************************\
* CDPlay_OnInitDialog
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnInitDialog(
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lParam
    )
{
    int     i;

    g_hBrushBkgd = CreateSolidBrush( GetSysColor(COLOR_BTNFACE) );

    EnumChildWindows( hwnd, ChildEnumProc, (LPARAM)hwnd );

    DragAcceptFiles( hwnd, TRUE );

    /*
    ** Initialize and read the TOC for all the detected CD-ROMS
    */
    SetPlayButtonsEnableState();

    for ( i = 0; i < g_NumCdDevices; i++ )
    {
	    ASSERT(g_Devices[i]->State == CD_BEING_SCANNED);
	    ASSERT(g_Devices[i]->hCd == 0L);

	    TimeAdjustInitialize( i );

	    g_Devices[i]->State = CD_NO_CD;
    }

    PostMessage(hwnd,WM_NOTIFY_FIRST_SCAN,0,0);

    return FALSE;
}


/*****************************Private*Routine******************************\
* CDPlay_OnWinIniChange
*
* Updates the time format separator and the LED display
*
* History:
* 29-09-94 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnWinIniChange(
    HWND hwnd,
    LPCTSTR lpszSectionName
    )
{
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_STIME, g_szTimeSep, 10 );
    UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_DISC_TIME | DISPLAY_UPD_TRACK_TIME );
}


/*****************************Private*Routine******************************\
* CDPlay_OnDrawItem
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnDrawItem(
    HWND hwnd,
    const DRAWITEMSTRUCT *lpdis
    )
{
    if (lpdis->CtlType == ODT_MENU)
    {
        return FALSE;
    }

    int         i;

    i = INDEX(lpdis->CtlID);

    switch (lpdis->CtlType) {

    case ODT_BUTTON:

	/*
	** See if the fast foreward or backward buttons has been pressed or
	** released.  If so execute the seek command here.  Do nothing on
	** the WM_COMMAND message.
	*/
	if ( lpdis->CtlID == IDM_PLAYBAR_SKIPBACK
	  || lpdis->CtlID == IDM_PLAYBAR_SKIPFORE ) {

	    if (lpdis->itemAction & ODA_SELECT ) {

		g_AcceleratorCount = 0;
		CdPlayerSeekCmd( hwnd, (lpdis->itemState & ODS_SELECTED),
				 lpdis->CtlID );
	    }
	}

	/*
	** Now draw the button according to the buttons state information.
	*/

/*
    case ODT_COMBOBOX:
	if (lpdis->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) {

	    switch (lpdis->CtlID) {

	    case IDC_ARTIST_NAME:
		DrawDriveItem( lpdis->hDC, &lpdis->rcItem,
			       lpdis->itemData,
			       (ODS_SELECTED & lpdis->itemState) );
		break;

	    }
	}
*/

	return TRUE;
    }
    return FALSE;
}


/*****************************Private*Routine******************************\
* CDPlay_OnCommand
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    )
{
    switch( id )
    {
	    case IDM_NET_CD:
	    {
            MMNET* pNet = (MMNET*)hwndCtl;
            if (pNet->discid==0)
            {
                //if disc id is 0, then we want to manually get the info for the current cd
                GetInternetDatabase(g_CurrCdrom,g_Devices[g_CurrCdrom]->CdInfo.Id,TRUE,TRUE,pNet->hwndCallback,NULL);
            }
            else if ((pNet->discid==-1) || (pNet->fForceNet))
            {
                //if disc id is -1, then we want to get just the batches
                int cdrom = g_CurrCdrom;

                if (pNet->fForceNet)
                {
                    //try to find the correct cdrom for this guy
                    for(int i = 0; i < g_NumCdDevices; i++)
                    {
                        if (pNet->discid == g_Devices[i]->CdInfo.Id)
                        {
                            //if the id was found in the player, physically rescan it
                            pNet->pData2 = NULL;
                            cdrom = i;
                            break;
                        }
                    } //end for
                } //end if force net

                GetInternetDatabase(cdrom,pNet->fForceNet ? pNet->discid : 0,TRUE,TRUE,pNet->hwndCallback,pNet->pData2);
            }
            else
            {
                for(int i = 0; i < g_NumCdDevices; i++)
                {
                    if (pNet->discid == g_Devices[i]->CdInfo.Id)
                    {
                        //don't hit the net, just scan the entry
                        GetInternetDatabase(i,g_Devices[i]->CdInfo.Id,FALSE,TRUE,pNet->hwndCallback,pNet->pData);
                        UpdateDisplay(DISPLAY_UPD_TITLE_NAME|DISPLAY_UPD_LED);
                    }
                } //end for
            }
       
	    }
	    break;

        case IDM_OPTIONS_NORMAL :
        {
            //turn randomness off if it is on
            if (!g_fSelectedOrder)
            {
	            if ( LockALLTableOfContents() )
                {
	                FlipBetweenShuffleAndOrder();
                }
            }
	        g_fRepeatSingle = FALSE;
            g_fIntroPlay = FALSE;
            g_fSelectedOrder = TRUE;
            g_fContinuous = FALSE;
        }
        break;

        case IDM_OPTIONS_RANDOM:
	        if ( LockALLTableOfContents() )
            {
	            g_fSelectedOrder = FALSE;
                ComputeAndUseShufflePlayLists();
                g_fIntroPlay = FALSE;
	            g_fContinuous = TRUE;
                g_fRepeatSingle = FALSE;
	        }
	    break;

        //case IDM_OPTIONS_MULTI:
	    //g_fSingleDisk = !g_fSingleDisk;
	    //break;

        case IDM_OPTIONS_REPEAT_SINGLE :
        {
            //turn randomness off if it is on
            if (!g_fSelectedOrder)
            {
	            if ( LockALLTableOfContents() )
                {
	                FlipBetweenShuffleAndOrder();
                }
            }
	        g_fRepeatSingle = TRUE;
            g_fIntroPlay = FALSE;
            g_fSelectedOrder = TRUE;
            g_fContinuous = FALSE;
        }
        break;

        case IDM_OPTIONS_INTRO:
            //turn randomness off if it is on
            if (!g_fSelectedOrder)
            {
	            if ( LockALLTableOfContents() )
                {
	                FlipBetweenShuffleAndOrder();
                }
            }
	        g_fIntroPlay = TRUE;
            g_fSelectedOrder = TRUE;
	        g_fContinuous = FALSE;
            g_fRepeatSingle = FALSE;
	    break;

        case IDM_OPTIONS_CONTINUOUS:
            //turn randomness off if it is on
            if (!g_fSelectedOrder)
            {
	            if ( LockALLTableOfContents() )
                {
	                FlipBetweenShuffleAndOrder();
                }
            }
	        g_fContinuous = TRUE;
            g_fIntroPlay = FALSE;
            g_fSelectedOrder = TRUE;
            g_fRepeatSingle = FALSE;
	    break;

        case IDM_TIME_REMAINING:
	        g_fDisplayT  = TRUE;
	        g_fDisplayD = g_fDisplayTr = g_fDisplayDr = FALSE;
	        UpdateDisplay( DISPLAY_UPD_LED );
	    break;

        case IDM_TRACK_REMAINING:
	        g_fDisplayTr = TRUE;
	        g_fDisplayD = g_fDisplayDr = g_fDisplayT = FALSE;
	        UpdateDisplay( DISPLAY_UPD_LED );
	    break;

        case IDM_DISC_REMAINING:
	        g_fDisplayDr = TRUE;
	        g_fDisplayD = g_fDisplayTr = g_fDisplayT = FALSE;
    	    UpdateDisplay( DISPLAY_UPD_LED );
	    break;

        case IDM_PLAYBAR_EJECT:
	        CdPlayerEjectCmd();
	    break;

        case IDM_PLAYBAR_PLAY:
	    /*
	    ** If we currently in PLAY mode and the command came from
	    ** a keyboard accelerator then assume that the user really
	    ** means Pause.  This is because the Ctrl-P key sequence
	    ** is a toggle between Play and Paused.  codeNotify is 1 when
	    ** the WM_COMMAND message came from an accelerator and 0 when
	    ** it cam from a menu.
	    */
	    if ((g_State & CD_PLAYING) && (codeNotify == 1))
        {
	        CdPlayerPauseCmd();
	    }
	    else
        {
	        CdPlayerPlayCmd();
	    }
	    break;

        case IDM_PLAYBAR_PAUSE:
	        CdPlayerPauseCmd();
	    break;

        case IDM_PLAYBAR_STOP:
	        CdPlayerStopCmd();
	    break;

        case IDM_PLAYBAR_PREVTRACK:
	    CdPlayerPrevTrackCmd();
	    break;

        case IDM_PLAYBAR_NEXTTRACK:
	    CdPlayerNextTrackCmd();
	    break;

        case IDM_DATABASE_EXIT:
	    PostMessage( hwnd, WM_CLOSE, 0, 0L );
	    break;
    }
}


/******************************Public*Routine******************************\
* CDPlay_OnDestroy
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnDestroy(
    HWND hwnd
    )
{
    int     i;

    for ( i = 0; i < g_NumCdDevices; i++ ) {

	if (g_fStopCDOnExit) {

	    if ( g_Devices[i]->State & CD_PLAYING
	      || g_Devices[i]->State & CD_PAUSED ) {

		  StopTheCdromDrive( i );
	    }
	}

#ifdef USE_IOCTLS
	if ( g_Devices[i]->hCd != NULL ) {
	    CloseHandle( g_Devices[i]->hCd );
	}
#else
	if ( g_Devices[i]->hCd != 0L ) {

	    CloseCdRom( g_Devices[i]->hCd );
	    g_Devices[i]->hCd = 0L;
	}
#endif


    ErasePlayList(i);
    EraseSaveList(i);
    EraseTrackList(i);

	LocalFree( (HLOCAL) g_Devices[i] );

    }

    if (g_hBrushBkgd) {
	DeleteObject( g_hBrushBkgd );
    }

    WinHelp( hwnd, g_HelpFileName, HELP_QUIT, 0 );

    PostQuitMessage( 0 );
}


/******************************Public*Routine******************************\
* CDPlay_OnClose
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnClose(
    HWND hwnd,
    BOOL fShuttingDown
    )
{
    /*
    ** If we are playing or paused and the brain "don't stop playing
    ** on exit" flag set, then we need to tell the user that he is about
    ** to go into stupid mode.  Basically CD Player can only perform as expected
    ** if the user has not mucked about with the play list, hasn't put the
    ** app into random mode or intro play mode or continuous play mode or
    ** multi-disc mode.
    */
    if ( !fShuttingDown && !g_fStopCDOnExit
      && (g_State & (CD_PLAYING | CD_PAUSED) ) ) {

	if ( !g_fSelectedOrder || g_fIntroPlay || g_fContinuous
	  || !g_fSingleDisk || !PlayListMatchesAvailList() ) {

	    TCHAR   s1[256];
	    TCHAR   s2[256];
	    int     iMsgBoxRtn;

	    _tcscpy( s1, IdStr( STR_EXIT_MESSAGE ) );
	    _tcscpy( s2, IdStr( STR_CDPLAYER ) );

	    iMsgBoxRtn = MessageBox( g_hwndApp, s1, s2,
				     MB_APPLMODAL | MB_DEFBUTTON1 |
				     MB_ICONQUESTION | MB_YESNO);

	    if ( iMsgBoxRtn == IDNO ) {
		return TRUE;
	    }

	}
    }

    //WriteSettings();

    return DestroyWindow( hwnd );
}


/*****************************Private*Routine******************************\
* CDPlay_OnEndSession
*
* If the session is really ending make sure that we stop the CD Player
* from playing and that all the ini file stuff is saved away.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnEndSession(
    HWND hwnd,
    BOOL fEnding
    )
{
    if ( fEnding ) {
	CDPlay_OnClose( hwnd, fEnding );
    }
}


/******************************Public*Routine******************************\
* CDPlay_OnSize
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnSize(
    HWND hwnd,
    UINT state,
    int cx,
    int cy
    )
{
    if (g_fIsIconic && (state != SIZE_MINIMIZED)) {
	SetWindowText( hwnd, IdStr( STR_CDPLAYER ) );
    }
    g_fIsIconic = (state == SIZE_MINIMIZED);

    SetWindowPos(GetDlgItem(g_hwndApp,IDC_LED),
	hwnd,
	0,
	0,
	cx,
	cy,
	SWP_NOACTIVATE);
}

/*
* NormalizeNameForMenuDisplay
    This function turns a string like "Twist & Shout" into
    "Twist && Shout" because otherwise it will look like
    "Twist _Shout" in the menu due to the accelerator char
*/
extern "C" void NormalizeNameForMenuDisplay(TCHAR* szInput, TCHAR* szOutput, DWORD cbLen)
{
    ZeroMemory(szOutput,cbLen);
    WORD index1 = 0;
    WORD index2 = 0;
    for (; index1 < _tcslen(szInput); index1++)
    {
        szOutput[index2] = szInput[index1];
        if (szOutput[index2] == TEXT('&'))
        {
            szOutput[++index2] = TEXT('&');
        }
        index2++;
    }
}

/*****************************Private*Routine******************************\
* CDPlay_OnNotify
*
* Time to display the little tool tips.  Also, change the status bar
* so that it displays a longer version of the tool tip text.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT
CDPlay_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR *pnmhdr
    )
{
    return TRUE;
}

BOOL
CDPlay_CopyData(
    HWND hwnd,
    PCOPYDATASTRUCT lpcpds
    )
{
    LPTSTR lpCmdLine;

    // Make a copy of the passed command line as we are not supposed
    // to write into the one passed in the WM_COPYDATA message.
    lpCmdLine = (TCHAR*)AllocMemory( lpcpds->cbData );
    _tcscpy( lpCmdLine, (LPCTSTR)lpcpds->lpData );

    PostMessage (hwnd, WM_CDPLAYER_COPYDATA, 0, (LPARAM)(LPVOID)lpCmdLine);
    return TRUE;
} // End CopyData


  
/*****************************Private*Routine******************************\
* CDPlay_OnCopyData
*
* Handles command lines passed from other intances of CD Player
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnCopyData(
    HWND hwnd,
    PCOPYDATASTRUCT lpcpds
    )
{
    LPTSTR lpCmdLine;
    BOOL fWasPlaying = FALSE;
    BOOL fUpdate;
    int iTrack = -1;
    int iCdRom;

    // Prevent Re-entrancy while
    // we are opening/closing CD's
    if (g_fInCopyData)
	return FALSE;
    g_fInCopyData = TRUE;

    /*
    ** Make a copy of the passed command line as we are not supposed
    ** to write into the one passed in the WM_COPYDATA message.
    */
    //lpCmdLine = AllocMemory( lpcpds->cbData );
    //_tcscpy( lpCmdLine, (LPCTSTR)lpcpds->lpData );

    lpCmdLine = (LPTSTR)(LPVOID)lpcpds;
    if (lpCmdLine == NULL)
    {
	g_fInCopyData = FALSE;
	return 0L;
    }


    iCdRom = ParseCommandLine( lpCmdLine, &iTrack, FALSE );
    if (iCdRom < 0 && iTrack < 0) {
	LocalFree( (HLOCAL)lpCmdLine );
	g_fInCopyData = FALSE;
	    return 0L;
    }

    // Check if it is just an update command?!?
    fUpdate = IsUpdateOptionGiven (lpCmdLine);
    if ((fUpdate) && (iTrack == -1))
    {
	if ((iCdRom >= 0) && (iCdRom < g_NumCdDevices))
	{
		CheckUnitCdrom(iCdRom, TRUE);
	}

	LocalFree( (HLOCAL)lpCmdLine );
	g_fInCopyData = FALSE;
	    return 0L;
    }

    /*
    ** Remember our current playing state as we need to temporarly
    ** stop the CD if it is currently playing.
    */
    if ( g_State & (CD_PLAYING | CD_PAUSED) ) 
    {

#ifdef DBG
	dprintf(TEXT("Auto Stopping"));
#endif

	    while( !LockALLTableOfContents() ) 
	{

		MSG msg;

#if DBG
		dprintf(TEXT("Busy waiting for TOC to become valid!"));
#endif

		GetMessage( &msg, NULL, WM_NOTIFY_TOC_READ, WM_NOTIFY_TOC_READ );
		DispatchMessage( &msg );
	    }

	    CdPlayerStopCmd();
	    fWasPlaying = TRUE;
    }


    /*
    ** Figure what has been passed and act on it accordingly.
    */
    HandlePassedCommandLine( lpCmdLine, FALSE );


    /*
    ** If we were playing make sure that we are still playing the
    ** new track(s)
    */
    if ( fWasPlaying || g_fPlay ) 
    {

#ifdef DBG
	    dprintf(TEXT("Trying to autoplay"));
#endif

	    while( !LockTableOfContents(g_CurrCdrom) ) 
	{

		MSG     msg;

#ifdef DBG
	    dprintf(TEXT("Busy waiting for TOC to become valid!"));
#endif

		GetMessage( &msg, NULL, WM_NOTIFY_TOC_READ, WM_NOTIFY_TOC_READ );
		DispatchMessage( &msg );
	    }

	    CdPlayerPlayCmd();
    }

    /*
    ** Free the local copy of the command line.
    */
    LocalFree( (HLOCAL)lpCmdLine );

    g_fInCopyData = FALSE;
    return 0L;
}


/*****************************Private*Routine******************************\
* CDPlay_OnTocRead
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnTocRead(
    int iDriveRead
    )
{
    static int iNumRead = 0;

    //  This serializes processing between this
    //  function and the various Table of Content Threads
    //  Preventing resource contention on CDROM Multi-Changers.
    EnterCriticalSection (&g_csTOCSerialize);

    /*
    ** Have we finished the initial read of the CD-Rom TOCs ?
    ** If so we have to re-open the device.  We only need to do this
    ** on Daytona because MCI device handles are not shared between threads.
    */
    iNumRead++;

#ifndef USE_IOCTLS
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    GetVersionEx(&os);
    if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
	if (iNumRead <= g_NumCdDevices) {

	    /*
	    ** Now, open the cdrom device on the UI thread.
	    */
	    g_Devices[iDriveRead]->hCd =
		OpenCdRom( g_Devices[iDriveRead]->drive, NULL );
	}
    }
#endif


    /*
    ** This means that one of the threads dedicated to reading the
    ** toc has finished.  iDriveRead contains the relevant cdrom id.
    */
    LockALLTableOfContents();

    if ( g_Devices[iDriveRead]->State & CD_LOADED )
    {
	    /*
	    ** We have a CD loaded, so generate unique ID
	    ** based on TOC information.
	    */
	    g_Devices[iDriveRead]->CdInfo.Id = ComputeNewDiscId( iDriveRead );

	    /*
	    ** Check database for this compact disc
	    */
	    AddFindEntry( iDriveRead, g_Devices[iDriveRead]->CdInfo.Id,
		          &(g_Devices[iDriveRead]->toc) );

        //plop this into the punit table
        //try to find the drive in the unit table
        if (g_pSink)
        {
            LPCDOPT pOpt = (LPCDOPT)g_pSink->GetOptions();
            LPCDOPTIONS pCDOpts = NULL;
            LPCDUNIT pUnit = NULL;

            if (pOpt)
            {
                pCDOpts = pOpt->GetCDOpts();
            }

            if (pCDOpts)
            {
                pUnit = pCDOpts->pCDUnitList;
            }

            //scan the list to find the one we want
            for (int index = 0; index < iDriveRead; index++)
            {
                if (pUnit)
                {
                    pUnit = pUnit->pNext;
                }
            }

            if (pUnit)
            {
                pUnit->dwTitleID = g_Devices[iDriveRead]->CdInfo.Id;
                pUnit->dwNumTracks = g_Devices[iDriveRead]->CdInfo.NumTracks;
                GetTOC(iDriveRead,pUnit->szNetQuery);
                pOpt->DiscChanged(pUnit);
            }
        } //end if gpsink
    }

    /*
    ** If we have completed the initialization of the Cd-Rom drives we can
    ** now complete the startup processing of the application.
    */
    if (iNumRead == g_NumCdDevices)
    {
    	CompleteCdPlayerStartUp();
    }
    else {

	/*
	** if we are in random mode, then we need to shuffle the play lists.
	** but only if we can lock all the cd devices.
	*/

	TimeAdjustInitialize( iDriveRead );

	if ( g_fSelectedOrder == FALSE ) {
	    if ( LockALLTableOfContents() ) {
		ComputeAndUseShufflePlayLists();
	    }
	}

	ComputeDriveComboBox();

	if (iDriveRead == g_CurrCdrom)
    {
	    if (g_fPlay)
        {
            CdPlayerPlayCmd();
        }
	    SetPlayButtonsEnableState();
	}

    }

    LeaveCriticalSection (&g_csTOCSerialize);

    return TRUE;
}


/*****************************Private*Routine******************************\
* CDPlay_OnDeviceChange
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/

BOOL
CDPlay_OnDeviceChange(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT  uiEvent = (UINT)wParam;
    DWORD dwData  = (DWORD)lParam;

    switch (uiEvent)
    {
    case DBT_DEVICEARRIVAL:             // Insertion
    case DBT_DEVICEREMOVECOMPLETE:      // Ejection
	if ((PDEV_BROADCAST_HDR)dwData)
	{
	    switch (((PDEV_BROADCAST_HDR)dwData)->dbch_devicetype)
	    {
	    case DBT_DEVTYP_VOLUME:
		{
		TCHAR chDrive[4] = TEXT("A:\\");
		INT   i,j,drive;
		DWORD dwCurr;
		PDEV_BROADCAST_VOLUME pdbv;
		DWORD dwMask, dwDrives;

		pdbv = (PDEV_BROADCAST_VOLUME)dwData;
		dwMask = pdbv->dbcv_unitmask;
		dwDrives = GetLogicalDrives();
		dwMask &= dwDrives;

		if (dwMask)
		{
			// Check all drives for match
		    for (i = 0; i < 32; i++)
		    {
			dwCurr = 1 << i;
			if (dwCurr & dwMask)
			{
				// Check drive
			    chDrive[0] = TEXT('A') + i;
			    if ( GetDriveType(chDrive) == DRIVE_CDROM ) 
			    {
				    // Find Associated Drive structure
				drive = -1;
				for (j = 0; j < g_NumCdDevices; j++)
				{
				    if (g_Devices[j]->drive == chDrive[0])
					drive = j;
				}
				    // Structure not found, make one
				if (drive == -1)
				{
			    #ifdef DBG
				    dprintf (TEXT("CDPlay_OnDeviceChange - didn't find drive"));
			    #endif
				    if (g_NumCdDevices > MAX_CD_DEVICES)
				    {
					// Error - not enough device slots
					break;
				    }
				    
				    g_Devices[g_NumCdDevices] = (CDROM*)AllocMemory( sizeof(CDROM) );
				    if (NULL == g_Devices[g_NumCdDevices])
				    {
					// Error - unable to get enough memory
					break;
				    }
				    g_Devices[g_NumCdDevices]->drive = chDrive[0];
				    drive = g_NumCdDevices;
				    g_NumCdDevices++;
				}

				    // Insert/Eject new drive
				if (uiEvent == DBT_DEVICEARRIVAL)
                {
				    // Drive has been inserted
				    // The Shell should inform us using 
				    // the AUTOPLAY through WM_COPYDDATA

                    //This is only necessary to detect discs with
                    //more than just redbook audio on them ...
                    //to prevent a double-scan of any discs that
                    //are normal audio, we need to block the "get it now"
                    //net prompt when scanning this way
                    g_fBlockNetPrompt = TRUE;
                    CheckUnitCdrom(drive,TRUE);
                    g_fBlockNetPrompt = FALSE;

		            return FALSE;
				}
				else
                {
				    NoMediaUpdate (drive);
				}
			    }
		   
			}
		    }
		}
		break;
		}

	    default:
		// Not a logical volume message
		break;
	    }
	}
	break;
    
    case DBT_DEVICEQUERYREMOVE:         // Permission to remove a device is requested.
    case DBT_DEVICEQUERYREMOVEFAILED:   // Request to remove a device has been canceled.
    case DBT_DEVICEREMOVEPENDING:       // Device is about to be removed. Can not be denied.
    case DBT_DEVICETYPESPECIFIC:        // Device-specific event.
    case DBT_CONFIGCHANGED:             // Current configuration has changed.
    default:
	break;
    }

    return TRUE;
} // End CDPlay_OnDeviceChange


  
/*****************************Private*Routine******************************\
* CDPlay_OnDropFiles
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnDropFiles(
    HWND hwnd,
    HDROP hdrop
    )
{
    int     cFiles;
    int     cGoodFiles;
    int     iTextLen;
    int     i;
    TCHAR   szFileName[MAX_PATH+3];
    LPTSTR  lpCommandLine;
    BOOL    fWasPlaying = FALSE;

    // Prevent Re-entrancy while we are 
    // Opening and closing CD's
    if (g_fInCopyData)
	return;
    g_fInCopyData = TRUE;


    /*
    ** Determine how many files were passed to us.
    */
    cFiles = DragQueryFile( hdrop, (UINT)-1, (LPTSTR)NULL, 0 );

    /*
    ** Calculate the length of the command line each filename should be
    ** separated by a space character
    */
    iTextLen  = _tcslen( g_szCdplayer );
    iTextLen += _tcslen( g_szPlayOption );
    iTextLen += _tcslen( g_szTrackOption );
    for ( cGoodFiles = cFiles, i = 0; i < cFiles; i++ ) {

	int unused1, unused2;

	DragQueryFile( hdrop, i, szFileName, MAX_PATH );


	if (IsTrackFileNameValid( szFileName, &unused1,
				  &unused2, TRUE, FALSE )) {

	    // Add on 3 extra characters - one for the space and
	    // two for quote marks, we do this because the filename
	    // given may contain space characters.
	    iTextLen += _tcslen( szFileName ) + 2 + 1;
	}
	else {
	    cGoodFiles--;
	}
    }

    /*
    ** If the none of the dropped files are valid tracks just return
    */
    if (cGoodFiles < 1) {
	g_fInCopyData = FALSE;
	    return;
    }


    /*
    ** Allocate a chunk of memory big enough for all the options and
    ** filenames.  Don't forget the NULL.
    */
    lpCommandLine = (TCHAR*)AllocMemory(sizeof(TCHAR) * (iTextLen + 1));


    /*
    ** Add a dummy intial command line arg.  This is because the
    ** first arg is always the name of the invoked application.  We ignore
    ** this paramter.  Also if we are currently playing we need to
    ** add the -play option to command line as well as stop the CD.
    */
    _tcscpy( lpCommandLine, g_szCdplayer );
    if ( g_State & (CD_PLAYING | CD_PAUSED) ) {

	CdPlayerStopCmd();
	fWasPlaying = TRUE;

	_tcscat( lpCommandLine, g_szPlayOption );
    }


    /*
    ** If there is more than one file name specified then we should constuct
    ** a new playlist from the given files.
    */
    if ( cGoodFiles > 1) {
	_tcscat( lpCommandLine, g_szTrackOption );
    }


    /*
    ** Build up the command line.
    */
    for ( i = 0; i < cFiles; i++ ) {

	int unused1, unused2;

	DragQueryFile( hdrop, i, szFileName, MAX_PATH );

	if (IsTrackFileNameValid( szFileName, &unused1,
				  &unused2, TRUE, TRUE )) {

	    _tcscat( lpCommandLine, TEXT("\'") );
	    _tcscat( lpCommandLine, szFileName );
	    _tcscat( lpCommandLine, TEXT("\'") );
	    _tcscat( lpCommandLine, g_szBlank );
	}
    }


    /*
    ** now process the newly constructed command line.
    */
    HandlePassedCommandLine( lpCommandLine, FALSE );


    /*
    ** If we were playing make sure that we are still playing the
    ** new track(s)
    */
    if ( fWasPlaying ) {

	CdPlayerPlayCmd();
    }

    LocalFree( lpCommandLine );
    DragFinish( hdrop );

    g_fInCopyData = FALSE;
}


/*****************************Private*Routine******************************\
* ResolveLink
*
* Takes the shortcut (shell link) file pointed to be szFileName and
* resolves the link returning the linked file name in szFileName.
*
* szFileName must point to at least MAX_PATH amount of TCHARS.  The function
* return TRUE if the link was successfully resolved and FALSE otherwise.
*
* History:
* dd-mm-94 - StephenE - Created
* 03-11-95 - ShawnB - Unicode enabled
*
\**************************************************************************/
BOOL
ResolveLink(
    TCHAR *szFileName
    )
{
    return FALSE;
}
//#endif


/******************************Public*Routine******************************\
* FatalApplicationError
*
* Call this function if something "bad" happens to the application.  It
* displays an error message and then kills itself.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
FatalApplicationError(
    INT uIdStringResource,
    ...
    )
{
    va_list va;
    TCHAR   chBuffer1[ STR_MAX_STRING_LEN ];
    TCHAR   chBuffer2[ STR_MAX_STRING_LEN ];

    /*
    ** Load the relevant messages
    */
    va_start(va, uIdStringResource);
    wvsprintf(chBuffer1, IdStr(uIdStringResource), va);
    va_end(va);

    _tcscpy( chBuffer2, IdStr(STR_FATAL_ERROR) ); /*"CD Player: Fatal Error"*/

    /*
    ** How much of the application do we need to kill
    */

    if (g_hwndApp) {

	if ( IsWindowVisible(g_hwndApp) ) {
	    BringWindowToTop(g_hwndApp);
	}

	MessageBox( g_hwndApp, chBuffer1, chBuffer2,
		    MB_ICONSTOP | MB_OK | MB_APPLMODAL | MB_SETFOREGROUND );

	DestroyWindow( g_hwndApp );

    }
    else {

	MessageBox( NULL, chBuffer1, chBuffer2,
		    MB_APPLMODAL | MB_ICONSTOP | MB_OK | MB_SETFOREGROUND );
    }

    ExitProcess( (UINT)-1 );

}


/******************************Public*Routine******************************\
* IdStr
*
* Loads the given string resource ID into the passed storage.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LPTSTR
IdStr(
    int idResource
    )
{
    static TCHAR    chBuffer[ STR_MAX_STRING_LEN ];

    if (LoadString(g_hInst, idResource, chBuffer, STR_MAX_STRING_LEN) == 0)
    {
	    return TEXT("");
    }

    return chBuffer;

}


/******************************Public*Routine******************************\
* CheckMenuItemIfTrue
*
* If "flag" TRUE the given menu item is checked, otherwise it is unchecked.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckMenuItemIfTrue(
    HMENU hMenu,
    UINT idItem,
    BOOL flag
    )
{
    UINT uFlags;

    if (flag) {
	uFlags = MF_CHECKED | MF_BYCOMMAND;
    }
    else {
	uFlags = MF_UNCHECKED | MF_BYCOMMAND;
    }

    CheckMenuItem( hMenu, idItem, uFlags );
}


/******************************Public*Routine******************************\
* ReadSettings
*
* Read app settings from ini file.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ReadSettings(
    void* pData
    )
{
    LPCDOPT pOpt = NULL;
    LPCDOPTDATA pOptionData = (LPCDOPTDATA)pData;

    //if no option data, get some!
    if (pOptionData == NULL)
    {
        pOpt = (LPCDOPT)g_pSink->GetOptions();
        if( pOpt )
        {
            LPCDOPTIONS pOptions = pOpt->GetCDOpts();
            pOptionData = pOptions->pCDData;
        }
    }

    //if we still don't have it, bail out!
    if (pOptionData == NULL)
    {
        return;
    }

	g_fStopCDOnExit = pOptionData->fExitStop;

    //if being called because of user dialog setting, reset the play mode flag
    if (pData != NULL)
    {
        g_fPlay = pOptionData->fStartPlay;
    }

	if ( g_NumCdDevices < 2 )
    {
	    g_fMultiDiskAvailable = FALSE;
	    g_fSingleDisk = TRUE;
	}
	else {
	    g_fMultiDiskAvailable = TRUE;
        g_fSingleDisk = FALSE;
	}

    g_fDisplayD = FALSE;
    g_fDisplayDr = FALSE;
    g_fDisplayT = FALSE;
    g_fDisplayTr = FALSE;

    switch (pOptionData->fDispMode)
    {
        case CDDISP_CDTIME :
        {
            g_fDisplayD = TRUE;
        }
        break;

        case CDDISP_CDREMAIN :
        {
            g_fDisplayDr = TRUE;
        }
        break;

        case CDDISP_TRACKTIME :
        {
            g_fDisplayT = TRUE;
        }
        break;

        case CDDISP_TRACKREMAIN :
        {
            g_fDisplayTr = TRUE;
        }
        break;
    }

    g_IntroPlayLength = pOptionData->dwIntroTime;

    //set into correct mode
    g_fSelectedOrder = (pOptionData->dwPlayMode != IDM_MODE_RANDOM);

	/*
	** Make sure that the LED display format is correct
	*/
	if ( g_fDisplayT == FALSE && g_fDisplayTr == FALSE
	  && g_fDisplayDr == FALSE && g_fDisplayD == FALSE)
    {
        g_fDisplayT = TRUE;
    }
}

/******************************Public*Routine******************************\
* LockTableOfContents
*
* This function is used to determine if it is valid for the UI thread
* to access the table of contents for the specified CD Rom.  If this
* function returns FALSE the UI thread should NOT touch the table of
* contents for this CD Rom.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
LockTableOfContents(
    int cdrom
    )
{
    DWORD   dwRet;

    if (g_Devices[cdrom]->fIsTocValid) {
	return TRUE;
    }

    if (g_Devices[cdrom]->hThreadToc == NULL) {
	return FALSE;
    }

    dwRet = WaitForSingleObject(g_Devices[cdrom]->hThreadToc, 0L );
    if (dwRet == WAIT_OBJECT_0) {

	GetExitCodeThread( g_Devices[cdrom]->hThreadToc, &dwRet );
	g_Devices[cdrom]->fIsTocValid = (BOOL)dwRet;
	CloseHandle( g_Devices[cdrom]->hThreadToc );
	g_Devices[cdrom]->hThreadToc = NULL;
    }

    return g_Devices[cdrom]->fIsTocValid;
}


/******************************Public*Routine******************************\
* LockAllTableOfContents
*
* This function is used to determine if it is valid for the UI thread
* to access the table of contents for the ALL the cdroms devices.
* The function returns FALSE the UI thread should NOT touch the table of
* contents for any CD Rom.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
LockALLTableOfContents(
    void
    )
{
    BOOL    fLock;
    int     i;

    for (i = 0, fLock = TRUE; fLock && (i < g_NumCdDevices); i++) {
	fLock = LockTableOfContents(i);
    }

    return fLock;
}


/******************************Public*Routine******************************\
* AllocMemory
*
* Allocates a memory of the given size.  This function will terminate the
* application if the allocation failed.  Memory allocated by this function
* must be freed with LocalFree.  The memory should not be locked or unlocked.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LPVOID
AllocMemory(
    UINT uSize
    )
{
    LPVOID lp;
    lp = LocalAlloc( LPTR, uSize );
    if (lp == NULL) {

	/*
	** No memory - no application, simple !
	*/

	FatalApplicationError( STR_FAIL_INIT );
    }

    return lp;
}


/******************************Public*Routine******************************\
* SetPlayButtonsEnableState
*
* Sets the play buttons enable state to match the state of the current
* cdrom device.  See below...
*
*
*                 CDPlayer buttons enable state table
* 
* E=Enabled D=Disabled       Play  Pause  Eject  Stop   Other DataB 
* 
* Disk in use                 D     D      D       D      D     D   
* 
* No music cd or data cdrom   D     D      E       D      D     D   
* 
* Music cd (playing)          D     E      E       E      E     E   
* 
* Music cd (paused)           E     E      E       E      E     E   
* 
* Music cd (stopped)          E     D      E       D      E     E   
* 
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SetPlayButtonsEnableState(
    void
    )
{
    BOOL    fMusicCdLoaded;
    BOOL    fActivePlayList;
    int     i;

    /*
    ** Do we have a music cd loaded.
    */
    if (g_State & (CD_BEING_SCANNED | CD_NO_CD | CD_DATA_CD_LOADED | CD_IN_USE))
    {
	    fMusicCdLoaded = FALSE;
    }
    else
    {
	    fMusicCdLoaded = TRUE;
    }

    /*
    ** Is there an active playlist
    */
    if ( (CDTIME(g_CurrCdrom).TotalMin == 0) && (CDTIME(g_CurrCdrom).TotalSec == 0) )
    {
	    fActivePlayList = FALSE;
    }
    else
    {
    	fActivePlayList = TRUE;
    }

    //tell the main UI about the track button
    HWND hwndTrackButton = GetDlgItem(GetParent(g_hwndApp),IDB_TRACK);
    if (hwndTrackButton)
    {
        EnableWindow(hwndTrackButton,(fMusicCdLoaded & fActivePlayList));
    }

    //just turn off all "old" cdplayer buttons, since they are not used in this app
    EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)], FALSE );
	EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)], FALSE );
	EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_PAUSE)], FALSE );

    /*
    ** Do the remaining buttons
    */

    for ( i = IDM_PLAYBAR_PREVTRACK; i <= IDM_PLAYBAR_NEXTTRACK; i++ )
    {
    	EnableWindow( g_hwndControls[INDEX(i)], FALSE );
    }

    /*
    ** If the drive is in use then we must diable the eject button.
    */
    EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_EJECT)], FALSE );
}


/******************************Public*Routine******************************\
* HeartBeatTimerProc
*
* This function is responsible for.
*
*  1. detecting new or ejected cdroms.
*  2. flashing the LED display if we are in paused mode.
*  3. Incrementing the LED display if we are in play mode.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void CALLBACK
HeartBeatTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    )
{
    static DWORD dwTickCount;
    DWORD   dwMod;

    ++dwTickCount;

    dwMod = (dwTickCount % 6);

    /*
    ** Check for "letting go" of drive every 3 seconds
    */
    if ( 0 == dwMod )
    {
	    for (int i = 0; i < g_NumCdDevices; i++)
        {
            if ( (!(g_Devices[i]->State & CD_EDITING))
              && (!(g_Devices[i]->State & CD_PLAYING)) )
            {
                CheckUnitCdrom(i,FALSE);
            }
        }
    }

    if ( g_State & CD_PLAYING ) {

	if ( LockALLTableOfContents() ) {
	    SyncDisplay();
	}
    }

    /*
    ** If we are paused and NOT skipping flash the display.
    */

    else if ((g_State & CD_PAUSED) && !(g_State & CD_SEEKING)) {

	HWND hwnd;

	switch ( dwMod ) {

	case 2:
	case 5:
	case 8:
	case 11:
	    if ( g_fIsIconic ) {
			//Next two lines removed to fix tooltip bug:<mwetzel 08.26.97>
			//SetWindowText( g_hwndApp, g_szBlank );
			//UpdateWindow( g_hwndApp );
	    }
	    else {

		hwnd = g_hwndControls[INDEX(IDC_LED)];

		g_fFlashLed = TRUE;
		//SetWindowText( hwnd, g_szBlank );
		g_fFlashLed = FALSE;
	    }
	    break;

	case 0:
	case 3:
	case 6:
	case 9:
	    UpdateDisplay( DISPLAY_UPD_LED );
	    break;
	}

    }
}


/******************************Public*Routine******************************\
* SkipBeatTimerProc
*
* This function is responsible for advancing or retreating the current
* playing position.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void CALLBACK
SkipBeatTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    )
{

    /*
    ** Deteremine if it is time to accelerate the skipping frequency.
    */
    switch (++g_AcceleratorCount) {

    case SKIP_ACCELERATOR_LIMIT1:
	KillTimer( hwnd, idEvent );
	SetTimer( hwnd, idEvent, SKIPBEAT_TIMER_RATE2, (TIMERPROC)SkipBeatTimerProc );
	break;

    case SKIP_ACCELERATOR_LIMIT2:
	KillTimer( hwnd, idEvent );
	SetTimer( hwnd, idEvent, SKIPBEAT_TIMER_RATE3, (TIMERPROC)SkipBeatTimerProc );
	break;
    }

    if ( LockALLTableOfContents() ) {
	if ( idEvent == IDM_PLAYBAR_SKIPFORE) {

	    TimeAdjustIncSecond( g_CurrCdrom );

	    /*
	    ** When TimeAjustIncSecond gets to the end of the last track
	    ** it sets CURRTRACK(g_CurrCdrom) equal to NULL.  When this
	    ** occurs we effectively reset the CD Player
	    */
	    if ( CURRTRACK(g_CurrCdrom) == NULL ) {

		if ( g_State & (CD_WAS_PLAYING | CD_PAUSED) ) {

		    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
				 WM_LBUTTONDOWN, 0, 0L );

		    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
				 WM_LBUTTONUP, 0, 0L );
		}
		else {

		    /*
		    ** Seek to the first playable track.
		    */
		    CURRTRACK(g_CurrCdrom) = FindFirstTrack( g_CurrCdrom );
		    if ( CURRTRACK(g_CurrCdrom) != NULL ) {

			TimeAdjustSkipToTrack( g_CurrCdrom,
					       CURRTRACK(g_CurrCdrom) );

			UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME |
				       DISPLAY_UPD_TRACK_NAME );

			SetPlayButtonsEnableState();
		    }
		}
	    }
	}
	else {
	    TimeAdjustDecSecond( g_CurrCdrom );
	}
    }
}


/******************************Public*Routine******************************\
* UpdateDisplay
*
* This routine updates the display according to the flags that
* are passed in.  The display consists of the LED display, the
* track and title names, the disc and track lengths and the cdrom
* combo-box.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
UpdateDisplay(
    DWORD Flags
    )
{
    TCHAR       lpsz[55];
    TCHAR       lpszIcon[75];
    PTRACK_PLAY tr;
    int         track;
    int         mtemp, stemp, m, s;


    /*
    ** Check for valid flags
    */

    if ( Flags == 0 ) {
	return;
    }

    ZeroMemory(lpsz,sizeof(lpsz));

    /*
    ** Grab current track information
    */

    if (CURRTRACK(g_CurrCdrom) != NULL) {

	track = CURRTRACK(g_CurrCdrom)->TocIndex + FIRSTTRACK(g_CurrCdrom);
    }
    else {

	track = 0;
    }

    /*
    ** Update the LED box?
    */


    if (Flags & DISPLAY_UPD_LED) {

	/*
	** Update LED box
	*/

	if (g_fDisplayT) {

	    if (Flags & DISPLAY_UPD_LEADOUT_TIME) {

		wsprintf( lpsz, TRACK_TIME_LEADOUT_FORMAT,
			  //track,
			  CDTIME(g_CurrCdrom).TrackCurMin,
			  g_szTimeSep,
			  CDTIME(g_CurrCdrom).TrackCurSec );
	    }
	    else {

		wsprintf( lpsz, TRACK_TIME_FORMAT,
			  //track,
			  CDTIME(g_CurrCdrom).TrackCurMin,
			  g_szTimeSep,
			  CDTIME(g_CurrCdrom).TrackCurSec );
	    }
	}

	if (g_fDisplayTr) {

	    if (Flags & DISPLAY_UPD_LEADOUT_TIME) {

		wsprintf( lpsz, TRACK_REM_FORMAT, //track - 1,
			  CDTIME(g_CurrCdrom).TrackCurMin,
			  g_szTimeSep,
			  CDTIME(g_CurrCdrom).TrackCurSec );
	    }
	    else {

		wsprintf( lpsz, TRACK_REM_FORMAT, //track,
			  CDTIME(g_CurrCdrom).TrackRemMin,
			  g_szTimeSep,
			  CDTIME(g_CurrCdrom).TrackRemSec );
	    }
	}

    if (g_fDisplayD)
    {
	    /*
	    ** Compute remaining time, then sub from total time
	    */

	    mtemp = stemp = m = s =0;

	    if (CURRTRACK(g_CurrCdrom) != NULL)
        {
		    for ( tr = CURRTRACK(g_CurrCdrom)->nextplay;
		          tr != NULL;
		          tr = tr->nextplay )
            {

		        FigureTrackTime( g_CurrCdrom, tr->TocIndex, &mtemp, &stemp );

		        m+=mtemp;
		        s+=stemp;

		    }

		    m+= CDTIME(g_CurrCdrom).TrackRemMin;
		    s+= CDTIME(g_CurrCdrom).TrackRemSec;
	    }

	    m += (s / 60);
	    s  = (s % 60);

	    CDTIME(g_CurrCdrom).RemMin = m;
	    CDTIME(g_CurrCdrom).RemSec = s;

        //convert to a total number of seconds remaining
        s = (m*60) + s;

        //convert total time to a number of seconds
        DWORD stotal = (CDTIME(g_CurrCdrom).TotalMin*60) + CDTIME(g_CurrCdrom).TotalSec;
 
        //subtract time remaining from total time
        stotal = stotal - s;

	    m  = (stotal / 60);
	    s  = (stotal % 60);

        wsprintf( lpsz, DISC_TIME_FORMAT,
		      m,
		      g_szTimeSep,
		      s);
    }

	if (g_fDisplayDr) {

	    /*
	    ** Compute remaining time
	    */

	    mtemp = stemp = m = s =0;

	    if (CURRTRACK(g_CurrCdrom) != NULL) {

		for ( tr = CURRTRACK(g_CurrCdrom)->nextplay;
		      tr != NULL;
		      tr = tr->nextplay ) {

		    FigureTrackTime( g_CurrCdrom, tr->TocIndex, &mtemp, &stemp );

		    m+=mtemp;
		    s+=stemp;

		}

		m+= CDTIME(g_CurrCdrom).TrackRemMin;
		s+= CDTIME(g_CurrCdrom).TrackRemSec;

	    }

	    m+= (s / 60);
	    s = (s % 60);

	    CDTIME(g_CurrCdrom).RemMin = m;
	    CDTIME(g_CurrCdrom).RemSec = s;

	    wsprintf( lpsz, DISC_REM_FORMAT,
		      CDTIME(g_CurrCdrom).RemMin,
		      g_szTimeSep,
		      CDTIME(g_CurrCdrom).RemSec );
	}

	SetWindowText( g_hwndControls[INDEX(IDC_LED)], lpsz );

    if (Flags != DISPLAY_UPD_LED)
    {
        InvalidateRect(g_hwndControls[INDEX(IDC_LED)],NULL,FALSE);
        UpdateWindow(g_hwndControls[INDEX(IDC_LED)]);
    }


	if (g_fIsIconic) {
		//Next four lines changed to fix tooltip bugs: <mwetzel 08.26.97>
		if( g_Devices[g_CurrCdrom]->State & CD_PAUSED )
			wsprintf( lpszIcon, IdStr( STR_CDPLAYER_PAUSED), lpsz );
		else
			wsprintf( lpszIcon, IdStr( STR_CDPLAYER_TIME ), lpsz );
	    SetWindowText( g_hwndApp, lpszIcon );
	}
    }

    //update the framework window to show the time
    if ((CURRTRACK(g_CurrCdrom)) && (lpsz[0] != TEXT('\0')))
    {    
        //might already be pre-pending track number
        if (lpsz[0] != TEXT('[')) 
        {
            wsprintf(lpszIcon,TEXT("[%i] %s"),CURRTRACK(g_CurrCdrom)->TocIndex+1,lpsz);
        }
        else
        {
            _tcscpy(lpszIcon,lpsz);
        }
        MMSETTITLE mmTitle;
        mmTitle.mmInfoText = MMINFOTEXT_DESCRIPTION;
        mmTitle.szTitle = lpszIcon;
        g_pSink->OnEvent(MMEVENT_SETTITLE,&mmTitle);
    }

    /*
    ** Update Title?
    */

    if (Flags & DISPLAY_UPD_TITLE_NAME)
    {
	    ComputeDriveComboBox( );

	    SetWindowText( g_hwndControls[INDEX(IDC_TITLE_NAME)],
		           (LPCTSTR)TITLE(g_CurrCdrom) );

        //update the framework window to show the title
        MMSETTITLE mmTitle;
        mmTitle.mmInfoText = MMINFOTEXT_TITLE;
        mmTitle.szTitle = TITLE(g_CurrCdrom);
        g_pSink->OnEvent(MMEVENT_SETTITLE,&mmTitle);
    }

}


/******************************Public*Routine******************************\
* Common_OnCtlColor
*
* Here we return a brush to paint the background with.  The brush is the same
* color as the face of a button.  We also set the text background color so
* that static controls draw correctly.  This function is shared with the
* disk info/editing dialog box.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
HBRUSH
Common_OnCtlColor(
    HWND hwnd,
    HDC hdc,
    HWND hwndChild,
    int type
    )
{
    SetBkColor( hdc, GetSysColor(COLOR_BTNFACE) );
    return g_hBrushBkgd;
}

/******************************Public*Routine******************************\
* Common_OnMeasureItem
*
* All items are the same height and width.
*
* We only have to update the height field for owner draw combo boxes and
* list boxes.  This function is shared with the disk edit/info dialog box.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL
Common_OnMeasureItem(
    HWND hwnd,
    MEASUREITEMSTRUCT *lpMeasureItem
    )
{
    if (lpMeasureItem->CtlType == ODT_MENU)
    {
        return FALSE;
    }

    HFONT   hFont;
    int     cyBorder, cyDelta;
    LOGFONT lf;

    hFont = GetWindowFont( hwnd );

    if ( hFont != NULL ) {

	GetObject( hFont, sizeof(lf), &lf );
    }
    else {
	SystemParametersInfo( SPI_GETICONTITLELOGFONT,
		sizeof(lf), (LPVOID)&lf, 0 );
    }

    cyDelta  = ABS( lf.lfHeight ) / 2;
    cyBorder = GetSystemMetrics( SM_CYBORDER );

    //
    // Ensure enough room between chars.
    //
    if (cyDelta < 4 * cyBorder) {
        cyDelta = 4 * cyBorder;
    }

    lpMeasureItem->itemHeight = ABS( lf.lfHeight ) + cyDelta;

    return TRUE;
}

/******************************Public*Routine******************************\
* DrawTrackItem
*
* This routine draws the information in a cell of the track name
* combo box.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
DrawTrackItem(
    HDC hdc,
    const RECT *r,
    DWORD item,
    BOOL selected
    )
{
    SIZE        si;
    int         i;
    int         cxTrk;
    PTRACK_INF  t;
    TCHAR       s[ARTIST_LENGTH];
    TCHAR       szTrk[16];

    /*
    ** Check for invalid items
    */

    if ( item == (DWORD)-1 ) {

	return;
    }

    if ( ALLTRACKS(g_CurrCdrom) == NULL ) {

	return;
    }


    /*
    ** Check selection status, and set up to draw correctly
    */

    if ( selected ) {

	SetBkColor( hdc, GetSysColor( COLOR_HIGHLIGHT ) );
	SetTextColor( hdc, GetSysColor( COLOR_HIGHLIGHTTEXT ) );
    }
    else {

	SetBkColor( hdc, GetSysColor(COLOR_WINDOW));
	SetTextColor( hdc, GetSysColor(COLOR_WINDOWTEXT));
    }

    /*
    ** Get track info
    */

    t = FindTrackNodeFromTocIndex( item, ALLTRACKS( g_CurrCdrom ) );


    if ( (t != NULL) && (t->name != NULL) ) {

	/*
	** Do we need to munge track name (clip to listbox)?
	*/

	wsprintf(szTrk, TEXT("<%02d> "), t->TocIndex + FIRSTTRACK(g_CurrCdrom));
	GetTextExtentPoint( hdc, szTrk, _tcslen(szTrk), &si );
	cxTrk = si.cx;

	i = _tcslen( t->name ) + 1;

	do {
	    GetTextExtentPoint( hdc, t->name, --i, &si );

	} while( si.cx > (r->right - r->left - cxTrk) );

	ZeroMemory( s, TRACK_TITLE_LENGTH * sizeof( TCHAR ) );
	_tcsncpy( s, t->name, i );

    }
    else {

	_tcscpy( s, g_szBlank );
	i = 1;

    }

    /*
    ** Draw track name
    */

    ExtTextOut( hdc, r->left, r->top,
		ETO_OPAQUE | ETO_CLIPPED,
		r, s, i, NULL );

    /*
    ** draw track number
    */
    if ( t != NULL ) {
	ExtTextOut( hdc, r->right - cxTrk, r->top, ETO_CLIPPED,
		    r, szTrk, _tcslen( szTrk ), NULL );
    }

}

/*****************************Private*Routine******************************\
* HandlePassedCommandLine
*
* This function gets called to handle command line options that are passed to
* CDPlayer as the result of the WM_DROPFILES or WM_COPYDATA messages.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
HandlePassedCommandLine(
    LPTSTR lpCmdLine,
    BOOL   fCheckCDRom
    )
{

    int     i;
    int     iTrack = -1, iCDrom;

    iCDrom = ParseCommandLine( lpCmdLine, &iTrack, TRUE );
    if ((iCDrom < 0) || (iCDrom >= g_NumCdDevices))
	return;

    
	// CheckUnitCDRom to reload Table of Contents
    if ( fCheckCDRom ) 
    {

	CheckUnitCdrom(iCDrom, TRUE);

	while( !LockTableOfContents(iCDrom) ) 
	{

		MSG     msg;

	    GetMessage( &msg, NULL, WM_NOTIFY_TOC_READ, WM_NOTIFY_TOC_READ );
		DispatchMessage( &msg );
	    }
    }

#if 0
    if (iCDrom != g_CurrCdrom)
    {
	    HWND hwndBtn = g_hwndControls[INDEX(IDC_ARTIST_NAME)];

	    SwitchToCdrom( iCDrom, TRUE );
	    SetPlayButtonsEnableState();
	    SendMessage( hwndBtn, CB_SETCURSEL, (WPARAM)iCDrom, 0 );
    }
#endif

    /*
    ** Initialize the new play list for each drive.
    */
    for ( i = 0; i < g_NumCdDevices; i++) 
    {
	    TimeAdjustInitialize( i );
    }

    // Set Current Track to specified track
    if ( iTrack != -1 ) 
    {
	    PTRACK_PLAY tr;

	    tr = PLAYLIST( iCDrom );
	    if ( tr != NULL ) 
	{
		for( i = 0; i < iTrack; i++, tr = tr->nextplay );
		    TimeAdjustSkipToTrack( iCDrom, tr );
	    }
    }
}


/******************************Public*Routine******************************\
* IsUpdateOptionGiven
*
* Checks the command line to see if the "-update" option has been passed.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
IsUpdateOptionGiven(
    LPTSTR lpstr
    )
{
    TCHAR   chOption[MAX_PATH];


    /*
    ** Start by converting everything to upper case.
    */
    CharUpperBuff( lpstr, _tcslen(lpstr) );

    /*
    ** The first parameter on the command line is always the
    ** string used invoke the program.  ie cdplayer.exe
    */
    lpstr += _tcsspn( lpstr, g_szBlank );
    lpstr += CopyWord( chOption, lpstr );


    /*
    ** Remove leading space
    */
    lpstr += _tcsspn( lpstr, g_szBlank );


    /*
    ** process any command line options
    */
    while ( (*lpstr == g_chOptionHyphen) || (*lpstr == g_chOptionSlash) ) {

	/*
	** pass over the option delimeter
	*/
	lpstr++;

	/*
	** Copy option and skip over it.
	*/
	lpstr += CopyWord( chOption, lpstr );


	/*
	** Is this the play option ??  If so, don't  bother processing anymore
	** options.
	*/
	if ( 0 == _tcscmp( chOption, g_szUpdate ) ) {

	    return TRUE;
	}

	/*
	** Remove leading space
	*/
	lpstr += _tcsspn( lpstr, g_szBlank );
    }

    return FALSE;
}



/*****************************Private*Routine******************************\
* ParseCommandLine
*
* Here we look to see if we have been asked to play a particular track.
* The format of the command line is:
*
*
*  CDPlayer command options.
*
*  CDPLAYER {Options}
*
*   Options     :   -play | {Sub-Options}
*   Sub-Options :   {-track tracklist} | trackname
*   trackname   :   filename | drive letter
*   tracklist   :   filename+
*
*      -track      A track list if a list of tracks that the user wants
*                  to play.  It overides any play list that may already be stored
*                  for the current cd.
*
*      -play       Start playing the current play list.  If -play is not specified
*                  CD Player seeks to the first track in the play list.
*
*
*   On Windows NT the format of [file] is:
*       d:\track(nn).cda
*
*   where d: is the drive letter of the cdrom that you want to play
*   and \track(nn) is the track number that you want to play.
*
*   Therefore to play track 8 from a cd-rom drive mapped to e:
*
*       cdplayer /play e:\track08.cda
*
*   On Chicago the file is actually a riff CDDA file which contains
*   all the info required to locate the disc and track.
*
* Returns the index of the CD-Rom drive which should be played first.  Can return
* -1 iff the caller passed FALSE for the fQuiet parameter and the message box was
* actually displayed.  This should only occur when the user trys to start a new
* copy of cdplayer passing it the track.cda file of a disk that is not inserted
* in any of the current CD-Drives attached to the machine.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
ParseCommandLine(
    LPTSTR lpstr,
    int *piTrackToSeekTo,
    BOOL fQuiet
    )
{

    TCHAR   chOption[MAX_PATH];
    BOOL    fTrack = FALSE;
    int     iCdRomIndex = -1;  // Assume Failure until proven otherwise
    int     ii;

    for (ii = 0; ii < g_NumCdDevices; ii++) {
    g_Devices[ii]->fKilledPlayList = FALSE;
    }
    

    /*
    ** Start by converting everything to upper case.
    */
    CharUpperBuff( lpstr, _tcslen(lpstr) );

#if DBG
#ifdef UNICODE
    dprintf( TEXT("CD Player Command line : %ls"), lpstr );
#else
    dprintf( "CD Player Command line : %s", lpstr );
#endif
#endif

    /*
    ** The first parameter on the command line is always the
    ** string used invoke the program.  ie cdplayer.exe
    */
    lpstr += _tcsspn( lpstr, g_szBlank );
    lpstr += CopyWord( chOption, lpstr );


    /*
    ** Remove leading space
    */
    lpstr += _tcsspn( lpstr, g_szBlank );


    /*
    ** process any command line options
    */
    while ( (*lpstr == g_chOptionHyphen) || (*lpstr == g_chOptionSlash) ) {

	/*
	** pass over the option delimeter
	*/
	lpstr++;

	/*
	** Copy option and skip over it.
	*/
	lpstr += CopyWord( chOption, lpstr );


	/*
	** Is this a command line option we understand - ignore ones
	** we don't understand.
	*/
	if ( 0 == _tcscmp( chOption, g_szTrack ) )
    {

	    if ( !fTrack )
        {
		    lpstr = ParseTrackList( lpstr, &iCdRomIndex );
		    fTrack = TRUE;
	    }
	}
	else if ( 0 == _tcscmp( chOption, g_szPlay ) )
    {
	    g_fPlay = TRUE;
	}
    else if ( 0 == _tcscmp( chOption, g_szTray) )
    {
        g_fStartedInTray = TRUE;
    }
	else
    {
#if DBG
#ifdef UNICODE
	    dprintf(TEXT("Ignoring unknown option %ls\n"), chOption );
#else
	    dprintf("Ignoring unknown option %s\n", chOption );
#endif
#endif
	}

	/*
	** Remove leading space
	*/
	lpstr += _tcsspn( lpstr, g_szBlank );
    }


    /*
    ** parse remaining command line parameters
    */

    if ( (*lpstr != g_chNULL) && !fTrack) {

	/*
	** Copy track name and skip over it.  Sometimes the shell
	** gives us quoted strings and sometimes it doesn't.  If the
	** string is not quoted assume that remainder of the command line
	** is the track name.
	*/
	if ( (*lpstr == TEXT('\'')) || (*lpstr == TEXT('\"')) ) {
	    lpstr += CopyWord( chOption, lpstr );
	}
	else {
	    _tcscpy(chOption, lpstr);
	}

	if ( IsTrackFileNameValid( chOption, &iCdRomIndex,
				   piTrackToSeekTo, FALSE, fQuiet ) )
    {
        //if the user passed in a track, turn off start-up random mode
        if (!g_fSelectedOrder)
        {
            g_fSelectedOrder = TRUE;
            SendMessage(GetParent(g_hwndApp),WM_COMMAND,MAKEWPARAM(IDM_MODE_NORMAL,0),(LPARAM)0);
        }
	    ResetPlayList( iCdRomIndex );
	}
#if DBG
#ifdef UNICODE
	dprintf(TEXT("Seeking to track %ls\n"), chOption );
#else
	dprintf("Seeking to track %s\n", chOption );
#endif
#endif
    }

    return iCdRomIndex;
}



/*****************************Private*Routine******************************\
* ParseTrackList
*
* Each track is separated by a ' ' character.  The track list is terminated
* by the NULL, '/' or '-' character.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
TCHAR *
ParseTrackList(
    TCHAR *szTrackList,
    int *piCdRomIndex
    )
{
    TCHAR   chTrack[MAX_PATH];
    int     iTrackIndex;
    int     iCdRom = -1;                // Assume failure, until proven otherwise
    BOOL    fPlayListErased = FALSE;


    /*
    ** Remove any stray white space
    */

    szTrackList += _tcsspn( szTrackList, g_szBlank );

    /*
    ** While there are still valid characters to process
    */

    while ( (*szTrackList != g_chNULL)
	 && (*szTrackList != g_chOptionHyphen)
	 && (*szTrackList != g_chOptionSlash) ) {

	/*
	** Copy the track name and skip over it.
	*/
	szTrackList += CopyWord( chTrack, szTrackList );

	/*
	** Now check that we have been given a valid filename
	*/

	if ( IsTrackFileNameValid( chTrack, &iCdRom, &iTrackIndex, TRUE, FALSE ) ) {

	    PTRACK_PLAY     pt;

	    /*
	    ** If this is the first valid file given nuke the
	    ** existing play lists and prepare for a new list.  Note that
	    ** things are complicated by the fact that we could be given
	    ** files from more than one CD-Rom drive.
	    */

	if (! g_Devices[iCdRom]->fKilledPlayList)
	{
		    /*
		    ** Kill the old play and save lists.
		    */

		    ErasePlayList( iCdRom );
		    EraseSaveList( iCdRom );

		    PLAYLIST( iCdRom ) = NULL;
		    SAVELIST( iCdRom ) = NULL;

		    fPlayListErased = TRUE;
		    
		g_Devices[iCdRom]->fKilledPlayList = TRUE;
		    *piCdRomIndex = iCdRom;
	    }

	    pt = (TRACK_PLAY*)AllocMemory( sizeof(TRACK_PLAY) );

	    pt->TocIndex = iTrackIndex;
	    pt->min = 0;
	    pt->sec = 0;

	    /*
	    ** Is this the first track on this devices play list ?
	    */

	    if ( PLAYLIST(iCdRom) == NULL ) {

		PLAYLIST(iCdRom) = pt;
		pt->nextplay = pt->prevplay = NULL;
	    }
	    else {

		/*
		** append this track to the end of the current play list
		*/

		AppendTrackToPlayList( PLAYLIST(iCdRom), pt );
	    }
	}
	else {

	    /*
	    ** Put up a message box warning the user that the given
	    ** track name is invalid and that we can't play it.
	    */

	    ;
	}

	/*
	** Remove any stray white space
	*/
	szTrackList += _tcsspn( szTrackList, g_szBlank );
    }

    /*
    ** If we have erased the play list we have to go off and reset the
    ** saved play list.
    */

    if ( fPlayListErased ) {
	    SAVELIST( iCdRom ) = CopyPlayList( PLAYLIST(iCdRom) );
    }

    return szTrackList;
}



/*****************************Private*Routine******************************\
* CopyWord
*
* Copies one from szSource to szWord - assumes that words are delimited
* by ' ' characters.  szSource MUST point to the begining of the word.
*
* Returns length of word copied.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
CopyWord(
    TCHAR *szWord,
    TCHAR *szSource
    )
{
    int     n, nReturn;

    /*
    ** Copy the track name
    */
    if ( (*szSource == TEXT('\'')) || (*szSource == TEXT('\"')) ) {

	TCHAR ch = *szSource;

	/*
	** Remember which quote character it was
	** According to the DOCS " is invalid in a filename...
	*/

	n = 0;

	/*
	** Move over the initial quote, then copy the filename
	*/

	while ( *++szSource && *szSource != ch ) {
	    szWord[n++] = *szSource;
	}
	nReturn = n + (*szSource == ch ? 2 : 1);
    }
    else {

	n = _tcscspn( szSource, g_szBlank );
	_tcsncpy( szWord, szSource, n );
	nReturn = n;
    }

    szWord[n] = g_chNULL;

    return nReturn;
}



/*****************************Private*Routine******************************\
* IsTrackFileNameValid
*
* This function returns true if the specified filename is a valid CD track.

* On NT track filenames must be of the form:
*   d:\track(n).cda  where d: is the CD-Rom device and \track(n).cda
*                    is the index of the track to be played (starting from 1).
*
* On Chicago the track filename is actually a riff CDDA file which contains
* the track info that we require.
*
* If the filename is valid the function true and sets piCdromIndex and
* piTrackIndex to the correct values.
*
* History:
* 29-09-94 - StephenE - Created
*
\**************************************************************************/
BOOL
IsTrackFileNameValid(
    LPTSTR lpstFileName,
    int *piCdRomIndex,
    int *piTrackIndex,
    BOOL fScanningTracks,
    BOOL fQuiet
    )
{
#define RIFF_RIFF 0x46464952
#define RIFF_CDDA 0x41444443

    RIFFCDA     cda;
	HANDLE          hFile;
    TCHAR       chDriveLetter;
    int         i;
    TCHAR       szFileName[MAX_PATH];
	TCHAR           szPath[MAX_PATH];
    SHFILEINFO  shInfo;
    DWORD       cbRead;


    //
    // If we are not constructing a track play list it is valid to just specify
    // a drive letter, in which case we select that drive and start playing
    // at the first track on it.  All the tracks are played in sequential
    // order.
    //
    if ( !fScanningTracks) {

	//
	// Map the drive letter onto the internal CD-Rom index used by CDPlayer.
	//
	chDriveLetter = *lpstFileName;
	for ( i = 0; i < g_NumCdDevices; i++ ) {

	    if (g_Devices[i]->drive == chDriveLetter) {

		*piCdRomIndex = i;
		break;
	    }
	}

	//
	// If we mapped the drive OK check to see if we should play all
	// the tracks or just the current play list for that drive.  If we
	// didn't map the drive OK assume that its the first part of a
	// RIFF filename and fall through to the code below that opens the
	// RIFF file and parses its contents.
	//
	if ( i != g_NumCdDevices ) {

	    //
	    // If next character is only a colon ':' then play the
	    // the entire disk starting from the first track.
	    //
	    if ( 0 == _tcscmp(lpstFileName + 1, g_szColon) ) {

		*piTrackIndex = 0;
		return TRUE;
	    }

	    //
	    // If the next two characters are colon backslash ":\" then
	    // we seek to the specified drive and play only those tracks that
	    // are in the default playlist for the current disk in that drive.
	    // All we need to do to achive this is return FALSE.
	    //
	    if ( 0 == _tcscmp(lpstFileName + 1, g_szColonBackSlash) ) {
		return FALSE;
	    }
	}
    }


    //
    // Otherwise, open the file and read the CDA info.  The file name may be a
    // link to .cda in which case we need to get the shell to resolve the link for
    // us.  We take a copy of the file name because the ResolveLink function
    // modifies the file name string in place.
    //
    _tcscpy(szFileName, lpstFileName);
    if (0L == SHGetFileInfo( szFileName, 0L, &shInfo,
			     sizeof(shInfo), SHGFI_ATTRIBUTES)) {
	return FALSE;
    }

    if ((shInfo.dwAttributes & SFGAO_LINK) == SFGAO_LINK) {

	if (!g_fOleInitialized)
    {
	    g_fOleInitialized = SUCCEEDED(OleInitialize(NULL));
	}

	if (!ResolveLink(szFileName)) {
	    return FALSE;
	}
    }

	// Make sure file exists
	if (GetFileAttributes (szFileName) == ((DWORD)-1)) {
		// Get Full path to file
		if (0 == SearchPath (NULL, szFileName, NULL, 
							 MAX_PATH, szPath, NULL)) {
			return FALSE;
		}
	} else {
		_tcscpy (szPath, szFileName);
	}

	// Open file and read in CDA info
	hFile = CreateFile (szFileName, GENERIC_READ, 
						FILE_SHARE_READ, NULL, 
						OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE == hFile) {
		return FALSE;
	}
	
	ReadFile(hFile, &cda, sizeof(cda), &cbRead, NULL);
	CloseHandle (hFile);

    //
    // Make sure its a RIFF CDDA file
    //
    if ( (cda.dwRIFF != RIFF_RIFF) || (cda.dwCDDA != RIFF_CDDA) ) {
	return FALSE;
    }

    //
    // Make sure that we have this disc loaded.
    //
    for ( i = 0; i < g_NumCdDevices; i++ ) {

	if (g_Devices[i]->CdInfo.Id == cda.DiscID) {

	    *piCdRomIndex = i;
	    break;
	}
    }


    //
    // If we didn't map the drive OK return FALSE AND set the
    // returned CD-ROM index to -1 but only if the caller asked us
    // to complain about an incorrect CD being inserted in the drive.
    //
    if ( i == g_NumCdDevices ) {

	if (!fQuiet) {
	    AskUserToInsertCorrectDisc(cda.DiscID);
	    *piCdRomIndex = -1;
	}
	return FALSE;
    }

    *piTrackIndex = cda.wTrack - 1;

    return TRUE;
}


/*****************************Private*Routine******************************\
* AppendTrackToPlayList
*
* Appends the TRACK_PLAY record pointed to by pAppend to the end of the
* double linked list pointed to by pHead.
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
AppendTrackToPlayList(
    PTRACK_PLAY pHead,
    PTRACK_PLAY pAppend
    )
{
    PTRACK_PLAY pp = pHead;

    while (pp->nextplay != NULL) {
	pp = pp->nextplay;
    }

    pp->nextplay = pAppend;
    pAppend->prevplay = pp;
    pAppend->nextplay = NULL;

}


/*****************************Private*Routine******************************\
* FindMostSuitableDrive
*
* Tries to determine the best drive to make the current drive.  Returns the
* drive.
*
* We should choose the first disc that is playing if any are playing.
*
* New dstewart: Else choose the drive that is selected in the CDUNIT table
*
* Else we should choose the first disc with a music disk in it if there
* any drives with music discs in them.
*
* Else we should chose the first drive that is available if any of the
* drives are available.
*
* Else just choose the first (ie. zeroth) drive.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
FindMostSuitableDrive(
    void
    )
{
    int     iDisc;

    /*
    ** Check for a playing drive
    */
    for ( iDisc = 0; iDisc < g_NumCdDevices; iDisc++ ) {

	if ( g_Devices[iDisc]->State & (CD_PLAYING | CD_PAUSED) ) {
	    return iDisc;
	}
    }

    //check the current default drive
    LPCDOPT pOpt = (LPCDOPT)g_pSink->GetOptions();
    LPCDOPTIONS pCDOpts = NULL;
    LPCDUNIT pUnit = NULL;
    int iDefDrive = 0;

    if (pOpt)
    {
        pCDOpts = pOpt->GetCDOpts();
    }

    if (pCDOpts)
    {
        pUnit = pCDOpts->pCDUnitList;
    }

    //scan the list to find the one we want
    for (int index = 0; index < g_NumCdDevices; index++)
    {
        if (pUnit)
        {
            if (pUnit->fDefaultDrive)
            {
                iDefDrive = index;

        	    //if this is the default AND it has a disc loaded, go for it
                if ( g_Devices[index]->State & CD_LOADED )
                {
                    return index;
                }
            }

            pUnit = pUnit->pNext;

        }
    }

    /*
    ** Check for a drive with a music disk in it
    */
    for ( iDisc = 0; iDisc < g_NumCdDevices; iDisc++ )
    {
	    if ( g_Devices[iDisc]->State & CD_LOADED )
        {
	        return iDisc;
	    }
    }

    /*
    **  If the default drive is not in use, use it
    */
	if ( (g_Devices[iDefDrive]->State & (CD_BEING_SCANNED | CD_IN_USE)) == 0 )
    {
	    return iDefDrive;
	}

    /*
    ** Check for any drive that is not in use
    */
    for ( iDisc = 0; iDisc < g_NumCdDevices; iDisc++ )
    {
	    if ( (g_Devices[iDisc]->State & (CD_BEING_SCANNED | CD_IN_USE)) == 0 )
        {
	        return iDisc;
	    }
    }

    /*
    **  Ok, no disc are loaded, but all disc are in use, just use the default
    */
    return iDefDrive;
}


/*****************************Private*Routine******************************\
* AskUserToInsertCorrectDisc
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
AskUserToInsertCorrectDisc(
    DWORD dwID
    )
{
    TCHAR   szMsgBoxTitle[32];
    TCHAR   szDiskTitle[TITLE_LENGTH];
    TCHAR   szArtistName[ARTIST_LENGTH];
    TCHAR   szFormat[STR_MAX_STRING_LEN];
    TCHAR   szText[STR_MAX_STRING_LEN + TITLE_LENGTH];

    LPCDDATA pData = (LPCDDATA)g_pSink->GetData();

    _tcscpy(szDiskTitle,g_szNothingThere);

    if(pData)
    {
        //
        // Try to read in title from the options database
        //

        if (pData->QueryTitle(dwID))
        {
            //
            // We found an entry for this disc, so copy all the information
            // from the title database

            LPCDTITLE pCDTitle = NULL;

            if (pData->LockTitle(&pCDTitle,dwID))
            {
                _tcscpy(szDiskTitle,pCDTitle->szTitle);
                _tcscpy(szArtistName,pCDTitle->szArtist);
                pData->UnlockTitle(pCDTitle,FALSE);
            } //end if title locked
        } //end if title found
    }

    /*
    ** If the disk title was found in the database display it.
    */
    if (_tcscmp(szDiskTitle, g_szNothingThere) != 0)
    {
	    _tcscpy( szFormat, IdStr(STR_DISK_NOT_THERE_K) );
	    wsprintf(szText, szFormat, szDiskTitle, szArtistName);
    }
    else
    {
    	_tcscpy( szText, IdStr(STR_DISK_NOT_THERE) );
    }

    //
    // If CD Player is minimized make sure it is restored
    // before displaying the MessageBox
    //
    if (IsIconic(g_hwndApp)) {

	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(g_hwndApp, &wndpl);
	wndpl.showCmd = SW_RESTORE;
	SetWindowPlacement(g_hwndApp, &wndpl);
    }

    _tcscpy( szMsgBoxTitle,  IdStr(STR_CDPLAYER) );
    MessageBox( g_hwndApp, szText, szMsgBoxTitle,
		MB_SETFOREGROUND | MB_ICONINFORMATION | MB_APPLMODAL | MB_OK);
}


#ifndef USE_IOCTLS
BOOL CheckMCICDA (TCHAR chDrive)
{
    DWORD cchLen;
    DWORD dwResult;
    DWORD dwErr;
    CDHANDLE hCD;
    TCHAR szPath[MAX_PATH];
    TCHAR szText[512];
    TCHAR szTitle[MAX_PATH];

    // Make sure the mcicda.dll exists
    cchLen = NUMELEMS(szPath);
    dwResult = SearchPath (NULL, TEXT ("mcicda.dll"), NULL,
			   cchLen, szPath, NULL);
    if ((! dwResult) || 
	    (0xFFFFFFFF == GetFileAttributes (szPath)))
    {
	    // Give Missing MCICDA.DLL error message
	    GetSystemDirectory (szPath, cchLen);

	    _tcscpy( szTitle, IdStr( STR_MCICDA_MISSING ) );
	    wsprintf (szText, szTitle, szPath);
	    _tcscpy( szTitle, IdStr( STR_CDPLAYER ) );
	
	    MessageBox( NULL, szText, szTitle,
				MB_APPLMODAL | MB_ICONINFORMATION |
				MB_OK | MB_SETFOREGROUND );
	    return FALSE;
    }

    // Make sure mcicda.dll service is up and running
    hCD = OpenCdRom (chDrive, &dwErr);
    if (! hCD)
    {
	    // Error loading media device driver.
	    _tcscpy( szText, IdStr( STR_MCICDA_NOT_WORKING ) );
	    _tcscpy( szTitle, IdStr( STR_CDPLAYER ) );
    
	    MessageBox( NULL, szText, szTitle,
				MB_APPLMODAL | MB_ICONINFORMATION |
				MB_OK | MB_SETFOREGROUND );
	    return FALSE;
    }

    // Close Device
    CloseCdRom (hCD);
    return TRUE;
}
#endif // ! USE_IOCTLS


#if DBG
/******************************Public*Routine******************************\
* CDAssert
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CDAssert(
    LPSTR x,
    LPSTR file,
    int line
    )
{
    TCHAR    buff[128];

    wsprintf( buff, TEXT("%s \nat line %d of %s"), x, line, file );
    MessageBox( NULL, buff, TEXT("Assertion Failure:"), MB_APPLMODAL | MB_OK );
}

/******************************Public*Routine******************************\
* dprintf
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
dprintf(
    TCHAR *lpszFormat,
    ...
    )
{
    TCHAR buf[512];
    UINT n;
    va_list va;
    static int iPrintOutput = -1;

    if (iPrintOutput == -1) {
	iPrintOutput = GetProfileInt( TEXT("MMDEBUG"), TEXT("CdPlayer"), 0);
    }

    if (iPrintOutput) {

	n = wsprintf(buf, TEXT("CdPlayer: <%d>"), GetCurrentThreadId() );

	va_start(va, lpszFormat);
	n += wvsprintf(buf+n, lpszFormat, va);
	va_end(va);

	buf[n++] = '\n';
	buf[n] = 0;
	OutputDebugString(buf);
    }

}
#endif // End #ifdef DBG

/******************************Public*Routine******************************\
* ChildEnumProc
*
* Gets the position of each child control window.  As saves the associated
* window handle for later use.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL CALLBACK
ChildEnumProc(
    HWND hwndChild,
    LPARAM hwndParent
    )
{
    int index = 0;

    index = INDEX(GetDlgCtrlID( hwndChild ));

    if ((index > -1) && (index < NUM_OF_CONTROLS))
    {
        g_hwndControls[index] = hwndChild;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\helpids.h ===
// Disc Settings dialog:
#define IDH_CD_DRIVE_NAME           4300
#define IDH_CD_GET_ARTIST           4301
#define IDH_CD_GET_TITLE            4302
#define IDH_CD_PLAY_LISTBOX         4303
#define IDH_CD_ADD                  4304
#define IDH_CD_REMOVE               4305
#define IDH_CD_CLEAR                4306
#define IDH_CD_DEFAULT              4307
#define IDH_CD_TRACK_NAME           4308
#define IDH_CD_TRACK_LISTBOX        4309
#define IDH_CD_SETNAME              4310

// Preferences dialog box           4311
#define IDH_CD_STOP_CD_ON_EXIT      4312
#define IDH_CD_SAVE_ON_EXIT         4313
#define IDH_CD_SHOW_TOOLTIPS        4314
#define IDH_CD_INTRO_LENGTH         4315
#define IDH_CD_DISPLAY_FONT         4316



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\ledwnd.cpp ===
/******************************Module*Header*******************************\
* Module Name: ledwnd.c
*
* Implementation of the LED window.
*
*
* Created: 18-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>             /* required for all Windows applications */
#include <windowsx.h>

#include <string.h>
#include <tchar.h>              /* contains portable ascii/unicode macros */

#include <commctrl.h>

#include "playres.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "literals.h"
#include "trklst.h"

#define DECLARE_DATA
#include "ledwnd.h"
#include "dib.h"

#include "..\cdopt\cdopt.h"

#define WM_LED_INFO_PAINT               (WM_USER+2000) //wparam = draw, lparam = volchanged state
#define WM_LED_MUTE                     (WM_USER+2001) //wparam = unused, lparam = mute flag
#define WM_LED_DOWNLOAD                 (WM_USER+2002) //wparam = unused, lparam = download flag
#define WM_NET_CHANGEPROVIDER           (WM_USER+1002) //wparam = unused, lparam = LPCDPROVIDER
#define VOLUME_STEPS 40
#define VOLUME_SPACING 3
#define VOLUME_DELTA 0x2FF
#define VOLUME_LINE_HEIGHT 28
#define VOLUME_WIDTH 290

#define TOOLID_STATUS       0
#define TOOLID_MODE         1
#define TOOLID_LOGO         2
#define TOOLID_TIME         3
#define TOOLID_TRACKORMUTE  4    
#define TOOLID_TITLE        5
#define TOOLID_TRACK        6
#define TOOLID_ARTIST       7

#define LARGE_MODE_INDICATOR 400

#define LOGO_X_OFFSET 4
#define LOGO_Y_OFFSET 4
#define INFO_AREA_OFFSET 55

#define ANI_NOCD_FRAME 0
#define ANI_STOP_FRAME 1
#define ANI_LAST_PLAY_FRAME 4
#define ANI_PAUSE_FRAME 5

#define MODE_NORMAL_FRAME 0
#define MODE_REPEAT1_FRAME 1
#define MODE_REPEATALL_FRAME 2
#define MODE_INTRO_FRAME 3
#define MODE_RANDOM_FRAME 4

int   g_nLastXOrigin = 0;
BITMAP g_bmLogo;
BOOL g_fAllowDraw = TRUE;
DWORD  g_dwLevel = 0;
TCHAR* g_szMixerName = NULL;
HWND g_hwndPlay = NULL;
HWND g_hwndMode = NULL;
HWND g_hwndDownload = NULL;
DWORD g_dwLastState = CD_NO_CD;
DWORD g_dwLastModeFrame = MODE_NORMAL_FRAME;
COLORREF CurrentColorRef = RGB(0x00,0xFF,0xFF);
BOOL g_fMute = TRUE;
BOOL g_fDownloading = FALSE;
LPCDPROVIDER g_pCurrentProvider = NULL;
RECT g_timerect;
HWND g_hwndToolTips = NULL;
extern HINSTANCE g_hInst;

/* -------------------------------------------------------------------------
** Private functions for the LED class
** -------------------------------------------------------------------------
*/

BOOL
LED_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    );

BOOL
LED_LargeMode(HWND hwnd);

void
LED_OnPaint(
    HWND hwnd
    );

void
LED_OnLButtonUp(
    HWND hwnd,
    int x,
    int y,
    UINT keyFlags
    );

void
LED_OnSetText(
    HWND hwnd,
    LPCTSTR lpszText
    );

void
LED_DrawText(
    HWND hwnd,
    HDC hdcLed,
    LPCTSTR s,
    int sLen
    );

void
LED_Animation(HDC hdc);

void
LED_DrawLogo(
    HWND hwnd,
    HDC hdcLed, RECT* pPaintRect);

void
LED_DrawInfo(
    HWND hwnd,
    HDC hdcLed,
    LPCTSTR s,
    int sLen, RECT* pPaintRect
    );

void
LED_DrawTrackMute(
    HWND hwnd,
    HDC hdcLed, RECT* pPaintRect);

void
LED_CreateLEDFonts(
    HDC hdc
    );

void LED_DrawVolume(
    HWND ledWnd, HDC hdc
    );


HANDLE hbmpLogo = NULL;
HANDLE hbmpVendorLogo = NULL;

/******************************Public*Routine******************************\
* InitLEDClass
*
* Called to register the LED window class and create a font for the LED
* window to use.  This function must be called before the CD Player dialog
* box is created.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
InitLEDClass(
    HINSTANCE hInst
    )
{
    WNDCLASS    LEDwndclass;
    HDC         hdc;

    ZeroMemory( &LEDwndclass, sizeof(LEDwndclass) );

    /*
    ** Register the LED window.
    */
    LEDwndclass.lpfnWndProc     = LEDWndProc;
    LEDwndclass.hInstance       = hInst;
    LEDwndclass.hCursor         = LoadCursor( NULL, IDC_ARROW );
    LEDwndclass.hbrBackground   = (HBRUSH)GetStockObject( BLACK_BRUSH );
    LEDwndclass.lpszClassName   = g_szLEDClassName;
    LEDwndclass.style           = CS_OWNDC;

    hdc = GetDC( GetDesktopWindow() );
    LED_CreateLEDFonts( hdc );
    ReleaseDC( GetDesktopWindow(), hdc );

    return RegisterClass( &LEDwndclass );
}

void LED_OnDestroy(HWND hwnd)
{
    if (hbmpLogo)
    {
        GlobalFree(hbmpLogo);
        hbmpLogo = NULL;
    }

    if ( hLEDFontL != NULL )
    {
        DeleteObject( hLEDFontL );
    }

    if ( hLEDFontS != NULL )
    {
        DeleteObject( hLEDFontS );
    }

    if ( hLEDFontB != NULL )
    {
        DeleteObject( hLEDFontB );
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * LED_OnToolTipNotify
// Called from tool tips to get the text they need to display
////////////////////////////////////////////////////////////////////////////////////////////
VOID LED_OnToolTipNotify(HWND hwnd, LPARAM lParam)
{     
    LPTOOLTIPTEXT lpttt;     
    UINT nID;

    if ((((LPNMHDR) lParam)->code) == TTN_NEEDTEXT) 
    { 
        nID = (UINT)((LPNMHDR)lParam)->idFrom; 
        lpttt = (LPTOOLTIPTEXT)lParam;

        switch (nID)
        {
            case TOOLID_STATUS :
            {
                TCHAR szFormat[30];
                TCHAR szStatus[30];
                LoadString(g_hInst,STR_FORMAT_STATUS,szFormat,sizeof(szFormat)/sizeof(TCHAR));

                if (g_fDownloading)
                {
                    LoadString(g_hInst,STR_STATUS_DOWNLOADING,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                }
                else
                {
                    if (g_State & CD_PLAYING)
                    {
                        LoadString(g_hInst,STR_STATUS_PLAY,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                    }

                    if (g_State & CD_STOPPED)
                    {
                        LoadString(g_hInst,STR_STATUS_STOP,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                    }

                    if (g_State & CD_PAUSED)
                    {
                        LoadString(g_hInst,STR_STATUS_PAUSED,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                    }

                    if ((g_State & CD_NO_CD) || (g_State & CD_DATA_CD_LOADED))
                    {
                        LoadString(g_hInst,STR_STATUS_NODISC,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                    }
                } //end else
                wsprintf(lpttt->szText,szFormat,szStatus);
            }
            break;

            case TOOLID_MODE :
            {
                TCHAR szFormat[30];
                TCHAR szStatus[30];
                LoadString(g_hInst,STR_FORMAT_MODE,szFormat,sizeof(szFormat)/sizeof(TCHAR));
                LoadString(g_hInst,STR_MODE_NORMAL,szStatus,sizeof(szStatus)/sizeof(TCHAR));

                if (g_fContinuous)
                {
                    LoadString(g_hInst,STR_MODE_REPEATALL,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                }

                if (g_fIntroPlay)
                {
                    LoadString(g_hInst,STR_MODE_INTROPLAY,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                }

                if (!g_fSelectedOrder)
                {
                    LoadString(g_hInst,STR_MODE_RANDOM,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                }

                if (g_fRepeatSingle)
                {
                    LoadString(g_hInst,STR_MODE_REPEATONE,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                }

                wsprintf(lpttt->szText,szFormat,szStatus);
            }
            break;

            case TOOLID_LOGO :
            {
                if (g_fDownloading)
                {
                    _tcscpy(lpttt->szText,g_pCurrentProvider->szProviderName);
                }
                else
                {
                    LoadString(g_hInst,STR_LOGO,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
            }
            break;

            case TOOLID_TIME :
            {
                if (g_fDisplayT)
                {
                    LoadString(g_hInst,STR_TRACK_TIME,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }

                if (g_fDisplayTr)
                {
                    LoadString(g_hInst,STR_TRACK_REMAINING,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }

                if (g_fDisplayD)
                {
                    LoadString(g_hInst,STR_DISC_TIME,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }

                if (g_fDisplayDr)
                {
                    LoadString(g_hInst,STR_DISC_REMAINING,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
            }
            break;

            case TOOLID_TRACKORMUTE :
            {
                BOOL fLargeMode = FALSE;
                if (LED_LargeMode(hwnd))
                {
                    fLargeMode = TRUE;
                }

                if ((g_fMute) && (fLargeMode))
                {
                    LoadString(g_hInst,STR_STATUS_MUTE,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
                else
                {
                    LoadString(g_hInst,STR_TRACK_NUMBER,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
            }
            break;

            case TOOLID_TITLE :
            {
                if (g_fAllowDraw)
                {
                    LoadString(g_hInst,STR_TITLE,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
                else
                {
                    LoadString(g_hInst,STR_VOLUME,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
            }
            break;

            case TOOLID_TRACK :
            {
                if (g_fAllowDraw)
                {
                    LoadString(g_hInst,STR_TRACK,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
                else
                {
                    LoadString(g_hInst,STR_VOLUME,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
            }
            break;

            case TOOLID_ARTIST :
            {
                if (g_fAllowDraw)
                {
                    LoadString(g_hInst,STR_ARTIST,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
                else
                {
                    LoadString(g_hInst,STR_VOLUME,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
            }
            break;
        } //end switch
    } 	
    return;
} 

void DoDrawing(HWND hwnd, HDC hdc, RECT* pPaintRect)
{
    int sLen;
    TCHAR s[MAX_PATH];

    sLen = GetWindowText( hwnd, s, sizeof(s)/sizeof(TCHAR));

    RECT wndRect;
    GetClientRect(hwnd,&wndRect);

    HPALETTE hPalOld = SelectPalette(hdc,g_pSink->GetPalette(),FALSE);
    RealizePalette(hdc);

    HDC memDC = CreateCompatibleDC(hdc);
    HPALETTE hPalOldMem = SelectPalette(hdc,g_pSink->GetPalette(),FALSE);
    RealizePalette(hdc);

    SetBkColor( memDC, RGB(0x00,0x00,0x00) );
    SetTextColor( memDC, CurrentColorRef );

    HBITMAP hbmp = CreateCompatibleBitmap(hdc,wndRect.right-wndRect.left,wndRect.bottom-wndRect.top);
    HBITMAP holdBmp = (HBITMAP)SelectObject(memDC,hbmp);
      
    if (LED_LargeMode(hwnd))
    {
        LED_Animation(hdc); //use hdc to ensure the clip rect is not affecting these windows
        LED_DrawLogo(hwnd,memDC,pPaintRect);
        LED_DrawTrackMute(hwnd,memDC,pPaintRect);
        if (g_fAllowDraw)
        {
            LED_DrawInfo(hwnd,memDC, s, sLen,pPaintRect);
        }
        else
        {
            LED_DrawVolume(hwnd,memDC);
        }
    }
    else
    {
        //hide all animations
        ShowWindow(g_hwndPlay,SW_HIDE);
        ShowWindow(g_hwndMode,SW_HIDE);
        if (g_hwndDownload)
        {
            ShowWindow(g_hwndDownload,SW_HIDE);
        }
    }
    
    /*
    ** Draw the LED display text
    */
    LED_DrawText( hwnd, memDC, s, sLen );

    //blit from memory onto display and clean up
    BitBlt(hdc,wndRect.left,wndRect.top,wndRect.right-wndRect.left,wndRect.bottom-wndRect.top,
	   memDC,0,0,SRCCOPY);

    SelectObject(memDC,holdBmp);
    DeleteObject(hbmp);
    SelectPalette(hdc,hPalOld,FALSE);
    RealizePalette(hdc);
    SelectPalette(memDC,hPalOldMem,FALSE);
    RealizePalette(memDC);
    DeleteDC(memDC);

    GetClientRect( hwnd, &wndRect );
    HRGN region = CreateRectRgn(wndRect.left,wndRect.top,wndRect.right,wndRect.bottom);

    SelectClipRgn(hdc, region);
    DeleteObject(region);
}

BOOL LED_OnEraseBackground(HWND hwnd, HDC hdc)
{
    //DoDrawing(hwnd,hdc);
    return TRUE;
}

/******************************Public*Routine******************************\
* LEDWndProc
*
* This routine handles the WM_PAINT and WM_SETTEXT messages
* for the "LED" display window.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
LEDWndProc(
    HWND hwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( message )
    {
        HANDLE_MSG( hwnd, WM_CREATE,    LED_OnCreate );
        HANDLE_MSG( hwnd, WM_DESTROY,   LED_OnDestroy);
        HANDLE_MSG( hwnd, WM_PAINT,     LED_OnPaint );
        HANDLE_MSG( hwnd, WM_LBUTTONUP, LED_OnLButtonUp );
        HANDLE_MSG( hwnd, WM_SETTEXT,   LED_OnSetText );
        HANDLE_MSG( hwnd, WM_ERASEBKGND, LED_OnEraseBackground);

        case WM_NOTIFY :
	    {
            if ((((LPNMHDR)lParam)->code) == TTN_NEEDTEXT)
            {
                LED_OnToolTipNotify(hwnd,lParam);
            }
        }
        break;

        case WM_LBUTTONDOWN :
        case WM_MBUTTONDOWN :
        case WM_RBUTTONDOWN :
        case WM_MOUSEMOVE :
        {
            MSG msg;
            msg.lParam = lParam; 
            msg.wParam = wParam; 
            msg.message = message;
            msg.hwnd = hwnd; 
            SendMessage(g_hwndToolTips, TTM_RELAYEVENT, 0, (LPARAM)&msg);
        }
        break;
        
        case WM_LED_INFO_PAINT :
        {
            g_fAllowDraw = (BOOL)wParam;
            if (!g_fAllowDraw)
            {
                MMONVOLCHANGED* pVolChange = (MMONVOLCHANGED*)lParam;
                g_szMixerName = pVolChange->szLineName;
                g_dwLevel = pVolChange->dwNewVolume;
                InvalidateRect(hwnd,NULL,FALSE);
                UpdateWindow(hwnd);
            }
        }
        break;

        case WM_LED_MUTE :
        {
            g_fMute = (BOOL)lParam;
            InvalidateRect(hwnd,NULL,FALSE);
            UpdateWindow(hwnd);
        }
        break;

        case WM_NET_CHANGEPROVIDER :
        {
            if (g_fDownloading)
            {
                if (hbmpVendorLogo)
                {
                    GlobalFree(hbmpVendorLogo);
                    hbmpVendorLogo = NULL;
                }

                LPCDPROVIDER pProv = (LPCDPROVIDER)lParam;
                if (pProv)
                {
                    hbmpVendorLogo = OpenDIB(pProv->szProviderLogo,-1);
                    g_pCurrentProvider = pProv;

                    //if tool tip is showing, kill it
                    TOOLINFO ti;
                    ti.cbSize = sizeof(ti);
                    if (SendMessage(g_hwndToolTips, TTM_GETCURRENTTOOL, 0,  (LPARAM) (LPTOOLINFO) &ti))
                    {
                        if (ti.uId == TOOLID_LOGO)
                        {
                            //fake a button down
                            MSG msg;
                            msg.lParam = 0; 
                            msg.wParam = 0; 
                            msg.message = WM_LBUTTONDOWN;
                            msg.hwnd = hwnd; 
                            SendMessage(g_hwndToolTips, TTM_RELAYEVENT, 0, (LPARAM)&msg);
                        }
                    }
                }

                InvalidateRect(hwnd,NULL,FALSE);
                UpdateWindow(hwnd);
            } //end if downloading
        }
        break;

        case WM_LED_DOWNLOAD :
        {
            BOOL fDownloading = (BOOL)lParam;
            if (fDownloading == g_fDownloading)
            {
                //can get called multiple times for same mode
                break;
            }

            g_fDownloading = fDownloading;

            if (g_fDownloading)
            {
                //get the path to the vendor logo file
                LPCDOPT pOpts = (LPCDOPT)g_pSink->GetOptions();

                if (pOpts)
                {
                    LPCDOPTIONS pOptions = NULL;
                    pOptions = pOpts->GetCDOpts();

                    if (pOptions)
                    {
                        if (pOptions->pCurrentProvider!=NULL)
                        {
                            hbmpVendorLogo = OpenDIB(pOptions->pCurrentProvider->szProviderLogo,-1);
                            g_pCurrentProvider = pOptions->pCurrentProvider;
                        } //end if current provider ok
                    } //end if poptions ok
                } //end if popts created

                //create the downloading animation
                g_hwndDownload = Animate_Create(hwnd,
                                            IDI_ICON_ANI_DOWN,
                                            WS_CHILD,
                                            g_hInst);

                //headers don't have Animate_OpenEx yet,
                //so just do the straight call
                SendMessage(g_hwndDownload,ACM_OPEN,(WPARAM)g_hInst,
                        (LPARAM)MAKEINTRESOURCE(IDI_ICON_ANI_DOWN));

                //move to the top/left of the window
                RECT anirect;
                GetClientRect(g_hwndDownload,&anirect);
                MoveWindow(g_hwndDownload,
                     LOGO_X_OFFSET,
                     LOGO_Y_OFFSET,
                     anirect.right - anirect.left,
                     anirect.bottom - anirect.top,
                     FALSE);

                Animate_Play(g_hwndDownload,0,-1,-1);

                ShowWindow(g_hwndPlay,SW_HIDE);
                ShowWindow(g_hwndDownload,SW_SHOW);

                if (hbmpVendorLogo)
                {
                    InvalidateRect(hwnd,NULL,FALSE);
                    UpdateWindow(hwnd);
                }
            }
            else
            {
                ShowWindow(g_hwndDownload,SW_HIDE);
                ShowWindow(g_hwndPlay,SW_SHOW);
                DestroyWindow(g_hwndDownload);
                g_hwndDownload = NULL;
                if (hbmpVendorLogo)
                {
                    GlobalFree(hbmpVendorLogo);
                    InvalidateRect(hwnd,NULL,FALSE);
                    UpdateWindow(hwnd);
                }
            }
        }
        break;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}

void LED_SetTool(HWND hwnd, UINT toolID, int left, int top, int right, int bottom)
{
    TOOLINFO ti;
    RECT toolRect;
    BOOL fAddTool = TRUE;

    SetRect(&toolRect,left,top,right,bottom);

    ti.cbSize = sizeof(TOOLINFO); 
 	ti.uFlags = 0; 
	ti.hwnd = hwnd; 
	ti.hinst = g_hInst; 
	ti.uId = toolID; 
	ti.lpszText = LPSTR_TEXTCALLBACK;

	//check to see if tool already exists
    if (SendMessage(g_hwndToolTips, TTM_GETTOOLINFO, 0,  (LPARAM) (LPTOOLINFO) &ti))
    {
        //if tool exists, we don't want to add it ...
        fAddTool = FALSE;

        //... unless the rects have changed
        if (memcmp(&ti.rect,&toolRect,sizeof(RECT)) != 0)
        {
            SendMessage(g_hwndToolTips, TTM_DELTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
            fAddTool = TRUE;
        }
    }

	if (fAddTool)
    {
        SetRect(&ti.rect,left,top,right,bottom);
        SendMessage(g_hwndToolTips, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
    }
}

/*****************************Private*Routine******************************\
* LED_OnCreate
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
LED_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    )
{
    HDC     hdcLed;

    hdcLed = GetDC( hwnd );
    SetTextColor( hdcLed, CurrentColorRef );
    ReleaseDC( hwnd, hdcLed );

    //create the tooltips
    g_hwndToolTips = CreateWindow(TOOLTIPS_CLASS, (LPTSTR) NULL, TTS_ALWAYSTIP | WS_POPUP, 
						CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
						hwnd, (HMENU) NULL, g_hInst, NULL); 

    //determine color depth
    HDC hdcScreen = GetDC(NULL);
    UINT uBPP = GetDeviceCaps(hdcScreen, PLANES) * GetDeviceCaps(hdcScreen, BITSPIXEL);
    ReleaseDC(NULL, hdcScreen);

    //load the logo
    HBITMAP hbmpTemp = NULL;
    if (uBPP == 4) //16-color
    {
        hbmpTemp = (HBITMAP)LoadImage(g_hInst,MAKEINTRESOURCE(IDB_CDLOGO_16),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
    }
    else
    {
        hbmpTemp = (HBITMAP)LoadImage(g_hInst,MAKEINTRESOURCE(IDB_CDLOGO),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
    }
	hbmpLogo = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    GetObject(hbmpTemp,sizeof(g_bmLogo),&g_bmLogo);
    DeleteObject(hbmpTemp);

    g_hwndPlay = Animate_Create(hwnd,
                                IDI_ICON_ANI_PLAY,
                                WS_CHILD,
                                g_hInst);

    //headers don't have Animate_OpenEx yet,
    //so just do the straight call
    SendMessage(g_hwndPlay,ACM_OPEN,(WPARAM)g_hInst,
            (LPARAM)MAKEINTRESOURCE(IDI_ICON_ANI_PLAY));

    //move to the top/left of the window
    RECT anirect;
    GetClientRect(g_hwndPlay,&anirect);
    MoveWindow(g_hwndPlay,
         LOGO_X_OFFSET,
         LOGO_Y_OFFSET,
         anirect.right - anirect.left,
         anirect.bottom - anirect.top,
         FALSE);

    LED_SetTool(hwnd,TOOLID_STATUS,anirect.left,anirect.top,anirect.right,anirect.bottom);

    ShowWindow(g_hwndPlay,SW_SHOW);

    g_hwndMode = Animate_Create(hwnd,
                                IDI_ICON_ANI_MODE,
                                WS_CHILD,
                                g_hInst);

    //headers don't have Animate_OpenEx yet,
    //so just do the straight call
    SendMessage(g_hwndMode,ACM_OPEN,(WPARAM)g_hInst,
            (LPARAM)MAKEINTRESOURCE(IDI_ICON_ANI_MODE));

    //move to the top/left of the window
    GetClientRect(g_hwndMode,&anirect);
    MoveWindow(g_hwndMode,
         (g_bmLogo.bmWidth - (anirect.right - anirect.left)) + LOGO_X_OFFSET,
         LOGO_Y_OFFSET,
         anirect.right - anirect.left,
         anirect.bottom - anirect.top,
         FALSE);

    LED_SetTool(hwnd,TOOLID_MODE,
            (g_bmLogo.bmWidth - (anirect.right - anirect.left)) + LOGO_X_OFFSET,
            LOGO_Y_OFFSET,
            g_bmLogo.bmWidth + LOGO_X_OFFSET,
            LOGO_Y_OFFSET + (anirect.bottom - anirect.top));

    ShowWindow(g_hwndMode,SW_SHOW);

    //set the bounding rect for clicking on the time ... intialize to whole rect
    RECT rcParent;
    GetClientRect(hwnd,&rcParent);
    SetRect(&g_timerect,rcParent.left,rcParent.top,rcParent.right,rcParent.bottom);

    return TRUE;
}

void LED_Animation(HDC hdc)
{
    ShowWindow(g_hwndMode,SW_SHOW);
    
    if (!g_fDownloading)
    {
        ShowWindow(g_hwndPlay,SW_SHOW);

        if (g_State != g_dwLastState)
        {
            g_dwLastState = g_State;
            Animate_Stop(g_hwndPlay);

            if (g_State & CD_PLAYING)
            {
                Animate_Play(g_hwndPlay,ANI_STOP_FRAME,ANI_LAST_PLAY_FRAME,-1);
            }

            if (g_State & CD_STOPPED)
            {
                Animate_Seek(g_hwndPlay,ANI_STOP_FRAME);
            }

            if (g_State & CD_PAUSED)
            {
                Animate_Play(g_hwndPlay,ANI_LAST_PLAY_FRAME,ANI_PAUSE_FRAME,-1);
            }

            if ((g_State & CD_NO_CD) || (g_State & CD_DATA_CD_LOADED))
            {
                Animate_Seek(g_hwndPlay,ANI_NOCD_FRAME);
            }
        }
    }
    else
    {
        if (g_hwndDownload)
        {
            ShowWindow(g_hwndDownload,SW_SHOW);
        }
    }

    RECT rect;
    GetClientRect(g_hwndPlay,&rect);
    
    ExcludeClipRect(hdc,
                    LOGO_X_OFFSET,
                    LOGO_Y_OFFSET,
                    (rect.right - rect.left) + LOGO_X_OFFSET,
                    (rect.bottom - rect.top) + LOGO_Y_OFFSET);


    DWORD dwCurFrame = MODE_NORMAL_FRAME;

    if (g_fContinuous)
    {
        dwCurFrame = MODE_REPEATALL_FRAME;
    }
    if (g_fIntroPlay)
    {
        dwCurFrame = MODE_INTRO_FRAME;
    }
    if (!g_fSelectedOrder)
    {
        dwCurFrame = MODE_RANDOM_FRAME;
    }
    if (g_fRepeatSingle)
    {
        dwCurFrame = MODE_REPEAT1_FRAME;
    }

    if (dwCurFrame != g_dwLastModeFrame)
    {
        g_dwLastModeFrame = dwCurFrame;
        Animate_Seek(g_hwndMode,dwCurFrame);
    }

    GetClientRect(g_hwndMode,&rect);
    ExcludeClipRect(hdc,
                    (g_bmLogo.bmWidth - (rect.right - rect.left)) + LOGO_X_OFFSET,
                    LOGO_Y_OFFSET,
                    g_bmLogo.bmWidth + LOGO_X_OFFSET,
                    (rect.bottom - rect.top) + LOGO_Y_OFFSET);
}

BOOL LED_LargeMode(HWND hwnd)
{
    RECT rcParent;
    GetClientRect(GetParent(hwnd),&rcParent);
    if (rcParent.right - rcParent.left < LARGE_MODE_INDICATOR)
    {
        return FALSE;
    }

    return TRUE;
}

/*****************************Private*Routine******************************\
* LED_OnPaint
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_OnPaint(
    HWND hwnd
    )
{
    PAINTSTRUCT ps;
    HDC         hdcLed;

    hdcLed = BeginPaint( hwnd, &ps );
    DoDrawing(hwnd, hdcLed, &(ps.rcPaint));
    EndPaint( hwnd, &ps );
}



/*****************************Private*Routine******************************\
* LED_OnLButtonUp
*
* Rotate the time remaing buttons and then set the display accordingly.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_OnLButtonUp(
    HWND hwnd,
    int x,
    int y,
    UINT keyFlags
    )
{
    BOOL b, b2;

    /*
    ** If this window is not the master display LED just return
    */
    if ( GetWindowLongPtr(hwnd, GWLP_ID) != IDC_LED )
    {
        return;
    }

    RECT rcParent;
    GetClientRect(GetParent(hwnd),&rcParent);

    POINT pt;
    pt.x = x;
    pt.y = y;
    
    //if we're downloading AND within the logo rect, launch the provider's url
    if ((g_fDownloading) && (g_pCurrentProvider))
    {
        RECT logoRect;
        SetRect(&logoRect,
                LOGO_X_OFFSET,
                (rcParent.bottom - g_bmLogo.bmHeight) - LOGO_Y_OFFSET,
                LOGO_X_OFFSET + g_bmLogo.bmWidth,
                rcParent.bottom - LOGO_Y_OFFSET);

        if (PtInRect(&logoRect,pt))
        {
            ShellExecute(NULL,_TEXT("open"),g_pCurrentProvider->szProviderHome,NULL,_TEXT(""),SW_NORMAL);
            return;
        }
    }

    //if button in time rect AND volume isn't showing, allow click
    if ((PtInRect(&g_timerect,pt)) && (g_fAllowDraw))
    {
        b = g_fDisplayT;
        b2 = g_fDisplayD;
        g_fDisplayD = g_fDisplayTr;
        g_fDisplayT = g_fDisplayDr;
        g_fDisplayDr = b2;
        g_fDisplayTr = b;

        //reset options
        LPCDOPT pOpts = (LPCDOPT)g_pSink->GetOptions();
        if (pOpts)
        {
            LPCDOPTDATA pOptions = pOpts->GetCDOpts()->pCDData;
            if (pOptions)
            {
                if (g_fDisplayT)
                {
                    pOptions->fDispMode = CDDISP_TRACKTIME;
                }

                if (g_fDisplayTr)
                {
                    pOptions->fDispMode = CDDISP_TRACKREMAIN;
                }

                if (g_fDisplayD)
                {
                    pOptions->fDispMode = CDDISP_CDTIME;
                }

                if (g_fDisplayDr)
                {
                    pOptions->fDispMode = CDDISP_CDREMAIN;
                }
            } //end if poptions
            pOpts->UpdateRegistry();
        } //end if popts

        UpdateDisplay( DISPLAY_UPD_LED );
    } //end if point in rect of time
}

void LED_DrawVolume(HWND ledWnd, HDC hdc)
{
    if (g_szMixerName == NULL)
    {
        return;
    }

    //only do it in "large mode"
    if (!LED_LargeMode(ledWnd))
    {
        g_fAllowDraw = TRUE; //allow drawing of title and artist
        return;
    }
    
    RECT volrect, wholerect;
    HWND hwndparent = GetParent(ledWnd);
    GetClientRect(hwndparent,&wholerect);

    //normalize the rect and set new left-hand side
    wholerect.bottom = (wholerect.bottom - wholerect.top);
    wholerect.top = 0;
    wholerect.right = (wholerect.right - wholerect.left);
    wholerect.left = INFO_AREA_OFFSET;

    volrect.bottom = wholerect.bottom - LOGO_Y_OFFSET;
    volrect.top = volrect.bottom - VOLUME_LINE_HEIGHT;
    volrect.left = wholerect.left;
    volrect.right = volrect.left + VOLUME_WIDTH;

    if (volrect.right > g_nLastXOrigin)
    {
        volrect.right = g_nLastXOrigin;
    }

    int nWidth = volrect.right-volrect.left;

    //setup
    HDC memDC = CreateCompatibleDC(hdc);
    HBITMAP hbmp = CreateCompatibleBitmap(hdc,wholerect.right-wholerect.left,wholerect.bottom-wholerect.top);
    HBITMAP holdBmp = (HBITMAP)SelectObject(memDC,hbmp);
    HBRUSH hbrBlack = CreateSolidBrush(RGB(0x00,0x00,0x00));
    HBRUSH hbrBlue = CreateSolidBrush(CurrentColorRef);
    HFONT horgFont = (HFONT)SelectObject(memDC,hLEDFontB);

    int nStepWidth = (nWidth / VOLUME_STEPS);
    int nRectWidth = nStepWidth - VOLUME_SPACING;

    //blank out the background
    FillRect(memDC,&wholerect,hbrBlack);
    DeleteObject(hbrBlack);

    SetTextColor(memDC,CurrentColorRef);
    SetBkColor(memDC, RGB(0x00,0x00,0x00));

    SIZE sz;
    RECT textrect;
    memcpy(&textrect,&wholerect,sizeof(textrect));
        
    GetTextExtentPoint32(memDC, g_szMixerName,_tcslen(g_szMixerName), &sz );
    textrect.right = textrect.left + sz.cx;
    textrect.bottom = volrect.top - 3;
    textrect.top = textrect.bottom - sz.cy;
    ExtTextOut(memDC,textrect.left,textrect.top,ETO_OPAQUE,&textrect,g_szMixerName,_tcslen(g_szMixerName),NULL);

    //draw lines
    float nVolLines = ((float)g_dwLevel / 65535) * VOLUME_STEPS;

    for (int i = 0; i < VOLUME_STEPS; i++)
    {
	    RECT rect;
	    int nLineTop = volrect.top+5;
	    
	    if ((i >= nVolLines) && (i != 0) && (i != VOLUME_STEPS -1))
	    {
	        nLineTop = volrect.bottom - ((volrect.bottom - nLineTop) / 4);
	    }

	    SetRect(&rect,
		    volrect.left + (i * nStepWidth),
		    nLineTop,
		    volrect.left + (i * nStepWidth) + nRectWidth,
		    volrect.bottom);

	    FillRect(memDC,&rect,hbrBlue);
    }

    //blit from memory onto display and clean up
    BitBlt(hdc,wholerect.left,wholerect.top,nWidth,wholerect.bottom-wholerect.top,
	   memDC,wholerect.left,wholerect.top,SRCCOPY);

    SelectObject(memDC,holdBmp);
    SelectObject(memDC,horgFont);
    DeleteDC(memDC);
    DeleteObject(hbmp);
    DeleteObject(hbrBlue);
}

//draws text and excludes its clipping rect
//returns the bottom of the rectangle, so it can be used to do lines of text
int DrawAndExclude(HDC hdc, TCHAR* szText, int xPos, int yPos, int nRight, HWND hwnd, int ToolID)
{
    SIZE sizeText;
    GetTextExtentPoint32( hdc, szText, _tcslen(szText), &sizeText );

    RECT rc;
    rc.top = yPos;
    rc.left = xPos;
    rc.right = nRight;
    rc.bottom = rc.top + sizeText.cy;
    
    DrawText(hdc,szText,-1,&rc,DT_CALCRECT|DT_END_ELLIPSIS|DT_EXPANDTABS|DT_NOPREFIX|DT_SINGLELINE);

    //don't do drawing and clipping, or tooltip, for null strings
    if (_tcslen(szText)>0)
    {
        DrawText(hdc,szText,-1,&rc,DT_END_ELLIPSIS|DT_EXPANDTABS|DT_NOPREFIX|DT_SINGLELINE);
        ExcludeClipRect(hdc,rc.left,rc.top,rc.right,rc.bottom);
        LED_SetTool(hwnd,ToolID, rc.left, rc.top, rc.right, rc.bottom);
    }

    return (rc.bottom);
}

void LED_DrawLogo(HWND hwnd, HDC hdcLed, RECT* pPaintRect)
{
    //check to see if we should even bother
    RECT rcParent;
    GetClientRect(GetParent(hwnd),&rcParent);

    RECT destrect, logorect;
    SetRect(&logorect,LOGO_X_OFFSET,(rcParent.bottom - g_bmLogo.bmHeight) - LOGO_Y_OFFSET,4+g_bmLogo.bmWidth,rcParent.bottom-LOGO_Y_OFFSET);
    if (!IntersectRect(&destrect,&logorect,pPaintRect))
    {
        return; //painting wasn't needed
    }

    HANDLE hLogoOrVendor = hbmpLogo;
    if ((g_fDownloading) && (hbmpVendorLogo))
    {
        hLogoOrVendor = hbmpVendorLogo;
    }

    //draw the bitmap of the cd logo
    DibBlt(hdcLed, // destination DC 
                LOGO_X_OFFSET, // x upper left 
                (rcParent.bottom - g_bmLogo.bmHeight) - LOGO_Y_OFFSET,  // y upper left  
                // The next two lines specify the width and height. 
                -1, 
                -1, 
                hLogoOrVendor,    // source image
                0, 0,      // x and y upper left 
                SRCCOPY,0);  // raster operation

    ExcludeClipRect(hdcLed,LOGO_X_OFFSET,(rcParent.bottom - g_bmLogo.bmHeight) - LOGO_Y_OFFSET,4+g_bmLogo.bmWidth,rcParent.bottom-LOGO_Y_OFFSET);
    LED_SetTool(hwnd,TOOLID_LOGO,LOGO_X_OFFSET,(rcParent.bottom - g_bmLogo.bmHeight) - LOGO_Y_OFFSET,4+g_bmLogo.bmWidth,rcParent.bottom-LOGO_Y_OFFSET);
}

void LED_GetTimeRect(HWND hwnd, HDC hdcLed, LPCTSTR s, int sLen, RECT& rect)
{
    RECT rcParent;
    GetClientRect(GetParent(hwnd),&rcParent);

    HFONT hOrgFont = (HFONT)SelectObject(hdcLed,hLEDFontL);
    
    SIZE sz;
    GetTextExtentPoint32( hdcLed, s, sLen, &sz );
    rect.left = (rcParent.right - sz.cx) - LOGO_X_OFFSET;
    rect.top = (rcParent.bottom - sz.cy) - LOGO_Y_OFFSET;

    rect.bottom = rect.top + sz.cy + 3;
    rect.right  = rcParent.right - 3;

    SelectObject( hdcLed, hOrgFont );
}

void LED_DrawInfo(HWND hwnd, HDC hdcLed, LPCTSTR s, int sLen, RECT* pPaintRect)
{
    //figure out where time text will be, so we don't run into it
    RECT timerect;
    LED_GetTimeRect(hwnd,hdcLed,s,sLen,timerect);
    int xOrigin = timerect.left;

    RECT rcParent;
    GetClientRect(GetParent(hwnd),&rcParent);

    RECT rc;
    rc.bottom = rcParent.bottom;
    rc.top = rcParent.top;
    rc.left = rcParent.left + INFO_AREA_OFFSET;
    rc.right = xOrigin;

    RECT destrect;
    if (!IntersectRect(&destrect,&rc,pPaintRect))
    {
        return; //painting wasn't needed
    }

    HFONT hOrgFont = (HFONT)SelectObject( hdcLed, hLEDFontB );

    TCHAR szDisp[MAX_PATH];
    TCHAR sztrack[MAX_PATH];

    _tcscpy(sztrack,TEXT(""));

    PTRACK_INF t;
    if (CURRTRACK(g_CurrCdrom)!=NULL)
    {
        t = FindTrackNodeFromTocIndex( CURRTRACK(g_CurrCdrom)->TocIndex, ALLTRACKS( g_CurrCdrom ) );
        if (t)
        {
            _tcscpy(sztrack,t->name);
        }
    }

    LoadString(g_hInst, STR_DISPLAY_LABELS, szDisp, sizeof(szDisp)/sizeof(TCHAR));

    DrawText( hdcLed,          // handle to device context
              szDisp, // pointer to string to draw
              -1,       // string length, in characters
              &rc,    // pointer to struct with formatting dimensions
              DT_CALCRECT|DT_EXPANDTABS|DT_NOPREFIX);

    rc.top = rcParent.top + ((rcParent.bottom - rc.bottom)/2);
    rc.bottom = rcParent.bottom + ((rcParent.bottom - rc.bottom)/2);
    rc.right = rc.left;

    TCHAR szTitle[MAX_PATH];
    _tcscpy(szTitle,TITLE(g_CurrCdrom));

    if (_tcslen(szTitle)==0)
    {
        _tcscpy(szTitle,IdStr( STR_NEW_TITLE ));
    }

    int nNextLineTop = 0;
    nNextLineTop = DrawAndExclude(hdcLed,szTitle,rc.right,rc.top,xOrigin,hwnd,TOOLID_TITLE);
    nNextLineTop = DrawAndExclude(hdcLed,sztrack,rc.right,nNextLineTop,xOrigin,hwnd,TOOLID_TRACK);
    DrawAndExclude(hdcLed,ARTIST(g_CurrCdrom),rc.right,nNextLineTop,xOrigin,hwnd,TOOLID_ARTIST);

    SelectObject( hdcLed, hOrgFont );
}

void LED_DrawTrackMute(HWND hwnd, HDC hdcLed, RECT* pPaintRect)
{
    RECT rcParent;
    GetClientRect(GetParent(hwnd),&rcParent);

    //draw the mute status, if present (or track number)
    BOOL fDrawInfo = TRUE;
    RECT muteRect;
    muteRect.top = LOGO_Y_OFFSET;
    muteRect.right = rcParent.right;
    muteRect.left = rcParent.left;
    muteRect.bottom = rcParent.bottom;

    TCHAR mutestr[MAX_PATH];

    if (g_fMute)
    {
        LoadString(g_hInst,STR_MUTE,mutestr,sizeof(mutestr)/sizeof(TCHAR));
    }
    else
    {
        TCHAR tempstr[MAX_PATH];
        LoadString(g_hInst,STR_INIT_TRACK,tempstr,sizeof(tempstr)/sizeof(TCHAR));
        if (CURRTRACK(g_CurrCdrom))
        {
            wsprintf(mutestr,tempstr,(CURRTRACK(g_CurrCdrom)->TocIndex)+1);
        }
        else
        {
            fDrawInfo = FALSE;

            //remove the tooltip
            TOOLINFO ti;
            ti.cbSize = sizeof(TOOLINFO); 
 	        ti.uFlags = 0; 
	        ti.hwnd = hwnd; 
	        ti.hinst = g_hInst; 
	        ti.uId = TOOLID_TRACKORMUTE; 
	        ti.lpszText = LPSTR_TEXTCALLBACK;
            SendMessage(g_hwndToolTips, TTM_DELTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
        }
    }

    if (fDrawInfo)
    {
        HFONT hOldFont;

        hOldFont = (HFONT) SelectObject(hdcLed, hLEDFontB);
        DrawText(hdcLed,mutestr,-1,&muteRect,DT_CALCRECT|DT_SINGLELINE);
        muteRect.left = (rcParent.right - LOGO_X_OFFSET) - (muteRect.right - muteRect.left);
        muteRect.right = rcParent.right - LOGO_X_OFFSET;

        RECT destrect;
        if (IntersectRect(&destrect,&muteRect,pPaintRect))
        {

            if (g_fMute)
            {
                SetTextColor(hdcLed,RGB(0xFF,0x00,0x00));
            }

            DrawText(hdcLed,mutestr,-1,&muteRect,DT_SINGLELINE);
            ExcludeClipRect(hdcLed,muteRect.left,muteRect.top,muteRect.right,muteRect.bottom);
            LED_SetTool(hwnd,TOOLID_TRACKORMUTE,muteRect.left,muteRect.top,muteRect.right,muteRect.bottom);
            SetTextColor( hdcLed, CurrentColorRef );
        }

        // restore font
        SelectObject(hdcLed, hOldFont);

    } //end if draw info
}

/*****************************Private*Routine******************************\
* LED_DrawText
*
* Draws the LED display screen text (quickly).  The text is centered
* vertically and horizontally.  Only the backround is drawn if the g_fFlashed
* flag is set.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_DrawText(
    HWND hwnd,
    HDC hdcLed,
    LPCTSTR s,
    int sLen
    )
{
    RECT        rc;
    SIZE        sz;
    int         xOrigin;
    int         yOrigin;
    BOOL        fLargeMode = FALSE;

    HWND hwndparent = GetParent(hwnd);
    HFONT hOrgFont = NULL;

    RECT rcParent;
    GetClientRect(hwndparent,&rcParent);

    if (LED_LargeMode(hwnd))
    {
        fLargeMode = TRUE;
    }
    else
    {
        //change the string to display the track info
        if (CURRTRACK(g_CurrCdrom))
        {
            TCHAR tempstr[MAX_PATH];
            wsprintf(tempstr,TEXT("[%i] %s"),CURRTRACK(g_CurrCdrom)->TocIndex+1,s);
            _tcscpy((TCHAR*)s,tempstr);
            sLen = _tcslen(s);
        }
    }

    if (fLargeMode)
    {
        hOrgFont = (HFONT)SelectObject(hdcLed,hLEDFontL);
    }
    else
    {
        hOrgFont = (HFONT)SelectObject(hdcLed,hLEDFontS);
    }

    GetTextExtentPoint32( hdcLed, s, sLen, &sz );

    if (fLargeMode)
    {
        xOrigin = (rcParent.right - sz.cx) - LOGO_X_OFFSET;
        yOrigin = (rcParent.bottom - sz.cy) - LOGO_Y_OFFSET;
    }
    else
    {
        xOrigin = ((rcParent.right - rcParent.left) - sz.cx) / 2;
        yOrigin = ((rcParent.bottom - rcParent.top) - sz.cy) / 2;
    }

    if (sLen==1)
    {
        xOrigin = g_nLastXOrigin;
    }
    else
    {
        g_nLastXOrigin = xOrigin;
    }

    if (fLargeMode)
    {
        if (!g_fAllowDraw)
        {
            int nRightClip = INFO_AREA_OFFSET + VOLUME_WIDTH;
            if (nRightClip > xOrigin)
            {
                nRightClip = xOrigin;
            }
            ExcludeClipRect(hdcLed,INFO_AREA_OFFSET,rcParent.top,nRightClip,rcParent.bottom);
        }
    }

    rc.top    = yOrigin;
    rc.bottom = rc.top + sz.cy + 3;
    rc.left   = xOrigin;
    rc.right  = rcParent.right - 3;

    ExtTextOut( hdcLed, xOrigin, rc.top, ETO_OPAQUE, &rc, s, sLen, NULL);
    ExcludeClipRect(hdcLed,rc.left,rc.top,rc.right,rc.bottom);
    
    if (fLargeMode)
    {
        //set time rect to cover just the time values for clicking
        SetRect(&g_timerect,rc.left,rc.top,rc.right,rc.bottom);
    }
    else
    {
        SIZE tracksz;
        tracksz.cx = 0;
        if (CURRTRACK(g_CurrCdrom))
        {
            TCHAR tempstr[MAX_PATH];
            wsprintf(tempstr,TEXT("[%i]"),CURRTRACK(g_CurrCdrom)->TocIndex+1);
            GetTextExtentPoint32( hdcLed, tempstr, _tcslen(tempstr), &tracksz );
            LED_SetTool(hwnd,TOOLID_TRACKORMUTE,rcParent.left,rcParent.top,rc.left+tracksz.cx,rcParent.bottom);
        }
        else
        {
            rc.left = rcParent.left;
        }

        //set time rect to cover the part of the client area that isn't the track
        SetRect(&g_timerect,rc.left+tracksz.cx,rcParent.top,rcParent.right,rcParent.bottom);
    }

    LED_SetTool(hwnd,TOOLID_TIME,g_timerect.left,g_timerect.top,g_timerect.right,g_timerect.bottom);

    HBRUSH hbrBlack = CreateSolidBrush(RGB(0x00,0x00,0x00));

    RECT rectLED;
    GetClientRect(hwnd,&rectLED);
    FillRect(hdcLed,&rectLED,hbrBlack);
    DeleteObject(hbrBlack);

    SelectObject(hdcLed, hOrgFont);
}


/*****************************Private*Routine******************************\
* LED_OnSetText
*
* Change the LED display text.  Calling DefWindowProc ensures that the
* window text is saved correctly.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_OnSetText(
    HWND hwnd,
    LPCTSTR lpszText
    )
{
    DefWindowProc( hwnd, WM_SETTEXT, 0,  (LPARAM)lpszText);

    if (LED_LargeMode(hwnd))
    {
        RECT rect;
        HDC hdc = GetDC(hwnd);
        LED_GetTimeRect(hwnd, hdc, lpszText, _tcslen(lpszText), rect);
        ReleaseDC(hwnd,hdc);
        rect.left = g_nLastXOrigin;
        InvalidateRect(hwnd,&rect,FALSE);
    }
    else
    {
        InvalidateRect(hwnd,NULL,FALSE);
    }

    UpdateWindow(hwnd);
}


/*****************************Private*Routine******************************\
* LED_CreateLEDFonts
*
* Small font is 12pt MS Sans Serif
* Large font is 18pt MS Sans Serif
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
LED_CreateLEDFonts(
    HDC hdc
    )
{
    LOGFONT     lf;
    int         iLogPelsY;


    iLogPelsY = GetDeviceCaps( hdc, LOGPIXELSY );

    ZeroMemory( &lf, sizeof(lf) );

    HFONT hTempFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    GetObject(hTempFont,sizeof(lf),&lf);

    lf.lfHeight = (-9 * iLogPelsY) / 72;    /* 9pt */
    if (lf.lfCharSet == ANSI_CHARSET)
    {
        lf.lfWeight = FW_BOLD;
    }
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;

    hLEDFontS = CreateFontIndirect(&lf);

    lf.lfHeight = (-10 * iLogPelsY) / 72;    /* 10 pt */
    if (lf.lfCharSet == ANSI_CHARSET)
    {
        lf.lfWeight = FW_BOLD;
    }

    hLEDFontB = CreateFontIndirect(&lf);

    lf.lfHeight = (-20 * iLogPelsY) / 72;   /* 20 pt */
    if (lf.lfCharSet == ANSI_CHARSET)
    {
        lf.lfWeight = FW_EXTRABOLD;             /* extra bold */
    }

    hLEDFontL = CreateFontIndirect(&lf);


    /*
    ** If can't create either font set up some sensible defaults.
    */
    if ( hLEDFontL == NULL || hLEDFontS == NULL || hLEDFontB == NULL)
    {
        if ( hLEDFontL != NULL )
        {
            DeleteObject( hLEDFontL );
        }

        if ( hLEDFontS != NULL )
        {
            DeleteObject( hLEDFontS );
        }

        if ( hLEDFontB != NULL )
        {
            DeleteObject( hLEDFontB );
        }

        hLEDFontS = hLEDFontL = hLEDFontB = (HFONT)GetStockObject( ANSI_VAR_FONT );
    }
}


/* -------------------------------------------------------------------------
** Private functions for the Text class
** -------------------------------------------------------------------------
*/
void
Text_OnPaint(
    HWND hwnd
    );

LRESULT CALLBACK
TextWndProc(
    HWND hwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam
    );

void
Text_OnSetText(
    HWND hwnd,
    LPCTSTR lpszText
    );

void
Text_OnSetFont(
    HWND hwndCtl,
    HFONT hfont,
    BOOL fRedraw
    );

/******************************Public*Routine******************************\
* Init_SJE_TextClass
*
* Called to register the text window class .
* This function must be called before the CD Player dialog box is created.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
Init_SJE_TextClass(
    HINSTANCE hInst
    )
{
    WNDCLASS    wndclass;

    ZeroMemory( &wndclass, sizeof(wndclass) );

    /*
    ** Register the Text window.
    */
    wndclass.lpfnWndProc     = TextWndProc;
    wndclass.hInstance       = hInst;
    wndclass.hCursor         = LoadCursor( NULL, IDC_ARROW );
    wndclass.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1);
    wndclass.lpszClassName   = g_szTextClassName;

    return RegisterClass( &wndclass );
}


/******************************Public*Routine******************************\
* TextWndProc
*
* This routine handles the WM_PAINT and WM_SETTEXT messages
* for the "Text" display window.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
TextWndProc(
    HWND hwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( message ) {

    HANDLE_MSG( hwnd, WM_PAINT,     Text_OnPaint );
    HANDLE_MSG( hwnd, WM_SETTEXT,   Text_OnSetText );
    HANDLE_MSG( hwnd, WM_SETFONT,   Text_OnSetFont );
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}



/*****************************Private*Routine******************************\
* Text_OnPaint
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
Text_OnPaint(
    HWND hwnd
    )
{
    PAINTSTRUCT ps;
    TCHAR       s[128];
    int         sLen;
    HDC         hdc;
    RECT        rc;
    HFONT       hfont;
    HFONT       hfontOrg;
    LONG_PTR    lStyle;


    hdc = BeginPaint( hwnd, &ps );

    GetWindowRect( hwnd, &rc );
    MapWindowRect( GetDesktopWindow(), hwnd, &rc );

    lStyle = GetWindowLongPtr( hwnd, GWL_STYLE );
    sLen = GetWindowText( hwnd, s, 128 );
    hfont = (HFONT)GetWindowLongPtr( hwnd, GWLP_USERDATA );
    if ( hfont )
    {
        hfontOrg = (HFONT)SelectObject( hdc, hfont );
    }

    /*
    ** Draw a frame around the window
    */
    DrawEdge( hdc, &rc, EDGE_SUNKEN, BF_RECT );


    /*
    ** Draw the text
    */
    SetBkColor( hdc, GetSysColor( COLOR_BTNFACE ) );
    SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
    rc.left = 1 + (2 * GetSystemMetrics(SM_CXBORDER));

    DrawText( hdc, s, sLen, &rc,
              DT_NOPREFIX | DT_LEFT | DT_VCENTER |
              DT_NOCLIP | DT_SINGLELINE );

    if ( hfontOrg ) {
        SelectObject( hdc, hfontOrg );
    }

    EndPaint( hwnd, &ps );
}


/*****************************Private*Routine******************************\
* Text_OnSetText
*
* Change the text.  Calling DefWindowProc ensures that the
* window text is saved correctly.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
Text_OnSetText(
    HWND hwnd,
    LPCTSTR lpszText
    )
{
    DefWindowProc( hwnd, WM_SETTEXT, 0,  (LPARAM)lpszText);
    InvalidateRect( hwnd, NULL, TRUE );
    UpdateWindow( hwnd );
}


/*****************************Private*Routine******************************\
* Text_OnSetFont
*
* Sets the windows font
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
Text_OnSetFont(
    HWND hwnd,
    HFONT hfont,
    BOOL fRedraw
    )
{
    SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)hfont );
    if ( fRedraw ) {
        InvalidateRect( hwnd, NULL, TRUE );
        UpdateWindow( hwnd );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\scan.h ===
/******************************Module*Header*******************************\
* Module Name: scan.h
*
*
*
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#define TRACK_TYPE_MASK 0x04
#define AUDIO_TRACK     0x00
#define DATA_TRACK      0x04


typedef struct {
    HWND    hwndNotify;
    int     cdrom;
} TOC_THREAD_PARMS;

int
ScanForCdromDevices(
    void
    );

void
ScanningThread(
    HWND hwndDlg
    );

BOOL CALLBACK
ScaningDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

void RescanDevice(
    HWND hwndNotify,
    int cdrom
    );

void
ReadTableOfContents(
    TOC_THREAD_PARMS *pTocThrdParms
    );

void
TableOfContentsThread(
    TOC_THREAD_PARMS *pTocThrdParms
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\mmcomp.cpp ===
// MMComp.cpp : Implementation of DLL Exports.


#include "windows.h"
#include "playres.h"
#include "objbase.h"
#include "initguid.h"
#include "cdplay.h"
#include "tchar.h"

HINSTANCE g_dllInst = NULL;

const CLSID CLSID_CDPlay = {0xE5927147,0x521E,0x11D1,{0x9B,0x97,0x00,0xC0,0x4F,0xA3,0xB6,0x0E}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\ledwnd.h ===
/******************************Module*Header*******************************\
* Module Name: ledwnd.h
*
* Public interface to the LED window implementation
*
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

BOOL
InitLEDClass(
    HINSTANCE hInst
    );

LRESULT CALLBACK
LEDWndProc(
    HWND hwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
Init_SJE_TextClass(
    HINSTANCE hInst
    );


#ifdef DECLARE_DATA
BYTE cr[] = {
    0x8D, 0x8B, 0x8F, 0x89, 0xA9, 0xA5, 0xC5, 0xC3,
    0xA8, 0xD9, 0xE6, 0xEA, 0xF5, 0xE8, 0xFC, 0xAF,
    0xF4, 0xF4, 0xE4, 0xF6, 0xF8, 0xFA, 0xE6, 0xF2,
    0xFC, 0xB9, 0xF8, 0xE2, 0xBC, 0xB0, 0x93, 0x95,
    0xAD, 0xAB, 0xF1, 0xD7, 0xC1, 0xD5, 0xCE, 0xC2,
    0xC6, 0x89, 0xEF, 0xD8, 0xD8, 0xDF, 0xC1, 0xDF,
    0xBD, 0xBB, 0xBF, 0xB9, 0xB9, 0xBF, 0x9B, 0x97,
    0xCC, 0xDC, 0xC9, 0xCF, 0xD9, 0xD9, 0x9E, 0xDD,
    0xB9, 0xE1, 0xEF, 0xCE, 0xCE, 0xC8, 0xCC, 0x8D,
    0xA7, 0xA1, 0xA4, 0xEB, 0x8E, 0xBF, 0xAB, 0xBC,
    0xB5, 0xBC, 0xB3, 0xBD, 0xBA, 0xD8, 0xDC, 0x96,
    0xB6, 0xBD, 0xA8, 0xBE, 0xAB, 0xFD, 0x99, 0xAA,
    0x99, 0xEC, 0xE8, 0xA2, 0x8A, 0x91, 0x8E, 0x88,
    0x86, 0x90, 0xCA, 0xBB, 0x84, 0x84, 0x82, 0x83,
    0x99, 0x81, 0x81, 0xFE, 0xFE, 0xBF, 0x99, 0x9F,
    0x96, 0xD9, 0xAB, 0x8E, 0x95, 0x9E, 0x95, 0xF2,
    0x8A, 0xCC, 0xEB, 0xE8, 0xE1, 0xA5, 0xD2, 0xF5,
    0xE1, 0xEA, 0xE1, 0xEE, 0xFE, 0x80, 0x84, 0x82,
    0x9A, 0x9C, 0x98, 0xBE, 0xB4, 0xF8, 0xF7, 0xF9,
    0xF9, 0xFE, 0xFF, 0xFF, 0xBC, 0xFF, 0xE7, 0xBF,
    0x8D, 0xAC, 0xA8, 0xAE, 0xAE, 0xE9, 0xC7, 0xD2,
    0xDA, 0xC0, 0xCF, 0x8B, 0xEB, 0xDF, 0xC7, 0xC9,
    0xD6, 0xD8, 0xC6, 0xDB, 0xC7, 0xB8, 0xBC, 0xBA,
    0xB2, 0xB4, 0xB0, 0x96, 0x9C, 0xCD, 0xCC, 0xD0,
    0xA4, 0xB4, 0xA1, 0xB7, 0xAD, 0xAA, 0xA8, 0xE7,
    0xE5, 0xC4, 0xC0, 0xC6, 0xC6, 0x8C, 0xA2, 0xA6,
    0xA3, 0xA5, 0xB3, 0xBA, 0xA6, 0xF5, 0x94, 0xB6,
    0xB6, 0xB2, 0xA9, 0xD6, 0xD6, 0x9E, 0xAC, 0xB6,
    0x93, 0x95, 0x8B, 0x82, 0x8A, 0x8A, 0xC6, 0xB7,
    0x81, 0x8C, 0x98, 0x99, 0x95, 0xE0, 0xE4, 0xE2,
    0xFA, 0xFC, 0xF8, 0xDE, 0xD4, 0xBA, 0x84, 0x9E,
    0x9F, 0x90, 0x94, 0x9A, 0x90, 0xDD, 0xAB, 0xB6,
    0xA0, 0xC5, 0xE7, 0xF0, 0xED, 0xE2, 0xE8, 0xA7,
    0xA5, 0x84, 0x80, 0x86, 0x86, 0xDF, 0xE7, 0xEC,
    0xFB, 0xB1, 0xC6, 0xE6, 0xE6, 0xFB, 0xF3, 0xE5,
    0x95, 0x93, 0x97, 0x91, 0x91, 0x97, 0x93, 0x95,
    0x8D, 0x81, 0xC6, 0xCC, 0xC7, 0xD0, 0xCB, 0xC2,
    0xC6, 0xDD, 0xCB, 0xDF, 0xC5, 0xC2, 0xC0, 0x8F,
    0x9D, 0xBC, 0xB8, 0xBE, 0xBE, 0xF9, 0xD7, 0xC2,
    0xCA, 0xD8, 0x9A, 0xE8, 0xD4, 0xD8, 0xCE, 0xCF,
    0xA1, 0xB3, 0xA6, 0xCE, 0xCE, 0x82, 0xA7, 0xBE,
    0xA4, 0xAC, 0xEA, 0x9B, 0xA5, 0xAE, 0xA5, 0xAA,
    0xBE, 0xDC, 0xD8, 0xDE, 0xDE, 0xD8, 0xDC, 0xFA,
    0xF8, 0xB8, 0xBE, 0xB6, 0xB5, 0xB3, 0xB7, 0xAC,
    0x94, 0x93, 0x83, 0x97, 0x8D, 0x93, 0x83, 0xC7,
    0xC5, 0xE4, 0xE0, 0xE6, 0xE6, 0xA1, 0x8F, 0x9A,
    0x82, 0x98, 0x97, 0xD3, 0xB7, 0x99, 0x97, 0x8E,
    0x8C, 0x96, 0x94, 0xF6, 0xF6, 0xB7, 0x97, 0x93,
    0xEC, 0xA1, 0xCA, 0xE6, 0xE5, 0xE9, 0x8B, 0x8D,
    0x85, 0x83, 0x87, 0x81, 0xA1, 0xAD, 0xEA, 0xEA,
    0xF4, 0xF8, 0xF1, 0xF2, 0xE0, 0xF0, 0xF2, 0xB7,
    0xEC, 0xF6, 0xBA, 0xB6, 0x91, 0x97, 0x93, 0x95,
    0xF0, 0xC4, 0xCC, 0xC6, 0xC8, 0xCA, 0xD6, 0xC2,
    0x88, 0xEB, 0xD8, 0xC4, 0xC3, 0xC0, 0xCB, 0xDD,
    0xBD, 0xBB, 0xBF, 0xB9, 0xB9, 0xBF, 0xBB, 0xBD,
    0xB5, 0xB3, 0xB7, 0xB1, 0xB1, 0xB7, 0xFE, 0xB2,
    0xCA, 0xDB
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\trklst.h ===
/******************************Module*Header*******************************\
* Module Name: trklst.h
*
* This module manipulates the cdrom track list.  The table of contents MUST
* be locked for ALL cdrom devices before calling any functions in this module.
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

void
ComputeDriveComboBox(
    void
    );

void
SwitchToCdrom(
    int NewCdrom,
    BOOL prompt
    );

PTRACK_INF
FindTrackNodeFromTocIndex(
    int tocindex,
    PTRACK_INF listhead
    );

PTRACK_PLAY
FindFirstTrack(
    int cdrom
    );

PTRACK_PLAY
FindLastTrack(
    IN INT cdrom
    );

BOOL
AllTracksPlayed(
    void
    );

PTRACK_PLAY
FindNextTrack(
    BOOL wrap
    );

PTRACK_PLAY
FindPrevTrack(
    int cdrom,
    BOOL wrap
    );

int
FindContiguousEnd(
    int cdrom,
    PTRACK_PLAY tr
    );

void
FlipBetweenShuffleAndOrder(
    void
    );

void
ComputeAndUseShufflePlayLists(
    void
    );

void
ComputeSingleShufflePlayList(
    int i
    );

void
RestorePlayListsFromShuffleLists(
    void
    );

void
FigureTrackTime(
    int cdrom,
    int index,
    int * min,
    int * sec
    );

void
TimeAdjustInitialize(
    int cdrom
    );

void
TimeAdjustIncSecond(
    int cdrom
    );

void
TimeAdjustDecSecond(
    int cdrom
    );

void
InitializeNewTrackTime(
    int cdrom,
    PTRACK_PLAY tr,
    BOOL fUpdateDisplay
    );

void
TimeAdjustSkipToTrack(
    int cdrom,
    PTRACK_PLAY tr
    );

void
SyncDisplay(
    void
    );

void
ValidatePosition(
    int cdrom
    );

VOID
ResetTrackComboBox(
    int cdrom
    );

BOOL
PlayListMatchesAvailList(
    void
    );

void
AddTemporaryTrackToPlayList(
    PCURRPOS pCurr
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\scan.cpp ===
/******************************Module*Header*******************************\
* Module Name: scan.c
*
* Code for scanning the available CD Rom devices.
*
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>    /* required for all Windows applications */
#include <windowsx.h>

#include <string.h>
#include <tchar.h>              /* contains portable ascii/unicode macros */

#include "playres.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"
#include "database.h"



/*****************************Private*Routine******************************\
* ScanForCdromDevices
*
* Returns the number of CD-ROM devices installed in the system.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
int
ScanForCdromDevices(
    void
    )
{
    DWORD   dwDrives;
    TCHAR   chDrive[] = TEXT("A:\\");
    int     iNumDrives;

    iNumDrives  = 0;

    for (dwDrives = GetLogicalDrives(); dwDrives != 0; dwDrives >>= 1 ) {

        /*
        ** Is there a logical drive ??
        */
        if (dwDrives & 1) {

            if ( GetDriveType(chDrive) == DRIVE_CDROM ) {

                g_Devices[iNumDrives] = (CDROM*)AllocMemory( sizeof(CDROM) );

                g_Devices[iNumDrives]->drive = chDrive[0];
                g_Devices[iNumDrives]->State = CD_BEING_SCANNED;

                iNumDrives++;
            }
        }

        /*
        ** Go look at the next drive
        */
        chDrive[0] = chDrive[0] + 1;
    }

    return iNumDrives;
}


/******************************Public*Routine******************************\
* RescanDevice
*
*
* This routine is called to scan the disc in a given cdrom by
* reading its table of contents.  If the cdrom is playing the user is
* notified that the music will stop.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void RescanDevice(
    HWND hwndNotify,
    int cdrom
    )
{
    TOC_THREAD_PARMS    *ptoc;
    HWND                hwndButton;
    int                 iMsgBoxRtn;

    if ( g_Devices[cdrom]->State & CD_PLAYING ) {

        TCHAR   s1[256];
        TCHAR   s2[256];

        _tcscpy( s1, IdStr( STR_CANCEL_PLAY ) );
        _tcscpy( s2, IdStr( STR_RESCAN ) );

        iMsgBoxRtn = MessageBox( g_hwndApp, s1, s2,
                                 MB_APPLMODAL | MB_DEFBUTTON1 |
                                 MB_ICONQUESTION | MB_YESNO);

        if ( iMsgBoxRtn == IDYES ) {

            hwndButton = g_hwndControls[INDEX(IDM_PLAYBAR_STOP)];

            SendMessage( hwndButton, WM_LBUTTONDOWN, 0, 0L );
            SendMessage( hwndButton, WM_LBUTTONUP, 0, 0L );
        }
        else {

            return;
        }
    }


    /*
    ** Attempt to read table of contents of disc in this drive.  We
    ** now spawn off a separate thread to do this.  Note that the child
    ** thread frees the storage allocated below.
    */
    ptoc = (TOC_THREAD_PARMS*)AllocMemory( sizeof(TOC_THREAD_PARMS) );
    ptoc->hwndNotify = hwndNotify;
    ptoc->cdrom = cdrom;
    ReadTableOfContents( ptoc );

}


/*****************************Private*Routine******************************\
* ReadTableofContents
*
* This function reads in the table of contents (TOC) for the specified cdrom.
* All TOC's are read on a worker thread.  The hi-word of thread_info variable
* is a boolean that states if the display should been updated after the TOC
* has been reads.  The lo-word of thread_info is the id of the cdrom device
* to be read.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ReadTableOfContents(
    TOC_THREAD_PARMS *ptoc
    )
{
    DWORD   dwThreadId;
    int     cdrom;

    cdrom = ptoc->cdrom;
    g_Devices[ cdrom ]->fIsTocValid = FALSE;
    g_Devices[cdrom]->fShowLeadIn = FALSE;
    g_Devices[cdrom]->fProcessingLeadIn = FALSE;

    if (g_Devices[ cdrom ]->hThreadToc != NULL) {

        /*
        ** We have a thread TOC handle see if the thread is
        ** still running.  If so just return, otherwise
        */
        switch ( WaitForSingleObject(g_Devices[ cdrom ]->hThreadToc, 0L) ) {

        /*
        ** Thread has finished to continue
        */
        case WAIT_OBJECT_0:
            break;

        /*
        ** The thread is still running so just return
        */
        case WAIT_TIMEOUT:
        default:
            return;
        }

        CloseHandle( g_Devices[ cdrom ]->hThreadToc );
    }

    g_Devices[ cdrom ]->hThreadToc = CreateThread(
        NULL, 0L, (LPTHREAD_START_ROUTINE)TableOfContentsThread,
        (LPVOID)ptoc, 0L, &dwThreadId );

    /*
    ** For now I will kill the app if I cannot create the
    ** ReadTableOfContents thread.  This is probably a bit
    ** harsh.
    */

    if (g_Devices[ cdrom ]->hThreadToc == NULL) {
        FatalApplicationError( STR_NO_RES, GetLastError() );
    }

}

/*****************************Private*Routine******************************\
* TableOfContentsThread
*
* This is the worker thread that reads the table of contents for the
* specified cdrom.
*
* Before the thread exits we post a message to the UI threads main window to
* notify it that the TOC for this cdrom has been updated.  It then  examines the
* database to determine if this cdrom is known and updates the screen ccordingly.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TableOfContentsThread(
    TOC_THREAD_PARMS *ptoc
    )
{
    DWORD   status;
    UCHAR   num, numaudio;
    int     cdrom;
    HWND    hwndNotify;

    //  This serializes access to this function 
    //  between multiple threads and the CDPlayer_OnTocRead
    //  function on the main thread. 
    //  This prevents resource contention on CDROM Multi-changers
    EnterCriticalSection (&g_csTOCSerialize);

    cdrom = ptoc->cdrom;
    hwndNotify = ptoc->hwndNotify;

    LocalFree( ptoc );

    /*
    ** Try to read the TOC from the drive.
    */

#ifdef USE_IOCTLS

    status = GetCdromTOC( g_Devices[cdrom]->hCd, &(g_Devices[cdrom]->toc) );
    num = g_Devices[cdrom]->toc.LastTrack - g_Devices[cdrom]->toc.FirstTrack+1;
    {
        int     i;

        numaudio = 0;

        /*
        ** Look for audio tracks...
        */
        for( i = 0; i < num; i++ ) {

            if ( (g_Devices[cdrom]->toc.TrackData[i].Control &
                  TRACK_TYPE_MASK ) == AUDIO_TRACK ) {

                numaudio++;
            }

        }
    }

    /*
    ** Need to check if we got data tracks or audio
    ** tracks back...if there is a mix, strip out
    ** the data tracks...
    */
    if (status == ERROR_SUCCESS) {


        /*
        ** If there aren't any audio tracks, then we (most likely)
        ** have a data CD loaded.
        */

        if (numaudio == 0) {

            status == ERROR_UNRECOGNIZED_MEDIA;
            g_Devices[cdrom]->State = CD_DATA_CD_LOADED | CD_STOPPED;

        }
        else {

            g_Devices[cdrom]->State = CD_LOADED | CD_STOPPED;
        }
    }
    else {

        g_Devices[cdrom]->State = CD_NO_CD | CD_STOPPED;
    }

#else
    {
        MCIDEVICEID wDeviceID;
        DWORD       dwCDPlayerMode = 0L;

    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    GetVersionEx(&os);
    if (os.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        if (g_Devices[cdrom]->hCd == 0) {
            g_Devices[cdrom]->hCd = OpenCdRom( g_Devices[cdrom]->drive,
                                               &status );
        }
        wDeviceID = g_Devices[cdrom]->hCd;
    }
    else
    {
        wDeviceID = OpenCdRom( g_Devices[cdrom]->drive, &status );
    }

        if ( wDeviceID != 0 ) {

            int     i;

            numaudio = 0;
            status = GetCdromTOC( wDeviceID, &(g_Devices[cdrom]->toc) );

            /*
            ** Need to check if we got data tracks or audio
            ** tracks back...if there is a mix, strip out
            ** the data tracks...
            */
            if ( status == ERROR_SUCCESS) {
                num = g_Devices[cdrom]->toc.LastTrack -
                      g_Devices[cdrom]->toc.FirstTrack + 1;

                for( i = 0; i < num; i++ ) {

                    if ( IsCdromTrackAudio(wDeviceID, i) ) {

                        numaudio++;
                    }
                }
            }

            dwCDPlayerMode = GetCdromMode( wDeviceID );

            OSVERSIONINFO os;
            os.dwOSVersionInfoSize = sizeof(os);
            GetVersionEx(&os);
            if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
            {
                CloseCdRom( wDeviceID );
            }
        }

        /*
        ** Need to check if we got data tracks or audio
        ** tracks back...if there is a mix, strip out
        ** the data tracks...
        */
        if (status == ERROR_SUCCESS) {

            /*
            ** If there aren't any audio tracks, then we (most likely)
            ** have a data CD loaded.
            */

            if (numaudio == 0) {

                g_Devices[cdrom]->State = CD_DATA_CD_LOADED | CD_STOPPED;
            }
            else {

                g_Devices[cdrom]->State = CD_LOADED;

                switch (dwCDPlayerMode) {

                case MCI_MODE_PAUSE:
                    g_Devices[cdrom]->State |= CD_PAUSED;
                    break;

                case MCI_MODE_PLAY:
                    g_Devices[cdrom]->State |= CD_PLAYING;
                    break;

                default:
                    g_Devices[cdrom]->State |= CD_STOPPED;
                    break;
                }
            }

        }
        else {

            if (status == (DWORD)MCIERR_MUST_USE_SHAREABLE) {
                g_Devices[cdrom]->State = CD_IN_USE;
            }

            if (g_Devices[cdrom]->State != CD_IN_USE) {
                g_Devices[cdrom]->State = CD_NO_CD | CD_STOPPED;
            }
        }
    }
#endif

    /*
    ** Notify the UI thread that a TOC has been read and then terminate the
    ** thread.
    */

    PostMessage( hwndNotify, WM_NOTIFY_TOC_READ,
                 (WPARAM)cdrom, (LPARAM)numaudio );

    LeaveCriticalSection (&g_csTOCSerialize);
    
    ExitThread( 1L );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\playres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MMComp.rc
//
#define IDX_1                           0
#define IDX_2                           1
#define IDX_3                           2
#define IDX_4                           3
#define IDX_5                           4
#define IDX_6                           5
#define IDX_7                           6
#define IDX_8                           7
#define IDX_9                           8
#define NUMBER_OF_BITMAPS               8
#define PLAYBAR_BITMAPS                 8
#define IDX_10                          9
#define DEFAULT_TBAR_SIZE               11
#define IDR_BASECOMP                    101
#define IDR_MAINMENU                    102
#define IDR_CDPLAY                      102
#define IDR_CDPLAYER                    104
#define IDR_SCANNING                    106
#define IDR_CDPLAYER_ICON               107
#define IDR_TRACK                       108
#define IDR_DROP                        109
#define IDR_SHELLICON                   110
#define IDR_DROPDEL                     111
#define IDR_DROPCPY                     112
#define IDR_PREFERENCES                 113
#define IDR_ACCELTABLE                  118
#define IDI_ICON_CDPLAY                 201
#define IDC_TRANS_PLACEHOLDER           202
#define IDD_DIALOG_TRANSPORT            203
#define IDC_CURSOR_HAND                 205
#define IDB_TRANS_TRACKLIST             206
#define IDB_TRANS_PLAY                  207
#define IDB_TRANS_STOP                  208
#define IDB_TRANS_EJECT                 209
#define IDB_TRANS_PREVTRACK             210
#define IDB_TRANS_NEXTTRACK             211
#define IDB_TRANS_MULTDISK              212
#define IDB_TRANS_PDISK                 213
#define IDB_TRANS_NDISK                 214
#define IDB_CDLOGO                      215
#define IDB_CDLOGO_16                   216
#define STR_MAX_STRING_LEN              255
#define DISC_MENU_BASE                  300
#define IDM_DATABASE_EDIT               300
#define IDM_DATABASE_EXIT               301
#define VIEW_MENU_BASE                  400
#define IDM_TIME_REMAINING              403
#define IDM_TRACK_REMAINING             404
#define IDM_DISC_REMAINING              405
#define INTERNET_MENU_BASE              450
#define OPTIONS_MENU_BASE               500
#define IDM_OPTIONS_RANDOM              501
#define IDM_OPTIONS_MULTI               502
#define IDM_OPTIONS_CONTINUOUS          503
#define IDM_OPTIONS_INTRO               504
#define IDM_OPTIONS_PREFERENCES         505
#define IDM_OPTIONS_REPEAT_SINGLE       506
#define IDM_OPTIONS_NORMAL              507
#define HELP_MENU_BASE                  600
#define IDM_HELP_CONTENTS               600
#define IDM_HELP_USING                  601
#define IDM_HELP_ABOUT                  602
#define IDM_HELP_TOPICS                 603
#define IDK_SKIPF                       700
#define IDK_SKIPB                       701
#define IDK_PLAY                        702
#define IDK_STOP                        703
#define IDK_PAUSE                       704
#define IDK_EJECT                       705
#define IDK_RESCAN                      706
#define IDC_CDPLAYER_FIRST              1000
#define IDC_BUTTON1                     1000
#define MENU_STRING_BASE                1000
#define IDM_PLAYBAR_PLAY                1000
#define IDC_BUTTON2                     1001
#define IDM_PLAYBAR_PAUSE               1001
#define IDC_BUTTON3                     1002
#define IDM_PLAYBAR_STOP                1002
#define IDC_BUTTON4                     1003
#define IDM_PLAYBAR_PREVTRACK           1003
#define IDC_BUTTON5                     1004
#define IDM_PLAYBAR_SKIPBACK            1004
#define IDC_BUTTON6                     1005
#define IDM_PLAYBAR_SKIPFORE            1005
#define IDC_BUTTON7                     1006
#define IDM_PLAYBAR_NEXTTRACK           1006
#define IDC_BUTTON8                     1007
#define IDM_PLAYBAR_EJECT               1007
#define IDC_LED                         1008
#define IDC_TRACKINFO_FIRST             1009
#define IDC_COMBO1                      1009
#define IDC_COMBO1_TEXT                 1010
#define IDC_EDIT1                       1011
#define IDB_PLAY_CD                     1012
#define IDC_EDIT1_TEXT                  1012
#define IDB_PAUSE                       1013
#define IDC_COMBO2                      1013
#define IDB_STOP_CD                     1014
#define IDC_COMBO2_TEXT                 1014
#define IDC_CDPLAYER_LAST               1014
#define IDB_REWIND                      1015
#define IDB_FASTFORWARD                 1016
#define IDB_PREV_TRACK                  1017
#define IDB_NEXT_TRACK                  1018
#define IDB_EJECT_CD                    1019
#define IDC_TRACKLIST                   1021
#define IDC_CLOSE                       2001
#define IDC_DEFAULT                     2002
#define IDC_DISC_HELP                   2003
#define IDC_ADD                         2006
#define IDC_REMOVE                      2007
#define IDC_CLEAR                       2008
#define IDC_SETNAME                     2009
#define IDC_STATIC_DRIVE                2011
#define IDC_SJETEXT_DRIVE               2012
#define IDC_STATIC_ARTIST               2013
#define IDC_EDIT_ARTIST                 2014
#define IDC_STATIC_TITLE                2015
#define IDC_EDIT_TITLE                  2016
#define IDC_STATIC_PLAY_LIST            2017
#define IDC_LISTBOX_PLAY_LIST           2018
#define IDC_STATIC_AVAILABLE_TRACKS     2019
#define IDC_LISTBOX_AVAILABLE_TRACKS    2020
#define IDC_STATIC_TRACK                2021
#define IDC_EDIT_TRACK                  2022
#define IDC_STOP_CD_ON_EXIT             3000
#define IDC_SAVE_ON_EXIT                3001
#define IDC_SHOW_TOOLTIPS               3002
#define IDC_SMALL_FONT                  3003
#define IDC_LARGE_FONT                  3004
#define IDC_LED_DISPLAY                 3005
#define IDC_INTRO_PLAY_LEN              3006
#define IDC_INTRO_SPINBTN               3007
#define STR_REGISTRY_KEY                3100
#define STR_CDPLAYER                    3101
#define STR_TERMINATE                   3102
#define STR_FAIL_INIT                   3103
#define STR_NO_CDROMS                   3104
#define STR_FATAL_ERROR                 3105
#define STR_SCANNING                    3106
#define STR_INITIALIZATION              3107
#define STR_TRACK1                      3108
#define STR_SAVE_CHANGES                3109
#define STR_SAVE_INFO                   3110
#define STR_CANCEL_PLAY                 3111
#define STR_RESCAN                      3112
#define STR_READING_TOC                 3113
#define STR_CHANGE_CDROM                3114
#define STR_CDPLAYER_TIME               3115
#define STR_NO_RES                      3116
#define STR_INSERT_DISC                 3117
#define STR_NO_DISC                     3118
#define STR_ERR_GEN                     3119
#define STR_CDPLAYER_PAUSED             3120
#define STR_DATA_DISC                   3121
#define STR_INIT_TOTAL_PLAY             3330
#define STR_INIT_TRACK_PLAY             3331
#define STR_TOTAL_PLAY                  3332
#define STR_TRACK_PLAY                  3333
#define STR_NEW_ARTIST                  3334
#define STR_NEW_TITLE                   3335
#define STR_INIT_TRACK                  3336
#define STR_HDR_ARTIST                  3337
#define STR_HDR_TRACK                   3338
#define STR_HDR_TITLE                   3339
#define STR_UNKNOWN                     3340
#define STR_BAD_DISC                    3341
#define STR_CDROM_INUSE                 3342
#define STR_DISC_INUSE                  3343
#define STR_WAITING                     3344
#define STR_EXIT_MESSAGE                3345
#define STR_NOT_IN_PLAYLIST             3346
#define STR_BEING_SCANNED               3347
#define STR_DISK_NOT_THERE_K            3348
#define STR_DISK_NOT_THERE              3349
#define STR_UNKNOWN_ARTIST              3350
#define STR_DISPLAY_LABELS              3400
#define STR_MCICDA_MISSING              3452
#define STR_MCICDA_NOT_WORKING          3453
#define STR_MUTE                        3454
#define IDI_ICON_ANI_PLAY               4000
#define IDI_ICON_ANI_MODE               4001
#define IDI_ICON_ANI_DOWN               4002
#define STR_FORMAT_STATUS               5000
#define STR_FORMAT_MODE                 5001
#define STR_LOGO                        5002
#define STR_TRACK_REMAINING             5003
#define STR_TRACK_TIME                  5004
#define STR_DISC_REMAINING              5005
#define STR_DISC_TIME                   5006
#define STR_TRACK_NUMBER                5007
#define STR_STATUS_MUTE                 5008
#define STR_TITLE                       5009
#define STR_TRACK                       5010
#define STR_ARTIST                      5011
#define STR_STATUS_PLAY                 5012
#define STR_STATUS_DOWNLOADING          5013
#define STR_STATUS_NODISC               5014
#define STR_STATUS_STOP                 5015
#define STR_STATUS_PAUSED               5016
#define STR_MODE_NORMAL                 5017
#define STR_MODE_RANDOM                 5018
#define STR_MODE_REPEATONE              5019
#define STR_MODE_REPEATALL              5020
#define STR_MODE_INTROPLAY              5021
#define STR_VOLUME                      5022
#define IDX_SEPARATOR                   -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        216
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\literals.cpp ===
/******************************Module*Header*******************************\
* Module Name: literals.c
*
* Global string variables that don't need converting for international builds.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/
#define NOOLE
#include <windows.h>

#include "playres.h"

#ifndef APP_FONT
#define APP_FONT   "MS San Serif"
#endif

//#ifdef CHICAGO
#include <regstr.h>
//#endif

#ifdef __cplusplus
extern "C" {
#endif
      TCHAR     g_szEmpty[]                 = TEXT("");
      TCHAR     g_IniFileName[]             = TEXT("cdplayer.ini");
      TCHAR     g_HelpFileName[]            = TEXT("cdplayer.hlp");

      TCHAR     g_szBlank[]                 = TEXT(" ");
      TCHAR     g_szSJE_CdPlayerClass[]     = TEXT("SJE_CdPlayerClass");
      TCHAR     g_szSndVol32[]              = TEXT("sndvol32.exe");
      TCHAR     TRACK_TIME_FORMAT[]         = TEXT("%02d%s%02d");
      TCHAR     TRACK_TIME_LEADOUT_FORMAT[] = TEXT("-%02d%s%02d");
      TCHAR     TRACK_REM_FORMAT[]          = TEXT("%02d%s%02d");
      TCHAR     DISC_REM_FORMAT[]           = TEXT("%02d%s%02d");
      TCHAR     DISC_TIME_FORMAT[]           = TEXT("%02d%s%02d");

      TCHAR     g_szSaveSettingsOnExit[]    = TEXT("SaveSettingsOnExit");
      TCHAR     g_szSmallFont[]             = TEXT("SmallFont");
      TCHAR     g_szToolTips[]              = TEXT("ToolTips");
      TCHAR     g_szStopCDPlayingOnExit[]   = TEXT("ExitStop");
      TCHAR     g_szStartCDPlayingOnStart[] = TEXT("StartPlay");
      TCHAR     g_szInOrderPlay[]           = TEXT("InOrderPlay");
      TCHAR     g_szMultiDiscPlay[]         = TEXT("MultiDiscPlay");
      TCHAR     g_szDisplayT[]              = TEXT("DispMode");
      TCHAR     g_szIntroPlay[]             = TEXT("IntroPlay");
      TCHAR     g_szIntroPlayLen[]          = TEXT("IntroTime");
      TCHAR     g_szContinuousPlay[]        = TEXT("ContinuousPlay");
      TCHAR     g_szDiscAndTrackDisplay[]   = TEXT("DiscAndTrackDisplay");
      TCHAR     g_szWindowOriginX[]         = TEXT("WindowOriginX");
      TCHAR     g_szWindowOriginY[]         = TEXT("WindowOriginY");
      TCHAR     g_szWindowOrigin[]          = TEXT("WindowOrigin");
      TCHAR     g_szSettings[]              = TEXT("Settings");
      TCHAR     g_szRandomPlay[]            = TEXT("RandomPlay");
      TCHAR     g_szNothingThere[]          = TEXT("");
      TCHAR     g_szEntryTypeF[]            = TEXT("EntryType=%d");
      TCHAR     g_szArtistF[]               = TEXT("artist=%s");
      TCHAR     g_szTitleF[]                = TEXT("title=%s");
      TCHAR     g_szNumTracksF[]            = TEXT("numtracks=%d");
      TCHAR     g_szOrderF[]                = TEXT("order=");
      TCHAR     g_szNumPlayF[]              = TEXT("numplay=%d");

      TCHAR     g_szEntryType[]             = TEXT("EntryType");
      TCHAR     g_szArtist[]                = TEXT("artist");
      TCHAR     g_szTitle[]                 = TEXT("title");
      TCHAR     g_szNumTracks[]             = TEXT("numtracks");
      TCHAR     g_szOrder[]                 = TEXT("order");
      TCHAR     g_szNumPlay[]               = TEXT("numplay");

      TCHAR     g_szThreeNulls[]            = TEXT("\0\0\0");
      TCHAR     g_szSectionF[]              = TEXT("%lX");

      TCHAR     g_szMusicBoxIni[]           = TEXT("musicbox.ini");
      TCHAR     g_szMusicBoxFormat[]        = TEXT("Track%d");
      TCHAR     g_szPlayList[]              = TEXT("PlayList");
      TCHAR     g_szDiscTitle[]             = TEXT("DiscTitle");

      TCHAR     g_szTextClassName[]         = TEXT("SJE_TextClass");
      TCHAR     g_szLEDClassName[]          = TEXT("SJE_LEDClass");
      TCHAR     g_szAppFontName[]           = TEXT(APP_FONT);
      TCHAR     g_szPlay[]                  = TEXT("PLAY");
      TCHAR     g_szTray[]                  = TEXT("TRAY");
      TCHAR     g_szTrack[]                 = TEXT("TRACK");
      TCHAR     g_szCDA[]                   = TEXT("CDA");
      TCHAR     g_szTrackFormat[]           = TEXT("%d");
      TCHAR     g_szNumbers[]               = TEXT("0123456789");
      TCHAR     g_szColon[]                 = TEXT(":");
      TCHAR     g_szColonBackSlash[]        = TEXT(":\\");

      TCHAR     g_szPlayOption[]            = TEXT("-PLAY ");
      TCHAR     g_szTrackOption[]           = TEXT("-TRACK ");
      TCHAR     g_szCdplayer[]              = TEXT("CDPLAYER ");

      TCHAR     g_chBlank                   = TEXT(' ');
      TCHAR     g_chOptionSlash             = TEXT('/');
      TCHAR     g_chOptionHyphen            = TEXT('-');
      TCHAR     g_chNULL                    = TEXT('\0');

      TCHAR     g_szRegistryKey[]           = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\DeluxeCD\\Settings");
      TCHAR     g_szUpdate[]                = TEXT("UPDATE");
      TCHAR     g_szUpdateOption[]          = TEXT(" -UPDATE ");

      TCHAR     g_szCdPlayerMutex[]         = TEXT("CdPlayerThereCanOnlyBeOne");

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\literals.h ===
/******************************Module*Header*******************************\
* Module Name: literals.c
*
* Global string variables that don't need converting for international builds.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/
#define NOUSER
#define NOGDI
#define NOOLE
//#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

extern       TCHAR     g_szEmpty[];
extern       TCHAR     g_IniFileName[];
extern       TCHAR     g_HelpFileName[];

extern const TCHAR     g_szBlank[];
extern const TCHAR     g_szSJE_CdPlayerClass[];
extern const TCHAR     g_szSndVol32[];
extern const TCHAR     TRACK_TIME_FORMAT[];
extern const TCHAR     TRACK_TIME_LEADOUT_FORMAT[];
extern const TCHAR     TRACK_REM_FORMAT[];
extern const TCHAR     DISC_REM_FORMAT[];
extern const TCHAR     DISC_TIME_FORMAT[];

extern       TCHAR     g_szSaveSettingsOnExit[];
extern       TCHAR     g_szSmallFont[];
extern       TCHAR     g_szStopCDPlayingOnExit[];
extern       TCHAR     g_szStartCDPlayingOnStart[];
extern       TCHAR     g_szInOrderPlay[];
extern       TCHAR     g_szMultiDiscPlay[];
extern       TCHAR     g_szDisplayT[];
extern       TCHAR     g_szDisplayTr[];
extern       TCHAR     g_szDisplayDr[];
extern       TCHAR     g_szIntroPlay[];
extern       TCHAR     g_szIntroPlayLen[];
extern       TCHAR     g_szContinuousPlay[];
extern       TCHAR     g_szDiscAndTrackDisplay[];
extern       TCHAR     g_szWindowOriginX[];
extern       TCHAR     g_szWindowOriginY[];
extern       TCHAR     g_szWindowOrigin[];
extern       TCHAR     g_szSettings[];
extern       TCHAR     g_szRandomPlay[];
extern const TCHAR     g_szNothingThere[];
extern       TCHAR     g_szEntryTypeF[];
extern       TCHAR     g_szArtistF[];
extern       TCHAR     g_szTitleF[];
extern       TCHAR     g_szNumTracksF[];
extern       TCHAR     g_szOrderF[];
extern       TCHAR     g_szNumPlayF[];

extern       TCHAR     g_szEntryType[];
extern       TCHAR     g_szArtist[];
extern       TCHAR     g_szTitle[];
extern       TCHAR     g_szNumTracks[];
extern       TCHAR     g_szOrder[];
extern       TCHAR     g_szNumPlay[];

extern       TCHAR     g_szThreeNulls[];
extern       TCHAR     g_szSectionF[];

extern const TCHAR     g_szMusicBoxIni[];
extern const TCHAR     g_szMusicBoxFormat[];
extern const TCHAR     g_szPlayList[];
extern const TCHAR     g_szDiscTitle[];

extern const TCHAR     g_szTextClassName[];
extern const TCHAR     g_szLEDClassName[];
extern const TCHAR     g_szAppFontName[];
extern const TCHAR     g_szPlay[];
extern const TCHAR     g_szTray[];
extern const TCHAR     g_szTrack[];
extern const TCHAR     g_szCDA[];
extern const TCHAR     g_szTrackFormat[];
extern const TCHAR     g_szNumbers[];
extern const TCHAR     g_szColon[];
extern const TCHAR     g_szColonBackSlash[];

extern const TCHAR     g_szPlayOption[];
extern const TCHAR     g_szTrackOption[];
extern const TCHAR     g_szCdplayer[];

extern const TCHAR     g_chBlank;
extern const TCHAR     g_chOptionSlash;
extern const TCHAR     g_chOptionHyphen;
extern const TCHAR     g_chNULL;

extern const TCHAR     g_szRegistryKey[];

extern const TCHAR     g_szUpdate[];
extern const TCHAR     g_szUpdateOption[];

extern const TCHAR     g_szCdPlayerMutex[];

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\frame.h ===
#ifndef BUILD_FRAME_H
#define BUILD_FRAME_H

#define VIEW_MODE_NORMAL  0
#define VIEW_MODE_RESTORE 1
#define VIEW_MODE_SMALL   2
#define VIEW_MODE_NOBAR   3

HANDLE BuildFrameBitmap(HDC hDC,            //dc to be compatible with
                        LPRECT pMainRect,   //overall window size
                        LPRECT pViewRect,   //rect of black viewport window,
                                            //where gradient should begin,
                                            //with 0,0 as top left of main
                        int nViewMode,      //if in normal, restore, small
                        LPPOINT pSysMenuPt, //point where sys menu icon is placed
                        LPRECT pSepRects,   //array of rects for separator bars
                        int nNumSeps,       //number of separtors in array
                        BITMAP* pBM);       //bitmap info

#endif //BUILD_FRAME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\dib.h ===
/*----------------------------------------------------------------------------*\
|   Routines for dealing with Device independent bitmaps                       |
|									       |
|   History:                                                                   |
|       06/23/89 toddla     Created                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/

HANDLE      OpenDIB(LPTSTR szFile, HFILE fh);
BOOL        WriteDIB(LPTSTR szFile, HFILE fh, HANDLE hdib);
UINT        PaletteSize(VOID FAR * pv);
WORD        DibNumColors(VOID FAR * pv);
HPALETTE    CreateDibPalette(HANDLE hdib);
HPALETTE    CreateBIPalette(LPBITMAPINFOHEADER lpbi);
HPALETTE    CreateExplicitPalette(void);
HPALETTE    CreateColorPalette(void);
HANDLE      DibFromBitmap(HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage);
HANDLE      DibFromDib(HANDLE hdib, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage);
HBITMAP     BitmapFromDib(HANDLE hdib, HPALETTE hpal, UINT wUsage);
BOOL        SetDibUsage(HANDLE hdib, HPALETTE hpal,UINT wUsage);
BOOL        DibInfo(LPBITMAPINFOHEADER lpbiSource, LPBITMAPINFOHEADER lpbiTarget);
HANDLE      ReadDibBitmapInfo(HFILE fh);
BOOL        SetPalFlags(HPALETTE hpal, int iIndex, int cntEntries, UINT wFlags);

BOOL        DrawBitmap(HDC hdc, int x, int y, HBITMAP hbm, DWORD rop);
BOOL        StretchBitmap(HDC hdc, int x, int y, int dx, int dy, HBITMAP hbm, int x0, int y0, int dx0, int dy0, DWORD rop);

BOOL        DibBlt(HDC hdc, int x0, int y0, int dx, int dy, HANDLE hdib, int x1, int y1, LONG rop, UINT wUsage);
BOOL        StretchDibBlt(HDC hdc, int x, int y, int dx, int dy, HANDLE hdib, int x0, int y0, int dx0, int dy0, LONG rop,  UINT wUsage);

LPVOID      DibLock(HANDLE hdib,int x, int y);
VOID        DibUnlock(HANDLE hdib);
LPVOID      DibXY(LPBITMAPINFOHEADER lpbi,int x, int y);
HANDLE      CreateDib(WORD bits, int dx, int dy);

#define BFT_ICON   0x4349   /* 'IC' */
#define BFT_BITMAP 0x4d42   /* 'BM' */
#define BFT_CURSOR 0x5450   /* 'PT' */

#define ISDIB(bft) ((bft) == BFT_BITMAP)
#define ALIGNULONG(i)     ((i+3)/4*4)        /* ULONG aligned ! */
#define WIDTHBYTES(i)     ((i+31)/32*4)      /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)

#define PALVERSION      0x300
#define MAXPALETTE      256
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\frame.cpp ===
#include "windows.h"
#include "frame.h"
#include "dib.h"
#include "resource.h"
#include "mmfw.h"

//constants for bitmap placement in FRAME.BMP
#define PIECE_WIDTH         9
#define PIECE_HEIGHT        10
#define SMALL_MODE_OFFSET   90

//outer edges
#define TOP_LEFT_CORNER     0
#define TOP_STRIP           1
#define TOP_RIGHT_CORNER    2
#define LEFT_STRIP          3
#define SEPARATOR_BAR       4
#define RIGHT_STRIP         5
#define BOTTOM_LEFT_CORNER  6
#define BOTTOM_STRIP        7
#define BOTTOM_RIGHT_CORNER 8

//inner edges
#define TOP_LEFT_CORNER_VIEW     9
#define TOP_STRIP_VIEW           10
#define TOP_RIGHT_CORNER_VIEW    11
#define LEFT_STRIP_VIEW          12
#define RIGHT_STRIP_VIEW         13
#define BOTTOM_LEFT_CORNER_VIEW  14
#define BOTTOM_STRIP_VIEW        15
#define BOTTOM_RIGHT_CORNER_VIEW 16
#define LEFT_INNER_STRIP_VIEW    17
#define RIGHT_INNER_STRIP_VIEW   18

#define LEFT_INNER_X_OFFSET 5
#define LEFT_INNER_Y_OFFSET 7
#define RIGHT_INNER_X_OFFSET 9
#define RIGHT_INNER_Y_OFFSET 7

//system menu icon
#define SYSTEM_MENU_INDEX 52
#define SYSTEM_MENU_WIDTH 12
#define SYSTEM_MENU_HEIGHT 14

//volume control notch
#define VOLUME_X_OFFSET 2

#define BACKGROUND_COLOR    RGB(0x7F, 0x7F, 0x7F)
#define BACKGROUND_COLOR_16 RGB(0xC0, 0xC0, 0xC0)
#define BACKGROUND_COLOR_HI RGB(0xFF, 0xFF, 0xFF)

extern HPALETTE hpalMain; //main palette of app
extern HINSTANCE hInst;   //instance of app
extern int g_nColorMode;  //color mode

HANDLE BuildFrameBitmap(HDC hDC,            //dc to be compatible with
                        LPRECT pMainRect,   //overall window size
                        LPRECT pViewRect,   //rect of black viewport window,
                                            //where gradient should begin,
                                            //with 0,0 as top left of main
                        int nViewMode,      //if in normal, restore, small
                        LPPOINT pSysMenuPt, //point where sys menu icon is placed
                        LPRECT pSepRects,   //array of rects for separator bars
                        int nNumSeps,       //number of separtors in array
                        BITMAP* pBM)        //bitmap info
{
	HDC memDC = CreateCompatibleDC(hDC);
	HPALETTE hpalOld = SelectPalette(memDC, hpalMain, FALSE);
	
    HBITMAP hbmpOld;
    HBITMAP hbmpTemp;
    HBITMAP hbmpFinal;

    int nSmallOffset = 0;
    if ((nViewMode != VIEW_MODE_NORMAL) && (nViewMode != VIEW_MODE_NOBAR))
    {
        nSmallOffset = SMALL_MODE_OFFSET;
    }

    //load frame bitmap
    int nBitmap = IDB_FRAME_TOOLKIT;
    switch (g_nColorMode)
    {
        case COLOR_16 : nBitmap = IDB_FRAME_TOOLKIT_16; break;
        case COLOR_HICONTRAST : nBitmap = IDB_FRAME_TOOLKIT_HI; break;
    }

    hbmpTemp = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	HANDLE hbmpFrame = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    DeleteObject(hbmpTemp);

    hbmpFinal = CreateCompatibleBitmap(hDC,
                                       pMainRect->right - pMainRect->left,
                                       pMainRect->bottom - pMainRect->top);

    hbmpOld = (HBITMAP)SelectObject(memDC, hbmpFinal);

    //first paint the background
    COLORREF colorBackground = BACKGROUND_COLOR;
    switch (g_nColorMode)
    {
        case COLOR_16 : colorBackground = BACKGROUND_COLOR_16; break;
        case COLOR_HICONTRAST : colorBackground = BACKGROUND_COLOR_HI; break;
    }

    HBRUSH hbrBack = CreateSolidBrush(colorBackground);
    FillRect(memDC,pMainRect,hbrBack);
    DeleteObject(hbrBack);

    //now draw the separators
    for (int i = 0; i < nNumSeps; i++)
    {
	    StretchDibBlt(memDC,
		    pSepRects[i].left,
		    pSepRects[i].top,
		    PIECE_WIDTH,
		    pSepRects[i].bottom - pSepRects[i].top,
		    hbmpFrame,
		    SEPARATOR_BAR*PIECE_WIDTH,0,
		    PIECE_WIDTH,
		    PIECE_HEIGHT,
		    SRCCOPY,0);
    }

    //draw each side
    StretchDibBlt(memDC,
            pMainRect->left,
            pMainRect->top,
            pMainRect->right - pMainRect->left,
            PIECE_HEIGHT,
            hbmpFrame,
            TOP_STRIP*PIECE_WIDTH,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    StretchDibBlt(memDC,
            pMainRect->left,
            pMainRect->top,
            PIECE_WIDTH,
            pMainRect->bottom - pMainRect->top,
            hbmpFrame,
            LEFT_STRIP*PIECE_WIDTH,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    StretchDibBlt(memDC,
            pMainRect->right - PIECE_WIDTH,
            pMainRect->top,
            PIECE_WIDTH,
            pMainRect->bottom - pMainRect->top,
            hbmpFrame,
            RIGHT_STRIP*PIECE_WIDTH,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    StretchDibBlt(memDC,
            pMainRect->left,
            pMainRect->bottom - PIECE_HEIGHT,
            pMainRect->right - pMainRect->left,
            PIECE_HEIGHT,
            hbmpFrame,
            BOTTOM_STRIP*PIECE_WIDTH,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    //draw each corner
    DibBlt(memDC,
            pMainRect->left,
            pMainRect->top,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            TOP_LEFT_CORNER*PIECE_WIDTH,0,
            SRCCOPY,0);            

    DibBlt(memDC,
            pMainRect->right-PIECE_WIDTH,
            pMainRect->top,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            TOP_RIGHT_CORNER*PIECE_WIDTH,0,
            SRCCOPY,0);            

    DibBlt(memDC,
            pMainRect->left,
            pMainRect->bottom - PIECE_HEIGHT,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            BOTTOM_LEFT_CORNER*PIECE_WIDTH,0,
            SRCCOPY,0);            

    DibBlt(memDC,
            pMainRect->right - PIECE_WIDTH,
            pMainRect->bottom - PIECE_HEIGHT,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            BOTTOM_RIGHT_CORNER*PIECE_WIDTH,0,
            SRCCOPY,0);            

    //draw each side of the interior viewport
    StretchDibBlt(memDC,
            pViewRect->left,
            pViewRect->top,
            pViewRect->right - pViewRect->left,
            PIECE_HEIGHT,
            hbmpFrame,
            TOP_STRIP_VIEW*PIECE_WIDTH+nSmallOffset,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    StretchDibBlt(memDC,
            pViewRect->left,
            pViewRect->top,
            PIECE_WIDTH,
            pViewRect->bottom - pViewRect->top,
            hbmpFrame,
            LEFT_STRIP_VIEW*PIECE_WIDTH+nSmallOffset,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    StretchDibBlt(memDC,
            pViewRect->right - PIECE_WIDTH,
            pViewRect->top,
            PIECE_WIDTH,
            pViewRect->bottom - pViewRect->top,
            hbmpFrame,
            RIGHT_STRIP_VIEW*PIECE_WIDTH+nSmallOffset,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    StretchDibBlt(memDC,
            pViewRect->left,
            pViewRect->bottom - PIECE_HEIGHT,
            pViewRect->right - pViewRect->left,
            PIECE_HEIGHT,
            hbmpFrame,
            BOTTOM_STRIP_VIEW*PIECE_WIDTH+nSmallOffset,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);
    
    //draw each corner of the interior viewport
    DibBlt(memDC,
            pViewRect->left,
            pViewRect->top,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            TOP_LEFT_CORNER_VIEW*PIECE_WIDTH+nSmallOffset,0,
            SRCCOPY,0);            

    DibBlt(memDC,
            pViewRect->right-PIECE_WIDTH,
            pViewRect->top,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            TOP_RIGHT_CORNER_VIEW*PIECE_WIDTH+nSmallOffset,0,
            SRCCOPY,0);            

    DibBlt(memDC,
            pViewRect->left,
            pViewRect->bottom - PIECE_HEIGHT,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            BOTTOM_LEFT_CORNER_VIEW*PIECE_WIDTH+nSmallOffset,0,
            SRCCOPY,0);            

    DibBlt(memDC,
            pViewRect->right - PIECE_WIDTH,
            pViewRect->bottom - PIECE_HEIGHT,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            BOTTOM_RIGHT_CORNER_VIEW*PIECE_WIDTH+nSmallOffset,0,
            SRCCOPY,0);
            
    if ((nViewMode == VIEW_MODE_NORMAL) || (nViewMode == VIEW_MODE_NOBAR))
    {
        //draw the interiors of the viewport
        StretchDibBlt(memDC,
                pViewRect->left + LEFT_INNER_X_OFFSET,
                pViewRect->top + LEFT_INNER_Y_OFFSET,
                PIECE_WIDTH,
                (pViewRect->bottom - PIECE_HEIGHT) - (pViewRect->top + LEFT_INNER_Y_OFFSET),
                hbmpFrame,
                LEFT_INNER_STRIP_VIEW*PIECE_WIDTH,0,
                PIECE_WIDTH,
                PIECE_HEIGHT,
                SRCCOPY,0);

        StretchDibBlt(memDC,
                (pViewRect->right - RIGHT_INNER_X_OFFSET) - PIECE_WIDTH,
                pViewRect->top + RIGHT_INNER_Y_OFFSET,
                PIECE_WIDTH,
                (pViewRect->bottom - PIECE_HEIGHT) - (pViewRect->top + RIGHT_INNER_Y_OFFSET),
                hbmpFrame,
                RIGHT_INNER_STRIP_VIEW*PIECE_WIDTH,0,
                PIECE_WIDTH,
                PIECE_HEIGHT,
                SRCCOPY,0);

        //draw the "notch" for the volume knob in this mode
        nBitmap = IDB_NOTCH;
        switch (g_nColorMode)
        {
            case COLOR_16 : nBitmap = IDB_NOTCH_16; break;
            case COLOR_HICONTRAST : nBitmap = IDB_NOTCH_HI; break;
        }

        HBITMAP hbmpNotch = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
        HDC memDC2 = CreateCompatibleDC(memDC);
        HBITMAP hbmpOld2 = (HBITMAP)SelectObject(memDC2,hbmpNotch);
        BITMAP bm;
        GetObject(hbmpNotch,sizeof(bm),&bm);

        BitBlt(memDC,
                pViewRect->right - bm.bmWidth,
                (pViewRect->bottom - PIECE_HEIGHT) - VOLUME_X_OFFSET,
                bm.bmWidth,
                bm.bmHeight,
                memDC2,
                0,0,SRCCOPY);

        SelectObject(memDC2,hbmpOld2);
        DeleteObject(hbmpNotch);
        DeleteDC(memDC2);
    }            

    //blit the system menu onto the picture, from the button toolkit bitmap
    if (nViewMode < VIEW_MODE_SMALL)
    {
        nBitmap = IDB_BUTTON_TOOLKIT;
        switch (g_nColorMode)
        {
            case COLOR_16 : nBitmap = IDB_BUTTON_TOOLKIT_16; break;
            case COLOR_HICONTRAST : nBitmap = IDB_BUTTON_TOOLKIT_HI; break;
        }
        
        HBITMAP hbmpSys = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
        HDC memDC2 = CreateCompatibleDC(memDC);
        HBITMAP hbmpOld2 = (HBITMAP)SelectObject(memDC2,hbmpSys);

        BitBlt(memDC,
                pSysMenuPt->x,
                pSysMenuPt->y,
                SYSTEM_MENU_WIDTH,
                SYSTEM_MENU_HEIGHT,
                memDC2,
                SYSTEM_MENU_INDEX,0,
                SRCCOPY);
        
        SelectObject(memDC2,hbmpOld2);
        DeleteObject(hbmpSys);
        DeleteDC(memDC2);
    }

    SelectObject(memDC,hbmpOld);
	SelectPalette(memDC, hpalOld, TRUE);
    DeleteDC(memDC);

    GlobalFree(hbmpFrame);

    if (pBM)
    {
        GetObject(hbmpFinal,sizeof(BITMAP),pBM);
    }

	HANDLE hdib = DibFromBitmap((HBITMAP)hbmpFinal,0,0,hpalMain,0);
    DeleteObject(hbmpFinal);

    return hdib;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\dib.cpp ===
/*----------------------------------------------------------------------------*\
|   Routines for dealing with Device independent bitmaps                       |
|                                                                              |
|   History:                                                                   |
|       06/23/89 toddla     Created                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/

#include <windows.h>
#include "dib.h"

#define HUGE_T

HANDLE CreateLogicalDib(HBITMAP hbm, WORD biBits, HPALETTE hpal);

static DWORD NEAR PASCAL lread(HFILE fh, VOID FAR *pv, DWORD ul);
static DWORD NEAR PASCAL lwrite(HFILE fh, VOID FAR *pv, DWORD ul);

/* flags for _lseek */
#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

/*
 *   Open a DIB file and return a MEMORY DIB, a memory handle containing..
 *
 *   BITMAP INFO    bi
 *   palette data
 *   bits....
 *
 */
HANDLE OpenDIB(LPTSTR szFile, HFILE fh)
{
    BITMAPINFOHEADER    bi;
    LPBITMAPINFOHEADER  lpbi;
    DWORD               dwLen;
    DWORD               dwBits;
    HANDLE              hdib;
    HANDLE              h;
#ifndef UNICODE
    OFSTRUCT            of;
#endif
    BOOL fOpened = FALSE;

    if (szFile != NULL) {
#ifdef UNICODE
	fh = (HFILE)HandleToUlong(CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ,
			 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
#else
	fh = OpenFile(szFile, &of, OF_READ);
#endif
	fOpened = TRUE;
    }

    if (fh == (HFILE)-1)
	return NULL;

    hdib = ReadDibBitmapInfo(fh);

    if (!hdib)
	return NULL;

    DibInfo((LPBITMAPINFOHEADER)GlobalLock(hdib),&bi);  GlobalUnlock(hdib);

    /* How much memory do we need to hold the DIB */

    dwBits = bi.biSizeImage;
    dwLen  = bi.biSize + PaletteSize(&bi) + dwBits;

    /* Can we get more memory? */

    h = GlobalReAlloc(hdib,dwLen,GMEM_MOVEABLE);

    if (!h)
    {
	GlobalFree(hdib);
	hdib = NULL;
    }
    else
    {
	hdib = h;
    }

    if (hdib)
    {
	lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

	/* read in the bits */
	lread(fh, (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi), dwBits);

	GlobalUnlock(hdib);
    }

    if (fOpened)
	_lclose(fh);

    return hdib;
}

/*
 *   Write a global handle in CF_DIB format to a file.
 *
 */
BOOL WriteDIB(LPTSTR szFile,HFILE fh, HANDLE hdib)
{
    BITMAPFILEHEADER    hdr;
    LPBITMAPINFOHEADER  lpbi;
    BITMAPINFOHEADER    bi;
    DWORD               dwSize;
    BOOL fOpened = FALSE;

    if (!hdib)
	return FALSE;

    if (szFile != NULL) {       
#ifdef UNICODE
	fh = (HFILE)HandleToUlong(CreateFile(szFile,GENERIC_WRITE | GENERIC_READ, 0,
			     NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL));
#else
	OFSTRUCT            of;
	fh = OpenFile(szFile,&of,OF_CREATE|OF_READWRITE);
#endif
	fOpened = TRUE;
    }

    if (fh == (HFILE)-1)
	return FALSE;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);
    DibInfo(lpbi,&bi);

    dwSize = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;


    hdr.bfType          = BFT_BITMAP;
    hdr.bfSize          = dwSize + sizeof(BITMAPFILEHEADER);
    hdr.bfReserved1     = 0;
    hdr.bfReserved2     = 0;
    hdr.bfOffBits       = (DWORD)sizeof(BITMAPFILEHEADER) + lpbi->biSize +
			  PaletteSize(lpbi);

    _lwrite(fh,(const char*)&hdr,sizeof(BITMAPFILEHEADER));
    lwrite(fh,(LPVOID)lpbi,dwSize);

    GlobalUnlock(hdib);

    if (fOpened)
	_lclose(fh);

    return TRUE;
}

/*
 *  DibInfo(hbi, lpbi)
 *
 *  retrives the DIB info associated with a CF_DIB format memory block.
 */
BOOL  DibInfo(LPBITMAPINFOHEADER lpbiSource, LPBITMAPINFOHEADER lpbiTarget)
{
    if (lpbiSource)
    {
	*lpbiTarget = *lpbiSource;

	if (lpbiTarget->biSize == sizeof(BITMAPCOREHEADER))
	{
	    BITMAPCOREHEADER bc;

	    bc = *(LPBITMAPCOREHEADER)lpbiTarget;

	    lpbiTarget->biSize               = sizeof(BITMAPINFOHEADER);
	    lpbiTarget->biWidth              = (DWORD)bc.bcWidth;
	    lpbiTarget->biHeight             = (DWORD)bc.bcHeight;
	    lpbiTarget->biPlanes             =  (UINT)bc.bcPlanes;
	    lpbiTarget->biBitCount           =  (UINT)bc.bcBitCount;
	    lpbiTarget->biCompression        = BI_RGB;
	    lpbiTarget->biSizeImage          = 0;
	    lpbiTarget->biXPelsPerMeter      = 0;
	    lpbiTarget->biYPelsPerMeter      = 0;
	    lpbiTarget->biClrUsed            = 0;
	    lpbiTarget->biClrImportant       = 0;
	}

	/*
	 * fill in the default fields
	 */
	if (lpbiTarget->biSize != sizeof(BITMAPCOREHEADER))
	{
	    if (lpbiTarget->biSizeImage == 0L)
		lpbiTarget->biSizeImage = (DWORD)DIBWIDTHBYTES(*lpbiTarget) * lpbiTarget->biHeight;

	    if (lpbiTarget->biClrUsed == 0L)
		lpbiTarget->biClrUsed = DibNumColors(lpbiTarget);
	}
	return TRUE;
    }
    return FALSE;
}

HPALETTE CreateColorPalette()
{
    LOGPALETTE          *pPal;
    HPALETTE            hpal = NULL;
    WORD                nNumColors;
    BYTE                red;
    BYTE                green;
    BYTE                blue;
    int                 i;

    nNumColors = MAXPALETTE;
    pPal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));

    if (!pPal)
	goto exit;

    pPal->palNumEntries = nNumColors;
    pPal->palVersion    = PALVERSION;

    red = green = blue = 0;

    for (i = 0; i < pPal->palNumEntries; i++)
    {
	pPal->palPalEntry[i].peRed   = red;
	pPal->palPalEntry[i].peGreen = green;
	pPal->palPalEntry[i].peBlue  = blue;
	pPal->palPalEntry[i].peFlags = (BYTE)0;

	if (!(red += 32))
	    if (!(green += 32))
		blue += 64;
    }

    hpal = CreatePalette(pPal);
    LocalFree((HANDLE)pPal);

exit:
    return hpal;
}

/*
 *  CreateBIPalette()
 *
 *  Given a Pointer to a BITMAPINFO struct will create a
 *  a GDI palette object from the color table.
 *
 *  works with "old" and "new" DIB's
 *
 */
HPALETTE CreateBIPalette(LPBITMAPINFOHEADER lpbi)
{
    LOGPALETTE          *pPal;
    HPALETTE            hpal = NULL;
    WORD                nNumColors;
    UINT                i;
    RGBQUAD        FAR *pRgb;
    BOOL                fCoreHeader;

    if (!lpbi)
	return NULL;

    nNumColors = DibNumColors(lpbi);

    if (nNumColors)
    {
		fCoreHeader = (lpbi->biSize == sizeof(BITMAPCOREHEADER));

		pRgb = (RGBQUAD FAR *)((LPBYTE)lpbi + (UINT)lpbi->biSize);
		pPal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));

		if (!pPal)
			goto exit;

		pPal->palNumEntries = nNumColors;
		pPal->palVersion    = PALVERSION;

		for (i = 0; i < nNumColors; i++)
		{
			pPal->palPalEntry[i].peRed       = pRgb->rgbRed;
			pPal->palPalEntry[i].peGreen = pRgb->rgbGreen;
			pPal->palPalEntry[i].peBlue  = pRgb->rgbBlue;
			pPal->palPalEntry[i].peFlags = (BYTE)0;

			if (fCoreHeader)
				//((LPBYTE)pRgb) += sizeof(RGBTRIPLE) ;
                pRgb += sizeof(RGBTRIPLE) ;
			else
				pRgb++;
		}

		hpal = CreatePalette(pPal);
		LocalFree((HANDLE)pPal);
    }
    else if (lpbi->biBitCount == 24)
    {
	hpal = CreateColorPalette();
    }

exit:
    return hpal;
}


/*
 *  CreateDibPalette()
 *
 *  Given a Global HANDLE to a BITMAPINFO Struct
 *  will create a GDI palette object from the color table.
 *
 *  works with "old" and "new" DIB's
 *
 */
HPALETTE CreateDibPalette(HANDLE hbi)
{
    HPALETTE hpal;

    if (!hbi)
	return NULL;

    hpal = CreateBIPalette((LPBITMAPINFOHEADER)GlobalLock(hbi));
    GlobalUnlock(hbi);
    return hpal;
}

HPALETTE CreateExplicitPalette()
{
    PLOGPALETTE ppal;
    HPALETTE    hpal;
    int         i;
    #define     NPAL   256

    ppal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * NPAL);

    ppal->palVersion    = 0x300;
    ppal->palNumEntries = NPAL;

    for (i=0; i<NPAL; i++)
    {
	ppal->palPalEntry[i].peFlags = (BYTE)PC_EXPLICIT;
	ppal->palPalEntry[i].peRed   = (BYTE)i;
	ppal->palPalEntry[i].peGreen = (BYTE)0;
	ppal->palPalEntry[i].peBlue  = (BYTE)0;
    }

    hpal = CreatePalette(ppal);
    LocalFree((HANDLE)ppal);
    return hpal;
}



/*
 *  ReadDibBitmapInfo()
 *
 *  Will read a file in DIB format and return a global HANDLE to it's
 *  BITMAPINFO.  This function will work with both "old" and "new"
 *  bitmap formats, but will always return a "new" BITMAPINFO
 *
 */
HANDLE ReadDibBitmapInfo(HFILE fh)
{
    DWORD     off;
    HANDLE    hbi = NULL;
    int       size;
    int       i;
    UINT      nNumColors;

    RGBQUAD FAR       *pRgb;
    BITMAPINFOHEADER   bi;
    BITMAPCOREHEADER   bc;
    LPBITMAPINFOHEADER lpbi;
    BITMAPFILEHEADER   bf;

    if (fh == (HFILE)-1)
	return NULL;

    off = _llseek(fh,0L,SEEK_CUR);

    if (sizeof(bf) != _lread(fh,(LPBYTE)&bf,sizeof(bf)))
	return FALSE;

    /*
     *  do we have a RC HEADER?
     */
    if (!ISDIB(bf.bfType))
    {
	bf.bfOffBits = 0L;
	_llseek(fh,off,SEEK_SET);
    }

    if (sizeof(bi) != _lread(fh,(LPBYTE)&bi,sizeof(bi)))
	return FALSE;

    nNumColors = DibNumColors(&bi);

    /*
     *  what type of bitmap info is this?
     */
    switch (size = (int)bi.biSize)
    {
	case sizeof(BITMAPINFOHEADER):
	    break;

	case sizeof(BITMAPCOREHEADER):
	    bc = *(BITMAPCOREHEADER*)&bi;
	    bi.biSize               = sizeof(BITMAPINFOHEADER);
	    bi.biWidth              = (DWORD)bc.bcWidth;
	    bi.biHeight             = (DWORD)bc.bcHeight;
	    bi.biPlanes             =  (UINT)bc.bcPlanes;
	    bi.biBitCount           =  (UINT)bc.bcBitCount;
	    bi.biCompression        = BI_RGB;
	    bi.biSizeImage          = 0;
	    bi.biXPelsPerMeter      = 0;
	    bi.biYPelsPerMeter      = 0;
	    bi.biClrUsed            = nNumColors;
	    bi.biClrImportant       = nNumColors;

	    _llseek(fh,(LONG)sizeof(BITMAPCOREHEADER)-sizeof(BITMAPINFOHEADER),SEEK_CUR);

	    break;

	default:
	    return NULL;       /* not a DIB */
    }

    /*
     *  fill in some default values!
     */
    if (bi.biSizeImage == 0)
    {
	bi.biSizeImage = (DWORD)DIBWIDTHBYTES(bi) * bi.biHeight;
    }

    if (bi.biXPelsPerMeter == 0)
    {
	bi.biXPelsPerMeter = 0;         // ??????????????
    }

    if (bi.biYPelsPerMeter == 0)
    {
	bi.biYPelsPerMeter = 0;         // ??????????????
    }

    if (bi.biClrUsed == 0)
    {
	bi.biClrUsed = DibNumColors(&bi);
    }

    hbi = GlobalAlloc(GMEM_MOVEABLE,(LONG)bi.biSize + nNumColors * sizeof(RGBQUAD));
    if (!hbi)
	return NULL;

    lpbi = (BITMAPINFOHEADER *)GlobalLock(hbi);
    *lpbi = bi;

    pRgb = (RGBQUAD FAR *)((LPBYTE)lpbi + bi.biSize);

    if (nNumColors)
    {
	if (size == (int)sizeof(BITMAPCOREHEADER))
	{
	    /*
	     * convert a old color table (3 byte entries) to a new
	     * color table (4 byte entries)
	     */
	    _lread(fh,(LPBYTE)pRgb,nNumColors * sizeof(RGBTRIPLE));

	    for (i=nNumColors-1; i>=0; i--)
	    {
		RGBQUAD rgb;

		rgb.rgbRed      = ((RGBTRIPLE FAR *)pRgb)[i].rgbtRed;
		rgb.rgbBlue     = ((RGBTRIPLE FAR *)pRgb)[i].rgbtBlue;
		rgb.rgbGreen    = ((RGBTRIPLE FAR *)pRgb)[i].rgbtGreen;
		rgb.rgbReserved = (BYTE)0;

		pRgb[i] = rgb;
	    }
	}
	else
	{
	    _lread(fh,(LPBYTE)pRgb,nNumColors * sizeof(RGBQUAD));
	}
    }

    if (bf.bfOffBits != 0L)
	_llseek(fh,off + bf.bfOffBits,SEEK_SET);

    GlobalUnlock(hbi);
    return hbi;
}

/*  How big is the palette? if bits per pel not 24
 *  no of bytes to read is 6 for 1 bit, 48 for 4 bits
 *  256*3 for 8 bits and 0 for 24 bits
 */
UINT PaletteSize(VOID FAR * pv)
{
    #define lpbi ((LPBITMAPINFOHEADER)pv)
    #define lpbc ((LPBITMAPCOREHEADER)pv)

    UINT    NumColors;

    NumColors = DibNumColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	return NumColors * sizeof(RGBTRIPLE);
    else
	return NumColors * sizeof(RGBQUAD);

    #undef lpbi
    #undef lpbc
}

/*  How Many colors does this DIB have?
 *  this will work on both PM and Windows bitmap info structures.
 */
WORD DibNumColors(VOID FAR * pv)
{
    #define lpbi ((LPBITMAPINFOHEADER)pv)
    #define lpbc ((LPBITMAPCOREHEADER)pv)

    int bits;

    /*
     *  with the new format headers, the size of the palette is in biClrUsed
     *  else is dependent on bits per pixel
     */
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
    {
	if (lpbi->biClrUsed != 0)
	    return (UINT)lpbi->biClrUsed;

	bits = lpbi->biBitCount;
    }
    else
    {
	bits = lpbc->bcBitCount;
    }

    switch (bits)
    {
    case 1:
	    return 2;
    case 4:
	    return 16;
    case 8:
	    return 256;
    default:
	    return 0;
    }

    #undef lpbi
    #undef lpbc
}

/*
 *  DibFromBitmap()
 *
 *  Will create a global memory block in DIB format that represents the DDB
 *  passed in
 *
 */
HANDLE DibFromBitmap(HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage)
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dwLen;
    int                  nColors;
    HANDLE               hdib;
    HANDLE               h;
    HDC                  hdc;

    if (wUsage == 0)
	wUsage = DIB_RGB_COLORS;

    if (!hbm)
	return NULL;
#if 0
    if (biStyle == BI_RGB && wUsage == DIB_RGB_COLORS)
	return CreateLogicalDib(hbm,biBits,hpal);
#endif

    if (hpal == NULL)
	hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    GetObject(hbm,sizeof(bm),(LPBYTE)&bm);
#ifdef WIN32
    nColors = 0;  // GetObject only stores two bytes
#endif
    GetObject(hpal,sizeof(nColors),(LPBYTE)&nColors);

    if (biBits == 0)
	biBits = bm.bmPlanes * bm.bmBitsPixel;

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = biStyle;
    bi.biSizeImage          = 0;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = 0;
    bi.biClrImportant       = 0;

    dwLen  = bi.biSize + PaletteSize(&bi);

    hdc = CreateCompatibleDC(NULL);
    hpal = SelectPalette(hdc,hpal,TRUE);
    RealizePalette(hdc);  // why is this needed on a MEMORY DC? GDI bug??

    hdib = GlobalAlloc(GMEM_MOVEABLE,dwLen);

    if (!hdib)
	goto exit;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    *lpbi = bi;

    /*
     *  call GetDIBits with a NULL lpBits param, so it will calculate the
     *  biSizeImage field for us
     */
    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
	NULL, (LPBITMAPINFO)lpbi, wUsage);

    bi = *lpbi;
    GlobalUnlock(hdib);

    /*
     * HACK! if the driver did not fill in the biSizeImage field, make one up
     */
    if (bi.biSizeImage == 0)
    {
	bi.biSizeImage = (DWORD)WIDTHBYTES(bm.bmWidth * biBits) * bm.bmHeight;

	if (biStyle != BI_RGB)
	    bi.biSizeImage = (bi.biSizeImage * 3) / 2;
    }

    /*
     *  realloc the buffer big enough to hold all the bits
     */
    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;
    if (h = GlobalReAlloc(hdib,dwLen,GMEM_MOVEABLE))
    {
	hdib = h;
    }
    else
    {
	GlobalFree(hdib);
	hdib = NULL;
	goto exit;
    }

    /*
     *  call GetDIBits with a NON-NULL lpBits param, and actualy get the
     *  bits this time
     */
    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
	(LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi),
	(LPBITMAPINFO)lpbi, wUsage);

    bi = *lpbi;
    lpbi->biClrUsed = DibNumColors(lpbi) ;
    GlobalUnlock(hdib);

exit:
    SelectPalette(hdc,hpal,TRUE);
    DeleteDC(hdc);
    return hdib;
}

/*
 *  BitmapFromDib()
 *
 *  Will create a DDB (Device Dependent Bitmap) given a global handle to
 *  a memory block in CF_DIB format
 *
 */
HBITMAP BitmapFromDib(HANDLE hdib, HPALETTE hpal, UINT wUsage)
{
    LPBITMAPINFOHEADER lpbi;
    HPALETTE    hpalT;
    HDC         hdc;
    HBITMAP     hbm;
#if 0
    UINT        dx,dy,bits;
#endif

    if (!hdib)
	return NULL;

    if (wUsage == 0)
	wUsage = DIB_RGB_COLORS;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    if (!lpbi)
	return NULL;

    hdc = GetDC(NULL);
//    hdc = CreateCompatibleDC(NULL);

    if (hpal)
    {
	hpalT = SelectPalette(hdc,hpal,TRUE);
	RealizePalette(hdc);  // why is this needed on a MEMORY DC? GDI bug??
    }

#if 0
    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
    {
	dx   = ((LPBITMAPCOREHEADER)lpbi)->bcWidth;
	dy   = ((LPBITMAPCOREHEADER)lpbi)->bcHeight;
	bits = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;
    }
    else
    {
	dx   = (UINT)lpbi->biWidth;
	dy   = (UINT)lpbi->biHeight;
	bits = (UINT)lpbi->biBitCount;
    }

    if (bMonoBitmap /* || bits == 1 */)
    {
	hbm = CreateBitmap(dx,dy,1,1,NULL);
    }
    else
    {
	HDC hdcScreen = GetDC(NULL);
	hbm = CreateCompatibleBitmap(hdcScreen,dx,dy);
	ReleaseDC(NULL,hdcScreen);
    }

    if (hbm)
    {
	if (fErrProp)
	    SetDIBitsErrProp(hdc,hbm,0,dy,
	       (LPBYTE)lpbi + lpbi->biSize + PaletteSize(lpbi),
	       (LPBITMAPINFO)lpbi,wUsage);
	else
	    SetDIBits(hdc,hbm,0,dy,
	       (LPBYTE)lpbi + lpbi->biSize + PaletteSize(lpbi),
	       (LPBITMAPINFO)lpbi,wUsage);
    }

#else
    hbm = CreateDIBitmap(hdc,
		(LPBITMAPINFOHEADER)lpbi,
		(LONG)CBM_INIT,
		(LPBYTE)lpbi + lpbi->biSize + PaletteSize(lpbi),
		(LPBITMAPINFO)lpbi,
		wUsage );
#endif

    if (hpal && hpalT)
	SelectPalette(hdc,hpalT,TRUE);

//    DeleteDC(hdc);
    ReleaseDC(NULL,hdc);

    GlobalUnlock(hdib);
    return hbm;
}

/*
 *  DibFromDib()
 *
 *  Will convert a DIB in 1 format to a DIB in the specifed format
 *
 */
HANDLE DibFromDib(HANDLE hdib, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage)
{
    BITMAPINFOHEADER bi;
    HBITMAP     hbm;
    BOOL        fKillPalette=FALSE;

    if (!hdib)
	return NULL;

    DibInfo((LPBITMAPINFOHEADER)GlobalLock(hdib),&bi); GlobalUnlock(hdib);

    /*
     *  do we have the requested format already?
     */
    if (bi.biCompression == biStyle && (UINT)bi.biBitCount == biBits)
	return hdib;

    if (hpal == NULL)
    {
	hpal = CreateDibPalette(hdib);
	fKillPalette++;
    }

    hbm = BitmapFromDib(hdib,hpal,wUsage);

    if (hbm == NULL)
    {
	hdib = NULL;
    }
    else
    {
	hdib = DibFromBitmap(hbm,biStyle,biBits,hpal,wUsage);
	DeleteObject(hbm);
    }

    if (fKillPalette && hpal)
	DeleteObject(hpal);

    return hdib;
}

#define MAKEP(sel,off)  ((VOID FAR *)MAKELONG(off,sel))

/*
 *  CreateLogicalDib
 *
 *  Given a DDB and a HPALETTE create a "logical" DIB
 *
 *  if the HBITMAP is NULL create a DIB from the system "stock" bitmap
 *      This is used to save a logical palette to a disk file as a DIB
 *
 *  if the HPALETTE is NULL use the system "stock" palette (ie the
 *      system palette)
 *
 *  a "logical" DIB is a DIB where the DIB color table *exactly* matches
 *  the passed logical palette.  There will be no system colors in the DIB
 *  block, and a pixel value of <n> in the DIB will correspond to logical
 *  palette index <n>.
 *
 *  This is accomplished by doing a GetDIBits() with the DIB_PAL_COLORS
 *  option then converting the palindexes returned in the color table
 *  from palette indexes to logical RGB values.  The entire passed logical
 *  palette is always copied to the DIB color table.
 *
 *  The DIB color table will have exactly the same number of entries as
 *  the logical palette.  Normaly GetDIBits() will always set biClrUsed to
 *  the maximum colors supported by the device regardless of the number of
 *  colors in the logical palette
 *
 *  Why would you want to do this?  The major reason for a "logical" DIB
 *  is so when the DIB is written to a disk file then reloaded the logical
 *  palette created from the DIB color table will be the same as one used
 *  originaly to create the bitmap.  It also will prevent GDI from doing
 *  nearest color matching on PC_RESERVED palettes.
 *
 *  ** What do we do if the logical palette has more than 256 entries!!!!!
 *  ** GetDIBits() may return logical palette index's that are greater than
 *  ** 256, we cant represent these colors in the "logical" DIB
 *  **
 *  ** for now hose the caller?????
 *
 */

HANDLE CreateLogicalDib(HBITMAP hbm, WORD biBits, HPALETTE hpal)
{
    BITMAP              bm;
    BITMAPINFOHEADER    bi;
    LPBITMAPINFOHEADER  lpDib;      // pointer to DIB
    LPBITMAPINFOHEADER  lpbi;       // temp pointer to BITMAPINFO
    DWORD               dwLen;
    DWORD               dw;
    int                 n;
    int                 nColors;
    HANDLE              hdib;
    HDC                 hdc;
    BYTE FAR *          lpBits;
    UINT FAR *          lpCT;
    RGBQUAD FAR *       lpRgb;
    PALETTEENTRY        peT;
    HPALETTE            hpalT;

    if (hpal == NULL)
	hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    if (hbm == NULL)
	hbm = NULL; // ????GetStockObject(STOCK_BITMAP);

#ifdef WIN32
    nColors = 0;  // GetObject only stores two bytes
#endif
    GetObject(hpal,sizeof(nColors),(LPBYTE)&nColors);
    GetObject(hbm,sizeof(bm),(LPBYTE)&bm);

    if (biBits == 0)
	biBits = nColors > 16 ? 8 : 4;

/*
    if (nColors > 256)      // ACK!
	;                   // How do we handle this????
*/

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = BI_RGB;
    bi.biSizeImage          = (DWORD)WIDTHBYTES(bm.bmWidth * biBits) * bm.bmHeight;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = nColors;
    bi.biClrImportant       = 0;

    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;

    hdib = GlobalAlloc(GMEM_MOVEABLE,dwLen);

    if (!hdib)
	return NULL;

    lpbi = (BITMAPINFOHEADER*)MAKEP(GlobalAlloc(GMEM_FIXED,bi.biSize + 256 * sizeof(RGBQUAD)),0);

    if (!lpbi)
    {
	GlobalFree(hdib);
	return NULL;
    }

    hdc = GetDC(NULL);
    hpalT = SelectPalette(hdc,hpal,TRUE);
    RealizePalette(hdc);  // why is this needed on a MEMORY DC? GDI bug??

    lpDib = (BITMAPINFOHEADER*)GlobalLock(hdib);

    *lpbi  = bi;
    *lpDib = bi;
    lpCT   = (UINT FAR *)((LPBYTE)lpbi + (UINT)lpbi->biSize);
    lpRgb  = (RGBQUAD FAR *)((LPBYTE)lpDib + (UINT)lpDib->biSize);
    lpBits = (LPBYTE)lpDib + (UINT)lpDib->biSize + PaletteSize(lpDib);

    /*
     *  call GetDIBits to get the DIB bits and fill the color table with
     *  logical palette index's
     */
    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
	lpBits,(LPBITMAPINFO)lpbi, DIB_PAL_COLORS);

    /*
     *  Now convert the DIB bits into "real" logical palette index's
     *
     *  lpCT        points to the DIB color table wich is a UINT array of
     *              logical palette index's
     *
     *  lpBits      points to the DIB bits, each DIB pixel is a index into
     *              the DIB color table.
     *
     */

    if (biBits == 8)
    {
	for (dw = 0; dw < bi.biSizeImage; dw++, ((BYTE HUGE_T *)lpBits)++)
	    *lpBits = (BYTE)lpCT[*lpBits];
    }
    else // biBits == 4
    {
	for (dw = 0; dw < bi.biSizeImage; dw++, ((BYTE HUGE_T *)lpBits)++)
	    *lpBits = lpCT[*lpBits & 0x0F] | (lpCT[(*lpBits >> 4) & 0x0F] << 4);
    }

    /*
     *  Now copy the RGBs in the logical palette to the dib color table
     */
    for (n=0; n<nColors; n++,lpRgb++)
    {
	GetPaletteEntries(hpal,n,1,&peT);

	lpRgb->rgbRed      = peT.peRed;
	lpRgb->rgbGreen    = peT.peGreen;
	lpRgb->rgbBlue     = peT.peBlue;
	lpRgb->rgbReserved = (BYTE)0;
    }

    GlobalUnlock(hdib);
#ifdef WIN32
    GlobalFree(GlobalHandle(lpbi));
#else
    GlobalFree(SELECTOROF(lpbi));
#endif

    SelectPalette(hdc,hpalT,TRUE);
    ReleaseDC(NULL,hdc);

    return hdib;
}

/*
 *  Draws bitmap <hbm> at the specifed position in DC <hdc>
 *
 */
BOOL StretchBitmap(HDC hdc, int x, int y, int dx, int dy, HBITMAP hbm, int x0, int y0, int dx0, int dy0, DWORD rop)
{
    HDC hdcBits;
    HPALETTE hpal,hpalT;
    BOOL f;

    if (!hdc || !hbm)
	return FALSE;

    hpal = SelectPalette(hdc,(HPALETTE)GetStockObject(DEFAULT_PALETTE),TRUE);
    SelectPalette(hdc,hpal,TRUE);

    hdcBits = CreateCompatibleDC(hdc);
    SelectObject(hdcBits,hbm);
    hpalT = SelectPalette(hdcBits,hpal,TRUE);
    RealizePalette(hdcBits);
    f = StretchBlt(hdc,x,y,dx,dy,hdcBits,x0,y0,dx0,dy0,rop);
    SelectPalette(hdcBits,hpalT,TRUE);
    DeleteDC(hdcBits);

    return f;
}

/*
 *  Draws bitmap <hbm> at the specifed position in DC <hdc>
 *
 */
BOOL DrawBitmap(HDC hdc, int x, int y, HBITMAP hbm, DWORD rop)
{
    HDC hdcBits;
    BITMAP bm;
    BOOL f;

    if (!hdc || !hbm)
	return FALSE;

    hdcBits = CreateCompatibleDC(hdc);
    GetObject(hbm,sizeof(BITMAP),(LPBYTE)&bm);
    SelectObject(hdcBits,hbm);
    f = BitBlt(hdc,x,y,bm.bmWidth,bm.bmHeight,hdcBits,0,0,rop);
    DeleteDC(hdcBits);

    return f;
}

/*
 *  SetDibUsage(hdib,hpal,wUsage)
 *
 *  Modifies the color table of the passed DIB for use with the wUsage
 *  parameter specifed.
 *
 *  if wUsage is DIB_PAL_COLORS the DIB color table is set to 0-256
 *  if wUsage is DIB_RGB_COLORS the DIB color table is set to the RGB values
 *      in the passed palette
 *
 */
BOOL SetDibUsage(HANDLE hdib, HPALETTE hpal,UINT wUsage)
{
    LPBITMAPINFOHEADER lpbi;
    PALETTEENTRY       ape[MAXPALETTE];
    RGBQUAD FAR *      pRgb;
    UINT FAR *         pw;
    int                nColors;
    int                n;

    if (hpal == NULL)
	hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    if (!hdib)
	return FALSE;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    if (!lpbi)
	return FALSE;

    nColors = DibNumColors(lpbi);

    if (nColors > 0)
    {
	pRgb = (RGBQUAD FAR *)((LPBYTE)lpbi + (UINT)lpbi->biSize);

	switch (wUsage)
	{
	    //
	    // Set the DIB color table to palette indexes
	    //
	    case DIB_PAL_COLORS:
		for (pw = (UINT FAR*)pRgb,n=0; n<nColors; n++,pw++)
		    *pw = n;
		break;

	    //
	    // Set the DIB color table to RGBQUADS
	    //
	    default:
	    case DIB_RGB_COLORS:
		nColors = min(nColors,MAXPALETTE);

		GetPaletteEntries(hpal,0,nColors,ape);

		for (n=0; n<nColors; n++)
		{
		    pRgb[n].rgbRed      = ape[n].peRed;
		    pRgb[n].rgbGreen    = ape[n].peGreen;
		    pRgb[n].rgbBlue     = ape[n].peBlue;
		    pRgb[n].rgbReserved = 0;
		}
		break;
	}
    }
    GlobalUnlock(hdib);
    return TRUE;
}

/*
 *  SetPalFlags(hpal,iIndex, cnt, wFlags)
 *
 *  Modifies the palette flags of all indexs in the range (iIndex - nIndex+cnt)
 *  to the parameter specifed.
 *
 */
BOOL SetPalFlags(HPALETTE hpal, int iIndex, int cntEntries, UINT wFlags)
{
    int     i;
    BOOL    f;
    HANDLE  hpe;
    PALETTEENTRY FAR *lppe;

    if (hpal == NULL)
	return FALSE;

    if (cntEntries < 0) {
#ifdef WIN32
	cntEntries = 0;  // GetObject only stores two bytes
#endif
	GetObject(hpal,sizeof(int),(LPBYTE)&cntEntries);
    }

    hpe = GlobalAlloc(GMEM_MOVEABLE,(LONG)cntEntries * sizeof(PALETTEENTRY));

    if (!hpe)
	return FALSE;

    lppe = (PALETTEENTRY*)GlobalLock(hpe);

    GetPaletteEntries(hpal, iIndex, cntEntries, lppe);

    for (i=0; i<cntEntries; i++)
    {
	lppe[i].peFlags = (BYTE)wFlags;
    }

    f = SetPaletteEntries(hpal, iIndex, cntEntries, lppe);

    GlobalUnlock(hpe);
    GlobalFree(hpe);
    return f;
}

/*
 *  StretchDibBlt()
 *
 *  draws a bitmap in CF_DIB format, using StretchDIBits()
 *
 *  takes the same parameters as StretchBlt()
 */
BOOL StretchDibBlt(HDC hdc, int x, int y, int dx, int dy, HANDLE hdib, int x0, int y0, int dx0, int dy0, LONG rop, UINT wUsage)
{
    LPBITMAPINFOHEADER lpbi;
    LPBYTE        pBuf;
    BOOL         f;

    if (!hdib)
    {
	    return PatBlt(hdc,x,y,dx,dy,rop);
    }

    if (wUsage == 0)
    {
	    wUsage = DIB_RGB_COLORS;
    }

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    if (!lpbi)
    {
	    return FALSE;
    }

    if (dx0 == -1 && dy0 == -1)
    {
	    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	    {
	        dx0 = ((LPBITMAPCOREHEADER)lpbi)->bcWidth;
	        dy0 = ((LPBITMAPCOREHEADER)lpbi)->bcHeight;
	    }
	    else
	    {
	        dx0 = (int)lpbi->biWidth;
	        dy0 = (int)lpbi->biHeight;
	    }
    }

    if (dx < 0 && dy < 0)
    {
	    dx = dx0 * (-dx);
	    dy = dy0 * (-dy);
    }

    pBuf = (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi);

    f = StretchDIBits (
	                    hdc,
	                    x,y,
	                    dx,dy,
	                    x0,y0,
	                    dx0,dy0,
	                    pBuf, (LPBITMAPINFO)lpbi,
	                    wUsage,
	                    rop);

    GlobalUnlock(hdib);
    return f;
}

/*
 *  DibBlt()
 *
 *  draws a bitmap in CF_DIB format, using SetDIBits to device.
 *
 *  takes the same parameters as BitBlt()
 */
BOOL DibBlt(HDC hdc, int x0, int y0, int dx, int dy, HANDLE hdib, int x1, int y1, LONG rop, UINT wUsage)
{
    LPBITMAPINFOHEADER lpbi;
    LPBYTE       pBuf;
    BOOL        f;

    if (!hdib)
	return PatBlt(hdc,x0,y0,dx,dy,rop);

    if (wUsage == 0)
	wUsage = DIB_RGB_COLORS;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    if (!lpbi)
	return FALSE;

    if (dx == -1 && dy == -1)
    {
	if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	{
	    dx = ((LPBITMAPCOREHEADER)lpbi)->bcWidth;
	    dy = ((LPBITMAPCOREHEADER)lpbi)->bcHeight;
	}
	else
	{
	    dx = (int)lpbi->biWidth;
	    dy = (int)lpbi->biHeight;
	}
    }

    pBuf = (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi);

#if 0
    f = SetDIBitsToDevice(hdc, x0, y0, dx, dy,
	x1,y1,
	x1,
	dy,
	pBuf, (LPBITMAPINFO)lpbi,
	wUsage );
#else
    f = StretchDIBits (
	hdc,
	x0,y0,
	dx,dy,
	x1,y1,
	dx,dy,
	pBuf, (LPBITMAPINFO)lpbi,
	wUsage,
	rop);
#endif

    GlobalUnlock(hdib);
    return f;
}

LPVOID DibLock(HANDLE hdib,int x, int y)
{
    return DibXY((LPBITMAPINFOHEADER)GlobalLock(hdib),x,y);
}

VOID DibUnlock(HANDLE hdib)
{
    GlobalUnlock(hdib);
}

LPVOID DibXY(LPBITMAPINFOHEADER lpbi,int x, int y)
{
    BYTE HUGE_T *pBits;
    DWORD ulWidthBytes;

    pBits = (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi);

    ulWidthBytes = DIBWIDTHBYTES(*lpbi);

    pBits += (ulWidthBytes * (long)y) + x;

    return (LPVOID)pBits;
}

    //
    // These are the standard VGA colors, we will be stuck with until the
    // end of time!
    //
    static DWORD CosmicColors[16] = {
	 0x00000000        // 0000  black
	,0x00800000        // 0001  dark red
	,0x00008000        // 0010  dark green
	,0x00808000        // 0011  mustard
	,0x00000080        // 0100  dark blue
	,0x00800080        // 0101  purple
	,0x00008080        // 0110  dark turquoise
	,0x00C0C0C0        // 1000  gray
	,0x00808080        // 0111  dark gray
	,0x00FF0000        // 1001  red
	,0x0000FF00        // 1010  green
	,0x00FFFF00        // 1011  yellow
	,0x000000FF        // 1100  blue
	,0x00FF00FF        // 1101  pink (magenta)
	,0x0000FFFF        // 1110  cyan
	,0x00FFFFFF        // 1111  white
	};

HANDLE CreateDib(WORD bits, int dx, int dy)
{
    HANDLE              hdib;
    BITMAPINFOHEADER    bi;
    LPBITMAPINFOHEADER  lpbi;
    DWORD FAR *         pRgb;
    UINT                i;


    bi.biSize           = sizeof(BITMAPINFOHEADER);
    bi.biPlanes         = 1;
    bi.biBitCount       = bits;
    bi.biWidth          = dx;
    bi.biHeight         = dy;
    bi.biCompression    = BI_RGB;
    bi.biSizeImage      = 0;
    bi.biXPelsPerMeter  = 0;
    bi.biYPelsPerMeter  = 0;
    bi.biClrUsed                = 0;
    bi.biClrImportant   = 0;
    bi.biClrUsed        = DibNumColors(&bi);

    hdib = GlobalAlloc(GMEM_MOVEABLE,sizeof(BITMAPINFOHEADER) +
		+ (long)bi.biClrUsed * sizeof(RGBQUAD)
		+ (long)DIBWIDTHBYTES(bi) * (long)dy);

    if (hdib)
    {
	lpbi  = (BITMAPINFOHEADER*)GlobalLock(hdib);
	*lpbi = bi;

	pRgb  = (unsigned long*)((LPBYTE)lpbi + lpbi->biSize);

	//
	//  setup the color table
	//
	if (bits == 1)
	{
	    pRgb[0] = CosmicColors[0];
	    pRgb[1] = CosmicColors[15];
	}
	else
	{
	    for (i=0; i<bi.biClrUsed; i++)
				pRgb[i] = CosmicColors[i % 16];
	}

	GlobalUnlock(hdib);
    }

    return hdib;
}

/*
 * Private routines to read/write more than 64k
 */

#define MAXREAD (UINT)(32u * 1024)

static DWORD NEAR PASCAL lread(HFILE fh, VOID FAR *pv, DWORD ul)
{
    DWORD  ulT = ul;
    BYTE HUGE_T *hp = (unsigned char*)pv;

    while (ul > MAXREAD) {
	if (_lread(fh, (LPBYTE)hp, MAXREAD) != MAXREAD)
		return 0;
	ul -= MAXREAD;
	hp += MAXREAD;
    }
    if (_lread(fh, (LPBYTE)hp, (UINT)ul) != (UINT)ul)
	return 0;
    return ulT;
}

static DWORD NEAR PASCAL lwrite(HFILE fh, VOID FAR *pv, DWORD ul)
{
    DWORD  ulT = ul;
    BYTE HUGE_T *hp = (unsigned char*)pv;

    while (ul > MAXREAD) {
	if (_lwrite(fh, (const char*)hp, MAXREAD) != MAXREAD)
		return 0;
	ul -= MAXREAD;
	hp += MAXREAD;
    }
    if (_lwrite(fh, (const char*)hp, (UINT)ul) != (UINT)ul)
	return 0;
    return ulT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdplay\trklst.cpp ===
/******************************Module*Header*******************************\
* Module Name: trklst.c
*
* This module manipulates the cdrom track list.  The table of contents MUST
* be locked for ALL cdrom devices before calling any functions in this module.
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include "windows.h"
#include "windowsx.h"
#include "playres.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "scan.h"
#include "database.h"
#include "trklst.h"
#include "tchar.h"


/******************************Public*Routine******************************\
* ComputeDriveComboBox
*
* This routine deletes and then reads all the drive (artist) selections
* to the drive combobox.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ComputeDriveComboBox(
    void
    )
{
    int i,index;
    HWND hwnd;

    hwnd = g_hwndControls[INDEX(IDC_ARTIST_NAME)];

    //SetWindowRedraw( hwnd, FALSE );
    ComboBox_ResetContent( hwnd );

    index = 0;
    for( i = 0; i < g_NumCdDevices; i++ ) {

        ComboBox_InsertString( hwnd, -1, i );

        if ( i == g_CurrCdrom ) {

            index = i;
        }

    }

    SetWindowRedraw( hwnd, TRUE );
    ComboBox_SetCurSel( hwnd, index );

    RedrawWindow( hwnd, NULL, NULL, RDW_INVALIDATE );
    UpdateWindow( hwnd );
}



/*****************************Private*Routine******************************\
* SwitchToCdrom
*
* This routine is called when the used selects a new cdrom device
* to access.  It handles reset the state of both the "old" and "new"
* chosen cdroms.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SwitchToCdrom(
    int NewCdrom,
    BOOL prompt
    )
{
    int oldState, oldState2;
    TCHAR   s1[256], s2[256];

    oldState = g_Devices[g_LastCdrom]->State;
    oldState2 = g_Devices[g_CurrCdrom]->State;

    if (NewCdrom != g_LastCdrom) {

        if (prompt) {

            if (g_Devices[g_CurrCdrom]->State & CD_PLAYING) {

                _tcscpy( s1, IdStr( STR_CANCEL_PLAY ) );
                _tcscpy( s2, IdStr( STR_CHANGE_CDROM ) );

                if ( MessageBox( g_hwndApp, s1, s2,
                                MB_APPLMODAL | MB_DEFBUTTON1 |
                                MB_ICONQUESTION | MB_YESNO) != IDYES ) {
                    return;
                }
            }
        }


        /*
        ** stop the drive we're leaving
        */

        g_CurrCdrom = g_LastCdrom;

        if (prompt && (g_State & (CD_PLAYING | CD_PAUSED)) ) {

            HWND hwndButton;

            hwndButton = g_hwndControls[INDEX(IDM_PLAYBAR_STOP)];

            SendMessage( hwndButton, WM_LBUTTONDOWN, 0, 0L );
            SendMessage( hwndButton, WM_LBUTTONUP, 0, 0L );

        } else {

            if ( StopTheCdromDrive( g_LastCdrom ) )
            {
                g_State &= (~(CD_PLAYING | CD_PAUSED));
                g_State |= CD_STOPPED;
                g_pSink->OnEvent(MMEVENT_ONSTOP,NULL);
            }
        }

        /*
        ** Set new cdrom drive and initialize time fields
        */

        g_LastCdrom = g_CurrCdrom = NewCdrom;

        TimeAdjustInitialize( g_CurrCdrom );

        if ( (oldState & CD_PAUSED) || (oldState2 & CD_PAUSED) )
        {
            SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_PLAY, 0L );
            SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_PAUSE, 0L );
        }
    }

    if (g_Devices[g_CurrCdrom]->State & CD_LOADED)
    {
        //need to set track button on main ui
        HWND hwndTrackButton = GetDlgItem(GetParent(g_hwndApp),IDB_TRACK);
        if (hwndTrackButton)
        {
            EnableWindow(hwndTrackButton,TRUE);
        }
    }
}


/*****************************Private*Routine******************************\
* FindTrackNodeFromTocIndex
*
* This routine returns the node in the listed pointed to by listhead which
* has the TocIndex equal to tocindex.  NULL is returned if it is not
* found.  Returning NULL can easily bomb out the program -- but we should
* never be calling this routine with an invalid tocindex, and thus really
* never SHOULD return NULL.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_INF
FindTrackNodeFromTocIndex(
    int tocindex,
    PTRACK_INF listhead
    )
{
    PTRACK_INF t;

    for( t = listhead; ((t!=NULL) && (t->TocIndex!=tocindex)); t=t->next );
    return t;
}


/*****************************Private*Routine******************************\
* FindFirstTrack
*
* This routine computes the first "playable" track on a disc by
* scanning the the play order of the tracks
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
FindFirstTrack(
    int cdrom
    )
{
    if ( (g_Devices[cdrom]->State & CD_NO_CD) ||
         (g_Devices[cdrom]->State & CD_DATA_CD_LOADED) ) {

        return NULL;
    }

    return PLAYLIST(cdrom);
}



/*****************************Private*Routine******************************\
* FindLastTrack
*
* This routine computes the last "playable" track on a disc by
* scanning the the play order of the tracks
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
FindLastTrack(
    IN INT cdrom
    )
{
    PTRACK_PLAY tr;

    if ( PLAYLIST(cdrom) == NULL ) {
        return NULL;
    }

    for( tr = PLAYLIST(cdrom); tr->nextplay != NULL; tr = tr->nextplay );

    return tr;
}


/*****************************Private*Routine******************************\
* AllTracksPlayed
*
* This routine searches the play lists for all cdrom drives and
* returns a flag as to whether all tracks on all cdrom drives have
* been played.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
AllTracksPlayed(
    void
    )
{

    INT i;
    BOOL result = TRUE;

    for( i = 0; i < g_NumCdDevices; i++ ) {

        result &= (CURRTRACK(i) == NULL);
    }

    return result;
}


/*****************************Private*Routine******************************\
* FindNextTrack
*
* This routine computes the next "playable" track.  This is a
* one way door...i.e., the structures are manipulated.  It uses
* the following algorithms:
*
* Single Disc Play:
*
*     * if next track is not NULL, return next track
*     * If next track is NULL, and wrap==TRUE, return
*       first track
*     * return NULL
*
* Multi-Disc Play:
*
*     * if we're in random play, select a random drive to play from.
*     * if next track on current cdrom != NULL, return next track
*     * if it is NULL:
*
*         * check next cdrom device, if current track is not NULL
*           return CURRTRACK for that device and set gCurrCdrom to
*           that device
*         * if NULL, go to next drive
*         * last drive, check wrap
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
FindNextTrack(
    BOOL wrap
    )
{
    int i;

    /*
    ** First, bump current track pointer
    */

    if ( CURRTRACK(g_CurrCdrom) != NULL )
    {
        CURRTRACK(g_CurrCdrom) = CURRTRACK(g_CurrCdrom)->nextplay;
    }
    else {

        if ( g_fSingleDisk ) {

            return NULL;
        }
    }

    /*
    ** Do we need to switch drives?
    */

    if ( (!g_fSelectedOrder) && (!g_fSingleDisk) ) {

        /*
        ** Need to random to new cdrom
        */

        g_CurrCdrom = rand() % g_NumCdDevices;

    }

    /*
    ** Is chosen track playable?
    */

    if ( CURRTRACK(g_CurrCdrom) != NULL ) {

        /*
        ** Yep, so this is the easy case
        */

        return CURRTRACK(g_CurrCdrom);
    }

    /*
    ** Ok, CURRENT track on this device is not defined,
    ** so are we in multi-disc mode?
    */
    if ( !g_fSingleDisk ) {

        /*
        ** have all tracks played?
        */

        if ( AllTracksPlayed() ) {

            /*
            ** if wrap, reset all drives to front of their playlist
            */

            if ( wrap ) {

                /*
                ** If we are in random play mode we need to re-shuffle the
                ** track list so that people don't get the same tracks repeated
                ** again.
                */
                if (!g_fSelectedOrder) {
                    RestorePlayListsFromShuffleLists();
                    ComputeAndUseShufflePlayLists();
                }

                for ( i = 0; i < g_NumCdDevices; i++ )  {

                    CURRTRACK(i) = FindFirstTrack(i);
                }
            }
            else {

                /*
                ** All tracks on all drives have played, and we are NOT
                ** in continuous mode, so we are done playing.  Signify
                ** this by returning NULL (no playable tracks left).
                */

                return NULL;
            }
        }


        /*
        ** We're in mulit-disc play mode, and all the play lists should
        ** be reset now.  Cycle through cdrom drives looking for a playable
        ** track.
        */

        i = g_CurrCdrom;
        do {

            g_CurrCdrom++;
            if ( g_CurrCdrom >= g_NumCdDevices ) {

                /*
                ** We hit the end of the list of devices, if we're
                ** in continuous play mode, we need to wrap to the
                ** first cdrom drive.  Otherwise, we are done playing
                ** as there are no tracks left to play.
                */

                if ( wrap || (!g_fSelectedOrder) ) {

                    g_CurrCdrom = 0;

                }
                else {

                    g_CurrCdrom--;
                    return NULL;
                }
            }

        } while( (CURRTRACK(g_CurrCdrom) == NULL) && (i != g_CurrCdrom) );

        /*
        ** At this point we either have a playable track, or we
        ** are back where we started from and we're going to return
        ** NULL because there are no playable tracks left.
        */

        return CURRTRACK(g_CurrCdrom);

    }
    else {

        /*
        ** We're in single disc mode, and current track is NULL,
        ** which means we hit the end of the playlist.  So, check
        ** to see if we should wrap back to the first track, or
        ** return NULL to show that we're done playing.
        */

        if (wrap) {

            /*
            ** If we are in random play mode we need to re-shuffle the
            ** track list so that people don't get the same tracks repeated
            ** again.
            */
            if (!g_fSelectedOrder) {
                RestorePlayListsFromShuffleLists();
                ComputeAndUseShufflePlayLists();
            }

            /*
            ** wrap to start of the play list
            */

            CURRTRACK(g_CurrCdrom) = FindFirstTrack(g_CurrCdrom);
        }

        return CURRTRACK(g_CurrCdrom);
    }
}


/*****************************Private*Routine******************************\
* FindPrevTrack
*
* This routine computes the previous "playable" track on a disc by
* scanning the play order of the tracks from the current
* track to the start of the play list.  If we are at the start
* of the play list, then move to the end of the list if we
* are in "wrap" (i.e., continuous) play mode, otherwise return
* the current track.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
FindPrevTrack(
    int cdrom,
    BOOL wrap
    )
{
    /*
    ** Is current track valid?
    */

    if ( CURRTRACK(cdrom) == NULL )
    {
        return NULL;
    }


    /*
    ** If we're in multi disc play && random, the previous track
    ** is undefined since we could be jumping around on
    ** multiple discs.
    **
    ** Should Fix -- do we want to allow users to back up in the random
    **           list of a particular drive?
    */

    if ((!g_fSingleDisk) && (!g_fSelectedOrder))
    {
        return CURRTRACK(cdrom);
    }


    /*
    ** Did we hit the start of the play list?
    */

    if ( CURRTRACK(cdrom)->prevplay == NULL )
    {
        /*
        ** We hit the start of the list, check to see if we should
        ** wrap to end of list or not...
        */

        //in the case of multidisc, we should go to the last track of the previous disc
        if ((!g_fSingleDisk) && (cdrom > 0))
        {
            g_CurrCdrom = cdrom-1;
            PTRACK_PLAY pNext = FindLastTrack(g_CurrCdrom);
            if (pNext == NULL)
            {
                //bad track on previous disc, return current
                g_CurrCdrom = cdrom;
                return (CURRTRACK(cdrom));
            }
            else
            {
                return pNext;
            }
        }

        if ( wrap && g_fSingleDisk )
        {
            return FindLastTrack(cdrom);
        }
        else
        {
            return CURRTRACK(cdrom);
        }
    }

    return CURRTRACK(cdrom)->prevplay;
}


/*****************************Private*Routine******************************\
* FindContiguousEnd
*
* This routine returns the node of the track within PlayList which makes
* the largest contiguous block of tracks starting w/the track pointed
* to by "tr."  It is used to play multiple tracks at as one track
* when they are programmed to be played in sequence.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
int
FindContiguousEnd(
    int cdrom,
    PTRACK_PLAY tr
    )
{
    int i;
    PTRACK_PLAY trend;

    /*
    ** If we're in muti-disc random play, we only play
    ** one track at a time, so just return next track.
    */

    if ( (!g_fSelectedOrder) && (!g_fSingleDisk) ) {

        return tr->TocIndex + 1;
    }

    /*
    ** go forward in the play list looking for contiguous blocks
    ** of tracks to play together.  We need to check the TocIndex
    ** of each track to see if they are in a "run" [ like 2-5, etc. ]
    */

    i= tr->TocIndex + 1;
    trend = tr;

    while ( (trend->nextplay != NULL) && (trend->nextplay->TocIndex == i) ) {

        trend = trend->nextplay;
        i++;
    }

    return trend->TocIndex + 1;
}


/*****************************Private*Routine******************************\
* FlipBetweenShuffleAndOrder
*
* This routine handles going from ordered play to shuffle play and vica\versa.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
FlipBetweenShuffleAndOrder(
    void
    )
{
    if ( (!g_fSelectedOrder) ) {

        /*
        ** Transitioning from Random to Ordered Play
        */

        RestorePlayListsFromShuffleLists();
    }
    else {
        /*
        ** Transitioning from Ordered to Random Play
        */

        ComputeAndUseShufflePlayLists();
    }
}


/*****************************Private*Routine******************************\
* ComputeAndUseShufflePlayLists
*
* This routine computes shuffled play lists for each drive, and sets
* the current PLAYLIST for erach drive to the newly computed shuffled
* PLAYLIST.  The old PLAYLIST for each drive is saved in SAVELIST.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ComputeAndUseShufflePlayLists(
    void
    )
{
    int i;

    for ( i = 0; i < g_NumCdDevices; i++ ) {

        ComputeSingleShufflePlayList( i );
    }
}


/*****************************Private*Routine******************************\
* ComputeSingleShufflePlayList
*
* This routine computes shuffled play lists for drive i, and sets
* the current PLAYLIST for it the newly computed shuffled
* PLAYLIST.  The old PLAYLIST is saved in SAVELIST.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ComputeSingleShufflePlayList(
    int i
    )
{
    int j, index, numnodes;
    PTRACK_PLAY temp, temp1, duplist, prev, OldPlayList;

    /*
    ** First, delete the existing playlist
    */
    OldPlayList = PLAYLIST(i);
    PLAYLIST(i) = NULL;

    /*
    ** Now, go through each drive and create a shuffled play list
    ** First step is to duplicate the old play list, then we will
    ** randomly pick off nodes and put them on the shuffle play list.
    */

    duplist = prev = NULL;
    numnodes = 0;
    for( temp = SAVELIST(i); temp != NULL; temp = temp->nextplay ) {
        temp1 = (TRACK_PLAY*)AllocMemory( sizeof(TRACK_PLAY) );
        *temp1 = *temp;
        temp1->nextplay = NULL;
        if (duplist) {

            temp1->prevplay = prev;
            prev->nextplay = temp1;
            prev = temp1;
        }
        else {

            duplist = temp1;
            temp1->prevplay = NULL;
            prev = temp1;
        }

        numnodes++;
    }

    /*
    ** Now, randomly pick off nodes
    */

    prev = NULL;
    for( j = 0; j < numnodes; j++ ) {

        index = rand() % (numnodes - j + 1);
        temp = duplist;
        while( --index>0 ) {
            temp = temp->nextplay;
        }

        /*
        ** Got the node to transfer to playlist (temp),
        ** so we need to detach it from duplist so we
        ** can tack it onto the end of the playlist.
        */

        if ( temp != NULL ) {

            /*
            ** Detach temp from playlist.
            */

            if ( temp == duplist ) {

                duplist = temp->nextplay;
            }

            if ( temp->nextplay ) {

                temp->nextplay->prevplay = temp->prevplay;
            }

            if ( temp->prevplay ) {

                temp->prevplay->nextplay = temp->nextplay;
            }

            /*
            ** Now, tack it onto the end of the PLAYLIST
            */

            if ( PLAYLIST(i) ) {

                prev->nextplay = temp;
                temp->prevplay = prev;
                temp->nextplay = NULL;
                prev = temp;
            }
            else {

                PLAYLIST(i) = temp;
                temp->prevplay = NULL;
                prev = temp;
                temp->nextplay = NULL;
            }
        }
    }

    /*
    ** we need to reset the CURRTRACK pointer so
    ** that it points to a node in PLAYLIST instead of SAVELIST
    */

    if ( (g_Devices[i]->State & CD_PLAYING) && (CURRTRACK(i) != NULL) ) {

        index = CURRTRACK(i)->TocIndex;
        for( temp = PLAYLIST(i); temp->TocIndex!=index; temp=temp->nextplay );
        CURRTRACK(i) = temp;
    }
    else {

        CURRTRACK(i) = PLAYLIST(i);

        if ( PLAYLIST(i) != NULL ) {

            CDTIME(i).TrackTotalMin = PLAYLIST(i)->min;
            CDTIME(i).TrackTotalSec = PLAYLIST(i)->sec;
            CDTIME(i).TrackRemMin   = PLAYLIST(i)->min;
            CDTIME(i).TrackRemSec   = PLAYLIST(i)->sec;
        }


    }

    /*
    ** if this is the current drive, we need to redo the tracks in
    ** the track list combobox.
    */

    if ( i == g_CurrCdrom ) {

        ResetTrackComboBox( i );

    }

    /*
    ** Finally, free up the memory from the old playlist.
    */
    temp = OldPlayList;
    while ( temp != NULL ) {

        temp1 = temp->nextplay;
        LocalFree( (HLOCAL)temp );
        temp = temp1;
    }
}


/*****************************Private*Routine******************************\
* RestorePlayListsFromShuffleLists
*
* This routine restores the PLAYLIST for each drive to it's "pre-shuffled"
* state.  This should be stored in SAVELIST.  Once the restoration is done,
* un-needed node are released.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
RestorePlayListsFromShuffleLists(
    void
    )
{
    int i,index;
    PTRACK_PLAY temp;

    for ( i = 0; i < g_NumCdDevices; i++ ) {

        if ( SAVELIST(i) ) {

            if ( CURRTRACK(i) != NULL ) {

                index = CURRTRACK(i)->TocIndex;
            }
            else {

                index = -1;
            }

            ErasePlayList(i);
            PLAYLIST(i) = CopyPlayList( SAVELIST(i) );

            /*
            ** Reset CURRTRACK pointer
            */

            if ( (g_Devices[i]->State & CD_PLAYING) && (index != -1) ) {

                for( temp = PLAYLIST(i);
                     temp->TocIndex != index; temp=temp->nextplay );

                CURRTRACK(i) = temp;
            }
            else {

                CURRTRACK(i) = PLAYLIST(i);

                if ( PLAYLIST(i) != NULL ) {
                    CDTIME(i).TrackRemMin   = PLAYLIST(i)->min;
                    CDTIME(i).TrackRemSec   = PLAYLIST(i)->sec;
                    CDTIME(i).TrackTotalMin = PLAYLIST(i)->min;
                    CDTIME(i).TrackTotalSec = PLAYLIST(i)->sec;
                }
            }
        }

        if ( i == g_CurrCdrom ) {

            ResetTrackComboBox( i );
        }
    }
}



/*****************************Private*Routine******************************\
* FigureTrackTime
*
* This routine computes the length of a given track, in terms
* of minutes and seconds.
*
*   cdrom - supplies an index into the global structure gDevices
*
*   index - supplies an index to the track which should have its
*           length computed.  This is an index into the
*           gDevices[cdrom]->CdInfo.Tracks[...] structure
*
*   min   - supplies a pointer to an INT which will hold the minute
*           portion of the track length.
*
*   sec   - supplies a pointer to an INT which will hold the seconds
*           portion of the track length.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
FigureTrackTime(
    int cdrom,
    int index,
    int * min,
    int * sec
    )
{

    DWORD start, end, diff;

    start = ((TRACK_M(cdrom,index) * FRAMES_PER_MINUTE) +
             (TRACK_S(cdrom,index) * FRAMES_PER_SECOND) +
              TRACK_F(cdrom,index));

    end   = ((TRACK_M(cdrom,index+1) * FRAMES_PER_MINUTE) +
             (TRACK_S(cdrom,index+1) * FRAMES_PER_SECOND) +
              TRACK_F(cdrom,index+1));

    diff = end - start;

    (*min)   = (diff / FRAMES_PER_MINUTE);
    (*sec)   = (diff % FRAMES_PER_MINUTE) / FRAMES_PER_SECOND;

}



/*****************************Private*Routine******************************\
* TimeAdjustInitialize
*
*   Initializes the time, track, and title fields of a given
*   disc.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TimeAdjustInitialize(
    int cdrom
    )
{
    int m, s, mtemp, stemp, ts, tm;
    PTRACK_PLAY tr;


    /*
    ** Is there even a cd loaded?
    */

    if (g_Devices[cdrom]->State &
        (CD_BEING_SCANNED | CD_IN_USE | CD_NO_CD | CD_DATA_CD_LOADED)) {

        /*
        ** Fake some information
        */

        g_Devices[cdrom]->CdInfo.NumTracks = 0;
        g_Devices[cdrom]->toc.FirstTrack = 0;
        g_Devices[cdrom]->CdInfo.Id = 0;

        if (g_Devices[cdrom]->State & CD_IN_USE) {
            _tcscpy( (LPTSTR)TITLE(cdrom),  IdStr(STR_WAITING) );
            _tcscpy( (LPTSTR)ARTIST(cdrom), IdStr(STR_DISC_INUSE) );
        }
        else if (g_Devices[cdrom]->State & CD_BEING_SCANNED) {
            _tcscpy( (LPTSTR)TITLE(cdrom),  IdStr(STR_WAITING) );
            _tcscpy( (LPTSTR)ARTIST(cdrom), IdStr(STR_BEING_SCANNED) );
        }
        else
        {
            _tcscpy( (LPTSTR)TITLE(cdrom),  IdStr(STR_INSERT_DISC) );
            if (g_Devices[cdrom]->State & CD_DATA_CD_LOADED)
            {
                _tcscpy( (LPTSTR)ARTIST(cdrom), IdStr(STR_DATA_DISC) );
            }
            else
            {
                _tcscpy( (LPTSTR)ARTIST(cdrom), IdStr(STR_NO_DISC) );
            }
        }

        /*
        ** Kill off play list
        */

        ErasePlayList( cdrom );
        EraseSaveList( cdrom );
        EraseTrackList( cdrom );

        tr = NULL;
    }
    else {

        /*
        ** Find track to use as first track
        */

        tr = FindFirstTrack( cdrom );
    }

    /*
    ** Set current position information
    */

    CURRTRACK(cdrom) = tr;
    CDTIME(cdrom).TrackCurMin = 0;
    CDTIME(cdrom).TrackCurSec = 0;

    /*
    ** Compute PLAY length
    */

    mtemp = stemp = m = s = ts = tm =0;

    for( tr = PLAYLIST(cdrom); tr != NULL; tr = tr->nextplay ) {

        FigureTrackTime( cdrom, tr->TocIndex, &mtemp, &stemp );

        m+=mtemp;
        s+=stemp;

        tr->min = mtemp;
        tr->sec = stemp;
    }

    /*
    ** to be safe, recalculate the SAVE list each time as well.
    */
    for( tr = SAVELIST(cdrom); tr != NULL; tr = tr->nextplay ) {

        FigureTrackTime( cdrom, tr->TocIndex, &mtemp, &stemp );

        tr->min = mtemp;
        tr->sec = stemp;
    }


    m += (s / 60);
    s =  (s % 60);

    CDTIME(cdrom).TotalMin = m;
    CDTIME(cdrom).TotalSec = s;
    CDTIME(cdrom).RemMin = m;
    CDTIME(cdrom).RemSec = s;

    /*
    ** Fill in track length and information
    */

    if ( CURRTRACK(cdrom) != NULL ) {

        CDTIME(cdrom).TrackTotalMin = CDTIME(cdrom).TrackRemMin =
            CURRTRACK(cdrom)->min;

        CDTIME(cdrom).TrackTotalSec = CDTIME(cdrom).TrackRemSec =
            CURRTRACK(cdrom)->sec;
    }
    else {

        CDTIME(cdrom).TrackTotalMin = CDTIME(cdrom).TrackRemMin = 0;
        CDTIME(cdrom).TrackTotalSec = CDTIME(cdrom).TrackRemSec = 0;
    }

    /*
    ** Fill in track list combo box
    */

    if ( cdrom == g_CurrCdrom ) {

        ResetTrackComboBox( cdrom );

        /*
        ** Update display if this is the disc currently
        ** being displayed.
        */

        UpdateDisplay( DISPLAY_UPD_LED        |
                       DISPLAY_UPD_DISC_TIME  |
                       DISPLAY_UPD_TRACK_TIME |
                       DISPLAY_UPD_TITLE_NAME |
                       DISPLAY_UPD_TRACK_NAME );
    }

}



/*****************************Private*Routine******************************\
* TimeAdjustIncSecond
*
* Adds one second onto current position ("time") of disc
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TimeAdjustIncSecond(
    int cdrom
    )
{

    PTRACK_PLAY tr;

    /*
    ** If there is no current track just return
    */
    if ( CURRTRACK(g_CurrCdrom) == NULL ) {
        return;
    }

    /*
    ** Update current track time
    */

    CDTIME(cdrom).TrackCurSec++;
    if ( CDTIME(cdrom).TrackCurSec > 59 ) {

        CDTIME(cdrom).TrackCurMin++;
        CDTIME(cdrom).TrackCurSec = 0;
    }

    /*
    ** Now, check to see if we skipped any track boundaries
    */

    if (
        ((CDTIME(cdrom).TrackCurMin >= CDTIME(cdrom).TrackTotalMin) &&
         (CDTIME(cdrom).TrackCurSec >= CDTIME(cdrom).TrackTotalSec))

        ||

        ((g_fIntroPlay) &&
        ((CDTIME(cdrom).TrackCurMin >  0) ||
         (CDTIME(cdrom).TrackCurSec > g_IntroPlayLength)) )

       ) {

        /*
        ** We did, so skip to next track
        */

        /*
        ** Should Fix for new FindNextTrack
        */

        tr = FindNextTrack( g_fContinuous );

        if ( tr == NULL ) {

            /*
            ** Hit end of playlist, so stay at end of current
            ** track.
            */

            if (!g_fIntroPlay) {

                CDTIME(cdrom).TrackCurMin = CDTIME(cdrom).TrackTotalMin;
                CDTIME(cdrom).TrackCurSec = CDTIME(cdrom).TrackTotalSec;
            }
            else {

                CDTIME(cdrom).TrackCurMin = 0;
                CDTIME(cdrom).TrackCurSec = g_IntroPlayLength;
            }

            return;

        }

        if ( g_CurrCdrom != g_LastCdrom) {

            SwitchToCdrom(g_CurrCdrom, FALSE );
        }

        TimeAdjustSkipToTrack( cdrom, tr );
    }
    else {

        /*
        ** Update current track remaining time
        */

        CDTIME(cdrom).TrackRemSec--;
        if ( CDTIME(cdrom).TrackRemSec < 0 ) {

            CDTIME(cdrom).TrackRemMin--;
            CDTIME(cdrom).TrackRemSec = 59;
        }

        /*
        ** Update total remaining time
        */

        CDTIME(cdrom).RemSec--;
        if ( CDTIME(cdrom).RemSec < 0 ) {

            CDTIME(cdrom).RemMin--;
            CDTIME(cdrom).RemSec = 59;
        }
    }

    /*
    ** Update Display
    */

    UpdateDisplay( DISPLAY_UPD_LED );
}


/*****************************Private*Routine******************************\
* TimeAdjustDecSecond
*
* Subtracts one second from current position ("time") of disc
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TimeAdjustDecSecond(
    int cdrom
    )
{

    int min,sec;
    PTRACK_PLAY prev,tr;

    /*
    ** If there is no current track, just return
    */
    if ( CURRTRACK(g_CurrCdrom) == NULL ) {
        return;
    }

    /*
    ** Update current track
    */

    CDTIME(cdrom).TrackCurSec--;
    if ( CDTIME(cdrom).TrackCurSec < 0 ) {

        CDTIME(cdrom).TrackCurMin--;
        CDTIME(cdrom).TrackCurSec = 59;
    }

    /*
    ** Update current track remaining
    */

    CDTIME(cdrom).TrackRemSec++;
    if ( CDTIME(cdrom).TrackRemSec > 59 ) {

        CDTIME(cdrom).TrackRemMin++;
        CDTIME(cdrom).TrackRemSec = 0;
    }

    /*
    ** Update total remaining time
    */

    CDTIME(cdrom).RemSec++;
    if ( CDTIME(cdrom).RemSec > 59 ) {

        CDTIME(cdrom).RemMin++;
        CDTIME(cdrom).RemSec = 0;
    }

    /*
    ** Now, check to see if we skipped any boundaries we shouldn't have!
    */

    if ( CDTIME(cdrom).TrackCurMin < 0 ) {

        /*
        ** We went "off" the front end of the track,
        ** so we need to see what to do now.  Options
        ** are:
        **
        ** (1) Go to end of track before us.
        ** (2) If intro play, go to 0:10 of
        **     track before us.
        ** (3) If not in continuous play, and
        **     this is the first track, then
        **     just sit at 0:00
        */

        prev = FindPrevTrack( cdrom, g_fContinuous );

        //reset for multidisc case
        if (g_CurrCdrom != cdrom)
        {
            g_CurrCdrom = cdrom;
            prev = CURRTRACK(cdrom);
        }

        if ( prev == CURRTRACK(cdrom) ) {

            /*
            ** We are on the first track, and not in
            ** continuous mode, so just go to 0:00
            */

            CDTIME(cdrom).TrackCurSec = 0;
            CDTIME(cdrom).TrackCurMin = 0;
            CDTIME(cdrom).TrackRemMin = CDTIME(cdrom).TrackTotalMin;
            CDTIME(cdrom).TrackRemSec = CDTIME(cdrom).TrackTotalSec;
            min = sec = 0;

            for( tr = PLAYLIST( cdrom ); tr != NULL; tr = tr->nextplay ) {

                min += tr->min;
                sec += tr->sec;
            }

            min += (sec / 60);
            sec  = (sec % 60);

            CDTIME(cdrom).RemMin = min;
            CDTIME(cdrom).RemSec = sec;

            UpdateDisplay( DISPLAY_UPD_LED );

        }
        else {

            /*
            ** Valid previous track
            */

            if ( !g_fIntroPlay ) {

                /*
                ** We need to place the current play position
                ** at the end of the previous track.
                */

                CDTIME(cdrom).TrackCurMin = CDTIME(cdrom).TrackTotalMin = prev->min;
                CDTIME(cdrom).TrackCurSec = CDTIME(cdrom).TrackTotalSec = prev->sec;
                CDTIME(cdrom).TrackRemMin = CDTIME(cdrom).TrackRemSec = 0;

                min = sec = 0;
                for( tr = prev->nextplay; tr != NULL; tr = tr->nextplay ) {

                    min += tr->min;
                    sec += tr->sec;
                }

                min += (sec / 60);
                sec  = (sec % 60);

                CDTIME(cdrom).RemMin = min;
                CDTIME(cdrom).RemSec = sec;
            }
            else {

                /*
                ** Intro play -- instead of end of track,
                **               jump to 00:10...
                */

                CDTIME(cdrom).TrackCurMin = 0;
                CDTIME(cdrom).TrackCurSec =
                    min( g_IntroPlayLength, prev->sec );

                CDTIME(cdrom).TrackTotalMin = prev->min;
                CDTIME(cdrom).TrackTotalSec = prev->sec;

                CDTIME(cdrom).TrackRemMin = CDTIME(cdrom).TrackTotalMin;
                CDTIME(cdrom).TrackRemSec = CDTIME(cdrom).TrackTotalSec -
                                        min( g_IntroPlayLength, prev->sec );

                if ( CDTIME(cdrom).TrackRemSec < 0 ) {

                    CDTIME(cdrom).TrackRemSec += 60;
                    CDTIME(cdrom).TrackRemMin--;
                }

                min = sec = 0;
                for( tr = prev; tr != NULL; tr = tr->nextplay ) {

                    min += tr->min;
                    sec += tr->sec;
                }

                sec -= min( g_IntroPlayLength, prev->sec );
                if ( sec < 0 ) {
                    sec+=60;
                    min--;
                }

                min += (sec / 60);
                sec  = (sec % 60);

                CDTIME(cdrom).RemMin = min;
                CDTIME(cdrom).RemSec = sec;
            }

            CURRTRACK(cdrom) = prev;

            UpdateDisplay( DISPLAY_UPD_LED        |
                           DISPLAY_UPD_TRACK_NAME |
                           DISPLAY_UPD_TRACK_TIME );

        }
    }
    else {

        UpdateDisplay( DISPLAY_UPD_LED );
    }
}


/*****************************Private*Routine******************************\
* InitializeNewTrackTime
*
* Updates track/time information for gDevices array.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
InitializeNewTrackTime(
    int cdrom,
    PTRACK_PLAY tr,
    BOOL fUpdateDisplay
    )
{
    int min,sec;

    /*
    ** Update time information in gDevices structure
    */

    CDTIME(cdrom).CurrTrack = tr;
    CDTIME(cdrom).TrackCurMin = 0;
    CDTIME(cdrom).TrackCurSec = 0;

    if (tr == NULL) {

        CDTIME(cdrom).TrackTotalMin = 0;
        CDTIME(cdrom).TrackTotalSec = 0;

    }
    else {

        CDTIME(cdrom).TrackTotalMin = CDTIME(cdrom).TrackRemMin = tr->min;
        CDTIME(cdrom).TrackTotalSec = CDTIME(cdrom).TrackRemSec = tr->sec;

    }

    min = sec = 0;
    for( tr = PLAYLIST(cdrom); tr!=NULL; tr = tr->nextplay ) {

        min += tr->min;
        sec += tr->sec;
    }

    min += (sec / 60);
    sec  = (sec % 60);

    CDTIME(cdrom).RemMin = min;
    CDTIME(cdrom).RemSec = sec;

    /*
    ** Update LED box
    */
    if (fUpdateDisplay) {
        UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_NAME |
                       DISPLAY_UPD_TRACK_TIME );
    }
}




/*****************************Private*Routine******************************\
* TimeAdjustSkipToTrack
*
*   Updates time/track information for gDevices array and then
*   issues skip to track commands to cdrom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TimeAdjustSkipToTrack(
    int cdrom,
    PTRACK_PLAY tr
    )
{

    /*
    ** Update time information in gDevices structure
    */

    InitializeNewTrackTime( cdrom, tr, TRUE );

    /*
    ** Actually seek to the track, and play it if appropriate
    */

    if ((g_Devices[cdrom]->State & CD_PLAYING) ||
        (g_Devices[cdrom]->State & CD_PAUSED)) {

        PlayCurrTrack( cdrom );
        if (g_Devices[cdrom]->State & CD_PAUSED) {
            PauseTheCdromDrive( cdrom );
        }
    }
    else if (tr) {
        SeekToTrackAndHold( cdrom, tr->TocIndex );
    }
}


/*****************************Private*Routine******************************\
* SyncDisplay
*
* Queries the cdrom device for its current position, and then
* updates the display accordingly.  Also, detects when a track has
* finished playing, or when intro segment is over, and skips to the
* next track.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SyncDisplay(
    void
    )
{
    int m,s;
    PTRACK_PLAY next;
    CURRPOS cp;
    PCURRPOS pCurr = &cp;


    /*
    ** If there isn't a disc in the drive, ignore this
    ** request
    */

    if ( (g_Devices[g_CurrCdrom]->State & CD_NO_CD) ||
         (g_Devices[g_CurrCdrom]->State & CD_DATA_CD_LOADED) ) {
       return;
    }

    /*
    ** Query cdrom device for current position
    */

    if ( !GetCurrPos( g_CurrCdrom, pCurr ) ) {

        /*
        ** If there was an error, it will already have been
        ** reported in CheckStatus of cdapi.c...so, we don't need
        ** to tell anything more here.  When an error occurs, the
        ** fields of the pCurr structure are zeroed, so we don't
        ** need to clean those up either
        */

        return;
    }

    /*
    ** Has the current play selection finished playing?
    */
#ifdef USE_IOCTLS
    if ((pCurr->AudioStatus == AUDIO_STATUS_PLAY_COMPLETE) &&
        ( !(g_State & CD_SEEKING) )) {
#else

    if ((pCurr->AudioStatus == (DWORD)MCI_MODE_STOP) &&
        ( !(g_State & CD_SEEKING) )) {
#endif

Play_Complete:

        /*
        ** Yep, so skip to the next track.
        */
        if (g_fRepeatSingle)
        {
            next = CURRTRACK(g_CurrCdrom);
        }
        else
        {
            next = FindNextTrack( g_fContinuous );
        }

        if ( next == NULL ) {

            /*
            ** There are no more tracks to play, so
            ** fake a press on the "stop" button.  But,
            ** we want to set gCurrCdrom back to the "playing"
            ** drive 'cause it may have changed in our call
            ** to FindNextTrack.
            */

            g_CurrCdrom = g_LastCdrom;
            SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_STOP, 0L );
        }
        else {

            if ( g_CurrCdrom != g_LastCdrom ) {

                SwitchToCdrom( g_CurrCdrom, FALSE );

                /*
                ** We use to start the disc play by sending the play command.
                ** SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_PLAY, 0L );
                ** However, all we realy need to put the drives state into
                ** playing and let TimeAdjustSkipToTrack take care of starting
                ** playing.  If we don't do this when the app is in multi-disc
                ** random play mode, we get a fraction of a second of the
                ** first track in the playlist played before we seek to the
                ** the correct track and start playing it.  This sounds really
                ** bad.
                */

                g_State &= ~CD_STOPPED;
                g_State |= CD_PLAYING;

                //tell the main ui
                g_pSink->OnEvent(MMEVENT_ONPLAY,NULL);

            }

            TimeAdjustSkipToTrack( g_CurrCdrom, next );
        }

        return;
    }

    /*
    ** Check to see if we need to update the display
    */

    if ( (pCurr->Track < 100) && ( pCurr->Track >
         (CURRTRACK(g_CurrCdrom)->TocIndex + FIRSTTRACK(g_CurrCdrom)) )) {

        /*
        ** We got to the next track in a multi-track
        ** play, so mark per track information for
        ** new track
        */
        if ((CURRTRACK(g_CurrCdrom)->nextplay != NULL) &&
             (((CURRTRACK(g_CurrCdrom)->TocIndex + 1) ==
              CURRTRACK(g_CurrCdrom)->nextplay->TocIndex)||!g_fSelectedOrder))
              {

            if (g_fRepeatSingle)
            {
                next = CURRTRACK(g_CurrCdrom);
                TimeAdjustSkipToTrack( g_CurrCdrom, next );
            }
            else
            {
                next = FindNextTrack( g_fContinuous );
            }

            if (!g_fSelectedOrder)
            {
                if (next!=NULL)
                {
                    TimeAdjustSkipToTrack( g_CurrCdrom, next );
                }
            }

            if ( next == NULL ) {

                /*
                ** There are no more tracks to play, so
                ** fake a press on the "stop" button.  But,
                ** we want to set gCurrCdrom back to the "playing"
                ** drive 'cause it may have changed in our call
                ** to FindNextTrack.
                */

                g_CurrCdrom = g_LastCdrom;

                SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                             WM_LBUTTONDOWN, 0, 0L );

                SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                             WM_LBUTTONUP, 0, 0L );

            }
            else {

                if ( g_CurrCdrom != g_LastCdrom ) {

                    SwitchToCdrom( g_CurrCdrom, FALSE );
                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONDOWN, 0, 0L );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONUP, 0, 0L );
                }

                InitializeNewTrackTime( g_CurrCdrom, next, FALSE );
                UpdateDisplay( DISPLAY_UPD_TRACK_NAME | DISPLAY_UPD_TRACK_TIME );
            }
        }
        else {

            /*
            ** If we get here it is probably the result of starting
            ** CD Player whislt the current disc was still playing.
            ** We look for the currently playing track in the current
            ** playlist.
            */

            next = FindFirstTrack(g_CurrCdrom);
            PTRACK_PLAY last = next;

            while ( (next != NULL)
                 && (pCurr->Track != (next->TocIndex + 1)) ) {

#if DBG
                dprintf(TEXT("trying track %d"), (next->TocIndex + 1));
#endif
                last = next;
                next = next->nextplay;
            }

            /*
            ** If next is NULL it means that we are playing a track that
            ** is currently not on the users playlist.  So, we put up a
            ** message box informing the user of this fact and that we are
            ** going to temporarily add the track to the current playlist
            ** as the first track.  Otherwise, we found the track in the
            ** playlist so just update the track time for this track.
            */

            if (pCurr->Track < NUMTRACKS(g_CurrCdrom))
            {
                if (next == NULL)
                {
                    AddTemporaryTrackToPlayList(pCurr);
                }
                else
                {
                    InitializeNewTrackTime( g_CurrCdrom, next, TRUE );
                }
            }
            else
            {
                if (!g_fRepeatSingle)
                {
	                SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_STOP, 0L );
	                if (g_fContinuous)
				    {
    					SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_PLAY, 0L );
				    }
                } //end if not repeating single
                else
                {
                    next = last;
                    TimeAdjustSkipToTrack( g_CurrCdrom, next );
                } //end repeating single
            } //end if pcurr is bad
        }
        return;
    }

    if ( pCurr->Track <
         (CURRTRACK(g_CurrCdrom)->TocIndex + FIRSTTRACK(g_CurrCdrom)) )
        return;

    if ( (pCurr->Index != 0)
      && (pCurr->m <= CDTIME(g_CurrCdrom).TrackCurMin)
      && (pCurr->s <= CDTIME(g_CurrCdrom).TrackCurSec) )

        return;

    /*
    ** Set track elapsed time
    */

    CDTIME(g_CurrCdrom).TrackCurMin = pCurr->m;
    CDTIME(g_CurrCdrom).TrackCurSec = pCurr->s;

    /*
    ** Set track remaining time
    */

    m = pCurr->m;

    if ( (pCurr->s) <= CDTIME(g_CurrCdrom).TrackTotalSec ) {

        s = CDTIME(g_CurrCdrom).TrackTotalSec - pCurr->s;
    }
    else {

        s = 60 - (pCurr->s - CDTIME(g_CurrCdrom).TrackTotalSec);
        m++;
    }

    CDTIME(g_CurrCdrom).TrackRemMin = CDTIME(g_CurrCdrom).TrackTotalMin - m;
    CDTIME(g_CurrCdrom).TrackRemSec = s;

    /*
    ** Set disc remaining time
    **
    ** Should Fix -- for now, just decrement by 1 second
    */

    CDTIME(g_CurrCdrom).RemSec--;
    if (CDTIME(g_CurrCdrom).RemSec < 0) {

        CDTIME(g_CurrCdrom).RemSec = 59;
        CDTIME(g_CurrCdrom).RemMin--;
    }


    /*
    ** Update LED box
    */

    if ( (pCurr->Index != 0) || ((pCurr->m == 0) && (pCurr->s == 0)) ) {

        UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_NAME );
    }
    else {

        UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_LEADOUT_TIME );
    }

    /*
    ** Check to see if we are intro play and have played
    ** intro segment...if so, skip to next track
    */

    if ( ((pCurr->s >= (g_IntroPlayLength + 1)) || (pCurr->m > 0))
      && g_fIntroPlay ) {

        goto Play_Complete;
    }
}




/*****************************Private*Routine******************************\
* ValidatePosition
*
* Checks the current position on the CD, then verifies that the
* relative offset in the track + the beginning of the track's
* position is the same as the absolute position on the CD.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ValidatePosition(
    int cdrom
    )
{
    int Mult, Frames;
    CURRPOS cp;
    PCURRPOS pCurr = &cp;
    LPTSTR s1,s2;


    if (!GetCurrPos( cdrom, pCurr ))

        /*
        ** If there was an error, it will already have been
        ** reported in CheckStatus of cdapi.c...so, we don't need
        ** to tell anything more here.  When an error occurs, the
        ** fields of the pCurr structure are zeroed, so we don't
        ** need to clean those up either
        */

        return;


    /*
    ** Make sure the position returned is consistent with
    ** what we know about the CD. By comparing the relative time
    ** on this track to the absolute time on the CD, we should be
    ** able to make sure we're still on the right disc.  This is
    ** a failsafe for when polling fails to notice an ejected
    ** disc.
    */

    if ((cp.Track > 0)&&(cp.Track < 101)) {

        Frames = cp.ab_m * 60 * 75;
        Frames += cp.ab_s * 75;
        Frames += cp.ab_f;

        Frames -= TRACK_M(cdrom,cp.Track-1) * 60 * 75;
        Frames -= TRACK_S(cdrom,cp.Track-1) * 75;
        Frames -= TRACK_F(cdrom,cp.Track-1);
        if (pCurr->Index) {

            Mult = 1;
        }
        else {

            Mult = -1;
        }

        Frames -= Mult*cp.m * 60 * 75;
        Frames -= Mult*cp.s * 75;
        Frames -= Mult*cp.f;

        if (g_Devices[cdrom]->CdInfo.iFrameOffset ==  NEW_FRAMEOFFSET) {

            g_Devices[cdrom]->CdInfo.iFrameOffset = Frames;
        }

        if ((ABS(Frames - g_Devices[ cdrom ]->CdInfo.iFrameOffset) > 4) &&
            (ABS(Frames) > 4)) {

            HWND hwndStop;

            hwndStop = g_hwndControls[INDEX(IDM_PLAYBAR_STOP)];

            s1 = (TCHAR*)AllocMemory( _tcslen(IdStr(STR_BAD_DISC)) + 1 );
            _tcscpy( s1, IdStr(STR_BAD_DISC) );

            s2 = (TCHAR*)AllocMemory( _tcslen(IdStr(STR_CDPLAYER)) + 1);
            _tcscpy(s2,IdStr(STR_CDPLAYER));

            MessageBox( g_hwndApp, s1, s2, MB_APPLMODAL|MB_ICONSTOP|MB_OK );

            SendMessage( hwndStop,WM_LBUTTONDOWN, 1,0L );
            SendMessage( hwndStop,WM_LBUTTONUP, 1, 0L );

            RescanDevice(g_hwndApp, cdrom );

            LocalFree( (HLOCAL)s1 );
            LocalFree( (HLOCAL)s2 );

            return;
        }
    }
}



/*****************************Private*Routine******************************\
* ResetTrackComboBox
*
* This routine deletes and then resets the track name combobox based
* on the contents of the PLAYLIST for the specified cdrom drive.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
VOID
ResetTrackComboBox(
    int cdrom
    )
{
    int j,index;
    PTRACK_PLAY temp;
    HWND    hwnd;

    hwnd = g_hwndControls[INDEX(IDC_TRACK_LIST)];

    SetWindowRedraw( hwnd, FALSE );
    ComboBox_ResetContent( hwnd );

    /*
    ** Add new playlist, and select correct entry for current track
    */

    j = index = 0;
    for( temp = PLAYLIST(cdrom); temp != NULL; temp = temp->nextplay ) {

        ComboBox_InsertString( hwnd, -1, temp->TocIndex );

        if ( temp == CURRTRACK(cdrom) ) {

            index = j;
        }

        j++;

    }

    ComboBox_SetCurSel( hwnd, index );
    SetWindowRedraw( hwnd, TRUE );

    RedrawWindow( hwnd, NULL, NULL, RDW_INVALIDATE );
    UpdateWindow( hwnd );

    UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME );

}

/******************************Public*Routine******************************\
* PlayListMatchesAvailList
*
* Compares the current play list with the default play list to if they match.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
PlayListMatchesAvailList(
    void
    )
{

    PTRACK_PLAY pl = SAVELIST(g_CurrCdrom);
    int i = 0;

    while (pl && i < NUMTRACKS(g_CurrCdrom)) {

        if ( pl->TocIndex != i) {
            return FALSE;
        }
        pl = pl->nextplay;
        i++;
    }

    return pl == NULL && i == NUMTRACKS(g_CurrCdrom);
}


/*****************************Private*Routine******************************\
* AddTemporaryTrackToPlayList
*
* This functions adds the currently playing track to the playlist.
* pCurr contains the toc index of the track that is required to be added.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
AddTemporaryTrackToPlayList(
    PCURRPOS pCurr
    )
{
    // LPTSTR lpstrTitle;
    // LPTSTR lpstrText;
    PTRACK_PLAY tr;
    int m, s;


    /*
    ** Add track to the current playlist.
    */
    tr = (TRACK_PLAY*)AllocMemory( sizeof(TRACK_PLAY) );
    tr->TocIndex = pCurr->Track - 1;
    FigureTrackTime(g_CurrCdrom, tr->TocIndex, &tr->min, &tr->sec);

    tr->nextplay = PLAYLIST(g_CurrCdrom);
    tr->prevplay = NULL;

    PLAYLIST(g_CurrCdrom)->prevplay = tr;
    PLAYLIST(g_CurrCdrom) = tr;

    /*
    ** Update the display.
    */
    InitializeNewTrackTime( g_CurrCdrom, tr, TRUE );
    ResetTrackComboBox( g_CurrCdrom );

    m = CDTIME(g_CurrCdrom).TotalMin + tr->min;
    s = CDTIME(g_CurrCdrom).TotalSec + tr->sec;

    m += (s / 60);
    s =  (s % 60);

    CDTIME(g_CurrCdrom).TotalMin = m;
    CDTIME(g_CurrCdrom).TotalSec = s;
    UpdateDisplay(DISPLAY_UPD_DISC_TIME);


    /*
    ** Now modify the current saved playlist.  We do this so that transitions
    ** from/to random mode work correctly.
    */
    tr = (TRACK_PLAY*)AllocMemory( sizeof(TRACK_PLAY) );
    tr->TocIndex = pCurr->Track - 1;
    FigureTrackTime(g_CurrCdrom, tr->TocIndex, &tr->min, &tr->sec);

    tr->nextplay = SAVELIST(g_CurrCdrom);
    tr->prevplay = NULL;

    SAVELIST(g_CurrCdrom)->prevplay = tr;
    SAVELIST(g_CurrCdrom) = tr;

#if 0
    /*
    ** Now, tell the user what we have just done.  Note that we disable the
    ** the Heart beat timer so that we don't renenter ourselves.
    */
    lpstrTitle = AllocMemory( STR_MAX_STRING_LEN * sizeof(TCHAR) );
    lpstrText  = AllocMemory( STR_MAX_STRING_LEN * sizeof(TCHAR) );

    _tcscpy( lpstrText, IdStr(STR_NOT_IN_PLAYLIST) );
    _tcscpy( lpstrTitle, IdStr(STR_CDPLAYER) );

    KillTimer( g_hwndApp, HEARTBEAT_TIMER_ID );

    MessageBox( NULL, lpstrText, lpstrTitle,
                MB_APPLMODAL | MB_ICONINFORMATION | MB_OK );

    SetTimer( g_hwndApp, HEARTBEAT_TIMER_ID, HEARTBEAT_TIMER_RATE,
              HeartBeatTimerProc );
    LocalFree( (HLOCAL)lpstrText );
    LocalFree( (HLOCAL)lpstrTitle );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\img.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1996-1997 Microsoft Corporation. All Rights Reserved.
//
//  File: iimgctx.h
//
//--------------------------------------------------------------------------

#ifndef _IImgCtxObjects_H_
#define _IImgCtxObjects_H_

#ifdef __cplusplus
extern "C" {
#endif
typedef void (CALLBACK *PFNIMGCTXCALLBACK)(void *, void *);
#ifdef __cplusplus
}
#endif

#define IMGCHG_SIZE         0x0001
#define IMGCHG_VIEW         0x0002
#define IMGCHG_COMPLETE     0x0004
#define IMGCHG_ANIMATE      0x0008
#define IMGCHG_MASK         0x000F

#define IMGLOAD_NOTLOADED   0x00100000  // Image has not yet been loaded
#define IMGLOAD_LOADING     0x00200000  // Image in the process of being loaded
#define IMGLOAD_STOPPED     0x00400000  // Imaged aborted
#define IMGLOAD_ERROR       0x00800000  // Error loading image
#define IMGLOAD_COMPLETE    0x01000000  // Image loaded
#define IMGLOAD_MASK        0x01F00000

#define IMGBITS_NONE        0x02000000
#define IMGBITS_PARTIAL     0x04000000
#define IMGBITS_TOTAL       0x08000000
#define IMGBITS_MASK        0x0E000000

#define IMGANIM_ANIMATED    0x10000000
#define IMGANIM_MASK        0x10000000

#define IMGTRANS_OPAQUE     0x20000000
#define IMGTRANS_MASK       0x20000000

#define DWN_COLORMODE       0x0000003F  // Explicit color mode requested
#define DWN_DOWNLOADONLY    0x00000040  // Download data only, don't decode
#define DWN_FORCEDITHER     0x00000080  // Override automatic dithering
#define DWN_RAWIMAGE        0x00000100  // Disable dithering 

/* Definition of interface: IImgCtx */
#undef INTERFACE
#define INTERFACE IImgCtx

// {3050f3d7-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_IImgCtx, 0x3050f3d7, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

DECLARE_INTERFACE_(IImgCtx, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IImgCtx methods */

    /* Initialization/Download methods */
    STDMETHOD(Load)(THIS_ LPCWSTR pszUrl, DWORD dwFlags) PURE;
    STDMETHOD(SelectChanges)(THIS_ ULONG ulChgOn, ULONG ulChgOff, BOOL fSignal) PURE;
    STDMETHOD(SetCallback)(THIS_ PFNIMGCTXCALLBACK pfn, void * pvPrivateData) PURE;
    STDMETHOD(Disconnect)(THIS) PURE;

	/* Query methods */
    STDMETHOD(GetUpdateRects)(THIS_ struct tagRECT FAR* prc, struct tagRECT FAR* prcImg, long FAR* pcrc) PURE;
    STDMETHOD(GetStateInfo)(THIS_ ULONG FAR* pulState, struct tagSIZE FAR* psize, BOOL fClearChanges) PURE;
    STDMETHOD(GetPalette)(THIS_ HPALETTE FAR* phpal) PURE;

    /* Rendering methods */
    STDMETHOD(Draw)(THIS_ HDC hdc, struct tagRECT FAR* prcBounds) PURE;
    STDMETHOD(Tile)(THIS_ HDC hdc, struct tagPOINT FAR* pptBackOrg, struct tagRECT FAR* prcClip, struct tagSIZE FAR* psize) PURE;
    STDMETHOD(StretchBlt)(THIS_ HDC hdc, int dstX, int dstY, int dstXE, int dstYE, int srcX, int srcY, int srcXE, int srcYE, DWORD dwROP) PURE;
};

#ifdef COBJMACROS


#define IImgCtx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImgCtx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImgCtx_Release(This)	\
    (This)->lpVtbl -> Release(This)

#define IImgCtx_Load(This, pszUrl, dwFlags)	\
	(This)->lpVtbl -> Load(This, pszUrl, dwFlags)

#define IImgCtx_Draw(This, hdc, prcBounds)		\
	(This)->lpVtbl -> Draw(This, hdc, prcBounds)

#define IImgCtx_Tile(This, hdc, pptBackOrg, prcClip, psize)		\
	(This)->lpVtbl -> Tile(This, hdc, pptBackOrg, prcClip, psize)

#define IImgCtx_GetUpdateRects(This, prc, prcImg, pcrc)	\
	(This)->lpVtbl -> GetUpdateRects(This, prc, prcImg, pcrc)

#define IImgCtx_GetStateInfo(This, pulState, psize, fClearChanges)	\
	(This)->lpVtbl -> GetStateInfo(This, pulState, psize, fClearChanges)

#define IImgCtx_GetPalette(This, phpal)	\
	(This)->lpVtbl -> GetPalette(This, phpal)
	
#define IImgCtx_SelectChanges(This, ulChgOn, ulChgOff, fSignal)	\
	(This)->lpVtbl -> SelectChanges(This, ulChgOn, ulChgOff, fSignal)

#define IImgCtx_SetCallback(This, pfnCallback, pvPrivateData)	\
	(This)->lpVtbl -> SetCallback(This, pfnCallback, pvPrivateData)

#define IImgCtx_Disconnect(This) \
    (This)->lpVtbl -> Disconnect(This)

#define IImgCtx_StretchBlt(This, hdc, dstX, dstY, dstXE, dstYE, srcX, srcY, srcXE, srcYE, dwROP)   \
    (This)->lpVtbl -> StretchBlt(This, hdc, dstX, dstY, dstXE, dstYE, srcX, srcY, srcXE, srcYE, dwROP)

#endif /* COBJMACROS */


// {3050f3d6-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_IImgCtx, 0x3050f3d6, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\knob.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  KNOB.CPP
//
//      Multimedia Knob Control class; helper functions
//
//      Copyright (c) Microsoft Corporation     1997
//    
//      12/18/97 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "knob.h"
#include "windowsx.h"
#include <TCHAR.H>
#include "resource.h"
#include "dib.h"
#include "math.h"
#include "mmfw.h"

#ifdef UNICODE
    #define WC_KNOB L"DES_KnobClass"
#else
    #define WC_KNOB "DES_KnobClass"
#endif

//externals
extern  HPALETTE hpalMain;
extern  int g_nColorMode;

#define LIGHT_OFFSET 9
#define RADIAN_45DEG  0.785398163397448309615
#define RADIAN_90DEG  1.57079632679489661923
#define RADIAN_135DEG 2.356194490192344899999999999925
#define DEGREE_CONVERTER 57.295779513082320876846364344191
#define RADIAN_CONVERTER 0.017453292519943295769222222222222

#define TRACK_TICK 5
#define FAST_TRACK_TICK 1
#define TRACK_DEGREES_PER_TICK 10

#define FLASH_TICK      150

#define KEYBOARD_STEP 3000

//static data members ... these control the Window Class
HINSTANCE CKnob::m_hInst = NULL;
DWORD CKnob::m_dwKnobClassRef = 0;
ATOM CKnob::m_KnobAtom = NULL;
HANDLE CKnob::m_hbmpKnob = NULL;
HANDLE CKnob::m_hbmpKnobTab = NULL;
HANDLE CKnob::m_hbmpLight = NULL;
HANDLE CKnob::m_hbmpLightBright = NULL;
HANDLE CKnob::m_hbmpLightMask = NULL;
int CKnob::m_nLightWidth = 0;
int CKnob::m_nLightHeight = 0;

CKnob* CreateKnob(DWORD dwWindowStyle,
		  DWORD dwRange,
		  DWORD dwInitialPosition,
		  int x,
		  int y,
		  int width,
		  int height,
		  HWND hwndParent,
		  int nID,
		  HINSTANCE hInst)
{
    if (CKnob::m_KnobAtom == NULL)
    {
    	CKnob::InitKnobs(hInst);
    }

    CKnob* pKnob = new CKnob;

    //ensure this is a child window
    dwWindowStyle = dwWindowStyle|WS_CHILD;

	TCHAR szCaption[MAX_PATH];
	LoadString(hInst,IDB_TT_VOLUME,szCaption,sizeof(szCaption)/sizeof(TCHAR));

    HWND hwnd = CreateWindowEx(0,
			       WC_KNOB,
			       szCaption,
			       dwWindowStyle,
			       x,
			       y,
			       width,
			       height,
			       hwndParent,
			       (HMENU)nID,
			       hInst,
			       NULL);

    if (hwnd == NULL)
    {
	    //if we can't create the window, nuke it and fail
	    DWORD dwErr = GetLastError();
	    delete pKnob;
	    return NULL;
    }

    SetWindowLongPtr(hwnd,0,(LONG_PTR)pKnob);

    pKnob->m_hwnd = hwnd;
    pKnob->m_nID = nID;
    pKnob->SetRange(dwRange);
    pKnob->SetPosition(dwInitialPosition,FALSE);

    return (pKnob);
}

BOOL CKnob::InitKnobs(HINSTANCE hInst)
{
    m_hInst = hInst;
    
    if (m_KnobAtom == NULL)
    {
	    WNDCLASSEX wc;

	    ZeroMemory(&wc,sizeof(wc));
 
	    wc.cbSize = sizeof(wc);
	    wc.lpszClassName = WC_KNOB;
	    wc.lpfnWndProc = CKnob::KnobProc;
	    wc.hInstance = hInst;
	    wc.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
	    wc.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_MMFW));
	    wc.hCursor = LoadCursor(hInst, MAKEINTRESOURCE(IDC_VOLHAND));
	    wc.hbrBackground = (HBRUSH)(CTLCOLOR_DLG+1);
	    wc.cbWndExtra = sizeof(CKnob*);

	    m_KnobAtom = RegisterClassEx(&wc);
    }

    int nBitmap = IDB_KNOB;
    switch (g_nColorMode)
    {
        case COLOR_16 : nBitmap = IDB_KNOB_16; break;
        case COLOR_HICONTRAST : nBitmap = IDB_KNOB_HI; break;
    }

    HBITMAP hbmpTemp = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	CKnob::m_hbmpKnob = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    DeleteObject(hbmpTemp);

    nBitmap = IDB_KNOB_TABSTATE;
    switch (g_nColorMode)
    {
        case COLOR_16 : nBitmap = IDB_KNOB_TABSTATE_16; break;
        case COLOR_HICONTRAST : nBitmap = IDB_KNOB_TABSTATE_HI; break;
    }
    
    hbmpTemp = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	CKnob::m_hbmpKnobTab = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    DeleteObject(hbmpTemp);

    nBitmap = IDB_KNOB_LIGHT_DIM;
    switch (g_nColorMode)
    {
        case COLOR_16 : nBitmap = IDB_KNOB_LIGHT_16; break;
        case COLOR_HICONTRAST : nBitmap = IDB_KNOB_LIGHT_16; break;
    }
    
    hbmpTemp = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	CKnob::m_hbmpLight = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    BITMAP bm;
    GetObject(hbmpTemp,sizeof(bm),&bm);
    CKnob::m_nLightWidth = bm.bmWidth;
    CKnob::m_nLightHeight = bm.bmHeight;
    DeleteObject(hbmpTemp);

    nBitmap = IDB_KNOB_LIGHT;
    switch (g_nColorMode)
    {
        case COLOR_16 : nBitmap = IDB_KNOB_LIGHT_16; break;
        case COLOR_HICONTRAST : nBitmap = IDB_KNOB_LIGHT_HI; break;
    }
    
    hbmpTemp = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	CKnob::m_hbmpLightBright = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    DeleteObject(hbmpTemp);

    m_hbmpLightMask = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(IDB_KNOB_LIGHTMASK),IMAGE_BITMAP,0,0,LR_MONOCHROME);

    return (m_KnobAtom != NULL);
}

void CKnob::UninitKnobs()
{
    UnregisterClass(WC_KNOB,m_hInst);
    DeleteObject(CKnob::m_hbmpLightMask);
    GlobalFree(CKnob::m_hbmpLight);
    GlobalFree(CKnob::m_hbmpKnob);
    GlobalFree(CKnob::m_hbmpKnobTab);
    GlobalFree(CKnob::m_hbmpLightBright);
    m_KnobAtom = NULL;
    CKnob::m_hbmpLight = NULL;
    CKnob::m_hbmpKnob = NULL;
    CKnob::m_hbmpKnobTab = NULL;
    CKnob::m_hbmpLightMask = NULL;
    CKnob::m_hbmpLightBright = NULL;
}

//Given a parent window and a control ID, return the CMButton object
CKnob* GetKnobFromID(HWND hwndParent, int nID)
{
    HWND hwnd = GetDlgItem(hwndParent, nID);
    return (GetKnobFromHWND(hwnd));
}

//Given the window handle of the button, return the CMButton object
CKnob* GetKnobFromHWND(HWND hwnd)
{
    CKnob* pKnob = (CKnob*)GetWindowLongPtr(hwnd, 0);
    return (pKnob);    
}

CKnob::CKnob()
{
    m_dwKnobClassRef++;

    m_hwnd = NULL;
    m_nID = -1;
    m_nLightX = 0;
    m_nLightY = 0;
    m_dwRange = 100;
    m_dwPosition = 0;
    m_dwCurPosition = 0;
    m_fDim = TRUE;
}

CKnob::~CKnob()
{
    m_dwKnobClassRef--;

    if (m_dwKnobClassRef==0)
    {
	    UninitKnobs();
    }
}

void CALLBACK CKnob::TrackProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    CKnob* pKnob = (CKnob*)idEvent; //idEvent holds pointer to knob object that created timer
    if (pKnob!=NULL)
    {
        pKnob->OnTimer();
    }
}

void CALLBACK CKnob::FlashProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    CKnob* pKnob = (CKnob*)GetWindowLongPtr(hwnd, 0);
    if (pKnob!=NULL)
    {
        pKnob->OnFlashTimer();
    }
}

LRESULT CALLBACK CKnob::KnobProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    CKnob* pKnob = (CKnob*)GetWindowLongPtr(hwnd, 0);

    if (pKnob != NULL)
    {
	    switch (iMsg)
	    {
            case WM_SETFOCUS :
            {
                SendMessage(GetParent(pKnob->m_hwnd),DM_SETDEFID,pKnob->m_nID,0);

                pKnob->m_fDim = FALSE;
                InvalidateRect(hwnd,NULL,FALSE);
                UpdateWindow(hwnd);

                pKnob->m_uFlashTimerID = SetTimer(hwnd,(UINT_PTR)hwnd,FLASH_TICK,(TIMERPROC)CKnob::FlashProc);
            }
            break;

            case WM_KILLFOCUS :
            {
                KillTimer(hwnd,pKnob->m_uFlashTimerID);
                pKnob->m_fDim = TRUE;
                InvalidateRect(hwnd,NULL,FALSE);
                UpdateWindow(hwnd);
            }
            break;
            
            case WM_GETDLGCODE :
            {
                return (DLGC_WANTARROWS);
            }
            break;

            case WM_KEYDOWN :
            {
                int nVirtKey = (int)wParam;
                DWORD dwCurrent = pKnob->GetPosition();

                switch (nVirtKey)
                {
                    case VK_LEFT :
                    case VK_DOWN : 
                    {
                        if (dwCurrent - KEYBOARD_STEP > 65535)
                        {
                            dwCurrent = KEYBOARD_STEP;
                        }
                        pKnob->SetPosition(dwCurrent - KEYBOARD_STEP,TRUE);

                        NMHDR nmhdr;
                        nmhdr.hwndFrom = pKnob->m_hwnd;
                        nmhdr.idFrom = pKnob->m_nID;
                        nmhdr.code = TRUE;

                        SendMessage(GetParent(pKnob->m_hwnd),WM_NOTIFY,(WPARAM)pKnob->m_nID,(LPARAM)&nmhdr);
                    }
                    break;

                    case VK_RIGHT :
                    case VK_UP :
                    {
                        if (dwCurrent + KEYBOARD_STEP > 65535)
                        {
                            dwCurrent = 65535 - KEYBOARD_STEP;
                        }
                        pKnob->SetPosition(dwCurrent + KEYBOARD_STEP,TRUE);

                        NMHDR nmhdr;
                        nmhdr.hwndFrom = pKnob->m_hwnd;
                        nmhdr.idFrom = pKnob->m_nID;
                        nmhdr.code = TRUE;

                        SendMessage(GetParent(pKnob->m_hwnd),WM_NOTIFY,(WPARAM)pKnob->m_nID,(LPARAM)&nmhdr);
                    }
                    break;

                    default: 
                    {
                        //not a key we want ... tell our parent about it
                        SendMessage(GetParent(hwnd),WM_KEYDOWN,wParam,lParam);
                    }
                    break;
                } //end switch
            }
            break;

            case WM_ERASEBKGND :
            {
                pKnob->Draw((HDC)wParam);
                return TRUE;
            }

	        case WM_PAINT :
	        {
		        HDC hdc;
		        PAINTSTRUCT ps;

		        hdc = BeginPaint( hwnd, &ps );
		        
		        pKnob->Draw(hdc);
		        
		        EndPaint(hwnd,&ps);

                return 0;
	        }
	        break;

	        case WM_RBUTTONDOWN :
	        {
                pKnob->m_fFastKnob = TRUE;
    		    pKnob->OnButtonDown(LOWORD(lParam),HIWORD(lParam));
	    	    pKnob->OnMouseMove(LOWORD(lParam),HIWORD(lParam));
	        }
	        break;

	        case WM_RBUTTONUP :
	        {
    		    pKnob->OnButtonUp();
	        }
	        break;

	        case WM_LBUTTONDOWN :
	        {
                pKnob->m_fFastKnob = FALSE;
    		    pKnob->OnButtonDown(LOWORD(lParam),HIWORD(lParam));
	    	    pKnob->OnMouseMove(LOWORD(lParam),HIWORD(lParam));
	        }
	        break;

	        case WM_LBUTTONUP :
	        {
    		    pKnob->OnButtonUp();
	        }
	        break;

	        case WM_MOUSEMOVE :
	        {
	    	    pKnob->OnMouseMove(LOWORD(lParam),HIWORD(lParam));
	        }
	        break;

	    } //end switch
    } //end if class pointer assigned

    LRESULT lResult = DefWindowProc(hwnd, iMsg, wParam, lParam);

    if (iMsg == WM_DESTROY)
    {
	    //auto-delete the knob class
	    SetWindowLongPtr(hwnd,0,0);
	    if (pKnob)
	    {
	        delete pKnob;
	    }
	    pKnob = NULL;
    }

    return (lResult);
}

void CKnob::OnButtonDown(int x, int y)
{
    SetCapture(m_hwnd);

    m_fDim = FALSE;
    InvalidateRect(m_hwnd,NULL,FALSE);
    UpdateWindow(m_hwnd);

    m_uFlashTimerID = SetTimer(m_hwnd,(UINT_PTR)m_hwnd,FLASH_TICK,(TIMERPROC)CKnob::FlashProc);
}

void CKnob::OnButtonUp()
{
    KillTimer(m_hwnd,m_uTrackTimerID);
    KillTimer(m_hwnd,m_uFlashTimerID);

    //we want to be sure the light is dim when we're done
    if (!m_fDim)
    {
        m_fDim = TRUE;
        InvalidateRect(m_hwnd,NULL,FALSE);
        UpdateWindow(m_hwnd);
    }

    ReleaseCapture();
}

void CKnob::OnFlashTimer()
{
    m_fDim = !m_fDim;
    InvalidateRect(m_hwnd,NULL,FALSE);
    UpdateWindow(m_hwnd);
}

void CKnob::OnTimer()
{
    RECT rect;
    GetClientRect(m_hwnd,&rect);
    int nWidth = rect.right - rect.left;
    int radius = (nWidth / 2) - LIGHT_OFFSET;

    double degree = ((double)m_dwPosition / m_dwRange) * 270;
    degree = degree + 135;

    if (abs((int)m_trackdegree-(int)degree) < TRACK_DEGREES_PER_TICK)
    {
        m_trackdegree = degree;
        KillTimer(m_hwnd,m_uTrackTimerID);
    }
    else
    {
        if (m_trackdegree > degree)
        {
            m_trackdegree -= TRACK_DEGREES_PER_TICK;
        }
        else
        {
            m_trackdegree += TRACK_DEGREES_PER_TICK;
        }
    }

    double angle = m_trackdegree * RADIAN_CONVERTER;

    double fLightX = radius * cos(angle);
    double fLightY = radius * sin(angle);

    //convert to proper gdi coordinates
    m_nLightX = ((int)fLightX) - (m_nLightWidth / 2) + (nWidth / 2);
    m_nLightY = ((int)fLightY) - (m_nLightHeight / 2) + (nWidth / 2);

    InvalidateRect(m_hwnd,NULL,FALSE);
    UpdateWindow(m_hwnd);

	degree = m_trackdegree - 135;
	if (degree < 0) degree = degree + 360;
	double percentage = degree / 270; 
	m_dwCurPosition = (DWORD)(m_dwRange * percentage);

    NMHDR nmhdr;
    nmhdr.hwndFrom = m_hwnd;
    nmhdr.idFrom = m_nID;
    nmhdr.code = TRUE;

    SendMessage(GetParent(m_hwnd),WM_NOTIFY,(WPARAM)m_nID,(LPARAM)&nmhdr);
}


BOOL CKnob::ComputeCursor(int deltaX, int deltaY, int maxdist)
{
    double  distance = sqrt(double((deltaX * deltaX) + (deltaY * deltaY)));
    double  degrees =  -((atan2(deltaX,deltaY) * DEGREE_CONVERTER) - double(180.0));
    BOOL    fDeadZone = FALSE;

    if (distance < double(4))
    {
        fDeadZone = TRUE;
    }

    if (distance <= maxdist)
    {
        SetCursor(LoadCursor(m_hInst, MAKEINTRESOURCE(IDC_VOLHAND)));
    }
    else
    {
        int volcur;

        if ((degrees < double( 22.5) || degrees > double(337.5)) ||
            (degrees > double(157.5) && degrees < double(202.5)))
        {
            volcur = IDC_VOLHORZ;
        }
        else if ((degrees > double( 22.5) && degrees < double( 67.5)) ||
                 (degrees > double(202.5) && degrees < double(247.5)))
        {
            volcur = IDC_VOLDNEG;
        }
        else if ((degrees > double( 67.5) && degrees < double(112.5)) ||
                 (degrees > double(247.5) && degrees < double(292.5)))
        {
            volcur = IDC_VOLVERT;
        }
        else 
        {
            volcur = IDC_VOLDPOS;
        }

        SetCursor(LoadCursor(m_hInst, MAKEINTRESOURCE(volcur)));
    }

    return fDeadZone;
}

void CKnob::OnMouseMove(int x, int y)
{
    if (GetCapture()==m_hwnd)
    {
        //do the calculations as if 0,0 were the center of the control,
	    //then translate to gdi coordinates later (0,0 = top left of control in gdi)
	    RECT rect;
	    GetClientRect(m_hwnd,&rect);
	    int nWidth = rect.right - rect.left;
	    int nHeight = rect.bottom - rect.top;

        int maxdist = (nWidth / 2) + 3;
	    int radius = (nWidth / 2) - LIGHT_OFFSET;

	    //convert to short to force negative numbers for coordinates
	    short sx = (short)x;
	    short sy = (short)y;

	    int deltaX = sx - (nWidth / 2);
	    int deltaY = sy - (nHeight / 2);

        BOOL fDeadZone = ComputeCursor(deltaX, deltaY, maxdist);

        if (!fDeadZone)
        {
	        double angle = atan2(deltaY,deltaX);
	        double degrees = angle * DEGREE_CONVERTER;


	        degrees = degrees + 225;

	        if (degrees < 0) degrees = 0;
        
            if (degrees >= 360)
            {
                degrees = degrees - 360;
            }        
        
            if (degrees > 270)
            {
                return; //block this case
            }
	                
            double percentage = degrees / 270; 

            m_dwPosition = (DWORD)(m_dwRange * percentage);

            if (m_fFastKnob)
            {
                 m_uTrackTimerID = SetTimer(m_hwnd,(UINT_PTR)this,FAST_TRACK_TICK,(TIMERPROC)CKnob::TrackProc);
            }
            else
            {
                m_uTrackTimerID = SetTimer(m_hwnd,(UINT_PTR)this,TRACK_TICK,(TIMERPROC)CKnob::TrackProc);
            }
        }
    }
}

void CKnob::SetPosition(DWORD dwPosition, BOOL fNotify)
{
    if (GetCapture()==m_hwnd)
    {
        //we're in a feedback loop, return immediately
        return;
    }
    
    m_dwPosition = dwPosition;
    m_dwCurPosition = dwPosition;

    RECT rect;
    GetClientRect(m_hwnd,&rect);
    int nWidth = rect.right - rect.left;
    int radius = (nWidth / 2) - LIGHT_OFFSET;

    double degree = ((double)m_dwPosition / m_dwRange) * 270;
    degree = degree + 135;

    m_trackdegree = degree; //instantly track when position is set programmatically

    double angle = degree * RADIAN_CONVERTER;

    double fLightX = radius * cos(angle);
    double fLightY = radius * sin(angle);

    //convert to proper gdi coordinates
    m_nLightX = ((int)fLightX) - (m_nLightWidth / 2) + (nWidth / 2);
    m_nLightY = ((int)fLightY) - (m_nLightHeight / 2) + (nWidth / 2);

    InvalidateRect(m_hwnd,NULL,FALSE);
    UpdateWindow(m_hwnd);

    if (fNotify)
    {
        NMHDR nmhdr;
        nmhdr.hwndFrom = m_hwnd;
        nmhdr.idFrom = m_nID;
        nmhdr.code = FALSE;

        SendMessage(GetParent(m_hwnd),WM_NOTIFY,(WPARAM)m_nID,(LPARAM)&nmhdr);
    }
}

//kmaskblt -- cuz MaskBlt doesn't work on all platforms.  This is all it does anyway.
//            uses same params as MaskBlt, ignoring the flags part as dwDummy
void CKnob::KMaskBlt(HDC hdcDest, int x, int y, int width, int height, HDC hdcSource, int xs, int ys, HBITMAP hMask, int xm, int ym, DWORD dwDummy)
{
    HDC hdcMask = CreateCompatibleDC(hdcDest);
    HBITMAP holdbmp = (HBITMAP)SelectObject(hdcMask,hMask);

    BitBlt(hdcDest, x, y, width, height, hdcSource, xs, ys, SRCINVERT);
    BitBlt(hdcDest, x, y, width, height, hdcMask, xm, ym, SRCAND);
    BitBlt(hdcDest, x, y, width, height, hdcSource, xs, ys, SRCINVERT);

    SelectObject(hdcMask,holdbmp);
    DeleteDC(hdcMask);
}

void CKnob::Draw(HDC hdc)
{
    RECT rect;
    GetClientRect(m_hwnd,&rect);
    int nWidth = rect.right - rect.left;
    int nHeight = rect.bottom - rect.top;

    HPALETTE hpalOld = SelectPalette(hdc,hpalMain,FALSE);
    RealizePalette(hdc);
    
    HDC memDC = CreateCompatibleDC(hdc);
    HPALETTE hpalmemOld = SelectPalette(memDC,hpalMain,FALSE);
    RealizePalette(memDC);
    
    HBITMAP hbmp = CreateCompatibleBitmap(hdc,nWidth,nHeight);
    HBITMAP hbmpOld = (HBITMAP)SelectObject(memDC,hbmp);

    HDC maskmemDC = CreateCompatibleDC(hdc);
    HBITMAP hmaskbmp = CreateCompatibleBitmap(hdc,nWidth,nHeight);
    HBITMAP hmaskbmpOld = (HBITMAP)SelectObject(maskmemDC,hmaskbmp);

    if (GetFocus()==m_hwnd)
    {
        DibBlt(memDC, 0, 0, -1, -1, m_hbmpKnobTab, 0, 0, SRCCOPY, 0);
    }
    else
    {
        DibBlt(memDC, 0, 0, -1, -1, m_hbmpKnob, 0, 0, SRCCOPY, 0);
    }

    DibBlt(maskmemDC, 0, 0, -1, -1, m_fDim ? m_hbmpLight : m_hbmpLightBright, 0, 0, SRCCOPY, 0);
    KMaskBlt(memDC,
	    m_nLightX,
	    m_nLightY,
	    m_nLightWidth,
	    m_nLightHeight,
	    maskmemDC,
	    0,
	    0,
	    (HBITMAP)m_hbmpLightMask,
	    0,
	    0,
	    MAKEROP4(SRCAND,SRCCOPY));

    BitBlt(hdc,0,0,nWidth,nHeight,memDC,0,0,SRCCOPY);
    
    SelectObject(memDC,hbmpOld);
    SelectPalette(memDC,hpalmemOld,TRUE);
    RealizePalette(memDC);
    DeleteObject(hbmp);
    DeleteDC(memDC);

    SelectObject(maskmemDC, hmaskbmpOld);
    DeleteObject(hmaskbmp);
    DeleteDC(maskmemDC);

    SelectPalette(hdc,hpalOld,TRUE);
    RealizePalette(hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\knob.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  KNOB.H
//
//	Defines the Knob Control
//
//	Copyright (c) Microsoft Corporation	1997
//    
//	12/18/97 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _KNOB_HEADER_
#define _KNOB_HEADER_

#include "windows.h"

#ifdef __cplusplus
extern "C" {
#endif

//forward declaration
class CKnob;

//helper functions for global stuff, start up, shut down, etc.
CKnob* GetKnobFromID(HWND hwndParent, int nID);
CKnob* GetKnobFromHWND(HWND hwnd);

class CKnob
{
    public:
        /*
        Create a class of the knob
        */
        friend CKnob* CreateKnob(DWORD dwWindowStyle,
                                 DWORD dwRange,
                                 DWORD dwInitialPosition,
                                 int x,
                                 int y,
                                 int width,
                                 int height,
                                 HWND hwndParent,
                                 int nID,
                                 HINSTANCE hInst);

        CKnob(); //constructor
        ~CKnob(); //destructor

        HWND GetHWND() {return m_hwnd;}
        int GetID() {return m_nID;}
        void SetRange(DWORD dwRange) {m_dwRange = dwRange;}
        DWORD GetRange() {return m_dwRange;}
        DWORD GetPosition() {return m_dwCurPosition;}

        void SetPosition(DWORD dwPosition, BOOL fNotify);

    private:
        //non-static privates
        int m_nID;
        HWND m_hwnd;
        int m_nLightX;
        int m_nLightY;
        DWORD m_dwRange;
        DWORD m_dwPosition;
        DWORD m_dwCurPosition;
        double m_trackdegree;
        UINT_PTR m_uFlashTimerID;
        UINT_PTR m_uTrackTimerID;
        BOOL m_fDim;
        BOOL m_fFastKnob;

        void OnButtonDown(int x, int y);
        void OnButtonUp();
        BOOL ComputeCursor(int deltaX, int deltaY, int maxdist);
        void OnMouseMove(int x, int y);
        void OnTimer();
        void OnFlashTimer();
        void Draw(HDC hdc);
        void KMaskBlt(HDC hdcDest, int x, int y, int width, int height, HDC hdcSource, int xs, int ys, HBITMAP hMask, int xm, int xy, DWORD dwDummy);

    private:
        //static stuff for all knobs
        static HINSTANCE m_hInst;
        static DWORD m_dwKnobClassRef;
        static ATOM m_KnobAtom;
        static HANDLE m_hbmpKnob;
        static HANDLE m_hbmpKnobTab;
        static HANDLE m_hbmpLight;
        static HANDLE m_hbmpLightBright;
        static HANDLE m_hbmpLightMask;
        static int m_nLightWidth;
        static int m_nLightHeight;

        static LRESULT CALLBACK KnobProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
        static void CALLBACK TrackProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
        static void CALLBACK FlashProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
        static BOOL InitKnobs(HINSTANCE hInst);
        static void UninitKnobs();
};

#ifdef __cplusplus
};
#endif

#endif  //_KNOB_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\mmenu.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	MMENU.CPP: Defines custom menu interface for multimedia applet
//
//	Copyright (c) Microsoft Corporation	1998
//    
//	1/28/98 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "windows.h"
#include "mmenu.h"
#include "tchar.h"
#include "resource.h"

#define ICON_SPACING 3

extern HINSTANCE hInst;

typedef struct ownermenu
{
    TCHAR szText[MAX_PATH];
    HICON hIcon;
} OWNERMENU, *LPOWNERMENU;

HRESULT AllocCustomMenu(CustomMenu** ppMenu)
{
    *ppMenu = new CCustomMenu();
    
    if (*ppMenu==NULL)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

CCustomMenu::CCustomMenu()
{
    m_hMenu = CreatePopupMenu();

    //get system font for any owner drawing
    NONCLIENTMETRICS metrics;
    metrics.cbSize = sizeof(metrics);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS,sizeof(metrics),&metrics,0);

    m_hFont = CreateFontIndirect(&metrics.lfMenuFont);

    if (metrics.lfMenuFont.lfCharSet == ANSI_CHARSET)
    {
        metrics.lfMenuFont.lfWeight = FW_BOLD;
    }
       
    m_hBoldFont = CreateFontIndirect(&metrics.lfMenuFont);
}

CCustomMenu::~CCustomMenu()
{
    //clean up string data in menus
    int x  = GetMenuItemCount(m_hMenu);

    for (int i = 0; i < x; i++)
    {
        MENUITEMINFO mii;
        ZeroMemory(&mii,sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_DATA|MIIM_TYPE;
        GetMenuItemInfo(m_hMenu,i,TRUE,&mii);

        if ((mii.dwItemData!=0) && (mii.fType & MFT_OWNERDRAW))
        {
            OWNERMENU* pMenu = (OWNERMENU*)mii.dwItemData;
            if (pMenu)
            {
                DestroyIcon(pMenu->hIcon);
                delete [] pMenu;
            }
        }
    }

    DestroyMenu(m_hMenu);
    DeleteObject(m_hFont);
    DeleteObject(m_hBoldFont);
}

void CCustomMenu::Destroy()
{
    delete this;
}

BOOL CCustomMenu::AppendMenu(HINSTANCE hInst, int nStringID, CustomMenu* pMenu)
{
    TCHAR szMenu[MAX_PATH];
    LoadString(hInst,nStringID,szMenu,sizeof(szMenu)/sizeof(TCHAR));

    return ::AppendMenu(m_hMenu,MF_STRING|MF_POPUP,(UINT_PTR)pMenu->GetMenuHandle(),szMenu);
}

BOOL CCustomMenu::AppendMenu(int nMenuID, TCHAR* szMenu)
{
    return ::AppendMenu(m_hMenu,MF_STRING,nMenuID,szMenu);
}

BOOL CCustomMenu::AppendMenu(int nMenuID, HINSTANCE hInst, int nStringID)
{
    TCHAR szMenu[MAX_PATH];
    LoadString(hInst,nStringID,szMenu,sizeof(szMenu)/sizeof(TCHAR));

    return ::AppendMenu(m_hMenu,MF_STRING,nMenuID,szMenu);
}

BOOL CCustomMenu::AppendSeparator()
{
    return ::AppendMenu(m_hMenu,MF_SEPARATOR,0,0);
}

BOOL CCustomMenu::AppendMenu(int nMenuID, HINSTANCE hInst, int nIconID, int nStringID)
{
    OWNERMENU* pMenu = new OWNERMENU;

    if (!pMenu)
    {
        return FALSE;
    }

    LoadString(hInst,nStringID,pMenu->szText,sizeof(pMenu->szText)/sizeof(TCHAR));

    int cxMiniIcon = (int)GetSystemMetrics(SM_CXSMICON);
    int cyMiniIcon = (int)GetSystemMetrics(SM_CYSMICON);

    pMenu->hIcon = (HICON)LoadImage(hInst, MAKEINTRESOURCE(nIconID), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);

    return ::AppendMenu(m_hMenu,MF_OWNERDRAW,nMenuID,(LPTSTR)pMenu);
}

BOOL CCustomMenu::TrackPopupMenu(UINT uFlags, int x, int y, HWND hwnd, CONST RECT* pRect)
{
    TPMPARAMS tpm;
    tpm.cbSize = sizeof(tpm);
    memcpy(&(tpm.rcExclude),pRect,sizeof(RECT));
    
    return ::TrackPopupMenuEx(m_hMenu,uFlags,x,y,hwnd,&tpm);
}

BOOL CCustomMenu::SetMenuDefaultItem(UINT uItem, UINT fByPos)
{
    return ::SetMenuDefaultItem(m_hMenu,uItem,fByPos);
}

void CCustomMenu::MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pMeasure)
{
    OWNERMENU* szMenu = (OWNERMENU*)pMeasure->itemData;

    int cxMiniIcon = (int)GetSystemMetrics(SM_CXSMICON);
    int cyMiniIcon = (int)GetSystemMetrics(SM_CYSMICON);

    HDC hdc = GetDC(hwnd);

    HFONT hOrgFont = (HFONT)SelectObject(hdc,m_hBoldFont);
    SIZE size;

    GetTextExtentPoint32(hdc, szMenu->szText, _tcslen(szMenu->szText), &size );

    pMeasure->itemWidth = size.cx + cxMiniIcon + (ICON_SPACING*2);
    pMeasure->itemHeight = max(cyMiniIcon,size.cy);

    SelectObject(hdc,hOrgFont);
    ReleaseDC(hwnd,hdc);
}

void CCustomMenu::DrawItem(HWND hwnd, LPDRAWITEMSTRUCT pDraw)
{
    OWNERMENU* szMenu = (OWNERMENU*)pDraw->itemData;
    HDC hdc = pDraw->hDC;

    COLORREF colorFill = GetSysColor(COLOR_MENU);
    COLORREF colorText = GetSysColor(COLOR_MENUTEXT);

    if (pDraw->itemState & ODS_SELECTED)
    {
        colorFill = GetSysColor(COLOR_HIGHLIGHT);
        colorText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    }

    HBRUSH hbrBack = CreateSolidBrush(GetSysColor(COLOR_MENU));

    //blit the icon, always with menu color background
    int cxMiniIcon = (int)GetSystemMetrics(SM_CXSMICON);
    int cyMiniIcon = (int)GetSystemMetrics(SM_CYSMICON);
    DrawIconEx(hdc,pDraw->rcItem.left,pDraw->rcItem.top,szMenu->hIcon,cxMiniIcon,cyMiniIcon,0,hbrBack,DI_NORMAL);

    DeleteObject(hbrBack);
    hbrBack = CreateSolidBrush(colorFill);

    HFONT hOrgFont;
        
    if (pDraw->itemState & ODS_DEFAULT)
    {
        hOrgFont = (HFONT)SelectObject(hdc,m_hBoldFont);
    }
    else
    {
        hOrgFont = (HFONT)SelectObject(hdc,m_hFont);
    }

    pDraw->rcItem.left += (cxMiniIcon + ICON_SPACING);

    FillRect(hdc,&pDraw->rcItem,hbrBack);
    
    DeleteObject(hbrBack);

    pDraw->rcItem.left += ICON_SPACING;

    SetBkMode(hdc,TRANSPARENT);
    SetTextColor(hdc,colorText);

    DrawText(hdc, szMenu->szText, -1, &pDraw->rcItem, DT_SINGLELINE);

    SelectObject(hdc,hOrgFont);
}

LRESULT CCustomMenu::MenuChar(TCHAR tChar, UINT fuFlag, HMENU hMenu)
{
    //go through the menus one-by-one looking for the accel key
    int nReturn = 0;
    int nCode = MNC_IGNORE;

    int x  = GetMenuItemCount(m_hMenu);

    TCHAR teststr[3];
    wsprintf(teststr,TEXT("&%c"),tChar);
    _tcsupr(teststr);

    for (int i = 0; i < x; i++)
    {
        MENUITEMINFO mii;
        ZeroMemory(&mii,sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_DATA|MIIM_TYPE;
        GetMenuItemInfo(m_hMenu,i,TRUE,&mii);

        if ((mii.dwItemData!=0) && (mii.fType & MFT_OWNERDRAW))
        {
            OWNERMENU* szMenu = (OWNERMENU*)mii.dwItemData;
            TCHAR* pMenu = new TCHAR[_tcslen(szMenu->szText)+sizeof(TCHAR)];
            _tcscpy(pMenu,szMenu->szText);

            _tcsupr(pMenu);

            if (_tcsstr(pMenu,teststr)!=NULL)
            {
                nReturn = i;
                nCode = MNC_EXECUTE;
                if (pMenu)
                {
                    delete [] pMenu;
                    pMenu = NULL;
                }
                break;
            }

            if (pMenu)
            {
                delete [] pMenu;
                pMenu = NULL;
            }
        } //end if not separator
    }

    return (MAKELRESULT(nReturn, nCode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\mmenu.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	MMENU.H: Declares custom menu interface for multimedia applet
//
//	Copyright (c) Microsoft Corporation	1998
//    
//	1/28/98 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MMENUHEADER_
#define _MMENUHEADER_

#ifdef __cplusplus
extern "C" {
#endif

class CustomMenu;
class CCustomMenu;

class CustomMenu
{
    public:
        //append a string value
        virtual BOOL AppendMenu(int nMenuID, TCHAR* szMenu) = 0;
        //append a string from your resources
        virtual BOOL AppendMenu(int nMenuID, HINSTANCE hInst, int nStringID) = 0;
        //append a string and an icon from your resources
        virtual BOOL AppendMenu(int nMenuID, HINSTANCE hInst, int nIconID, int nStringID) = 0;
        //append another custom menu, with a resource string
        virtual BOOL AppendMenu(HINSTANCE hInst, int nStringID, CustomMenu* pMenu) = 0;

        virtual BOOL AppendSeparator() = 0;
        virtual BOOL TrackPopupMenu(UINT uFlags, int x, int y, HWND hwnd, CONST RECT* pRect) = 0;
        virtual BOOL SetMenuDefaultItem(UINT uItem, UINT fByPos) = 0;
        virtual void MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pMeasure) = 0;
        virtual void DrawItem(HWND hwnd, LPDRAWITEMSTRUCT pDraw) = 0;
        virtual LRESULT MenuChar(TCHAR tChar, UINT fuFlag, HMENU hMenu) = 0;
        virtual HMENU GetMenuHandle() = 0;
        virtual void Destroy() = 0;
};

class CCustomMenu : CustomMenu
{
    public:
        friend HRESULT AllocCustomMenu(CustomMenu** ppMenu);

        CCustomMenu();

        BOOL AppendMenu(int nMenuID, TCHAR* szMenu);
        BOOL AppendMenu(int nMenuID, HINSTANCE hInst, int nStringID);
        BOOL AppendMenu(int nMenuID, HINSTANCE hInst, int nIconID, int nStringID);
        BOOL AppendMenu(HINSTANCE hInst, int nStringID, CustomMenu* pMenu);
        BOOL AppendSeparator();
        BOOL TrackPopupMenu(UINT uFlags, int x, int y, HWND hwnd, CONST RECT* pRect);
        BOOL SetMenuDefaultItem(UINT uItem, UINT fByPos);
        void MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pMeasure);
        void DrawItem(HWND hwnd, LPDRAWITEMSTRUCT pDraw);
        LRESULT MenuChar(TCHAR tChar, UINT fuFlag, HMENU hMenu);
        HMENU GetMenuHandle() {return m_hMenu;}
        void Destroy();

    protected:
        ~CCustomMenu();
        BOOL IsItemFirst(int nMenuID);
        BOOL IsItemLast(int nMenuID);

    private:
        HMENU m_hMenu;
        HFONT m_hFont;
        HFONT m_hBoldFont;
};

#ifdef __cplusplus
};
#endif //c++

#endif //_MMENUHEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\main.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  MAIN.CPP
//
//      Main window of multimedia framework
//
//      Copyright (c) Microsoft Corporation     1997
//    
//      12/14/97 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <TCHAR.H>
#include "resource.h"
#include "objbase.h"
#include "initguid.h"
#include "sink.h"
#include "dib.h"
#include "resource.h"
#include "mbutton.h"  
#include "knob.h"
#include "winuser.h"
#include "img.h"
#include "frame.h"
#include <htmlhelp.h>
#include "..\cdopt\cdopt.h"
#include "..\cdnet\cdnet.h"
#include "mmenu.h"
#include <stdio.h>
#include "shellico.h"
#include <shellapi.h>
#include "..\cdplay\playres.h"
#include "wininet.h"

//Support for new WM_DEVICECHANGE behaviour in NT5
/////////////////////////////////////////////////
#include <objbase.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <dbt.h>
#include <devguid.h>
#include <mmddkp.h>
#include <ks.h>
#include <ksmedia.h>

HDEVNOTIFY DeviceEventContext = NULL;
BOOL bUseHandle = FALSE; //Indicates whether a handle is being used for device notification,
						 //instead of the general KSCATEGORY_AUDIO

BOOL Volume_DeviceChange_Init(HWND hWnd, DWORD dwMixerID);
void Volume_DeviceChange_Cleanup();
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////


// Next 2 lines added to add multimon support
#define COMPILE_MULTIMON_STUBS
#include "multimon.h"

////////////////////////////////////////////////////////////////////////////////////////////
// #defines for main ui and call-downs to cd player unit

#define IDC_LEDWINDOW                   IDC_LED
#define WM_LED_INFO_PAINT               (WM_USER+2000) //wparam = bool (allow self-draw), lparam = vol info
#define WM_LED_MUTE                     (WM_USER+2001) //wparam = unused, lparam = bool (mute)
#define WM_LED_DOWNLOAD                 (WM_USER+2002) //wparam = unused, lparam = download flag

//command ids from cdplayer
#define ID_CDUPDATE                     IDM_NET_CD

//battery power limit, stated as a percentage
#define BATTERY_PERCENTAGE_LIMIT        10

//helpers for detecting where the mouse is hitting
#define TITLEBAR_HEIGHT                 15
#define TITLEBAR_YOFFSET_LARGE          7
#define TITLEBAR_YOFFSET_SMALL          4
#define SYSMENU_XOFFSET                 7
#define SYSMENU_WIDTH                   12

//volume bar timer stuff
#define VOLUME_PERSIST_TIMER_RATE       2000
#define VOLUME_PERSIST_TIMER_EVENT      1000
#define SYSTIMERID                      1001

//don't remove the parens on these, or My Dear Aunt Sally will getcha
#define IDM_HOMEMENU_BASE               (LAST_SEARCH_MENU_ID + 1)
#define IDM_NETMENU_BASE                (LAST_SEARCH_MENU_ID + 100)
#define IDM_TRACKLIST_BASE              10000
#define IDM_DISCLIST_BASE               20000

#define TYPICAL_DISPLAY_AREA            48  //this value is the offset for large fonts
#define EDGE_CURVE_WIDTH                24
#define EDGE_CURVE_HEIGHT               26

#define VENDORLOGO_WIDTH                44
#define VENDORLOGO_HEIGHT               22
#define LOGO_Y_OFFSET                   10

//if button is re-hit within the time limit, don't allow it to trigger
#define MENU_TIMER_RATE 400

//ie autosearch url
#define REG_KEY_SEARCHURL TEXT("Software\\Microsoft\\Internet Explorer\\SearchUrl")
#define REG_KEY_SHELLSETTINGS REG_KEY_NEW_FRAMEWORK TEXT("\\Settings")
#define REG_KEY_SHELLENABLE TEXT("Tray")
#define PLAYCOMMAND1 TEXT("/play")
#define PLAYCOMMAND2 TEXT("-play")
#define TRAYCOMMAND1 TEXT("/tray")
#define TRAYCOMMAND2 TEXT("-tray")

//////////////////////////////////////////////////////////////////////////////////////
// Gradient stuff

#ifndef SPI_GETGRADIENTCAPTIONS
//from nt50 version of winuser.h
#define SPI_GETGRADIENTCAPTIONS             0x1008
#define COLOR_GRADIENTACTIVECAPTION     27
#define COLOR_GRADIENTINACTIVECAPTION   28
#endif

typedef BOOL (WINAPI *GRADIENTPROC)(HDC,PTRIVERTEX,ULONG,PUSHORT,ULONG,ULONG);


////////////////////////////////////////////////////////////////////////////////////////////
// Main functions in this file, forward-declared
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL LoadComponents(void);
void AddComponent(IMMComponent*);
void CleanUp(void);
void InitComponents(HWND);
BOOL CreateToolTips(HWND);

////////////////////////////////////////////////////////////////////////////////////////////
// Globals to this file

//Component information ... we only have one component now ... 
//this is in here to handle eventual move to multi-component design
PCOMPNODE pCompList = NULL;             //head of component list
PCOMPNODE pCompListTail = NULL;         //tail of component list
PCOMPNODE pNodeCurrent = NULL;          //currently selected component
int nNumComps = 0;                      //number of components
HWND hwndCurrentComp = NULL;            //window handle of current component

HINSTANCE hInst = NULL;                 //global instance of exe
int g_nColorMode = COLOR_VERYHI;        //global containing color mode (hi contract, 16 color, etc)

HWND hwndMain = NULL;                   //main window handle
HWND g_hwndTT = NULL;                   //tooltips
HHOOK g_hhk = NULL;                     //tooltips message hook
TCHAR g_tooltext[MAX_PATH];             //tooltip text holder
HANDLE hbmpMain = NULL;                 //main window bitmap, normal size
HANDLE hbmpMainRestore = NULL;          //main window bitmap, restored size
HANDLE hbmpMainSmall = NULL;            //main window bitmap, small size
HANDLE hbmpMainNoBar = NULL;            //main window bitmap, normal with no title bar
BITMAP bmMain;                          //bitmap metrics for normal size
BITMAP bmMainRestore;                   //bitmap metrics for restored size
BITMAP bmMainSmall;                     //bitmap metrics for small size
BITMAP bmMainNoBar;                     //bitmap metrics for no bar size
HPALETTE hpalMain = NULL;               //Palette of application
BOOL fPlaying = FALSE;                  //Play state of CD for play/pause
BOOL fIntro   = FALSE;                  //Intro mode state
BOOL fShellMode = FALSE;                //are we in shell icon mode?
int nCDMode = IDM_MODE_NORMAL;          //Current mode of CD (starts on normal mode)
int nDispAreaOffset = 0;                //Display area offset for large font mode
CustomMenu* g_pMenu = NULL;             //Pointer to current custom menu
UINT nLastMenu = 0;                      //ID of last button to display a menu
BOOL fBlockMenu = 0;                    //Flag to block menu re-entry
BOOL fOptionsDlgUp = FALSE;             //is options dialog active?
LPCDTITLE pSingleTitle = NULL;            //Disc ID for a direct download from tree control
LPCDOPT g_pOptions = NULL;              //for download callbacks when dialog is up
LPCDDATA g_pData = NULL;                //for callbacks to cd when dialog is up
TCHAR szAppName[MAX_PATH/2];            //IDS_APPNAME "Deluxe CD Player"
DWORD dwLastMixID = (DWORD)-1;          //Last mixer ID
HMIXEROBJ hmix = NULL;                  //current open mixer handle
TCHAR szLineName[MIXER_LONG_NAME_CHARS];//current volume line name
MIXERCONTROLDETAILS mixerlinedetails;   //current volume details
MIXERCONTROLDETAILS mutelinedetails;    //current mute details
DWORD mixervalue[2];                    //current volume level
LONG lCachedBalance = 0;                //last balance level
BOOL fmutevalue;                        //current mute value
HANDLE hMutex = NULL;                   //hMutex to prevent multiple instances of EXE
int  g_nViewMode = VIEW_MODE_NORMAL;    //view mode setting (default to normal)
WORD wDefButtonID = IDB_OPTIONS;         //default button
HCURSOR hCursorMute = NULL;             //mute button cursor
HMODULE hmImage = NULL;                 //module handle of dll with gradient function
GRADIENTPROC fnGradient = NULL;         //gradient function
UINT g_uTaskbarRestart = 0;             //registered message for taskbar re-creation
UINT giVolDevChange = 0;                //registered message for mmsystem device change

#ifdef UNICODE
#define CANONFUNCTION "InternetCanonicalizeUrlW"
#else
#define CANONFUNCTION "InternetCanonicalizeUrlA"
#endif

////////////////////////////////////////////////////////////////////////////////////////////
// Structures and defines for custom button controls
#define NUM_BUTTONS 16
typedef struct BUTTONINFO
{
    int     id;             //id of control
    POINT   uixy;           //x, y location on screen
    POINT   uixy2;          //x, y location when restored or small
    int     width;          //width of control in bitmap and on screen
    int     height;         //height of control in bitmap and on screen
    int     width2;         //width of control on screen when restored
    int     nIconID;        //id of icon, if any
    int     nToolTipID;     //id of tooltip string
    BOOL    fBlockTab;      //true = don't tab stop here
    DWORD   dwStyle;        //style for toolkit, see mbutton.h
} BUTTONINFO, *LPBUTTONINFO;
BUTTONINFO biButtons[NUM_BUTTONS];

////////////////////////////////////////////////////////////////////////////////////////////
// * GetSettings
// Reads the x and y positions of app for startup
// Also gets the view mode
////////////////////////////////////////////////////////////////////////////////////////////
void GetSettings(int& x, int& y)
{
    x = CW_USEDEFAULT;
    y = CW_USEDEFAULT;
    g_nViewMode = VIEW_MODE_NORMAL;

    LPCDOPT pOpt = GetCDOpt();

    if( pOpt )
    {
        LPCDOPTIONS pOptions = pOpt->GetCDOpts();
        LPCDOPTDATA pOptionData = pOptions->pCDData;

        x = pOptionData->dwWindowX;
        y = pOptionData->dwWindowY;
        g_nViewMode = pOptionData->dwViewMode;
        nCDMode = pOptionData->dwPlayMode;
        if (nCDMode < IDM_MODE_NORMAL)
        {
            nCDMode = IDM_MODE_NORMAL;
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetSettings
// Sets X, Y and view mode of app on shutdown
////////////////////////////////////////////////////////////////////////////////////////////
void SetSettings(int x, int y)
{
    LPCDOPT pOpt = GetCDOpt();

    if(pOpt)
    {
        LPCDOPTIONS pOptions = pOpt->GetCDOpts();
        LPCDOPTDATA pOptionData = pOptions->pCDData;

        pOptionData->dwWindowX = x;
        pOptionData->dwWindowY = y;
        pOptionData->dwViewMode = g_nViewMode;
        pOptionData->dwPlayMode = nCDMode;

        pOpt->UpdateRegistry();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetXOffset
// Returns 0 normally, or size of a single border if captions are turned on
////////////////////////////////////////////////////////////////////////////////////////////
int GetXOffset()
{
    #ifndef MMFW_USE_CAPTION
    return 0;
    #else
    return GetSystemMetrics(SM_CXFIXEDFRAME);
    #endif
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetYOffset
// Returns 0 normally, or size of a single border if captions are turned on
////////////////////////////////////////////////////////////////////////////////////////////
int GetYOffset()
{
    #ifndef MMFW_USE_CAPTION
    return 0;
    #else
    return GetSystemMetrics(SM_CYFIXEDFRAME);
    #endif
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetYOffsetCaption
// Returns 0 normally, or size of a caption if captions are turned on
////////////////////////////////////////////////////////////////////////////////////////////
int GetYOffsetCaption()
{
    #ifndef MMFW_USE_CAPTION
    return 0;
    #else
    return GetSystemMetrics(SM_CYCAPTION);
    #endif
}

////////////////////////////////////////////////////////////////////////////////////////////
// * DetermineColorMode
// Sets the g_nColorMode variable for use in creating the bumps for the app
////////////////////////////////////////////////////////////////////////////////////////////
void DetermineColorMode()
{
    g_nColorMode = COLOR_VERYHI;

    HDC hdcScreen = GetDC(NULL);
    UINT uBPP = GetDeviceCaps(hdcScreen, PLANES) * GetDeviceCaps(hdcScreen, BITSPIXEL);
    ReleaseDC(NULL, hdcScreen);

    switch (uBPP)
    {
        case 8 :
        {
            g_nColorMode = COLOR_256;
        }
        break;

        case 4 : 
        {
            g_nColorMode = COLOR_16;
        }
        break;

        case 2 :
        {
            g_nColorMode = COLOR_HICONTRAST; 
        }
        break;
    }

    //check directly for accessibility mode
    HIGHCONTRAST hi_con;
    ZeroMemory(&hi_con,sizeof(hi_con));
    hi_con.cbSize = sizeof(hi_con);

    SystemParametersInfo(SPI_GETHIGHCONTRAST,sizeof(hi_con),&hi_con,0);

    if (hi_con.dwFlags &  HCF_HIGHCONTRASTON)
    {
        g_nColorMode = COLOR_HICONTRAST;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetPalette
// Sets the palette for the app, generated from all bitmaps in the application and DLLs
////////////////////////////////////////////////////////////////////////////////////////////
HPALETTE SetPalette()
{
    #define NUMPALCOLORS 94

BYTE byVals[NUMPALCOLORS][3] = {
	      6,   6,   6,
	     18,  19,  45,
	     25,  40,   1,
	     17,  46,  46,
	     49,   7,   7,
	     45,  52,   3,
	     49,  49,  49,
	     24,  24,  91,
	      0,  90,   8,
	      1, 108,   5,
	     55,  67,   2,
	     33,  76,  76,
	     94,  29,  24,
	    102,  18, 102,
	     93,  94,  23,
	     78,  78,  78,
	     84,  84, 108,
	     78, 111, 111,
	    109,  80,  80,
	    108, 107,  79,
	    120, 120, 120,
	     15,   9, 157,
	     17,   8, 246,
	     55,  93, 175,
	     20,  91, 231,
	     83,  39, 167,
	     92,  16, 223,
	     96,  94, 150,
	     88,  87, 217,
	      0, 157,  15,
	      0, 153,  51,
	      0, 190,  18,
	     10, 155, 120,
	      6, 252,  17,
	      9, 236,  92,
	    127, 135,  35,
	     83, 142, 117,
	     92, 241,  21,
	     87, 223,  81,
	     14, 171, 171,
	     39, 147, 223,
	     18, 252, 157,
	     15, 244, 236,
	     87, 137, 136,
	     80, 184, 184,
	    112, 141, 141,
	    106, 170, 153,
	    119, 171, 168,
	     87, 155, 213,
	    101, 218, 170,
	     90, 233, 226,
	    154,  19,  24,
	    155,  26, 109,
	    138, 116,   8,
	    170,  98, 101,
	    243,  18,   6,
	    245,  10,  96,
	    233,  89,  17,
	    229, 103, 101,
	    154,  39, 161,
	    163,  26, 249,
	    158,  77, 159,
	    149,  94, 254,
	    234,  20, 160,
	    234,  29, 242,
	    233,  76, 163,
	    218,  81, 244,
	    163, 151,  10,
	    157, 156, 102,
	    164, 214,  45,
	    165, 242,  87,
	    223, 174,  17,
	    228, 160,  77,
	    242, 232,  15,
	    233, 218, 102,
	    138, 138, 138,
	    142, 141, 176,
	    148, 180, 180,
	    174, 141, 140,
	    169, 130, 168,
	    181, 179, 136,
	    176, 176, 177,
	    172, 170, 220,
	    133, 207, 177,
	    171, 236, 233,
	    231, 169, 157,
	    252, 170, 253,
	    247, 243, 168,
	    202, 204, 204,
	    201, 201, 243,
	    208, 238, 238,
	    246, 212, 212,
	    248, 244, 198,
	    250, 250, 250
    };

    struct
    {
	    LOGPALETTE lp;
	    PALETTEENTRY ape[NUMPALCOLORS-1];
    } pal;

    LOGPALETTE* pLP = (LOGPALETTE*)&pal;
    pLP->palVersion = 0x300;
    pLP->palNumEntries = NUMPALCOLORS;

    for (int i = 0; i < pLP->palNumEntries; i++)
    {
	    pLP->palPalEntry[i].peRed = byVals[i][0];
	    pLP->palPalEntry[i].peGreen = byVals[i][1];
	    pLP->palPalEntry[i].peBlue = byVals[i][2];
	    pLP->palPalEntry[i].peFlags = 0;
    }

    return (CreatePalette(pLP));
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetCurrentCDDrive
// returns the drive number of the cd that is currently selected in the cdplayer ui
////////////////////////////////////////////////////////////////////////////////////////////
int GetCurrentCDDrive()
{
	IMMComponentAutomation* pAuto = NULL;
	HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	if ((SUCCEEDED(hr)) && (pAuto != NULL))
	{
        MMMEDIAID mmMedia;
        mmMedia.nDrive = -1;
        pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
        pAuto->Release();
        return (mmMedia.nDrive);
    }

    return -1;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * InitCDVol
// Sets up the mixer structures for the current cd drive
////////////////////////////////////////////////////////////////////////////////////////////
BOOL InitCDVol(HWND hwndCallback, LPCDOPTIONS pCDOpts)
{
    //figure out which drive we're on
    int nDrive = GetCurrentCDDrive();

    //return if the drive is bogus
    if (nDrive < 0)
    {
        return FALSE;
    }

    //get the cdunit info from the options
    CDUNIT* pCDUnit = pCDOpts->pCDUnitList;
    
    //scan the list to find the one we want
    for (int index = 0; index < nDrive; index++)
    {
        pCDUnit = pCDUnit->pNext;
    }
    
    //check to see if we already have an open mixer
    if (hmix!=NULL)
    {
        //we've been here before ... may not need to be here now,
        //if both the mixer id and the control id are the same
        if ((dwLastMixID == pCDUnit->dwMixID) &&
            (mixerlinedetails.dwControlID == pCDUnit->dwVolID))
        {
            return FALSE;
        }

        //a change is coming, go ahead and close this mixer
        mixerClose((HMIXER)hmix);
    }

    //remember our last mixer id
    dwLastMixID = pCDUnit->dwMixID;

    //open the mixer
    mixerOpen((HMIXER*)(&hmix),pCDUnit->dwMixID,(DWORD_PTR)hwndCallback,0,CALLBACK_WINDOW|MIXER_OBJECTF_MIXER);
	
	Volume_DeviceChange_Init(hwndCallback, pCDUnit->dwMixID);
	
	MIXERLINE           mlDst;
	MMRESULT            mmr;
	int					newDest;
    
    ZeroMemory(&mlDst, sizeof(mlDst));
    
    mlDst.cbStruct      = sizeof(mlDst);
    mlDst.dwDestination = pCDUnit->dwMixID;
    
    mmr = mixerGetLineInfo((HMIXEROBJ)hmix
                           , &mlDst
                           , MIXER_GETLINEINFOF_DESTINATION);

    //save the details of the volume line
    mixerlinedetails.cbStruct = sizeof(mixerlinedetails);
    mixerlinedetails.dwControlID = pCDUnit->dwVolID;
    mixerlinedetails.cChannels = mlDst.cChannels;
    mixerlinedetails.hwndOwner = 0;
    mixerlinedetails.cMultipleItems = 0;
    mixerlinedetails.cbDetails = sizeof(mixervalue);
    mixerlinedetails.paDetails = &mixervalue[0];
                    
    //save the details of the mute line
    mutelinedetails.cbStruct = sizeof(mutelinedetails);
    mutelinedetails.dwControlID = pCDUnit->dwMuteID;
    mutelinedetails.cChannels = 1;
    mutelinedetails.hwndOwner = 0;
    mutelinedetails.cMultipleItems = 0;
    mutelinedetails.cbDetails = sizeof(fmutevalue);
    mutelinedetails.paDetails = &fmutevalue;

    //save the name of the volume line
    _tcscpy(szLineName,pCDUnit->szVolName);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetVolume
////////////////////////////////////////////////////////////////////////////////////////////
DWORD GetVolume()
{
    //get the value of this mixer control line
    ZeroMemory(mixervalue,sizeof(DWORD)*2);
    mixerGetControlDetails(hmix,&mixerlinedetails,MIXER_GETCONTROLDETAILSF_VALUE);
    return ((mixervalue[0] > mixervalue[1]) ? mixervalue[0] : mixervalue[1]);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetVolume
////////////////////////////////////////////////////////////////////////////////////////////
void SetVolume(DWORD dwVol)
{
    LONG        lBalance = 0;

    //if this is a stereo device, we need to check the balance
    if (mixerlinedetails.cChannels > 1)
    {
        ZeroMemory(mixervalue,sizeof(DWORD)*2);
        mixerGetControlDetails(hmix,&mixerlinedetails,MIXER_GETCONTROLDETAILSF_VALUE);

        LONG lDiv =  (LONG)(max(mixervalue[0], mixervalue[1]) - 0);

        //
        // if we're pegged, don't try to calculate the balance.
        //
        if (mixervalue[0] == 0 && mixervalue[1] == 0)
            lBalance = lCachedBalance;
        else if (mixervalue[0] == 0)
            lBalance = 32;
        else if (mixervalue[1] == 0) 
            lBalance = -32;
        else if (lDiv > 0)
        {
            lBalance = (32 * ((LONG)mixervalue[1]-(LONG)mixervalue[0]))
                       / lDiv;
            //
            // we always lose precision doing this.
            //
            if (lBalance > 0) lBalance++;
            if (lBalance < 0) lBalance--;

            //if we lost precision above, we can get it back by checking
            //the previous value of our balance.  We're usually only off by
            //one if this is the result of a rounding error.  Otherwise,
            //we probably have a different balance because the user set it.
            if (((lCachedBalance - lBalance) == 1) ||
                ((lCachedBalance - lBalance) == -1))
            {
                lBalance = lCachedBalance;
            }
        
        }
        else
            lBalance = 0;
    }

    //save this balance setting so we can use it if we're pegged later
    lCachedBalance = lBalance;

    //
    // Recalc channels based on Balance vs. Volume
    //
    mixervalue[0] = dwVol;
    mixervalue[1] = dwVol;
                   
    if (lBalance > 0)
        mixervalue[0] -= (lBalance * (LONG)(mixervalue[1]-0))
                        / 32;
    else if (lBalance < 0)
        mixervalue[1] -= (-lBalance * (LONG)(mixervalue[0]-0))
                        / 32;

    mixerSetControlDetails(hmix,&mixerlinedetails,MIXER_SETCONTROLDETAILSF_VALUE);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetMute
////////////////////////////////////////////////////////////////////////////////////////////
BOOL GetMute()
{
    if (mutelinedetails.dwControlID != DWORD(-1))
    {
        mixerGetControlDetails(hmix,&mutelinedetails,MIXER_GETCONTROLDETAILSF_VALUE);
    }
    else
    {
        //mixer line doesn't exist, assume not muted
        fmutevalue = FALSE;
    }

    return (fmutevalue);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetMute
// Implemented as a toggle from current state
////////////////////////////////////////////////////////////////////////////////////////////
void SetMute()
{
    if (mutelinedetails.dwControlID != DWORD(-1))
    {
        if (GetMute())
        {
            //muted, so unmute
            fmutevalue = FALSE;
            mixerSetControlDetails(hmix,&mutelinedetails,MIXER_SETCONTROLDETAILSF_VALUE);
        }
        else
        {
            //not muted, so mute
            fmutevalue = TRUE;
            MMRESULT mmr = mixerSetControlDetails(hmix,&mutelinedetails,MIXER_SETCONTROLDETAILSF_VALUE);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CanStartShell()
// Checks to see if we can launch if wanting to do so in shell mode
// Returns FALSE only if asking for "tray mode" and if reg setting is FALSE (or not present)
////////////////////////////////////////////////////////////////////////////////////////////
BOOL CanStartShell()
{
    BOOL retval = TRUE; //default to allowing launch
    fShellMode = FALSE;

    //if asking for permission to launch try, see if the registry setting is there
    HKEY hKeySettings;
	long lResult = ::RegOpenKeyEx( HKEY_CURRENT_USER,
							  REG_KEY_SHELLSETTINGS,
							  0, KEY_READ, &hKeySettings );

    if (lResult == ERROR_SUCCESS)
    {
        DWORD fEnable = FALSE;
        DWORD dwType = REG_DWORD;
        DWORD dwCbData = sizeof(fEnable);
        lResult  = ::RegQueryValueEx( hKeySettings, REG_KEY_SHELLENABLE, NULL,
						          &dwType, (LPBYTE)&fEnable, &dwCbData );

        if (fEnable)
        {
            fShellMode = TRUE;
        }

        RegCloseKey(hKeySettings);

        //check for the query on the command line
        TCHAR szCommand[MAX_PATH];
    
        _tcscpy(szCommand,GetCommandLine());
        _tcslwr(szCommand);
        if ((_tcsstr(szCommand,TRAYCOMMAND1) != NULL)
            ||
            (_tcsstr(szCommand,TRAYCOMMAND2) != NULL))
        {
            //user wants to check try status ... base on fenable
            retval = (BOOL)fEnable;
        }
    } //end if regkey

    return (retval);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * ShellOnly()
// Returns TRUE if we should not make the main UI visible.
////////////////////////////////////////////////////////////////////////////////////////////
BOOL ShellOnly()
{
    BOOL retval = FALSE;

    if (fShellMode)
    {
        //check for the query on the command line
        TCHAR szCommand[MAX_PATH];
    
        _tcscpy(szCommand,GetCommandLine());
        _tcslwr(szCommand);
        if ((_tcsstr(szCommand,TRAYCOMMAND1) != NULL)
            ||
            (_tcsstr(szCommand,TRAYCOMMAND2) != NULL))
        {
            retval = TRUE;
        }
    }

    return (retval);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * IsOnlyInstance 
// Check to see if this is the only instance, based on the webcd mutex
////////////////////////////////////////////////////////////////////////////////////////////
BOOL IsOnlyInstance()
{
    hMutex = CreateMutex(NULL,TRUE,WEBCD_MUTEX);
    if (GetLastError()==ERROR_ALREADY_EXISTS)
    {
        if (hMutex!=NULL)
        {
            ReleaseMutex(hMutex);
            CloseHandle(hMutex);
            hMutex = NULL;
        }

        //send the command line to the app that is already running
        HWND hwndFind = FindWindow(FRAMEWORK_CLASS, NULL);

        if (hwndFind)
        {
            //we only want to do this if NOT "autoplayed" ... that is, if /play is on the
            //command line, don't refocus us ... see bug 1244
            //(the old cdplayer implements it this way, too!)
            TCHAR szCommand[MAX_PATH];
            
            _tcscpy(szCommand,GetCommandLine());
            _tcslwr(szCommand);
            if ((_tcsstr(szCommand,PLAYCOMMAND1) == NULL)
                &&
                (_tcsstr(szCommand,PLAYCOMMAND2) == NULL))
            {
                //get the most recent "child" window
                hwndFind = GetLastActivePopup(hwndFind);

                //bring the window up if it is iconic
                if (IsIconic(hwndFind))
                {
                    ShowWindow(hwndFind,SW_RESTORE);
                }

                //display the window
                ShowWindow(hwndFind,SW_SHOW); //this "wakes up" if in shell mode in other inst.
		        BringWindowToTop(hwndFind);
		        SetForegroundWindow(hwndFind);
            }

            //forward the command line found to the second instance,
            //only if it is NOT an "autoplay" message -- we'll  scan that instead
            TCHAR tempCmdLine[MAX_PATH];
            _tcscpy(tempCmdLine,GetCommandLine());
            if (_tcslen(tempCmdLine) > 0)
            {
                if (tempCmdLine[_tcslen(tempCmdLine)-1] != TEXT('\\'))
                {
                    COPYDATASTRUCT  cpds;
	                cpds.dwData = 0L;
	                cpds.cbData = (_tcslen(GetCommandLine()) + 1) * sizeof(TCHAR);
	                cpds.lpData = LocalAlloc(LPTR,cpds.cbData);
	                if (cpds.lpData == NULL) {
	                    // Error - not enough memory to continue
	                    return (FALSE);
	                }

	                _tcscpy((LPTSTR)cpds.lpData, GetCommandLine());

	                SendMessage(hwndFind, WM_COPYDATA, 0, (LPARAM)(LPVOID)&cpds);
	                LocalFree((HLOCAL)cpds.lpData);
                } //end if not autoplay command line
            } //end if non-0 command line

        } //end if found other window

        return (FALSE);
    }

    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CalculateDispAreaOffset 
// Figures out how big the display area should be if we're not in standard font mode
////////////////////////////////////////////////////////////////////////////////////////////
void CalculateDispAreaOffset(IMMComponent* pComp)
{
    if (!pComp)
    {
        return;
    }
    
    MMCOMPDATA mmComp;
    mmComp.dwSize = sizeof(mmComp);
    pComp->GetInfo(&mmComp);

    //mmComp.rect (height) contains the min height of the display area on this monitor
    //for the largest view ... other views seem to be OK with different font settings

    //calculate how big the view must be compared to its normal min size
     nDispAreaOffset = (mmComp.rect.bottom - mmComp.rect.top) - TYPICAL_DISPLAY_AREA;

     //don't let the display area shrink, only grow
     if (nDispAreaOffset < 0)
     {
        nDispAreaOffset = 0;
     }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * BuildFrameworkBitmaps 
// Creates the bitmaps for normal, restored, and small sizes
////////////////////////////////////////////////////////////////////////////////////////////
BOOL BuildFrameworkBitmaps()
{
    POINT ptSys = {SYSMENU_XOFFSET,TITLEBAR_YOFFSET_LARGE};
    RECT rectMain = {0,0,480,150};
    RECT rectView = {10,25,472,98};
    RECT rectSeps[2] = {93,97,95,146,302,97,304,146};
    
    rectView.bottom += nDispAreaOffset;
    rectMain.bottom += nDispAreaOffset;

    for (UINT i = 0; i < sizeof(rectSeps) / sizeof(RECT); i++)
    {
        rectSeps[i].top += nDispAreaOffset;
        rectSeps[i].bottom += nDispAreaOffset;
    }

    HDC hdcMain = GetDC(hwndMain);
    hbmpMain = BuildFrameBitmap(hdcMain,&rectMain,&rectView,VIEW_MODE_NORMAL,&ptSys,rectSeps,2,&bmMain);

    //"no title bar" mode
    ptSys.x = SYSMENU_XOFFSET;
    ptSys.y = TITLEBAR_YOFFSET_LARGE;
    SetRect(&rectMain,0,0,480,134);
    SetRect(&rectView,10,9,472,82);
    SetRect(&rectSeps[0],93,81,95,130);
    SetRect(&rectSeps[1],302,81,304,130);
    hbmpMainNoBar = BuildFrameBitmap(hdcMain,&rectMain,&rectView,VIEW_MODE_NOBAR,&ptSys,rectSeps,2,&bmMainNoBar);

    //"restored" mode
    ptSys.x = SYSMENU_XOFFSET;
    ptSys.y = TITLEBAR_YOFFSET_SMALL;
    SetRect(&rectMain,0,0,393,50);
    SetRect(&rectView,301,21,386,43);
    SetRect(&rectSeps[0],92,25,101,38);
    SetRect(&rectSeps[1],211,25,220,38);
    hbmpMainRestore = BuildFrameBitmap(hdcMain,&rectMain,&rectView,VIEW_MODE_RESTORE,&ptSys,rectSeps,2,&bmMainRestore);

    //"very small" mode, no title bar
    SetRect(&rectMain,0,0,393,38);
    SetRect(&rectView,301,9,386,30);
    SetRect(&rectSeps[0],92,13,101,26);
    SetRect(&rectSeps[1],211,13,220,26);
    hbmpMainSmall = BuildFrameBitmap(hdcMain,&rectMain,&rectView,VIEW_MODE_SMALL,&ptSys,rectSeps,2,&bmMainSmall);

    ReleaseDC(hwndMain,hdcMain);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetCurvedEdges
// Changes clipping region of an HWND to have curved corners
////////////////////////////////////////////////////////////////////////////////////////////
void SetCurvedEdges(HWND hwnd)
{
    RECT rect;
    GetWindowRect(hwnd,&rect);

    //set the rect to "client" coordinates
    rect.bottom = rect.bottom - rect.top;
    rect.right = rect.right - rect.left;
    rect.top = 0;
    rect.left = 0;
    
    HRGN region = CreateRoundRectRgn(GetXOffset(),
                                     GetYOffsetCaption() + GetYOffset(),
                                     (rect.right - GetXOffset())+1,
                                     (rect.bottom - GetYOffset())+1,
                                     EDGE_CURVE_WIDTH,
                                     EDGE_CURVE_HEIGHT);

    SetWindowRgn(hwnd,region,TRUE);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetNoBarMode(HWND hwnd)
// Changes the view mode to have no title bar
////////////////////////////////////////////////////////////////////////////////////////////
void SetNoBarMode(HWND hwnd)
{
    g_nViewMode = VIEW_MODE_NOBAR;

    HDWP hdwp = BeginDeferWindowPos(NUM_BUTTONS+3);

    //move/size/hide buttons
    for (int i = 0; i < NUM_BUTTONS; i++)
    {
		hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,biButtons[i].id),hwnd,
			 biButtons[i].uixy.x,
			 biButtons[i].uixy.y - (bmMain.bmHeight - bmMainNoBar.bmHeight),
			 biButtons[i].width,
			 biButtons[i].height,
			 SWP_NOACTIVATE|SWP_NOZORDER);

        if (biButtons[i].dwStyle == MBS_SYSTEMTYPE)
        {
            ShowWindow(GetDlgItem(hwnd,biButtons[i].id),SW_HIDE); 
        }
    }

    //move volume and mute
	hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,IDB_VOLUME),hwnd,
		 403,
		 (93+nDispAreaOffset) - (bmMain.bmHeight - bmMainNoBar.bmHeight),
		 45,
		 45,
		 SWP_NOACTIVATE|SWP_NOZORDER);

	hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,IDB_MUTE),hwnd,
		 450,
		 (122+nDispAreaOffset) - (bmMain.bmHeight - bmMainNoBar.bmHeight),
		 13,
		 13,
		 SWP_NOACTIVATE|SWP_NOZORDER);

    //move display screen
    hdwp = DeferWindowPos(hdwp,hwndCurrentComp,hwnd,24,32-(bmMain.bmHeight - bmMainNoBar.bmHeight),431,56+nDispAreaOffset,SWP_NOACTIVATE|SWP_NOZORDER);
    InvalidateRect(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),NULL,TRUE);

    //size main window
    int sx = GetXOffset()*2;
    int sy = (GetYOffset()*2) + GetYOffsetCaption();
    SetWindowPos(hwnd,NULL,0,0,
	     bmMainNoBar.bmWidth+sx,
	     bmMainNoBar.bmHeight+sy,
	     SWP_NOMOVE|SWP_NOZORDER);

    SetCurvedEdges(hwnd);

    InvalidateRect(hwnd,NULL,TRUE);
    EndDeferWindowPos(hdwp);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetRestoredMode
// Changes the view mode to restored
////////////////////////////////////////////////////////////////////////////////////////////
void SetRestoredMode(HWND hwnd)
{
    if (g_nViewMode == VIEW_MODE_NORMAL)
    {
        //pre-blit the new button sizes
        CMButton* pButton;
        pButton = GetMButtonFromID(hwnd,IDB_PLAY);
        pButton->PreDrawUpstate(biButtons[2].width2,biButtons[2].height);
        pButton = GetMButtonFromID(hwnd,IDB_STOP);
        pButton->PreDrawUpstate(biButtons[3].width2,biButtons[3].height);
        pButton = GetMButtonFromID(hwnd,IDB_EJECT);
        pButton->PreDrawUpstate(biButtons[4].width2,biButtons[4].height);
        pButton = GetMButtonFromID(hwnd,IDB_TRACK);
        pButton->PreDrawUpstate(biButtons[10].width2,biButtons[10].height);
    }

    g_nViewMode = VIEW_MODE_RESTORE;

    HDWP hdwp = BeginDeferWindowPos(NUM_BUTTONS+2);

    //move/size/hide buttons
    for (int i = 0; i < NUM_BUTTONS; i++)
    {
	    if (biButtons[i].uixy2.x != 0)
	    {
		    hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,biButtons[i].id),hwnd,
			     biButtons[i].uixy2.x,
			     biButtons[i].uixy2.y,
			     biButtons[i].width2,
			     biButtons[i].height,
			     SWP_NOACTIVATE|SWP_NOZORDER);
	    }
        else
        {
            ShowWindow(GetDlgItem(hwnd,biButtons[i].id),SW_HIDE); //prevents tabbing
        }

        if (biButtons[i].dwStyle == MBS_SYSTEMTYPE)
        {
            ShowWindow(GetDlgItem(hwnd,biButtons[i].id),SW_SHOW); 
        }
    }

    //move display screen
    hdwp = DeferWindowPos(hdwp,hwndCurrentComp,hwnd,303,24,81,17,SWP_NOACTIVATE|SWP_NOZORDER);
    InvalidateRect(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),NULL,TRUE);

    //size main window
    int sx = GetXOffset()*2;
    int sy = (GetYOffset()*2) + GetYOffsetCaption();
    SetWindowPos(hwnd,NULL,0,0,
	     bmMainRestore.bmWidth+sx,
	     bmMainRestore.bmHeight+sy,
	     SWP_NOMOVE|SWP_NOZORDER);

    ShowWindow(GetDlgItem(hwnd,IDB_VOLUME),SW_HIDE);
    ShowWindow(GetDlgItem(hwnd,IDB_MUTE),SW_HIDE);
    ShowWindow(GetDlgItem(hwnd,IDB_SET_NORMAL_MODE),SW_SHOW);
    ShowWindow(GetDlgItem(hwnd,IDB_SET_TINY_MODE),SW_HIDE);

    SetCurvedEdges(hwnd);

    InvalidateRect(hwnd,NULL,TRUE);
    EndDeferWindowPos(hdwp);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetNormalMode
// Changes the view mode to normal
////////////////////////////////////////////////////////////////////////////////////////////
void SetNormalMode(HWND hwnd)
{
    //going from restore to max
    g_nViewMode = VIEW_MODE_NORMAL;

    //pre-blit the new button sizes
    CMButton* pButton;
    pButton = GetMButtonFromID(hwnd,IDB_PLAY);
    pButton->PreDrawUpstate(biButtons[2].width,biButtons[2].height);
    pButton = GetMButtonFromID(hwnd,IDB_STOP);
    pButton->PreDrawUpstate(biButtons[3].width,biButtons[3].height);
    pButton = GetMButtonFromID(hwnd,IDB_EJECT);
    pButton->PreDrawUpstate(biButtons[4].width,biButtons[4].height);
    pButton = GetMButtonFromID(hwnd,IDB_TRACK);
    pButton->PreDrawUpstate(biButtons[10].width,biButtons[10].height);

    HDWP hdwp = BeginDeferWindowPos(NUM_BUTTONS+3);

    //move/size/show buttons
    for (int i = 0; i < NUM_BUTTONS; i++)
    {
        ShowWindow(GetDlgItem(hwnd,biButtons[i].id),SW_SHOW);
        hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,biButtons[i].id),hwnd,
			          biButtons[i].uixy.x,
			          biButtons[i].uixy.y,
			          biButtons[i].width,
			          biButtons[i].height,
			          SWP_NOACTIVATE|SWP_NOZORDER);
    }

    //move volume and mute
	hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,IDB_VOLUME),hwnd,
		 403,
		 93+nDispAreaOffset,
		 45,
		 45,
		 SWP_NOACTIVATE|SWP_NOZORDER);

	hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,IDB_MUTE),hwnd,
		 450,
		 122+nDispAreaOffset,
		 13,
		 13,
		 SWP_NOACTIVATE|SWP_NOZORDER);

    //move display screen
    hdwp = DeferWindowPos(hdwp,hwndCurrentComp,hwnd,24,32,431,56+nDispAreaOffset,SWP_NOACTIVATE|SWP_NOZORDER);
    InvalidateRect(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),NULL,TRUE);

    ShowWindow(GetDlgItem(hwnd,IDB_VOLUME),SW_SHOW);
    ShowWindow(GetDlgItem(hwnd,IDB_MUTE),SW_SHOW);
    ShowWindow(GetDlgItem(hwnd,IDB_SET_NORMAL_MODE),SW_HIDE);
    ShowWindow(GetDlgItem(hwnd,IDB_SET_TINY_MODE),SW_SHOW);

    //Resize window
    int sx = GetXOffset()*2;
    int sy = (GetYOffset()*2) + GetYOffsetCaption();
    SetWindowPos(hwnd,NULL,0,0,
	     bmMain.bmWidth+sx,
	     bmMain.bmHeight+sy,
	     SWP_NOMOVE|SWP_NOZORDER);

    SetCurvedEdges(hwnd);

    InvalidateRect(hwnd,NULL,TRUE);
    EndDeferWindowPos(hdwp);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetSmallMode
// Changes the view mode to small
////////////////////////////////////////////////////////////////////////////////////////////
void SetSmallMode(HWND hwnd)
{
    g_nViewMode = VIEW_MODE_SMALL;

    HDWP hdwp = BeginDeferWindowPos(NUM_BUTTONS+2);

    //move/size/hide buttons
    for (int i = 0; i < NUM_BUTTONS; i++)
    {
	    if (biButtons[i].uixy2.x != 0)
	    {
		    hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,biButtons[i].id),hwnd,
			     biButtons[i].uixy2.x,
			     biButtons[i].uixy2.y - (bmMainRestore.bmHeight - bmMainSmall.bmHeight),
			     biButtons[i].width2,
			     biButtons[i].height,
			     SWP_NOACTIVATE|SWP_NOZORDER);
	    }

        if (biButtons[i].dwStyle == MBS_SYSTEMTYPE)
        {
            ShowWindow(GetDlgItem(hwnd,biButtons[i].id),SW_HIDE); 
        }
    }

    //move display screen
    hdwp = DeferWindowPos(hdwp,hwndCurrentComp,hwnd,303,24-(bmMainRestore.bmHeight - bmMainSmall.bmHeight),81,17,SWP_NOACTIVATE|SWP_NOZORDER);
    InvalidateRect(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),NULL,TRUE);

    //size main window
    int sx = GetXOffset()*2;
    int sy = (GetYOffset()*2) + GetYOffsetCaption();
    SetWindowPos(hwnd,NULL,0,0,
	     bmMainSmall.bmWidth+sx,
	     bmMainSmall.bmHeight+sy,
	     SWP_NOMOVE|SWP_NOZORDER);

    SetCurvedEdges(hwnd);

    InvalidateRect(hwnd,NULL,TRUE);
    EndDeferWindowPos(hdwp);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * AdjustForMultimon
// Will move the app onto the primary display if its x,y settings are not on a monitor
////////////////////////////////////////////////////////////////////////////////////////////
void AdjustForMultimon(HWND hwnd)
{
    RECT rect;
    GetWindowRect(hwnd,&rect);

    int cxWnd = rect.right - rect.left;
    int cyWnd = rect.bottom - rect.top;

	// Check if the app's rect is visible is any of the monitors
	if( NULL == MonitorFromRect( &rect, 0L ) )
	{
		//The window is not visible. Let's center it in the primary monitor.
		//Note: the window could be in this state if (1) the display mode was changed from 
		//a high-resolution to a lower resolution, with the cdplayer in the corner. Or,
		//(2) the multi-mon configuration was rearranged.

		RECT rcDesktop;

        GetWindowRect( GetDesktopWindow(), &rcDesktop );
		int cxDesktop = (rcDesktop.right - rcDesktop.left);
		int cyDesktop = (rcDesktop.bottom - rcDesktop.top);

		int x = (cxDesktop - cxWnd) / 2; //center in x
		int y = (cyDesktop - cyWnd) / 3; //and a little towards the top

        SetWindowPos(hwnd,NULL,x,y,0,0,SWP_NOSIZE|SWP_NOZORDER);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////
// * WinMain
// Entry point for application
////////////////////////////////////////////////////////////////////////////////////////////
int WINAPI WinMain(HINSTANCE hInstEXE, HINSTANCE hInstEXEPrev, PSTR lpszCmdLine, int nCmdShow)
{
    //first thing, must check tray icon state
    if (!CanStartShell())
    {
        return (0);
    }
        
    if (!IsOnlyInstance())
    {
        //can't have more than one of these
        return (0);
    }
    
    //save the global hinstance
    hInst = hInstEXE;

    DetermineColorMode();
    
    //start our linked list of components
    pCompList = new COMPNODE;
    ZeroMemory(pCompList,sizeof(COMPNODE));
    pCompListTail = pCompList;

    //load the app name
    LoadString(hInstEXE,IDS_APPNAME,szAppName,sizeof(szAppName)/sizeof(TCHAR));

    //init the networking component (this just inits some crit sections)
    CDNET_Init(hInstEXE);

    //load components from registry
    if (!LoadComponents())
    {
	    CleanUp();
	    return (0);
    }
    
    //register our main window class  
    WNDCLASSEX wc;
    ATOM atomClassName;
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(wc);
    wc.lpszClassName = FRAMEWORK_CLASS;
    wc.lpfnWndProc = MainWndProc;
    wc.hInstance = hInstEXE;
    wc.style = CS_DBLCLKS;
    wc.hIcon = LoadIcon(hInstEXE, MAKEINTRESOURCE(IDI_MMFW));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.hIconSm = (HICON)LoadImage(hInstEXE, MAKEINTRESOURCE(IDI_MMFW), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
    
    atomClassName = RegisterClassEx(&wc);

    int x = CW_USEDEFAULT;
    int y = CW_USEDEFAULT;
    
    GetSettings(x,y);

	hpalMain = SetPalette();

    #ifndef MMFW_USE_CAPTION
    DWORD dwStyle = WS_POPUP|WS_SYSMENU|WS_MINIMIZEBOX|WS_CLIPCHILDREN;
    #else
    DWORD dwStyle = WS_POPUP|WS_SYSMENU|WS_MINIMIZEBOX|WS_CAPTION|WS_CLIPCHILDREN;
    #endif

    //create our main window
    HWND hwnd = CreateWindowEx(WS_EX_APPWINDOW,
			     MAKEINTATOM(atomClassName),
			     szAppName,
			     dwStyle,
			     x,
			     y,
			     0,
			     0,
			     NULL,
			     NULL,
			     hInstEXE,
			     NULL);

    if (hwnd == NULL)
    {
        //major failure here!
        CleanUp();
        return 0;
    }

    hwndMain = hwnd;

    //tell our sink what our main window is
    CFrameworkNotifySink::m_hwndTitle = hwnd;

    //create the bitmaps of the main ui
    if (!BuildFrameworkBitmaps())
    {
        //failure -- can't create bitmaps for framework
        CleanUp();
        return 0;
    }

    int bmWidth = bmMain.bmWidth;
    int bmHeight = bmMain.bmHeight;

    //set window size to match the width and height of the correct mode's bitmap
    switch (g_nViewMode)
    {
        case VIEW_MODE_RESTORE :
        {
            bmWidth = bmMainRestore.bmWidth;
            bmHeight = bmMainRestore.bmHeight;
        }
        break;

        case VIEW_MODE_SMALL :
        {
            bmWidth = bmMainSmall.bmWidth;
            bmHeight = bmMainSmall.bmHeight;
        }
        break;

        case VIEW_MODE_NOBAR :
        {
            bmWidth = bmMainNoBar.bmWidth;
            bmHeight = bmMainNoBar.bmHeight;
        }
        break;
    }

    int sx = GetXOffset()*2;
    int sy = (GetYOffset()*2) + GetYOffsetCaption();
    SetWindowPos(hwnd,NULL,0,0,bmWidth+sx,bmHeight+sy,SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER);

    //check the window pos against multimon
    AdjustForMultimon(hwnd);

    SetCurvedEdges(hwnd);

    //Send us a message to set the initial mode of the player
    SendMessage(hwnd,WM_COMMAND,MAKEWPARAM(nCDMode,0),0);

    //show us!
    if (!ShellOnly())
    {
        ShowWindow(hwnd, nCmdShow);
        UpdateWindow(hwnd);

        LPCDDATA pCDData = GetCDData();

        if (pCDData)
        {
            pCDData->Initialize(hwnd);
            pCDData->CheckDatabase(hwnd);
        }
    }

    if (fShellMode)
    {
        CreateShellIcon(hInst,hwnd,pNodeCurrent,szAppName);
    }

    //main message loop
    MSG msg;

    for (;;)
    {
        if (PeekMessage(&msg, NULL, 0, 0,PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
                break;

	        /*
            if (hAccelApp && TranslateAccelerator(hwndApp, hAccelApp, &msg))
		    continue;
            */

	        if (!IsDialogMessage(hwnd,&msg))
	        {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            } //end if dialg msg
        }
        else
	    {
            WaitMessage();
        }
    } //end for

    //get outta here!
    CleanUp();

    return ((int)msg.wParam);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * ShowNewComponentWindow
// Displays the chosen component
// (Sort of a holdover from the old multi-component days, but it also serves to
// initialize the first component loaded)
////////////////////////////////////////////////////////////////////////////////////////////
void ShowNewComponentWindow(PCOMPNODE pNode, HWND hwnd)
{
    if (pNode == NULL)
    {
    	return;
    }

    //don't bother if we're already there
    if (pNode->hwndComp == hwndCurrentComp)
    {
	    return;
    }
    
    if (hwndCurrentComp != NULL)
    {
	    ShowWindow(hwndCurrentComp,SW_HIDE);
    }

    hwndCurrentComp = pNode->hwndComp;
    
    ShowWindow(hwndCurrentComp,SW_SHOW);

    pNodeCurrent = pNode;

    MMCOMPDATA mmComp;
    mmComp.dwSize = sizeof(mmComp);
    pNode->pComp->GetInfo(&mmComp);

    if (_tcslen(pNode->szTitle)==0)
    {
	    _tcscpy(pNode->szTitle,mmComp.szName);
    }

    SetWindowText(hwnd,szAppName);

    //also set icons
    if (mmComp.hiconLarge != NULL)
    {
    	SendMessage(hwnd, WM_SETICON, TRUE, (LPARAM)mmComp.hiconLarge);
    }

    if (mmComp.hiconSmall != NULL)
    {
	    SendMessage(hwnd, WM_SETICON, FALSE, (LPARAM)mmComp.hiconSmall);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * InitButtonProperties
// Set up the button info structure for all the transport buttons
//
// Should Fix: this is pretty ugly and hard-coded.  Implement to read from some kind of
//         easily-editable resource for when layout changes come?
////////////////////////////////////////////////////////////////////////////////////////////
void InitButtonProperties()
{
    //set up each button's properties
    ZeroMemory(biButtons,sizeof(BUTTONINFO)*NUM_BUTTONS);

    //order of buttons in this array affects the tab order
    biButtons[0].id = IDB_OPTIONS;
    biButtons[0].nToolTipID = IDB_TT_OPTIONS;
    biButtons[0].uixy.x = 11;
    biButtons[0].uixy.y = 102 + nDispAreaOffset;
    biButtons[0].width = 76;
    biButtons[0].height = 19;
    biButtons[0].uixy2.x = 9;
    biButtons[0].uixy2.y = 23;
    biButtons[0].width2 = 76;
    biButtons[0].dwStyle = MBS_STANDARDLEFT | MBS_DROPRIGHT;

    biButtons[1].id = IDB_NET;
    biButtons[1].nToolTipID = IDB_TT_NET;
    biButtons[1].uixy.x = 11;
    biButtons[1].uixy.y = 125 + nDispAreaOffset;
    biButtons[1].width = 76;
    biButtons[1].height = 19;
    biButtons[1].dwStyle = MBS_STANDARDLEFT | MBS_DROPRIGHT;

    biButtons[2].id = IDB_PLAY;
    biButtons[2].nToolTipID = IDB_TT_PLAY;
    biButtons[2].uixy.x = 103;
    biButtons[2].uixy.y = 102 + nDispAreaOffset;
    biButtons[2].width = 64;
    biButtons[2].height = 19; 
    biButtons[2].uixy2.x = 102;
    biButtons[2].uixy2.y = 23;
    biButtons[2].width2 = 34;
    biButtons[2].dwStyle = MBS_STANDARDLEFT | MBS_STANDARDRIGHT;
    biButtons[2].nIconID = IDI_ICON_PLAY;

    biButtons[3].id = IDB_STOP;
    biButtons[3].nToolTipID = IDB_TT_STOP;
    biButtons[3].uixy.x = 174;
    biButtons[3].uixy.y = 102 + nDispAreaOffset;
    biButtons[3].width = 64;
    biButtons[3].height = 19;
    biButtons[3].uixy2.x = 136;
    biButtons[3].uixy2.y = 23;
    biButtons[3].width2 = 34;
    biButtons[3].dwStyle = MBS_STANDARDLEFT | MBS_STANDARDRIGHT;
    biButtons[3].nIconID = IDI_ICON_STOP;

    biButtons[4].id = IDB_EJECT;    
    biButtons[4].nToolTipID = IDB_TT_EJECT;
    biButtons[4].uixy.x = 245;
    biButtons[4].uixy.y = 102 + nDispAreaOffset;
    biButtons[4].width = 51;
    biButtons[4].height = 19;
    biButtons[4].uixy2.x = 170;
    biButtons[4].uixy2.y = 23;
    biButtons[4].width2 = 34;
    biButtons[4].dwStyle = MBS_STANDARDLEFT | MBS_STANDARDRIGHT;
    biButtons[4].nIconID = IDI_ICON_EJECT;

    biButtons[5].id = IDB_REW;
    biButtons[5].nToolTipID = IDB_TT_REW;
    biButtons[5].uixy.x = 103;
    biButtons[5].uixy.y = 125 + nDispAreaOffset;
    biButtons[5].width = 33;
    biButtons[5].height = 19;
    biButtons[5].dwStyle = MBS_STANDARDLEFT | MBS_TOGGLERIGHT;
    biButtons[5].nIconID = IDI_ICON_REW;

    biButtons[6].id = IDB_FFWD;
    biButtons[6].nToolTipID = IDB_TT_FFWD;
    biButtons[6].uixy.x = 136;
    biButtons[6].uixy.y = 125 + nDispAreaOffset;
    biButtons[6].width = 31;
    biButtons[6].height = 19;
    biButtons[6].dwStyle = MBS_TOGGLELEFT | MBS_STANDARDRIGHT;
    biButtons[6].nIconID = IDI_ICON_FFWD;

    biButtons[7].id = IDB_PREVTRACK;
    biButtons[7].nToolTipID = IDB_TT_PREVTRACK;
    biButtons[7].uixy.x = 174;
    biButtons[7].uixy.y = 125 + nDispAreaOffset;
    biButtons[7].width = 33;
    biButtons[7].height = 19;
    biButtons[7].dwStyle = MBS_STANDARDLEFT | MBS_TOGGLERIGHT;
    biButtons[7].nIconID = IDI_ICON_PREV;

    biButtons[8].id = IDB_NEXTTRACK;
    biButtons[8].nToolTipID = IDB_TT_NEXTTRACK;
    biButtons[8].uixy.x = 207;
    biButtons[8].uixy.y = 125 + nDispAreaOffset;
    biButtons[8].width = 31;
    biButtons[8].height = 19;
    biButtons[8].dwStyle = MBS_TOGGLELEFT | MBS_STANDARDRIGHT;
    biButtons[8].nIconID = IDI_ICON_NEXT;

    biButtons[9].id = IDB_MODE;
    biButtons[9].nToolTipID = IDB_TT_MODE;
    biButtons[9].uixy.x = 245;
    biButtons[9].uixy.y = 125 + nDispAreaOffset;
    biButtons[9].width = 51;
    biButtons[9].height = 19;
    biButtons[9].dwStyle = MBS_STANDARDLEFT | MBS_DROPRIGHT;
    biButtons[9].nIconID = IDI_MODE_NORMAL;

    biButtons[10].id = IDB_TRACK;
    biButtons[10].nToolTipID = IDB_TT_TRACK;
    biButtons[10].uixy.x = 312;
    biButtons[10].uixy.y = 102 + nDispAreaOffset;
    biButtons[10].width = 76;
    biButtons[10].height = 19;
    biButtons[10].uixy2.x = 221;
    biButtons[10].uixy2.y = 23;
    biButtons[10].width2 = 72;
    biButtons[10].dwStyle = MBS_STANDARDLEFT | MBS_DROPRIGHT;

    biButtons[11].id = IDB_DISC;
    biButtons[11].nToolTipID = IDB_TT_DISC;
    biButtons[11].uixy.x = 312;
    biButtons[11].uixy.y = 125 + nDispAreaOffset;
    biButtons[11].width = 76;
    biButtons[11].height = 19;
    biButtons[11].dwStyle = MBS_STANDARDLEFT | MBS_DROPRIGHT;

    biButtons[12].id = IDB_CLOSE;
    biButtons[12].nToolTipID = IDB_TT_CLOSE;
    biButtons[12].uixy.x = 456;
    biButtons[12].uixy.y = 7;
    biButtons[12].width = 15;
    biButtons[12].height = 14;
    biButtons[12].fBlockTab = TRUE;
    biButtons[12].uixy2.x = 371;
    biButtons[12].uixy2.y = 4;
    biButtons[12].width2 = 15;
    biButtons[12].dwStyle = MBS_SYSTEMTYPE;
    biButtons[12].nIconID = IDB_CLOSE;

    biButtons[13].id = IDB_MINIMIZE;
    biButtons[13].nToolTipID = IDB_TT_MINIMIZE;
    biButtons[13].uixy.x = 427;
    biButtons[13].uixy.y = 7;
    biButtons[13].width = 14;
    biButtons[13].height =  14;
    biButtons[13].fBlockTab = TRUE;
    biButtons[13].uixy2.x = 343;
    biButtons[13].uixy2.y = 4;
    biButtons[13].width2 = 14;
    biButtons[13].dwStyle = MBS_SYSTEMTYPE;
    biButtons[13].nIconID = IDB_MINIMIZE;

    biButtons[14].id = IDB_SET_TINY_MODE;
    biButtons[14].nToolTipID = IDB_TT_RESTORE;
    biButtons[14].uixy.x = 442;
    biButtons[14].uixy.y = 7;
    biButtons[14].width = 14;
    biButtons[14].height =  14;
    biButtons[14].fBlockTab = TRUE;
    biButtons[14].uixy2.x = 357;
    biButtons[14].uixy2.y = 4;
    biButtons[14].width2 = 14;
    biButtons[14].dwStyle = MBS_SYSTEMTYPE;
    biButtons[14].nIconID = IDB_SET_TINY_MODE;

    biButtons[15].id = IDB_SET_NORMAL_MODE;
    biButtons[15].nToolTipID = IDB_TT_MAXIMIZE;
    biButtons[15].uixy.x = 442;
    biButtons[15].uixy.y = 7;
    biButtons[15].width = 14;
    biButtons[15].height =  14;
    biButtons[15].fBlockTab = TRUE;
    biButtons[15].uixy2.x = 357;
    biButtons[15].uixy2.y = 4;
    biButtons[15].width2 = 14;
    biButtons[15].dwStyle = MBS_SYSTEMTYPE;
    biButtons[15].nIconID = IDB_SET_NORMAL_MODE;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CreateMuteButton
// Make the little mute button guy
////////////////////////////////////////////////////////////////////////////////////////////
void CreateMuteButton(HWND hwndOwner)
{
	//first load mute button's cursor
    hCursorMute = LoadCursor(hInst,MAKEINTRESOURCE(IDC_MUTE));
    
    CMButton* pButton = NULL;

	TCHAR szCaption[MAX_PATH];
	LoadString(hInst,IDB_MUTE,szCaption,sizeof(szCaption)/sizeof(TCHAR));
	
    int yOffset = 122+nDispAreaOffset;
    if (g_nViewMode == VIEW_MODE_NOBAR)
    {
        yOffset -= 16;
    }

    pButton = CreateMButton(szCaption,IDB_MUTE,WS_VISIBLE|WS_TABSTOP,
				    MBS_SYSTEMTYPE,
				    450,
				    yOffset,
				    13,
				    13,
				    hwndOwner,
				    FALSE,  //create original, not subclass
				    IDB_MUTE,
                    IDB_TT_MUTE,
				    hInst);

    //hide this button in small mode
    if ((g_nViewMode==VIEW_MODE_RESTORE)||((g_nViewMode==VIEW_MODE_SMALL)))
    {
        ShowWindow(pButton->GetHWND(),SW_HIDE); 
    }

    //set up tool tip
    TOOLINFO ti;
    ti.cbSize = sizeof(TOOLINFO); 
    ti.uFlags = TTF_IDISHWND;
    ti.hwnd =  hwndOwner; 
    ti.uId = (UINT_PTR)(pButton->GetHWND());
    ti.hinst = hInst; 
    ti.lpszText = LPSTR_TEXTCALLBACK;
    SendMessage(g_hwndTT, TTM_ADDTOOL, 0,  (LPARAM) (LPTOOLINFO) &ti);

    //make sure button is in correct state if muted on start up
    SendMessage(pButton->GetHWND(),BM_SETSTATE,(WPARAM)GetMute(),0);
    SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_MUTE,0,GetMute());
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CreateVolumeKnob
// Put up the volume knob that EVERYONE LOVES
////////////////////////////////////////////////////////////////////////////////////////////
void CreateVolumeKnob(HWND hwndOwner)
{
    LPCDOPT pOpt = GetCDOpt();
    if( pOpt )
    {
        LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();
        InitCDVol(hwndOwner,pCDOpts);

        //ok, this is bad, but I have the options here and the only other thing
        //I need from them is the "topmost" setting for the main window ...
        //so I'll go ahead and take care of that here rather than recreating
        //this struct somewhere or making it global.
        SetWindowPos(hwndOwner,
                     pCDOpts->pCDData->fTopMost ? HWND_TOPMOST : HWND_NOTOPMOST,
                     0,0,0,0,
                     SWP_NOMOVE|SWP_NOSIZE);
    
        DWORD dwVol = GetVolume();
        int yOffset = 93+nDispAreaOffset;
        if (g_nViewMode == VIEW_MODE_NOBAR)
        {
            yOffset -= 16;
        }

        CKnob* pKnob = CreateKnob(WS_VISIBLE | WS_TABSTOP,
	                               0xFFFF,
	                               dwVol,
	                               403,
	                               yOffset,
	                               45,
	                               45,
	                               hwndOwner,
	                               IDB_VOLUME,
	                               hInst);

        TOOLINFO ti;
        ti.cbSize = sizeof(TOOLINFO); 
        ti.uFlags = TTF_IDISHWND;
        ti.hwnd =  hwndOwner; 
        ti.uId = (UINT_PTR)(pKnob->GetHWND());
        ti.hinst = hInst; 
        ti.lpszText = LPSTR_TEXTCALLBACK;
        SendMessage(g_hwndTT, TTM_ADDTOOL, 0,  (LPARAM) (LPTOOLINFO) &ti);

        if ((g_nViewMode==VIEW_MODE_RESTORE)||((g_nViewMode==VIEW_MODE_SMALL)))
        {
            ShowWindow(pKnob->GetHWND(),SW_HIDE);
        }
    
        CreateMuteButton(hwndOwner);
    }
    else
    {
        //fix for bug 886 ... turns off mute line in case of cdopt.dll failure
        SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_MUTE,0,FALSE);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CreateButtonWindows
// Put the transport control buttons onto the screen
////////////////////////////////////////////////////////////////////////////////////////////
void CreateButtonWindows(HWND hwndOwner)
{
    InitMButtons(hInst,hwndOwner);

    InitButtonProperties();

    for (int i = 0; i < NUM_BUTTONS; i++)
    {
	    DWORD wsTab = biButtons[i].fBlockTab ? 0 : WS_TABSTOP;

	    CMButton* pButton = NULL;
    
	    TCHAR szCaption[MAX_PATH];
	    LoadString(hInst,biButtons[i].id,szCaption,sizeof(szCaption)/sizeof(TCHAR));
	    
	    int x, y, width;
        int nView = SW_SHOW;

        switch (g_nViewMode)
        {
            case VIEW_MODE_NORMAL :
            {
                x = biButtons[i].uixy.x;
                y = biButtons[i].uixy.y;
                width = biButtons[i].width;
                if (biButtons[i].id == IDB_SET_NORMAL_MODE)
                {
                    nView = SW_HIDE;
                }
            }
            break;

            case VIEW_MODE_NOBAR :
            {
                x = biButtons[i].uixy.x;
                y = biButtons[i].uixy.y - 16;
                width = biButtons[i].width;
                if (biButtons[i].dwStyle == MBS_SYSTEMTYPE)
                {
                    nView = SW_HIDE;
                }
            }
            break;

            case VIEW_MODE_RESTORE :
            {
                x = biButtons[i].uixy2.x;
                y = biButtons[i].uixy2.y;
                width = biButtons[i].width2;
                if (biButtons[i].id == IDB_SET_TINY_MODE)
                {
                    nView = SW_HIDE;
                }
            }
            break;

            case VIEW_MODE_SMALL :
            {
                x = biButtons[i].uixy2.x;
                y = biButtons[i].uixy2.y - 12;
                width = biButtons[i].width2;
            }
            break;
        }

        //for buttons that aren't going to blit in smaller modes
        if (width == 0)
        {
            //set to normal width
            width = biButtons[i].width;
            nView = SW_HIDE;
        }

        pButton = CreateMButton(szCaption,biButtons[i].nIconID,WS_VISIBLE|wsTab,
				        biButtons[i].dwStyle,
				        x,
				        y,
				        width,
				        biButtons[i].height,
				        hwndOwner,
				        FALSE,  //create original, not subclass
				        biButtons[i].id,
                        biButtons[i].nToolTipID,
				        hInst);

        //hide system buttons in small mode
        if (g_nViewMode == VIEW_MODE_SMALL)
        {
            if (biButtons[i].dwStyle == MBS_SYSTEMTYPE)
            {
                ShowWindow(pButton->GetHWND(),SW_HIDE); 
            }
        }

        if (nView == SW_HIDE)
        {
            ShowWindow(pButton->GetHWND(),SW_HIDE);
        }

        TOOLINFO ti;
        ti.cbSize = sizeof(TOOLINFO); 
        ti.uFlags = TTF_IDISHWND;
        ti.hwnd =  hwndOwner; 
        ti.uId = (UINT_PTR)(pButton->GetHWND());
        ti.hinst = hInst; 
        ti.lpszText = LPSTR_TEXTCALLBACK;
        SendMessage(g_hwndTT, TTM_ADDTOOL, 0,  (LPARAM) (LPTOOLINFO) &ti);

	    //set focus and default to first control
	    if (i == 0)
	    {
	        SetFocus(pButton->GetHWND());
	    }
    } //end for buttons

    SendMessage(hwndOwner, DM_SETDEFID, biButtons[0].id, 0);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * VolPersistTimerProc
// When we're done displaying the volume, tell CD player to repaint normally
////////////////////////////////////////////////////////////////////////////////////////////
void CALLBACK VolPersistTimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    //turn on painting in the led window
    SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_INFO_PAINT,1,0);
    InvalidateRect(hwndCurrentComp,NULL,FALSE);
    KillTimer(hwnd,idEvent);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * IsNetOK
// Returns TRUE if it is OK to do networking-related stuff (i.e. the database is all right)
////////////////////////////////////////////////////////////////////////////////////////////
BOOL IsNetOK(HWND hwnd)
{
    DWORD dwRet = FALSE;
    
    LPCDDATA pData = GetCDData();
    if (pData)
    {
        if (SUCCEEDED(pData->CheckDatabase(hwnd)))
        {
            dwRet = TRUE;
        }
    }

    return (dwRet);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * IsDownloading
// Check on the networking thread to see if it is active
////////////////////////////////////////////////////////////////////////////////////////////
BOOL IsDownloading()
{
    BOOL retcode = FALSE;
    
    ICDNet* pICDNet = NULL;
    if (SUCCEEDED(CDNET_CreateInstance(NULL, IID_ICDNet, (void**)&pICDNet)))
    {
		    retcode = pICDNet->IsDownloading();
            pICDNet->Release();
    }

    return (retcode);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CancelDownload
// Tell the networking thread to quit as soon as it can
////////////////////////////////////////////////////////////////////////////////////////////
void CancelDownload()
{
    ICDNet* pICDNet = NULL;
    if (SUCCEEDED(CDNET_CreateInstance(NULL, IID_ICDNet, (void**)&pICDNet)))
    {
        pICDNet->CancelDownload();
        pICDNet->Release();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * EndDownloadThreads
// Kills the download threads on shutdown
////////////////////////////////////////////////////////////////////////////////////////////
void EndDownloadThreads()
{
    //optimization: don't bother if CDNET.DLL is not loaded
    if (GetModuleHandle(TEXT("CDNET.DLL")))
    {
        if (IsDownloading())
        {
            CancelDownload();
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * MenuButtonTimerProc
// Big ol' hack to make the menus that drop down from button seem like real menus ...
// if the user hits the button before the timeout time, we don't redisplay the menu
////////////////////////////////////////////////////////////////////////////////////////////
void CALLBACK MenuButtonTimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    //single-shot timer turns off the "block menu" flag
    fBlockMenu = FALSE;
    nLastMenu = 0;
    KillTimer(hwnd,idEvent);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * BlockMenu
// Turns on the button/menu hack
////////////////////////////////////////////////////////////////////////////////////////////
void BlockMenu(HWND hwnd)
{
    fBlockMenu = TRUE;
    SetTimer(hwnd,nLastMenu,MENU_TIMER_RATE,(TIMERPROC)MenuButtonTimerProc);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * NormalizeNameForMenuDisplay
//    This function turns a string like "Twist & Shout" into
//    "Twist && Shout" because otherwise it will look like
//    "Twist _Shout" in the menu due to the accelerator char
//
//  Defined in cdplayer.lib
//
////////////////////////////////////////////////////////////////////////////////////////////
extern "C" void NormalizeNameForMenuDisplay(TCHAR* szInput, TCHAR* szOutput, DWORD cbLen);

////////////////////////////////////////////////////////////////////////////////////////////
// * DrawButton
// Response to WM_DRAWITEM on buttons
////////////////////////////////////////////////////////////////////////////////////////////
void DrawButton(UINT idCtl, LPDRAWITEMSTRUCT lpdis)
{
    CMButton* pButton = GetMButtonFromID(hwndMain,idCtl);

    if (pButton!=NULL)
    {
	    pButton->Draw(lpdis);
    }

    //special case ... if the button is one of the scanner buttons,
    //forward this message to the component
    if ((idCtl==IDB_REW) || (idCtl==IDB_FFWD))
    {
        switch (idCtl)
        {
            case IDB_REW  : idCtl = IDM_PLAYBAR_SKIPBACK; break;
            case IDB_FFWD : idCtl = IDM_PLAYBAR_SKIPFORE; break;
        }
        lpdis->CtlID = idCtl;
        SendMessage(hwndCurrentComp,WM_DRAWITEM,idCtl,(LPARAM)lpdis);
    }

    if (
        (idCtl == IDB_OPTIONS) ||
        (idCtl == IDB_MODE) ||
        (idCtl == IDB_TRACK) ||
        (idCtl == IDB_NET) ||
        (idCtl == IDB_DISC)
       )
    {
        if (lpdis->itemState & ODS_SELECTED)
        {
            if ((fBlockMenu) && (nLastMenu == idCtl))
            {
                return;
            }

            HWND hwnd = hwndMain;
	        RECT rect;
            AllocCustomMenu(&g_pMenu);
            CustomMenu* pSearchSubMenu = NULL;
            CustomMenu* pProviderSubMenu = NULL;

            if (!g_pMenu)
            {
                return;
            }

            if (idCtl == IDB_OPTIONS)
            {
                g_pMenu->AppendMenu(IDM_OPTIONS,hInst,IDM_OPTIONS);
                g_pMenu->AppendMenu(IDM_PLAYLIST,hInst,IDM_PLAYLIST);
                g_pMenu->AppendSeparator();

                if (!IsNetOK(hwnd))
                {
                    EnableMenuItem(g_pMenu->GetMenuHandle(),
                                    IDM_PLAYLIST,
                                    MF_BYCOMMAND | MF_GRAYED);
                }

                if (g_nViewMode == VIEW_MODE_NORMAL)
                {
                    g_pMenu->AppendMenu(IDM_TINY,hInst,IDM_TINY);
                }
                else
                {
                    g_pMenu->AppendMenu(IDM_NORMAL,hInst,IDM_NORMAL);
                }

                g_pMenu->AppendSeparator();

                g_pMenu->AppendMenu(IDM_HELP,hInst,IDM_HELP);
                g_pMenu->AppendMenu(IDM_ABOUT,hInst,IDM_ABOUT);

                g_pMenu->AppendSeparator();

                g_pMenu->AppendMenu(IDM_EXIT,hInst,IDM_EXIT);
            } //end if options

            if (idCtl == IDB_NET)
            {
                AllocCustomMenu(&pSearchSubMenu);
                AllocCustomMenu(&pProviderSubMenu);

		        MMMEDIAID mmMedia;
                mmMedia.nDrive = -1;
	            IMMComponentAutomation* pAuto = NULL;
	            HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
		        pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
                pAuto->Release();

                BOOL fContinue = TRUE;

                //append static menu choices
                if (IsDownloading())
                {
                    g_pMenu->AppendMenu(IDM_NET_CANCEL,hInst,IDM_NET_CANCEL);
                }
                else
                {
                    g_pMenu->AppendMenu(IDM_NET_UPDATE,hInst,IDM_NET_UPDATE);
                    if (mmMedia.dwMediaID == 0)
                    {
                        //need to gray out menu
                        MENUITEMINFO mmi;
                        mmi.cbSize = sizeof(mmi);
                        mmi.fMask = MIIM_STATE;
                        mmi.fState = MFS_GRAYED;
                        HMENU hMenu = g_pMenu->GetMenuHandle();
                        SetMenuItemInfo(hMenu,IDM_NET_UPDATE,FALSE,&mmi);
                    }
                }
	            
                //if networking is not allowed, gray it out ...
                //don't worry about cancel case, it won't be there
                if (!IsNetOK(hwnd))
                {
                    EnableMenuItem(g_pMenu->GetMenuHandle(),
                                    IDM_NET_UPDATE,
                                    MF_BYCOMMAND | MF_GRAYED);
                }

                //don't allow searching if title isn't available
                LPCDDATA pData = GetCDData();
                if (pData)
                {
                    if (pData->QueryTitle(mmMedia.dwMediaID))
                    {
                        pSearchSubMenu->AppendMenu(IDM_NET_BAND,hInst,IDM_NET_BAND);
                        pSearchSubMenu->AppendMenu(IDM_NET_CD,hInst,IDM_NET_CD);
                        pSearchSubMenu->AppendMenu(IDM_NET_ROLLINGSTONE_ARTIST,hInst,IDM_NET_ROLLINGSTONE_ARTIST);
                        pSearchSubMenu->AppendMenu(IDM_NET_BILLBOARD_ARTIST,hInst,IDM_NET_BILLBOARD_ARTIST);
                        pSearchSubMenu->AppendMenu(IDM_NET_BILLBOARD_ALBUM,hInst,IDM_NET_BILLBOARD_ALBUM);
                        g_pMenu->AppendMenu(hInst,IDM_NET_SEARCH_HEADING,pSearchSubMenu);
                    }
                } //end if pdata

                //display any provider home pages
                DWORD i = 0;
                LPCDOPT pOpt = GetCDOpt();
                if( pOpt )
                {
                    LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();

                    LPCDPROVIDER pProviderList = pCDOpts->pProviderList;

                    while (pProviderList!=NULL)
                    {
                        TCHAR szProviderMenu[MAX_PATH];
                        TCHAR szHomePageFormat[MAX_PATH/2];
                        LoadString(hInst,IDS_HOMEPAGEFORMAT,szHomePageFormat,sizeof(szHomePageFormat)/sizeof(TCHAR));
                        wsprintf(szProviderMenu,szHomePageFormat,pProviderList->szProviderName);
    
                        pProviderSubMenu->AppendMenu(IDM_HOMEMENU_BASE+i,szProviderMenu);

                        pProviderList = pProviderList->pNext;
                        i++;
                    } //end while

                    g_pMenu->AppendMenu(hInst,IDM_NET_PROVIDER_HEADING,pProviderSubMenu);
                } //end home pages

                //display internet-loaded disc menus
                if (pData)
                {
                    if (pData->QueryTitle(mmMedia.dwMediaID))
                    {
                        LPCDTITLE pCDTitle = NULL;
                        hr =  pData->LockTitle(&pCDTitle,mmMedia.dwMediaID);

                        if (SUCCEEDED(hr))
                        {
                            for (i = 0; i < pCDTitle->dwNumMenus; i++)
                            {
                                if (i==0)
                                {
                                    g_pMenu->AppendSeparator();
                                }

                                TCHAR szDisplayNet[MAX_PATH];
                                NormalizeNameForMenuDisplay(pCDTitle->pMenuTable[i].szMenuText,szDisplayNet,sizeof(szDisplayNet));
            	                g_pMenu->AppendMenu(i + IDM_NETMENU_BASE,szDisplayNet);
                            }

                            pData->UnlockTitle(pCDTitle,FALSE);
                        }
                    } //end if query title
                }
            } //end if net

            if (idCtl == IDB_MODE)
            {
                g_pMenu->AppendMenu(IDM_MODE_NORMAL,hInst,IDI_MODE_NORMAL,IDM_MODE_NORMAL);
                g_pMenu->AppendMenu(IDM_MODE_RANDOM,hInst,IDI_MODE_RANDOM,IDM_MODE_RANDOM);
                g_pMenu->AppendMenu(IDM_MODE_REPEATONE,hInst,IDI_MODE_REPEATONE,IDM_MODE_REPEATONE);
                g_pMenu->AppendMenu(IDM_MODE_REPEATALL,hInst,IDI_MODE_REPEATALL,IDM_MODE_REPEATALL);
                g_pMenu->AppendMenu(IDM_MODE_INTRO,hInst,IDI_MODE_INTRO,IDM_MODE_INTRO);
                g_pMenu->SetMenuDefaultItem(nCDMode,FALSE);
            } //end if mode

            if (idCtl==IDB_TRACK)
            {
	            IMMComponentAutomation* pAuto = NULL;
	            HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	            if ((SUCCEEDED(hr)) && (pAuto != NULL))
	            {
                    int i = 0;
                    while (SUCCEEDED(hr))
                    {
		                MMTRACKORDISC mmTrack;
                        mmTrack.nNumber = i++;
                        hr = pAuto->OnAction(MMACTION_GETTRACKINFO,&mmTrack);
                        if (SUCCEEDED(hr))
                        {
                            g_pMenu->AppendMenu(mmTrack.nID + IDM_TRACKLIST_BASE, mmTrack.szName);
                            if (mmTrack.fCurrent)
                            {
                                g_pMenu->SetMenuDefaultItem(mmTrack.nID + IDM_TRACKLIST_BASE,FALSE);
                            } //end if current
                        } //end if ok
                    } //end while
                    pAuto->Release();
                }
            } //end if track

            if (idCtl == IDB_DISC)
            {
	            IMMComponentAutomation* pAuto = NULL;
	            HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
                int i = 0;

	            if ((SUCCEEDED(hr)) && (pAuto != NULL))
	            {
                    while (SUCCEEDED(hr))
                    {
		                MMTRACKORDISC mmDisc;
                        mmDisc.nNumber = i++;
                        hr = pAuto->OnAction(MMACTION_GETDISCINFO,&mmDisc);
                        if (SUCCEEDED(hr))
                        {
                            g_pMenu->AppendMenu(mmDisc.nID + IDM_DISCLIST_BASE, mmDisc.szName);
                            if (mmDisc.fCurrent)
                            {
                                g_pMenu->SetMenuDefaultItem(mmDisc.nID + IDM_DISCLIST_BASE,FALSE);
                            } //end if current
                        }
                    }
                    pAuto->Release();
                }
    
                if (i > 0)
                {
                    g_pMenu->AppendSeparator();
                }

                g_pMenu->AppendMenu(IDM_OPENVIRTUALCD,hInst,IDM_OPENVIRTUALCD);
            } //end if disc

            //push down to under button
            HWND hwndButton = pButton->GetHWND();
	        GetClientRect(hwndButton,&rect);

	        //convert whole rect to screen coordinates
            ClientToScreen(hwndButton,(LPPOINT)&rect);
            ClientToScreen(hwndButton,((LPPOINT)&rect)+1);

            KillTimer(hwnd,nLastMenu);
            nLastMenu = idCtl;
            fBlockMenu = TRUE;
            pButton->SetMenuingState(TRUE);
            if (g_pMenu)
            {
                g_pMenu->TrackPopupMenu(0,rect.left,rect.bottom,hwnd,&rect);
            }
            else
            {
                BlockMenu(hwnd);
            }
            pButton->SetMenuingState(FALSE);
    
            if (g_pMenu)
            {
                g_pMenu->Destroy();
                g_pMenu = NULL;
            }
    
            if (pProviderSubMenu)
            {
                pProviderSubMenu->Destroy();
                pProviderSubMenu = NULL;
            }
            if (pSearchSubMenu)
            {
                pSearchSubMenu->Destroy();
                pSearchSubMenu = NULL;
            }
        } //end if selected
    } //end if right button

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * OnNCHitTest
// How we pretend that we have a real caption
////////////////////////////////////////////////////////////////////////////////////////////
UINT OnNCHitTest(HWND hwnd, short x, short y, BOOL fButtonDown)
{
    UINT ht = HTCLIENT;

    if (!fButtonDown)
    {
        ht = FORWARD_WM_NCHITTEST(hwnd, x, y, DefWindowProc );
    }

    RECT rect;
    GetClientRect(hwnd,&rect);
    rect.bottom = rect.top + TITLEBAR_HEIGHT +
                    (g_nViewMode == VIEW_MODE_NORMAL ? TITLEBAR_YOFFSET_LARGE :
                                                       TITLEBAR_YOFFSET_SMALL);

    POINT pt;
    pt.x = (LONG)x;
    pt.y = (LONG)y;

    ScreenToClient(hwnd,&pt);

    if (PtInRect(&rect,pt))
    {
        ht = HTCAPTION;
    }

    rect.left = SYSMENU_XOFFSET;
    rect.right = SYSMENU_XOFFSET + SYSMENU_WIDTH;
    //check for a system-menu hit.
    if (PtInRect(&rect,pt))
    {
        ht = HTSYSMENU;
    }

    //always a caption hit in small mode or nobar mode
    if (g_nViewMode >= VIEW_MODE_SMALL)
    {
        ht = HTCAPTION;
    }

    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, ht);

    return (ht);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * FillGradient
// from kernel's caption.c
// Allows us to have the cool gradient caption bar that you get for free otherwise
////////////////////////////////////////////////////////////////////////////////////////////
void FillGradient(HDC hdc, LPCRECT prc, COLORREF rgbLeft, COLORREF rgbRight)
{
    TRIVERTEX avert[2];
    static GRADIENT_RECT auRect[1] = {0,1};
    #define GetCOLOR16(RGB, clr) ((COLOR16)(Get ## RGB ## Value(clr) << 8))

    avert[0].Red = GetCOLOR16(R, rgbLeft);
    avert[0].Green = GetCOLOR16(G, rgbLeft);
    avert[0].Blue = GetCOLOR16(B, rgbLeft);

    avert[1].Red = GetCOLOR16(R, rgbRight);
    avert[1].Green = GetCOLOR16(G, rgbRight);
    avert[1].Blue = GetCOLOR16(B, rgbRight);

    avert[0].x = prc->left;
    avert[0].y = prc->top;
    avert[1].x = prc->right;
    avert[1].y = prc->bottom;

    //only load once, when needed.  Freed in "CleanUp" call
    if (hmImage == NULL)
    {
        hmImage = LoadLibrary(TEXT("MSIMG32.DLL"));
        if (hmImage!=NULL)
        {
	        fnGradient = (GRADIENTPROC)GetProcAddress(hmImage,"GradientFill");
        }
    }

	if (fnGradient!=NULL)
	{
		fnGradient(hdc, avert, 2, (PUSHORT)auRect, 1, 0x00000000);
        return;
	}

    BOOL fActiveWindow = FALSE;

    if (hwndMain == GetForegroundWindow())
    {
	    fActiveWindow = TRUE;
    }

	HBRUSH hbrush = CreateSolidBrush(GetSysColor(fActiveWindow ? COLOR_ACTIVECAPTION : COLOR_INACTIVECAPTION));
	FillRect(hdc,prc,hbrush);
	DeleteObject(hbrush);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * DrawTitleBar
// Blits the title bar to the screen
////////////////////////////////////////////////////////////////////////////////////////////
void DrawTitleBar(HDC hdc, HWND hwnd, BOOL fActiveWindow, BOOL fExludeRect)
{
    if (g_nViewMode >= VIEW_MODE_SMALL)
    {
        return; //no title bar in these views
    }

    RECT rect;
    HBRUSH hbrush;

    //convert the client rect of the minimize button into the rect within the
    //main display area
    RECT minButtonRect;
    RECT mainWndRect;
    GetWindowRect(hwnd,&mainWndRect);
    
    HWND hwndButton = GetDlgItem(hwnd,IDB_MINIMIZE);

    if (!hwndButton)
    {
        return; //must have been called before button was created
    }

    GetWindowRect(hwndButton,&minButtonRect);
    
    HDC memDC = CreateCompatibleDC(hdc);
    HBITMAP hbmp = CreateCompatibleBitmap(hdc,
					  (g_nViewMode == VIEW_MODE_NORMAL ? bmMain.bmWidth : bmMainRestore.bmWidth),
					  (g_nViewMode == VIEW_MODE_NORMAL ? bmMain.bmHeight : bmMainRestore.bmHeight));
    HBITMAP holdbmp = (HBITMAP)SelectObject(memDC, hbmp);

    BOOL fGradient = FALSE;
    SystemParametersInfo(SPI_GETGRADIENTCAPTIONS,0,&fGradient,0);

    //we just need the left-hand side.
    //to get it, we take the width of the window and subtract the offset
    //from the right of the window
    minButtonRect.left = (mainWndRect.right - mainWndRect.left) -
                         (mainWndRect.right - minButtonRect.left);

    rect.left = SYSMENU_XOFFSET + SYSMENU_WIDTH + 1;
    rect.right = minButtonRect.left - (GetXOffset()*2) - 1;

    rect.top = (g_nViewMode == VIEW_MODE_NORMAL ? TITLEBAR_YOFFSET_LARGE :
                                                  TITLEBAR_YOFFSET_SMALL);

    rect.bottom = rect.top + TITLEBAR_HEIGHT;

    if (fGradient)
    {
	    DWORD dwStartColor = GetSysColor(fActiveWindow ? COLOR_ACTIVECAPTION : COLOR_INACTIVECAPTION);
	    DWORD dwFinishColor = GetSysColor(fActiveWindow ? COLOR_GRADIENTACTIVECAPTION : COLOR_GRADIENTINACTIVECAPTION);
	    FillGradient(memDC,&rect,dwStartColor,dwFinishColor);
    }
    else
    {
	    hbrush = CreateSolidBrush(GetSysColor(fActiveWindow ? COLOR_ACTIVECAPTION : COLOR_INACTIVECAPTION));
	    FillRect(memDC,&rect,hbrush);
	    DeleteObject(hbrush);
    }

    TCHAR s[MAX_PATH];
    GetWindowText(hwnd,s,MAX_PATH-1);

    SetBkMode(memDC,TRANSPARENT);
    SetTextColor(memDC, GetSysColor(fActiveWindow ? COLOR_CAPTIONTEXT : COLOR_INACTIVECAPTIONTEXT));

    //create title bar font
    NONCLIENTMETRICS metrics;
    metrics.cbSize = sizeof(metrics);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS,sizeof(metrics),&metrics,0);

    if (IS_DBCS_CHARSET(metrics.lfCaptionFont.lfCharSet))
    {
	metrics.lfCaptionFont.lfHeight = (-9 * STANDARD_PIXELS_PER_INCH) / 72;
    } else {
	metrics.lfCaptionFont.lfHeight = (-8 * STANDARD_PIXELS_PER_INCH) / 72;
    }

    HFONT hTitleFont = CreateFontIndirect(&metrics.lfCaptionFont);

    HFONT hOrgFont = (HFONT)SelectObject(memDC, hTitleFont);

    ExtTextOut( memDC, rect.left + 3, rect.top, 0, NULL, s, _tcslen(s), NULL );

    SelectObject(memDC,hOrgFont);

    BitBlt(hdc,rect.left,rect.top,rect.right-rect.left,rect.bottom-rect.top-1,memDC,rect.left,rect.top,SRCCOPY);

    if (fExludeRect)
    {
        ExcludeClipRect(hdc,rect.left,rect.top,rect.right,rect.bottom-1);        
    }

    SelectObject(memDC, holdbmp);
    DeleteObject(hbmp);
    SelectObject(memDC, hOrgFont);
    DeleteDC(memDC);
    DeleteObject(hTitleFont);
}
    
////////////////////////////////////////////////////////////////////////////////////////////
// * DrawVolume
// Tells the cdplayer to start showing the volume setting
////////////////////////////////////////////////////////////////////////////////////////////
void DrawVolume(DWORD level)
{
    //we just have the led window draw it
    HWND ledWnd = GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW);

    MMONVOLCHANGED mmVolChange;
    mmVolChange.dwNewVolume = level;
    mmVolChange.fMuted = FALSE;
    mmVolChange.szLineName = szLineName;

    SendMessage(ledWnd,WM_LED_INFO_PAINT,0,(LPARAM)&mmVolChange);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * OnToolTipNotify
// Called from tool tips to get the text they need to display
////////////////////////////////////////////////////////////////////////////////////////////
VOID OnToolTipNotify(LPARAM lParam)
{     
    LPTOOLTIPTEXT lpttt;     
    HWND hwndCtrl;  

    if ((((LPNMHDR) lParam)->code) == TTN_NEEDTEXT) 
    { 
        hwndCtrl = (HWND)((LPNMHDR)lParam)->idFrom; 
        lpttt = (LPTOOLTIPTEXT) lParam;

        if (hwndCtrl == GetDlgItem(hwndMain,IDB_VOLUME))
        {
            GetWindowText(hwndCtrl,g_tooltext,sizeof(g_tooltext)/sizeof(TCHAR));
        }
        else
        {
            CMButton* pButton = GetMButtonFromHWND(hwndCtrl);
            if (pButton)
            {
                LoadString(hInst,pButton->GetToolTipID(),g_tooltext,sizeof(g_tooltext)/sizeof(TCHAR));
            }
        }
        lpttt->lpszText = g_tooltext;
    } 	
    return;
} 

////////////////////////////////////////////////////////////////////////////////////////////
// * GetNumBatchedTitles
// Get the number of titles currently in the batch queue
////////////////////////////////////////////////////////////////////////////////////////////
DWORD GetNumBatchedTitles()
{
    LPCDDATA pData = GetCDData();
    DWORD dwReturn = 0;

    if (pData)
    {
        dwReturn = pData->GetNumBatched();
    }

    return (dwReturn);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandleBadServiceProvider
// Put up message box if the provider did not pass validation
////////////////////////////////////////////////////////////////////////////////////////////
void HandleBadServiceProvider(HWND hwndParent)
{
    TCHAR szError[MAX_PATH];
    LoadString(hInst,IDS_BADPROVIDER,szError,sizeof(szError)/sizeof(TCHAR));
    MessageBox(hwndParent,szError,szAppName,MB_ICONEXCLAMATION|MB_OK);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * NormalizeNameForURL
// Changes a name to a "normalized" name for URL
////////////////////////////////////////////////////////////////////////////////////////////
void NormalizeNameForURL(LPCTSTR szName, LPTSTR szOutput, DWORD cbOutputLen)
{
	typedef BOOL (PASCAL *CANPROC)(LPCTSTR, LPTSTR, LPDWORD, DWORD);
    CANPROC canProc = NULL;
    
    _tcscpy(szOutput,szName); //init URL with passed-in value

    //if possible, canonicalize the URL
    HMODULE hNet = LoadLibrary(TEXT("WININET.DLL"));
    if (hNet!=NULL)
    {
	    canProc = (CANPROC)GetProcAddress(hNet,CANONFUNCTION);
        if (canProc!=NULL)
        {
            BOOL f = canProc(szName,szOutput,&cbOutputLen,0);
        }
        FreeLibrary(hNet);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * OpenBrowserURL
// Opens a URL in the default browser
////////////////////////////////////////////////////////////////////////////////////////////
void OpenBrowserURL(TCHAR* szURL)
{
    ShellExecute(NULL,_TEXT("open"),szURL,NULL,_TEXT(""),SW_NORMAL);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * ProgressDlgProc
// Main proc for download progress dialog
// Should Fix: Put in own file
////////////////////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK ProgressDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fReturnVal = TRUE;
    static HWND hwndAnimate = NULL;
    static HANDLE hLogo = NULL;
    static LPCDOPT pOpts = NULL;
    static fOneDownloaded = FALSE;
    static LPCDPROVIDER pCurrent = NULL;
		
    switch (msg) 
    { 
    	default:
			fReturnVal = FALSE;
		break;
		
        case WM_INITDIALOG:
        {
            fOneDownloaded = FALSE;
            BOOL fSingle = FALSE;
            DWORD dwDiscID = (DWORD)-1; //use batch

            if (lParam == 0)
            {
                if (!pSingleTitle)
                {
                    EndDialog(hDlg,-1);
                    return FALSE;
                }

                fSingle = TRUE;
                dwDiscID = pSingleTitle->dwTitleID;
                lParam = 1;
            }

            if (IsDownloading())
            {
                //if we're downloading on the Main UI, put up a "waiting" message for now
                TCHAR szWaiting[MAX_PATH];
                LoadString(hInst,IDS_WAITINGFORDOWNLOAD,szWaiting,sizeof(szWaiting)/sizeof(TCHAR));
                SendDlgItemMessage(hDlg,IDC_STATIC_INFO,WM_SETTEXT,0,(LPARAM)szWaiting);
            }

            //set the range
        	SendDlgItemMessage(hDlg, IDC_METER, PBM_SETRANGE, 0, MAKELPARAM(0, lParam));
            SendDlgItemMessage(hDlg, IDC_METER, PBM_SETPOS, 0, 0);

            //proceed with the download
            MMNET mmNet;
            mmNet.discid = dwDiscID;
            mmNet.hwndCallback = hDlg; //call back to this guy
            mmNet.fForceNet = fSingle;
            mmNet.pData = (void*)GetCDData();
            if (fSingle)
            {
                mmNet.pData2 = (void*)pSingleTitle;
            }
            else
            {
                mmNet.pData2 = NULL;
            }
            SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(ID_CDUPDATE,0),(LPARAM)&mmNet);

            pOpts = GetCDOpt();
            
            if (!hLogo)
            {
                //get the path to the vendor logo file
                if (pOpts)
                {
                    LPCDOPTIONS pOptions = NULL;
                    pOptions = pOpts->GetCDOpts();

                    if (pOptions)
                    {
                        if (pOptions->pCurrentProvider!=NULL)
                        {
                            hLogo = OpenDIB(pOptions->pCurrentProvider->szProviderLogo,(HFILE)-1);
                            pCurrent = pOptions->pCurrentProvider;
                        } //end if current provider ok
                    } //end if poptions ok
                } //end if popts created
            }

            fReturnVal = TRUE; 
        }		
		break;

        case WM_PAINT :
        {
	        HDC hdc;
	        PAINTSTRUCT ps;

	        hdc = BeginPaint( hDlg, &ps );
    
            RECT progressrect, mainrect;
            GetWindowRect(GetDlgItem(hDlg,IDC_METER),&progressrect);
            GetWindowRect(hDlg,&mainrect);
            mainrect.top = mainrect.top + GetSystemMetrics(SM_CYCAPTION);

            //turn on animation if it is not visible
            if (!hwndAnimate)
            {
                hwndAnimate = Animate_Create(hDlg,
                                            IDI_ICON_ANI_DOWN,
                                            WS_CHILD|ACS_TRANSPARENT,
                                            hInst);

                //headers don't have Animate_OpenEx yet,
                //so just do the straight call
                SendMessage(hwndAnimate,ACM_OPEN,(WPARAM)hInst,
                        (LPARAM)MAKEINTRESOURCE(IDI_ICON_ANI_DOWN));

                //move to the top/left of the window, equidistant from top and progress indicator
                RECT anirect;
                GetWindowRect(hwndAnimate,&anirect);
                MoveWindow(hwndAnimate,
                     progressrect.left - mainrect.left - 3,
                     ((progressrect.top - mainrect.top)
                        - (anirect.bottom - anirect.top)) - LOGO_Y_OFFSET,
                     anirect.right - anirect.left,
                     anirect.bottom - anirect.top,
                     FALSE);

                Animate_Play(hwndAnimate,0,-1,-1);
                ShowWindow(hwndAnimate,SW_SHOW);

                //move "info" window                
                MoveWindow(GetDlgItem(hDlg,IDC_STATIC_INFO),
                          (progressrect.left - mainrect.left) + (anirect.right - anirect.left) + 3,
                          ((progressrect.top - mainrect.top)
                                - (anirect.bottom - anirect.top)) - LOGO_Y_OFFSET,
                          ((progressrect.right - mainrect.left) - VENDORLOGO_WIDTH - 3)
                                - ((progressrect.left - mainrect.left) + (anirect.right - anirect.left) + 3),
                          anirect.bottom - anirect.top,
                          FALSE);
            }

            if (hLogo)
            {
                DibBlt(hdc,
                        (progressrect.right - mainrect.left) - (VENDORLOGO_WIDTH + 5),
                        ((progressrect.top - mainrect.top)
                            - VENDORLOGO_HEIGHT) - LOGO_Y_OFFSET,
                        -1, 
                        -1, 
                        hLogo,
                        0,0,
                        SRCCOPY,0);
            }

	        EndPaint(hDlg,&ps);
            return 0;
        }
        break;

        //try to launch provider home page
        case WM_LBUTTONUP :
        {
            if ((hLogo) && (pCurrent))
            {
                RECT progressrect, mainrect;
                GetWindowRect(GetDlgItem(hDlg,IDC_METER),&progressrect);
                GetWindowRect(hDlg,&mainrect);
                mainrect.top = mainrect.top + GetSystemMetrics(SM_CYCAPTION);

                RECT logoRect;
                SetRect(&logoRect,
                        (progressrect.right - mainrect.left) - VENDORLOGO_WIDTH,
                        ((progressrect.top - mainrect.top)
                            - VENDORLOGO_HEIGHT) - LOGO_Y_OFFSET,
                        (progressrect.right - mainrect.left),
                        (progressrect.top - mainrect.top) - LOGO_Y_OFFSET);

                POINT pt;
                pt.x = LOWORD(lParam);
                pt.y = HIWORD(lParam);
        
                if (PtInRect(&logoRect,pt))
                {
                    OpenBrowserURL(pCurrent->szProviderHome);
                }
            }
        }
        break;

        case WM_DESTROY :
        {
            if (hwndAnimate)
            {
                DestroyWindow(hwndAnimate);
                hwndAnimate = NULL;
            }

            if (hLogo)
            {
                GlobalFree(hLogo);
                hLogo = NULL;
            }
        }
        break;

        case WM_NET_DB_UPDATE_BATCH :
        {
            LPCDOPT pOpts = GetCDOpt();
            if (pOpts)
            {
                pOpts->DownLoadCompletion(0,NULL);
            }
        }
        break;

        case WM_NET_DB_UPDATE_DISC :
        {
            LPCDOPT pOpts = GetCDOpt();
            if (pOpts)
            {
                pOpts->DiscChanged((LPCDUNIT)lParam);
            }
        }
        break;

        case WM_NET_CHANGEPROVIDER :
        {
            LPCDPROVIDER pProv = (LPCDPROVIDER)lParam;
            if (pProv!=NULL)
            {
                pCurrent = pProv;

                if (hLogo)
                {
                    GlobalFree(hLogo);
                    hLogo = NULL;
                }

                hLogo = OpenDIB(pCurrent->szProviderLogo,(HFILE)-1);
                InvalidateRect(hDlg,NULL,FALSE);
                UpdateWindow(hDlg);
            } //end if provider ok
        }
        break;

        case WM_NET_STATUS :
        {
            //until at least one title is downloaded, we need to do
            //something to entertain the user, so go ahead and show the
            //downloading text
            if (!fOneDownloaded)
            {
                TCHAR progstr[MAX_PATH];
                LoadString((HINSTANCE)wParam,(UINT)lParam,progstr,sizeof(progstr)/sizeof(TCHAR));
                SendDlgItemMessage(hDlg,IDC_STATIC_INFO,WM_SETTEXT,0,(LPARAM)progstr);
            }
        }
        break;

        case WM_NET_DONE :
        {
            fOneDownloaded = TRUE;

            if (lParam == (LPARAM)-1)
            {
                HandleBadServiceProvider(hDlg);
                EndDialog(hDlg,0);
                break;
            }

            if (lParam == 0)
            {
                EndDialog(hDlg,0);
                break;
            }
            else
            {
                MMNET mmNet;
                mmNet.discid = (DWORD)lParam;
                mmNet.hwndCallback = hDlg;
                mmNet.pData = (void*)GetCDData();
                mmNet.pData2 = NULL;
                mmNet.fForceNet = FALSE;
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(ID_CDUPDATE,0),(LPARAM)&mmNet);

                LPCDDATA pData = GetCDData();
                                
                //try to display that we found a title
                if (!pData)
                {
                    break;
                }
                
                //
                // Try to read in title from the options database
                //

                if (!pData->QueryTitle((DWORD)(lParam)))
                {
                    break;
                }

                //
                // We found an entry for this disc, so copy all the information
                // from the title database

                LPCDTITLE pCDTitle = NULL;

                if (FAILED(pData->LockTitle(&pCDTitle,(DWORD)(lParam))))
                {
                    break;
                }

                TCHAR foundstr[MAX_PATH];
                TCHAR formatstr[MAX_PATH];
                LoadString(hInst,IDS_FOUND,formatstr,sizeof(formatstr)/sizeof(TCHAR));
                wsprintf(foundstr,formatstr,pCDTitle->szTitle,pCDTitle->szArtist);
                SendDlgItemMessage(hDlg,IDC_STATIC_INFO,WM_SETTEXT,0,(LPARAM)foundstr);
            }
        }
        break;

        case WM_NET_INCMETER :
        {
            LRESULT dwPos = SendDlgItemMessage(hDlg,IDC_METER,PBM_GETPOS,0,0);
            SendDlgItemMessage(hDlg, IDC_METER, PBM_SETPOS, (WPARAM)++dwPos, 0);
        }
        break;

        case WM_NET_DB_FAILURE :
        {
            TCHAR szDBError[MAX_PATH];
            LoadString(hInst,IDS_DB_FAILURE,szDBError,sizeof(szDBError)/sizeof(TCHAR));
            MessageBox(hDlg,szDBError,szAppName,MB_ICONERROR|MB_OK);
        }
        break;

        case WM_NET_NET_FAILURE :
        {
            TCHAR szNetError[MAX_PATH];
            LoadString(hInst,IDS_NET_FAILURE,szNetError,sizeof(szNetError)/sizeof(TCHAR));
            MessageBox(hDlg,szNetError,szAppName,MB_ICONERROR|MB_OK);
        }
        break;

        case WM_COMMAND :
        {
            if (LOWORD(wParam) == IDCANCEL)
            {
                CancelDownload();
                EndDialog(hDlg,-1);
            }
        }
    }

    return fReturnVal;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandleDiscsNotFound
// Ask the user if they want to nuke unfound batched titles, or save them for another time
////////////////////////////////////////////////////////////////////////////////////////////
void HandleDiscsNotFound(HWND hwndParent)
{
    DWORD dwNumNotFound =  GetNumBatchedTitles();

    if (dwNumNotFound == 0)
    {
        return;
    }

    TCHAR szNotFound[MAX_PATH];

    if (dwNumNotFound > 1)
    {
        TCHAR szFormat[MAX_PATH];
        LoadString(hInst,IDS_NOTFOUND,szFormat,sizeof(szFormat)/sizeof(TCHAR));

        wsprintf(szNotFound,szFormat,dwNumNotFound);
    }
    else
    {
        LoadString(hInst,IDS_NOTFOUND1,szNotFound,sizeof(szNotFound)/sizeof(TCHAR));
    }

    int nAnswer = MessageBox(hwndParent,szNotFound,szAppName,MB_YESNO|MB_ICONQUESTION);

    if (nAnswer == IDNO)
    {
        LPCDDATA pData = GetCDData();
        if (pData)
        {
            pData->DumpBatch();
        }
    } //if said "no" to keeping batch
}

////////////////////////////////////////////////////////////////////////////////////////////
// * OptionsDownloadCallback
// Called from the options dialog to do batches or single downloads
////////////////////////////////////////////////////////////////////////////////////////////
DWORD CALLBACK OptionsDownloadCallback(LPCDTITLE pTitle, LPARAM lParam, HWND hwndParent)
{
    if (pTitle == NULL)
    {
        DWORD dwNumBatched = GetNumBatchedTitles();

        if (dwNumBatched > 0)
        {
            DialogBoxParam(hInst,MAKEINTRESOURCE(IDD_DOWNLOADPROGRESS),
                           hwndParent,ProgressDlgProc,dwNumBatched);
        }

        HandleDiscsNotFound(hwndParent);

        //refresh the number of batched titles
        return GetNumBatchedTitles();
    }
    else
    {
        pSingleTitle = pTitle;
        INT_PTR status = DialogBoxParam(hInst,MAKEINTRESOURCE(IDD_DOWNLOADPROGRESS),
                       hwndParent,ProgressDlgProc,0);

        //update the UI
        LPCDOPT pOpts = GetCDOpt();
        if (pOpts)
        {
            LPCDUNIT pUnit = pOpts->GetCDOpts()->pCDUnitList;

            while (pUnit!=NULL)
            {
                if (pUnit->dwTitleID == pSingleTitle->dwTitleID)
                {
                    pUnit->fDownLoading = FALSE;
                    pOpts->DiscChanged(pUnit);
                    break;
                }
                pUnit = pUnit->pNext;
            }
        }

        //if download wasn't canceled, check for disc id in database
        if (status != -1)
        {
            LPCDDATA pData = GetCDData();
            if (!pData->QueryTitle(pSingleTitle->dwTitleID))
            {
                TCHAR szNotFound[MAX_PATH];
                LoadString(hInst,IDS_TITLE_NOT_FOUND,szNotFound,sizeof(szNotFound)/sizeof(TCHAR));
                MessageBox(hwndParent,szNotFound,szAppName,MB_ICONINFORMATION|MB_OK);
            }
            else
            {
                if (pOpts)
                {
                    LPCDOPTIONS pCDOpts = pOpts->GetCDOpts();
                    pCDOpts->dwBatchedTitles = GetNumBatchedTitles();
                    pOpts->DownLoadCompletion(1,&(pSingleTitle->dwTitleID));
                } //end if OK to update batch number
            }
        }

        return 0;
    }
    
    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * OptionsApply
// Called from the options dialog when appy is hit, or by main UI when OK is hit
////////////////////////////////////////////////////////////////////////////////////////////
void CALLBACK OptionsApply(LPCDOPTIONS pCDOpts)
{
    if (!pCDOpts)
    {
        return;
    }
    
    //tell the CD player to rescan its settings ... 
    //most of the settings are for it
	IMMComponentAutomation* pAuto = NULL;
	HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	if ((SUCCEEDED(hr)) && (pAuto != NULL))
	{
		pAuto->OnAction(MMACTION_READSETTINGS,pCDOpts->pCDData);
        pAuto->Release();
    }

    LPCDUNIT pUnit = pCDOpts->pCDUnitList;
    LPCDDATA pData = GetCDData();

    while (pUnit!=NULL)
    {
        BOOL fRemove = FALSE;
        if (pData)
        {
            fRemove = !(pData->QueryTitle(pUnit->dwTitleID));
        }

        if ((pUnit->fChanged) || (fRemove))
        {
            if ((pUnit->dwTitleID != 0) && (pUnit->dwTitleID != (DWORD)-1))
            {
                //tell the cd player that a title was updated, perhaps the ones in the drive
                MMNET mmNet;
                mmNet.discid = pUnit->dwTitleID;
                mmNet.hwndCallback = hwndMain;
                mmNet.pData = (void*)GetCDData();
                mmNet.pData2 = NULL;
                mmNet.fForceNet = FALSE;
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(ID_CDUPDATE,0),(LPARAM)&mmNet);
            }
        }
        pUnit = pUnit->pNext;
    }

    SetWindowPos(hwndMain,
                 pCDOpts->pCDData->fTopMost ? HWND_TOPMOST : HWND_NOTOPMOST,
                 0,0,0,0,
                 SWP_NOMOVE|SWP_NOSIZE);

    //may have changed cd volume line
    if (InitCDVol(hwndMain, pCDOpts))
    {
        //when the volume line changes, we need to update the knob
        DWORD dwVol = GetVolume();
        CKnob* pKnob = GetKnobFromID(hwndMain,IDB_VOLUME);
        if (pKnob!=NULL)
        {
            pKnob->SetPosition(dwVol,TRUE);
        }

        SendMessage(GetDlgItem(hwndMain,IDB_MUTE),BM_SETSTATE,(WPARAM)GetMute(),0);
        SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_MUTE,0,GetMute());
    } //if vol line changed

    //may have turned on/off shell mode
    //we only care if the main UI is visible (i.e. not in shell-only mode)
    if (IsWindowVisible(hwndMain))
    {
        if (fShellMode != pCDOpts->pCDData->fTrayEnabled)
        {
            fShellMode = pCDOpts->pCDData->fTrayEnabled;
            if (fShellMode)
            {
                CreateShellIcon(hInst,hwndMain,pNodeCurrent,szAppName);
            }
            else
            {
                DestroyShellIcon();
            } //end shellmode
        } //end if shellmode changed in options
    } //end main ui visible
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandleMixerControlChange
// Updates UI when sndvol32 or other apps change our mixerline
////////////////////////////////////////////////////////////////////////////////////////////
void HandleMixerControlChange(DWORD dwLineID)
{
    if (dwLineID == mixerlinedetails.dwControlID)
    {
        DWORD dwVol = GetVolume();
	    CKnob* pKnob = GetKnobFromID(hwndMain,IDB_VOLUME);
        //possible to get this change before knob is up
        if (pKnob!=NULL)
        {
            pKnob->SetPosition(dwVol,TRUE);
        }
    }

    if (dwLineID == mutelinedetails.dwControlID)
    {
        SendMessage(GetDlgItem(hwndMain,IDB_MUTE),BM_SETSTATE,(WPARAM)GetMute(),0);
        SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_MUTE,0,GetMute());
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * ChildPaletteProc
// Updates child windows when palette changes
////////////////////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK ChildPaletteProc(HWND hwnd, LPARAM lParam)
{
    InvalidateRect(hwnd,NULL,FALSE);
    UpdateWindow(hwnd);
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandlePaletteChange
// Updates window when palette changes
////////////////////////////////////////////////////////////////////////////////////////////
int HandlePaletteChange()
{
    HDC hdc = GetDC(hwndMain);
    HPALETTE hOldPal = SelectPalette(hdc,hpalMain,FALSE);
    UINT i = RealizePalette(hdc);
    if (i)
    {
        //update child windows "by hand", since they are clipped
        EnumChildWindows(hwndMain,ChildPaletteProc,0);

        //update main window
        InvalidateRect(hwndMain,NULL,FALSE);
        UpdateWindow(hwndMain);
    }
    SelectPalette(hdc,hOldPal,TRUE);
    RealizePalette(hdc);
    ReleaseDC(hwndMain,hdc);
    return i;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandleDisplayChange
// Figures out if we need to recalc all bitmaps and does so ...
////////////////////////////////////////////////////////////////////////////////////////////
void HandleDisplayChange()
{
    int nOrgColorMode = g_nColorMode;

    DetermineColorMode();

    //only do anythhing if they changed modes
    if (g_nColorMode != nOrgColorMode)
    {
        //nuke all child windows
        for (int i = 0; i < NUM_BUTTONS; i++)
        {
            DestroyWindow(GetDlgItem(hwndMain,biButtons[i].id));
        }

        DestroyWindow(GetDlgItem(hwndMain,IDB_MUTE));
        DestroyWindow(GetDlgItem(hwndMain,IDB_VOLUME));
	    UninitMButtons();

        //nuke the bitmaps
	    GlobalFree(hbmpMain);
	    GlobalFree(hbmpMainRestore);
        GlobalFree(hbmpMainSmall);
        GlobalFree(hbmpMainNoBar);
	    DeleteObject(hpalMain);

    	hpalMain = SetPalette();

        //rebuild the bitmaps
        BuildFrameworkBitmaps();

        //recreate the windows
	    CreateButtonWindows(hwndMain);
	    CreateVolumeKnob(hwndMain);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * DoPaint
// Handles the WM_PAINT for the main UI, actually a multimon paint callback
////////////////////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK DoPaint(HMONITOR hmonitor, HDC hdc, LPRECT lprcMonitor, LPARAM lData)
{
	HWND hwnd = (HWND)lData;

    HPALETTE hpalOld = SelectPalette(hdc, hpalMain, FALSE);
	RealizePalette(hdc);

	BOOL fActiveWindow = FALSE;
    if (hwnd == GetForegroundWindow())
    {
	    fActiveWindow = TRUE;
    }

	DrawTitleBar(hdc, hwnd, fActiveWindow, TRUE);

    HANDLE hbmpView;
    BITMAP* pBM = &bmMain;
    switch (g_nViewMode)
    {
        case VIEW_MODE_NORMAL  :
        {
            hbmpView = hbmpMain; 
        }
        break;
    
        case VIEW_MODE_RESTORE :
        {
            hbmpView = hbmpMainRestore; 
            pBM = &bmMainRestore;
        }
        break;

        case VIEW_MODE_SMALL :
        {
            hbmpView = hbmpMainSmall;
            pBM = &bmMainSmall;
        }
        break;

        case VIEW_MODE_NOBAR :
        {
            hbmpView = hbmpMainNoBar;
            pBM = &bmMainNoBar;
        }
        break;
    }

    DibBlt(hdc,
        0,
        0,
        -1, 
        -1, 
        hbmpView,
        0,0,
        SRCCOPY,0);

    //reset the clipping region that was set in DrawTitleBar for reverse paint
    RECT rcParent;
    GetClientRect( hwnd, &rcParent );
    
    HRGN region = CreateRectRgn(rcParent.left,rcParent.top,rcParent.right,rcParent.bottom);

    SelectClipRgn(hdc, region);
    DeleteObject(region);

	SelectPalette(hdc, hpalOld, TRUE);
	RealizePalette(hdc);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetPlayButtonState
// Handles the play button's icon
////////////////////////////////////////////////////////////////////////////////////////////
void SetPlayButtonState(BOOL fIntroMode)
{
    CMButton* pButton = GetMButtonFromID(hwndMain,IDB_PLAY);

    if (pButton)
    {
        if ((fPlaying) && (fIntroMode))
        {
            pButton->SetIcon(IDI_MODE_INTRO);
            pButton->SetToolTipID(IDB_TT_INTRO);
            SetWindowText(pButton->GetHWND(),TEXT("2"));
        }

        if ((fPlaying) && (fIntro) && (!fIntroMode))
        {
            pButton->SetIcon(IDI_ICON_PAUSE);
            pButton->SetToolTipID(IDB_TT_PAUSE);
            SetWindowText(pButton->GetHWND(),TEXT("1"));
        }
    }

    fIntro = fIntroMode;

    //need to save playback mode at this point
    LPCDOPT pOpt = GetCDOpt();

    if(pOpt)
    {
        LPCDOPTIONS pOptions = pOpt->GetCDOpts();
        LPCDOPTDATA pOptionData = pOptions->pCDData;
        pOptionData->dwPlayMode = nCDMode;
        pOpt->UpdateRegistry();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetSearchURL
// Returns the standard IE "autosearch" URL
////////////////////////////////////////////////////////////////////////////////////////////
BOOL GetSearchURL(TCHAR* szSearchURL)
{
    BOOL fRet = FALSE;
    HKEY hKeySearch = NULL;

	long lResult = ::RegOpenKeyEx( HKEY_CURRENT_USER,
							  REG_KEY_SEARCHURL,
							  0, KEY_READ, &hKeySearch );

    if (lResult == ERROR_SUCCESS)
    {
        DWORD dwCbData = MAX_PATH;
        DWORD dwType = REG_SZ;
        lResult  = ::RegQueryValueEx( hKeySearch, TEXT(""), NULL,
						          &dwType, (LPBYTE)szSearchURL, &dwCbData );

        if (lResult == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }

        RegCloseKey(hKeySearch);
    }

    return (fRet);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * OpenVirtualCD
// Switches over to "Virtual CD mode" --
// basically a mode where we are playing back an ASX playlist of cached audio files
////////////////////////////////////////////////////////////////////////////////////////////
void OpenVirtualCD()
{
    //display dialog
    //if dialog successful, switch UI to msdxm.ocx mode
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandleCommand
// Handles all WM_COMMAND message for the main app
////////////////////////////////////////////////////////////////////////////////////////////
void HandleCommand(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    //handle system commands
    if ((LOWORD(wParam) >= SC_SIZE) && (LOWORD(wParam) <= SC_CONTEXTHELP))
    {
        SendMessage(hwnd,WM_SYSCOMMAND,(WPARAM)LOWORD(wParam),0);
        return;
    }

	switch (LOWORD(wParam))
	{
		case IDM_EXIT :
		{
            //if the shell icon is showing, then closing the app means hiding it
		    if (fShellMode)
            {
                ShowWindow(hwnd,SW_HIDE);
            }
            else
            {
                SendMessage(hwnd, WM_CLOSE, 0, 0);
            }
		    return;
		} //end exit
        break;

        case IDM_EXIT_SHELL :
        {
            //if the shell icon wanted us to shut down, but the main ui is visible, just
            //nuke shell mode
            if (IsWindowVisible(hwnd))
            {
                DestroyShellIcon();
                fShellMode = FALSE;
            }
            else
            {
                SendMessage(hwnd, WM_CLOSE, 0, 0);
            }
            return;
        }
        break;
	}

	IMMComponentAutomation* pAuto = NULL;
	HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	if ((SUCCEEDED(hr)) && (pAuto != NULL))
	{
        if ((LOWORD(wParam) >= IDM_TRACKLIST_BASE) && (LOWORD(wParam) < IDM_TRACKLIST_SHELL_BASE))
        {
            MMCHANGETRACK mmTrack;
            mmTrack.nNewTrack = LOWORD(wParam) - IDM_TRACKLIST_BASE;
            pAuto->OnAction(MMACTION_SETTRACK,&mmTrack);
        }

        if ((LOWORD(wParam) >= IDM_TRACKLIST_SHELL_BASE) && (LOWORD(wParam) < IDM_DISCLIST_BASE))
        {
            MMCHANGETRACK mmTrack;
            mmTrack.nNewTrack = LOWORD(wParam) - IDM_TRACKLIST_SHELL_BASE;
            pAuto->OnAction(MMACTION_SETTRACK,&mmTrack);

            //play it if we're not playing
            if (!fPlaying)
            {
                pAuto->OnAction(MMACTION_PLAY,NULL);
            }
        }

        if ((LOWORD(wParam) >= IDM_DISCLIST_BASE) && (LOWORD(wParam) < IDM_NET_UPDATE))
        {
            MMCHANGEDISC mmDisc;
            mmDisc.nNewDisc = LOWORD(wParam) - IDM_DISCLIST_BASE;
            pAuto->OnAction(MMACTION_SETDISC,&mmDisc);
        }

        if ((LOWORD(wParam) >= IDM_HOMEMENU_BASE) && (LOWORD(wParam) < IDM_NETMENU_BASE))
        {
            int i = LOWORD(wParam) - IDM_HOMEMENU_BASE;

            LPCDOPT pOpt = GetCDOpt();
            if( pOpt )
            {
                LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();

                LPCDPROVIDER pProviderList = pCDOpts->pProviderList;

                for (int x = 0; x < i; x++)
                {
                    pProviderList = pProviderList->pNext;
                }

                OpenBrowserURL(pProviderList->szProviderHome);
            }
        }

        if ((LOWORD(wParam) >= IDM_NETMENU_BASE) && (LOWORD(wParam) < IDM_OPTIONS))
        {
            MMMEDIAID mmMedia;
            mmMedia.nDrive = -1;
	        pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
    
            LPCDDATA pData = GetCDData();

            if (!pData)
            {
                return;
            }

            if (!pData->QueryTitle(mmMedia.dwMediaID))
            {
                return;
            }

            LPCDTITLE pCDTitle = NULL;
            hr =  pData->LockTitle(&pCDTitle,mmMedia.dwMediaID);

            if (FAILED(hr))
            {
                return;
            }

            LPCDMENU pCDMenu = &(pCDTitle->pMenuTable[LOWORD(wParam)-IDM_NETMENU_BASE]);

            if (pCDMenu->szMenuQuery)
            {
                OpenBrowserURL(pCDMenu->szMenuQuery);
            }

            pData->UnlockTitle(pCDTitle,FALSE);
        }

        switch (LOWORD(wParam))
        {
            case IDM_NET_UPDATE :
            {
                MMNET mmNet;
                mmNet.discid = 0; //use current disc
                mmNet.hwndCallback = hwnd;
                mmNet.pData = (void*)GetCDData();
                mmNet.pData2 = NULL;
                mmNet.fForceNet = FALSE;
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(ID_CDUPDATE,0),(LPARAM)&mmNet);
            }
            break;

            case IDM_NET_CANCEL :
            {
                CancelDownload();
            }
            break;

            case IDM_NET_ROLLINGSTONE_ARTIST :
            case IDM_NET_BILLBOARD_ALBUM :
            case IDM_NET_BILLBOARD_ARTIST :
            {            
	            MMMEDIAID mmMedia;
                mmMedia.nDrive = -1;
	            pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
    
                TCHAR szQuery[MAX_PATH*4];

                LPCDDATA pData = GetCDData();

                if (!pData)
                {
	                break;
                }

                if (!pData->QueryTitle(mmMedia.dwMediaID))
                {
                    return;
                }

                LPCDTITLE pCDTitle = NULL;
                hr =  pData->LockTitle(&pCDTitle,mmMedia.dwMediaID);

                if (FAILED(hr))
                {
                    break;
                }

                //normalize (canonize) the title and artist names
                TCHAR szArtist[CDSTR*3];
                TCHAR szTitle[CDSTR*3];
                NormalizeNameForURL(pCDTitle->szArtist,szArtist,sizeof(szArtist));
                NormalizeNameForURL(pCDTitle->szTitle,szTitle,sizeof(szTitle));

                pData->UnlockTitle(pCDTitle,FALSE);

                if ((LOWORD(wParam) == IDM_NET_BILLBOARD_ARTIST))
                {
                    TCHAR szFormat[MAX_PATH];
                    LoadString(hInst,IDS_BILLBOARD_FORMAT_ARTIST,szFormat,sizeof(szFormat)/sizeof(TCHAR));
                    wsprintf(szQuery,szFormat,szArtist);
                }
                else if ((LOWORD(wParam) == IDM_NET_ROLLINGSTONE_ARTIST))
                {
                    TCHAR szFormat[MAX_PATH];
                    LoadString(hInst,IDS_ROLLINGSTONE_FORMAT_ARTIST,szFormat,sizeof(szFormat)/sizeof(TCHAR));
                    wsprintf(szQuery,szFormat,szArtist);
                }
                else
                {
                    TCHAR szFormat[MAX_PATH];
                    LoadString(hInst,IDS_BILLBOARD_FORMAT_ALBUM,szFormat,sizeof(szFormat)/sizeof(TCHAR));
                    wsprintf(szQuery,szFormat,szArtist,szTitle);
                }

                OpenBrowserURL(szQuery);
            }
            break;

            case IDM_NET_CD :
            {
	            MMMEDIAID mmMedia;
                mmMedia.nDrive = -1;
	            pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
    
                TCHAR szQuery[MAX_PATH*4];

                LPCDDATA pData = GetCDData();

                if (!pData)
                {
	                break;
                }

                if (!pData->QueryTitle(mmMedia.dwMediaID))
                {
                    return;
                }

                LPCDTITLE pCDTitle = NULL;
                hr =  pData->LockTitle(&pCDTitle,mmMedia.dwMediaID);

                if (FAILED(hr))
                {
                    break;
                }

                TCHAR szSearchURL[MAX_PATH];
                if (!GetSearchURL(szSearchURL))
                {
                    break;
                }

                TCHAR szTemp[MAX_PATH*2];
                TCHAR szTemp2[MAX_PATH*2];

                wsprintf(szTemp,TEXT("%s %s"),pCDTitle->szArtist,pCDTitle->szTitle);
                NormalizeNameForURL(szTemp,szTemp2,sizeof(szTemp2));
                wsprintf(szQuery,szSearchURL,szTemp2);

                pData->UnlockTitle(pCDTitle,FALSE);

                OpenBrowserURL(szQuery);
            }
            break;

            case IDM_NET_BAND :
            {
	            MMMEDIAID mmMedia;
                mmMedia.nDrive = -1;
	            pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
    
                TCHAR szQuery[MAX_PATH*3];

                LPCDDATA pData = GetCDData();

                if (!pData)
                {
	                break;
                }

                if (!pData->QueryTitle(mmMedia.dwMediaID))
                {
                    return;
                }

                LPCDTITLE pCDTitle = NULL;
                hr =  pData->LockTitle(&pCDTitle,mmMedia.dwMediaID);

                if (FAILED(hr))
                {
                    break;
                }

                TCHAR szSearchURL[MAX_PATH];
                if (!GetSearchURL(szSearchURL))
                {
                    break;
                }

                TCHAR szArtist[CDSTR*3];
                NormalizeNameForURL(pCDTitle->szArtist,szArtist,sizeof(szArtist));

                wsprintf(szQuery,szSearchURL,szArtist);

                pData->UnlockTitle(pCDTitle,FALSE);

                OpenBrowserURL(szQuery);
            }
            break;

            case IDM_MODE_NORMAL :
            {
                nCDMode = LOWORD(wParam);
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(IDM_OPTIONS_NORMAL,0),(LPARAM)0);
                InvalidateRect(hwndCurrentComp,NULL,FALSE);
                UpdateWindow(hwndCurrentComp);
	            CMButton* pButton = GetMButtonFromID(hwnd,IDB_MODE);
                if (pButton)
                {
	                pButton->SetIcon(IDI_MODE_NORMAL);
                }
                SetPlayButtonState(FALSE);
            }
            break;

            case IDM_MODE_REPEATONE :
            {
                nCDMode = LOWORD(wParam);
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(IDM_OPTIONS_REPEAT_SINGLE,0),(LPARAM)0);
                InvalidateRect(hwndCurrentComp,NULL,FALSE);
                UpdateWindow(hwndCurrentComp);
	            CMButton* pButton = GetMButtonFromID(hwnd,IDB_MODE);
                if (pButton)
                {
	                pButton->SetIcon(IDI_MODE_REPEATONE);
                }
                SetPlayButtonState(FALSE);
            }
            break;

            case IDM_MODE_REPEATALL :
            {
                nCDMode = LOWORD(wParam);
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(IDM_OPTIONS_CONTINUOUS,0),(LPARAM)0);
                InvalidateRect(hwndCurrentComp,NULL,FALSE);
                UpdateWindow(hwndCurrentComp);
	            CMButton* pButton = GetMButtonFromID(hwnd,IDB_MODE);
                if (pButton)
                {
	                pButton->SetIcon(IDI_MODE_REPEATALL);
                }
                SetPlayButtonState(FALSE);
            }
            break;

            case IDM_MODE_RANDOM :
            {
                nCDMode = LOWORD(wParam);
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(IDM_OPTIONS_RANDOM,0),(LPARAM)0);
                InvalidateRect(hwndCurrentComp,NULL,FALSE);
                UpdateWindow(hwndCurrentComp);
	            CMButton* pButton = GetMButtonFromID(hwnd,IDB_MODE);
                if (pButton)
                {
    	            pButton->SetIcon(IDI_MODE_RANDOM);
                }
                SetPlayButtonState(FALSE);
            }
            break;

            case IDM_MODE_INTRO :
            {
                nCDMode = LOWORD(wParam);
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(IDM_OPTIONS_INTRO,0),(LPARAM)0);
                InvalidateRect(hwndCurrentComp,NULL,FALSE);
                UpdateWindow(hwndCurrentComp);
	            CMButton* pButton = GetMButtonFromID(hwnd,IDB_MODE);
                if (pButton)
                {
	                pButton->SetIcon(IDI_MODE_INTRO);
                }
                SetPlayButtonState(TRUE);
            }
            break;

            case IDM_HELP :
            {
                char chDst[MAX_PATH];
                WideCharToMultiByte(CP_ACP, 0, HELPFILENAME, 
									            -1, chDst, MAX_PATH, NULL, NULL); 
	            HtmlHelpA(GetDesktopWindow(), chDst, HH_DISPLAY_TOPIC, 0);
            }
            break;

            case IDM_ABOUT :
            {
                ShellAbout( hwnd, szAppName, TEXT(""), LoadIcon(hInst, MAKEINTRESOURCE(IDI_MMFW)));
            }
            break;

            case IDM_NORMAL :
            {
                SetNormalMode(hwnd);
            }
            break;

            case IDM_TINY :
            {
                SetRestoredMode(hwnd);
            }
            break;

            case IDB_MUTE :
            {
                //fix for bug 220 ... if mute button is set from "SetMute" during a button
                //click, it will get ANOTHER button click when it's focus is killed, so we
                //need to make sure it stays in the right state at the right time
                if (GetFocus()==GetDlgItem(hwndMain,IDB_MUTE))
                {
                    SetMute();
                }
                else
                {
                    SendMessage(GetDlgItem(hwndMain,IDB_MUTE),BM_SETSTATE,(WPARAM)GetMute(),0);
                }
            }
            break;

            case IDM_OPENVIRTUALCD :
            {
                OpenVirtualCD();
            }
            break;

            case IDM_PLAYLIST :         
            case IDM_OPTIONS :
            {
                CDOPT_PAGE  nStartSheet = CDOPT_PAGE_PLAY;

                if (LOWORD(wParam) == IDM_PLAYLIST)
                {
                    nStartSheet = CDOPT_PAGE_PLAYLIST;
                }

                LPCDOPT pOpt = GetCDOpt();
                if( pOpt )
                {
                    LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();

                    LPCDDATA pData = GetCDData();

                    if( pData )
                    {
                        //go through and set media ids for each drive
                        LPCDUNIT pUnit = pCDOpts->pCDUnitList;
                        int nCurrDrive = 0;
    
                        while (pUnit!=NULL)
                        {
			                MMMEDIAID mmMedia;
                            mmMedia.nDrive = nCurrDrive;
			                pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);

                            MMNETQUERY mmNetQuery;
                            mmNetQuery.nDrive = nCurrDrive++;
                            mmNetQuery.szNetQuery = pUnit->szNetQuery;
                            pAuto->OnAction(MMACTION_GETNETQUERY,&mmNetQuery);

                            pUnit->dwTitleID = mmMedia.dwMediaID;
                            pUnit->dwNumTracks = mmMedia.dwNumTracks;
                            if (IsDownloading())
                            {
                                pUnit->fDownLoading = TRUE;
                            }
                            else
                            {
                                pUnit->fDownLoading = FALSE;
                            }
                            pUnit = pUnit->pNext;
                        }

                        //set the number of batched titles and the callback functions
                        pCDOpts->dwBatchedTitles = GetNumBatchedTitles();
                        pCDOpts->pfnDownloadTitle = OptionsDownloadCallback;
                        pCDOpts->pfnOptionsCallback = OptionsApply;

                        fOptionsDlgUp = TRUE;
                        HRESULT hr = pOpt->OptionsDialog(hwnd, pData, nStartSheet);
                        fOptionsDlgUp = FALSE;

                        if (hr == S_OK) //don't use succeeded macro here, S_FALSE is also valid
                        {
                            OptionsApply(pCDOpts);
                        }
                    } //if pdata
                }
            }
            break;

            case IDB_PLAY :
            {
	            if (fPlaying)
	            {
                    if (fIntro)
                    {
                        //set to normal mode
                        SendMessage(hwnd,WM_COMMAND,MAKEWPARAM(IDM_MODE_NORMAL,0),0);
                        //set button back to regular icon
                        CMButton* pButton = GetMButtonFromID(hwnd,IDB_PLAY);
                        if (pButton)
                        {
                            pButton->SetIcon(IDI_ICON_PAUSE);
                            pButton->SetToolTipID(IDB_TT_PAUSE);
                            SetWindowText(pButton->GetHWND(),TEXT("1"));
                        }
                    }
                    else
                    {
		                pAuto->OnAction(MMACTION_PAUSE,NULL);
                    }
	            }
	            else
	            {
		            pAuto->OnAction(MMACTION_PLAY,NULL);
	            }
            }
            break;

            case IDB_EJECT :
            {
	            pAuto->OnAction(MMACTION_UNLOADMEDIA,NULL);
            }
            break;

            case IDB_FFWD :
            {
	            pAuto->OnAction(MMACTION_FFWD,NULL);
            }
            break;

            case IDB_NEXTTRACK :
            {
                pAuto->OnAction(MMACTION_NEXTTRACK,NULL);
            }
            break;

            case IDB_PREVTRACK :
            {
	            pAuto->OnAction(MMACTION_PREVTRACK,NULL);
            }
            break;

            case IDB_REW :
            {
	            pAuto->OnAction(MMACTION_REWIND,NULL);
            }
            break;

            case IDB_STOP :
            {
	            pAuto->OnAction(MMACTION_STOP,NULL);
            }
            break;

            case IDB_MINIMIZE :
            {
                ShowWindow(hwnd,SW_MINIMIZE);
                //see \\redrum\slmro\proj\win\src\CORE\user\mssyscmd.c
                PlaySound(TEXT("Minimize"),NULL,SND_ALIAS|SND_NODEFAULT|SND_ASYNC|SND_NOWAIT|SND_NOSTOP);
            }
            break;

            case IDB_SET_NORMAL_MODE :
            {
                SetNormalMode(hwnd);
            }
            break;

            case IDB_SET_TINY_MODE :
            {
                SetRestoredMode(hwnd);
            }
            break;

            case IDB_CLOSE :
            {
                //if the shell icon is showing, then closing the app means hiding it
		        if (fShellMode)
                {
                    ShowWindow(hwnd,SW_HIDE);
                }
                else
                {
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                }
            }
            break;
        }

        if (pAuto)
        {
            pAuto->Release();
	        pAuto = NULL;
        }
	}
}

////////////////////////
// Handles device change message from WinMM, All we need to do here is close any open
// Mixer Handles, re-compute mixer ID and control ID's and re-Open appropriately
//
void WinMMDeviceChangeHandler(HWND hWnd)
{
    LPCDOPT pOpt = GetCDOpt();

    if (hmix)                           // Close open mixer handle
    {
        mixerClose((HMIXER)hmix);
        hmix = NULL;
    }

    if(pOpt)
    {
        LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();

        pOpt->MMDeviceChanged();

        InitCDVol(hwndMain,pCDOpts);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * HandlePowerBroadcast
// On VxD drivers, you can't "suspend" with an open mixer device.  Bug 1132.
//
// If lParam == 1, this is a device remove
//
////////////////////////////////////////////////////////////////////////////////////////////
BOOL HandlePowerBroadcast(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = TRUE;
    
    switch (wParam)
    {
        case PBT_APMQUERYSTANDBY:
	    case PBT_APMQUERYSUSPEND:
        {
            if (hmix)
	        {
    		    mixerClose((HMIXER)hmix);
                hmix = NULL;
	        }
        } //end case power off
	    break;

        case PBT_APMSTANDBY :
        case PBT_APMSUSPEND :
        {
            //actually suspending, go ahead and stop the cd
            if (fPlaying)
            {
	            IMMComponentAutomation* pAuto = NULL;
                if (pNodeCurrent)
                {
	                HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	                if ((SUCCEEDED(hr)) && (pAuto != NULL))
	                {
                        //at this point, we can actually stop the CD
                        pAuto->OnAction(MMACTION_STOP,NULL);        
                        //release the automation object        
                        pAuto->Release();
                    }
                } //end if pnodecurrent
            } //end if playing
        }
        break;

	    case PBT_APMQUERYSTANDBYFAILED:
        case PBT_APMRESUMESTANDBY:
        case PBT_APMQUERYSUSPENDFAILED:
	    case PBT_APMRESUMESUSPEND:
        {
            WinMMDeviceChangeHandler(hWnd);
        } //end case power on
	    break;
    } //end switch

    return fRet;
}



////////////////////////////////////////////////////////////////////////////////////////////
// * HandleSysMenuInit
// Make sure the system menu only shows the correct choices
////////////////////////////////////////////////////////////////////////////////////////////
void HandleSysMenuInit(HWND hwnd, HMENU hmenu)
{
    //always gray out
    EnableMenuItem(hmenu,SC_SIZE,    MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenu,SC_MAXIMIZE,MF_BYCOMMAND|MF_GRAYED);

    //always enable
    EnableMenuItem(hmenu,SC_CLOSE,MF_BYCOMMAND|MF_ENABLED);

    //enable or gray based on minimize state
    if (IsIconic(hwnd))
    {
        EnableMenuItem(hmenu,SC_RESTORE, MF_BYCOMMAND|MF_ENABLED);
        EnableMenuItem(hmenu,SC_MOVE,    MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hmenu,SC_MINIMIZE,MF_BYCOMMAND|MF_GRAYED);
    }
    else
    {
        EnableMenuItem(hmenu,SC_RESTORE, MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hmenu,SC_MOVE,    MF_BYCOMMAND|MF_ENABLED);
        EnableMenuItem(hmenu,SC_MINIMIZE,MF_BYCOMMAND|MF_ENABLED);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SysMenuTimerProc
// Make sure the system menu only shows on a single click
////////////////////////////////////////////////////////////////////////////////////////////
void CALLBACK SysMenuTimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    KillTimer(hwnd,idEvent);

    POINTS pts;
    RECT rect;

    //make sure the menu shows up in a good-looking place
    GetClientRect(hwnd,&rect);
    rect.left = SYSMENU_XOFFSET;
    rect.right = SYSMENU_XOFFSET + SYSMENU_WIDTH;
    rect.bottom = rect.top + TITLEBAR_HEIGHT +
                    (g_nViewMode == VIEW_MODE_NORMAL ? TITLEBAR_YOFFSET_LARGE :
                                                       TITLEBAR_YOFFSET_SMALL);

    ClientToScreen(hwnd,(LPPOINT)&rect);
    ClientToScreen(hwnd,((LPPOINT)&rect)+1);
    pts.x = (short)rect.left;
    pts.y = (short)rect.bottom;

    HMENU hSysMenu = GetSystemMenu(hwnd,FALSE);

    TPMPARAMS tpm;
    tpm.cbSize = sizeof(tpm);
    memcpy(&(tpm.rcExclude),&rect,sizeof(RECT));
    TrackPopupMenuEx(hSysMenu,0,pts.x,pts.y,hwnd,&tpm);
}

BOOL HandleKeyboardAppCommand(HWND hwnd, short cmd)
{
    BOOL fHandled = FALSE;

    switch (cmd)
    {
        case APPCOMMAND_VOLUME_MUTE :
        {
            SetMute();
            fHandled = TRUE;
        }
        break;

        case APPCOMMAND_VOLUME_DOWN :
        {
            SendMessage(GetDlgItem(hwnd,IDB_VOLUME),WM_KEYDOWN,VK_DOWN,0);
            fHandled = TRUE;
        }
        break;

        case APPCOMMAND_VOLUME_UP :
        {
            SendMessage(GetDlgItem(hwnd,IDB_VOLUME),WM_KEYDOWN,VK_UP,0);
            fHandled = TRUE;
        }
        break;

        case APPCOMMAND_MEDIA_NEXTTRACK :
        {
            SendMessage(hwnd,WM_COMMAND,MAKEWPARAM(IDB_NEXTTRACK,0),(LPARAM)0);
            fHandled = TRUE;
        }
        break;

        case APPCOMMAND_MEDIA_PREVIOUSTRACK :
        {
            SendMessage(hwnd,WM_COMMAND,MAKEWPARAM(IDB_PREVTRACK,0),(LPARAM)0);
            fHandled = TRUE;
        }
        break;

        case APPCOMMAND_MEDIA_STOP :
        {
            SendMessage(hwnd,WM_COMMAND,MAKEWPARAM(IDB_STOP,0),(LPARAM)0);
            fHandled = TRUE;
        }
        break;

        case APPCOMMAND_MEDIA_PLAY_PAUSE :
        {
            SendMessage(hwnd,WM_COMMAND,MAKEWPARAM(IDB_PLAY,0),(LPARAM)0);
            fHandled = TRUE;
        }
        break;

        default:
        {
            fHandled = FALSE;
        }
        break;
    } //end switch

    return fHandled;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * MainWndProc
// Main window's message switcher
////////////////////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch (iMsg)
    {
	    //we're being created, start up
        case WM_CREATE :
	    {
            hwndMain = hwnd;

            g_uTaskbarRestart = RegisterWindowMessage(TEXT("TaskbarCreated"));
            giVolDevChange    = RegisterWindowMessage(TEXT("winmm_devicechange"));

            CreateToolTips(hwnd);
	        InitComponents(hwnd);
	        CreateButtonWindows(hwnd);
	        CreateVolumeKnob(hwnd);

            //if no disc in player, gray out the track button
	        IMMComponentAutomation* pAuto = NULL;
	        HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	        if ((SUCCEEDED(hr)) && (pAuto != NULL))
	        {
                MMMEDIAID mmMedia;
                mmMedia.nDrive = -1;
                pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
                pAuto->Release();
                if (mmMedia.dwMediaID == 0)
                {
                    EnableWindow(GetDlgItem(hwnd,IDB_TRACK),FALSE);
                }
            }
	    }
        break;

        case SHELLMESSAGE_CDICON :
        {
            return (ShellIconHandeMessage(lParam));
        }
        break;

        //called from sndvol32 or other apps that change mixer
        case MM_MIXM_CONTROL_CHANGE :
        {
            HandleMixerControlChange((DWORD)lParam);
        }
        break;

        //palette changed
        case WM_PALETTECHANGED :
        case WM_QUERYNEWPALETTE :
	    {
            return (HandlePaletteChange());
	    }
	    break;

        //autoplay copied command line when second instance running
        case WM_COPYDATA :
        {
            SendMessage(hwndCurrentComp,WM_COPYDATA,wParam,lParam);
        }
        break;

        //new keyboard interface
        case WM_APPCOMMAND :
        {
            return HandleKeyboardAppCommand(hwnd,GET_APPCOMMAND_LPARAM(lParam));
        }
        break;
	    
	    //activation/deactivation -- need to repaint title
        case WM_ACTIVATE :
        {
            HDC hdc = GetDC(hwnd);
            DrawTitleBar(hdc,hwnd,LOWORD(wParam),FALSE);
	        ReleaseDC(hwnd,hdc);
        }
        break;

        //check for switch to tiny mode
        case WM_NCLBUTTONDBLCLK :
        case WM_LBUTTONDBLCLK :
        {
            KillTimer(hwnd,SYSTIMERID);

            if (((int)wParam == HTSYSMENU) && (iMsg == WM_NCLBUTTONDBLCLK))
            {
                break; //don't allow this on a sys menu double-click
            }
            
            switch (g_nViewMode)
            {
                case VIEW_MODE_NORMAL  : SetNoBarMode(hwnd);    break;
                case VIEW_MODE_NOBAR   : SetNormalMode(hwnd);   break;
                case VIEW_MODE_RESTORE : SetSmallMode(hwnd);    break;
                case VIEW_MODE_SMALL   : SetRestoredMode(hwnd); break;
            } //end switch on view mode
        }
        break;

        //handle left click on system menu
        //need to set timer to handle double-click
        case WM_NCLBUTTONDOWN :
        {
            if ((int)wParam == HTSYSMENU)
            {
                SetTimer(hwnd,SYSTIMERID,GetDoubleClickTime()+100,(TIMERPROC)SysMenuTimerProc);
            }
        }
        break;

        //handle right click on system menu or caption
        //no need for timer on double-click
        case WM_NCRBUTTONDOWN :
        {
            if (((int)wParam == HTCAPTION) || ((int)wParam == HTSYSMENU))
            {
                POINTS pts = MAKEPOINTS(lParam);
                HMENU hSysMenu = GetSystemMenu(hwnd,FALSE);
                TrackPopupMenu(hSysMenu,0,pts.x,pts.y,0,hwnd,NULL);
            }
        }
        break;

        case WM_INITMENU :
        {
            HandleSysMenuInit(hwnd,(HMENU)wParam);
        }
        break;

        case WM_POWERBROADCAST:
        {
            return (HandlePowerBroadcast(hwnd,wParam,0));
        }
        break;

	    //check for mouse in title bar
        case WM_NCHITTEST :
        {
            return (OnNCHitTest(hwnd, LOWORD(lParam), HIWORD(lParam),FALSE));
        }
        break;

        case WM_NET_DB_UPDATE_BATCH :
        {
            LPCDOPT pOpts = GetCDOpt();
            if (pOpts)
            {
                pOpts->DownLoadCompletion(0,NULL);
            }
        }
        break;

        case WM_NET_DB_UPDATE_DISC :
        {
            LPCDOPT pOpts = GetCDOpt();
            if (pOpts)
            {
                pOpts->DiscChanged((LPCDUNIT)lParam);
            }
        }
        break;

        //download finished on a disc
        case WM_NET_INCMETER : //download finished on discid <lparam>
        {
            //lparam == -1 means the provider failed the validation check
            if (lParam == (LPARAM)-1)
            {
                SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_DOWNLOAD,0,(LPARAM)FALSE);
                HandleBadServiceProvider(hwnd);
                break;
            }

            if (lParam != 0) 
            {
                MMNET mmNet;
                mmNet.discid = (DWORD)(lParam);
                mmNet.hwndCallback = hwnd;
                mmNet.pData = (void*)GetCDData();
                mmNet.pData2 = NULL;
                mmNet.fForceNet = FALSE;
                SendMessage(hwndCurrentComp,WM_COMMAND,MAKEWPARAM(ID_CDUPDATE,0),(LPARAM)&mmNet);

                LPCDOPT pOpt = GetCDOpt();
                if (pOpt)
                {
                    LPCDUNIT pUnit = pOpt->GetCDOpts()->pCDUnitList;
                    int nCurrDrive = 0;
                
                    while (pUnit!=NULL)
                    {
                        if (pUnit->dwTitleID == mmNet.discid)
                        {
                            pUnit->fDownLoading = FALSE;
                            break;
                        }
                        pUnit = pUnit->pNext;
                    }
                    
                    LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();
                    pCDOpts->dwBatchedTitles = GetNumBatchedTitles();

                    pOpt->DownLoadCompletion(1,&(mmNet.discid));
                }

                //put up a message box if the title still isn't available
	            IMMComponentAutomation* pAuto = NULL;
	            HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	            if ((SUCCEEDED(hr)) && (pAuto != NULL))
	            {
                    MMMEDIAID mmMedia;
                    mmMedia.nDrive = -1;
                    pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
                    pAuto->Release();

                    if (mmNet.discid == mmMedia.dwMediaID)
                    {
                        LPCDDATA pData = GetCDData();
                        if (!pData->QueryTitle(mmNet.discid))
                        {
                            TCHAR szNotFound[MAX_PATH];
                            LoadString(hInst,IDS_TITLE_NOT_FOUND,szNotFound,sizeof(szNotFound)/sizeof(TCHAR));
                            MessageBox(hwnd,szNotFound,szAppName,MB_ICONINFORMATION|MB_OK);
                        }
                    } //end if disc is same as what is showing in player
                } //end if pauto ok
            }
        }
        break;

        case WM_NET_DB_FAILURE :
        {
            TCHAR szDBError[MAX_PATH];
            LoadString(hInst,IDS_DB_FAILURE,szDBError,sizeof(szDBError)/sizeof(TCHAR));
            MessageBox(hwnd,szDBError,szAppName,MB_ICONERROR|MB_OK);
        }
        break;

        case WM_NET_NET_FAILURE :
        {
            TCHAR szNetError[MAX_PATH];
            LoadString(hInst,IDS_NET_FAILURE,szNetError,sizeof(szNetError)/sizeof(TCHAR));
            MessageBox(hwnd,szNetError,szAppName,MB_ICONERROR|MB_OK);
        }
        break;

        case WM_NET_DONE :
        {
            if (lParam == 0)
            {
                //if lparam is 0, download is done ... nuke the animation
                SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_DOWNLOAD,0,(LPARAM)FALSE);
            }
        }
        break;

        //Network status callback
        case WM_NET_STATUS : //download information string in <lparam>
        {
            //we basically just ignore the string messages and start
            //the animation if one isn't going already
            SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_DOWNLOAD,0,(LPARAM)TRUE);
        }
        break;

        case WM_NET_CHANGEPROVIDER :
        {
            SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_NET_CHANGEPROVIDER,wParam,lParam);
        }
        break;

        //change the title bar contents
        case WM_SIZE :
        {
            if (wParam != SIZE_MINIMIZED)
            {
                TCHAR szText[MAX_PATH];
                _tcscpy(szText,szAppName);
                if (pNodeCurrent)
                {            
                    if (_tcslen(pNodeCurrent->szTitle) > 0)
                    {
                        wsprintf(szText,TEXT("%s - %s"),pNodeCurrent->szTitle,szAppName);
                    }
                }
            
                SetWindowText(hwnd,szText);
            }
        }
        break;

        //notification that the current disc drive is different
        case WM_DISCCHANGED :
        {
            LPCDOPT pOpt = GetCDOpt();
            if( pOpt )
            {
                LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();
                if (InitCDVol(hwnd,pCDOpts))
                {
                    DWORD dwVol = GetVolume();
                    CKnob* pKnob = GetKnobFromID(hwndMain,IDB_VOLUME);
                    if (pKnob!=NULL)
                    {
                        pKnob->SetPosition(dwVol,(BOOL)lParam);
                    }

                    SendMessage(GetDlgItem(hwnd,IDB_MUTE),BM_SETSTATE,(WPARAM)GetMute(),0);
                    SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_MUTE,0,GetMute());
                }
            } //end if popt

            //if no disc in player, gray out the track button
	        IMMComponentAutomation* pAuto = NULL;
	        HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	        if ((SUCCEEDED(hr)) && (pAuto != NULL))
	        {
                MMMEDIAID mmMedia;
                mmMedia.nDrive = -1;
                pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
                pAuto->Release();
                if (mmMedia.dwMediaID == 0)
                {
                    EnableWindow(GetDlgItem(hwnd,IDB_TRACK),FALSE);
                }
            }
        }
        break;
    
	    case WM_SYSCOLORCHANGE :
        case WM_DISPLAYCHANGE :
        {
            //user may have turned on high-contrast mode,
            //or changed the display depth.  Either way,
            //it may be time to change bitmaps
            HandleDisplayChange();
        }
        break;
        
        case WM_ERASEBKGND :
        {
            EnumDisplayMonitors((HDC)wParam, NULL, DoPaint, (LPARAM)hwnd);
            return TRUE;
        }
        break;

        case WM_SETCURSOR :
        {
            if ((HWND)wParam == GetDlgItem(hwnd,IDB_MUTE))
            {
                if (hCursorMute)
                {
                    SetCursor(hCursorMute);
                    return TRUE;
                }
            }
        }
        break;

        case WM_HELP :
        {
            char chDst[MAX_PATH];
            WideCharToMultiByte(CP_ACP, 0, HELPFILENAME, 
								            -1, chDst, MAX_PATH, NULL, NULL); 
            HtmlHelpA(GetDesktopWindow(), chDst, HH_DISPLAY_TOPIC, 0);
        }
        break;

        case WM_CLOSE :
        {
            if ((fShellMode) && IsWindowVisible(hwnd))
            {
                ShowWindow(hwnd,SW_HIDE);
                return 0;
            }
        }
        break;

        case WM_PAINT :
	    {
            //multi-mon paint
	        HDC hdc;
	        PAINTSTRUCT ps;
	        hdc = BeginPaint( hwnd, &ps );
            EnumDisplayMonitors(hdc, NULL, DoPaint, (LPARAM)hwnd);
            EndPaint(hwnd, &ps);
            return 0;
	    }
        break;

        //default push putton handler
        case DM_SETDEFID :
        {
            wDefButtonID = (WORD)wParam;
        }
        break;

        case DM_GETDEFID :
        {
            return (MAKELRESULT(wDefButtonID,DC_HASDEFID));
        }
        break;

        //custom menu accel handler
        case WM_MENUCHAR :
        {
            if (g_pMenu)
            {
                return (g_pMenu->MenuChar((TCHAR)LOWORD(wParam),(UINT)HIWORD(wParam),(HMENU)lParam));
            }
        }
        break;
        
        //custom menu handler
        case WM_MEASUREITEM :
        {
	        if (lParam == 0) return (0);

            if (g_pMenu)
            {
                g_pMenu->MeasureItem(hwnd,(LPMEASUREITEMSTRUCT)lParam);
            }
        }
        break;

        //custom menu/button handler
	    case WM_DRAWITEM :
	    {
	        if (lParam == 0) return (0);

            if (wParam == 0)
            {
                if (g_pMenu)
                {
                    g_pMenu->DrawItem(hwnd,(LPDRAWITEMSTRUCT)lParam);
                    return (1);
                }
            }
            else
            {
    	        DrawButton((UINT)wParam,(LPDRAWITEMSTRUCT)lParam);
                return (1);
            }

	        return (0);
	    }

        //notify is either from tool tip or volume knob	    
        case WM_NOTIFY :
	    {
            if ((((LPNMHDR)lParam)->code) == TTN_NEEDTEXT)
            {
                OnToolTipNotify(lParam);
            }
            else
            {
	            if ((int)wParam == IDB_VOLUME)
	            {
		            CKnob* pKnob = GetKnobFromID(hwnd,IDB_VOLUME);

		            DWORD dwNewVol = pKnob->GetPosition();

		            DrawVolume(pKnob->GetPosition());

		            if ((((LPNMHDR)lParam)->code) == TRUE)
                    {
                        SetVolume(dwNewVol);
                    }

		            //reset timer to repaint client area
		            KillTimer(hwnd,VOLUME_PERSIST_TIMER_EVENT);
		            SetTimer(hwnd,VOLUME_PERSIST_TIMER_EVENT,VOLUME_PERSIST_TIMER_RATE,(TIMERPROC)VolPersistTimerProc);
	            } //end if knob
            } //end else
	    }
	    break;
	    
	    //menu going away
        case WM_EXITMENULOOP :
        {
            BlockMenu(hwnd);
        }
        break;
        
        //command message
        case WM_COMMAND :
	    {
            HandleCommand(hwnd, iMsg, wParam, lParam);
	    }
	    break;

	    case WM_DEVICECHANGE :
	    {
			//if plug-and-play sends this, pass it along to the component
        	PDEV_BROADCAST_DEVICEINTERFACE bdi = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;
			PDEV_BROADCAST_HANDLE bh = (PDEV_BROADCAST_HANDLE)lParam;
	
			//If we have an handle on the device then we get a DEV_BROADCAST_HDR structure as the lParam.
			//Or else it means that we have registered for the general audio category KSCATEGORY_AUDIO.
			if(bUseHandle)
			{
				if(!DeviceEventContext || !bh ||
				bh->dbch_devicetype != DBT_DEVTYP_HANDLE)
				{
					return (SendMessage(hwndCurrentComp,WM_DEVICECHANGE,wParam,lParam));
				}
			}
			else if (!DeviceEventContext || !bdi ||
			bdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE ||
			!IsEqualGUID(KSCATEGORY_AUDIO, bdi->dbcc_classguid) ||	
			!(*bdi->dbcc_name)
			)
			{
				return (SendMessage(hwndCurrentComp,WM_DEVICECHANGE,wParam,lParam));
			}
			
			//Handle device changes to the mixer device.
			switch(wParam)
			{
				//send "1" in lparam to indicate that this is a device remove and not a power request

				case DBT_DEVICEQUERYREMOVE:
                    HandlePowerBroadcast(hwndMain, PBT_APMQUERYSUSPEND, (LPARAM)1);
					break;
				
			    case DBT_DEVICEQUERYREMOVEFAILED:
					HandlePowerBroadcast(hwndMain, PBT_APMQUERYSUSPENDFAILED, (LPARAM)1);
					break;
	    
				default:
					break;	
			}
	    }


        case WM_WININICHANGE :
        {
	        return (SendMessage(hwndCurrentComp,WM_WININICHANGE,wParam,lParam));
        }

	    //we're done
        case WM_ENDSESSION :
        case WM_DESTROY :
	    {
            if ((iMsg == WM_ENDSESSION) && (!wParam))
            {
                return 0;
            }

            if (hMutex)
            {
                ReleaseMutex(hMutex);
                CloseHandle(hMutex);
                hMutex = NULL;
            }

            //if playing and we don't want to be, stop it
            //BE VERY PARANOID and check all variables, this is an RTMCRIT bug fix
            LPCDOPT pOpt = GetCDOpt();
            if (pOpt)
            {
                LPCDOPTIONS pOptions = pOpt->GetCDOpts();
                if (pOptions)
                {
                    LPCDOPTDATA pOptionData = pOptions->pCDData;
                    if (pOptionData)
                    {
	                    if (pOptionData->fExitStop)
                        {
	                        IMMComponentAutomation* pAuto = NULL;
                            if (pNodeCurrent)
                            {
	                            HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	                            if ((SUCCEEDED(hr)) && (pAuto != NULL))
	                            {
                                    //at this point, we can actually stop the CD
                                    pAuto->OnAction(MMACTION_STOP,NULL);        
                                    //release the automation object        
                                    pAuto->Release();
                                }
                            } //end if pnodecurrent
                        } //end if "stop on exit"
                    } //end if option data ok
                } //end if options OK
            } //end if opt OK

            //make sure we're not downloading
            EndDownloadThreads();

			//Unregister the WM_DEVICECHANGE notification
			Volume_DeviceChange_Cleanup();
            
	        //close the volume mixer
            mixerClose((HMIXER)hmix);

            //delete any GDI objects
	        GlobalFree(hbmpMain);
	        GlobalFree(hbmpMainRestore);
            GlobalFree(hbmpMainSmall);
            GlobalFree(hbmpMainNoBar);
	        DeleteObject(hpalMain);

	        //shut down the button class
	        UninitMButtons();

	        //save window state
            if (!IsIconic(hwnd))
            {
                RECT rect;
	            GetWindowRect(hwnd,&rect);
	            SetSettings(rect.left,rect.top);
            }
	        
	        PostQuitMessage(0);
	        return (0);
	    }
    }

    if (iMsg == g_uTaskbarRestart)
    {
        if (fShellMode)
        {
            CreateShellIcon(hInst,hwndMain,pNodeCurrent,szAppName);
        }
    }

    if (iMsg == giVolDevChange)
    {
        WinMMDeviceChangeHandler(hwnd);
    }

    return (DefWindowProc(hwnd, iMsg, wParam, lParam));
}

////////////////////////////////////////////////////////////////////////////////////////////
// * LoadComponents
// Load registered componets from registry
// This code modified from the original MFC-based "Jazz" implementation, with blessings
// from todorfay <g>
////////////////////////////////////////////////////////////////////////////////////////////
BOOL LoadComponents( void )
{
	BOOL      fSuccess = FALSE;
	IMMComponent* pIComponent = NULL;
	TCHAR     szError[MAX_PATH];

	if( SUCCEEDED(CDPLAY_CreateInstance(NULL, IID_IMMComponent, (void**)&pIComponent)) )
	{
		fSuccess = TRUE;
        AddComponent(pIComponent);
	}
	else
	{
		TCHAR strMsg[MAX_PATH];
    	LoadString(hInst,IDS_ERRORLOADINGCOMP,szError,sizeof(szError)/sizeof(TCHAR));
        TCHAR strReinstall[MAX_PATH];
    	LoadString(hInst,IDS_REINSTALL,strReinstall,sizeof(strReinstall)/sizeof(TCHAR));
		wsprintf(strMsg,TEXT("%s\n\n%s"), szError, strReinstall);
		MessageBox(NULL, strMsg, szAppName, MB_OK|MB_ICONERROR );
	}

	return fSuccess;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * AddComponent
// Add a component to the list of comps
////////////////////////////////////////////////////////////////////////////////////////////
void AddComponent(IMMComponent* pComponent)
{
	pCompListTail->pComp = pComponent;
	pCompListTail->pSink = new CFrameworkNotifySink(pCompListTail);
    pCompListTail->pSink->AddRef();

	PCOMPNODE pNew = new COMPNODE;
	pNew->pComp = NULL;
	pNew->pNext = NULL;
	pNew->hwndComp = NULL;
	pNew->pSink = NULL;
	pNew->szTitle[0] = '\0';

	pCompListTail->pNext = pNew;
	pCompListTail = pNew;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CleanUp
// Get rid of anything that might have been around, like linked list, mutex, bitmaps, etc.
////////////////////////////////////////////////////////////////////////////////////////////
void CleanUp(void)
{
    if (pCompList)
    {
        while (pCompList->pNext != NULL)
        {
	        PCOMPNODE pTemp = pCompList;
	        pCompList = pTemp->pNext;
	        if (pTemp->pComp)
	        {
	            pTemp->pComp->Release();
	            pTemp->pSink->Release();
	        }
	        delete pTemp;
        }
    
        delete pCompList;
        pCompList = NULL;
    }

    if (g_pOptions)
    {
        g_pOptions->Release();
    }

    if (g_pData)
    {
        g_pData->Release();
    }

    if (g_hhk)
    {
        UnhookWindowsHookEx(g_hhk);
        g_hhk = NULL;
    }

    if (hmImage)
    {
        FreeLibrary(hmImage);
    }

    if (fShellMode)
    {
        DestroyShellIcon();
    }

    CDNET_Uninit();
}

////////////////////////////////////////////////////////////////////////////////////////////
// * InitComponents
// Initialize components by calling their INIT functions and setting their window sizes
////////////////////////////////////////////////////////////////////////////////////////////
void InitComponents(HWND hwnd)
{
    PCOMPNODE pList = pCompList;

    RECT rect;
    while (pList->pNext!=NULL)
    {
	    IMMComponent* pComp = pList->pComp;
	    if (pComp)
	    {
	        nNumComps++;
	        
	        pComp->Init(pList->pSink,hwnd,&rect,&(pList->hwndComp),&(pList->hmenuComp));

            CalculateDispAreaOffset(pComp);

            switch (g_nViewMode)
            {
                case VIEW_MODE_NORMAL :
                {
                    SetRect(&rect,24,32,455,88+nDispAreaOffset);
                }
                break;

                case VIEW_MODE_RESTORE :
                {
                    SetRect(&rect,303,24,384,41);
                }
                break;

                case VIEW_MODE_SMALL :
                {
                    SetRect(&rect,303,12,384,29);
                }
                break;

                case VIEW_MODE_NOBAR :
                {
                    SetRect(&rect,24,16,455,72+nDispAreaOffset);
                }
                break;
            }

	        SetWindowPos(pList->hwndComp,
		         hwnd,
		         rect.left,
		         rect.top,
		         rect.right - rect.left,
		         rect.bottom - rect.top,
		         SWP_NOZORDER|SWP_NOACTIVATE);

            //size ledwindow to maximum size
            HWND hwndLED = GetDlgItem(pList->hwndComp,IDC_LEDWINDOW);
            if (hwndLED)
            {
                SetRect(&rect,24,32,455,88+nDispAreaOffset);
	            SetWindowPos(hwndLED,
		             pList->hwndComp,
		             0,
		             0,
		             rect.right - rect.left,
		             rect.bottom - rect.top,
		             SWP_NOZORDER|SWP_NOACTIVATE);

                InvalidateRect(hwndLED,NULL,FALSE);
                UpdateWindow(hwndLED);
            }

	        if (!hwndCurrentComp)
	        {
		        ShowNewComponentWindow(pList, hwnd);
	        }
	    } //end if comp ok

	    pList = pList->pNext;
    } //end while
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetToolTipMsgProc
// Msg hook for tool tips so they know when to pop up
////////////////////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK GetToolTipMsgProc(int nCode, WPARAM wParam, LPARAM lParam)
{ 
    MSG *lpmsg;
    lpmsg = (MSG *) lParam;
     
    if (nCode < 0 || !(IsChild(hwndMain, lpmsg->hwnd)))
    {
        return (CallNextHookEx(g_hhk, nCode, wParam, lParam));  
    }

    switch (lpmsg->message)
    {
        case WM_MOUSEMOVE: 
        case WM_LBUTTONDOWN:         
        case WM_LBUTTONUP: 
        case WM_RBUTTONDOWN:         
        case WM_RBUTTONUP: 
            if (g_hwndTT != NULL)
            {                 
                MSG msg;  
                msg.lParam = lpmsg->lParam; 
                msg.wParam = lpmsg->wParam; 
                msg.message = lpmsg->message;                 
                msg.hwnd = lpmsg->hwnd; 
                
                SendMessage(g_hwndTT, TTM_RELAYEVENT, 0, 
                    (LPARAM) (LPMSG) &msg);             
            }             
            break; 
        
        default: break;     
    } 

    return (CallNextHookEx(g_hhk, nCode, wParam, lParam));
} 
    
////////////////////////////////////////////////////////////////////////////////////////////
// * CreateToolTips
// Common control setup code to init tool tips
////////////////////////////////////////////////////////////////////////////////////////////
BOOL CreateToolTips(HWND hwnd)
{  
    InitCommonControls(); 

    g_hwndTT = CreateWindowEx(0, TOOLTIPS_CLASS, (LPTSTR) NULL, 
        TTS_ALWAYSTIP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
        CW_USEDEFAULT, hwnd, (HMENU) NULL, hInst, NULL);
          
    if (g_hwndTT == NULL)
        return FALSE;  

    // Install a hook procedure to monitor the message stream for mouse 
    // messages intended for the controls in main window
    g_hhk = SetWindowsHookEx(WH_GETMESSAGE, GetToolTipMsgProc, 
        (HINSTANCE) NULL, GetCurrentThreadId());  

    if (g_hhk == NULL)
        return FALSE;
        
    return TRUE; 	
} 


//WM_DEVICECHANGE support/////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

void Volume_DeviceChange_Cleanup()
{
   if (DeviceEventContext) 
   {
       UnregisterDeviceNotification(DeviceEventContext);
       DeviceEventContext = 0;
   }

   bUseHandle = FALSE;

   return;
}

/*
**************************************************************************************************
	Volume_GetDeviceHandle()

	given a mixerID this functions opens its corresponding device handle. This handle can be used 
	to register for DeviceNotifications.

	dwMixerID -- The mixer ID
	phDevice -- a pointer to a handle. This pointer will hold the handle value if the function is
				successful
	
	return values -- If the handle could be obtained successfully the return vlaue is TRUE.

**************************************************************************************************
*/
BOOL Volume_GetDeviceHandle(DWORD dwMixerID, HANDLE *phDevice)
{
	MMRESULT mmr;
	ULONG cbSize=0;
	TCHAR *szInterfaceName=NULL;

	//Query for the Device interface name
	mmr = mixerMessage((HMIXER)dwMixerID, DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
	if(MMSYSERR_NOERROR == mmr)
	{
		szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
		if(!szInterfaceName)
		{
			return FALSE;
		}

		mmr = mixerMessage((HMIXER)dwMixerID, DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
		if(MMSYSERR_NOERROR != mmr)
		{
			GlobalFreePtr(szInterfaceName);
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	//Get an handle on the device interface name.
	*phDevice = CreateFile(szInterfaceName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
						 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	GlobalFreePtr(szInterfaceName);
	if(INVALID_HANDLE_VALUE == *phDevice)
	{
		return FALSE;
	}

	return TRUE;
}


/*	Volume_DeviceChange_Init()
*	First time initialization for WM_DEVICECHANGE messages
*	
*	On NT 5.0, you have to register for device notification
*/
BOOL Volume_DeviceChange_Init(HWND hWnd, DWORD dwMixerID)
{

	DEV_BROADCAST_HANDLE DevBrodHandle;
	DEV_BROADCAST_DEVICEINTERFACE dbi;
	HANDLE hMixerDevice=NULL;
	MMRESULT mmr;

	//If we had registered already for device notifications, unregister ourselves.
	Volume_DeviceChange_Cleanup();

	//If we get the device handle register for device notifications on it.
	if(Volume_GetDeviceHandle(dwMixerID, &hMixerDevice))
	{
		memset(&DevBrodHandle, 0, sizeof(DEV_BROADCAST_HANDLE));

		DevBrodHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
		DevBrodHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
		DevBrodHandle.dbch_handle = hMixerDevice;

		DeviceEventContext = RegisterDeviceNotification(hWnd, &DevBrodHandle, 
													DEVICE_NOTIFY_WINDOW_HANDLE);

		if(hMixerDevice)
		{
			CloseHandle(hMixerDevice);
			hMixerDevice = NULL;
		}
			
		if(DeviceEventContext)
		{
			bUseHandle = TRUE;
			return TRUE;
		}
	}

	if(!DeviceEventContext)
	{
		//Register for notifications from all audio devices. KSCATEGORY_AUDIO gives notifications
		//on device arrival and removal. We cannot identify which device the notification has arrived for
		//but we can take some precautionary measures on these messages so that we do not crash.
		dbi.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
		dbi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
		dbi.dbcc_reserved   = 0;
		dbi.dbcc_classguid  = KSCATEGORY_AUDIO;
		dbi.dbcc_name[0] = TEXT('\0');

		DeviceEventContext = RegisterDeviceNotification(hWnd,
                                         (PVOID)&dbi,
										 DEVICE_NOTIFY_WINDOW_HANDLE);
		if(!DeviceEventContext)
			return FALSE;
	}

	return TRUE;
}

//WM_DEVICECHANGE support ends////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\mbutton.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  MBUTTON.H
//
//	Defines CMButton class; helper functions
//
//	Copyright (c) Microsoft Corporation	1997
//    
//	12/14/97 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MBUTTON_HEADER_
#define _MBUTTON_HEADER_

#include "windows.h"

#ifdef __cplusplus
extern "C" {
#endif

//extended multimedia button styles
#define MBS_STANDARDLEFT    0x00000000L
#define MBS_TOGGLELEFT      0x00000001L
#define MBS_STANDARDRIGHT   0x00000002L
#define MBS_DROPRIGHT       0x00000004L
#define MBS_TOGGLERIGHT     0x00000008L
#define MBS_SYSTEMTYPE      0x00000010L
#define MBS_NOAUTODELETE    0x00000020L

#define STANDARD_PIXELS_PER_INCH 96

#define IS_DBCS_CHARSET( CharSet )									\
                   ( ((CharSet) == SHIFTJIS_CHARSET)    ? TRUE :       \
                     ((CharSet) == HANGEUL_CHARSET)     ? TRUE :       \
                     ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :       \
                     ((CharSet) == GB2312_CHARSET)      ? TRUE :       \
                     ((CharSet) == JOHAB_CHARSET)	? TRUE : FALSE \
                   )

//forward declaration of class
class CMButton;

//c-style helper functions

BOOL InitMButtons(HINSTANCE hInst, HWND hwnd);
void UninitMButtons();

CMButton* GetMButtonFromID(HWND hwndParent, int nID);
CMButton* GetMButtonFromHWND(HWND hwnd);

class CMButton
{
    public:
        friend CMButton* CreateMButton(TCHAR* szCaption,
                                       int nIconID,
                                       DWORD dwWindowStyle,
                                       DWORD dwMButtonStyle,
                                       int x,
                                       int y,
                                       int width,
                                       int height,
                                       HWND hwndParentOrSub,
                                       BOOL fSubExisting,
                                       int nID,
                                       int nToolTipID,
                                       HINSTANCE hInst);

        CMButton(); //constructor
        ~CMButton(); //destructor

        HWND GetHWND() {return m_hwnd;}
        int GetID() {return m_nID;}
        int GetToolTipID() {return m_nToolTipID;}
        void SetToolTipID(int nID) {m_nToolTipID = nID;}
        void SetText(TCHAR* szCaption);
        void SetIcon(int nIconID);
        void SetFont(HFONT hFont);
        void Draw(LPDRAWITEMSTRUCT lpdis);
        void PreDrawUpstate(int width, int height);
        BOOL MouseInButton() {return m_fMouseInButton;}
        BOOL GetMenuingState() {return m_fMenu;}
        void SetMenuingState(BOOL fMenuOn);

    private:
        //non-static privates
        HFONT m_hFont;
        int m_nID;
        int m_nToolTipID;
        HWND m_hwnd;
        BOOL m_fMouseInButton;
        DWORD m_dwStyle;
        WNDPROC m_fnOldButton;
        BOOL m_fRedraw;
        HINSTANCE m_hInst;
        int m_IconID;
        BOOL m_fMenu;
        BOOL m_fMenuingOff;
        int m_LastState;

        HANDLE m_hbmpUp;
        HANDLE m_hbmpDn;
        HANDLE m_hbmpHi;
        
        void DrawButtonBitmap(LPDRAWITEMSTRUCT lpdis, BOOL fDrawToScreen, RECT* pMidRect);

    private:
        //static stuff for all buttons
        static LRESULT CALLBACK ButtonProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
};

#ifdef __cplusplus
};
#endif

#endif  //_MBUTTON_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\mbutton.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  MBUTTON.CPP
//
//      Multimedia Button Control class; helper functions
//
//      Copyright (c) Microsoft Corporation     1997
//    
//      12/14/97 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "mbutton.h"
#include <windowsx.h>   //for GetWindowFont
#include <winuser.h>    //for TrackMouseEvent
#include <commctrl.h>   //for WM_MOUSELEAVE
#include <TCHAR.H>
#include "resource.h"
#include "dib.h"
#include "mmfw.h"

//file-local default values for buttons
#define NUM_STATES  3
#define STATE_UP    0
#define STATE_DN    1
#define STATE_HI    2
#define BOFF_STANDARDLEFT   0
#define BOFF_TOGGLELEFT     1
#define BOFF_STANDARDRIGHT  2
#define BOFF_DROPRIGHT      3
#define BOFF_TOGGLERIGHT    4
#define BOFF_MIDDLE         5
#define BOFF_SYSTEM         6
#define BOFF_MINIMIZE       7
#define BOFF_RESTORE        8
#define BOFF_MAXIMIZE       9
#define BOFF_CLOSE          10
#define BOFF_MUTE           11
#define BOFF_END            12
#define BUTTON_BITMAP_HEIGHT    19
#define BUTTON_FONT_SIZE        8
#define BUTTON_DBCS_FONT_SIZE   9
#define BUTTON_FONT_WEIGHT      FW_BOLD

#define MBUTTON_TEXT_COLOR RGB(0xFF,0xFF,0xFF)

HFONT    hFont = NULL;
HANDLE   hbmpButtonToolkit = NULL;
int      nStateOffset = 0;
int      nButtonOffsets[BOFF_END+1];
extern   HPALETTE hpalMain;
extern  int g_nColorMode;
CMButton* pButtonFocus = NULL;
CMButton* pButtonMouse = NULL;
BOOL      fAllowFocus = TRUE;


//for this to work on a Win95 machine, we need to make TrackMouseEvent
//a dynamically loaded thing ... but then you get NO HOVER-OVER EFFECT
typedef BOOL (PASCAL *TRACKPROC)(LPTRACKMOUSEEVENT);
TRACKPROC procTrackMouseEvent = NULL;

BOOL InitMButtons(HINSTANCE hInst, HWND hwnd)
{
    BOOL fReturn = TRUE;

    //if TrackMouseEvent exists, use it
    HMODULE hUser = GetModuleHandle(TEXT("USER32"));
    if (hUser)
    {
        procTrackMouseEvent = (TRACKPROC)GetProcAddress(hUser,"TrackMouseEvent");
    }

    //create font, named store in IDS_MBUTTON_FONT in string table
    LOGFONT     lf;
    ZeroMemory( &lf, sizeof(lf) );

    HFONT hTempFont = GetWindowFont( hwnd );
    if (hTempFont == NULL)
    {
        hTempFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    }

    GetObject(hTempFont,sizeof(lf),&lf);

    lf.lfHeight = (-BUTTON_FONT_SIZE * STANDARD_PIXELS_PER_INCH) / 72;
    if (lf.lfCharSet == ANSI_CHARSET)
    {
        lf.lfWeight = BUTTON_FONT_WEIGHT;
    }
    else if (IS_DBCS_CHARSET(lf.lfCharSet)) {
        lf.lfHeight = (-BUTTON_DBCS_FONT_SIZE * STANDARD_PIXELS_PER_INCH) / 72;
    }

    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;

    LoadString(hInst,IDS_MBUTTON_FONT,lf.lfFaceName,LF_FACESIZE-1);

    hFont = CreateFontIndirect(&lf);

    //create bitmap, has all states for all buttons
    int nBitmap = IDB_BUTTON_TOOLKIT;
    switch (g_nColorMode)
    {
        case COLOR_16 : nBitmap = IDB_BUTTON_TOOLKIT_16; break;
        case COLOR_HICONTRAST : nBitmap = IDB_BUTTON_TOOLKIT_HI; break;
    }

    HBITMAP hbmpTemp = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	hbmpButtonToolkit = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    BITMAP bm;
    GetObject(hbmpTemp,sizeof(bm),&bm);
    DeleteObject(hbmpTemp);

    nStateOffset = bm.bmWidth / NUM_STATES;

    //offsets within bitmap
    nButtonOffsets[BOFF_STANDARDLEFT]   = 0;
    nButtonOffsets[BOFF_TOGGLELEFT]     = 9;
    nButtonOffsets[BOFF_STANDARDRIGHT]  = 11;
    nButtonOffsets[BOFF_DROPRIGHT]      = 20;
    nButtonOffsets[BOFF_TOGGLERIGHT]    = 42;
    nButtonOffsets[BOFF_MIDDLE]         = 44; 
    nButtonOffsets[BOFF_SYSTEM]         = 52; 
    nButtonOffsets[BOFF_MINIMIZE]       = 64;
    nButtonOffsets[BOFF_RESTORE]        = 78; 
    nButtonOffsets[BOFF_MAXIMIZE]       = 92; 
    nButtonOffsets[BOFF_CLOSE]          = 106; 
    nButtonOffsets[BOFF_MUTE]           = 121;
    nButtonOffsets[BOFF_END]            = nStateOffset;

	//SetDibUsage(hbmpButtonToolkit,hpalMain,DIB_RGB_COLORS);

    return (fReturn);
}

void UninitMButtons()
{
    GlobalFree(hbmpButtonToolkit);
    DeleteObject(hFont);
}

//Given a parent window and a control ID, return the CMButton object
CMButton* GetMButtonFromID(HWND hwndParent, int nID)
{
    HWND hwnd = GetDlgItem(hwndParent, nID);
    return (GetMButtonFromHWND(hwnd));
}

//Given the window handle of the button, return the CMButton object
CMButton* GetMButtonFromHWND(HWND hwnd)
{
    CMButton* pButton = (CMButton*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    return (pButton);    
}

CMButton* CreateMButton(TCHAR* szCaption, int nIconID, DWORD dwWindowStyle, DWORD dwMButtonStyle, int x, int y, int width, int height, HWND hwndParentOrSub, BOOL fSubExisting, int nID, int nToolTipID, HINSTANCE hInst)
{
    CMButton* pButton = new CMButton;

    //ensure the button is a child, pushbutton, owner-draw
    //caller should specify WS_VISIBLE|WS_TABSTOP if desired
    dwWindowStyle = dwWindowStyle|WS_CHILD|BS_PUSHBUTTON|BS_OWNERDRAW;

    HWND hwnd;
    
    if (fSubExisting)
    {
	    //user already created button, is probably calling from WM_INITDIALOG
	    hwnd = hwndParentOrSub;
    }
    else
    {
	    //need to create the button ourselves
	    hwnd = CreateWindow(TEXT("BUTTON"),
			         szCaption,
			         dwWindowStyle,
			         x,
			         y,
			         width,
			         height,
			         hwndParentOrSub,
			         (HMENU)nID,
			         hInst,
			         NULL);
    }

    if (hwnd == NULL)
    {
	    //if we can't create the window, nuke it and fail
	    delete pButton;
	    return NULL;
    }

    pButton->m_hInst = hInst;
    pButton->m_fRedraw = FALSE;
    pButton->m_dwStyle = dwMButtonStyle;
    pButton->m_hwnd = hwnd;
    pButton->SetIcon(nIconID);
    pButton->SetFont(hFont);
    pButton->m_fRedraw = TRUE;
    pButton->m_nID = nID;
    pButton->m_nToolTipID = nToolTipID;

    pButton->PreDrawUpstate(width,height);

    //subclass the button; allows tracking of mouse events
    pButton->m_fnOldButton = (WNDPROC)SetWindowLongPtr(hwnd,GWLP_WNDPROC,(LONG_PTR)CMButton::ButtonProc);

    //put the button's pointer into the window's user bytes
    SetWindowLongPtr(hwnd,GWLP_USERDATA,(LONG_PTR)pButton);

    return (pButton);
}

void CMButton::PreDrawUpstate(int width, int height)
{
    //pre-draw the up states of the buttons for a faster-seeming first blit
    if (m_hbmpUp) DeleteObject(m_hbmpUp);
    if (m_hbmpDn) DeleteObject(m_hbmpDn);
    if (m_hbmpHi) DeleteObject(m_hbmpHi);
    m_hbmpUp = NULL;
    m_hbmpDn = NULL;
    m_hbmpHi = NULL;

    DRAWITEMSTRUCT drawItem;

    drawItem.rcItem.left = 0;
    drawItem.rcItem.top = 0;
    drawItem.rcItem.right = width;
    drawItem.rcItem.bottom = height;

    drawItem.itemState = 0;
    drawItem.hDC = GetDC(m_hwnd);
    HPALETTE hpalOld = SelectPalette(drawItem.hDC,hpalMain,FALSE);
    RealizePalette(drawItem.hDC);

    DrawButtonBitmap(&drawItem,FALSE,NULL);

    SelectPalette(drawItem.hDC,hpalOld,TRUE);
    RealizePalette(drawItem.hDC);
    ReleaseDC(m_hwnd,drawItem.hDC);
}

LRESULT CALLBACK CMButton::ButtonProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    CMButton* pButton = (CMButton*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    if (pButton == NULL)
    {
    	return (0);
    }

    switch (iMsg)
    {
	    case WM_MOUSEMOVE :
	    {
	        if (!pButton->m_fMouseInButton)
	        {
		        if (procTrackMouseEvent)
                {
		            //only do this if the trackmouseevent function exists,
                    //otherwise, the button color will never turn off
                    pButton->m_fMouseInButton = TRUE;
		            TRACKMOUSEEVENT tme;
		            tme.cbSize = sizeof(tme);
		            tme.dwFlags = TME_LEAVE;
		            tme.dwHoverTime = HOVER_DEFAULT;
		            tme.hwndTrack = hwnd;
                    procTrackMouseEvent(&tme);
		            InvalidateRect(hwnd,NULL,FALSE);
                } //end proctrackmouseevent is valid
	        }
	    }
	    break;

        case WM_KEYUP :
        {
            //for the close, min, and view buttons, we want to shunt
            //any keyboard movement to the knob ... although tempting,
            //don't do this on the setfocus, or the mouse won't work right

            if (
                (pButton->m_nID == IDB_CLOSE) ||
                (pButton->m_nID == IDB_MINIMIZE) ||
                (pButton->m_nID == IDB_SET_TINY_MODE) ||
                (pButton->m_nID == IDB_SET_NORMAL_MODE)
               )
            {
                HWND hwndFocus = GetDlgItem(GetParent(hwnd),IDB_VOLUME);
                if (IsWindowVisible(hwndFocus))
                {
                    SetFocus(hwndFocus);
                }
                else
                {
                    hwndFocus = GetDlgItem(GetParent(hwnd),IDB_OPTIONS);
                    SetFocus(hwndFocus);
                }
            } //end if
        }
        break;

        case WM_SETFOCUS :
        {
            SendMessage(GetParent(pButton->m_hwnd),DM_SETDEFID,pButton->m_nID,0);
        }
        break;

	    case WM_MOUSELEAVE :
	    {
	        pButton->m_fMouseInButton = FALSE;
	        InvalidateRect(hwnd,NULL,FALSE);
	    }
	    break;

        case WM_ERASEBKGND :
        {
            DRAWITEMSTRUCT drawItem;
            drawItem.hDC = (HDC)wParam;
            GetClientRect(hwnd,&(drawItem.rcItem));
            drawItem.itemState = pButton->m_LastState;
            pButton->Draw(&drawItem);
            return TRUE;
        }
        break;

    } //end switch

    LRESULT lResult = CallWindowProc((WNDPROC)pButton->m_fnOldButton,hwnd,iMsg,wParam,lParam);

    if ((iMsg == WM_DESTROY) && ((pButton->m_dwStyle & MBS_NOAUTODELETE) == 0))
    {
	    //auto-delete the button class
	    SetWindowLongPtr(hwnd,GWLP_USERDATA,0);
	    delete pButton;
	    pButton = NULL;
    }

    return (lResult);
}

CMButton::CMButton()
{
    //init all data values
    m_fMouseInButton = FALSE;
    m_dwStyle = MBS_STANDARDLEFT | MBS_STANDARDRIGHT;
    m_hFont = hFont;
    m_nID = 0;
    m_IconID = 0;
    m_hwnd = NULL;
    m_hbmpUp = NULL;
    m_hbmpDn = NULL;
    m_hbmpHi = NULL;
    m_fRedraw = FALSE;
    m_fMenu = FALSE;
    m_fMenuingOff = FALSE;
    m_LastState = 0;
}

CMButton::~CMButton()
{
    if (m_hbmpUp) DeleteObject(m_hbmpUp);
    if (m_hbmpDn) DeleteObject(m_hbmpDn);
    if (m_hbmpHi) DeleteObject(m_hbmpHi);
}

void CMButton::SetText(TCHAR* szCaption)
{
    SetWindowText(m_hwnd,szCaption);

    if (m_fRedraw)
    {
	    InvalidateRect(m_hwnd,NULL,FALSE);
    }
}

void CMButton::SetIcon(int nIconID)
{
    //assuming caller is responsible for cleaning up
    m_IconID = nIconID;

    if (m_fRedraw)
    {
	    InvalidateRect(m_hwnd,NULL,FALSE);
    }
}

void CMButton::SetFont(HFONT hFont)
{
    //assume caller is responsible for cleaning up
    m_hFont = hFont;
}

void CMButton::DrawButtonBitmap(LPDRAWITEMSTRUCT lpdis, BOOL fDrawToScreen, RECT* pMidRect)
{
    HANDLE hTemp = m_hbmpUp;
    int nState = STATE_UP;
	
    if (m_fMouseInButton)
    {
        pButtonMouse = this;
	    hTemp = m_hbmpHi;
	    nState = STATE_HI;

        if (pButtonFocus!=NULL)
        {
            fAllowFocus = FALSE;
            if (this != pButtonFocus)
            {
                InvalidateRect(pButtonFocus->GetHWND(),NULL,FALSE);
                UpdateWindow(pButtonFocus->GetHWND());
            }
        }
    }
    else
    {
        if (lpdis->itemState & ODS_FOCUS)
        {
            if (this == pButtonFocus)
            {
                if (fAllowFocus)
                {
                    hTemp = m_hbmpHi;
                    nState = STATE_HI;
                }
                else
                {
                    hTemp = m_hbmpUp;
                    nState = STATE_UP;
                }
            }
            else
            {
                pButtonFocus = this;
                hTemp = m_hbmpHi;
                nState = STATE_HI;
                fAllowFocus = TRUE;
                if ((pButtonMouse!=NULL) && (pButtonMouse!=this))
                {
	                pButtonMouse->m_fMouseInButton = FALSE;
	                InvalidateRect(pButtonMouse->GetHWND(),NULL,FALSE);
                    UpdateWindow(pButtonMouse->GetHWND());
                    pButtonMouse = NULL;
                } //end if removing mouse highlight
            }
        }
    } //end if mouse in or out of button

    if ((lpdis->itemState & ODS_SELECTED) || (m_fMenu))
    {
	    hTemp = m_hbmpDn;
	    nState = STATE_DN;
    }

	int offLeft, widLeft;
	int offRight, widRight;
	int offMid, widMid;

	offLeft = nButtonOffsets[BOFF_STANDARDLEFT] + (nState * nStateOffset);
	widLeft = nButtonOffsets[BOFF_STANDARDLEFT+1] - nButtonOffsets[BOFF_STANDARDLEFT];

	if ((m_dwStyle & MBS_TOGGLELEFT) == MBS_TOGGLELEFT)
	{
	    offLeft = nButtonOffsets[BOFF_TOGGLELEFT] + (nState * nStateOffset);
	    widLeft = nButtonOffsets[BOFF_TOGGLELEFT+1] - nButtonOffsets[BOFF_TOGGLELEFT];
	}

	if ((m_dwStyle & MBS_SYSTEMTYPE) == MBS_SYSTEMTYPE)
	{
	    switch (m_IconID)
	    {
		    case IDB_CLOSE :
		    {
		        offLeft = nButtonOffsets[BOFF_CLOSE] + (nState * nStateOffset);
		        widLeft = nButtonOffsets[BOFF_CLOSE+1] - nButtonOffsets[BOFF_CLOSE];
		    }
		    break;

		    case IDB_MINIMIZE :
		    {
		        offLeft = nButtonOffsets[BOFF_MINIMIZE] + (nState * nStateOffset);
		        widLeft = nButtonOffsets[BOFF_MINIMIZE+1] - nButtonOffsets[BOFF_MINIMIZE];
		    }
		    break;

		    case IDB_SET_TINY_MODE :
		    {
		        offLeft = nButtonOffsets[BOFF_RESTORE] + (nState * nStateOffset);
		        widLeft = nButtonOffsets[BOFF_RESTORE+1] - nButtonOffsets[BOFF_RESTORE];
		    }
		    break;

		    case IDB_SET_NORMAL_MODE :
		    {
		        offLeft = nButtonOffsets[BOFF_MAXIMIZE] + (nState * nStateOffset);
		        widLeft = nButtonOffsets[BOFF_MAXIMIZE+1] - nButtonOffsets[BOFF_MAXIMIZE];
		    }
		    break;

            case IDB_MUTE :
            {
                offLeft = nButtonOffsets[BOFF_MUTE] + (nState * nStateOffset);
                widLeft = nButtonOffsets[BOFF_MUTE+1]  - nButtonOffsets[BOFF_MUTE];
            }
	    }
	}

	offRight = nButtonOffsets[BOFF_STANDARDRIGHT] + (nState * nStateOffset);
	widRight = nButtonOffsets[BOFF_STANDARDRIGHT+1] - nButtonOffsets[BOFF_STANDARDRIGHT];

	if ((m_dwStyle & MBS_TOGGLERIGHT) == MBS_TOGGLERIGHT)
	{
	    offRight = nButtonOffsets[BOFF_TOGGLERIGHT] + (nState * nStateOffset);
	    widRight = nButtonOffsets[BOFF_TOGGLERIGHT+1] - nButtonOffsets[BOFF_TOGGLERIGHT];
	}

	if ((m_dwStyle & MBS_DROPRIGHT) == MBS_DROPRIGHT)
	{
	    offRight = nButtonOffsets[BOFF_DROPRIGHT] + (nState * nStateOffset);
	    widRight = nButtonOffsets[BOFF_DROPRIGHT+1] - nButtonOffsets[BOFF_DROPRIGHT];
	}

	offMid = nButtonOffsets[BOFF_MIDDLE] + (nState * nStateOffset);
	widMid = (lpdis->rcItem.right - lpdis->rcItem.left) - widLeft - widRight;

    if (pMidRect)
    {
        if (m_dwStyle & MBS_DROPRIGHT)
        {
            //set rect to just the middle of the button part
            SetRect(pMidRect,
                    lpdis->rcItem.left,
                    lpdis->rcItem.top,
                    lpdis->rcItem.left + widLeft + widMid,
                    lpdis->rcItem.top + BUTTON_BITMAP_HEIGHT);
        }
        else
        {
            //set rect to whole button
            SetRect(pMidRect,
                    lpdis->rcItem.left,
                    lpdis->rcItem.top,
                    lpdis->rcItem.right,
                    lpdis->rcItem.bottom);
        }
    }

    if (hTemp == NULL)
    {
	    //draw and save bumps
	    HDC memDC = CreateCompatibleDC(lpdis->hDC);
	    HPALETTE hpalOld = SelectPalette(memDC, hpalMain, FALSE);
	    HBITMAP holdbmp;

        switch (nState)
        {
            case STATE_UP :
            {
		        m_hbmpUp = CreateCompatibleBitmap(lpdis->hDC,
						          lpdis->rcItem.right - lpdis->rcItem.left,
						          BUTTON_BITMAP_HEIGHT);

		        holdbmp = (HBITMAP)SelectObject(memDC,m_hbmpUp);
            }
            break;

            case STATE_DN :
            {
		        m_hbmpDn = CreateCompatibleBitmap(lpdis->hDC,
						          lpdis->rcItem.right - lpdis->rcItem.left,
						          BUTTON_BITMAP_HEIGHT);
		        holdbmp = (HBITMAP)SelectObject(memDC,m_hbmpDn);
            }
            break;

            case STATE_HI :
            {
	            m_hbmpHi = CreateCompatibleBitmap(lpdis->hDC,
					              lpdis->rcItem.right - lpdis->rcItem.left,
					              BUTTON_BITMAP_HEIGHT);
	            holdbmp = (HBITMAP)SelectObject(memDC,m_hbmpHi);
            }
            break;
        }

	    //draw left
	    DibBlt(memDC,
		        lpdis->rcItem.left,
		        lpdis->rcItem.top,
		        -1, 
		        -1, 
		        hbmpButtonToolkit,
		        offLeft,0,
		        SRCCOPY,0);

	    if ((m_dwStyle & MBS_SYSTEMTYPE) != MBS_SYSTEMTYPE)
	    {
	        //draw middle
	        StretchDibBlt(memDC,
		        lpdis->rcItem.left + widLeft,
		        lpdis->rcItem.top,
		        widMid,
		        BUTTON_BITMAP_HEIGHT,
		        hbmpButtonToolkit,
		        offMid,0,
		        nButtonOffsets[BOFF_MIDDLE+1] - nButtonOffsets[BOFF_MIDDLE],
		        BUTTON_BITMAP_HEIGHT,
		        SRCCOPY,0);

	        //draw right
	        DibBlt(memDC,
		        lpdis->rcItem.right - widRight,
		        lpdis->rcItem.top,
		        -1,
		        -1,
		        hbmpButtonToolkit,
		        offRight,0,
		        SRCCOPY,0);
	    }

	    SelectObject(memDC,holdbmp);
	    SelectPalette(memDC, hpalOld, TRUE);
	    DeleteDC(memDC);
    } //end not already drawn

    if (fDrawToScreen)
    {
	    //should have bumps ready to go now
	    hTemp = m_hbmpUp;

	    if (m_fMouseInButton)
	    {
	        hTemp = m_hbmpHi;
	    }

        if (lpdis->itemState & ODS_FOCUS)
        {
            if (fAllowFocus)
            {
                hTemp = m_hbmpHi;
            }
        }

	    if ((lpdis->itemState & ODS_SELECTED) || (m_fMenu))
	    {
	        hTemp = m_hbmpDn;
	    }

	    if (!(lpdis->itemState & ODS_SELECTED) && (m_fMenuingOff))
        {
            m_fMenu = FALSE;
            m_fMenuingOff = FALSE;
            hTemp = m_hbmpUp;
        }

	    HDC memDC = CreateCompatibleDC(lpdis->hDC);
	    HBITMAP holdbmp = (HBITMAP)SelectObject(memDC,hTemp);

	    BitBlt(lpdis->hDC,
		        lpdis->rcItem.left,
		        lpdis->rcItem.top,
		        lpdis->rcItem.right - lpdis->rcItem.left, 
		        lpdis->rcItem.bottom - lpdis->rcItem.top, 
		        memDC,
		        0,0,
		        SRCCOPY);

	    SelectObject(memDC,holdbmp);
	    DeleteDC(memDC);
    }
}

void CMButton::Draw(LPDRAWITEMSTRUCT lpdis)
{
    HPALETTE hpalOld = SelectPalette(lpdis->hDC,hpalMain,FALSE);
    RealizePalette(lpdis->hDC);

    SetTextColor(lpdis->hDC, MBUTTON_TEXT_COLOR);

    m_LastState = lpdis->itemState;

    if (lpdis->itemState & ODS_DISABLED)
    {
        SetTextColor(lpdis->hDC, GetSysColor(COLOR_GRAYTEXT));
    }

    RECT midRect;
    DrawButtonBitmap(lpdis,TRUE,&midRect);

    if ((m_dwStyle & MBS_SYSTEMTYPE) == MBS_SYSTEMTYPE)
    {
        SelectPalette(lpdis->hDC,hpalOld,TRUE);
        RealizePalette(lpdis->hDC);
	    return;
    }

    SetBkMode(lpdis->hDC,TRANSPARENT);

    if (m_IconID == 0)
    {
	    HFONT hOldFont = (HFONT)SelectObject(lpdis->hDC,m_hFont);

	    TCHAR szCaption[MAX_PATH];
	    GetWindowText(m_hwnd,szCaption,sizeof(szCaption)/sizeof(TCHAR));
	    SIZE size;

	    GetTextExtentPoint32( lpdis->hDC, szCaption, _tcslen(szCaption), &size );

	    //center text
	    int x = (((midRect.right - midRect.left) - size.cx) / 2) + midRect.left;
	    int y = (((lpdis->rcItem.bottom - lpdis->rcItem.top) - size.cy) / 2) + lpdis->rcItem.top;

	    //simulate a press
	    if ((lpdis->itemState & ODS_SELECTED) || (m_fMenu))
	    {
	        x++;
	        y++;
	    }

	    ExtTextOut( lpdis->hDC, x, y, 0, NULL, szCaption, _tcslen(szCaption), NULL );

	    SelectObject(lpdis->hDC,hOldFont);
    } //end if no icon
    else
    {
	    //center icon
	    int x = (((midRect.right - midRect.left) - 32) / 2) + midRect.left;
	    int y = (((lpdis->rcItem.bottom - lpdis->rcItem.top) - 32) / 2) + lpdis->rcItem.top;
	    //simulate a press
	    if ((lpdis->itemState & ODS_SELECTED) || (m_fMenu))
	    {
	        x++;
	        y++;
	    }

	    HICON hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(m_IconID), IMAGE_ICON, 32, 32, LR_MONOCHROME);
	    DrawIcon(lpdis->hDC,x,y,hIcon);
        DestroyIcon(hIcon);
    }

    SelectPalette(lpdis->hDC,hpalOld,TRUE);
    RealizePalette(lpdis->hDC);
}

void CMButton::SetMenuingState(BOOL fMenuOn)
{
    if (fMenuOn)
    {
        m_fMenu = fMenuOn;
        m_fMenuingOff = FALSE;
    }
    else
    {
        m_fMenuingOff = TRUE;
        InvalidateRect(m_hwnd,NULL,FALSE);
        UpdateWindow(m_hwnd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\multimon.h ===
#if !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500)

//=============================================================================
//
// MULTIMON
// stub module that fakes multiple monitor apis on pre Memphis Win32 OSes
//
// By using this header your code will work unchanged on Win95,
// you will get back default values from GetSystemMetrics() for new metrics
// and the new APIs will act like only one display is present.
//
// exactly one source must include this with COMPILE_MULTIMON_STUBS defined
//
//=============================================================================

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
// if we are building on Win95/NT4 headers we need to declare this stuff ourselves
//
#ifndef SM_CMONITORS

#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81

DECLARE_HANDLE(HMONITOR);

#define MONITOR_DEFAULTTONULL       0x00000000
#define MONITOR_DEFAULTTOPRIMARY    0x00000001
#define MONITOR_DEFAULTTONEAREST    0x00000002

#define MONITORINFOF_PRIMARY        0x00000001

typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;

#define CCHDEVICENAME 32

#ifdef __cplusplus
typedef struct tagMONITORINFOEX : public tagMONITORINFO
{
    TCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEX, *LPMONITORINFOEX;
#else
typedef struct
{
    MONITORINFO;
    TCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEX, *LPMONITORINFOEX;
#endif

typedef BOOL (CALLBACK* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);

#endif  // SM_CMONITORS

#undef GetMonitorInfo
#undef GetSystemMetrics
#undef MonitorFromWindow
#undef MonitorFromRect
#undef MonitorFromPoint
#undef EnumDisplayMonitors

//
// define this to compile the stubs
// otherwise you get the declarations
//
#ifdef COMPILE_MULTIMON_STUBS

//-----------------------------------------------------------------------------
//
// Implement the API stubs.
//
//-----------------------------------------------------------------------------

int      (WINAPI* g_pfnGetSystemMetrics)(int);
HMONITOR (WINAPI* g_pfnMonitorFromWindow)(HWND, BOOL);
HMONITOR (WINAPI* g_pfnMonitorFromRect)(LPCRECT, BOOL);
HMONITOR (WINAPI* g_pfnMonitorFromPoint)(POINT, BOOL);
BOOL     (WINAPI* g_pfnGetMonitorInfo)(HMONITOR, LPMONITORINFO);
BOOL     (WINAPI* g_pfnEnumDisplayMonitors)(HDC, LPCRECT, MONITORENUMPROC, LPARAM);

BOOL InitMultipleMonitorStubs(void)
{
    HMODULE hUser32;
    static BOOL fInitDone;

    if (fInitDone)
    {
        return g_pfnGetMonitorInfo != NULL;
    }

    if ((hUser32 = GetModuleHandle(TEXT("USER32"))) &&
        (*(FARPROC*)&g_pfnGetSystemMetrics    = GetProcAddress(hUser32,"GetSystemMetrics")) &&
        (*(FARPROC*)&g_pfnMonitorFromWindow   = GetProcAddress(hUser32,"MonitorFromWindow")) &&
        (*(FARPROC*)&g_pfnMonitorFromRect     = GetProcAddress(hUser32,"MonitorFromRect")) &&
        (*(FARPROC*)&g_pfnMonitorFromPoint    = GetProcAddress(hUser32,"MonitorFromPoint")) &&
        (*(FARPROC*)&g_pfnEnumDisplayMonitors = GetProcAddress(hUser32,"EnumDisplayMonitors")) &&
#ifdef UNICODE
        (*(FARPROC*)&g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoW")) &&
#else
        (*(FARPROC*)&g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoA")) &&
#endif
        //
        // Old builds of Memphis had different indices for these metrics, and
        // some of the APIs and structs have changed since then, so validate that
        // the returned metrics are not totally messed up.  (for example on an old
        // Memphis build, the new index for SM_CYVIRTUALSCREEN will fetch 0)
        //
        // If this is preventing you from using the shell on secondary monitors
        // under Memphis then upgrade to a new Memphis build that is in sync with
        // the current version of the multi-monitor APIs.
        //
        (GetSystemMetrics(SM_CXVIRTUALSCREEN) >= GetSystemMetrics(SM_CXSCREEN)) &&
        (GetSystemMetrics(SM_CYVIRTUALSCREEN) >= GetSystemMetrics(SM_CYSCREEN)) )
    {
        fInitDone = TRUE;
        return TRUE;
    }
    else
    {
        g_pfnGetSystemMetrics    = NULL;
        g_pfnMonitorFromWindow   = NULL;
        g_pfnMonitorFromRect     = NULL;
        g_pfnMonitorFromPoint    = NULL;
        g_pfnGetMonitorInfo      = NULL;
        g_pfnEnumDisplayMonitors = NULL;

        fInitDone = TRUE;
        return FALSE;
    }
}

//-----------------------------------------------------------------------------
//
// fake implementations of Monitor APIs that work with the primary display
// no special parameter validation is made since these run in client code
//
//-----------------------------------------------------------------------------

int WINAPI
xGetSystemMetrics(int nIndex)
{
    if (InitMultipleMonitorStubs())
        return g_pfnGetSystemMetrics(nIndex);

    switch (nIndex)
    {
    case SM_CMONITORS:
    case SM_SAMEDISPLAYFORMAT:
        return 1;

    case SM_XVIRTUALSCREEN:
    case SM_YVIRTUALSCREEN:
        return 0;

    case SM_CXVIRTUALSCREEN:
        nIndex = SM_CXSCREEN;
        break;

    case SM_CYVIRTUALSCREEN:
        nIndex = SM_CYSCREEN;
        break;
    }

    return GetSystemMetrics(nIndex);
}

#define xPRIMARY_MONITOR ((HMONITOR)0x42)

HMONITOR WINAPI
xMonitorFromRect(LPCRECT lprcScreenCoords, UINT uFlags)
{
    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromRect(lprcScreenCoords, uFlags);

    if ((uFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
        ((lprcScreenCoords->right > 0) &&
        (lprcScreenCoords->bottom > 0) &&
        (lprcScreenCoords->left < GetSystemMetrics(SM_CXSCREEN)) &&
        (lprcScreenCoords->top < GetSystemMetrics(SM_CYSCREEN))))
    {
        return xPRIMARY_MONITOR;
    }

    return NULL;
}

HMONITOR WINAPI
xMonitorFromPoint(POINT ptScreenCoords, UINT uFlags)
{
    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromPoint(ptScreenCoords, uFlags);

    if ((uFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
        ((ptScreenCoords.x >= 0) &&
        (ptScreenCoords.x < GetSystemMetrics(SM_CXSCREEN)) &&
        (ptScreenCoords.y >= 0) &&
        (ptScreenCoords.y < GetSystemMetrics(SM_CYSCREEN))))
    {
        return xPRIMARY_MONITOR;
    }

    return NULL;
}

HMONITOR WINAPI
xMonitorFromWindow(HWND hWnd, UINT uFlags)
{
    RECT rc;

    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromWindow(hWnd, uFlags);

    if (uFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST))
        return xPRIMARY_MONITOR;

    if (GetWindowRect(hWnd, &rc))
        return xMonitorFromRect(&rc, uFlags);

    return NULL;
}

BOOL WINAPI
xGetMonitorInfo(HMONITOR hMonitor, LPMONITORINFO lpMonitorInfo)
{
    RECT rcWork;

    if (InitMultipleMonitorStubs())
        return g_pfnGetMonitorInfo(hMonitor, lpMonitorInfo);

    if ((hMonitor == xPRIMARY_MONITOR) && lpMonitorInfo &&
        (lpMonitorInfo->cbSize >= sizeof(MONITORINFO)) &&
        SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0))
    {
        lpMonitorInfo->rcMonitor.left = 0;
        lpMonitorInfo->rcMonitor.top  = 0;
        lpMonitorInfo->rcMonitor.right  = GetSystemMetrics(SM_CXSCREEN);
        lpMonitorInfo->rcMonitor.bottom = GetSystemMetrics(SM_CYSCREEN);
        lpMonitorInfo->rcWork = rcWork;
        lpMonitorInfo->dwFlags = MONITORINFOF_PRIMARY;

        if (lpMonitorInfo->cbSize >= sizeof(MONITORINFOEX))
            lstrcpy(((MONITORINFOEX*)lpMonitorInfo)->szDevice, TEXT("DISPLAY"));

        return TRUE;
    }

    return FALSE;
}

BOOL WINAPI
xEnumDisplayMonitors(HDC hdcOptionalForPainting,
    LPCRECT lprcEnumMonitorsThatIntersect, MONITORENUMPROC lpfnEnumProc,
    LPARAM lData)
{
    RECT rcCallback, rcLimit;

    if (InitMultipleMonitorStubs())
        return g_pfnEnumDisplayMonitors(hdcOptionalForPainting,
            lprcEnumMonitorsThatIntersect, lpfnEnumProc, lData);
    
    if (!lpfnEnumProc)
        return FALSE;

    rcLimit.left   = 0;
    rcLimit.top    = 0;
    rcLimit.right  = GetSystemMetrics(SM_CXSCREEN);
    rcLimit.bottom = GetSystemMetrics(SM_CYSCREEN);

    if (hdcOptionalForPainting)
    {
        RECT rcClip;
        HWND hWnd;

        if ((hWnd = WindowFromDC(hdcOptionalForPainting)) == NULL)
            return FALSE;

        switch (GetClipBox(hdcOptionalForPainting, &rcClip))
        {
        default:
            MapWindowPoints(NULL, hWnd, (LPPOINT)&rcLimit, 2);
            if (IntersectRect(&rcCallback, &rcClip, &rcLimit))
                break;
            //fall thru
        case NULLREGION:
             return TRUE;
        case ERROR:
             return FALSE;
        }

        rcLimit = rcCallback;
    }

    if (!lprcEnumMonitorsThatIntersect ||
        IntersectRect(&rcCallback, lprcEnumMonitorsThatIntersect, &rcLimit))
    {
        lpfnEnumProc(xPRIMARY_MONITOR, hdcOptionalForPainting, &rcCallback,
            lData);
    }

    return TRUE;
}

#undef xPRIMARY_MONITOR
#undef COMPILE_MULTIMON_STUBS

#else	// COMPILE_MULTIMON_STUBS

extern int	WINAPI xGetSystemMetrics(int);
extern HMONITOR WINAPI xMonitorFromWindow(HWND, UINT);
extern HMONITOR WINAPI xMonitorFromRect(LPCRECT, UINT);
extern HMONITOR WINAPI xMonitorFromPoint(POINT, UINT);
extern BOOL	WINAPI xGetMonitorInfo(HMONITOR, LPMONITORINFO);
extern BOOL	WINAPI xEnumDisplayMonitors(HDC, LPCRECT, MONITORENUMPROC, LPARAM);

#endif	// COMPILE_MULTIMON_STUBS

//
// build defines that replace the regular APIs with our versions
//
#define GetSystemMetrics    xGetSystemMetrics
#define MonitorFromWindow   xMonitorFromWindow
#define MonitorFromRect     xMonitorFromRect
#define MonitorFromPoint    xMonitorFromPoint
#define GetMonitorInfo      xGetMonitorInfo
#define EnumDisplayMonitors xEnumDisplayMonitors

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif  /* !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mmfw.rc
//
#define IDD_DOWNLOADPROGRESS            100
#define IDI_MMFW                        101
#define IDR_MMFW                        102
#define IDB_BACKGRND                    103
#define IDB_PLAY                        104
#define IDB_STOP                        105
#define IDB_EJECT                       106
#define IDB_REW                         107
#define IDB_FFWD                        108
#define IDB_PREVTRACK                   109
#define IDB_NEXTTRACK                   110
#define IDB_NDISC                       111
#define IDB_FRAME_TOOLKIT               112
#define IDB_CLOSE                       124
#define IDB_TRACK                       127
#define IDB_COVER                       128
#define IDB_NET                         129
#define IDB_DVDMAIN                     137
#define IDB_ALLTRANS                    140
#define IDB_DISC                        141
#define IDB_HELP                        142
#define IDB_OPTIONS                     143
#define IDB_MODE                        144
#define IDB_VOLUME_MINUS                145
#define IDB_VOLUME_PLUS                 146
#define IDB_VOLUME                      147
#define IDB_ALLTRANS_DOWN               148
#define IDB_ALLTRANS_HIGHLIGHT          150
#define IDB_MINIMIZE                    151
#define IDB_SET_TINY_MODE               152
#define IDB_SET_NORMAL_MODE             153
#define IDB_BUTTON_TOOLKIT              154
#define IDB_KNOB                        155
#define IDB_KNOB_LIGHT                  156
#define IDB_KNOB_LIGHTMASK              157
#define IDB_NOTCH                       158
#define IDB_KNOB_LIGHT_DIM              159
#define IDB_KNOB_TABSTATE               160
#define IDB_MUTE                        161
#define IDC_STATIC_INFO                 198
#define IDB_BUTTON_OVERLAYS             200
#define IDI_ICON_STOP                   202
#define IDI_ICON_EJECT                  203
#define IDI_ICON_REW                    204
#define IDI_ICON_FFWD                   205
#define IDI_ICON_PREV                   206
#define IDI_ICON_NEXT                   208
#define IDI_ICON_MODE                   209
#define IDI_ICON_COVER                  210
#define IDI_ICON_VMINUS                 212
#define IDI_ICON_VPLUS                  213
#define IDI_ICON_SYSTEM                 214
#define IDI_ICON_MINIMIZE               215
#define IDI_ICON_PAUSE                  216
#define IDI_ICON_PLAY                   217
#define IDC_VOLHAND                     219
#define IDC_VOLVERT                     220
#define IDC_VOLHORZ                     221
#define IDC_VOLDPOS                     222
#define IDC_VOLDNEG                     223
#define IDC_MUTE                        224

#define IDB_FRAME_TOOLKIT_16            300
#define IDB_BUTTON_TOOLKIT_16           301
#define IDB_KNOB_LIGHT_16               302
#define IDB_KNOB_LIGHT_DIM_16           303
#define IDB_KNOB_16                     304
#define IDB_KNOB_TABSTATE_16            305
#define IDB_NOTCH_16                    306

#define IDB_FRAME_TOOLKIT_HI            400
#define IDB_BUTTON_TOOLKIT_HI           401
#define IDB_KNOB_LIGHT_HI               402
#define IDB_KNOB_LIGHT_DIM_HI           403
#define IDB_KNOB_HI                     404
#define IDB_KNOB_TABSTATE_HI            405
#define IDB_NOTCH_HI                    406
#define IDI_MODE_NORMAL                 500
#define IDI_MODE_REPEATONE              501
#define IDI_MODE_REPEATALL              502
#define IDI_MODE_RANDOM                 503
#define IDI_MODE_INTRO                  504
#define IDI_SHELL_PLAY                  505
#define IDI_SHELL_PAUSE                 506
#define IDI_SHELL_NODISC                507

//note: do not use 10000 - 20000 for menu ids
#define IDM_NET_UPDATE                  30000
#define IDM_NET_CANCEL                  30001
#define IDM_NET_BAND                    30002
#define IDM_NET_CD                      30003
#define IDM_NET_BILLBOARD_ARTIST        30004
#define IDM_NET_BILLBOARD_ALBUM         30005
#define IDM_NET_ROLLINGSTONE_ARTIST     30006
#define LAST_SEARCH_MENU_ID             IDM_NET_ROLLINGSTONE_ARTIST
#define IDM_OPTIONS                     35000
#define IDM_PLAYLIST                    35001
#define IDM_HELP                        35002
#define IDM_ABOUT                       35003
#define IDM_NORMAL                      35004
#define IDM_TINY                        35005
#define IDM_EXIT                        35006
#define IDM_EXIT_SHELL                  35007
#define IDM_MODE_NORMAL                 36005
#define IDM_MODE_REPEATONE              36006
#define IDM_MODE_REPEATALL              36007
#define IDM_MODE_RANDOM                 36008
#define IDM_MODE_INTRO                  36009
#define IDM_OPENVIRTUALCD               36010
#define IDC_METER                       45001
#define IDS_MBUTTON_FONT                57602
#define IDS_APPNAME                     57603
#define IDS_NOCOMPREGISTERED            57604
#define IDS_BADCOMPREGISTERED           57605
#define IDS_ERRORLOADINGCOMP            57606
#define IDS_NOTHINGREGISTERED           57607
#define IDS_HOMEPAGEFORMAT              57608
#define IDS_FOUND                       57609
#define IDS_NOTFOUND1                   57610
#define IDS_NOTFOUND                    57611
#define IDS_BADPROVIDER                 57612
#define IDS_BILLBOARD_FORMAT_ARTIST     57613
#define IDS_BILLBOARD_FORMAT_ALBUM      57614
#define IDS_TITLE_NOT_FOUND             57615
#define IDS_DB_FAILURE                  57616
#define IDS_REINSTALL                   57617
#define IDS_WAITINGFORDOWNLOAD          57618
#define IDS_ROLLINGSTONE_FORMAT_ARTIST  57619
#define IDS_NET_FAILURE                 57620
#define IDB_TT_PLAY                     58000
#define IDB_TT_PAUSE                    58001
#define IDB_TT_STOP                     58002
#define IDB_TT_EJECT                    58003
#define IDB_TT_REW                      58004
#define IDB_TT_FFWD                     58005
#define IDB_TT_PREVTRACK                58006
#define IDB_TT_NEXTTRACK                58007
#define IDB_TT_NDISC                    58008
#define IDB_TT_CLOSE                    58009
#define IDB_TT_TRACK                    58010
#define IDB_TT_MUTE                     58011
#define IDB_TT_NET                      58012
#define IDB_TT_DISC                     58013
#define IDB_TT_OPTIONS                  58014
#define IDB_TT_HELP                     58015
#define IDB_TT_MODE                     58016
#define IDB_TT_VOLUME                   58017
#define IDB_TT_MINIMIZE                 58018
#define IDB_TT_RESTORE                  58019
#define IDB_TT_MAXIMIZE                 58020
#define IDB_TT_INTRO                    58021
#define IDM_NET_SEARCH_HEADING          58030
#define IDM_NET_PROVIDER_HEADING        58040
#define IDS_SH_TRANS                    58050
#define IDS_SH_TRACK                    58051
#define IDS_SH_NET                      58052
#define IDS_SH_DISC                     58053
#define IDS_SH_OPTIONS                  58054
#define IDS_SH_MODE                     58055
#define IDS_SH_PLAY                     58056
#define IDS_SH_STOP                     58057
#define IDS_SH_PAUSE                    58058
#define IDS_SH_EJECT                    58059
#define IDS_SH_PREVTRACK                58060
#define IDS_SH_NEXTTRACK                58061
#define IDS_RIPPING_CD                  58062
                   
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        218
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdnet\cdnet.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Contains CD Networking Interfaces and Prototypes
//
//	Copyright (c) Microsoft Corporation	1998
//    
//	1/6/98 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _CDNET_PUBLICINTEFACES_
#define _CDNET_PUBLICINTEFACES_

#include <objbase.h>
#include "..\cdopt\cdopt.h"

#ifdef __cplusplus
extern "C" {
#endif

#define WM_NET_DONE                     (WM_USER+1000) //wparam = unused, lparam = discid or status
#define WM_NET_STATUS                   (WM_USER+1001) //wparam = hinst, lparam = string id
#define WM_NET_CHANGEPROVIDER           (WM_USER+1002) //wparam = num to download, lparam = LPCDPROVIDER
#define WM_NET_INCMETER                 (WM_USER+1003) //wparam = hinst, lparam = discid
#define WM_NET_DB_FAILURE               (WM_USER+1004) //wparam = unused, lparam = unused
#define WM_NET_DB_UPDATE_BATCH          (WM_USER+1005) //no params, called to update batch with added disc
#define WM_NET_DB_UPDATE_DISC           (WM_USER+1006) //lparam = punit, called to update disc info in playlist
#define WM_NET_NET_FAILURE              (WM_USER+1007) //wparam = unused, lparam = unused

#define UPLOAD_STATUS_CANCELED          0
#define UPLOAD_STATUS_NO_PROVIDERS      1
#define UPLOAD_STATUS_SOME_PROVIDERS    2
#define UPLOAD_STATUS_ALL_PROVIDERS     3

const CLSID CLSID_CDNet = {0xE5927147,0x521E,0x11D1,{0x9B,0x97,0x00,0xC0,0x4F,0xA3,0xB6,0x0F}};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Definitions 
//
// Defines the GUIDs / IIDs for this project:
//
// IID_IMMFWNotifySink, IMMComponent, IMMComponentAutomation
//
// These are the three interfaces for Framework / Component communications.
// All other interfaces should be private to the specific project.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define lCDNETIIDFirst			    0xb2cd5bbc
#define DEFINE_CDNETIID(name, x)	DEFINE_GUID(name, lCDNETIIDFirst + x, 0x5221,0x11d1,0x9b,0x97,0x0,0xc0,0x4f,0xa3,0xb6,0xc)

DEFINE_CDNETIID(IID_ICDNet,	0);

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Typedefs
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef interface ICDNet	    	ICDNet;
typedef ICDNet*	    			    LPCDNET;

#ifndef LPUNKNOWN
typedef IUnknown*   						LPUNKNOWN;
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Definitions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE ICDNet
DECLARE_INTERFACE_(ICDNet, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;

    //---  ICDNet methods--- 
	STDMETHOD (SetOptionsAndData)		(THIS_	void* pOpt, void* pData) PURE;
	STDMETHOD (Download)				(THIS_	DWORD dwDeviceHandle, TCHAR chDrive, DWORD dwMSID, LPCDTITLE pTitle, BOOL fManual, HWND hwndParent) PURE;
	STDMETHOD_(BOOL,IsDownloading)		(THIS_) PURE;
    STDMETHOD (CancelDownload)          (THIS_) PURE;
	STDMETHOD (Upload)  				(THIS_	LPCDTITLE pTitle, HWND hwndParent) PURE;
	STDMETHOD_(BOOL,CanUpload)			(THIS_) PURE;
};

#ifdef __cplusplus
};
#endif

#endif  //_MMFRAMEWORK_PUBLICINTEFACES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdnet\condlg.cpp ===
/******************************Module*Header*******************************\
* Module Name: condlg.cpp
*
* Author:  David Stewart [dstewart]
*
* Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#include "windows.h"
#include "condlg.h"
#include "netres.h"
#include "..\cdopt\cdopt.h"
#include <htmlhelp.h>
#include "icwcfg.h"

extern HINSTANCE g_dllInst;
TCHAR g_Drive;

BOOL InternetConnectionWizardHasRun()
{
    HKEY hKey;
    DWORD dwICWCompleted = 0;

    if (RegOpenKey(HKEY_CURRENT_USER, TEXT(ICW_REGPATHSETTINGS), &hKey) == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(dwICWCompleted);
        RegQueryValueEx(hKey, TEXT(ICW_REGKEYCOMPLETED), NULL, NULL, (LPBYTE)&dwICWCompleted, &dwSize);
        RegCloseKey(hKey);
    }

    if (dwICWCompleted > 0)
    {
        return TRUE;
    }
    
    return FALSE;
}

void LaunchICW()
{
    HINSTANCE hInetCfgDll = LoadLibrary(TEXT("inetcfg.dll"));

    if (hInetCfgDll)
    {
        PFNCHECKCONNECTIONWIZARD fp = (PFNCHECKCONNECTIONWIZARD)GetProcAddress(hInetCfgDll, "CheckConnectionWizard");
        if (fp)
        {
            DWORD dwRet;
            DWORD dwFlags = ICW_LAUNCHFULL | ICW_LAUNCHMANUAL | ICW_FULL_SMARTSTART;

            // Launch ICW full or manual path, whichever is available
            // NOTE: the ICW code makes sure only a single instance is up
            fp(dwFlags, &dwRet);
        }
        FreeLibrary(hInetCfgDll);
    }
}

BOOL _InternetGetConnectedState(DWORD* pdwHow, DWORD dwReserved, BOOL fConnect)
{
    //note: to make this work on Win95 machines, set retval to true by default
    BOOL retval = FALSE;

    //check to see if we have configured the connection already
    if (!InternetConnectionWizardHasRun())
    {
        //nope, so we need to run the ICW and return FALSE here
        LaunchICW();
        return FALSE;
    }

    HMODULE hNet = LoadLibrary(TEXT("WININET.DLL"));
    if (hNet!=NULL)
    {
	    typedef BOOL (PASCAL *CONPROC)(DWORD*, DWORD);
	    CONPROC conProc = (CONPROC)GetProcAddress(hNet,"InternetGetConnectedState");
	    if (conProc)
	    {
	        retval = conProc(pdwHow,dwReserved);

            if ((!retval) && (*pdwHow &1)) //INTERNET_CONNECTION_MODEM
            {
                if (fConnect)
                {
    	            typedef BOOL (PASCAL *DIALPROC)(DWORD, DWORD);
                    DIALPROC dialProc = (DIALPROC)GetProcAddress(hNet,"InternetAutodial");
                    if (dialProc)
                    {
                        retval = dialProc(1,0); //INTERNET_AUTODIAL_FORCE_ONLINE
                    }
                } //end if connect
            } //end if not online, but with a modem
	    } //end if connection proc available
	    FreeLibrary(hNet);
    }

    return (retval);
}

INT_PTR CALLBACK ConDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static LPCDOPTDATA pOptionData = NULL;

    switch (message)
    {
        case WM_INITDIALOG :
        {
            pOptionData = (LPCDOPTDATA)lParam;

            SendDlgItemMessage(hwnd,IDC_RADIO_DOWNLOAD_ONE,BM_SETCHECK,1,0);

            RECT rectDialog;
            GetWindowRect(hwnd,&rectDialog);

            SetWindowPos(hwnd,
                         GetParent(hwnd),
                         (GetSystemMetrics(SM_CXSCREEN)/2) - ((rectDialog.right - rectDialog.left) /2),
                         (GetSystemMetrics(SM_CYSCREEN)/2) - ((rectDialog.bottom - rectDialog.top) /2),
                         0,
                         0,
                         SWP_NOSIZE);

            //title of dialog is a "format string" with room for a single char drive letter
            TCHAR szFormat[MAX_PATH];
            TCHAR szTitle[MAX_PATH];
            GetWindowText(hwnd,szFormat,sizeof(szFormat)/sizeof(TCHAR));
            wsprintf(szTitle,szFormat,g_Drive);
            SetWindowText(hwnd,szTitle);
        }
        break;
    
        case WM_COMMAND :
        {
            switch (LOWORD(wParam))
            {
                case (IDOK) :
                {
                    if (SendDlgItemMessage(hwnd,IDC_RADIO_DOWNLOAD_ALL,BM_GETCHECK,0,0))
                    {
                        pOptionData->fDownloadPrompt = FALSE;
                    }

                    EndDialog(hwnd,CONNECTION_GETITNOW);
                }
                break;

                case (IDCANCEL) :
                {                      
                    if (pOptionData->fBatchEnabled)
                    {
                        EndDialog(hwnd,CONNECTION_BATCH);
                    }
                    else
                    {
                        EndDialog(hwnd,CONNECTION_DONOTHING);
                    } 
                }
                break;

                case (IDC_DOWNLOAD_HELP) :
                { 
                    #ifndef DEBUG
                    HtmlHelp(hwnd, TEXT("deluxcd.chm>main"), HH_DISPLAY_TOPIC, (DWORD_PTR) TEXT("CDX_overview.htm"));
                    #endif
                }
                break;
            } // end switch on WM_COMMAND
        } //end case WM_COMMAND
        break;
    }

    return FALSE;
}

int ConnectionCheck(HWND hwndParent, void* pPassedOpt, TCHAR chDrive)
{
    if (!pPassedOpt)
    {
        return CONNECTION_DONOTHING;
    }

    LPCDOPT pOpt = (LPCDOPT)pPassedOpt;

    LPCDOPTIONS pOptions = pOpt->GetCDOpts();
    LPCDOPTDATA pOptionData = pOptions->pCDData;

    if ((pOptionData->fDownloadPrompt) && (pOptionData->fDownloadEnabled))
    {
        //set global drive letter for dialog box
        g_Drive = chDrive;

        //no options selected, so prompt instead
        int nSelection = (int)DialogBoxParam(g_dllInst, MAKEINTRESOURCE(IDD_DIALOG_DOWNLOAD),
                   hwndParent, ConDlgProc, (LPARAM)pOptionData );

        pOpt->UpdateRegistry();

        return nSelection;
    }

    if (pOptionData->fDownloadEnabled)
    {
        return CONNECTION_GETITNOW;
    }

    if (pOptionData->fBatchEnabled)
    {
        return CONNECTION_BATCH;
    }

    return CONNECTION_DONOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdnet\condlg.h ===
/******************************Module*Header*******************************\
* Module Name: condlg.h
*
* Author:  David Stewart [dstewart]
*
* Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#ifndef _CONDLG_
#define _CONDLG_

#define CONNECTION_DONOTHING      0
#define CONNECTION_BATCH          1
#define CONNECTION_GETITNOW       2

BOOL _InternetGetConnectedState(DWORD* pdwHow, DWORD dwReserved, BOOL fConnect);
int ConnectionCheck(HWND hwndParent, void* pPassedOpt, TCHAR chDrive);

#endif //_CONDLG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\mmfw.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Contains Multimedia Framework Interfaces and Prototypes
//
//	Copyright (c) Microsoft Corporation	1997
//    
//	10/31/97 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MMFRAMEWORK_PUBLICINTEFACES_
#define _MMFRAMEWORK_PUBLICINTEFACES_

#include "mmsystem.h"
#include "objbase.h"

#ifdef __cplusplus
extern "C" {
#endif

//literals the app needs to know
#define REG_KEY_NEW_FRAMEWORK TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\DeluxeCD")
#define REG_KEY_FRAMEWORK_COMPONENTS REG_KEY_NEW_FRAMEWORK TEXT("\\Components")
#define FRAMEWORK_CLASS TEXT("MMFRAME_MAIN")
#define MENU_INIFILE_ENTRY TEXT("MENU%i")
#define URL_SEPARATOR TEXT("::")
#define WEBCD_MUTEX TEXT("WEBCD_MUTEX")
#define HELPFILENAME TEXT("DELUXCD.CHM")

//color modes
#define COLOR_VERYHI     0
#define COLOR_256        1
#define COLOR_16         2
#define COLOR_HICONTRAST 3

// Allocator functions for the LIBs that used to be DLLs
void    WINAPI CDNET_Init(HINSTANCE hInst);
void    WINAPI CDNET_Uninit(void);
HRESULT WINAPI CDNET_CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj);
HRESULT WINAPI CDPLAY_CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj);
HRESULT WINAPI CDOPT_CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj);

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Definitions 
//
// Defines the GUIDs / IIDs for this project:
//
// IID_IMMFWNotifySink, IMMComponent, IMMComponentAutomation
//
// These are the three interfaces for Framework / Component communications.
// All other interfaces should be private to the specific project.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define lMMFWIIDFirst			0xb2cd5bbb
#define DEFINE_MMFWIID(name, x)	DEFINE_GUID(name, lMMFWIIDFirst + x, 0x5221,0x11d1,0x9b,0x97,0x0,0xc0,0x4f,0xa3,0xb6,0xc)

DEFINE_MMFWIID(IID_IMMFWNotifySink,	    	0);
DEFINE_MMFWIID(IID_IMMComponent,	    	1);
DEFINE_MMFWIID(IID_IMMComponentAutomation,  2);

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Typedefs
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef interface IMMFWNotifySink	    	IMMFWNotifySink;
typedef IMMFWNotifySink*	    			LPMMFWNOTIFYSINK;

typedef interface IMMComponent  			IMMComponent;
typedef IMMComponent*   					LPMMCOMPONENT;

typedef interface IMMComponentAutomation    IMMComponentAutomation;
typedef IMMComponentAutomation*             LPMMCOMPONENTAUTOMATION;

#ifndef LPUNKNOWN
typedef IUnknown*   						LPUNKNOWN;
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	HRESULT Return Codes
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

// Success Codes

#define MM_S_FIRST			(OLE_S_FIRST + 9000)

#define S_FINISHED          (S_OK)
#define	S_CONTINUE			(MM_S_FIRST + 1)
#define S_CHECKMENU         (MM_S_FIRST + 2)

// Error Codes

#define MM_E_FIRST				(OLE_E_FIRST + 9000)

#define E_NOTINITED             (MM_E_FIRST + 1)
#define E_INCOMPATIBLEDLL		(MM_E_FIRST + 2)
#define E_GRAYMENU              (MM_E_FIRST + 3)


///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Common enums
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMEVENTS = Event notifications that should be send to the framework via the NotifySink.
//            This allows the framework to do things like fire events to a web browser's script language
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum MMEVENTS
{
	MMEVENT_SETTITLE	    = 0,    //change title of playing media
	MMEVENT_CHANGEUIELEMENT	= 1,	//indicates major change in display, transport, or menu (i.e. handle is now different)
	MMEVENT_ONPLAY		    = 2,    //begin playing media
	MMEVENT_ONSTOP			= 3,    //stop media
    MMEVENT_ONPAUSE         = 4,    //pause media
	MMEVENT_ONUSERNOTIFY	= 5,    //use instead of putting up your own message boxes ... framework may have alternative display method
    MMEVENT_ONMEDIALOADED   = 6,    //media has been loaded
    MMEVENT_ONMEDIAUNLOADED = 7,    //media has been unloaded
    MMEVENT_ONTRACKCHANGED  = 8,    //media track changed
    MMEVENT_ONDISCCHANGED   = 9,    //disc changed
    MMEVENT_ONSETVOLUME     = 10,    //device volume changed
    MMEVENT_ONERROR         = 11    //error occurred
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMACTIONS = Commands sent to IMMComponentAutomation.
//             This allows the framework to drive the component without UI (i.e. in a web script)
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum MMACTIONS
{
	MMACTION_PLAY		    = 0,	
	MMACTION_STOP	    	= 1,	
	MMACTION_SETPOSITION	= 2,
	MMACTION_LOADMEDIA      = 3,
   	MMACTION_UNLOADMEDIA    = 4,
    MMACTION_NEXTTRACK      = 5,
    MMACTION_PREVTRACK      = 7,
    MMACTION_PAUSE          = 8,
    MMACTION_REWIND         = 9,
    MMACTION_FFWD           = 10,
    MMACTION_NEXTMEDIA      = 11,
    MMACTION_GETMEDIAID     = 12,
    MMACTION_READSETTINGS   = 13,
    MMACTION_GETTRACKINFO   = 14,
    MMACTION_GETDISCINFO    = 15,
    MMACTION_SETTRACK       = 16,
    MMACTION_SETDISC        = 17,
    MMACTION_GETNETQUERY    = 18,
}; 

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMICONSIZES =  The various sizes for icons the framework can request.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum MMICONSIZES
{
    MMICONSIZE_16BY16       = 16,
    MMICONSIZE_32BY32       = 32,
    MMICONSIZE_48BY48       = 48
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMINFOTEXT = Different types of text requested in IMMComponent::GetText.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum MMINFOTEXT
{
    MMINFOTEXT_TITLE        = 0,
    MMINFOTEXT_ARTIST       = 1,
    MMINFOTEXT_MEDIATYPE    = 2,
    MMINFOTEXT_DESCRIPTION  = 3,
    MMINFOTEXT_MENULABEL    = 4,
    MMINFOTEXT_MENUPROMPT   = 5,
    MMINFOTEXT_MEDIAID      = 6
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMUIELEMENTS = FLAGS for use with MMEVENT_CHANGEUIELEMENT
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum MMUIELEMENTS
{
    MMUIELEMENT_DISPLAY      = 1,
    MMUIELEMENT_TRANSPORT    = 2,
    MMUIELEMENT_MENU         = 4
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMPOSTYPE = Indicator of type of positioning scheme used.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum MMPOSTYPE
{
    MMPOSTYPE_SAMPLES        = 0,
    MMPOSTYPE_MILLISECONDS   = 1,
    MMPOSTYPE_BYTES          = 2,
    MMPOSTYPE_SMPTE          = 3,
    MMPOSTYPE_CDFRAMES       = 4
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Type definitions
//
// Structs for Events and Actions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
				
typedef struct MMNET
{
    DWORD discid;
    BOOL  fForceNet;
    HWND  hwndCallback;
    void* pData;
    void* pData2;
} MMNET, *LPMMNET;

typedef struct MMSETTITLE
{
    MMINFOTEXT      mmInfoText;
    LPTSTR          szTitle;
} MMSETTITLE, *LPMMSETTITLE;

typedef struct MMCHANGEUIELEMENT
{
    MMUIELEMENTS    mmElementFlag;
    HANDLE          hElement;
} MMCHANGEUIELEMENT, *LPMMCHANGEUIELEMENT;

typedef struct MMONSTOP
{
    int             nReason;
    DWORD           dwPosition;
} MMONSTOP, *LPMMONSTOP;

typedef struct MMONUSERNOTIFY
{
    LPTSTR          szNotification;
    UINT            uType; //see MessageBox API in Win32 SDK
} MMONUSERNOTIFY, *LPMMONUSERNOTIFY;

typedef struct MMONMEDIALOADED
{
    LPTSTR          szMediaName;
} MMONMEDIALOADED, *LPMMONMEDIALOADED;

typedef struct MMONTRACKCHANGED
{
    int             nNewTrack;
} MMONTRACKCHANGED, *LPMMONTRACKCHANGED;

typedef struct MMONDISCCHANGED
{
    int             nNewDisc;
    BOOL            fDisplayVolChange;
} MMONDISCCHANGED, *LPMMONDISCCHANGED;

typedef struct MMONVOLCHANGED
{
    DWORD           dwNewVolume;
    BOOL            fMuted;
    TCHAR*          szLineName;
} MMONVOLCHANGED, *LPMMONVOLCHANGED;

typedef struct MMONERROR
{
    MMRESULT        mmrErrorCode;
    LPTSTR          szErrorString;
} MMONERROR, *LPMMONERROR;

typedef struct MMSETPOSITION
{
    MMPOSTYPE       mmPosType;
    DWORD           dwPosition;
} MMSETPOSITION, *LPMMSETPOSITION;

typedef struct MMLOADMEDIA
{
    LPTSTR          szMedia;
} MMLOADMEDIA, *LPMMLOADMEDIA;

typedef struct MMCHANGETRACK
{
    int             nNewTrack;
} MMCHANGETRACK, *LPMMCHANGETRACK;

typedef struct MMCHANGEDISC
{
    int             nNewDisc;
} MMCHANGEDISC, *LPMMCHANGEDISC;

typedef struct MMTRACKORDISC
{
    int     nNumber;  //input to call: sequential number of track or disc we are requesting
    BOOL    fCurrent; //returned from call to say that track or disc request is current
    int     nID;      //unique ID of track or disc returned from call
    TCHAR   szName[MAX_PATH]; //name of track or disc returned from call
} MMTRACKORDISC, *LPMMTRACKORDISC;

typedef struct MMMEDIAID
{
    int     nDrive; //-1 means "use current"
    DWORD   dwMediaID;
    DWORD   dwNumTracks;
    TCHAR   szMediaID[MAX_PATH];
    TCHAR   szTitle[MAX_PATH];
    TCHAR   szTrack[MAX_PATH];
    TCHAR   szArtist[MAX_PATH];
} MMMEDIAID, *LPMMMEDIAID;

typedef struct MMNETQUERY
{
    int     nDrive; //-1 means "use current"
    TCHAR*  szNetQuery;
} MMNETQUERY, *LPMMNETQUERY;

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Definitions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE IMMFWNotifySink
DECLARE_INTERFACE_(IMMFWNotifySink, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;

    //---  IMMFWNotifySink methods--- 

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMFWNotifySink::OnEvent

    This is the component's primary method of communication back to the framework.
    
    It is used to indicate that something has changed so that the framework can update its
    UI or fire an event through to the web scripting language, etc.  The component
    should not expect that the framework will actually do anything with any notification.

    mmEventID = Event enum indicating type of event
    pEvent = Pointer to structure of type associated with mmEventID

    return values = S_OK, E_FAIL
                    Except for MMEVENT_ONUSERNOTIFY, hr = MessageBox response value
///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
	STDMETHOD (OnEvent) 				(THIS_	MMEVENTS mmEventID, 
												LPVOID pEvent) PURE;
/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMFWNotifySink::GetCustomMenu

    Returns the custom menu object for the framework

///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    STDMETHOD_(void*,GetCustomMenu)       (THIS) PURE;

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMFWNotifySink::GetPalette

    Returns the custom palette handle for the framework

///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    STDMETHOD_(HPALETTE,GetPalette)       (THIS) PURE;

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMFWNotifySink::GetOptions

    Returns the options object for the framework

///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    STDMETHOD_(void*,GetOptions)       (THIS) PURE;

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMFWNotifySink::GetData

    Returns the data object for the framework

///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    STDMETHOD_(void*,GetData)       (THIS) PURE;
};

/*
*****************************************************************************
About Registering Components

Components should be registered under:

HKCU\Software\Microsoft\MediaFramework\Components\<component guid>
    Default = "Friendly Name"
    HandlesExtensions = "File extensions (without periods) that this handles" (optional)
    HandlesTypes = "Media types supported, such as 'cdaudio' or 'wave'"
    Command = "Command line that will trigger this component to be shown by default, just text, no slashes"

The component's class factory should be registered like an inproc server:

HKCR\CLSID\<component guid>
    Default = "Name"
    \InprocServer32
        Default = "DLL_Full_Path.DLL"
        ThreadingModel = "Apartment"

The following is an example .RGS script file for the Active Template Library:

    HKCR
    {
	    ExampleComp.ExampleComp.1 = s 'ExampleComp Class'
	    {
		    CLSID = s '{E5927147-521E-11D1-9B97-00C04FA3B60C}'
	    }
	    ExampleComp.ExampleComp = s 'ExampleComp Class'
	    {
		    CurVer = s 'ExampleComp.ExampleComp.1'
	    }
	    NoRemove CLSID
	    {
		    ForceRemove {E5927147-521E-11D1-9B97-00C04FA3B60C} = s 'ExampleComp Class'
		    {
			    ProgID = s 'ExampleComp.ExampleComp.1'
			    VersionIndependentProgID = s 'ExampleComp.ExampleComp'
			    InprocServer32 = s '%MODULE%'
			    {
				    val ThreadingModel = s 'Apartment'
			    }
		    }
	    }
    }
    HKCU
    {
	    'Software'
	    {
		    'Microsoft'
		    {
			    'MediaFramework'
			    {
				    'Components'
				    {
					    ForceRemove {E5927147-521E-11D1-9B97-00C04FA3B60C} = s 'Example Component'
                        {
                            HandlesExtensions = s 'wav mid'
                            HandlesTypes = s 'cdaudio'
                            Command = s 'cd'
                        }
				    }
			    }
		    }
	    }
    }

*****************************************************************************
*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Component enlistment structure
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define MAX_NAME 50

typedef struct MMCOMPDATA
{
    DWORD                   dwSize;             //size in bytes of structure
    HICON                   hiconSmall;         //16 by 16 icon
    HICON                   hiconLarge;         //32 by 32 icon
    int                     nAniResID;          //resource id of animated icon
    HINSTANCE               hInst;              //instance handle
    TCHAR                   szName[MAX_NAME];   //name of component
    BOOL                    fVolume;            //supports volume?
    BOOL                    fPan;               //supports pan?
    RECT                    rect;               //suggested rect for display window
} MMCOMPDATA, *LPMMCOMPDATA;

#undef INTERFACE
#define INTERFACE IMMComponent
DECLARE_INTERFACE_(IMMComponent, IUnknown)
{
    //---  IUnknown methods--- 

    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;

    //---  IMMComponent methods--- 
/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMComponent::GetInfo

    This function fills in an MMCOMPDATA structure supplied by the framework.

    The framework will call this function before calling Init.  It is used to
    figure out how to display your component on the switchbar.

    mmCompData = pointer to MMCOMPDATA structure from the framework
    
    return values = S_OK, E_FAIL
///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    STDMETHOD (GetInfo)                 (THIS_ MMCOMPDATA* mmCompData) PURE;

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMComponent::Init

    This function is called when the framework actually wants you to create your
    display window and be ready to play back media.

    If at all possible, you should delay loading anything that will increase your
    memory footprint (i.e. support DLLs) until this call is made.  That will allow
    the framework to load much more quickly and only take the hit if the user actually
    decides to use your component.  Once the Init call is made, however, you will not
    be asked to unload until this object's refcount is 0, which may or may not be when
    the framework itself unloads.

    pSink = pointer to framework notification sink
    hwndMain = handle to main framework window for DirectX calls and others that require it
    pRect = main size and position rect for your window
    phwndComp = out parameter ... store your main window handle here.  All other windows in the
                component should be child windows of this one, so when the framework calls
                show / hide on this main window, all of your childen will show / hide as well
                This window should be created as a child of the "main" window sent into this
                function, and it should be created without the WS_VISIBLE flag set.
    phMenu = out parameter ... store your custom menu handler here, or NULL if not applicable.
    
    return values = S_OK, E_FAIL
///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    STDMETHOD (Init)                    (THIS_ IMMFWNotifySink* pSink, HWND hwndMain, RECT* pRect, HWND* phwndComp, HMENU* phMenu) PURE;
};

#undef INTERFACE
#define INTERFACE IMMComponentAutomation
DECLARE_INTERFACE_(IMMComponentAutomation, IUnknown)
{
    //---  IUnknown methods--- 

    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;
 

    //---  IMMComponentAutomation methods--- 
	
/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    IMMComponentAutomation::OnAction

    If the component supports IMMComponentAutomation, it is able to respond to transport
    control requests without having its UI pressed.  This is handy to allow the user to
    script the component via VBScript or JavaScript on a web page.  The framework will
    handle all of the necessary details; the component just needs to respond appropriately
    to this method.

    mmActionID = Action type indicator
    pAction = Pointer to action structure of type indicated by mmActionID

    return value = S_OK, E_FAIL
///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
	STDMETHOD (OnAction)				(THIS_	MMACTIONS mmActionID, 
												LPVOID pAction) PURE;
};

#ifdef __cplusplus
};
#endif

#endif  //_MMFRAMEWORK_PUBLICINTEFACES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdnet\dllmain.cpp ===
// MMComp.cpp : Implementation of DLL Exports.


#include "windows.h"
#include "netres.h"
#include "tchar.h"
#include "getinfo.h"
#include "cdnet.h"

HINSTANCE g_dllInst = NULL;
HINSTANCE g_hURLMon = NULL;
CRITICAL_SECTION g_Critical;
CRITICAL_SECTION g_BatchCrit;

extern "C"
HRESULT WINAPI CDNET_CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj)
{
    CCDNet* pObj;
    HRESULT hr = E_OUTOFMEMORY;

    *ppvObj = NULL;

    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
    {
        return CLASS_E_NOAGGREGATION;
    }

    pObj = new CCDNet();

    if (NULL==pObj)
    {
        return hr;
    }

    hr = pObj->QueryInterface(riid, ppvObj);

    if (FAILED(hr))
    {
        delete pObj;
    }

    return hr;
}


extern "C"
void WINAPI CDNET_Init(HINSTANCE hInst)
{
    g_dllInst = hInst;
    InitializeCriticalSection(&g_Critical);
    InitializeCriticalSection(&g_BatchCrit);
}

extern "C"
void WINAPI CDNET_Uninit()
{
    if (g_hURLMon)
    {
        FreeLibrary(g_hURLMon);
    }
    DeleteCriticalSection(&g_Critical);
    DeleteCriticalSection(&g_BatchCrit);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\shellico.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  SHELLICO.H
//
//      Shell tray icon handler
//
//      Copyright (c) Microsoft Corporation     1997, 1998
//    
//      3/15/98 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "mmfw.h"
#include "sink.h"

#define SHELLMESSAGE_CDICON (WM_USER+210)
#define IDM_TRACKLIST_SHELL_BASE        15000
#define PLAY_ICON 0
#define PAUSE_ICON 1
#define NODISC_ICON 2

BOOL CreateShellIcon(HINSTANCE hInst, HWND hwndOwner, PCOMPNODE pNode, TCHAR* szTip);
void DestroyShellIcon();
void ShellIconSetTooltip();
void ShellIconSetState(int nIconType);
LRESULT ShellIconHandeMessage(LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdnet\getinfo.h ===
/******************************Module*Header*******************************\
* Module Name: getinfo.h
*
* Author:  David Stewart [dstewart]
*
* Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#if !defined(AFX_CDNETDLG_H__903DF404_39B8_11D1_BA31_00A0C913D47E__INCLUDED_)
#define AFX_CDNETDLG_H__903DF404_39B8_11D1_BA31_00A0C913D47E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "cdnet.h"
#include "wininet.h"

/////////////////////////////////////////////////////////////////////////////
// CGetInfoFromNet

class CCDNet : public ICDNet
{
public:
	CCDNet();
    ~CCDNet();

public:
// IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();
// ICDNet
    STDMETHOD(SetOptionsAndData)(void* pOpt, void* pData);
    STDMETHOD(Download)(DWORD dwDeviceHandle, TCHAR chDrive, DWORD dwMSID, LPCDTITLE pTitle, BOOL fManual, HWND hwndParent);
    STDMETHOD_(BOOL,IsDownloading)();
    STDMETHOD(CancelDownload)();
    STDMETHOD(Upload)(LPCDTITLE pTitle, HWND hwndParent);
    STDMETHOD_(BOOL,CanUpload)();

private:
    DWORD m_dwRef;
};

class CGetInfoFromNet
{
public:
	// Construction
	CGetInfoFromNet(DWORD cdrom, DWORD dwMSID, HWND hwndParent);	// standard constructor
    ~CGetInfoFromNet();

	//main call
	BOOL DoIt(BOOL fManual, LPCDTITLE pTitle, TCHAR chDrive);
    void AddToBatch(int nNumTracks, TCHAR* szQuery);

// Implementation
private:
	//functions
	void BuildQuery();
	int readtoc();

	//data
	unsigned long m_toc[101];
	unsigned long m_TotalLength;
    TCHAR   m_Query[INTERNET_MAX_PATH_LENGTH-INTERNET_MAX_HOST_NAME_LENGTH];
	DWORD m_MS;
	DWORD DevHandle;
    int     m_Tracks;
};

#endif // !defined(AFX_CDNETDLG_H__903DF404_39B8_11D1_BA31_00A0C913D47E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdnet\netres.h ===
// Used by cdnet.rc
//
#define IDC_STATIC_FUNCTION             1000
#define IDD_MULTIPLE_HITS               301
#define IDD_DIALOG_DOWNLOAD             302
#define IDC_LIST_DISCS                  1001
#define IDC_STATIC                      -1

#define IDC_RADIO_DOWNLOAD_ONE          100
#define IDC_RADIO_DOWNLOAD_ALL          101
#define IDC_DOWNLOAD_HELP               102
#define IDI_NEWDISC                     103

#define IDS_STRING_FINDINGRESOURCE      55001
#define IDS_STRING_CONNECTING           55002
#define IDS_STRING_REDIRECTING          55003
#define IDS_STRING_BEGINDOWNLOAD        55004
#define IDS_STRING_DOWNLOAD             55005
#define IDS_STRING_ENDDOWNLOAD          55006
#define IDS_STRING_SENDINGREQUEST       55007

#define IDS_STRING_DEFAULTTRACK         55010
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\sink.cpp ===
// FrameworkNotifySink.cpp: implementation of the CFrameworkNotifySink class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <tchar.h>
#include "sink.h"
#include "mbutton.h"
#include "resource.h"
#include "mmenu.h"
#include "shellico.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

HWND CFrameworkNotifySink::m_hwndTitle = NULL;
extern BOOL fPlaying;
extern BOOL fIntro;
extern BOOL fShellMode;
extern HPALETTE hpalMain; //main palette of app
extern LPCDOPT g_pOptions;
extern LPCDDATA g_pData;
extern HWND hwndMain;

CFrameworkNotifySink::CFrameworkNotifySink(PCOMPNODE pNode)
{
    m_dwRef = 0;
    m_pNode = pNode;

   LoadString(NULL,IDS_APPNAME,m_szAppName,sizeof(m_szAppName)/sizeof(TCHAR));
}

CFrameworkNotifySink::~CFrameworkNotifySink()
{
}

HRESULT CFrameworkNotifySink::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    return S_OK;
}

ULONG CFrameworkNotifySink::AddRef()
{
    return (m_dwRef++);
}

ULONG CFrameworkNotifySink::Release()
{
    m_dwRef--;
    if (m_dwRef == 0)
    {
        delete this;
    }
    return (m_dwRef);
}

HRESULT CFrameworkNotifySink::OnEvent(MMEVENTS mmEventID, LPVOID pEvent)
{
    HRESULT hr = S_OK;

    switch (mmEventID)
    {
        case (MMEVENT_SETTITLE) :
        {
            MMSETTITLE* pSetTitle = (MMSETTITLE*)pEvent;
            if (pSetTitle->mmInfoText == MMINFOTEXT_TITLE)
            {
                if (m_hwndTitle)
                {
                    _tcscpy(m_pNode->szTitle,pSetTitle->szTitle);
                    TCHAR szText[MAX_PATH];
                    wsprintf(szText,TEXT("%s - %s"),pSetTitle->szTitle,m_szAppName);

                    //only do this if the titles don't match
                    TCHAR szOrgTitle[MAX_PATH];
                    GetWindowText(m_hwndTitle,szOrgTitle,sizeof(szOrgTitle)/sizeof(TCHAR));
                    if (_tcscmp(szOrgTitle,szText)!=0)
                    {
                        SetWindowText(m_hwndTitle,szText);
                        RedrawWindow(m_hwndTitle,NULL,NULL,RDW_FRAME|RDW_INVALIDATE);

                        if (fShellMode)
                        {
                            ShellIconSetTooltip();
                        } //end if shell mode
                    }
                } //end if window ok
            } //end if title

            if (pSetTitle->mmInfoText == MMINFOTEXT_DESCRIPTION)
            {
                if (IsIconic(m_hwndTitle))
                {
                    TCHAR szText[MAX_PATH];
                    wsprintf(szText,TEXT("%s - %s"),pSetTitle->szTitle,m_szAppName);
                    SetWindowText(m_hwndTitle,szText);
                }

                if (fShellMode)
                {
                    ShellIconSetTooltip();
                }
            } //end if description
        }
        break;
           
        case (MMEVENT_ONPLAY) :
        {
			CMButton* pButton = GetMButtonFromID(m_hwndTitle,IDB_PLAY);
            if (pButton)
            {
			    if (fIntro)
                {
                    pButton->SetIcon(IDI_MODE_INTRO);
                    pButton->SetToolTipID(IDB_TT_INTRO);
                    SetWindowText(pButton->GetHWND(),TEXT("2"));
                }
                else
                {
                    pButton->SetIcon(IDI_ICON_PAUSE);
                    pButton->SetToolTipID(IDB_TT_PAUSE);
                    SetWindowText(pButton->GetHWND(),TEXT("1"));
                }
            }

            if (fShellMode)
            {
                ShellIconSetState(PAUSE_ICON);
            } //end if shell mode

			fPlaying = TRUE;
        }
        break;

        case (MMEVENT_ONSTOP) :
        {
            CMButton* pButton = GetMButtonFromID(m_hwndTitle,IDB_PLAY);
            if (pButton)
            {
                pButton->SetIcon(IDI_ICON_PLAY);
                pButton->SetToolTipID(IDB_TT_PLAY);
                SetWindowText(pButton->GetHWND(),TEXT(""));
            }

            fPlaying = FALSE;
            if (fShellMode)
            {
                ShellIconSetState(PLAY_ICON);
            } //end if shell mode
        }
        break;

        case (MMEVENT_ONPAUSE) :
        {
            CMButton* pButton = GetMButtonFromID(m_hwndTitle,IDB_PLAY);
            if (pButton)
            {
                pButton->SetIcon(IDI_ICON_PLAY);
                pButton->SetToolTipID(IDB_TT_PLAY);
                SetWindowText(pButton->GetHWND(),TEXT(""));
            }

            fPlaying = FALSE;
            if (fShellMode)
            {
                ShellIconSetState(PLAY_ICON);
            } //end if shell mode
        }
        break;

        case (MMEVENT_ONMEDIAUNLOADED) :
        {
            CMButton* pButton = GetMButtonFromID(m_hwndTitle,IDB_PLAY);
            if (pButton)
            {
                pButton->SetIcon(IDI_ICON_PLAY);
                pButton->SetToolTipID(IDB_TT_PLAY);
                SetWindowText(pButton->GetHWND(),TEXT(""));
            }

            fPlaying = FALSE;
            if (fShellMode)
            {
                ShellIconSetState(NODISC_ICON);
            } //end if shell mode
        }
        break;

        case (MMEVENT_ONUSERNOTIFY) :
        {
        }
        break;

        case (MMEVENT_ONDISCCHANGED) :
        {
            MMONDISCCHANGED* pDisc = (MMONDISCCHANGED*)pEvent;
            SendMessage(m_hwndTitle,WM_DISCCHANGED,pDisc->nNewDisc,pDisc->fDisplayVolChange);
        }
        break;
    }

    return hr;
}

void* CFrameworkNotifySink::GetCustomMenu()
{
    CustomMenu* pMenu = NULL;
    AllocCustomMenu(&pMenu);

    return (pMenu);
}

HPALETTE CFrameworkNotifySink::GetPalette()
{
    return hpalMain;
}

void* CFrameworkNotifySink::GetOptions()
{
    return ((void*)GetCDOpt());
}

void* CFrameworkNotifySink::GetData()
{
    return ((void*)GetCDData());
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetCDOpt
// Creates or returns the global CDOpt
////////////////////////////////////////////////////////////////////////////////////////////
LPCDOPT GetCDOpt()
{
    if (g_pOptions == NULL)
    {
        CDOPT_CreateInstance(NULL, IID_ICDOpt, (void**)&g_pOptions);
    }

    return g_pOptions;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetCDData
// Creates or returns the global CDOpt
////////////////////////////////////////////////////////////////////////////////////////////
LPCDDATA GetCDData()
{
    if (g_pData == NULL)
    {
        HRESULT hr = CDOPT_CreateInstance(NULL, IID_ICDData, (void**)&g_pData);
    }

    return g_pData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\cdopti.h ===
//--------------------------------------------------------------------------;
//
//  File: cdopti.h  (internal to this module)
//
//  CD Player Plus! options Dialog.
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;

#ifndef _CDOPTINTERNAL_PUBLICINTEFACES_
#define _CDOPTINTERNAL_PUBLICINTEFACES_

#include "optres.h"
#include "cdopt.h"

// Intro time range (for CDOPTS.dwIntroTime)
#define CDINTRO_MIN_TIME    (1)
#define CDINTRO_MAX_TIME    (20)

// Default values

#define CDDEFAULT_INTRO             (5)
#define CDDEFAULT_DISP              CDDISP_TRACKTIME
#define CDDEFAULT_START             TRUE
#define CDDEFAULT_EXIT              TRUE
#define CDDEFAULT_TOP               FALSE
#define CDDEFAULT_TRAY              FALSE
#define CDDEFAULT_PLAY              (0)
#define CDDEFAULT_DOWNLOADENABLED   TRUE
#define CDDEFAULT_DOWNLOADPROMPT    TRUE
#define CDDEFAULT_BATCHENABLED      TRUE
#define CDDEFAULT_BYARTIST          FALSE
#define CDDEFAULT_CONFIRMUPLOAD     TRUE




#endif  //_CDOPTINTERNAL_PUBLICINTEFACES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\shellico.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  SHELLICO.CPP
//
//      Shell tray icon handler
//
//      Copyright (c) Microsoft Corporation     1998
//    
//      3/15/98 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <tchar.h>
#include <shellapi.h>
#include "shellico.h"
#include "mmenu.h"
#include "resource.h"

#define IDM_HOMEMENU_BASE               (LAST_SEARCH_MENU_ID + 1)
#define IDM_NETMENU_BASE                (LAST_SEARCH_MENU_ID + 100)
#define IDM_DISCLIST_BASE               20000
#define SHELLTIMERID                    1500

//file-global variables
PCOMPNODE g_pNode = NULL;
IMMComponentAutomation* g_pAuto = NULL;
HWND g_hwnd = NULL;
HINSTANCE g_hInst = NULL;
BOOL g_fShellIconCreated = FALSE;

//icon
HICON hIconPlay = NULL;
HICON hIconPause = NULL;
HICON hIconNoDisc = NULL;

extern fOptionsDlgUp;
extern nCDMode;
extern BOOL fPlaying;
extern BOOL IsDownloading();
extern CustomMenu* g_pMenu;
extern "C" void NormalizeNameForMenuDisplay(TCHAR* szInput, TCHAR* szOutput, DWORD cbLen);

void CheckDiscState()
{
    if (g_fShellIconCreated)
    {
        MMMEDIAID mmMedia;
        mmMedia.nDrive = -1;
        g_pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);

        if (mmMedia.dwMediaID != 0)
        {
            ShellIconSetState(fPlaying ? PAUSE_ICON : PLAY_ICON);
        }
        else
        {
            ShellIconSetState(NODISC_ICON);
        }
    }
}

BOOL CreateShellIcon(HINSTANCE hInst, HWND hwndOwner, PCOMPNODE pNode, TCHAR* sztip)
{
    BOOL retval = FALSE;
    g_hInst = hInst;

	HRESULT hr = pNode->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&g_pAuto);
    if (SUCCEEDED(hr))
    {
        g_pNode = pNode;

        //load all of the icon images
        hIconPlay = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_SHELL_PLAY), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
        hIconPause = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_SHELL_PAUSE), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
        hIconNoDisc = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_SHELL_NODISC), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);

        //now, create the tray icon
        g_hwnd = hwndOwner;
        NOTIFYICONDATA nData;
        nData.cbSize = sizeof(nData);
        nData.hWnd = hwndOwner;
        nData.uID = SHELLMESSAGE_CDICON;
        nData.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
        nData.uCallbackMessage = SHELLMESSAGE_CDICON;
        nData.hIcon = hIconPlay;
        _tcscpy(nData.szTip,sztip);

        retval = Shell_NotifyIcon(NIM_ADD,&nData);

        if (!retval)
        {
            g_pAuto->Release();
            g_pAuto = NULL;
        }
        else
        {
            g_fShellIconCreated = TRUE;
            CheckDiscState();
        }
    }

    return (retval);
}

void DestroyShellIcon()
{
    g_fShellIconCreated = FALSE;

    if (g_pAuto)
    {
        //g_pAuto was addref'ed when we qi'ed for it.
        g_pAuto->Release();
    }

    NOTIFYICONDATA nData;
    nData.cbSize = sizeof(nData);
    nData.uID = SHELLMESSAGE_CDICON;
    nData.hWnd = g_hwnd;
    Shell_NotifyIcon(NIM_DELETE,&nData);

    //kill the icons
    DestroyIcon(hIconPlay);
    DestroyIcon(hIconPause);
    DestroyIcon(hIconNoDisc);

    hIconPlay = NULL;
    hIconPause = NULL;
    hIconNoDisc = NULL;
}

//works around bug in all Windows versions
//where ampersands are stripped from tooltips on shell icon
void EscapeTooltip(TCHAR* szInput, TCHAR* szOutput, DWORD cbLen)
{
    ZeroMemory(szOutput,cbLen);
    WORD index1 = 0;
    WORD index2 = 0;
    for (; ((index1 < _tcslen(szInput)) && (index2 < ((cbLen/sizeof(TCHAR))-1))); index1++)
    {
        szOutput[index2] = szInput[index1];
        if (szOutput[index2] == TEXT('&'))
        {
            szOutput[++index2] = TEXT('&');
            szOutput[++index2] = TEXT('&');
        }
        index2++;
    }
}

void ShellIconSetTooltip()
{
    if (g_fShellIconCreated)
    {
        NOTIFYICONDATA nData;
        nData.cbSize = sizeof(nData);
        nData.hWnd = g_hwnd;
        nData.uID = SHELLMESSAGE_CDICON;
        nData.uFlags = NIF_TIP;

        MMMEDIAID mmMedia;
        mmMedia.nDrive = -1;
        mmMedia.szTrack[0] = TEXT('\0');
        g_pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);

        TCHAR szTempTip[MAX_PATH+sizeof(TCHAR)];
        TCHAR szEscapeTip[MAX_PATH+sizeof(TCHAR)];

        if ((mmMedia.dwMediaID != 0) || (_tcslen(mmMedia.szTrack)!=0))
        {
            //128 + 128 + 4 = 260 ... that's max_path
            wsprintf(szTempTip,TEXT("%s (%s)"),mmMedia.szTitle,mmMedia.szTrack);
        }
        else
        {
            _tcscpy(szTempTip,mmMedia.szTitle);
        }
        
        //escape out & symbols if they are in the string
        if (_tcschr(szTempTip,TEXT('&')))
        {
            EscapeTooltip(szTempTip,szEscapeTip,sizeof(szEscapeTip));
            _tcscpy(szTempTip,szEscapeTip);
        }

        //truncate long tip to size of tooltip
        szTempTip[(sizeof(nData.szTip)/sizeof(TCHAR))-1] = TEXT('\0');
        _tcscpy(nData.szTip,szTempTip);

        Shell_NotifyIcon(NIM_MODIFY,&nData);

        //bit of a hack, but if we're getting a new tool tip, then we might be need to turn
        //on or off the "nodisc" state
        CheckDiscState();
    }
}

void CreateTransportMenu(CustomMenu* pMenu, CustomMenu* pTransMenu)
{
    //play or pause
    if (fPlaying)
    {
        pTransMenu->AppendMenu(IDB_PLAY,g_hInst,IDS_SH_PAUSE);
    }
    else
    {
        pTransMenu->AppendMenu(IDB_PLAY,g_hInst,IDS_SH_PLAY);
    }

    //stop
    pTransMenu->AppendMenu(IDB_STOP,g_hInst,IDS_SH_STOP);

    //eject
    pTransMenu->AppendMenu(IDB_EJECT,g_hInst,IDS_SH_EJECT);

    //previous track
    pTransMenu->AppendMenu(IDB_PREVTRACK,g_hInst,IDS_SH_PREVTRACK);

    //next track
    pTransMenu->AppendMenu(IDB_NEXTTRACK,g_hInst,IDS_SH_NEXTTRACK);

    pMenu->AppendMenu(g_hInst,IDS_SH_TRANS,pTransMenu);
}

void CreateOptionsMenu(CustomMenu* pMenu, CustomMenu* pOptionsMenu)
{
    pOptionsMenu->AppendMenu(IDM_OPTIONS,g_hInst,IDM_OPTIONS);
    pOptionsMenu->AppendMenu(IDM_PLAYLIST,g_hInst,IDM_PLAYLIST);
    pOptionsMenu->AppendSeparator();

//do not bother graying out the playlist menu, it causes too much delay in odbc load
/*
    LPCDDATA pData = GetCDData();
    if (pData)
    {
        if (FAILED(pData->CheckDatabase(g_hwnd)))
        {
            EnableMenuItem(pOptionsMenu->GetMenuHandle(),
                            IDM_PLAYLIST,
                            MF_BYCOMMAND | MF_GRAYED);
        }
    }
*/

    pOptionsMenu->AppendMenu(IDM_HELP,g_hInst,IDM_HELP);

    pMenu->AppendMenu(g_hInst,IDS_SH_OPTIONS,pOptionsMenu);
}

void CreateModeMenu(CustomMenu* pMenu, CustomMenu* pModeMenu)
{
    pModeMenu->AppendMenu(IDM_MODE_NORMAL,g_hInst,IDI_MODE_NORMAL,IDM_MODE_NORMAL);
    pModeMenu->AppendMenu(IDM_MODE_RANDOM,g_hInst,IDI_MODE_RANDOM,IDM_MODE_RANDOM);
    pModeMenu->AppendMenu(IDM_MODE_REPEATONE,g_hInst,IDI_MODE_REPEATONE,IDM_MODE_REPEATONE);
    pModeMenu->AppendMenu(IDM_MODE_REPEATALL,g_hInst,IDI_MODE_REPEATALL,IDM_MODE_REPEATALL);
    pModeMenu->AppendMenu(IDM_MODE_INTRO,g_hInst,IDI_MODE_INTRO,IDM_MODE_INTRO);
    pModeMenu->SetMenuDefaultItem(nCDMode,FALSE);

    pMenu->AppendMenu(g_hInst,IDS_SH_MODE,pModeMenu);
}

void CreateNetMenu(CustomMenu* pMenu, CustomMenu* pNetMenu, CustomMenu* pSearchSubMenu, CustomMenu* pProviderSubMenu)
{
	MMMEDIAID mmMedia;
    mmMedia.nDrive = -1;
	g_pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);

    BOOL fContinue = TRUE;

    //append static menu choices
    if (IsDownloading())
    {
        pNetMenu->AppendMenu(IDM_NET_CANCEL,g_hInst,IDM_NET_CANCEL);
    }
    else
    {
        pNetMenu->AppendMenu(IDM_NET_UPDATE,g_hInst,IDM_NET_UPDATE);
        if (mmMedia.dwMediaID == 0)
        {
            //need to gray out menu
            MENUITEMINFO mmi;
            mmi.cbSize = sizeof(mmi);
            mmi.fMask = MIIM_STATE;
            mmi.fState = MFS_GRAYED;
            HMENU hMenu = pNetMenu->GetMenuHandle();
            SetMenuItemInfo(hMenu,IDM_NET_UPDATE,FALSE,&mmi);
        }
    }
	
    //if networking is not allowed, gray it out ...
    //don't worry about cancel case, it won't be there
    LPCDDATA pData = GetCDData();
    if (mmMedia.dwMediaID != 0)
    {
        //don't allow searching if title isn't available
        if (pData)
        {
            if (pData->QueryTitle(mmMedia.dwMediaID))
            {
                pSearchSubMenu->AppendMenu(IDM_NET_BAND,g_hInst,IDM_NET_BAND);
                pSearchSubMenu->AppendMenu(IDM_NET_CD,g_hInst,IDM_NET_CD);
                pSearchSubMenu->AppendMenu(IDM_NET_ROLLINGSTONE_ARTIST,g_hInst,IDM_NET_ROLLINGSTONE_ARTIST);
                pSearchSubMenu->AppendMenu(IDM_NET_BILLBOARD_ARTIST,g_hInst,IDM_NET_BILLBOARD_ARTIST);
                pSearchSubMenu->AppendMenu(IDM_NET_BILLBOARD_ALBUM,g_hInst,IDM_NET_BILLBOARD_ALBUM);
                pNetMenu->AppendMenu(g_hInst,IDM_NET_SEARCH_HEADING,pSearchSubMenu);
            }
        } //end if pdata
    }

    //display any provider home pages
    DWORD i = 0;
    LPCDOPT pOpt = GetCDOpt();
    if( pOpt )
    {
        LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();

        LPCDPROVIDER pProviderList = pCDOpts->pProviderList;

        while (pProviderList!=NULL)
        {
            TCHAR szProviderMenu[MAX_PATH];
            TCHAR szHomePageFormat[MAX_PATH/2];
            LoadString(g_hInst,IDS_HOMEPAGEFORMAT,szHomePageFormat,sizeof(szHomePageFormat)/sizeof(TCHAR));
            wsprintf(szProviderMenu,szHomePageFormat,pProviderList->szProviderName);

            pProviderSubMenu->AppendMenu(IDM_HOMEMENU_BASE+i,szProviderMenu);

            pProviderList = pProviderList->pNext;
            i++;
        } //end while

        pNetMenu->AppendMenu(g_hInst,IDM_NET_PROVIDER_HEADING,pProviderSubMenu);
    } //end home pages

    //display internet-loaded disc menus
    if (mmMedia.dwMediaID != 0)
    {
        if (pData)
        {
            if (pData->QueryTitle(mmMedia.dwMediaID))
            {
                LPCDTITLE pCDTitle = NULL;
                HRESULT hr =  pData->LockTitle(&pCDTitle,mmMedia.dwMediaID);

                if (SUCCEEDED(hr))
                {
                    for (i = 0; i < pCDTitle->dwNumMenus; i++)
                    {
                        if (i==0)
                        {
                            pNetMenu->AppendSeparator();
                        }

                        TCHAR szDisplayNet[MAX_PATH];
                        NormalizeNameForMenuDisplay(pCDTitle->pMenuTable[i].szMenuText,szDisplayNet,sizeof(szDisplayNet));
            	        pNetMenu->AppendMenu(i + IDM_NETMENU_BASE,szDisplayNet);
                    }

                    pData->UnlockTitle(pCDTitle,FALSE);
                }
            } //end if query title
        }
    }

    pMenu->AppendMenu(g_hInst,IDS_SH_NET,pNetMenu);
}

void CreateTrackMenu(CustomMenu* pMenu, CustomMenu* pTrackMenu)
{
    int i = 0;
    HRESULT hr = S_OK;
    while (SUCCEEDED(hr))
    {
		MMTRACKORDISC mmTrack;
        mmTrack.nNumber = i++;
        hr = g_pAuto->OnAction(MMACTION_GETTRACKINFO,&mmTrack);
        if (SUCCEEDED(hr))
        {
            pTrackMenu->AppendMenu(mmTrack.nID + IDM_TRACKLIST_SHELL_BASE, mmTrack.szName);
            if (mmTrack.fCurrent)
            {
                pTrackMenu->SetMenuDefaultItem(mmTrack.nID + IDM_TRACKLIST_SHELL_BASE,FALSE);
            } //end if current
        } //end if ok
    } //end while

    pMenu->AppendMenu(g_hInst,IDS_SH_TRACK,pTrackMenu);
}

void CreateDiscMenu(CustomMenu* pMenu, CustomMenu* pDiscMenu)
{
    int i = 0;
    HRESULT hr = S_OK;
    while (SUCCEEDED(hr))
    {
        MMTRACKORDISC mmDisc;
        mmDisc.nNumber = i++;
        hr = g_pAuto->OnAction(MMACTION_GETDISCINFO,&mmDisc);
        if (SUCCEEDED(hr))
        {
            pDiscMenu->AppendMenu(mmDisc.nID + IDM_DISCLIST_BASE, mmDisc.szName);
            if (mmDisc.fCurrent)
            {
                pDiscMenu->SetMenuDefaultItem(mmDisc.nID + IDM_DISCLIST_BASE,FALSE);
            } //end if current
        }
    }

    pMenu->AppendMenu(g_hInst,IDS_SH_DISC,pDiscMenu);
}

void CALLBACK lButtonTimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    KillTimer(hwnd,idEvent);

    if (fPlaying)
    {
        g_pAuto->OnAction(MMACTION_PAUSE,NULL);
        //ShellIconSetState(PLAY_ICON);
    }
    else
    {
        g_pAuto->OnAction(MMACTION_PLAY,NULL);
        //ShellIconSetState(PAUSE_ICON);
    }
}

LRESULT ShellIconHandeMessage(LPARAM lParam)
{
    switch (lParam)
    {
        case (WM_LBUTTONDOWN) :
        {
            SetTimer(g_hwnd,SHELLTIMERID,GetDoubleClickTime()+100,(TIMERPROC)lButtonTimerProc);
        }
        break;

        case (WM_LBUTTONDBLCLK) :
        {
            KillTimer(g_hwnd,SHELLTIMERID);
            
            if ((IsWindowVisible(g_hwnd)) && (!IsIconic(g_hwnd)))
            {
                ShowWindow(g_hwnd,SW_HIDE);
            }
            else
            {
                if (IsIconic(g_hwnd))
                {
                    ShowWindow(g_hwnd,SW_RESTORE);
                }

                ShowWindow(g_hwnd,SW_SHOW);
		        BringWindowToTop(g_hwnd);
		        SetForegroundWindow(g_hwnd);
            }
        }
        break;

        case (WM_RBUTTONUP) :
        {
            if (!fOptionsDlgUp)
            {
                CustomMenu* pTrackMenu = NULL;
                CustomMenu* pDiscMenu = NULL;
                CustomMenu* pOptionsMenu = NULL;
                CustomMenu* pNetMenu = NULL;
                CustomMenu* pSearchSubMenu = NULL;
                CustomMenu* pProviderSubMenu = NULL;
                CustomMenu* pModeMenu = NULL;
                CustomMenu* pTransMenu = NULL;

                AllocCustomMenu(&g_pMenu);
                AllocCustomMenu(&pTrackMenu);
                AllocCustomMenu(&pDiscMenu);
                AllocCustomMenu(&pOptionsMenu);
                AllocCustomMenu(&pNetMenu);
                AllocCustomMenu(&pSearchSubMenu);
                AllocCustomMenu(&pProviderSubMenu);
                AllocCustomMenu(&pModeMenu);
                AllocCustomMenu(&pTransMenu);

                if (g_pMenu)
                {
                    g_pMenu->AppendMenu(IDM_ABOUT,g_hInst,IDM_ABOUT);
                    g_pMenu->AppendSeparator();

                    CreateTransportMenu(g_pMenu,pTransMenu);
                    CreateOptionsMenu(g_pMenu,pOptionsMenu);
                    CreateNetMenu(g_pMenu,pNetMenu,pSearchSubMenu,pProviderSubMenu);
                    CreateModeMenu(g_pMenu,pModeMenu);
                    CreateDiscMenu(g_pMenu,pDiscMenu);
                    CreateTrackMenu(g_pMenu,pTrackMenu);

                    g_pMenu->AppendSeparator();
                    g_pMenu->AppendMenu(IDM_EXIT_SHELL,g_hInst,IDM_EXIT);

                    POINT mouse;
                    GetCursorPos(&mouse);
                    RECT rect;
                    SetRect(&rect,0,0,0,0);
                    SetForegroundWindow(g_hwnd);
                    g_pMenu->TrackPopupMenu(0,mouse.x,mouse.y,g_hwnd,&rect);

                    pTrackMenu->Destroy();
                    pDiscMenu->Destroy();
                    pOptionsMenu->Destroy();
                    pNetMenu->Destroy();
                    pSearchSubMenu->Destroy();
                    pProviderSubMenu->Destroy();
                    pModeMenu->Destroy();
                    pTransMenu->Destroy();
                }

                if (g_pMenu)
                {
                    g_pMenu->Destroy();
                    g_pMenu = NULL;
                }
            } //end if ok to do
            else
            {
                MessageBeep(0);
            }
        } //end right-button up
        break;
    }

    return 0;
}

void ShellIconSetState(int nIconType)
{
    if (g_fShellIconCreated)
    {
        int iID = IDI_SHELL_PLAY;
        HICON hIcon = hIconPlay;
    
        switch(nIconType)
        {
            case PAUSE_ICON : 
            {
                iID = IDI_SHELL_PAUSE;
                hIcon = hIconPause;
            }
            break;

            case NODISC_ICON :
            {
                iID = IDI_SHELL_NODISC;
                hIcon = hIconNoDisc;
            }
            break;
        }
   
        NOTIFYICONDATA nData;
        nData.cbSize = sizeof(nData);
        nData.hWnd = g_hwnd;
        nData.uID = SHELLMESSAGE_CDICON;
        nData.uFlags = NIF_ICON;
        nData.hIcon = hIcon;

        Shell_NotifyIcon(NIM_MODIFY,&nData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\main\sink.h ===
// FrameworkNotifySink.h: interface for the CFrameworkNotifySink class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FRAMEWORKNOTIFYSINK_H__E5927148_521E_11D1_9B97_00C04FA3B60C__INCLUDED_)
#define AFX_FRAMEWORKNOTIFYSINK_H__E5927148_521E_11D1_9B97_00C04FA3B60C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "mmfw.h"
#include "..\cdopt\cdopt.h"

#define WM_DISCCHANGED WM_USER + 1500

typedef struct CompNode
{
    IMMComponent*       pComp;
    HWND                hwndComp;
    HMENU               hmenuComp;
    IMMFWNotifySink*    pSink;
    struct CompNode*    pNext;
    TCHAR                szTitle[MAX_PATH*2];
} COMPNODE, *PCOMPNODE;

LPCDOPT GetCDOpt();
LPCDDATA GetCDData();

class CFrameworkNotifySink : public IMMFWNotifySink  
{
public:
	CFrameworkNotifySink(PCOMPNODE pNode);
	virtual ~CFrameworkNotifySink();

    STDMETHOD (QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

	STDMETHOD (OnEvent)(MMEVENTS mmEventID, LPVOID pEvent);
    STDMETHOD_(void*,GetCustomMenu)();
    STDMETHOD_(HPALETTE,GetPalette)();
    STDMETHOD_(void*,GetOptions)();
    STDMETHOD_(void*,GetData)();

public:
    static HWND m_hwndTitle;

private:
	DWORD m_dwRef;
    PCOMPNODE m_pNode;
    TCHAR m_szAppName[MAX_PATH/2];
};

#endif // !defined(AFX_FRAMEWORKNOTIFYSINK_H__E5927148_521E_11D1_9B97_00C04FA3B60C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\dllmain.cpp ===
// DLLMAIN: Entry points for COM object dll


#include "precomp.h"
#include "optres.h"
#include "tchar.h"
#include "cdoptimp.h"
#include "cddata.h"


extern "C"
HRESULT WINAPI CDOPT_CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj)
{
    LPUNKNOWN pObj;
    HRESULT hr = E_OUTOFMEMORY;

    *ppvObj = NULL;

    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
    {
        return CLASS_E_NOAGGREGATION;
    }

    if (IID_ICDData == riid)
    {
        pObj = (LPUNKNOWN) new CCDData();
    }
    else if (IID_ICDOpt == riid)
    {
        pObj = (LPUNKNOWN) new CCDOpt();
    }

    if (NULL==pObj)
    {
        return hr;
    }

    hr = pObj->QueryInterface(riid, ppvObj);

    if (FAILED(hr))
    {
        delete pObj;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\helpids.h ===
// Context Help IDs deluxe CD player preference dialog         

extern TCHAR gszHelpFile[];

// PlayOpts dialog help ID's

#define IDH_PLAYBACKOPTIONS                     1100   // Options that control application behavior (startplay, exitstop, topmost)
#define IDH_STARTPLAY                           1101   // Checkbox, if checked cd starts playing when app launches
#define IDH_EXITSTOP                            1102   // Checkbox, if checked cd stops playing when app exits
#define IDH_TOPMOST                             1103   // Checkbox, if checked CD player window floats on top of all other windows
#define IDH_TIMEDISPLAY                         1104   // Options that allow you to change the default time display
#define IDH_CDTIME                              1105   // RadioButton, display current CD time
#define IDH_TRACKTIME                           1106   // RadioButton, display current track time
#define IDH_TRACKTIMEREMAIN                     1107   // RadioButton, display remaining track time
#define IDH_CDTIMEREMAIN                        1108   // RadioButton, display remaining CD time
#define IDH_PREVIEWOPTION                       1109   // Descripe Preview Feature
#define IDH_PREVIEWSLIDER                       1110   // Slider - allows you to set the preview time
#define IDH_PREVIEWDISPLAY                      1111   // display - shows your your current prview time
#define IDH_PLAYBACKDEFAULTS                    1112   // Button - Sets playback options defaults
#define IDH_SETVOLUMECONTROL                    1113   // Button - Puts up advanced volume dialog to configure volume control for cd players

// Volume configuration dialog help ID's

#define IDH_VOL_MSG                             1000   // Purpose of Advanced Volume Config Dialog
#define IDH_SELECTCDPLAYER                      1001   // ComboBox to select cd player to configure
#define IDH_SELECTCDMIXER                       1002   // ComboBox to select cd player to configure
#define IDH_SELECTCDCONTROL                     1003   // ComboBox to select cd player to configure
#define IDH_USEMIXERDEFAULTS                    1004   // Button to revert to calcuated cd line volume line and mixer

// TitleOpts dialog help ID's

#define IDH_DOWNLOADING                         1200   // Explains internet download feature
#define IDH_ABOUTALBUMS                         1201   // Explains album information
#define IDH_AUTODOWNLOADENABLED                 1202   // Checkbox, if checked the player will attempt downloading of album information
#define IDH_DOWNLOADPROMPT                      1203   // Checkbox, if checked user is prompted when downloading is attempted
#define IDH_SELECTCURRENTPROVIDER               1204   // Combobox to select primary provider
#define IDH_ABOUTBATCHING                       1205   // Explains album batching
#define IDH_BATCHENABLED                        1206   // Checkbox, if checked batching is enabled
#define IDH_NUMBATCHED                          1207   // Text - informs user how many albums are batched
#define IDH_DOWNLOADNOW                         1208   // Button - attempts to download any batched albums
#define IDH_TITLEDEFAULTS                       1209   // Button - Sets title options to default values

// PlayList dialog help ID's

#define IDH_ALBUMDATABASE                       1300   // Explains album database browser tree control
#define IDH_VIEWBYARTIST                        1301   // Checkbox - If checked, database shows albums in database by artist, if not, by album title
#define IDH_EDITPLAYLIST                        1302   // Button - puts up Playlist Editor Dialog

// PlayList Editor dialog help ID's

#define IDH_EDIT_ARTIST                         1400   // Editbox - Edit artist name
#define IDH_EDIT_TITLE                          1401   // Editbox - Edit title name
#define IDH_AVAILTRACKS                         1402   // Combobox - select/edit track names
#define IDH_ADDTOPLAYLIST                       1403   // Button - Add current selected track to playlist
#define IDH_PLAYLIST                            1404   // listbox - List current play list
#define IDH_PLAYLIST_REMOVE                     1405   // button - remove current selected tracks in playlist listbox
#define IDH_PLAYLIST_CLEAR                      1406   // button - clear all tracks in playlist listbox
#define IDH_PLAYLIST_RESET                      1407   // button - reset playlist listbox to actuall album track order playlist

#define IDH_SYSTRAY_ICON                        1500   // Checkbox - enables the systray icons for the cd player
#define IDH_SUBMIT_ALBUM_DATA                   1501   // Button - Submits modified album information to internet data providers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\cdopt.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Contains CD Options Interface
//
//	Copyright (c) Microsoft Corporation	1998
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _CDOPT_PUBLICINTEFACES_
#define _CDOPT_PUBLICINTEFACES_

#include "objbase.h"
#include "mmsystem.h"

#ifdef __cplusplus
extern "C" {
#endif

const CLSID CLSID_CDOpt = {0xE5927147,0x521E,0x11D1,{0x9B,0x97,0x00,0xC0,0x4F,0xA3,0xB6,0x10}};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Definitions 
//
// Defines the GUIDs / IIDs for this project:
//
// IID_IMMFWNotifySink, IMMComponent, IMMComponentAutomation
//
// These are the three interfaces for Framework / Component communications.
// All other interfaces should be private to the specific project.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define lCDOPTIIDFirst			    0xb2cd5bbd
#define DEFINE_CDOPTIID(name, x)	DEFINE_GUID(name, lCDOPTIIDFirst + x, 0x5221,0x11d1,0x9b,0x97,0x0,0xc0,0x4f,0xa3,0xb6,0xc)

DEFINE_CDOPTIID(IID_ICDOpt,	        0);
DEFINE_CDOPTIID(IID_ICDData,	    1);


///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CDOptions Interface Typedefs
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef interface ICDOpt	    	ICDOpt;
typedef ICDOpt*	    			    LPCDOPT;

typedef interface ICDData	        ICDData;
typedef ICDData*	    			LPCDDATA;

#ifndef LPUNKNOWN
typedef IUnknown*                   LPUNKNOWN;
#endif



///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CDOPTIONS common defines
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
enum CDDISP_MODES 
{
    CDDISP_CDTIME       =   0x0001,		
    CDDISP_CDREMAIN     =   0x0002,		
    CDDISP_TRACKTIME    =   0x0004,
    CDDISP_TRACKREMAIN  =   0x0008,
};

enum CDOPT_PAGE 
{
    CDOPT_PAGE_PLAY       =   0x0000,		
    CDOPT_PAGE_TITLE      =   0x0001,		
    CDOPT_PAGE_PLAYLIST   =   0x0002,		
};


#define CDTITLE_NODISC      (0)
#define CDSTR               (128)

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CDOptions common typedefs
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

struct CDOPTIONS;
struct CDTITLE;

typedef DWORD   (CALLBACK FAR * LPFNCDDOWNLOAD)(CDTITLE  *pTitle, LPARAM lParam, HWND hwnd);
typedef void    (CALLBACK FAR * LPFNCDOPTIONS)(CDOPTIONS *pCDOpts);


typedef struct CDUNIT
{
    TCHAR   szDriver[MAX_PATH];
    TCHAR   szDeviceDesc[MAX_PATH];
    TCHAR   szDriveName[MAX_PATH];
    TCHAR   szMixerName[MAXPNAMELEN];
    TCHAR   szVolName[MIXER_LONG_NAME_CHARS];
    TCHAR   szNetQuery[2048];
    DWORD   dwMixID;
    DWORD   dwDestID;
    DWORD   dwVolID;
    DWORD   dwMuteID;
    DWORD   dwTitleID;
    DWORD   dwNumTracks;
    BOOL    fSelected;
    BOOL    fDefaultDrive;
    BOOL    fDownLoading;
    BOOL    fChanged;
    CDUNIT *pNext;

} CDUNIT, *LPCDUNIT;


typedef struct CDPROVIDER
{
    TCHAR       szProviderURL[MAX_PATH];
    TCHAR       szProviderName[MAX_PATH];
    TCHAR       szProviderHome[MAX_PATH];
    TCHAR       szProviderLogo[MAX_PATH];
    TCHAR       szProviderUpload[MAX_PATH];
    BOOL        fTimedOut;
    CDPROVIDER  *pNext;
    
} CDPROVIDER, *LPCDPROVIDER;


typedef struct CDOPTDATA
{                                  
    BYTE    fDispMode;              
    BOOL    fStartPlay;             
    BOOL    fExitStop;              
    BOOL    fTopMost; 
    BOOL    fTrayEnabled;          
    BOOL    fDownloadEnabled;      
    BOOL    fDownloadPrompt;       
    BOOL    fBatchEnabled;
    BOOL    fByArtist; 
    DWORD   dwPlayMode;        
    DWORD   dwIntroTime; 
    DWORD   dwWindowX;
    DWORD   dwWindowY;
    DWORD   dwViewMode;
            
} CDOPTDATA, *LPCDOPTDATA;



typedef struct CDMENU
{
    TCHAR       szMenuText[CDSTR];
    TCHAR       *szMenuQuery;

} CDMENU, *LPCDMENU;


typedef struct CDTRACK
{
    TCHAR       szName[CDSTR];

} CDTRACK, *LPCDTRACK;


typedef struct CDTITLE
{
    DWORD       dwTitleID;
    DWORD       dwNumTracks;
    BOOL        fDownLoading;
    LPCDTRACK   pTrackTable;
    DWORD       dwNumPlay;
    LPWORD      pPlayList;
    DWORD       dwNumMenus;
    LPCDMENU    pMenuTable;
    TCHAR       szTitle[CDSTR];
    TCHAR       szArtist[CDSTR];
    TCHAR       szLabel[CDSTR];
    TCHAR       szDate[CDSTR];
    TCHAR       szCopyright[CDSTR];
    TCHAR       *szTitleQuery;
    BOOL        dwLockCnt;
    BOOL        fLoaded;
    BOOL        fChanged;
    BOOL        fDriveExpanded;
    BOOL        fAlbumExpanded;
    BOOL        fArtistExpanded;
    BOOL        fRemove;
    CDTITLE *   pNext;

}CDTITLE, *LPCDTITLE;


typedef struct CDOPTIONS
{
    LPCDOPTDATA     pCDData;
    LPCDPROVIDER    pProviderList;
    LPCDPROVIDER    pCurrentProvider;
    LPCDPROVIDER    pDefaultProvider;
    LPCDUNIT        pCDUnitList;
    DWORD           dwBatchedTitles;
    LPFNCDDOWNLOAD  pfnDownloadTitle;
    LPFNCDOPTIONS   pfnOptionsCallback;
    LPARAM          lParam;
    UINT_PTR        pReserved;

} CDOPTIONS, *LPCDOPTIONS;


typedef struct CDBATCH
{
    DWORD           dwTitleID;
    DWORD           dwNumTracks;
    TCHAR           *szTitleQuery;
    BOOL            fRemove;
    BOOL            fFresh;
    CDBATCH         *pNext;

} CDBATCH, *LPCDBATCH;


///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CDOptions Interface Definitions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE ICDOpt
DECLARE_INTERFACE_(ICDOpt, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			    (THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			    (THIS) PURE;
    STDMETHOD_(ULONG,Release) 			    (THIS) PURE;

    //---  ICDOpt methods--- 
    STDMETHOD_(LPCDOPTIONS,GetCDOpts)       (THIS) PURE;

    STDMETHOD (CreateProviderList)          (THIS_ LPCDPROVIDER *ppProviderList) PURE;

    STDMETHOD_(void, DestroyProviderList)   (THIS_ LPCDPROVIDER *ppProviderList) PURE;

    STDMETHOD_(void, UpdateRegistry)        (THIS) PURE;

    STDMETHOD (OptionsDialog)               (THIS_ HWND hWnd, 
                                                   LPCDDATA pCDData,
                                                   CDOPT_PAGE nStartPage) PURE;

    STDMETHOD_(BOOL,VerifyProvider)         (THIS_ LPCDPROVIDER pCDProvider, 
                                                TCHAR *szCertKey) PURE;

    STDMETHOD (CreateProviderKey)           (THIS_ LPCDPROVIDER pCDProvider, 
                                                   TCHAR *szCertKey,
                                                   UINT cBytes) PURE;

    STDMETHOD_(void,DownLoadCompletion)     (THIS_ DWORD dwNumIDs,
                                                    LPDWORD pdwIDs) PURE;

    STDMETHOD_(void,DiscChanged)            (THIS_ LPCDUNIT pCDUnit) PURE;

    STDMETHOD_(void,MMDeviceChanged)        (THIS) PURE;

};


#undef INTERFACE
#define INTERFACE ICDData
DECLARE_INTERFACE_(ICDData, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;

    //---  ICDOpt methods--- 

    STDMETHOD (Initialize)              (THIS_ HWND hWnd) PURE;

    STDMETHOD (CheckDatabase)           (THIS_ HWND hWnd) PURE;

    STDMETHOD_(BOOL, QueryTitle)        (THIS_ DWORD dwTitleID) PURE;

    STDMETHOD (LockTitle)               (THIS_ LPCDTITLE *ppCDTitle,
                                               DWORD dwTitleID) PURE;


    STDMETHOD (CreateTitle)             (THIS_ LPCDTITLE *ppCDTitle,
                                               DWORD dwTitleID,                                   
                                               DWORD dwNumTracks,
                                               DWORD dwNumMenus) PURE;
    
    STDMETHOD (SetTitleQuery)           (THIS_ LPCDTITLE pCDTitle,
                                               TCHAR *szTitleQuery) PURE;

    STDMETHOD (SetMenuQuery)            (THIS_ LPCDMENU pCDMenu,
                                               TCHAR *szMenuQuery) PURE;

    STDMETHOD_(void,UnlockTitle)        (THIS_ LPCDTITLE pCDTitle, 
                                               BOOL fPresist) PURE;

    STDMETHOD (LoadTitles)              (THIS_ HWND hWnd) PURE;

    STDMETHOD (PersistTitles)           (THIS) PURE;

    STDMETHOD (UnloadTitles)            (THIS) PURE;

    STDMETHOD_(LPCDTITLE,GetTitleList)  (THIS) PURE;

    // -- Batch methods

    STDMETHOD_(BOOL, QueryBatch)        (THIS_ DWORD dwTitleID) PURE;

    STDMETHOD_(DWORD, GetNumBatched)    (THIS) PURE;

    STDMETHOD (LoadBatch)               (THIS_ HWND hWnd,
                                               LPCDBATCH *ppCDBatchList) PURE;

    STDMETHOD (UnloadBatch)             (THIS_ LPCDBATCH pCDBatchList) PURE;

    STDMETHOD (DumpBatch)               (THIS) PURE;

    STDMETHOD (AddToBatch)              (THIS_ DWORD dwTitleID, 
                                               TCHAR *szTitleQuery, 
                                               DWORD dwNumTracks) PURE;

};



#ifdef __cplusplus
};
#endif

#endif  //_CDOPT_PUBLICINTEFACES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\cddata.h ===
//--------------------------------------------------------------------------;
//
//  File: cddb.h
//
//  CD Database object
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved
//
//--------------------------------------------------------------------------;
#if !defined(CDDATA_COM_IMPLEMENTATION)
#define CDDATA_COM_IMPLEMENTATION

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "cdopt.h"
#include <wininet.h>
#include "sqlobj.h"

/////////////////////////////////////////////////////////////////////////////
// Types

typedef struct TIMEDMETER
{
    HWND        hMeter;
    HWND        hParent;
    BOOL        fShowing;
    DWORD       dwStartTime;
    DWORD       dwShowCount;
    DWORD       dwCount;
    DWORD       dwJump;
    DWORD       dwRange;

} TIMEDMETER, *LPTIMEDMETER;

typedef struct CBTABLE
{
    SDWORD  cbTitles[10];
    SDWORD  cbTracks[3];
    SDWORD  cbMenus[4];
    SDWORD  cbBatch[3];

}CBTABLE, *LPCBTABLE;

typedef struct BOUND
{
    HENV        henv;
    HDBC        hdbc;
    CDTITLE     CDTitle;
    CDTRACK     CDTrack;
    CDMENU      CDMenu;
    TCHAR       szPlayList[255];
    TCHAR       szQuery[INTERNET_MAX_PATH_LENGTH];
    DWORD       dwTrackID;
    DWORD       dwMenuID;
    CBTABLE     cbt;

}BOUND, *LPBOUND;




#define NUMTABLES 4


/////////////////////////////////////////////////////////////////////////////
// CCDDB

class CCDData : public ICDData
{
public:
	CCDData();
    ~CCDData();

public:
// IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

// ICDData

    STDMETHOD (Initialize)                  (HWND hWnd);
    STDMETHOD (CheckDatabase)               (HWND hWnd);
    STDMETHOD_(BOOL,QueryTitle)             (DWORD dwTitleID);
    STDMETHOD (LockTitle)                   (LPCDTITLE *ppCDTitle, DWORD dwTitleID);
    STDMETHOD (CreateTitle)                 (LPCDTITLE *ppCDTitle, DWORD dwTitleID, DWORD dwNumTracks, DWORD dwNumMenus);
    STDMETHOD (SetTitleQuery)               (LPCDTITLE pCDTitle, TCHAR *szTitleQuery);
    STDMETHOD (SetMenuQuery)                (LPCDMENU pCDMenu, TCHAR *szMenuQuery);
    STDMETHOD_(void,UnlockTitle)            (LPCDTITLE pCDTitle, BOOL fPresist);
    STDMETHOD (LoadTitles)                  (HWND hWnd);
    STDMETHOD (PersistTitles)               (void);
    STDMETHOD (UnloadTitles)                (void);
    STDMETHOD_(LPCDTITLE,GetTitleList)      (void);

    STDMETHOD_(BOOL,QueryBatch)             (DWORD dwTitleID);
    STDMETHOD_(DWORD,GetNumBatched)         (void);
    STDMETHOD (LoadBatch)                   (HWND hWnd, LPCDBATCH *ppCDBatchList);
    STDMETHOD (UnloadBatch)                 (LPCDBATCH pCDBatchList);
    STDMETHOD (DumpBatch)                   (void);
    STDMETHOD (AddToBatch)                  (DWORD dwTitleID, TCHAR *szTitleQuery, DWORD dwNumTracks);
    STDMETHOD_(DWORD,GetAppDataDir)         (TCHAR* pstrDir, DWORD cchSize);


private:
    DWORD               m_dwRef;
    DWORD               m_dwLoadCnt;
    DWORD               m_dwBatchCnt;
    CRITICAL_SECTION    m_crit;
    HENV                m_henv;
    HDBC                m_hdbc;
    HSTMT               m_hstmt[NUMTABLES];
    BOUND               m_bd;
    LPCDTITLE           m_pTitleList;
    LPCDBATCH           m_pBatchList;
    SQL *               m_pSQL;
    BOOL                m_fToldUser;

    static INT_PTR CALLBACK MeterHandler    (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

 	STDMETHOD_(void,Enter)				    (void);
	STDMETHOD_(void,Leave)				    (void);
	STDMETHOD (GetSQLPtr)				    (BOOL fInited);

    STDMETHOD_(void,CreateMeter)            (LPTIMEDMETER ptm, HWND hWnd, DWORD dwCount, DWORD dwJump, UINT uStringID);
    STDMETHOD_(void,UpdateMeter)            (LPTIMEDMETER ptm);
    STDMETHOD_(void,DestroyMeter)           (LPTIMEDMETER ptm);

    STDMETHOD (ConnectToDatabase)           (WORD fRequest);
    STDMETHOD_(void,CreateDatabase)         (void);
    STDMETHOD (OpenDatabase)                (BOOL fCreate, HWND hWnd);
    STDMETHOD_(void,CloseDatabase)          (void);

    STDMETHOD_(void,InitCBTable)            (LPBOUND pbd);
    STDMETHOD_(void,SetCursors)             (HSTMT *hstmt);
    STDMETHOD_(void,BindTitles)             (HSTMT *hstmt, LPBOUND pbd);
    STDMETHOD_(void,BindTracks)             (HSTMT *hstmt, LPBOUND pbd);
    STDMETHOD_(void,BindMenus)              (HSTMT *hstmt, LPBOUND pbd);
    STDMETHOD_(void,BindBatch)              (HSTMT *hstmt, LPBOUND pbd);
    STDMETHOD_(void,SetBindings)            (HSTMT *hstmt, LPBOUND pbd);
    STDMETHOD_(RETCODE,AllocStmt)           (HDBC hdbc, HSTMT *hstmt);
    STDMETHOD_(void,FreeStmt)               (HSTMT *hstmt);
    STDMETHOD_(void,ReportError)            (LPBOUND pbd, HSTMT hstmt);

    STDMETHOD (GetUnknownString)            (TCHAR **ppStr, const TCHAR *szSection, const TCHAR *szEntry, DWORD dwInitialAlloc);
    STDMETHOD_(DWORD,ImportCount)           (TCHAR *pEntries);
    STDMETHOD_(void,InitDatabase)           (HSTMT *hstmt);
    STDMETHOD_(void,ImportTrack)            (TCHAR *szDiscID, DWORD dwTrack);
    STDMETHOD_(RETCODE,ImportTracks)        (HSTMT hstmt, TCHAR *szDiscID);
    STDMETHOD (ImportTitle)                 (TCHAR *szDiscID);
    STDMETHOD_(void,ImportDatabase)         (LPTIMEDMETER ptm, HSTMT *hstmt, TCHAR *szDiscID);

    STDMETHOD_(DWORD,GetNumRows)            (UCHAR *szDSN);
    STDMETHOD (ExtractTitle)                (LPCDTITLE *ppCDTitle);
    STDMETHOD (ExtractTitles)               (LPCDTITLE *ppCDTitleList, HWND hWnd);
    STDMETHOD (ExtractSingleTitle)          (LPCDTITLE *ppCDTitle, DWORD dwTitleID);
    STDMETHOD_(BOOL,QueryDatabase)          (DWORD dwTitleID, const TCHAR *szTable);

    STDMETHOD_(void,SaveTitle)              (LPCDTITLE pCDTitle, BOOL fExist);
    STDMETHOD_(void,SaveTracks)             (LPCDTITLE pCDTitle, BOOL fExist);
    STDMETHOD_(void,SaveMenus)              (LPCDTITLE pCDTitle);
	
    STDMETHOD_(LPCDTITLE,FindTitle)         (LPCDTITLE pCDTitle, DWORD dwTitleID);
	STDMETHOD (NewTitle)                    (LPCDTITLE *ppCDTitle, DWORD dwTitleID, DWORD dwNumTracks, DWORD dwNumMenus);
    STDMETHOD_(void,DestroyTitle)           (LPCDTITLE pCDTitle);
    STDMETHOD_(void,DBSaveTitle)            (LPCDTITLE pCDTitle);
    STDMETHOD_(void,DBRemoveTitle)          (LPCDTITLE pCDTitle);
    STDMETHOD_(void,DestroyTitles)          (LPCDTITLE *ppCDTitles);
    STDMETHOD_(void,SaveTitles)             (LPCDTITLE *ppCDTitles);
    STDMETHOD_(void,AddTitle)               (LPCDTITLE *ppCDTitles, LPCDTITLE pCDTitle);

    STDMETHOD (ExtractBatch)                (LPCDBATCH *ppCDBatchList, HWND hWnd);
    STDMETHOD_(void,DeleteBatch)            (LPCDBATCH pCDBatch);
    STDMETHOD_(void,DestroyBatch)           (LPCDBATCH *ppCDBatchList);
    STDMETHOD_(BOOL,FindBatchTitle)         (LPCDBATCH pCDBatchList, DWORD dwTitleID);
    STDMETHOD_(void,RemoveFromBatch)		(DWORD dwTitleID);

    STDMETHOD_(BOOL,IsOldFormat)            (void);
    STDMETHOD (UpgradeDatabase)             (HWND hWnd);
};

#endif // !defined(CDDATA_COM_IMPLEMENTATION)




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdnet\getinfo.cpp ===
/******************************Module*Header*******************************\
* Module Name: getinfo.cpp
*
* Author:  David Stewart [dstewart]
*
* Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#include <TCHAR.H>
#include <objbase.h>
#include <mmsystem.h> //for mci commands
#include <urlmon.h>
#include <hlguids.h>  //for IID_IBindStatusCallback
#include "getinfo.h"
#include "netres.h"
#include "wininet.h"
#include "condlg.h"
#include "..\main\mmfw.h"
#include "..\cdopt\cdopt.h"
#include "mapi.h"
#include <stdio.h>

extern HINSTANCE g_dllInst;

#define MODE_OK 0
#define MODE_MULTIPLE 1
#define MODE_NOT_FOUND 2

#define FRAMES_PER_SECOND           75
#define FRAMES_PER_MINUTE           (60*FRAMES_PER_SECOND)
#define MAX_UPLOAD_URL_LENGTH       1500

#ifdef UNICODE
#define URLFUNCTION "URLOpenStreamW"
#define CANONFUNCTION "InternetCanonicalizeUrlW"
#else
#define URLFUNCTION "URLOpenStreamA"
#define CANONFUNCTION "InternetCanonicalizeUrlA"
#endif

HWND    g_hwndParent = NULL;
extern HINSTANCE g_hURLMon;
LPCDOPT g_pNetOpt = NULL;
LPCDDATA g_pNetData = NULL;
BOOL g_fCancelDownload = FALSE;     //ANY ACCESS MUST BE SURROUNDED by Enter/Leave g_Critical
IBinding* g_pBind = NULL;           //ANY ACCESS MUST BE SURROUNDED by Enter/Leave g_Critical
long g_lNumDownloadingThreads = 0;  //MUST USE InterlockedIncrement/Decrement
BOOL g_fDownloadDone = FALSE;
BOOL g_fDBWriteFailure = FALSE;
extern CRITICAL_SECTION g_Critical;
extern CRITICAL_SECTION g_BatchCrit;

DWORD WINAPI SpawnSingleDownload(LPVOID pParam);
DWORD WINAPI SpawnBatchDownload(LPVOID pParam);
DWORD WINAPI DoBatchDownload(LPCDBATCH pBatchList, HWND hwndParent);
BOOL DoDownload(TCHAR* url, TCHAR* szFilename, HWND hwndParent);

CCDNet::CCDNet()
{
    m_dwRef = 0;
}

CCDNet::~CCDNet()
{
}

STDMETHODIMP CCDNet::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (IID_IUnknown == riid || IID_ICDNet == riid)
    {  
        *ppv = this;
    }

    if (NULL==*ppv)
    {
        return E_NOINTERFACE;
    }

    AddRef();

    return S_OK;
}

STDMETHODIMP_(ULONG) CCDNet::AddRef(void)
{
    return ++m_dwRef;
}

STDMETHODIMP_(ULONG) CCDNet::Release(void)
{
    if (0!=--m_dwRef)
        return m_dwRef;

    delete this;
    return 0;
}

STDMETHODIMP CCDNet::SetOptionsAndData(void* pOpts, void* pData)
{
    g_pNetOpt = (LPCDOPT)pOpts;
    g_pNetData = (LPCDDATA)pData;

    return S_OK;
}

//this is a start to implementing the "upload via http" case rather than the
//upload via mail case
BOOL UploadToProvider(LPCDPROVIDER pProvider, LPCDTITLE pTitle, HWND hwndParent)
{
    TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    TCHAR szMainURL[INTERNET_MAX_URL_LENGTH];
    TCHAR szFilename[MAX_PATH];

    //get the InternetCanonicalizeURL function
	typedef BOOL (PASCAL *CANPROC)(LPCTSTR, LPTSTR, LPDWORD, DWORD);
    CANPROC canProc = NULL;

    HMODULE hNet = LoadLibrary(TEXT("WININET.DLL"));
    if (hNet!=NULL)
    {
	    canProc = (CANPROC)GetProcAddress(hNet,CANONFUNCTION);
    }
    else
    {
        return FALSE;
    }
    
    if (pProvider && pTitle && canProc)
    {
        //check for provider URL
        if (_tcslen(pProvider->szProviderUpload)>0)
        {
            TCHAR szTempCan[MAX_PATH*2];

            //create the URL to send
            wsprintf(szMainURL,TEXT("%s%s"),pProvider->szProviderUpload,pTitle->szTitleQuery);
            _tcscpy(szURL,szMainURL);

            //add title
            _tcscat(szURL,TEXT("&t="));
            DWORD dwSize = sizeof(szTempCan);
            canProc(pTitle->szTitle,szTempCan,&dwSize,0);
            _tcscat(szURL,szTempCan);

            //add artist
            _tcscat(szURL,TEXT("&a="));
            dwSize = sizeof(szTempCan);
            canProc(pTitle->szArtist,szTempCan,&dwSize,0);
            _tcscat(szURL,szTempCan);
        
            //add tracks
            TCHAR szTrack[MAX_PATH];
            for (DWORD i = 0; i < pTitle->dwNumTracks; i++)
            {
                wsprintf(szTrack,TEXT("&%u="),i+1);

                dwSize = sizeof(szTempCan);
                canProc(pTitle->pTrackTable[i].szName,szTempCan,&dwSize,0);

                if ((_tcslen(szURL) + _tcslen(szTrack) + _tcslen(szTempCan)) > 
                    MAX_UPLOAD_URL_LENGTH-sizeof(TCHAR))
                {
                    //we're coming close to the limit.  Send what we have and start rebuilding
                    if (!g_fCancelDownload)
                    {
                        if (DoDownload(szURL,szFilename, hwndParent))
                        {
                            DeleteFile(szFilename);
                        } //end if "upload" successful
                        else
                        {
                            //bad upload, don't bother sending the rest
                            //probably a timeout
                            return FALSE;
                        }
                    }

                    //reset the URL to just the provider + toc
                    _tcscpy(szURL,szMainURL);
                } //end if length

                _tcscat(szURL,szTrack);
                _tcscat(szURL,szTempCan);
            } //end for track

            //send it
            if (!g_fCancelDownload)
            {
                if (DoDownload(szURL,szFilename, hwndParent))
                {
                    DeleteFile(szFilename);
                } //end if "upload" successful
                else
                {
                    return FALSE;
                }
            }
        } //end if url exists
    } //end if state OK

    if (hNet)
    {
        FreeLibrary(hNet);
    }

    return TRUE;
}

DWORD WINAPI UploadThread(LPVOID pParam)
{
    InterlockedIncrement((LONG*)&g_lNumDownloadingThreads);

    //this will block us against the batch download happening, too
	EnterCriticalSection(&g_BatchCrit);

    LPCDTITLE pTitle = (LPCDTITLE)pParam;
    HWND hwndParent = g_hwndParent;
    
    int nTries = 0;
    int nSuccessful = 0;

    if (pTitle)
    {
        LPCDOPTIONS pOptions = g_pNetOpt->GetCDOpts();             // Get the options, needed for provider list

        if (pOptions && pOptions->pCurrentProvider)             // Make sure we have providers
        {        
            LPCDPROVIDER pProviderList = NULL;
            LPCDPROVIDER pProvider = NULL;
        
            g_pNetOpt->CreateProviderList(&pProviderList);       // Get the sorted provider list
            pProvider = pProviderList;                          // Get the head of the list

            while ((pProvider) && (!g_fCancelDownload))
            {
                nTries++;
                if (UploadToProvider(pProvider,pTitle,hwndParent))
                {
                    nSuccessful++;
                }
                pProvider = pProvider->pNext;
            }

            g_pNetOpt->DestroyProviderList(&pProviderList);
        } //end if providers
    }

    //addref'ed before thread was created
    g_pNetOpt->Release();
    g_pNetData->Release();
    
    long status = UPLOAD_STATUS_NO_PROVIDERS;
    
    if ((nSuccessful != nTries) && (nSuccessful > 0))
    {
        status = UPLOAD_STATUS_SOME_PROVIDERS;
    }

    if ((nSuccessful == nTries) && (nSuccessful > 0))
    {
        status = UPLOAD_STATUS_ALL_PROVIDERS;
    }

    if (g_fCancelDownload)
    {
        status = UPLOAD_STATUS_CANCELED;
    }

	LeaveCriticalSection(&g_BatchCrit);
    InterlockedDecrement((LONG*)&g_lNumDownloadingThreads);

    //post message saying we're done
    PostMessage(hwndParent,WM_NET_DONE,(WPARAM)g_dllInst,status);

    return 0;
}

STDMETHODIMP CCDNet::Upload(LPCDTITLE pTitle, HWND hwndParent)
{
    HRESULT hr = E_FAIL;
    DWORD   dwHow;
    BOOL    fConnected;

    if (g_pNetOpt && g_pNetData && pTitle)                                      // Make sure we are in a valid state
    {
        fConnected = _InternetGetConnectedState(&dwHow,0,TRUE);     // Make sure we are connected to net

        if (fConnected)                                             // Make sure we are in a valid state
        {
            EnterCriticalSection(&g_Critical);
            g_fCancelDownload = FALSE;
            LeaveCriticalSection(&g_Critical);

            DWORD dwThreadID;
            HANDLE hNetThread = NULL;

            g_hwndParent = hwndParent;
            g_pNetOpt->AddRef();
            g_pNetData->AddRef();
            hNetThread = CreateThread(NULL,0,UploadThread,(void*)pTitle,0,&dwThreadID);
            if (hNetThread)
            {
                CloseHandle(hNetThread);
                hr = S_OK;
            }
        } //end if connected
    } //end if options and data ok

    return (hr);
}

STDMETHODIMP_(BOOL) CCDNet::CanUpload()
{
    BOOL retcode = FALSE;

    if (g_pNetOpt && g_pNetData)                                      // Make sure we are in a valid state
    {
        //check all providers to be sure at least one has upload capability
        LPCDOPTIONS pOptions = g_pNetOpt->GetCDOpts();             // Get the options, needed for provider list

        if (pOptions && pOptions->pCurrentProvider)             // Make sure we have providers
        {        
            LPCDPROVIDER pProviderList = NULL;
            LPCDPROVIDER pProvider = NULL;
    
            g_pNetOpt->CreateProviderList(&pProviderList);       // Get the sorted provider list
            pProvider = pProviderList;                          // Get the head of the list

            while (pProvider)
            {
                if (_tcslen(pProvider->szProviderUpload) > 0)
                {
                    retcode = TRUE;
                }
                pProvider = pProvider->pNext;
            } //end while

            g_pNetOpt->DestroyProviderList(&pProviderList);
        } //end if providers
    } //end if set up properly

    return (retcode);
}

STDMETHODIMP CCDNet::Download(DWORD dwDeviceHandle, TCHAR chDrive, DWORD dwMSID, LPCDTITLE pTitle, BOOL fManual, HWND hwndParent)
{
    if (g_pNetOpt==NULL)
    {
        return E_FAIL;
    }

    if (g_pNetData==NULL)
    {
        return E_FAIL;
    }

    if (FAILED(g_pNetData->CheckDatabase(hwndParent)))
    {
        return E_FAIL;
    }

	CGetInfoFromNet netinfo(dwDeviceHandle, 
                            dwMSID, 
                            hwndParent);

    EnterCriticalSection(&g_Critical);
    g_fCancelDownload = FALSE;
    LeaveCriticalSection(&g_Critical);
    
	BOOL fResult = netinfo.DoIt(fManual, pTitle, chDrive);

    return fResult ? S_OK : E_FAIL;
}

STDMETHODIMP_(BOOL) CCDNet::IsDownloading()
{
    BOOL retcode = FALSE;

    if (g_lNumDownloadingThreads > 0)
    {
        retcode = TRUE;
    }

    return (retcode);
}

STDMETHODIMP CCDNet::CancelDownload()
{
    EnterCriticalSection(&g_Critical);
    if (g_pBind)
    {
        g_pBind->Abort();
    }
    g_fCancelDownload = TRUE;
    LeaveCriticalSection(&g_Critical);
    while (IsDownloading())
    {
        Sleep(10);
    }

    return S_OK;
}

struct CBindStatusCallback : IBindStatusCallback
{
///// object state
    ULONG           m_cRef;         // object reference count
	BOOL            m_fAbort;       // set to true if we want this to abort
    HWND            m_hMessage;     // callback window
	IStream*	    m_pStream;	// holds downloaded data

///// construction and destruction
    CBindStatusCallback(IStream* pStream, HWND hwndParent);
    ~CBindStatusCallback();

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IBindStatusCallback methods
    STDMETHODIMP OnStartBinding(DWORD dwReserved, IBinding *pib);
    STDMETHODIMP GetPriority(LONG *pnPriority);
    STDMETHODIMP OnLowResource(DWORD reserved);
    STDMETHODIMP OnProgress(ULONG ulProgress, ULONG ulProgressMax,
	ULONG ulStatusCode, LPCWSTR szStatusText);
    STDMETHODIMP OnStopBinding(HRESULT hresult, LPCWSTR szError);
    STDMETHODIMP GetBindInfo(DWORD *grfBINDF, BINDINFO *pbindinfo);
    STDMETHODIMP OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
	FORMATETC *pformatetc, STGMEDIUM *pstgmed);
    STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown *punk);
};

/////////////////////////////////////////////////////////////////////////////
// CBindStatusCallback Creation & Destruction
//
CBindStatusCallback::CBindStatusCallback(IStream* pStream, HWND hwndParent)
{
    HRESULT hr = S_OK;
    m_cRef = 0;
    m_fAbort = FALSE;
    m_pStream = pStream;
    m_pStream->AddRef();
    m_hMessage = hwndParent;

    PostMessage(m_hMessage,WM_NET_STATUS,(WPARAM)g_dllInst,IDS_STRING_CONNECTING);
}


CBindStatusCallback::~CBindStatusCallback()
{
    EnterCriticalSection(&g_Critical);
    if (g_pBind)
    {
        g_pBind->Release();
        g_pBind = NULL;
    }
    LeaveCriticalSection(&g_Critical);

	if( m_pStream )
	{
		m_pStream->Release();
		m_pStream = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBindStatusCallback IUnknown Methods
//

STDMETHODIMP CBindStatusCallback::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IBindStatusCallback))
    {
	    *ppvObj = (IBindStatusCallback *) this;
	    AddRef();
	    return NOERROR;
    }
    else
    {
    	*ppvObj = NULL;
	    return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CBindStatusCallback::AddRef()
{
    InterlockedIncrement((LONG*)&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CBindStatusCallback::Release()
{
    ULONG cRef = m_cRef;
    if (InterlockedDecrement((LONG*)&m_cRef) == 0)
    {
    	delete this;
	    return 0;
    }
    else
	return cRef-1;
}


/////////////////////////////////////////////////////////////////////////////
// CBindStatusCallback IBindStatusCallback Methods
//

STDMETHODIMP CBindStatusCallback::OnStartBinding(DWORD dwReserved, IBinding *pib)
{
    EnterCriticalSection(&g_Critical);
    g_pBind = pib;
    g_pBind->AddRef();
    LeaveCriticalSection(&g_Critical);
    return S_OK;
}

STDMETHODIMP CBindStatusCallback::GetPriority(LONG *pnPriority)
{
    return S_OK;
}

STDMETHODIMP CBindStatusCallback::OnLowResource(DWORD reserved)
{
    return S_OK;
}

STDMETHODIMP CBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
    ULONG ulStatusCode, LPCWSTR szStatusText)
{
	int nResID = 0;

    switch (ulStatusCode)
    {
        case (BINDSTATUS_FINDINGRESOURCE) : nResID = IDS_STRING_FINDINGRESOURCE; break;
        case (BINDSTATUS_CONNECTING) : nResID = IDS_STRING_CONNECTING; break;
        case (BINDSTATUS_REDIRECTING) : nResID = IDS_STRING_REDIRECTING; break;
        case (BINDSTATUS_BEGINDOWNLOADDATA) : nResID = IDS_STRING_BEGINDOWNLOAD; break;
        case (BINDSTATUS_DOWNLOADINGDATA) : nResID = IDS_STRING_DOWNLOAD; break;
        case (BINDSTATUS_ENDDOWNLOADDATA) : nResID = IDS_STRING_ENDDOWNLOAD; break;
        case (BINDSTATUS_SENDINGREQUEST) : nResID = IDS_STRING_SENDINGREQUEST; break;
    } //end switch
        
    if (nResID > 0)
    {
        PostMessage(m_hMessage,WM_NET_STATUS,(WPARAM)g_dllInst,nResID);
    }

    if (( m_fAbort ) || (g_fCancelDownload))
	{
        EnterCriticalSection(&g_Critical);
        g_fCancelDownload = TRUE;
        g_fDownloadDone = TRUE;
        LeaveCriticalSection(&g_Critical);
		return E_ABORT;
	}
    return S_OK;
}

STDMETHODIMP CBindStatusCallback::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    EnterCriticalSection(&g_Critical);
    if (g_pBind)
    {
        g_pBind->Release();
        g_pBind = NULL;
    }
    LeaveCriticalSection(&g_Critical);
    return S_OK;
}


STDMETHODIMP CBindStatusCallback::GetBindInfo(DWORD *pgrfBINDF, BINDINFO *pbindinfo)
{
    *pgrfBINDF = 0;
    pbindinfo->cbSize = sizeof(BINDINFO);
    pbindinfo->szExtraInfo = NULL;
    ZeroMemory(&pbindinfo->stgmedData, sizeof(STGMEDIUM));
    pbindinfo->grfBindInfoF = 0;
    pbindinfo->dwBindVerb = BINDVERB_GET;
    pbindinfo->szCustomVerb = NULL;

    return S_OK;
}

STDMETHODIMP CBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
    FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
	// fill our stream with the data from the stream passed to us
	if( m_pStream )
	{
		ULARGE_INTEGER cb;

		cb.LowPart = dwSize;
		cb.HighPart = 0;
		if( pstgmed && pstgmed->pstm )
		{
			pstgmed->pstm->CopyTo( m_pStream, cb, NULL, NULL );
		}
	}

    // Notify owner when download is complete
	if( grfBSCF & BSCF_LASTDATANOTIFICATION )
	{
        g_fDownloadDone = TRUE;

		if( m_pStream )
		{
			m_pStream->Release();
			m_pStream = NULL;
		}
	}
    return S_OK;
}

STDMETHODIMP CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CGetInfoFromNet

CGetInfoFromNet::CGetInfoFromNet(DWORD cdrom, DWORD dwMSID, HWND hwndParent)
{
	DevHandle = cdrom;
	m_MS = dwMSID;
    g_hwndParent = hwndParent;
}

CGetInfoFromNet::~CGetInfoFromNet()
{
}

BOOL CGetInfoFromNet::DoIt(BOOL fManual, LPCDTITLE pTitle, TCHAR chDrive) 
{
	BOOL fRet = FALSE;

    int nMode = CONNECTION_GETITNOW;
    
    if (!fManual)
    {
        if (g_lNumDownloadingThreads == 0)
        {
            //if no threads are running already,
            //check the connection, possibly prompting the user
            nMode = ConnectionCheck(g_hwndParent,g_pNetOpt, chDrive);
        }
    }

    if (nMode == CONNECTION_DONOTHING)
    {
        return FALSE;
    }

	//if passed-in ID is not > 0, then we don't want to scan current disc
    if ((m_MS > 0) && (pTitle == NULL))
    {
        m_Tracks = readtoc();

	    if (m_Tracks > 0)
	    {
		    BuildQuery();
	    }
    } //if msid is greater than 0

    if (nMode == CONNECTION_BATCH)
    {
        if (m_MS > 0)
        {
            AddToBatch(m_Tracks,m_Query);
        }
        return FALSE;
    }

    //we need to determine now whether we spawn a batching thread or a single-item downloader
    g_fDBWriteFailure = FALSE;
    DWORD dwThreadID;
    HANDLE hNetThread = NULL;

    //addref the global pointers before entering the thread
    g_pNetOpt->AddRef();
    g_pNetData->AddRef();
    
    if (m_MS > 0)
    {
        //need to create a batch item for this thread to use
        LPCDBATCH pBatch = new CDBATCH;
        pBatch->fRemove = FALSE;
        pBatch->fFresh = TRUE;
        pBatch->pNext = NULL;

        if (!pTitle)
        {
            pBatch->dwTitleID = m_MS;
            pBatch->dwNumTracks = m_Tracks;
            pBatch->szTitleQuery = new TCHAR[_tcslen(m_Query)+1];
            _tcscpy(pBatch->szTitleQuery,m_Query);
        }
        else
        {
            pBatch->dwTitleID = pTitle->dwTitleID;
            pBatch->dwNumTracks = pTitle->dwNumTracks;
            if (pTitle->szTitleQuery)
            {
                pBatch->szTitleQuery = new TCHAR[_tcslen(pTitle->szTitleQuery)+1];
                _tcscpy(pBatch->szTitleQuery,pTitle->szTitleQuery);
            }
            else
            {
                pBatch->szTitleQuery = new TCHAR[_tcslen(m_Query)+1];
                _tcscpy(pBatch->szTitleQuery,m_Query);
            }
        }

        hNetThread = CreateThread(NULL,0,SpawnSingleDownload,(void*)pBatch,0,&dwThreadID);
    }
    else
    {
        hNetThread = CreateThread(NULL,0,SpawnBatchDownload,(void*)NULL,0,&dwThreadID);
    }

    if (hNetThread)
    {
        CloseHandle(hNetThread);
        fRet = TRUE;
    }

	return (fRet);
}

int CGetInfoFromNet::readtoc()
{
	DWORD dwRet;
    MCI_SET_PARMS   mciSet;

    ZeroMemory( &mciSet, sizeof(mciSet) );

    mciSet.dwTimeFormat = MCI_FORMAT_MSF;
    mciSendCommand( DevHandle, MCI_SET, MCI_SET_TIME_FORMAT, (DWORD_PTR)(LPVOID)&mciSet );

    MCI_STATUS_PARMS mciStatus;
    long lAddress, lStartPos, lDiskLen;
    int i;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;

    //
    // NOTE: none of the mciSendCommand calls below bother to check the
    //       return code.  This is asking for trouble... but if the
    //       commands fail we cannot do much about it.
    //
    dwRet = mciSendCommand( DevHandle, MCI_STATUS,
		    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus);

	int tracks = -1;
	tracks = (UCHAR)mciStatus.dwReturn;

    mciStatus.dwItem = MCI_STATUS_POSITION;
    for ( i = 0; i < tracks; i++ )
    {

	    mciStatus.dwTrack = i + 1;
	    dwRet = mciSendCommand( DevHandle, MCI_STATUS,
			    MCI_STATUS_ITEM | MCI_TRACK,
			    (DWORD_PTR)(LPVOID)&mciStatus);

	    lAddress = (long)mciStatus.dwReturn;

        //converts "packed" time into pure frames
        lAddress =  (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
					(MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
					(MCI_MSF_FRAME( lAddress));

		m_toc[i] = lAddress;

		if (i==0)
		{
			lStartPos = lAddress;
		}
    }

    mciStatus.dwItem = MCI_STATUS_LENGTH;
    dwRet = mciSendCommand( DevHandle, MCI_STATUS,
		    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus);

    /*
    ** Convert the total disk length into frames
    */
    lAddress  = (long)mciStatus.dwReturn;
    lDiskLen =  (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
				(MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
				(MCI_MSF_FRAME( lAddress));

    /*
    ** Now, determine the absolute start position of the sentinel
    ** track.  That is, the special track that marks the end of the
    ** disk.
    */
    lAddress = lStartPos + lDiskLen + 1; //dstewart: add one for true time

	m_toc[i] = lAddress;

	return (tracks);
}

void CGetInfoFromNet::BuildQuery()
{
    wsprintf(m_Query,TEXT("cd=%X"),m_Tracks);
	
	//add each frame stattime to query, include end time of disc
	TCHAR tempstr[MAX_PATH];
	for (int i = 0; i < m_Tracks+1; i++)
	{
		wsprintf(tempstr,TEXT("+%X"),m_toc[i]);
		_tcscat(m_Query,tempstr);
	}
}

void CGetInfoFromNet::AddToBatch(int nNumTracks, TCHAR* szQuery)
{
    if ((g_pNetData) && (g_pNetOpt))
    {
        g_pNetData->AddToBatch(m_MS, szQuery, nNumTracks);
        LPCDOPTIONS pOptions = g_pNetOpt->GetCDOpts();
        if (pOptions)
        {
            pOptions->dwBatchedTitles = g_pNetData->GetNumBatched();
            g_pNetOpt->DownLoadCompletion(0,NULL);
        }
    }
}    

void CopyStreamToFile( IStream* pStream, HANDLE hFile )
{
	TCHAR	achBuf[512];
	ULONG	cb = 1;
	DWORD	dwWritten;
	LARGE_INTEGER	dlib;

	dlib.LowPart = 0;
	dlib.HighPart = 0;
	pStream->Seek( dlib, STREAM_SEEK_SET, NULL );
	pStream->Read( achBuf, 512, &cb );
	while( cb )
	{
		if( FALSE == WriteFile( hFile, achBuf, cb, &dwWritten, NULL ))
		{
			break;
		}
		pStream->Read( achBuf, 512, &cb );
	}
}

BOOL DoDownload(TCHAR* url, TCHAR* szFilename, HWND hwndParent)
{
	TCHAR szPath[_MAX_PATH];
	TCHAR    sz[_MAX_PATH];
	BOOL fGotFileName = FALSE;

	// Get a file name
	if(GetTempPath(_MAX_PATH, szPath))
	{
		if(GetTempFileName(szPath, TEXT("cdd"), 0, sz))
		{
		    fGotFileName = TRUE;
	    }
	}

    if (!fGotFileName)
    {
	    return FALSE;
    }

    IStream* pStream = NULL;

    g_fDownloadDone = FALSE;
    if (FAILED(CreateStreamOnHGlobal( NULL, TRUE, &pStream )))
    {
        return FALSE;
    }
    //pStream was addref'ed by createstreamonhgobal

	CBindStatusCallback* pCDC = new CBindStatusCallback(pStream, hwndParent);
	if(!pCDC)
	{
        pStream->Release();
		return FALSE;
	}
	pCDC->AddRef();

    HRESULT hr = E_NOTIMPL;

    if (g_hURLMon == NULL)
    {
        g_hURLMon = LoadLibrary(TEXT("URLMON.DLL"));
    }

    if (g_hURLMon!=NULL)
    {
	    typedef BOOL (PASCAL *URLDOWNLOADPROC)(LPUNKNOWN, LPCTSTR, DWORD, LPBINDSTATUSCALLBACK);
	    URLDOWNLOADPROC URLDownload = (URLDOWNLOADPROC)GetProcAddress(g_hURLMon,URLFUNCTION);

        if (URLDownload!=NULL)
        {
            #ifdef DBG
	        OutputDebugString(url);
            OutputDebugString(TEXT("\n"));
            #endif
            hr = URLDownload(NULL, url, 0, pCDC);
        }
    }

	if(FAILED(hr))
	{
		pCDC->Release();
        pStream->Release();
        return FALSE;
	}

    pCDC->Release();

    if (g_fCancelDownload)
    {
        return FALSE;
    }

	// Create the file for writing
	HANDLE hFileWrite = CreateFile(sz, GENERIC_READ | GENERIC_WRITE, 
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, NULL);
	if( hFileWrite != INVALID_HANDLE_VALUE )
	{
		CopyStreamToFile( pStream, hFileWrite );
		CloseHandle( hFileWrite );
	}

    pStream->Release();

    _tcscpy(szFilename,sz);

    return TRUE;
}

//dialog box handler for multiple hits
INT_PTR CALLBACK MultiHitDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG :
        {
            TCHAR* szFilename = (TCHAR*)lParam;
            TCHAR szTemp[MAX_PATH];
            TCHAR szArtist[MAX_PATH];
            TCHAR szTitle[MAX_PATH];
            int i = 1;

            _tcscpy(szTitle,TEXT("."));
            
            while (_tcslen(szTitle)>0)
            {
                wsprintf(szTemp,TEXT("Title%i"),i);
       	        GetPrivateProfileString(TEXT("CD"),szTemp,TEXT(""),szTitle,sizeof(szTitle)/sizeof(TCHAR),szFilename);
                wsprintf(szTemp,TEXT("Artist%i"),i);
    	        GetPrivateProfileString(TEXT("CD"),szTemp,TEXT(""),szArtist,sizeof(szArtist)/sizeof(TCHAR),szFilename);
                i++;

                if (_tcslen(szTitle)>0)
                {
                    wsprintf(szTemp,TEXT("%s (%s)"),szTitle,szArtist);
                    SendDlgItemMessage(hwnd,IDC_LIST_DISCS,LB_ADDSTRING,0,(LPARAM)szTemp);
                }
            }

            SendDlgItemMessage(hwnd,IDC_LIST_DISCS,LB_SETCURSEL,0,0);
        }
        break;

        case WM_COMMAND :
        {
            if (LOWORD(wParam)==IDCANCEL)
            {
                EndDialog(hwnd,-1);
            }

            if (LOWORD(wParam)==IDOK)
            {
                LRESULT nSel = SendDlgItemMessage(hwnd,IDC_LIST_DISCS,LB_GETCURSEL,0,0);
                EndDialog(hwnd,nSel+1);
            }
        }
        break;
    }

    return FALSE;
}

BOOL ResolveMultiples(TCHAR* szFilename, BOOL fCurrent, HWND hwndParent)
{
    //special case ... sometimes, this comes back with <2 hits!!!
    //in this case, go ahead and ask for URL1

    TCHAR sznewurl[INTERNET_MAX_URL_LENGTH];
    GetPrivateProfileString(TEXT("CD"),TEXT("URL2"),TEXT(""),sznewurl,sizeof(sznewurl)/sizeof(TCHAR),szFilename);

    INT_PTR nSelection = 0;

    if (_tcslen(sznewurl)==0)
    {
        nSelection = 1;
    }
    else
    {
        if (fCurrent)
        {
            nSelection = DialogBoxParam(g_dllInst, MAKEINTRESOURCE(IDD_MULTIPLE_HITS),
                       hwndParent, MultiHitDlgProc, (LPARAM)szFilename );
        }
    }

    if (nSelection > 0)
    {
        TCHAR szSelected[MAX_PATH];
        wsprintf(szSelected,TEXT("URL%i"),nSelection);

        GetPrivateProfileString(TEXT("CD"),szSelected,TEXT(""),sznewurl,sizeof(sznewurl)/sizeof(TCHAR),szFilename);

        DeleteFile(szFilename);

        if (DoDownload(sznewurl,szFilename, hwndParent))
        {
            return TRUE;
        }
    }

    return FALSE;
}

//no more cover art in first version
#if 0
void TranslateTempCoverToFinal(TCHAR* szCurrent, TCHAR* szFinal, long discid, TCHAR* extension)
{
    //we want to put the cover art in a "coverart" subdir relative to whereever CD player is
    TCHAR szPath[MAX_PATH];
    GetModuleFileName(NULL,szPath,sizeof(szPath));

    TCHAR* szPathEnd;
    szPathEnd = _tcsrchr(szPath, TEXT('\\'))+sizeof(TCHAR);
    _tcscpy(szPathEnd,TEXT("coverart\\"));

    CreateDirectory(szPath,NULL); //create the coverart subdir

    wsprintf(szFinal,TEXT("%s%08X%s"),szPath,discid,extension);
}
#endif

DWORD GetNextDisc(long lOriginal, LPCDBATCH* ppBatch)
{
    DWORD discid = (DWORD)-1;

    //only do the batch if no discid was passed in originally to thread
    if (lOriginal < 1)
    {
        if (*ppBatch!=NULL)
        {
            *ppBatch = (*ppBatch)->pNext;
            if (*ppBatch != NULL)
            {
                discid = (*ppBatch)->dwTitleID;
            }
        }
    }

    return (discid);
}       

LPCDPROVIDER GetNewProvider(LPCDPROVIDER pList, LPCDPROVIDER pCurrent, LPCDPROVIDER pDefault)
{
    //find the next provider that isn't the current
    if (pCurrent == pDefault)
    {
        //we've just done the current provider, so go to the head of the list next
        pCurrent = pList;
        if (pCurrent == pDefault)
        {
            //if the default was also the head of the list, go to the next and return
            pCurrent = pCurrent->pNext;
        }
        return (pCurrent);
    }

    //get the next entry on the list
    pCurrent = pCurrent->pNext;

    //is the next entry the same as the default entry?  if so, move on one more
    if (pCurrent == pDefault)
    {
        pCurrent = pCurrent->pNext;
    }

    return (pCurrent);
}

//if szProvider is NULL, szURL is filled in with "just the query" ...
//if szProvider is not NULL, it is prepended to the query in szURL
int GetTracksAndQuery(LPCDBATCH pBatch, TCHAR* szURL, TCHAR* szProvider)
{
    if (pBatch == NULL)
    {
        return 0;
    }
    
    int nReturn = pBatch->dwNumTracks;

    if (szProvider != NULL)
    {
        wsprintf(szURL,TEXT("%s%s"),szProvider,pBatch->szTitleQuery);
    }
    else
    {
        _tcscpy(szURL,pBatch->szTitleQuery);
    }

    return nReturn;
}

void WINAPI AddTitleToDatabase(DWORD dwDiscID, DWORD dwTracks, TCHAR *szURL, TCHAR *szTempFile)
{
    LPCDTITLE   pCDTitle = NULL;
    TCHAR       tempstr[CDSTR];
    BOOL        fContinue = TRUE;
    DWORD       dwMenus = 0;

    while (fContinue)
    {
        TCHAR szMenuIndex[10];
        TCHAR szMenuEntry[INTERNET_MAX_URL_LENGTH];
        wsprintf(szMenuIndex,TEXT("MENU%i"),dwMenus+1);

		GetPrivateProfileString( TEXT("CD"), szMenuIndex, TEXT(""),
						         szMenuEntry, sizeof(szMenuEntry)/sizeof(TCHAR), szTempFile );

        if (_tcslen(szMenuEntry)>0)
        {
            dwMenus++;
        }
        else
        {
            fContinue = FALSE;
        }
    }

    if (SUCCEEDED(g_pNetData->CreateTitle(&pCDTitle, dwDiscID, dwTracks, dwMenus)))
    {
        GetPrivateProfileString(TEXT("CD"),TEXT("TITLE"),TEXT(""),tempstr,sizeof(tempstr)/sizeof(TCHAR),szTempFile);
        _tcscpy(pCDTitle->szTitle,tempstr);

        GetPrivateProfileString(TEXT("CD"),TEXT("ARTIST"),TEXT(""),tempstr,sizeof(tempstr)/sizeof(TCHAR),szTempFile);
        _tcscpy(pCDTitle->szArtist,tempstr);

        GetPrivateProfileString(TEXT("CD"),TEXT("LABEL"),TEXT(""),tempstr,sizeof(tempstr)/sizeof(TCHAR),szTempFile);
        _tcscpy(pCDTitle->szLabel,tempstr);

        GetPrivateProfileString(TEXT("CD"),TEXT("COPYRIGHT"),TEXT(""),tempstr,sizeof(tempstr)/sizeof(TCHAR),szTempFile);
        _tcscpy(pCDTitle->szCopyright,tempstr);

        GetPrivateProfileString(TEXT("CD"),TEXT("RELEASEDATE"),TEXT(""),tempstr,sizeof(tempstr)/sizeof(TCHAR),szTempFile);
        _tcscpy(pCDTitle->szDate,tempstr);

        g_pNetData->SetTitleQuery(pCDTitle, szURL); 

        for (int i = 1; i < (int) dwTracks + 1; i++)
        {
	        TCHAR tempstrtrack[10];
	        TCHAR tempstrtitle[CDSTR];
	        wsprintf(tempstrtrack,TEXT("TRACK%i"),i);
	        GetPrivateProfileString(TEXT("CD"),tempstrtrack,TEXT(""),tempstrtitle,sizeof(tempstrtitle)/sizeof(TCHAR),szTempFile);

            if (_tcslen(tempstrtitle) == 0)
            {
                TCHAR strFormat[CDSTR];
                LoadString(g_dllInst,IDS_STRING_DEFAULTTRACK,strFormat,sizeof(strFormat)/sizeof(TCHAR));
                wsprintf(tempstrtitle,strFormat,i);
            }

            _tcscpy(pCDTitle->pTrackTable[i-1].szName,tempstrtitle);
        }

        for (i = 1; i < (int) (dwMenus + 1); i++)
        {
	        TCHAR tempstrmenu[10];
	        TCHAR tempstrmenuvalue[CDSTR+INTERNET_MAX_URL_LENGTH+(3*sizeof(TCHAR))]; //3 = two colons and a terminating null
	        wsprintf(tempstrmenu,TEXT("MENU%i"),i);
	        GetPrivateProfileString(TEXT("CD"),tempstrmenu,TEXT(""),tempstrmenuvalue,sizeof(tempstrmenuvalue)/sizeof(TCHAR),szTempFile);

            //need to split menu into its component parts
            if (_tcslen(tempstrmenuvalue)!=0)
            {
                TCHAR* szNamePart;
                szNamePart = _tcsstr(tempstrmenuvalue,URL_SEPARATOR);

                TCHAR* szURLPart;
                szURLPart = _tcsstr(tempstrmenuvalue,URL_SEPARATOR);
                if (szURLPart!=NULL)
                {
                    //need to move past two colons
                    szURLPart = _tcsinc(szURLPart);
                    szURLPart = _tcsinc(szURLPart);
                }

                if (szNamePart!=NULL)
                {
                    *szNamePart = '\0';
                }

                if (tempstrmenuvalue)
                {
                    if (_tcslen(tempstrmenuvalue) >= sizeof(pCDTitle->pMenuTable[i-1].szMenuText)/sizeof(TCHAR))
                    {
                        tempstrmenuvalue[sizeof(pCDTitle->pMenuTable[i-1].szMenuText)/sizeof(TCHAR) - 1] = TEXT('\0');  // Trunc string to max len
                    }
                    _tcscpy(pCDTitle->pMenuTable[i-1].szMenuText,tempstrmenuvalue);
                }

                if (szURLPart)
                { 
                    g_pNetData->SetMenuQuery(&(pCDTitle->pMenuTable[i-1]), szURLPart); 
                }
            }
        }

        g_pNetData->UnlockTitle(pCDTitle,TRUE);

        //at this point, if the title is not in the database, we have a major problem
        if (!g_pNetData->QueryTitle(dwDiscID))
        {
            g_fDBWriteFailure = TRUE;
        }
        else
        {
            g_fDBWriteFailure = FALSE;
        }
    }
}


BOOL IsCertifiedProvider(LPCDPROVIDER pProvider, TCHAR *szTempFile)
{
    BOOL    fCertified = TRUE;
    TCHAR   szCert[MAX_PATH];
    
    GetPrivateProfileString(TEXT("CD"),TEXT("CERTIFICATE"),TEXT(""),szCert,sizeof(szCert)/sizeof(TCHAR),szTempFile);

    fCertified = g_pNetOpt->VerifyProvider(pProvider,szCert);

    return(fCertified);
}

void UpdatePropertyPage(DWORD dwDiscID, BOOL fDownloading, HWND hwndParent)
{
    if (g_pNetOpt)
    {
        LPCDUNIT pUnit = g_pNetOpt->GetCDOpts()->pCDUnitList;

        while (pUnit!=NULL)
        {
            if (pUnit->dwTitleID == dwDiscID)
            {
                pUnit->fDownLoading = fDownloading;
                PostMessage(hwndParent,WM_NET_DB_UPDATE_DISC,0,(LPARAM)pUnit); //Tell the UI we changed status of disc
                break;
            }
            pUnit = pUnit->pNext;
        }
    }
}

BOOL WINAPI DownloadBatch(LPCDBATCH pBatch, LPCDPROVIDER pProvider, LPDWORD pdwMultiHit, LPBOOL pfTimeout, HWND hwndParent)
{
    BOOL    fSuccess = FALSE;
    DWORD   dwTracks;
    TCHAR   szURL[INTERNET_MAX_URL_LENGTH];
    TCHAR   szTempFile[MAX_PATH];
    DWORD   dwDiscID;

    dwTracks = GetTracksAndQuery(pBatch, szURL, pProvider->szProviderURL);
    dwDiscID = pBatch->dwTitleID;
    *pfTimeout = FALSE;

    UpdatePropertyPage(pBatch->dwTitleID, TRUE, hwndParent); //tell prop page ui that disc is downloading

    if (dwTracks > 0 && dwDiscID != 0)
    {
        if (DoDownload(szURL,szTempFile,hwndParent))
        {
            if (IsCertifiedProvider(pProvider, szTempFile))
            {
	            int nMode = GetPrivateProfileInt(TEXT("CD"),TEXT("MODE"),MODE_NOT_FOUND,szTempFile);

                if (nMode == MODE_NOT_FOUND)
                {
                    DeleteFile(szTempFile);
                }
                else if (nMode == MODE_MULTIPLE)
                {
                    if (pdwMultiHit)
                    {
                        (*pdwMultiHit)++;
                    }

                    if (!ResolveMultiples(szTempFile,TRUE,hwndParent))
                    {
                        DeleteFile(szTempFile);
                    }
                    else
                    {
                        nMode = MODE_OK;
                    }
                }
                
                if (nMode == MODE_OK)
                {
                    GetTracksAndQuery(pBatch,szURL,NULL); //reset szURL to lose the provider
                    AddTitleToDatabase(dwDiscID, dwTracks, szURL, szTempFile);
                    DeleteFile(szTempFile);
                    fSuccess = TRUE;
                } //end if mode ok
            } //end if certified provider
        } //end if download ok
        else
        {
            *pfTimeout = TRUE;
        }
    } //end if valid query
    
    UpdatePropertyPage(pBatch->dwTitleID, FALSE, hwndParent); //tell prop page ui that disc is no longer downloading

    return(fSuccess);
}

DWORD WINAPI SpawnSingleDownload(LPVOID pParam)
{
    InterlockedIncrement((LONG*)&g_lNumDownloadingThreads);

    LPCDBATCH pBatch = (LPCDBATCH)pParam;
    HWND hwndParent = g_hwndParent;
    
    if (pBatch)
    {
        DoBatchDownload(pBatch,hwndParent);

        //if download failed, add to batch if not already in db
        //but only do this if batching is turned on
        LPCDOPTIONS pOptions = g_pNetOpt->GetCDOpts();
        if (pOptions)
        {
            LPCDOPTDATA pOptionData = pOptions->pCDData;
            if (pOptionData)
            {
                if (pOptionData->fBatchEnabled)
                {
                    if (!g_pNetData->QueryTitle(pBatch->dwTitleID))
                    {
                        g_pNetData->AddToBatch(pBatch->dwTitleID, pBatch->szTitleQuery, pBatch->dwNumTracks);
                        pOptions->dwBatchedTitles = g_pNetData->GetNumBatched();
                        PostMessage(hwndParent,WM_NET_DB_UPDATE_BATCH,0,0); //Tell the UI we changed number in batch
                    } //end if not in db
                } //if batching is on
            } //end if option data
        } //end if poptions

        delete [] pBatch->szTitleQuery;
        delete pBatch;
    }

    //addref'ed before thread was created
    g_pNetOpt->Release();
    g_pNetData->Release();
    
    InterlockedDecrement((LONG*)&g_lNumDownloadingThreads);
    return 0;
}

DWORD WINAPI SpawnBatchDownload(LPVOID pParam)
{
    InterlockedIncrement((LONG*)&g_lNumDownloadingThreads);

    LPCDBATCH pBatchList = NULL;
    HWND hwndParent = g_hwndParent;

    if (g_pNetData)
    {
        if (SUCCEEDED(g_pNetData->LoadBatch(NULL,&pBatchList)))
        {
            DoBatchDownload(pBatchList,hwndParent);
            g_pNetData->UnloadBatch(pBatchList);
        }
    }

    //addref'ed before thread was created
    g_pNetOpt->Release();
    g_pNetData->Release();
    
    InterlockedDecrement((LONG*)&g_lNumDownloadingThreads);
    return 0;
}

DWORD WINAPI DoBatchDownload(LPCDBATCH pBatchList, HWND hwndParent)
{
	EnterCriticalSection(&g_BatchCrit);

    BOOL    retcode = FALSE;
    DWORD   dwHow;
    BOOL    fConnected;
    DWORD   dwCurrent = 0;
    DWORD   dwOther = 0;
    DWORD   dwMultiHit = 0;
    DWORD   dwTimedOut = 0;

    fConnected = _InternetGetConnectedState(&dwHow,0,TRUE);     // Make sure we are connected to net

    if (fConnected && g_pNetOpt && g_pNetData)                        // Make sure we are in a valid state
    {
        LPCDOPTIONS pOptions = g_pNetOpt->GetCDOpts();             // Get the options, needed for provider list

        if (pOptions && pOptions->pCurrentProvider)             // Make sure we have providers
        {        
            LPCDPROVIDER pProviderList = NULL;
            LPCDPROVIDER pProvider = NULL;
            
            g_pNetOpt->CreateProviderList(&pProviderList);       // Get the sorted provider list
            pProvider = pProviderList;                          // Get the head of the list

            LPCDBATCH pBatch;
                      
            if (pBatchList)
            {
                while (pProvider && !g_fCancelDownload)                 // loop thru providers, but check current first and only once.
                {
                    BOOL fNotifiedUIProvider = FALSE;
                    pBatch = pBatchList;
                
                    while (pBatch && !g_fCancelDownload && !pProvider->fTimedOut)  // We will loop thru each batched title
                    {
                        BOOL fAttemptDownload = TRUE;                   // Assume we are going to try to download all in batch
                        if (pBatch->fRemove)
                        {
                            fAttemptDownload = FALSE; //we've already tried this disc on one provider and got it
                        }

                        if (fAttemptDownload)
                        {
                            if (!fNotifiedUIProvider)
                            {
                                PostMessage(hwndParent,WM_NET_CHANGEPROVIDER,0,(LPARAM)pProvider); //Tell the UI who the provider is
                                fNotifiedUIProvider = TRUE;
                            }

                            BOOL fTimeout = FALSE;

                            if (DownloadBatch(pBatch, pProvider, &dwMultiHit, &fTimeout, hwndParent))  // attempt to download this batch
                            {
                                pBatch->fRemove = TRUE;                         // This batch download succeeded, mark for termination from batch

                                if (pProvider == pOptions->pCurrentProvider)
                                {
                                    dwCurrent++;
                                }
                                else
                                {
                                    dwOther++;
                                }
                            }
                            else
                            {
                                pProvider->fTimedOut = fTimeout;
                            }

                            //check to see if db write failed
                            if (g_fDBWriteFailure)
                            {
                                //let the UI know
                                PostMessage(hwndParent,WM_NET_DB_FAILURE,0,0);

                                //get out of the batch loop
                                break;
                            }
                        
                            //let ui know that something happened with this disc
                            PostMessage(hwndParent,WM_NET_DONE,(WPARAM)g_dllInst,pBatch->dwTitleID);

                            //increment the meter if we know this is the last time we're
                            //visiting this particular disc ... either it was found, or
                            //we are out of possible places to look
                            if ((pBatch->fRemove) || (pProvider->pNext == NULL))
                            {
                                PostMessage(hwndParent,WM_NET_INCMETER,(WPARAM)g_dllInst,pBatch->dwTitleID);
                            }

                        } //end attempt on disc

                        pBatch = pBatch->pNext;
                    } //end batch
                
                    if (g_fDBWriteFailure)
                    {
                        //get out of the provider loop
                        break;
                    }

                    pProvider = pProvider->pNext; //providers are "in order"
                } //end while cycling providers

            } //end if load batch OK

            //check to see if ALL providers timed out ... possible net problem
            BOOL fAllFailed = TRUE;
            pProvider = pProviderList;
            while (pProvider!=NULL)
            {
                if (!pProvider->fTimedOut)
                {
                    fAllFailed = FALSE;
                    break;
                }
                pProvider = pProvider->pNext;
            }

            if (fAllFailed)
            {
                //let the UI know
                PostMessage(hwndParent,WM_NET_NET_FAILURE,0,0);
            }

            g_pNetOpt->DestroyProviderList(&pProviderList);
        } //end if pointers ok

#ifdef DBG
        // Ok, output some interesting stat's about what happened.
        {
            TCHAR str[255];
            wsprintf(str, TEXT("current = %d, other = %d, multihits = %d\n"), dwCurrent, dwOther, dwMultiHit);
            OutputDebugString(str);
        }
#endif
    } //end if connected to net and pointers ok

    if (!fConnected)
    {
        //may be a net problem
        if ((dwHow & (INTERNET_CONNECTION_MODEM|INTERNET_CONNECTION_LAN)) == 0)
        {
            PostMessage(hwndParent,WM_NET_NET_FAILURE,0,0);
        }
    }

    PostMessage(hwndParent,WM_NET_DONE,(WPARAM)g_dllInst,(LPARAM) 0); //fBadGuy ? -1 : 0);

	LeaveCriticalSection(&g_BatchCrit);

    return (retcode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\cdoptimp.cpp ===
/******************************Module*Header*******************************\
* Module Name: cdoptimp.cpp
*
* Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#include "precomp.h"
#include "objbase.h"
#include "cdoptimp.h"
#include "cdopti.h"
#include "cddata.h"

extern HINSTANCE g_dllInst;

/////////////
// Typedefs
/////////////
typedef struct Sheet
{
    INT             iResID;
    DLGPROC         pfnDlgProc;

}SHEET,*LPSHEET;

typedef struct CDReserved
{
    LPCDOPTIONS     pCDOpts;
    BOOL            fChanged;

}CDRESERVED, *LPCDRESERVED;


/////////////
// Defines
/////////////
#define CDKEYSIZE   (20)
#define NUMKEYSRC   (2)
#define NUMPAGES    (3)


//////////
// Globals
//////////
TCHAR gszHelpFile[]               = TEXT("deluxcd.hlp");

const TCHAR szCDKeySet[]          = TEXT("MSDELXCD");
const TCHAR szCDPlayerPath[]      = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\DeluxeCD\\Settings");
const TCHAR szCDSysTrayPath[]     = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
const TCHAR szCDSysTray[]         = TEXT("DeluxeCD");
const TCHAR szCDTrayOption[]      = TEXT("-tray");
const TCHAR szCDStartPlay[]       = TEXT("StartPlay");
const TCHAR szCDExitStop[]        = TEXT("ExitStop");
const TCHAR szCDDispMode[]        = TEXT("DispMode");
const TCHAR szCDTopMost[]         = TEXT("TopMost");
const TCHAR szCDTray[]            = TEXT("Tray");
const TCHAR szCDPlayMode[]        = TEXT("PlayMode");
const TCHAR szCDIntroTime[]       = TEXT("IntroTime");
const TCHAR szCDDownloadEnabled[] = TEXT("DownloadEnabled");
const TCHAR szCDDownloadPrompt[]  = TEXT("DownloadPrompt");
const TCHAR szCDBatchEnabled[]    = TEXT("BatchEnabled");
const TCHAR szCDByArtist[]        = TEXT("ByArtist");
const TCHAR szCDConfirmUpload[]   = TEXT("ConfirmUpload");
const TCHAR szCDWindowX[]         = TEXT("WindowX");
const TCHAR szCDWindowY[]         = TEXT("WindowY");
const TCHAR szCDViewMode[]        = TEXT("ViewMode");

const TCHAR szCDCurrentProvider[] = TEXT("CurrentProvider");

const TCHAR szCDProviderPath[]    = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\DeluxeCD\\Providers\\");
const TCHAR szCDProviderKey[]     = TEXT("Provider");
const TCHAR szCDProviderURL[]     = TEXT("ProviderURL");
const TCHAR szCDProviderName[]    = TEXT("ProviderName");
const TCHAR szCDProviderHome[]    = TEXT("ProviderHome");
const TCHAR szCDProviderLogo[]    = TEXT("ProviderLogo");
const TCHAR szCDProviderUpload[]  = TEXT("ProviderUpload");


////////////
// IUnknown Implementation for CDOpt
////////////


CCDOpt::CCDOpt()
{
    HRESULT hr;

    m_dwRef = 0;
    m_pCDData = NULL;
    m_pCDOpts = new(CDOPTIONS);
    m_hImageList = NULL;
    m_pCDTitle = NULL;
    m_hInst = NULL;
    m_hList = NULL;
    m_uDragListMsg = 0L;
    m_pfnSubProc = NULL;
    m_fEditReturn = FALSE;
    m_fVolChanged = FALSE;
    m_fAlbumsExpanded = FALSE;
    m_fDrivesExpanded = TRUE;
    m_pICDNet = FALSE;
    m_pCDUploadTitle = NULL;
    m_hTitleWnd = NULL;
    m_fDelayUpdate = false;

    if (m_pCDOpts == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        memset(m_pCDOpts,0,sizeof(CDOPTIONS));

        hr = CreateCDList(&(m_pCDOpts->pCDUnitList));

        if (SUCCEEDED(hr))
        {
            m_pCDOpts->pCDData = new(CDOPTDATA);

            if (m_pCDOpts->pCDData == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                memset(m_pCDOpts->pCDData, 0, sizeof(CDOPTDATA));

                hr = GetCDData(m_pCDOpts->pCDData);

                if (SUCCEEDED(hr))
                {
                    hr = GetProviderData(m_pCDOpts);
                }
            }
        }
    }

    if (FAILED(hr))
    {
        DestroyCDOptions();
    }
}


CCDOpt::~CCDOpt()
{
    DestroyCDOptions();
}


STDMETHODIMP CCDOpt::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (IID_IUnknown == riid || IID_ICDOpt == riid)
    {
        *ppv = this;
    }

    if (NULL==*ppv)
    {
        return E_NOINTERFACE;
    }

    AddRef();

    return S_OK;
}

STDMETHODIMP_(ULONG) CCDOpt::AddRef(void)
{
    return ++m_dwRef;
}

STDMETHODIMP_(ULONG) CCDOpt::Release(void)
{
    if (0!=--m_dwRef)
        return m_dwRef;

    delete this;
    return 0;
}


////////////
// ICDOpt Public Method Implementation
////////////


STDMETHODIMP_(LPCDOPTIONS) CCDOpt::GetCDOpts(void)
{
    return(m_pCDOpts);
}


STDMETHODIMP_(void) CCDOpt::OrderProviders(LPCDPROVIDER *ppProviderList, LPCDPROVIDER pCurrentProvider)
{
    if (ppProviderList && *ppProviderList && pCurrentProvider)
    {
        LPCDPROVIDER pProvider;
        LPCDPROVIDER pLast = NULL;
        pProvider = *ppProviderList;

        while (pProvider)
        {
            if (pProvider == pCurrentProvider)
            {
                if (pLast != NULL)      // if current is not already head of list
                {
                    pLast->pNext = pProvider->pNext;                // Current is now removed from the list
                    pProvider->pNext = *ppProviderList;             // Have current point to head of list
                    *ppProviderList = pProvider;                    // Current is now head of list
                }

                break;
            }

            pLast = pProvider;
            pProvider = pProvider->pNext;
        }
    }
}

STDMETHODIMP CCDOpt::CreateProviderList(LPCDPROVIDER *ppProviderList)
{
    HRESULT hr = S_OK;

    if (ppProviderList)
    {
        LPCDPROVIDER pProvider = m_pCDOpts->pProviderList;
        LPCDPROVIDER pCurrentProvider = NULL;
        LPCDPROVIDER pNewProvider = NULL;
        LPCDPROVIDER pLast = NULL;

        while (pProvider)
        {
            pNewProvider = (LPCDPROVIDER) new(CDPROVIDER);

            if (pNewProvider == NULL)
            {
                hr = E_FAIL;
                break;
            }

            memcpy(pNewProvider, pProvider, sizeof(CDPROVIDER));
            pNewProvider->pNext = NULL;

            if (pLast)
            {
                pLast->pNext = pNewProvider;
            }
            else
            {
                *ppProviderList = pNewProvider;
            }

            if (pProvider == m_pCDOpts->pCurrentProvider)
            {
                pCurrentProvider = pNewProvider;
            }

            pLast = pNewProvider;
            pProvider = pProvider->pNext;
        }

        if (SUCCEEDED(hr))
        {
            OrderProviders(ppProviderList, pCurrentProvider);
        }
        else
        {
            DestroyProviderList(ppProviderList);
        }
    }

    return(hr);
}

STDMETHODIMP_(void) CCDOpt::DestroyProviderList(LPCDPROVIDER *ppProviderList)
{
    if (ppProviderList)
    {
        while (*ppProviderList)
        {
            LPCDPROVIDER pTemp = *ppProviderList;
            *ppProviderList = (*ppProviderList)->pNext;
            delete pTemp;
        }
    }
}


STDMETHODIMP_(void) CCDOpt::UpdateRegistry(void)
{
    if (m_pCDOpts && m_pCDOpts->pCDData)
    {
        SetCDData(m_pCDOpts->pCDData);
    }
}


STDMETHODIMP CCDOpt::OptionsDialog(HWND hWnd, LPCDDATA pCDData, CDOPT_PAGE nStartPage)
{
    HRESULT hr = S_OK;
    PROPSHEETHEADER psh;
    PROPSHEETPAGE psp[NUMPAGES];
    int page;
    int pages;
    TCHAR str[MAX_PATH];

    if (m_pCDOpts == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LPCDOPTIONS pCDCopy = NULL;
        CDRESERVED  cdReserved;

        cdReserved.pCDOpts = m_pCDOpts;
        cdReserved.fChanged = FALSE;

        m_pCDOpts->pReserved = (UINT_PTR)&cdReserved;

        if (pCDData && SUCCEEDED(pCDData->CheckDatabase(hWnd)))
        {
            m_pCDData = pCDData;
            m_pCDData->AddRef();
        }


        hr = CopyOptions();

        if (SUCCEEDED(hr))
        {
            pages = NUMPAGES;

            if (m_pCDData == NULL)
            {
                nStartPage = CDOPT_PAGE_PLAY;
                pages = 1;
            }

            for (page = 0; page < pages; page++)
            {
                memset(&psp[page],0,sizeof(PROPSHEETPAGE));
                psp[page].dwSize = sizeof(PROPSHEETPAGE);
                psp[page].dwFlags = PSP_DEFAULT;
                psp[page].hInstance = g_dllInst;
                psp[page].lParam = (LPARAM) this;

                switch (page)
                {
                    case 0:
                        psp[page].pszTemplate = MAKEINTRESOURCE(IDD_CDPLAYEROPTIONS);
                        psp[page].pfnDlgProc = CCDOpt::PlayerOptionsProc;
                    break;

                    case 1:
                        psp[page].pszTemplate = MAKEINTRESOURCE(IDD_CDTITLEOPTIONS);
                        psp[page].pfnDlgProc = CCDOpt::TitleOptionsProc;
                    break;

                    case 2:
                        psp[page].pszTemplate = MAKEINTRESOURCE(IDD_CDPLAYLISTS);
                        psp[page].pfnDlgProc = CCDOpt::PlayListsProc;
                    break;
                }
            }

            LoadString( g_dllInst, IDS_CDOPTIONS, str, sizeof( str )/sizeof(TCHAR) );

            memset(&psh,0,sizeof(psh));
            psh.dwSize = sizeof(psh);
            psh.dwFlags = PSH_DEFAULT | PSH_PROPSHEETPAGE;
            psh.hwndParent = hWnd;
            psh.hInstance = g_dllInst;
            psh.pszCaption = str;
            psh.nPages = pages;
            psh.nStartPage = nStartPage;
            psh.ppsp = psp;

            m_hInst = g_dllInst;

            if (PropertySheet(&psh) == -1)
            {
                hr = E_FAIL;            // Big problem.
            }

            DumpOptionsCopy();

            if (SUCCEEDED(hr))
            {
                if (!cdReserved.fChanged)
                {
                    hr = S_FALSE;       // No changes
                }
                else
                {
                    hr = S_OK;          // There have been changes
                }
            }
        }

        if (m_pCDData)
        {
            m_pCDData->Release();
            m_pCDData = NULL;
        }
    }

    return(hr);
}

STDMETHODIMP_(void) CCDOpt::DestroyCDOptions(void)
{
    if (m_pCDOpts)
    {
        if (m_pCDOpts->pCDData)
        {
            delete m_pCDOpts->pCDData;
        }

        if (m_pCDOpts->pProviderList)
        {
            DestroyProviderList(&(m_pCDOpts->pProviderList));
        }

        if (m_pCDOpts->pCDUnitList)
        {
            DestroyCDList(&(m_pCDOpts->pCDUnitList));
        }

        delete m_pCDOpts;
    }
}


STDMETHODIMP_(void) CCDOpt::RegGetByte(HKEY hKey, const TCHAR *szKey, LPBYTE pByte, BYTE bDefault)
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwByte;

    if (RegQueryValueEx(hKey, szKey, NULL, NULL, (LPBYTE) &dwByte, &dwSize) != NO_ERROR)
    {
        *pByte = bDefault;
    }
    else
    {
        *pByte = (BYTE) dwByte;
    }
}


STDMETHODIMP_(void) CCDOpt::RegGetDWORD(HKEY hKey, const TCHAR *szKey, LPDWORD pdwData, DWORD dwDefault)
{
    DWORD dwSize = sizeof(DWORD);

    if (RegQueryValueEx(hKey, szKey, NULL, NULL, (LPBYTE) pdwData, &dwSize) != NO_ERROR)
    {
        *pdwData = dwDefault;
    }
}


STDMETHODIMP_(void) CCDOpt::RegSetByte(HKEY hKey, const TCHAR *szKey, BYTE bData)
{
    DWORD dwData = (DWORD) bData;

    RegSetValueEx( hKey, (LPTSTR) szKey, 0, REG_DWORD, (LPBYTE) &dwData, sizeof(DWORD) );
}


STDMETHODIMP_(void) CCDOpt::RegSetDWORD(HKEY hKey, const TCHAR *szKey, DWORD dwData)
{
    RegSetValueEx( hKey, (LPTSTR) szKey, 0, REG_DWORD,(LPBYTE) &dwData, sizeof(DWORD) );
}


STDMETHODIMP_(BOOL) CCDOpt::GetUploadPrompt(void)
{
    HKEY        hKey;
    BOOL fConfirm = CDDEFAULT_CONFIRMUPLOAD;

    if (RegOpenKeyEx(HKEY_CURRENT_USER , szCDPlayerPath , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
    {
        RegGetByte(hKey,     szCDConfirmUpload,  (LPBYTE) &fConfirm,      CDDEFAULT_CONFIRMUPLOAD);
        RegCloseKey(hKey);
    }

    return fConfirm;
}


STDMETHODIMP_(void) CCDOpt::SetUploadPrompt(BOOL fConfirmUpload)
{
    HKEY        hKey;

    if (RegCreateKeyEx( HKEY_CURRENT_USER, (LPTSTR)szCDPlayerPath, 0, NULL, 0,KEY_WRITE | KEY_READ, NULL, &hKey, NULL ) == ERROR_SUCCESS)
    {
        RegSetByte(hKey,     szCDConfirmUpload,  (BYTE) fConfirmUpload);
        RegCloseKey(hKey);
    }
}


STDMETHODIMP CCDOpt::GetCDData(LPCDOPTDATA pCDData)
{
    HRESULT     hr = S_OK;
    HKEY        hKey;

    if (pCDData)
    {
        if (RegOpenKeyEx(HKEY_CURRENT_USER , szCDPlayerPath , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
        {
            DWORD dwSize = sizeof(BOOL);

            RegGetByte(hKey,     szCDStartPlay,      (LPBYTE) &pCDData->fStartPlay,          CDDEFAULT_START);
            RegGetByte(hKey,     szCDExitStop,       (LPBYTE) &pCDData->fExitStop,           CDDEFAULT_EXIT);
            RegGetByte(hKey,     szCDDispMode,       (LPBYTE) &pCDData->fDispMode,           CDDEFAULT_DISP);
            RegGetByte(hKey,     szCDTopMost,        (LPBYTE) &pCDData->fTopMost,            CDDEFAULT_TOP);
            RegGetByte(hKey,     szCDTray,           (LPBYTE) &pCDData->fTrayEnabled,        CDDEFAULT_TRAY);
            RegGetDWORD(hKey,    szCDIntroTime,      (LPDWORD) &pCDData->dwIntroTime,        CDDEFAULT_INTRO);
            RegGetDWORD(hKey,    szCDPlayMode,       (LPDWORD) &pCDData->dwPlayMode,         CDDEFAULT_PLAY);
            RegGetByte(hKey,     szCDDownloadEnabled,(LPBYTE) &pCDData->fDownloadEnabled,    CDDEFAULT_DOWNLOADENABLED);
            RegGetByte(hKey,     szCDDownloadPrompt, (LPBYTE) &pCDData->fDownloadPrompt,     CDDEFAULT_DOWNLOADPROMPT);
            RegGetByte(hKey,     szCDBatchEnabled,   (LPBYTE) &pCDData->fBatchEnabled,       CDDEFAULT_BATCHENABLED);
            RegGetByte(hKey,     szCDByArtist,       (LPBYTE) &pCDData->fByArtist,           CDDEFAULT_BYARTIST);
            RegGetDWORD(hKey,    szCDWindowX,        (LPDWORD) &pCDData->dwWindowX,          CW_USEDEFAULT);
            RegGetDWORD(hKey,    szCDWindowY,        (LPDWORD) &pCDData->dwWindowY,          CW_USEDEFAULT);
            RegGetDWORD(hKey,    szCDViewMode,       (LPDWORD) &pCDData->dwViewMode,         0);

            RegCloseKey(hKey);
        }
        else     // Just use the defaults
        {
            pCDData->fStartPlay         = CDDEFAULT_START;
            pCDData->fExitStop          = CDDEFAULT_EXIT;
            pCDData->fDispMode          = CDDEFAULT_DISP;
            pCDData->fTopMost           = CDDEFAULT_TOP;
            pCDData->fTrayEnabled       = CDDEFAULT_TRAY;
            pCDData->dwIntroTime        = CDDEFAULT_INTRO;
            pCDData->dwPlayMode         = CDDEFAULT_PLAY;
            pCDData->fDownloadEnabled   = CDDEFAULT_DOWNLOADENABLED;
            pCDData->fDownloadPrompt    = CDDEFAULT_DOWNLOADPROMPT;
            pCDData->fBatchEnabled      = CDDEFAULT_BATCHENABLED;
            pCDData->fByArtist          = CDDEFAULT_BYARTIST;
            pCDData->dwWindowX          = CW_USEDEFAULT ;
            pCDData->dwWindowY          = CW_USEDEFAULT ;
            pCDData->dwViewMode         = 0;
        }
    }

    return(hr);
}


STDMETHODIMP CCDOpt::SetCDData(LPCDOPTDATA pCDData)
{
    HRESULT     hr = E_FAIL;
    HKEY        hKey;

    if (pCDData)
    {
        if (RegCreateKeyEx( HKEY_CURRENT_USER, (LPTSTR)szCDPlayerPath, 0, NULL, 0,KEY_WRITE | KEY_READ, NULL, &hKey, NULL ) == ERROR_SUCCESS)
        {
            DWORD dwSize = sizeof(BOOL);

            hr = S_OK;

            RegSetByte(hKey,     szCDStartPlay,      (BYTE) pCDData->fStartPlay);
            RegSetByte(hKey,     szCDExitStop,       (BYTE) pCDData->fExitStop);
            RegSetByte(hKey,     szCDDispMode,       (BYTE) pCDData->fDispMode);
            RegSetByte(hKey,     szCDTopMost,        (BYTE) pCDData->fTopMost);
            RegSetByte(hKey,     szCDTray,           (BYTE) pCDData->fTrayEnabled);
            RegSetDWORD(hKey,    szCDIntroTime,      (DWORD) pCDData->dwIntroTime);
            RegSetDWORD(hKey,    szCDPlayMode,       (DWORD) pCDData->dwPlayMode);
            RegSetByte(hKey,     szCDDownloadEnabled,(BYTE) pCDData->fDownloadEnabled);
            RegSetByte(hKey,     szCDDownloadPrompt, (BYTE) pCDData->fDownloadPrompt);
            RegSetByte(hKey,     szCDBatchEnabled,   (BYTE) pCDData->fBatchEnabled);
            RegSetByte(hKey,     szCDByArtist,       (BYTE) pCDData->fByArtist);
            RegSetDWORD(hKey,    szCDWindowX,        (DWORD) pCDData->dwWindowX);
            RegSetDWORD(hKey,    szCDWindowY,        (DWORD) pCDData->dwWindowY);
            RegSetDWORD(hKey,    szCDViewMode,       (DWORD) pCDData->dwViewMode);

            RegCloseKey(hKey);

            if (RegCreateKeyEx( HKEY_LOCAL_MACHINE, (LPTSTR)szCDSysTrayPath, 0, NULL, 0,KEY_WRITE | KEY_READ, NULL, &hKey, NULL ) == ERROR_SUCCESS)
            {
                TCHAR szPath[MAX_PATH];
                TCHAR szCommand[MAX_PATH + 5];

                if (pCDData->fTrayEnabled)
                {
                    GetModuleFileName(NULL, szPath, sizeof(szPath)/sizeof(TCHAR));
                    wsprintf(szCommand, TEXT("%s %s"), szPath, szCDTrayOption);
                    RegSetValueEx( hKey, (LPTSTR) szCDSysTray, 0, REG_SZ,(LPBYTE) szCommand, (wcslen(szCommand)*sizeof(TCHAR))+sizeof(TCHAR));
                }
                else
                {
                    RegDeleteValue( hKey, (LPTSTR) szCDSysTray);
                }

                RegCloseKey(hKey);
            }
        }
    }

    return(hr);
}



STDMETHODIMP_(void) CCDOpt::GetCurrentProviderURL(TCHAR *szProviderURL)
{
    HKEY hKey;

    if (szProviderURL)
    {
        if (RegOpenKeyEx(HKEY_CURRENT_USER , szCDPlayerPath , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
        {
            DWORD dwSize = MAX_PATH;

            RegQueryValueEx(hKey, szCDCurrentProvider, NULL, NULL, (LPBYTE) szProviderURL, &dwSize);

            RegCloseKey(hKey);
        }
    }
}



STDMETHODIMP CCDOpt::GetProviderData(LPCDOPTIONS pCDOpts)
{
    HRESULT         hr = S_OK;
    DWORD           dwCount = 0;
    TCHAR           szPath[MAX_PATH];
    BOOL            done = FALSE;
    LPCDPROVIDER    pProvider;
    LPCDPROVIDER    *ppLast;
    HKEY            hKey;
    TCHAR           szProviderURL[MAX_PATH];

    if (pCDOpts)
    {
        szProviderURL[0] = TEXT('\0');

        GetCurrentProviderURL(szProviderURL);

        ppLast = &(pCDOpts->pProviderList);

        while (!done)
        {
            wsprintf(szPath,TEXT("%s%s%04d"), szCDProviderPath, szCDProviderKey, dwCount);

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE , szPath , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
            {
                BOOL fGotIt = FALSE;

                pProvider = new (CDPROVIDER);

                if (pProvider == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    done = TRUE;
                }
                else
                {
                    memset(pProvider, 0, sizeof(CDPROVIDER));

                    DWORD cbSize = sizeof(pProvider->szProviderURL);

                    if (RegQueryValueEx(hKey, szCDProviderURL, NULL, NULL, (LPBYTE) pProvider->szProviderURL, &cbSize) == NO_ERROR)
                    {
                        cbSize = sizeof(pProvider->szProviderName);

                        if (RegQueryValueEx(hKey, szCDProviderName, NULL, NULL, (LPBYTE) pProvider->szProviderName, &cbSize) == NO_ERROR)
                        {
                            cbSize = sizeof(pProvider->szProviderHome);

                            if (RegQueryValueEx(hKey, szCDProviderHome, NULL, NULL, (LPBYTE) pProvider->szProviderHome, &cbSize) == NO_ERROR)
                            {
                                TCHAR szTempLogo[MAX_PATH];
                                cbSize = sizeof(szTempLogo);

                                if (RegQueryValueEx(hKey, szCDProviderLogo, NULL, NULL, (LPBYTE) szTempLogo, &cbSize) == NO_ERROR)
                                {
                                    ExpandEnvironmentStrings(szTempLogo,pProvider->szProviderLogo,sizeof(pProvider->szProviderLogo)/sizeof(TCHAR));

                                    cbSize = sizeof(pProvider->szProviderUpload);
                                    RegQueryValueEx(hKey, szCDProviderUpload, NULL, NULL, (LPBYTE) pProvider->szProviderUpload, &cbSize);

                                    *ppLast = pProvider;
                                    ppLast = &(pProvider)->pNext;
                                    fGotIt = TRUE;

                                    if (pCDOpts->pDefaultProvider == NULL)
                                    {
                                        pCDOpts->pDefaultProvider = pProvider;
                                        pCDOpts->pCurrentProvider = pProvider;
                                    }

                                    if (!lstrcmp(szProviderURL, pProvider->szProviderURL))
                                    {
                                        pCDOpts->pCurrentProvider = pProvider;
                                    }

                                    #ifdef DEBUG

                                    char szCert[255];

                                    CreateProviderKey(pProvider, szCert, sizeof(szCert));

                                    char szOut[255];

                                    wsprintf(szOut,"%s = %s, Verify = %d\n", pProvider->szProviderName, szCert, VerifyProvider(pProvider, szCert));
                                    OutputDebugString(szOut);

                                    #endif
                                }
                            }
                        }
                    }

                    if (!fGotIt)
                    {
                        delete pProvider;
                        pProvider = NULL;
                    }
                }

                RegCloseKey(hKey);

                dwCount++;
            }
            else
            {
                done = TRUE;
            }
        }
    }

    return(hr);
}


STDMETHODIMP CCDOpt::SetProviderData(LPCDOPTIONS pCDOpts)
{
    HRESULT         hr = S_OK;
    DWORD           dwCount = 0;
    BOOL            done = FALSE;
    LPCDPROVIDER    pProvider;
    HKEY            hKey;

    pProvider = pCDOpts->pCurrentProvider;

    if (pProvider)
    {
        if (RegCreateKeyEx( HKEY_CURRENT_USER, (LPTSTR)szCDPlayerPath, 0, NULL, 0,KEY_WRITE | KEY_READ, NULL, &hKey, NULL ) == ERROR_SUCCESS)
        {
            RegSetValueEx( hKey, (LPTSTR) szCDCurrentProvider, 0, REG_SZ, (LPBYTE) pProvider->szProviderURL, (lstrlen(pProvider->szProviderURL)*sizeof(TCHAR))+sizeof(TCHAR));

            RegCloseKey(hKey);
        }
    }

    return(hr);
}




STDMETHODIMP_(void) CCDOpt::DumpOptionsCopy(void)
{
    if (m_pCDCopy)
    {
        if (m_pCDCopy->pCDData)
        {
            delete m_pCDCopy->pCDData;
        }

        delete m_pCDCopy;

        m_pCDCopy = NULL;
    }
}



STDMETHODIMP CCDOpt::CopyOptions(void)
{
    HRESULT hr = S_OK;

    if (m_pCDOpts)
    {
        m_pCDCopy = (LPCDOPTIONS) new(CDOPTIONS);

        if (m_pCDCopy == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memcpy(m_pCDCopy, m_pCDOpts, sizeof(CDOPTIONS));

            m_pCDCopy->pCDData = new (CDOPTDATA);

            if (m_pCDCopy->pCDData == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                memcpy(m_pCDCopy->pCDData, m_pCDOpts->pCDData, sizeof(CDOPTDATA));
            }
        }
    }

    if (FAILED(hr))
    {
        DumpOptionsCopy();
    }

    return(hr);
}




STDMETHODIMP_(BOOL) CCDOpt::OptionsChanged(LPCDOPTIONS pCDOpts)
{
    BOOL fChanged = FALSE;

    if (pCDOpts)
    {
        LPCDRESERVED pCDReserved =  (LPCDRESERVED) pCDOpts->pReserved;
        LPCDOPTIONS pCDOriginal =   pCDReserved->pCDOpts;

        fChanged = m_fVolChanged;

        if (!fChanged)
        {
            if (memcmp(pCDOpts->pCDData,pCDOriginal->pCDData,sizeof(CDOPTDATA)))
            {
                fChanged = TRUE;
            }
            else if (pCDOpts->pCurrentProvider != pCDOriginal->pCurrentProvider)
            {
                fChanged = TRUE;
            }
            else if (m_pCDData)
            {
                LPCDTITLE pCDTitle = m_pCDData->GetTitleList();

                while (pCDTitle)
                {
                    if (pCDTitle->fChanged || pCDTitle->fRemove)
                    {
                        fChanged = TRUE;
                        break;
                    }

                    pCDTitle = pCDTitle->pNext;
                }
            }
        }
    }

    return(fChanged);
}


STDMETHODIMP_(void) CCDOpt::ApplyCurrentSettings(void)
{

    if (m_pCDCopy)
    {
        if (OptionsChanged(m_pCDCopy))
        {
            LPCDRESERVED pCDReserved =  (LPCDRESERVED) m_pCDCopy->pReserved;

            pCDReserved->fChanged = TRUE;

            memcpy(m_pCDOpts->pCDData, m_pCDCopy->pCDData, sizeof(CDOPTDATA));
            m_pCDOpts->pCurrentProvider = m_pCDCopy->pCurrentProvider;

            SetCDData(m_pCDCopy->pCDData);
            SetProviderData(m_pCDCopy);

            if (m_pCDData)
            {
                m_pCDData->PersistTitles();
            }

            if (m_pCDCopy->pfnOptionsCallback)
            {
                m_pCDCopy->pfnOptionsCallback(m_pCDCopy);
            }
        }
    }
}


STDMETHODIMP_(void) CCDOpt::ToggleApplyButton(HWND hDlg)
{
    HWND hwndSheet;

    if (m_pCDCopy)
    {
        hwndSheet = GetParent(hDlg);

        if (OptionsChanged(m_pCDCopy))
        {
            PropSheet_Changed(hwndSheet,hDlg);
        }
        else
        {
            PropSheet_UnChanged(hwndSheet,hDlg);
        }
    }
}



STDMETHODIMP CCDOpt::AcquireKey(LPCDKEY pCDKey, char *szName)
{
    HRESULT hr = E_FAIL;
    DWORD dwLength = strlen(szName);

    pCDKey->hProv = NULL;

    if(!CryptAcquireContext(&(pCDKey->hProv), szCDKeySet, NULL, PROV_RSA_FULL, 0 ))
    {
        hr = GetLastError();

        if (hr == NTE_BAD_KEYSET)
        {
            if(CryptAcquireContext(&(pCDKey->hProv), szCDKeySet, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET ))
            {
                hr = S_OK;
            }
            else
            {
                hr = GetLastError();
            }
        }
    }

    if(pCDKey->hProv)
    {
        if(CryptCreateHash(pCDKey->hProv, CALG_MD5, 0, 0, &(pCDKey->hHash)))
        {
            if(CryptHashData(pCDKey->hHash, (BYTE *)szName, dwLength, 0))
            {
                if(CryptDeriveKey(pCDKey->hProv, CALG_RC2, pCDKey->hHash, CRYPT_EXPORTABLE, &(pCDKey->hKey)))
                {
                    hr = S_OK;
                }
            }
        }
    }

    if (FAILED(hr))
    {
        hr = GetLastError();
    }

    return(hr);
}

STDMETHODIMP_(void) CCDOpt::ReleaseKey(LPCDKEY pCDKey)
{
    if(pCDKey->hHash)
    {
        CryptDestroyHash(pCDKey->hHash);
        pCDKey->hHash = 0;
    }

    if(pCDKey->hKey)
    {
        CryptDestroyKey(pCDKey->hKey);
        pCDKey->hKey = 0;
    }

    if(pCDKey->hProv)
    {
        CryptReleaseContext(pCDKey->hProv, 0);
        pCDKey->hProv = 0;
    }
}


// This function takes a certification key, decrypts it and determines it's validity
//
// It first converts the returned data from it's re-able numeric text version, into
// it's raw encrypted data format.
//
// It then generates the data key using the current provider data, as was done when the key
// was generated
//
// It then decrypts the encrypted data and compares it to the data key, if they match, great
// if not, then this provider is not certified and was attempting to mess with us.

STDMETHODIMP_(BOOL) CCDOpt::VerifyProvider(LPCDPROVIDER pCDProvider, TCHAR *szCertKey)
{
    BOOL fCertified = FALSE;
    CDKEY cdKey;
    char  szKey[CDKEYSIZE * 2]; //note: crypto doesn't know unicode, we'll do the conversion later
    TCHAR szMatch[CDKEYSIZE];
    DWORD dwSize;
    TCHAR *szSrc;
    TCHAR szHex[3];
    LPBYTE pData;
    HRESULT hr;

    szSrc = szCertKey;
    dwSize = lstrlen(szCertKey);
    szHex[2] = TEXT('\0');
    pData = (LPBYTE) szKey;

    for (DWORD dwPos = 0; dwPos < dwSize; dwPos += 2)
    {
        szHex[0] = szSrc[0];
        szHex[1] = szSrc[1];
        szSrc += 2;
        _stscanf(szHex,TEXT("%xd"),pData);
        pData++;
    }

    dwSize = dwSize >> 1;

    memset(&cdKey,0,sizeof(cdKey));

    if (SUCCEEDED(CreateCertString(pCDProvider, szMatch)))
    {
        char chKeyName[MAX_PATH];
        #ifdef UNICODE
        WideCharToMultiByte(CP_ACP, 0, pCDProvider->szProviderName,
                                        -1, chKeyName, MAX_PATH, NULL, NULL);
        #else
        strcpy(chKeyName,pCDProvider->szProviderName);
        #endif

        hr = AcquireKey(&cdKey, chKeyName);

        if (SUCCEEDED(hr))
        {
            if (CryptDecrypt(cdKey.hKey, 0, TRUE, 0, (BYTE *) szKey, &dwSize))
            {
                szKey[dwSize] = TEXT('\0');

                //convert key back to unicode for string comparison
                #ifdef UNICODE
                wchar_t wszKey[CDKEYSIZE*2];
                MultiByteToWideChar( CP_ACP, 0, szKey, -1, wszKey, sizeof(wszKey) / sizeof(wchar_t) );
                #else
                char wszKey[CDKEYSIZE*2];
                strcpy(wszKey,szKey);
                #endif

                if (lstrcmp(szMatch, wszKey) == 0)
                {
                    fCertified = TRUE;
                }
            }
            else
            {
                hr = GetLastError();

                if (hr == NTE_PERM)
                {
                    //succeed in the case where crypto fails due to import restrictions (i.e. France)
                    fCertified = TRUE;
                }
            }

            ReleaseKey(&cdKey);
        }
    }

    return fCertified;
}


// This function creates a string to be encrypted based on data in the provider header
//
// It takes the provider name and the provider URL and strips out any spaces and punctuation
// Of the data that remains, it only uses every other character. It fills out the key
// to exactly CDKEYSIZE characters, when it's full it stops, if it runs out of input
// characters from the header, it simply wraps back to the begining of the input data until full.
// Also, the output characters are stored in reverse order than they are found and every other
// character is capitalized, while all others are lowercased.
// This generates a key that is encrypted using crypto.
//
// During runtime in the shipped product, the key passed down to us is decrypted, this key is
// re-generated from the provider and the strings must match, if not, well, then it's not certified.
//
STDMETHODIMP CCDOpt::CreateCertString(LPCDPROVIDER pCDProvider, TCHAR *szCertStr)
{
    HRESULT hr = S_OK;
    TCHAR *pDest = szCertStr + (CDKEYSIZE - 2);
    TCHAR *pSrc = NULL;
    TCHAR *pSrcPtrs[NUMKEYSRC];
    DWORD count = 0;
    DWORD dwSrc = 0;

    pSrcPtrs[0] = pCDProvider->szProviderName;
    pSrcPtrs[1] = pCDProvider->szProviderURL;

    pSrc = pSrcPtrs[dwSrc];

    while(count < (DWORD)(CDKEYSIZE - 1))
    {
        while(*pSrc && (_istspace(*pSrc) || _istpunct(*pSrc)))
        {
            pSrc++;
        }

        if (*pSrc == TEXT('\0'))
        {
            dwSrc = (dwSrc + 1) % NUMKEYSRC;

            if (dwSrc == 0 && count == 0)
            {
                hr = E_INVALIDARG;
                break;
            }

            pSrc = pSrcPtrs[dwSrc];
        }
        else
        {
            *pDest = *pSrc++;

            if (*pSrc != TEXT('\0'))
            {
                pSrc++;
            }

            if (count & 1)
            {
                *pDest = _totlower(*pDest);
            }
            else
            {
                *pDest = _totupper(*pDest);
            }

            *pDest--;
            count++;
        }
    }

    if (SUCCEEDED(hr))
    {
        szCertStr[CDKEYSIZE - 1] = TEXT('\0');
    }

    return(hr);
}


// This function will generate an Certification string using the provider information,
//
// this function only operates in a build that has DEBUG defined, in the shipping version this
// function will return E_NOTIMPL.
//
// First, using the provider data, a data key is generated of a precise size.  This key is then
// encrypted.  The raw encrypted data is then converted to a readable numeric text format and
// returned as the certification key for this provider
//
// This certification key will be provided to the provided who will download it upon request to
// allow us to verify that they are indeed a licensed cd data provider.
//
// This key does NOT expire, it's mainly here to prevent unlicensed data providers from hooking
// into this product.

STDMETHODIMP CCDOpt::CreateProviderKey(LPCDPROVIDER pCDProvider, TCHAR *szCertKey, UINT cBytes)
{
    HRESULT hr = E_NOTIMPL;

#ifdef DEBUG

    hr = S_OK;

    if (cBytes < 128 || pCDProvider == NULL || szCertKey == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        TCHAR szKey[CDKEYSIZE * 2];

        if (SUCCEEDED(CreateCertString(pCDProvider, szKey)))
        {
            CDKEY cdKey;

            memset(&cdKey,0,sizeof(cdKey));

            hr = AcquireKey(&cdKey, pCDProvider->szProviderName);

            if (SUCCEEDED(hr))
            {
                DWORD dwSize = lstrlen(szKey);

                if (CryptEncrypt(cdKey.hKey, 0, TRUE, 0, (BYTE *) szKey, &dwSize, CDKEYSIZE * 2))
                {
                    LPBYTE pData = (LPBYTE) szKey;
                    TCHAR *szDest = szCertKey;

                    for (DWORD dwPos = 0; dwPos < dwSize; dwPos++, szDest += 2, pData++)
                    {
                        wsprintf(szDest, TEXT("%02x"), (UINT) *pData);
                    }

                    hr = S_OK;
                }
                else
                {
                    hr = GetLastError();
                }

                ReleaseKey(&cdKey);
            }
        }
    }

#endif // DEBUG

    return hr;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\cddata.cpp ===
//--------------------------------------------------------------------------;
//
//  File: cddb.cpp
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved
//
//--------------------------------------------------------------------------;

#include "precomp.h"
#include "cdopti.h"
#include "cddata.h"
#include "shlobj.h"
#include "shlwapi.h"

#define SECTION_BUFFER      (512)
#define PLAYLIST_BUFFER     (255)
#define BUFFERINC   (128)

#define MAXNUMPLAY (127)
#define ROWSET  1

#ifndef SQL_SUCCEEDED
#define SQL_SUCCEEDED(rc) (((rc)&(~1))==0)
#endif

#ifndef SQL_W_CHAR
#undef SQL_C_WCHAR
#define SQL_C_WCHAR		 	(-8)
#endif

#ifndef SQL_LONGCHAR_FIELD
#define SQL_LONGCHAR_FIELD (-10)
#endif

const TCHAR     gszIniFile[]     = TEXT("cdplayer.ini");
const TCHAR     gszDefault[]     = TEXT("\0");
const TCHAR     gszArtist[]      = TEXT("artist");
const TCHAR     gszTitle[]       = TEXT("title");
const TCHAR     gszNumTracks[]   = TEXT("numtracks");
const TCHAR     gszOrder[]       = TEXT("order");
const TCHAR     gszNumPlay[]     = TEXT("numplay");

const TCHAR     gszDriverName[]  = TEXT("Microsoft Access Driver (*.mdb)");
const TCHAR     gszDSNAttr[]     = TEXT("DSN=DeluxeCD%cDefaultDir=%s%cDriverID=25%cDBQ=DeluxeCD.mdb%c");
const TCHAR     gszDSNCreate[]   = TEXT("CREATE_DB=%s\\DeluxeCD.mdb%c");

const TCHAR     gszTitleTable[]  = TEXT("Titles");
const TCHAR     gszTrackTable[]  = TEXT("Tracks");
const TCHAR     gszMenuTable[]   = TEXT("Menus");
const TCHAR     gszBatchTable[]  = TEXT("Batch");

TCHAR         gszDSN[]         = TEXT("DeluxeCD");

TCHAR         gszTitlesCreate[] = TEXT("create table Titles ")
                                       TEXT("(")
                                            TEXT("TitleID long, ")
                                            TEXT("Artist longchar, ")
                                            TEXT("Title longchar, ")
                                            TEXT("Copyright longchar, ")
                                            TEXT("Label longchar, ")
                                            TEXT("ReleaseDate longchar, ")
                                            TEXT("NumTracks long, ")
                                            TEXT("NumMenus long, ")
                                            TEXT("PlayList longchar, ")
                                            TEXT("TitleQuery longchar ")
                                       TEXT(")");

TCHAR        gszTracksCreate[] = TEXT("create table Tracks ")
                                       TEXT("(")
                                            TEXT("TitleID long, ")
                                            TEXT("TrackID long, ")
                                            TEXT("TrackName longchar ")
                                       TEXT(")");

TCHAR         gszMenusCreate[] = TEXT("create table Menus ")
                                       TEXT("(")
                                            TEXT("TitleID long, ")
                                            TEXT("MenuID long, ")
                                            TEXT("MenuName longchar, ")
                                            TEXT("MenuQuery longchar ")
                                       TEXT(")");

TCHAR         gszBatchCreate[] = TEXT("create table Batch ")
                                       TEXT("(")
                                            TEXT("TitleID long, ")
                                            TEXT("NumTracks long, ")
                                            TEXT("TitleQuery longchar")
                                       TEXT(")");


SDWORD              gcbTitles[] = { 0, SQL_NTS, SQL_NTS, SQL_NTS, SQL_NTS, SQL_NTS, 0, 0, SQL_NTS, INTERNET_MAX_PATH_LENGTH };
SDWORD              gcbTracks[] = { 0, 0, SQL_NTS };
SDWORD              gcbMenus[]  = { 0, 0, SQL_NTS, INTERNET_MAX_PATH_LENGTH };
SDWORD              gcbBatch[]  = { 0, 0, INTERNET_MAX_PATH_LENGTH };



extern HINSTANCE g_dllInst;

////////////
// Functions
////////////

CCDData::CCDData()
{
    m_pTitleList = NULL;
    m_pBatchList = NULL;
    m_dwLoadCnt = 0;
    m_dwBatchCnt = 0;
    m_henv = NULL;
    m_hdbc = NULL;
    m_fToldUser = FALSE;
    m_pSQL = NULL;
    m_dwRef = 0;

    memset(&m_bd, 0, sizeof(m_bd));

	InitializeCriticalSection(&m_crit);

}


CCDData::~CCDData()
{
    CloseDatabase();

    if (m_pTitleList)
    {
        DestroyTitles(&m_pTitleList);
    }

    if (m_pSQL)
    {
        delete m_pSQL;
    }

	DeleteCriticalSection(&m_crit);
}


STDMETHODIMP CCDData::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (IID_IUnknown == riid || IID_ICDData == riid)
    {
        *ppv = this;
    }

    if (NULL==*ppv)
    {
        return E_NOINTERFACE;
    }

    AddRef();

    return S_OK;
}


STDMETHODIMP CCDData::GetSQLPtr(BOOL fInited)
{
	HRESULT hr = S_OK;

	if (m_pSQL == NULL)
	{
        static BOOL fAttempt = FALSE;

        if (!fAttempt)
        {
            m_pSQL = new SQL;

            if (m_pSQL && !m_pSQL->Initialize())
            {
                delete m_pSQL;
                m_pSQL = NULL;
		        hr = E_FAIL;
            }
            else
            {
                if (!fInited)     // we must be running in shell mode, quietly initialize
                {
                    Initialize(NULL);
                    CheckDatabase(NULL);
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }

        fAttempt = TRUE;
    }

	return(hr);
}

STDMETHODIMP_(ULONG) CCDData::AddRef(void)
{
    return ++m_dwRef;
}


STDMETHODIMP_(ULONG) CCDData::Release(void)
{
    if (0!=--m_dwRef)
        return m_dwRef;

    delete this;
    return 0;
}


STDMETHODIMP_(void) CCDData::Enter(void)
{
	EnterCriticalSection(&m_crit);
}

STDMETHODIMP_(void) CCDData::Leave(void)
{
	LeaveCriticalSection(&m_crit);
}





STDMETHODIMP CCDData::GetUnknownString(TCHAR **ppStr, const TCHAR *szSection, const TCHAR *szEntry, DWORD dwInitialAlloc)
{
    TCHAR   *pStr;
    DWORD   dwSize;
    DWORD   dwResult;
    HRESULT hr = S_OK;

    dwSize = dwInitialAlloc - BUFFERINC;

    pStr = NULL;

    do
    {
        dwSize += BUFFERINC;

        if (pStr)
        {
            delete pStr;
        }

        pStr = new(TCHAR[dwSize]);

        if (pStr == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        dwResult = GetPrivateProfileString(szSection, szEntry, TEXT("\0"), pStr, dwSize, gszIniFile);
    }
    while (dwResult == (dwSize - 2));

    *ppStr = pStr;

    return(hr);
}




STDMETHODIMP_(void) CCDData::ImportTrack(TCHAR *szDiscID, DWORD dwTrack)
{
    TCHAR szTrack[6];

    wsprintf(szTrack,TEXT("%d"),dwTrack);
    GetPrivateProfileString(szDiscID,szTrack,gszDefault,m_bd.CDTrack.szName,CDSTR,gszIniFile);
}


STDMETHODIMP_(RETCODE) CCDData::ImportTracks(HSTMT hstmt, TCHAR *szDiscID)
{
    RETCODE rc = SQL_SUCCESS;

    for (DWORD dwTrack = 0; dwTrack < m_bd.CDTitle.dwNumTracks; dwTrack++)
    {
        ImportTrack(szDiscID, dwTrack);

        rc = m_pSQL->SetPos(hstmt, 0, SQL_ADD, SQL_LOCK_NO_CHANGE);

        if (rc == SQL_SUCCESS)
        {
            m_bd.dwTrackID++;
        }
        else
        {
            ReportError(&m_bd, hstmt);
            break;
        }

    }

    return(rc);
}


STDMETHODIMP CCDData::ImportTitle(TCHAR *szDiscID)
{
    HRESULT     hr = S_OK;
    DWORD       dwTitleID;

    _stscanf(szDiscID,TEXT("%xd"),&dwTitleID);

    if (dwTitleID == CDTITLE_NODISC)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_bd.CDTitle.dwTitleID      = dwTitleID;
        m_bd.CDTitle.dwNumTracks    = GetPrivateProfileInt(szDiscID,gszNumTracks,0,gszIniFile);
        m_bd.CDTitle.dwNumPlay      = GetPrivateProfileInt(szDiscID,gszNumPlay,0,gszIniFile);
        GetPrivateProfileString(szDiscID, gszArtist, gszDefault, m_bd.CDTitle.szArtist, CDSTR, gszIniFile);
        GetPrivateProfileString(szDiscID, gszTitle,  gszDefault, m_bd.CDTitle.szTitle,  CDSTR, gszIniFile);

        m_bd.szPlayList[0] = TEXT('\0');
        m_bd.szQuery[0] = TEXT('\0');

        if (m_bd.CDTitle.dwNumPlay)
        {
            TCHAR   *pPlayTable = NULL;
            TCHAR   *pText = NULL;
            DWORD   dwIndex;
            int     iNum;
            TCHAR   *pDst = m_bd.szPlayList;

            m_bd.CDTitle.dwNumPlay = min(m_bd.CDTitle.dwNumPlay, MAXNUMPLAY);

            if (FAILED(GetUnknownString(&pPlayTable, szDiscID, gszOrder, PLAYLIST_BUFFER)))
            {
                m_bd.CDTitle.dwNumPlay = 0;
            }
            else
            {
                pText = pPlayTable;

                for (dwIndex = 0; dwIndex < m_bd.CDTitle.dwNumPlay && *pText; dwIndex++)
                {
                    _stscanf(pText,TEXT("%d"), &iNum);
                    wsprintf(pDst, TEXT("%02x"), iNum);

                    while(*pDst != TEXT('\0'))
                    {
                        pDst++;
                    }

                    while(isdigit(*pText++));
                }

                delete pPlayTable;
            }
        }
    }

    return(hr);
}


STDMETHODIMP_(void) CCDData::ImportDatabase(LPTIMEDMETER ptm, HSTMT *hstmt, TCHAR *szDiscID)
{
    DWORD   dwCount = 0;
    RETCODE rc;

    while(*szDiscID)
    {
        m_bd.dwTrackID = 0;
        m_bd.dwMenuID = 0;

        if (SUCCEEDED(ImportTitle(szDiscID)))
        {
            rc = ImportTracks(hstmt[1], szDiscID);

            if (rc == SQL_SUCCESS)
            {
                rc = m_pSQL->SetPos(hstmt[0], 0, SQL_ADD, SQL_LOCK_NO_CHANGE);
                ReportError(&m_bd, hstmt);
            }

            if (!SQL_SUCCEEDED(rc))
            {
                break;
            }
        }

        UpdateMeter(ptm);

        while(*szDiscID++);
    }
}



STDMETHODIMP_(DWORD) CCDData::ImportCount(TCHAR *pEntries)
{
    TCHAR *szDiscID = pEntries;
    DWORD dwCount = 0;

    while(*szDiscID)
    {
        dwCount++;
        while(*szDiscID++);
    }

    return(dwCount);
}




STDMETHODIMP_(void) CCDData::CreateMeter(LPTIMEDMETER ptm, HWND hWnd, DWORD dwCount, DWORD dwJump, UINT uStringID)
{
    if (hWnd && ptm)
    {
        ptm->hMeter = CreateDialog(g_dllInst,MAKEINTRESOURCE(IDD_LOADSTATUS),hWnd, MeterHandler);

        if (ptm->hMeter)
        {
            ptm->hParent = hWnd;
            ptm->dwStartTime = timeGetTime();
            ptm->dwRange = dwCount;
            ptm->fShowing = FALSE;
            ptm->dwCount = 0;
            ptm->dwShowCount = 0;
            ptm->dwJump = dwJump;

            if (uStringID != 0)
            {
                TCHAR szTitle[255];
                LoadString(g_dllInst, uStringID, szTitle, sizeof(szTitle)/sizeof(TCHAR));
                SetWindowText(ptm->hMeter, szTitle);
            }
        }
    }
    else
    {
        if (ptm)
        {
            memset(ptm, 0, sizeof(TIMEDMETER));
        }
    }
}


STDMETHODIMP_(void) CCDData::UpdateMeter(LPTIMEDMETER ptm)
{
    if (ptm && ptm->hMeter)
    {
        ptm->dwCount++;

        if (ptm->fShowing)
        {
            if (ptm->hMeter && ((ptm->dwCount % ptm->dwJump) == 0))
            {
                SendDlgItemMessage( ptm->hMeter, IDC_PROGRESSMETER, PBM_SETPOS, (WPARAM) ptm->dwCount - ptm->dwShowCount, 0);
            }
        }
        else
        {
            if ((ptm->dwCount % ptm->dwJump) == 0)
            {
                DWORD dwUsedTime = timeGetTime() - ptm->dwStartTime;               // Compute time used
                DWORD dwProjected = (ptm->dwRange / ptm->dwCount) * dwUsedTime;    // Project Time to complete
                DWORD dwProjRemain = dwProjected - dwUsedTime;                     // Compute projected remaining time

                if (dwProjRemain >= 1500)        // If it looks like it's going to take a while, put up the meter
                {
                    DWORD dwNumJumps = ptm->dwCount / ptm->dwJump;
                    DWORD dwJumpTime = dwUsedTime / dwNumJumps;

                    if (dwJumpTime > 200)       // To make sure the meter moves smoothly, re-compute jump count
                    {
                        ptm->dwJump = (ptm->dwJump / ((dwJumpTime / 200) + 1)) + 1;
                    }

                    ptm->dwShowCount = ptm->dwCount;
                    SendDlgItemMessage( ptm->hMeter, IDC_PROGRESSMETER, PBM_SETRANGE, 0, MAKELPARAM(0, ptm->dwRange - ptm->dwShowCount));
                    SendDlgItemMessage( ptm->hMeter, IDC_PROGRESSMETER, PBM_SETPOS, (WPARAM) 0, 0);
			        ShowWindow(ptm->hMeter,SW_SHOWNORMAL);
			        UpdateWindow(ptm->hMeter);
                    ptm->fShowing = TRUE;
                }
            }
        }
    }
}



STDMETHODIMP_(void) CCDData::DestroyMeter(LPTIMEDMETER ptm)
{
    if (ptm && ptm->hMeter)
    {
        DestroyWindow(ptm->hMeter);
        SetForegroundWindow(ptm->hParent);
        memset(ptm, 0, sizeof(LPTIMEDMETER));
    }
}



STDMETHODIMP_(void) CCDData::InitDatabase(HSTMT *hstmt)
{
    m_pSQL->ExecDirect(hstmt[0], (UCHAR *) TEXT("drop table Titles"), SQL_NTS);
    m_pSQL->ExecDirect(hstmt[1], (UCHAR *) TEXT("drop table Tracks"), SQL_NTS);
    m_pSQL->ExecDirect(hstmt[2], (UCHAR *) TEXT("drop table Menus"), SQL_NTS);
    m_pSQL->ExecDirect(hstmt[3], (UCHAR *) TEXT("drop table Batch"), SQL_NTS);

    m_pSQL->ExecDirect(hstmt[0], (UCHAR *) gszTitlesCreate, SQL_NTS);
    m_pSQL->ExecDirect(hstmt[1], (UCHAR *) gszTracksCreate, SQL_NTS);
    m_pSQL->ExecDirect(hstmt[2], (UCHAR *) gszMenusCreate, SQL_NTS);
    m_pSQL->ExecDirect(hstmt[3], (UCHAR *) gszBatchCreate, SQL_NTS);

    m_pSQL->FreeStmt(hstmt[0], SQL_CLOSE);
    m_pSQL->FreeStmt(hstmt[1], SQL_CLOSE);
    m_pSQL->FreeStmt(hstmt[2], SQL_CLOSE);
    m_pSQL->FreeStmt(hstmt[3], SQL_CLOSE);
}



STDMETHODIMP_(void) CCDData::SetCursors(HSTMT *hstmt)
{
    for (DWORD dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
    {
        m_pSQL->SetStmtOption(hstmt[dwIndex], SQL_CONCURRENCY, SQL_CONCUR_VALUES);
        m_pSQL->SetStmtOption(hstmt[dwIndex], SQL_CURSOR_TYPE, SQL_CURSOR_KEYSET_DRIVEN);
        m_pSQL->SetStmtOption(hstmt[dwIndex], SQL_ROWSET_SIZE, ROWSET);
    }
}


STDMETHODIMP_(void) CCDData::InitCBTable(LPBOUND pbd)
{
    memcpy(pbd->cbt.cbTitles, gcbTitles, sizeof(gcbTitles));
    memcpy(pbd->cbt.cbTracks, gcbTracks, sizeof(gcbTracks));
    memcpy(pbd->cbt.cbMenus,  gcbMenus,  sizeof(gcbMenus));
    memcpy(pbd->cbt.cbBatch,  gcbBatch,  sizeof(gcbBatch));
}

STDMETHODIMP_(void) CCDData::BindTitles(HSTMT *hstmt, LPBOUND pbd)
{
    m_pSQL->BindCol(hstmt[0],  1, SQL_C_ULONG,  &(pbd->CDTitle.dwTitleID),    sizeof(pbd->CDTitle.dwTitleID),     &pbd->cbt.cbTitles[0]);
    m_pSQL->BindCol(hstmt[0],  2, SQL_C_WCHAR,   pbd->CDTitle.szArtist,        sizeof(pbd->CDTitle.szArtist),      &pbd->cbt.cbTitles[1]);
    m_pSQL->BindCol(hstmt[0],  3, SQL_C_WCHAR,   pbd->CDTitle.szTitle,         sizeof(pbd->CDTitle.szTitle),       &pbd->cbt.cbTitles[2]);
    m_pSQL->BindCol(hstmt[0],  4, SQL_C_WCHAR,   pbd->CDTitle.szCopyright,     sizeof(pbd->CDTitle.szCopyright),   &pbd->cbt.cbTitles[3]);
    m_pSQL->BindCol(hstmt[0],  5, SQL_C_WCHAR,   pbd->CDTitle.szLabel,         sizeof(pbd->CDTitle.szLabel),       &pbd->cbt.cbTitles[4]);
    m_pSQL->BindCol(hstmt[0],  6, SQL_C_WCHAR,   pbd->CDTitle.szDate,          sizeof(pbd->CDTitle.szDate),        &pbd->cbt.cbTitles[5]);
    m_pSQL->BindCol(hstmt[0],  7, SQL_C_ULONG,  &(pbd->CDTitle.dwNumTracks),  sizeof(pbd->CDTitle.dwNumTracks),   &pbd->cbt.cbTitles[6]);
    m_pSQL->BindCol(hstmt[0],  8, SQL_C_ULONG,  &(pbd->CDTitle.dwNumMenus),   sizeof(pbd->CDTitle.dwNumMenus),    &pbd->cbt.cbTitles[7]);
    m_pSQL->BindCol(hstmt[0],  9, SQL_C_WCHAR,   pbd->szPlayList,              sizeof(pbd->szPlayList),            &pbd->cbt.cbTitles[8]);
    m_pSQL->BindCol(hstmt[0], 10, SQL_C_WCHAR,   pbd->szQuery,                 sizeof(pbd->szQuery),               &pbd->cbt.cbTitles[9]);
}


STDMETHODIMP_(void) CCDData::BindTracks(HSTMT *hstmt, LPBOUND pbd)
{
    m_pSQL->BindCol(hstmt[1],  1, SQL_C_ULONG,  &(pbd->CDTitle.dwTitleID),    sizeof(pbd->CDTitle.dwTitleID),     &pbd->cbt.cbTracks[0]);
    m_pSQL->BindCol(hstmt[1],  2, SQL_C_ULONG,  &(pbd->dwTrackID),            sizeof(pbd->dwTrackID),             &pbd->cbt.cbTracks[1]);
    m_pSQL->BindCol(hstmt[1],  3, SQL_C_WCHAR,   pbd->CDTrack.szName,          sizeof(pbd->CDTrack.szName),        &pbd->cbt.cbTracks[2]);
}

STDMETHODIMP_(void) CCDData::BindMenus(HSTMT *hstmt, LPBOUND pbd)
{
    m_pSQL->BindCol(hstmt[2],  1, SQL_C_ULONG,  &(pbd->CDTitle.dwTitleID),    sizeof(pbd->CDTitle.dwTitleID),     &pbd->cbt.cbMenus[0]);
    m_pSQL->BindCol(hstmt[2],  2, SQL_C_ULONG,  &(pbd->dwMenuID),             sizeof(pbd->dwMenuID),              &pbd->cbt.cbMenus[1]);
    m_pSQL->BindCol(hstmt[2],  3, SQL_C_WCHAR,   pbd->CDMenu.szMenuText,       sizeof(pbd->CDMenu.szMenuText),     &pbd->cbt.cbMenus[2]);
    m_pSQL->BindCol(hstmt[2],  4, SQL_C_WCHAR,   pbd->szQuery,                 sizeof(pbd->szQuery),               &pbd->cbt.cbMenus[3]);
}

STDMETHODIMP_(void) CCDData::BindBatch(HSTMT *hstmt, LPBOUND pbd)
{
    m_pSQL->BindCol(hstmt[3],  1, SQL_C_ULONG,  &(pbd->CDTitle.dwTitleID),    sizeof(pbd->CDTitle.dwTitleID),     &pbd->cbt.cbBatch[0]);
    m_pSQL->BindCol(hstmt[3],  2, SQL_C_ULONG,  &(pbd->CDTitle.dwNumTracks),  sizeof(pbd->CDTitle.dwNumTracks),   &pbd->cbt.cbBatch[1]);
    m_pSQL->BindCol(hstmt[3],  3, SQL_C_WCHAR, pbd->szQuery,                 sizeof(pbd->szQuery),               &pbd->cbt.cbBatch[2]);
}


STDMETHODIMP_(void) CCDData::SetBindings(HSTMT *hstmt, LPBOUND pbd)
{
    BindTitles(hstmt,pbd);
    BindTracks(hstmt,pbd);
    BindMenus(hstmt,pbd);
    BindBatch(hstmt,pbd);
}


STDMETHODIMP_(void) CCDData::ReportError(LPBOUND pbd, HSTMT hstmt)
{
#ifdef DEBUG

    UCHAR state[255];
    SDWORD dwErr;
    UCHAR szErr[SQL_MAX_MESSAGE_LENGTH];
    SWORD cbErr;

    m_pSQL->Error(pbd->henv, pbd->hdbc, hstmt, state, &dwErr, szErr, SQL_MAX_MESSAGE_LENGTH, &cbErr);

    OutputDebugString((TCHAR *) szErr);

    if (szErr[0] != TEXT('\0'))
    {
        OutputDebugString(TEXT("\n"));
    }
#endif
}





STDMETHODIMP_(RETCODE) CCDData::AllocStmt(HDBC hdbc, HSTMT *hstmt)
{
    RETCODE rc = SQL_SUCCESS;
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
    {
        hstmt[dwIndex] = NULL;
    }

    for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
    {
        rc = m_pSQL->AllocStmt(hdbc, &hstmt[dwIndex]);

        if (rc != SQL_SUCCESS)
        {
            break;
        }
    }

    return(rc);
}

STDMETHODIMP_(void) CCDData::FreeStmt(HSTMT *hstmt)
{
    RETCODE rc = SQL_SUCCESS;
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
    {
        if (hstmt[dwIndex] != NULL)
        {
            m_pSQL->FreeStmt(hstmt[dwIndex], SQL_DROP);
            hstmt[dwIndex] = NULL;
        }
    }
}




STDMETHODIMP_(void) CCDData::CreateDatabase(void)
{
    HENV        henv;
    HDBC        hdbc;
    HSTMT       hstmt[NUMTABLES];
    TCHAR       szWinDir[MAX_PATH];
    TCHAR       szCreateAttr[MAX_PATH];
    TCHAR       szDSNAttr[MAX_PATH];

    if (GetAppDataDir(szWinDir, sizeof(szWinDir)/sizeof(TCHAR)) != 0)
    {
        wsprintf(szCreateAttr, gszDSNCreate, szWinDir, TEXT('\0'));
        wsprintf(szDSNAttr, gszDSNAttr, TEXT('\0'), szWinDir, TEXT('\0'), TEXT('\0'), TEXT('\0'));

        if (m_pSQL->ConfigDataSource(NULL, ODBC_ADD_DSN, gszDriverName, szCreateAttr))
        {
            if (m_pSQL->ConfigDataSource(NULL, ODBC_ADD_DSN, gszDriverName, szDSNAttr))
            {
                if (m_pSQL->AllocEnv(&henv) == SQL_SUCCESS)
                {
                    if (m_pSQL->AllocConnect(henv, &hdbc) == SQL_SUCCESS)
                    {
                        if (m_pSQL->Connect(hdbc, (UCHAR *) gszDSN, SQL_NTS, NULL, 0, NULL, 0) == SQL_SUCCESS)
                        {
                            if (AllocStmt(hdbc, hstmt) == SQL_SUCCESS)
                            {
                                InitDatabase(hstmt);
                            }
                            FreeStmt(hstmt);
                        }
                        m_pSQL->Disconnect(hdbc);
                    }
                    m_pSQL->FreeConnect(hdbc);
                }
                m_pSQL->FreeEnv(henv);
            }
        }
    }
}


STDMETHODIMP CCDData::CheckDatabase(HWND hWnd)
{
    HRESULT hr = S_OK;

    GetSQLPtr(FALSE);

    if (!m_pSQL)
    {
        if (!m_fToldUser)
        {
            TCHAR szTitle[255];
            TCHAR szCaption[255];
            LoadString(g_dllInst, IDS_ERROR_NO_ODBC, szTitle, sizeof(szTitle)/sizeof(TCHAR));
            LoadString(g_dllInst, IDS_ERROR_SETUP, szCaption, sizeof(szTitle)/sizeof(TCHAR));
            MessageBox(hWnd, szTitle, szCaption, MB_OK | MB_ICONEXCLAMATION);
            m_fToldUser = TRUE;
        }

        hr = E_FAIL;
    }

    return(hr);
}


//finds the dir that is correct for storing cd information
STDMETHODIMP_(DWORD) CCDData::GetAppDataDir(TCHAR* pstrDir, DWORD cchSize)
{
    DWORD dwRet = 0;

    TCHAR szDataDir[MAX_PATH];

    //get the allusers application folder
    if (SUCCEEDED(SHGetFolderPath(NULL,CSIDL_APPDATA,NULL,SHGFP_TYPE_CURRENT,pstrDir)))
    {
        if (PathAppend(pstrDir,TEXT("Microsoft\\CD Player")))
        {
            SHCreateDirectoryExW(NULL, pstrDir, NULL);

            //shorten the pathname, because ODBC can't handle spaces
            TCHAR szDir[MAX_PATH];
            _tcscpy(szDir,pstrDir);
            dwRet = GetShortPathName(szDir,pstrDir,cchSize);
        }
    }

    return (dwRet);
}

STDMETHODIMP CCDData::Initialize(HWND hWnd)
{
    TCHAR       *pEntries = NULL;
    HRESULT     hr = S_OK;
    DWORD       dwCount;
    UDWORD      row[NUMTABLES];
    UWORD       rgfRowStat[NUMTABLES][ROWSET];
    TCHAR       szWinDir[MAX_PATH];
    TCHAR       szCreateAttr[MAX_PATH];
    TIMEDMETER  tm;

    if (SUCCEEDED(GetSQLPtr(TRUE)))
    {
        if (GetAppDataDir(szWinDir, sizeof(szWinDir)/sizeof(TCHAR)) != 0)
        {
            wsprintf(szCreateAttr, gszDSNCreate, szWinDir, TEXT('\0'));

            if (m_pSQL->ConfigDataSource(NULL, ODBC_ADD_DSN, gszDriverName, szCreateAttr))  // If this fails, we assume we've already imported the file
            {
                hr = GetUnknownString(&pEntries, NULL, NULL, SECTION_BUFFER);

                if (SUCCEEDED(hr))
                {
                    dwCount = ImportCount(pEntries);

                    CreateMeter(&tm, hWnd, dwCount, 5,  IDS_IMPORTING);

                    OpenDatabase(TRUE,hWnd);

                    if (m_henv)
                    {
                        TCHAR    *szDiscID = pEntries;
                        DWORD   dwIndex;

                        memset(&m_bd, 0, sizeof(m_bd));
                        m_bd.henv = m_henv;
                        m_bd.hdbc = m_hdbc;

                        InitDatabase(m_hstmt);

                        InitCBTable(&m_bd);
                        SetCursors( m_hstmt );
                        SetBindings( m_hstmt, &m_bd);

                        m_pSQL->SetConnectOption(m_hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_OFF);

                        m_pSQL->ExecDirect(m_hstmt[0], (UCHAR *) TEXT("select * from Titles"), SQL_NTS);
                        m_pSQL->ExecDirect(m_hstmt[1], (UCHAR *) TEXT("select * from Tracks"), SQL_NTS);
                        m_pSQL->ExecDirect(m_hstmt[2], (UCHAR *) TEXT("select * from Menus"), SQL_NTS);

                        for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
                        {
                            m_pSQL->ExtendedFetch(m_hstmt[dwIndex], SQL_FETCH_FIRST, 1, &row[dwIndex], rgfRowStat[dwIndex]);
                        }

                        ImportDatabase(&tm, m_hstmt, szDiscID);

                        m_pSQL->Transact(SQL_NULL_HENV, m_hdbc, SQL_COMMIT);

                        for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
                        {
                            m_pSQL->FreeStmt(m_hstmt[dwIndex], SQL_CLOSE);
                        }

                        m_pSQL->ExecDirect(m_hstmt[0], (UCHAR *) TEXT("create index TitleIDx on Titles(TitleID)"), SQL_NTS);
                        m_pSQL->ExecDirect(m_hstmt[1], (UCHAR *) TEXT("create index TitleIDx on Tracks(TitleID)"), SQL_NTS);
                        m_pSQL->ExecDirect(m_hstmt[2], (UCHAR *) TEXT("create index TitleIDx on Menus(TitleID)"), SQL_NTS);

                        m_pSQL->Transact(SQL_NULL_HENV, m_hdbc, SQL_COMMIT);
                        m_pSQL->SetConnectOption(m_hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_ON);

                        CloseDatabase();
                    }

                    DestroyMeter(&tm);
                }

                if (pEntries)
                {
                    delete pEntries;
                }
            }

            hr = OpenDatabase(FALSE,hWnd);       // We either already have a database or we just created one, open it. (If we didn't import OpenDatabase will create new one
        }
    }

    return(hr);
}

STDMETHODIMP CCDData::ConnectToDatabase(WORD fRequest)
{
    HRESULT     hr = E_FAIL;
    TCHAR       szWinDir[MAX_PATH];
    TCHAR       szDSNAttr[MAX_PATH];

    if (GetAppDataDir(szWinDir, sizeof(szWinDir)/sizeof(TCHAR)) != 0)
    {
        wsprintf(szDSNAttr, gszDSNAttr, TEXT('\0'), szWinDir, TEXT('\0'), TEXT('\0'), TEXT('\0'));

        if (m_pSQL->ConfigDataSource(NULL, fRequest, gszDriverName, szDSNAttr))
        {
            if (m_pSQL->AllocEnv(&m_henv) == SQL_SUCCESS)
            {
                if (m_pSQL->AllocConnect(m_henv, &m_hdbc) == SQL_SUCCESS)
                {
                    if (m_pSQL->Connect(m_hdbc, (UCHAR *) gszDSN, SQL_NTS, NULL, 0, NULL, 0) == SQL_SUCCESS)
                    {
                        if (AllocStmt(m_hdbc, m_hstmt) == SQL_SUCCESS)
                        {
                            hr = S_OK;
                        }
                    }
                }
            }
        }
    }

    return(hr);
}


STDMETHODIMP CCDData::OpenDatabase(BOOL fCreate, HWND hWnd)
{
    HRESULT hr = E_FAIL;

    m_henv = NULL;
    m_hdbc = NULL;

    for (DWORD dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
    {
        m_hstmt[dwIndex] = NULL;
    }

    hr = ConnectToDatabase(ODBC_ADD_DSN);

    if (FAILED(hr))                 // Lets try creating the database
    {
        CreateDatabase();
        hr = ConnectToDatabase(ODBC_CONFIG_DSN);
    }
    else
    {
        //only do this if connection to database succeeded right off the bat,
        //because if we just created a new one, it is in the right format already.
        if (IsOldFormat())
        {
            hr = UpgradeDatabase(hWnd);
        }
    }

    if (FAILED(hr))
    {
        CloseDatabase();
    }

    return (hr);
}



STDMETHODIMP_(void) CCDData::CloseDatabase(void)
{
    if (m_pSQL)
    {
        FreeStmt(m_hstmt);

        if (m_hdbc)
        {
            m_pSQL->Disconnect(m_hdbc);
            m_pSQL->FreeConnect(m_hdbc);
        }

        if (m_henv)
        {
            m_pSQL->FreeEnv(m_henv);
        }
    }
}




STDMETHODIMP_(DWORD) CCDData::GetNumRows(UCHAR *szDSN)
{
    HSTMT hstmt;
    DWORD dwCount = 0;
    SWORD Type,Cardinality;
    SDWORD cbCardinality = 0, cbType = 0;
    RETCODE rc;

    if (m_pSQL->AllocStmt(m_hdbc, &hstmt) == SQL_SUCCESS)
    {
        if (m_pSQL->Statistics(hstmt, NULL, 0, NULL, 0, szDSN, SQL_NTS, SQL_INDEX_ALL, SQL_ENSURE) == SQL_SUCCESS)
        {
            rc = m_pSQL->BindCol(hstmt,  7, SQL_C_SSHORT,  &Type,        sizeof(Type),         &cbType);
            rc = m_pSQL->BindCol(hstmt, 11, SQL_C_SSHORT,  &Cardinality, sizeof(Cardinality),  &cbCardinality);

            if (rc != SQL_SUCCESS)
            {
                ReportError(&m_bd, hstmt);
            }

            while (rc == SQL_SUCCESS)
            {
                rc = m_pSQL->Fetch(hstmt);

                if (rc == SQL_SUCCESS)
                {
                    if (Type == SQL_TABLE_STAT)
                    {
                        dwCount = (DWORD) Cardinality;
                        break;
                    }
                }
            }
        }

        m_pSQL->FreeStmt(hstmt, SQL_DROP);
    }
    return(dwCount);
}






STDMETHODIMP CCDData::ExtractTitle(LPCDTITLE *ppCDTitle)
{
    HRESULT     hr;
    LPCDTITLE   pCDTitle = NULL;

    m_bd.CDTitle.fLoaded = FALSE;

    hr = NewTitle(&pCDTitle, m_bd.CDTitle.dwTitleID, m_bd.CDTitle.dwNumTracks, m_bd.CDTitle.dwNumMenus);

    if (SUCCEEDED(hr))
    {
        DWORD dwTrack = 0;
        DWORD dwMenu = 0;

        m_bd.CDTitle.pTrackTable = pCDTitle->pTrackTable;
        m_bd.CDTitle.pMenuTable = pCDTitle->pMenuTable;
        m_bd.CDTitle.pPlayList = pCDTitle->pPlayList;

        memcpy(pCDTitle,&m_bd.CDTitle,sizeof(m_bd.CDTitle));
        memset(&m_bd.CDTitle, 0, sizeof(m_bd.CDTitle));

        DWORD dwSize = lstrlen(m_bd.szQuery) + 1;

        if (dwSize)
        {
            pCDTitle->szTitleQuery = new(TCHAR[dwSize]);

            if (pCDTitle->szTitleQuery)
            {
                lstrcpy(pCDTitle->szTitleQuery, m_bd.szQuery);
            }
        }

        pCDTitle->dwNumPlay = lstrlen(m_bd.szPlayList) >> 1; // Null terminated, two digits per entry (two chars) thus divide by 2

        if (pCDTitle->dwNumPlay)
        {
            pCDTitle->dwNumPlay = min(pCDTitle->dwNumPlay, MAXNUMPLAY);

            pCDTitle->pPlayList = new(WORD[pCDTitle->dwNumPlay]);

            if (pCDTitle->pPlayList == NULL)
            {
                pCDTitle->dwNumPlay = 0;
            }
            else
            {
                TCHAR   *pText = m_bd.szPlayList;
                LPWORD  pNum = pCDTitle->pPlayList;
                DWORD   dwIndex = 0;
                TCHAR   szNum[3];
                int     iNum;

                szNum[2] = TEXT('\0');
                for (dwIndex = 0; dwIndex < pCDTitle->dwNumPlay; dwIndex++, pNum++)
                {
                    szNum[0] = *pText++;
                    szNum[1] = *pText++;
                    _stscanf(szNum, TEXT("%02x"), &iNum);
                    *pNum = (WORD) iNum;
                }
            }
        }
    }

    if (SUCCEEDED(hr) && ppCDTitle)
    {
        *ppCDTitle = pCDTitle;
    }
    else if (pCDTitle)
    {
        DestroyTitle(pCDTitle);
    }

    return(hr);
}


STDMETHODIMP_(LPCDTITLE) CCDData::FindTitle(LPCDTITLE pCDTitle, DWORD dwTitleID)
{
    while (pCDTitle)
    {
        if (pCDTitle->dwTitleID == dwTitleID)
        {
            break;
        }

        pCDTitle = pCDTitle->pNext;
    }

    return(pCDTitle);
}



STDMETHODIMP CCDData::ExtractTitles(LPCDTITLE *ppCDTitleList, HWND hWnd)
{
    HRESULT     hr = S_OK;
    LPCDTITLE   pCDTitle = NULL;;
    TIMEDMETER  tm;

    InitCBTable(&m_bd);
    SetCursors(m_hstmt);
    SetBindings(m_hstmt, &m_bd);

    if (ppCDTitleList == NULL || m_henv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        RETCODE rc;
        DWORD dwCount = GetNumRows((UCHAR *) gszTitleTable) + GetNumRows((UCHAR *) gszTrackTable) + GetNumRows((UCHAR *) gszMenuTable);

        CreateMeter(&tm, hWnd, dwCount, 100, 0);

        dwCount = 0;

        rc = m_pSQL->ExecDirect(m_hstmt[0], (UCHAR *) TEXT("select * from Titles"), SQL_NTS);

        if (rc == SQL_SUCCESS)
        {
            m_bd.szQuery[0] = TEXT('\0');

            while (m_pSQL->Fetch(m_hstmt[0]) == SQL_SUCCESS)
            {
                hr = ExtractTitle(&pCDTitle);

                if (SUCCEEDED(hr))
                {
                    AddTitle(ppCDTitleList, pCDTitle);
                    UpdateMeter(&tm);
                }

                m_bd.szQuery[0] = TEXT('\0');
            }

            if (*ppCDTitleList)
            {
                hr = S_OK;
            }

            m_pSQL->FreeStmt(m_hstmt[0], SQL_CLOSE);

            m_pSQL->ExecDirect(m_hstmt[1], (UCHAR *) TEXT("select * from Tracks"), SQL_NTS);
            pCDTitle = NULL;

            while (m_pSQL->Fetch(m_hstmt[1]) == SQL_SUCCESS)
            {
                if (pCDTitle == NULL || pCDTitle->dwTitleID != m_bd.CDTitle.dwTitleID)
                {
                    pCDTitle = FindTitle(*ppCDTitleList, m_bd.CDTitle.dwTitleID);
                }

                if (pCDTitle)
                {
                    if (m_bd.dwTrackID < pCDTitle->dwNumTracks)
                    {
                        memcpy(&(pCDTitle->pTrackTable[m_bd.dwTrackID]), &(m_bd.CDTrack), sizeof(m_bd.CDTrack));
                        UpdateMeter(&tm);
                    }
                }
            }

            m_pSQL->FreeStmt(m_hstmt[1], SQL_CLOSE);



            m_pSQL->ExecDirect(m_hstmt[2], (UCHAR *) TEXT("select * from Menus"), SQL_NTS);
            pCDTitle = NULL;
            m_bd.szQuery[0] = TEXT('\0');

            while (m_pSQL->Fetch(m_hstmt[2]) == SQL_SUCCESS)
            {
                if (pCDTitle == NULL || pCDTitle->dwTitleID != m_bd.CDTitle.dwTitleID)
                {
                    pCDTitle = FindTitle(*ppCDTitleList, m_bd.CDTitle.dwTitleID);
                }

                if (pCDTitle)
                {
                    if (m_bd.dwMenuID < pCDTitle->dwNumMenus)
                    {
                        LPCDMENU pCDMenu = &(pCDTitle->pMenuTable[m_bd.dwMenuID]);
                        TCHAR *szMenuQuery;

                        SetMenuQuery(pCDMenu, m_bd.szQuery);
                        szMenuQuery = pCDMenu->szMenuQuery;
                        memcpy(pCDMenu, &(m_bd.CDMenu), sizeof(m_bd.CDMenu));
                        pCDMenu->szMenuQuery = szMenuQuery;
                        m_bd.szQuery[0] = TEXT('\0');

                        UpdateMeter(&tm);
                    }
                }
            }

            m_pSQL->FreeStmt(m_hstmt[2], SQL_CLOSE);
        }

        DestroyMeter(&tm);
    }

    return(hr);
}



STDMETHODIMP CCDData::ExtractSingleTitle(LPCDTITLE *ppCDTitle, DWORD dwTitleID)
{
    HRESULT     hr = S_OK;
    LPCDTITLE   pCDTitle = NULL;;

    InitCBTable(&m_bd);
    SetCursors(m_hstmt);
    SetBindings( m_hstmt, &m_bd);

    if (ppCDTitle == NULL || m_henv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        RETCODE     rc;
        UCHAR       szQuery[MAX_PATH];

        wsprintf((TCHAR *) szQuery, TEXT("select * from Titles where TitleID = %d"), dwTitleID);
        rc = m_pSQL->ExecDirect(m_hstmt[0], szQuery, SQL_NTS);

        if (rc != SQL_SUCCESS)
        {
            hr = E_FAIL;
        }
        else
        {
            if (m_pSQL->Fetch(m_hstmt[0]) == SQL_SUCCESS)
            {
                hr = ExtractTitle(&pCDTitle);
            }
            else
            {
                hr = E_FAIL;
            }

            m_pSQL->FreeStmt(m_hstmt[0], SQL_CLOSE);

            if (SUCCEEDED(hr))
            {
                wsprintf((TCHAR *) szQuery, TEXT("select * from Tracks where TitleID = %d"), dwTitleID);
                m_pSQL->ExecDirect(m_hstmt[1], szQuery, SQL_NTS);

                while (m_pSQL->Fetch(m_hstmt[1]) == SQL_SUCCESS)
                {
                    if (m_bd.dwTrackID < pCDTitle->dwNumTracks)
                    {
                        memcpy(&(pCDTitle->pTrackTable[m_bd.dwTrackID]), &(m_bd.CDTrack), sizeof(m_bd.CDTrack));
                    }
                }

                m_pSQL->FreeStmt(m_hstmt[1], SQL_CLOSE);


                wsprintf((TCHAR *) szQuery, TEXT("select * from Menus where TitleID = %d"), dwTitleID);
                m_pSQL->ExecDirect(m_hstmt[2], szQuery, SQL_NTS);

                while (m_pSQL->Fetch(m_hstmt[2]) == SQL_SUCCESS)
                {
                    if (m_bd.dwMenuID < pCDTitle->dwNumMenus)
                    {
                        LPCDMENU pCDMenu = &(pCDTitle->pMenuTable[m_bd.dwMenuID]);
                        TCHAR *szMenuQuery;

                        SetMenuQuery(pCDMenu, m_bd.szQuery);
                        szMenuQuery = pCDMenu->szMenuQuery;
                        memcpy(pCDMenu, &(m_bd.CDMenu), sizeof(m_bd.CDMenu));
                        pCDMenu->szMenuQuery = szMenuQuery;
                        m_bd.szQuery[0] = TEXT('\0');
                    }
                }

                m_pSQL->FreeStmt(m_hstmt[2], SQL_CLOSE);
            }
        } //end else main query successful
    } //end else args ok

    if (SUCCEEDED(hr))
    {
        *ppCDTitle = pCDTitle;
    }

    return(hr);
}


STDMETHODIMP_(BOOL) CCDData::QueryDatabase(DWORD dwTitleID, const TCHAR *szTable)
{
    BOOL        fResult = FALSE;
    RETCODE     rc;
    UCHAR       szQuery[MAX_PATH];
    HSTMT       hstmt;

    if (m_pSQL->AllocStmt(m_hdbc, &hstmt) == SQL_SUCCESS)
    {
        wsprintf((TCHAR *) szQuery, TEXT("select * from %s where TitleID = %d"), szTable, dwTitleID);
        rc = m_pSQL->ExecDirect(hstmt, szQuery, SQL_NTS);

        if (rc == SQL_SUCCESS)
        {
            if (m_pSQL->Fetch(hstmt) == SQL_SUCCESS)
            {
                fResult = TRUE;
            }
        }

        m_pSQL->FreeStmt(hstmt, SQL_DROP);
    }

    return (fResult);
}




STDMETHODIMP_(BOOL) CCDData::QueryTitle(DWORD dwTitleID)
{
    BOOL fResult = FALSE;
    LPCDTITLE pCDTitle;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (m_pTitleList == NULL)       // Database Not in memory, just query database directly
        {
            fResult = QueryDatabase(dwTitleID, gszTitleTable);
        }
        else                            // Database is in memory, just look here.
        {
            pCDTitle = m_pTitleList;

            while (pCDTitle)
            {
                if (pCDTitle->dwTitleID == dwTitleID)
                {
                    if (!pCDTitle->fRemove)
                    {
                        fResult = TRUE;
                    }
                    break;
                }

                pCDTitle = pCDTitle->pNext;
            }
        }
    }

    Leave();

    return(fResult);
}


STDMETHODIMP CCDData::LockTitle(LPCDTITLE *ppCDTitle, DWORD dwTitleID)
{
    HRESULT hr = E_INVALIDARG;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (ppCDTitle)
        {
            if (m_pTitleList == NULL)       // Database Not in memory, load explicitly
            {
                if (SUCCEEDED(ExtractSingleTitle(ppCDTitle, dwTitleID)))
                {
                    (*ppCDTitle)->fLoaded = TRUE;
                    (*ppCDTitle)->dwLockCnt = 1;
                    hr = S_OK;
                }
            }
            else                            // Database is in memory, just look here.
            {
                LPCDTITLE pCDTitle;
                pCDTitle = m_pTitleList;

                while (pCDTitle)
                {
                    if (pCDTitle->dwTitleID == dwTitleID)
                    {
                        *ppCDTitle = pCDTitle;
                        pCDTitle->fLoaded = FALSE;
                        pCDTitle->dwLockCnt++;
                        hr = S_OK;
                        break;
                    }

                    pCDTitle = pCDTitle->pNext;
                }
            }
        }
    }

    Leave();

    return(hr);
}



STDMETHODIMP_(void) CCDData::UnlockTitle(LPCDTITLE pCDTitle, BOOL fPresist)
{
    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (pCDTitle)
        {
            if (fPresist)               // They either made a new one, or made changes
            {
                DBSaveTitle(pCDTitle);  // write it to database
            }

            if (pCDTitle->fLoaded)      // This was NOT pulled from our database (Either locked while we didn't have the database, or was created.
            {
                pCDTitle->dwLockCnt--;          // they are unlocking

                if (fPresist && m_dwLoadCnt)    // This is a new item, lets add it to load database
                {
                    AddTitle(&m_pTitleList, pCDTitle);    // Insert into the loaded databased
                }
                else if (pCDTitle->dwLockCnt == 0)  // Not being saved and not in database, so nuke it
                {
                    DestroyTitle(pCDTitle);
                }
            }
            else                         // This title was pulled from our database, so just dec the ref
            {
                pCDTitle->dwLockCnt--;
            }
        }
    }

    Leave();
}



INT_PTR CALLBACK CCDData::MeterHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fReturnVal = TRUE;
	    	
    switch (msg)
    {
    	default:
			fReturnVal = FALSE;
		break;
		
        case WM_INITDIALOG:
        {
			fReturnVal = TRUE;
        }		
		break;
    }

    return fReturnVal;
}




STDMETHODIMP CCDData::LoadTitles(HWND hWnd)
{
    HRESULT hr = E_FAIL;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        hr = S_OK;

        if (m_pTitleList == NULL)
        {
            hr = ExtractTitles(&m_pTitleList, hWnd);
        }

        if (SUCCEEDED(hr))
        {
            m_dwLoadCnt++;
        }
    }

    Leave();

    return(hr);
}


STDMETHODIMP CCDData::PersistTitles()
{
    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        SaveTitles(&m_pTitleList);
    }

    Leave();

    return S_OK;
}


STDMETHODIMP CCDData::UnloadTitles()
{
    HRESULT hr = E_FAIL;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (m_pTitleList)
        {
            m_dwLoadCnt--;

            if (m_dwLoadCnt == 0)
            {
                DestroyTitles(&m_pTitleList);
            }

            hr = S_OK;
        }
    }

    Leave();

    return(hr);
}

STDMETHODIMP CCDData::CreateTitle(LPCDTITLE *ppCDTitle, DWORD dwTitleID, DWORD dwNumTracks, DWORD dwNumMenus)
{
    HRESULT hr = E_FAIL;
    LPCDTITLE pCDTitle;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        hr = S_OK;

        if (!QueryTitle(dwTitleID))      // Only create a blank if it's not already in database
        {
			RemoveFromBatch(dwTitleID);

            hr = NewTitle(&pCDTitle, dwTitleID, dwNumTracks, dwNumMenus);
        }
        else
        {
            hr = LockTitle(&pCDTitle, dwTitleID);           // Let's get return the one we got

            if (SUCCEEDED(hr))                              // but first, re-fit it according to params
            {
                if (pCDTitle->dwNumTracks != dwNumTracks)
                {
                    if (pCDTitle->pTrackTable)
                    {
                        delete pCDTitle->pTrackTable;
                    }

                    pCDTitle->dwNumTracks = dwNumTracks;
                    pCDTitle->pTrackTable = new(CDTRACK[dwNumTracks]);

                    if (pCDTitle->pTrackTable == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if (SUCCEEDED(hr) && pCDTitle->dwNumMenus != dwNumMenus)
                {
                    if (pCDTitle->pMenuTable)
                    {
                        delete pCDTitle->pMenuTable;
                    }

                    pCDTitle->dwNumMenus = dwNumMenus;
                    pCDTitle->pMenuTable = new(CDMENU[dwNumMenus]);
                    ZeroMemory(pCDTitle->pMenuTable,sizeof(CDMENU)*dwNumMenus);

                    if (pCDTitle->pMenuTable == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if (FAILED(hr))
                {
                    DestroyTitle(pCDTitle);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            *ppCDTitle = pCDTitle;
        }
    }

    Leave();

    return(hr);
}




STDMETHODIMP CCDData::SetTitleQuery(LPCDTITLE pCDTitle, TCHAR *szTitleQuery)
{
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (pCDTitle && szTitleQuery && lstrlen(szTitleQuery) < INTERNET_MAX_PATH_LENGTH)
        {
            if (pCDTitle->szTitleQuery)
            {
                delete pCDTitle->szTitleQuery;
            }

            DWORD dwSize = lstrlen(szTitleQuery) + 1;

            pCDTitle->szTitleQuery = new(TCHAR[dwSize]);

            if (pCDTitle->szTitleQuery == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                lstrcpy(pCDTitle->szTitleQuery, szTitleQuery);
                hr = S_OK;
            }
        }
    }

    return(hr);
}


STDMETHODIMP CCDData::SetMenuQuery(LPCDMENU pCDMenu, TCHAR *szMenuQuery)
{
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (pCDMenu && szMenuQuery && lstrlen(szMenuQuery) < INTERNET_MAX_PATH_LENGTH)
        {
            if (pCDMenu->szMenuQuery)
            {
                delete pCDMenu->szMenuQuery;
            }

            DWORD dwSize = lstrlen(szMenuQuery) + 1;

            pCDMenu->szMenuQuery = new(TCHAR[dwSize]);

            if (pCDMenu->szMenuQuery== NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                lstrcpy(pCDMenu->szMenuQuery, szMenuQuery);
                hr = S_OK;
            }
        }
    }

    return(hr);
}



STDMETHODIMP CCDData::NewTitle(LPCDTITLE *ppCDTitle, DWORD dwTitleID, DWORD dwNumTracks, DWORD dwNumMenus)
{
    HRESULT hr = S_OK;

    if (ppCDTitle == NULL || dwTitleID == CDTITLE_NODISC || dwNumTracks == 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LPCDTITLE pCDTitle = new(CDTITLE);

        if (pCDTitle == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memset(pCDTitle, 0, sizeof(CDTITLE));

            pCDTitle->dwTitleID = dwTitleID;
            pCDTitle->dwNumTracks = dwNumTracks;
            pCDTitle->dwNumMenus = dwNumMenus;
            pCDTitle->fLoaded = TRUE;
            pCDTitle->dwLockCnt = 1;

            pCDTitle->pTrackTable = new(CDTRACK[dwNumTracks]);

            if (pCDTitle->pTrackTable == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                memset(pCDTitle->pTrackTable, 0, sizeof(CDTRACK) * dwNumTracks);

                if (dwNumMenus)
                {
                    pCDTitle->pMenuTable = new(CDMENU[dwNumMenus]);

                    if (pCDTitle->pMenuTable == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        memset(pCDTitle->pMenuTable, 0, sizeof(CDMENU) * dwNumMenus);
                    }
                }
            }

            if (FAILED(hr))
            {
                if (pCDTitle->pMenuTable)
                {
                    delete pCDTitle->pMenuTable;
                }

                if (pCDTitle->pTrackTable)
                {
                    delete pCDTitle->pTrackTable;
                }

                delete(pCDTitle);
            }
            else
            {
                *ppCDTitle = pCDTitle;
            }
        }
    }

    return(hr);
}




STDMETHODIMP_(void) CCDData::DestroyTitle(LPCDTITLE pCDTitle)
{
    if (pCDTitle)
    {
        if (pCDTitle->szTitleQuery)
        {
            delete pCDTitle->szTitleQuery;
        }

        if (pCDTitle->pTrackTable)
        {
            delete pCDTitle->pTrackTable;
        }

        if (pCDTitle->pPlayList)
        {
            delete pCDTitle->pPlayList;
        }

        if (pCDTitle->pMenuTable)
        {
            for (DWORD dwMenu = 0; dwMenu < pCDTitle->dwNumMenus; dwMenu++)
            {
                TCHAR *szMenuQuery = pCDTitle->pMenuTable[dwMenu].szMenuQuery;

                if (szMenuQuery)
                {
                    delete szMenuQuery;
                }
            }
            delete pCDTitle->pMenuTable;
        }
    }

    delete pCDTitle;
}



STDMETHODIMP_(void) CCDData::SaveTitle(LPCDTITLE pCDTitle, BOOL fExist)
{
    UCHAR       szQuery[MAX_PATH];
    UDWORD      row[NUMTABLES];
    UWORD       rgfRowStat[NUMTABLES][ROWSET];
    RETCODE     rc;

    if (fExist)
    {
        wsprintf((TCHAR *) szQuery, TEXT("select * from Titles where TitleID = %d"), pCDTitle->dwTitleID);
        rc = m_pSQL->ExecDirect(m_hstmt[0], szQuery, SQL_NTS);
        ReportError(&m_bd, m_hstmt[0]);
    }
    else
    {
        rc = m_pSQL->ExecDirect(m_hstmt[0], (UCHAR *) TEXT("select * from Titles"), SQL_NTS);
        ReportError(&m_bd, m_hstmt[0]);
    }

    rc = m_pSQL->ExtendedFetch(m_hstmt[0], SQL_FETCH_LAST, 1, &row[0], rgfRowStat[0]);
    ReportError(&m_bd, m_hstmt[0]);

    InitCBTable(&m_bd);
    memcpy(&m_bd.CDTitle, pCDTitle, sizeof(CDTITLE));

    if (pCDTitle->szTitleQuery)
    {
        lstrcpy(m_bd.szQuery, pCDTitle->szTitleQuery);
    }
    else
    {
        m_bd.szQuery[0] = TEXT('\0');
    }

    pCDTitle->dwNumPlay = min(pCDTitle->dwNumPlay, MAXNUMPLAY);

    m_bd.szPlayList[0] = TEXT('\0');

    if (pCDTitle->dwNumPlay && pCDTitle->pPlayList)
    {
        DWORD  dwIndex;
        TCHAR  *pDst = m_bd.szPlayList;
        LPWORD pNum = pCDTitle->pPlayList;

        for (dwIndex = 0; dwIndex < pCDTitle->dwNumPlay; dwIndex++, pNum++)
        {
            wsprintf(pDst, TEXT("%02x"), *pNum);

            while(*pDst != TEXT('\0'))
            {
                pDst++;
            }
        }
    }

    if (fExist)
    {
        rc = m_pSQL->SetPos(m_hstmt[0], 0, SQL_UPDATE, SQL_LOCK_NO_CHANGE);
       // ReportError(&m_bd, m_hstmt[0]);
    }
    else
    {
        rc = m_pSQL->SetPos(m_hstmt[0], 0, SQL_ADD, SQL_LOCK_NO_CHANGE);
       // ReportError(&m_bd, m_hstmt[0]);
    }
}



STDMETHODIMP_(void) CCDData::SaveTracks(LPCDTITLE pCDTitle, BOOL fExist)
{
    UCHAR       szQuery[MAX_PATH];
    UDWORD      row[NUMTABLES];
    UWORD       rgfRowStat[NUMTABLES][ROWSET];
    RETCODE     rc;
    DWORD       dwTrack;
    DWORD       dwTitleID = pCDTitle->dwTitleID;

    if (fExist)
    {
        wsprintf((TCHAR *) szQuery, TEXT("select * from Tracks where TitleID = %d"), pCDTitle->dwTitleID);
        rc = m_pSQL->ExecDirect(m_hstmt[1], szQuery, SQL_NTS);
        ReportError(&m_bd, m_hstmt[1]);
    }
    else
    {
        rc = m_pSQL->ExecDirect(m_hstmt[1], (UCHAR *) TEXT("select * from Tracks"), SQL_NTS);
        ReportError(&m_bd, m_hstmt[1]);
    }

    if (fExist)
    {
        rc = m_pSQL->ExtendedFetch(m_hstmt[1], SQL_FETCH_FIRST, 1, &row[0], rgfRowStat[0]);
        ReportError(&m_bd, m_hstmt[1]);

        for (dwTrack = 0; dwTrack < pCDTitle->dwNumTracks; dwTrack++)
        {
            InitCBTable(&m_bd);
            m_bd.CDTitle.dwTitleID = dwTitleID;

            if (m_bd.dwTrackID < pCDTitle->dwNumTracks)
            {
                memcpy(&m_bd.CDTrack, &(pCDTitle->pTrackTable[m_bd.dwTrackID]), sizeof(CDTRACK));
                rc = m_pSQL->SetPos(m_hstmt[1], 0, SQL_UPDATE, SQL_LOCK_NO_CHANGE);
                ReportError(&m_bd, m_hstmt[1]);
            }

            rc = m_pSQL->ExtendedFetch(m_hstmt[1], SQL_FETCH_NEXT, 1, &row[0], rgfRowStat[0]);
            ReportError(&m_bd, m_hstmt[1]);

        }
    }
    else
    {
        rc = m_pSQL->ExtendedFetch(m_hstmt[1], SQL_FETCH_LAST, 1, &row[0], rgfRowStat[0]);
        ReportError(&m_bd, m_hstmt[1]);

        InitCBTable(&m_bd);
        m_bd.CDTitle.dwTitleID = dwTitleID;

        for (dwTrack = 0; dwTrack < pCDTitle->dwNumTracks; dwTrack++)
        {
            m_bd.dwTrackID = dwTrack;
            memcpy(&m_bd.CDTrack, &(pCDTitle->pTrackTable[dwTrack]), sizeof(CDTRACK));
            rc = m_pSQL->SetPos(m_hstmt[1], 0, SQL_ADD, SQL_LOCK_NO_CHANGE);
            ReportError(&m_bd, m_hstmt[1]);
        }
    }
}


STDMETHODIMP_(void) CCDData::SaveMenus(LPCDTITLE pCDTitle)
{
    UCHAR       szQuery[MAX_PATH];
    UDWORD      row[NUMTABLES];
    UWORD       rgfRowStat[NUMTABLES][ROWSET];
    RETCODE     rc;
    DWORD       dwMenu;
    DWORD       dwTitleID = pCDTitle->dwTitleID;


    wsprintf((TCHAR *) szQuery, TEXT("delete from Menus where TitleID = %d"), pCDTitle->dwTitleID);
    rc = m_pSQL->ExecDirect(m_hstmt[2], szQuery, SQL_NTS);

    if (pCDTitle->dwNumMenus)
    {
        rc = m_pSQL->ExecDirect(m_hstmt[2], (UCHAR *) TEXT("select * from Menus"), SQL_NTS);
        ReportError(&m_bd, m_hstmt[2]);

        rc = m_pSQL->ExtendedFetch(m_hstmt[2], SQL_FETCH_LAST, 1, &row[0], rgfRowStat[0]);
        ReportError(&m_bd, m_hstmt[2]);

        InitCBTable(&m_bd);
        m_bd.CDTitle.dwTitleID = dwTitleID;

        for (dwMenu = 0; dwMenu < pCDTitle->dwNumMenus; dwMenu++)
        {
            LPCDMENU pCDMenu = &(pCDTitle->pMenuTable[dwMenu]);

            m_bd.dwMenuID = dwMenu;
            memcpy(&m_bd.CDMenu, pCDMenu, sizeof(CDMENU));
            m_bd.szQuery[0] = TEXT('\0');

            if (pCDMenu->szMenuQuery)
            {
                lstrcpy(m_bd.szQuery, pCDMenu->szMenuQuery);
            }

            rc = m_pSQL->SetPos(m_hstmt[2], 0, SQL_ADD, SQL_LOCK_NO_CHANGE);
            //ReportError(&m_bd, m_hstmt[2]);
        }
    }
}



STDMETHODIMP_(void) CCDData::DBSaveTitle(LPCDTITLE pCDTitle)
{
    if (pCDTitle)
    {
        RETCODE     rc;
        DWORD       dwIndex;

        BOOL fExist = QueryDatabase(pCDTitle->dwTitleID, gszTitleTable);

        InitCBTable(&m_bd);
        SetCursors( m_hstmt );
        SetBindings( m_hstmt, &m_bd);

        rc = m_pSQL->SetConnectOption(m_hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_OFF);
        ReportError(&m_bd, m_hstmt[0]);

        SaveTitle(pCDTitle, fExist);
        SaveTracks(pCDTitle, fExist);
        SaveMenus(pCDTitle);

        rc = m_pSQL->Transact(SQL_NULL_HENV, m_hdbc, SQL_COMMIT);
//        ReportError(&m_bd, m_hstmt[0]);

        rc = m_pSQL->SetConnectOption(m_hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_ON);
//        ReportError(&m_bd, m_hstmt[0]);

        for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
        {
            m_pSQL->FreeStmt(m_hstmt[dwIndex], SQL_CLOSE);
        }
    }
}



STDMETHODIMP_(void) CCDData::DBRemoveTitle(LPCDTITLE pCDTitle)
{
    if (pCDTitle && pCDTitle->dwTitleID != CDTITLE_NODISC)
    {
        RETCODE     rc;
        UCHAR       szQuery[MAX_PATH];
        HSTMT       hstmt;

        if (m_pSQL->AllocStmt(m_hdbc, &hstmt) == SQL_SUCCESS)
        {
            wsprintf((TCHAR *) szQuery, TEXT("delete from Titles where TitleID = %d"), pCDTitle->dwTitleID);
            rc = m_pSQL->ExecDirect(hstmt, szQuery, SQL_NTS);

            wsprintf((TCHAR *) szQuery, TEXT("delete from Tracks where TitleID = %d"), pCDTitle->dwTitleID);
            rc = m_pSQL->ExecDirect(hstmt, szQuery, SQL_NTS);

            wsprintf((TCHAR *) szQuery, TEXT("delete from Menus where TitleID = %d"), pCDTitle->dwTitleID);
            rc = m_pSQL->ExecDirect(hstmt, szQuery, SQL_NTS);

            m_pSQL->FreeStmt(hstmt, SQL_DROP);
        }
    }
}





STDMETHODIMP_(void) CCDData::DestroyTitles(LPCDTITLE *ppCDTitles)
{
    if (ppCDTitles && *ppCDTitles)
    {
        LPCDTITLE pNext;
        LPCDTITLE pCDTitle = *ppCDTitles;

        *ppCDTitles = NULL;

        pNext = pCDTitle;

        while (pCDTitle)
        {
            pNext = pCDTitle->pNext;

            if (pCDTitle->dwLockCnt)        // Someone locked a node that was in memory and have unloaded before unlocking
            {                               // We will abandon the node, it will be destroyed when they unlock it.
                pCDTitle->fLoaded = TRUE;
                pCDTitle->pNext = NULL;
            }
            else
            {
                DestroyTitle(pCDTitle);
            }

            pCDTitle = pNext;
        }
    }
}



STDMETHODIMP_(void) CCDData::SaveTitles(LPCDTITLE *ppCDTitles)
{
    if (ppCDTitles && *ppCDTitles)
    {
        LPCDTITLE pLast = NULL;
        LPCDTITLE pNext;
        LPCDTITLE pCDTitle = *ppCDTitles;

        pNext = pCDTitle;

        while (pCDTitle)
        {
            pNext = pCDTitle->pNext;

            if (pCDTitle->fRemove)
            {
                if (pCDTitle->dwTitleID != DWORD(-1))
                {
                    DBRemoveTitle(pCDTitle);
                }

                if (pLast == NULL)
                {
                    *ppCDTitles = pNext;
                }
                else
                {
                    pLast->pNext = pNext;
                }

                DestroyTitle(pCDTitle);
            }
            else
            {
                if (pCDTitle->fChanged)
                {
                    DBSaveTitle(pCDTitle);
                    pCDTitle->fChanged = FALSE;
                }

                pLast = pCDTitle;
            }

            pCDTitle = pNext;
        }
    }
}





STDMETHODIMP_(void) CCDData::AddTitle(LPCDTITLE *ppCDTitles, LPCDTITLE pCDNewTitle)
{
    if (ppCDTitles && pCDNewTitle)
    {
        if (*ppCDTitles == NULL)        // Inserting into empty list
        {
            *ppCDTitles = pCDNewTitle;
            pCDNewTitle->pNext = NULL;
        }
        else                            // Insertion sort based on artist name (for view by artist feature)
        {
            LPCDTITLE pCDTitle = *ppCDTitles;
            LPCDTITLE pLast = NULL;
            TCHAR *szArtist = pCDNewTitle->szArtist;

            while (pCDTitle)
            {
                if (lstrcmp(pCDTitle->szArtist, szArtist) >= 0) // we'll only sort by artist, the tree control will sort titles for us
                {
                    if (pLast == NULL)              // insert at head of list
                    {
                        pCDNewTitle->pNext = *ppCDTitles;
                        *ppCDTitles = pCDNewTitle;
                    }
                    else
                    {
                        pCDNewTitle->pNext = pCDTitle;
                        pLast->pNext = pCDNewTitle;
                    }

                    break;
                }

                if (pCDTitle->pNext == NULL)        // Insert on end of list
                {
                    pCDTitle->pNext = pCDNewTitle;
                    pCDNewTitle->pNext = NULL;
                    break;
                }

                pLast = pCDTitle;
                pCDTitle = pCDTitle->pNext;
            }
        }
    }
}


STDMETHODIMP_(LPCDTITLE) CCDData::GetTitleList(void)
{
    LPCDTITLE pCDTitle;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        pCDTitle = m_pTitleList;
    }

    Leave();

    return(pCDTitle);
}




STDMETHODIMP_(DWORD) CCDData::GetNumBatched(void)
{
    DWORD dwCount = 0;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (m_pBatchList == NULL)       // Batch Not in memory, just query Batch database directly
        {
            dwCount = GetNumRows((UCHAR *) gszBatchTable);
        }
        else
        {
            LPCDBATCH pCDBatch = m_pBatchList;

            while (pCDBatch)
            {
                if (!pCDBatch->fRemove)
                {
                    dwCount++;
                }

                pCDBatch = pCDBatch->pNext;
            }
        }
    }

    Leave();

    return(dwCount);
}




STDMETHODIMP_(BOOL) CCDData::FindBatchTitle(LPCDBATCH pCDBatchList, DWORD dwTitleID)
{
    BOOL        fFound = FALSE;
    LPCDBATCH   pCDBatch = pCDBatchList;

    while (pCDBatch)
    {
        if (pCDBatch->dwTitleID == dwTitleID)
        {
            if (!pCDBatch->fRemove)
            {
                fFound = TRUE;
            }

            break;
        }

        pCDBatch = pCDBatch->pNext;
    }

    return(fFound);
}



STDMETHODIMP_(BOOL) CCDData::QueryBatch(DWORD dwTitleID)
{
    BOOL        fFound = FALSE;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (m_pBatchList == NULL)       // Batch Not in memory, just query Batch database directly
        {
            fFound = QueryDatabase(dwTitleID, gszBatchTable);
        }
        else                            // Batch is in memory, just look here.
        {
            fFound = FindBatchTitle(m_pBatchList, dwTitleID);
        }
    }

    Leave();

    return(fFound);
}


STDMETHODIMP CCDData::ExtractBatch(LPCDBATCH *ppCDBatchList, HWND hWnd)
{
    HRESULT     hr = E_FAIL;
    LPCDBATCH   pCDBatch= NULL;
    TIMEDMETER  tm;

    InitCBTable(&m_bd);
    SetCursors(m_hstmt);
    SetBindings(m_hstmt, &m_bd);

    if (ppCDBatchList == NULL || m_henv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        RETCODE rc;
        DWORD dwCount = GetNumRows((UCHAR *) gszBatchTable);

        CreateMeter(&tm, hWnd, dwCount, 100, 0);

        dwCount = 0;

        rc = m_pSQL->ExecDirect(m_hstmt[3], (UCHAR *) TEXT("select * from Batch"), SQL_NTS);

        if (rc == SQL_SUCCESS)
        {
            m_bd.szQuery[0] = TEXT('\0');

            while (m_pSQL->Fetch(m_hstmt[3]) == SQL_SUCCESS)
            {
                pCDBatch = new CDBATCH;

                if (pCDBatch == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
                else
                {
                    DWORD dwSize = lstrlen(m_bd.szQuery) + 1;

                    pCDBatch->szTitleQuery = new(TCHAR[dwSize]);

                    if (pCDBatch->szTitleQuery == NULL)
                    {
                        delete pCDBatch;
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    else
                    {
                        lstrcpy(pCDBatch->szTitleQuery, m_bd.szQuery);
                        pCDBatch->dwTitleID = m_bd.CDTitle.dwTitleID;
                        pCDBatch->dwNumTracks = m_bd.CDTitle.dwNumTracks;
                        pCDBatch->fRemove = FALSE;
                        pCDBatch->fFresh = TRUE;
                        pCDBatch->pNext = *ppCDBatchList;
                        *ppCDBatchList = pCDBatch;

                        m_bd.szQuery[0] = TEXT('\0');
                        UpdateMeter(&tm);
                        hr = S_OK;
                    }
                }
            }

            m_pSQL->FreeStmt(m_hstmt[3], SQL_CLOSE);
        }

        DestroyMeter(&tm);
    }

    return(hr);
}








STDMETHODIMP CCDData::LoadBatch(HWND hWnd, LPCDBATCH *ppCDBatchList)
{
    HRESULT hr = E_FAIL;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (ppCDBatchList)
        {
            if (m_pBatchList == NULL)
            {
                hr = ExtractBatch(&m_pBatchList, hWnd);

                if (SUCCEEDED(hr))
                {
                    m_dwBatchCnt++;
                    *ppCDBatchList = m_pBatchList;
                }
            }
        }
    }

    Leave();

    return(hr);
}





STDMETHODIMP_(void) CCDData::DeleteBatch(LPCDBATCH pCDBatch)
{
    RETCODE     rc;
    UCHAR       szQuery[MAX_PATH];
    HSTMT       hstmt;

    if (pCDBatch->fRemove)
    {
        if (m_pSQL->AllocStmt(m_hdbc, &hstmt) == SQL_SUCCESS)
        {
            wsprintf((TCHAR *) szQuery, TEXT("delete from Batch where TitleID = %d"), pCDBatch->dwTitleID);
            rc = m_pSQL->ExecDirect(hstmt, szQuery, SQL_NTS);

            m_pSQL->FreeStmt(hstmt, SQL_DROP);
        }
    }

    if (pCDBatch->szTitleQuery)
    {
        delete pCDBatch->szTitleQuery;
    }

    delete pCDBatch;
}






STDMETHODIMP_(void) CCDData::DestroyBatch(LPCDBATCH *ppCDBatchList)
{
    if (ppCDBatchList && *ppCDBatchList)
    {
        LPCDBATCH pNext;
        LPCDBATCH pCDBatch = *ppCDBatchList;

        *ppCDBatchList = NULL;

        while (pCDBatch)
        {
            pNext = pCDBatch->pNext;
            DeleteBatch(pCDBatch);
            pCDBatch = pNext;
        }
    }
}




STDMETHODIMP CCDData::UnloadBatch(LPCDBATCH pCDBatchList)
{
    HRESULT hr = E_FAIL;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (pCDBatchList == m_pBatchList && m_dwBatchCnt)
        {
            m_dwBatchCnt--;

            if (m_dwBatchCnt == 0)
            {
                DestroyBatch(&m_pBatchList);
            }

            hr = S_OK;
        }
    }

    Leave();

    return(hr);
}







STDMETHODIMP CCDData::DumpBatch(void)
{
    HRESULT hr = E_FAIL;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (m_dwBatchCnt == 0)
        {
            HSTMT       hstmt;

            if (m_pSQL->AllocStmt(m_hdbc, &hstmt) == SQL_SUCCESS)
            {
                m_pSQL->ExecDirect(hstmt, (UCHAR *) TEXT("drop table Batch"), SQL_NTS);
                m_pSQL->ExecDirect(hstmt, (UCHAR *) gszBatchCreate, SQL_NTS);
                m_pSQL->FreeStmt(hstmt, SQL_CLOSE);

                m_pSQL->FreeStmt(hstmt, SQL_DROP);

                hr = S_OK;
            }
        }
    }

    Leave();

    return (hr);
}


STDMETHODIMP_(void) CCDData::RemoveFromBatch(DWORD dwTitleID)
{
    if (QueryBatch(dwTitleID))
    {
        if (m_pBatchList)
        {
            LPCDBATCH pBatch = m_pBatchList;

            while(pBatch)
            {
                if (pBatch->dwTitleID == dwTitleID)
                {
                    pBatch->fRemove = TRUE;
                    break;
                }

                pBatch = pBatch->pNext;
            }
        }
        else
        {
            RETCODE     rc;
            UCHAR       szQuery[MAX_PATH];
            HSTMT       hstmt;

            if (m_pSQL->AllocStmt(m_hdbc, &hstmt) == SQL_SUCCESS)
            {
                wsprintf((TCHAR *) szQuery, TEXT("delete from Batch where TitleID = %d"), dwTitleID);
                rc = m_pSQL->ExecDirect(hstmt, szQuery, SQL_NTS);

                m_pSQL->FreeStmt(hstmt, SQL_DROP);
            }
        }
    }
}



STDMETHODIMP CCDData::AddToBatch(DWORD dwTitleID, TCHAR *szTitleQuery, DWORD dwNumTracks)
{
    HRESULT hr = E_FAIL;

    Enter();

    if (SUCCEEDED(GetSQLPtr(FALSE)))
    {
        if (!QueryBatch(dwTitleID) && szTitleQuery && (UINT)lstrlen(szTitleQuery) < (sizeof(m_bd.szQuery)/sizeof(TCHAR)))
        {
            RETCODE     rc;
            DWORD       dwIndex;
            UDWORD      row;
            UWORD       rgfRowStat[ROWSET];

            InitCBTable(&m_bd);
            SetCursors( m_hstmt );
            SetBindings( m_hstmt, &m_bd);

            m_pSQL->SetConnectOption(m_hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_OFF);

            rc = m_pSQL->ExecDirect(m_hstmt[3], (UCHAR *) TEXT("select * from Batch"), SQL_NTS);
            ReportError(&m_bd, m_hstmt[3]);

            rc = m_pSQL->ExtendedFetch(m_hstmt[3], SQL_FETCH_LAST, 1, &row, rgfRowStat);
            ReportError(&m_bd, m_hstmt[3]);

            InitCBTable(&m_bd);
            m_bd.CDTitle.dwTitleID = dwTitleID;
            m_bd.CDTitle.dwNumTracks = dwNumTracks;

            lstrcpy(m_bd.szQuery, szTitleQuery);

            rc = m_pSQL->SetPos(m_hstmt[3], 0, SQL_ADD, SQL_LOCK_NO_CHANGE);
 //           ReportError(&m_bd, m_hstmt[3]);

            rc = m_pSQL->Transact(SQL_NULL_HENV, m_hdbc, SQL_COMMIT);
//            ReportError(&m_bd, m_hstmt[3]);

            m_pSQL->SetConnectOption(m_hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_ON);

            for (dwIndex = 0; dwIndex < NUMTABLES; dwIndex++)
            {
                m_pSQL->FreeStmt(m_hstmt[dwIndex], SQL_CLOSE);
            }

            hr = S_OK;
        }
    }

    Leave();

    return(hr);
}

STDMETHODIMP_(BOOL) CCDData::IsOldFormat()
{
    BOOL fResult = FALSE;
    TCHAR szName[MAX_PATH];
    SQLSMALLINT nName;
    SQLSMALLINT sqlType;
    SQLUINTEGER dwColDef;
    SQLSMALLINT ibScale;
    SQLSMALLINT fNullable;

    RETCODE rc = SQL_SUCCESS;

    rc = m_pSQL->ExecDirect(m_hstmt[0], (UCHAR *) TEXT("select * from Titles"), SQL_NTS);

    if (SQL_SUCCEEDED(rc))
    {
        //check "artist" and "titlequery" columns to find out if this is an old-format db.
        //if either is the old type, then this is an old-format db
        rc = m_pSQL->DescribeCol(m_hstmt[0], 2, (UCHAR*)(&szName), sizeof(szName), &nName, &sqlType, &dwColDef, &ibScale, &fNullable);
        if (SQL_SUCCEEDED(rc))
        {
            if (sqlType != SQL_LONGCHAR_FIELD)
            {
                fResult = TRUE;
            }
        }

        rc = m_pSQL->DescribeCol(m_hstmt[0], 10, (UCHAR*)(&szName), sizeof(szName), &nName, &sqlType, &dwColDef, &ibScale, &fNullable);
        if (SQL_SUCCEEDED(rc))
        {
            if (sqlType == SQL_C_BINARY)
            {
                fResult = TRUE;
            }
        }
    }

    m_pSQL->FreeStmt(m_hstmt[0],SQL_CLOSE);

    return (fResult);
}

//helper function to convert ascii hex to unicode chars
void TranslateToUnicode(TCHAR* pszTrans)
{
    TCHAR* pszTrans2 = pszTrans;
    int nLen = _tcslen(pszTrans);
    int x = 0;

    while (!((pszTrans2[0] == TEXT('0')) && (pszTrans2[1] == TEXT('0'))))
    {
        TCHAR CH;
        CH = ( pszTrans2 [0] >= TEXT('A') ? ( ( pszTrans2 [0] & 0xDF ) - TEXT('A') ) + 10 :
        ( pszTrans2 [0] - TEXT('0') ) );
        CH *= 16;
        CH += ( pszTrans2 [1] >= TEXT('A') ? ( ( pszTrans2 [1] & 0xDF ) - TEXT('A') ) + 10 :
        ( pszTrans2 [1] - TEXT('0') ) );

        pszTrans[x++] = CH;
        pszTrans2 += 2;

        //get out of the loop if we're at the end of the buffer's length
        if (x >= nLen)
        {
            break;
        }
    }

    pszTrans[x] = 0;
}

STDMETHODIMP CCDData::UpgradeDatabase(HWND hWnd)
{
    HRESULT hr = S_OK;
    HSTMT hstmt = NULL;
    TIMEDMETER tm;

    DWORD dwCount =   GetNumRows((UCHAR *) gszTitleTable)
                    + GetNumRows((UCHAR *) gszBatchTable);

    //steps:
    //1. Read values from old version of database
    //2. Delete the original database
    //3. Create new database with correct data types
    //4. Put data into new database
    //5. Clean up

    //Step 1: Read values from old version of database
    LPCDBATCH pBatchList = NULL;
    LoadTitles(hWnd); //(also gets tracks and menus)
    LoadBatch(hWnd,&pBatchList);

    //need to copy the batch list to ensure that it isn't already in cached in memory,
    //and therefore rejected by the "AddToBatch" call
    LPCDBATCH pBatchHead = NULL;
    LPCDBATCH pBatchTail = NULL;
    LPCDBATCH pBatch = pBatchList;

    while (pBatch)
    {
        LPCDBATCH pNewBatch = new CDBATCH;
        if (!pNewBatch)
            return E_OUTOFMEMORY;
        memcpy(pNewBatch,pBatch,sizeof(CDBATCH));
        pNewBatch->szTitleQuery = new TCHAR[lstrlen(pBatch->szTitleQuery)+1];
        if (!(pNewBatch->szTitleQuery))
            return E_OUTOFMEMORY;
        _tcscpy(pNewBatch->szTitleQuery,pBatch->szTitleQuery);

        if (!pBatchHead)
        {
            pBatchHead = pNewBatch;
            pBatchTail = pNewBatch;
        }
        else
        {
            pBatchTail->pNext = pNewBatch;
            pBatchTail = pNewBatch;
        }

        pNewBatch->pNext = NULL;

        pBatch = pBatch->pNext;
    }

    UnloadBatch(pBatchList);

    //Step 2: Delete the original database
    CloseDatabase();

    TCHAR szFileName[MAX_PATH];
    GetAppDataDir(szFileName,sizeof(szFileName)/sizeof(TCHAR));
    _tcscat(szFileName,TEXT("\\DeluxeCD.MDB"));

    DeleteFile(szFileName);

    //Step 3: Create new database with correct data types
    CreateDatabase();
    ConnectToDatabase(ODBC_CONFIG_DSN);

    //Step 4: Put data into new database
    CreateMeter(&tm, hWnd, dwCount, 5,  IDS_IMPORTING);

    //put all the titles into the new db
    LPCDTITLE pCDTitle = m_pTitleList;
    while (pCDTitle)
    {
        TranslateToUnicode(pCDTitle->szTitleQuery);

        for (DWORD x = 0; x < pCDTitle->dwNumMenus; x++)
        {
            TranslateToUnicode(pCDTitle->pMenuTable[x].szMenuQuery);
        }

        DBSaveTitle(pCDTitle);
        UpdateMeter(&tm);
        pCDTitle = pCDTitle->pNext;
    }

    //put all the batches into the new db
    pBatch = pBatchHead;
    while (pBatch)
    {
        TranslateToUnicode(pBatch->szTitleQuery);
        AddToBatch(pBatch->dwTitleID,pBatch->szTitleQuery,pBatch->dwNumTracks);
        pBatch->fRemove = FALSE;
        UpdateMeter(&tm);

        LPCDBATCH pBatchToDelete = pBatch;

        pBatch = pBatch->pNext;

        delete pBatchToDelete->szTitleQuery;
        delete pBatchToDelete;
    }

    //Step 5: Clean up
    DestroyMeter(&tm);

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\cdoptimp.h ===
/******************************Module*Header*******************************\
* Module Name: cdoptimp.h
*
* Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#if !defined(CDOPT_COM_IMPLEMENTATION)
#define CDOPT_COM_IMPLEMENTATION

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include "cdopt.h"
#include <windows.h>
#include <windowsx.h>
#include <wincrypt.h>
#include "..\cdnet\cdnet.h"


/////////////////////////////////////////////////////////////////////////////
// Internal Defines

#define CDINFO_NOEDIT       (0x0000)
#define CDINFO_EDIT         (0x0001)
#define CDINFO_TRACK        (CDINFO_EDIT | 0x0010)
#define CDINFO_TITLE        (CDINFO_EDIT | 0x0020)
#define CDINFO_ARTIST       (CDINFO_EDIT | 0x0040)
#define CDINFO_DISC         (CDINFO_NOEDIT | 0x0020)
#define CDINFO_ALBUMS       (CDINFO_NOEDIT | 0x0080)
#define CDINFO_DRIVES       (CDINFO_NOEDIT | 0x0100)
#define CDINFO_LABEL        (CDINFO_NOEDIT | 0x0200)
#define CDINFO_CDROM        (CDINFO_NOEDIT | 0x0400)
#define CDINFO_OTHER        (CDINFO_NOEDIT | 0x0800)

#define DG_BEGINDRAG    (LB_MSGMAX+100)
#define DG_DRAGGING     (LB_MSGMAX+101)
#define DG_DROPPED      (LB_MSGMAX+102)
#define DG_CANCELDRAG   (LB_MSGMAX+103)
#define DG_CURSORSET    0
#define DG_MOVE         0
#define DG_COPY         1

#define SJE_DRAGLISTMSGSTRING "sje_DragMultiListMsg"
#define TRACK_TITLE_LENGTH 255


/////////////////////////////////////////////////////////////////////////////
// Internal Structures

typedef struct DRAGMULTILISTINFO
{
    UINT    uNotification;
    HWND    hWnd;
    POINT   ptCursor;
    DWORD   dwState;

} DRAGMULTILISTINFO, *LPDRAGMULTILISTINFO;

typedef struct LIST_INFO
{
    int      index;
    UINT_PTR dwData;
    TCHAR    chName[TRACK_TITLE_LENGTH];

} LIST_INFO, *LPLIST_INFO;


typedef struct CDTREEINFO
{
    LPCDTITLE   pCDTitle;
    DWORD       dwTrack;
    DWORD       fdwType;
    LPCDUNIT    pCDUnit;

} CDTREEINFO, *LPCDTREEINFO;

typedef struct CDCONTROL        // UI Tree node for Controls
{
    TCHAR           szName[MIXER_LONG_NAME_CHARS];
    DWORD           dwVolID;
    DWORD           dwMuteID;
    CDCONTROL       *pNext;

} CDCONTROL, *LPCDCONTROL;


typedef struct CDMIXER          // UI Tree node for mixers
{
    DWORD           dwMixID;
    TCHAR           szPname[MAXPNAMELEN];
    CDMIXER         *pNext;
    LPCDCONTROL     pControlList;
    LPCDCONTROL     pCurrentControl;
    LPCDCONTROL     pOriginalControl;
    LPCDCONTROL     pDefaultControl;

} CDMIXER, *LPCDMIXER;


typedef struct CDDRIVE          // UI Tree node for CD players
{
    TCHAR           szDriveName[MAX_PATH];
    TCHAR           szDeviceDesc[MAX_PATH];
    CDDRIVE         *pNext;
    LPCDMIXER       pMixerList;
    LPCDMIXER       pCurrentMixer;
    LPCDMIXER       pOriginalMixer;
    BOOL            fSelected;

} CDDRIVE, *LPCDDRIVE;

typedef struct CDKEY
{
    HCRYPTPROV      hProv;
    HCRYPTKEY       hKey;
    HCRYPTHASH      hHash;

} CDKEY, *LPCDKEY;


/////////////////////////////////////////////////////////////////////////////
// CCDOpt

class CCDOpt : public ICDOpt
{
public:
    CCDOpt();
    ~CCDOpt();

public:
// IUnknown
    STDMETHOD (QueryInterface)              (REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)                (void);
    STDMETHOD_(ULONG,Release)               (void);

// ICDOpt
    STDMETHOD_(LPCDOPTIONS, GetCDOpts)      (void);
    STDMETHOD (CreateProviderList)          (LPCDPROVIDER *ppProviderList);
    STDMETHOD_(void,DestroyProviderList)    (LPCDPROVIDER *ppProviderList);
    STDMETHOD_(void,UpdateRegistry)         (void);
    STDMETHOD (OptionsDialog)               (HWND hWnd, LPCDDATA pCDData, CDOPT_PAGE nStartPage);
    STDMETHOD_(BOOL,VerifyProvider)         (LPCDPROVIDER pCDProvider, TCHAR *szCertKey);
    STDMETHOD (CreateProviderKey)           (LPCDPROVIDER pCDProvider, TCHAR *szCertKey, UINT cBytes);
    STDMETHOD_(void,DownLoadCompletion)     (DWORD dwNumIDs, LPDWORD pdwIDs);
    STDMETHOD_(void,DiscChanged)            (LPCDUNIT pCDUnit);
    STDMETHOD_(void,MMDeviceChanged)        (void);

private:
    DWORD           m_dwRef;
    HINSTANCE       m_hInst;                // hInstance of caller
    LPCDOPTIONS     m_pCDOpts;              // Original Opts from reg
    LPCDOPTIONS     m_pCDCopy;              // Current Working copy while UI is up.
    LPCDDATA        m_pCDData;              // Reference to CD Database Object
    LPCDDRIVE       m_pCDTree;              // Internal tree for CD/Mixer/Control Tree (Control line picker dialog)
    LPCDDRIVE       m_pCDSelected;          // Stores originally selected drive
    HIMAGELIST      m_hImageList;           // List of icon's for treeview of titles
    LPCDTITLE       m_pCDTitle;             // Used by Title Editor Dialog
    LPCDTITLE       m_pCDUploadTitle;       // Used to upload a title to net
    LRESULT         m_dwTrack;
    HWND            m_hList;
    WNDPROC         m_pfnSubProc;           // Used to subclass the Tree control
    BOOL            m_fEditReturn;          // True if user ended edit with a return in treeview
    BOOL            m_fVolChanged;          // True if there has been a change to the volume configuration
    BOOL            m_fAlbumsExpanded;      // True if database is expanded in tree
    BOOL            m_fDrivesExpanded;      // True if drivelist is expanded in tree
    HWND            m_hTitleWnd;            // Title Options dialog hwnd

    HDC             m_hdcMem;               // Temporary hdc used to draw the track bitmap.
    HBITMAP         m_hbmTrack;             // HBITMAP to be displayed beside the tracks
    UINT            m_DragMessage;          // Message ID of drag drop interface
    HCURSOR         m_hCursorDrop;          // Drops allowed cursor
    HCURSOR         m_hCursorNoDrop;        // Drops not allowed cursor
    HCURSOR         m_hCursorDropCpy;       // Drop copies the selection
    UINT            m_uDragListMsg;
    ICDNet *        m_pICDNet;              // Pointer to internet object for uploading title info

    static WNDPROC  s_fpCbEditProcOrg;
    bool            m_fDelayUpdate;

    // playopts.cpp
    static INT_PTR CALLBACK PlayerOptionsProc  (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK PlayListsProc      (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK TitleOptionsProc   (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK ListEditorProc     (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK MixerConfigProc    (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK SubProc         (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK DragListProc    (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK UploadProc         (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK ConfirmProc        (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK CbEditProc      (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    STDMETHOD_(INT_PTR,PlayerOptions)          (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHOD_(INT_PTR,PlayLists)              (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHOD_(INT_PTR,TitleOptions)           (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

    STDMETHOD_(void,OrderProviders)         (LPCDPROVIDER *ppProviderList, LPCDPROVIDER pCurrentProvider);
    STDMETHOD_(void,ApplyCurrentSettings)   (void);
    STDMETHOD_(void,ToggleApplyButton)      (HWND hDlg);
    STDMETHOD (AcquireKey)                  (LPCDKEY pCDKey, char *szName);
    STDMETHOD_(void,ReleaseKey)             (LPCDKEY pCDKey);
    STDMETHOD (CreateCertString)            (LPCDPROVIDER pCDProvider, TCHAR *szCertStr);


    STDMETHOD_(void,RegGetByte)             (HKEY hKey, const TCHAR *szKey, LPBYTE pByte, BYTE bDefault);
    STDMETHOD_(void,RegGetDWORD)            (HKEY hKey, const TCHAR *szKey, LPDWORD pdwData, DWORD dwDefault);
    STDMETHOD_(void,RegSetByte)             (HKEY hKey, const TCHAR *szKey, BYTE bData);
    STDMETHOD_(void,RegSetDWORD)            (HKEY hKey, const TCHAR *szKey, DWORD dwData);

    STDMETHOD_(BOOL,GetUploadPrompt)        (void);
    STDMETHOD_(void,SetUploadPrompt)        (BOOL fConfirmUpload);

    STDMETHOD (GetCDData)                   (LPCDOPTDATA pCDData);
    STDMETHOD (SetCDData)                   (LPCDOPTDATA pCDData);

    STDMETHOD_(void,GetCurrentProviderURL)  (TCHAR *szProviderURL);
    STDMETHOD (GetProviderData)             (LPCDOPTIONS pCDOpts);
    STDMETHOD (SetProviderData)             (LPCDOPTIONS pCDOpts);

    STDMETHOD (CopyOptions)                 (void);
    STDMETHOD_(void,DumpOptionsCopy)        (void);
    STDMETHOD_(void,DestroyCDOptions)       (void);
    STDMETHOD_(BOOL,OptionsChanged)         (LPCDOPTIONS pCDOpts);

    STDMETHOD_(void,UsePlayerDefaults)      (HWND hDlg);
    STDMETHOD_(BOOL,InitPlayerOptions)      (HWND hDlg);
    STDMETHOD_(void,SetIntroTime)           (HWND hDlg);

    STDMETHOD_(void,ToggleInternetDownload) (HWND hDlg);
    STDMETHOD_(BOOL,InitTitleOptions)       (HWND hDlg);
    STDMETHOD_(void,RestoreTitleDefaults)   (HWND hDlg);
    STDMETHOD_(void,ChangeCDProvider)       (HWND hDlg);
    STDMETHOD_(void,DownloadNow)            (HWND hDlg);
    STDMETHOD_(void,UpdateBatched)          (HWND hDlg);

    // playlist.cpp

    STDMETHOD_(HTREEITEM,AddNameToTree)     (HWND hDlg, LPCDUNIT pCDUnit, TCHAR *szName, HTREEITEM hParent, HTREEITEM hInsertAfter, LPCDTITLE pCDTitle, DWORD fdwType, DWORD dwTrack, DWORD dwImage);
    STDMETHOD_(void,AddTracksToTree)        (HWND hDlg, LPCDTITLE pCDTitle, HTREEITEM parent);
    STDMETHOD_(void,UpdateTitleTree)        (HWND hDlg, LPCDDATA pCDData);
    STDMETHOD_(void,AddTitleByCD)           (HWND hDlg);
    STDMETHOD_(void,ToggleByArtist)         (HWND hDlg, LPCDDATA pCDData);
    STDMETHOD_(BOOL,InitPlayLists)          (HWND hDlg, LPCDDATA pCDData);
    STDMETHOD_(void,DumpMixerTree)          (HWND hDlg);
    STDMETHOD_(void,DumpRecurseTree)        (HWND hTree, HTREEITEM hItem);
    STDMETHOD_(LPCDTREEINFO,NewCDTreeInfo)  (LPCDTITLE pCDTitle, LPCDUNIT pCDUnit, DWORD fdwType, DWORD dwTrack);
    STDMETHOD_(BOOL,PlayListNotify)         (HWND hDlg, LPNMHDR pnmh);
    STDMETHOD_(void,TreeItemMenu)           (HWND hDlg);
    STDMETHOD_(void,ToggleExpand)           (HWND hDlg);
    STDMETHOD_(void,EditTreeItem)           (HWND hDlg);
    STDMETHOD_(void,DeleteTitle)            (HWND hDlg);
    STDMETHOD_(void,RefreshTreeItem)        (HWND hDlg, HTREEITEM hItem);
    STDMETHOD_(HTREEITEM,FindRecurseTree)   (HWND hDlg, HTREEITEM hItem, LPCDTITLE pCDTitle, BOOL fRefresh, DWORD dwTitleID);
    STDMETHOD_(HTREEITEM,FindTitleInDBTree) (HWND hDlg, LPCDTITLE pCDTitle);
    STDMETHOD_(BOOL,DeleteTitleItem)        (HWND hDlg, HTREEITEM hItem);
    STDMETHOD_(void,RefreshTree)            (HWND hDlg, LPCDTITLE pCDTitle, DWORD dwTitleID);
    STDMETHOD_(void,DownloadTitle)          (HWND hDlg);
    STDMETHOD_(void,EditCurrentTitle)       (HWND hDlg);
    STDMETHOD_(void,ArtistNameChange)       (HWND hDlg, HTREEITEM hItem, TCHAR *szName);
    STDMETHOD_(void,NotifyTitleChange)      (LPCDTITLE pCDTitle);
    STDMETHOD_(void,SubClassDlg)            (HWND hDlg);
    STDMETHOD_(void,UnSubClassDlg)          (HWND hDlg);
    STDMETHOD_(void,EndEditReturn)          (HWND hDlg);
    STDMETHOD_(void,SetArtistExpand)        (HWND hDlg, HTREEITEM hItem, BOOL fExpand);

    // dragdrop.cpp

    STDMETHOD_(LRESULT,DragList)            (HWND hLB, UINT uMsg, WPARAM wPara, LPARAM lParam);
    STDMETHOD_(UINT,InitDragMultiList)      (void);
    STDMETHOD_(BOOL,MakeMultiDragList)      (HWND hLB);
    STDMETHOD_(int,LBMultiItemFromPt)       (HWND hLB, POINT pt, BOOL bAutoScroll);
    STDMETHOD_(void,DrawMultiInsert)        (HWND hwndParent, HWND hLB, int nItem);


    // listedit.cpp

    STDMETHOD_(void,AddEditToPlayList)      (HWND hDlg);
    STDMETHOD_(void,TrackEditChange)        (HWND hDlg);
    STDMETHOD_(void,AddTrackToPlayList)     (HWND hDlg, UINT_PTR dwTrack);
    STDMETHOD_(void,ResetPlayList)          (HWND hDlg);
    STDMETHOD_(void,AddToPlayList)          (HWND hDlg);
    STDMETHOD_(BOOL,ListEditor)             (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHOD_(BOOL,DoListCommand)          (HWND hDlg, WPARAM wParam, LPARAM lParam);
    STDMETHOD_(void,CommitTitleChanges)     (HWND hDlg, BOOL fSave);
    STDMETHOD_(BOOL,ListEditDialog)         (HWND hDlg, LPCDTITLE pCDTitle);
    STDMETHOD_(BOOL,InitListEdit)           (HWND hDlg);
    STDMETHOD_(void,RemovePlayListSel)      (HWND hDlg);
    STDMETHOD_(void,UpdateListButtons)      (HWND hDlg);
    STDMETHOD_(void,AvailTracksNotify)      (HWND hDlg, UINT code);
    STDMETHOD_(void,CurrListNotify)         (HWND hDlg, UINT code);
    STDMETHOD_(void,UpdateAvailList)        (HWND hDlg);
    STDMETHOD_(void,UploadTitle)            (HWND hDlg);
    STDMETHOD_(BOOL,ConfirmUpload)          (HWND hDlg);
    STDMETHOD_(BOOL,Upload)                 (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHOD_(BOOL,Confirm)                (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

    STDMETHOD_(void,OnDrawItem)             (HWND hDlg, const DRAWITEMSTRUCT *lpdis);
    STDMETHOD_(void,DrawListItem)           (HWND hDlg, HDC hdc, const RECT *rItem, UINT_PTR itemIndex, BOOL selected);
    STDMETHOD_(BOOL,OnQueryDrop)            (HWND hDlg, HWND hwndDrop, HWND hwndSrc, POINT ptDrop, DWORD dwState);
    STDMETHOD_(BOOL,OnProcessDrop)          (HWND hDlg, HWND hwndDrop, HWND hwndSrc, POINT ptDrop, DWORD dwState);
    STDMETHOD_(int,InsertIndex)             (HWND hDlg, POINT pt, BOOL bDragging);
    STDMETHOD_(BOOL,IsInListbox)            (HWND hDlg, HWND hwndListbox, POINT pt);
    STDMETHOD_(void,MoveCopySelection)      (HWND hDlg, int iInsertPos, DWORD dwState);
    STDMETHOD_(BOOL,DoDragCommand)          (HWND hDlg, LPDRAGMULTILISTINFO lpns);
    enum { WM_PRIVATE = WM_APP + 1 };
    STDMETHOD_(void,OnPrivateMsg)           (HWND hDlg, WPARAM, LPARAM);

    // volopt.cpp

    STDMETHOD_(BOOL,MixerConfig)            (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHOD_(MMRESULT,GetDefaultMixID)    (DWORD *pdwMixID);
    STDMETHOD_(void,SearchControls)         (int mxid, LPMIXERLINE pml, LPDWORD pdwVolID, LPDWORD pdwMuteID, TCHAR *szName, BOOL *pfFound, BOOL fVerify);
    STDMETHOD_(void,SearchConnections)      (int mxid, DWORD dwDestination, DWORD dwConnections, LPDWORD pdwVolID, LPDWORD pdwMuteID, TCHAR *szName, BOOL *pfFound, BOOL fVerify);
    STDMETHOD_(BOOL,SearchDevice)           (DWORD dwMixID, LPCDUNIT pCDUnit, LPDWORD pdwDestID, LPDWORD pdwVolID, LPDWORD pdwMuteID, TCHAR *szName, BOOL fVerify);
    STDMETHOD_(void,GetUnitDefaults)        (LPCDUNIT pCDUnit);
    STDMETHOD_(BOOL,MapLetterToDevice)      (TCHAR DriveLetter, TCHAR *szDriver, TCHAR *szDevDesc, DWORD dwSize);
    STDMETHOD_(BOOL,TruncName)              (TCHAR *pDest, TCHAR *pSrc);
    STDMETHOD (ComputeMixID)                (LPDWORD pdwMixID, TCHAR *szMixerName);
    STDMETHOD (GetUnitRegData)              (LPCDUNIT pCDUnit);
    STDMETHOD_(void,SetUnitRegData)         (LPCDUNIT pCDUnit);
    STDMETHOD_(void,GetUnitValues)          (LPCDUNIT pCDUnit);
    STDMETHOD_(void,WriteCDList)            (LPCDUNIT pCDList);
    STDMETHOD_(void,DestroyCDList)          (LPCDUNIT *ppCDList);
    STDMETHOD_(UINT,GetDefDrive)            (void);
    STDMETHOD (CreateCDList)                (LPCDUNIT *ppCDList);

    STDMETHOD (BuildUITree)                 (LPCDDRIVE *ppCDRoot, LPCDUNIT pCDList);
    STDMETHOD_(void,DestroyUITree)          (LPCDDRIVE *ppCDRoot);
    STDMETHOD_(void,SetUIDefaults)          (LPCDDRIVE pCDTree, LPCDUNIT pCDList);
    STDMETHOD_(void,RestoreOriginals)       (void);
    STDMETHOD (AddLineControls)             (LPCDMIXER pMixer, LPCDCONTROL *ppLastControl, int mxid, LPMIXERLINE pml);
    STDMETHOD (AddConnections)              (LPCDMIXER pMixer, LPCDCONTROL *ppLastControl, int mxid, DWORD dwDestination, DWORD dwConnections);
    STDMETHOD (AddControls)                 (LPCDMIXER pMixer);
    STDMETHOD (AddMixers)                   (LPCDDRIVE pDevice);
    STDMETHOD_(BOOL,UpdateCDList)           (LPCDDRIVE pCDTree, LPCDUNIT pCDList);
    STDMETHOD_(void,InitControlUI)          (HWND hDlg, LPCDMIXER pMixer);
    STDMETHOD_(void,InitMixerUI)            (HWND hDlg, LPCDDRIVE pDevice);
    STDMETHOD_(void,InitDeviceUI)           (HWND hDlg, LPCDDRIVE pCDTree, LPCDDRIVE pCurrentDevice);
    STDMETHOD_(BOOL,InitMixerConfig)        (HWND hDlg);
    STDMETHOD_(LPCDDRIVE,GetCurrentDevice)  (HWND hDlg);
    STDMETHOD_(LPCDMIXER,GetCurrentMixer)   (HWND hDlg);
    STDMETHOD_(void,ChangeCDDrives)         (HWND hDlg);
    STDMETHOD_(void,ChangeCDMixer)          (HWND hDlg);
    STDMETHOD_(void,ChangeCDControl)        (HWND hDlg);
    STDMETHOD_(void,SetMixerDefaults)       (HWND hDlg);
    STDMETHOD_(BOOL,VolumeDialog)           (HWND hDlg);

};

#endif // !defined(CDOPT_COM_IMPLEMENTATION)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\precomp.h ===
/****************************************************************************

    Contains the standard headers

    Copyright (c) Microsoft Corporation	1995
    
    8/11/95 Brian McDowell

*******************************************************************************/

#include <windows.h>
#include <ole2.h>
#include <windowsx.h>
#include <stdlib.h>
#include <math.h> 
#include <io.h>
#include <fcntl.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <memory.h>
#include <commctrl.h>
#include <prsht.h>
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\sqlobj.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  SQLOBJ.H
//
//	Defines the SQL Wrapper object
//
//	Copyright (c) Microsoft Corporation	1998
//
//  protect us from the DLL's not being present and to allow us to run.
//  got to be a simplier solution.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _SQLOBJ_HEADER_
#define _SQLOBJ_HEADER_

#include <odbcinst.h>
#include <sqlext.h>

#ifdef __cplusplus
extern "C" {
#endif


typedef BOOL       (INSTAPI * SQ_CONFIGDATASOURCE) (HWND,WORD,LPCTSTR, LPCTSTR);
typedef SQLRETURN  (SQL_API * SQ_SETPOS)           (SQLHSTMT,SQLUSMALLINT,SQLUSMALLINT,SQLUSMALLINT);
typedef SQLRETURN  (SQL_API * SQ_EXTENDEDFETCH)    (SQLHSTMT,SQLUSMALLINT,SQLINTEGER,SQLUINTEGER *,SQLUSMALLINT *);
typedef SQLRETURN  (SQL_API * SQ_FREESTMT)         (SQLHSTMT,SQLUSMALLINT);
typedef SQLRETURN  (SQL_API * SQ_EXECDIRECT)       (SQLHSTMT,SQLCHAR *,SQLINTEGER);
typedef SQLRETURN  (SQL_API * SQ_SETSTMTOPTION)    (SQLHSTMT,SQLUSMALLINT,SQLUINTEGER);
typedef SQLRETURN  (SQL_API * SQ_BINDCOL)          (SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLPOINTER,SQLINTEGER,SQLINTEGER *);
typedef SQLRETURN  (SQL_API * SQ_ERROR)            (SQLHENV,SQLHDBC,SQLHSTMT,SQLCHAR *,SQLINTEGER *,SQLCHAR *,SQLSMALLINT,SQLSMALLINT *);
typedef SQLRETURN  (SQL_API * SQ_ALLOCSTMT)        (SQLHDBC,SQLHSTMT *);
typedef SQLRETURN  (SQL_API * SQ_FREECONNECT)      (SQLHDBC);
typedef SQLRETURN  (SQL_API * SQ_FREEENV)          (SQLHENV);
typedef SQLRETURN  (SQL_API * SQ_DISCONNECT)       (SQLHDBC);
typedef SQLRETURN  (SQL_API * SQ_CONNECT)          (SQLHDBC,SQLCHAR *,SQLSMALLINT,SQLCHAR *,SQLSMALLINT,SQLCHAR *,SQLSMALLINT);
typedef SQLRETURN  (SQL_API * SQ_ALLOCCONNECT)     (SQLHENV,SQLHDBC *);
typedef SQLRETURN  (SQL_API * SQ_ALLOCENV)         (SQLHENV *);
typedef SQLRETURN  (SQL_API * SQ_SETCONNECTOPTION) (SQLHDBC,SQLUSMALLINT,SQLUINTEGER);
typedef SQLRETURN  (SQL_API * SQ_TRANSACT)         (SQLHENV,SQLHDBC,SQLUSMALLINT);
typedef SQLRETURN  (SQL_API * SQ_FETCH)            (SQLHSTMT);
typedef SQLRETURN  (SQL_API * SQ_STATISTICS)       (SQLHSTMT,SQLCHAR *,SQLSMALLINT,SQLCHAR *,SQLSMALLINT,SQLCHAR *,SQLSMALLINT,SQLUSMALLINT,SQLUSMALLINT);
typedef SQLRETURN  (SQL_API * SQ_DESCRIBECOL)      (SQLHSTMT,SQLSMALLINT,SQLCHAR *,SQLSMALLINT,SQLSMALLINT *,SQLSMALLINT *,SQLUINTEGER *,SQLSMALLINT *,SQLSMALLINT *);

class SQL
{
    public:

        SQL(); 
        ~SQL();
        
        BOOL               Initialize(void);

        BOOL       INSTAPI ConfigDataSource(HWND hwndParent, WORD fRequest,LPCTSTR lpszDriver, LPCTSTR lpszAttributes);
        SQLRETURN  SQL_API SetPos( SQLHSTMT hstmt, SQLUSMALLINT irow, SQLUSMALLINT fOption, SQLUSMALLINT fLock);
        SQLRETURN  SQL_API ExtendedFetch( SQLHSTMT hstmt, SQLUSMALLINT fFetchType, SQLINTEGER irow, SQLUINTEGER *pcrow, SQLUSMALLINT *rgfRowStatus);
        SQLRETURN  SQL_API FreeStmt(SQLHSTMT StatementHandle, SQLUSMALLINT Option);
        SQLRETURN  SQL_API ExecDirect(SQLHSTMT StatementHandle, SQLCHAR *StatementText, SQLINTEGER TextLength);
        SQLRETURN  SQL_API SetStmtOption(SQLHSTMT StatementHandle, SQLUSMALLINT Option, SQLUINTEGER Value);
        SQLRETURN  SQL_API BindCol(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType, SQLPOINTER TargetValue, SQLINTEGER BufferLength, SQLINTEGER *StrLen_or_Ind);
        SQLRETURN  SQL_API Error(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle, SQLHSTMT StatementHandle, SQLCHAR *Sqlstate, SQLINTEGER *NativeError, SQLCHAR *MessageText, SQLSMALLINT BufferLength, SQLSMALLINT *TextLength);
        SQLRETURN  SQL_API AllocStmt(SQLHDBC ConnectionHandle, SQLHSTMT *StatementHandle);
        SQLRETURN  SQL_API FreeConnect(SQLHDBC ConnectionHandle);
        SQLRETURN  SQL_API FreeEnv(SQLHENV EnvironmentHandle);
        SQLRETURN  SQL_API Disconnect(SQLHDBC ConnectionHandle);
        SQLRETURN  SQL_API Connect(SQLHDBC ConnectionHandle, SQLCHAR *ServerName, SQLSMALLINT NameLength1, SQLCHAR *UserName, SQLSMALLINT NameLength2, SQLCHAR *Authentication, SQLSMALLINT NameLength3);
        SQLRETURN  SQL_API AllocConnect(SQLHENV EnvironmentHandle, SQLHDBC *ConnectionHandle);
        SQLRETURN  SQL_API AllocEnv(SQLHENV *EnvironmentHandle);
        SQLRETURN  SQL_API SetConnectOption(SQLHDBC ConnectionHandle, SQLUSMALLINT Option, SQLUINTEGER Value);
        SQLRETURN  SQL_API Transact(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle, SQLUSMALLINT CompletionType);
        SQLRETURN  SQL_API Fetch(SQLHSTMT StatementHandle);
        SQLRETURN  SQL_API Statistics(SQLHSTMT StatementHandle, SQLCHAR *CatalogName, SQLSMALLINT NameLength1, SQLCHAR *SchemaName, SQLSMALLINT NameLength2, SQLCHAR *TableName, SQLSMALLINT NameLength3, SQLUSMALLINT Unique, SQLUSMALLINT Reserved);
        SQLRETURN  SQL_API DescribeCol(SQLHSTMT StatementHandle, SQLSMALLINT ColumnNumber, SQLCHAR * ColumnName, SQLSMALLINT BufferLength, SQLSMALLINT * NameLengthPtr, SQLSMALLINT * DataTypePtr, SQLUINTEGER * ColumnSizePtr, SQLSMALLINT * DecimalDigitsPtr, SQLSMALLINT * NullablePtr);

    private:
        HMODULE                 m_hODBC;
        HMODULE                 m_hODBCCP;

        SQ_CONFIGDATASOURCE    m_pfnConfigDataSource;
        SQ_SETPOS              m_pfnSetPos;
        SQ_EXTENDEDFETCH       m_pfnExtendedFetch;
        SQ_FREESTMT            m_pfnFreeStmt;
        SQ_EXECDIRECT          m_pfnExecDirect;
        SQ_SETSTMTOPTION       m_pfnSetStmtOption;
        SQ_BINDCOL             m_pfnBindCol;
        SQ_ERROR               m_pfnError;
        SQ_ALLOCSTMT           m_pfnAllocStmt;
        SQ_FREECONNECT         m_pfnFreeConnect;
        SQ_FREEENV             m_pfnFreeEnv;
        SQ_DISCONNECT          m_pfnDisconnect;
        SQ_CONNECT             m_pfnConnect;
        SQ_ALLOCCONNECT        m_pfnAllocConnect;
        SQ_ALLOCENV            m_pfnAllocEnv;
        SQ_SETCONNECTOPTION    m_pfnSetConnectOption;
        SQ_TRANSACT            m_pfnTransact;
        SQ_FETCH               m_pfnFetch;
        SQ_STATISTICS          m_pfnStatistics;
        SQ_DESCRIBECOL         m_pfnDescribeCol;
};

#ifdef __cplusplus
};
#endif

#endif  //_SQLOBJ_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\dragdrop.cpp ===
/******************************Module*Header*******************************\
* Module Name: DragDrop.c
*
* An attempt to implement dragging and dropping between Multi-selection
* listboxes.
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#define NOOLE
#define NODRAGLIST

#include "precomp.h"  
#include "cdopti.h"
#include "cdoptimp.h"


#define LONG2POINT(l, pt) ((pt).x = (SHORT)LOWORD(l), \
                           (pt).y = (SHORT)HIWORD(l))



#define DF_ACTUALLYDRAG     0x0001
#define DF_DEFERRED         0x0002

#define INITLINESPERSECOND  36
#define VERTCHANGENUMLINES  25

#define TIMERID             238
#define TIMERLEN            250
#define TIMERLEN2           50

#define DX_INSERT           16
#define DY_INSERT           16


typedef struct DRAGPROP
{
    WNDPROC  lpfnDefProc;
    HWND     hwndDrag;
    UINT     uFlags;
    DWORD    dwState;
    CCDOpt * pCDOpt;

} DRAGPROP, *PDRAGPROP;


TCHAR   szDragListMsgString[]   = TEXT(SJE_DRAGLISTMSGSTRING);
TCHAR   szDragProp[]            = TEXT("DragMultiProp");




STDMETHODIMP_(UINT) CCDOpt::InitDragMultiList(void)
{
	if (!m_uDragListMsg) {

        m_uDragListMsg = RegisterWindowMessage(szDragListMsgString);

        if (!m_uDragListMsg) {
            return 0;
        }
    }
    return m_uDragListMsg;
}


STDMETHODIMP_(LRESULT) CCDOpt::DragList(HWND hLB, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PDRAGPROP           pDragProp;
    DRAGMULTILISTINFO   sNotify;
    WNDPROC             lpfnDefProc;
    BOOL                bDragging;

    pDragProp = (PDRAGPROP)GetProp(hLB, szDragProp);
    bDragging = pDragProp->hwndDrag == hLB;

    // Save this in case anything happens to pDragProp before we return.

    lpfnDefProc = pDragProp->lpfnDefProc;

    switch (uMsg) {

    case WM_DESTROY:
        if (bDragging)
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L); // cancel drag


        // Restore the window proc just in case.

        SubclassWindow( hLB, lpfnDefProc );

        if (pDragProp) {
            LocalFree((HLOCAL)pDragProp);
            RemoveProp(hLB, szDragProp);
        }
        break;


    case WM_LBUTTONDOWN:
        {
            POINT pt;
            int nItem;


            if (bDragging)                                // nested button-down
                SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);  // cancel drag

            SetFocus(hLB);

            LONG2POINT(lParam, pt);

            ClientToScreen(hLB, &pt);
            nItem = LBMultiItemFromPt(hLB, pt, FALSE);

            if ( nItem >= 0 ) {

                //
                // We can only allow dragging if the item is selected.
                // If the item is not selected - pass the message on.
                //
                if ( ListBox_GetSel( hLB, nItem ) <= 0 ) {
                    return CallWindowProc( lpfnDefProc, hLB, uMsg,
                                           wParam, lParam );
                }

                pDragProp->dwState = (wParam & MK_CONTROL) ? DG_COPY : DG_MOVE;
                sNotify.uNotification = DG_BEGINDRAG;
                goto QueryParent;

            }
            else {
                goto FakeDrag;
            }
        }


    case WM_TIMER:
        if (wParam != TIMERID) {
            break;
        }

        {
            POINT CursorPos;

            GetCursorPos( &CursorPos );
            ScreenToClient( hLB, &CursorPos );
            lParam = MAKELPARAM((WORD)CursorPos.x, (WORD)CursorPos.y);
        }

        // Fall through

    case WM_MOUSEMOVE:
        if (bDragging) {

            HWND hwndParent;
            LRESULT lRet;

            // We may be just simulating a drag, but not actually doing
            // anything.

            if (!(pDragProp->uFlags&DF_ACTUALLYDRAG)) {
                return(0L);
            }


            if ( pDragProp->uFlags & DF_DEFERRED ) {

                pDragProp->uFlags &= ~DF_DEFERRED;
                KillTimer(hLB, TIMERID);
                SetTimer(hLB, TIMERID, TIMERLEN2, NULL);
            }

            sNotify.uNotification = DG_DRAGGING;

QueryParent:
            hwndParent = GetParent( hLB );
            sNotify.hWnd = hLB;
            sNotify.dwState = pDragProp->dwState;

            LONG2POINT( lParam, sNotify.ptCursor );

            ClientToScreen( hLB, &sNotify.ptCursor );

            lRet = SendMessage( hwndParent, m_uDragListMsg, GetDlgCtrlID(hLB),
                                 (LPARAM)(LPDRAGMULTILISTINFO)&sNotify );

            if ( uMsg == WM_LBUTTONDOWN ) {

                // Some things may not be draggable

                if (lRet) {

                    SetTimer(hLB, TIMERID, TIMERLEN, NULL);
                    pDragProp->uFlags = DF_DEFERRED | DF_ACTUALLYDRAG;
                }
                else {
FakeDrag:
                    pDragProp->uFlags = 0;
                }

                // Set capture and change mouse cursor

                pDragProp->hwndDrag = hLB;
                SetCapture( hLB );
            }

            // Don't call the def proc, since it may try to change the
            // selection or set timers or things like that.

            return 0L;
       }
       break;


    case  WM_RBUTTONDOWN:
    case  WM_LBUTTONUP:

        // if we are capturing mouse - release it and check for an
        // acceptable place where mouse is now to decide drop or not

        if (bDragging) {

            HWND hwndParent;

            pDragProp->hwndDrag = NULL;
            KillTimer(hLB, TIMERID);
            ReleaseCapture();
            SetCursor(LoadCursor(NULL, IDC_ARROW));

            hwndParent = GetParent(hLB);

            sNotify.uNotification = (uMsg == WM_LBUTTONUP)
                                        ? DG_DROPPED : DG_CANCELDRAG;
            sNotify.hWnd = hLB;
            sNotify.dwState = pDragProp->dwState;

            LONG2POINT( lParam, sNotify.ptCursor );

            ClientToScreen( hLB, &sNotify.ptCursor );

            SendMessage( hwndParent, m_uDragListMsg, GetDlgCtrlID(hLB),
                         (LPARAM)(LPDRAGMULTILISTINFO)&sNotify);

            //
            // If we didn't actually do any dragging just fake a button
            // click at the current location.
            //
            if ( pDragProp->uFlags & DF_DEFERRED ) {
                CallWindowProc(lpfnDefProc, hLB, WM_LBUTTONDOWN, wParam, lParam);
                CallWindowProc(lpfnDefProc, hLB, uMsg, wParam, lParam);
            }

            // We need to make sure to return 0 in case this is from a
            // keyboard message.

            return 0L;
        }
        break;


    case WM_GETDLGCODE:
        if (bDragging)
            return (CallWindowProc(lpfnDefProc, hLB, uMsg, wParam, lParam)
                    | DLGC_WANTMESSAGE);
        break;


    case WM_KEYDOWN:
        if (wParam == VK_ESCAPE) {
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);
        }
    case WM_CHAR:
    case WM_KEYUP:

        // We don't want the listbox processing this if we are dragging.

        if (bDragging)
            return 0L;
        break;

    default:
        break;
    }

    return CallWindowProc(lpfnDefProc, hLB, uMsg, wParam, lParam);
}

LRESULT CALLBACK CCDOpt::DragListProc(HWND hLB, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PDRAGPROP pDragProp = (PDRAGPROP)GetProp(hLB, szDragProp);

    return(pDragProp->pCDOpt->DragList(hLB, uMsg, wParam, lParam));
}



STDMETHODIMP_(BOOL) CCDOpt::MakeMultiDragList(HWND hLB)
{
    PDRAGPROP pDragProp;

    if (!m_uDragListMsg) {

        return FALSE;
    }

    //
    // Check that we have not already subclassed this window.
    //

    if (GetProp(hLB, szDragProp)) {
        return TRUE;
    }

    pDragProp = (PDRAGPROP)LocalAlloc(LPTR, sizeof(DRAGPROP));
    if (pDragProp == NULL ) {

        return FALSE;
    }

    pDragProp->pCDOpt = this;

    SetProp(hLB, szDragProp, (HANDLE)pDragProp);
    pDragProp->lpfnDefProc = SubclassWindow( hLB, DragListProc );

    return TRUE;
}



STDMETHODIMP_(int) CCDOpt::LBMultiItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll)
{
    static LONG dwLastScroll = 0;

    RECT    rc;
    DWORD   dwNow;
    int     nItem;
    WORD    wScrollDelay, wActualDelay;

    ScreenToClient(hLB, &pt);
    GetClientRect(hLB, &rc);

    nItem = ListBox_GetTopIndex( hLB );

    //
    // Is the point in the LB client area?
    //

    if ( PtInRect(&rc, pt) ) {

        //
        // Check each visible item in turn.
        //

        for ( ; ; ++nItem) {

            if ( LB_ERR == ListBox_GetItemRect( hLB, nItem, &rc) ) {
                break;
            }

            if ( PtInRect(&rc, pt) ) {

                return nItem;
            }
        }
    }
    else {

        //
        // If we want autoscroll and the point is directly above or below the
        // LB, determine the direction and if it is time to scroll yet.
        //

        if ( bAutoScroll && (UINT)pt.x < (UINT)rc.right ) {

            if (pt.y <= 0) {
                --nItem;
            }
            else {

                ++nItem;
                pt.y = rc.bottom - pt.y;
            }

            wScrollDelay = (WORD)(1000 / (INITLINESPERSECOND - pt.y/VERTCHANGENUMLINES));

            dwNow = GetTickCount();
            wActualDelay = (WORD)(dwNow - dwLastScroll);

            if (wActualDelay > wScrollDelay) {

                //
                // This will the actual number of scrolls per second to be
                // much closer to the required number.
                //

                if (wActualDelay > wScrollDelay * 2)
                    dwLastScroll = dwNow;
                else
                    dwLastScroll += wScrollDelay;

                ListBox_SetTopIndex( hLB, nItem );
            }
        }
    }

    return -1;
}


STDMETHODIMP_(void) CCDOpt::DrawMultiInsert(HWND hwndParent, HWND hLB, int nItem)
{
    static POINT ptLastInsert;
    static INT nLastInsert = -1;

    RECT rc;

    //
    // Erase the old mark if necessary
    //

    if ( nLastInsert >= 0 && nItem != nLastInsert ) {

        rc.left   = ptLastInsert.x;
        rc.top    = ptLastInsert.y;
        rc.right  = rc.left + DX_INSERT;
        rc.bottom = rc.top + DY_INSERT;

        //
        // Need to update immediately in case the insert rects overlap.
        //

        InvalidateRect( hwndParent, &rc, TRUE );
        UpdateWindow( hwndParent );

        nLastInsert = -1;
    }

    //
    // Draw a new mark if necessary
    //

    if ( nItem != nLastInsert && nItem >= 0 ) {

        static HICON hInsert = NULL;

        if ( !hInsert ) {
            hInsert = LoadIcon(m_hInst, MAKEINTRESOURCE(IDR_INSERT));
        }

        if ( hInsert ) {

            HDC     hDC;
            int     iItemHeight;

            GetWindowRect( hLB, &rc );
            ScreenToClient( hLB, (LPPOINT)&rc );
            ptLastInsert.x = rc.left - DX_INSERT;

            iItemHeight = ListBox_GetItemHeight( hLB, nItem );
            nLastInsert = nItem;

            nItem -= ListBox_GetTopIndex( hLB );
            ptLastInsert.y = (nItem * iItemHeight) - DY_INSERT / 2;

            ClientToScreen(hLB, &ptLastInsert);
            ScreenToClient(hwndParent, &ptLastInsert);

            hDC = GetDC(hwndParent);
            DrawIcon(hDC, ptLastInsert.x, ptLastInsert.y, hInsert);
            ReleaseDC(hwndParent, hDC);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\playopts.cpp ===
//--------------------------------------------------------------------------;
//
//  File: playopts.cpp
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved
//
//--------------------------------------------------------------------------;

#include "precomp.h"
#include "optres.h"
#include "cdopti.h"
#include "cdoptimp.h"
#include "mmsystem.h"
#include "helpids.h"

//////////////
// Help ID's
//////////////

#pragma data_seg(".text")
const static DWORD aPlayOptsHelp[] =
{
    IDC_STARTPLAY,              IDH_STARTPLAY,
    IDC_EXITSTOP,               IDH_EXITSTOP,
    IDC_TOPMOST,                IDH_TOPMOST,
    IDC_PLAYBACK_GROUP,         IDH_PLAYBACKOPTIONS,
    IDC_TIMEDISPLAY_GROUP,      IDH_TIMEDISPLAY,
    IDC_CDTIME,                 IDH_CDTIME,
    IDC_TRACKTIME,              IDH_TRACKTIME,
    IDC_TRACKTIMEREMAIN,        IDH_TRACKTIMEREMAIN,
    IDC_CDTIMEREMAIN,           IDH_CDTIMEREMAIN,
    IDC_PREVIEWTIME_GROUP,      IDH_PREVIEWOPTION,
    IDC_INTROTIMESLIDER,        IDH_PREVIEWSLIDER,
    IDC_INTROTIMETEXT,          IDH_PREVIEWDISPLAY,
    IDC_PREVIEWTIME_TEXT,       IDH_PREVIEWOPTION,
    IDC_OPTIONSRESTORE,         IDH_PLAYBACKDEFAULTS,
    IDC_SETVOLUMECNTL,          IDH_SETVOLUMECONTROL,
    IDC_TRAYENABLE,             IDH_SYSTRAY_ICON,
    0, 0
};
#pragma data_seg()


////////////
// Functions
////////////


STDMETHODIMP_(void) CCDOpt::SetIntroTime(HWND hDlg)
{
    TCHAR        seconds[CDSTR];
    TCHAR        str[CDSTR];

    if (m_pCDCopy)
    {
        LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

        if (pCDData->dwIntroTime == 1)
        {
            LoadString( m_hInst, IDS_SECOND, seconds, sizeof( seconds ) /sizeof(TCHAR));
        }
        else
        {
            LoadString( m_hInst, IDS_SECONDS, seconds, sizeof( seconds ) /sizeof(TCHAR));
        }

        wsprintf(str, TEXT("%d %s"), pCDData->dwIntroTime, seconds);
        SetDlgItemText(hDlg, IDC_INTROTIMETEXT, str);

        SendDlgItemMessage( hDlg, IDC_INTROTIMESLIDER, TBM_SETPOS, TRUE, pCDData->dwIntroTime);

        ToggleApplyButton(hDlg);
    }
}


STDMETHODIMP_(BOOL) CCDOpt::InitPlayerOptions(HWND hDlg)
{
    if (m_pCDCopy)
    {
        LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

        CheckDlgButton(hDlg, IDC_STARTPLAY, pCDData->fStartPlay);
        CheckDlgButton(hDlg, IDC_EXITSTOP, pCDData->fExitStop);
        CheckDlgButton(hDlg, IDC_TOPMOST, pCDData->fTopMost);
        CheckDlgButton(hDlg, IDC_TRAYENABLE, pCDData->fTrayEnabled);

        CheckDlgButton(hDlg, IDC_TRACKTIME,         pCDData->fDispMode == CDDISP_TRACKTIME);
        CheckDlgButton(hDlg, IDC_TRACKTIMEREMAIN,   pCDData->fDispMode == CDDISP_TRACKREMAIN);
        CheckDlgButton(hDlg, IDC_CDTIME,            pCDData->fDispMode == CDDISP_CDTIME);
        CheckDlgButton(hDlg, IDC_CDTIMEREMAIN,      pCDData->fDispMode == CDDISP_CDREMAIN);

        SendDlgItemMessage( hDlg, IDC_INTROTIMESLIDER, TBM_SETRANGE, TRUE, MAKELONG( CDINTRO_MIN_TIME, CDINTRO_MAX_TIME ) );
        SendDlgItemMessage( hDlg, IDC_INTROTIMESLIDER, TBM_SETTICFREQ , 1, 0 );

        SetIntroTime(hDlg);
    }

    return TRUE;
}


STDMETHODIMP_(void) CCDOpt::UsePlayerDefaults(HWND hDlg)
{
    if (m_pCDCopy)
    {
        LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

        pCDData->fStartPlay     = CDDEFAULT_START;
        pCDData->fExitStop      = CDDEFAULT_EXIT;
        pCDData->fDispMode      = CDDEFAULT_DISP;
        pCDData->fTopMost       = CDDEFAULT_TOP;
        pCDData->fTrayEnabled   = CDDEFAULT_TRAY;
        pCDData->dwIntroTime    = CDDEFAULT_INTRO;

        InitPlayerOptions(hDlg);

        ToggleApplyButton(hDlg);
    }
}


STDMETHODIMP_(INT_PTR) CCDOpt::PlayerOptions(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;

    switch (msg)
    {
        default:
            fResult = FALSE;
        break;

        case WM_CONTEXTMENU:
        {
            WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)aPlayOptsHelp);
        }
        break;

        case WM_HELP:
        {
            WinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPSTR)aPlayOptsHelp);
        }
        break;

        case WM_INITDIALOG:
        {
            fResult = InitPlayerOptions(hDlg);
        }
        break;

        case WM_COMMAND:
        {
            LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

            switch (LOWORD(wParam))
            {
                case IDC_OPTIONSRESTORE:
                    UsePlayerDefaults(hDlg);
                break;

                case IDC_SETVOLUMECNTL:
                    m_fVolChanged = VolumeDialog(hDlg);
                break;

                case IDC_STARTPLAY:
                    pCDData->fStartPlay = Button_GetCheck(GetDlgItem(hDlg, IDC_STARTPLAY));
                    ToggleApplyButton(hDlg);
                break;

                case IDC_EXITSTOP:
                    pCDData->fExitStop = Button_GetCheck(GetDlgItem(hDlg, IDC_EXITSTOP));
                    ToggleApplyButton(hDlg);
                break;

                case IDC_TOPMOST:
                    pCDData->fTopMost = Button_GetCheck(GetDlgItem(hDlg, IDC_TOPMOST));
                    ToggleApplyButton(hDlg);
                break;

                case IDC_TRAYENABLE:
                    pCDData->fTrayEnabled = Button_GetCheck(GetDlgItem(hDlg, IDC_TRAYENABLE));
                    ToggleApplyButton(hDlg);
                break;

                case IDC_TRACKTIME:
                    pCDData->fDispMode = CDDISP_TRACKTIME;
                    ToggleApplyButton(hDlg);
                break;

                case IDC_TRACKTIMEREMAIN:
                    pCDData->fDispMode = CDDISP_TRACKREMAIN;
                    ToggleApplyButton(hDlg);
                break;

                case IDC_CDTIME:
                    pCDData->fDispMode = CDDISP_CDTIME;
                    ToggleApplyButton(hDlg);
                break;

                case IDC_CDTIMEREMAIN:
                    pCDData->fDispMode = CDDISP_CDREMAIN;
                    ToggleApplyButton(hDlg);
                break;

                default:
                    fResult = FALSE;
                break;
            }
        }
        break;

        case WM_HSCROLL:
        {
            LPCDOPTDATA pCDData = m_pCDCopy->pCDData;
            HWND hScroll = (HWND) lParam;

            if (hScroll == GetDlgItem(hDlg, IDC_INTROTIMESLIDER))
            {
                pCDData->dwIntroTime = (DWORD) SendDlgItemMessage( hDlg, IDC_INTROTIMESLIDER, TBM_GETPOS, 0, 0 );
                SetIntroTime(hDlg);
            }
        }
        break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
                case PSN_APPLY:
                {
                    ApplyCurrentSettings();
                }
            }
        }
        break;
    }

    return fResult;
}


///////////////////
// Dialog handler
//
INT_PTR CALLBACK CCDOpt::PlayerOptionsProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);

    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) ((LPPROPSHEETPAGE) lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);
    }

    if (pCDOpt)
    {
        fResult = pCDOpt->PlayerOptions(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\playlist.cpp ===
//--------------------------------------------------------------------------;
//
//  File: playlist.cpp
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved
//
//--------------------------------------------------------------------------;

#include "precomp.h"
#include "cdopti.h"
#include "cdoptimp.h"
#include "cddata.h"
#include "helpids.h"

//////////////
// Help ID's
//////////////

#pragma data_seg(".text")
const static DWORD aPlayListHelp[] =
{
    IDC_EDITPLAYLIST,           IDH_EDITPLAYLIST,
    IDC_DATABASE_TEXT,          IDH_ALBUMDATABASE,
    IDC_CDTREE,                 IDH_ALBUMDATABASE,
    IDC_BYARTIST,               IDH_VIEWBYARTIST,
    0, 0
};
#pragma data_seg()


////////////
// Local constants
////////////

#define NO_IMAGE                (DWORD(-1))
#define CD_IMAGE                (0)
#define CDS_IMAGE               (1)
#define NOCD_IMAGE              (2)
#define CDCASE_IMAGE            (3)
#define CDOPEN_IMAGE            (4)
#define CDCOLLECTION_IMAGE      (5)
#define CDSONG_IMAGE            (6)

#define FORMAT_LET_NAME         TEXT("( %s )  %s")
#define FORMAT_NAME             TEXT("%s")
#define FORMAT_LET_NAME_ARTIST  TEXT("( %s )  %s (%s)")
#define FORMAT_LABEL_TYPE       TEXT("%s  (%s)")
#define FORMAT_NEW_TRACK        TEXT("%s %d")

#define MAXLABEL                (CDSTR * 4)


////////////
// Methods
////////////

STDMETHODIMP_(HTREEITEM) CCDOpt::AddNameToTree(HWND hDlg, LPCDUNIT pCDUnit, TCHAR *szName, HTREEITEM hParent, HTREEITEM hInsertAfter, LPCDTITLE pCDTitle, DWORD fdwType, DWORD dwTracks, DWORD dwImage)
{
	HTREEITEM			newItem;
	TV_INSERTSTRUCT		is;

	memset( &is, 0, sizeof( is ) );
	is.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE ;
    is.item.iImage = is.item.iSelectedImage = (int) dwImage;

	is.hParent = hParent;
	is.hInsertAfter = hInsertAfter;
    is.item.pszText = szName;
    is.item.lParam = (LPARAM) NewCDTreeInfo(pCDTitle, pCDUnit, fdwType, dwTracks);

    if (is.hInsertAfter == NULL)
    {
        is.hInsertAfter = TVI_LAST; //chk version of NT fails on NULL for this param
    }
	
	newItem = (HTREEITEM) SendDlgItemMessage( hDlg, IDC_CDTREE, TVM_INSERTITEM, 0, (LPARAM) &is );

    return(newItem);
}




STDMETHODIMP_(void) CCDOpt::AddTracksToTree(HWND hDlg, LPCDTITLE pCDTitle, HTREEITEM parent)
{
    DWORD       dwTrack;
    TCHAR       str[MAXLABEL];

    if (pCDTitle && pCDTitle->pTrackTable)
    {
        for (dwTrack = 0; dwTrack < pCDTitle->dwNumTracks; dwTrack++)
        {
            wsprintf(str, FORMAT_NAME, pCDTitle->pTrackTable[dwTrack].szName);

            AddNameToTree(hDlg, NULL, str, parent, NULL, pCDTitle, CDINFO_TRACK, dwTrack, CDSONG_IMAGE);
        }
    }
}




STDMETHODIMP_(void) CCDOpt::AddTitleByCD(HWND hDlg)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    LPCDUNIT    pCDUnit = m_pCDCopy->pCDUnitList;
    TCHAR       szUnknown[CDSTR];
    TCHAR       szNoDisc[CDSTR];
    TCHAR       szDownLoading[CDSTR];
    TCHAR       str[MAXLABEL];

    LoadString( m_hInst, IDS_NODISC, szNoDisc, sizeof( szNoDisc ) /sizeof(TCHAR));
    LoadString( m_hInst, IDS_UNKNOWNTITLE, szUnknown, sizeof( szUnknown ) /sizeof(TCHAR));
    LoadString( m_hInst, IDS_DOWNLOADING, szDownLoading, sizeof( szDownLoading ) /sizeof(TCHAR));

    if (pCDUnit)
    {
        HTREEITEM   hDisc;
        HTREEITEM   hTitle;

        LoadString( m_hInst, IDS_CDTITLES, str, sizeof( str )/sizeof(TCHAR) );
        hDisc = AddNameToTree(hDlg, NULL, str, NULL, NULL, NULL, CDINFO_DRIVES, 0, CDS_IMAGE);

        while (pCDUnit)
        {
            if (pCDUnit->dwTitleID == CDTITLE_NODISC)
            {
                wsprintf(str, FORMAT_LET_NAME, pCDUnit->szDriveName, szNoDisc);
                AddNameToTree(hDlg, pCDUnit, str, hDisc, NULL, NULL, CDINFO_CDROM, 0, NOCD_IMAGE);
            }
            else
            {
                LPCDTITLE   pCDTitle = m_pCDData->GetTitleList();

                while (pCDTitle)
                {
                    if (pCDTitle->dwTitleID == pCDUnit->dwTitleID && !pCDTitle->fRemove)
                    {
                        pCDTitle->fDownLoading = pCDUnit->fDownLoading;
                        break;
                    }

                    pCDTitle = pCDTitle->pNext;
                }

                if (pCDTitle || pCDUnit->fDownLoading)
                {
                    if (pCDUnit->fDownLoading)
                    {
                        wsprintf(str, FORMAT_LET_NAME, pCDUnit->szDriveName, szDownLoading);
                        AddNameToTree(hDlg, pCDUnit, str, hDisc, NULL, pCDTitle, CDINFO_CDROM, 0, CD_IMAGE);
                    }
                    else
                    {
                        wsprintf(str, FORMAT_LET_NAME_ARTIST, pCDUnit->szDriveName, pCDTitle->szTitle, pCDTitle->szArtist);
                        hTitle = AddNameToTree(hDlg, pCDUnit, str, hDisc, NULL, pCDTitle, CDINFO_CDROM, 0, CD_IMAGE);
                        AddTracksToTree(hDlg, pCDTitle, hTitle);

                        if (pCDTitle->fDriveExpanded)
                        {
                            TreeView_Expand(hTree, hTitle, TVE_EXPAND);
                        }
                    }
                }
                else
                {
                    wsprintf(str,FORMAT_LET_NAME, pCDUnit->szDriveName, szUnknown);
                    hTitle = AddNameToTree(hDlg, pCDUnit, str, hDisc, NULL, NULL, CDINFO_CDROM, 0, CD_IMAGE);
                }
            }

            pCDUnit = pCDUnit->pNext;
        }

        if (m_fDrivesExpanded)
        {
            TreeView_Expand(hTree, hDisc, TVE_EXPAND);
        }
    }
}




STDMETHODIMP_(void) CCDOpt::UpdateTitleTree(HWND hDlg, LPCDDATA pCDData)
{
    if (m_pCDCopy && pCDData)
    {
        HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
        HTREEITEM   parent;
        HTREEITEM   title;
        TCHAR       str[MAXLABEL];
        TCHAR       szByArtist[CDSTR];
        TCHAR       szByTitle[CDSTR];
        TCHAR       szTitles[CDSTR];
        TCHAR       szDownLoading[CDSTR];
        BOOL        fExpandArtist = FALSE;

        LPCDTITLE   pCDTitle = pCDData->GetTitleList();

        LoadString( m_hInst, IDS_BYARTIST, szByArtist, sizeof( szByArtist )/sizeof(TCHAR) );
        LoadString( m_hInst, IDS_BYTITLE, szByTitle, sizeof( szByTitle )/sizeof(TCHAR) );
        LoadString( m_hInst, IDS_OTHERTITLES, szTitles, sizeof( szTitles )/sizeof(TCHAR) );
        LoadString( m_hInst, IDS_DOWNLOADING, szDownLoading, sizeof( szDownLoading )/sizeof(TCHAR) );

        AddTitleByCD(hDlg);

        while(pCDTitle && pCDTitle->fRemove)            // If we have removed titles, we don't display them, and we need to have a valid title to start here.
        {
            pCDTitle = pCDTitle->pNext;
        }

        if (pCDTitle)   // There are no titles in database, don't show it.
        {
            HTREEITEM hArtist = NULL;
            TCHAR szUnknownArtist[CDSTR];
            TCHAR *szThisArtist;
            BOOL fByArtist = m_pCDCopy->pCDData->fByArtist;

            if (fByArtist)
            {
                wsprintf(str,  FORMAT_LABEL_TYPE, szTitles, szByArtist);
            }
            else
            {
                wsprintf(str,  FORMAT_LABEL_TYPE, szTitles, szByTitle);
            }

            parent = AddNameToTree(hDlg, NULL, str, NULL, NULL, NULL, CDINFO_ALBUMS, 0, CDS_IMAGE);

            if (fByArtist)
            {
                LoadString( m_hInst, IDS_UNKNOWNARTIST, szUnknownArtist, sizeof( szUnknownArtist )/sizeof(TCHAR) );

                szThisArtist = pCDTitle->szArtist;
                while(*szThisArtist != TEXT('\0') && (*szThisArtist == TEXT(' ') || *szThisArtist == TEXT('\t')))  // Unknown artist are null string or whitespace
                {
                    szThisArtist++;
                }

                if (szThisArtist[0] == TEXT('\0'))
                {
                    hArtist = AddNameToTree(hDlg, NULL, szUnknownArtist, parent, NULL, NULL, CDINFO_LABEL, 0, CDCOLLECTION_IMAGE);
                }
                else
                {
                    hArtist = AddNameToTree(hDlg, NULL, szThisArtist, parent, NULL, NULL, CDINFO_ARTIST, 0, CDCOLLECTION_IMAGE);
                }

                fExpandArtist = pCDTitle->fArtistExpanded;
            }


            while (pCDTitle)
            {
                if (!fByArtist)
                {
                    if (pCDTitle->fDownLoading)
                    {
                        wsprintf(str, FORMAT_NAME, szDownLoading);
                    }
                    else
                    {
                        wsprintf(str, FORMAT_LABEL_TYPE,pCDTitle->szTitle, pCDTitle->szArtist);
                    }

                    title = AddNameToTree(hDlg, NULL, str, parent, TVI_SORT, pCDTitle, CDINFO_DISC, 0, CDCASE_IMAGE);

                    if (!pCDTitle->fDownLoading)
                    {
                        AddTracksToTree(hDlg, pCDTitle, title);

                        if (pCDTitle->fAlbumExpanded)
                        {
                            TreeView_Expand(hTree, title, TVE_EXPAND);
                        }

                    }
                }
                else
                {
                    TCHAR *szCurrentArtist = pCDTitle->szArtist;
                    while(*szCurrentArtist != TEXT('\0') && (*szCurrentArtist == TEXT(' ') || *szCurrentArtist == TEXT('\t')))
                    {
                        szCurrentArtist++;
                    }

                    if (lstrcmp(szThisArtist, szCurrentArtist))     // New Artist?
                    {
                        if (fExpandArtist)
                        {
                            TreeView_Expand(hTree, hArtist, TVE_EXPAND);
                        }

                        szThisArtist = szCurrentArtist;
                        hArtist = AddNameToTree(hDlg, NULL, szThisArtist, parent, NULL, NULL, CDINFO_ARTIST, 0, CDCOLLECTION_IMAGE);

                        fExpandArtist = pCDTitle->fArtistExpanded;
                    }

                    if (pCDTitle->fDownLoading)
                    {
                        title = AddNameToTree(hDlg, NULL, szDownLoading, hArtist, TVI_SORT, pCDTitle, CDINFO_TITLE, 0, CDCASE_IMAGE);
                    }
                    else
                    {
                        title = AddNameToTree(hDlg, NULL, pCDTitle->szTitle, hArtist, TVI_SORT, pCDTitle, CDINFO_TITLE, 0, CDCASE_IMAGE);
                        AddTracksToTree(hDlg, pCDTitle, title);

                        if (pCDTitle->fAlbumExpanded)
                        {
                            TreeView_Expand(hTree, title, TVE_EXPAND);
                        }
                    }
                }

                pCDTitle = pCDTitle->pNext;

                while (pCDTitle && pCDTitle->fRemove)   // Skip any titles that have been removed
                {
                    pCDTitle = pCDTitle->pNext;
                }
            }

            if (fByArtist && fExpandArtist)
            {
                TreeView_Expand(hTree, hArtist, TVE_EXPAND);
            }

            if (m_fAlbumsExpanded)
            {
                TreeView_Expand(hTree, parent, TVE_EXPAND);
            }
        }
    }
}


STDMETHODIMP_(void) CCDOpt::DumpRecurseTree(HWND hTree, HTREEITEM hItem)
{
    TV_ITEM item;

    if (hItem)
    {
        DumpRecurseTree(hTree, TreeView_GetChild(hTree, hItem));            // Kill Kids
        DumpRecurseTree(hTree, TreeView_GetNextSibling(hTree, hItem));      // Kill Sibs

        memset(&item,0,sizeof(item));                                       // Kill it.
        item.mask = TVIF_PARAM;
        item.hItem = hItem;
        item.lParam = NULL;

        if (TreeView_GetItem(hTree,&item))
        {
            if (item.lParam)
            {
                LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

                delete pCDInfo;
            }

        }

        TreeView_DeleteItem(hTree, hItem);
    }
}

STDMETHODIMP_(void) CCDOpt::DumpMixerTree(HWND hDlg)
{
    HWND    hTree = GetDlgItem(hDlg, IDC_CDTREE);

    SetWindowRedraw(hTree,FALSE);
    DumpRecurseTree(hTree, TreeView_GetRoot(hTree));
    SetWindowRedraw(hTree,TRUE);
}


STDMETHODIMP_(LPCDTREEINFO) CCDOpt::NewCDTreeInfo(LPCDTITLE pCDTitle, LPCDUNIT pCDUnit, DWORD fdwType, DWORD dwTrack)
{
    LPCDTREEINFO pCDInfo = new(CDTREEINFO);

    if (pCDInfo)
    {
        pCDInfo->pCDTitle = pCDTitle;
        pCDInfo->fdwType = fdwType;
        pCDInfo->dwTrack = dwTrack;
        pCDInfo->pCDUnit = pCDUnit;
    }

    return(pCDInfo);
}





STDMETHODIMP_(BOOL) CCDOpt::InitPlayLists(HWND hDlg, LPCDDATA pCDData)
{
    BOOL fResult = TRUE;

    if (m_pCDCopy && pCDData)
    {
        int cxMiniIcon = (int)GetSystemMetrics(SM_CXSMICON);
        int cyMiniIcon = (int)GetSystemMetrics(SM_CYSMICON);

        m_hImageList = ImageList_Create(cxMiniIcon,cyMiniIcon, TRUE, 6, 4);

        if (m_hImageList == NULL)
        {
            fResult = FALSE;
        }
        else
        {
            HICON hIcon;
            HWND hTree =  GetDlgItem(hDlg, IDC_CDTREE);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_SMALLCD), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_CDSTACK), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_NODISC), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_TITLECLOSED), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_TITLEOPEN), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_CDCOLLECTION), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_SONG), IMAGE_ICON, cxMiniIcon, cyMiniIcon, LR_DEFAULTCOLOR);
            ImageList_AddIcon(m_hImageList, hIcon);
            DestroyIcon(hIcon);

            TreeView_SetImageList(hTree, m_hImageList, TVSIL_NORMAL);

            EnableWindow(GetDlgItem(hDlg, IDC_EDITPLAYLIST), FALSE);

            CheckDlgButton(hDlg, IDC_BYARTIST, m_pCDCopy->pCDData->fByArtist);

            UpdateTitleTree(hDlg, pCDData);
        }
    }

    return fResult;
}

STDMETHODIMP_(void) CCDOpt::ToggleByArtist(HWND hDlg, LPCDDATA pCDData)
{
    if (m_pCDCopy)
    {
        HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);

        DumpMixerTree(hDlg);

        SetWindowRedraw(hTree,FALSE);
        TreeView_DeleteAllItems(hTree);
        SetWindowRedraw(hTree,TRUE);

        m_pCDCopy->pCDData->fByArtist = Button_GetCheck(GetDlgItem(hDlg, IDC_BYARTIST));

        UpdateTitleTree(hDlg, pCDData);
    }
}

STDMETHODIMP_(void) CCDOpt::TreeItemMenu(HWND hDlg)
{
    DWORD           dwPos;
    POINT           pt;
    TV_HITTESTINFO  tvHit;
    HMENU           hMenu;
    HMENU           hPopup;
    TV_ITEM         item;
    int             mCmd;
    HWND            hTree = GetDlgItem(hDlg, IDC_CDTREE);
    TCHAR           szExpand[64];

    //dont bring up a menu unless click is on the item.
    dwPos = GetMessagePos();
    pt.x = GET_X_LPARAM(dwPos);
    pt.y = GET_Y_LPARAM(dwPos);

    tvHit.pt = pt;
    ScreenToClient(hTree, &tvHit.pt);
    item.hItem = TreeView_HitTest(hTree, &tvHit);

    if (item.hItem && (hMenu = LoadMenu(m_hInst, MAKEINTRESOURCE(IDR_TITLEMENU))))
    {
        LPCDTREEINFO pCDInfo;
        HTREEITEM hKids = NULL;

        hPopup = GetSubMenu(hMenu, 0);

        item.mask = TVIF_STATE | TVIF_HANDLE | TVIF_CHILDREN | TVIF_PARAM;
        TreeView_GetItem(hTree, &item);

        pCDInfo = (LPCDTREEINFO) item.lParam;

        if (item.state & TVIS_EXPANDED)
        {
            LoadString( m_hInst, IDS_COLLAPSE, szExpand, sizeof( szExpand )/sizeof(TCHAR) );
            ModifyMenu(hPopup, ID_EXPAND, MF_BYCOMMAND | MF_STRING, ID_EXPAND, szExpand);
        }

        hKids = TreeView_GetChild(hTree, item.hItem);

        if (hKids == NULL || item.cChildren == 0)
        {
            EnableMenuItem(hPopup, ID_EXPAND, MF_GRAYED | MF_BYCOMMAND);
        }

        if (pCDInfo->pCDTitle == NULL)
        {
            if (pCDInfo->fdwType == (DWORD)CDINFO_CDROM && pCDInfo->pCDUnit && pCDInfo->pCDUnit->dwTitleID != (DWORD)CDTITLE_NODISC)
            {
                TCHAR szCreate[64];
                LoadString( m_hInst, IDS_CREATEPLAYLIST, szCreate, sizeof( szCreate )/sizeof(TCHAR) );
                ModifyMenu(hPopup, IDC_EDITPLAYLIST, MF_BYCOMMAND | MF_STRING, IDC_EDITPLAYLIST, szCreate);
            }
            else
            {
                EnableMenuItem(hPopup, ID_DOWNLOADTITLE, MF_GRAYED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDC_EDITPLAYLIST, MF_GRAYED | MF_BYCOMMAND);
            }

            RemoveMenu(hPopup, ID_EDITTITLENAME, MF_BYCOMMAND);
            RemoveMenu(hPopup, ID_EDITTRACKNAME, MF_BYCOMMAND);
            RemoveMenu(hPopup, ID_DELETETITLE, MF_BYCOMMAND);

            if (pCDInfo->fdwType != (DWORD)CDINFO_ARTIST)
            {
                RemoveMenu(hPopup, ID_EDITARTISTNAME, MF_BYCOMMAND);
            }
        }
        else
        {
            RemoveMenu(hPopup, ID_EDITARTISTNAME, MF_BYCOMMAND);

           if (pCDInfo->pCDTitle->fDownLoading)
            {
                EnableMenuItem(hPopup, ID_DOWNLOADTITLE, MF_GRAYED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDC_EDITPLAYLIST, MF_GRAYED | MF_BYCOMMAND);
            }

            if (!(pCDInfo->fdwType & (DWORD)CDINFO_DISC) && (pCDInfo->fdwType != (DWORD)CDINFO_CDROM))
            {
                EnableMenuItem(hPopup, ID_DOWNLOADTITLE, MF_GRAYED | MF_BYCOMMAND);
            }
            else
            {
                TCHAR *szTitleQuery = pCDInfo->pCDTitle->szTitleQuery;

                if (szTitleQuery)
                {
                    while (*szTitleQuery != TEXT('\0') && (*szTitleQuery == TEXT(' ') || *szTitleQuery == TEXT('\t')))
                    {
                        szTitleQuery++;
                    }

                    if (*szTitleQuery == TEXT('\0'))
                    {
                        EnableMenuItem(hPopup, ID_DOWNLOADTITLE, MF_GRAYED | MF_BYCOMMAND);
                    }
                }
                else
                {
                    EnableMenuItem(hPopup, ID_DOWNLOADTITLE, MF_GRAYED | MF_BYCOMMAND);
                }
            }

            if (pCDInfo->fdwType == (DWORD)CDINFO_TITLE)
            {
                RemoveMenu(hPopup, ID_EDITTRACKNAME, MF_BYCOMMAND);
            }
            else if (pCDInfo->fdwType == (DWORD)CDINFO_TRACK)
            {
                RemoveMenu(hPopup, ID_EDITTITLENAME, MF_BYCOMMAND);
                RemoveMenu(hPopup, ID_DELETETITLE, MF_BYCOMMAND);
            }
            else
            {
                RemoveMenu(hPopup, ID_EDITTITLENAME, MF_BYCOMMAND);
                RemoveMenu(hPopup, ID_EDITTRACKNAME, MF_BYCOMMAND);
            }
        }

        if (m_pCDCopy->pfnDownloadTitle == NULL)
        {
            EnableMenuItem(hPopup, ID_DOWNLOADTITLE, MF_GRAYED | MF_BYCOMMAND);
        }

        TreeView_SelectItem(hTree, item.hItem);

        mCmd = TrackPopupMenuEx(hPopup, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_TOPALIGN, pt.x, pt.y, hDlg, NULL);

        DestroyMenu(hMenu);
        FORWARD_WM_COMMAND(hDlg, mCmd, 0, 0, SendMessage);
    }
}



STDMETHODIMP_(void) CCDOpt::ToggleExpand(HWND hDlg)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem = TreeView_GetSelection(hTree);
    TV_ITEM     item;

    if (hItem)
    {
        item.mask = TVIF_PARAM;
        item.hItem = hItem;
        TreeView_GetItem(hTree, &item);
    }

    TreeView_Expand(hTree, hItem, TVE_TOGGLE);
}


STDMETHODIMP_(void) CCDOpt::EditTreeItem(HWND hDlg)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem = TreeView_GetSelection(hTree);
    TV_ITEM     item;

    if (hItem)
    {
        item.mask = TVIF_PARAM;
        item.hItem = hItem;
        TreeView_GetItem(hTree, &item);
    }

    TreeView_EditLabel(hTree, hItem);
}

STDMETHODIMP_(void) CCDOpt::RefreshTreeItem(HWND hDlg, HTREEITEM hItem)
{
    HWND    hTree = GetDlgItem(hDlg, IDC_CDTREE);
    TV_ITEM item;
    HTREEITEM hKid;
    TCHAR str[MAXLABEL];

    memset(&item, 0, sizeof(item));
    item.mask = TVIF_PARAM;
    item.hItem = hItem;

    if (TreeView_GetItem(hTree, &item))
    {
        LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;
        LPCDUNIT pCDUnit = pCDInfo->pCDUnit;

        if (pCDUnit)   // This is a CD Drive, lets set the name
        {
            TCHAR szDownLoading[CDSTR];

            LoadString( m_hInst, IDS_DOWNLOADING, szDownLoading, sizeof( szDownLoading )/sizeof(TCHAR) );

            if (pCDInfo->pCDTitle == NULL)
            {
                TCHAR szUnknown[CDSTR];

                LoadString( m_hInst, IDS_UNKNOWNTITLE, szUnknown, sizeof( szUnknown )/sizeof(TCHAR) );
                wsprintf(str, FORMAT_LET_NAME, pCDInfo->pCDUnit->szDriveName, szUnknown);
            }
            else if (pCDInfo->pCDTitle->fDownLoading)
            {
                wsprintf(str, FORMAT_LET_NAME, pCDInfo->pCDUnit->szDriveName, szDownLoading);
            }
            else
            {
                wsprintf(str, FORMAT_LET_NAME_ARTIST, pCDUnit->szDriveName, pCDInfo->pCDTitle->szTitle, pCDInfo->pCDTitle->szArtist);
            }

        }
        else
        {
            if (!m_pCDCopy->pCDData->fByArtist)
            {
                wsprintf(str, FORMAT_LABEL_TYPE,pCDInfo->pCDTitle->szTitle, pCDInfo->pCDTitle->szArtist);
            }
            else
            {
                wsprintf(str, FORMAT_NAME, pCDInfo->pCDTitle->szTitle);
            }
        }


        memset(&item,0,sizeof(item));
        item.mask = TVIF_TEXT;
        item.hItem = hItem;
        item.pszText = str;

        TreeView_SetItem(hTree,&item);

        hKid = TreeView_GetChild(hTree, hItem);

        if (!hKid)
        {
            AddTracksToTree(hDlg, pCDInfo->pCDTitle, hItem);
        }
        else
        {
            DWORD dwTrack;

            for (dwTrack = 0; dwTrack < pCDInfo->pCDTitle->dwNumTracks && (hKid != NULL) ; dwTrack++)
            {
                wsprintf(str, FORMAT_NAME, pCDInfo->pCDTitle->pTrackTable[dwTrack].szName);

                memset(&item,0,sizeof(item));
                item.mask = TVIF_TEXT;
                item.hItem = hKid;
                item.pszText = str;

                TreeView_SetItem(hTree,&item);

                hKid = TreeView_GetNextSibling(hTree, hKid);
            }
        }
    }
}


STDMETHODIMP_(HTREEITEM) CCDOpt::FindRecurseTree(HWND hDlg, HTREEITEM hItem, LPCDTITLE pCDTitle, BOOL fRefresh, DWORD dwTitleID)
{
    HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
    TV_ITEM     item;
    HTREEITEM   hMatch = NULL;
    if (hItem)
    {
        hMatch = FindRecurseTree(hDlg, TreeView_GetChild(hTree, hItem), pCDTitle, fRefresh, dwTitleID);     // Search Kids

        if (!hMatch)                                                                                        // Search Sibs
        {
            hMatch = FindRecurseTree(hDlg, TreeView_GetNextSibling(hTree, hItem), pCDTitle, fRefresh, dwTitleID);
        }

        if (!hMatch)                                                                                        // Search IT
        {
            memset(&item,0,sizeof(item));
            item.mask = TVIF_PARAM;
            item.hItem = hItem;
            item.lParam = NULL;

            if (TreeView_GetItem(hTree,&item))
            {
                if (item.lParam)
                {
                    LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

                    if (pCDTitle && (pCDInfo->pCDTitle == pCDTitle) && (pCDInfo->fdwType & (DWORD)CDINFO_DISC || pCDInfo->fdwType == (DWORD)CDINFO_CDROM))
                    {
                        hMatch = hItem;

                        if (fRefresh)
                        {
                            RefreshTreeItem(hDlg, hMatch);

                            hMatch = NULL;  // Find all of them, not just the first
                        }
                    }
                    else if (fRefresh && pCDInfo->pCDUnit && pCDInfo->fdwType == (DWORD)CDINFO_CDROM)  // If doing a refresh and this is a drive node with NO disc
                    {
                        if (pCDInfo->pCDUnit->dwTitleID == dwTitleID)     // Cool, a new disc has shown up.
                        {
                            pCDInfo->pCDTitle = pCDTitle;
                            pCDInfo->dwTrack = 0;
                            pCDInfo->fdwType = CDINFO_CDROM;

                            memset(&item,0,sizeof(item));
                            item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                            item.hItem = hItem;
                            item.iImage = item.iSelectedImage = (int) CD_IMAGE;

                            TreeView_SetItem(hTree, &item);

                            RefreshTreeItem(hDlg, hItem);

                        }
                    }
                }
            }
        }
    }

    return(hMatch);
}


STDMETHODIMP_(HTREEITEM) CCDOpt::FindTitleInDBTree(HWND hDlg, LPCDTITLE pCDTitle)
{
    return(FindRecurseTree(hDlg, TreeView_GetRoot(GetDlgItem(hDlg, IDC_CDTREE)), pCDTitle, FALSE, 0));
}


STDMETHODIMP_(void) CCDOpt::RefreshTree(HWND hDlg, LPCDTITLE pCDTitle, DWORD dwTitleID)
{
    FindRecurseTree(hDlg, TreeView_GetRoot(GetDlgItem(hDlg, IDC_CDTREE)), pCDTitle, TRUE, dwTitleID);
}


STDMETHODIMP_(BOOL) CCDOpt::DeleteTitleItem(HWND hDlg, HTREEITEM hItem)
{
    HWND    hTree = GetDlgItem(hDlg, IDC_CDTREE);
    TV_ITEM item;
    BOOL    fResult = FALSE;

    item.mask = TVIF_PARAM;
    item.hItem = hItem;

    if (TreeView_GetItem(hTree, &item))
    {
        LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

        if (pCDInfo)
        {
            if (!(pCDInfo->fdwType & (DWORD)CDINFO_DISC) && (pCDInfo->fdwType != (DWORD)CDINFO_CDROM))
            {
                MessageBeep(MB_ICONASTERISK);
            }
            else if (pCDInfo->pCDTitle)
            {
                HTREEITEM hParent = TreeView_GetParent(hTree, hItem);

                pCDInfo->pCDTitle->fRemove = TRUE;

                if (pCDInfo->fdwType == (DWORD)CDINFO_CDROM)       // Title From CDROM
                {
                    TCHAR       szUnknown[CDSTR];
                    TCHAR       str[MAXLABEL];
                    LPCDTITLE   pOldTitle = pCDInfo->pCDTitle;

                    pCDInfo->pCDTitle = NULL;

                    LoadString( m_hInst, IDS_UNKNOWNTITLE, szUnknown, sizeof( szUnknown )/sizeof(TCHAR) );
                    wsprintf(str, FORMAT_LET_NAME, pCDInfo->pCDUnit->szDriveName, szUnknown);
					pCDInfo->pCDUnit->fChanged = TRUE;							// Let the UI know...

                    SetWindowRedraw(hTree,FALSE);
                    DumpRecurseTree(hTree, TreeView_GetChild(hTree, hItem));    // Kill off kid and all siblings
                    SetWindowRedraw(hTree,TRUE);

                    item.mask = TVIF_TEXT | TVIF_CHILDREN;
                    item.hItem = hItem;
                    item.pszText = str;
                    item.cChildren = 0;

                    TreeView_SetItem(hTree, &item);

                    hItem = FindTitleInDBTree(hDlg, pOldTitle);          // This disc also exist in the database branch of tree

                    if (hItem)
                    {
                        DeleteTitleItem(hDlg, hItem);
                    }
                    else
                    {
                        ToggleApplyButton(hDlg);
                    }

                    fResult = TRUE;
                }
                else
                {
                    if (TreeView_DeleteItem(hTree, hItem))
                    {
                        LPCDTITLE pOldTitle = pCDInfo->pCDTitle;

                        delete pCDInfo;

                        ToggleApplyButton(hDlg);
                        fResult = TRUE;

                        if (hParent)
                        {
                            item.mask = TVIF_PARAM | TVIF_CHILDREN;
                            item.hItem = hParent;

                            if (TreeView_GetItem(hTree, &item))
                            {
                                pCDInfo = (LPCDTREEINFO) item.lParam;

                                if (pCDInfo && pCDInfo->fdwType == (DWORD)CDINFO_ARTIST && item.cChildren == 0)
                                {
                                    if (TreeView_DeleteItem(hTree, hParent))
                                    {
                                        delete pCDInfo;
                                    }
                                }
                            }
                        }

                        if (pOldTitle)
                        {
                            hItem = FindTitleInDBTree(hDlg, pOldTitle);          // This disc also exist in the database branch of tree

                            if (hItem)
                            {
                                DeleteTitleItem(hDlg, hItem);
                            }
                        }
                    }
                }
            }
        }
    }

    return(fResult);
}


STDMETHODIMP_(void) CCDOpt::DeleteTitle(HWND hDlg)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem = TreeView_GetSelection(hTree);

    if (hItem)
    {
        if (DeleteTitleItem(hDlg, hItem))
        {
            NMHDR nmh;

            nmh.code = TVN_SELCHANGED;          // Forcing controls to update
            PlayListNotify(hDlg, &nmh);
        }
    }
}




STDMETHODIMP_(void) CCDOpt::DownloadTitle(HWND hDlg)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem = TreeView_GetSelection(hTree);
    TV_ITEM     item;

    item.mask = TVIF_PARAM;
    item.hItem = hItem;

    if (TreeView_GetItem(hTree, &item))
    {
        LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

        if (pCDInfo && m_pCDCopy->pfnDownloadTitle)
        {
            if ((pCDInfo->fdwType & (DWORD)CDINFO_DISC) || (pCDInfo->fdwType == (DWORD)CDINFO_CDROM))
            {
                if (pCDInfo->pCDTitle)
                {
                    m_pCDCopy->pfnDownloadTitle(pCDInfo->pCDTitle, m_pCDCopy->lParam, hDlg);

                    pCDInfo->pCDTitle->fChanged = TRUE;

                    RefreshTree(hDlg, pCDInfo->pCDTitle, pCDInfo->pCDTitle->dwTitleID);
                }
                else if (pCDInfo->fdwType == (DWORD)CDINFO_CDROM)   // Create a new one from the internet (only for CDROM entries)
                {
                    LPCDTITLE pNewTitle = NULL;

                    if (SUCCEEDED(m_pCDData->CreateTitle(&pNewTitle, pCDInfo->pCDUnit->dwTitleID, pCDInfo->pCDUnit->dwNumTracks, 0)))
                    {
                        m_pCDCopy->pfnDownloadTitle(pNewTitle, m_pCDCopy->lParam, hDlg);

                        m_pCDData->UnlockTitle(pNewTitle, FALSE);	// Get rid of my temp title

						if (SUCCEEDED(m_pCDData->LockTitle(&pNewTitle, pCDInfo->pCDUnit->dwTitleID)))
						{
                            LPCDTITLE pCDTitle = m_pCDData->GetTitleList();

                            while (pCDTitle)
                            {
                                if(pCDTitle != pNewTitle && pCDTitle->dwTitleID == pNewTitle->dwTitleID && pCDTitle->fRemove)
                                {
                                    pCDTitle->dwTitleID = DWORD(-1);
                                    break;
                                }

                                pCDTitle = pCDTitle->pNext;
                            }

						    RefreshTree(hDlg, pNewTitle, pNewTitle->dwTitleID);
						    m_pCDData->UnlockTitle(pNewTitle, FALSE);
                        }
                    }
                }
            }
        }
    }
}



STDMETHODIMP_(void) CCDOpt::EditCurrentTitle(HWND hDlg)
{
    HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem = TreeView_GetSelection(hTree);
    TV_ITEM     item;

    item.mask = TVIF_PARAM;
    item.hItem = hItem;

    if (TreeView_GetItem(hTree, &item))
    {
        LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

        if (pCDInfo)
        {
            LPCDTITLE pCDTitle = pCDInfo->pCDTitle;
            BOOL fCreated = FALSE;

            if (pCDTitle == NULL)            // No data, this is a create call.
            {
                if (pCDInfo->pCDUnit)        // Can only do this for CD units, we need an ID
                {
                   if (SUCCEEDED(m_pCDData->CreateTitle(&pCDTitle, pCDInfo->pCDUnit->dwTitleID, pCDInfo->pCDUnit->dwNumTracks, 0)))
                   {
                        TCHAR szTrack[CDSTR];

                        LoadString(m_hInst, IDS_NEWARTIST, pCDTitle->szArtist, sizeof (pCDTitle->szArtist)/sizeof(TCHAR));
                        LoadString(m_hInst, IDS_NEWTITLE, pCDTitle->szTitle, sizeof (pCDTitle->szTitle)/sizeof(TCHAR));
                        LoadString(m_hInst, IDS_TRACK, szTrack, sizeof (szTrack)/sizeof(TCHAR));

                        m_pCDData->SetTitleQuery(pCDTitle, pCDInfo->pCDUnit->szNetQuery);

                        pCDTitle->pPlayList = new(WORD[pCDTitle->dwNumTracks]);

                        if (pCDTitle->pPlayList)
                        {
                            LPWORD pNum = pCDTitle->pPlayList;

                            pCDTitle->dwNumPlay = pCDTitle->dwNumTracks;
                            for (DWORD dwTrack = 0; dwTrack < pCDTitle->dwNumTracks; dwTrack++, pNum++)
                            {
                                wsprintf(pCDTitle->pTrackTable[dwTrack].szName, FORMAT_NEW_TRACK, szTrack, dwTrack + 1);
                                *pNum = (WORD) dwTrack;
                            }

                            fCreated = TRUE;
                        }
                        else
                        {
                            m_pCDData->UnlockTitle(pCDTitle, FALSE);
                            pCDTitle = NULL;
                        }
                    }
                }
            }

            if (pCDTitle)
            {
                if (ListEditDialog(hDlg, pCDTitle))
                {
                    pCDTitle->fChanged = TRUE;

                    RefreshTree(hDlg, pCDTitle, pCDTitle->dwTitleID);

                    if (fCreated)       // Save in DB
                    {
                        pCDInfo->pCDTitle = pCDTitle;               // Lets reference the new title in the tree
                        m_pCDData->UnlockTitle(pCDTitle, TRUE);     // Lets save it and put it in the tree (the pointer is still valid until tree is dumped)
                    }

                    NotifyTitleChange(pCDTitle);

                    HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);

                    DumpMixerTree(hDlg);

                    SetWindowRedraw(hTree,FALSE);
                    TreeView_DeleteAllItems(hTree);
                    SetWindowRedraw(hTree,TRUE);

                    UpdateTitleTree(hDlg, m_pCDData);
                }
                else if (fCreated)      // Dump it, they didn't do anything
                {
                    m_pCDData->UnlockTitle(pCDTitle, FALSE);
                }
            }
        }
    }
}


STDMETHODIMP_(void) CCDOpt::DownLoadCompletion(DWORD dwNumIDs, LPDWORD pdwIDs)
{
    UpdateBatched(m_hTitleWnd);

    if (m_hList && m_pCDData && pdwIDs && dwNumIDs)
    {
        LPCDTITLE pCDTitleList = m_pCDData->GetTitleList();
        HWND hDlg = m_hList;
        DWORD dwID;
        LPDWORD pID = pdwIDs;
        NMHDR mhdr;

        for (dwID = 0; dwID < dwNumIDs; dwID++, pID++)      // Look at each ID
        {
            LPCDUNIT pCDUnit = m_pCDCopy->pCDUnitList;      // Only support background downloading of disc in the Drives

            while (pCDUnit)                                 // So, look at each drive for this ID
            {
                if (pCDUnit->dwTitleID == *pID)             // This drive has a matching ID
                {
                    LPCDTITLE pCDTitle = pCDTitleList;      // Lets find the title for this CD

                    while (pCDTitle)
                    {
                        if (pCDTitle->dwTitleID == *pID)
                        {
                            break;
                        }
                        pCDTitle = pCDTitle->pNext;
                    }

                    if (pCDTitle)
                    {
                        pCDTitle->fDownLoading = pCDUnit->fDownLoading = FALSE;
                    }

                    RefreshTree(hDlg, pCDTitle, *pID);

                    mhdr.code = TVN_SELCHANGED;
                    PlayListNotify(hDlg, &mhdr);
                }

                pCDUnit = pCDUnit->pNext;
            }
        }
    }
}


STDMETHODIMP_(void) CCDOpt::DiscChanged(LPCDUNIT pCDUnit)
{
    if (m_hList && m_pCDData)
    {
        HWND        hDlg = m_hList;
        HWND        hTree = GetDlgItem(hDlg, IDC_CDTREE);
        HTREEITEM   hItem;
        LPCDTITLE   pCDTitleList = m_pCDData->GetTitleList();
        NMHDR mhdr;

        hItem = TreeView_GetRoot(hTree);

        if (hItem)
        {
            hItem = TreeView_GetChild(hTree,hItem);

            while(hItem)
            {
                TV_ITEM item;

                item.mask = TVIF_PARAM;
                item.hItem = hItem;

                if (TreeView_GetItem(hTree, &item))
                {
                    LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

                    if (pCDInfo && pCDInfo->pCDUnit)
                    {
                        if (pCDInfo->pCDUnit == pCDUnit)
                        {
                            if (pCDInfo->pCDUnit->dwTitleID == CDTITLE_NODISC)
                            {
                                TCHAR   szNoDisc[CDSTR];
                                TCHAR   str[MAXLABEL];

                                SetWindowRedraw(hTree,FALSE);
                                DumpRecurseTree(hTree, TreeView_GetChild(hTree, hItem));    // Kill off kids
                                SetWindowRedraw(hTree,TRUE);

                                TreeView_Expand(hTree, hItem, TVE_COLLAPSE | TVE_COLLAPSERESET);

                                pCDInfo->pCDTitle = NULL;
                                pCDInfo->dwTrack = 0;
                                pCDInfo->fdwType = CDINFO_CDROM;

                                LoadString( m_hInst, IDS_NODISC, szNoDisc, sizeof( szNoDisc )/sizeof(TCHAR) );

                                wsprintf(str, FORMAT_LET_NAME, pCDUnit->szDriveName, szNoDisc);

	                            item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN ;
                                item.iImage = item.iSelectedImage = (int) NOCD_IMAGE;
	                            item.pszText = str;
                                item.cChildren = 0;

                                TreeView_SetItem(hTree, &item);

                                hItem = TreeView_GetSelection(hTree);
                                TreeView_SelectItem(hTree, NULL);
                                TreeView_SelectItem(hTree, hItem);
                            }
                            else
                            {
                                LPCDTITLE pCDTitle = pCDTitleList;      // Lets find the title for this CD

                                while (pCDTitle)
                                {
                                    if (pCDTitle->dwTitleID == pCDInfo->pCDUnit->dwTitleID && !pCDTitle->fRemove)
                                    {
                                        break;
                                    }
                                    pCDTitle = pCDTitle->pNext;
                                }

                                if (pCDTitle)
                                {
                                    pCDInfo->pCDTitle = pCDTitle;
                                    pCDInfo->dwTrack = pCDTitle->dwNumTracks;
                                    pCDInfo->fdwType = CDINFO_CDROM;

                                    pCDTitle->fDownLoading = pCDUnit->fDownLoading;
 	                                item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN;
                                    item.cChildren = pCDTitle->dwNumTracks;
                                    item.iImage = item.iSelectedImage = (int) CD_IMAGE;
                                    TreeView_SetItem(hTree, &item);

                                    RefreshTree(hDlg, pCDTitle, pCDTitle->dwTitleID);
                                }
                                else
                                {
                                    TCHAR   szUnknown[CDSTR];
                                    TCHAR   szDownLoading[CDSTR];
                                    TCHAR   str[MAXLABEL];

                                    pCDInfo->pCDTitle = NULL;
                                    pCDInfo->dwTrack = pCDUnit->dwNumTracks;
                                    pCDInfo->fdwType = CDINFO_CDROM;

                                    if (pCDUnit->fDownLoading)
                                    {
                                        LoadString( m_hInst, IDS_DOWNLOADING, szDownLoading, sizeof( szDownLoading )/sizeof(TCHAR) );
                                        wsprintf(str, FORMAT_NAME, szDownLoading);
                                    }
                                    else
                                    {
                                        LoadString( m_hInst, IDS_UNKNOWNTITLE, szUnknown, sizeof( szUnknown )/sizeof(TCHAR) );
                                        wsprintf(str, FORMAT_LET_NAME, pCDInfo->pCDUnit->szDriveName, szUnknown);
                                    }

	                                item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE ;
                                    item.iImage = item.iSelectedImage = (int) CD_IMAGE;
	                                item.pszText = str;

                                    TreeView_SetItem(hTree, &item);
                                }

                                mhdr.code = TVN_SELCHANGED;
                                PlayListNotify(hDlg, &mhdr);
                            }

                            break;
                        }
                    }
                }

                hItem = TreeView_GetNextSibling(hTree,hItem);
            }
        }
    }
}


STDMETHODIMP_(void) CCDOpt::NotifyTitleChange(LPCDTITLE pCDTitle)
{
    LPCDUNIT pCDUnit = m_pCDCopy->pCDUnitList;

    while(pCDUnit)
    {
        if (pCDUnit->dwTitleID == pCDTitle->dwTitleID && m_pCDCopy->pfnOptionsCallback)
        {
            pCDUnit->fChanged = TRUE;
            m_pCDCopy->pfnOptionsCallback(m_pCDCopy);
            pCDUnit->fChanged = FALSE;
        }

        pCDUnit = pCDUnit->pNext;
    }
}


STDMETHODIMP_(void) CCDOpt::ArtistNameChange(HWND hDlg, HTREEITEM hItem, TCHAR *szName)
{
    HWND        hTree =  GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hKid = TreeView_GetChild(hTree, hItem);
    TV_ITEM     item;

    while (hKid)
    {
        item.mask = TVIF_PARAM;
        item.hItem = hKid;

        if (TreeView_GetItem(hTree, &item))
        {
            LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

            if (pCDInfo)
            {
                LPCDTITLE pCDTitle = pCDInfo->pCDTitle;

                if (pCDTitle)
                {
                    pCDTitle->fChanged = TRUE;
                    lstrcpy(pCDTitle->szArtist, szName);
                    NotifyTitleChange(pCDTitle);
                }
            }
        }

        hKid = TreeView_GetNextSibling(hTree, hKid);
    }
}


STDMETHODIMP_(void) CCDOpt::EndEditReturn(HWND hDlg)
{
    HWND        hTree =  GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hItem = TreeView_GetSelection(hTree);
    TV_ITEM     item;

    item.mask = TVIF_PARAM;
    item.hItem = hItem;

    if (TreeView_GetItem(hTree, &item))
    {
        LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

        if (pCDInfo->fdwType == (DWORD)CDINFO_TRACK)
        {
            HTREEITEM hSib = TreeView_GetNextSibling(hTree, hItem);

            if (hSib == NULL)
            {
                HTREEITEM hPrevSib;

                hPrevSib = TreeView_GetPrevSibling(hTree, hItem);
                hSib = hPrevSib;

                while (hPrevSib)
                {
                    hPrevSib = TreeView_GetPrevSibling(hTree, hPrevSib);

                    if (hPrevSib != NULL)
                    {
                        hSib = hPrevSib;
                    }
                }
            }

            if (hSib)
            {
                TreeView_SelectItem(hTree, hSib);
                TreeView_EnsureVisible(hTree, hSib);
                TreeView_EditLabel(hTree, hSib);
            }
        }
    }
}



LRESULT CALLBACK CCDOpt::SubProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CCDOpt *pCDOpt = (CCDOpt *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    LRESULT lResult = 0;

    if (pCDOpt)
    {
        switch (msg)
        {
            case WM_GETDLGCODE:
            {
                LPMSG pMsg = (LPMSG) lParam;

                if (pMsg)
                {
                    if (wParam == VK_RETURN)
                    {
                        pCDOpt->m_fEditReturn = TRUE;
                    }
                }

                return(DLGC_WANTMESSAGE | CallWindowProc((WNDPROC) pCDOpt->m_pfnSubProc, hWnd, msg, wParam, lParam));
            }
            break;
        }

        lResult = CallWindowProc((WNDPROC) pCDOpt->m_pfnSubProc, hWnd, msg, wParam, lParam);
    }

    return (lResult);
}



STDMETHODIMP_(void) CCDOpt::SubClassDlg(HWND hDlg)
{
    if (m_pfnSubProc == NULL)
    {
        HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
        HWND hEdit = TreeView_GetEditControl(hTree);

        if (hEdit != NULL)
        {
            SetWindowLongPtr(hEdit,GWLP_USERDATA,(LONG_PTR) this);
            m_pfnSubProc = (WNDPROC)SetWindowLongPtr(hEdit,GWLP_WNDPROC,(LONG_PTR) SubProc);
        }
    }
}


STDMETHODIMP_(void) CCDOpt::UnSubClassDlg(HWND hDlg)
{
    if (m_pfnSubProc != NULL)
    {
        HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
        HWND hEdit = TreeView_GetEditControl(hTree);

        if (hEdit)
        {
            SetWindowLongPtr(hEdit,GWLP_WNDPROC,(LONG_PTR) m_pfnSubProc);
            m_pfnSubProc = NULL;
        }
    }
}


STDMETHODIMP_(void) CCDOpt::SetArtistExpand(HWND hDlg, HTREEITEM hItem, BOOL fExpand)
{
    HWND        hTree =  GetDlgItem(hDlg, IDC_CDTREE);
    HTREEITEM   hKid = TreeView_GetChild(hTree, hItem);
    TV_ITEM     item;

    while (hKid)
    {
        item.mask = TVIF_PARAM;
        item.hItem = hKid;

        if (TreeView_GetItem(hTree, &item))
        {
            LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

            if (pCDInfo)
            {
                LPCDTITLE pCDTitle = pCDInfo->pCDTitle;

                if (pCDTitle)
                {
                    pCDTitle->fArtistExpanded = fExpand;
                }
            }
        }

        hKid = TreeView_GetNextSibling(hTree, hKid);
    }
}




STDMETHODIMP_(BOOL) CCDOpt::PlayListNotify(HWND hDlg, LPNMHDR pnmh)
{
    BOOL fReturnVal = TRUE;

    switch (pnmh->code)
    {
        case NM_RCLICK:
        {
            TreeItemMenu(hDlg);

            fReturnVal = TRUE;
        }
        break;

        case TVN_KEYDOWN:
        {
            TV_KEYDOWN * pkd = (TV_KEYDOWN *) pnmh;

            switch(pkd->wVKey)
            {
                case VK_DELETE:
                {
                    DeleteTitle(hDlg);
                }
                break;

                case VK_F2:
                {
                    EditTreeItem(hDlg);
                }
                break;

                case VK_F5:
                {
                    if (m_pCDData)
                    {
                        HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);

                        DumpMixerTree(hDlg);

                        SetWindowRedraw(hTree,FALSE);
                        TreeView_DeleteAllItems(hTree);
                        SetWindowRedraw(hTree,TRUE);

                        m_pCDData->PersistTitles();
                        m_pCDData->UnloadTitles();
                        m_pCDData->LoadTitles(hDlg);

                        InitPlayLists(hDlg, m_pCDData);
                    }
                }

                break;
            }
        }
        break;

        case NM_DBLCLK:
        {
            if (pnmh->idFrom == IDC_CDTREE)
            {
                HWND hTree =  GetDlgItem(hDlg, IDC_CDTREE);
                HTREEITEM hItem = TreeView_GetSelection(hTree);
                TV_HITTESTINFO  ht;

                if (hItem)
                {
                    GetCursorPos(&ht.pt);
                    ScreenToClient(hTree, &ht.pt);
                    TreeView_HitTest(hTree, &ht);

                    if ((ht.flags & TVHT_ONITEM) && (TreeView_GetChild(hTree, hItem) == NULL) && IsWindowEnabled(GetDlgItem(hDlg,IDC_EDITPLAYLIST)))
                    {
                        FORWARD_WM_COMMAND(hDlg, IDC_EDITPLAYLIST, 0, 0, PostMessage);
                    }
                }
            }
        }
        break;

        case TVN_SELCHANGED:
        {
            HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
            TV_ITEM item;
            BOOL fEnable = FALSE;

            memset(&item, 0, sizeof(item));

            item.hItem = TreeView_GetSelection(hTree);
            item.mask = TVIF_PARAM;

            if (TreeView_GetItem(hTree, &item))
            {
                LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;
                TCHAR szButton[64];

                LoadString( m_hInst, IDS_EDITPLAYLIST, szButton, sizeof( szButton )/sizeof(TCHAR) );

                if (pCDInfo->pCDTitle == NULL && pCDInfo->fdwType == (DWORD)CDINFO_CDROM && pCDInfo->pCDUnit && pCDInfo->pCDUnit->dwTitleID != (DWORD)CDTITLE_NODISC)
                {
                    LoadString( m_hInst, IDS_CREATEPLAYLIST, szButton, sizeof( szButton )/sizeof(TCHAR) );
                    fEnable = TRUE;
                }
                else if (pCDInfo->pCDTitle && !pCDInfo->pCDTitle->fDownLoading)
                {
                    fEnable = TRUE;
                }

                SetWindowText(GetDlgItem(hDlg, IDC_EDITPLAYLIST), szButton);
            }

            EnableWindow(GetDlgItem(hDlg, IDC_EDITPLAYLIST), fEnable);
        }
        break;

        case TVN_ITEMEXPANDED:
        {
            NM_TREEVIEW * ptv = (NM_TREEVIEW *) pnmh;

            HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
            TV_ITEM item;

            memset(&item,0,sizeof(item));
            item.mask = TVIF_PARAM;
            item.hItem = ptv->itemNew.hItem;

            if (TreeView_GetItem(hTree,&item))
            {
                BOOL fExpanded = (ptv->itemNew.state & TVIS_EXPANDED) ? TRUE : FALSE;

                if (item.lParam)
                {
                    LPCDTREEINFO pCDInfo = (LPCDTREEINFO) item.lParam;

                    if (pCDInfo)
                    {
                        LPCDTITLE pCDTitle = pCDInfo->pCDTitle;

                        if (pCDInfo->fdwType == (DWORD)CDINFO_DRIVES)
                        {
                            m_fDrivesExpanded = fExpanded;
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_ALBUMS)
                        {
                            m_fAlbumsExpanded = fExpanded;
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_CDROM && pCDTitle)
                        {
                            pCDTitle->fDriveExpanded = fExpanded;
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_DISC && pCDTitle)
                        {
                            pCDTitle->fAlbumExpanded = fExpanded;
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_ARTIST)
                        {
                            SetArtistExpand(hDlg, ptv->itemNew.hItem, fExpanded);
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_TITLE && pCDTitle)
                        {
                            pCDTitle->fAlbumExpanded = fExpanded;
                        }
                    }
                }
            }
        }
        break;

        case TVN_ITEMEXPANDING:
        {
            NM_TREEVIEW * ptv = (NM_TREEVIEW *) pnmh;

            HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
            TV_ITEM item;

            memset(&item,0,sizeof(item));
            item.mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE ;
            item.hItem = ptv->itemNew.hItem;

            if (TreeView_GetItem(hTree,&item))
            {
                if ((ptv->itemNew.state & TVIS_EXPANDED) && item.iImage == CDOPEN_IMAGE)
                {
                    item.iImage = item.iSelectedImage = (int) CDCASE_IMAGE;
                }
                else if (!(ptv->itemNew.state & TVIS_EXPANDED) && item.iImage == CDCASE_IMAGE)
                {
                    item.iImage = item.iSelectedImage = (int) CDOPEN_IMAGE;
                }

                TreeView_SetItem(hTree, &item);
            }
        }
        break;

        case TVN_BEGINLABELEDIT:
        {
            TV_DISPINFO * ptv = (TV_DISPINFO *) pnmh;
            LPCDTREEINFO pCDInfo = (LPCDTREEINFO) ptv->item.lParam;
            BOOL fResult = TRUE;

            if (pCDInfo->fdwType & CDINFO_EDIT)
            {
                fResult = FALSE;

                SendMessage( hDlg, DM_SETDEFID, IDC_CDTREE, 0L);
                SubClassDlg(hDlg);
            }

            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR) fResult);
        }
        break;

        case TVN_ENDLABELEDIT:
        {
            TV_DISPINFO * ptv = (TV_DISPINFO *) pnmh;

            if (ptv->item.lParam != NULL)
            {
                LPCDTREEINFO pCDInfo = (LPCDTREEINFO) ptv->item.lParam;
                BOOL fResult = TRUE;

                TCHAR *pStr = ptv->item.pszText;

                if (pStr)
                {
                    while(*pStr != TEXT('\0') && (*pStr == TEXT(' ') || *pStr == TEXT('\t')))  // Unknown artist are null string or whitespace
                    {
                        pStr++;
                    }

                    if (lstrlen(pStr) >= CDSTR)
                    {
                        pStr[CDSTR - 1] = TEXT('\0');
                    }

                    if (*pStr == TEXT('\0'))          // Reject whitespace only responses
                    {
                        fResult = FALSE;
                    }
                    else
                    {
                        TCHAR *pDst = NULL;

                        if (pCDInfo->fdwType == (DWORD)CDINFO_ARTIST)
                        {
                            if (pCDInfo->pCDTitle == NULL)
                            {
                                ArtistNameChange(hDlg, ptv->item.hItem, pStr);
                                pDst = NULL;
                            }
                            else
                            {
                                pDst = pCDInfo->pCDTitle->szArtist;
                            }
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_TITLE)
                        {
                            pDst = pCDInfo->pCDTitle->szTitle;
                        }
                        else if (pCDInfo->fdwType == (DWORD)CDINFO_TRACK)
                        {
                            if (pCDInfo->pCDTitle->pTrackTable && pCDInfo->dwTrack < pCDInfo->pCDTitle->dwNumTracks)
                            {
                                pDst = pCDInfo->pCDTitle->pTrackTable[pCDInfo->dwTrack].szName;
                            }
                        }

                        if (pDst)
                        {
                            pCDInfo->pCDTitle->fChanged = TRUE;
                            lstrcpy(pDst, pStr);

                            RefreshTree(hDlg, pCDInfo->pCDTitle, pCDInfo->pCDTitle->dwTitleID);
                            ToggleApplyButton(hDlg);

                            NotifyTitleChange(pCDInfo->pCDTitle);
                        }
                    }
                }

                UnSubClassDlg(hDlg);

                if (m_fEditReturn)
                {
                    m_fEditReturn = FALSE;
                    EndEditReturn(hDlg);
                }

                SendMessage( hDlg, DM_SETDEFID, IDOK, 0L );
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR) fResult);
            }
        }
        break;

        case PSN_QUERYCANCEL:
        {
            LPCDTITLE pCDTitle = m_pCDData->GetTitleList();

            DumpMixerTree(hDlg);

            while (pCDTitle)
            {
                if (pCDTitle->fChanged || pCDTitle->fRemove)
                {
                    TCHAR szSave[CDSTR];
                    TCHAR szAlert[CDSTR];

                    LoadString( m_hInst, IDS_SAVEPROMPT, szSave, sizeof( szSave )/sizeof(TCHAR) );
                    LoadString( m_hInst, IDS_ALERTTEXT, szAlert, sizeof( szAlert )/sizeof(TCHAR) );

                    if (MessageBox(hDlg, szSave, szAlert, MB_YESNO | MB_ICONWARNING) == IDYES)
                    {
                        m_pCDData->PersistTitles();
                    }
                    break;
                }

                pCDTitle = pCDTitle->pNext;

                fReturnVal = FALSE;
            }
        }
        break;

        case PSN_APPLY:
        {
            ApplyCurrentSettings();
        }
        break;
    }

    return (fReturnVal);
}



STDMETHODIMP_(INT_PTR) CCDOpt::PlayLists(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fResult = TRUE;

    switch (msg)
    {
        default:
            fResult = FALSE;
        break;

        case WM_CONTEXTMENU:
        {
            if ((HWND)wParam != GetDlgItem(hDlg, IDC_CDTREE))
            {
                WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)aPlayListHelp);
            }
        }
        break;

        case WM_HELP:
        {
            WinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPSTR)aPlayListHelp);
        }
        break;

        case WM_DESTROY:
        {
            if (m_pCDData)
            {
                DumpMixerTree(hDlg);
                m_pCDData->UnloadTitles();
                ImageList_Destroy(m_hImageList);
                m_hImageList = NULL;
                m_hList = NULL;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            #ifdef UNICODE
            HWND hTree = GetDlgItem(hDlg, IDC_CDTREE);
            if (hTree)
            {
                TreeView_SetUnicodeFormat(hTree,TRUE);
            }
            #endif

            if (m_pCDData)
            {
                m_hList = hDlg;
                m_pCDData->LoadTitles(hDlg);
            }

            m_fDrivesExpanded = TRUE;
            m_fAlbumsExpanded = FALSE;


            fResult = InitPlayLists(hDlg, m_pCDData);
        }
        break;


        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case ID_DOWNLOADTITLE:
                    DownloadTitle(hDlg);
                break;

                case ID_DELETETITLE:
                    DeleteTitle(hDlg);
                break;

                case ID_EDITARTISTNAME:
                case ID_EDITTITLENAME:
                case ID_EDITTRACKNAME:
                    EditTreeItem(hDlg);
                break;

                case ID_EXPAND:
                    ToggleExpand(hDlg);
                break;

                case IDC_EDITPLAYLIST:
                    EditCurrentTitle(hDlg);
                break;

                case IDC_BYARTIST:
                    ToggleByArtist(hDlg, m_pCDData);
                break;

                case ID_HELPMENU:
                    WinHelp (GetDlgItem(hDlg, IDC_CDTREE), gszHelpFile, HELP_WM_HELP, (ULONG_PTR) (LPSTR) aPlayListHelp);
                break;

                default:
                    fResult = FALSE;
                break;
            }
        }
        break;

        case WM_NOTIFY:
        {
            fResult = PlayListNotify(hDlg, (LPNMHDR) lParam);
        }
        break;
    }

    return fResult;
}



///////////////////
// Dialog handler
//
INT_PTR CALLBACK CCDOpt::PlayListsProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);

    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) ((LPPROPSHEETPAGE) lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);

    }

    if (pCDOpt)
    {
        fResult = (BOOL) pCDOpt->PlayLists(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\listedit.cpp ===
//--------------------------------------------------------------------------;
//
//  File: listedit.cpp
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved
//
//--------------------------------------------------------------------------;

#include "precomp.h"
#include <regstr.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "optres.h"
#include "..\cdplay\playres.h"
#include "cdopti.h"
#include "cdoptimp.h"
#include "helpids.h"

#include "..\main\resource.h"
#include "..\main\mmfw.h"

//////////////
// Help ID's
//////////////

#pragma data_seg(".text")
const static DWORD aListEditHelp[] =
{
    IDC_ARTIST_TEXT,        IDH_EDIT_ARTIST,
    IDC_EDIT_ARTIST,        IDH_EDIT_ARTIST,
    IDC_TITLE_TEXT,         IDH_EDIT_TITLE,
    IDC_EDIT_TITLE,         IDH_EDIT_TITLE,
    IDC_AVAILTRACKS_TEXT,   IDH_AVAILTRACKS,
    IDC_AVAILTRACKS,        IDH_AVAILTRACKS,
    IDC_ADDTOPLAYLIST,      IDH_ADDTOPLAYLIST,
    IDC_PLAYLIST_TEXT,      IDH_PLAYLIST,
    IDC_CURRLIST,           IDH_PLAYLIST,
    IDC_BUTTON_REMOVE,      IDH_PLAYLIST_REMOVE,
    IDC_BUTTON_CLEAR,       IDH_PLAYLIST_CLEAR,
    IDC_BUTTON_RESET,       IDH_PLAYLIST_RESET,
    IDC_UPLOADTITLE,        IDH_SUBMIT_ALBUM_DATA,
    0, 0
};
#pragma data_seg()


///////////////////
// Called to init the dialog when it first appears.
//
STDMETHODIMP_(BOOL) CCDOpt::InitListEdit(HWND hDlg)
{
    DWORD dwTrack;
    LRESULT dwItem;
    LPWORD pNum = NULL;
    DWORD dwTracks;

    // Setup the CD Net object for uploading data
    /////////////////////////////////////////////
    if (m_pICDNet)
    {
        m_pICDNet->Release();
        m_pICDNet = NULL;
    }

    if (SUCCEEDED(CDNET_CreateInstance(NULL, IID_ICDNet, (void**)&m_pICDNet)))
    {
        m_pICDNet->SetOptionsAndData((void *) this, (void *) m_pCDData);

        if (!(m_pICDNet->CanUpload() && m_pCDTitle->szTitleQuery && lstrlen(m_pCDTitle->szTitleQuery)))
        {
            m_pICDNet->Release();
            m_pICDNet = NULL;
        }
    }

    EnableWindow(GetDlgItem(hDlg, IDC_UPLOADTITLE), m_pICDNet != NULL);

    //Drag drop interface////////
    /////////////////////////////
    m_hInst = m_hInst;
    m_DragMessage = InitDragMultiList();
    if (m_hCursorNoDrop == NULL) {
        m_hCursorNoDrop = LoadCursor(NULL, IDC_NO);
    }

    if (m_hCursorDrop == NULL) {
        m_hCursorDrop = LoadCursor(m_hInst, MAKEINTRESOURCE(IDR_DROP));
    }

    if (m_hCursorDropCpy == NULL) {
        m_hCursorDropCpy = LoadCursor(m_hInst, MAKEINTRESOURCE(IDR_DROPCPY));
    }


    MakeMultiDragList( GetDlgItem(hDlg, IDC_CURRLIST));

    //Setup the track bitmap
    m_hbmTrack = LoadBitmap( m_hInst, MAKEINTRESOURCE(IDR_TRACK) );
    HDC hdc = GetDC( hDlg );
    m_hdcMem = CreateCompatibleDC( hdc );
    ReleaseDC( hDlg, hdc );
    SelectObject( m_hdcMem, m_hbmTrack );
    /////////////////////////////


    //
    // If IME is enabled, subclass the Edit control in Combobox,
    // to capture IME specific messages.
    //
    if (GetSystemMetrics(SM_IMMENABLED)) {  // This SM doesn't change while the system is up.
        HWND hwndCombo = GetDlgItem(hDlg, IDC_AVAILTRACKS);
        if (hwndCombo) {
            HWND hwndCbEdit = GetTopWindow(hwndCombo);
            if (hwndCbEdit) {
                s_fpCbEditProcOrg = (WNDPROC)SubclassWindow(hwndCbEdit, CbEditProc);
            }
        }
    }

    /////////////////////////////

    if (m_pCDTitle)
    {
        SendDlgItemMessage(hDlg, IDC_EDIT_ARTIST, WM_SETTEXT, 0, (LPARAM) m_pCDTitle->szArtist);
        SendDlgItemMessage(hDlg, IDC_EDIT_TITLE, WM_SETTEXT, 0, (LPARAM) m_pCDTitle->szTitle);

        m_dwTrack = 0;

        SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_RESETCONTENT, 0, 0);

        if (m_pCDTitle->pTrackTable)
        {
            for (dwTrack = 0; dwTrack < m_pCDTitle->dwNumTracks; dwTrack++)
            {
                dwItem = SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_ADDSTRING, 0, (LPARAM) m_pCDTitle->pTrackTable[dwTrack].szName);

                if (dwItem != CB_ERR && dwItem != CB_ERRSPACE && dwItem == m_dwTrack)
                {
                    SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_SETCURSEL, (WPARAM) dwItem, 0);
                }
            }
        }
        else if (m_pCDTitle->dwNumTracks)
        {
            TCHAR szText[CDSTR];
            TCHAR szTrack[CDSTR];

            LoadString(m_hInst, IDS_TRACK, szTrack, sizeof(szTrack)/sizeof(TCHAR));

            for (dwTrack = 0; dwTrack < m_pCDTitle->dwNumTracks; dwTrack++)
            {
                wsprintf(szText,TEXT("%s %d"), szTrack, dwTrack + 1);

                dwItem = SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_ADDSTRING, 0, (LPARAM) szText);

                if (dwItem != CB_ERR && dwItem != CB_ERRSPACE && dwItem == m_dwTrack)
                {
                    SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_SETCURSEL, (WPARAM) dwItem, 0);
                }
            }
        }

        SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), FALSE);
        SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_RESETCONTENT, 0, 0);

        pNum = m_pCDTitle->pPlayList;
        dwTracks = m_pCDTitle->dwNumPlay;

        if (pNum == NULL || dwTracks == 0)
        {
            dwTracks = m_pCDTitle->dwNumTracks;
        }

        if (dwTracks)
        {
            for (dwTrack = 0; dwTrack < dwTracks; dwTrack++)
            {
                DWORD dwNum = dwTrack;

                if (pNum)
                {
                    dwNum = *pNum;
                    pNum++;
                }

                if (dwNum < m_pCDTitle->dwNumTracks)
                {
                    dwItem = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_ADDSTRING, 0, (LPARAM) m_pCDTitle->pTrackTable[dwNum].szName);

                    if(dwItem != LB_ERR && dwItem != LB_ERRSPACE)
                    {
                         SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_SETITEMDATA,  (WPARAM) dwItem, (LPARAM) dwNum);
                    }
                }
            }
        }

        SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), TRUE);

        UpdateListButtons(hDlg);
    }

    return(TRUE);
}


STDMETHODIMP_(void) CCDOpt::AddTrackToPlayList(HWND hDlg, UINT_PTR dwTrack)
{
    LRESULT dwItem;
    DWORD   dwSize;

    dwSize = (DWORD)SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETLBTEXTLEN,  (WPARAM) dwTrack, 0);

    if (dwSize != CB_ERR)
    {
        dwSize++;

        TCHAR *szName = new(TCHAR[dwSize]);

        if (szName)
        {
            if (SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETLBTEXT,  (WPARAM) dwTrack, (LPARAM) szName) != CB_ERR)
            {
                if (dwSize >= CDSTR)    // Truncate the name to fit in our max cd title string size
                {
                    szName[CDSTR - 1] = '\0';
                }

                dwItem = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_ADDSTRING, 0, (LPARAM) szName);

                if (dwItem != LB_ERR && dwItem != LB_ERRSPACE)
                {
                    SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_SETITEMDATA,  (WPARAM) dwItem, (LPARAM) dwTrack);
                }

            }

            delete szName;
        }
    }
}


STDMETHODIMP_(void) CCDOpt::ResetPlayList(HWND hDlg)
{
    UINT_PTR dwTrack;

    SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), FALSE);
    SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_RESETCONTENT, 0, 0);

    for (dwTrack = 0; dwTrack < m_pCDTitle->dwNumTracks; dwTrack++)
    {
        AddTrackToPlayList(hDlg, dwTrack);
    }
    SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), TRUE);
    UpdateListButtons(hDlg);
}



STDMETHODIMP_(void) CCDOpt::UpdateAvailList(HWND hDlg)
{
    TCHAR szName[CDSTR];

    if (SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, WM_GETTEXT,  (WPARAM) CDSTR, (LPARAM) szName) != CB_ERR)
    {
        SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), FALSE);

        SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_DELETESTRING, (WPARAM) m_dwTrack, 0);
        SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_INSERTSTRING, (WPARAM) m_dwTrack, (LPARAM) szName);

        SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), TRUE);
    }
}



STDMETHODIMP_(void) CCDOpt::AddToPlayList(HWND hDlg)
{
    LRESULT dwTrack;

    dwTrack = SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETCURSEL, 0, 0);

    if (dwTrack == CB_ERR) // Must be editing, no selection while editing.
    {
        dwTrack = m_dwTrack;
    }

    SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), FALSE);
    AddTrackToPlayList(hDlg, m_dwTrack);
    SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), TRUE);

    UpdateListButtons(hDlg);

}


STDMETHODIMP_(void) CCDOpt::AddEditToPlayList(HWND hDlg)
{
    TCHAR szName[CDSTR];
    LRESULT dwItem;

    if (SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, WM_GETTEXT,  (WPARAM) CDSTR, (LPARAM) szName) != CB_ERR)
    {
        dwItem = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_ADDSTRING, 0, (LPARAM) szName);

        if (dwItem != LB_ERR && dwItem != LB_ERRSPACE)
        {
            SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_SETITEMDATA,  (WPARAM) dwItem, (LPARAM) m_dwTrack);
        }
    }
}


STDMETHODIMP_(void) CCDOpt::TrackEditChange(HWND hDlg)
{
    if (m_fDelayUpdate) {
        return;
    }

    TCHAR szName[CDSTR];
    LRESULT dwTrack;
    LRESULT dwCount;

    if (SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, WM_GETTEXT,  (WPARAM) CDSTR, (LPARAM) szName) != CB_ERR)
    {
        //Reset the combo box content. Because the Currlist takes data from there.
        HWND hAvailWnd = GetDlgItem(hDlg, IDC_AVAILTRACKS);
        DWORD dwSel;

        dwSel = ComboBox_GetEditSel(hAvailWnd);
        ComboBox_DeleteString(hAvailWnd, m_dwTrack);
        ComboBox_InsertString(hAvailWnd, m_dwTrack, szName);
        ComboBox_SetCurSel(hAvailWnd, m_dwTrack); //Reset selection
        ComboBox_SetEditSel(hAvailWnd, LOWORD(dwSel), HIWORD(dwSel)); //Reset the text edit control.

        SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), FALSE);

        dwCount = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_GETCOUNT, 0, 0);

        while (dwCount--)
        {
            dwTrack = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_GETITEMDATA, (WPARAM) dwCount, (LPARAM) 0);

            if (dwTrack != LB_ERR && dwTrack == m_dwTrack)
            {
                LRESULT dwItem;

                SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_DELETESTRING, (WPARAM) dwCount, 0);

                dwItem = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_INSERTSTRING, (WPARAM) dwCount, (LPARAM) szName);

                if (dwItem != LB_ERR && dwItem != LB_ERRSPACE)
                {
                    SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_SETITEMDATA,  (WPARAM) dwCount, (LPARAM) m_dwTrack);
                }
            }
        }

        SetWindowRedraw(GetDlgItem(hDlg, IDC_CURRLIST), TRUE);
    }
}


STDMETHODIMP_(void) CCDOpt::UpdateListButtons(HWND hDlg)
{
    LRESULT dwItem;
    int     num;
    HWND    hPlayWnd = GetDlgItem(hDlg, IDC_CURRLIST);

    num = ListBox_GetSelCount( hPlayWnd );
    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_REMOVE), num > 0);

    dwItem = SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_GETCOUNT,  0, 0);
    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_CLEAR), (dwItem != LB_ERR && dwItem != 0) );
}


STDMETHODIMP_(void) CCDOpt::RemovePlayListSel(HWND hDlg)
{
    int     num;
    int     i;
    int     *pList;
    HWND    hPlayWnd = GetDlgItem(hDlg, IDC_CURRLIST);

    /*
    ** Get the number of tracks currently selected.  Return if an error
    ** occurrs or zero tracks selected.
    */
    num = ListBox_GetSelCount( hPlayWnd );
    if ( num <= 0 ) {
        return;
    }

    pList = new int[num];
    ListBox_GetSelItems( hPlayWnd, num, pList );

    SetWindowRedraw( hPlayWnd, FALSE );
    for ( i = num - 1; i >= 0; i-- ) {

        ListBox_DeleteString( hPlayWnd, pList[i] );

    }

    SetWindowRedraw( hPlayWnd, TRUE );

    DWORD dwErr = ListBox_SetSel(hPlayWnd, TRUE , pList[0]);

    if (dwErr == LB_ERR && pList[0] > 0)
    {
        pList[0]--;
        ListBox_SetSel(hPlayWnd, TRUE , pList[0]);
    }

    delete pList;
    UpdateListButtons(hDlg);

}




STDMETHODIMP_(void) CCDOpt::OnDrawItem(HWND hDlg, const DRAWITEMSTRUCT *lpdis)
{
    if ( (lpdis->itemAction & ODA_DRAWENTIRE) || (lpdis->itemAction & ODA_SELECT) ) {

        DrawListItem(hDlg, lpdis->hDC, &lpdis->rcItem,lpdis->itemData, lpdis->itemState & ODS_SELECTED );

        if ( lpdis->itemState & ODS_FOCUS ) {
            DrawFocusRect( lpdis->hDC, &lpdis->rcItem );
        }
    }
}



STDMETHODIMP_(void) CCDOpt::DrawListItem(HWND hDlg, HDC hdc, const RECT *rItem, UINT_PTR itemIndex, BOOL selected)
{
    DWORD       dwROP;
    SIZE        si;
    UINT        i;
    TCHAR       s[TRACK_TITLE_LENGTH];
    TCHAR       szDotDot[] = TEXT("... ");
    int         cxDotDot;


    /*
    ** Check selection status, and set up to draw correctly
    */
    if ( selected ) {

        SetBkColor( hdc, GetSysColor( COLOR_HIGHLIGHT ) );
        SetTextColor( hdc, GetSysColor( COLOR_HIGHLIGHTTEXT ) );
        dwROP = MERGEPAINT;

    }
    else {

        SetBkColor( hdc, GetSysColor(COLOR_WINDOW));
        SetTextColor( hdc, GetSysColor(COLOR_WINDOWTEXT));
        dwROP = SRCAND;
    }

    /*
    ** Get track string
    */
    ComboBox_GetLBText( GetDlgItem(hDlg, IDC_AVAILTRACKS), itemIndex, s );

    /*
    ** Do we need to munge track name (clip to listbox)?
    */
    GetTextExtentPoint( hdc, szDotDot, lstrlen( szDotDot ), &si );
    cxDotDot = si.cx;

    i = lstrlen( s ) + 1;
    do {
        GetTextExtentPoint( hdc, s, --i, &si );
    } while( si.cx > (rItem->right - cxDotDot - 20)  );


    /*
    ** Draw track name
    */
    ExtTextOut( hdc, rItem->left + 20, rItem->top, ETO_OPAQUE | ETO_CLIPPED,
                rItem, s, i, NULL );

    if ( lstrlen( s ) > (int) i ) {

        ExtTextOut( hdc, rItem->left + si.cx + 20, rItem->top, ETO_CLIPPED,
                    rItem, szDotDot, lstrlen(szDotDot), NULL );
    }

    /*
    ** draw cd icon for each track
    */
    BitBlt( hdc, rItem->left, rItem->top, 14, 14, m_hdcMem, 0, 0, dwROP );
}



STDMETHODIMP_(BOOL) CCDOpt::IsInListbox(HWND hDlg, HWND hwndListbox, POINT pt)
{
    RECT    rc;

    ScreenToClient(hDlg, &pt);

    if ( ChildWindowFromPoint( hDlg, pt ) == hwndListbox ) {

        GetClientRect( hwndListbox, &rc );
        MapWindowRect( hwndListbox, hDlg, &rc );

        return PtInRect( &rc, pt );
    }

    return FALSE;
}




STDMETHODIMP_(int) CCDOpt::InsertIndex(HWND hDlg, POINT pt, BOOL bDragging)
{
    int     nItem;
    int     nCount;
    HWND hPlayWnd = GetDlgItem(hDlg, IDC_CURRLIST);

    nCount = ListBox_GetCount( hPlayWnd );
    nItem = LBMultiItemFromPt( hPlayWnd, pt, bDragging );

    /*
    ** If the mouse is not over any particular list item, but it is inside
    ** the client area of the listbox just append to end of the listbox.
    */

    if ( nItem == -1 ) {

        if ( IsInListbox( hDlg, hPlayWnd, pt ) ) {
            nItem = nCount;
        }
    }

    /*
    ** Otherwise, if the mouse is over a list item and there is
    ** at least one item in the listbox determine if the inertion point is
    ** above or below the current item.
    */

    else if ( nItem > 0 && nCount > 0 ) {

        long    pt_y;
        RECT    rc;

        ListBox_GetItemRect( hPlayWnd, nItem, &rc );
        ScreenToClient( hPlayWnd, &pt );

        pt_y = rc.bottom - ((rc.bottom - rc.top) / 2);

        if ( pt.y > pt_y ) {
            nItem++;
        }
    }

    DrawMultiInsert( hDlg, hPlayWnd, bDragging ? nItem : -1 );

    return nItem;
}




STDMETHODIMP_(BOOL) CCDOpt::OnQueryDrop( HWND hDlg, HWND hwndDrop, HWND hwndSrc, POINT ptDrop, DWORD dwState)
{
    int     index;
    HWND    hPlayWnd = GetDlgItem(hDlg, IDC_CURRLIST);

    index = InsertIndex( hDlg, ptDrop, TRUE );

    if ( index >= 0  ) {

        if ( (hwndSrc == hPlayWnd) && (dwState == DG_COPY) ) {

            SetCursor( m_hCursorDropCpy );
        }
        else {

            SetCursor( m_hCursorDrop );
        }
    }
    else {

        SetCursor( m_hCursorNoDrop );
    }

    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
    return TRUE;
}





STDMETHODIMP_(void) CCDOpt::MoveCopySelection(HWND hDlg, int iInsertPos, DWORD dwState)
{
    int         num;
    int         i;
    int         *pList;
    LIST_INFO   *pInfo;
    HWND        hPlayWnd = GetDlgItem(hDlg, IDC_CURRLIST);

    /*
    ** Get the number of tracks currently selected.  Return if an error
    ** occurrs or zero tracks selected.
    */
    num = ListBox_GetSelCount( hPlayWnd );
    if ( num <= 0 ) {
        return;
    }

    pList = new int[num];
    pInfo = new LIST_INFO[num];
    ListBox_GetSelItems( hPlayWnd, num, pList );


    SetWindowRedraw( hPlayWnd, FALSE );

    for ( i = num - 1; i >= 0; i-- ) {

        ListBox_GetText( hPlayWnd, pList[i], pInfo[i].chName );
        pInfo[i].dwData = ListBox_GetItemData( hPlayWnd, pList[i] );

        if ( dwState == DG_MOVE ) {
            pInfo[i].index = pList[i];
            ListBox_DeleteString( hPlayWnd, pList[i] );
        }
    }

    if ( dwState == DG_MOVE ) {

        /*
        ** for each selected item that was above the insertion point
        ** reduce the insertion point by 1.
        */
        int iTempInsertionPt = iInsertPos;

        for ( i = 0; i < num; i++ ) {
            if ( pInfo[i].index < iInsertPos ) {
                iTempInsertionPt--;
            }
        }
        iInsertPos = iTempInsertionPt;
    }


    for ( i = 0; i < num; i++ ) {

        ListBox_InsertString( hPlayWnd, iInsertPos + i, pInfo[i].chName );
        ListBox_SetItemData( hPlayWnd, iInsertPos + i, pInfo[i].dwData );
    }

    /*
    ** Adjust the selection to reflect the move
    */
    if ( num != 0 ) {

          ListBox_SelItemRange(hPlayWnd, TRUE, iInsertPos, (iInsertPos + num) - 1);
    }

    SetWindowRedraw( hPlayWnd, TRUE );

    delete pList;
    delete pInfo;
}



STDMETHODIMP_(BOOL) CCDOpt::OnProcessDrop(HWND hDlg, HWND hwndDrop, HWND hwndSrc, POINT ptDrop, DWORD dwState)
{

    int     index;
    HWND    hPlayWnd = GetDlgItem(hDlg, IDC_CURRLIST);

    /*
    ** Are we dropping on the play list window ?
    */
    if ( hwndDrop == hPlayWnd ) {

        index = InsertIndex( hDlg, ptDrop, FALSE );

        /*
        ** Is it OK to drop here ?
        */
        if ( index >= 0 ) {

            if ( hwndSrc == hPlayWnd ) {

                MoveCopySelection( hDlg, index, dwState );
            }
        }
    }

    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
    return TRUE;
}



STDMETHODIMP_(void) CCDOpt::CommitTitleChanges(HWND hDlg, BOOL fSave)
{
    BOOL fChanges = FALSE;

    //Playlist interface
    DeleteDC(m_hdcMem);
    DeleteObject(m_hbmTrack);

    if (fSave)
    {
        DWORD   dwItem = 0;
        DWORD   dwTrack;
        DWORD   dwSize;
        TCHAR str[CDSTR];

        SendDlgItemMessage(hDlg, IDC_EDIT_ARTIST, WM_GETTEXT, (WPARAM) CDSTR, (LPARAM) str);
        if (lstrcmp(m_pCDTitle->szArtist, str))
        {
            fChanges = TRUE;
            lstrcpy(m_pCDTitle->szArtist, str);
        }

        SendDlgItemMessage(hDlg, IDC_EDIT_TITLE, WM_GETTEXT, (WPARAM) CDSTR, (LPARAM) str);
        if (lstrcmp(m_pCDTitle->szTitle, str))
        {
            fChanges = TRUE;
            lstrcpy(m_pCDTitle->szTitle, str);
        }

        for (dwTrack = 0; dwTrack < m_pCDTitle->dwNumTracks; dwTrack++)
        {
            dwSize = (DWORD)SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETLBTEXTLEN,  (WPARAM) dwTrack, 0);

            if (dwSize != CB_ERR)
            {
                dwSize++;

                TCHAR *szName = new(TCHAR[dwSize]);

                if (szName)
                {
                    if (SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETLBTEXT,  (WPARAM) dwTrack, (LPARAM) szName) != CB_ERR)
                    {
                        if (dwSize >= CDSTR)    // Truncate the name to fit in our max cd title string size
                        {
                            szName[CDSTR - 1] = '\0';
                        }

                        if (lstrcmp(m_pCDTitle->pTrackTable[dwTrack].szName, szName))
                        {
                            fChanges = TRUE;
                            lstrcpy(m_pCDTitle->pTrackTable[dwTrack].szName, szName);
                        }
                    }

                    delete szName;
                }
            }
        }

        dwSize = (DWORD)SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_GETCOUNT,  0, 0);

        if (dwSize != LB_ERR)
        {
            if (dwSize == 0 && m_pCDTitle->dwNumPlay != 0)
            {
                fChanges = TRUE;

                m_pCDTitle->dwNumPlay = 0;

                if (m_pCDTitle->pPlayList)
                {
                    delete m_pCDTitle->pPlayList;
                    m_pCDTitle->pPlayList = NULL;
                }
            }
            else
            {
                BOOL fDefaultlist = FALSE;

                if (dwSize == m_pCDTitle->dwNumTracks && m_pCDTitle->dwNumPlay == 0)
                {
                    fDefaultlist = TRUE;

                    for (dwTrack = 0; dwTrack < dwSize; dwTrack++)
                    {
                        dwItem = (DWORD)SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_GETITEMDATA,  (WPARAM) dwTrack, 0);

                        if (dwItem == LB_ERR || (dwItem != dwTrack))
                        {
                            fDefaultlist = FALSE;
                            break;
                        }
                    }
                }

                if (!fDefaultlist)
                {
                    LPWORD pList = new(WORD[dwSize]);

                    if (pList)
                    {
                        LPWORD pNum = pList;

                        for (dwTrack = 0; dwTrack < dwSize; dwTrack++, pNum++)
                        {
                            dwItem = (DWORD)SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_GETITEMDATA,  (WPARAM) dwTrack, 0);

                            if (dwItem != LB_ERR)
                            {
                                *pNum =  (WORD) dwItem;
                            }
                            else
                            {
                                *pNum = 0;
                            }
                        }

                        if (dwSize != m_pCDTitle->dwNumPlay || memcmp(pList, m_pCDTitle->pPlayList, sizeof(WORD) * m_pCDTitle->dwNumPlay))
                        {
                            fChanges = TRUE;

                            if (m_pCDTitle->pPlayList)
                            {
                                delete m_pCDTitle->pPlayList;
                            }

                            m_pCDTitle->pPlayList = pList;
                            m_pCDTitle->dwNumPlay = dwSize;
                        }
                        else
                        {
                            delete pList;
                        }
                    }
                }
            }
        }
    }

    if (!fChanges)
    {
        m_pCDTitle = NULL;
    }
}








STDMETHODIMP_(void) CCDOpt::AvailTracksNotify(HWND hDlg, UINT code)
{
    static BOOL fMenuFixed = TRUE;

    switch (code)
    {
        case CBN_DROPDOWN:
        case CBN_SELCHANGE:
        {
            if (!fMenuFixed)
            {
                UpdateAvailList(hDlg);
                fMenuFixed = TRUE;
            }

            if (code == CBN_SELCHANGE)
            {
                m_dwTrack = SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETCURSEL, 0, 0);
            }
        }
        break;

        case CBN_EDITCHANGE:
            fMenuFixed = FALSE;
            TrackEditChange(hDlg);
        break;

        case CBN_KILLFOCUS:
            SendMessage( hDlg, DM_SETDEFID, IDOK, 0L );
        break;

        case CBN_SETFOCUS:
            SendMessage( hDlg, DM_SETDEFID, IDC_AVAILTRACKS, 0L);
        break;

        case CB_OKAY:
        {
            UpdateAvailList(hDlg);

            m_dwTrack++;
            if ((UINT_PTR)m_dwTrack >= m_pCDTitle->dwNumTracks)
            {
                m_dwTrack = 0;
            }

            SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_SETCURSEL, (WPARAM) m_dwTrack, 0);
        }
        break;
    }
}

STDMETHODIMP_(void) CCDOpt::CurrListNotify(HWND hDlg, UINT code)
{
    switch (code)
    {
        case LBN_SELCHANGE:
        {
            UpdateListButtons(hDlg);
        }
        break;
    }
}



STDMETHODIMP_(BOOL) CCDOpt::Upload(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    static  HWND hAnim = NULL;

    switch (msg)
    {
        default:
            fResult = FALSE;
        break;

        case WM_INITDIALOG:
        {
            HRESULT hr = m_pICDNet->Upload(m_pCDUploadTitle, hDlg);
            RECT mainrect;
            RECT anirect;

            if (FAILED(hr))
            {
                TCHAR szNetError[MAX_PATH];
                TCHAR szAppName[MAX_PATH];
                LoadString(m_hInst,IDS_NET_FAILURE,szNetError,sizeof(szNetError)/sizeof(TCHAR));
                LoadString(m_hInst,IDS_APPNAME,szAppName,sizeof(szAppName)/sizeof(TCHAR));
                MessageBox(hDlg,szNetError,szAppName,MB_ICONERROR|MB_OK);

                EndDialog(hDlg,FALSE);
            }

            GetWindowRect(hDlg,&mainrect);
            mainrect.top = mainrect.top + GetSystemMetrics(SM_CYCAPTION);

            hAnim = Animate_Create(hDlg, IDI_ICON_ANI_DOWN, WS_CHILD|ACS_TRANSPARENT, 0);

            SendMessage(hAnim,ACM_OPEN,(WPARAM)0, (LPARAM)MAKEINTRESOURCE(IDI_ICON_ANI_DOWN));
            GetWindowRect(hAnim,&anirect);
            MoveWindow(hAnim, 11, 11, anirect.right - anirect.left, anirect.bottom - anirect.top, FALSE);  // Fixme - should hard code location

            Animate_Play(hAnim,0,-1,-1);
            ShowWindow(hAnim,SW_SHOW);
        }
        break;

        case WM_DESTROY:
        {
            if (hAnim)
            {
                DestroyWindow(hAnim);
                hAnim = NULL;
            }
        }
        break;

        case WM_NET_DONE:
        {
            TCHAR   str[MAX_PATH];
            BOOL    fAlert = TRUE;
            DWORD   dwFlag;

            switch (lParam)
            {
                default:
                {
                    fAlert = FALSE;
                }
                break;

                case UPLOAD_STATUS_NO_PROVIDERS:
                {
                    LoadString(m_hInst, IDS_ERROR_NOUPLOAD, str, sizeof(str)/sizeof(TCHAR));
                    dwFlag = MB_ICONERROR;
                }
                break;

                case UPLOAD_STATUS_SOME_PROVIDERS:
                {
                    LoadString(m_hInst, IDS_ERROR_PARTUPLOAD, str, sizeof(str)/sizeof(TCHAR));
                    dwFlag = MB_ICONWARNING;
                }
                break;

                case UPLOAD_STATUS_ALL_PROVIDERS:
                {
                    LoadString(m_hInst, IDS_UPLOAD_SUCCESS, str, sizeof(str)/sizeof(TCHAR));
                    dwFlag = MB_ICONINFORMATION;
                }
                break;
            }

            if (fAlert)
            {
                TCHAR title[MAX_PATH];

                LoadString(m_hInst, IDS_UPLOAD_STATUS, title, sizeof(title)/sizeof(TCHAR));
                MessageBox(hDlg,str,title,MB_OK | dwFlag);
            }

            EndDialog(hDlg,FALSE);
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    m_pICDNet->CancelDownload();
                    EndDialog(hDlg,FALSE);
                break;
            }
        }
        break;
    }

    return fResult;
}


INT_PTR CALLBACK CCDOpt::UploadProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);

    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);
    }

    if (pCDOpt)
    {
        fResult = pCDOpt->Upload(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}



STDMETHODIMP_(BOOL) CCDOpt::Confirm(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;

    switch (msg)
    {
        default:
            fResult = FALSE;
        break;

        case WM_INITDIALOG:
        {
            CheckDlgButton(hDlg, IDC_CONFIRMPROMPT, FALSE);
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                    SetUploadPrompt(!Button_GetCheck(GetDlgItem(hDlg, IDC_CONFIRMPROMPT)));
                    EndDialog(hDlg,TRUE);
                break;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                break;
            }
        }
        break;
    }

    return fResult;
}


INT_PTR CALLBACK CCDOpt::ConfirmProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);

    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);
    }

    if (pCDOpt)
    {
        fResult = pCDOpt->Confirm(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}


STDMETHODIMP_(BOOL) CCDOpt::ConfirmUpload(HWND hDlg)
{
    INT_PTR fContinue = TRUE;

    if (GetUploadPrompt())
    {
        fContinue = DialogBoxParam(m_hInst, MAKEINTRESOURCE(IDD_UPLOAD_CONFIRM), hDlg, CCDOpt::ConfirmProc, (LPARAM) this);
    }

    return (BOOL)fContinue;
}


STDMETHODIMP_(void) CCDOpt::UploadTitle(HWND hDlg)
{
    if (ConfirmUpload(hDlg))
    {
        if (m_pICDNet)
        {
            DWORD     dwTrack;
            DWORD       dwSize;
            LPCDTRACK   pCDTracks = (LPCDTRACK) new CDTRACK[m_pCDTitle->dwNumTracks];

            if (pCDTracks)
            {
                m_pCDUploadTitle = new CDTITLE;

                if (m_pCDUploadTitle)
                {
                    memset(m_pCDUploadTitle, 0, sizeof(CDTITLE));

                    m_pCDUploadTitle->dwTitleID = m_pCDTitle->dwTitleID;
                    m_pCDUploadTitle->dwNumTracks = m_pCDTitle->dwNumTracks;
                    m_pCDUploadTitle->pTrackTable = pCDTracks;

                    m_pCDData->SetTitleQuery(m_pCDUploadTitle, m_pCDTitle->szTitleQuery);

                    SendDlgItemMessage(hDlg, IDC_EDIT_ARTIST, WM_GETTEXT, (WPARAM) CDSTR, (LPARAM) m_pCDUploadTitle->szArtist);
                    SendDlgItemMessage(hDlg, IDC_EDIT_TITLE, WM_GETTEXT, (WPARAM) CDSTR, (LPARAM) m_pCDUploadTitle->szTitle);

                    for (dwTrack = 0; dwTrack < m_pCDTitle->dwNumTracks; dwTrack++)
                    {
                        dwSize = (DWORD)SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETLBTEXTLEN,  (WPARAM) dwTrack, 0);

                        if (dwSize != CB_ERR)
                        {
                            dwSize++;

                            TCHAR *szName = new(TCHAR[dwSize]);

                            if (szName)
                            {
                                if (SendDlgItemMessage(hDlg, IDC_AVAILTRACKS, CB_GETLBTEXT,  (WPARAM) dwTrack, (LPARAM) szName) != CB_ERR)
                                {
                                    if (dwSize >= CDSTR)    // Truncate the name to fit in our max cd title string size
                                    {
                                        szName[CDSTR - 1] = '\0';
                                    }

                                    lstrcpy(pCDTracks[dwTrack].szName, szName);
                                }

                                delete szName;
                            }
                        }
                    }
                }
                else
                {
                    delete pCDTracks;
                }
            }

            if (m_pCDUploadTitle)
            {
                DialogBoxParam(m_hInst, MAKEINTRESOURCE(IDD_DIALOG_UPLOAD), hDlg, CCDOpt::UploadProc, (LPARAM) this);

                if (m_pCDUploadTitle->szTitleQuery)
                {
                    delete m_pCDUploadTitle->szTitleQuery;
                }

                delete m_pCDUploadTitle;
                m_pCDUploadTitle = NULL;
            }
        }
    }
}



STDMETHODIMP_(BOOL) CCDOpt::DoListCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    BOOL fResult = TRUE;
    UINT code = HIWORD(wParam);
    UINT id = LOWORD(wParam);

    switch (id)
    {
        case IDOK:
            CommitTitleChanges(hDlg, TRUE);
            EndDialog(hDlg, TRUE);
        break;

        case IDCANCEL:
            CommitTitleChanges(hDlg, FALSE);
            EndDialog(hDlg,FALSE);
        break;

        case IDC_ADDTOPLAYLIST:
            AddToPlayList(hDlg);
        break;

        case IDC_BUTTON_REMOVE:
            RemovePlayListSel(hDlg);
        break;

        case IDC_BUTTON_CLEAR:
            SendDlgItemMessage(hDlg, IDC_CURRLIST, LB_RESETCONTENT, 0, 0);
            UpdateListButtons(hDlg);
        break;

        case IDC_BUTTON_RESET:
            ResetPlayList(hDlg);
        break;

        case IDC_UPLOADTITLE:
            UploadTitle(hDlg);
        break;

        case IDC_EDIT_TITLE:
        break;

        case IDC_EDIT_ARTIST:
        break;

        case IDC_CURRLIST:
            CurrListNotify(hDlg, code);
        break;

        case IDC_AVAILTRACKS:
            AvailTracksNotify(hDlg, code);
        break;

        default:
            fResult = FALSE;
        break;
    }

    return fResult;
}



// Process any drag/drop notifications first.
//
// wParam == The ID of the drag source.
// lParam == A pointer to a DRAGLISTINFO structure

STDMETHODIMP_(BOOL) CCDOpt::DoDragCommand(HWND hDlg, LPDRAGMULTILISTINFO lpns)
{
    HWND hwndDrop;
    BOOL fResult;

    hwndDrop = WindowFromPoint( lpns->ptCursor );

    switch (lpns->uNotification)
    {
        case DG_BEGINDRAG:
        {
            fResult = SetDlgMsgResult( hDlg, WM_COMMAND, TRUE );
        }
        break;

        case DG_DRAGGING:
        {
            fResult = OnQueryDrop( hDlg, hwndDrop, lpns->hWnd, lpns->ptCursor, lpns->dwState);
        }
        break;

        case DG_DROPPED:
        {
            fResult = OnProcessDrop( hDlg, hwndDrop, lpns->hWnd, lpns->ptCursor, lpns->dwState );
        }
        break;

        case DG_CANCELDRAG:
        {
            InsertIndex( hDlg, lpns->ptCursor, FALSE );
        }
        default:
        {
            fResult =  SetDlgMsgResult( hDlg, WM_COMMAND, FALSE );
        }
        break;
    }

    return fResult;
}

STDMETHODIMP_(void) CCDOpt::OnPrivateMsg(HWND hDlg, WPARAM wParam, LPARAM)
{
    switch (wParam) {
    case WM_IME_STARTCOMPOSITION:
        if (PRIMARYLANGID(LOWORD(GetKeyboardLayout(0))) == LANG_KOREAN) {
            m_fDelayUpdate = true;
        }
        break;
    case WM_IME_ENDCOMPOSITION:
        m_fDelayUpdate = false;
        break;
    }
}

STDMETHODIMP_(BOOL) CCDOpt::ListEditor(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fResult = TRUE;

    if (msg == m_DragMessage)
    {
        fResult = DoDragCommand(hDlg, (LPDRAGMULTILISTINFO) lParam);
    }
    else
    {
        switch (msg)
        {
            default:
                fResult = FALSE;
            break;

            case WM_DESTROY:
            {
                if (m_pICDNet)
                {
                    m_pICDNet->Release();
                    m_pICDNet = NULL;
                }
            }
            break;

            case WM_CONTEXTMENU:
            {
                WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)aListEditHelp);
            }
            break;

            case WM_HELP:
            {
                WinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPSTR)aListEditHelp);
            }
            break;

           case WM_INITDIALOG:
            {
                fResult = InitListEdit(hDlg);
            }
            break;

            case WM_COMMAND:
            {
                fResult = DoListCommand(hDlg,wParam,lParam);
            }
            break;

            case WM_DRAWITEM:
            {
                OnDrawItem(hDlg, (LPDRAWITEMSTRUCT) lParam);
            }
            break;

            case WM_PRIVATE:
                OnPrivateMsg(hDlg, wParam, lParam);
                break;
        }
    }

    return fResult;
}


///////////////////
// Dialog handler
//
INT_PTR CALLBACK CCDOpt::ListEditorProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);

    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);
    }

    if (pCDOpt)
    {
        fResult = pCDOpt->ListEditor(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}


////////////
// Called to put up the UI to allow the user Edit a Playlist
//
STDMETHODIMP_(BOOL) CCDOpt::ListEditDialog(HWND hDlg, LPCDTITLE pCDTitle)
{
    BOOL fResult = FALSE;

    if (pCDTitle)
    {
        m_pCDTitle = pCDTitle;  // If no changes, the commit function will clear m_pCDTitle

        if (DialogBoxParam( m_hInst, MAKEINTRESOURCE(IDD_DIALOG_PLAYLIST), hDlg, CCDOpt::ListEditorProc, (LPARAM) this) == TRUE)
        {
            if (m_pCDTitle)     // If no changes, then this will be cleared
            {
                m_pCDTitle->fChanged = TRUE;

                fResult = TRUE; // So tell caller that there were changes
            }
        }

        m_pCDTitle = NULL;
    }

    return (fResult);
}


WNDPROC CCDOpt::s_fpCbEditProcOrg;

LRESULT CALLBACK CCDOpt::CbEditProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
    case WM_IME_STARTCOMPOSITION:
    case WM_IME_ENDCOMPOSITION:
        SendMessage(GetParent(GetParent(hwnd)), WM_PRIVATE, msg, 0);
        break;
    }
    return CallWindowProc(s_fpCbEditProcOrg, hwnd, msg, wParam, lParam);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\optres.h ===
////////////////////////////////////////////
//
// Resource ID's for cdopt.h
//
////////////////////////////////////////////

#define IDS_CDOPTIONS                   1
#define IDS_SECONDS                     2
#define IDS_CDTITLES                    3
#define IDS_OTHERTITLES                 4
#define IDS_ARTIST                      5
#define IDS_TITLE                       6
#define IDS_PLAYLIST                    7
#define IDS_NODISC                      8
#define IDS_UNKNOWNTITLE                9
#define IDS_UNKNOWNARTIST               10
#define IDS_BYARTIST                    11
#define IDS_BYTITLE                     12
#define IDS_ALERTTEXT                   13
#define IDS_SAVEPROMPT                  14
#define IDS_COLLAPSE                    15
#define IDS_CREATEPLAYLIST              16
#define IDS_EDITPLAYLIST                17
#define IDS_BATCHTEXT                   18
#define IDS_TRACK                       19
#define IDS_DOWNLOADING                 20
#define IDS_NEWARTIST                   21
#define IDS_NEWTITLE                    22
#define IDS_IMPORTING                   23
#define IDS_ERROR_NO_ODBC               24
#define IDS_ERROR_SETUP                 25
#define IDS_SECOND                      26
#define IDS_ERROR_NOUPLOAD              27
#define IDS_ERROR_PARTUPLOAD            28
#define IDS_UPLOAD_SUCCESS              29
#define IDS_UPLOAD_STATUS               30

#define IDD_WEBCD                       101
#define IDD_CDPLAYEROPTIONS             102
#define IDI_CD                          103
#define IDD_CDPLAYLISTS                 105
#define IDD_CDHOST                      106
#define IDD_MIXERPICKER                 107
#define IDD_LOADSTATUS                  108
#define IDR_TITLEMENU                   109
#define IDI_SMALLCD                     110
#define IDI_CDSTACK                     111
#define IDI_NODISC                      112
#define IDI_TITLECLOSED                 113
#define IDI_TITLEOPEN                   114
#define IDI_CDCOLLECTION                115
#define IDI_SONG                        116
#define IDI_CDVOLUME                    117
#define IDD_DIALOG_PLAYLIST             118
#define IDD_DIALOG_UPLOAD               119
#define IDD_UPLOAD_CONFIRM              120
#define IDD_CDTITLEOPTIONS              121
#define IDI_CDQUESTION                  122
#define IDR_INSERT                      123

#define IDAPPLY                         1000
#define IDC_STARTPLAY                   1001
#define IDC_EXITSTOP                    1002
#define IDC_TOPMOST                     1003
#define IDC_CDTIME                      1004
#define IDC_TRACKTIME                   1005
#define IDC_TRACKTIMEREMAIN             1006
#define IDC_CDTIMEREMAIN                1007
#define IDC_INTROTIMESLIDER             1008
#define IDC_INTROTIMETEXT               1009
#define IDC_TITLEPICKER                 1010
#define IDC_DOWNLOADPROMPT              1011
#define IDC_DOWNLOADENABLED             1012
#define IDC_PLAYLISTRESTORE             1013
#define IDC_TITLERESTORE                1014
#define IDC_TITLETEXT                   1015
#define IDC_ARTISTTEXT                  1016
#define IDC_PLAYLIST                    1017
#define IDC_CDOPTIONS                   1018
#define IDC_OPTIONSRESTORE              1019
#define IDC_SETVOLUMECNTL               1020
#define IDC_PROVIDERPICKER              1021
#define IDC_MIXERTREE                   1022
#define IDC_DEFAULTMIXER                1023
#define IDC_BATCHENABLED                1024
#define IDC_CDDRIVE                     1025
#define IDC_AUDIOMIXER                  1026
#define IDC_AUDIOCONTROL                1027
#define IDC_EDITLIST                    1028
#define IDC_EDITPLAYLIST                1029
#define IDC_CDTREE                      1030
#define IDC_PROGRESSMETER               1031
#define IDC_BYARTIST                    1032
#define IDC_BATCHTEXT                   1033
#define IDC_DOWNLOADNOW                 1034
//#define IDC_EDIT_ARTIST                 1035
//#define IDC_EDIT_TITLE                  1036
#define IDC_CURRLIST                    1037
#define IDC_BUTTON_REMOVE               1038
#define IDC_BUTTON_CLEAR                1039
#define IDC_BUTTON_RESET                1040
#define IDC_AVAILTITLES                 1041
#define IDC_AVAILTRACKS                 1042
#define IDC_ADDTOPLAYLIST               1043
#define IDC_VOL_MSG_TEXT                1044
#define IDC_SELECTPLAYER_TEXT           1045
#define IDC_SELECTMIXER_TEXT            1046
#define IDC_SELECTCONTROL_TEXT          1047
#define IDC_VOL_CONFIG_GROUP            1048
#define IDC_PLAYBACK_GROUP              1049
#define IDC_TIMEDISPLAY_GROUP           1050
#define IDC_PREVIEWTIME_GROUP           1051
#define IDC_PREVIEWTIME_TEXT            1052
#define IDC_CURPROVIDER_TEXT            1053
#define IDC_ALBUMBATCH_GROUP            1054
#define IDC_ALBUMINFO_TEXT              1055
#define IDC_DOWNLOAD_GROUP              1056
#define IDC_ALBUMBATCH_TEXT             1057
#define IDC_DATABASE_TEXT               1058
#define IDC_VOLCONFIG_ICON              1059
#define IDC_ARTIST_TEXT                 1060
#define IDC_TITLE_TEXT                  1061
#define IDC_AVAILTRACKS_TEXT            1062
#define IDC_PLAYLIST_TEXT               1063
#define IDC_SEPLINE1                    1064
#define IDC_SEPLINE2                    1065
#define IDC_TRAYENABLE                  1066
#define IDC_UPLOADTITLE                 1067
#define IDC_UPLOADTITLE_TEXT            1068
#define IDC_CONFIRMPROMPT               1069
#define IDC_CONFIRM_TEXT                1070
#define IDC_CDQUESTION                  1071

#define ID_DELETETITLE                  40000
#define ID_EXPAND                       40001
#define ID_EDITTITLENAME                40002
#define ID_EDITTRACKNAME                40003
#define ID_EDITARTISTNAME               40004
#define ID_DOWNLOADTITLE                40005
#define ID_HELPMENU                     40006
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\cdplay.h ===
// cdplay.h.h : Declaration of the CCDPlay

#ifndef __CDPLAY_H_
#define __CDPLAY_H_

#include "playres.h"
#include "..\main\mmfw.h"

/////////////////////////////////////////////////////////////////////////////
// CCDPlay
class CCDPlay :	public IMMComponent, IMMComponentAutomation
{
public:
	CCDPlay();
    ~CCDPlay();

// ICDPlay
public:
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();
    STDMETHOD(GetInfo)(MMCOMPDATA* mmCompData);
    STDMETHOD(Init)(IMMFWNotifySink* pSink, HWND hwndMain, RECT* pRect, HWND* phwndComp, HMENU* phMenu);
	STDMETHOD(OnAction)(MMACTIONS mmActionID, LPVOID pAction);

private:
    STDMETHOD(QueryVolumeSupport)(BOOL* pVolume, BOOL* pPan);
	void InitIcons();
    HRESULT GetTrackInfo(LPMMTRACKORDISC pInfo);
    HRESULT GetDiscInfo(LPMMTRACKORDISC pInfo);
    void NormalizeNameForMenuDisplay(TCHAR* szInput, TCHAR* szOutput, DWORD cbLen);
    void SetTrack(int nTrack);
    void SetDisc(int nDisc);

	IMMFWNotifySink* m_pSink;
	HICON m_hIcon16;
	HICON m_hIcon32;
    HMENU m_hMenu;
    HWND  m_hwndMain;

    DWORD m_dwRef;
};

class CCDPlayClassFactory : public IClassFactory
{
public:
    CCDPlayClassFactory();

    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    STDMETHOD(CreateInstance)(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
    STDMETHOD(LockServer)(BOOL fLock);

private:
    DWORD m_dwRef;
};

#endif //__CDPLAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\cdapi.h ===
/******************************Module*Header*******************************\
* Module Name: cdapi.h
*
*
*
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifdef USE_IOCTLS
#include <ntddcdrm.h>
#else
#include <mmsystem.h>
#endif

#define MAX_CD_DEVICES 50

/* -------------------------------------------------------------------------
** Defines for cdrom state
**
**  These are bit flags
** -------------------------------------------------------------------------
*/

#define CD_PLAYING          0x0001
#define CD_STOPPED          0x0002
#define CD_PAUSED           0x0004
#define CD_SKIP_F           0x0008
#define CD_SKIP_B           0x0010
#define CD_FF               0x0020
#define CD_RW               0x0040
#define CD_SEEKING          (CD_FF | CD_RW)
#define CD_LOADED           0x0080
#define CD_NO_CD            0x0100
#define CD_DATA_CD_LOADED   0x0200
#define CD_EDITING          0x0400
#define CD_PAUSED_AND_MOVED 0x0800
#define CD_PLAY_PENDING     0x1000
#define CD_WAS_PLAYING      0x2000
#define CD_IN_USE           0x4000
#define CD_BEING_SCANNED    0x8000


/* -------------------------------------------------------------------------
** Some MACROS
** -------------------------------------------------------------------------
*/

#ifdef USE_IOCTLS
#define CDHANDLE    HANDLE
#else
#define CDHANDLE    MCIDEVICEID
#endif

#define CDTIME(x)       g_Devices[x]->time
#define CURRTRACK(x)    g_Devices[x]->time.CurrTrack

#ifdef USE_IOCTLS
#define TRACK_M(x,y)    g_Devices[x]->toc.TrackData[y].Address[1]
#define TRACK_S(x,y)    g_Devices[x]->toc.TrackData[y].Address[2]
#define TRACK_F(x,y)    g_Devices[x]->toc.TrackData[y].Address[3]
#else
#define TRACK_M(x,y)    MCI_MSF_MINUTE(g_Devices[x]->toc.TrackData[y].Address)
#define TRACK_S(x,y)    MCI_MSF_SECOND(g_Devices[x]->toc.TrackData[y].Address)
#define TRACK_F(x,y)    MCI_MSF_FRAME(g_Devices[x]->toc.TrackData[y].Address)
#endif

#define FIRSTTRACK(x)   g_Devices[x]->toc.FirstTrack
#define LASTTRACK(x)    g_Devices[x]->toc.LastTrack
#define ALLTRACKS(x)    g_Devices[x]->CdInfo.AllTracks
#define PLAYLIST(x)     g_Devices[x]->CdInfo.PlayList
#define SAVELIST(x)     g_Devices[x]->CdInfo.SaveList
#define TITLE(x)        g_Devices[x]->CdInfo.Title
#define ARTIST(x)       g_Devices[x]->CdInfo.Artist
#define NUMTRACKS(x)    g_Devices[x]->CdInfo.NumTracks
#define STATE(x)        g_Devices[x]->State
#define g_State         (g_Devices[g_CurrCdrom]->State)
#define ABS(x)          ((x) < 0 ? (-(x)) : (x))


/* -------------------------------------------------------------------------
** Type definitions for CD database entries, etc.
**
** -------------------------------------------------------------------------
*/
#define TITLE_LENGTH        128
#define ARTIST_LENGTH       128
#define TRACK_TITLE_LENGTH  128
#define MAX_TRACKS          100
#define NEW_FRAMEOFFSET     1234567

#ifndef USE_IOCTLS
//
// Maximum CD Rom size
//

#define MAXIMUM_NUMBER_TRACKS 100
#define MAXIMUM_CDROM_SIZE 804


//
// Used with StatusTrackPos call
//
#define MCI_STATUS_TRACK_POS 0xBEEF

typedef struct
{
    DWORD   dwStatus;
    DWORD   dwTrack;
    DWORD   dwDiscTime;
} STATUSTRACKPOS, *PSTATUSTRACKPOS;

//
// CD ROM Table OF Contents (TOC)
//
// Format 0 - Get table of contents
//

typedef struct _TRACK_DATA {
    UCHAR TrackNumber;
    DWORD Address;
    DWORD AddressF;
} TRACK_DATA, *PTRACK_DATA;

typedef struct _CDROM_TOC {

    //
    // Header
    //

    UCHAR Length[2];
    UCHAR FirstTrack;
    UCHAR LastTrack;

    //
    // Track data
    //

    TRACK_DATA TrackData[MAXIMUM_NUMBER_TRACKS];
} CDROM_TOC, *PCDROM_TOC;

#define CDROM_TOC_SIZE sizeof(CDROM_TOC)
#endif

typedef struct _TRACK_INF {
    struct _TRACK_INF   *next;
    int                 TocIndex;
    TCHAR               name[TRACK_TITLE_LENGTH];
} TRACK_INF, *PTRACK_INF;

typedef struct _TRACK_PLAY {
    struct _TRACK_PLAY  *prevplay;
    struct _TRACK_PLAY  *nextplay;
    int                 TocIndex;
    int                 min;
    int                 sec;
} TRACK_PLAY, *PTRACK_PLAY;

typedef struct _TIMES {
    PTRACK_PLAY         CurrTrack;
    int                 TotalMin;
    int                 TotalSec;
    int                 RemMin;
    int                 RemSec;
    int                 TrackCurMin;
    int                 TrackCurSec;
    int                 TrackTotalMin;
    int                 TrackTotalSec;
    int                 TrackRemMin;
    int                 TrackRemSec;
} TIMES, *PTIMES;

typedef struct _ENTRY {
    PTRACK_INF          AllTracks;
    PTRACK_PLAY         PlayList;
    PTRACK_PLAY         SaveList;
    int                 NumTracks;
    DWORD               Id;
    BOOL                save;
    BOOL                IsVirginCd;
    int                 iFrameOffset;
    TCHAR               Title[TITLE_LENGTH];
    TCHAR               Artist[TITLE_LENGTH];
} ENTRY, *PENTRY;

typedef struct _CDROM {
    CDHANDLE            hCd;
    HANDLE              hThreadToc;
    BOOL                fIsTocValid;
    TCHAR               drive;
    DWORD               State;
    CDROM_TOC           toc;
    ENTRY               CdInfo;
    TIMES               time;
    BOOL                fShowLeadIn;
    BOOL                fProcessingLeadIn;
    BOOL                fKilledPlayList;  // Used to prevent bug with -track option
} CDROM, *PCDROM;

typedef struct _CURRPOS {
#ifdef USE_IOCTLS
    UCHAR               AudioStatus;
#else
    DWORD               AudioStatus;
#endif
    int                 Track;
    int                 Index;
    int                 m;
    int                 s;
    int                 f;
    int                 ab_m;
    int                 ab_s;
    int                 ab_f;
} CURRPOS, *PCURRPOS;


/* -------------------------------------------------------------------------
** High level function declarations
**
** -------------------------------------------------------------------------
*/

#ifdef __cplusplus
extern "C" {
#endif

void
CheckStatus(
    LPSTR szCaller,
    DWORD status,
    int cdrom
    );

void
NoMediaUpdate(
    int cdrom
    );

void
CheckUnitCdrom(
    int cdrom,
    BOOL fForceRescan
    );

BOOL
EjectTheCdromDisc(
    INT cdrom
    );

BOOL
PlayCurrTrack(
    int cdrom
    );

BOOL
StopTheCdromDrive(
    int cdrom
    );

BOOL
PauseTheCdromDrive(
    int cdrom
    );

BOOL
ResumeTheCdromDrive(
    int cdrom
    );

BOOL
SeekToCurrSecond(
    int cdrom
    );

BOOL
GetCurrPos(
    int cdrom,
    PCURRPOS CpPtr
    );

BOOL
SeekToTrackAndHold(
    int cdrom,
    int tindex
    );


/* -------------------------------------------------------------------------
** NT Layer Function Declarations
**
** These are the low-level functions that manipulate the specified CD-ROM
** device.
** -------------------------------------------------------------------------
*/
DWORD
GetCdromTOC(
    CDHANDLE,
    PCDROM_TOC
    );

DWORD
StopCdrom(
    CDHANDLE
    );

DWORD
PauseCdrom(
    CDHANDLE
    );


#ifdef USE_IOCTLS
DWORD
ResumeCdrom(
    CDHANDLE
    );

DWORD
PlayCdrom(
    CDHANDLE,
    PCDROM_PLAY_AUDIO_MSF
    );

DWORD
SeekCdrom(
    CDHANDLE,
    PCDROM_SEEK_AUDIO_MSF
    );

DWORD
GetCdromSubQData(
    CDHANDLE,
    PSUB_Q_CHANNEL_DATA,
    PCDROM_SUB_Q_DATA_FORMAT
    );

#else

DWORD
ResumeCdrom(
    CDHANDLE,
    int
    );

CDHANDLE
OpenCdRom(
    TCHAR chDrive,
    LPDWORD lpdwErrCode
    );

void
CloseCdRom(
    CDHANDLE DevHandle
    );

DWORD
GetCdromMode(
    CDHANDLE DevHandle
    );

DWORD
GetCdromCurrentTrack(
    CDHANDLE DevHandle
    );

BOOL
IsCdromTrackAudio(
    CDHANDLE DevHandle,
    int iTrackNumber
    );

DWORD
PlayCdrom(
    CDHANDLE DeviceHandle,
    MCI_PLAY_PARMS *mciPlay
    );

DWORD
SeekCdrom(
    CDHANDLE DeviceHandle,
    MCI_SEEK_PARMS *mciSeek
    );

DWORD
GetCdromCurrentPosition(
    CDHANDLE DevHandle,
    DWORD *lpdwPosition
    );

#endif

DWORD
EjectCdrom(
    CDHANDLE
    );

DWORD
TestUnitReadyCdrom(
    CDHANDLE DeviceHandle
    );

#if 0
DWORD
GetCdromVolume(
    CDHANDLE DeviceHandle
    );
#endif

DWORD
StatusTrackPosCdrom(
    MCIDEVICEID DevHandle,
    DWORD * pStatus,
    DWORD * pTrack,
    DWORD * pPos
    );

#ifdef __cplusplus
};
#endif

/* -------------------------------------------------------------------------
** Public Globals - Most of these should be treated as read only.
** -------------------------------------------------------------------------
*/
#ifndef GLOBAL
#define GLOBAL extern
#endif
GLOBAL  PCDROM  g_Devices[MAX_CD_DEVICES];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\sqlobj.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  SQLOBJ.CPP
//
//      SQL Wrapper Object
//
//      Copyright (c) Microsoft Corporation     1998
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "sqlobj.h"





SQL::SQL(void)
{
    TCHAR path[_MAX_PATH];

    GetSystemDirectory(path, sizeof(path)/sizeof(TCHAR));
    lstrcat(path, TEXT("\\odbccp32.dll"));

    m_hODBCCP = LoadLibrary(path);
    m_hODBC = NULL;
     
    if (m_hODBCCP)
    {
        GetSystemDirectory(path, sizeof(path)/sizeof(TCHAR));
        lstrcat(path, TEXT("\\odbc32.dll"));

        m_hODBC = LoadLibrary(path);
 
        if (m_hODBC == NULL)
        {
            FreeLibrary(m_hODBCCP);
        }
    }

    if (m_hODBCCP && m_hODBC)
    {
        m_pfnSetPos             = (SQ_SETPOS)           GetProcAddress( m_hODBC,   "SQLSetPos");
        m_pfnExtendedFetch      = (SQ_EXTENDEDFETCH)    GetProcAddress( m_hODBC,   "SQLExtendedFetch");
        m_pfnFreeStmt           = (SQ_FREESTMT)         GetProcAddress( m_hODBC,   "SQLFreeStmt");
        m_pfnSetStmtOption      = (SQ_SETSTMTOPTION)    GetProcAddress( m_hODBC,   "SQLSetStmtOption");
        m_pfnBindCol            = (SQ_BINDCOL)          GetProcAddress( m_hODBC,   "SQLBindCol");
        m_pfnAllocStmt          = (SQ_ALLOCSTMT)        GetProcAddress( m_hODBC,   "SQLAllocStmt");
        m_pfnFreeConnect        = (SQ_FREECONNECT)      GetProcAddress( m_hODBC,   "SQLFreeConnect");
        m_pfnFreeEnv            = (SQ_FREEENV)          GetProcAddress( m_hODBC,   "SQLFreeEnv");
        m_pfnDisconnect         = (SQ_DISCONNECT)       GetProcAddress( m_hODBC,   "SQLDisconnect");
        m_pfnAllocConnect       = (SQ_ALLOCCONNECT)     GetProcAddress( m_hODBC,   "SQLAllocConnect");
        m_pfnAllocEnv           = (SQ_ALLOCENV)         GetProcAddress( m_hODBC,   "SQLAllocEnv");
        m_pfnTransact           = (SQ_TRANSACT)         GetProcAddress( m_hODBC,   "SQLTransact");
        m_pfnFetch              = (SQ_FETCH)            GetProcAddress( m_hODBC,   "SQLFetch");

        #ifdef UNICODE
        m_pfnConfigDataSource   = (SQ_CONFIGDATASOURCE) GetProcAddress( m_hODBCCP, "SQLConfigDataSourceW");
        m_pfnConnect            = (SQ_CONNECT)          GetProcAddress( m_hODBC,   "SQLConnectW");
        m_pfnError              = (SQ_ERROR)            GetProcAddress( m_hODBC,   "SQLErrorW");
        m_pfnExecDirect         = (SQ_EXECDIRECT)       GetProcAddress( m_hODBC,   "SQLExecDirectW");
        m_pfnSetConnectOption   = (SQ_SETCONNECTOPTION) GetProcAddress( m_hODBC,   "SQLSetConnectOptionW");
        m_pfnStatistics         = (SQ_STATISTICS)       GetProcAddress( m_hODBC,   "SQLStatisticsW");
        m_pfnDescribeCol        = (SQ_DESCRIBECOL)      GetProcAddress( m_hODBC,   "SQLDescribeColW");
        #else
        //for some reason, there is no "A" on odbc's export of SQLConfigDataSource
        m_pfnConfigDataSource   = (SQ_CONFIGDATASOURCE) GetProcAddress( m_hODBCCP, "SQLConfigDataSource");
        m_pfnConnect            = (SQ_CONNECT)          GetProcAddress( m_hODBC,   "SQLConnectA");
        m_pfnError              = (SQ_ERROR)            GetProcAddress( m_hODBC,   "SQLErrorA");
        m_pfnExecDirect         = (SQ_EXECDIRECT)       GetProcAddress( m_hODBC,   "SQLExecDirectA");
        m_pfnSetConnectOption   = (SQ_SETCONNECTOPTION) GetProcAddress( m_hODBC,   "SQLSetConnectOptionA");
        m_pfnStatistics         = (SQ_STATISTICS)       GetProcAddress( m_hODBC,   "SQLStatisticsA");
        m_pfnDescribeCol        = (SQ_DESCRIBECOL)      GetProcAddress( m_hODBC,   "SQLDescribeColA");
        #endif

        if (!m_pfnConfigDataSource  || !m_pfnSetPos         || !m_pfnExtendedFetch  || !m_pfnFreeStmt       || !m_pfnExecDirect     ||
            !m_pfnSetStmtOption     || !m_pfnBindCol        || !m_pfnError          || !m_pfnAllocStmt      || !m_pfnFreeConnect    ||
            !m_pfnFreeEnv           || !m_pfnDisconnect     || !m_pfnConnect        || !m_pfnAllocConnect   || !m_pfnAllocEnv       ||
            !m_pfnSetConnectOption  || !m_pfnTransact       || !m_pfnFetch          || !m_pfnStatistics     || !m_pfnDescribeCol)
        {
            FreeLibrary(m_hODBC);
            FreeLibrary(m_hODBCCP);
            m_hODBC = NULL;
            m_hODBCCP = NULL;
        }

    }
}



SQL::~SQL(void)
{
    if (m_hODBC)
    {
        FreeLibrary(m_hODBC);
    }

    if (m_hODBCCP)
    {
        FreeLibrary(m_hODBCCP);
    }
}


BOOL SQL::Initialize(void)
{
    return (m_hODBC != NULL);
}

BOOL INSTAPI SQL::ConfigDataSource(HWND hwndParent, WORD fRequest,LPCTSTR lpszDriver, LPCTSTR lpszAttributes)
{
    return m_pfnConfigDataSource(hwndParent, fRequest, lpszDriver, lpszAttributes);
}


SQLRETURN  SQL_API SQL::SetPos( SQLHSTMT hstmt, SQLUSMALLINT irow, SQLUSMALLINT fOption, SQLUSMALLINT fLock)
{
    return m_pfnSetPos( hstmt, irow, fOption, fLock);
}


SQLRETURN  SQL_API SQL::ExtendedFetch( SQLHSTMT hstmt, SQLUSMALLINT fFetchType, SQLINTEGER irow, SQLUINTEGER *pcrow, SQLUSMALLINT *rgfRowStatus)
{
    return m_pfnExtendedFetch( hstmt, fFetchType, irow, pcrow, rgfRowStatus);
}


SQLRETURN  SQL_API SQL::FreeStmt(SQLHSTMT StatementHandle, SQLUSMALLINT Option)
{
    return m_pfnFreeStmt(StatementHandle, Option);
}


SQLRETURN  SQL_API SQL::ExecDirect(SQLHSTMT StatementHandle, SQLCHAR *StatementText, SQLINTEGER TextLength)
{
    return m_pfnExecDirect(StatementHandle, StatementText, TextLength);
}


SQLRETURN  SQL_API SQL::SetStmtOption(SQLHSTMT StatementHandle, SQLUSMALLINT Option, SQLUINTEGER Value)
{
    return m_pfnSetStmtOption(StatementHandle, Option, Value);
}


SQLRETURN  SQL_API SQL::BindCol(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType, SQLPOINTER TargetValue, SQLINTEGER BufferLength, SQLINTEGER *StrLen_or_Ind)
{
    return m_pfnBindCol(StatementHandle, ColumnNumber, TargetType, TargetValue, BufferLength, StrLen_or_Ind);
}


SQLRETURN  SQL_API SQL::Error(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle, SQLHSTMT StatementHandle, SQLCHAR *Sqlstate, SQLINTEGER *NativeError, SQLCHAR *MessageText, SQLSMALLINT BufferLength, SQLSMALLINT *TextLength)
{
    return m_pfnError(EnvironmentHandle, ConnectionHandle, StatementHandle, Sqlstate, NativeError, MessageText, BufferLength, TextLength);
}


SQLRETURN  SQL_API SQL::AllocStmt(SQLHDBC ConnectionHandle, SQLHSTMT *StatementHandle)
{
    return m_pfnAllocStmt(ConnectionHandle, StatementHandle);
}


SQLRETURN  SQL_API SQL::FreeConnect(SQLHDBC ConnectionHandle)
{
    return m_pfnFreeConnect(ConnectionHandle);
}


SQLRETURN  SQL_API SQL::FreeEnv(SQLHENV EnvironmentHandle)
{
    return m_pfnFreeEnv(EnvironmentHandle);
}


SQLRETURN  SQL_API SQL::Disconnect(SQLHDBC ConnectionHandle)
{
    return m_pfnDisconnect(ConnectionHandle);
}


SQLRETURN  SQL_API SQL::Connect(SQLHDBC ConnectionHandle, SQLCHAR *ServerName, SQLSMALLINT NameLength1, SQLCHAR *UserName, SQLSMALLINT NameLength2, SQLCHAR *Authentication, SQLSMALLINT NameLength3)
{
    return m_pfnConnect(ConnectionHandle, ServerName, NameLength1, UserName, NameLength2, Authentication, NameLength3);
}


SQLRETURN  SQL_API SQL::AllocConnect(SQLHENV EnvironmentHandle, SQLHDBC *ConnectionHandle)
{
    return m_pfnAllocConnect(EnvironmentHandle, ConnectionHandle);
}


SQLRETURN  SQL_API SQL::AllocEnv(SQLHENV *EnvironmentHandle)
{
    return m_pfnAllocEnv(EnvironmentHandle);
}


SQLRETURN  SQL_API SQL::SetConnectOption(SQLHDBC ConnectionHandle, SQLUSMALLINT Option, SQLUINTEGER Value)
{
    return m_pfnSetConnectOption(ConnectionHandle, Option, Value);
}


SQLRETURN  SQL_API SQL::Transact(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle, SQLUSMALLINT CompletionType)
{
    return m_pfnTransact(EnvironmentHandle, ConnectionHandle, CompletionType);
}


SQLRETURN  SQL_API SQL::Fetch(SQLHSTMT StatementHandle)
{
    return m_pfnFetch(StatementHandle);
}


SQLRETURN  SQL_API SQL::Statistics(SQLHSTMT StatementHandle, SQLCHAR *CatalogName, SQLSMALLINT NameLength1, SQLCHAR *SchemaName, SQLSMALLINT NameLength2, SQLCHAR *TableName, SQLSMALLINT NameLength3, SQLUSMALLINT Unique, SQLUSMALLINT Reserved)
{
    return m_pfnStatistics(StatementHandle, CatalogName, NameLength1, SchemaName, NameLength2, TableName, NameLength3, Unique, Reserved);
}

SQLRETURN  SQL_API SQL::DescribeCol(SQLHSTMT StatementHandle, SQLSMALLINT ColumnNumber, SQLCHAR * ColumnName, SQLSMALLINT BufferLength, SQLSMALLINT * NameLengthPtr, SQLSMALLINT * DataTypePtr, SQLUINTEGER * ColumnSizePtr, SQLSMALLINT * DecimalDigitsPtr, SQLSMALLINT * NullablePtr)
{
    return m_pfnDescribeCol(StatementHandle, ColumnNumber, ColumnName, BufferLength, NameLengthPtr, DataTypePtr, ColumnSizePtr, DecimalDigitsPtr, NullablePtr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\titleopt.cpp ===
//--------------------------------------------------------------------------;
//
//  File: titleopt.cpp
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved
//
//--------------------------------------------------------------------------;

#include "precomp.h"
#include "cdopti.h"
#include "cdoptimp.h"
#include "helpids.h"

//////////////
// Help ID's
//////////////

#pragma data_seg(".text")
const static DWORD aTitleOptsHelp[] =
{
    IDC_CURPROVIDER_TEXT,       IDH_SELECTCURRENTPROVIDER,
    IDC_PROVIDERPICKER,         IDH_SELECTCURRENTPROVIDER,
    IDC_ALBUMBATCH_GROUP,       IDH_ABOUTBATCHING,
    IDC_ALBUMINFO_TEXT,         IDH_ABOUTALBUMS,
    IDC_DOWNLOADPROMPT,         IDH_DOWNLOADPROMPT,
    IDC_BATCHENABLED,           IDH_BATCHENABLED,
    IDC_TITLERESTORE,           IDH_TITLEDEFAULTS,
    IDC_BATCHTEXT,              IDH_NUMBATCHED,
    IDC_DOWNLOADENABLED,        IDH_AUTODOWNLOADENABLED,
    IDC_DOWNLOADNOW,            IDH_DOWNLOADNOW,
    IDC_DOWNLOAD_GROUP,         IDH_DOWNLOADING,
    IDC_ALBUMBATCH_TEXT,        IDH_ABOUTBATCHING,
    0, 0
};
#pragma data_seg()

////////////
// Functions
////////////

STDMETHODIMP_(void) CCDOpt::ToggleInternetDownload(HWND hDlg)
{
    if (m_pCDCopy)
    {
        LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

        pCDData->fDownloadEnabled = Button_GetCheck(GetDlgItem(hDlg, IDC_DOWNLOADENABLED));

        EnableWindow(GetDlgItem(hDlg, IDC_PROVIDERPICKER),   pCDData->fDownloadEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_CURPROVIDER_TEXT), pCDData->fDownloadEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOADPROMPT),   pCDData->fDownloadEnabled);


        ToggleApplyButton(hDlg);
    }
}


STDMETHODIMP_(void) CCDOpt::UpdateBatched(HWND hDlg)
{
    if (hDlg != NULL)
    {
        TCHAR szNum[MAX_PATH];
        TCHAR szBatch[MAX_PATH];

        if (m_pCDOpts->dwBatchedTitles == 0 || m_pCDOpts->pfnDownloadTitle == NULL)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOADNOW), FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOADNOW), TRUE);
        }

        LoadString( m_hInst, IDS_BATCHTEXT, szBatch, sizeof( szBatch )/sizeof(TCHAR) );
        wsprintf(szNum, TEXT("%s %d"), szBatch, m_pCDOpts->dwBatchedTitles);
        SetWindowText(GetDlgItem(hDlg, IDC_BATCHTEXT), szNum);
    }
}


STDMETHODIMP_(BOOL) CCDOpt::InitTitleOptions(HWND hDlg)
{
    if (m_pCDCopy)
    {
        LPCDOPTDATA pCDData = m_pCDCopy->pCDData;
        LPCDPROVIDER pProvider;

        CheckDlgButton(hDlg, IDC_DOWNLOADENABLED,   pCDData->fDownloadEnabled);
        CheckDlgButton(hDlg, IDC_DOWNLOADPROMPT,    pCDData->fDownloadPrompt);
        CheckDlgButton(hDlg, IDC_BATCHENABLED,      pCDData->fBatchEnabled);

        m_hTitleWnd = hDlg;
        UpdateBatched(m_hTitleWnd);

        SendDlgItemMessage(hDlg, IDC_PROVIDERPICKER, CB_RESETCONTENT,0,0);

        pProvider = m_pCDCopy->pProviderList;

        while (pProvider)
        {
            LRESULT dwIndex = SendDlgItemMessage(hDlg, IDC_PROVIDERPICKER, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) pProvider->szProviderName);

            if (dwIndex != CB_ERR && dwIndex != CB_ERRSPACE)
            {
                SendDlgItemMessage(hDlg, IDC_PROVIDERPICKER, CB_SETITEMDATA,  (WPARAM) dwIndex, (LPARAM) pProvider);

                if (pProvider == m_pCDCopy->pCurrentProvider)
                {
                    SendDlgItemMessage(hDlg, IDC_PROVIDERPICKER, CB_SETCURSEL,  (WPARAM) dwIndex, 0);
                }
            }

            pProvider = pProvider->pNext;
        }

        ToggleInternetDownload(hDlg);
    }

    return TRUE;
}


STDMETHODIMP_(void) CCDOpt::RestoreTitleDefaults(HWND hDlg)
{
    if (m_pCDCopy)
    {
        LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

        pCDData->fDownloadEnabled   = CDDEFAULT_DOWNLOADENABLED;
        pCDData->fDownloadPrompt    = CDDEFAULT_DOWNLOADPROMPT;
        pCDData->fBatchEnabled       = CDDEFAULT_BATCHENABLED;

        m_pCDCopy->pCurrentProvider = m_pCDCopy->pDefaultProvider;

        InitTitleOptions(hDlg);

        ToggleApplyButton(hDlg);
    }
}



STDMETHODIMP_(void) CCDOpt::ChangeCDProvider(HWND hDlg)
{
    if (m_pCDCopy)
    {
        LRESULT dwResult = SendDlgItemMessage(hDlg, IDC_PROVIDERPICKER, CB_GETCURSEL, 0, 0);

        if (dwResult != CB_ERR)
        {
            dwResult = SendDlgItemMessage(hDlg, IDC_PROVIDERPICKER, CB_GETITEMDATA,  (WPARAM) dwResult, 0);

            if (dwResult != CB_ERR)
            {
                m_pCDCopy->pCurrentProvider = (LPCDPROVIDER) dwResult;
            }
        }

        ToggleApplyButton(hDlg);
    }
}


STDMETHODIMP_(void) CCDOpt::DownloadNow(HWND hDlg)
{
    if (m_pCDOpts->dwBatchedTitles && m_pCDOpts->pfnDownloadTitle)
    {
        TCHAR szNum[MAX_PATH];
        TCHAR szBatch[MAX_PATH];

        m_pCDOpts->dwBatchedTitles = m_pCDOpts->pfnDownloadTitle(NULL, m_pCDOpts->lParam, hDlg);

        EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOADNOW), m_pCDOpts->dwBatchedTitles != 0);

        LoadString( m_hInst, IDS_BATCHTEXT, szBatch, sizeof( szBatch )/sizeof(TCHAR) );
        wsprintf(szNum, TEXT("%s %d"), szBatch, m_pCDOpts->dwBatchedTitles);
        SetWindowText(GetDlgItem(hDlg, IDC_BATCHTEXT), szNum);
    }
}


STDMETHODIMP_(INT_PTR) CCDOpt::TitleOptions(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fResult = TRUE;

    switch (msg)
    {
        default:
            fResult = FALSE;
        break;

        case WM_DESTROY:
        {
            m_hTitleWnd = NULL;
        }
        break;

        case WM_CONTEXTMENU:
        {
            WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)aTitleOptsHelp);
        }
        break;

        case WM_HELP:
        {
            WinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPSTR)aTitleOptsHelp);
        }
        break;

        case WM_INITDIALOG:
        {
            fResult = InitTitleOptions(hDlg);
        }
        break;

        case WM_COMMAND:
        {
            LPCDOPTDATA pCDData = m_pCDCopy->pCDData;

            switch (LOWORD(wParam))
            {
                case IDC_TITLERESTORE:
                    RestoreTitleDefaults(hDlg);
                break;

                case IDC_DOWNLOADENABLED:
                    ToggleInternetDownload(hDlg);
                break;

                case IDC_DOWNLOADPROMPT:
                    pCDData->fDownloadPrompt = Button_GetCheck(GetDlgItem(hDlg, IDC_DOWNLOADPROMPT));
                    ToggleApplyButton(hDlg);
                break;

                case IDC_BATCHENABLED:
                    pCDData->fBatchEnabled = Button_GetCheck(GetDlgItem(hDlg, IDC_BATCHENABLED));
                    ToggleApplyButton(hDlg);
                break;

                case IDC_DOWNLOADNOW:
                    DownloadNow(hDlg);
                break;

                case IDC_PROVIDERPICKER:
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        ChangeCDProvider(hDlg);
                    }
                }
                break;

                default:
                    fResult = FALSE;
                break;
            }
        }
        break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
                case PSN_APPLY:
                {
                    ApplyCurrentSettings();
                }
            }
        }
        break;
    }

    return fResult;
}

///////////////////
// Dialog handler
//
INT_PTR CALLBACK CCDOpt::TitleOptionsProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);

    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) ((LPPROPSHEETPAGE) lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);
    }

    if (pCDOpt)
    {
        fResult = pCDOpt->TitleOptions(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\commands.h ===
/******************************Module*Header*******************************\
* Module Name: commands.h
*
* Functions that execue the users commands.
*
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

void
CdPlayerEjectCmd(
    void
    );

void
CdPlayerPlayCmd(
    void
    );

void
CdPlayerPauseCmd(
    void
    );


void
CdPlayerStopCmd(
    void
    );

void
CdPlayerPrevTrackCmd(
    void
    );

void
CdPlayerNextTrackCmd(
    void
    );

void
CdPlayerSeekCmd(
    HWND    hwnd,
    BOOL    fStart,
    UINT    uDirection
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdopt\volopt.cpp ===
//--------------------------------------------------------------------------;
//
//  File: volopt.cpp
//
//  Copyright (c) 1998 Microsoft Corporation.  All rights reserved
//
//--------------------------------------------------------------------------;

#include "precomp.h"
#include <regstr.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "optres.h"
#include "cdopti.h"
#include "cdoptimp.h"
#include "helpids.h"
#include "winbase.h"

//////////////
// Help ID's
//////////////

#pragma data_seg(".text")
const static DWORD aVolOptsHelp[] =
{
    IDC_VOLCONFIG_ICON,     IDH_VOL_MSG,
    IDC_VOL_MSG_TEXT,       IDH_VOL_MSG,
    IDC_VOL_CONFIG_GROUP,   IDH_VOL_MSG,
    IDC_DEFAULTMIXER,       IDH_USEMIXERDEFAULTS,
    IDC_SELECTPLAYER_TEXT,  IDH_SELECTCDPLAYER,
    IDC_CDDRIVE,            IDH_SELECTCDPLAYER,
    IDC_SELECTMIXER_TEXT,   IDH_SELECTCDMIXER,
    IDC_AUDIOMIXER,         IDH_SELECTCDMIXER,
    IDC_SELECTCONTROL_TEXT, IDH_SELECTCDCONTROL,
    IDC_AUDIOCONTROL,       IDH_SELECTCDCONTROL,
    0, 0
};
#pragma data_seg()

////////////
// Types
////////////

typedef struct CDCTL            // Used to write to reg (don't change)
{
    DWORD dwVolID;
    DWORD dwMuteID;
    DWORD dwDestID;

} CDCTL, *LPCDCTL;



////////////
// Globals
////////////
#define MYREGSTR_PATH_MEDIA  TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaResources")
const TCHAR gszRegstrCDAPath[]   = MYREGSTR_PATH_MEDIA TEXT("\\mci\\cdaudio");
const TCHAR gszDefaultCDA[]      = TEXT("Default Drive");

const TCHAR szRegstrCDROMPath[]  = TEXT("System\\CurrentControlSet\\Services\\Class\\");
const TCHAR szPrefMixer[]        = TEXT("Preferred Mixer");
const TCHAR szPrefControls[]     = TEXT("Preferred Controls");
const TCHAR szSelected[]         = TEXT("Selected");

const TCHAR szMapperPath[]       = TEXT("Software\\Microsoft\\Multimedia\\Sound Mapper");
const TCHAR szPlayback[]         = TEXT("Playback");
const TCHAR szPreferredOnly[]    = TEXT("PreferredOnly");

const TCHAR szNTCDROMPath[]      = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\DeluxeCD\\Settings\\");



////////////
// Functions
////////////


/////////////
// Uses new winmm feature to get the preferred wave ID, much cleaner.
//
STDMETHODIMP_(MMRESULT) CCDOpt::GetDefaultMixID(DWORD *pdwMixID)
{
    MMRESULT        mmr;
    DWORD           dwWaveID;
    DWORD           dwFlags = 0;
	UINT			dwMixID = 0;

    mmr = waveOutMessage((HWAVEOUT)(UINT_PTR)WAVE_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pdwMixID)
    {
		mmr = mixerGetID((HMIXEROBJ)ULongToPtr(dwWaveID), &dwMixID, MIXER_OBJECTF_WAVEOUT);

		if(MMSYSERR_NOERROR == mmr)
		{
			*pdwMixID = dwMixID;
		}
    }

    return(mmr);
}


///////////
// A mixer line has been found with controls, this function is called to either 1) verify
// that passed in VolID and MuteID's can be found on this mixer line and are of the right
// control type.  or 2) to find the Volume Slider and Mute ID controls that do exist on
// this mixer line.
//

STDMETHODIMP_(void) CCDOpt::SearchControls(int mxid, LPMIXERLINE pml, LPDWORD pdwVolID, LPDWORD pdwMuteID, TCHAR *szName, BOOL *pfFound, BOOL fVerify)
{
    MIXERLINECONTROLS mlc;
    DWORD dwControl;

    memset(&mlc, 0, sizeof(mlc));
    mlc.cbStruct = sizeof(mlc);
    mlc.dwLineID = pml->dwLineID;
    mlc.cControls = pml->cControls;
    mlc.cbmxctrl = sizeof(MIXERCONTROL);
    mlc.pamxctrl = (LPMIXERCONTROL) new(MIXERCONTROL[pml->cControls]);

    if (mlc.pamxctrl)
    {
        if (mixerGetLineControls((HMIXEROBJ)IntToPtr(mxid), &mlc, MIXER_GETLINECONTROLSF_ALL) == MMSYSERR_NOERROR)
        {
            for (dwControl = 0; dwControl < pml->cControls && !(*pfFound); dwControl++)
            {
                if (mlc.pamxctrl[dwControl].dwControlType == (DWORD)MIXERCONTROL_CONTROLTYPE_VOLUME)
                {
                    DWORD dwIndex;
                    DWORD dwVolID = DWORD(-1);
                    DWORD dwMuteID = DWORD(-1);

                    dwVolID = mlc.pamxctrl[dwControl].dwControlID;

                    for (dwIndex = 0; dwIndex < pml->cControls; dwIndex++)
                    {
                        if (mlc.pamxctrl[dwIndex].dwControlType == (DWORD)MIXERCONTROL_CONTROLTYPE_MUTE)
                        {
                            dwMuteID = mlc.pamxctrl[dwIndex].dwControlID;
                            break;
                        }
                    }

                    if (fVerify)
                    {
                        if (*pdwVolID == dwVolID && *pdwMuteID == dwMuteID)
                        {
                            if (szName)
                            {
                                lstrcpy(szName, pml->szName); // mlc.pamxctrl[dwControl].szName);
                            }

                            *pfFound = TRUE;
                        }
                    }
                    else
                    {
                        if (szName)
                        {
                            lstrcpy(szName, pml->szName); // mlc.pamxctrl[dwControl].szName);
                        }

                        *pfFound = TRUE;
                        *pdwVolID = dwVolID;
                        *pdwMuteID = dwMuteID;
                    }
                }
            }
        }

        delete mlc.pamxctrl;
    }
}

///////////////
// If a mixer line has connects, this function is called to enumerate all lines that have controls
// that meet our criteria and then seek out the controls on those connections using the above SearchControls
// function.
//
// NOTE: This function makes two scans over the connections, first looking for CompactDisc lines, and then
// if unsuccessful, it makes a second scan looking for other lines that might have a CD connected, like line-in
// and aux lines.
//
STDMETHODIMP_(void) CCDOpt::SearchConnections(int mxid, DWORD dwDestination, DWORD dwConnections, LPDWORD pdwVolID, LPDWORD pdwMuteID, TCHAR *szName, BOOL *pfFound, BOOL fVerify)
{
    MIXERLINE   mlDst;
    DWORD       dwConnection;
    DWORD       dwScan;

    for (dwScan = 0; dwScan < 2 && !(*pfFound); dwScan++)  // On first scan look for CD, on second scan, look for anything else.
    {
        for (dwConnection = 0; dwConnection < dwConnections && !(*pfFound); dwConnection++)
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwDestination  = dwDestination;
            mlDst.dwSource = dwConnection;

            if (mixerGetLineInfo((HMIXEROBJ)IntToPtr(mxid), &mlDst, MIXER_GETLINEINFOF_SOURCE) == MMSYSERR_NOERROR)
            {
                if (mlDst.cControls)    // Make sure this source has controls on it
                {
                    if (((dwScan == 0) && (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC)) ||
                        ((dwScan == 1) && (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_LINE ||
                                           mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY ||
                                           mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_DIGITAL ||
                                           mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_ANALOG)))
                    {
                        SearchControls(mxid, &mlDst, pdwVolID, pdwMuteID, szName, pfFound, fVerify);
                    }
                }
            }
        }
    }
}


/////////////////
// Used in two modes, fVerify is TRUE,  the VolID and MuteID are inputs and will return TRUE if valid
// if not in verification mode, this function is used to compute the default vol and mute ID's for this device.
// It scans all the destinations on the Mixer looking for output destinations (speakers, headphones, etc)
// Once it finds them, it then Searchs for controls on itself and/or any connections itself.
//
// NOTE: The current default behavior is to locate CD type connections, and then, if not finding any that
// work, to attempt to use the destination master volume.  To reverse this, look for master volume first, and then
// look for CD lines if master can't be found, Switch the two intermost If conditions and calls so that
// SearchControls on the line happens before the connections are searched.

STDMETHODIMP_(BOOL) CCDOpt::SearchDevice(DWORD dwMixID, LPCDUNIT pCDUnit, LPDWORD pdwDestID, LPDWORD pdwVolID, LPDWORD pdwMuteID, TCHAR *szName, BOOL fVerify)
{
    MIXERCAPS mc;
    MMRESULT mmr;
    BOOL    fFound = FALSE;

    mmr = mixerGetDevCaps(dwMixID, &mc, sizeof(mc));

    if (mmr == MMSYSERR_NOERROR)
    {
        MIXERLINE   mlDst;
        DWORD       dwDestination;
        DWORD       cDestinations;

        if (pCDUnit)
        {
            lstrcpy(pCDUnit->szMixerName, mc.szPname);
        }

        dwDestination = 0;              // Setup loop to check all destinations
        cDestinations = mc.cDestinations;

        if (fVerify)                    // If in Verify mode, only check the specified destination ID
        {
            dwDestination = *pdwDestID;
            cDestinations = dwDestination + 1;
        }

        for ( ; dwDestination < cDestinations && !fFound; dwDestination++)
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwDestination = dwDestination;

            if (mixerGetLineInfo((HMIXEROBJ)ULongToPtr(dwMixID), &mlDst, MIXER_GETLINEINFOF_DESTINATION  ) == MMSYSERR_NOERROR)
            {
                if (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_SPEAKERS ||    // needs to be a likely output destination
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_HEADPHONES ||
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT)
                {
                    // Note: To default to Master Volume (instead of CD volume) just SearchControls first.

                    if (!fFound && mlDst.cConnections)  // only look at connections if there is no master slider control.
                    {
                        SearchConnections(dwMixID, dwDestination, mlDst.cConnections, pdwVolID, pdwMuteID, szName, &fFound, fVerify);
                    }

                    if (!fFound && mlDst.cControls)     // If there are controls, we'll take the master
                    {
                        SearchControls(dwMixID, &mlDst, pdwVolID, pdwMuteID, szName, &fFound, fVerify);
                    }

                    *pdwDestID = dwDestination;
                }
            }
        }
    }

    return(fFound);
}


////////////////
// When a new CD is found, and there are no valid enteries in the registry for it, we compute
// defaults for that unit.  This function uses the above function SearchDevice to do just that.
// First it finds the preferred MixerID and assumes this CD is connected to it, this it finds
// the default controls on that mixer and assignes them.
//
STDMETHODIMP_(void) CCDOpt::GetUnitDefaults(LPCDUNIT pCDUnit)
{
    if (pCDUnit)
    {
        pCDUnit->dwMixID = DWORD(-1);
        pCDUnit->dwVolID = DWORD(-1);
        pCDUnit->dwMuteID = DWORD(-1);
        pCDUnit->dwDestID = DWORD(-1);

        if (GetDefaultMixID(&pCDUnit->dwMixID) == MMSYSERR_NOERROR)
        {
            SearchDevice(pCDUnit->dwMixID, pCDUnit, &pCDUnit->dwDestID, &pCDUnit->dwVolID, &pCDUnit->dwMuteID, pCDUnit->szVolName, FALSE);
        }
    }
}



//////////////
// This function enumerates installed disk devices that are of type CDROM and are installed
// It seeks out the one that matches the specified drive letter and collects information about it
// It returns the class driver path and the descriptive name of the drive.
//
// NOTE This function assumes both szDriver and szDevDesc are the dwSize bytes each.
//
STDMETHODIMP_(BOOL) CCDOpt::MapLetterToDevice(TCHAR DriveLetter, TCHAR *szDriver, TCHAR *szDevDesc, DWORD dwSize)
{
    HKEY hkEnum;
    BOOL fResult = FALSE;

    if (!RegOpenKey(HKEY_DYN_DATA, REGSTR_PATH_DYNA_ENUM, &hkEnum))
    {
        HKEY      hkDev;
        DWORD     dwEnumDevCnt;
        TCHAR     aszCMKey[MAX_PATH];
        BOOLEAN   found = FALSE;

        for (dwEnumDevCnt = 0; !found && !RegEnumKey(hkEnum, dwEnumDevCnt, aszCMKey, sizeof(aszCMKey)/sizeof(TCHAR)); dwEnumDevCnt++)
        {
            if (!RegOpenKey(hkEnum, aszCMKey, &hkDev))
            {
                TCHAR aszDrvKey[MAX_PATH];
                TCHAR tmp;
                DWORD cb = sizeof(aszDrvKey);

                RegQueryValueEx(hkDev, REGSTR_VAL_HARDWARE_KEY, NULL, NULL, (LPBYTE)&aszDrvKey, &cb);

                tmp = aszDrvKey[5];
                aszDrvKey[5] = TEXT('\0');

			    if ( !lstrcmpi( REGSTR_VAL_SCSI, aszDrvKey ) )
                {
                    HKEY  hkDrv;
                    TCHAR aszEnumKey[MAX_PATH];
                    aszDrvKey[5] = tmp;

                    wsprintf(aszEnumKey, TEXT("Enum\\%s"), aszDrvKey);

                    if (!RegOpenKey(HKEY_LOCAL_MACHINE, aszEnumKey, &hkDrv))
                    {
                        TCHAR DrvLet[3];

                        cb = sizeof( DrvLet );

                        RegQueryValueEx(hkDrv, REGSTR_VAL_CURDRVLET, NULL, NULL, (LPBYTE)&DrvLet, &cb);

                        if ( DrvLet[0] == DriveLetter )
                        {
                            DWORD cb2 = dwSize;
                            cb = dwSize;

                            if ((RegQueryValueEx(hkDrv, REGSTR_VAL_DEVDESC, NULL, NULL, (LPBYTE)szDevDesc, &cb) == NO_ERROR) &&
                                (RegQueryValueEx(hkDrv, REGSTR_VAL_DRIVER, NULL, NULL, (LPBYTE)szDriver, &cb2) == NO_ERROR))
                            {
                                fResult = TRUE;
                            }

                            found = TRUE;
                        }

                        RegCloseKey(hkDrv);
                    }
                }

                RegCloseKey(hkDev);
            }
        }

        RegCloseKey(hkEnum);
    }

    if (!fResult)
    {
        //check to see if we're on NT
        OSVERSIONINFO os;
        os.dwOSVersionInfoSize = sizeof(os);
        GetVersionEx(&os);
        if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            TCHAR szDrive[MAX_PATH];
            TCHAR szDriverTemp[MAX_PATH*2];
            TCHAR* szGUID = NULL;
            ZeroMemory(szDriverTemp,sizeof(szDriverTemp));
            ZeroMemory(szDriver,dwSize);

            wsprintf(szDrive,TEXT("%c:\\"),DriveLetter);
            if (GetVolumeNameForVolumeMountPoint(szDrive,szDriverTemp,dwSize/sizeof(TCHAR)))
            {
                //szDriverTemp now has a string like \\?\Volume{GUID}\ ... we just want
                //the {GUID} part, as that is the drive's unique ID.
                szGUID = _tcschr(szDriverTemp,TEXT('{'));
                if (szGUID!=NULL)
                {
                    fResult = TRUE;
                    _tcscpy(szDriver,szGUID);
                    if (szDriver[_tcslen(szDriver)-1] != TEXT('}'))
                    {
                        szDriver[_tcslen(szDriver)-1] = TEXT('\0');
                    }
                }
            }
        } //end if NT
    }

    return(fResult);
}


///////////////
//  Since audio devices can come and go, the names of the devices can change since there is
//  number appended by the system inclosed in brackets at the end of the string.
//  This function attempts to truncate this appended number after copying the original into
//  the destination buffer.
//
STDMETHODIMP_(BOOL) CCDOpt::TruncName(TCHAR *pDest, TCHAR *pSrc)
{
    BOOL fSuccess = TRUE;

    TCHAR *pTrunc;

    lstrcpy(pDest, pSrc);

    pTrunc = pDest;
    while (*pTrunc++);

    while (pTrunc-- > pDest)
    {
        if (*pTrunc == TEXT('['))
        {
            *pTrunc = TEXT('\0');
            break;
        }
    }

    if (pTrunc == pDest)
    {
        fSuccess = FALSE;
    }

    return(fSuccess);
}


/////////////////
// After reading the preferred mixer device name from the registry, we have to locate that
// device in the system by mixer ID.  To do this, we scan thru all available mixers looking
// for an exact match of the name.  If an exact match can not be found, we then scan again
// looking for a match using truncated strings where the system appended instance number is
// removed.  If we can't find it at that point, we are in trouble and have to give up.
//
STDMETHODIMP CCDOpt::ComputeMixID(LPDWORD pdwMixID, TCHAR *szMixerName)
{
    HRESULT     hr = E_FAIL;
    DWORD       dwNumMixers;
    DWORD       dwID;
    MMRESULT    mmr;
    BOOL        fFound = FALSE;
    TCHAR       szTruncName[MAXPNAMELEN];
    TCHAR       szTruncSeek[MAXPNAMELEN];
    MIXERCAPS   mc;

    dwNumMixers = mixerGetNumDevs();

    for (dwID = 0; dwID < dwNumMixers && !fFound; dwID++)          // First look for EXACT match.
    {
        mmr = mixerGetDevCaps(dwID, &mc, sizeof(mc));

        if (mmr == MMSYSERR_NOERROR)
        {
			if (!lstrcmp(mc.szPname, szMixerName))
			{
                hr = S_OK;
                fFound = TRUE;
                *pdwMixID = dwID;
            }
        }
    }

    if (!fFound)    // Exact match isn't found, strip off (#) and look again
    {
        if (TruncName(szTruncName, szMixerName))
        {
            for (dwID = 0; dwID < dwNumMixers && !fFound; dwID++)
            {
                mmr = mixerGetDevCaps(dwID, &mc, sizeof(mc));

                if (mmr == MMSYSERR_NOERROR)
                {
                    TruncName(szTruncSeek, mc.szPname);

			        if (!lstrcmp(szTruncSeek, szTruncName))
			        {
                        lstrcpy(szMixerName, mc.szPname); // repair the name we matched
                        hr = S_OK;
                        fFound = TRUE;
                        *pdwMixID  = dwID;
                    }
                }
            }
        }
    }

    return(hr);
}

///////////////
// This function looks up this devices registry information using the driver information that
// was mapped from the drive letter.  It attempts to read in the preferred mixer ID and then
// calculate the mixerID from it, if that fails, the function fails and the unit will use default
// information calcuated by this program.  If it succeeds, it then reads in the control ID's for
// the volume and mute controls for this mixer.  If it can't find them or the ones it does find
// can not be located on the specified device, then we compute defaults.  If we can't compute defaults
// the entire function fails and the entire drive is re-computed.
//
STDMETHODIMP CCDOpt::GetUnitRegData(LPCDUNIT pCDUnit)
{
    HRESULT     hr = E_FAIL;
    TCHAR       szRegDriverStr[MAX_PATH];
    HKEY        hKey;
    DWORD       dwMixID;
    CDCTL       cdCtl;
    HKEY        hKeyRoot = HKEY_LOCAL_MACHINE;

    if (pCDUnit)
    {
        OSVERSIONINFO os;
        os.dwOSVersionInfoSize = sizeof(os);
        GetVersionEx(&os);
        if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            hKeyRoot = HKEY_CURRENT_USER;
            wsprintf(szRegDriverStr,TEXT("%s%s"),szNTCDROMPath, pCDUnit->szDriver);
        }
        else
        {
            wsprintf(szRegDriverStr,TEXT("%s%s"),szRegstrCDROMPath, pCDUnit->szDriver);
        }

        if (RegOpenKeyEx(hKeyRoot , szRegDriverStr , 0 , KEY_READ , &hKey) == ERROR_SUCCESS)
        {
            DWORD dwSize = sizeof(BOOL);

            RegQueryValueEx(hKey, szSelected, NULL, NULL, (LPBYTE) &(pCDUnit->fSelected), &dwSize);

            dwSize = MAXPNAMELEN*sizeof(TCHAR);

            if (RegQueryValueEx(hKey, szPrefMixer, NULL, NULL, (LPBYTE) pCDUnit->szMixerName, &dwSize) == NO_ERROR)
            {
                hr = ComputeMixID(&dwMixID, pCDUnit->szMixerName);

                if (SUCCEEDED(hr))
                {
                    BOOL fGotControls = FALSE;
                    TCHAR szVolName[MIXER_LONG_NAME_CHARS] = TEXT("\0");

                    dwSize = sizeof(cdCtl);

                    cdCtl.dwDestID = DWORD(-1);
                    cdCtl.dwMuteID = DWORD(-1);
                    cdCtl.dwVolID = DWORD(-1);

                    if (RegQueryValueEx(hKey, szPrefControls, NULL, NULL, (LPBYTE) &cdCtl, &dwSize) == NO_ERROR)
                    {
                        fGotControls = SearchDevice(dwMixID, NULL, &cdCtl.dwDestID, &cdCtl.dwVolID, &cdCtl.dwMuteID, szVolName, TRUE); // Verify Controls
                    }

                    if (!fGotControls)  // Either were not in reg or fail verification, compute defaults for this device
                    {
                        fGotControls = SearchDevice(dwMixID, NULL, &cdCtl.dwDestID, &cdCtl.dwVolID, &cdCtl.dwMuteID, szVolName, FALSE);
                    }

                    if (!fGotControls)  // If we don't have them by now, we are in trouble.
                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        pCDUnit->dwMixID = dwMixID;
                        pCDUnit->dwDestID = cdCtl.dwDestID;
                        pCDUnit->dwVolID = cdCtl.dwVolID;
                        pCDUnit->dwMuteID = cdCtl.dwMuteID;
                        lstrcpy(pCDUnit->szVolName, szVolName);
                    }
                }
            }

            RegCloseKey(hKey);
        }
    }

    return(hr);
}


////////////////
// This function writes out the preferred mixer device name and the preferred control ID's into the
// cdrom driver registry for safe keeping.
//
STDMETHODIMP_(void) CCDOpt::SetUnitRegData(LPCDUNIT pCDUnit)
{
    HRESULT     hr = E_FAIL;
    TCHAR       szRegDriverStr[MAX_PATH];
    HKEY        hKey;
    CDCTL       cdCtl;

    //this function is very different on NT
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    GetVersionEx(&os);
    if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        if (pCDUnit)
        {
            wsprintf(szRegDriverStr,TEXT("%s%s"),szNTCDROMPath, pCDUnit->szDriver);

            if (RegCreateKeyEx(HKEY_CURRENT_USER , szRegDriverStr , 0 , NULL, 0, KEY_WRITE , NULL, &hKey, NULL) == ERROR_SUCCESS)
            {
                cdCtl.dwVolID = pCDUnit->dwVolID;
                cdCtl.dwMuteID = pCDUnit->dwMuteID;
                cdCtl.dwDestID = pCDUnit->dwDestID;

                RegSetValueEx(hKey, szPrefMixer, NULL, REG_SZ, (LPBYTE) pCDUnit->szMixerName, (sizeof(TCHAR) * lstrlen(pCDUnit->szMixerName))+sizeof(TCHAR));
                RegSetValueEx(hKey, szPrefControls, NULL, REG_BINARY, (LPBYTE) &cdCtl, sizeof(cdCtl));
                RegSetValueEx(hKey, szSelected, NULL, REG_BINARY, (LPBYTE) &(pCDUnit->fSelected), sizeof(BOOL));

                RegCloseKey(hKey);
            }
        }
    } //end if NT
    else
    {
        if (pCDUnit)
        {
            wsprintf(szRegDriverStr,TEXT("%s%s"),szRegstrCDROMPath, pCDUnit->szDriver);

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE , szRegDriverStr , 0 , KEY_WRITE , &hKey) == ERROR_SUCCESS)
            {
                cdCtl.dwVolID = pCDUnit->dwVolID;
                cdCtl.dwMuteID = pCDUnit->dwMuteID;
                cdCtl.dwDestID = pCDUnit->dwDestID;

                RegSetValueEx(hKey, szPrefMixer, NULL, REG_SZ, (LPBYTE) pCDUnit->szMixerName, (sizeof(TCHAR) * lstrlen(pCDUnit->szMixerName))+sizeof(TCHAR));
                RegSetValueEx(hKey, szPrefControls, NULL, REG_BINARY, (LPBYTE) &cdCtl, sizeof(cdCtl));
                RegSetValueEx(hKey, szSelected, NULL, REG_BINARY, (LPBYTE) &(pCDUnit->fSelected), sizeof(BOOL));

                RegCloseKey(hKey);
            }
        }
    } //end else Win9x
}


//////////////////
// Given just the drive letter of a CDROM, this function will obtain all information needed by the
// program on this drive.  Some is calcuated via the PnP registry for this drive's driver, other information
// is obtained from the registry or defaults are computed based on the installed audio components
//
STDMETHODIMP_(void) CCDOpt::GetUnitValues(LPCDUNIT pCDUnit)
{
    if (pCDUnit)
    {
        TCHAR cDriveLetter = pCDUnit->szDriveName[0];

        if (MapLetterToDevice(cDriveLetter, pCDUnit->szDriver, pCDUnit->szDeviceDesc, sizeof(pCDUnit->szDriver)))
        {
            if (FAILED(GetUnitRegData(pCDUnit)))     // Can fail if reg is empty or mixer ID can't be computed
            {
                GetUnitDefaults(pCDUnit);
            }
        }
        else
        {
            GetUnitDefaults(pCDUnit);
        }
    }
}


//////////////////
// This method is called in response to a PnP notify or a WinMM Device Change message.  It will verify
// the existance of all assigned MixerID's and the corresponding Volume and Mute ID on that device.
// In the event the device no-longer exists a default will be computed.
//
//
STDMETHODIMP_(void) CCDOpt::MMDeviceChanged(void)
{
    LPCDUNIT pCDUnit = m_pCDOpts->pCDUnitList;

    while (pCDUnit)
    {
        GetUnitValues(pCDUnit);
        pCDUnit = pCDUnit->pNext;
    }
}


//////////////////
// This function will save all the information for all the CD drives in the system out to the registry
// it does not modify or delete any of this information.
//
STDMETHODIMP_(void) CCDOpt::WriteCDList(LPCDUNIT pCDList)
{
    if (pCDList)
    {
        LPCDUNIT pUnit = pCDList;

        while (pUnit)
        {
            SetUnitRegData(pUnit);

            pUnit = pUnit->pNext;
        }
    }
}

////////////////
// This function will destory the list containing all the drive information in the system
// freeing up all memory, this function does not save any information.
//
STDMETHODIMP_(void) CCDOpt::DestroyCDList(LPCDUNIT *ppCDList)
{

    if (ppCDList && *ppCDList)
    {
        while(*ppCDList)
        {
            LPCDUNIT pTemp = *ppCDList;
            *ppCDList = (*ppCDList)->pNext;
            delete pTemp;
        }
    }
}


STDMETHODIMP_(UINT) CCDOpt::GetDefDrive(void)
{
    HKEY hkTmp;
    UINT uDrive = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, gszRegstrCDAPath, 0, KEY_READ, &hkTmp ) == ERROR_SUCCESS)
    {
        DWORD cb = sizeof(UINT);
        RegQueryValueEx(hkTmp, gszDefaultCDA, NULL, NULL, (LPBYTE)&uDrive, &cb);
        RegCloseKey(hkTmp);
    }

    return uDrive;
}

/////////////
// This function builds a list of all the CD drives in the system, the list
// is a linked list with each node containing information that is specific
// to that CD player as well as the user options for each player.
//

STDMETHODIMP CCDOpt::CreateCDList(LPCDUNIT *ppCDList)
{
    DWORD   dwBytes = 0;
    TCHAR   *szDriveNames = NULL;
    TCHAR   *szDriveNamesHead = NULL;
    HRESULT hr = S_OK;
    UINT    uDefDrive = GetDefDrive();

    if (ppCDList == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LPCDUNIT *ppUnit = NULL;

        *ppCDList = NULL;
        ppUnit = ppCDList;

        dwBytes = GetLogicalDriveStrings(0, NULL);

        if (dwBytes)
        {
            szDriveNames = new(TCHAR[dwBytes]);
            szDriveNamesHead = szDriveNames;

            if (szDriveNames == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                dwBytes = GetLogicalDriveStrings(dwBytes, szDriveNames);

                if (dwBytes)
                {
                    UINT uDrive = 0;

                    while (*szDriveNames)
                    {
                        if (GetDriveType(szDriveNames) == DRIVE_CDROM)
                        {
                            *ppUnit = new(CDUNIT);

                            if (*ppUnit == NULL)
                            {
                                hr = E_OUTOFMEMORY;
                                break;
                            }
                            else
                            {
                                memset(*ppUnit,0,sizeof(CDUNIT));
                                _tcsncpy((*ppUnit)->szDriveName,szDriveNames,min(sizeof((*ppUnit)->szDriveName)/sizeof(TCHAR),(UINT)lstrlen(szDriveNames)));

                                (*ppUnit)->dwTitleID = (DWORD)CDTITLE_NODISC;

                                CharUpper((*ppUnit)->szDriveName);

                                GetUnitValues(*ppUnit);

                                if (uDrive == uDefDrive)
                                {
                                    (*ppUnit)->fDefaultDrive = TRUE;
                                }

                                ppUnit = &((*ppUnit)->pNext);
                                uDrive++;
                            }
                        }

                        while(*szDriveNames++);
                    }
                }
            }

            if (szDriveNamesHead)
            {
                delete [] szDriveNamesHead;
            }
        }
    }

    if (FAILED(hr))
    {
        DestroyCDList(ppCDList);
    }

    return hr;
}




/////////////
// Traverse the UI Tree, destroying it as it goes.
//
STDMETHODIMP_(void) CCDOpt::DestroyUITree(LPCDDRIVE *ppCDRoot)
{
   if (ppCDRoot)
   {
        LPCDDRIVE pDriveList;

        pDriveList = *ppCDRoot;
        *ppCDRoot = NULL;

        while (pDriveList)
        {
            LPCDDRIVE pNextDrive = pDriveList->pNext;

            while (pDriveList->pMixerList)
            {
                LPCDMIXER pNextMixer = pDriveList->pMixerList->pNext;

                while(pDriveList->pMixerList->pControlList)
                {
                    LPCDCONTROL pNextControl = pDriveList->pMixerList->pControlList->pNext;
                    delete pDriveList->pMixerList->pControlList;
                    pDriveList->pMixerList->pControlList = pNextControl;
                }

                delete pDriveList->pMixerList;
                pDriveList->pMixerList = pNextMixer;
            }

            delete pDriveList;
            pDriveList = pNextDrive;
        }
    }
}


///////////////////
// Add line controls to internal tree data structure for UI
//

STDMETHODIMP CCDOpt::AddLineControls(LPCDMIXER pMixer, LPCDCONTROL *ppLastControl, int mxid, LPMIXERLINE pml)
{
    MIXERLINECONTROLS mlc;
    DWORD dwControl;
    HRESULT hr = S_FALSE;

    memset(&mlc, 0, sizeof(mlc));
    mlc.cbStruct = sizeof(mlc);
    mlc.dwLineID = pml->dwLineID;
    mlc.cControls = pml->cControls;
    mlc.cbmxctrl = sizeof(MIXERCONTROL);
    mlc.pamxctrl = (LPMIXERCONTROL) new(MIXERCONTROL[pml->cControls]);

    if (mlc.pamxctrl)
    {
        if (mixerGetLineControls((HMIXEROBJ)IntToPtr(mxid), &mlc, MIXER_GETLINECONTROLSF_ALL) == MMSYSERR_NOERROR)
        {
            for (dwControl = 0; dwControl < pml->cControls; dwControl++)
            {
                if (mlc.pamxctrl[dwControl].dwControlType == (DWORD)MIXERCONTROL_CONTROLTYPE_VOLUME)
                {
                    DWORD       dwIndex;
                    DWORD       dwVolID = mlc.pamxctrl[dwControl].dwControlID;
                    DWORD       dwMuteID = DWORD(-1);
                    LPCDCONTROL pControl;

                    for (dwIndex = 0; dwIndex < pml->cControls; dwIndex++)
                    {
                        if (mlc.pamxctrl[dwIndex].dwControlType == (DWORD)MIXERCONTROL_CONTROLTYPE_MUTE)
                        {
                            dwMuteID = mlc.pamxctrl[dwIndex].dwControlID;
                            break;
                        }
                    }

                    pControl = new (CDCONTROL);

                    if (pControl == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        memset(pControl, 0, sizeof(CDCONTROL));

                        if (pMixer->pControlList == NULL)
                        {
                            pMixer->pControlList = pControl;
                        }

                        if (*ppLastControl)
                        {
                            (*ppLastControl)->pNext = pControl;
                        }

                        lstrcpy(pControl->szName, pml->szName); // mlc.pamxctrl[dwControl].szName);
                        pControl->dwVolID = dwVolID;
                        pControl->dwMuteID = dwMuteID;

                        *ppLastControl = pControl;
						hr = S_OK;
                    }

                    break;
                }
            }
        }

        delete mlc.pamxctrl;
    }

    return(hr);
}

/////////////////
// Searchs connections for controls to add to UI tree
//

STDMETHODIMP CCDOpt::AddConnections(LPCDMIXER pMixer, LPCDCONTROL *ppLastControl, int mxid, DWORD dwDestination, DWORD dwConnections)
{
    MIXERLINE   mlDst;
    DWORD       dwConnection;
    HRESULT     hr = S_FALSE;
	BOOL		bGotSomething=FALSE; //TRUE if any controls were found.

    for (dwConnection = 0; dwConnection < dwConnections; dwConnection++)
    {
        mlDst.cbStruct = sizeof ( mlDst );
        mlDst.dwDestination  = dwDestination;
        mlDst.dwSource = dwConnection;

        if (mixerGetLineInfo((HMIXEROBJ)IntToPtr(mxid), &mlDst, MIXER_GETLINEINFOF_SOURCE) == MMSYSERR_NOERROR)
        {
            if (mlDst.cControls)    // Make sure this source has controls on it
            {
                if (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC ||
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_LINE ||
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY ||
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_DIGITAL ||
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_ANALOG)
                {
                    hr = AddLineControls(pMixer, ppLastControl, mxid, &mlDst);

                    if (FAILED(hr))
                    {
                        break;
                    }

					if(S_FALSE != hr)
					{
						bGotSomething = TRUE;
					}
                }
            }
        }
    }

	if(SUCCEEDED(hr) && bGotSomething)
	{
		return S_OK;
	}

    return(hr);
}


//////////////
// Adds control nodes to the UI tree for the specified device
//
// Returns S_FALSE if no lines were added for this mixer.

STDMETHODIMP CCDOpt::AddControls(LPCDMIXER pMixer)
{
    MIXERLINE   mlDst;
    DWORD       dwDestination;
    MIXERCAPS   mc;
    LPCDCONTROL pLastControl = NULL;
    HRESULT     hr = S_FALSE;
	BOOL		bGotSomething=FALSE; //TRUE if any valid lines were found on the mixer.

    if (mixerGetDevCaps(pMixer->dwMixID, &mc, sizeof(mc)) == MMSYSERR_NOERROR)
    {
        for (dwDestination = 0; dwDestination < mc.cDestinations; dwDestination++)
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwDestination = dwDestination;

            if (mixerGetLineInfo((HMIXEROBJ)ULongToPtr(pMixer->dwMixID), &mlDst, MIXER_GETLINEINFOF_DESTINATION  ) == MMSYSERR_NOERROR)
            {
                if (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_SPEAKERS ||    // needs to be a likely output destination
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_HEADPHONES ||
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT)
                {
                    if (mlDst.cControls)  // If there are no controls, we won't present it to the user as an option
                    {
                        hr = AddLineControls(pMixer, &pLastControl, pMixer->dwMixID, &mlDst);

                        if (FAILED(hr))
                        {
                            break;
                        }

						if(S_FALSE != hr)
						{
							bGotSomething = TRUE;
						}
                    }

                    if (mlDst.cConnections)  // If there are connections to this line, lets add thier controls
                    {
                        hr = AddConnections(pMixer, &pLastControl, pMixer->dwMixID, dwDestination, mlDst.cConnections);

                        if (FAILED(hr))
                        {
                            break;
                        }

						if(S_FALSE != hr)
						{
							bGotSomething = TRUE;
						}
                    }
                }
            }
        }
    }

	if(SUCCEEDED(hr) && bGotSomething)
	{
		return S_OK;
	}

    return(hr);
}


///////////////////
// Adds audio mixers to UI tree for the cd player unit specified
//

STDMETHODIMP CCDOpt::AddMixers(LPCDDRIVE pDevice)
{
    HRESULT     hr = S_OK;
    DWORD       dwNumMixers;
    DWORD       dwID;
    MMRESULT    mmr;
    MIXERCAPS   mc;
    LPCDMIXER   pMixer;
    LPCDMIXER   pLastMixer = NULL;

    if (pDevice)
    {
        dwNumMixers = mixerGetNumDevs();

        for (dwID = 0; dwID < dwNumMixers; dwID++)
        {
            mmr = mixerGetDevCaps(dwID, &mc, sizeof(mc));

            if (mmr == MMSYSERR_NOERROR && mc.cDestinations)
            {
                pMixer = new (CDMIXER);

                if (pMixer == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
                else
                {
                    memset(pMixer, 0, sizeof(CDMIXER));

                    if (pDevice->pMixerList == NULL)
                    {
                        pDevice->pMixerList = pMixer;
                    }

                    lstrcpy(pMixer->szPname, mc.szPname);
                    pMixer->dwMixID = dwID;

                    hr = AddControls(pMixer);

                    if (FAILED(hr))
                    {
                        break;
                    }

					if(S_FALSE == hr)
					{
						//No valid line was found for this mixer.
						//Example: The mixer device has only a WaveIn (USB microphone). Bug #398736.
						delete pMixer;
						pMixer = NULL;
						continue;
					}

					if (pLastMixer)
                    {
                        pLastMixer->pNext = pMixer;
                    }

                    pLastMixer = pMixer;
                }
            }
        }
    }

    return(hr);
}

//////////////
// Takes the UI tree and updates it's current and default setting links based on data
// from the CDINFO tree which was created from the registry
//

STDMETHODIMP_(void) CCDOpt::SetUIDefaults(LPCDDRIVE pCDTree, LPCDUNIT pCDList)
{
    LPCDDRIVE pDriveList;
    LPCDUNIT pCDUnit = pCDList;

    pDriveList = pCDTree;

    while(pDriveList && pCDUnit)
    {
        LPCDMIXER pMixer;

        pMixer = pDriveList->pMixerList;

        while (pMixer)
        {
            LPCDCONTROL pControl;
            DWORD dwVolID = DWORD(-1);
            DWORD dwMuteID = DWORD(-1);
            DWORD dwDestID = DWORD(-1);

            if (pMixer->dwMixID == pCDUnit->dwMixID)
            {
                pDriveList->pCurrentMixer = pMixer;
                pDriveList->pOriginalMixer = pMixer;
            }

            pControl = pMixer->pControlList;

            SearchDevice(pMixer->dwMixID, NULL, &dwDestID, &dwVolID, &dwMuteID, NULL, FALSE);

            while (pControl)
            {
                if (pControl->dwVolID == dwVolID && pControl->dwMuteID == dwMuteID)
                {
                    pMixer->pDefaultControl = pControl;
                }

                if (pMixer->dwMixID == pCDUnit->dwMixID && pControl->dwVolID == pCDUnit->dwVolID)
                {
                    pMixer->pCurrentControl = pControl;
                    pMixer->pOriginalControl = pControl;
                }

                pControl = pControl->pNext;
            }

            pMixer = pMixer->pNext;
        }

        pDriveList = pDriveList->pNext;
        pCDUnit = pCDUnit->pNext;
    }

}

//////////////
// Takes the UI tree and updates it's current and default setting links based on data
// from the CDINFO tree which was created from the registry
//

STDMETHODIMP_(void) CCDOpt::RestoreOriginals(void)
{
    LPCDDRIVE pDriveList;

    pDriveList = m_pCDTree;

    while(pDriveList)
    {
        LPCDMIXER pMixer;

        pMixer = pDriveList->pMixerList;

        while (pMixer)
        {
            LPCDCONTROL pControl;

            pDriveList->pCurrentMixer = pDriveList->pOriginalMixer;

            pControl = pMixer->pControlList;

            while (pControl)
            {
                pMixer->pCurrentControl = pMixer->pOriginalControl;
                pControl = pControl->pNext;
            }

            pMixer = pMixer->pNext;
        }

        pDriveList = pDriveList->pNext;
    }
}

//////////////
// Updates the CD Tree from the UI Tree after the dialog closes (on OK), if there
// are any changes it returns true.  The caller is expected to write these changes out to reg
//

STDMETHODIMP_(BOOL) CCDOpt::UpdateCDList(LPCDDRIVE pCDTree, LPCDUNIT pCDList)
{
    BOOL        fChanged = FALSE;
    LPCDDRIVE   pDriveList;
    LPCDUNIT    pCDUnit = pCDList;

    pDriveList = pCDTree;

    while(pDriveList && pCDUnit)
    {
        if (pCDUnit->fSelected != pDriveList->fSelected)                // Selected drive has changed
        {
            pCDUnit->fSelected = pDriveList->fSelected;
            fChanged = TRUE;
        }

        if (pDriveList->pCurrentMixer && pDriveList->pCurrentMixer->pCurrentControl)
        {
            LPCDMIXER pMixer = pDriveList->pCurrentMixer;

            if (pMixer->dwMixID != pCDUnit->dwMixID)     // Mixer has changed
            {
                pCDUnit->dwMixID = pMixer->dwMixID;
                lstrcpy(pCDUnit->szMixerName, pMixer->szPname);

                fChanged = TRUE;
            }

            LPCDCONTROL pControl = pDriveList->pCurrentMixer->pCurrentControl;

            if (pControl->dwVolID != pCDUnit->dwVolID)    // Control has changed
            {
                pCDUnit->dwVolID = pControl->dwVolID;
                pCDUnit->dwMuteID = pControl->dwMuteID;
                lstrcpy(pCDUnit->szVolName, pControl->szName);

                fChanged = TRUE;
            }
        }

        pDriveList = pDriveList->pNext;
        pCDUnit = pCDUnit->pNext;
    }

    return(fChanged);
}



////////////
// Contructs UI tree for all devices/mixers/controls
//

STDMETHODIMP CCDOpt::BuildUITree(LPCDDRIVE *ppCDRoot, LPCDUNIT pCDList)
{
    LPCDUNIT    pCDUnit = pCDList;
    LPCDDRIVE   pDevice;
    LPCDDRIVE   pLastDevice;
    HRESULT     hr = S_OK;

    m_pCDSelected = NULL;

    if (ppCDRoot)
    {
        *ppCDRoot = NULL;
        pLastDevice = NULL;

        while (pCDUnit)
        {
            pDevice = new (CDDRIVE);

            if (pDevice == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            else
            {
                memset(pDevice, 0, sizeof(CDDRIVE));

                if (*ppCDRoot == NULL)
                {
                    *ppCDRoot = pDevice;
                }

                if (pLastDevice)
                {
                    pLastDevice->pNext = pDevice;
                }

                lstrcpy(pDevice->szDriveName, pCDUnit->szDriveName);
                lstrcpy(pDevice->szDeviceDesc, pCDUnit->szDeviceDesc);
                pDevice->fSelected = pCDUnit->fSelected;

                hr = AddMixers(pDevice);

                if (FAILED(hr))
                {
                    break;
                }

                pCDUnit = pCDUnit->pNext;
                pLastDevice = pDevice;
            }
        }

        if (FAILED(hr))
        {
            if (*ppCDRoot)
            {
                DestroyUITree(ppCDRoot);
            }
        }
        else
        {
            SetUIDefaults(*ppCDRoot, pCDList);
        }
    }

    return(hr);
}



/////////////////
// Updates the control combo box using the mixer node of the UI tree
//

STDMETHODIMP_(void) CCDOpt::InitControlUI(HWND hDlg, LPCDMIXER pMixer)
{
    LPCDCONTROL pControl;
    LRESULT dwIndex;

    SendDlgItemMessage(hDlg, IDC_AUDIOCONTROL, CB_RESETCONTENT,0,0);

    pControl = pMixer->pControlList;

    if (pMixer->pCurrentControl == NULL)
    {
        pMixer->pCurrentControl = pMixer->pDefaultControl;
    }

    while(pControl)
    {
        dwIndex = SendDlgItemMessage(hDlg, IDC_AUDIOCONTROL, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) pControl->szName);

        if (dwIndex != CB_ERR && dwIndex != CB_ERRSPACE)
        {
            SendDlgItemMessage(hDlg, IDC_AUDIOCONTROL, CB_SETITEMDATA,  (WPARAM) dwIndex, (LPARAM) pControl);

            if (pMixer->pCurrentControl == pControl)
            {
                SendDlgItemMessage(hDlg, IDC_AUDIOCONTROL, CB_SETCURSEL,  (WPARAM) dwIndex, 0);
            }
        }

        pControl = pControl->pNext;
    }
}


////////////////
// Sets up the mixer combobox using the specified device
//

STDMETHODIMP_(void) CCDOpt::InitMixerUI(HWND hDlg, LPCDDRIVE pDevice)
{
    LPCDMIXER   pMixer;
    LRESULT     dwIndex;

    SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_RESETCONTENT,0,0);

    pMixer = pDevice->pMixerList;

    while (pMixer)
    {
        dwIndex = SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) pMixer->szPname);

        if (dwIndex != CB_ERR && dwIndex != CB_ERRSPACE)
        {
            SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_SETITEMDATA,  (WPARAM) dwIndex, (LPARAM) pMixer);

            if (pDevice->pCurrentMixer == pMixer)
            {
                SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_SETCURSEL,  (WPARAM) dwIndex, 0);

                InitControlUI(hDlg, pMixer);
            }
        }

        pMixer = pMixer->pNext;
    }
}


////////////////
// Sets up the cd device combo box
//

STDMETHODIMP_(void) CCDOpt::InitDeviceUI(HWND hDlg, LPCDDRIVE pCDTree, LPCDDRIVE pCurrentDevice)
{
    LPCDDRIVE   pDevice;
    LRESULT     dwIndex;

    SendDlgItemMessage(hDlg, IDC_CDDRIVE, CB_RESETCONTENT,0,0);

    pDevice = pCDTree;

    while (pDevice)
    {
        TCHAR str[MAX_PATH];

        wsprintf(str, TEXT("( %s ) %s"), pDevice->szDriveName, pDevice->szDeviceDesc);

        dwIndex = SendDlgItemMessage(hDlg, IDC_CDDRIVE, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) str);

        if (dwIndex != CB_ERR && dwIndex != CB_ERRSPACE)
        {
            SendDlgItemMessage(hDlg, IDC_CDDRIVE, CB_SETITEMDATA,  (WPARAM) dwIndex, (LPARAM) pDevice);

            if (pDevice == pCurrentDevice)
            {
                SendDlgItemMessage(hDlg, IDC_CDDRIVE, CB_SETCURSEL,  (WPARAM) dwIndex, 0);

                InitMixerUI(hDlg, pDevice);
           }
        }

        pDevice = pDevice->pNext;
    }
}

///////////////////
// Called to init the dialog when it first appears.  Given a list of CD devices, this
// function fills out the dialog using the first device in the list.
//
STDMETHODIMP_(BOOL) CCDOpt::InitMixerConfig(HWND hDlg)
{
    LPCDDRIVE pDevice = m_pCDTree;

    while (pDevice)
    {
        if (pDevice->fSelected)
        {
            break;
        }

        pDevice = pDevice->pNext;
    }

    if (pDevice == NULL)
    {
        pDevice = m_pCDTree;
    }

    InitDeviceUI(hDlg, m_pCDTree, pDevice); // Init to the selected device

    return(TRUE);
}

//////////////
// This function pulls the CD Drive node out of the combo box and returns it. It returns a
// reference into the main Drive tree.
//

STDMETHODIMP_(LPCDDRIVE) CCDOpt::GetCurrentDevice(HWND hDlg)
{
    LRESULT   dwResult;
    LPCDDRIVE pDevice = NULL;

    dwResult = SendDlgItemMessage(hDlg, IDC_CDDRIVE, CB_GETCURSEL, 0, 0);

    if (dwResult != CB_ERR)
    {
        dwResult = SendDlgItemMessage(hDlg, IDC_CDDRIVE, CB_GETITEMDATA,  (WPARAM) dwResult, 0);

        if (dwResult != CB_ERR)
        {
            pDevice = (LPCDDRIVE) dwResult;
        }
    }

    return(pDevice);
}

//////////////
// This function pulls the CD Drive mixer out of the combo box and returns it. It returns a
// reference into the main Drive tree.
//

STDMETHODIMP_(LPCDMIXER) CCDOpt::GetCurrentMixer(HWND hDlg)
{
    LRESULT     dwResult;
    LPCDMIXER   pMixer = NULL;

    dwResult = SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_GETCURSEL, 0, 0);

    if (dwResult != CB_ERR)
    {
        dwResult = SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_GETITEMDATA,  (WPARAM) dwResult, 0);

        if (dwResult != CB_ERR)
        {
            pMixer = (LPCDMIXER) dwResult;
        }
    }

    return(pMixer);
}


//////////////
// Called when the user changes the CD Device. it pulls the CD Drive node out of the combo box and
// then resets the UI to reflect that drives current settings.
//
STDMETHODIMP_(void) CCDOpt::ChangeCDDrives(HWND hDlg)
{
    LPCDDRIVE pDevice = GetCurrentDevice(hDlg);

    if (pDevice)
    {
        LPCDDRIVE pDev = m_pCDTree;

        InitDeviceUI(hDlg, m_pCDTree, pDevice);

        while (pDev)
        {
            pDev->fSelected = (BOOL) (pDev == pDevice);
            pDev = pDev->pNext;
        }
    }
}


//////////
// Called when the user changes the current mixer for the drive, it updates the
// display and the info for the drive.
//
STDMETHODIMP_(void) CCDOpt::ChangeCDMixer(HWND hDlg)
{
    LRESULT     dwResult;
    LPCDDRIVE   pDevice = GetCurrentDevice(hDlg);

    dwResult = SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_GETCURSEL, 0, 0);

    if (dwResult != CB_ERR)
    {
        dwResult = SendDlgItemMessage(hDlg, IDC_AUDIOMIXER, CB_GETITEMDATA,  (WPARAM) dwResult, 0);

        if (dwResult != CB_ERR)
        {
            pDevice->pCurrentMixer = (LPCDMIXER) dwResult;

            InitMixerUI(hDlg, pDevice);
        }
    }
}

/////////////////
// Called when the user changes the current control for the mixer on the current device.
// It updates the internal data structure for that drive.
//
STDMETHODIMP_(void) CCDOpt::ChangeCDControl(HWND hDlg)
{
    LPCDMIXER   pMixer = GetCurrentMixer(hDlg);
    LRESULT     dwResult;

    dwResult = SendDlgItemMessage(hDlg, IDC_AUDIOCONTROL, CB_GETCURSEL, 0, 0);

    if (dwResult != CB_ERR)
    {
        dwResult = SendDlgItemMessage(hDlg, IDC_AUDIOCONTROL, CB_GETITEMDATA,  (WPARAM) dwResult, 0);

        if (dwResult != CB_ERR)
        {
            pMixer->pCurrentControl = (LPCDCONTROL) dwResult;

            InitControlUI(hDlg, pMixer);
        }
    }
}


//////////////////
// Called to set the default control for the current mixer (lets the system pick)
//
STDMETHODIMP_(void) CCDOpt::SetMixerDefaults(HWND hDlg)
{
    LPCDMIXER   pMixer = GetCurrentMixer(hDlg);

    if (pMixer)
    {
        pMixer->pCurrentControl = NULL;

        InitControlUI(hDlg, pMixer);
    }
}


///////////////////
// Dialog handler for the mixer configuration dialog
//

STDMETHODIMP_(BOOL) CCDOpt::MixerConfig(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;

    switch (msg)
    {
        default:
            fResult = FALSE;
        break;


        case WM_CONTEXTMENU:
        {
            WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)aVolOptsHelp);
        }
        break;

        case WM_HELP:
        {
            WinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPSTR)aVolOptsHelp);
        }
        break;

        case WM_INITDIALOG:
        {
            fResult = InitMixerConfig(hDlg);
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
	            	EndDialog(hDlg, TRUE);
				break;

				case IDCANCEL:
                    RestoreOriginals();
					EndDialog(hDlg,FALSE);
				break;

                case IDC_DEFAULTMIXER:
                    SetMixerDefaults(hDlg);
                break;

                case IDC_CDDRIVE:
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        ChangeCDDrives(hDlg);
                    }
                break;

                case IDC_AUDIOMIXER:
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        ChangeCDMixer(hDlg);
                    }
                break;

                case IDC_AUDIOCONTROL:
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        ChangeCDControl(hDlg);
                    }
                break;

                default:
                    fResult = FALSE;
                break;
            }
        }
        break;
    }

    return fResult;
}

///////////////////
// Dialog handler
//
INT_PTR CALLBACK CCDOpt::MixerConfigProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fResult = TRUE;
    CCDOpt  *pCDOpt = (CCDOpt *) GetWindowLongPtr(hDlg, DWLP_USER);

    if (msg == WM_INITDIALOG)
    {
        pCDOpt = (CCDOpt *) lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pCDOpt);
    }

    if (pCDOpt)
    {
        fResult = pCDOpt->MixerConfig(hDlg, msg, wParam, lParam);
    }

    if (msg == WM_DESTROY)
    {
        pCDOpt = NULL;
    }

    return(fResult);
}

////////////
// Called to put up the UI to allow the user to change the CD Volume Configuration
//
STDMETHODIMP_(BOOL) CCDOpt::VolumeDialog(HWND hDlg)
{
    BOOL fChanged = FALSE;

    if (m_pCDOpts && m_pCDOpts->pCDUnitList)
    {
        if (SUCCEEDED(BuildUITree(&m_pCDTree, m_pCDOpts->pCDUnitList)))
        {
	        if(DialogBoxParam( m_hInst, MAKEINTRESOURCE(IDD_MIXERPICKER), hDlg, CCDOpt::MixerConfigProc, (LPARAM) this) == TRUE)
            {
                fChanged = UpdateCDList(m_pCDTree, m_pCDOpts->pCDUnitList);

                if (fChanged)
                {
                    WriteCDList(m_pCDOpts->pCDUnitList);
                }
            }

            DestroyUITree(&m_pCDTree);
        }
    }

    return(fChanged);
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\cdplay.cpp ===
// CDPlay.cpp : Implementation of CCDPlay
#include "windows.h"
#include "CDPlay.h"
#include "cdapi.h"
#include "cdplayer.h"
#include "literals.h"

#include "playres.h"
#include "tchar.h"

#include "trklst.h"

extern HINSTANCE g_dllInst;
extern BOOL g_fOleInitialized;
extern TCHAR g_szTimeSep[10];

/////////////////////////////////////////////////////////////////////////////
// CCDPlay

CCDPlay::CCDPlay()
{
    m_hMenu = NULL;
    m_hwndMain = NULL;
    m_pSink = NULL;
    m_dwRef = 0;

    InitIcons();
}

CCDPlay::~CCDPlay()
{
    //close device ...

    //destroy objects
    if (m_hIcon16)
    {
        DestroyIcon(m_hIcon16);
        m_hIcon16 = NULL;
    }

    if (m_hIcon32)
    {
        DestroyIcon(m_hIcon32);
        m_hIcon32 = NULL;
    }

    if (m_hMenu)
    {
        DestroyMenu(m_hMenu);
        m_hMenu = NULL;
    }

    // Cleanup from cd player stuff
    DeleteCriticalSection (&g_csTOCSerialize);

    if (g_fOleInitialized)
    {
	    OleUninitialize();
    }
}

STDMETHODIMP CCDPlay::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (IID_IUnknown == riid || IID_IMMComponent == riid)
    {  
        *ppv = this;
    }

    if (IID_IMMComponentAutomation == riid)
    {
        *ppv = (IMMComponentAutomation*)this;
    }

    if (NULL==*ppv)
    {
        return E_NOINTERFACE;
    }

    AddRef();

    return S_OK;
}

STDMETHODIMP_(ULONG) CCDPlay::AddRef(void)
{
    return ++m_dwRef;
}

STDMETHODIMP_(ULONG) CCDPlay::Release(void)
{
    if (0!=--m_dwRef)
        return m_dwRef;

    delete this;
    return 0;
}

STDMETHODIMP CCDPlay::GetInfo(MMCOMPDATA* mmCompData)
{
    mmCompData->hiconSmall = m_hIcon16;
    mmCompData->hiconLarge = m_hIcon32;
    mmCompData->nAniResID = -1;
    mmCompData->hInst = g_dllInst;
    _tcscpy(mmCompData->szName,TEXT("CD"));
    QueryVolumeSupport(&mmCompData->fVolume, &mmCompData->fPan);

    //try to get the rect required by the ledwnd,
    //this could change if there are large fonts involved
    TCHAR szDisp[MAX_PATH];
    LoadString(g_dllInst, STR_DISPLAY_LABELS, szDisp, sizeof(szDisp)/sizeof(TCHAR));

    HWND hwndDisp = GetDlgItem(m_hwndMain,IDC_LED);
    HDC hdc = GetDC(hwndDisp);

    LOGFONT     lf;
    int         iLogPelsY;
    iLogPelsY = GetDeviceCaps( hdc, LOGPIXELSY );
    ZeroMemory( &lf, sizeof(lf) );

    HFONT hTempFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    GetObject(hTempFont,sizeof(lf),&lf);

    lf.lfHeight = (-10 * iLogPelsY) / 72;
    if (lf.lfCharSet == ANSI_CHARSET)
    {
        lf.lfWeight = FW_BOLD;
    }
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;

    HFONT hDispFont = CreateFontIndirect(&lf);

    HFONT hOrgFont = (HFONT)SelectObject(hdc,hDispFont);

    GetClientRect(hwndDisp,&(mmCompData->rect));

    DrawText( hdc,          // handle to device context
              szDisp, // pointer to string to draw
              -1,       // string length, in characters
              &(mmCompData->rect),    // pointer to struct with formatting dimensions
              DT_CALCRECT|DT_EXPANDTABS|DT_NOPREFIX);

    SelectObject(hdc,hOrgFont);
    DeleteObject(hDispFont);
    ReleaseDC(hwndDisp,hdc);

    return S_OK;
}

BOOL CALLBACK
TransDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return FALSE;
}

extern HWND PASCAL WinFake(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow, HWND hwndMain, IMMFWNotifySink* pSink);

STDMETHODIMP CCDPlay::Init(IMMFWNotifySink* pSink, HWND hwndMain, RECT* pRect, HWND* phwndComp, HMENU* phMenu)
{
    HRESULT hr = S_OK;

    //save sink pointer
    m_pSink = pSink;

    //load custom menu
    m_hMenu = LoadMenu(g_dllInst,
                       MAKEINTRESOURCE(IDR_MAINMENU));

    *phMenu = m_hMenu;

    //create the main window here
    
    //fake cd player into thinking it can go)
    m_hwndMain = WinFake(g_dllInst,NULL,"",SW_NORMAL,hwndMain,pSink);

    //set up pointer to main window of app
    *phwndComp = m_hwndMain;

	return hr;
}

void GetTOC(int cdrom, TCHAR* szNetQuery)
{
	DWORD dwRet;
    MCI_SET_PARMS   mciSet;
	unsigned long m_toc[101];

    ZeroMemory( &mciSet, sizeof(mciSet) );

    mciSet.dwTimeFormat = MCI_FORMAT_MSF;
    mciSendCommand( g_Devices[ cdrom ]->hCd, MCI_SET, MCI_SET_TIME_FORMAT, (DWORD_PTR)(LPVOID)&mciSet );

    MCI_STATUS_PARMS mciStatus;
    long lAddress, lStartPos, lDiskLen;
    int i;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;

    //
    // NOTE: none of the mciSendCommand calls below bother to check the
    //       return code.  This is asking for trouble... but if the
    //       commands fail we cannot do much about it.
    //
    dwRet = mciSendCommand( g_Devices[ cdrom ]->hCd, MCI_STATUS,
		    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus);

	int tracks = -1;
	tracks = (UCHAR)mciStatus.dwReturn;

    mciStatus.dwItem = MCI_STATUS_POSITION;
    for ( i = 0; i < tracks; i++ )
    {

	    mciStatus.dwTrack = i + 1;
	    dwRet = mciSendCommand( g_Devices[ cdrom ]->hCd, MCI_STATUS,
			    MCI_STATUS_ITEM | MCI_TRACK,
			    (DWORD_PTR)(LPVOID)&mciStatus);

	    lAddress = (long)mciStatus.dwReturn;

        //converts "packed" time into pure frames
        lAddress =  (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
					(MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
					(MCI_MSF_FRAME( lAddress));

		m_toc[i] = lAddress;

		if (i==0)
		{
			lStartPos = lAddress;
		}
    }

    mciStatus.dwItem = MCI_STATUS_LENGTH;
    dwRet = mciSendCommand( g_Devices[ cdrom ]->hCd, MCI_STATUS,
		    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus);

    /*
    ** Convert the total disk length into frames
    */
    lAddress  = (long)mciStatus.dwReturn;
    lDiskLen =  (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
				(MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
				(MCI_MSF_FRAME( lAddress));

    /*
    ** Now, determine the absolute start position of the sentinel
    ** track.  That is, the special track that marks the end of the
    ** disk.
    */
    lAddress = lStartPos + lDiskLen + 1; //dstewart: add one for true time

	m_toc[i] = lAddress;

    wsprintf(szNetQuery,TEXT("cd=%X"),tracks);
	
	//add each frame stattime to query, include end time of disc
	TCHAR tempstr[MAX_PATH];
	for (i = 0; i < tracks+1; i++)
	{
		wsprintf(tempstr,TEXT("+%X"),m_toc[i]);
		_tcscat(szNetQuery,tempstr);
	}
}

STDMETHODIMP CCDPlay::OnAction(MMACTIONS mmActionID, LPVOID pAction)
{
    HRESULT hr = S_OK;

    switch (mmActionID)
    {
        case MMACTION_PLAY:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_PLAY,0),0);
        }
        break;

        case MMACTION_STOP:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_STOP,0),0);
        }
        break;

        case MMACTION_UNLOADMEDIA: //"eject"
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_EJECT,0),0);
        }
        break;

        case MMACTION_NEXTTRACK:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_NEXTTRACK,0),0);
        }
        break;

        case MMACTION_PREVTRACK:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_PREVTRACK,0),0);
        }
        break;

        case MMACTION_PAUSE:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_PAUSE,0),0);
        }
        break;

        case MMACTION_REWIND:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_SKIPBACK,0),0);
        }
        break;

        case MMACTION_FFWD:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_SKIPFORE,0),0);
        }
        break;

        case MMACTION_NEXTMEDIA:
        {
            SendMessage(m_hwndMain,WM_COMMAND,MAKEWPARAM(IDM_PLAYBAR_EJECT,0),0);
        }
        break;

        case MMACTION_GETMEDIAID:
        {
            MMMEDIAID* pID = (MMMEDIAID*)pAction;
            if (pID->nDrive == -1)
            {
                pID->nDrive = g_CurrCdrom;
            }
            wsprintf( pID->szMediaID, g_szSectionF, g_Devices[pID->nDrive]->CdInfo.Id );
            pID->dwMediaID = g_Devices[pID->nDrive]->CdInfo.Id;
            pID->dwNumTracks = NUMTRACKS(pID->nDrive);
            _tcscpy(pID->szArtist,ARTIST(pID->nDrive));
            _tcscpy(pID->szTitle,TITLE(pID->nDrive));

            PTRACK_INF t;
            if (CURRTRACK(pID->nDrive)!=NULL)
            {
                t = FindTrackNodeFromTocIndex( CURRTRACK(pID->nDrive)->TocIndex, ALLTRACKS( pID->nDrive ) );
                if (t)
                {
                    _tcscpy(pID->szTrack,t->name);
                }
            }
        }
        break;

        case MMACTION_GETNETQUERY:
        {
            MMNETQUERY* pQuery = (MMNETQUERY*)pAction;
            if (pQuery->nDrive == -1)
            {
                pQuery->nDrive = g_CurrCdrom;
            }

            GetTOC(pQuery->nDrive,pQuery->szNetQuery);
        }
        break;

        case MMACTION_READSETTINGS :
        {
            ReadSettings((void*)pAction);
			UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME |
				       DISPLAY_UPD_TRACK_NAME );
        }
        break;

        case MMACTION_GETTRACKINFO :
        {
            LPMMTRACKORDISC pInfo = (LPMMTRACKORDISC)pAction;
            return (GetTrackInfo(pInfo));
        }
        break;

        case MMACTION_GETDISCINFO :
        {
            LPMMTRACKORDISC pInfo = (LPMMTRACKORDISC)pAction;
            return (GetDiscInfo(pInfo));
        }
        break;

        case MMACTION_SETTRACK :
        {
            LPMMCHANGETRACK pTrack = (LPMMCHANGETRACK)pAction;
            SetTrack(pTrack->nNewTrack);
        }
        break;

        case MMACTION_SETDISC :
        {
            LPMMCHANGEDISC pDisc = (LPMMCHANGEDISC)pAction;
            SetDisc(pDisc->nNewDisc);
        }
        break;

        default:
        {
            hr = E_NOTIMPL;
        }   
        break;
    }

    return hr;
}

//QueryVolumeSupport is just a helper function ... you don't have to do it this way
STDMETHODIMP CCDPlay::QueryVolumeSupport(BOOL* pVolume, BOOL* pPan)
{
    *pVolume = FALSE;
    *pPan = FALSE;

	return S_OK;
}

//InitIcons is just a helper function ... you don't have to do it this way
void CCDPlay::InitIcons()
{
    m_hIcon16 = NULL;
    m_hIcon32 = NULL;

    m_hIcon16 = (HICON)LoadImage(g_dllInst, MAKEINTRESOURCE(IDI_ICON_CDPLAY), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
    m_hIcon32 = LoadIcon(g_dllInst, MAKEINTRESOURCE(IDI_ICON_CDPLAY));
}

/*
* NormalizeNameForMenuDisplay
    This function turns a string like "Twist & Shout" into
    "Twist && Shout" because otherwise it will look like
    "Twist _Shout" in the menu due to the accelerator char
*/
void CCDPlay::NormalizeNameForMenuDisplay(TCHAR* szInput, TCHAR* szOutput, DWORD cbLen)
{
    ZeroMemory(szOutput,cbLen);
    WORD index1 = 0;
    WORD index2 = 0;
    for (; index1 < _tcslen(szInput); index1++)
    {
        szOutput[index2] = szInput[index1];
        if (szOutput[index2] == TEXT('&'))
        {
            szOutput[++index2] = TEXT('&');
        }
        index2++;
    }
}

//try to find and return the track info referenced by pInfo->nNumber
HRESULT CCDPlay::GetTrackInfo(LPMMTRACKORDISC pInfo)
{
    HRESULT hr = E_FAIL;

    if (pInfo)
    {
        int index = -1;

	    PTRACK_PLAY  playlist;
	    for( playlist = SAVELIST(g_CurrCdrom);
             playlist != NULL;
             playlist = playlist->nextplay )
	    {
            index++;
            PTRACK_INF t = NULL;
            t = FindTrackNodeFromTocIndex( playlist->TocIndex, ALLTRACKS( g_CurrCdrom ) );

            if ((t) && (index == pInfo->nNumber))
            {
    	        int mtemp, stemp;
                FigureTrackTime(g_CurrCdrom, t->TocIndex, &mtemp, &stemp );

                TCHAR szDisplayTrack[TRACK_TITLE_LENGTH*2];
                NormalizeNameForMenuDisplay(t->name,szDisplayTrack,sizeof(szDisplayTrack));
            
                wsprintf(pInfo->szName,TEXT("%i. %s (%i%s%02i)"),t->TocIndex + 1,szDisplayTrack,mtemp,g_szTimeSep,stemp);
                pInfo->nID = t->TocIndex;

                if (playlist->TocIndex == CURRTRACK(g_CurrCdrom)->TocIndex)
                {
                    pInfo->fCurrent = TRUE;
                }
                else
                {
                    pInfo->fCurrent = FALSE;
                }

                hr = S_OK; //indicate that indexed track was found
            } //end if track ok
	    } //end stepping
    } //end if pinfo valid
    return (hr);
}

HRESULT CCDPlay::GetDiscInfo(LPMMTRACKORDISC pInfo)
{
    HRESULT hr = E_FAIL;

    if (pInfo)
    {
	    for(int i = 0; i < g_NumCdDevices; i++)
	    {
            if (i == pInfo->nNumber)
            {
                TCHAR szDisplayTitle[TITLE_LENGTH*2];
                NormalizeNameForMenuDisplay(TITLE(i),szDisplayTitle,sizeof(szDisplayTitle));

                TCHAR szDisplayArtist[ARTIST_LENGTH*2];
                NormalizeNameForMenuDisplay(ARTIST(i),szDisplayArtist,sizeof(szDisplayArtist));

                if (g_Devices[i]->State & (CD_BEING_SCANNED | CD_NO_CD | CD_DATA_CD_LOADED | CD_IN_USE))
                {
	                wsprintf(pInfo->szName,TEXT("<%c:> %s"),g_Devices[i]->drive,szDisplayTitle);
                }
                else
                {
	                wsprintf(pInfo->szName,TEXT("<%c:> %s (%s)"),
                                g_Devices[i]->drive,szDisplayTitle,szDisplayArtist);
                }

                pInfo->nID = i;

                if (i == g_CurrCdrom)
                {
                    pInfo->fCurrent = TRUE;
                }
                else
                {
                    pInfo->fCurrent = FALSE;
                }
                
                hr = S_OK;
            } //end if match
	    } //end for
    } //end if pinfo valid

    return (hr);
}

void CCDPlay::SetTrack(int nTrack)
{
    PTRACK_INF tr;

    tr = ALLTRACKS( g_CurrCdrom );
    if ( tr != NULL )
    {
        PTRACK_PLAY trCurrent = CURRTRACK(g_CurrCdrom);
        tr = FindTrackNodeFromTocIndex(nTrack,ALLTRACKS(g_CurrCdrom));

        if (tr->TocIndex != trCurrent->TocIndex)
        {
            PTRACK_PLAY p = NULL;
            for (p = PLAYLIST(g_CurrCdrom); (p!=NULL) && (p->TocIndex != tr->TocIndex); p = p->nextplay);
            if (p)
            {
                TimeAdjustSkipToTrack( g_CurrCdrom, p );
            } //if not null
        } //if not equal to current
	} //if tr not null
}

void CCDPlay::SetDisc(int nDisc)
{
	SwitchToCdrom(nDisc, FALSE);
    MMONDISCCHANGED mmOnDisc;
    mmOnDisc.nNewDisc = g_CurrCdrom;
    mmOnDisc.fDisplayVolChange = TRUE;
    g_pSink->OnEvent(MMEVENT_ONDISCCHANGED,&mmOnDisc);
}

extern "C"
HRESULT WINAPI CDPLAY_CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj)
{
    CCDPlay* pObj;
    HRESULT hr = E_OUTOFMEMORY;

    *ppvObj = NULL;

    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
    {
        return CLASS_E_NOAGGREGATION;
    }

    pObj = new CCDPlay();

    if (NULL==pObj)
    {
        return hr;
    }

    hr = pObj->QueryInterface(riid, ppvObj);

    if (FAILED(hr))
    {
        delete pObj;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\cdapimci.cpp ===
/******************************Module*Header*******************************\
* Module Name: cdapimci.c
*
* This module encapsulates the CD-ROM device into a set of callable apis.
* The api's are implemented using the cdaudio mci interface.
*
* Created: 26-04-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 - 1995 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>    /* required for all Windows applications */
#include <windowsx.h>
#include <string.h>

#include "playres.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"
#include "..\cdopt\cdopt.h"

#ifdef __cplusplus
extern "C" {
#endif
/* -------------------------------------------------------------------------
**
** High level routines
**
** -------------------------------------------------------------------------
*/

BOOL g_fCDOpen = TRUE;

/******************************Public*Routine******************************\
* OpenCdRom
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
MCIDEVICEID
OpenCdRom(
    TCHAR chDrive,
    LPDWORD lpdwErrCode
    )
{
    MCI_OPEN_PARMS  mciOpen;
    TCHAR           szElementName[4];
    TCHAR           szAliasName[32];
    DWORD           dwFlags;
    DWORD           dwAliasCount = GetCurrentTime();
    DWORD           dwRet;

    ZeroMemory( &mciOpen, sizeof(mciOpen) );

    mciOpen.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    wsprintf( szElementName, TEXT("%c:"), chDrive );
    wsprintf( szAliasName, TEXT("SJE%lu:"), dwAliasCount );

    mciOpen.lpstrElementName = szElementName;
    mciOpen.lpstrAlias = szAliasName;

    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    GetVersionEx(&os);
    if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_SHAREABLE | MCI_OPEN_ALIAS |
                  MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;
    }
    else
    {
        dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_ALIAS |
                  MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;
    }

    dwRet = mciSendCommand(0, MCI_OPEN, dwFlags, (DWORD_PTR)(LPVOID)&mciOpen);


    if ( dwRet == MMSYSERR_NOERROR ) {

        MCI_SET_PARMS   mciSet;

        ZeroMemory( &mciSet, sizeof(mciSet) );

        mciSet.dwTimeFormat = MCI_FORMAT_MSF;
        mciSendCommand( mciOpen.wDeviceID, MCI_SET,
                        MCI_SET_TIME_FORMAT, (DWORD_PTR)(LPVOID)&mciSet );
    }
    else {

        /*
        ** Only return the error code if we have been given a valid pointer
        */
        if (lpdwErrCode != NULL) {
            *lpdwErrCode = dwRet;
        }

        mciOpen.wDeviceID = 0;
    }

    return mciOpen.wDeviceID;
}


/******************************Public*Routine******************************\
* CloseCdRom
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
CloseCdRom(
    MCIDEVICEID DevHandle
    )
{
    mciSendCommand( DevHandle, MCI_CLOSE, 0L, 0L );
}


/******************************Public*Routine******************************\
* CheckStatus
*
* Check return code for known bad codes and inform
* user how to correct (if possible) the problem.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckStatus(
    LPSTR szCaller,
    DWORD status,
    int cdrom
    )
{
#if DBG
    TCHAR   s[200];
    TCHAR   err[100];
#endif


    if (status==ERROR_SUCCESS)
        return;

/*
    switch (status)
    {
    case MCIERR_HARDWARE:
        NoMediaUpdate( cdrom );
        break;
    }
*/

#if DBG
    mciGetErrorString( status, err, sizeof(err) / sizeof(TCHAR) );
    wsprintf( s, IdStr( STR_ERR_GEN ), g_Devices[cdrom]->drive, err );

    OutputDebugString (s);
    OutputDebugString (TEXT("\r\n"));
#endif
}



/******************************Public*Routine******************************\
* CheckUnitCdrom
*
* Queries the device state, checking to see if a disc has been ejected or
* inserted.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckUnitCdrom(
    int cdrom,
    BOOL fForceRescan
    )
{
    DWORD   status;

    if ((cdrom < 0) || (cdrom >= MAX_CD_DEVICES))
    {
        return;
    }

    if (fForceRescan)
    {
        // Close Device to force read of correct TOC
        if (g_Devices[cdrom]->hCd != 0L)
        {
            CloseCdRom (g_Devices[cdrom]->hCd);
            g_Devices[cdrom]->hCd = 0L;
        }
    }

    if ( g_Devices[cdrom]->hCd == 0L ) {

        g_Devices[cdrom]->hCd = OpenCdRom( g_Devices[cdrom]->drive, NULL );

        if ( g_Devices[cdrom]->hCd == 0 ) {
            return;
        }
        else {

            /*
            ** Force a rescan of this disc.
            */
            g_Devices[cdrom]->State = CD_NO_CD;
        }

    }

    status = TestUnitReadyCdrom( g_Devices[cdrom]->hCd );

    if (g_Devices[cdrom]->State & CD_NO_CD)
    {

        if (status == ERROR_SUCCESS) {

            /*
            ** A new disc has been inserted, scan it now.
            */

            RescanDevice( g_hwndApp, cdrom );
        }
    }
    else {

        if (status != ERROR_SUCCESS) {

            /*
            ** Disc has been ejected.
            */

            NoMediaUpdate( cdrom );
        }
    }
}


/******************************Public*Routine******************************\
* NoMediaUpdate
*
* Update the user display when it is found that no media is in the device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
NoMediaUpdate(
    int cdrom
    )
{
    BOOL fChangePlayButtons;

    if ( cdrom == g_CurrCdrom )
    {
        fChangePlayButtons = TRUE;
    }
    else {
        fChangePlayButtons = FALSE;
    }

    g_Devices[cdrom]->State = (CD_NO_CD | CD_STOPPED);

    if (fChangePlayButtons)
    {
        g_pSink->OnEvent(MMEVENT_ONMEDIAUNLOADED,NULL);

        //tell the UI to gray out the button
        HWND hwndTrackButton = GetDlgItem(GetParent(g_hwndApp),IDB_TRACK);
        if (hwndTrackButton)
        {
            EnableWindow(hwndTrackButton,FALSE);
        }

        SetPlayButtonsEnableState();
    }

    //tell the playlist
	// Drive has been ejected
    if (g_pSink)
    {
        LPCDOPT pOpt = (LPCDOPT)g_pSink->GetOptions();
        LPCDOPTIONS pCDOpts = NULL;
        LPCDUNIT pUnit = NULL;

        if (pOpt)
        {
            pCDOpts = pOpt->GetCDOpts();
        }

        if (pCDOpts)
        {
            pUnit = pCDOpts->pCDUnitList;
        }

        //scan the list to find the one we want
        for (int index = 0; index < cdrom; index++)
        {
            if (pUnit)
            {
                pUnit = pUnit->pNext;
            }
        }

        if (pUnit)
        {
            pUnit->dwTitleID = CDTITLE_NODISC;
            pUnit->dwNumTracks = 0;
            pUnit->szNetQuery[0] = '\0';
            pOpt->DiscChanged(pUnit);
        }
    } //end if sink


    TimeAdjustInitialize( cdrom );
}



/******************************Public*Routine******************************\
* EjectTheCdromDisc
*
* Eject the disc from the specified cdrom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
EjectTheCdromDisc(
    int cdrom
    )
{
    DWORD status;

    /*
    ** Stop the drive first
    */

    status = StopCdrom( g_Devices[cdrom]->hCd );

    /*
    ** Eject the disc
    */

    status = EjectCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "EjectCdrom", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* PlayCurrTrack
*
* Set cdrom device playing from start MSF to end MSF of current
* track.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
PlayCurrTrack(
    int cdrom
    )
{
    DWORD status;
    MCI_PLAY_PARMS pam;
    int min,sec,endindex;
    PTRACK_PLAY tr;

    tr = CURRTRACK( cdrom );
    if (tr==NULL) {

        return( FALSE );

    }

    sec = TRACK_S(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurSec;
    min = TRACK_M(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurMin;
    min+= (sec / 60);
    sec = (sec % 60);

    pam.dwFrom = MCI_MAKE_MSF( min, sec, TRACK_F(cdrom,tr->TocIndex) );

    endindex = FindContiguousEnd( cdrom, tr );

    pam.dwTo = MCI_MAKE_MSF( TRACK_M(cdrom,endindex),
                             TRACK_S(cdrom,endindex),
                             TRACK_F(cdrom,endindex) );

#if DBG
{
    long lAddress, lEndPos, lStartPos;

    dprintf( TEXT("Playing from     : %2.2d:%2.2d:%2.2d"),
             MCI_MSF_MINUTE(pam.dwFrom),
             MCI_MSF_SECOND(pam.dwFrom),
             MCI_MSF_FRAME( pam.dwFrom) );
    dprintf( TEXT("Playing to       : %2.2d:%2.2d:%2.2d"),
             MCI_MSF_MINUTE(pam.dwTo),
             MCI_MSF_SECOND(pam.dwTo),
             MCI_MSF_FRAME( pam.dwTo) );

    lAddress = pam.dwFrom;
    lStartPos = (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
                (MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
                (MCI_MSF_FRAME(lAddress));

    lAddress = pam.dwTo;
    lEndPos   = (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
                (MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
                (MCI_MSF_FRAME(lAddress));

    lAddress = lEndPos - lStartPos;
    lStartPos =
        MCI_MAKE_MSF((lAddress / FRAMES_PER_MINUTE),
                     (lAddress % FRAMES_PER_MINUTE) / FRAMES_PER_SECOND,
                     (lAddress % FRAMES_PER_MINUTE) % FRAMES_PER_SECOND);

    lAddress = lStartPos;
    dprintf( TEXT("Play length      : %2.2d:%2.2d:%2.2d"),
             MCI_MSF_MINUTE(lAddress),
             MCI_MSF_SECOND(lAddress),
             MCI_MSF_FRAME( lAddress) );
}
#endif
    status = PlayCdrom( g_Devices[cdrom]->hCd, &pam );

    CheckStatus( "PlayCurrTrack", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* StopTheCdromDrive
*
* Tell the cdrom device to stop playing
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
StopTheCdromDrive(
    int cdrom
    )
{

    DWORD status;

    status = StopCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "StopCdrom", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* PauseTheCdromDrive
*
* Tell the cdrom device to pause playing
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
PauseTheCdromDrive(
    int cdrom
    )
{

    DWORD status;

    status = PauseCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "PauseCdrom", status, cdrom );

    return status == ERROR_SUCCESS;
}



/******************************Public*Routine******************************\
* ResumeTheCdromDrive
*
* Tell the cdrom device to resume playing
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
ResumeTheCdromDrive(
    int cdrom
    )
{

    DWORD status;

    status = ResumeCdrom( g_Devices[cdrom]->hCd, cdrom );

    CheckStatus( "ResumeCdrom", status, cdrom );

    if ( status == ERROR_NOT_READY ) {
        NoMediaUpdate( cdrom );
    }

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* SeekToCurrSecond
*
* Seek to the position on the disc represented by the
* current time (position) information in gDevices, and
* continue playing to the end of the current track.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
SeekToCurrSecond(
    int cdrom
    )
{
    DWORD       status;
    int         endindex;
    PTRACK_PLAY tr;
    UCHAR       StartingF, StartingS, StartingM;


    /*
    ** Build starting and ending positions for play
    */

    tr = CDTIME(cdrom).CurrTrack;
    if (tr == NULL) {

        return FALSE;
    }

    StartingM = (TRACK_M(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurMin);
    StartingS = (TRACK_S(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurSec);
    StartingF = (TRACK_F(cdrom,tr->TocIndex));

    if (StartingS > 59) {
        StartingM++;
        StartingS -= (UCHAR)60;
    }

    if (g_Devices[ cdrom ]->State & CD_PLAYING) {

        MCI_PLAY_PARMS mciPlay;


        endindex = FindContiguousEnd( cdrom, tr );

        mciPlay.dwFrom = MCI_MAKE_MSF( StartingM, StartingS, StartingF );
        mciPlay.dwTo   = MCI_MAKE_MSF( TRACK_M(cdrom,endindex),
                                       TRACK_S(cdrom,endindex),
                                       TRACK_F(cdrom,endindex) );
        status = PlayCdrom( g_Devices[ cdrom ]->hCd, &mciPlay );
    }
    else {

        MCI_SEEK_PARMS mciSeek;

        mciSeek.dwTo = MCI_MAKE_MSF( StartingM, StartingS, StartingF );

        status = SeekCdrom( g_Devices[ cdrom ]->hCd, &mciSeek );

    }

    CheckStatus( "SeekToCurrSec", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* GetCurrPos
*
* Query cdrom device for its current position and status
* and return information in callers buffer.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
GetCurrPos(
    int cdrom,
    PCURRPOS CpPtr
    )
{
    DWORD status;
    DWORD dwStatus;
    DWORD dwTrack = 0;
    DWORD dwAbsPos;
    BOOL  fNT;

    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    GetVersionEx(&os);
    if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        fNT = TRUE;
    }
    else
    {
        fNT = FALSE;
    }


    /*
    ** Tell lower layer what we want it to do...in this case,
    ** we need to specify which SubQData format we want returned.
    ** This is exported from scsicdrom.sys to the user layer
    ** so that it could be implemented in one call, instead of
    ** four separate calls (there are four SubQData formats)
    */

    /*
    ** Set up for current position SubQData format.
    */

    if (CDTIME(cdrom).CurrTrack != NULL) {

        if (fNT)
        {
            status = StatusTrackPosCdrom ( g_Devices[ cdrom ]->hCd, &dwStatus, &dwTrack, &dwAbsPos);
        }
        else
        {
            status = GetCdromCurrentPosition( g_Devices[ cdrom ]->hCd, &dwAbsPos );
        }

    }
    else {

        status = MCIERR_INTERNAL;

    }

    if (status == ERROR_SUCCESS) {

        int     iTrack;
        LONG    lAbsPosF;
        LONG    lStartPos;
        LONG    lTrackPos;

        if (!fNT)
        {
            iTrack = (int)GetCdromCurrentTrack( g_Devices[ cdrom ]->hCd );
        }
        else
        {
            iTrack = (int)dwTrack;
        }

        if (!fNT)
        {
            CpPtr->AudioStatus = GetCdromMode( g_Devices[ cdrom ]->hCd );
        }
        else
        {
            CpPtr->AudioStatus = dwStatus;
        }
        CpPtr->Track = iTrack;
        CpPtr->Index = 1;

        iTrack--;

        lStartPos = (TRACK_M(cdrom, iTrack ) * FRAMES_PER_MINUTE) +
                    (TRACK_S(cdrom, iTrack ) * FRAMES_PER_SECOND) +
                    (TRACK_F(cdrom, iTrack ));

        lAbsPosF  = (MCI_MSF_MINUTE(dwAbsPos) * FRAMES_PER_MINUTE) +
                    (MCI_MSF_SECOND(dwAbsPos) * FRAMES_PER_SECOND) +
                    (MCI_MSF_FRAME(dwAbsPos));

        lTrackPos = lAbsPosF - lStartPos;

        /*
        ** Are we in the track lead in zone ?
        */
        if ( lTrackPos < 0 ) {

            /*
            ** Have we just entered the lead in zone
            */
            if (!g_Devices[cdrom]->fProcessingLeadIn) {

                g_Devices[cdrom]->fProcessingLeadIn = TRUE;

                /*
                ** Is the track that we are currently in the next track
                ** that we actually want to play.  If it is then everything is
                ** OK.  If it isn't then we need to hack the current position
                ** information so that it looks like we sre still playing the
                ** previous track.
                */
                if ( CURRTRACK(cdrom)->nextplay
                  && CURRTRACK(cdrom)->nextplay->TocIndex == iTrack) {

                    g_Devices[cdrom]->fShowLeadIn = TRUE;
                }
                else {
                    g_Devices[cdrom]->fShowLeadIn = FALSE;
                }
            }

            g_Devices[cdrom]->fShowLeadIn = FALSE;

            if (g_Devices[cdrom]->fShowLeadIn) {

                CpPtr->Index = 0;
                lTrackPos = -lTrackPos;
            }
            else {

                CpPtr->Track = iTrack;
                iTrack--;
                lTrackPos = lAbsPosF
                               - g_Devices[cdrom]->toc.TrackData[iTrack].AddressF;
            }
        }
        else {

            g_Devices[cdrom]->fShowLeadIn = FALSE;
            g_Devices[cdrom]->fProcessingLeadIn = FALSE;
        }

        CpPtr->m = (int)(lTrackPos / FRAMES_PER_MINUTE);
        CpPtr->s = (int)(lTrackPos % FRAMES_PER_MINUTE) / FRAMES_PER_SECOND;
        CpPtr->f = (int)(lTrackPos % FRAMES_PER_MINUTE) % FRAMES_PER_SECOND;

        CpPtr->ab_m = (int)MCI_MSF_MINUTE(dwAbsPos);
        CpPtr->ab_s = (int)MCI_MSF_SECOND(dwAbsPos);
        CpPtr->ab_f = (int)MCI_MSF_FRAME(dwAbsPos);

        /*
        ** Round up to the nearest second.
        */
        if (CpPtr->f > (FRAMES_PER_SECOND / 2) ) {

            if ( ++CpPtr->s > 59 ) {
                CpPtr->s = 0;
                CpPtr->m++;
            }
        }
        else {
            CpPtr->f = 0;
        }

        if (CpPtr->ab_f > (FRAMES_PER_SECOND / 2) ) {

            if ( ++CpPtr->ab_s > 59 ) {
                CpPtr->ab_s = 0;
                CpPtr->ab_m++;
            }
        }
        else {
            CpPtr->ab_f = 0;
        }

    }
    else {

        ZeroMemory( CpPtr, sizeof(*CpPtr) );
    }

    CheckStatus( "GetCurrPos", status, cdrom );

    return status==ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* SeekToTrackAndHold
*
* Seek to specified track and enter hold state.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
SeekToTrackAndHold(
    int cdrom,
    int tindex
    )
{
    DWORD status;
    MCI_SEEK_PARMS sam;

    sam.dwTo = MCI_MAKE_MSF( TRACK_M(cdrom,tindex),
                             TRACK_S(cdrom,tindex),
                             TRACK_F(cdrom,tindex) );

    status = SeekCdrom( g_Devices[ cdrom ]->hCd, &sam );

    CheckStatus( "SeekToTrackAndHold", status, cdrom );

    return status == ERROR_SUCCESS;
}



/* -------------------------------------------------------------------------
**
** Low level routines
**
** -------------------------------------------------------------------------
*/


/******************************Public*Routine******************************\
* GetCdromTOC
*
* This routine will get the table of contents from
* a CDRom device.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromTOC(
    MCIDEVICEID DevHandle,
    PCDROM_TOC TocPtr
    )
{
    MCI_STATUS_PARMS mciStatus;
    long lAddress, lStartPos, lDiskLen;
    int i;
    DWORD dwRet;

#if DBG
    dprintf( TEXT("Reading TOC for drive %d"), DevHandle );
#endif

    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;

    //
    // NOTE: none of the mciSendCommand calls below bother to check the
    //       return code.  This is asking for trouble... but if the
    //       commands fail we cannot do much about it.
    //
    dwRet = mciSendCommand( DevHandle, MCI_STATUS,
                    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus);

    TocPtr->FirstTrack = 1;
    TocPtr->LastTrack = (UCHAR)mciStatus.dwReturn;

    mciStatus.dwItem = MCI_STATUS_POSITION;
    for ( i = 0; i < TocPtr->LastTrack; i++ ) {

        mciStatus.dwTrack = i + 1;
        dwRet = mciSendCommand( DevHandle, MCI_STATUS,
                        MCI_STATUS_ITEM | MCI_TRACK,
                        (DWORD_PTR)(LPVOID)&mciStatus);

        TocPtr->TrackData[i].TrackNumber = (UCHAR)(i + 1);
        lAddress = TocPtr->TrackData[i].Address = (long)mciStatus.dwReturn;

        lStartPos = (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
                    (MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
                    (MCI_MSF_FRAME( lAddress));

        TocPtr->TrackData[i].AddressF = lStartPos;

    }


    mciStatus.dwItem = MCI_STATUS_LENGTH;
    dwRet = mciSendCommand( DevHandle, MCI_STATUS,
                    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus);

    /*
    ** Convert the absolute start address of the first track
    ** into Frames
    */
    lAddress  = TocPtr->TrackData[0].Address;
    lStartPos = TocPtr->TrackData[0].AddressF;

    /*
    ** Convert the total disk length into Frames
    */
    lAddress  = (long)mciStatus.dwReturn;
    lDiskLen  = (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
                (MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
                (MCI_MSF_FRAME(lAddress));

    /*
    ** Now, determine the absolute start position of the sentinel
    ** track.  That is, the special track that marks the end of the
    ** disk.
    */
    lAddress = lStartPos + lDiskLen;

    TocPtr->TrackData[i].TrackNumber = 0;
    TocPtr->TrackData[i].Address     =
        MCI_MAKE_MSF((lAddress / FRAMES_PER_MINUTE),
                     (lAddress % FRAMES_PER_MINUTE) / FRAMES_PER_SECOND,
                     (lAddress % FRAMES_PER_MINUTE) % FRAMES_PER_SECOND);

    return (TocPtr->LastTrack != 0) ? ERROR_SUCCESS : MCIERR_INTERNAL;
}




/******************************Public*Routine******************************\
* StopCdrom
*
* This routine will stop a CDRom device that is playing.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
StopCdrom(
    MCIDEVICEID DevHandle
    )
{
    MCI_GENERIC_PARMS mciGen;

    ZeroMemory( &mciGen, sizeof(mciGen) );

    return mciSendCommand( DevHandle, MCI_STOP, 0L, (DWORD_PTR)(LPVOID)&mciGen );
}



/******************************Public*Routine******************************\
* PauseCdrom
*
* This routine will pause a CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
PauseCdrom(
    MCIDEVICEID DevHandle
    )
{
    MCI_GENERIC_PARMS mciGen;

    ZeroMemory( &mciGen, sizeof(mciGen) );

    return mciSendCommand( DevHandle, MCI_PAUSE, 0L, (DWORD_PTR)(LPVOID)&mciGen );
}


/******************************Public*Routine******************************\
* ResumeCdrom
*
* This routine will resume a paused CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
ResumeCdrom(
    MCIDEVICEID DevHandle,
    int cdrom
    )

{
    MCI_GENERIC_PARMS   mciGen;
    DWORD               dwRet;
    static int          fCanResume = -1;

    ZeroMemory( &mciGen, sizeof(mciGen) );

    switch (fCanResume) {

    case -1:
        dwRet = mciSendCommand( DevHandle, MCI_RESUME, MCI_TO, (DWORD_PTR)(LPVOID)&mciGen );

        fCanResume = (dwRet == MMSYSERR_NOERROR ? 1 : 0);

        if (0 == fCanResume) {
            dwRet = (PlayCurrTrack( cdrom ) ? MMSYSERR_NOERROR : MCIERR_HARDWARE);
        }
        break;

    case 0:
        dwRet = (PlayCurrTrack( cdrom ) ? MMSYSERR_NOERROR : MCIERR_HARDWARE);
        break;

    case 1:
        dwRet = mciSendCommand( DevHandle, MCI_RESUME, MCI_TO, (DWORD_PTR)(LPVOID)&mciGen );
        break;
    }

    return dwRet;
}



/******************************Public*Routine******************************\
* PlayCdrom
*
* This routine plays a CDRom device starting and ending at the MSF
* positions specified in the structure passed in.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
PlayCdrom(
    MCIDEVICEID DevHandle,
    MCI_PLAY_PARMS *mciPlay
    )
{
    return mciSendCommand( DevHandle, MCI_PLAY,
                           MCI_FROM | MCI_TO, (DWORD_PTR)(LPVOID)mciPlay );
}

/******************************Public*Routine******************************\
* IsCdromTrackAudio
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
IsCdromTrackAudio(
    CDHANDLE DevHandle,
    int iTrackNumber
    )
{
    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_CDA_STATUS_TYPE_TRACK;
    mciStatus.dwTrack = iTrackNumber + 1;

    mciSendCommand( DevHandle, MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK,
                    (DWORD_PTR)(LPVOID)&mciStatus);

    return mciStatus.dwReturn == (DWORD)MCI_CDA_TRACK_AUDIO;
}


/******************************Public*Routine******************************\
* GetCdromCurrentPosition
*
* Gets the current ABSOLUTE position of the specified cdrom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromCurrentPosition(
    CDHANDLE DevHandle,
    DWORD *lpdwPosition
    )
{

    MCI_STATUS_PARMS mciStatus;
    DWORD            dwErr;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    mciStatus.dwItem = MCI_STATUS_POSITION;
    dwErr = mciSendCommand( DevHandle, MCI_STATUS,
                            MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus );
    *lpdwPosition = (long)mciStatus.dwReturn;

    return dwErr;
}



/******************************Public*Routine******************************\
* GetCdromMode
*
* Gets the current mode of the cdrom.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromMode(
    MCIDEVICEID DevHandle
    )
{

    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    mciStatus.dwItem = MCI_STATUS_MODE;
    mciSendCommand( DevHandle, MCI_STATUS,
                    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus );
    return (DWORD)mciStatus.dwReturn;
}


/******************************Public*Routine******************************\
* GetCdromCurrentTrack
*
* Gets the current track of the cdrom.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromCurrentTrack(
    MCIDEVICEID DevHandle
    )
{

    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    mciStatus.dwItem = MCI_STATUS_CURRENT_TRACK;
    mciSendCommand( DevHandle, MCI_STATUS,
                    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus );
    return (DWORD)mciStatus.dwReturn;
}


/******************************Public*Routine******************************\
* SeekCdrom
*
* This routine seek to an MSF address on the audio CD and enters
* a hold (paused) state.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
SeekCdrom(
    MCIDEVICEID DevHandle,
    MCI_SEEK_PARMS *mciSeek
    )
{
    return mciSendCommand( DevHandle, MCI_SEEK,
                           MCI_TO, (DWORD_PTR)(LPVOID)mciSeek );
}



/******************************Public*Routine******************************\
* EjectCdrom
*
* This routine will eject a disc from a CDRom device or close the tray if
* it is open.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
EjectCdrom(
    MCIDEVICEID DevHandle
    )
{
    MCI_SET_PARMS   mciSet;
    DWORD mmr = ERROR_SUCCESS;

    ZeroMemory( &mciSet, sizeof(mciSet) );

    if ((GetCdromMode(DevHandle) == (DWORD)MCI_MODE_OPEN) && g_fCDOpen)
    {
        mmr = mciSendCommand( DevHandle, MCI_SET,
                               MCI_SET_DOOR_CLOSED, (DWORD_PTR)(LPVOID)&mciSet );

        if (mmr == ERROR_SUCCESS)
        {
            g_fCDOpen = FALSE;
        }
    }
    else
    {
        mmr = mciSendCommand( DevHandle, MCI_SET,
                               MCI_SET_DOOR_OPEN, (DWORD_PTR)(LPVOID)&mciSet );

        if (mmr == ERROR_SUCCESS)
        {
            g_fCDOpen = TRUE;
        }
    }

    return (mmr);
}



/******************************Public*Routine******************************\
* TestUnitReadyCdrom
*
* This routine will retrieve the status of the CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
TestUnitReadyCdrom(
    MCIDEVICEID DevHandle
    )
{
    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    mciStatus.dwItem = MCI_STATUS_MEDIA_PRESENT;
    if ( mciSendCommand( DevHandle, MCI_STATUS, MCI_STATUS_ITEM,
                         (DWORD_PTR)(LPVOID)&mciStatus ) == MMSYSERR_NOERROR ) {

        return mciStatus.dwReturn ? ERROR_SUCCESS : ERROR_NOT_READY;
    }

    return ERROR_NOT_READY;

}



/******************************Public*Routine******************************\
* StatusTrackPosCdrom
*
* This routine will retrieve the 
* status, current track, and current position of the CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
StatusTrackPosCdrom(
    MCIDEVICEID DevHandle,
    DWORD * pStatus,
    DWORD * pTrack,
    DWORD * pPos
    )
{
    DWORD dwErr;
    MCI_STATUS_PARMS mciStatus;
    PSTATUSTRACKPOS pSTP = NULL;
    STATUSTRACKPOS stp;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    // Note:  This is a non-standard MCI call (I.E. HACK!)
    //        the only reason for this behavior is it reduces
    //        the number of IOCTL's per 1/2 second on the HeartBeat
    //        thread for updating the timer display from ~15 to only
    //        ~1 on average.   Resulting in a major reduction in
    //        system traffic on the SCSI or IDE bus.

    // Note:  we are passing down a structre to MCICDA containing
    //        the position, track, and status values which it will
    //        fill in for us and return.
    mciStatus.dwItem = MCI_STATUS_TRACK_POS;
    mciStatus.dwReturn = (DWORD_PTR)&stp;
    dwErr = mciSendCommand( DevHandle, MCI_STATUS, MCI_STATUS_ITEM,
                         (DWORD_PTR)(LPVOID)&mciStatus );
    if (dwErr == MMSYSERR_NOERROR)
    {
        pSTP = (PSTATUSTRACKPOS)mciStatus.dwReturn;
        if (pSTP)
        {
            if (pStatus)
                *pStatus = pSTP->dwStatus;
            if (pTrack)
                *pTrack = pSTP->dwTrack;
            if (pPos)
                *pPos = pSTP->dwDiscTime;

            pSTP = NULL;
        }
    }

    return dwErr;
} // End StatusTrackPosCdrom

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\dib.h ===
/*----------------------------------------------------------------------------*\
|   Routines for dealing with Device independent bitmaps                       |
|									       |
|   History:                                                                   |
|       06/23/89 toddla     Created                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/

HANDLE      OpenDIB(LPTSTR szFile, HFILE fh);
UINT        PaletteSize(VOID FAR * pv);
UINT        DibNumColors(VOID FAR * pv);
HANDLE      DibFromBitmap(HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage);
BOOL        DibBlt(HDC hdc, int x0, int y0, int dx, int dy, HANDLE hdib, int x1, int y1, LONG rop, UINT wUsage);
BOOL        DibInfo(LPBITMAPINFOHEADER lpbiSource, LPBITMAPINFOHEADER lpbiTarget);
HANDLE      ReadDibBitmapInfo(HFILE fh);

#define BFT_ICON   0x4349   /* 'IC' */
#define BFT_BITMAP 0x4d42   /* 'BM' */
#define BFT_CURSOR 0x5450   /* 'PT' */

#define WIDTHBYTES(i)     ((i+31)/32*4)      /* ULONG aligned ! */
#define ALIGNULONG(i)     ((i+3)/4*4)        /* ULONG aligned ! */
#define ISDIB(bft) ((bft) == BFT_BITMAP)
#define DIBWIDTHBYTES(bi) (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\database.cpp ===
/******************************Module*Header*******************************\
* Module Name: database.c
*
* This module implements the database routines for the CD Audio app.
* The information is stored in the ini file "cdaudio.ini" which should
* be located in the nt\windows directory.
*
* Warning:
*   These functions ARE NOT THREAD safe.
*   The functions in this file MUST only be called on the UI thread.  Before
*   calling any of the functions the CALLER MUST call LockTableOfContents
*   for the specified cdrom device.
*
* Author:
*   Rick Turner (ricktu) 31-Jan-1992
*
*
* Revision History:
*
*   04-Aug-1992 (ricktu)    Incorperated routines from old cdaudio.c,
*                           and made work w/new child window framework.
*
*
* Copyright (c) 1993 - 1995 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE
#include <windows.h>
#include "playres.h"
#include "cdapi.h"
#include "cdplayer.h"
#include "database.h"
#include "literals.h"


#include <string.h>
#include <stdio.h>
#include <tchar.h>

#include "trklst.h"

#include "..\cdnet\cdnet.h"
#include "..\cdopt\cdopt.h"

/* -------------------------------------------------------------------------
** Private entry points
** -------------------------------------------------------------------------
*/
DWORD
ComputeOldDiscId(
    int cdrom
    );


BOOL
ReadEntry(
    int cdrom,
    DWORD dwId);


/*****************************Private*Routine******************************\
* ComputeOldDiscId
*
* This routine computes a unique ID based on the information
* in the table of contexts a given disc.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
DWORD
ComputeOldDiscId(
    int cdrom
    )
{
    int NumTracks,i;
    DWORD DiscId = 0;


    NumTracks = g_Devices[ cdrom ]->toc.LastTrack -
		g_Devices[ cdrom ]->toc.FirstTrack;

    for ( i = 0; i < NumTracks; i++ )  {
	DiscId += ( (TRACK_M(cdrom,i) << 16) +
		    (TRACK_S(cdrom,i) <<  8) +
		     TRACK_F(cdrom,i) );
    }

    return DiscId;

}


/******************************Public*Routine******************************\
* ComputeNewDiscId
*
* Just call mci to get the product ID.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
ComputeNewDiscId(
    int cdrom
    )
{
#ifdef USE_IOCTLS
    return ComputeOrgDiscId( cdrom );
#else

    MCI_INFO_PARMS  mciInfo;
    TCHAR           szBuffer[32];
    DWORD           dwRet;

    mciInfo.lpstrReturn = szBuffer;
    mciInfo.dwRetSize   = sizeof(szBuffer)/sizeof(TCHAR);

    dwRet = mciSendCommand( g_Devices[cdrom]->hCd, MCI_INFO,
			    MCI_INFO_MEDIA_IDENTITY,
			    (DWORD_PTR)(LPVOID)&mciInfo );

    if ( dwRet != MMSYSERR_NOERROR ) {
	return 0L;
    }

    _stscanf(szBuffer, TEXT("%ld"), &dwRet );

    return dwRet;

#endif
}



/*****************************Private*Routine******************************\
* ComputeOrgDiscId
*
* This routine computes a unique ID based on the information
* in the table of contexts a given disc. This is done by taking
* the TMSF value for each track and XOR'ing it with the previous
* quantity shifted left one bit.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
DWORD
ComputeOrgDiscId(
    int cdrom
    )
{
    int NumTracks,i;
    DWORD DiscId = 0;


    NumTracks = g_Devices[ cdrom ]->toc.LastTrack -
		g_Devices[ cdrom ]->toc.FirstTrack + 1;

    for ( i = 0; i < NumTracks; i++ ) {
	DiscId = (DiscId << 1) ^
		   ((i<<24) +
		    (TRACK_M(cdrom,i) << 16) +
		    (TRACK_S(cdrom,i) <<  8) +
		     TRACK_F(cdrom,i) );
    }

    return DiscId;

}


/*****************************Private*Routine******************************\
* ErasePlayList
*
* Erases the current play list.  This includes freeing the memory
* for the nodes in the play list, and resetting the current track
* pointer to NULL.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
ErasePlayList(
    int cdrom
    )
{

    PTRACK_PLAY temp, temp1;

    //
    // Free memory for each track in play list
    //

    temp = PLAYLIST( cdrom );
    while (temp!=NULL) {

	temp1 = temp->nextplay;
	LocalFree( (HLOCAL)temp );
	temp = temp1;

    }

    //
    // Reset pointers
    //

    PLAYLIST( cdrom ) = NULL;
    CURRTRACK( cdrom ) = NULL;
}



/******************************Public*Routine******************************\
* EraseSaveList
*
* Erases the current save list.  This includes freeing the memory
* for the nodes in the save list.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
EraseSaveList(
    int cdrom
    )
{

    PTRACK_PLAY temp, temp1;

    //
    // Free memory for each track in play list
    //


    temp = SAVELIST( cdrom );
    while ( temp != NULL ) {

	temp1 = temp->nextplay;
	LocalFree( (HLOCAL)temp );
	temp = temp1;

    }

    //
    // Reset pointers
    //

    SAVELIST( cdrom ) = NULL;

}


/*****************************Private*Routine******************************\
* EraseTrackList
*
* Erases the current track list.  This includes freeing the memory
* for the nodes in the track list, and resetting the track list
* pointer to NULL.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
EraseTrackList(
    int cdrom
    )
{

    PTRACK_INF temp, temp1;

    //
    // Free memory for each track in track list
    //

    temp = ALLTRACKS( cdrom );
    while ( temp != NULL ) {

	temp1 = temp->next;
	LocalFree( (HLOCAL)temp );
	temp = temp1;
    }

    //
    // Reset pointers
    //

    ALLTRACKS( cdrom ) = NULL;

}

/******************************Public*Routine******************************\
* CopyPlayList
*
* Returns a copy of the playlist pointed to by p.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
PTRACK_PLAY
CopyPlayList(
    PTRACK_PLAY p
    )
{

    PTRACK_PLAY t,t1,tend,tret;

    tret = tend = NULL;

    //
    // Duplicate list pointed to by p.
    //

    t = p;
    while( t!=NULL ) {

	t1 = (PTRACK_PLAY)AllocMemory( sizeof(TRACK_PLAY) );
	t1->TocIndex = t->TocIndex;
	t1->min = t->min;
	t1->sec = t->sec;
	t1->nextplay = NULL;
	t1->prevplay = tend;

	if (tret==NULL) {

	    tret = tend = t1;
	}
	else {

	    tend->nextplay = t1;
	    tend = t1;
	}

	t = t->nextplay;

    }

    return(tret);

}


/*****************************Private*Routine******************************\
* ResetPlayList
*
* Resets play order for the disc.  Used to initialize/reset
* the play list.  This is done by reseting the doubly-linked list
* of tracks in the g_Devices[...]->CdInfo.PlayList.[prevplay,nextplay]
* pointers.  All the tracks on the CD are stored in a singly linked list
* pointed to by g_Devices[...]->CdInfo.AllTracks pointer.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
ResetPlayList(
     int cdrom
    )
{
    PTRACK_INF t;
    PTRACK_PLAY temp, prev;


    //
    // Kill old play list
    //

    ErasePlayList( cdrom );
    EraseSaveList( cdrom );

    //
    // Duplicate each node in AllTracks and insert in-order
    // in SaveList list.  The SaveList is the master which is
    // used for the playlist.
    //

    t = ALLTRACKS( cdrom );
    prev = NULL;

    while (t!=NULL) {

	temp = (PTRACK_PLAY)AllocMemory( sizeof(TRACK_PLAY) );

	temp->TocIndex = t->TocIndex;
	temp->min = 0;
	temp->sec = 0;
	temp->prevplay = prev;
	temp->nextplay = NULL;

	if (prev!=NULL) {

	    prev->nextplay = temp;
	}
	else {

	    SAVELIST( cdrom ) = temp;
	}

	prev = temp;
	t=t->next;

    }

    PLAYLIST( cdrom ) = CopyPlayList( SAVELIST( cdrom) );
}

void RecomputePlayTimes(int dCdrom)
{
    /*
    ** Compute PLAY length
    */
    PTRACK_PLAY pp;
    int m, s, mtemp, stemp;

    m = s = 0;
    for( pp = PLAYLIST(dCdrom); pp != NULL; pp = pp->nextplay )
    {

        FigureTrackTime( dCdrom, pp->TocIndex, &mtemp, &stemp );

        m+=mtemp;
        s+=stemp;

        pp->min = mtemp;
        pp->sec = stemp;
    }

    //also refresh the savelist
    for( pp = SAVELIST(dCdrom); pp != NULL; pp = pp->nextplay )
    {

        FigureTrackTime( dCdrom, pp->TocIndex, &mtemp, &stemp );

        pp->min = mtemp;
        pp->sec = stemp;
    }

    m += (s / 60);
    s =  (s % 60);

    CDTIME(dCdrom).TotalMin = m;
    CDTIME(dCdrom).TotalSec = s;

    /*
    ** Make sure that the track time displayed in the LED and the
    ** status bar is correct.  If we have a current track and the
    ** CD is playing or paused then everything is OK.  Otherwise, we
    ** have to reset the track times.
    */
    if ( CURRTRACK( dCdrom ) != NULL ) {

        if ( STATE(dCdrom) & CD_STOPPED ) {

            CDTIME(dCdrom).TrackTotalMin = CURRTRACK( dCdrom )->min;
            CDTIME(dCdrom).TrackRemMin   = CURRTRACK( dCdrom )->min;

            CDTIME(dCdrom).TrackTotalSec = CURRTRACK( dCdrom )->sec;
            CDTIME(dCdrom).TrackRemSec   = CURRTRACK( dCdrom )->sec;
        }

    }
    else {

        CDTIME(dCdrom).TrackTotalMin = 0;
        CDTIME(dCdrom).TrackRemMin   = 0;
        CDTIME(dCdrom).TrackTotalSec = 0;
        CDTIME(dCdrom).TrackRemSec   = 0;
    }

    if (dCdrom == g_CurrCdrom)
    {
        UpdateDisplay( DISPLAY_UPD_DISC_TIME );
    }
}

void CreateNewEntry(int cdrom, DWORD key, PCDROM_TOC lpTOC)
{
    /*
    ** This is a new entry, fill it in but don't store it in the database.
    */

    PTRACK_INF  temp, temp1;
    PTRACK_PLAY pTempCurrTrack = CURRTRACK(cdrom);
    int i, num;
    int nSaveTrack = -1;

    if (CURRTRACK(cdrom))
    {
        nSaveTrack = CURRTRACK(cdrom)->TocIndex;
    }

    ErasePlayList( cdrom );
    EraseSaveList( cdrom );
    EraseTrackList( cdrom );

    g_Devices[ cdrom ]->CdInfo.iFrameOffset = NEW_FRAMEOFFSET;
	g_Devices[ cdrom ]->CdInfo.IsVirginCd = TRUE;
    g_Devices[ cdrom ]->CdInfo.Id = key;

	wsprintf( (LPTSTR)ARTIST( cdrom ), IdStr( STR_NEW_ARTIST ) );
	wsprintf( (LPTSTR)TITLE( cdrom ), IdStr( STR_NEW_TITLE ) );

	if (lpTOC)
    {
        NUMTRACKS( cdrom ) = num = lpTOC->LastTrack - lpTOC->FirstTrack + 1;
    }
    else
    {
        num = NUMTRACKS( cdrom );
    }


	/*
	** Create generic playlist, which is all audio tracks
	** played in the order they are on the CD.  First, create
	** a singly linked list that contains all the tracks.
	** Then, create a double linked list, using the nodes of
	** from the single linked list for the play list.
	*/


	for( i = 0; i < num; i++ ) {

	    /*
	    ** Create storage for track
	    */

	    temp = (PTRACK_INF)AllocMemory( sizeof(TRACK_INF) );

	    /*
	    ** Initialize information (storage already ZERO initialized)
	    */

	    wsprintf( (LPTSTR)temp->name, IdStr( STR_INIT_TRACK ), i+1 );
	    temp->TocIndex = i;
	    temp->next = NULL;

	    /*
	    ** Add node to singly linked list of all tracks
	    */

	    if (i == 0) {

		temp1 = ALLTRACKS( cdrom ) = temp;
	    }
	    else {

		temp1->next = temp;
		temp1 = temp;
	    }
	}

	/*
	** Generate generic play list (all tracks in order)
	*/

	ResetPlayList( cdrom );

    if (nSaveTrack > -1)
    {
	    PTRACK_PLAY  playlist;
	    for( playlist = PLAYLIST(cdrom);
             playlist != NULL;
             playlist = playlist->nextplay )
	    {
            if (playlist->TocIndex == nSaveTrack)
            {
                CURRTRACK(cdrom) = playlist;
            }
        }
    }

    if (!g_fSelectedOrder)
    {
        ComputeSingleShufflePlayList(cdrom);
    }

    RecomputePlayTimes(cdrom);
}

BOOL GetInternetDatabase(int cdrom, DWORD key, BOOL fHitNet, BOOL fManual, HWND hwndCallback, void* pData)
{
    if (!g_fBlockNetPrompt)
    {
        if (fHitNet)
        {
            ICDNet* pICDNet = NULL;
            if (SUCCEEDED(CDNET_CreateInstance(NULL, IID_ICDNet, (void**)&pICDNet)))
            {
		            pICDNet->SetOptionsAndData((void*)g_pSink->GetOptions(),(void*)g_pSink->GetData());
                    pICDNet->Download(g_Devices[ cdrom ]->hCd,g_Devices[cdrom]->drive,key,(LPCDTITLE)pData,fManual,hwndCallback);
                    pICDNet->Release();
            }
            return FALSE; //couldn't find title just now, catch it on the callback
        }
    }

    if ( ReadEntry(cdrom, key))
    {
        return TRUE;
    }

    if (!fHitNet)
    {
        CreateNewEntry(cdrom, key, NULL);
        RecomputePlayTimes(cdrom);
    }

    return FALSE;
}

/*****************************Private*Routine******************************\
* ReadEntry
*
* Try to read entry for new disc from  database ini file.
* The section name we are trying to read is a hex
* value of the disc id.  If the sections is found,
* fill in the data for the disc in the cdrom drive.
*
* This function uses over 16K of stack space !!
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
BOOL
ReadEntry(
    int cdrom,
    DWORD dwId)
{
    UINT        i;
    int         numtracks, numplay;
    PTRACK_INF  temp, curr;
    PTRACK_PLAY temp1, prev;
    BOOL        fRewriteEntry = FALSE;
    LPCDDATA    pData = NULL;

    g_Devices[ cdrom ]->CdInfo.iFrameOffset = NEW_FRAMEOFFSET;

    pData = (LPCDDATA)g_pSink->GetData();
    if( !pData )
    {
        //Can't create the options object, so fail
        return (FALSE);
    }

    pData->AddRef();

    //
    // Try to read in title from the options database
    //

    if (!pData->QueryTitle(dwId))
    {
        pData->Release();
        return (FALSE);
    }

    //
    // We found an entry for this disc, so copy all the information
    // from the title database

    LPCDTITLE pCDTitle = NULL;

    if (FAILED(pData->LockTitle(&pCDTitle,dwId)))
    {
        pData->Release();
        return FALSE;
    }

    _tcscpy(g_Devices[ cdrom ]->CdInfo.Title,pCDTitle->szTitle);

    numtracks = pCDTitle->dwNumTracks;

    // Make sure there is at least one track!!!
    if (0 == numtracks)
    {
    	fRewriteEntry = TRUE;
    }

    g_Devices[ cdrom ]->CdInfo.NumTracks = numtracks;
    _tcscpy(g_Devices[ cdrom ]->CdInfo.Artist,pCDTitle->szArtist);

    //
    // Validate the stored track numbers
    //
    if (g_Devices[cdrom]->fIsTocValid)
    {
	    int    maxTracks;  // validate the high point in database

	    maxTracks = g_Devices[cdrom]->toc.LastTrack;

	    if (numtracks > maxTracks)
        {
	        // Current database contains invalid data
	        // this can result in the CD not playing at all as the end
	        // point is likely to be invalid
	        g_Devices[ cdrom ]->CdInfo.NumTracks
	          = numtracks
	          = maxTracks;
	        fRewriteEntry = TRUE;
	    }
    }

    //
    // Read the track list information
    //

    for (i=0, curr = NULL; i < (UINT)numtracks; i++)
    {
	    temp = (PTRACK_INF)AllocMemory( sizeof(TRACK_INF) );
	    temp->TocIndex = i;
	    temp->next = NULL;

        _tcscpy(temp->name,pCDTitle->pTrackTable[i].szName);

	    if (curr==NULL)
        {
	        ALLTRACKS( cdrom ) = curr = temp;

	    } else
        {

	        curr->next = temp;
	        curr = temp;

	    }
    }

    // Make sure there is at least one entry in TRACK list
    if (ALLTRACKS(cdrom) == NULL)
    {
	    fRewriteEntry = TRUE;
    }

    //
    // if we detected a problem in the ini file, or the entry is an
    // old format, rewrite the section.
    //

    if (fRewriteEntry)
    {
	    //
	    // Generate generic play list (all tracks in order)
	    //

	    ResetPlayList( cdrom );

        if (!g_fSelectedOrder)
        {
            ComputeSingleShufflePlayList(cdrom);
        }

        RecomputePlayTimes(cdrom);
    }
    else
    {
	    //
	    // Read play list (order) information and construct play list doubly
	    // linked list
	    //

	    numplay = pCDTitle->dwNumPlay;
        if (numplay == 0)
        {
            numplay = pCDTitle->dwNumTracks;
        }

	    prev = NULL;

        int iCurrTrack = -1;

        if (CURRTRACK(cdrom)!=NULL)
        {
            iCurrTrack = CURRTRACK(cdrom)->TocIndex;
        }

        EraseSaveList(cdrom);
        ErasePlayList(cdrom);

	    for (int tr_index = 0; tr_index < numplay; tr_index++)
        {
	        /*
	        ** Assert that i is a valid index.
	        **  ie 0 <= i <= (numtracks - 1)
	        */

            if (pCDTitle->dwNumPlay > 0)
            {
                i = pCDTitle->pPlayList[tr_index];
            }
            else
            {
                i = tr_index;
            }

	        i = min( ((UINT)numtracks - 1), i );

	        temp1 = (PTRACK_PLAY)AllocMemory( sizeof(TRACK_PLAY) );
	        temp1->TocIndex = (int)i;
	        temp1->min = 0;
	        temp1->sec = 0;
	        temp1->prevplay = prev;
	        temp1->nextplay = NULL;

	        if (prev==NULL)
            {
    		    SAVELIST( cdrom ) = temp1;
	        }
            else
            {
    		    prev->nextplay  = temp1;
	        }
	        prev = temp1;
	    }

	    // Make sure there is at least one entry in SAVED list
	    if (SAVELIST(cdrom) == NULL)
	    {
	        // Nope, use default list instead
	        ResetPlayList( cdrom );
	    }

	    PLAYLIST( cdrom ) = CopyPlayList( SAVELIST( cdrom ) );

        //reset current track if necessary
        if (iCurrTrack != -1)
        {
            BOOL fFound = FALSE;

            for (PTRACK_PLAY pp = PLAYLIST(cdrom); pp != NULL; pp = pp->nextplay )
            {
                if ( pp->TocIndex == iCurrTrack )
                {
                    fFound = TRUE;
                    break;
                }
            } //end for

            if (fFound)
            {
                CURRTRACK(cdrom) = pp;
            }
            else
            {
                /*
                ** If the track was not found in the new track list and this
                ** cd is currently playing then stop it.
                */
                if ( (STATE(cdrom) & (CD_PLAYING | CD_PAUSED)) )
                {

                    SendDlgItemMessage( g_hwndApp, IDM_PLAYBAR_STOP,
                                        WM_LBUTTONDOWN, 1, 0 );

                    SendDlgItemMessage( g_hwndApp, IDM_PLAYBAR_STOP,
                                        WM_LBUTTONUP, 1, 0 );
                }

                CURRTRACK(cdrom) = PLAYLIST(cdrom);
            }
        }

        /*
        ** If we were previously in "Random" mode shuffle the new
        ** playlist.
        */
        if (!g_fSelectedOrder)
        {
            ComputeSingleShufflePlayList(cdrom);
        }

        RecomputePlayTimes(cdrom);
    }

    //unlock title data, don't persist it
    pData->UnlockTitle(pCDTitle,FALSE);
    pData->Release();

    return TRUE;
}

/******************************Public*Routine******************************\
* AddFindEntry
*
* Search the database file for the current disc,  if found, read the
* information, otherwise, generate some default artist and track names etc.
* but don't store this in the database.  A new entry is only added to the
* database after the user has used the "Edit Track Titles" dialog box.
*
* The design of this function is complicated by the fact that we have to
* support two previous attempts at generating CDplayer keys.  Also, we try
* to support the MusicBox key format now that it is compatible with the
* new CDplayer format.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
AddFindEntry(
    int cdrom,
    DWORD key,
    PCDROM_TOC lpTOC
    )
{
    /*
    ** Kill off old PlayList, Save lists if they exists.
    */

    ErasePlayList( cdrom );
    EraseSaveList( cdrom );
    EraseTrackList( cdrom );

    /*
    ** Check ini file for an existing entry
    **
    ** First Look in cdplayer.ini using the new key, return if found
    */

    // We initialize this field early, otherwise ReadEntry will not be
    // able to save any new information (or lose invalid).
    g_Devices[ cdrom ]->CdInfo.save = TRUE;

    if ( ReadEntry(cdrom, key) )
    {
	    return;
    }

    /*
    ** Initialize these fields
    */
    g_Devices[ cdrom ]->CdInfo.IsVirginCd = FALSE;
    g_Devices[ cdrom ]->CdInfo.Id = key;

	/*
	** dstewart: Try to get the info from the net
	*/
	if ( GetInternetDatabase(cdrom, key, TRUE, FALSE, GetParent(g_hwndApp),NULL) )
	{
        return;
    }
	/*
	** end dstewart
	*/

    CreateNewEntry(cdrom,key,lpTOC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\cdplayer.h ===
/******************************Module*Header*******************************\
* Module Name: cdplayer.h
*
*
*
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
//#ifdef CHICAGO
#include <shellapi.h>
//#endif

#include "..\main\mmfw.h"

#define IDC_ARTIST_NAME IDC_COMBO1
#define IDC_TRACK_LIST IDC_COMBO2
#define IDC_TITLE_NAME IDC_EDIT1
#define IDB_TRACK 127

/* -------------------------------------------------------------------------
** Replace the WM_MENUSELECT message craker because it contains a bug.
** -------------------------------------------------------------------------
*/
#ifdef HANDLE_WM_MENUSELECT
#undef HANDLE_WM_MENUSELECT
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn)                  \
    ((fn)( (hwnd), (HMENU)(lParam),                                     \
           (UINT)LOWORD(wParam), NULL, (UINT)HIWORD(wParam)), 0L)
#endif

#ifndef NUMELEMS
    #define NUMELEMS(a) (sizeof((a))/sizeof((a)[0]))
#endif // NUMELEMS


#define NUM_OF_CONTROLS (IDC_CDPLAYER_LAST - IDC_CDPLAYER_FIRST + 1)
#define NUM_OF_BUTTONS  (IDC_BUTTON8 - IDC_BUTTON1 + 1)

#define INDEX( _x_ )    ((_x_) - IDC_CDPLAYER_FIRST)

#if DBG

void
dprintf(
    TCHAR *lpszFormat,
    ...
    );
void CDAssert( LPSTR x, LPSTR file, int line );
#undef ASSERT
#define ASSERT(_x_) if (!(_x_))  CDAssert( #_x_, __FILE__, __LINE__ )

#else

#undef ASSERT
#define ASSERT(_x_)

#endif

#define WM_CDPLAYER_MSG_BASE        (WM_USER + 0x1000)

#define WM_NOTIFY_CDROM_COUNT       (WM_CDPLAYER_MSG_BASE)
#define WM_NOTIFY_TOC_READ          (WM_CDPLAYER_MSG_BASE+1)
#define WM_NOTIFY_FIRST_SCAN        (WM_CDPLAYER_MSG_BASE+2)

#define HEARTBEAT_TIMER_ID          0x3243
#ifdef DAYTONA
#define HEARTBEAT_TIMER_RATE        250         /* 4 times a second */
#else
#define HEARTBEAT_TIMER_RATE        500         /* 2 times a second */
#endif

#define SKIPBEAT_TIMER_ID           0x3245
#define SKIPBEAT_TIMER_RATE         200         /* 5  times a second */
#define SKIPBEAT_TIMER_RATE2        100         /* 10 times a second */
#define SKIPBEAT_TIMER_RATE3        50          /* 20 times a second */
#define SKIP_ACCELERATOR_LIMIT1     5           /* 5  seconds        */
#define SKIP_ACCELERATOR_LIMIT2     20          /* 20 seconds        */


#define FRAMES_PER_SECOND           75
#define FRAMES_PER_MINUTE           (60*FRAMES_PER_SECOND)


#define DISPLAY_UPD_LED             0x00000001
#define DISPLAY_UPD_TITLE_NAME      0x00000002
#define DISPLAY_UPD_TRACK_NAME      0x00000004
#define DISPLAY_UPD_TRACK_TIME      0x00000008
#define DISPLAY_UPD_DISC_TIME       0x00000010
#define DISPLAY_UPD_CDROM_STATE     0x00000020
#define DISPLAY_UPD_LEADOUT_TIME    0x80000000


#define INTRO_LOWER_LEN             5
#define INTRO_DEFAULT_LEN           10
#define INTRO_UPPER_LEN             15


//  Audio Play Files consist completely of this header block.  These
//  files are readable in the root of any audio disc regardless of
//  the capabilities of the drive.
//
//  The "Unique Disk ID Number" is a calculated value consisting of
//  a combination of parameters, including the number of tracks and
//  the starting locations of those tracks.
//
//  Applications interpreting CDDA RIFF files should be advised that
//  additional RIFF file chunks may be added to this header in the
//  future in order to add information, such as the disk and song title.

#define RIFF_RIFF 0x46464952
#define RIFF_CDDA 0x41444443

typedef struct {
    DWORD   dwRIFF;         // 'RIFF'
    DWORD   dwSize;         // Chunk size = (file size - 8)
    DWORD   dwCDDA;         // 'CDDA'
    DWORD   dwFmt;          // 'fmt '
    DWORD   dwCDDASize;     // Chunk size of 'fmt ' = 24
    WORD    wFormat;        // Format tag
    WORD    wTrack;         // Track number
    DWORD   DiscID;         // Unique disk id
    DWORD   lbnTrackStart;  // Track starting sector (LBN)
    DWORD   lbnTrackLength; // Track length (LBN count)
    DWORD   msfTrackStart;  // Track starting sector (MSF)
    DWORD   msfTrackLength; // Track length (MSF)
}   RIFFCDA;


BOOL
InitInstance(
    HANDLE hInstance
    );


INT_PTR CALLBACK
MyMainWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
CDPlay_OnInitDialog(
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lParam
    );

void
CDPlay_OnInitMenuPopup(
    HWND hwnd,
    HMENU hMenu,
    UINT item,
    BOOL fSystemMenu
    );

void
CDPlay_OnPaint(
    HWND hwnd
    );

void
CDPlay_OnSysColorChange(
    HWND hwnd
    );

void
CDPlay_OnWinIniChange(
    HWND hwnd,
    LPCTSTR lpszSectionName
    );

LRESULT
CDPlay_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR *pnmhdr
    );

UINT
CDPlay_OnNCHitTest(
    HWND hwnd,
    int x,
    int y
    );

BOOL
CDPlay_OnCopyData(
    HWND hwnd,
    PCOPYDATASTRUCT lpcpds
    );

BOOL
CDPlay_OnTocRead(
    int iDriveRead
    );

BOOL
CDPlay_OnDeviceChange(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam);

void
CDPlay_OnDropFiles(
    HWND hwnd,
    HDROP hdrop
    );

BOOL
CDPlay_OnDrawItem(
    HWND hwnd,
    const DRAWITEMSTRUCT *lpdis
    );

void
CDPlay_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    );

void
CDPlay_OnDestroy(
    HWND hwnd
    );

BOOL
CDPlay_OnClose(
    HWND hwnd,
    BOOL fShuttingDown
    );

void
CDPlay_OnEndSession(
    HWND hwnd,
    BOOL fEnding
    );

void
CDPlay_OnSize(
    HWND hwnd,
    UINT state,
    int cx,
    int cy
    );

BOOL CALLBACK
ChildEnumProc(
    HWND hwndChild,
    LPARAM lp
    );

void
FatalApplicationError(
    INT uIdStringResource,
    ...
    );

void
LED_ToggleDisplayFont(
    HWND hwnd,
    BOOL fFont
    );

LPTSTR
IdStr(
    int idResource
    );

void
CheckMenuItemIfTrue(
    HMENU hMenu,
    UINT idItem,
    BOOL flag
    );

void
ReadSettings(
    void* pData
    );

BOOL
LockTableOfContents(
    int cdrom
    );

BOOL
LockALLTableOfContents(
    void
    );

LPVOID
AllocMemory(
    UINT uSize
    );

void
SetPlayButtonsEnableState(
    void
    );

void CALLBACK
HeartBeatTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    );

void CALLBACK
SkipBeatTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    );

void
UpdateDisplay(
    DWORD Flags
    );

HBRUSH
Common_OnCtlColor(
    HWND hwnd,
    HDC hdc,
    HWND hwndChild,
    int type
    );

BOOL
Common_OnMeasureItem(
    HWND hwnd,
    MEASUREITEMSTRUCT *lpMeasureItem
    );

void
DrawTrackItem(
    HDC hdc,
    const RECT *r,
    DWORD item,
    BOOL selected
    );

void
DrawDriveItem(
    HDC   hdc,
    const RECT *r,
    DWORD item,
    BOOL  selected
    );

void
CdPlayerAlreadyRunning(
    void
    );

void
CdPlayerStartUp(
    HWND hwndMain
    );

void
CompleteCdPlayerStartUp(
    void
    );

BOOL
IsPlayOptionGiven(
    LPTSTR lpCmdLine
    );

BOOL
IsUpdateOptionGiven(
    LPTSTR lpCmdLine
    );

/* -------------------------------------------------------------------------
** Public Globals - Most of these should be treated as read only.
** -------------------------------------------------------------------------
*/
#ifndef GLOBAL
#define GLOBAL extern
#endif

GLOBAL HWND             g_hwndApp;
GLOBAL HWND             g_hwndControls[NUM_OF_CONTROLS];
GLOBAL BOOL             g_fSelectedOrder;
GLOBAL BOOL             g_fSingleDisk;
GLOBAL BOOL             g_fIntroPlay;
GLOBAL BOOL             g_fContinuous;
GLOBAL BOOL             g_fRepeatSingle;
GLOBAL BOOL             g_fDisplayT;
GLOBAL BOOL             g_fDisplayTr;
GLOBAL BOOL             g_fDisplayDr;
GLOBAL BOOL             g_fDisplayD;
GLOBAL BOOL             g_fMultiDiskAvailable;
GLOBAL BOOL             g_fIsIconic;
GLOBAL BOOL             g_fSmallLedFont;
GLOBAL BOOL             g_fStopCDOnExit;
GLOBAL BOOL             g_fPlay;
GLOBAL BOOL             g_fStartedInTray;
GLOBAL BOOL             g_fBlockNetPrompt;

GLOBAL int              g_NumCdDevices;
GLOBAL int              g_LastCdrom;
GLOBAL int              g_CurrCdrom;
GLOBAL int              g_IntroPlayLength;

GLOBAL TCHAR            g_szArtistTxt[128];
GLOBAL TCHAR            g_szTitleTxt[128];
GLOBAL TCHAR            g_szUnknownTxt[128];
GLOBAL TCHAR            g_szTrackTxt[128];

GLOBAL BOOL             g_fFlashLed;

GLOBAL HBITMAP          g_hbmTrack;
GLOBAL HBITMAP          g_hbmInsertPoint;
GLOBAL HBITMAP          g_hbmEditBtns;

GLOBAL HFONT            hLEDFontS;
GLOBAL HFONT            hLEDFontL;
GLOBAL HFONT            hLEDFontB;
GLOBAL LPSTR            g_lpCmdLine;

extern BOOL             g_fTrackInfoVisible;
extern IMMFWNotifySink* g_pSink;

GLOBAL CRITICAL_SECTION g_csTOCSerialize;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\database.h ===
/******************************Module*Header*******************************\
* Module Name: databas.h
*
* This module implements the database routines for the CD Audio app.
* The information is stored in the ini file "cdaudio.ini" which should
* be located in the nt\windows directory.
*
*
* Author:
*   Rick Turner (ricktu) 31-Jan-1992
*
*
* Revision History:
*
*   04-Aug-1992 (ricktu)    Incorperated routines from old cdaudio.c,
*                           and made work w/new child window framework.
*
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

BOOL GetInternetDatabase(
    int cdrom,
    DWORD key,
    BOOL fHitNet,
    BOOL fManual,
    HWND hwndCallback,
    void* pData
);

VOID
ErasePlayList(
    int cdrom
    );

VOID
EraseSaveList(
    int cdrom
    );

VOID
EraseTrackList(
    int cdrom
    );

PTRACK_PLAY
CopyPlayList(
    PTRACK_PLAY p
    );

VOID
ResetPlayList(
    int cdrom
    );

DWORD
ComputeNewDiscId(
    int cdrom
    );

DWORD
ComputeOrgDiscId(
    int cdrom
    );

VOID
AddFindEntry(
    int cdrom,
    DWORD key,
    PCDROM_TOC lpTOC
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\dragdrop.h ===
/******************************Module*Header*******************************\
* Module Name: DragDrop.h
*
* An attempt to implement dragging and dropping between Multi-selection
* listboxes.
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifndef _INC_DRAGMULITLIST
#define _INC_DRAGMULTILIST

typedef struct {
    UINT    uNotification;
    HWND    hWnd;
    POINT   ptCursor;
    DWORD   dwState;
} DRAGMULTILISTINFO, FAR *LPDRAGMULTILISTINFO;

#define DL_BEGINDRAG    (LB_MSGMAX+100)
#define DL_DRAGGING     (LB_MSGMAX+101)
#define DL_DROPPED      (LB_MSGMAX+102)
#define DL_CANCELDRAG   (LB_MSGMAX+103)

#define DL_CURSORSET    0

#define DL_MOVE         0
#define DL_COPY         1


#define SJE_DRAGLISTMSGSTRING "sje_DragMultiListMsg"

/*---------------------------------------------------------------------
** Exported functions and variables
**---------------------------------------------------------------------
*/
UINT WINAPI
InitDragMultiList(
    void
    );

BOOL WINAPI
MakeMultiDragList(
    HWND hLB
    );

int WINAPI
LBMultiItemFromPt(
    HWND hLB,
    POINT pt,
    BOOL bAutoScroll
    );

VOID WINAPI
DrawMultiInsert(
    HWND hwndParent,
    HWND hLB,
    int nItem
    );

#endif  /* _INC_DRAGMULTILIST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\helpids.h ===
// Disc Settings dialog:
#define IDH_CD_DRIVE_NAME           4300
#define IDH_CD_GET_ARTIST           4301
#define IDH_CD_GET_TITLE            4302
#define IDH_CD_PLAY_LISTBOX         4303
#define IDH_CD_ADD                  4304
#define IDH_CD_REMOVE               4305
#define IDH_CD_CLEAR                4306
#define IDH_CD_DEFAULT              4307
#define IDH_CD_TRACK_NAME           4308
#define IDH_CD_TRACK_LISTBOX        4309
#define IDH_CD_SETNAME              4310

// Preferences dialog box           4311
#define IDH_CD_STOP_CD_ON_EXIT      4312
#define IDH_CD_SAVE_ON_EXIT         4313
#define IDH_CD_SHOW_TOOLTIPS        4314
#define IDH_CD_INTRO_LENGTH         4315
#define IDH_CD_DISPLAY_FONT         4316



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\cdplayer.cpp ===
/******************************Module*Header*******************************\
* Module Name: cdplayer.c
*
* CD Playing application
*
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 - 1995 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#include <windows.h>    /* required for all Windows applications          */
#include <shellapi.h>
#include <windowsx.h>

#include <ole2.h>
#include <shlobj.h>
#include <dbt.h>

#include "..\main\mmfw.h"
#include "..\main\resource.h"
#include "..\main\mmenu.h"
#include "..\cdopt\cdopt.h"
#include "..\cdnet\cdnet.h"

#define NOMENUHELP
#define NOBTNLIST
#define NOTRACKBAR
#define NODRAGLIST
#define NOUPDOWN
#include <commctrl.h>   /* want toolbar and status bar                    */


#include <string.h>
#include <stdio.h>
#include <tchar.h>      /* contains portable ascii/unicode macros         */
#include <stdarg.h>
#include <stdlib.h>

#define GLOBAL          /* This allocates storage for the public globals  */


#include "playres.h"
#include "cdplayer.h"
#include "ledwnd.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"
#include "database.h"
#include "commands.h"
#include "literals.h"

//#ifndef WM_CDPLAYER_COPYDATA
#define WM_CDPLAYER_COPYDATA (WM_USER+0x100)
//#endif

IMMFWNotifySink* g_pSink;
ATOM g_atomCDClass = NULL;
extern HINSTANCE g_hInst;

void GetTOC(int cdrom, TCHAR* szNetQuery);

/* -------------------------------------------------------------------------
** Private functions
** -------------------------------------------------------------------------
*/
int
CopyWord(
    TCHAR *szWord,
    TCHAR *szSource
    );

void
AppendTrackToPlayList(
    PTRACK_PLAY pHead,
    PTRACK_PLAY pInsert
    );

BOOL
IsTrackFileNameValid(
    LPTSTR lpstFileName,
    int *piCdRomIndex,
    int *piTrackIndex,
    BOOL fScanningTracks,
    BOOL fQuiet
    );

TCHAR *
ParseTrackList(
    TCHAR *szTrackList,
    int *piCdRomIndex
    );

int
ParseCommandLine(
    LPTSTR lpstr,
    int *piTrackToSeekTo,
    BOOL fQuiet
    );

void
HandlePassedCommandLine(
    LPTSTR lpCmdLine,
    BOOL   fCheckCDRom
    );

int
FindMostSuitableDrive(
    void
    );

void
AskUserToInsertCorrectDisc(
    DWORD dwID
    );

#ifndef USE_IOCTLS
BOOL CheckMCICDA (TCHAR chDrive);
#endif // ! USE_IOCTLS

BOOL
CDPlay_CopyData(
    HWND hwnd,
    PCOPYDATASTRUCT lpcpds
    );

/* -------------------------------------------------------------------------
** Private Globals
** -------------------------------------------------------------------------
*/

HBRUSH          g_hBrushBkgd;

TCHAR           g_szTimeSep[10];
int             g_AcceleratorCount;
BOOL            g_fInCopyData = FALSE;

HCURSOR         g_hcurs = NULL;

//---------------------------------------------------------------------------
// Stuff required to make drag/dropping of a shortcut file work on Chicago
//---------------------------------------------------------------------------
BOOL
ResolveLink(
    TCHAR * szFileName
    );

BOOL g_fOleInitialized = FALSE;


/*
** these values are defined by the UI gods...
*/
const int dxButton     = 24;
const int dyButton     = 22;
const int dxBitmap     = 16;
const int dyBitmap     = 16;
const int xFirstButton = 8;


/******************************Public*Routine******************************\
* WinMain
*
*
* Windows recognizes this function by name as the initial entry point
* for the program.  This function calls the application initialization
* routine, if no other instance of the program is running, and always
* calls the instance initialization routine.  It then executes a message
* retrieval and dispatch loop that is the top-level control structure
* for the remainder of execution.  The loop is terminated when a WM_QUIT
* message is received, at which time this function exits the application
* instance by returning the value passed by PostQuitMessage().
*
* If this function must abort before entering the message loop, it
* returns the conventional value NULL.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
HWND PASCAL
WinFake(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow,
    HWND hwndMain,
    IMMFWNotifySink* pSink
    )
{
    g_pSink = pSink;

    g_fBlockNetPrompt = FALSE;

    g_fSelectedOrder = TRUE;
    g_fIntroPlay = FALSE;
    g_fContinuous = FALSE;
    g_fRepeatSingle = FALSE;

#ifdef DBG
    /*
    ** This removes the Gdi batch feature.  It ensures that the screen
    ** is updated after every gdi call - very useful for debugging.
    */
    GdiSetBatchLimit(1);
#endif

    /*
    ** Save the instance handle in static variable, which will be used in
    ** many subsequence calls from this application to Windows.
    */
    g_hInst = hInstance;
    g_lpCmdLine = lpCmdLine;

    InitializeCriticalSection (&g_csTOCSerialize);

    /*
    ** Initialize the cdplayer application.
    */
    CdPlayerStartUp(hwndMain);

    return g_hwndApp;
}


/*****************************Private*Routine******************************\
* InitInstance
*
*
* This function is called at initialization time for every instance of
* this application.  This function performs initialization tasks that
* cannot be shared by multiple instances.
*
* In this case, we save the instance handle in a static variable and
* create and display the main program window.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
InitInstance(
    HANDLE hInstance,
    HWND hwndMain
    )
{
    HWND        hwnd;

    /*
    ** Load in some strings
    */

    _tcscpy( g_szArtistTxt,  IdStr( STR_HDR_ARTIST ) );
    _tcscpy( g_szTitleTxt,   IdStr( STR_HDR_TITLE ) );
    _tcscpy( g_szUnknownTxt, IdStr( STR_UNKNOWN ) );
    _tcscpy( g_szTrackTxt,   IdStr( STR_HDR_TRACK ) );

    g_szTimeSep[0] = TEXT(':');
    g_szTimeSep[1] = g_chNULL;
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_STIME, g_szTimeSep, 10 );


    /*
    ** Initialize the my classes.  We do this here because the dialog
    ** that we are about to create contains two windows on my class.
    ** The dialog would fail to be created if the classes was not registered.
    */
    g_fDisplayT = TRUE;
    InitLEDClass( g_hInst );
    Init_SJE_TextClass( g_hInst );

    WNDCLASS cls;
    cls.lpszClassName  = g_szSJE_CdPlayerClass;
    cls.hCursor        = NULL; //LoadCursor(NULL, IDC_ARROW);
    cls.hIcon          = NULL;
    cls.lpszMenuName   = NULL;
    cls.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
    cls.hInstance      = (HINSTANCE)hInstance;
    cls.style          = CS_DBLCLKS;
    cls.lpfnWndProc    = DefDlgProc;
    cls.cbClsExtra     = 0;
    cls.cbWndExtra     = DLGWINDOWEXTRA;
    if ( !RegisterClass(&cls) )
    {
	    return FALSE;
    }

    g_hcurs = LoadCursor(g_hInst,MAKEINTRESOURCE(IDC_CURSOR_HAND));

    /*
    ** Create a main window for this application instance.
    */
    hwnd = CreateDialog( g_hInst, MAKEINTRESOURCE(IDR_CDPLAYER),
			 hwndMain, MyMainWndProc );


    /*
    ** If window could not be created, return "failure"
    */
    if ( !hwnd )
    {
	    return FALSE;
    }

    g_hwndApp = hwnd;

    return TRUE;
}

/*****************************Private*Routine******************************\
* CdPlayerStartUp
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerStartUp(
    HWND hwndMain
    )
{
    /*
    ** Reseed random generator
    */
    srand( GetTickCount() );


    /*
    ** Set error mode popups for critical errors (like
    ** no disc in drive) OFF.
    */
    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );


    /*
    ** Scan device chain for CDROM devices...   Terminate if none found.
    */
    g_NumCdDevices = ScanForCdromDevices( );

    if ( g_NumCdDevices == 0 )
    {
	    LPTSTR lpstrTitle;
	    LPTSTR lpstrText;

	    lpstrTitle = (TCHAR*)AllocMemory( STR_MAX_STRING_LEN * sizeof(TCHAR) );
	    lpstrText  = (TCHAR*)AllocMemory( STR_MAX_STRING_LEN * sizeof(TCHAR) );

	    _tcscpy( lpstrText, IdStr(STR_NO_CDROMS) );
	    _tcscpy( lpstrTitle, IdStr(STR_CDPLAYER) );

	    MessageBox( NULL, lpstrText, lpstrTitle,
		        MB_APPLMODAL | MB_ICONINFORMATION |
		        MB_OK | MB_SETFOREGROUND );

	    LocalFree( (HLOCAL)lpstrText );
	    LocalFree( (HLOCAL)lpstrTitle );

	    ExitProcess( (UINT)-1 );
    }

#ifndef USE_IOCTLS
    // Make sure we have a functional MCI (CD Audio)
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    GetVersionEx(&os);
    if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
	    if (! CheckMCICDA (g_Devices[0]->drive))
	    {
	        ExitProcess( (UINT)-1 );
	    }
    }
#endif // ! USE_IOCTLS

    /*
    ** Perform initializations that apply to a specific instance
    ** This function actually creates the CdPlayer window.  (Note that it is
    ** not visible yet).  If we get here we know that there is a least one
    ** cdrom device detected which may have a music cd in it.  If it does
    ** contain a music cdrom the table of contents will have been read and
    ** cd database queryed to determine if the music cd is known.  Therefore
    ** on the WM_INITDIALOG message we should update the "Artist", "Title" and
    ** "Track" fields of the track info display and adjust the enable state
    ** of the play buttons.
    */

    if ( !InitInstance( g_hInst, hwndMain ) )
    {
    	FatalApplicationError( STR_TERMINATE );
    }


    /*
    ** Restore ourselves from the ini file
    */
    ReadSettings(NULL);

    /*
    ** Scan command the command line.  If we were given any valid commandline
    ** args we have to adjust the nCmdShow parameter.  (ie.  start minimized
    ** if the user just wants us to play a certain track.  ScanCommandLine can
    ** overide the default playlist for all the cd-rom devices installed.  It
    ** modifies the global flag g_fPlay and returns the index of the first
    ** CD-Rom that should be played.
    */
    g_CurrCdrom = g_LastCdrom = 0;
}

/*****************************Private*Routine******************************\
* CompleteCdPlayerStartUp
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
CompleteCdPlayerStartUp(
    void
    )
{
    int iTrackToSeekTo = -1;
    int i;

    g_fStartedInTray = FALSE;

    /*
    ** Scan command the command line.  If we were given any valid
    ** commandline args we have to adjust the nCmdShow parameter.  (ie.
    ** start minimized if the user just wants us to play a certain
    ** track.  ScanCommandLine can overide the default playlist for all
    ** the cd-rom devices installed.  It modifies the global flag
    ** g_fPlay and returns the index of the first CD-Rom that should be
    ** played.
    **
    */
    g_CurrCdrom = g_LastCdrom = ParseCommandLine( GetCommandLine(),
						  &iTrackToSeekTo, FALSE );
    /*
    ** If the message box prompting the user to insert the correct cd disc in
    ** the drive was displayed, ParseCommandLine will return -1, in which case
    ** find the most suitable drive, also make sure that we don't come up
    ** playing.
    */
    if (g_LastCdrom == -1)
    {
	    g_fPlay = FALSE;
	    g_CurrCdrom = g_LastCdrom = FindMostSuitableDrive();
    }

    for ( i = 0; i < g_NumCdDevices; i++) {

	TimeAdjustInitialize( i );
    }

    /*
    ** All the rescan threads are either dead or in the act of dying.
    ** It is now safe to initalize the time information for each
    ** cdrom drive.
    */
    if ( iTrackToSeekTo != -1 ) {

	PTRACK_PLAY tr;

	tr = PLAYLIST( g_CurrCdrom );
	if ( tr != NULL ) {

	    for( i = 0; i < iTrackToSeekTo; i++, tr = tr->nextplay );

	    TimeAdjustSkipToTrack( g_CurrCdrom, tr );
	}
    }


    /*
    ** if we are in random mode, then we need to shuffle the play lists.
    */

    if (!g_fSelectedOrder)
    {
	    ComputeAndUseShufflePlayLists();
    }
    SetPlayButtonsEnableState();


    /*
    ** Start the heart beat time.  This timer is responsible for:
    **  1. detecting new or ejected cdroms.
    **  2. flashing the LED display if we are in paused mode.
    **  3. Incrementing the LED display if we are in play mode.
    */
    UINT_PTR timerid = SetTimer( g_hwndApp, HEARTBEAT_TIMER_ID, HEARTBEAT_TIMER_RATE,
	      (TIMERPROC)HeartBeatTimerProc );

    if (!g_fPlay)
    {
        //"play" wasn't on the command line, but maybe the user wants it on startup anyway
        HKEY    hKey;
        LONG    lRet;

        lRet = RegOpenKey( HKEY_CURRENT_USER, g_szRegistryKey, &hKey );

        if ( (lRet == ERROR_SUCCESS) )
        {
	        DWORD   dwType, dwLen;

	        dwLen = sizeof( g_fPlay );
	        if ( ERROR_SUCCESS != RegQueryValueEx(hKey, g_szStartCDPlayingOnStart,
				            0L, &dwType, (LPBYTE)&g_fPlay,
				            &dwLen) )
            {
	            g_fPlay = FALSE; //default to not playing
	        }

            RegCloseKey(hKey);
        }
    }

    //Don't start if player was started in tray mode.
    //This prevents the user from getting an unexpected blast on boot.
    if (( g_fPlay ) && (!g_fStartedInTray))
    {
        CdPlayerPlayCmd();
    }

    if (g_CurrCdrom != 0)
    {
        //didn't use the default player, so jump to the new one
        MMONDISCCHANGED mmOnDisc;
        mmOnDisc.nNewDisc = g_CurrCdrom;
        mmOnDisc.fDisplayVolChange = FALSE;
        g_pSink->OnEvent(MMEVENT_ONDISCCHANGED,&mmOnDisc);
    }

    if (g_Devices[g_CurrCdrom]->State & CD_LOADED)
    {
        //need to set track button on main ui
        HWND hwndTrackButton = GetDlgItem(GetParent(g_hwndApp),IDB_TRACK);
        if (hwndTrackButton)
        {
            EnableWindow(hwndTrackButton,TRUE);
        }
    }

	//cd was already playing; let's update the main ui
	if (g_Devices[g_CurrCdrom]->State & CD_PLAYING)
	{
        g_pSink->OnEvent(MMEVENT_ONPLAY,NULL);
	}
}

/******************************Public*Routine******************************\
* MyMainWndProc
*
* Use the message crackers to dispatch the dialog messages to appropirate
* message handlers.  The message crackers are portable between 16 and 32
* bit versions of Windows.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
INT_PTR CALLBACK
MyMainWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch ( message ) {

    HANDLE_MSG( hwnd, WM_INITDIALOG,        CDPlay_OnInitDialog );
    HANDLE_MSG( hwnd, WM_DRAWITEM,          CDPlay_OnDrawItem );
    HANDLE_MSG( hwnd, WM_COMMAND,           CDPlay_OnCommand );
    HANDLE_MSG( hwnd, WM_DESTROY,           CDPlay_OnDestroy );
    HANDLE_MSG( hwnd, WM_SIZE,              CDPlay_OnSize );
    HANDLE_MSG( hwnd, WM_ENDSESSION,        CDPlay_OnEndSession );
    HANDLE_MSG( hwnd, WM_WININICHANGE,      CDPlay_OnWinIniChange );
    HANDLE_MSG( hwnd, WM_CTLCOLORSTATIC,    Common_OnCtlColor );
    HANDLE_MSG( hwnd, WM_CTLCOLORDLG,       Common_OnCtlColor );
    HANDLE_MSG( hwnd, WM_MEASUREITEM,       Common_OnMeasureItem );
    HANDLE_MSG( hwnd, WM_NOTIFY,            CDPlay_OnNotify );

    HANDLE_MSG( hwnd, WM_DROPFILES,         CDPlay_OnDropFiles );

    case WM_DEVICECHANGE:
	return CDPlay_OnDeviceChange (hwnd, wParam, lParam);

    case WM_SETFOCUS :
    {
        //move focus to next window in tab order
        HWND hwndNext = GetNextDlgTabItem(GetParent(hwnd),hwnd,FALSE);

        //if the next window just lost focus, we need to go the other way
        if (hwndNext == (HWND)wParam)
        {
            hwndNext = GetNextDlgTabItem(GetParent(hwnd),hwnd,TRUE);
        }

        SetFocus(hwndNext);

        return 0;
    }
    break;

	case WM_ERASEBKGND:
	return 1;

    case WM_CLOSE:
	return CDPlay_OnClose(hwnd, FALSE);

    case WM_COPYDATA:
	    return CDPlay_CopyData( hwnd,  (PCOPYDATASTRUCT)lParam );

    case WM_CDPLAYER_COPYDATA:
	    return CDPlay_OnCopyData( hwnd,  (PCOPYDATASTRUCT)lParam );

    case WM_NOTIFY_TOC_READ:
	return CDPlay_OnTocRead( (int)wParam );

    case WM_NOTIFY_FIRST_SCAN:
    {
        for ( int i = 0; i < g_NumCdDevices; i++ )
        {
	        RescanDevice( hwnd, i );
        }

        return TRUE;
    }
    break;

    default:
	return FALSE;
    }
}


/*****************************Private*Routine******************************\
* CDPlay_OnInitDialog
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnInitDialog(
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lParam
    )
{
    int     i;

    g_hBrushBkgd = CreateSolidBrush( GetSysColor(COLOR_BTNFACE) );

    EnumChildWindows( hwnd, ChildEnumProc, (LPARAM)hwnd );

    DragAcceptFiles( hwnd, TRUE );

    /*
    ** Initialize and read the TOC for all the detected CD-ROMS
    */
    SetPlayButtonsEnableState();

    for ( i = 0; i < g_NumCdDevices; i++ )
    {
	    ASSERT(g_Devices[i]->State == CD_BEING_SCANNED);
	    ASSERT(g_Devices[i]->hCd == 0L);

	    TimeAdjustInitialize( i );

	    g_Devices[i]->State = CD_NO_CD;
    }

    PostMessage(hwnd,WM_NOTIFY_FIRST_SCAN,0,0);

    return FALSE;
}


/*****************************Private*Routine******************************\
* CDPlay_OnWinIniChange
*
* Updates the time format separator and the LED display
*
* History:
* 29-09-94 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnWinIniChange(
    HWND hwnd,
    LPCTSTR lpszSectionName
    )
{
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_STIME, g_szTimeSep, 10 );
    UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_DISC_TIME | DISPLAY_UPD_TRACK_TIME );
}


/*****************************Private*Routine******************************\
* CDPlay_OnDrawItem
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnDrawItem(
    HWND hwnd,
    const DRAWITEMSTRUCT *lpdis
    )
{
    if (lpdis->CtlType == ODT_MENU)
    {
        return FALSE;
    }

    int         i;

    i = INDEX(lpdis->CtlID);

    switch (lpdis->CtlType) {

    case ODT_BUTTON:

	/*
	** See if the fast foreward or backward buttons has been pressed or
	** released.  If so execute the seek command here.  Do nothing on
	** the WM_COMMAND message.
	*/
	if ( lpdis->CtlID == IDM_PLAYBAR_SKIPBACK
	  || lpdis->CtlID == IDM_PLAYBAR_SKIPFORE ) {

	    if (lpdis->itemAction & ODA_SELECT ) {

		g_AcceleratorCount = 0;
		CdPlayerSeekCmd( hwnd, (lpdis->itemState & ODS_SELECTED),
				 lpdis->CtlID );
	    }
	}

	/*
	** Now draw the button according to the buttons state information.
	*/

/*
    case ODT_COMBOBOX:
	if (lpdis->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) {

	    switch (lpdis->CtlID) {

	    case IDC_ARTIST_NAME:
		DrawDriveItem( lpdis->hDC, &lpdis->rcItem,
			       lpdis->itemData,
			       (ODS_SELECTED & lpdis->itemState) );
		break;

	    }
	}
*/

	return TRUE;
    }
    return FALSE;
}


/*****************************Private*Routine******************************\
* CDPlay_OnCommand
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    )
{
    switch( id )
    {
	    case IDM_NET_CD:
	    {
            MMNET* pNet = (MMNET*)hwndCtl;
            if (pNet->discid==0)
            {
                //if disc id is 0, then we want to manually get the info for the current cd
                GetInternetDatabase(g_CurrCdrom,g_Devices[g_CurrCdrom]->CdInfo.Id,TRUE,TRUE,pNet->hwndCallback,NULL);
            }
            else if ((pNet->discid==-1) || (pNet->fForceNet))
            {
                //if disc id is -1, then we want to get just the batches
                int cdrom = g_CurrCdrom;

                if (pNet->fForceNet)
                {
                    //try to find the correct cdrom for this guy
                    for(int i = 0; i < g_NumCdDevices; i++)
                    {
                        if (pNet->discid == g_Devices[i]->CdInfo.Id)
                        {
                            //if the id was found in the player, physically rescan it
                            pNet->pData2 = NULL;
                            cdrom = i;
                            break;
                        }
                    } //end for
                } //end if force net

                GetInternetDatabase(cdrom,pNet->fForceNet ? pNet->discid : 0,TRUE,TRUE,pNet->hwndCallback,pNet->pData2);
            }
            else
            {
                for(int i = 0; i < g_NumCdDevices; i++)
                {
                    if (pNet->discid == g_Devices[i]->CdInfo.Id)
                    {
                        //don't hit the net, just scan the entry
                        GetInternetDatabase(i,g_Devices[i]->CdInfo.Id,FALSE,TRUE,pNet->hwndCallback,pNet->pData);
                        UpdateDisplay(DISPLAY_UPD_TITLE_NAME|DISPLAY_UPD_LED);
                    }
                } //end for
            }

	    }
	    break;

        case IDM_OPTIONS_NORMAL :
        {
            //turn randomness off if it is on
            if (!g_fSelectedOrder)
            {
	            if ( LockALLTableOfContents() )
                {
	                FlipBetweenShuffleAndOrder();
                }
            }
	        g_fRepeatSingle = FALSE;
            g_fIntroPlay = FALSE;
            g_fSelectedOrder = TRUE;
            g_fContinuous = FALSE;
        }
        break;

        case IDM_OPTIONS_RANDOM:
	        if ( LockALLTableOfContents() )
            {
	            g_fSelectedOrder = FALSE;
                ComputeAndUseShufflePlayLists();
                g_fIntroPlay = FALSE;
	            g_fContinuous = TRUE;
                g_fRepeatSingle = FALSE;
	        }
	    break;

        //case IDM_OPTIONS_MULTI:
	    //g_fSingleDisk = !g_fSingleDisk;
	    //break;

        case IDM_OPTIONS_REPEAT_SINGLE :
        {
            //turn randomness off if it is on
            if (!g_fSelectedOrder)
            {
	            if ( LockALLTableOfContents() )
                {
	                FlipBetweenShuffleAndOrder();
                }
            }
	        g_fRepeatSingle = TRUE;
            g_fIntroPlay = FALSE;
            g_fSelectedOrder = TRUE;
            g_fContinuous = FALSE;
        }
        break;

        case IDM_OPTIONS_INTRO:
            //turn randomness off if it is on
            if (!g_fSelectedOrder)
            {
	            if ( LockALLTableOfContents() )
                {
	                FlipBetweenShuffleAndOrder();
                }
            }
	        g_fIntroPlay = TRUE;
            g_fSelectedOrder = TRUE;
	        g_fContinuous = FALSE;
            g_fRepeatSingle = FALSE;
	    break;

        case IDM_OPTIONS_CONTINUOUS:
            //turn randomness off if it is on
            if (!g_fSelectedOrder)
            {
	            if ( LockALLTableOfContents() )
                {
	                FlipBetweenShuffleAndOrder();
                }
            }
	        g_fContinuous = TRUE;
            g_fIntroPlay = FALSE;
            g_fSelectedOrder = TRUE;
            g_fRepeatSingle = FALSE;
	    break;

        case IDM_TIME_REMAINING:
	        g_fDisplayT  = TRUE;
	        g_fDisplayD = g_fDisplayTr = g_fDisplayDr = FALSE;
	        UpdateDisplay( DISPLAY_UPD_LED );
	    break;

        case IDM_TRACK_REMAINING:
	        g_fDisplayTr = TRUE;
	        g_fDisplayD = g_fDisplayDr = g_fDisplayT = FALSE;
	        UpdateDisplay( DISPLAY_UPD_LED );
	    break;

        case IDM_DISC_REMAINING:
	        g_fDisplayDr = TRUE;
	        g_fDisplayD = g_fDisplayTr = g_fDisplayT = FALSE;
    	    UpdateDisplay( DISPLAY_UPD_LED );
	    break;

        case IDM_PLAYBAR_EJECT:
	        CdPlayerEjectCmd();
	    break;

        case IDM_PLAYBAR_PLAY:
	    /*
	    ** If we currently in PLAY mode and the command came from
	    ** a keyboard accelerator then assume that the user really
	    ** means Pause.  This is because the Ctrl-P key sequence
	    ** is a toggle between Play and Paused.  codeNotify is 1 when
	    ** the WM_COMMAND message came from an accelerator and 0 when
	    ** it cam from a menu.
	    */
	    if ((g_State & CD_PLAYING) && (codeNotify == 1))
        {
	        CdPlayerPauseCmd();
	    }
	    else
        {
	        CdPlayerPlayCmd();
	    }
	    break;

        case IDM_PLAYBAR_PAUSE:
	        CdPlayerPauseCmd();
	    break;

        case IDM_PLAYBAR_STOP:
	        CdPlayerStopCmd();
	    break;

        case IDM_PLAYBAR_PREVTRACK:
	    CdPlayerPrevTrackCmd();
	    break;

        case IDM_PLAYBAR_NEXTTRACK:
	    CdPlayerNextTrackCmd();
	    break;

        case IDM_DATABASE_EXIT:
	    PostMessage( hwnd, WM_CLOSE, 0, 0L );
	    break;
    }
}


/******************************Public*Routine******************************\
* CDPlay_OnDestroy
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnDestroy(
    HWND hwnd
    )
{
    int     i;

    for ( i = 0; i < g_NumCdDevices; i++ ) {

	if (g_fStopCDOnExit) {

	    if ( g_Devices[i]->State & CD_PLAYING
	      || g_Devices[i]->State & CD_PAUSED ) {

		  StopTheCdromDrive( i );
	    }
	}

#ifdef USE_IOCTLS
	if ( g_Devices[i]->hCd != NULL ) {
	    CloseHandle( g_Devices[i]->hCd );
	}
#else
	if ( g_Devices[i]->hCd != 0L ) {

	    CloseCdRom( g_Devices[i]->hCd );
	    g_Devices[i]->hCd = 0L;
	}
#endif


    ErasePlayList(i);
    EraseSaveList(i);
    EraseTrackList(i);

	LocalFree( (HLOCAL) g_Devices[i] );

    }

    if (g_hBrushBkgd) {
	DeleteObject( g_hBrushBkgd );
    }

    WinHelp( hwnd, g_HelpFileName, HELP_QUIT, 0 );

    PostQuitMessage( 0 );
}


/******************************Public*Routine******************************\
* CDPlay_OnClose
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnClose(
    HWND hwnd,
    BOOL fShuttingDown
    )
{
    /*
    ** If we are playing or paused and the "don't stop playing
    ** on exit" flag set, then we need to tell the user that he is about
    ** to go into stupid mode.  Basically CD Player can only perform as expected
    ** if the user has not mucked about with the play list, hasn't put the
    ** app into random mode or intro play mode or continuous play mode or
    ** multi-disc mode.
    */
    if ( !fShuttingDown && !g_fStopCDOnExit
      && (g_State & (CD_PLAYING | CD_PAUSED) ) ) {

	if ( !g_fSelectedOrder || g_fIntroPlay || g_fContinuous
	  || !g_fSingleDisk || !PlayListMatchesAvailList() ) {

	    TCHAR   s1[256];
	    TCHAR   s2[256];
	    int     iMsgBoxRtn;

	    _tcscpy( s1, IdStr( STR_EXIT_MESSAGE ) );
	    _tcscpy( s2, IdStr( STR_CDPLAYER ) );

	    iMsgBoxRtn = MessageBox( g_hwndApp, s1, s2,
				     MB_APPLMODAL | MB_DEFBUTTON1 |
				     MB_ICONQUESTION | MB_YESNO);

	    if ( iMsgBoxRtn == IDNO ) {
		return TRUE;
	    }

	}
    }

    //WriteSettings();

    return DestroyWindow( hwnd );
}


/*****************************Private*Routine******************************\
* CDPlay_OnEndSession
*
* If the session is really ending make sure that we stop the CD Player
* from playing and that all the ini file stuff is saved away.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnEndSession(
    HWND hwnd,
    BOOL fEnding
    )
{
    if ( fEnding ) {
	CDPlay_OnClose( hwnd, fEnding );
    }
}


/******************************Public*Routine******************************\
* CDPlay_OnSize
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnSize(
    HWND hwnd,
    UINT state,
    int cx,
    int cy
    )
{
    if (g_fIsIconic && (state != SIZE_MINIMIZED)) {
	SetWindowText( hwnd, IdStr( STR_CDPLAYER ) );
    }
    g_fIsIconic = (state == SIZE_MINIMIZED);

    SetWindowPos(GetDlgItem(g_hwndApp,IDC_LED),
	hwnd,
	0,
	0,
	cx,
	cy,
	SWP_NOACTIVATE);
}

/*
* NormalizeNameForMenuDisplay
    This function turns a string like "Twist & Shout" into
    "Twist && Shout" because otherwise it will look like
    "Twist _Shout" in the menu due to the accelerator char
*/
extern "C" void NormalizeNameForMenuDisplay(TCHAR* szInput, TCHAR* szOutput, DWORD cbLen)
{
    ZeroMemory(szOutput,cbLen);
    WORD index1 = 0;
    WORD index2 = 0;
    for (; index1 < _tcslen(szInput); index1++)
    {
        szOutput[index2] = szInput[index1];
        if (szOutput[index2] == TEXT('&'))
        {
            szOutput[++index2] = TEXT('&');
        }
        index2++;
    }
}

/*****************************Private*Routine******************************\
* CDPlay_OnNotify
*
* Time to display the little tool tips.  Also, change the status bar
* so that it displays a longer version of the tool tip text.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT
CDPlay_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR *pnmhdr
    )
{
    return TRUE;
}

BOOL
CDPlay_CopyData(
    HWND hwnd,
    PCOPYDATASTRUCT lpcpds
    )
{
    LPTSTR lpCmdLine;

    // Make a copy of the passed command line as we are not supposed
    // to write into the one passed in the WM_COPYDATA message.
    lpCmdLine = (TCHAR*)AllocMemory( lpcpds->cbData );
    _tcscpy( lpCmdLine, (LPCTSTR)lpcpds->lpData );

    PostMessage (hwnd, WM_CDPLAYER_COPYDATA, 0, (LPARAM)(LPVOID)lpCmdLine);
    return TRUE;
} // End CopyData



/*****************************Private*Routine******************************\
* CDPlay_OnCopyData
*
* Handles command lines passed from other intances of CD Player
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnCopyData(
    HWND hwnd,
    PCOPYDATASTRUCT lpcpds
    )
{
    LPTSTR lpCmdLine;
    BOOL fWasPlaying = FALSE;
    BOOL fUpdate;
    int iTrack = -1;
    int iCdRom;

    // Prevent Re-entrancy while
    // we are opening/closing CD's
    if (g_fInCopyData)
	return FALSE;
    g_fInCopyData = TRUE;

    /*
    ** Make a copy of the passed command line as we are not supposed
    ** to write into the one passed in the WM_COPYDATA message.
    */
    //lpCmdLine = AllocMemory( lpcpds->cbData );
    //_tcscpy( lpCmdLine, (LPCTSTR)lpcpds->lpData );

    lpCmdLine = (LPTSTR)(LPVOID)lpcpds;
    if (lpCmdLine == NULL)
    {
	g_fInCopyData = FALSE;
	return 0L;
    }


    iCdRom = ParseCommandLine( lpCmdLine, &iTrack, FALSE );
    if (iCdRom < 0 && iTrack < 0) {
	LocalFree( (HLOCAL)lpCmdLine );
	g_fInCopyData = FALSE;
	    return 0L;
    }

    // Check if it is just an update command?!?
    fUpdate = IsUpdateOptionGiven (lpCmdLine);
    if ((fUpdate) && (iTrack == -1))
    {
	if ((iCdRom >= 0) && (iCdRom < g_NumCdDevices))
	{
		CheckUnitCdrom(iCdRom, TRUE);
	}

	LocalFree( (HLOCAL)lpCmdLine );
	g_fInCopyData = FALSE;
	    return 0L;
    }

    /*
    ** Remember our current playing state as we need to temporarly
    ** stop the CD if it is currently playing.
    */
    if ( g_State & (CD_PLAYING | CD_PAUSED) )
    {

#ifdef DBG
	dprintf(TEXT("Auto Stopping"));
#endif

	    while( !LockALLTableOfContents() )
	{

		MSG msg;

#if DBG
		dprintf(TEXT("Busy waiting for TOC to become valid!"));
#endif

		GetMessage( &msg, NULL, WM_NOTIFY_TOC_READ, WM_NOTIFY_TOC_READ );
		DispatchMessage( &msg );
	    }

	    CdPlayerStopCmd();
	    fWasPlaying = TRUE;
    }


    /*
    ** Figure what has been passed and act on it accordingly.
    */
    HandlePassedCommandLine( lpCmdLine, FALSE );


    /*
    ** If we were playing make sure that we are still playing the
    ** new track(s)
    */
    if ( fWasPlaying || g_fPlay )
    {

#ifdef DBG
	    dprintf(TEXT("Trying to autoplay"));
#endif

	    while( !LockTableOfContents(g_CurrCdrom) )
	{

		MSG     msg;

#ifdef DBG
	    dprintf(TEXT("Busy waiting for TOC to become valid!"));
#endif

		GetMessage( &msg, NULL, WM_NOTIFY_TOC_READ, WM_NOTIFY_TOC_READ );
		DispatchMessage( &msg );
	    }

	    CdPlayerPlayCmd();
    }

    /*
    ** Free the local copy of the command line.
    */
    LocalFree( (HLOCAL)lpCmdLine );

    g_fInCopyData = FALSE;
    return 0L;
}


/*****************************Private*Routine******************************\
* CDPlay_OnTocRead
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnTocRead(
    int iDriveRead
    )
{
    static int iNumRead = 0;

    //  This serializes processing between this
    //  function and the various Table of Content Threads
    //  Preventing resource contention on CDROM Multi-Changers.
    EnterCriticalSection (&g_csTOCSerialize);

    /*
    ** Have we finished the initial read of the CD-Rom TOCs ?
    ** If so we have to re-open the device.  We only need to do this
    ** on Daytona because MCI device handles are not shared between threads.
    */
    iNumRead++;

#ifndef USE_IOCTLS
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    GetVersionEx(&os);
    if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
	if (iNumRead <= g_NumCdDevices) {

	    /*
	    ** Now, open the cdrom device on the UI thread.
	    */
	    g_Devices[iDriveRead]->hCd =
		OpenCdRom( g_Devices[iDriveRead]->drive, NULL );
	}
    }
#endif


    /*
    ** This means that one of the threads dedicated to reading the
    ** toc has finished.  iDriveRead contains the relevant cdrom id.
    */
    LockALLTableOfContents();

    if ( g_Devices[iDriveRead]->State & CD_LOADED )
    {
	    /*
	    ** We have a CD loaded, so generate unique ID
	    ** based on TOC information.
	    */
	    g_Devices[iDriveRead]->CdInfo.Id = ComputeNewDiscId( iDriveRead );

	    /*
	    ** Check database for this compact disc
	    */
	    AddFindEntry( iDriveRead, g_Devices[iDriveRead]->CdInfo.Id,
		          &(g_Devices[iDriveRead]->toc) );

        //plop this into the punit table
        //try to find the drive in the unit table
        if (g_pSink)
        {
            LPCDOPT pOpt = (LPCDOPT)g_pSink->GetOptions();
            LPCDOPTIONS pCDOpts = NULL;
            LPCDUNIT pUnit = NULL;

            if (pOpt)
            {
                pCDOpts = pOpt->GetCDOpts();
            }

            if (pCDOpts)
            {
                pUnit = pCDOpts->pCDUnitList;
            }

            //scan the list to find the one we want
            for (int index = 0; index < iDriveRead; index++)
            {
                if (pUnit)
                {
                    pUnit = pUnit->pNext;
                }
            }

            if (pUnit)
            {
                pUnit->dwTitleID = g_Devices[iDriveRead]->CdInfo.Id;
                pUnit->dwNumTracks = g_Devices[iDriveRead]->CdInfo.NumTracks;
                GetTOC(iDriveRead,pUnit->szNetQuery);
                pOpt->DiscChanged(pUnit);
            }
        } //end if gpsink
    }

    /*
    ** If we have completed the initialization of the Cd-Rom drives we can
    ** now complete the startup processing of the application.
    */
    if (iNumRead == g_NumCdDevices)
    {
    	CompleteCdPlayerStartUp();
    }
    else {

	/*
	** if we are in random mode, then we need to shuffle the play lists.
	** but only if we can lock all the cd devices.
	*/

	TimeAdjustInitialize( iDriveRead );

	if ( g_fSelectedOrder == FALSE ) {
	    if ( LockALLTableOfContents() ) {
		ComputeAndUseShufflePlayLists();
	    }
	}

	ComputeDriveComboBox();

	if (iDriveRead == g_CurrCdrom)
    {
	    if (g_fPlay)
        {
            CdPlayerPlayCmd();
        }
	    SetPlayButtonsEnableState();
	}

    }

    LeaveCriticalSection (&g_csTOCSerialize);

    return TRUE;
}


/*****************************Private*Routine******************************\
* CDPlay_OnDeviceChange
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/

BOOL
CDPlay_OnDeviceChange(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT  uiEvent = (UINT)wParam;
    DWORD_PTR dwData  = (DWORD_PTR)lParam;

    switch (uiEvent)
    {
    case DBT_DEVICEARRIVAL:             // Insertion
    case DBT_DEVICEREMOVECOMPLETE:      // Ejection
	if ((PDEV_BROADCAST_HDR)dwData)
	{
	    switch (((PDEV_BROADCAST_HDR)dwData)->dbch_devicetype)
	    {
	    case DBT_DEVTYP_VOLUME:
		{
		TCHAR chDrive[4] = TEXT("A:\\");
		INT   i,j,drive;
		DWORD dwCurr;
		PDEV_BROADCAST_VOLUME pdbv;
		DWORD dwMask, dwDrives;

		pdbv = (PDEV_BROADCAST_VOLUME)dwData;
		dwMask = pdbv->dbcv_unitmask;
		dwDrives = GetLogicalDrives();
		dwMask &= dwDrives;

		if (dwMask)
		{
			// Check all drives for match
		    for (i = 0; i < 32; i++)
		    {
			dwCurr = 1 << i;
			if (dwCurr & dwMask)
			{
				// Check drive
			    chDrive[0] = TEXT('A') + i;
			    if ( GetDriveType(chDrive) == DRIVE_CDROM )
			    {
				    // Find Associated Drive structure
				drive = -1;
				for (j = 0; j < g_NumCdDevices; j++)
				{
				    if (g_Devices[j]->drive == chDrive[0])
					drive = j;
				}
				    // Structure not found, make one
				if (drive == -1)
				{
			    #ifdef DBG
				    dprintf (TEXT("CDPlay_OnDeviceChange - didn't find drive"));
			    #endif
				    if (g_NumCdDevices > MAX_CD_DEVICES)
				    {
					// Error - not enough device slots
					break;
				    }
				
				    g_Devices[g_NumCdDevices] = (CDROM*)AllocMemory( sizeof(CDROM) );
				    if (NULL == g_Devices[g_NumCdDevices])
				    {
					// Error - unable to get enough memory
					break;
				    }
				    g_Devices[g_NumCdDevices]->drive = chDrive[0];
				    drive = g_NumCdDevices;
				    g_NumCdDevices++;
				}

				    // Insert/Eject new drive
				if (uiEvent == DBT_DEVICEARRIVAL)
                {
				    // Drive has been inserted
				    // The Shell should inform us using
				    // the AUTOPLAY through WM_COPYDDATA

                    //This is only necessary to detect discs with
                    //more than just redbook audio on them ...
                    //to prevent a double-scan of any discs that
                    //are normal audio, we need to block the "get it now"
                    //net prompt when scanning this way
                    g_fBlockNetPrompt = TRUE;
                    CheckUnitCdrom(drive,TRUE);
                    g_fBlockNetPrompt = FALSE;

		            return FALSE;
				}
				else
                {
				    NoMediaUpdate (drive);
				}
			    }
		
			}
		    }
		}
		break;
		}

	    default:
		// Not a logical volume message
		break;
	    }
	}
	break;

    case DBT_DEVICEQUERYREMOVE:         // Permission to remove a device is requested.
    case DBT_DEVICEQUERYREMOVEFAILED:   // Request to remove a device has been canceled.
    case DBT_DEVICEREMOVEPENDING:       // Device is about to be removed. Can not be denied.
    case DBT_DEVICETYPESPECIFIC:        // Device-specific event.
    case DBT_CONFIGCHANGED:             // Current configuration has changed.
    default:
	break;
    }

    return TRUE;
} // End CDPlay_OnDeviceChange



/*****************************Private*Routine******************************\
* CDPlay_OnDropFiles
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnDropFiles(
    HWND hwnd,
    HDROP hdrop
    )
{
    int     cFiles;
    int     cGoodFiles;
    int     iTextLen;
    int     i;
    TCHAR   szFileName[MAX_PATH+3];
    LPTSTR  lpCommandLine;
    BOOL    fWasPlaying = FALSE;

    // Prevent Re-entrancy while we are
    // Opening and closing CD's
    if (g_fInCopyData)
	return;
    g_fInCopyData = TRUE;


    /*
    ** Determine how many files were passed to us.
    */
    cFiles = DragQueryFile( hdrop, (UINT)-1, (LPTSTR)NULL, 0 );

    /*
    ** Calculate the length of the command line each filename should be
    ** separated by a space character
    */
    iTextLen  = _tcslen( g_szCdplayer );
    iTextLen += _tcslen( g_szPlayOption );
    iTextLen += _tcslen( g_szTrackOption );
    for ( cGoodFiles = cFiles, i = 0; i < cFiles; i++ ) {

	int unused1, unused2;

	DragQueryFile( hdrop, i, szFileName, MAX_PATH );


	if (IsTrackFileNameValid( szFileName, &unused1,
				  &unused2, TRUE, FALSE )) {

	    // Add on 3 extra characters - one for the space and
	    // two for quote marks, we do this because the filename
	    // given may contain space characters.
	    iTextLen += _tcslen( szFileName ) + 2 + 1;
	}
	else {
	    cGoodFiles--;
	}
    }

    /*
    ** If the none of the dropped files are valid tracks just return
    */
    if (cGoodFiles < 1) {
	g_fInCopyData = FALSE;
	    return;
    }


    /*
    ** Allocate a chunk of memory big enough for all the options and
    ** filenames.  Don't forget the NULL.
    */
    lpCommandLine = (TCHAR*)AllocMemory(sizeof(TCHAR) * (iTextLen + 1));


    /*
    ** Add a dummy intial command line arg.  This is because the
    ** first arg is always the name of the invoked application.  We ignore
    ** this paramter.  Also if we are currently playing we need to
    ** add the -play option to command line as well as stop the CD.
    */
    _tcscpy( lpCommandLine, g_szCdplayer );
    if ( g_State & (CD_PLAYING | CD_PAUSED) ) {

	CdPlayerStopCmd();
	fWasPlaying = TRUE;

	_tcscat( lpCommandLine, g_szPlayOption );
    }


    /*
    ** If there is more than one file name specified then we should constuct
    ** a new playlist from the given files.
    */
    if ( cGoodFiles > 1) {
	_tcscat( lpCommandLine, g_szTrackOption );
    }


    /*
    ** Build up the command line.
    */
    for ( i = 0; i < cFiles; i++ ) {

	int unused1, unused2;

	DragQueryFile( hdrop, i, szFileName, MAX_PATH );

	if (IsTrackFileNameValid( szFileName, &unused1,
				  &unused2, TRUE, TRUE )) {

	    _tcscat( lpCommandLine, TEXT("\'") );
	    _tcscat( lpCommandLine, szFileName );
	    _tcscat( lpCommandLine, TEXT("\'") );
	    _tcscat( lpCommandLine, g_szBlank );
	}
    }


    /*
    ** now process the newly constructed command line.
    */
    HandlePassedCommandLine( lpCommandLine, FALSE );


    /*
    ** If we were playing make sure that we are still playing the
    ** new track(s)
    */
    if ( fWasPlaying ) {

	CdPlayerPlayCmd();
    }

    LocalFree( lpCommandLine );
    DragFinish( hdrop );

    g_fInCopyData = FALSE;
}


/*****************************Private*Routine******************************\
* ResolveLink
*
* Takes the shortcut (shell link) file pointed to be szFileName and
* resolves the link returning the linked file name in szFileName.
*
* szFileName must point to at least MAX_PATH amount of TCHARS.  The function
* return TRUE if the link was successfully resolved and FALSE otherwise.
*
* History:
* dd-mm-94 - StephenE - Created
* 03-11-95 - ShawnB - Unicode enabled
*
\**************************************************************************/
BOOL
ResolveLink(
    TCHAR *szFileName
    )
{
    return FALSE;
}
//#endif


/******************************Public*Routine******************************\
* FatalApplicationError
*
* Call this function if something "bad" happens to the application.  It
* displays an error message and then kills itself.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
FatalApplicationError(
    INT uIdStringResource,
    ...
    )
{
    va_list va;
    TCHAR   chBuffer1[ STR_MAX_STRING_LEN ];
    TCHAR   chBuffer2[ STR_MAX_STRING_LEN ];

    /*
    ** Load the relevant messages
    */
    va_start(va, uIdStringResource);
    wvsprintf(chBuffer1, IdStr(uIdStringResource), va);
    va_end(va);

    _tcscpy( chBuffer2, IdStr(STR_FATAL_ERROR) ); /*"CD Player: Fatal Error"*/

    /*
    ** How much of the application do we need to kill
    */

    if (g_hwndApp) {

	if ( IsWindowVisible(g_hwndApp) ) {
	    BringWindowToTop(g_hwndApp);
	}

	MessageBox( g_hwndApp, chBuffer1, chBuffer2,
		    MB_ICONSTOP | MB_OK | MB_APPLMODAL | MB_SETFOREGROUND );

	DestroyWindow( g_hwndApp );

    }
    else {

	MessageBox( NULL, chBuffer1, chBuffer2,
		    MB_APPLMODAL | MB_ICONSTOP | MB_OK | MB_SETFOREGROUND );
    }

    ExitProcess( (UINT)-1 );

}


/******************************Public*Routine******************************\
* IdStr
*
* Loads the given string resource ID into the passed storage.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LPTSTR
IdStr(
    int idResource
    )
{
    static TCHAR    chBuffer[ STR_MAX_STRING_LEN ];

    if (LoadString(g_hInst, idResource, chBuffer, STR_MAX_STRING_LEN) == 0)
    {
	    return TEXT("");
    }

    return chBuffer;

}


/******************************Public*Routine******************************\
* CheckMenuItemIfTrue
*
* If "flag" TRUE the given menu item is checked, otherwise it is unchecked.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckMenuItemIfTrue(
    HMENU hMenu,
    UINT idItem,
    BOOL flag
    )
{
    UINT uFlags;

    if (flag) {
	uFlags = MF_CHECKED | MF_BYCOMMAND;
    }
    else {
	uFlags = MF_UNCHECKED | MF_BYCOMMAND;
    }

    CheckMenuItem( hMenu, idItem, uFlags );
}


/******************************Public*Routine******************************\
* ReadSettings
*
* Read app settings from ini file.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ReadSettings(
    void* pData
    )
{
    LPCDOPT pOpt = NULL;
    LPCDOPTDATA pOptionData = (LPCDOPTDATA)pData;

    //if no option data, get some!
    if (pOptionData == NULL)
    {
        pOpt = (LPCDOPT)g_pSink->GetOptions();
        if( pOpt )
        {
            LPCDOPTIONS pOptions = pOpt->GetCDOpts();
            pOptionData = pOptions->pCDData;
        }
    }

    //if we still don't have it, bail out!
    if (pOptionData == NULL)
    {
        return;
    }

	g_fStopCDOnExit = pOptionData->fExitStop;

    //if being called because of user dialog setting, reset the play mode flag
    if (pData != NULL)
    {
        g_fPlay = pOptionData->fStartPlay;
    }

	if ( g_NumCdDevices < 2 )
    {
	    g_fMultiDiskAvailable = FALSE;
	    g_fSingleDisk = TRUE;
	}
	else {
	    g_fMultiDiskAvailable = TRUE;
        g_fSingleDisk = FALSE;
	}

    g_fDisplayD = FALSE;
    g_fDisplayDr = FALSE;
    g_fDisplayT = FALSE;
    g_fDisplayTr = FALSE;

    switch (pOptionData->fDispMode)
    {
        case CDDISP_CDTIME :
        {
            g_fDisplayD = TRUE;
        }
        break;

        case CDDISP_CDREMAIN :
        {
            g_fDisplayDr = TRUE;
        }
        break;

        case CDDISP_TRACKTIME :
        {
            g_fDisplayT = TRUE;
        }
        break;

        case CDDISP_TRACKREMAIN :
        {
            g_fDisplayTr = TRUE;
        }
        break;
    }

    g_IntroPlayLength = pOptionData->dwIntroTime;

    //set into correct mode
    g_fSelectedOrder = (pOptionData->dwPlayMode != IDM_MODE_RANDOM);

    //if not selected order (i.e. we're in random mode) then also make it continuous.
    if (!g_fSelectedOrder)
    {
        g_fContinuous = TRUE;
    }

	/*
	** Make sure that the LED display format is correct
	*/
	if ( g_fDisplayT == FALSE && g_fDisplayTr == FALSE
	  && g_fDisplayDr == FALSE && g_fDisplayD == FALSE)
    {
        g_fDisplayT = TRUE;
    }
}

/******************************Public*Routine******************************\
* LockTableOfContents
*
* This function is used to determine if it is valid for the UI thread
* to access the table of contents for the specified CD Rom.  If this
* function returns FALSE the UI thread should NOT touch the table of
* contents for this CD Rom.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
LockTableOfContents(
    int cdrom
    )
{
    DWORD   dwRet;

    if (g_Devices[cdrom]->fIsTocValid) {
	return TRUE;
    }

    if (g_Devices[cdrom]->hThreadToc == NULL) {
	return FALSE;
    }

    dwRet = WaitForSingleObject(g_Devices[cdrom]->hThreadToc, 0L );
    if (dwRet == WAIT_OBJECT_0) {

	GetExitCodeThread( g_Devices[cdrom]->hThreadToc, &dwRet );
	g_Devices[cdrom]->fIsTocValid = (BOOL)dwRet;
	CloseHandle( g_Devices[cdrom]->hThreadToc );
	g_Devices[cdrom]->hThreadToc = NULL;
    }

    return g_Devices[cdrom]->fIsTocValid;
}


/******************************Public*Routine******************************\
* LockAllTableOfContents
*
* This function is used to determine if it is valid for the UI thread
* to access the table of contents for the ALL the cdroms devices.
* The function returns FALSE the UI thread should NOT touch the table of
* contents for any CD Rom.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
LockALLTableOfContents(
    void
    )
{
    BOOL    fLock;
    int     i;

    for (i = 0, fLock = TRUE; fLock && (i < g_NumCdDevices); i++) {
	fLock = LockTableOfContents(i);
    }

    return fLock;
}


/******************************Public*Routine******************************\
* AllocMemory
*
* Allocates a memory of the given size.  This function will terminate the
* application if the allocation failed.  Memory allocated by this function
* must be freed with LocalFree.  The memory should not be locked or unlocked.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LPVOID
AllocMemory(
    UINT uSize
    )
{
    LPVOID lp;
    lp = LocalAlloc( LPTR, uSize );
    if (lp == NULL) {

	/*
	** No memory - no application, simple !
	*/

	FatalApplicationError( STR_FAIL_INIT );
    }

    return lp;
}


/******************************Public*Routine******************************\
* SetPlayButtonsEnableState
*
* Sets the play buttons enable state to match the state of the current
* cdrom device.  See below...
*
*
*                 CDPlayer buttons enable state table
* 
* E=Enabled D=Disabled       Play  Pause  Eject  Stop   Other DataB 
* 
* Disk in use                 D     D      D       D      D     D   
* 
* No music cd or data cdrom   D     D      E       D      D     D   
* 
* Music cd (playing)          D     E      E       E      E     E   
* 
* Music cd (paused)           E     E      E       E      E     E   
* 
* Music cd (stopped)          E     D      E       D      E     E   
* 
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SetPlayButtonsEnableState(
    void
    )
{
    BOOL    fMusicCdLoaded;
    BOOL    fActivePlayList;
    int     i;

    /*
    ** Do we have a music cd loaded.
    */
    if (g_State & (CD_BEING_SCANNED | CD_NO_CD | CD_DATA_CD_LOADED | CD_IN_USE))
    {
	    fMusicCdLoaded = FALSE;
    }
    else
    {
	    fMusicCdLoaded = TRUE;
    }

    /*
    ** Is there an active playlist
    */
    if ( (CDTIME(g_CurrCdrom).TotalMin == 0) && (CDTIME(g_CurrCdrom).TotalSec == 0) )
    {
	    fActivePlayList = FALSE;
    }
    else
    {
    	fActivePlayList = TRUE;
    }

    //tell the main UI about the track button
    HWND hwndTrackButton = GetDlgItem(GetParent(g_hwndApp),IDB_TRACK);
    if (hwndTrackButton)
    {
        EnableWindow(hwndTrackButton,(fMusicCdLoaded & fActivePlayList));
    }

    //just turn off all "old" cdplayer buttons, since they are not used in this app
    EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)], FALSE );
	EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)], FALSE );
	EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_PAUSE)], FALSE );

    /*
    ** Do the remaining buttons
    */

    for ( i = IDM_PLAYBAR_PREVTRACK; i <= IDM_PLAYBAR_NEXTTRACK; i++ )
    {
    	EnableWindow( g_hwndControls[INDEX(i)], FALSE );
    }

    /*
    ** If the drive is in use then we must diable the eject button.
    */
    EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_EJECT)], FALSE );
}


/******************************Public*Routine******************************\
* HeartBeatTimerProc
*
* This function is responsible for.
*
*  1. detecting new or ejected cdroms.
*  2. flashing the LED display if we are in paused mode.
*  3. Incrementing the LED display if we are in play mode.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void CALLBACK
HeartBeatTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    )
{
    static DWORD dwTickCount;
    DWORD   dwMod;

    ++dwTickCount;

    dwMod = (dwTickCount % 6);

    /*
    ** Check for "letting go" of drive every 3 seconds
    */
    if ( 0 == dwMod )
    {
	    for (int i = 0; i < g_NumCdDevices; i++)
        {
            if ( (!(g_Devices[i]->State & CD_EDITING))
              && (!(g_Devices[i]->State & CD_PLAYING)) )
            {
                CheckUnitCdrom(i,FALSE);
            }
        }
    }

    if ( g_State & CD_PLAYING ) {

	if ( LockALLTableOfContents() ) {
	    SyncDisplay();
	}
    }

    /*
    ** If we are paused and NOT skipping flash the display.
    */

    else if ((g_State & CD_PAUSED) && !(g_State & CD_SEEKING)) {

	HWND hwnd;

	switch ( dwMod ) {

	case 2:
	case 5:
	case 8:
	case 11:
	    if ( g_fIsIconic ) {
			//Next two lines removed to fix tooltip bug:<mwetzel 08.26.97>
			//SetWindowText( g_hwndApp, g_szBlank );
			//UpdateWindow( g_hwndApp );
	    }
	    else {

		hwnd = g_hwndControls[INDEX(IDC_LED)];

		g_fFlashLed = TRUE;
		//SetWindowText( hwnd, g_szBlank );
		g_fFlashLed = FALSE;
	    }
	    break;

	case 0:
	case 3:
	case 6:
	case 9:
	    UpdateDisplay( DISPLAY_UPD_LED );
	    break;
	}

    }
}


/******************************Public*Routine******************************\
* SkipBeatTimerProc
*
* This function is responsible for advancing or retreating the current
* playing position.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void CALLBACK
SkipBeatTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    )
{

    /*
    ** Deteremine if it is time to accelerate the skipping frequency.
    */
    switch (++g_AcceleratorCount) {

    case SKIP_ACCELERATOR_LIMIT1:
	KillTimer( hwnd, idEvent );
	SetTimer( hwnd, idEvent, SKIPBEAT_TIMER_RATE2, (TIMERPROC)SkipBeatTimerProc );
	break;

    case SKIP_ACCELERATOR_LIMIT2:
	KillTimer( hwnd, idEvent );
	SetTimer( hwnd, idEvent, SKIPBEAT_TIMER_RATE3, (TIMERPROC)SkipBeatTimerProc );
	break;
    }

    if ( LockALLTableOfContents() ) {
	if ( idEvent == IDM_PLAYBAR_SKIPFORE) {

	    TimeAdjustIncSecond( g_CurrCdrom );

	    /*
	    ** When TimeAjustIncSecond gets to the end of the last track
	    ** it sets CURRTRACK(g_CurrCdrom) equal to NULL.  When this
	    ** occurs we effectively reset the CD Player
	    */
	    if ( CURRTRACK(g_CurrCdrom) == NULL ) {

		if ( g_State & (CD_WAS_PLAYING | CD_PAUSED) ) {

		    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
				 WM_LBUTTONDOWN, 0, 0L );

		    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
				 WM_LBUTTONUP, 0, 0L );
		}
		else {

		    /*
		    ** Seek to the first playable track.
		    */
		    CURRTRACK(g_CurrCdrom) = FindFirstTrack( g_CurrCdrom );
		    if ( CURRTRACK(g_CurrCdrom) != NULL ) {

			TimeAdjustSkipToTrack( g_CurrCdrom,
					       CURRTRACK(g_CurrCdrom) );

			UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME |
				       DISPLAY_UPD_TRACK_NAME );

			SetPlayButtonsEnableState();
		    }
		}
	    }
	}
	else {
	    TimeAdjustDecSecond( g_CurrCdrom );
	}
    }
}


/******************************Public*Routine******************************\
* UpdateDisplay
*
* This routine updates the display according to the flags that
* are passed in.  The display consists of the LED display, the
* track and title names, the disc and track lengths and the cdrom
* combo-box.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
UpdateDisplay(
    DWORD Flags
    )
{
    TCHAR       lpsz[55];
    TCHAR       lpszIcon[75];
    PTRACK_PLAY tr;
    int         track;
    int         mtemp, stemp, m, s;

    /*
    ** Check for valid flags
    */

    if ( Flags == 0 ) {
	return;
    }

    ZeroMemory(lpsz,sizeof(lpsz));

    /*
    ** Grab current track information
    */

    if (CURRTRACK(g_CurrCdrom) != NULL) {

	track = CURRTRACK(g_CurrCdrom)->TocIndex + FIRSTTRACK(g_CurrCdrom);
    }
    else {

	track = 0;
    }

    /*
    ** Update the LED box?
    */


    if (Flags & DISPLAY_UPD_LED) {

	/*
	** Update LED box
	*/

	if (g_fDisplayT) {

	    if (Flags & DISPLAY_UPD_LEADOUT_TIME) {

		wsprintf( lpsz, TRACK_TIME_LEADOUT_FORMAT,
			  //track,
			  CDTIME(g_CurrCdrom).TrackCurMin,
			  g_szTimeSep,
			  CDTIME(g_CurrCdrom).TrackCurSec );
	    }
	    else {

		wsprintf( lpsz, TRACK_TIME_FORMAT,
			  //track,
			  CDTIME(g_CurrCdrom).TrackCurMin,
			  g_szTimeSep,
			  CDTIME(g_CurrCdrom).TrackCurSec );
	    }
	}

	if (g_fDisplayTr) {

	    if (Flags & DISPLAY_UPD_LEADOUT_TIME) {

		wsprintf( lpsz, TRACK_REM_FORMAT, //track - 1,
			  CDTIME(g_CurrCdrom).TrackCurMin,
			  g_szTimeSep,
			  CDTIME(g_CurrCdrom).TrackCurSec );
	    }
	    else {

		wsprintf( lpsz, TRACK_REM_FORMAT, //track,
			  CDTIME(g_CurrCdrom).TrackRemMin,
			  g_szTimeSep,
			  CDTIME(g_CurrCdrom).TrackRemSec );
	    }
	}

    if (g_fDisplayD)
    {
	    /*
	    ** Compute remaining time, then sub from total time
	    */

	    mtemp = stemp = m = s =0;

	    if (CURRTRACK(g_CurrCdrom) != NULL)
        {
		    for ( tr = CURRTRACK(g_CurrCdrom)->nextplay;
		          tr != NULL;
		          tr = tr->nextplay )
            {

		        FigureTrackTime( g_CurrCdrom, tr->TocIndex, &mtemp, &stemp );

		        m+=mtemp;
		        s+=stemp;

		    }

		    m+= CDTIME(g_CurrCdrom).TrackRemMin;
		    s+= CDTIME(g_CurrCdrom).TrackRemSec;
	    }

	    m += (s / 60);
	    s  = (s % 60);

	    CDTIME(g_CurrCdrom).RemMin = m;
	    CDTIME(g_CurrCdrom).RemSec = s;

        //convert to a total number of seconds remaining
        s = (m*60) + s;

        //convert total time to a number of seconds
        DWORD stotal = (CDTIME(g_CurrCdrom).TotalMin*60) + CDTIME(g_CurrCdrom).TotalSec;

        //subtract time remaining from total time
        stotal = stotal - s;

	    m  = (stotal / 60);
	    s  = (stotal % 60);

        wsprintf( lpsz, DISC_TIME_FORMAT,
		      m,
		      g_szTimeSep,
		      s);
    }

	if (g_fDisplayDr) {

	    /*
	    ** Compute remaining time
	    */

	    mtemp = stemp = m = s =0;

	    if (CURRTRACK(g_CurrCdrom) != NULL) {

		for ( tr = CURRTRACK(g_CurrCdrom)->nextplay;
		      tr != NULL;
		      tr = tr->nextplay ) {

		    FigureTrackTime( g_CurrCdrom, tr->TocIndex, &mtemp, &stemp );

		    m+=mtemp;
		    s+=stemp;

		}

		m+= CDTIME(g_CurrCdrom).TrackRemMin;
		s+= CDTIME(g_CurrCdrom).TrackRemSec;

	    }

	    m+= (s / 60);
	    s = (s % 60);

	    CDTIME(g_CurrCdrom).RemMin = m;
	    CDTIME(g_CurrCdrom).RemSec = s;

	    wsprintf( lpsz, DISC_REM_FORMAT,
		      CDTIME(g_CurrCdrom).RemMin,
		      g_szTimeSep,
		      CDTIME(g_CurrCdrom).RemSec );
	}

	SetWindowText( g_hwndControls[INDEX(IDC_LED)], lpsz );

    if (Flags != DISPLAY_UPD_LED)
    {
        InvalidateRect(g_hwndControls[INDEX(IDC_LED)],NULL,FALSE);
        UpdateWindow(g_hwndControls[INDEX(IDC_LED)]);
    }


	if (g_fIsIconic) {
		//Next four lines changed to fix tooltip bugs: <mwetzel 08.26.97>
		if( g_Devices[g_CurrCdrom]->State & CD_PAUSED )
			wsprintf( lpszIcon, IdStr( STR_CDPLAYER_PAUSED), lpsz );
		else
			wsprintf( lpszIcon, IdStr( STR_CDPLAYER_TIME ), lpsz );
	    SetWindowText( g_hwndApp, lpszIcon );
	}
    }

    //update the framework window to show the time
    if ((CURRTRACK(g_CurrCdrom)) && (lpsz[0] != TEXT('\0')))
    {
        //might already be pre-pending track number
        if (lpsz[0] != TEXT('['))
        {
            wsprintf(lpszIcon,TEXT("[%i] %s"),CURRTRACK(g_CurrCdrom)->TocIndex+1,lpsz);
        }
        else
        {
            _tcscpy(lpszIcon,lpsz);
        }
        MMSETTITLE mmTitle;
        mmTitle.mmInfoText = MMINFOTEXT_DESCRIPTION;
        mmTitle.szTitle = lpszIcon;
        g_pSink->OnEvent(MMEVENT_SETTITLE,&mmTitle);
    }

    /*
    ** Update Title?
    */

    if (Flags & DISPLAY_UPD_TITLE_NAME)
    {
	    ComputeDriveComboBox( );

	    SetWindowText( g_hwndControls[INDEX(IDC_TITLE_NAME)],
		           (LPCTSTR)TITLE(g_CurrCdrom) );

        //update the framework window to show the title
        MMSETTITLE mmTitle;
        mmTitle.mmInfoText = MMINFOTEXT_TITLE;
        mmTitle.szTitle = TITLE(g_CurrCdrom);
        g_pSink->OnEvent(MMEVENT_SETTITLE,&mmTitle);
    }

}


/******************************Public*Routine******************************\
* Common_OnCtlColor
*
* Here we return a brush to paint the background with.  The brush is the same
* color as the face of a button.  We also set the text background color so
* that static controls draw correctly.  This function is shared with the
* disk info/editing dialog box.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
HBRUSH
Common_OnCtlColor(
    HWND hwnd,
    HDC hdc,
    HWND hwndChild,
    int type
    )
{
    SetBkColor( hdc, GetSysColor(COLOR_BTNFACE) );
    return g_hBrushBkgd;
}

/******************************Public*Routine******************************\
* Common_OnMeasureItem
*
* All items are the same height and width.
*
* We only have to update the height field for owner draw combo boxes and
* list boxes.  This function is shared with the disk edit/info dialog box.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL
Common_OnMeasureItem(
    HWND hwnd,
    MEASUREITEMSTRUCT *lpMeasureItem
    )
{
    if (lpMeasureItem->CtlType == ODT_MENU)
    {
        return FALSE;
    }

    HFONT   hFont;
    int     cyBorder, cyDelta;
    LOGFONT lf;

    hFont = GetWindowFont( hwnd );

    if ( hFont != NULL ) {

	GetObject( hFont, sizeof(lf), &lf );
    }
    else {
	SystemParametersInfo( SPI_GETICONTITLELOGFONT,
		sizeof(lf), (LPVOID)&lf, 0 );
    }

    cyDelta  = ABS( lf.lfHeight ) / 2;
    cyBorder = GetSystemMetrics( SM_CYBORDER );

    //
    // Ensure enough room between chars.
    //
    if (cyDelta < 4 * cyBorder) {
        cyDelta = 4 * cyBorder;
    }

    lpMeasureItem->itemHeight = ABS( lf.lfHeight ) + cyDelta;

    return TRUE;
}

/******************************Public*Routine******************************\
* DrawTrackItem
*
* This routine draws the information in a cell of the track name
* combo box.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
DrawTrackItem(
    HDC hdc,
    const RECT *r,
    DWORD item,
    BOOL selected
    )
{
    SIZE        si;
    int         i;
    int         cxTrk;
    PTRACK_INF  t;
    TCHAR       s[ARTIST_LENGTH];
    TCHAR       szTrk[16];

    /*
    ** Check for invalid items
    */

    if ( item == (DWORD)-1 ) {

	return;
    }

    if ( ALLTRACKS(g_CurrCdrom) == NULL ) {

	return;
    }


    /*
    ** Check selection status, and set up to draw correctly
    */

    if ( selected ) {

	SetBkColor( hdc, GetSysColor( COLOR_HIGHLIGHT ) );
	SetTextColor( hdc, GetSysColor( COLOR_HIGHLIGHTTEXT ) );
    }
    else {

	SetBkColor( hdc, GetSysColor(COLOR_WINDOW));
	SetTextColor( hdc, GetSysColor(COLOR_WINDOWTEXT));
    }

    /*
    ** Get track info
    */

    t = FindTrackNodeFromTocIndex( item, ALLTRACKS( g_CurrCdrom ) );


    if ( (t != NULL) && (t->name != NULL) ) {

	/*
	** Do we need to munge track name (clip to listbox)?
	*/

	wsprintf(szTrk, TEXT("<%02d> "), t->TocIndex + FIRSTTRACK(g_CurrCdrom));
	GetTextExtentPoint( hdc, szTrk, _tcslen(szTrk), &si );
	cxTrk = si.cx;

	i = _tcslen( t->name ) + 1;

	do {
	    GetTextExtentPoint( hdc, t->name, --i, &si );

	} while( si.cx > (r->right - r->left - cxTrk) );

	ZeroMemory( s, TRACK_TITLE_LENGTH * sizeof( TCHAR ) );
	_tcsncpy( s, t->name, i );

    }
    else {

	_tcscpy( s, g_szBlank );
	i = 1;

    }

    /*
    ** Draw track name
    */

    ExtTextOut( hdc, r->left, r->top,
		ETO_OPAQUE | ETO_CLIPPED,
		r, s, i, NULL );

    /*
    ** draw track number
    */
    if ( t != NULL ) {
	ExtTextOut( hdc, r->right - cxTrk, r->top, ETO_CLIPPED,
		    r, szTrk, _tcslen( szTrk ), NULL );
    }

}

/*****************************Private*Routine******************************\
* HandlePassedCommandLine
*
* This function gets called to handle command line options that are passed to
* CDPlayer as the result of the WM_DROPFILES or WM_COPYDATA messages.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
HandlePassedCommandLine(
    LPTSTR lpCmdLine,
    BOOL   fCheckCDRom
    )
{

    int     i;
    int     iTrack = -1, iCDrom;

    iCDrom = ParseCommandLine( lpCmdLine, &iTrack, TRUE );
    if ((iCDrom < 0) || (iCDrom >= g_NumCdDevices))
	return;


	// CheckUnitCDRom to reload Table of Contents
    if ( fCheckCDRom )
    {

	CheckUnitCdrom(iCDrom, TRUE);

	while( !LockTableOfContents(iCDrom) )
	{

		MSG     msg;

	    GetMessage( &msg, NULL, WM_NOTIFY_TOC_READ, WM_NOTIFY_TOC_READ );
		DispatchMessage( &msg );
	    }
    }

#if 0
    if (iCDrom != g_CurrCdrom)
    {
	    HWND hwndBtn = g_hwndControls[INDEX(IDC_ARTIST_NAME)];

	    SwitchToCdrom( iCDrom, TRUE );
	    SetPlayButtonsEnableState();
	    SendMessage( hwndBtn, CB_SETCURSEL, (WPARAM)iCDrom, 0 );
    }
#endif

    /*
    ** Initialize the new play list for each drive.
    */
    for ( i = 0; i < g_NumCdDevices; i++)
    {
	    TimeAdjustInitialize( i );
    }

    // Set Current Track to specified track
    if ( iTrack != -1 )
    {
	    PTRACK_PLAY tr;

	    tr = PLAYLIST( iCDrom );
	    if ( tr != NULL )
	{
		for( i = 0; i < iTrack; i++, tr = tr->nextplay );
		    TimeAdjustSkipToTrack( iCDrom, tr );
	    }
    }
}


/******************************Public*Routine******************************\
* IsUpdateOptionGiven
*
* Checks the command line to see if the "-update" option has been passed.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
IsUpdateOptionGiven(
    LPTSTR lpstr
    )
{
    TCHAR   chOption[MAX_PATH];


    /*
    ** Start by converting everything to upper case.
    */
    CharUpperBuff( lpstr, _tcslen(lpstr) );

    /*
    ** The first parameter on the command line is always the
    ** string used invoke the program.  ie cdplayer.exe
    */
    lpstr += _tcsspn( lpstr, g_szBlank );
    lpstr += CopyWord( chOption, lpstr );


    /*
    ** Remove leading space
    */
    lpstr += _tcsspn( lpstr, g_szBlank );


    /*
    ** process any command line options
    */
    while ( (*lpstr == g_chOptionHyphen) || (*lpstr == g_chOptionSlash) ) {

	/*
	** pass over the option delimeter
	*/
	lpstr++;

	/*
	** Copy option and skip over it.
	*/
	lpstr += CopyWord( chOption, lpstr );


	/*
	** Is this the play option ??  If so, don't  bother processing anymore
	** options.
	*/
	if ( 0 == _tcscmp( chOption, g_szUpdate ) ) {

	    return TRUE;
	}

	/*
	** Remove leading space
	*/
	lpstr += _tcsspn( lpstr, g_szBlank );
    }

    return FALSE;
}



/*****************************Private*Routine******************************\
* ParseCommandLine
*
* Here we look to see if we have been asked to play a particular track.
* The format of the command line is:
*
*
*  CDPlayer command options.
*
*  CDPLAYER {Options}
*
*   Options     :   -play | {Sub-Options}
*   Sub-Options :   {-track tracklist} | trackname
*   trackname   :   filename | drive letter
*   tracklist   :   filename+
*
*      -track      A track list if a list of tracks that the user wants
*                  to play.  It overides any play list that may already be stored
*                  for the current cd.
*
*      -play       Start playing the current play list.  If -play is not specified
*                  CD Player seeks to the first track in the play list.
*
*
*   On Windows NT the format of [file] is:
*       d:\track(nn).cda
*
*   where d: is the drive letter of the cdrom that you want to play
*   and \track(nn) is the track number that you want to play.
*
*   Therefore to play track 8 from a cd-rom drive mapped to e:
*
*       cdplayer /play e:\track08.cda
*
*   On Chicago the file is actually a riff CDDA file which contains
*   all the info required to locate the disc and track.
*
* Returns the index of the CD-Rom drive which should be played first.  Can return
* -1 iff the caller passed FALSE for the fQuiet parameter and the message box was
* actually displayed.  This should only occur when the user trys to start a new
* copy of cdplayer passing it the track.cda file of a disk that is not inserted
* in any of the current CD-Drives attached to the machine.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
ParseCommandLine(
    LPTSTR lpstr,
    int *piTrackToSeekTo,
    BOOL fQuiet
    )
{

    TCHAR   chOption[MAX_PATH];
    BOOL    fTrack = FALSE;
    int     iCdRomIndex = -1;  // Assume Failure until proven otherwise
    int     ii;

    for (ii = 0; ii < g_NumCdDevices; ii++) {
    g_Devices[ii]->fKilledPlayList = FALSE;
    }


    /*
    ** Start by converting everything to upper case.
    */
    CharUpperBuff( lpstr, _tcslen(lpstr) );

#if DBG
#ifdef UNICODE
    dprintf( TEXT("CD Player Command line : %ls"), lpstr );
#else
    dprintf( "CD Player Command line : %s", lpstr );
#endif
#endif

    /*
    ** The first parameter on the command line is always the
    ** string used invoke the program.  ie cdplayer.exe
    */
    lpstr += _tcsspn( lpstr, g_szBlank );
    lpstr += CopyWord( chOption, lpstr );


    /*
    ** Remove leading space
    */
    lpstr += _tcsspn( lpstr, g_szBlank );


    /*
    ** process any command line options
    */
    while ( (*lpstr == g_chOptionHyphen) || (*lpstr == g_chOptionSlash) ) {

	/*
	** pass over the option delimeter
	*/
	lpstr++;

	/*
	** Copy option and skip over it.
	*/
	lpstr += CopyWord( chOption, lpstr );


	/*
	** Is this a command line option we understand - ignore ones
	** we don't understand.
	*/
	if ( 0 == _tcscmp( chOption, g_szTrack ) )
    {

	    if ( !fTrack )
        {
		    lpstr = ParseTrackList( lpstr, &iCdRomIndex );
		    fTrack = TRUE;
	    }
	}
	else if ( 0 == _tcscmp( chOption, g_szPlay ) )
    {
	    g_fPlay = TRUE;
	}
    else if ( 0 == _tcscmp( chOption, g_szTray) )
    {
        g_fStartedInTray = TRUE;
    }
	else
    {
#if DBG
#ifdef UNICODE
	    dprintf(TEXT("Ignoring unknown option %ls\n"), chOption );
#else
	    dprintf("Ignoring unknown option %s\n", chOption );
#endif
#endif
	}

	/*
	** Remove leading space
	*/
	lpstr += _tcsspn( lpstr, g_szBlank );
    }


    /*
    ** parse remaining command line parameters
    */

    if ( (*lpstr != g_chNULL) && !fTrack) {

	/*
	** Copy track name and skip over it.  Sometimes the shell
	** gives us quoted strings and sometimes it doesn't.  If the
	** string is not quoted assume that remainder of the command line
	** is the track name.
	*/
	if ( (*lpstr == TEXT('\'')) || (*lpstr == TEXT('\"')) ) {
	    lpstr += CopyWord( chOption, lpstr );
	}
	else {
	    _tcscpy(chOption, lpstr);
	}

	if ( IsTrackFileNameValid( chOption, &iCdRomIndex,
				   piTrackToSeekTo, FALSE, fQuiet ) )
    {
        //if the user passed in a track, turn off start-up random mode
        if (!g_fSelectedOrder)
        {
            g_fSelectedOrder = TRUE;
            SendMessage(GetParent(g_hwndApp),WM_COMMAND,MAKEWPARAM(IDM_MODE_NORMAL,0),(LPARAM)0);
        }
	    ResetPlayList( iCdRomIndex );
	}
#if DBG
#ifdef UNICODE
	dprintf(TEXT("Seeking to track %ls\n"), chOption );
#else
	dprintf("Seeking to track %s\n", chOption );
#endif
#endif
    }

    return iCdRomIndex;
}



/*****************************Private*Routine******************************\
* ParseTrackList
*
* Each track is separated by a ' ' character.  The track list is terminated
* by the NULL, '/' or '-' character.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
TCHAR *
ParseTrackList(
    TCHAR *szTrackList,
    int *piCdRomIndex
    )
{
    TCHAR   chTrack[MAX_PATH];
    int     iTrackIndex;
    int     iCdRom = -1;                // Assume failure, until proven otherwise
    BOOL    fPlayListErased = FALSE;


    ZeroMemory (&chTrack, sizeof (chTrack)); // Make Prefix happy.

    /*
    ** Remove any stray white space
    */

    szTrackList += _tcsspn( szTrackList, g_szBlank );

    /*
    ** While there are still valid characters to process
    */

    while ( (*szTrackList != g_chNULL)
	 && (*szTrackList != g_chOptionHyphen)
	 && (*szTrackList != g_chOptionSlash) ) {

	/*
	** Copy the track name and skip over it.
	*/
	szTrackList += CopyWord( chTrack, szTrackList );

	/*
	** Now check that we have been given a valid filename
	*/

	if ( IsTrackFileNameValid( chTrack, &iCdRom, &iTrackIndex, TRUE, FALSE ) ) {

	    PTRACK_PLAY     pt;

	    /*
	    ** If this is the first valid file given nuke the
	    ** existing play lists and prepare for a new list.  Note that
	    ** things are complicated by the fact that we could be given
	    ** files from more than one CD-Rom drive.
	    */

	if (! g_Devices[iCdRom]->fKilledPlayList)
	{
		    /*
		    ** Kill the old play and save lists.
		    */

		    ErasePlayList( iCdRom );
		    EraseSaveList( iCdRom );

		    PLAYLIST( iCdRom ) = NULL;
		    SAVELIST( iCdRom ) = NULL;

		    fPlayListErased = TRUE;
		
		g_Devices[iCdRom]->fKilledPlayList = TRUE;
		    *piCdRomIndex = iCdRom;
	    }

	    pt = (TRACK_PLAY*)AllocMemory( sizeof(TRACK_PLAY) );

	    pt->TocIndex = iTrackIndex;
	    pt->min = 0;
	    pt->sec = 0;

	    /*
	    ** Is this the first track on this devices play list ?
	    */

	    if ( PLAYLIST(iCdRom) == NULL ) {

		PLAYLIST(iCdRom) = pt;
		pt->nextplay = pt->prevplay = NULL;
	    }
	    else {

		/*
		** append this track to the end of the current play list
		*/

		AppendTrackToPlayList( PLAYLIST(iCdRom), pt );
	    }
	}
	else {

	    /*
	    ** Put up a message box warning the user that the given
	    ** track name is invalid and that we can't play it.
	    */

	    ;
	}

	/*
	** Remove any stray white space
	*/
	szTrackList += _tcsspn( szTrackList, g_szBlank );
    }

    /*
    ** If we have erased the play list we have to go off and reset the
    ** saved play list.
    */

    if ( fPlayListErased ) {
	    SAVELIST( iCdRom ) = CopyPlayList( PLAYLIST(iCdRom) );
    }

    return szTrackList;
}



/*****************************Private*Routine******************************\
* CopyWord
*
* Copies one from szSource to szWord - assumes that words are delimited
* by ' ' characters.  szSource MUST point to the begining of the word.
*
* Returns length of word copied.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
CopyWord(
    TCHAR *szWord,
    TCHAR *szSource
    )
{
    int     n, nReturn;

    /*
    ** Copy the track name
    */
    if ( (*szSource == TEXT('\'')) || (*szSource == TEXT('\"')) ) {

	TCHAR ch = *szSource;

	/*
	** Remember which quote character it was
	** According to the DOCS " is invalid in a filename...
	*/

	n = 0;

	/*
	** Move over the initial quote, then copy the filename
	*/

	while ( *++szSource && *szSource != ch ) {
	    szWord[n++] = *szSource;
	}
	nReturn = n + (*szSource == ch ? 2 : 1);
    }
    else {

	n = _tcscspn( szSource, g_szBlank );
	_tcsncpy( szWord, szSource, n );
	nReturn = n;
    }

    szWord[n] = g_chNULL;

    return nReturn;
}



/*****************************Private*Routine******************************\
* IsTrackFileNameValid
*
* This function returns true if the specified filename is a valid CD track.

* On NT track filenames must be of the form:
*   d:\track(n).cda  where d: is the CD-Rom device and \track(n).cda
*                    is the index of the track to be played (starting from 1).
*
* On Chicago the track filename is actually a riff CDDA file which contains
* the track info that we require.
*
* If the filename is valid the function true and sets piCdromIndex and
* piTrackIndex to the correct values.
*
* History:
* 29-09-94 - StephenE - Created
*
\**************************************************************************/
BOOL
IsTrackFileNameValid(
    LPTSTR lpstFileName,
    int *piCdRomIndex,
    int *piTrackIndex,
    BOOL fScanningTracks,
    BOOL fQuiet
    )
{
#define RIFF_RIFF 0x46464952
#define RIFF_CDDA 0x41444443

    RIFFCDA     cda;
	HANDLE          hFile;
    TCHAR       chDriveLetter;
    int         i;
    TCHAR       szFileName[MAX_PATH];
	TCHAR           szPath[MAX_PATH];
    SHFILEINFO  shInfo;
    DWORD       cbRead;


    //
    // If we are not constructing a track play list it is valid to just specify
    // a drive letter, in which case we select that drive and start playing
    // at the first track on it.  All the tracks are played in sequential
    // order.
    //
    if ( !fScanningTracks) {

	//
	// Map the drive letter onto the internal CD-Rom index used by CDPlayer.
	//
	chDriveLetter = *lpstFileName;
	for ( i = 0; i < g_NumCdDevices; i++ ) {

	    if (g_Devices[i]->drive == chDriveLetter) {

		*piCdRomIndex = i;
		break;
	    }
	}

	//
	// If we mapped the drive OK check to see if we should play all
	// the tracks or just the current play list for that drive.  If we
	// didn't map the drive OK assume that its the first part of a
	// RIFF filename and fall through to the code below that opens the
	// RIFF file and parses its contents.
	//
	if ( i != g_NumCdDevices ) {

	    //
	    // If next character is only a colon ':' then play the
	    // the entire disk starting from the first track.
	    //
	    if ( 0 == _tcscmp(lpstFileName + 1, g_szColon) ) {

		*piTrackIndex = 0;
		return TRUE;
	    }

	    //
	    // If the next two characters are colon backslash ":\" then
	    // we seek to the specified drive and play only those tracks that
	    // are in the default playlist for the current disk in that drive.
	    // All we need to do to achive this is return FALSE.
	    //
	    if ( 0 == _tcscmp(lpstFileName + 1, g_szColonBackSlash) ) {
		return FALSE;
	    }
	}
    }


    //
    // Otherwise, open the file and read the CDA info.  The file name may be a
    // link to .cda in which case we need to get the shell to resolve the link for
    // us.  We take a copy of the file name because the ResolveLink function
    // modifies the file name string in place.
    //
    _tcscpy(szFileName, lpstFileName);
    if (0L == SHGetFileInfo( szFileName, 0L, &shInfo,
			     sizeof(shInfo), SHGFI_ATTRIBUTES)) {
	return FALSE;
    }

    if ((shInfo.dwAttributes & SFGAO_LINK) == SFGAO_LINK) {

	if (!g_fOleInitialized)
    {
	    g_fOleInitialized = SUCCEEDED(OleInitialize(NULL));
	}

	if (!ResolveLink(szFileName)) {
	    return FALSE;
	}
    }

	// Make sure file exists
	if (GetFileAttributes (szFileName) == ((DWORD)-1)) {
		// Get Full path to file
		if (0 == SearchPath (NULL, szFileName, NULL,
							 MAX_PATH, szPath, NULL)) {
			return FALSE;
		}
	} else {
		_tcscpy (szPath, szFileName);
	}

	// Open file and read in CDA info
	hFile = CreateFile (szFileName, GENERIC_READ,
						FILE_SHARE_READ, NULL,
						OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE == hFile) {
		return FALSE;
	}
	
	ReadFile(hFile, &cda, sizeof(cda), &cbRead, NULL);
	CloseHandle (hFile);

    //
    // Make sure its a RIFF CDDA file
    //
    if ( (cda.dwRIFF != RIFF_RIFF) || (cda.dwCDDA != RIFF_CDDA) ) {
	return FALSE;
    }

    //
    // Make sure that we have this disc loaded.
    //
    for ( i = 0; i < g_NumCdDevices; i++ ) {

	if (g_Devices[i]->CdInfo.Id == cda.DiscID) {

	    *piCdRomIndex = i;
	    break;
	}
    }


    //
    // If we didn't map the drive OK return FALSE AND set the
    // returned CD-ROM index to -1 but only if the caller asked us
    // to complain about an incorrect CD being inserted in the drive.
    //
    if ( i == g_NumCdDevices ) {

	if (!fQuiet) {
	    AskUserToInsertCorrectDisc(cda.DiscID);
	    *piCdRomIndex = -1;
	}
	return FALSE;
    }

    *piTrackIndex = cda.wTrack - 1;

    return TRUE;
}


/*****************************Private*Routine******************************\
* AppendTrackToPlayList
*
* Appends the TRACK_PLAY record pointed to by pAppend to the end of the
* double linked list pointed to by pHead.
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
AppendTrackToPlayList(
    PTRACK_PLAY pHead,
    PTRACK_PLAY pAppend
    )
{
    PTRACK_PLAY pp = pHead;

    while (pp->nextplay != NULL) {
	pp = pp->nextplay;
    }

    pp->nextplay = pAppend;
    pAppend->prevplay = pp;
    pAppend->nextplay = NULL;

}


/*****************************Private*Routine******************************\
* FindMostSuitableDrive
*
* Tries to determine the best drive to make the current drive.  Returns the
* drive.
*
* We should choose the first disc that is playing if any are playing.
*
* New dstewart: Else choose the drive that is selected in the CDUNIT table
*
* Else we should choose the first disc with a music disk in it if there
* any drives with music discs in them.
*
* Else we should chose the first drive that is available if any of the
* drives are available.
*
* Else just choose the first (ie. zeroth) drive.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
FindMostSuitableDrive(
    void
    )
{
    int     iDisc;

    /*
    ** Check for a playing drive
    */
    for ( iDisc = 0; iDisc < g_NumCdDevices; iDisc++ ) {

	if ( g_Devices[iDisc]->State & (CD_PLAYING | CD_PAUSED) ) {
	    return iDisc;
	}
    }

    //check the current default drive
    LPCDOPT pOpt = (LPCDOPT)g_pSink->GetOptions();
    LPCDOPTIONS pCDOpts = NULL;
    LPCDUNIT pUnit = NULL;
    int iDefDrive = 0;

    if (pOpt)
    {
        pCDOpts = pOpt->GetCDOpts();
    }

    if (pCDOpts)
    {
        pUnit = pCDOpts->pCDUnitList;
    }

    //scan the list to find the one we want
    for (int index = 0; index < g_NumCdDevices; index++)
    {
        if (pUnit)
        {
            if (pUnit->fDefaultDrive)
            {
                iDefDrive = index;

        	    //if this is the default AND it has a disc loaded, go for it
                if ( g_Devices[index]->State & CD_LOADED )
                {
                    return index;
                }
            }

            pUnit = pUnit->pNext;

        }
    }

    /*
    ** Check for a drive with a music disk in it
    */
    for ( iDisc = 0; iDisc < g_NumCdDevices; iDisc++ )
    {
	    if ( g_Devices[iDisc]->State & CD_LOADED )
        {
	        return iDisc;
	    }
    }

    /*
    **  If the default drive is not in use, use it
    */
	if ( (g_Devices[iDefDrive]->State & (CD_BEING_SCANNED | CD_IN_USE)) == 0 )
    {
	    return iDefDrive;
	}

    /*
    ** Check for any drive that is not in use
    */
    for ( iDisc = 0; iDisc < g_NumCdDevices; iDisc++ )
    {
	    if ( (g_Devices[iDisc]->State & (CD_BEING_SCANNED | CD_IN_USE)) == 0 )
        {
	        return iDisc;
	    }
    }

    /*
    **  Ok, no disc are loaded, but all disc are in use, just use the default
    */
    return iDefDrive;
}


/*****************************Private*Routine******************************\
* AskUserToInsertCorrectDisc
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
AskUserToInsertCorrectDisc(
    DWORD dwID
    )
{
    TCHAR   szMsgBoxTitle[32];
    TCHAR   szDiskTitle[TITLE_LENGTH];
    TCHAR   szArtistName[ARTIST_LENGTH];
    TCHAR   szFormat[STR_MAX_STRING_LEN];
    TCHAR   szText[STR_MAX_STRING_LEN + TITLE_LENGTH];

    LPCDDATA pData = (LPCDDATA)g_pSink->GetData();

    _tcscpy(szDiskTitle,g_szNothingThere);

    if(pData)
    {
        //
        // Try to read in title from the options database
        //

        if (pData->QueryTitle(dwID))
        {
            //
            // We found an entry for this disc, so copy all the information
            // from the title database

            LPCDTITLE pCDTitle = NULL;

            if (pData->LockTitle(&pCDTitle,dwID))
            {
                _tcscpy(szDiskTitle,pCDTitle->szTitle);
                _tcscpy(szArtistName,pCDTitle->szArtist);
                pData->UnlockTitle(pCDTitle,FALSE);
            } //end if title locked
        } //end if title found
    }

    /*
    ** If the disk title was found in the database display it.
    */
    if (_tcscmp(szDiskTitle, g_szNothingThere) != 0)
    {
	    _tcscpy( szFormat, IdStr(STR_DISK_NOT_THERE_K) );
	    wsprintf(szText, szFormat, szDiskTitle, szArtistName);
    }
    else
    {
    	_tcscpy( szText, IdStr(STR_DISK_NOT_THERE) );
    }

    //
    // If CD Player is minimized make sure it is restored
    // before displaying the MessageBox
    //
    if (IsIconic(g_hwndApp)) {

	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(g_hwndApp, &wndpl);
	wndpl.showCmd = SW_RESTORE;
	SetWindowPlacement(g_hwndApp, &wndpl);
    }

    _tcscpy( szMsgBoxTitle,  IdStr(STR_CDPLAYER) );
    MessageBox( g_hwndApp, szText, szMsgBoxTitle,
		MB_SETFOREGROUND | MB_ICONINFORMATION | MB_APPLMODAL | MB_OK);
}


#ifndef USE_IOCTLS
BOOL CheckMCICDA (TCHAR chDrive)
{
    DWORD cchLen;
    DWORD dwResult;
    DWORD dwErr;
    CDHANDLE hCD;
    TCHAR szPath[MAX_PATH];
    TCHAR szText[512];
    TCHAR szTitle[MAX_PATH];

    // Make sure the mcicda.dll exists
    cchLen = NUMELEMS(szPath);
    dwResult = SearchPath (NULL, TEXT ("mcicda.dll"), NULL,
			   cchLen, szPath, NULL);
    if ((! dwResult) ||
	    (0xFFFFFFFF == GetFileAttributes (szPath)))
    {
	    // Give Missing MCICDA.DLL error message
	    GetSystemDirectory (szPath, cchLen);

	    _tcscpy( szTitle, IdStr( STR_MCICDA_MISSING ) );
	    wsprintf (szText, szTitle, szPath);
	    _tcscpy( szTitle, IdStr( STR_CDPLAYER ) );
	
	    MessageBox( NULL, szText, szTitle,
				MB_APPLMODAL | MB_ICONINFORMATION |
				MB_OK | MB_SETFOREGROUND );
	    return FALSE;
    }

    // Make sure mcicda.dll service is up and running
    hCD = OpenCdRom (chDrive, &dwErr);
    if (! hCD)
    {
            DWORD SessionId = 0;
            ProcessIdToSessionId( GetCurrentProcessId(), &SessionId );

	    // Error loading media device driver.
            if (SessionId != 0){  //Remote connection user
	        _tcscpy( szText, IdStr( STR_MCICDA_NOT_AVAIL ) );
            }
            else {
	        _tcscpy( szText, IdStr( STR_MCICDA_NOT_WORKING ) );
            }

	    _tcscpy( szTitle, IdStr( STR_CDPLAYER ) );

	    MessageBox( NULL, szText, szTitle,
				MB_APPLMODAL | MB_ICONINFORMATION |
				MB_OK | MB_SETFOREGROUND );
	    return FALSE;
    }

    // Close Device
    CloseCdRom (hCD);
    return TRUE;
}
#endif // ! USE_IOCTLS


#if DBG
/******************************Public*Routine******************************\
* CDAssert
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CDAssert(
    LPSTR x,
    LPSTR file,
    int line
    )
{
    TCHAR    buff[128];

    wsprintf( buff, TEXT("%s \nat line %d of %s"), x, line, file );
    MessageBox( NULL, buff, TEXT("Assertion Failure:"), MB_APPLMODAL | MB_OK );
}

/******************************Public*Routine******************************\
* dprintf
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
dprintf(
    TCHAR *lpszFormat,
    ...
    )
{
    TCHAR buf[512];
    UINT n;
    va_list va;
    static int iPrintOutput = -1;

    if (iPrintOutput == -1) {
	iPrintOutput = GetProfileInt( TEXT("MMDEBUG"), TEXT("CdPlayer"), 0);
    }

    if (iPrintOutput) {

	n = wsprintf(buf, TEXT("CdPlayer: <%d>"), GetCurrentThreadId() );

	va_start(va, lpszFormat);
	n += wvsprintf(buf+n, lpszFormat, va);
	va_end(va);

	buf[n++] = '\n';
	buf[n] = 0;
	OutputDebugString(buf);
    }

}
#endif // End #ifdef DBG

/******************************Public*Routine******************************\
* ChildEnumProc
*
* Gets the position of each child control window.  As saves the associated
* window handle for later use.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL CALLBACK
ChildEnumProc(
    HWND hwndChild,
    LPARAM hwndParent
    )
{
    int index = 0;

    index = INDEX(GetDlgCtrlID( hwndChild ));

    if ((index > -1) && (index < NUM_OF_CONTROLS))
    {
        g_hwndControls[index] = hwndChild;
    }

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\literals.cpp ===
/******************************Module*Header*******************************\
* Module Name: literals.c
*
* Global string variables that don't need converting for international builds.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/
#define NOOLE
#include <windows.h>

#include "playres.h"

#ifndef APP_FONT
#define APP_FONT   "MS San Serif"
#endif

//#ifdef CHICAGO
#include <regstr.h>
//#endif

#ifdef __cplusplus
extern "C" {
#endif
      TCHAR     g_szEmpty[]                 = TEXT("");
      TCHAR     g_IniFileName[]             = TEXT("cdplayer.ini");
      TCHAR     g_HelpFileName[]            = TEXT("cdplayer.hlp");

      TCHAR     g_szBlank[]                 = TEXT(" ");
      TCHAR     g_szSJE_CdPlayerClass[]     = TEXT("SJE_CdPlayerClass");
      TCHAR     g_szSndVol32[]              = TEXT("sndvol32.exe");
      TCHAR     TRACK_TIME_FORMAT[]         = TEXT("%02d%s%02d");
      TCHAR     TRACK_TIME_LEADOUT_FORMAT[] = TEXT("-%02d%s%02d");
      TCHAR     TRACK_REM_FORMAT[]          = TEXT("%02d%s%02d");
      TCHAR     DISC_REM_FORMAT[]           = TEXT("%02d%s%02d");
      TCHAR     DISC_TIME_FORMAT[]           = TEXT("%02d%s%02d");

      TCHAR     g_szSaveSettingsOnExit[]    = TEXT("SaveSettingsOnExit");
      TCHAR     g_szSmallFont[]             = TEXT("SmallFont");
      TCHAR     g_szToolTips[]              = TEXT("ToolTips");
      TCHAR     g_szStopCDPlayingOnExit[]   = TEXT("ExitStop");
      TCHAR     g_szStartCDPlayingOnStart[] = TEXT("StartPlay");
      TCHAR     g_szInOrderPlay[]           = TEXT("InOrderPlay");
      TCHAR     g_szMultiDiscPlay[]         = TEXT("MultiDiscPlay");
      TCHAR     g_szDisplayT[]              = TEXT("DispMode");
      TCHAR     g_szIntroPlay[]             = TEXT("IntroPlay");
      TCHAR     g_szIntroPlayLen[]          = TEXT("IntroTime");
      TCHAR     g_szContinuousPlay[]        = TEXT("ContinuousPlay");
      TCHAR     g_szDiscAndTrackDisplay[]   = TEXT("DiscAndTrackDisplay");
      TCHAR     g_szWindowOriginX[]         = TEXT("WindowOriginX");
      TCHAR     g_szWindowOriginY[]         = TEXT("WindowOriginY");
      TCHAR     g_szWindowOrigin[]          = TEXT("WindowOrigin");
      TCHAR     g_szSettings[]              = TEXT("Settings");
      TCHAR     g_szRandomPlay[]            = TEXT("RandomPlay");
      TCHAR     g_szNothingThere[]          = TEXT("");
      TCHAR     g_szEntryTypeF[]            = TEXT("EntryType=%d");
      TCHAR     g_szArtistF[]               = TEXT("artist=%s");
      TCHAR     g_szTitleF[]                = TEXT("title=%s");
      TCHAR     g_szNumTracksF[]            = TEXT("numtracks=%d");
      TCHAR     g_szOrderF[]                = TEXT("order=");
      TCHAR     g_szNumPlayF[]              = TEXT("numplay=%d");

      TCHAR     g_szEntryType[]             = TEXT("EntryType");
      TCHAR     g_szArtist[]                = TEXT("artist");
      TCHAR     g_szTitle[]                 = TEXT("title");
      TCHAR     g_szNumTracks[]             = TEXT("numtracks");
      TCHAR     g_szOrder[]                 = TEXT("order");
      TCHAR     g_szNumPlay[]               = TEXT("numplay");

      TCHAR     g_szThreeNulls[]            = TEXT("\0\0\0");
      TCHAR     g_szSectionF[]              = TEXT("%lX");

      TCHAR     g_szMusicBoxIni[]           = TEXT("musicbox.ini");
      TCHAR     g_szMusicBoxFormat[]        = TEXT("Track%d");
      TCHAR     g_szPlayList[]              = TEXT("PlayList");
      TCHAR     g_szDiscTitle[]             = TEXT("DiscTitle");

      TCHAR     g_szTextClassName[]         = TEXT("SJE_TextClass");
      TCHAR     g_szLEDClassName[]          = TEXT("SJE_LEDClass");
      TCHAR     g_szAppFontName[]           = TEXT(APP_FONT);
      TCHAR     g_szPlay[]                  = TEXT("PLAY");
      TCHAR     g_szTray[]                  = TEXT("TRAY");
      TCHAR     g_szTrack[]                 = TEXT("TRACK");
      TCHAR     g_szCDA[]                   = TEXT("CDA");
      TCHAR     g_szTrackFormat[]           = TEXT("%d");
      TCHAR     g_szNumbers[]               = TEXT("0123456789");
      TCHAR     g_szColon[]                 = TEXT(":");
      TCHAR     g_szColonBackSlash[]        = TEXT(":\\");

      TCHAR     g_szPlayOption[]            = TEXT("-PLAY ");
      TCHAR     g_szTrackOption[]           = TEXT("-TRACK ");
      TCHAR     g_szCdplayer[]              = TEXT("CDPLAYER ");

      TCHAR     g_chBlank                   = TEXT(' ');
      TCHAR     g_chOptionSlash             = TEXT('/');
      TCHAR     g_chOptionHyphen            = TEXT('-');
      TCHAR     g_chNULL                    = TEXT('\0');

      TCHAR     g_szRegistryKey[]           = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\DeluxeCD\\Settings");
      TCHAR     g_szUpdate[]                = TEXT("UPDATE");
      TCHAR     g_szUpdateOption[]          = TEXT(" -UPDATE ");

      TCHAR     g_szCdPlayerMutex[]         = TEXT("CdPlayerThereCanOnlyBeOne");

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\commands.cpp ===
/******************************Module*Header*******************************\
* Module Name: commands.c
*
* Executes the users commands.
*
*
* Created: 18-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>    /* required for all Windows applications */
#include <windowsx.h>
#include <string.h>
#include <malloc.h>
#include <stdarg.h>
#include <stdio.h>


#include "playres.h"
#include "cdplayer.h"
#include "ledwnd.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"
#include "database.h"
#include "commands.h"


#define PREVTRAK_TIMELIMIT 3 //seconds
extern IMMFWNotifySink* g_pSink;

/******************************Public*Routine******************************\
* CdPlayerEjectCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerEjectCmd(
    void
    )
{
    if (g_State & CD_PAUSED) {
        g_State &= (~(CD_PAUSED_AND_MOVED | CD_PAUSED));
    }

    if (g_State & CD_PLAYING) {
        g_State &= ~CD_PLAYING;
        g_State |= CD_STOPPED;
    }

    if (EjectTheCdromDisc(g_CurrCdrom))
    {
        g_State = (CD_NO_CD | CD_STOPPED);
        SetPlayButtonsEnableState();
        TimeAdjustInitialize( g_CurrCdrom );
        g_pSink->OnEvent(MMEVENT_ONMEDIAUNLOADED,NULL);
    }
}


/******************************Public*Routine******************************\
* CdPlayerPlayCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerPlayCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the play button again.
    */
    if ( LockALLTableOfContents() ) {

        if (g_State & CD_LOADED ) {

            if ((g_State & CD_STOPPED) && PlayCurrTrack( g_CurrCdrom )) {

                g_State &= ~CD_STOPPED;
                g_State |= CD_PLAYING;
            }
            else if ( g_State & CD_PAUSED ) {

                if ( g_State & CD_PAUSED_AND_MOVED ) {

                    g_State &= ~CD_PAUSED_AND_MOVED;
                    g_State |= CD_PLAYING;


                    if ( SeekToCurrSecond( g_CurrCdrom ) ) {

                        g_State &= ~CD_PAUSED;
                        g_State |= CD_PLAYING;
                    }
                    else {

                        g_State &= ~CD_PLAYING;
                    }

                }
                else if ( ResumeTheCdromDrive( g_CurrCdrom ) ) {

                    g_State &= ~CD_PAUSED;
                    g_State |= CD_PLAYING;
                }

                UpdateDisplay( DISPLAY_UPD_LED );
            }

            if (g_State & CD_PLAYING)
            {
                g_pSink->OnEvent(MMEVENT_ONPLAY,NULL);
            }
        }
        else {
#if DBG
            dprintf( TEXT("Failing play because NO disc loaded") );
#endif
        }

        SetPlayButtonsEnableState();
    }
}


/******************************Public*Routine******************************\
* CdPlayerPauseCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerPauseCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the pause button again.
    */
    if ( LockALLTableOfContents() ) {

        if ( g_State & CD_PLAYING )
        {
            if ( PauseTheCdromDrive( g_CurrCdrom ) )
            {
                g_State &= ~CD_PLAYING;
                g_State |= CD_PAUSED;
                g_pSink->OnEvent(MMEVENT_ONPAUSE,NULL);
            }
        }
        else if ( g_State & CD_PAUSED )
        {

            if ( g_State & CD_PAUSED_AND_MOVED ) {

                g_State &= ~CD_PAUSED_AND_MOVED;
                g_State |= CD_PLAYING;


                if ( SeekToCurrSecond( g_CurrCdrom ) ) {

                    g_State &= ~CD_PAUSED;
                    g_State |= CD_PLAYING;
                }
                else {

                    g_State &= ~CD_PLAYING;
                }

            }
            else if ( ResumeTheCdromDrive( g_CurrCdrom ) ) {

                g_State &= ~CD_PAUSED;
                g_State |= CD_PLAYING;
            }

            UpdateDisplay( DISPLAY_UPD_LED );

            if (g_State & CD_PLAYING)
            {
                g_pSink->OnEvent(MMEVENT_ONPLAY,NULL);
            }
        }

        SetPlayButtonsEnableState();
    }
}


/******************************Public*Routine******************************\
* CdPlayerStopCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerStopCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the stop button again.
    */
    if ( LockALLTableOfContents() ) {

        BOOL bPlaying, bPaused;

        bPlaying = g_State & CD_PLAYING;
        bPaused  = g_State & CD_PAUSED;

        if ( (bPlaying || bPaused) && StopTheCdromDrive(g_CurrCdrom) ) {

            g_State &= ~(bPlaying ? CD_PLAYING : CD_PAUSED);
            g_State |= CD_STOPPED;

            /*
            ** Stop the current play operation and seek to the first
            ** playable track.
            */
            CURRTRACK(g_CurrCdrom) = FindFirstTrack( g_CurrCdrom );
            TimeAdjustSkipToTrack( g_CurrCdrom, CURRTRACK(g_CurrCdrom) );

            UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME |
                           DISPLAY_UPD_TRACK_NAME );

            SetPlayButtonsEnableState();


            // Stop it again!!!
            // This is to prevent a strange bug with NEC 4x,6x players
            // Where a SEEK command in TimeAdjustSkipToTrack causes
            // The ejection mechanism to get locked.
            if (StopTheCdromDrive (g_CurrCdrom))
            {
                g_pSink->OnEvent(MMEVENT_ONSTOP,NULL);
            }
        }
    }
}

/******************************Public*Routine******************************\
* CdPlayerPrevTrackCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerPrevTrackCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the previous track button again.
    */
    if ( LockALLTableOfContents() ) {

        DWORD       dwOldState;
        int         i, j;
        PTRACK_PLAY tr;

        if ( (CDTIME(g_CurrCdrom).TrackCurSec <= PREVTRAK_TIMELIMIT)
          && (CDTIME(g_CurrCdrom).TrackCurMin == 0) ) {

            dwOldState = g_State;
            i = g_CurrCdrom;

            tr = FindPrevTrack( g_CurrCdrom, g_fContinuous );

            if ( tr == NULL ) {

                /*
                ** If we were Paused or Playing fake a press on the
                ** "stop" button
                */
                if ( g_State & (CD_PLAYING | CD_PAUSED) ) {
                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                                 WM_LBUTTONDOWN, 0, 0L );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                                 WM_LBUTTONUP, 0, 0L );
                }
            }
            else {

                TimeAdjustSkipToTrack( g_CurrCdrom, tr );

                if ( (i != g_CurrCdrom) && (dwOldState & CD_PLAYING) )
                {
                    j = g_CurrCdrom;
                    g_CurrCdrom = i;

                    //don't allow the ledwnd to paint
                    LockWindowUpdate(g_hwndControls[INDEX(IDC_LED)]);
                    SwitchToCdrom( j, FALSE );
                    LockWindowUpdate(NULL);

                    //switchtocdrom command stopped drive, setting us back to track 1...
                    //reset to correct track
                    TimeAdjustSkipToTrack( g_CurrCdrom, tr );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONDOWN, 0, 0L );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONUP, 0, 0L );
                }
            }
        }
        else {

            TimeAdjustSkipToTrack( g_CurrCdrom, CURRTRACK( g_CurrCdrom ) );
        }
    }
}

/******************************Public*Routine******************************\
* CdPlayerNextTrackCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerNextTrackCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the next track button again.
    */
    if ( LockALLTableOfContents() ) {

        DWORD       dwOldState;
        PTRACK_PLAY tr;

        dwOldState = g_State;

        tr = FindNextTrack( g_fContinuous );
        if ( tr == NULL ) {

            /*
            ** If the CD is playing fake a press on the "stop" button
            ** otherwise call the stop function directly.
            */
            if ( g_State & (CD_PLAYING | CD_PAUSED) ) {
                SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                             WM_LBUTTONDOWN, 0, 0L );

                SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                             WM_LBUTTONUP, 0, 0L );
            }
            else {

                /*
                ** Seek to the first playable track.
                */
                CURRTRACK(g_CurrCdrom) = FindFirstTrack( g_CurrCdrom );
                if (CURRTRACK(g_CurrCdrom) != NULL ) {

                    TimeAdjustSkipToTrack( g_CurrCdrom,
                                           CURRTRACK(g_CurrCdrom) );
                    UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME |
                                   DISPLAY_UPD_TRACK_NAME );

                    SetPlayButtonsEnableState();
                }

            }
        }
        else {

            if ( g_LastCdrom != g_CurrCdrom) {

                SwitchToCdrom( g_CurrCdrom,FALSE);
                TimeAdjustSkipToTrack( g_CurrCdrom, tr );

                if ( dwOldState & CD_PLAYING ) {

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONDOWN, 0, 0L );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONUP, 0, 0L );
                }

            }
            else {

                TimeAdjustSkipToTrack( g_CurrCdrom, tr );
            }
        }
    }
}


/******************************Public*Routine******************************\
* CdPlayerSeekCmd
*
* How Seek works.
*
* When the user presses a seek button (forwards or backwards) this function
* gets called.  The cdplayer can be in three possible states:
*
*   1. Playing
*   2. Paused
*   3. Stopped
*
* In state 1 (playing) we pause the device and alter its global state flags
* to show that it was playing (CD_WAS_PLAYING).  This is so that we can
* return to the playing state when the user stops seeking.
*
* We then start a timer.  We always call the timer function, this means
* that we will allways skip one second no matter how quickly the user
* clicks the seek button.  The timer just increments (or decrements) the
* current play position according to the currrent play list.  When the users
* releases the seek button we stop the timer and resume playing if the
* CD_WAS_PLAYING flag was set.
*
* The interesting case is when we try to seek beyond the end of the current
* play list.  We detect this by testing the state of CURRTRACK(g_CurrCdrom).
* If NULL we have come to the end of the play list.  If we were paused or
* previously playing we fake a stop command by sending a WM_LBUTTONDOWN,
* WM_LBUTTONUP message pair to the stop button.   This causes the focus
* to be moved from the currently pressed seek button, which means that
* this function will get called BEFORE the CdPlayerStopCmd function.  So
* by the time CdPlayerStopCmd gets called the correct playing state of
* the cdrom device would have been restored by the code below.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerSeekCmd(
    HWND    hwnd,
    BOOL    fStart,
    UINT    uDirection
    )
{
    UINT_PTR    rc;
    BOOL        frc;

    if ( fStart ) {

        if (g_State & CD_PLAYING) {

            g_State &= ~CD_PLAYING;
            g_State |= CD_WAS_PLAYING;

            PauseTheCdromDrive( g_CurrCdrom );
        }
        g_State |= CD_SEEKING;

        rc = SetTimer( hwnd, uDirection, SKIPBEAT_TIMER_RATE,
                       (TIMERPROC)SkipBeatTimerProc );
        ASSERT(rc != 0);

        SkipBeatTimerProc( hwnd, WM_TIMER, uDirection, 0L );
    }
    else {

        g_State &= ~CD_SEEKING;

        if (g_State & CD_WAS_PLAYING) {

            g_State &= ~CD_WAS_PLAYING;
            g_State |= CD_PLAYING;
        }

        if ( g_State & CD_PAUSED ) {
            g_State |= CD_PAUSED_AND_MOVED;
        }
        else {

           SeekToCurrSecond( g_CurrCdrom );
        }

        frc = KillTimer( hwnd, uDirection );
        ASSERT(frc != FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\literals.h ===
/******************************Module*Header*******************************\
* Module Name: literals.c
*
* Global string variables that don't need converting for international builds.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/
#define NOUSER
#define NOGDI
#define NOOLE
//#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

extern       TCHAR     g_szEmpty[];
extern       TCHAR     g_IniFileName[];
extern       TCHAR     g_HelpFileName[];

extern const TCHAR     g_szBlank[];
extern const TCHAR     g_szSJE_CdPlayerClass[];
extern const TCHAR     g_szSndVol32[];
extern const TCHAR     TRACK_TIME_FORMAT[];
extern const TCHAR     TRACK_TIME_LEADOUT_FORMAT[];
extern const TCHAR     TRACK_REM_FORMAT[];
extern const TCHAR     DISC_REM_FORMAT[];
extern const TCHAR     DISC_TIME_FORMAT[];

extern       TCHAR     g_szSaveSettingsOnExit[];
extern       TCHAR     g_szSmallFont[];
extern       TCHAR     g_szStopCDPlayingOnExit[];
extern       TCHAR     g_szStartCDPlayingOnStart[];
extern       TCHAR     g_szInOrderPlay[];
extern       TCHAR     g_szMultiDiscPlay[];
extern       TCHAR     g_szDisplayT[];
extern       TCHAR     g_szDisplayTr[];
extern       TCHAR     g_szDisplayDr[];
extern       TCHAR     g_szIntroPlay[];
extern       TCHAR     g_szIntroPlayLen[];
extern       TCHAR     g_szContinuousPlay[];
extern       TCHAR     g_szDiscAndTrackDisplay[];
extern       TCHAR     g_szWindowOriginX[];
extern       TCHAR     g_szWindowOriginY[];
extern       TCHAR     g_szWindowOrigin[];
extern       TCHAR     g_szSettings[];
extern       TCHAR     g_szRandomPlay[];
extern const TCHAR     g_szNothingThere[];
extern       TCHAR     g_szEntryTypeF[];
extern       TCHAR     g_szArtistF[];
extern       TCHAR     g_szTitleF[];
extern       TCHAR     g_szNumTracksF[];
extern       TCHAR     g_szOrderF[];
extern       TCHAR     g_szNumPlayF[];

extern       TCHAR     g_szEntryType[];
extern       TCHAR     g_szArtist[];
extern       TCHAR     g_szTitle[];
extern       TCHAR     g_szNumTracks[];
extern       TCHAR     g_szOrder[];
extern       TCHAR     g_szNumPlay[];

extern       TCHAR     g_szThreeNulls[];
extern       TCHAR     g_szSectionF[];

extern const TCHAR     g_szMusicBoxIni[];
extern const TCHAR     g_szMusicBoxFormat[];
extern const TCHAR     g_szPlayList[];
extern const TCHAR     g_szDiscTitle[];

extern const TCHAR     g_szTextClassName[];
extern const TCHAR     g_szLEDClassName[];
extern const TCHAR     g_szAppFontName[];
extern const TCHAR     g_szPlay[];
extern const TCHAR     g_szTray[];
extern const TCHAR     g_szTrack[];
extern const TCHAR     g_szCDA[];
extern const TCHAR     g_szTrackFormat[];
extern const TCHAR     g_szNumbers[];
extern const TCHAR     g_szColon[];
extern const TCHAR     g_szColonBackSlash[];

extern const TCHAR     g_szPlayOption[];
extern const TCHAR     g_szTrackOption[];
extern const TCHAR     g_szCdplayer[];

extern const TCHAR     g_chBlank;
extern const TCHAR     g_chOptionSlash;
extern const TCHAR     g_chOptionHyphen;
extern const TCHAR     g_chNULL;

extern const TCHAR     g_szRegistryKey[];

extern const TCHAR     g_szUpdate[];
extern const TCHAR     g_szUpdateOption[];

extern const TCHAR     g_szCdPlayerMutex[];

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\mmcomp.cpp ===
// MMComp.cpp : Implementation of DLL Exports.


#include "windows.h"
#include "playres.h"
#include "objbase.h"
#include "initguid.h"
#include "cdplay.h"
#include "tchar.h"

HINSTANCE g_dllInst = NULL;

const CLSID CLSID_CDPlay = {0xE5927147,0x521E,0x11D1,{0x9B,0x97,0x00,0xC0,0x4F,0xA3,0xB6,0x0E}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\dib.cpp ===
/*----------------------------------------------------------------------------*\
|   Routines for dealing with Device independent bitmaps                       |
|                                                                              |
|   History:                                                                   |
|       06/23/89 toddla     Created                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/

#include <windows.h>
#include <stdio.h>
#include "dib.h"

#define HUGE_T

/*
 *   Open a DIB file and return a MEMORY DIB, a memory handle containing..
 *
 *   BITMAP INFO    bi
 *   palette data
 *   bits....
 *
 */
HANDLE OpenDIB(LPTSTR szFile, HFILE fh)
{
    BITMAPINFOHEADER    bi;
    LPBITMAPINFOHEADER  lpbi;
    DWORD               dwLen;
    DWORD               dwBits;
    HANDLE              hdib;
    HANDLE              h;
#ifndef UNICODE
    OFSTRUCT            of;
#endif
    BOOL fOpened = FALSE;

    if (szFile != NULL)
    {
    #ifdef UNICODE
	    fh = (HFILE)HandleToUlong(CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ,
			     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    #else
	    fh = OpenFile(szFile, &of, OF_READ);
    #endif
	    fOpened = TRUE;
    }

    if (fh == -1)
	return NULL;

    hdib = ReadDibBitmapInfo(fh);

    if (!hdib)
	return NULL;

    DibInfo((LPBITMAPINFOHEADER)GlobalLock(hdib),&bi);  GlobalUnlock(hdib);

    /* How much memory do we need to hold the DIB */

    dwBits = bi.biSizeImage;
    dwLen  = bi.biSize + PaletteSize(&bi) + dwBits;

    /* Can we get more memory? */

    h = GlobalReAlloc(hdib,dwLen,GMEM_MOVEABLE);

    if (!h)
    {
	    GlobalFree(hdib);
	    hdib = NULL;
    }
    else
    {
    	hdib = h;
    }

    if (hdib)
    {
	    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

	    /* read in the bits */
	    _lread(fh, (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi), dwBits);

	    GlobalUnlock(hdib);
    }

    if (fOpened)
	_lclose(fh);

    return hdib;
}

/*
 *  DibInfo(hbi, lpbi)
 *
 *  retrives the DIB info associated with a CF_DIB format memory block.
 */
BOOL  DibInfo(LPBITMAPINFOHEADER lpbiSource, LPBITMAPINFOHEADER lpbiTarget)
{
    if (lpbiSource)
    {
	*lpbiTarget = *lpbiSource;

	if (lpbiTarget->biSize == sizeof(BITMAPCOREHEADER))
	{
	    BITMAPCOREHEADER bc;

	    bc = *(LPBITMAPCOREHEADER)lpbiTarget;

	    lpbiTarget->biSize               = sizeof(BITMAPINFOHEADER);
	    lpbiTarget->biWidth              = (DWORD)bc.bcWidth;
	    lpbiTarget->biHeight             = (DWORD)bc.bcHeight;
	    lpbiTarget->biPlanes             =  (UINT)bc.bcPlanes;
	    lpbiTarget->biBitCount           =  (UINT)bc.bcBitCount;
	    lpbiTarget->biCompression        = BI_RGB;
	    lpbiTarget->biSizeImage          = 0;
	    lpbiTarget->biXPelsPerMeter      = 0;
	    lpbiTarget->biYPelsPerMeter      = 0;
	    lpbiTarget->biClrUsed            = 0;
	    lpbiTarget->biClrImportant       = 0;
	}

	/*
	 * fill in the default fields
	 */
	if (lpbiTarget->biSize != sizeof(BITMAPCOREHEADER))
	{
	    if (lpbiTarget->biSizeImage == 0L)
		lpbiTarget->biSizeImage = (DWORD)DIBWIDTHBYTES(*lpbiTarget) * lpbiTarget->biHeight;

	    if (lpbiTarget->biClrUsed == 0L)
		lpbiTarget->biClrUsed = DibNumColors(lpbiTarget);
	}
	return TRUE;
    }
    return FALSE;
}

/*
 *  ReadDibBitmapInfo()
 *
 *  Will read a file in DIB format and return a global HANDLE to it's
 *  BITMAPINFO.  This function will work with both "old" and "new"
 *  bitmap formats, but will always return a "new" BITMAPINFO
 *
 */
HANDLE ReadDibBitmapInfo(HFILE fh)
{
    DWORD     off;
    HANDLE    hbi = NULL;
    int       size;
    int       i;
    UINT      nNumColors;

    RGBQUAD FAR       *pRgb;
    BITMAPINFOHEADER   bi;
    BITMAPCOREHEADER   bc;
    LPBITMAPINFOHEADER lpbi;
    BITMAPFILEHEADER   bf;

    if (fh == -1)
	return NULL;

    off = _llseek(fh,0L,SEEK_CUR);

    if (sizeof(bf) != _lread(fh,(LPBYTE)&bf,sizeof(bf)))
	return FALSE;

    /*
     *  do we have a RC HEADER?
     */
    if (!ISDIB(bf.bfType))
    {
	bf.bfOffBits = 0L;
	_llseek(fh,off,SEEK_SET);
    }

    if (sizeof(bi) != _lread(fh,(LPBYTE)&bi,sizeof(bi)))
	return FALSE;

    nNumColors = DibNumColors(&bi);

    /*
     *  what type of bitmap info is this?
     */
    switch (size = (int)bi.biSize)
    {
	case sizeof(BITMAPINFOHEADER):
	    break;

	case sizeof(BITMAPCOREHEADER):
	    bc = *(BITMAPCOREHEADER*)&bi;
	    bi.biSize               = sizeof(BITMAPINFOHEADER);
	    bi.biWidth              = (DWORD)bc.bcWidth;
	    bi.biHeight             = (DWORD)bc.bcHeight;
	    bi.biPlanes             =  (UINT)bc.bcPlanes;
	    bi.biBitCount           =  (UINT)bc.bcBitCount;
	    bi.biCompression        = BI_RGB;
	    bi.biSizeImage          = 0;
	    bi.biXPelsPerMeter      = 0;
	    bi.biYPelsPerMeter      = 0;
	    bi.biClrUsed            = nNumColors;
	    bi.biClrImportant       = nNumColors;

	    _llseek(fh,(LONG)(sizeof(BITMAPCOREHEADER)-sizeof(BITMAPINFOHEADER)),SEEK_CUR);

	    break;

	default:
	    return NULL;       /* not a DIB */
    }

    /*
     *  fill in some default values!
     */
    if (bi.biSizeImage == 0)
    {
	bi.biSizeImage = (DWORD)DIBWIDTHBYTES(bi) * bi.biHeight;
    }

    if (bi.biXPelsPerMeter == 0)
    {
	bi.biXPelsPerMeter = 0;         // ??????????????
    }

    if (bi.biYPelsPerMeter == 0)
    {
	bi.biYPelsPerMeter = 0;         // ??????????????
    }

    if (bi.biClrUsed == 0)
    {
	bi.biClrUsed = DibNumColors(&bi);
    }

    hbi = GlobalAlloc(GMEM_MOVEABLE,(LONG)bi.biSize + nNumColors * sizeof(RGBQUAD));
    if (!hbi)
	return NULL;

    lpbi = (BITMAPINFOHEADER *)GlobalLock(hbi);
    *lpbi = bi;

    pRgb = (RGBQUAD FAR *)((LPBYTE)lpbi + bi.biSize);

    if (nNumColors)
    {
	if (size == (int)sizeof(BITMAPCOREHEADER))
	{
	    /*
	     * convert a old color table (3 byte entries) to a new
	     * color table (4 byte entries)
	     */
	    _lread(fh,(LPBYTE)pRgb,nNumColors * sizeof(RGBTRIPLE));

	    for (i=nNumColors-1; i>=0; i--)
	    {
		RGBQUAD rgb;

		rgb.rgbRed      = ((RGBTRIPLE FAR *)pRgb)[i].rgbtRed;
		rgb.rgbBlue     = ((RGBTRIPLE FAR *)pRgb)[i].rgbtBlue;
		rgb.rgbGreen    = ((RGBTRIPLE FAR *)pRgb)[i].rgbtGreen;
		rgb.rgbReserved = (BYTE)0;

		pRgb[i] = rgb;
	    }
	}
	else
	{
	    _lread(fh,(LPBYTE)pRgb,nNumColors * sizeof(RGBQUAD));
	}
    }

    if (bf.bfOffBits != 0L)
	_llseek(fh,off + bf.bfOffBits,SEEK_SET);

    GlobalUnlock(hbi);
    return hbi;
}

/*  How big is the palette? if bits per pel not 24
 *  no of bytes to read is 6 for 1 bit, 48 for 4 bits
 *  256*3 for 8 bits and 0 for 24 bits
 */
UINT PaletteSize(VOID FAR * pv)
{
    #define lpbi ((LPBITMAPINFOHEADER)pv)
    #define lpbc ((LPBITMAPCOREHEADER)pv)

    UINT    NumColors;

    NumColors = DibNumColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	return NumColors * sizeof(RGBTRIPLE);
    else
	return NumColors * sizeof(RGBQUAD);

    #undef lpbi
    #undef lpbc
}

/*  How Many colors does this DIB have?
 *  this will work on both PM and Windows bitmap info structures.
 */
UINT DibNumColors(VOID FAR * pv)
{
    #define lpbi ((LPBITMAPINFOHEADER)pv)
    #define lpbc ((LPBITMAPCOREHEADER)pv)

    int bits;

    /*
     *  with the new format headers, the size of the palette is in biClrUsed
     *  else is dependent on bits per pixel
     */
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
    {
	if (lpbi->biClrUsed != 0)
	    return (UINT)lpbi->biClrUsed;

	bits = lpbi->biBitCount;
    }
    else
    {
	bits = lpbc->bcBitCount;
    }

    switch (bits)
    {
    case 1:
	    return 2;
    case 4:
	    return 16;
    case 8:
	    return 256;
    default:
	    return 0;
    }

    #undef lpbi
    #undef lpbc
}

/*
 *  DibFromBitmap()
 *
 *  Will create a global memory block in DIB format that represents the DDB
 *  passed in
 *
 */
HANDLE DibFromBitmap(HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage)
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dwLen;
    int                  nColors;
    HANDLE               hdib;
    HANDLE               h;
    HDC                  hdc;

    if (wUsage == 0)
	wUsage = DIB_RGB_COLORS;

    if (!hbm)
	return NULL;
    if (hpal == NULL)
	hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    GetObject(hbm,sizeof(bm),(LPBYTE)&bm);
#ifdef WIN32
    nColors = 0;  // GetObject only stores two bytes
#endif
    GetObject(hpal,sizeof(nColors),(LPBYTE)&nColors);

    if (biBits == 0)
	biBits = bm.bmPlanes * bm.bmBitsPixel;

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = biStyle;
    bi.biSizeImage          = 0;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = 0;
    bi.biClrImportant       = 0;

    dwLen  = bi.biSize + PaletteSize(&bi);

    hdc = CreateCompatibleDC(NULL);
    hpal = SelectPalette(hdc,hpal,TRUE);
    RealizePalette(hdc);  // why is this needed on a MEMORY DC? GDI bug??

    hdib = GlobalAlloc(GMEM_MOVEABLE,dwLen);

    if (!hdib)
	goto exit;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    *lpbi = bi;

    /*
     *  call GetDIBits with a NULL lpBits param, so it will calculate the
     *  biSizeImage field for us
     */
    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
	NULL, (LPBITMAPINFO)lpbi, wUsage);

    bi = *lpbi;
    GlobalUnlock(hdib);

    /*
     * HACK! if the driver did not fill in the biSizeImage field, make one up
     */
    if (bi.biSizeImage == 0)
    {
	bi.biSizeImage = (DWORD)WIDTHBYTES(bm.bmWidth * biBits) * bm.bmHeight;

	if (biStyle != BI_RGB)
	    bi.biSizeImage = (bi.biSizeImage * 3) / 2;
    }

    /*
     *  realloc the buffer big enough to hold all the bits
     */
    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;
    if (h = GlobalReAlloc(hdib,dwLen,GMEM_MOVEABLE))
    {
	hdib = h;
    }
    else
    {
	GlobalFree(hdib);
	hdib = NULL;
	goto exit;
    }

    /*
     *  call GetDIBits with a NON-NULL lpBits param, and actualy get the
     *  bits this time
     */
    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
	(LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi),
	(LPBITMAPINFO)lpbi, wUsage);

    bi = *lpbi;
    lpbi->biClrUsed = DibNumColors(lpbi) ;
    GlobalUnlock(hdib);

exit:
    SelectPalette(hdc,hpal,TRUE);
    DeleteDC(hdc);
    return hdib;
}


/*
 *  DibBlt()
 *
 *  draws a bitmap in CF_DIB format, using SetDIBits to device.
 *
 *  takes the same parameters as BitBlt()
 */
BOOL DibBlt(HDC hdc, int x0, int y0, int dx, int dy, HANDLE hdib, int x1, int y1, LONG rop, UINT wUsage)
{
    LPBITMAPINFOHEADER lpbi;
    LPBYTE       pBuf;
    BOOL        f;

    if (!hdib)
	return PatBlt(hdc,x0,y0,dx,dy,rop);

    if (wUsage == 0)
	wUsage = DIB_RGB_COLORS;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    if (!lpbi)
	return FALSE;

    if (dx == -1 && dy == -1)
    {
	if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	{
	    dx = ((LPBITMAPCOREHEADER)lpbi)->bcWidth;
	    dy = ((LPBITMAPCOREHEADER)lpbi)->bcHeight;
	}
	else
	{
	    dx = (int)lpbi->biWidth;
	    dy = (int)lpbi->biHeight;
	}
    }

    pBuf = (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi);


    f = StretchDIBits (
	hdc,
	x0,y0,
	dx,dy,
	x1,y1,
	dx,dy,
	pBuf, (LPBITMAPINFO)lpbi,
	wUsage,
	rop);

    GlobalUnlock(hdib);
    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\trklst.h ===
/******************************Module*Header*******************************\
* Module Name: trklst.h
*
* This module manipulates the cdrom track list.  The table of contents MUST
* be locked for ALL cdrom devices before calling any functions in this module.
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

void
ComputeDriveComboBox(
    void
    );

void
SwitchToCdrom(
    int NewCdrom,
    BOOL prompt
    );

PTRACK_INF
FindTrackNodeFromTocIndex(
    int tocindex,
    PTRACK_INF listhead
    );

PTRACK_PLAY
FindFirstTrack(
    int cdrom
    );

PTRACK_PLAY
FindLastTrack(
    IN INT cdrom
    );

BOOL
AllTracksPlayed(
    void
    );

PTRACK_PLAY
FindNextTrack(
    BOOL wrap
    );

PTRACK_PLAY
FindPrevTrack(
    int cdrom,
    BOOL wrap
    );

int
FindContiguousEnd(
    int cdrom,
    PTRACK_PLAY tr
    );

void
FlipBetweenShuffleAndOrder(
    void
    );

void
ComputeAndUseShufflePlayLists(
    void
    );

void
ComputeSingleShufflePlayList(
    int i
    );

void
RestorePlayListsFromShuffleLists(
    void
    );

void
FigureTrackTime(
    int cdrom,
    int index,
    int * min,
    int * sec
    );

void
TimeAdjustInitialize(
    int cdrom
    );

void
TimeAdjustIncSecond(
    int cdrom
    );

void
TimeAdjustDecSecond(
    int cdrom
    );

void
InitializeNewTrackTime(
    int cdrom,
    PTRACK_PLAY tr,
    BOOL fUpdateDisplay
    );

void
TimeAdjustSkipToTrack(
    int cdrom,
    PTRACK_PLAY tr
    );

void
SyncDisplay(
    void
    );

void
ValidatePosition(
    int cdrom
    );

VOID
ResetTrackComboBox(
    int cdrom
    );

BOOL
PlayListMatchesAvailList(
    void
    );

void
AddTemporaryTrackToPlayList(
    PCURRPOS pCurr
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\scan.h ===
/******************************Module*Header*******************************\
* Module Name: scan.h
*
*
*
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#define TRACK_TYPE_MASK 0x04
#define AUDIO_TRACK     0x00
#define DATA_TRACK      0x04


typedef struct {
    HWND    hwndNotify;
    int     cdrom;
} TOC_THREAD_PARMS;

int
ScanForCdromDevices(
    void
    );

void
ScanningThread(
    HWND hwndDlg
    );

BOOL CALLBACK
ScaningDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

void RescanDevice(
    HWND hwndNotify,
    int cdrom
    );

void
ReadTableOfContents(
    TOC_THREAD_PARMS *pTocThrdParms
    );

void
TableOfContentsThread(
    TOC_THREAD_PARMS *pTocThrdParms
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\dib.h ===
/*----------------------------------------------------------------------------*\
|   Routines for dealing with Device independent bitmaps                       |
|									       |
|   History:                                                                   |
|       06/23/89 toddla     Created                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/

HANDLE      OpenDIB(LPTSTR szFile, HFILE fh);
BOOL        WriteDIB(LPTSTR szFile, HFILE fh, HANDLE hdib);
UINT        PaletteSize(VOID FAR * pv);
WORD        DibNumColors(VOID FAR * pv);
HPALETTE    CreateDibPalette(HANDLE hdib);
HPALETTE    CreateBIPalette(LPBITMAPINFOHEADER lpbi);
HPALETTE    CreateExplicitPalette(void);
HPALETTE    CreateColorPalette(void);
HANDLE      DibFromBitmap(HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage);
HANDLE      DibFromDib(HANDLE hdib, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage);
HBITMAP     BitmapFromDib(HANDLE hdib, HPALETTE hpal, UINT wUsage);
BOOL        SetDibUsage(HANDLE hdib, HPALETTE hpal,UINT wUsage);
BOOL        DibInfo(LPBITMAPINFOHEADER lpbiSource, LPBITMAPINFOHEADER lpbiTarget);
HANDLE      ReadDibBitmapInfo(HFILE fh);
BOOL        SetPalFlags(HPALETTE hpal, int iIndex, int cntEntries, UINT wFlags);

BOOL        DrawBitmap(HDC hdc, int x, int y, HBITMAP hbm, DWORD rop);
BOOL        StretchBitmap(HDC hdc, int x, int y, int dx, int dy, HBITMAP hbm, int x0, int y0, int dx0, int dy0, DWORD rop);

BOOL        DibBlt(HDC hdc, int x0, int y0, int dx, int dy, HANDLE hdib, int x1, int y1, LONG rop, UINT wUsage);
BOOL        StretchDibBlt(HDC hdc, int x, int y, int dx, int dy, HANDLE hdib, int x0, int y0, int dx0, int dy0, LONG rop,  UINT wUsage);

LPVOID      DibLock(HANDLE hdib,int x, int y);
VOID        DibUnlock(HANDLE hdib);
LPVOID      DibXY(LPBITMAPINFOHEADER lpbi,int x, int y);
HANDLE      CreateDib(WORD bits, int dx, int dy);

#define BFT_ICON   0x4349   /* 'IC' */
#define BFT_BITMAP 0x4d42   /* 'BM' */
#define BFT_CURSOR 0x5450   /* 'PT' */

#define ISDIB(bft) ((bft) == BFT_BITMAP)
#define ALIGNULONG(i)     ((i+3)/4*4)        /* ULONG aligned ! */
#define WIDTHBYTES(i)     ((i+31)/32*4)      /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)

#define PALVERSION      0x300
#define MAXPALETTE      256
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\frame.h ===
#ifndef BUILD_FRAME_H
#define BUILD_FRAME_H

#define VIEW_MODE_NORMAL  0
#define VIEW_MODE_RESTORE 1
#define VIEW_MODE_SMALL   2
#define VIEW_MODE_NOBAR   3

HANDLE BuildFrameBitmap(HDC hDC,            //dc to be compatible with
                        LPRECT pMainRect,   //overall window size
                        LPRECT pViewRect,   //rect of black viewport window,
                                            //where gradient should begin,
                                            //with 0,0 as top left of main
                        int nViewMode,      //if in normal, restore, small
                        LPPOINT pSysMenuPt, //point where sys menu icon is placed
                        LPRECT pSepRects,   //array of rects for separator bars
                        int nNumSeps,       //number of separtors in array
                        BITMAP* pBM);       //bitmap info

#endif //BUILD_FRAME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\img.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1996-1997 Microsoft Corporation. All Rights Reserved.
//
//  File: iimgctx.h
//
//--------------------------------------------------------------------------

#ifndef _IImgCtxObjects_H_
#define _IImgCtxObjects_H_

#ifdef __cplusplus
extern "C" {
#endif
typedef void (CALLBACK *PFNIMGCTXCALLBACK)(void *, void *);
#ifdef __cplusplus
}
#endif

#define IMGCHG_SIZE         0x0001
#define IMGCHG_VIEW         0x0002
#define IMGCHG_COMPLETE     0x0004
#define IMGCHG_ANIMATE      0x0008
#define IMGCHG_MASK         0x000F

#define IMGLOAD_NOTLOADED   0x00100000  // Image has not yet been loaded
#define IMGLOAD_LOADING     0x00200000  // Image in the process of being loaded
#define IMGLOAD_STOPPED     0x00400000  // Imaged aborted
#define IMGLOAD_ERROR       0x00800000  // Error loading image
#define IMGLOAD_COMPLETE    0x01000000  // Image loaded
#define IMGLOAD_MASK        0x01F00000

#define IMGBITS_NONE        0x02000000
#define IMGBITS_PARTIAL     0x04000000
#define IMGBITS_TOTAL       0x08000000
#define IMGBITS_MASK        0x0E000000

#define IMGANIM_ANIMATED    0x10000000
#define IMGANIM_MASK        0x10000000

#define IMGTRANS_OPAQUE     0x20000000
#define IMGTRANS_MASK       0x20000000

#define DWN_COLORMODE       0x0000003F  // Explicit color mode requested
#define DWN_DOWNLOADONLY    0x00000040  // Download data only, don't decode
#define DWN_FORCEDITHER     0x00000080  // Override automatic dithering
#define DWN_RAWIMAGE        0x00000100  // Disable dithering 

/* Definition of interface: IImgCtx */
#undef INTERFACE
#define INTERFACE IImgCtx

// {3050f3d7-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_IImgCtx, 0x3050f3d7, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

DECLARE_INTERFACE_(IImgCtx, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IImgCtx methods */

    /* Initialization/Download methods */
    STDMETHOD(Load)(THIS_ LPCWSTR pszUrl, DWORD dwFlags) PURE;
    STDMETHOD(SelectChanges)(THIS_ ULONG ulChgOn, ULONG ulChgOff, BOOL fSignal) PURE;
    STDMETHOD(SetCallback)(THIS_ PFNIMGCTXCALLBACK pfn, void * pvPrivateData) PURE;
    STDMETHOD(Disconnect)(THIS) PURE;

	/* Query methods */
    STDMETHOD(GetUpdateRects)(THIS_ struct tagRECT FAR* prc, struct tagRECT FAR* prcImg, long FAR* pcrc) PURE;
    STDMETHOD(GetStateInfo)(THIS_ ULONG FAR* pulState, struct tagSIZE FAR* psize, BOOL fClearChanges) PURE;
    STDMETHOD(GetPalette)(THIS_ HPALETTE FAR* phpal) PURE;

    /* Rendering methods */
    STDMETHOD(Draw)(THIS_ HDC hdc, struct tagRECT FAR* prcBounds) PURE;
    STDMETHOD(Tile)(THIS_ HDC hdc, struct tagPOINT FAR* pptBackOrg, struct tagRECT FAR* prcClip, struct tagSIZE FAR* psize) PURE;
    STDMETHOD(StretchBlt)(THIS_ HDC hdc, int dstX, int dstY, int dstXE, int dstYE, int srcX, int srcY, int srcXE, int srcYE, DWORD dwROP) PURE;
};

#ifdef COBJMACROS


#define IImgCtx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImgCtx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImgCtx_Release(This)	\
    (This)->lpVtbl -> Release(This)

#define IImgCtx_Load(This, pszUrl, dwFlags)	\
	(This)->lpVtbl -> Load(This, pszUrl, dwFlags)

#define IImgCtx_Draw(This, hdc, prcBounds)		\
	(This)->lpVtbl -> Draw(This, hdc, prcBounds)

#define IImgCtx_Tile(This, hdc, pptBackOrg, prcClip, psize)		\
	(This)->lpVtbl -> Tile(This, hdc, pptBackOrg, prcClip, psize)

#define IImgCtx_GetUpdateRects(This, prc, prcImg, pcrc)	\
	(This)->lpVtbl -> GetUpdateRects(This, prc, prcImg, pcrc)

#define IImgCtx_GetStateInfo(This, pulState, psize, fClearChanges)	\
	(This)->lpVtbl -> GetStateInfo(This, pulState, psize, fClearChanges)

#define IImgCtx_GetPalette(This, phpal)	\
	(This)->lpVtbl -> GetPalette(This, phpal)
	
#define IImgCtx_SelectChanges(This, ulChgOn, ulChgOff, fSignal)	\
	(This)->lpVtbl -> SelectChanges(This, ulChgOn, ulChgOff, fSignal)

#define IImgCtx_SetCallback(This, pfnCallback, pvPrivateData)	\
	(This)->lpVtbl -> SetCallback(This, pfnCallback, pvPrivateData)

#define IImgCtx_Disconnect(This) \
    (This)->lpVtbl -> Disconnect(This)

#define IImgCtx_StretchBlt(This, hdc, dstX, dstY, dstXE, dstYE, srcX, srcY, srcXE, srcYE, dwROP)   \
    (This)->lpVtbl -> StretchBlt(This, hdc, dstX, dstY, dstXE, dstYE, srcX, srcY, srcXE, srcYE, dwROP)

#endif /* COBJMACROS */


// {3050f3d6-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_IImgCtx, 0x3050f3d6, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\ledwnd.h ===
/******************************Module*Header*******************************\
* Module Name: ledwnd.h
*
* Public interface to the LED window implementation
*
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

BOOL
InitLEDClass(
    HINSTANCE hInst
    );

LRESULT CALLBACK
LEDWndProc(
    HWND hwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
Init_SJE_TextClass(
    HINSTANCE hInst
    );


#ifdef DECLARE_DATA
BYTE cr[] = {
    0x8D, 0x8B, 0x8F, 0x89, 0xA9, 0xA5, 0xC5, 0xC3,
    0xA8, 0xD9, 0xE6, 0xEA, 0xF5, 0xE8, 0xFC, 0xAF,
    0xF4, 0xF4, 0xE4, 0xF6, 0xF8, 0xFA, 0xE6, 0xF2,
    0xFC, 0xB9, 0xF8, 0xE2, 0xBC, 0xB0, 0x93, 0x95,
    0xAD, 0xAB, 0xF1, 0xD7, 0xC1, 0xD5, 0xCE, 0xC2,
    0xC6, 0x89, 0xEF, 0xD8, 0xD8, 0xDF, 0xC1, 0xDF,
    0xBD, 0xBB, 0xBF, 0xB9, 0xB9, 0xBF, 0x9B, 0x97,
    0xCC, 0xDC, 0xC9, 0xCF, 0xD9, 0xD9, 0x9E, 0xDD,
    0xB9, 0xE1, 0xEF, 0xCE, 0xCE, 0xC8, 0xCC, 0x8D,
    0xA7, 0xA1, 0xA4, 0xEB, 0x8E, 0xBF, 0xAB, 0xBC,
    0xB5, 0xBC, 0xB3, 0xBD, 0xBA, 0xD8, 0xDC, 0x96,
    0xB6, 0xBD, 0xA8, 0xBE, 0xAB, 0xFD, 0x99, 0xAA,
    0x99, 0xEC, 0xE8, 0xA2, 0x8A, 0x91, 0x8E, 0x88,
    0x86, 0x90, 0xCA, 0xBB, 0x84, 0x84, 0x82, 0x83,
    0x99, 0x81, 0x81, 0xFE, 0xFE, 0xBF, 0x99, 0x9F,
    0x96, 0xD9, 0xAB, 0x8E, 0x95, 0x9E, 0x95, 0xF2,
    0x8A, 0xCC, 0xEB, 0xE8, 0xE1, 0xA5, 0xD2, 0xF5,
    0xE1, 0xEA, 0xE1, 0xEE, 0xFE, 0x80, 0x84, 0x82,
    0x9A, 0x9C, 0x98, 0xBE, 0xB4, 0xF8, 0xF7, 0xF9,
    0xF9, 0xFE, 0xFF, 0xFF, 0xBC, 0xFF, 0xE7, 0xBF,
    0x8D, 0xAC, 0xA8, 0xAE, 0xAE, 0xE9, 0xC7, 0xD2,
    0xDA, 0xC0, 0xCF, 0x8B, 0xEB, 0xDF, 0xC7, 0xC9,
    0xD6, 0xD8, 0xC6, 0xDB, 0xC7, 0xB8, 0xBC, 0xBA,
    0xB2, 0xB4, 0xB0, 0x96, 0x9C, 0xCD, 0xCC, 0xD0,
    0xA4, 0xB4, 0xA1, 0xB7, 0xAD, 0xAA, 0xA8, 0xE7,
    0xE5, 0xC4, 0xC0, 0xC6, 0xC6, 0x8C, 0xA2, 0xA6,
    0xA3, 0xA5, 0xB3, 0xBA, 0xA6, 0xF5, 0x94, 0xB6,
    0xB6, 0xB2, 0xA9, 0xD6, 0xD6, 0x9E, 0xAC, 0xB6,
    0x93, 0x95, 0x8B, 0x82, 0x8A, 0x8A, 0xC6, 0xB7,
    0x81, 0x8C, 0x98, 0x99, 0x95, 0xE0, 0xE4, 0xE2,
    0xFA, 0xFC, 0xF8, 0xDE, 0xD4, 0xBA, 0x84, 0x9E,
    0x9F, 0x90, 0x94, 0x9A, 0x90, 0xDD, 0xAB, 0xB6,
    0xA0, 0xC5, 0xE7, 0xF0, 0xED, 0xE2, 0xE8, 0xA7,
    0xA5, 0x84, 0x80, 0x86, 0x86, 0xDF, 0xE7, 0xEC,
    0xFB, 0xB1, 0xC6, 0xE6, 0xE6, 0xFB, 0xF3, 0xE5,
    0x95, 0x93, 0x97, 0x91, 0x91, 0x97, 0x93, 0x95,
    0x8D, 0x81, 0xC6, 0xCC, 0xC7, 0xD0, 0xCB, 0xC2,
    0xC6, 0xDD, 0xCB, 0xDF, 0xC5, 0xC2, 0xC0, 0x8F,
    0x9D, 0xBC, 0xB8, 0xBE, 0xBE, 0xF9, 0xD7, 0xC2,
    0xCA, 0xD8, 0x9A, 0xE8, 0xD4, 0xD8, 0xCE, 0xCF,
    0xA1, 0xB3, 0xA6, 0xCE, 0xCE, 0x82, 0xA7, 0xBE,
    0xA4, 0xAC, 0xEA, 0x9B, 0xA5, 0xAE, 0xA5, 0xAA,
    0xBE, 0xDC, 0xD8, 0xDE, 0xDE, 0xD8, 0xDC, 0xFA,
    0xF8, 0xB8, 0xBE, 0xB6, 0xB5, 0xB3, 0xB7, 0xAC,
    0x94, 0x93, 0x83, 0x97, 0x8D, 0x93, 0x83, 0xC7,
    0xC5, 0xE4, 0xE0, 0xE6, 0xE6, 0xA1, 0x8F, 0x9A,
    0x82, 0x98, 0x97, 0xD3, 0xB7, 0x99, 0x97, 0x8E,
    0x8C, 0x96, 0x94, 0xF6, 0xF6, 0xB7, 0x97, 0x93,
    0xEC, 0xA1, 0xCA, 0xE6, 0xE5, 0xE9, 0x8B, 0x8D,
    0x85, 0x83, 0x87, 0x81, 0xA1, 0xAD, 0xEA, 0xEA,
    0xF4, 0xF8, 0xF1, 0xF2, 0xE0, 0xF0, 0xF2, 0xB7,
    0xEC, 0xF6, 0xBA, 0xB6, 0x91, 0x97, 0x93, 0x95,
    0xF0, 0xC4, 0xCC, 0xC6, 0xC8, 0xCA, 0xD6, 0xC2,
    0x88, 0xEB, 0xD8, 0xC4, 0xC3, 0xC0, 0xCB, 0xDD,
    0xBD, 0xBB, 0xBF, 0xB9, 0xB9, 0xBF, 0xBB, 0xBD,
    0xB5, 0xB3, 0xB7, 0xB1, 0xB1, 0xB7, 0xFE, 0xB2,
    0xCA, 0xDB
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\knob.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  KNOB.H
//
//	Defines the Knob Control
//
//	Copyright (c) Microsoft Corporation	1997
//    
//	12/18/97 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _KNOB_HEADER_
#define _KNOB_HEADER_

#include "windows.h"

#ifdef __cplusplus
extern "C" {
#endif

//forward declaration
class CKnob;

//helper functions for global stuff, start up, shut down, etc.
CKnob* GetKnobFromID(HWND hwndParent, int nID);
CKnob* GetKnobFromHWND(HWND hwnd);

class CKnob
{
    public:
        /*
        Create a class of the knob
        */
        friend CKnob* CreateKnob(DWORD dwWindowStyle,
                                 DWORD dwRange,
                                 DWORD dwInitialPosition,
                                 int x,
                                 int y,
                                 int width,
                                 int height,
                                 HWND hwndParent,
                                 int nID,
                                 HINSTANCE hInst);

        CKnob(); //constructor
        ~CKnob(); //destructor

        HWND GetHWND() {return m_hwnd;}
        int GetID() {return m_nID;}
        void SetRange(DWORD dwRange) {m_dwRange = dwRange;}
        DWORD GetRange() {return m_dwRange;}
        DWORD GetPosition() {return m_dwCurPosition;}

        void SetPosition(DWORD dwPosition, BOOL fNotify);

    private:
        //non-static privates
        int m_nID;
        HWND m_hwnd;
        int m_nLightX;
        int m_nLightY;
        DWORD m_dwRange;
        DWORD m_dwPosition;
        DWORD m_dwCurPosition;
        double m_trackdegree;
        UINT_PTR m_uFlashTimerID;
        UINT_PTR m_uTrackTimerID;
        BOOL m_fDim;
        BOOL m_fFastKnob;

        void OnButtonDown(int x, int y);
        void OnButtonUp();
        BOOL ComputeCursor(int deltaX, int deltaY, int maxdist);
        void OnMouseMove(int x, int y);
        void OnTimer();
        void OnFlashTimer();
        void Draw(HDC hdc);
        void KMaskBlt(HDC hdcDest, int x, int y, int width, int height, HDC hdcSource, int xs, int ys, HBITMAP hMask, int xm, int xy, DWORD dwDummy);

    private:
        //static stuff for all knobs
        static HINSTANCE m_hInst;
        static DWORD m_dwKnobClassRef;
        static ATOM m_KnobAtom;
        static HANDLE m_hbmpKnob;
        static HANDLE m_hbmpKnobTab;
        static HANDLE m_hbmpLight;
        static HANDLE m_hbmpLightBright;
        static HANDLE m_hbmpLightMask;
        static int m_nLightWidth;
        static int m_nLightHeight;

        static LRESULT CALLBACK KnobProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
        static void CALLBACK TrackProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
        static void CALLBACK FlashProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
        static BOOL InitKnobs(HINSTANCE hInst);
        static void UninitKnobs();
};

#ifdef __cplusplus
};
#endif

#endif  //_KNOB_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\playres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MMComp.rc
//
#define IDX_1                           0
#define IDX_2                           1
#define IDX_3                           2
#define IDX_4                           3
#define IDX_5                           4
#define IDX_6                           5
#define IDX_7                           6
#define IDX_8                           7
#define IDX_9                           8
#define NUMBER_OF_BITMAPS               8
#define PLAYBAR_BITMAPS                 8
#define IDX_10                          9
#define DEFAULT_TBAR_SIZE               11
#define IDR_BASECOMP                    101
#define IDR_MAINMENU                    102
#define IDR_CDPLAY                      102
#define IDR_CDPLAYER                    104
#define IDR_SCANNING                    106
#define IDR_CDPLAYER_ICON               107
#define IDR_TRACK                       108
#define IDR_DROP                        109
#define IDR_SHELLICON                   110
#define IDR_DROPDEL                     111
#define IDR_DROPCPY                     112
#define IDR_PREFERENCES                 113
#define IDR_ACCELTABLE                  118
#define IDI_ICON_CDPLAY                 201
#define IDC_TRANS_PLACEHOLDER           202
#define IDD_DIALOG_TRANSPORT            203
#define IDC_CURSOR_HAND                 205
#define IDB_TRANS_TRACKLIST             206
#define IDB_TRANS_PLAY                  207
#define IDB_TRANS_STOP                  208
#define IDB_TRANS_EJECT                 209
#define IDB_TRANS_PREVTRACK             210
#define IDB_TRANS_NEXTTRACK             211
#define IDB_TRANS_MULTDISK              212
#define IDB_TRANS_PDISK                 213
#define IDB_TRANS_NDISK                 214
#define IDB_CDLOGO                      215
#define IDB_CDLOGO_16                   216
#define STR_MAX_STRING_LEN              255
#define DISC_MENU_BASE                  300
#define IDM_DATABASE_EDIT               300
#define IDM_DATABASE_EXIT               301
#define VIEW_MENU_BASE                  400
#define IDM_TIME_REMAINING              403
#define IDM_TRACK_REMAINING             404
#define IDM_DISC_REMAINING              405
#define INTERNET_MENU_BASE              450
#define OPTIONS_MENU_BASE               500
#define IDM_OPTIONS_RANDOM              501
#define IDM_OPTIONS_MULTI               502
#define IDM_OPTIONS_CONTINUOUS          503
#define IDM_OPTIONS_INTRO               504
#define IDM_OPTIONS_PREFERENCES         505
#define IDM_OPTIONS_REPEAT_SINGLE       506
#define IDM_OPTIONS_NORMAL              507
#define HELP_MENU_BASE                  600
#define IDM_HELP_CONTENTS               600
#define IDM_HELP_USING                  601
#define IDM_HELP_ABOUT                  602
#define IDM_HELP_TOPICS                 603
#define IDK_SKIPF                       700
#define IDK_SKIPB                       701
#define IDK_PLAY                        702
#define IDK_STOP                        703
#define IDK_PAUSE                       704
#define IDK_EJECT                       705
#define IDK_RESCAN                      706
#define IDC_CDPLAYER_FIRST              1000
#define IDC_BUTTON1                     1000
#define MENU_STRING_BASE                1000
#define IDM_PLAYBAR_PLAY                1000
#define IDC_BUTTON2                     1001
#define IDM_PLAYBAR_PAUSE               1001
#define IDC_BUTTON3                     1002
#define IDM_PLAYBAR_STOP                1002
#define IDC_BUTTON4                     1003
#define IDM_PLAYBAR_PREVTRACK           1003
#define IDC_BUTTON5                     1004
#define IDM_PLAYBAR_SKIPBACK            1004
#define IDC_BUTTON6                     1005
#define IDM_PLAYBAR_SKIPFORE            1005
#define IDC_BUTTON7                     1006
#define IDM_PLAYBAR_NEXTTRACK           1006
#define IDC_BUTTON8                     1007
#define IDM_PLAYBAR_EJECT               1007
#define IDC_LED                         1008
#define IDC_TRACKINFO_FIRST             1009
#define IDC_COMBO1                      1009
#define IDC_COMBO1_TEXT                 1010
#define IDC_EDIT1                       1011
#define IDB_PLAY_CD                     1012
#define IDC_EDIT1_TEXT                  1012
#define IDB_PAUSE                       1013
#define IDC_COMBO2                      1013
#define IDB_STOP_CD                     1014
#define IDC_COMBO2_TEXT                 1014
#define IDC_CDPLAYER_LAST               1014
#define IDB_REWIND                      1015
#define IDB_FASTFORWARD                 1016
#define IDB_PREV_TRACK                  1017
#define IDB_NEXT_TRACK                  1018
#define IDB_EJECT_CD                    1019
#define IDC_TRACKLIST                   1021
#define IDC_CLOSE                       2001
#define IDC_DEFAULT                     2002
#define IDC_DISC_HELP                   2003
#define IDC_ADD                         2006
#define IDC_REMOVE                      2007
#define IDC_CLEAR                       2008
#define IDC_SETNAME                     2009
#define IDC_STATIC_DRIVE                2011
#define IDC_SJETEXT_DRIVE               2012
#define IDC_STATIC_ARTIST               2013
#define IDC_EDIT_ARTIST                 2014
#define IDC_STATIC_TITLE                2015
#define IDC_EDIT_TITLE                  2016
#define IDC_STATIC_PLAY_LIST            2017
#define IDC_LISTBOX_PLAY_LIST           2018
#define IDC_STATIC_AVAILABLE_TRACKS     2019
#define IDC_LISTBOX_AVAILABLE_TRACKS    2020
#define IDC_STATIC_TRACK                2021
#define IDC_EDIT_TRACK                  2022
#define IDC_STOP_CD_ON_EXIT             3000
#define IDC_SAVE_ON_EXIT                3001
#define IDC_SHOW_TOOLTIPS               3002
#define IDC_SMALL_FONT                  3003
#define IDC_LARGE_FONT                  3004
#define IDC_LED_DISPLAY                 3005
#define IDC_INTRO_PLAY_LEN              3006
#define IDC_INTRO_SPINBTN               3007
#define STR_REGISTRY_KEY                3100
#define STR_CDPLAYER                    3101
#define STR_TERMINATE                   3102
#define STR_FAIL_INIT                   3103
#define STR_NO_CDROMS                   3104
#define STR_FATAL_ERROR                 3105
#define STR_SCANNING                    3106
#define STR_INITIALIZATION              3107
#define STR_TRACK1                      3108
#define STR_SAVE_CHANGES                3109
#define STR_SAVE_INFO                   3110
#define STR_CANCEL_PLAY                 3111
#define STR_RESCAN                      3112
#define STR_READING_TOC                 3113
#define STR_CHANGE_CDROM                3114
#define STR_CDPLAYER_TIME               3115
#define STR_NO_RES                      3116
#define STR_INSERT_DISC                 3117
#define STR_NO_DISC                     3118
#define STR_ERR_GEN                     3119
#define STR_CDPLAYER_PAUSED             3120
#define STR_DATA_DISC                   3121
#define STR_INIT_TOTAL_PLAY             3330
#define STR_INIT_TRACK_PLAY             3331
#define STR_TOTAL_PLAY                  3332
#define STR_TRACK_PLAY                  3333
#define STR_NEW_ARTIST                  3334
#define STR_NEW_TITLE                   3335
#define STR_INIT_TRACK                  3336
#define STR_HDR_ARTIST                  3337
#define STR_HDR_TRACK                   3338
#define STR_HDR_TITLE                   3339
#define STR_UNKNOWN                     3340
#define STR_BAD_DISC                    3341
#define STR_CDROM_INUSE                 3342
#define STR_DISC_INUSE                  3343
#define STR_WAITING                     3344
#define STR_EXIT_MESSAGE                3345
#define STR_NOT_IN_PLAYLIST             3346
#define STR_BEING_SCANNED               3347
#define STR_DISK_NOT_THERE_K            3348
#define STR_DISK_NOT_THERE              3349
#define STR_UNKNOWN_ARTIST              3350
#define STR_DISPLAY_LABELS              3400
#define STR_MCICDA_MISSING              3452
#define STR_MCICDA_NOT_WORKING          3453
#define STR_MUTE                        3454
#define STR_MCICDA_NOT_AVAIL            3455
#define IDI_ICON_ANI_PLAY               4000
#define IDI_ICON_ANI_MODE               4001
#define IDI_ICON_ANI_DOWN               4002
#define STR_FORMAT_STATUS               5000
#define STR_FORMAT_MODE                 5001
#define STR_LOGO                        5002
#define STR_TRACK_REMAINING             5003
#define STR_TRACK_TIME                  5004
#define STR_DISC_REMAINING              5005
#define STR_DISC_TIME                   5006
#define STR_TRACK_NUMBER                5007
#define STR_STATUS_MUTE                 5008
#define STR_TITLE                       5009
#define STR_TRACK                       5010
#define STR_ARTIST                      5011
#define STR_STATUS_PLAY                 5012
#define STR_STATUS_DOWNLOADING          5013
#define STR_STATUS_NODISC               5014
#define STR_STATUS_STOP                 5015
#define STR_STATUS_PAUSED               5016
#define STR_MODE_NORMAL                 5017
#define STR_MODE_RANDOM                 5018
#define STR_MODE_REPEATONE              5019
#define STR_MODE_REPEATALL              5020
#define STR_MODE_INTROPLAY              5021
#define STR_VOLUME                      5022
#define IDX_SEPARATOR                   -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        216
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\ledwnd.cpp ===
/******************************Module*Header*******************************\
* Module Name: ledwnd.c
*
* Implementation of the LED window.
*
*
* Created: 18-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>             /* required for all Windows applications */
#include <windowsx.h>

#include <string.h>
#include <tchar.h>              /* contains portable ascii/unicode macros */

#include <commctrl.h>

#include "playres.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "literals.h"
#include "trklst.h"

#define DECLARE_DATA
#include "ledwnd.h"
#include "dib.h"

#include "..\cdopt\cdopt.h"

#define WM_LED_INFO_PAINT               (WM_USER+2000) //wparam = draw, lparam = volchanged state
#define WM_LED_MUTE                     (WM_USER+2001) //wparam = unused, lparam = mute flag
#define WM_LED_DOWNLOAD                 (WM_USER+2002) //wparam = unused, lparam = download flag
#define WM_NET_CHANGEPROVIDER           (WM_USER+1002) //wparam = unused, lparam = LPCDPROVIDER
#define VOLUME_STEPS 40
#define VOLUME_SPACING 3
#define VOLUME_DELTA 0x2FF
#define VOLUME_LINE_HEIGHT 28
#define VOLUME_WIDTH 290

#define TOOLID_STATUS       0
#define TOOLID_MODE         1
#define TOOLID_LOGO         2
#define TOOLID_TIME         3
#define TOOLID_TRACKORMUTE  4    
#define TOOLID_TITLE        5
#define TOOLID_TRACK        6
#define TOOLID_ARTIST       7

#define LARGE_MODE_INDICATOR 400

#define LOGO_X_OFFSET 4
#define LOGO_Y_OFFSET 4
#define INFO_AREA_OFFSET 55

#define ANI_NOCD_FRAME 0
#define ANI_STOP_FRAME 1
#define ANI_LAST_PLAY_FRAME 4
#define ANI_PAUSE_FRAME 5

#define MODE_NORMAL_FRAME 0
#define MODE_REPEAT1_FRAME 1
#define MODE_REPEATALL_FRAME 2
#define MODE_INTRO_FRAME 3
#define MODE_RANDOM_FRAME 4

int   g_nLastXOrigin = 0;
BITMAP g_bmLogo;
BOOL g_fAllowDraw = TRUE;
DWORD  g_dwLevel = 0;
TCHAR* g_szMixerName = NULL;
HWND g_hwndPlay = NULL;
HWND g_hwndMode = NULL;
HWND g_hwndDownload = NULL;
DWORD g_dwLastState = CD_NO_CD;
DWORD g_dwLastModeFrame = MODE_NORMAL_FRAME;
COLORREF CurrentColorRef = RGB(0x00,0xFF,0xFF);
BOOL g_fMute = TRUE;
BOOL g_fDownloading = FALSE;
LPCDPROVIDER g_pCurrentProvider = NULL;
RECT g_timerect;
HWND g_hwndToolTips = NULL;
extern HINSTANCE g_hInst;

/* -------------------------------------------------------------------------
** Private functions for the LED class
** -------------------------------------------------------------------------
*/

BOOL
LED_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    );

BOOL
LED_LargeMode(HWND hwnd);

void
LED_OnPaint(
    HWND hwnd
    );

void
LED_OnLButtonUp(
    HWND hwnd,
    int x,
    int y,
    UINT keyFlags
    );

void
LED_OnSetText(
    HWND hwnd,
    LPCTSTR lpszText
    );

void
LED_DrawText(
    HWND hwnd,
    HDC hdcLed,
    LPCTSTR s,
    int sLen
    );

void
LED_Animation(HDC hdc);

void
LED_DrawLogo(
    HWND hwnd,
    HDC hdcLed, RECT* pPaintRect);

void
LED_DrawInfo(
    HWND hwnd,
    HDC hdcLed,
    LPCTSTR s,
    int sLen, RECT* pPaintRect
    );

void
LED_DrawTrackMute(
    HWND hwnd,
    HDC hdcLed, RECT* pPaintRect);

void
LED_CreateLEDFonts(
    HDC hdc
    );

void LED_DrawVolume(
    HWND ledWnd, HDC hdc
    );


HANDLE hbmpLogo = NULL;
HANDLE hbmpVendorLogo = NULL;

/******************************Public*Routine******************************\
* InitLEDClass
*
* Called to register the LED window class and create a font for the LED
* window to use.  This function must be called before the CD Player dialog
* box is created.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
InitLEDClass(
    HINSTANCE hInst
    )
{
    WNDCLASS    LEDwndclass;
    HDC         hdc;

    ZeroMemory( &LEDwndclass, sizeof(LEDwndclass) );

    /*
    ** Register the LED window.
    */
    LEDwndclass.lpfnWndProc     = LEDWndProc;
    LEDwndclass.hInstance       = hInst;
    LEDwndclass.hCursor         = LoadCursor( NULL, IDC_ARROW );
    LEDwndclass.hbrBackground   = (HBRUSH)GetStockObject( BLACK_BRUSH );
    LEDwndclass.lpszClassName   = g_szLEDClassName;
    LEDwndclass.style           = CS_OWNDC;

    hdc = GetDC( GetDesktopWindow() );
    LED_CreateLEDFonts( hdc );
    ReleaseDC( GetDesktopWindow(), hdc );

    return RegisterClass( &LEDwndclass );
}

void LED_OnDestroy(HWND hwnd)
{
    if (hbmpLogo)
    {
        GlobalFree(hbmpLogo);
        hbmpLogo = NULL;
    }

    if ( hLEDFontL != NULL )
    {
        DeleteObject( hLEDFontL );
    }

    if ( hLEDFontS != NULL )
    {
        DeleteObject( hLEDFontS );
    }

    if ( hLEDFontB != NULL )
    {
        DeleteObject( hLEDFontB );
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * LED_OnToolTipNotify
// Called from tool tips to get the text they need to display
////////////////////////////////////////////////////////////////////////////////////////////
VOID LED_OnToolTipNotify(HWND hwnd, LPARAM lParam)
{     
    LPTOOLTIPTEXT lpttt;     
    UINT nID;

    if ((((LPNMHDR) lParam)->code) == TTN_NEEDTEXT) 
    { 
        nID = (UINT)((LPNMHDR)lParam)->idFrom; 
        lpttt = (LPTOOLTIPTEXT)lParam;

        switch (nID)
        {
            case TOOLID_STATUS :
            {
                TCHAR szFormat[30];
                TCHAR szStatus[30];
                LoadString(g_hInst,STR_FORMAT_STATUS,szFormat,sizeof(szFormat)/sizeof(TCHAR));

                if (g_fDownloading)
                {
                    LoadString(g_hInst,STR_STATUS_DOWNLOADING,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                }
                else
                {
                    if (g_State & CD_PLAYING)
                    {
                        LoadString(g_hInst,STR_STATUS_PLAY,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                    }

                    if (g_State & CD_STOPPED)
                    {
                        LoadString(g_hInst,STR_STATUS_STOP,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                    }

                    if (g_State & CD_PAUSED)
                    {
                        LoadString(g_hInst,STR_STATUS_PAUSED,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                    }

                    if ((g_State & CD_NO_CD) || (g_State & CD_DATA_CD_LOADED))
                    {
                        LoadString(g_hInst,STR_STATUS_NODISC,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                    }
                } //end else
                wsprintf(lpttt->szText,szFormat,szStatus);
            }
            break;

            case TOOLID_MODE :
            {
                TCHAR szFormat[30];
                TCHAR szStatus[30];
                LoadString(g_hInst,STR_FORMAT_MODE,szFormat,sizeof(szFormat)/sizeof(TCHAR));
                LoadString(g_hInst,STR_MODE_NORMAL,szStatus,sizeof(szStatus)/sizeof(TCHAR));

                if (g_fContinuous)
                {
                    LoadString(g_hInst,STR_MODE_REPEATALL,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                }

                if (g_fIntroPlay)
                {
                    LoadString(g_hInst,STR_MODE_INTROPLAY,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                }

                if (!g_fSelectedOrder)
                {
                    LoadString(g_hInst,STR_MODE_RANDOM,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                }

                if (g_fRepeatSingle)
                {
                    LoadString(g_hInst,STR_MODE_REPEATONE,szStatus,sizeof(szStatus)/sizeof(TCHAR));
                }

                wsprintf(lpttt->szText,szFormat,szStatus);
            }
            break;

            case TOOLID_LOGO :
            {
                if (g_fDownloading)
                {
                    _tcscpy(lpttt->szText,g_pCurrentProvider->szProviderName);
                }
                else
                {
                    LoadString(g_hInst,STR_LOGO,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
            }
            break;

            case TOOLID_TIME :
            {
                if (g_fDisplayT)
                {
                    LoadString(g_hInst,STR_TRACK_TIME,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }

                if (g_fDisplayTr)
                {
                    LoadString(g_hInst,STR_TRACK_REMAINING,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }

                if (g_fDisplayD)
                {
                    LoadString(g_hInst,STR_DISC_TIME,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }

                if (g_fDisplayDr)
                {
                    LoadString(g_hInst,STR_DISC_REMAINING,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
            }
            break;

            case TOOLID_TRACKORMUTE :
            {
                BOOL fLargeMode = FALSE;
                if (LED_LargeMode(hwnd))
                {
                    fLargeMode = TRUE;
                }

                if ((g_fMute) && (fLargeMode))
                {
                    LoadString(g_hInst,STR_STATUS_MUTE,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
                else
                {
                    LoadString(g_hInst,STR_TRACK_NUMBER,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
            }
            break;

            case TOOLID_TITLE :
            {
                if (g_fAllowDraw)
                {
                    LoadString(g_hInst,STR_TITLE,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
                else
                {
                    LoadString(g_hInst,STR_VOLUME,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
            }
            break;

            case TOOLID_TRACK :
            {
                if (g_fAllowDraw)
                {
                    LoadString(g_hInst,STR_TRACK,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
                else
                {
                    LoadString(g_hInst,STR_VOLUME,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
            }
            break;

            case TOOLID_ARTIST :
            {
                if (g_fAllowDraw)
                {
                    LoadString(g_hInst,STR_ARTIST,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
                else
                {
                    LoadString(g_hInst,STR_VOLUME,lpttt->szText,sizeof(lpttt->szText)/sizeof(TCHAR));
                }
            }
            break;
        } //end switch
    } 	
    return;
} 

void DoDrawing(HWND hwnd, HDC hdc, RECT* pPaintRect)
{
    int sLen;
    TCHAR s[MAX_PATH];

    sLen = GetWindowText( hwnd, s, sizeof(s)/sizeof(TCHAR));

    RECT wndRect;
    GetClientRect(hwnd,&wndRect);

    HPALETTE hPalOld = SelectPalette(hdc,g_pSink->GetPalette(),FALSE);
    RealizePalette(hdc);

    HDC memDC = CreateCompatibleDC(hdc);
    HPALETTE hPalOldMem = SelectPalette(hdc,g_pSink->GetPalette(),FALSE);
    RealizePalette(hdc);

    SetBkColor( memDC, RGB(0x00,0x00,0x00) );
    SetTextColor( memDC, CurrentColorRef );

    HBITMAP hbmp = CreateCompatibleBitmap(hdc,wndRect.right-wndRect.left,wndRect.bottom-wndRect.top);
    HBITMAP holdBmp = (HBITMAP)SelectObject(memDC,hbmp);
      
    if (LED_LargeMode(hwnd))
    {
        LED_Animation(hdc); //use hdc to ensure the clip rect is not affecting these windows
        LED_DrawLogo(hwnd,memDC,pPaintRect);
        LED_DrawTrackMute(hwnd,memDC,pPaintRect);
        if (g_fAllowDraw)
        {
            LED_DrawInfo(hwnd,memDC, s, sLen,pPaintRect);
        }
        else
        {
            LED_DrawVolume(hwnd,memDC);
        }
    }
    else
    {
        //hide all animations
        ShowWindow(g_hwndPlay,SW_HIDE);
        ShowWindow(g_hwndMode,SW_HIDE);
        if (g_hwndDownload)
        {
            ShowWindow(g_hwndDownload,SW_HIDE);
        }
    }
    
    /*
    ** Draw the LED display text
    */
    LED_DrawText( hwnd, memDC, s, sLen );

    //blit from memory onto display and clean up
    BitBlt(hdc,wndRect.left,wndRect.top,wndRect.right-wndRect.left,wndRect.bottom-wndRect.top,
	   memDC,0,0,SRCCOPY);

    SelectObject(memDC,holdBmp);
    DeleteObject(hbmp);
    SelectPalette(hdc,hPalOld,FALSE);
    RealizePalette(hdc);
    SelectPalette(memDC,hPalOldMem,FALSE);
    RealizePalette(memDC);
    DeleteDC(memDC);

    GetClientRect( hwnd, &wndRect );
    HRGN region = CreateRectRgn(wndRect.left,wndRect.top,wndRect.right,wndRect.bottom);

    SelectClipRgn(hdc, region);
    DeleteObject(region);
}

BOOL LED_OnEraseBackground(HWND hwnd, HDC hdc)
{
    //DoDrawing(hwnd,hdc);
    return TRUE;
}

/******************************Public*Routine******************************\
* LEDWndProc
*
* This routine handles the WM_PAINT and WM_SETTEXT messages
* for the "LED" display window.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
LEDWndProc(
    HWND hwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( message )
    {
        HANDLE_MSG( hwnd, WM_CREATE,    LED_OnCreate );
        HANDLE_MSG( hwnd, WM_DESTROY,   LED_OnDestroy);
        HANDLE_MSG( hwnd, WM_PAINT,     LED_OnPaint );
        HANDLE_MSG( hwnd, WM_LBUTTONUP, LED_OnLButtonUp );
        HANDLE_MSG( hwnd, WM_SETTEXT,   LED_OnSetText );
        HANDLE_MSG( hwnd, WM_ERASEBKGND, LED_OnEraseBackground);

        case WM_NOTIFY :
	    {
            if ((((LPNMHDR)lParam)->code) == TTN_NEEDTEXT)
            {
                LED_OnToolTipNotify(hwnd,lParam);
            }
        }
        break;

        case WM_LBUTTONDOWN :
        case WM_MBUTTONDOWN :
        case WM_RBUTTONDOWN :
        case WM_MOUSEMOVE :
        {
            MSG msg;
            msg.lParam = lParam; 
            msg.wParam = wParam; 
            msg.message = message;
            msg.hwnd = hwnd; 
            SendMessage(g_hwndToolTips, TTM_RELAYEVENT, 0, (LPARAM)&msg);
        }
        break;
        
        case WM_LED_INFO_PAINT :
        {
            g_fAllowDraw = (BOOL)wParam;
            if (!g_fAllowDraw)
            {
                MMONVOLCHANGED* pVolChange = (MMONVOLCHANGED*)lParam;
                g_szMixerName = pVolChange->szLineName;
                g_dwLevel = pVolChange->dwNewVolume;
                InvalidateRect(hwnd,NULL,FALSE);
                UpdateWindow(hwnd);
            }
        }
        break;

        case WM_LED_MUTE :
        {
            g_fMute = (BOOL)lParam;
            InvalidateRect(hwnd,NULL,FALSE);
            UpdateWindow(hwnd);
        }
        break;

        case WM_NET_CHANGEPROVIDER :
        {
            if (g_fDownloading)
            {
                if (hbmpVendorLogo)
                {
                    GlobalFree(hbmpVendorLogo);
                    hbmpVendorLogo = NULL;
                }

                LPCDPROVIDER pProv = (LPCDPROVIDER)lParam;
                if (pProv)
                {
                    hbmpVendorLogo = OpenDIB(pProv->szProviderLogo,-1);
                    g_pCurrentProvider = pProv;

                    //if tool tip is showing, kill it
                    TOOLINFO ti;
                    ti.cbSize = sizeof(ti);
                    if (SendMessage(g_hwndToolTips, TTM_GETCURRENTTOOL, 0,  (LPARAM) (LPTOOLINFO) &ti))
                    {
                        if (ti.uId == TOOLID_LOGO)
                        {
                            //fake a button down
                            MSG msg;
                            msg.lParam = 0; 
                            msg.wParam = 0; 
                            msg.message = WM_LBUTTONDOWN;
                            msg.hwnd = hwnd; 
                            SendMessage(g_hwndToolTips, TTM_RELAYEVENT, 0, (LPARAM)&msg);
                        }
                    }
                }

                InvalidateRect(hwnd,NULL,FALSE);
                UpdateWindow(hwnd);
            } //end if downloading
        }
        break;

        case WM_LED_DOWNLOAD :
        {
            BOOL fDownloading = (BOOL)lParam;
            if (fDownloading == g_fDownloading)
            {
                //can get called multiple times for same mode
                break;
            }

            g_fDownloading = fDownloading;

            if (g_fDownloading)
            {
                //get the path to the vendor logo file
                LPCDOPT pOpts = (LPCDOPT)g_pSink->GetOptions();

                if (pOpts)
                {
                    LPCDOPTIONS pOptions = NULL;
                    pOptions = pOpts->GetCDOpts();

                    if (pOptions)
                    {
                        if (pOptions->pCurrentProvider!=NULL)
                        {
                            hbmpVendorLogo = OpenDIB(pOptions->pCurrentProvider->szProviderLogo,-1);
                            g_pCurrentProvider = pOptions->pCurrentProvider;
                        } //end if current provider ok
                    } //end if poptions ok
                } //end if popts created

                //create the downloading animation
                g_hwndDownload = Animate_Create(hwnd,
                                            IDI_ICON_ANI_DOWN,
                                            WS_CHILD,
                                            g_hInst);

                //headers don't have Animate_OpenEx yet,
                //so just do the straight call
                SendMessage(g_hwndDownload,ACM_OPEN,(WPARAM)g_hInst,
                        (LPARAM)MAKEINTRESOURCE(IDI_ICON_ANI_DOWN));

                //move to the top/left of the window
                RECT anirect;
                GetClientRect(g_hwndDownload,&anirect);
                MoveWindow(g_hwndDownload,
                     LOGO_X_OFFSET,
                     LOGO_Y_OFFSET,
                     anirect.right - anirect.left,
                     anirect.bottom - anirect.top,
                     FALSE);

                Animate_Play(g_hwndDownload,0,-1,-1);

                ShowWindow(g_hwndPlay,SW_HIDE);
                ShowWindow(g_hwndDownload,SW_SHOW);

                if (hbmpVendorLogo)
                {
                    InvalidateRect(hwnd,NULL,FALSE);
                    UpdateWindow(hwnd);
                }
            }
            else
            {
                ShowWindow(g_hwndDownload,SW_HIDE);
                ShowWindow(g_hwndPlay,SW_SHOW);
                DestroyWindow(g_hwndDownload);
                g_hwndDownload = NULL;
                if (hbmpVendorLogo)
                {
                    GlobalFree(hbmpVendorLogo);
                    InvalidateRect(hwnd,NULL,FALSE);
                    UpdateWindow(hwnd);
                }
            }
        }
        break;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}

void LED_SetTool(HWND hwnd, UINT toolID, int left, int top, int right, int bottom)
{
    TOOLINFO ti;
    RECT toolRect;
    BOOL fAddTool = TRUE;

    SetRect(&toolRect,left,top,right,bottom);

    ti.cbSize = sizeof(TOOLINFO); 
 	ti.uFlags = 0; 
	ti.hwnd = hwnd; 
	ti.hinst = g_hInst; 
	ti.uId = toolID; 
	ti.lpszText = LPSTR_TEXTCALLBACK;

	//check to see if tool already exists
    if (SendMessage(g_hwndToolTips, TTM_GETTOOLINFO, 0,  (LPARAM) (LPTOOLINFO) &ti))
    {
        //if tool exists, we don't want to add it ...
        fAddTool = FALSE;

        //... unless the rects have changed
        if (memcmp(&ti.rect,&toolRect,sizeof(RECT)) != 0)
        {
            SendMessage(g_hwndToolTips, TTM_DELTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
            fAddTool = TRUE;
        }
    }

	if (fAddTool)
    {
        SetRect(&ti.rect,left,top,right,bottom);
        SendMessage(g_hwndToolTips, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
    }
}

/*****************************Private*Routine******************************\
* LED_OnCreate
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
LED_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    )
{
    HDC     hdcLed;

    hdcLed = GetDC( hwnd );
    SetTextColor( hdcLed, CurrentColorRef );
    ReleaseDC( hwnd, hdcLed );

    //create the tooltips
    g_hwndToolTips = CreateWindow(TOOLTIPS_CLASS, (LPTSTR) NULL, TTS_ALWAYSTIP | WS_POPUP, 
						CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
						hwnd, (HMENU) NULL, g_hInst, NULL); 

    //determine color depth
    HDC hdcScreen = GetDC(NULL);
    UINT uBPP = GetDeviceCaps(hdcScreen, PLANES) * GetDeviceCaps(hdcScreen, BITSPIXEL);
    ReleaseDC(NULL, hdcScreen);

    //load the logo
    HBITMAP hbmpTemp = NULL;
    if (uBPP == 4) //16-color
    {
        hbmpTemp = (HBITMAP)LoadImage(g_hInst,MAKEINTRESOURCE(IDB_CDLOGO_16),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
    }
    else
    {
        hbmpTemp = (HBITMAP)LoadImage(g_hInst,MAKEINTRESOURCE(IDB_CDLOGO),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
    }
	hbmpLogo = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    GetObject(hbmpTemp,sizeof(g_bmLogo),&g_bmLogo);
    DeleteObject(hbmpTemp);

    g_hwndPlay = Animate_Create(hwnd,
                                IDI_ICON_ANI_PLAY,
                                WS_CHILD,
                                g_hInst);

    //headers don't have Animate_OpenEx yet,
    //so just do the straight call
    SendMessage(g_hwndPlay,ACM_OPEN,(WPARAM)g_hInst,
            (LPARAM)MAKEINTRESOURCE(IDI_ICON_ANI_PLAY));

    //move to the top/left of the window
    RECT anirect;
    GetClientRect(g_hwndPlay,&anirect);
    MoveWindow(g_hwndPlay,
         LOGO_X_OFFSET,
         LOGO_Y_OFFSET,
         anirect.right - anirect.left,
         anirect.bottom - anirect.top,
         FALSE);

    LED_SetTool(hwnd,TOOLID_STATUS,anirect.left,anirect.top,anirect.right,anirect.bottom);

    ShowWindow(g_hwndPlay,SW_SHOW);

    g_hwndMode = Animate_Create(hwnd,
                                IDI_ICON_ANI_MODE,
                                WS_CHILD,
                                g_hInst);

    //headers don't have Animate_OpenEx yet,
    //so just do the straight call
    SendMessage(g_hwndMode,ACM_OPEN,(WPARAM)g_hInst,
            (LPARAM)MAKEINTRESOURCE(IDI_ICON_ANI_MODE));

    //move to the top/left of the window
    GetClientRect(g_hwndMode,&anirect);
    MoveWindow(g_hwndMode,
         (g_bmLogo.bmWidth - (anirect.right - anirect.left)) + LOGO_X_OFFSET,
         LOGO_Y_OFFSET,
         anirect.right - anirect.left,
         anirect.bottom - anirect.top,
         FALSE);

    LED_SetTool(hwnd,TOOLID_MODE,
            (g_bmLogo.bmWidth - (anirect.right - anirect.left)) + LOGO_X_OFFSET,
            LOGO_Y_OFFSET,
            g_bmLogo.bmWidth + LOGO_X_OFFSET,
            LOGO_Y_OFFSET + (anirect.bottom - anirect.top));

    ShowWindow(g_hwndMode,SW_SHOW);

    //set the bounding rect for clicking on the time ... intialize to whole rect
    RECT rcParent;
    GetClientRect(hwnd,&rcParent);
    SetRect(&g_timerect,rcParent.left,rcParent.top,rcParent.right,rcParent.bottom);

    return TRUE;
}

void LED_Animation(HDC hdc)
{
    ShowWindow(g_hwndMode,SW_SHOW);
    
    if (!g_fDownloading)
    {
        ShowWindow(g_hwndPlay,SW_SHOW);

        if (g_State != g_dwLastState)
        {
            g_dwLastState = g_State;
            Animate_Stop(g_hwndPlay);

            if (g_State & CD_PLAYING)
            {
                Animate_Play(g_hwndPlay,ANI_STOP_FRAME,ANI_LAST_PLAY_FRAME,-1);
            }

            if (g_State & CD_STOPPED)
            {
                Animate_Seek(g_hwndPlay,ANI_STOP_FRAME);
            }

            if (g_State & CD_PAUSED)
            {
                Animate_Play(g_hwndPlay,ANI_LAST_PLAY_FRAME,ANI_PAUSE_FRAME,-1);
            }

            if ((g_State & CD_NO_CD) || (g_State & CD_DATA_CD_LOADED))
            {
                Animate_Seek(g_hwndPlay,ANI_NOCD_FRAME);
            }
        }
    }
    else
    {
        if (g_hwndDownload)
        {
            ShowWindow(g_hwndDownload,SW_SHOW);
        }
    }

    RECT rect;
    GetClientRect(g_hwndPlay,&rect);
    
    ExcludeClipRect(hdc,
                    LOGO_X_OFFSET,
                    LOGO_Y_OFFSET,
                    (rect.right - rect.left) + LOGO_X_OFFSET,
                    (rect.bottom - rect.top) + LOGO_Y_OFFSET);


    DWORD dwCurFrame = MODE_NORMAL_FRAME;

    if (g_fContinuous)
    {
        dwCurFrame = MODE_REPEATALL_FRAME;
    }
    if (g_fIntroPlay)
    {
        dwCurFrame = MODE_INTRO_FRAME;
    }
    if (!g_fSelectedOrder)
    {
        dwCurFrame = MODE_RANDOM_FRAME;
    }
    if (g_fRepeatSingle)
    {
        dwCurFrame = MODE_REPEAT1_FRAME;
    }

    if (dwCurFrame != g_dwLastModeFrame)
    {
        g_dwLastModeFrame = dwCurFrame;
        Animate_Seek(g_hwndMode,dwCurFrame);
    }

    GetClientRect(g_hwndMode,&rect);
    ExcludeClipRect(hdc,
                    (g_bmLogo.bmWidth - (rect.right - rect.left)) + LOGO_X_OFFSET,
                    LOGO_Y_OFFSET,
                    g_bmLogo.bmWidth + LOGO_X_OFFSET,
                    (rect.bottom - rect.top) + LOGO_Y_OFFSET);
}

BOOL LED_LargeMode(HWND hwnd)
{
    RECT rcParent;
    GetClientRect(GetParent(hwnd),&rcParent);
    if (rcParent.right - rcParent.left < LARGE_MODE_INDICATOR)
    {
        return FALSE;
    }

    return TRUE;
}

/*****************************Private*Routine******************************\
* LED_OnPaint
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_OnPaint(
    HWND hwnd
    )
{
    PAINTSTRUCT ps;
    HDC         hdcLed;

    hdcLed = BeginPaint( hwnd, &ps );
    DoDrawing(hwnd, hdcLed, &(ps.rcPaint));
    EndPaint( hwnd, &ps );
}



/*****************************Private*Routine******************************\
* LED_OnLButtonUp
*
* Rotate the time remaing buttons and then set the display accordingly.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_OnLButtonUp(
    HWND hwnd,
    int x,
    int y,
    UINT keyFlags
    )
{
    BOOL b, b2;

    /*
    ** If this window is not the master display LED just return
    */
    if ( GetWindowLongPtr(hwnd, GWLP_ID) != IDC_LED )
    {
        return;
    }

    RECT rcParent;
    GetClientRect(GetParent(hwnd),&rcParent);

    POINT pt;
    pt.x = x;
    pt.y = y;
    
    //if we're downloading AND within the logo rect, launch the provider's url
    if ((g_fDownloading) && (g_pCurrentProvider))
    {
        RECT logoRect;
        SetRect(&logoRect,
                LOGO_X_OFFSET,
                (rcParent.bottom - g_bmLogo.bmHeight) - LOGO_Y_OFFSET,
                LOGO_X_OFFSET + g_bmLogo.bmWidth,
                rcParent.bottom - LOGO_Y_OFFSET);

        if (PtInRect(&logoRect,pt))
        {
            ShellExecute(NULL,_TEXT("open"),g_pCurrentProvider->szProviderHome,NULL,_TEXT(""),SW_NORMAL);
            return;
        }
    }

    //if button in time rect AND volume isn't showing, allow click
    if ((PtInRect(&g_timerect,pt)) && (g_fAllowDraw))
    {
        b = g_fDisplayT;
        b2 = g_fDisplayD;
        g_fDisplayD = g_fDisplayTr;
        g_fDisplayT = g_fDisplayDr;
        g_fDisplayDr = b2;
        g_fDisplayTr = b;

        //reset options
        LPCDOPT pOpts = (LPCDOPT)g_pSink->GetOptions();
        if (pOpts)
        {
            LPCDOPTDATA pOptions = pOpts->GetCDOpts()->pCDData;
            if (pOptions)
            {
                if (g_fDisplayT)
                {
                    pOptions->fDispMode = CDDISP_TRACKTIME;
                }

                if (g_fDisplayTr)
                {
                    pOptions->fDispMode = CDDISP_TRACKREMAIN;
                }

                if (g_fDisplayD)
                {
                    pOptions->fDispMode = CDDISP_CDTIME;
                }

                if (g_fDisplayDr)
                {
                    pOptions->fDispMode = CDDISP_CDREMAIN;
                }
            } //end if poptions
            pOpts->UpdateRegistry();
        } //end if popts

        UpdateDisplay( DISPLAY_UPD_LED );
    } //end if point in rect of time
}

void LED_DrawVolume(HWND ledWnd, HDC hdc)
{
    if (g_szMixerName == NULL)
    {
        return;
    }

    //only do it in "large mode"
    if (!LED_LargeMode(ledWnd))
    {
        g_fAllowDraw = TRUE; //allow drawing of title and artist
        return;
    }
    
    RECT volrect, wholerect;
    HWND hwndparent = GetParent(ledWnd);
    GetClientRect(hwndparent,&wholerect);

    //normalize the rect and set new left-hand side
    wholerect.bottom = (wholerect.bottom - wholerect.top);
    wholerect.top = 0;
    wholerect.right = (wholerect.right - wholerect.left);
    wholerect.left = INFO_AREA_OFFSET;

    volrect.bottom = wholerect.bottom - LOGO_Y_OFFSET;
    volrect.top = volrect.bottom - VOLUME_LINE_HEIGHT;
    volrect.left = wholerect.left;
    volrect.right = volrect.left + VOLUME_WIDTH;

    if (volrect.right > g_nLastXOrigin)
    {
        volrect.right = g_nLastXOrigin;
    }

    int nWidth = volrect.right-volrect.left;

    //setup
    HDC memDC = CreateCompatibleDC(hdc);
    HBITMAP hbmp = CreateCompatibleBitmap(hdc,wholerect.right-wholerect.left,wholerect.bottom-wholerect.top);
    HBITMAP holdBmp = (HBITMAP)SelectObject(memDC,hbmp);
    HBRUSH hbrBlack = CreateSolidBrush(RGB(0x00,0x00,0x00));
    HBRUSH hbrBlue = CreateSolidBrush(CurrentColorRef);
    HFONT horgFont = (HFONT)SelectObject(memDC,hLEDFontB);

    int nStepWidth = (nWidth / VOLUME_STEPS);
    int nRectWidth = nStepWidth - VOLUME_SPACING;

    //blank out the background
    FillRect(memDC,&wholerect,hbrBlack);
    DeleteObject(hbrBlack);

    SetTextColor(memDC,CurrentColorRef);
    SetBkColor(memDC, RGB(0x00,0x00,0x00));

    SIZE sz;
    RECT textrect;
    memcpy(&textrect,&wholerect,sizeof(textrect));
        
    GetTextExtentPoint32(memDC, g_szMixerName,_tcslen(g_szMixerName), &sz );
    textrect.right = textrect.left + sz.cx;
    textrect.bottom = volrect.top - 3;
    textrect.top = textrect.bottom - sz.cy;
    ExtTextOut(memDC,textrect.left,textrect.top,ETO_OPAQUE,&textrect,g_szMixerName,_tcslen(g_szMixerName),NULL);

    //draw lines
    float nVolLines = ((float)g_dwLevel / 65535) * VOLUME_STEPS;

    for (int i = 0; i < VOLUME_STEPS; i++)
    {
	    RECT rect;
	    int nLineTop = volrect.top+5;
	    
	    if ((i >= nVolLines) && (i != 0) && (i != VOLUME_STEPS -1))
	    {
	        nLineTop = volrect.bottom - ((volrect.bottom - nLineTop) / 4);
	    }

	    SetRect(&rect,
		    volrect.left + (i * nStepWidth),
		    nLineTop,
		    volrect.left + (i * nStepWidth) + nRectWidth,
		    volrect.bottom);

	    FillRect(memDC,&rect,hbrBlue);
    }

    //blit from memory onto display and clean up
    BitBlt(hdc,wholerect.left,wholerect.top,nWidth,wholerect.bottom-wholerect.top,
	   memDC,wholerect.left,wholerect.top,SRCCOPY);

    SelectObject(memDC,holdBmp);
    SelectObject(memDC,horgFont);
    DeleteDC(memDC);
    DeleteObject(hbmp);
    DeleteObject(hbrBlue);
}

//draws text and excludes its clipping rect
//returns the bottom of the rectangle, so it can be used to do lines of text
int DrawAndExclude(HDC hdc, TCHAR* szText, int xPos, int yPos, int nRight, HWND hwnd, int ToolID)
{
    SIZE sizeText;
    GetTextExtentPoint32( hdc, szText, _tcslen(szText), &sizeText );

    RECT rc;
    rc.top = yPos;
    rc.left = xPos;
    rc.right = nRight;
    rc.bottom = rc.top + sizeText.cy;
    
    DrawText(hdc,szText,-1,&rc,DT_CALCRECT|DT_END_ELLIPSIS|DT_EXPANDTABS|DT_NOPREFIX|DT_SINGLELINE);

    //don't do drawing and clipping, or tooltip, for null strings
    if (_tcslen(szText)>0)
    {
        DrawText(hdc,szText,-1,&rc,DT_END_ELLIPSIS|DT_EXPANDTABS|DT_NOPREFIX|DT_SINGLELINE);
        ExcludeClipRect(hdc,rc.left,rc.top,rc.right,rc.bottom);
        LED_SetTool(hwnd,ToolID, rc.left, rc.top, rc.right, rc.bottom);
    }

    return (rc.bottom);
}

void LED_DrawLogo(HWND hwnd, HDC hdcLed, RECT* pPaintRect)
{
    //check to see if we should even bother
    RECT rcParent;
    GetClientRect(GetParent(hwnd),&rcParent);

    RECT destrect, logorect;
    SetRect(&logorect,LOGO_X_OFFSET,(rcParent.bottom - g_bmLogo.bmHeight) - LOGO_Y_OFFSET,4+g_bmLogo.bmWidth,rcParent.bottom-LOGO_Y_OFFSET);
    if (!IntersectRect(&destrect,&logorect,pPaintRect))
    {
        return; //painting wasn't needed
    }

    HANDLE hLogoOrVendor = hbmpLogo;
    if ((g_fDownloading) && (hbmpVendorLogo))
    {
        hLogoOrVendor = hbmpVendorLogo;
    }

    //draw the bitmap of the cd logo
    DibBlt(hdcLed, // destination DC 
                LOGO_X_OFFSET, // x upper left 
                (rcParent.bottom - g_bmLogo.bmHeight) - LOGO_Y_OFFSET,  // y upper left  
                // The next two lines specify the width and height. 
                -1, 
                -1, 
                hLogoOrVendor,    // source image
                0, 0,      // x and y upper left 
                SRCCOPY,0);  // raster operation

    ExcludeClipRect(hdcLed,LOGO_X_OFFSET,(rcParent.bottom - g_bmLogo.bmHeight) - LOGO_Y_OFFSET,4+g_bmLogo.bmWidth,rcParent.bottom-LOGO_Y_OFFSET);
    LED_SetTool(hwnd,TOOLID_LOGO,LOGO_X_OFFSET,(rcParent.bottom - g_bmLogo.bmHeight) - LOGO_Y_OFFSET,4+g_bmLogo.bmWidth,rcParent.bottom-LOGO_Y_OFFSET);
}

void LED_GetTimeRect(HWND hwnd, HDC hdcLed, LPCTSTR s, int sLen, RECT& rect)
{
    RECT rcParent;
    GetClientRect(GetParent(hwnd),&rcParent);

    HFONT hOrgFont = (HFONT)SelectObject(hdcLed,hLEDFontL);
    
    SIZE sz;
    GetTextExtentPoint32( hdcLed, s, sLen, &sz );
    rect.left = (rcParent.right - sz.cx) - LOGO_X_OFFSET;
    rect.top = (rcParent.bottom - sz.cy) - LOGO_Y_OFFSET;

    rect.bottom = rect.top + sz.cy + 3;
    rect.right  = rcParent.right - 3;

    SelectObject( hdcLed, hOrgFont );
}

void LED_DrawInfo(HWND hwnd, HDC hdcLed, LPCTSTR s, int sLen, RECT* pPaintRect)
{
    //figure out where time text will be, so we don't run into it
    RECT timerect;
    LED_GetTimeRect(hwnd,hdcLed,s,sLen,timerect);
    int xOrigin = timerect.left;

    RECT rcParent;
    GetClientRect(GetParent(hwnd),&rcParent);

    RECT rc;
    rc.bottom = rcParent.bottom;
    rc.top = rcParent.top;
    rc.left = rcParent.left + INFO_AREA_OFFSET;
    rc.right = xOrigin;

    RECT destrect;
    if (!IntersectRect(&destrect,&rc,pPaintRect))
    {
        return; //painting wasn't needed
    }

    HFONT hOrgFont = (HFONT)SelectObject( hdcLed, hLEDFontB );

    TCHAR szDisp[MAX_PATH];
    TCHAR sztrack[MAX_PATH];

    _tcscpy(sztrack,TEXT(""));

    PTRACK_INF t;
    if (CURRTRACK(g_CurrCdrom)!=NULL)
    {
        t = FindTrackNodeFromTocIndex( CURRTRACK(g_CurrCdrom)->TocIndex, ALLTRACKS( g_CurrCdrom ) );
        if (t)
        {
            _tcscpy(sztrack,t->name);
        }
    }

    LoadString(g_hInst, STR_DISPLAY_LABELS, szDisp, sizeof(szDisp)/sizeof(TCHAR));

    DrawText( hdcLed,          // handle to device context
              szDisp, // pointer to string to draw
              -1,       // string length, in characters
              &rc,    // pointer to struct with formatting dimensions
              DT_CALCRECT|DT_EXPANDTABS|DT_NOPREFIX);

    rc.top = rcParent.top + ((rcParent.bottom - rc.bottom)/2);
    rc.bottom = rcParent.bottom + ((rcParent.bottom - rc.bottom)/2);
    rc.right = rc.left;

    TCHAR szTitle[MAX_PATH];
    _tcscpy(szTitle,TITLE(g_CurrCdrom));

    if (_tcslen(szTitle)==0)
    {
        _tcscpy(szTitle,IdStr( STR_NEW_TITLE ));
    }

    int nNextLineTop = 0;
    nNextLineTop = DrawAndExclude(hdcLed,szTitle,rc.right,rc.top,xOrigin,hwnd,TOOLID_TITLE);
    nNextLineTop = DrawAndExclude(hdcLed,sztrack,rc.right,nNextLineTop,xOrigin,hwnd,TOOLID_TRACK);
    DrawAndExclude(hdcLed,ARTIST(g_CurrCdrom),rc.right,nNextLineTop,xOrigin,hwnd,TOOLID_ARTIST);

    SelectObject( hdcLed, hOrgFont );
}

void LED_DrawTrackMute(HWND hwnd, HDC hdcLed, RECT* pPaintRect)
{
    RECT rcParent;
    GetClientRect(GetParent(hwnd),&rcParent);

    //draw the mute status, if present (or track number)
    BOOL fDrawInfo = TRUE;
    RECT muteRect;
    muteRect.top = LOGO_Y_OFFSET;
    muteRect.right = rcParent.right;
    muteRect.left = rcParent.left;
    muteRect.bottom = rcParent.bottom;

    TCHAR mutestr[MAX_PATH];

    if (g_fMute)
    {
        LoadString(g_hInst,STR_MUTE,mutestr,sizeof(mutestr)/sizeof(TCHAR));
    }
    else
    {
        TCHAR tempstr[MAX_PATH];
        LoadString(g_hInst,STR_INIT_TRACK,tempstr,sizeof(tempstr)/sizeof(TCHAR));
        if (CURRTRACK(g_CurrCdrom))
        {
            wsprintf(mutestr,tempstr,(CURRTRACK(g_CurrCdrom)->TocIndex)+1);
        }
        else
        {
            fDrawInfo = FALSE;

            //remove the tooltip
            TOOLINFO ti;
            ti.cbSize = sizeof(TOOLINFO); 
 	        ti.uFlags = 0; 
	        ti.hwnd = hwnd; 
	        ti.hinst = g_hInst; 
	        ti.uId = TOOLID_TRACKORMUTE; 
	        ti.lpszText = LPSTR_TEXTCALLBACK;
            SendMessage(g_hwndToolTips, TTM_DELTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
        }
    }

    if (fDrawInfo)
    {
        HFONT hOldFont;

        hOldFont = (HFONT) SelectObject(hdcLed, hLEDFontB);
        DrawText(hdcLed,mutestr,-1,&muteRect,DT_CALCRECT|DT_SINGLELINE);
        muteRect.left = (rcParent.right - LOGO_X_OFFSET) - (muteRect.right - muteRect.left);
        muteRect.right = rcParent.right - LOGO_X_OFFSET;

        RECT destrect;
        if (IntersectRect(&destrect,&muteRect,pPaintRect))
        {

            if (g_fMute)
            {
                SetTextColor(hdcLed,RGB(0xFF,0x00,0x00));
            }

            DrawText(hdcLed,mutestr,-1,&muteRect,DT_SINGLELINE);
            ExcludeClipRect(hdcLed,muteRect.left,muteRect.top,muteRect.right,muteRect.bottom);
            LED_SetTool(hwnd,TOOLID_TRACKORMUTE,muteRect.left,muteRect.top,muteRect.right,muteRect.bottom);
            SetTextColor( hdcLed, CurrentColorRef );
        }

        // restore font
        SelectObject(hdcLed, hOldFont);

    } //end if draw info
}

/*****************************Private*Routine******************************\
* LED_DrawText
*
* Draws the LED display screen text (quickly).  The text is centered
* vertically and horizontally.  Only the backround is drawn if the g_fFlashed
* flag is set.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_DrawText(
    HWND hwnd,
    HDC hdcLed,
    LPCTSTR s,
    int sLen
    )
{
    RECT        rc;
    SIZE        sz;
    int         xOrigin;
    int         yOrigin;
    BOOL        fLargeMode = FALSE;

    HWND hwndparent = GetParent(hwnd);
    HFONT hOrgFont = NULL;

    RECT rcParent;
    GetClientRect(hwndparent,&rcParent);

    if (LED_LargeMode(hwnd))
    {
        fLargeMode = TRUE;
    }
    else
    {
        //change the string to display the track info
        if (CURRTRACK(g_CurrCdrom))
        {
            TCHAR tempstr[MAX_PATH];
            wsprintf(tempstr,TEXT("[%i] %s"),CURRTRACK(g_CurrCdrom)->TocIndex+1,s);
            _tcscpy((TCHAR*)s,tempstr);
            sLen = _tcslen(s);
        }
    }

    if (fLargeMode)
    {
        hOrgFont = (HFONT)SelectObject(hdcLed,hLEDFontL);
    }
    else
    {
        hOrgFont = (HFONT)SelectObject(hdcLed,hLEDFontS);
    }

    GetTextExtentPoint32( hdcLed, s, sLen, &sz );

    if (fLargeMode)
    {
        xOrigin = (rcParent.right - sz.cx) - LOGO_X_OFFSET;
        yOrigin = (rcParent.bottom - sz.cy) - LOGO_Y_OFFSET;
    }
    else
    {
        xOrigin = ((rcParent.right - rcParent.left) - sz.cx) / 2;
        yOrigin = ((rcParent.bottom - rcParent.top) - sz.cy) / 2;
    }

    if (sLen==1)
    {
        xOrigin = g_nLastXOrigin;
    }
    else
    {
        g_nLastXOrigin = xOrigin;
    }

    if (fLargeMode)
    {
        if (!g_fAllowDraw)
        {
            int nRightClip = INFO_AREA_OFFSET + VOLUME_WIDTH;
            if (nRightClip > xOrigin)
            {
                nRightClip = xOrigin;
            }
            ExcludeClipRect(hdcLed,INFO_AREA_OFFSET,rcParent.top,nRightClip,rcParent.bottom);
        }
    }

    rc.top    = yOrigin;
    rc.bottom = rc.top + sz.cy + 3;
    rc.left   = xOrigin;
    rc.right  = rcParent.right - 3;

    ExtTextOut( hdcLed, xOrigin, rc.top, ETO_OPAQUE, &rc, s, sLen, NULL);
    ExcludeClipRect(hdcLed,rc.left,rc.top,rc.right,rc.bottom);
    
    if (fLargeMode)
    {
        //set time rect to cover just the time values for clicking
        SetRect(&g_timerect,rc.left,rc.top,rc.right,rc.bottom);
    }
    else
    {
        SIZE tracksz;
        tracksz.cx = 0;
        if (CURRTRACK(g_CurrCdrom))
        {
            TCHAR tempstr[MAX_PATH];
            wsprintf(tempstr,TEXT("[%i]"),CURRTRACK(g_CurrCdrom)->TocIndex+1);
            GetTextExtentPoint32( hdcLed, tempstr, _tcslen(tempstr), &tracksz );
            LED_SetTool(hwnd,TOOLID_TRACKORMUTE,rcParent.left,rcParent.top,rc.left+tracksz.cx,rcParent.bottom);
        }
        else
        {
            rc.left = rcParent.left;
        }

        //set time rect to cover the part of the client area that isn't the track
        SetRect(&g_timerect,rc.left+tracksz.cx,rcParent.top,rcParent.right,rcParent.bottom);
    }

    LED_SetTool(hwnd,TOOLID_TIME,g_timerect.left,g_timerect.top,g_timerect.right,g_timerect.bottom);

    HBRUSH hbrBlack = CreateSolidBrush(RGB(0x00,0x00,0x00));

    RECT rectLED;
    GetClientRect(hwnd,&rectLED);
    FillRect(hdcLed,&rectLED,hbrBlack);
    DeleteObject(hbrBlack);

    SelectObject(hdcLed, hOrgFont);
}


/*****************************Private*Routine******************************\
* LED_OnSetText
*
* Change the LED display text.  Calling DefWindowProc ensures that the
* window text is saved correctly.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_OnSetText(
    HWND hwnd,
    LPCTSTR lpszText
    )
{
    DefWindowProc( hwnd, WM_SETTEXT, 0,  (LPARAM)lpszText);

    if (LED_LargeMode(hwnd))
    {
        RECT rect;
        HDC hdc = GetDC(hwnd);
        LED_GetTimeRect(hwnd, hdc, lpszText, _tcslen(lpszText), rect);
        ReleaseDC(hwnd,hdc);
        rect.left = g_nLastXOrigin;
        InvalidateRect(hwnd,&rect,FALSE);
    }
    else
    {
        InvalidateRect(hwnd,NULL,FALSE);
    }

    UpdateWindow(hwnd);
}


/*****************************Private*Routine******************************\
* LED_CreateLEDFonts
*
* Small font is 12pt MS Sans Serif
* Large font is 18pt MS Sans Serif
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
LED_CreateLEDFonts(
    HDC hdc
    )
{
    LOGFONT     lf;
    int         iLogPelsY;


    iLogPelsY = GetDeviceCaps( hdc, LOGPIXELSY );

    ZeroMemory( &lf, sizeof(lf) );

    HFONT hTempFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    GetObject(hTempFont,sizeof(lf),&lf);

    lf.lfHeight = (-9 * iLogPelsY) / 72;    /* 9pt */
    if (lf.lfCharSet == ANSI_CHARSET)
    {
        lf.lfWeight = FW_BOLD;
    }
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;

    hLEDFontS = CreateFontIndirect(&lf);

    lf.lfHeight = (-10 * iLogPelsY) / 72;    /* 10 pt */
    if (lf.lfCharSet == ANSI_CHARSET)
    {
        lf.lfWeight = FW_BOLD;
    }

    hLEDFontB = CreateFontIndirect(&lf);

    lf.lfHeight = (-20 * iLogPelsY) / 72;   /* 20 pt */
    if (lf.lfCharSet == ANSI_CHARSET)
    {
        lf.lfWeight = FW_EXTRABOLD;             /* extra bold */
    }

    hLEDFontL = CreateFontIndirect(&lf);


    /*
    ** If can't create either font set up some sensible defaults.
    */
    if ( hLEDFontL == NULL || hLEDFontS == NULL || hLEDFontB == NULL)
    {
        if ( hLEDFontL != NULL )
        {
            DeleteObject( hLEDFontL );
        }

        if ( hLEDFontS != NULL )
        {
            DeleteObject( hLEDFontS );
        }

        if ( hLEDFontB != NULL )
        {
            DeleteObject( hLEDFontB );
        }

        hLEDFontS = hLEDFontL = hLEDFontB = (HFONT)GetStockObject( ANSI_VAR_FONT );
    }
}


/* -------------------------------------------------------------------------
** Private functions for the Text class
** -------------------------------------------------------------------------
*/
void
Text_OnPaint(
    HWND hwnd
    );

LRESULT CALLBACK
TextWndProc(
    HWND hwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam
    );

void
Text_OnSetText(
    HWND hwnd,
    LPCTSTR lpszText
    );

void
Text_OnSetFont(
    HWND hwndCtl,
    HFONT hfont,
    BOOL fRedraw
    );

/******************************Public*Routine******************************\
* Init_SJE_TextClass
*
* Called to register the text window class .
* This function must be called before the CD Player dialog box is created.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
Init_SJE_TextClass(
    HINSTANCE hInst
    )
{
    WNDCLASS    wndclass;

    ZeroMemory( &wndclass, sizeof(wndclass) );

    /*
    ** Register the Text window.
    */
    wndclass.lpfnWndProc     = TextWndProc;
    wndclass.hInstance       = hInst;
    wndclass.hCursor         = LoadCursor( NULL, IDC_ARROW );
    wndclass.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1);
    wndclass.lpszClassName   = g_szTextClassName;

    return RegisterClass( &wndclass );
}


/******************************Public*Routine******************************\
* TextWndProc
*
* This routine handles the WM_PAINT and WM_SETTEXT messages
* for the "Text" display window.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
TextWndProc(
    HWND hwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( message ) {

    HANDLE_MSG( hwnd, WM_PAINT,     Text_OnPaint );
    HANDLE_MSG( hwnd, WM_SETTEXT,   Text_OnSetText );
    HANDLE_MSG( hwnd, WM_SETFONT,   Text_OnSetFont );
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}



/*****************************Private*Routine******************************\
* Text_OnPaint
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
Text_OnPaint(
    HWND hwnd
    )
{
    PAINTSTRUCT ps;
    TCHAR       s[128];
    int         sLen;
    HDC         hdc;
    RECT        rc;
    HFONT       hfont;
    HFONT       hfontOrg = NULL;
    LONG_PTR    lStyle;


    hdc = BeginPaint( hwnd, &ps );

    GetWindowRect( hwnd, &rc );
    MapWindowRect( GetDesktopWindow(), hwnd, &rc );

    lStyle = GetWindowLongPtr( hwnd, GWL_STYLE );
    sLen = GetWindowText( hwnd, s, 128 );
    hfont = (HFONT)GetWindowLongPtr( hwnd, GWLP_USERDATA );
    if ( hfont )
    {
        hfontOrg = (HFONT)SelectObject( hdc, hfont );
    }

    /*
    ** Draw a frame around the window
    */
    DrawEdge( hdc, &rc, EDGE_SUNKEN, BF_RECT );


    /*
    ** Draw the text
    */
    SetBkColor( hdc, GetSysColor( COLOR_BTNFACE ) );
    SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
    rc.left = 1 + (2 * GetSystemMetrics(SM_CXBORDER));

    DrawText( hdc, s, sLen, &rc,
              DT_NOPREFIX | DT_LEFT | DT_VCENTER |
              DT_NOCLIP | DT_SINGLELINE );

    if ( hfontOrg ) {
        SelectObject( hdc, hfontOrg );
    }

    EndPaint( hwnd, &ps );
}


/*****************************Private*Routine******************************\
* Text_OnSetText
*
* Change the text.  Calling DefWindowProc ensures that the
* window text is saved correctly.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
Text_OnSetText(
    HWND hwnd,
    LPCTSTR lpszText
    )
{
    DefWindowProc( hwnd, WM_SETTEXT, 0,  (LPARAM)lpszText);
    InvalidateRect( hwnd, NULL, TRUE );
    UpdateWindow( hwnd );
}


/*****************************Private*Routine******************************\
* Text_OnSetFont
*
* Sets the windows font
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
Text_OnSetFont(
    HWND hwnd,
    HFONT hfont,
    BOOL fRedraw
    )
{
    SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)hfont );
    if ( fRedraw ) {
        InvalidateRect( hwnd, NULL, TRUE );
        UpdateWindow( hwnd );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\trklst.cpp ===
/******************************Module*Header*******************************\
* Module Name: trklst.c
*
* This module manipulates the cdrom track list.  The table of contents MUST
* be locked for ALL cdrom devices before calling any functions in this module.
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include "windows.h"
#include "windowsx.h"
#include "playres.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "scan.h"
#include "database.h"
#include "trklst.h"
#include "tchar.h"


/******************************Public*Routine******************************\
* ComputeDriveComboBox
*
* This routine deletes and then reads all the drive (artist) selections
* to the drive combobox.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ComputeDriveComboBox(
    void
    )
{
    int i,index;
    HWND hwnd;

    hwnd = g_hwndControls[INDEX(IDC_ARTIST_NAME)];

    //SetWindowRedraw( hwnd, FALSE );
    ComboBox_ResetContent( hwnd );

    index = 0;
    for( i = 0; i < g_NumCdDevices; i++ ) {

        ComboBox_InsertString( hwnd, -1, (DWORD_PTR)i );

        if ( i == g_CurrCdrom ) {

            index = i;
        }

    }

    SetWindowRedraw( hwnd, TRUE );
    ComboBox_SetCurSel( hwnd, index );

    RedrawWindow( hwnd, NULL, NULL, RDW_INVALIDATE );
    UpdateWindow( hwnd );
}



/*****************************Private*Routine******************************\
* SwitchToCdrom
*
* This routine is called when the used selects a new cdrom device
* to access.  It handles reset the state of both the "old" and "new"
* chosen cdroms.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SwitchToCdrom(
    int NewCdrom,
    BOOL prompt
    )
{
    int oldState, oldState2;
    TCHAR   s1[256], s2[256];

    oldState = g_Devices[g_LastCdrom]->State;
    oldState2 = g_Devices[g_CurrCdrom]->State;

    if (NewCdrom != g_LastCdrom) {

        if (prompt) {

            if (g_Devices[g_CurrCdrom]->State & CD_PLAYING) {

                _tcscpy( s1, IdStr( STR_CANCEL_PLAY ) );
                _tcscpy( s2, IdStr( STR_CHANGE_CDROM ) );

                if ( MessageBox( g_hwndApp, s1, s2,
                                MB_APPLMODAL | MB_DEFBUTTON1 |
                                MB_ICONQUESTION | MB_YESNO) != IDYES ) {
                    return;
                }
            }
        }


        /*
        ** stop the drive we're leaving
        */

        g_CurrCdrom = g_LastCdrom;

        if (prompt && (g_State & (CD_PLAYING | CD_PAUSED)) ) {

            HWND hwndButton;

            hwndButton = g_hwndControls[INDEX(IDM_PLAYBAR_STOP)];

            SendMessage( hwndButton, WM_LBUTTONDOWN, 0, 0L );
            SendMessage( hwndButton, WM_LBUTTONUP, 0, 0L );

        } else {

            if ( StopTheCdromDrive( g_LastCdrom ) )
            {
                g_State &= (~(CD_PLAYING | CD_PAUSED));
                g_State |= CD_STOPPED;
                g_pSink->OnEvent(MMEVENT_ONSTOP,NULL);
            }
        }

        /*
        ** Set new cdrom drive and initialize time fields
        */

        g_LastCdrom = g_CurrCdrom = NewCdrom;

        TimeAdjustInitialize( g_CurrCdrom );

        if ( (oldState & CD_PAUSED) || (oldState2 & CD_PAUSED) )
        {
            SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_PLAY, 0L );
            SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_PAUSE, 0L );
        }
    }

    if (g_Devices[g_CurrCdrom]->State & CD_LOADED)
    {
        //need to set track button on main ui
        HWND hwndTrackButton = GetDlgItem(GetParent(g_hwndApp),IDB_TRACK);
        if (hwndTrackButton)
        {
            EnableWindow(hwndTrackButton,TRUE);
        }
    }
}


/*****************************Private*Routine******************************\
* FindTrackNodeFromTocIndex
*
* This routine returns the node in the listed pointed to by listhead which
* has the TocIndex equal to tocindex.  NULL is returned if it is not
* found.  Returning NULL can easily bomb out the program -- but we should
* never be calling this routine with an invalid tocindex, and thus really
* never SHOULD return NULL.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_INF
FindTrackNodeFromTocIndex(
    int tocindex,
    PTRACK_INF listhead
    )
{
    PTRACK_INF t;

    for( t = listhead; ((t!=NULL) && (t->TocIndex!=tocindex)); t=t->next );
    return t;
}


/*****************************Private*Routine******************************\
* FindFirstTrack
*
* This routine computes the first "playable" track on a disc by
* scanning the the play order of the tracks
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
FindFirstTrack(
    int cdrom
    )
{
    if ( (g_Devices[cdrom]->State & CD_NO_CD) ||
         (g_Devices[cdrom]->State & CD_DATA_CD_LOADED) ) {

        return NULL;
    }

    return PLAYLIST(cdrom);
}



/*****************************Private*Routine******************************\
* FindLastTrack
*
* This routine computes the last "playable" track on a disc by
* scanning the the play order of the tracks
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
FindLastTrack(
    IN INT cdrom
    )
{
    PTRACK_PLAY tr;

    if ( PLAYLIST(cdrom) == NULL ) {
        return NULL;
    }

    for( tr = PLAYLIST(cdrom); tr->nextplay != NULL; tr = tr->nextplay );

    return tr;
}


/*****************************Private*Routine******************************\
* AllTracksPlayed
*
* This routine searches the play lists for all cdrom drives and
* returns a flag as to whether all tracks on all cdrom drives have
* been played.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
AllTracksPlayed(
    void
    )
{

    INT i;
    BOOL result = TRUE;

    for( i = 0; i < g_NumCdDevices; i++ ) {

        result &= (CURRTRACK(i) == NULL);
    }

    return result;
}


/*****************************Private*Routine******************************\
* FindNextTrack
*
* This routine computes the next "playable" track.  This is a
* one way door...i.e., the structures are manipulated.  It uses
* the following algorithms:
*
* Single Disc Play:
*
*     * if next track is not NULL, return next track
*     * If next track is NULL, and wrap==TRUE, return
*       first track
*     * return NULL
*
* Multi-Disc Play:
*
*     * if we're in random play, select a random drive to play from.
*     * if next track on current cdrom != NULL, return next track
*     * if it is NULL:
*
*         * check next cdrom device, if current track is not NULL
*           return CURRTRACK for that device and set gCurrCdrom to
*           that device
*         * if NULL, go to next drive
*         * last drive, check wrap
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
FindNextTrack(
    BOOL wrap
    )
{
    int i;

    /*
    ** First, bump current track pointer
    */

    if ( CURRTRACK(g_CurrCdrom) != NULL )
    {
        CURRTRACK(g_CurrCdrom) = CURRTRACK(g_CurrCdrom)->nextplay;
    }
    else {

        if ( g_fSingleDisk ) {

            return NULL;
        }
    }

    /*
    ** Do we need to switch drives?
    */

    if ( (!g_fSelectedOrder) && (!g_fSingleDisk) ) {

        /*
        ** Need to random to new cdrom
        */

        g_CurrCdrom = rand() % g_NumCdDevices;

    }

    /*
    ** Is chosen track playable?
    */

    if ( CURRTRACK(g_CurrCdrom) != NULL ) {

        /*
        ** Yep, so this is the easy case
        */

        return CURRTRACK(g_CurrCdrom);
    }

    /*
    ** Ok, CURRENT track on this device is not defined,
    ** so are we in multi-disc mode?
    */
    if ( !g_fSingleDisk ) {

        /*
        ** have all tracks played?
        */

        if ( AllTracksPlayed() ) {

            /*
            ** if wrap, reset all drives to front of their playlist
            */

            if ( wrap ) {

                /*
                ** If we are in random play mode we need to re-shuffle the
                ** track list so that people don't get the same tracks repeated
                ** again.
                */
                if (!g_fSelectedOrder) {
                    RestorePlayListsFromShuffleLists();
                    ComputeAndUseShufflePlayLists();
                }

                for ( i = 0; i < g_NumCdDevices; i++ )  {

                    CURRTRACK(i) = FindFirstTrack(i);
                }
            }
            else {

                /*
                ** All tracks on all drives have played, and we are NOT
                ** in continuous mode, so we are done playing.  Signify
                ** this by returning NULL (no playable tracks left).
                */

                return NULL;
            }
        }


        /*
        ** We're in mulit-disc play mode, and all the play lists should
        ** be reset now.  Cycle through cdrom drives looking for a playable
        ** track.
        */

        i = g_CurrCdrom;
        do {

            g_CurrCdrom++;
            if ( g_CurrCdrom >= g_NumCdDevices ) {

                /*
                ** We hit the end of the list of devices, if we're
                ** in continuous play mode, we need to wrap to the
                ** first cdrom drive.  Otherwise, we are done playing
                ** as there are no tracks left to play.
                */

                if ( wrap || (!g_fSelectedOrder) ) {

                    g_CurrCdrom = 0;

                }
                else {

                    g_CurrCdrom--;
                    return NULL;
                }
            }

        } while( (CURRTRACK(g_CurrCdrom) == NULL) && (i != g_CurrCdrom) );

        /*
        ** At this point we either have a playable track, or we
        ** are back where we started from and we're going to return
        ** NULL because there are no playable tracks left.
        */

        return CURRTRACK(g_CurrCdrom);

    }
    else {

        /*
        ** We're in single disc mode, and current track is NULL,
        ** which means we hit the end of the playlist.  So, check
        ** to see if we should wrap back to the first track, or
        ** return NULL to show that we're done playing.
        */

        if (wrap) {

            /*
            ** If we are in random play mode we need to re-shuffle the
            ** track list so that people don't get the same tracks repeated
            ** again.
            */
            if (!g_fSelectedOrder) {
                RestorePlayListsFromShuffleLists();
                ComputeAndUseShufflePlayLists();
            }

            /*
            ** wrap to start of the play list
            */

            CURRTRACK(g_CurrCdrom) = FindFirstTrack(g_CurrCdrom);
        }

        return CURRTRACK(g_CurrCdrom);
    }
}


/*****************************Private*Routine******************************\
* FindPrevTrack
*
* This routine computes the previous "playable" track on a disc by
* scanning the play order of the tracks from the current
* track to the start of the play list.  If we are at the start
* of the play list, then move to the end of the list if we
* are in "wrap" (i.e., continuous) play mode, otherwise return
* the current track.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
FindPrevTrack(
    int cdrom,
    BOOL wrap
    )
{
    /*
    ** Is current track valid?
    */

    if ( CURRTRACK(cdrom) == NULL )
    {
        return NULL;
    }


    /*
    ** If we're in multi disc play && random, the previous track
    ** is undefined since we could be jumping around on
    ** multiple discs.
    **
    ** FIXFIX -- do we want to allow users to back up in the random
    **           list of a particular drive?
    */

    if ((!g_fSingleDisk) && (!g_fSelectedOrder))
    {
        return CURRTRACK(cdrom);
    }


    /*
    ** Did we hit the start of the play list?
    */

    if ( CURRTRACK(cdrom)->prevplay == NULL )
    {
        /*
        ** We hit the start of the list, check to see if we should
        ** wrap to end of list or not...
        */

        //in the case of multidisc, we should go to the last track of the previous disc
        if ((!g_fSingleDisk) && (cdrom > 0))
        {
            g_CurrCdrom = cdrom-1;
            PTRACK_PLAY pNext = FindLastTrack(g_CurrCdrom);
            if (pNext == NULL)
            {
                //bad track on previous disc, return current
                g_CurrCdrom = cdrom;
                return (CURRTRACK(cdrom));
            }
            else
            {
                return pNext;
            }
        }

        if ( wrap && g_fSingleDisk )
        {
            return FindLastTrack(cdrom);
        }
        else
        {
            return CURRTRACK(cdrom);
        }
    }

    return CURRTRACK(cdrom)->prevplay;
}


/*****************************Private*Routine******************************\
* FindContiguousEnd
*
* This routine returns the node of the track within PlayList which makes
* the largest contiguous block of tracks starting w/the track pointed
* to by "tr."  It is used to play multiple tracks at as one track
* when they are programmed to be played in sequence.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
int
FindContiguousEnd(
    int cdrom,
    PTRACK_PLAY tr
    )
{
    int i;
    PTRACK_PLAY trend;

    /*
    ** If we're in muti-disc random play, we only play
    ** one track at a time, so just return next track.
    */

    if ( (!g_fSelectedOrder) && (!g_fSingleDisk) ) {

        return tr->TocIndex + 1;
    }

    /*
    ** go forward in the play list looking for contiguous blocks
    ** of tracks to play together.  We need to check the TocIndex
    ** of each track to see if they are in a "run" [ like 2-5, etc. ]
    */

    i= tr->TocIndex + 1;
    trend = tr;

    while ( (trend->nextplay != NULL) && (trend->nextplay->TocIndex == i) ) {

        trend = trend->nextplay;
        i++;
    }

    return trend->TocIndex + 1;
}


/*****************************Private*Routine******************************\
* FlipBetweenShuffleAndOrder
*
* This routine handles going from ordered play to shuffle play and vica\versa.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
FlipBetweenShuffleAndOrder(
    void
    )
{
    if ( (!g_fSelectedOrder) ) {

        /*
        ** Transitioning from Random to Ordered Play
        */

        RestorePlayListsFromShuffleLists();
    }
    else {
        /*
        ** Transitioning from Ordered to Random Play
        */

        ComputeAndUseShufflePlayLists();
    }
}


/*****************************Private*Routine******************************\
* ComputeAndUseShufflePlayLists
*
* This routine computes shuffled play lists for each drive, and sets
* the current PLAYLIST for erach drive to the newly computed shuffled
* PLAYLIST.  The old PLAYLIST for each drive is saved in SAVELIST.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ComputeAndUseShufflePlayLists(
    void
    )
{
    int i;

    for ( i = 0; i < g_NumCdDevices; i++ ) {

        ComputeSingleShufflePlayList( i );
    }
}


/*****************************Private*Routine******************************\
* ComputeSingleShufflePlayList
*
* This routine computes shuffled play lists for drive i, and sets
* the current PLAYLIST for it the newly computed shuffled
* PLAYLIST.  The old PLAYLIST is saved in SAVELIST.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ComputeSingleShufflePlayList(
    int i
    )
{
    int j, index, numnodes;
    PTRACK_PLAY temp, temp1, duplist, prev, OldPlayList;

    /*
    ** First, delete the existing playlist
    */
    OldPlayList = PLAYLIST(i);
    PLAYLIST(i) = NULL;

    /*
    ** Now, go through each drive and create a shuffled play list
    ** First step is to duplicate the old play list, then we will
    ** randomly pick off nodes and put them on the shuffle play list.
    */

    duplist = prev = NULL;
    numnodes = 0;
    for( temp = SAVELIST(i); temp != NULL; temp = temp->nextplay ) {
        temp1 = (TRACK_PLAY*)AllocMemory( sizeof(TRACK_PLAY) );
        *temp1 = *temp;
        temp1->nextplay = NULL;
        if (duplist) {

            temp1->prevplay = prev;
            prev->nextplay = temp1;
            prev = temp1;
        }
        else {

            duplist = temp1;
            temp1->prevplay = NULL;
            prev = temp1;
        }

        numnodes++;
    }

    /*
    ** Now, randomly pick off nodes
    */

    prev = NULL;
    for( j = 0; j < numnodes; j++ ) {

        index = rand() % (numnodes - j + 1);
        temp = duplist;
        while( --index>0 ) {
            temp = temp->nextplay;
        }

        /*
        ** Got the node to transfer to playlist (temp),
        ** so we need to detach it from duplist so we
        ** can tack it onto the end of the playlist.
        */

        if ( temp != NULL ) {

            /*
            ** Detach temp from playlist.
            */

            if ( temp == duplist ) {

                duplist = temp->nextplay;
            }

            if ( temp->nextplay ) {

                temp->nextplay->prevplay = temp->prevplay;
            }

            if ( temp->prevplay ) {

                temp->prevplay->nextplay = temp->nextplay;
            }

            /*
            ** Now, tack it onto the end of the PLAYLIST
            */

            if ( PLAYLIST(i) ) {

                prev->nextplay = temp;
                temp->prevplay = prev;
                temp->nextplay = NULL;
                prev = temp;
            }
            else {

                PLAYLIST(i) = temp;
                temp->prevplay = NULL;
                prev = temp;
                temp->nextplay = NULL;
            }
        }
    }

    /*
    ** we need to reset the CURRTRACK pointer so
    ** that it points to a node in PLAYLIST instead of SAVELIST
    */

    if ( (g_Devices[i]->State & CD_PLAYING) && (CURRTRACK(i) != NULL) ) {

        index = CURRTRACK(i)->TocIndex;
        for( temp = PLAYLIST(i); temp->TocIndex!=index; temp=temp->nextplay );
        CURRTRACK(i) = temp;
    }
    else {

        CURRTRACK(i) = PLAYLIST(i);

        if ( PLAYLIST(i) != NULL ) {

            CDTIME(i).TrackTotalMin = PLAYLIST(i)->min;
            CDTIME(i).TrackTotalSec = PLAYLIST(i)->sec;
            CDTIME(i).TrackRemMin   = PLAYLIST(i)->min;
            CDTIME(i).TrackRemSec   = PLAYLIST(i)->sec;
        }


    }

    /*
    ** if this is the current drive, we need to redo the tracks in
    ** the track list combobox.
    */

    if ( i == g_CurrCdrom ) {

        ResetTrackComboBox( i );

    }

    /*
    ** Finally, free up the memory from the old playlist.
    */
    temp = OldPlayList;
    while ( temp != NULL ) {

        temp1 = temp->nextplay;
        LocalFree( (HLOCAL)temp );
        temp = temp1;
    }
}


/*****************************Private*Routine******************************\
* RestorePlayListsFromShuffleLists
*
* This routine restores the PLAYLIST for each drive to it's "pre-shuffled"
* state.  This should be stored in SAVELIST.  Once the restoration is done,
* un-needed node are released.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
RestorePlayListsFromShuffleLists(
    void
    )
{
    int i,index;
    PTRACK_PLAY temp;

    for ( i = 0; i < g_NumCdDevices; i++ ) {

        if ( SAVELIST(i) ) {

            if ( CURRTRACK(i) != NULL ) {

                index = CURRTRACK(i)->TocIndex;
            }
            else {

                index = -1;
            }

            ErasePlayList(i);
            PLAYLIST(i) = CopyPlayList( SAVELIST(i) );

            /*
            ** Reset CURRTRACK pointer
            */

            if ( (g_Devices[i]->State & CD_PLAYING) && (index != -1) ) {

                for( temp = PLAYLIST(i);
                     temp->TocIndex != index; temp=temp->nextplay );

                CURRTRACK(i) = temp;
            }
            else {

                CURRTRACK(i) = PLAYLIST(i);

                if ( PLAYLIST(i) != NULL ) {
                    CDTIME(i).TrackRemMin   = PLAYLIST(i)->min;
                    CDTIME(i).TrackRemSec   = PLAYLIST(i)->sec;
                    CDTIME(i).TrackTotalMin = PLAYLIST(i)->min;
                    CDTIME(i).TrackTotalSec = PLAYLIST(i)->sec;
                }
            }
        }

        if ( i == g_CurrCdrom ) {

            ResetTrackComboBox( i );
        }
    }
}



/*****************************Private*Routine******************************\
* FigureTrackTime
*
* This routine computes the length of a given track, in terms
* of minutes and seconds.
*
*   cdrom - supplies an index into the global structure gDevices
*
*   index - supplies an index to the track which should have its
*           length computed.  This is an index into the
*           gDevices[cdrom]->CdInfo.Tracks[...] structure
*
*   min   - supplies a pointer to an INT which will hold the minute
*           portion of the track length.
*
*   sec   - supplies a pointer to an INT which will hold the seconds
*           portion of the track length.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
FigureTrackTime(
    int cdrom,
    int index,
    int * min,
    int * sec
    )
{

    DWORD start, end, diff;

    start = ((TRACK_M(cdrom,index) * FRAMES_PER_MINUTE) +
             (TRACK_S(cdrom,index) * FRAMES_PER_SECOND) +
              TRACK_F(cdrom,index));

    end   = ((TRACK_M(cdrom,index+1) * FRAMES_PER_MINUTE) +
             (TRACK_S(cdrom,index+1) * FRAMES_PER_SECOND) +
              TRACK_F(cdrom,index+1));

    diff = end - start;

    (*min)   = (diff / FRAMES_PER_MINUTE);
    (*sec)   = (diff % FRAMES_PER_MINUTE) / FRAMES_PER_SECOND;

}



/*****************************Private*Routine******************************\
* TimeAdjustInitialize
*
*   Initializes the time, track, and title fields of a given
*   disc.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TimeAdjustInitialize(
    int cdrom
    )
{
    int m, s, mtemp, stemp, ts, tm;
    PTRACK_PLAY tr;


    /*
    ** Is there even a cd loaded?
    */

    if (g_Devices[cdrom]->State &
        (CD_BEING_SCANNED | CD_IN_USE | CD_NO_CD | CD_DATA_CD_LOADED)) {

        /*
        ** Fake some information
        */

        g_Devices[cdrom]->CdInfo.NumTracks = 0;
        g_Devices[cdrom]->toc.FirstTrack = 0;
        g_Devices[cdrom]->CdInfo.Id = 0;

        if (g_Devices[cdrom]->State & CD_IN_USE) {
            _tcscpy( (LPTSTR)TITLE(cdrom),  IdStr(STR_WAITING) );
            _tcscpy( (LPTSTR)ARTIST(cdrom), IdStr(STR_DISC_INUSE) );
        }
        else if (g_Devices[cdrom]->State & CD_BEING_SCANNED) {
            _tcscpy( (LPTSTR)TITLE(cdrom),  IdStr(STR_WAITING) );
            _tcscpy( (LPTSTR)ARTIST(cdrom), IdStr(STR_BEING_SCANNED) );
        }
        else
        {
            _tcscpy( (LPTSTR)TITLE(cdrom),  IdStr(STR_INSERT_DISC) );
            if (g_Devices[cdrom]->State & CD_DATA_CD_LOADED)
            {
                _tcscpy( (LPTSTR)ARTIST(cdrom), IdStr(STR_DATA_DISC) );
            }
            else
            {
                _tcscpy( (LPTSTR)ARTIST(cdrom), IdStr(STR_NO_DISC) );
            }
        }

        /*
        ** Kill off play list
        */

        ErasePlayList( cdrom );
        EraseSaveList( cdrom );
        EraseTrackList( cdrom );

        tr = NULL;
    }
    else {

        /*
        ** Find track to use as first track
        */

        tr = FindFirstTrack( cdrom );
    }

    /*
    ** Set current position information
    */

    CURRTRACK(cdrom) = tr;
    CDTIME(cdrom).TrackCurMin = 0;
    CDTIME(cdrom).TrackCurSec = 0;

    /*
    ** Compute PLAY length
    */

    mtemp = stemp = m = s = ts = tm =0;

    for( tr = PLAYLIST(cdrom); tr != NULL; tr = tr->nextplay ) {

        FigureTrackTime( cdrom, tr->TocIndex, &mtemp, &stemp );

        m+=mtemp;
        s+=stemp;

        tr->min = mtemp;
        tr->sec = stemp;
    }

    /*
    ** to be safe, recalculate the SAVE list each time as well.
    */
    for( tr = SAVELIST(cdrom); tr != NULL; tr = tr->nextplay ) {

        FigureTrackTime( cdrom, tr->TocIndex, &mtemp, &stemp );

        tr->min = mtemp;
        tr->sec = stemp;
    }


    m += (s / 60);
    s =  (s % 60);

    CDTIME(cdrom).TotalMin = m;
    CDTIME(cdrom).TotalSec = s;
    CDTIME(cdrom).RemMin = m;
    CDTIME(cdrom).RemSec = s;

    /*
    ** Fill in track length and information
    */

    if ( CURRTRACK(cdrom) != NULL ) {

        CDTIME(cdrom).TrackTotalMin = CDTIME(cdrom).TrackRemMin =
            CURRTRACK(cdrom)->min;

        CDTIME(cdrom).TrackTotalSec = CDTIME(cdrom).TrackRemSec =
            CURRTRACK(cdrom)->sec;
    }
    else {

        CDTIME(cdrom).TrackTotalMin = CDTIME(cdrom).TrackRemMin = 0;
        CDTIME(cdrom).TrackTotalSec = CDTIME(cdrom).TrackRemSec = 0;
    }

    /*
    ** Fill in track list combo box
    */

    if ( cdrom == g_CurrCdrom ) {

        ResetTrackComboBox( cdrom );

        /*
        ** Update display if this is the disc currently
        ** being displayed.
        */

        UpdateDisplay( DISPLAY_UPD_LED        |
                       DISPLAY_UPD_DISC_TIME  |
                       DISPLAY_UPD_TRACK_TIME |
                       DISPLAY_UPD_TITLE_NAME |
                       DISPLAY_UPD_TRACK_NAME );
    }

}



/*****************************Private*Routine******************************\
* TimeAdjustIncSecond
*
* Adds one second onto current position ("time") of disc
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TimeAdjustIncSecond(
    int cdrom
    )
{

    PTRACK_PLAY tr;

    /*
    ** If there is no current track just return
    */
    if ( CURRTRACK(g_CurrCdrom) == NULL ) {
        return;
    }

    /*
    ** Update current track time
    */

    CDTIME(cdrom).TrackCurSec++;
    if ( CDTIME(cdrom).TrackCurSec > 59 ) {

        CDTIME(cdrom).TrackCurMin++;
        CDTIME(cdrom).TrackCurSec = 0;
    }

    /*
    ** Now, check to see if we skipped any track boundaries
    */

    if (
        ((CDTIME(cdrom).TrackCurMin >= CDTIME(cdrom).TrackTotalMin) &&
         (CDTIME(cdrom).TrackCurSec >= CDTIME(cdrom).TrackTotalSec))

        ||

        ((g_fIntroPlay) &&
        ((CDTIME(cdrom).TrackCurMin >  0) ||
         (CDTIME(cdrom).TrackCurSec > g_IntroPlayLength)) )

       ) {

        /*
        ** We did, so skip to next track
        */

        /*
        ** FIXFIX for new FindNextTrack
        */

        tr = FindNextTrack( g_fContinuous );

        if ( tr == NULL ) {

            /*
            ** Hit end of playlist, so stay at end of current
            ** track.
            */

            if (!g_fIntroPlay) {

                CDTIME(cdrom).TrackCurMin = CDTIME(cdrom).TrackTotalMin;
                CDTIME(cdrom).TrackCurSec = CDTIME(cdrom).TrackTotalSec;
            }
            else {

                CDTIME(cdrom).TrackCurMin = 0;
                CDTIME(cdrom).TrackCurSec = g_IntroPlayLength;
            }

            return;

        }

        if ( g_CurrCdrom != g_LastCdrom) {

            SwitchToCdrom(g_CurrCdrom, FALSE );
        }

        TimeAdjustSkipToTrack( cdrom, tr );
    }
    else {

        /*
        ** Update current track remaining time
        */

        CDTIME(cdrom).TrackRemSec--;
        if ( CDTIME(cdrom).TrackRemSec < 0 ) {

            CDTIME(cdrom).TrackRemMin--;
            CDTIME(cdrom).TrackRemSec = 59;
        }

        /*
        ** Update total remaining time
        */

        CDTIME(cdrom).RemSec--;
        if ( CDTIME(cdrom).RemSec < 0 ) {

            CDTIME(cdrom).RemMin--;
            CDTIME(cdrom).RemSec = 59;
        }
    }

    /*
    ** Update Display
    */

    UpdateDisplay( DISPLAY_UPD_LED );
}


/*****************************Private*Routine******************************\
* TimeAdjustDecSecond
*
* Subtracts one second from current position ("time") of disc
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TimeAdjustDecSecond(
    int cdrom
    )
{

    int min,sec;
    PTRACK_PLAY prev,tr;

    /*
    ** If there is no current track, just return
    */
    if ( CURRTRACK(g_CurrCdrom) == NULL ) {
        return;
    }

    /*
    ** Update current track
    */

    CDTIME(cdrom).TrackCurSec--;
    if ( CDTIME(cdrom).TrackCurSec < 0 ) {

        CDTIME(cdrom).TrackCurMin--;
        CDTIME(cdrom).TrackCurSec = 59;
    }

    /*
    ** Update current track remaining
    */

    CDTIME(cdrom).TrackRemSec++;
    if ( CDTIME(cdrom).TrackRemSec > 59 ) {

        CDTIME(cdrom).TrackRemMin++;
        CDTIME(cdrom).TrackRemSec = 0;
    }

    /*
    ** Update total remaining time
    */

    CDTIME(cdrom).RemSec++;
    if ( CDTIME(cdrom).RemSec > 59 ) {

        CDTIME(cdrom).RemMin++;
        CDTIME(cdrom).RemSec = 0;
    }

    /*
    ** Now, check to see if we skipped any boundaries we shouldn't have!
    */

    if ( CDTIME(cdrom).TrackCurMin < 0 ) {

        /*
        ** We went "off" the front end of the track,
        ** so we need to see what to do now.  Options
        ** are:
        **
        ** (1) Go to end of track before us.
        ** (2) If intro play, go to 0:10 of
        **     track before us.
        ** (3) If not in continuous play, and
        **     this is the first track, then
        **     just sit at 0:00
        */

        prev = FindPrevTrack( cdrom, g_fContinuous );

        //reset for multidisc case
        if (g_CurrCdrom != cdrom)
        {
            g_CurrCdrom = cdrom;
            prev = CURRTRACK(cdrom);
        }

        if ( prev == CURRTRACK(cdrom) ) {

            /*
            ** We are on the first track, and not in
            ** continuous mode, so just go to 0:00
            */

            CDTIME(cdrom).TrackCurSec = 0;
            CDTIME(cdrom).TrackCurMin = 0;
            CDTIME(cdrom).TrackRemMin = CDTIME(cdrom).TrackTotalMin;
            CDTIME(cdrom).TrackRemSec = CDTIME(cdrom).TrackTotalSec;
            min = sec = 0;

            for( tr = PLAYLIST( cdrom ); tr != NULL; tr = tr->nextplay ) {

                min += tr->min;
                sec += tr->sec;
            }

            min += (sec / 60);
            sec  = (sec % 60);

            CDTIME(cdrom).RemMin = min;
            CDTIME(cdrom).RemSec = sec;

            UpdateDisplay( DISPLAY_UPD_LED );

        }
        else {

            /*
            ** Valid previous track
            */

            if ( !g_fIntroPlay ) {

                /*
                ** We need to place the current play position
                ** at the end of the previous track.
                */

                CDTIME(cdrom).TrackCurMin = CDTIME(cdrom).TrackTotalMin = prev->min;
                CDTIME(cdrom).TrackCurSec = CDTIME(cdrom).TrackTotalSec = prev->sec;
                CDTIME(cdrom).TrackRemMin = CDTIME(cdrom).TrackRemSec = 0;

                min = sec = 0;
                for( tr = prev->nextplay; tr != NULL; tr = tr->nextplay ) {

                    min += tr->min;
                    sec += tr->sec;
                }

                min += (sec / 60);
                sec  = (sec % 60);

                CDTIME(cdrom).RemMin = min;
                CDTIME(cdrom).RemSec = sec;
            }
            else {

                /*
                ** Intro play -- instead of end of track,
                **               jump to 00:10...
                */

                CDTIME(cdrom).TrackCurMin = 0;
                CDTIME(cdrom).TrackCurSec =
                    min( g_IntroPlayLength, prev->sec );

                CDTIME(cdrom).TrackTotalMin = prev->min;
                CDTIME(cdrom).TrackTotalSec = prev->sec;

                CDTIME(cdrom).TrackRemMin = CDTIME(cdrom).TrackTotalMin;
                CDTIME(cdrom).TrackRemSec = CDTIME(cdrom).TrackTotalSec -
                                        min( g_IntroPlayLength, prev->sec );

                if ( CDTIME(cdrom).TrackRemSec < 0 ) {

                    CDTIME(cdrom).TrackRemSec += 60;
                    CDTIME(cdrom).TrackRemMin--;
                }

                min = sec = 0;
                for( tr = prev; tr != NULL; tr = tr->nextplay ) {

                    min += tr->min;
                    sec += tr->sec;
                }

                sec -= min( g_IntroPlayLength, prev->sec );
                if ( sec < 0 ) {
                    sec+=60;
                    min--;
                }

                min += (sec / 60);
                sec  = (sec % 60);

                CDTIME(cdrom).RemMin = min;
                CDTIME(cdrom).RemSec = sec;
            }

            CURRTRACK(cdrom) = prev;

            UpdateDisplay( DISPLAY_UPD_LED        |
                           DISPLAY_UPD_TRACK_NAME |
                           DISPLAY_UPD_TRACK_TIME );

        }
    }
    else {

        UpdateDisplay( DISPLAY_UPD_LED );
    }
}


/*****************************Private*Routine******************************\
* InitializeNewTrackTime
*
* Updates track/time information for gDevices array.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
InitializeNewTrackTime(
    int cdrom,
    PTRACK_PLAY tr,
    BOOL fUpdateDisplay
    )
{
    int min,sec;

    /*
    ** Update time information in gDevices structure
    */

    CDTIME(cdrom).CurrTrack = tr;
    CDTIME(cdrom).TrackCurMin = 0;
    CDTIME(cdrom).TrackCurSec = 0;

    if (tr == NULL) {

        CDTIME(cdrom).TrackTotalMin = 0;
        CDTIME(cdrom).TrackTotalSec = 0;

    }
    else {

        CDTIME(cdrom).TrackTotalMin = CDTIME(cdrom).TrackRemMin = tr->min;
        CDTIME(cdrom).TrackTotalSec = CDTIME(cdrom).TrackRemSec = tr->sec;

    }

    min = sec = 0;
    for( tr = PLAYLIST(cdrom); tr!=NULL; tr = tr->nextplay ) {

        min += tr->min;
        sec += tr->sec;
    }

    min += (sec / 60);
    sec  = (sec % 60);

    CDTIME(cdrom).RemMin = min;
    CDTIME(cdrom).RemSec = sec;

    /*
    ** Update LED box
    */
    if (fUpdateDisplay) {
        UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_NAME |
                       DISPLAY_UPD_TRACK_TIME );
    }
}




/*****************************Private*Routine******************************\
* TimeAdjustSkipToTrack
*
*   Updates time/track information for gDevices array and then
*   issues skip to track commands to cdrom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TimeAdjustSkipToTrack(
    int cdrom,
    PTRACK_PLAY tr
    )
{

    /*
    ** Update time information in gDevices structure
    */

    InitializeNewTrackTime( cdrom, tr, TRUE );

    /*
    ** Actually seek to the track, and play it if appropriate
    */

    if ((g_Devices[cdrom]->State & CD_PLAYING) ||
        (g_Devices[cdrom]->State & CD_PAUSED)) {

        PlayCurrTrack( cdrom );
        if (g_Devices[cdrom]->State & CD_PAUSED) {
            PauseTheCdromDrive( cdrom );
        }
    }
    else if (tr) {
        SeekToTrackAndHold( cdrom, tr->TocIndex );
    }
}


/*****************************Private*Routine******************************\
* SyncDisplay
*
* Queries the cdrom device for its current position, and then
* updates the display accordingly.  Also, detects when a track has
* finished playing, or when intro segment is over, and skips to the
* next track.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SyncDisplay(
    void
    )
{
    int m,s;
    PTRACK_PLAY next;
    CURRPOS cp;
    PCURRPOS pCurr = &cp;


    /*
    ** If there isn't a disc in the drive, ignore this
    ** request
    */

    if ( (g_Devices[g_CurrCdrom]->State & CD_NO_CD) ||
         (g_Devices[g_CurrCdrom]->State & CD_DATA_CD_LOADED) ) {
       return;
    }

    /*
    ** Query cdrom device for current position
    */

    if ( !GetCurrPos( g_CurrCdrom, pCurr ) ) {

        /*
        ** If there was an error, it will already have been
        ** reported in CheckStatus of cdapi.c...so, we don't need
        ** to tell anything more here.  When an error occurs, the
        ** fields of the pCurr structure are zeroed, so we don't
        ** need to clean those up either
        */

        return;
    }

    /*
    ** Has the current play selection finished playing?
    */
#ifdef USE_IOCTLS
    if ((pCurr->AudioStatus == AUDIO_STATUS_PLAY_COMPLETE) &&
        ( !(g_State & CD_SEEKING) )) {
#else

    if ((pCurr->AudioStatus == (DWORD)MCI_MODE_STOP) &&
        ( !(g_State & CD_SEEKING) )) {
#endif

Play_Complete:

        /*
        ** Yep, so skip to the next track.
        */
        if (g_fRepeatSingle)
        {
            next = CURRTRACK(g_CurrCdrom);
        }
        else
        {
            next = FindNextTrack( g_fContinuous );
        }

        if ( next == NULL ) {

            /*
            ** There are no more tracks to play, so
            ** fake a press on the "stop" button.  But,
            ** we want to set gCurrCdrom back to the "playing"
            ** drive 'cause it may have changed in our call
            ** to FindNextTrack.
            */

            g_CurrCdrom = g_LastCdrom;
            SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_STOP, 0L );
        }
        else {

            if ( g_CurrCdrom != g_LastCdrom ) {

                SwitchToCdrom( g_CurrCdrom, FALSE );

                /*
                ** We use to start the disc play by sending the play command.
                ** SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_PLAY, 0L );
                ** However, all we realy need to put the drives state into
                ** playing and let TimeAdjustSkipToTrack take care of starting
                ** playing.  If we don't do this when the app is in multi-disc
                ** random play mode, we get a fraction of a second of the
                ** first track in the playlist played before we seek to the
                ** the correct track and start playing it.  This sounds really
                ** bad.
                */

                g_State &= ~CD_STOPPED;
                g_State |= CD_PLAYING;

                //tell the main ui
                g_pSink->OnEvent(MMEVENT_ONPLAY,NULL);

            }

            TimeAdjustSkipToTrack( g_CurrCdrom, next );
        }

        return;
    }

    /*
    ** Check to see if we need to update the display
    */

    if ( (pCurr->Track < 100) && ( pCurr->Track >
         (CURRTRACK(g_CurrCdrom)->TocIndex + FIRSTTRACK(g_CurrCdrom)) )) {

        /*
        ** We got to the next track in a multi-track
        ** play, so mark per track information for
        ** new track
        */
        if ((CURRTRACK(g_CurrCdrom)->nextplay != NULL) &&
             (((CURRTRACK(g_CurrCdrom)->TocIndex + 1) ==
              CURRTRACK(g_CurrCdrom)->nextplay->TocIndex)||!g_fSelectedOrder))
              {

            if (g_fRepeatSingle)
            {
                next = CURRTRACK(g_CurrCdrom);
                TimeAdjustSkipToTrack( g_CurrCdrom, next );
            }
            else
            {
                next = FindNextTrack( g_fContinuous );
            }

            if (!g_fSelectedOrder)
            {
                if (next!=NULL)
                {
                    TimeAdjustSkipToTrack( g_CurrCdrom, next );
                }
            }

            if ( next == NULL ) {

                /*
                ** There are no more tracks to play, so
                ** fake a press on the "stop" button.  But,
                ** we want to set gCurrCdrom back to the "playing"
                ** drive 'cause it may have changed in our call
                ** to FindNextTrack.
                */

                g_CurrCdrom = g_LastCdrom;

                SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                             WM_LBUTTONDOWN, 0, 0L );

                SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                             WM_LBUTTONUP, 0, 0L );

            }
            else {

                if ( g_CurrCdrom != g_LastCdrom ) {

                    SwitchToCdrom( g_CurrCdrom, FALSE );
                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONDOWN, 0, 0L );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONUP, 0, 0L );
                }

                InitializeNewTrackTime( g_CurrCdrom, next, FALSE );
                UpdateDisplay( DISPLAY_UPD_TRACK_NAME | DISPLAY_UPD_TRACK_TIME );
            }
        }
        else {

            /*
            ** If we get here it is probably the result of starting
            ** CD Player whislt the current disc was still playing.
            ** We look for the currently playing track in the current
            ** playlist.
            */

            next = FindFirstTrack(g_CurrCdrom);
            PTRACK_PLAY last = next;

            while ( (next != NULL)
                 && (pCurr->Track != (next->TocIndex + 1)) ) {

#if DBG
                dprintf(TEXT("trying track %d"), (next->TocIndex + 1));
#endif
                last = next;
                next = next->nextplay;
            }

            /*
            ** If next is NULL it means that we are playing a track that
            ** is currently not on the users playlist.  So, we put up a
            ** message box informing the user of this fact and that we are
            ** going to temporarily add the track to the current playlist
            ** as the first track.  Otherwise, we found the track in the
            ** playlist so just update the track time for this track.
            */

            if (pCurr->Track < NUMTRACKS(g_CurrCdrom))
            {
                if (next == NULL)
                {
                    AddTemporaryTrackToPlayList(pCurr);
                }
                else
                {
                    InitializeNewTrackTime( g_CurrCdrom, next, TRUE );
                }
            }
            else
            {
                if (!g_fRepeatSingle)
                {
	                SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_STOP, 0L );
	                if (g_fContinuous)
				    {
    					SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_PLAY, 0L );
				    }
                } //end if not repeating single
                else
                {
                    next = last;
                    TimeAdjustSkipToTrack( g_CurrCdrom, next );
                } //end repeating single
            } //end if pcurr is bad
        }
        return;
    }

    if ( pCurr->Track <
         (CURRTRACK(g_CurrCdrom)->TocIndex + FIRSTTRACK(g_CurrCdrom)) )
        return;

    if ( (pCurr->Index != 0)
      && (pCurr->m <= CDTIME(g_CurrCdrom).TrackCurMin)
      && (pCurr->s <= CDTIME(g_CurrCdrom).TrackCurSec) )

        return;

    /*
    ** Set track elapsed time
    */

    CDTIME(g_CurrCdrom).TrackCurMin = pCurr->m;
    CDTIME(g_CurrCdrom).TrackCurSec = pCurr->s;

    /*
    ** Set track remaining time
    */

    m = pCurr->m;

    if ( (pCurr->s) <= CDTIME(g_CurrCdrom).TrackTotalSec ) {

        s = CDTIME(g_CurrCdrom).TrackTotalSec - pCurr->s;
    }
    else {

        s = 60 - (pCurr->s - CDTIME(g_CurrCdrom).TrackTotalSec);
        m++;
    }

    CDTIME(g_CurrCdrom).TrackRemMin = CDTIME(g_CurrCdrom).TrackTotalMin - m;
    CDTIME(g_CurrCdrom).TrackRemSec = s;

    /*
    ** Set disc remaining time
    **
    ** BUGBUG -- for now, just decrement by 1 second
    */

    CDTIME(g_CurrCdrom).RemSec--;
    if (CDTIME(g_CurrCdrom).RemSec < 0) {

        CDTIME(g_CurrCdrom).RemSec = 59;
        CDTIME(g_CurrCdrom).RemMin--;
    }


    /*
    ** Update LED box
    */

    if ( (pCurr->Index != 0) || ((pCurr->m == 0) && (pCurr->s == 0)) ) {

        UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_NAME );
    }
    else {

        UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_LEADOUT_TIME );
    }

    /*
    ** Check to see if we are intro play and have played
    ** intro segment...if so, skip to next track
    */

    if ( ((pCurr->s >= (g_IntroPlayLength + 1)) || (pCurr->m > 0))
      && g_fIntroPlay ) {

        goto Play_Complete;
    }
}




/*****************************Private*Routine******************************\
* ValidatePosition
*
* Checks the current position on the CD, then verifies that the
* relative offset in the track + the beginning of the track's
* position is the same as the absolute position on the CD.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ValidatePosition(
    int cdrom
    )
{
    int Mult, Frames;
    CURRPOS cp;
    PCURRPOS pCurr = &cp;
    LPTSTR s1,s2;


    if (!GetCurrPos( cdrom, pCurr ))

        /*
        ** If there was an error, it will already have been
        ** reported in CheckStatus of cdapi.c...so, we don't need
        ** to tell anything more here.  When an error occurs, the
        ** fields of the pCurr structure are zeroed, so we don't
        ** need to clean those up either
        */

        return;


    /*
    ** Make sure the position returned is consistent with
    ** what we know about the CD. By comparing the relative time
    ** on this track to the absolute time on the CD, we should be
    ** able to make sure we're still on the right disc.  This is
    ** a failsafe for when polling fails to notice an ejected
    ** disc.
    */

    if ((cp.Track > 0)&&(cp.Track < 101)) {

        Frames = cp.ab_m * 60 * 75;
        Frames += cp.ab_s * 75;
        Frames += cp.ab_f;

        Frames -= TRACK_M(cdrom,cp.Track-1) * 60 * 75;
        Frames -= TRACK_S(cdrom,cp.Track-1) * 75;
        Frames -= TRACK_F(cdrom,cp.Track-1);
        if (pCurr->Index) {

            Mult = 1;
        }
        else {

            Mult = -1;
        }

        Frames -= Mult*cp.m * 60 * 75;
        Frames -= Mult*cp.s * 75;
        Frames -= Mult*cp.f;

        if (g_Devices[cdrom]->CdInfo.iFrameOffset ==  NEW_FRAMEOFFSET) {

            g_Devices[cdrom]->CdInfo.iFrameOffset = Frames;
        }

        if ((ABS(Frames - g_Devices[ cdrom ]->CdInfo.iFrameOffset) > 4) &&
            (ABS(Frames) > 4)) {

            HWND hwndStop;

            hwndStop = g_hwndControls[INDEX(IDM_PLAYBAR_STOP)];

            s1 = (TCHAR*)AllocMemory( _tcslen(IdStr(STR_BAD_DISC)) + 1 );
            _tcscpy( s1, IdStr(STR_BAD_DISC) );

            s2 = (TCHAR*)AllocMemory( _tcslen(IdStr(STR_CDPLAYER)) + 1);
            _tcscpy(s2,IdStr(STR_CDPLAYER));

            MessageBox( g_hwndApp, s1, s2, MB_APPLMODAL|MB_ICONSTOP|MB_OK );

            SendMessage( hwndStop,WM_LBUTTONDOWN, 1,0L );
            SendMessage( hwndStop,WM_LBUTTONUP, 1, 0L );

            RescanDevice(g_hwndApp, cdrom );

            LocalFree( (HLOCAL)s1 );
            LocalFree( (HLOCAL)s2 );

            return;
        }
    }
}



/*****************************Private*Routine******************************\
* ResetTrackComboBox
*
* This routine deletes and then resets the track name combobox based
* on the contents of the PLAYLIST for the specified cdrom drive.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
VOID
ResetTrackComboBox(
    int cdrom
    )
{
    int j,index;
    PTRACK_PLAY temp;
    HWND    hwnd;

    hwnd = g_hwndControls[INDEX(IDC_TRACK_LIST)];

    SetWindowRedraw( hwnd, FALSE );
    ComboBox_ResetContent( hwnd );

    /*
    ** Add new playlist, and select correct entry for current track
    */

    j = index = 0;
    for( temp = PLAYLIST(cdrom); temp != NULL; temp = temp->nextplay ) {

        ComboBox_InsertString( hwnd, -1, (DWORD_PTR)temp->TocIndex );

        if ( temp == CURRTRACK(cdrom) ) {

            index = j;
        }

        j++;

    }

    ComboBox_SetCurSel( hwnd, index );
    SetWindowRedraw( hwnd, TRUE );

    RedrawWindow( hwnd, NULL, NULL, RDW_INVALIDATE );
    UpdateWindow( hwnd );

    UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME );

}

/******************************Public*Routine******************************\
* PlayListMatchesAvailList
*
* Compares the current play list with the default play list to if they match.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
PlayListMatchesAvailList(
    void
    )
{

    PTRACK_PLAY pl = SAVELIST(g_CurrCdrom);
    int i = 0;

    while (pl && i < NUMTRACKS(g_CurrCdrom)) {

        if ( pl->TocIndex != i) {
            return FALSE;
        }
        pl = pl->nextplay;
        i++;
    }

    return pl == NULL && i == NUMTRACKS(g_CurrCdrom);
}


/*****************************Private*Routine******************************\
* AddTemporaryTrackToPlayList
*
* This functions adds the currently playing track to the playlist.
* pCurr contains the toc index of the track that is required to be added.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
AddTemporaryTrackToPlayList(
    PCURRPOS pCurr
    )
{
    // LPTSTR lpstrTitle;
    // LPTSTR lpstrText;
    PTRACK_PLAY tr;
    int m, s;


    /*
    ** Add track to the current playlist.
    */
    tr = (TRACK_PLAY*)AllocMemory( sizeof(TRACK_PLAY) );
    tr->TocIndex = pCurr->Track - 1;
    FigureTrackTime(g_CurrCdrom, tr->TocIndex, &tr->min, &tr->sec);

    tr->nextplay = PLAYLIST(g_CurrCdrom);
    tr->prevplay = NULL;

    PLAYLIST(g_CurrCdrom)->prevplay = tr;
    PLAYLIST(g_CurrCdrom) = tr;

    /*
    ** Update the display.
    */
    InitializeNewTrackTime( g_CurrCdrom, tr, TRUE );
    ResetTrackComboBox( g_CurrCdrom );

    m = CDTIME(g_CurrCdrom).TotalMin + tr->min;
    s = CDTIME(g_CurrCdrom).TotalSec + tr->sec;

    m += (s / 60);
    s =  (s % 60);

    CDTIME(g_CurrCdrom).TotalMin = m;
    CDTIME(g_CurrCdrom).TotalSec = s;
    UpdateDisplay(DISPLAY_UPD_DISC_TIME);


    /*
    ** Now modify the current saved playlist.  We do this so that transitions
    ** from/to random mode work correctly.
    */
    tr = (TRACK_PLAY*)AllocMemory( sizeof(TRACK_PLAY) );
    tr->TocIndex = pCurr->Track - 1;
    FigureTrackTime(g_CurrCdrom, tr->TocIndex, &tr->min, &tr->sec);

    tr->nextplay = SAVELIST(g_CurrCdrom);
    tr->prevplay = NULL;

    SAVELIST(g_CurrCdrom)->prevplay = tr;
    SAVELIST(g_CurrCdrom) = tr;

#if 0
    /*
    ** Now, tell the user what we have just done.  Note that we disable the
    ** the Heart beat timer so that we don't renenter ourselves.
    */
    lpstrTitle = AllocMemory( STR_MAX_STRING_LEN * sizeof(TCHAR) );
    lpstrText  = AllocMemory( STR_MAX_STRING_LEN * sizeof(TCHAR) );

    _tcscpy( lpstrText, IdStr(STR_NOT_IN_PLAYLIST) );
    _tcscpy( lpstrTitle, IdStr(STR_CDPLAYER) );

    KillTimer( g_hwndApp, HEARTBEAT_TIMER_ID );

    MessageBox( NULL, lpstrText, lpstrTitle,
                MB_APPLMODAL | MB_ICONINFORMATION | MB_OK );

    SetTimer( g_hwndApp, HEARTBEAT_TIMER_ID, HEARTBEAT_TIMER_RATE,
              HeartBeatTimerProc );
    LocalFree( (HLOCAL)lpstrText );
    LocalFree( (HLOCAL)lpstrTitle );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\dib.cpp ===
/*----------------------------------------------------------------------------*\
|   Routines for dealing with Device independent bitmaps                       |
|                                                                              |
|   History:                                                                   |
|       06/23/89 toddla     Created                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/

#include <windows.h>
#include "dib.h"

#define HUGE_T

HANDLE CreateLogicalDib(HBITMAP hbm, WORD biBits, HPALETTE hpal);

static DWORD NEAR PASCAL lread(HFILE fh, VOID FAR *pv, DWORD ul);
static DWORD NEAR PASCAL lwrite(HFILE fh, VOID FAR *pv, DWORD ul);

/* flags for _lseek */
#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

/*
 *   Open a DIB file and return a MEMORY DIB, a memory handle containing..
 *
 *   BITMAP INFO    bi
 *   palette data
 *   bits....
 *
 */
HANDLE OpenDIB(LPTSTR szFile, HFILE fh)
{
    BITMAPINFOHEADER    bi;
    LPBITMAPINFOHEADER  lpbi;
    DWORD               dwLen;
    DWORD               dwBits;
    HANDLE              hdib;
    HANDLE              h;
#ifndef UNICODE
    OFSTRUCT            of;
#endif
    BOOL fOpened = FALSE;

    if (szFile != NULL) {
#ifdef UNICODE
	fh = (HFILE)HandleToUlong(CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ,
			 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
#else
	fh = OpenFile(szFile, &of, OF_READ);
#endif
	fOpened = TRUE;
    }

    if (fh == (HFILE)-1)
	return NULL;

    hdib = ReadDibBitmapInfo(fh);

    if (!hdib)
	return NULL;

    DibInfo((LPBITMAPINFOHEADER)GlobalLock(hdib),&bi);  GlobalUnlock(hdib);

    /* How much memory do we need to hold the DIB */

    dwBits = bi.biSizeImage;
    dwLen  = bi.biSize + PaletteSize(&bi) + dwBits;

    /* Can we get more memory? */

    h = GlobalReAlloc(hdib,dwLen,GMEM_MOVEABLE);

    if (!h)
    {
	GlobalFree(hdib);
	hdib = NULL;
    }
    else
    {
	hdib = h;
    }

    if (hdib)
    {
	lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

	/* read in the bits */
	lread(fh, (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi), dwBits);

	GlobalUnlock(hdib);
    }

    if (fOpened)
	_lclose(fh);

    return hdib;
}

/*
 *   Write a global handle in CF_DIB format to a file.
 *
 */
BOOL WriteDIB(LPTSTR szFile,HFILE fh, HANDLE hdib)
{
    BITMAPFILEHEADER    hdr;
    LPBITMAPINFOHEADER  lpbi;
    BITMAPINFOHEADER    bi;
    DWORD               dwSize;
    BOOL fOpened = FALSE;

    if (!hdib)
	return FALSE;

    if (szFile != NULL) {       
#ifdef UNICODE
	fh = (HFILE)HandleToUlong(CreateFile(szFile,GENERIC_WRITE | GENERIC_READ, 0,
			     NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL));
#else
	OFSTRUCT            of;
	fh = OpenFile(szFile,&of,OF_CREATE|OF_READWRITE);
#endif
	fOpened = TRUE;
    }

    if (fh == (HFILE)-1)
	return FALSE;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);
    DibInfo(lpbi,&bi);

    dwSize = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;


    hdr.bfType          = BFT_BITMAP;
    hdr.bfSize          = dwSize + sizeof(BITMAPFILEHEADER);
    hdr.bfReserved1     = 0;
    hdr.bfReserved2     = 0;
    hdr.bfOffBits       = (DWORD)sizeof(BITMAPFILEHEADER) + lpbi->biSize +
			  PaletteSize(lpbi);

    _lwrite(fh,(const char*)&hdr,sizeof(BITMAPFILEHEADER));
    lwrite(fh,(LPVOID)lpbi,dwSize);

    GlobalUnlock(hdib);

    if (fOpened)
	_lclose(fh);

    return TRUE;
}

/*
 *  DibInfo(hbi, lpbi)
 *
 *  retrives the DIB info associated with a CF_DIB format memory block.
 */
BOOL  DibInfo(LPBITMAPINFOHEADER lpbiSource, LPBITMAPINFOHEADER lpbiTarget)
{
    if (lpbiSource)
    {
	*lpbiTarget = *lpbiSource;

	if (lpbiTarget->biSize == sizeof(BITMAPCOREHEADER))
	{
	    BITMAPCOREHEADER bc;

	    bc = *(LPBITMAPCOREHEADER)lpbiTarget;

	    lpbiTarget->biSize               = sizeof(BITMAPINFOHEADER);
	    lpbiTarget->biWidth              = (DWORD)bc.bcWidth;
	    lpbiTarget->biHeight             = (DWORD)bc.bcHeight;
	    lpbiTarget->biPlanes             =  (UINT)bc.bcPlanes;
	    lpbiTarget->biBitCount           =  (UINT)bc.bcBitCount;
	    lpbiTarget->biCompression        = BI_RGB;
	    lpbiTarget->biSizeImage          = 0;
	    lpbiTarget->biXPelsPerMeter      = 0;
	    lpbiTarget->biYPelsPerMeter      = 0;
	    lpbiTarget->biClrUsed            = 0;
	    lpbiTarget->biClrImportant       = 0;
	}

	/*
	 * fill in the default fields
	 */
	if (lpbiTarget->biSize != sizeof(BITMAPCOREHEADER))
	{
	    if (lpbiTarget->biSizeImage == 0L)
		lpbiTarget->biSizeImage = (DWORD)DIBWIDTHBYTES(*lpbiTarget) * lpbiTarget->biHeight;

	    if (lpbiTarget->biClrUsed == 0L)
		lpbiTarget->biClrUsed = DibNumColors(lpbiTarget);
	}
	return TRUE;
    }
    return FALSE;
}

HPALETTE CreateColorPalette()
{
    LOGPALETTE          *pPal;
    HPALETTE            hpal = NULL;
    WORD                nNumColors;
    BYTE                red;
    BYTE                green;
    BYTE                blue;
    int                 i;

    nNumColors = MAXPALETTE;
    pPal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));

    if (!pPal)
	goto exit;

    pPal->palNumEntries = nNumColors;
    pPal->palVersion    = PALVERSION;

    red = green = blue = 0;

    for (i = 0; i < pPal->palNumEntries; i++)
    {
	pPal->palPalEntry[i].peRed   = red;
	pPal->palPalEntry[i].peGreen = green;
	pPal->palPalEntry[i].peBlue  = blue;
	pPal->palPalEntry[i].peFlags = (BYTE)0;

	if (!(red += 32))
	    if (!(green += 32))
		blue += 64;
    }

    hpal = CreatePalette(pPal);
    LocalFree((HANDLE)pPal);

exit:
    return hpal;
}

/*
 *  CreateBIPalette()
 *
 *  Given a Pointer to a BITMAPINFO struct will create a
 *  a GDI palette object from the color table.
 *
 *  works with "old" and "new" DIB's
 *
 */
HPALETTE CreateBIPalette(LPBITMAPINFOHEADER lpbi)
{
    LOGPALETTE          *pPal;
    HPALETTE            hpal = NULL;
    WORD                nNumColors;
    UINT                i;
    RGBQUAD        FAR *pRgb;
    BOOL                fCoreHeader;

    if (!lpbi)
	return NULL;

    nNumColors = DibNumColors(lpbi);

    if (nNumColors)
    {
		fCoreHeader = (lpbi->biSize == sizeof(BITMAPCOREHEADER));

		pRgb = (RGBQUAD FAR *)((LPBYTE)lpbi + (UINT)lpbi->biSize);
		pPal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));

		if (!pPal)
			goto exit;

		pPal->palNumEntries = nNumColors;
		pPal->palVersion    = PALVERSION;

		for (i = 0; i < nNumColors; i++)
		{
			pPal->palPalEntry[i].peRed       = pRgb->rgbRed;
			pPal->palPalEntry[i].peGreen = pRgb->rgbGreen;
			pPal->palPalEntry[i].peBlue  = pRgb->rgbBlue;
			pPal->palPalEntry[i].peFlags = (BYTE)0;

			if (fCoreHeader)
				//((LPBYTE)pRgb) += sizeof(RGBTRIPLE) ;
                pRgb += sizeof(RGBTRIPLE) ;
			else
				pRgb++;
		}

		hpal = CreatePalette(pPal);
		LocalFree((HANDLE)pPal);
    }
    else if (lpbi->biBitCount == 24)
    {
	hpal = CreateColorPalette();
    }

exit:
    return hpal;
}


/*
 *  CreateDibPalette()
 *
 *  Given a Global HANDLE to a BITMAPINFO Struct
 *  will create a GDI palette object from the color table.
 *
 *  works with "old" and "new" DIB's
 *
 */
HPALETTE CreateDibPalette(HANDLE hbi)
{
    HPALETTE hpal;

    if (!hbi)
	return NULL;

    hpal = CreateBIPalette((LPBITMAPINFOHEADER)GlobalLock(hbi));
    GlobalUnlock(hbi);
    return hpal;
}

HPALETTE CreateExplicitPalette()
{
    PLOGPALETTE ppal;
    HPALETTE    hpal;
    int         i;
    #define     NPAL   256

    ppal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * NPAL);

    ppal->palVersion    = 0x300;
    ppal->palNumEntries = NPAL;

    for (i=0; i<NPAL; i++)
    {
	ppal->palPalEntry[i].peFlags = (BYTE)PC_EXPLICIT;
	ppal->palPalEntry[i].peRed   = (BYTE)i;
	ppal->palPalEntry[i].peGreen = (BYTE)0;
	ppal->palPalEntry[i].peBlue  = (BYTE)0;
    }

    hpal = CreatePalette(ppal);
    LocalFree((HANDLE)ppal);
    return hpal;
}



/*
 *  ReadDibBitmapInfo()
 *
 *  Will read a file in DIB format and return a global HANDLE to it's
 *  BITMAPINFO.  This function will work with both "old" and "new"
 *  bitmap formats, but will always return a "new" BITMAPINFO
 *
 */
HANDLE ReadDibBitmapInfo(HFILE fh)
{
    DWORD     off;
    HANDLE    hbi = NULL;
    int       size;
    int       i;
    UINT      nNumColors;

    RGBQUAD FAR       *pRgb;
    BITMAPINFOHEADER   bi;
    BITMAPCOREHEADER   bc;
    LPBITMAPINFOHEADER lpbi;
    BITMAPFILEHEADER   bf;

    if (fh == (HFILE)-1)
	return NULL;

    off = _llseek(fh,0L,SEEK_CUR);

    if (sizeof(bf) != _lread(fh,(LPBYTE)&bf,sizeof(bf)))
	return FALSE;

    /*
     *  do we have a RC HEADER?
     */
    if (!ISDIB(bf.bfType))
    {
	bf.bfOffBits = 0L;
	_llseek(fh,off,SEEK_SET);
    }

    if (sizeof(bi) != _lread(fh,(LPBYTE)&bi,sizeof(bi)))
	return FALSE;

    nNumColors = DibNumColors(&bi);

    /*
     *  what type of bitmap info is this?
     */
    switch (size = (int)bi.biSize)
    {
	case sizeof(BITMAPINFOHEADER):
	    break;

	case sizeof(BITMAPCOREHEADER):
	    bc = *(BITMAPCOREHEADER*)&bi;
	    bi.biSize               = sizeof(BITMAPINFOHEADER);
	    bi.biWidth              = (DWORD)bc.bcWidth;
	    bi.biHeight             = (DWORD)bc.bcHeight;
	    bi.biPlanes             =  (UINT)bc.bcPlanes;
	    bi.biBitCount           =  (UINT)bc.bcBitCount;
	    bi.biCompression        = BI_RGB;
	    bi.biSizeImage          = 0;
	    bi.biXPelsPerMeter      = 0;
	    bi.biYPelsPerMeter      = 0;
	    bi.biClrUsed            = nNumColors;
	    bi.biClrImportant       = nNumColors;

	    _llseek(fh,(LONG)(sizeof(BITMAPCOREHEADER)-sizeof(BITMAPINFOHEADER)),SEEK_CUR);

	    break;

	default:
	    return NULL;       /* not a DIB */
    }

    /*
     *  fill in some default values!
     */
    if (bi.biSizeImage == 0)
    {
	bi.biSizeImage = (DWORD)DIBWIDTHBYTES(bi) * bi.biHeight;
    }

    if (bi.biXPelsPerMeter == 0)
    {
	bi.biXPelsPerMeter = 0;         // ??????????????
    }

    if (bi.biYPelsPerMeter == 0)
    {
	bi.biYPelsPerMeter = 0;         // ??????????????
    }

    if (bi.biClrUsed == 0)
    {
	bi.biClrUsed = DibNumColors(&bi);
    }

    hbi = GlobalAlloc(GMEM_MOVEABLE,(LONG)bi.biSize + nNumColors * sizeof(RGBQUAD));
    if (!hbi)
	return NULL;

    lpbi = (BITMAPINFOHEADER *)GlobalLock(hbi);
    *lpbi = bi;

    pRgb = (RGBQUAD FAR *)((LPBYTE)lpbi + bi.biSize);

    if (nNumColors)
    {
	if (size == (int)sizeof(BITMAPCOREHEADER))
	{
	    /*
	     * convert a old color table (3 byte entries) to a new
	     * color table (4 byte entries)
	     */
	    _lread(fh,(LPBYTE)pRgb,nNumColors * sizeof(RGBTRIPLE));

	    for (i=nNumColors-1; i>=0; i--)
	    {
		RGBQUAD rgb;

		rgb.rgbRed      = ((RGBTRIPLE FAR *)pRgb)[i].rgbtRed;
		rgb.rgbBlue     = ((RGBTRIPLE FAR *)pRgb)[i].rgbtBlue;
		rgb.rgbGreen    = ((RGBTRIPLE FAR *)pRgb)[i].rgbtGreen;
		rgb.rgbReserved = (BYTE)0;

		pRgb[i] = rgb;
	    }
	}
	else
	{
	    _lread(fh,(LPBYTE)pRgb,nNumColors * sizeof(RGBQUAD));
	}
    }

    if (bf.bfOffBits != 0L)
	_llseek(fh,off + bf.bfOffBits,SEEK_SET);

    GlobalUnlock(hbi);
    return hbi;
}

/*  How big is the palette? if bits per pel not 24
 *  no of bytes to read is 6 for 1 bit, 48 for 4 bits
 *  256*3 for 8 bits and 0 for 24 bits
 */
UINT PaletteSize(VOID FAR * pv)
{
    #define lpbi ((LPBITMAPINFOHEADER)pv)
    #define lpbc ((LPBITMAPCOREHEADER)pv)

    UINT    NumColors;

    NumColors = DibNumColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	return NumColors * sizeof(RGBTRIPLE);
    else
	return NumColors * sizeof(RGBQUAD);

    #undef lpbi
    #undef lpbc
}

/*  How Many colors does this DIB have?
 *  this will work on both PM and Windows bitmap info structures.
 */
WORD DibNumColors(VOID FAR * pv)
{
    #define lpbi ((LPBITMAPINFOHEADER)pv)
    #define lpbc ((LPBITMAPCOREHEADER)pv)

    int bits;

    /*
     *  with the new format headers, the size of the palette is in biClrUsed
     *  else is dependent on bits per pixel
     */
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
    {
	if (lpbi->biClrUsed != 0)
	    return (UINT)lpbi->biClrUsed;

	bits = lpbi->biBitCount;
    }
    else
    {
	bits = lpbc->bcBitCount;
    }

    switch (bits)
    {
    case 1:
	    return 2;
    case 4:
	    return 16;
    case 8:
	    return 256;
    default:
	    return 0;
    }

    #undef lpbi
    #undef lpbc
}

/*
 *  DibFromBitmap()
 *
 *  Will create a global memory block in DIB format that represents the DDB
 *  passed in
 *
 */
HANDLE DibFromBitmap(HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage)
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dwLen;
    int                  nColors;
    HANDLE               hdib;
    HANDLE               h;
    HDC                  hdc;

    if (wUsage == 0)
	wUsage = DIB_RGB_COLORS;

    if (!hbm)
	return NULL;
#if 0
    if (biStyle == BI_RGB && wUsage == DIB_RGB_COLORS)
	return CreateLogicalDib(hbm,biBits,hpal);
#endif

    if (hpal == NULL)
	hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    GetObject(hbm,sizeof(bm),(LPBYTE)&bm);
#ifdef WIN32
    nColors = 0;  // GetObject only stores two bytes
#endif
    GetObject(hpal,sizeof(nColors),(LPBYTE)&nColors);

    if (biBits == 0)
	biBits = bm.bmPlanes * bm.bmBitsPixel;

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = biStyle;
    bi.biSizeImage          = 0;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = 0;
    bi.biClrImportant       = 0;

    dwLen  = bi.biSize + PaletteSize(&bi);

    hdc = CreateCompatibleDC(NULL);
    hpal = SelectPalette(hdc,hpal,TRUE);
    RealizePalette(hdc);  // why is this needed on a MEMORY DC? GDI bug??

    hdib = GlobalAlloc(GMEM_MOVEABLE,dwLen);

    if (!hdib)
	goto exit;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    *lpbi = bi;

    /*
     *  call GetDIBits with a NULL lpBits param, so it will calculate the
     *  biSizeImage field for us
     */
    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
	NULL, (LPBITMAPINFO)lpbi, wUsage);

    bi = *lpbi;
    GlobalUnlock(hdib);

    /*
     * HACK! if the driver did not fill in the biSizeImage field, make one up
     */
    if (bi.biSizeImage == 0)
    {
	bi.biSizeImage = (DWORD)WIDTHBYTES(bm.bmWidth * biBits) * bm.bmHeight;

	if (biStyle != BI_RGB)
	    bi.biSizeImage = (bi.biSizeImage * 3) / 2;
    }

    /*
     *  realloc the buffer big enough to hold all the bits
     */
    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;
    if (h = GlobalReAlloc(hdib,dwLen,GMEM_MOVEABLE))
    {
	hdib = h;
    }
    else
    {
	GlobalFree(hdib);
	hdib = NULL;
	goto exit;
    }

    /*
     *  call GetDIBits with a NON-NULL lpBits param, and actualy get the
     *  bits this time
     */
    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
	(LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi),
	(LPBITMAPINFO)lpbi, wUsage);

    bi = *lpbi;
    lpbi->biClrUsed = DibNumColors(lpbi) ;
    GlobalUnlock(hdib);

exit:
    SelectPalette(hdc,hpal,TRUE);
    DeleteDC(hdc);
    return hdib;
}

/*
 *  BitmapFromDib()
 *
 *  Will create a DDB (Device Dependent Bitmap) given a global handle to
 *  a memory block in CF_DIB format
 *
 */
HBITMAP BitmapFromDib(HANDLE hdib, HPALETTE hpal, UINT wUsage)
{
    LPBITMAPINFOHEADER lpbi;
    HPALETTE    hpalT;
    HDC         hdc;
    HBITMAP     hbm;
#if 0
    UINT        dx,dy,bits;
#endif

    if (!hdib)
	return NULL;

    if (wUsage == 0)
	wUsage = DIB_RGB_COLORS;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    if (!lpbi)
	return NULL;

    hdc = GetDC(NULL);
//    hdc = CreateCompatibleDC(NULL);

    if (hpal)
    {
	hpalT = SelectPalette(hdc,hpal,TRUE);
	RealizePalette(hdc);  // why is this needed on a MEMORY DC? GDI bug??
    }

#if 0
    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
    {
	dx   = ((LPBITMAPCOREHEADER)lpbi)->bcWidth;
	dy   = ((LPBITMAPCOREHEADER)lpbi)->bcHeight;
	bits = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;
    }
    else
    {
	dx   = (UINT)lpbi->biWidth;
	dy   = (UINT)lpbi->biHeight;
	bits = (UINT)lpbi->biBitCount;
    }

    if (bMonoBitmap /* || bits == 1 */)
    {
	hbm = CreateBitmap(dx,dy,1,1,NULL);
    }
    else
    {
	HDC hdcScreen = GetDC(NULL);
	hbm = CreateCompatibleBitmap(hdcScreen,dx,dy);
	ReleaseDC(NULL,hdcScreen);
    }

    if (hbm)
    {
	if (fErrProp)
	    SetDIBitsErrProp(hdc,hbm,0,dy,
	       (LPBYTE)lpbi + lpbi->biSize + PaletteSize(lpbi),
	       (LPBITMAPINFO)lpbi,wUsage);
	else
	    SetDIBits(hdc,hbm,0,dy,
	       (LPBYTE)lpbi + lpbi->biSize + PaletteSize(lpbi),
	       (LPBITMAPINFO)lpbi,wUsage);
    }

#else
    hbm = CreateDIBitmap(hdc,
		(LPBITMAPINFOHEADER)lpbi,
		(LONG)CBM_INIT,
		(LPBYTE)lpbi + lpbi->biSize + PaletteSize(lpbi),
		(LPBITMAPINFO)lpbi,
		wUsage );
#endif

    if (hpal && hpalT)
	SelectPalette(hdc,hpalT,TRUE);

//    DeleteDC(hdc);
    ReleaseDC(NULL,hdc);

    GlobalUnlock(hdib);
    return hbm;
}

/*
 *  DibFromDib()
 *
 *  Will convert a DIB in 1 format to a DIB in the specifed format
 *
 */
HANDLE DibFromDib(HANDLE hdib, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage)
{
    BITMAPINFOHEADER bi;
    HBITMAP     hbm;
    BOOL        fKillPalette=FALSE;

    if (!hdib)
	return NULL;

    DibInfo((LPBITMAPINFOHEADER)GlobalLock(hdib),&bi); GlobalUnlock(hdib);

    /*
     *  do we have the requested format already?
     */
    if (bi.biCompression == biStyle && (UINT)bi.biBitCount == biBits)
	return hdib;

    if (hpal == NULL)
    {
	hpal = CreateDibPalette(hdib);
	fKillPalette++;
    }

    hbm = BitmapFromDib(hdib,hpal,wUsage);

    if (hbm == NULL)
    {
	hdib = NULL;
    }
    else
    {
	hdib = DibFromBitmap(hbm,biStyle,biBits,hpal,wUsage);
	DeleteObject(hbm);
    }

    if (fKillPalette && hpal)
	DeleteObject(hpal);

    return hdib;
}


/*
 *  CreateLogicalDib
 *
 *  Given a DDB and a HPALETTE create a "logical" DIB
 *
 *  if the HBITMAP is NULL create a DIB from the system "stock" bitmap
 *      This is used to save a logical palette to a disk file as a DIB
 *
 *  if the HPALETTE is NULL use the system "stock" palette (ie the
 *      system palette)
 *
 *  a "logical" DIB is a DIB where the DIB color table *exactly* matches
 *  the passed logical palette.  There will be no system colors in the DIB
 *  block, and a pixel value of <n> in the DIB will correspond to logical
 *  palette index <n>.
 *
 *  This is accomplished by doing a GetDIBits() with the DIB_PAL_COLORS
 *  option then converting the palindexes returned in the color table
 *  from palette indexes to logical RGB values.  The entire passed logical
 *  palette is always copied to the DIB color table.
 *
 *  The DIB color table will have exactly the same number of entries as
 *  the logical palette.  Normaly GetDIBits() will always set biClrUsed to
 *  the maximum colors supported by the device regardless of the number of
 *  colors in the logical palette
 *
 *  Why would you want to do this?  The major reason for a "logical" DIB
 *  is so when the DIB is written to a disk file then reloaded the logical
 *  palette created from the DIB color table will be the same as one used
 *  originaly to create the bitmap.  It also will prevent GDI from doing
 *  nearest color matching on PC_RESERVED palettes.
 *
 *  ** What do we do if the logical palette has more than 256 entries!!!!!
 *  ** GetDIBits() may return logical palette index's that are greater than
 *  ** 256, we cant represent these colors in the "logical" DIB
 *  **
 *  ** for now hose the caller?????
 *
 */

HANDLE CreateLogicalDib(HBITMAP hbm, WORD biBits, HPALETTE hpal)
{
    BITMAP              bm;
    BITMAPINFOHEADER    bi;
    LPBITMAPINFOHEADER  lpDib;      // pointer to DIB
    LPBITMAPINFOHEADER  lpbi;       // temp pointer to BITMAPINFO
    DWORD               dwLen;
    DWORD               dw;
    int                 n;
    int                 nColors;
    HANDLE              hdib;
    HDC                 hdc;
    BYTE FAR *          lpBits;
    UINT FAR *          lpCT;
    RGBQUAD FAR *       lpRgb;
    PALETTEENTRY        peT;
    HPALETTE            hpalT;

    if (hpal == NULL)
	hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    if (hbm == NULL)
	hbm = NULL; // ????GetStockObject(STOCK_BITMAP);

#ifdef WIN32
    nColors = 0;  // GetObject only stores two bytes
#endif
    GetObject(hpal,sizeof(nColors),(LPBYTE)&nColors);
    GetObject(hbm,sizeof(bm),(LPBYTE)&bm);

    if (biBits == 0)
	biBits = nColors > 16 ? 8 : 4;

/*
    if (nColors > 256)      // ACK!
	;                   // How do we handle this????
*/

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = BI_RGB;
    bi.biSizeImage          = (DWORD)WIDTHBYTES(bm.bmWidth * biBits) * bm.bmHeight;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = nColors;
    bi.biClrImportant       = 0;

    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;

    hdib = GlobalAlloc(GMEM_MOVEABLE,dwLen);

    if (!hdib)
	return NULL;

    lpbi = (BITMAPINFOHEADER*)GlobalAlloc(GMEM_FIXED,bi.biSize + 256 * sizeof(RGBQUAD));

    if (!lpbi)
    {
	GlobalFree(hdib);
	return NULL;
    }

    hdc = GetDC(NULL);
    hpalT = SelectPalette(hdc,hpal,TRUE);
    RealizePalette(hdc);  // why is this needed on a MEMORY DC? GDI bug??

    lpDib = (BITMAPINFOHEADER*)GlobalLock(hdib);

    *lpbi  = bi;
    *lpDib = bi;
    lpCT   = (UINT FAR *)((LPBYTE)lpbi + (UINT)lpbi->biSize);
    lpRgb  = (RGBQUAD FAR *)((LPBYTE)lpDib + (UINT)lpDib->biSize);
    lpBits = (LPBYTE)lpDib + (UINT)lpDib->biSize + PaletteSize(lpDib);

    /*
     *  call GetDIBits to get the DIB bits and fill the color table with
     *  logical palette index's
     */
    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
	lpBits,(LPBITMAPINFO)lpbi, DIB_PAL_COLORS);

    /*
     *  Now convert the DIB bits into "real" logical palette index's
     *
     *  lpCT        points to the DIB color table wich is a UINT array of
     *              logical palette index's
     *
     *  lpBits      points to the DIB bits, each DIB pixel is a index into
     *              the DIB color table.
     *
     */

    if (biBits == 8)
    {
	for (dw = 0; dw < bi.biSizeImage; dw++, ((BYTE HUGE_T *)lpBits)++)
	    *lpBits = (BYTE)lpCT[*lpBits];
    }
    else // biBits == 4
    {
	for (dw = 0; dw < bi.biSizeImage; dw++, ((BYTE HUGE_T *)lpBits)++)
	    *lpBits = lpCT[*lpBits & 0x0F] | (lpCT[(*lpBits >> 4) & 0x0F] << 4);
    }

    /*
     *  Now copy the RGBs in the logical palette to the dib color table
     */
    for (n=0; n<nColors; n++,lpRgb++)
    {
	GetPaletteEntries(hpal,n,1,&peT);

	lpRgb->rgbRed      = peT.peRed;
	lpRgb->rgbGreen    = peT.peGreen;
	lpRgb->rgbBlue     = peT.peBlue;
	lpRgb->rgbReserved = (BYTE)0;
    }

    GlobalUnlock(hdib);
#ifdef WIN32
    GlobalFree(GlobalHandle(lpbi));
#else
    GlobalFree(SELECTOROF(lpbi));
#endif

    SelectPalette(hdc,hpalT,TRUE);
    ReleaseDC(NULL,hdc);

    return hdib;
}

/*
 *  Draws bitmap <hbm> at the specifed position in DC <hdc>
 *
 */
BOOL StretchBitmap(HDC hdc, int x, int y, int dx, int dy, HBITMAP hbm, int x0, int y0, int dx0, int dy0, DWORD rop)
{
    HDC hdcBits;
    HPALETTE hpal,hpalT;
    BOOL f;

    if (!hdc || !hbm)
	return FALSE;

    hpal = SelectPalette(hdc,(HPALETTE)GetStockObject(DEFAULT_PALETTE),TRUE);
    SelectPalette(hdc,hpal,TRUE);

    hdcBits = CreateCompatibleDC(hdc);
    SelectObject(hdcBits,hbm);
    hpalT = SelectPalette(hdcBits,hpal,TRUE);
    RealizePalette(hdcBits);
    f = StretchBlt(hdc,x,y,dx,dy,hdcBits,x0,y0,dx0,dy0,rop);
    SelectPalette(hdcBits,hpalT,TRUE);
    DeleteDC(hdcBits);

    return f;
}

/*
 *  Draws bitmap <hbm> at the specifed position in DC <hdc>
 *
 */
BOOL DrawBitmap(HDC hdc, int x, int y, HBITMAP hbm, DWORD rop)
{
    HDC hdcBits;
    BITMAP bm;
    BOOL f;

    if (!hdc || !hbm)
	return FALSE;

    hdcBits = CreateCompatibleDC(hdc);
    GetObject(hbm,sizeof(BITMAP),(LPBYTE)&bm);
    SelectObject(hdcBits,hbm);
    f = BitBlt(hdc,x,y,bm.bmWidth,bm.bmHeight,hdcBits,0,0,rop);
    DeleteDC(hdcBits);

    return f;
}

/*
 *  SetDibUsage(hdib,hpal,wUsage)
 *
 *  Modifies the color table of the passed DIB for use with the wUsage
 *  parameter specifed.
 *
 *  if wUsage is DIB_PAL_COLORS the DIB color table is set to 0-256
 *  if wUsage is DIB_RGB_COLORS the DIB color table is set to the RGB values
 *      in the passed palette
 *
 */
BOOL SetDibUsage(HANDLE hdib, HPALETTE hpal,UINT wUsage)
{
    LPBITMAPINFOHEADER lpbi;
    PALETTEENTRY       ape[MAXPALETTE];
    RGBQUAD FAR *      pRgb;
    UINT FAR *         pw;
    int                nColors;
    int                n;

    if (hpal == NULL)
	hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    if (!hdib)
	return FALSE;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    if (!lpbi)
	return FALSE;

    nColors = DibNumColors(lpbi);

    if (nColors > 0)
    {
	pRgb = (RGBQUAD FAR *)((LPBYTE)lpbi + (UINT)lpbi->biSize);

	switch (wUsage)
	{
	    //
	    // Set the DIB color table to palette indexes
	    //
	    case DIB_PAL_COLORS:
		for (pw = (UINT FAR*)pRgb,n=0; n<nColors; n++,pw++)
		    *pw = n;
		break;

	    //
	    // Set the DIB color table to RGBQUADS
	    //
	    default:
	    case DIB_RGB_COLORS:
		nColors = min(nColors,MAXPALETTE);

		GetPaletteEntries(hpal,0,nColors,ape);

		for (n=0; n<nColors; n++)
		{
		    pRgb[n].rgbRed      = ape[n].peRed;
		    pRgb[n].rgbGreen    = ape[n].peGreen;
		    pRgb[n].rgbBlue     = ape[n].peBlue;
		    pRgb[n].rgbReserved = 0;
		}
		break;
	}
    }
    GlobalUnlock(hdib);
    return TRUE;
}

/*
 *  SetPalFlags(hpal,iIndex, cnt, wFlags)
 *
 *  Modifies the palette flags of all indexs in the range (iIndex - nIndex+cnt)
 *  to the parameter specifed.
 *
 */
BOOL SetPalFlags(HPALETTE hpal, int iIndex, int cntEntries, UINT wFlags)
{
    int     i;
    BOOL    f;
    HANDLE  hpe;
    PALETTEENTRY FAR *lppe;

    if (hpal == NULL)
	return FALSE;

    if (cntEntries < 0) {
#ifdef WIN32
	cntEntries = 0;  // GetObject only stores two bytes
#endif
	GetObject(hpal,sizeof(int),(LPBYTE)&cntEntries);
    }

    hpe = GlobalAlloc(GMEM_MOVEABLE,(LONG)cntEntries * sizeof(PALETTEENTRY));

    if (!hpe)
	return FALSE;

    lppe = (PALETTEENTRY*)GlobalLock(hpe);

    GetPaletteEntries(hpal, iIndex, cntEntries, lppe);

    for (i=0; i<cntEntries; i++)
    {
	lppe[i].peFlags = (BYTE)wFlags;
    }

    f = SetPaletteEntries(hpal, iIndex, cntEntries, lppe);

    GlobalUnlock(hpe);
    GlobalFree(hpe);
    return f;
}

/*
 *  StretchDibBlt()
 *
 *  draws a bitmap in CF_DIB format, using StretchDIBits()
 *
 *  takes the same parameters as StretchBlt()
 */
BOOL StretchDibBlt(HDC hdc, int x, int y, int dx, int dy, HANDLE hdib, int x0, int y0, int dx0, int dy0, LONG rop, UINT wUsage)
{
    LPBITMAPINFOHEADER lpbi;
    LPBYTE        pBuf;
    BOOL         f;

    if (!hdib)
    {
	    return PatBlt(hdc,x,y,dx,dy,rop);
    }

    if (wUsage == 0)
    {
	    wUsage = DIB_RGB_COLORS;
    }

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    if (!lpbi)
    {
	    return FALSE;
    }

    if (dx0 == -1 && dy0 == -1)
    {
	    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	    {
	        dx0 = ((LPBITMAPCOREHEADER)lpbi)->bcWidth;
	        dy0 = ((LPBITMAPCOREHEADER)lpbi)->bcHeight;
	    }
	    else
	    {
	        dx0 = (int)lpbi->biWidth;
	        dy0 = (int)lpbi->biHeight;
	    }
    }

    if (dx < 0 && dy < 0)
    {
	    dx = dx0 * (-dx);
	    dy = dy0 * (-dy);
    }

    pBuf = (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi);

    f = StretchDIBits (
	                    hdc,
	                    x,y,
	                    dx,dy,
	                    x0,y0,
	                    dx0,dy0,
	                    pBuf, (LPBITMAPINFO)lpbi,
	                    wUsage,
	                    rop);

    GlobalUnlock(hdib);
    return f;
}

/*
 *  DibBlt()
 *
 *  draws a bitmap in CF_DIB format, using SetDIBits to device.
 *
 *  takes the same parameters as BitBlt()
 */
BOOL DibBlt(HDC hdc, int x0, int y0, int dx, int dy, HANDLE hdib, int x1, int y1, LONG rop, UINT wUsage)
{
    LPBITMAPINFOHEADER lpbi;
    LPBYTE       pBuf;
    BOOL        f;

    if (!hdib)
	return PatBlt(hdc,x0,y0,dx,dy,rop);

    if (wUsage == 0)
	wUsage = DIB_RGB_COLORS;

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    if (!lpbi)
	return FALSE;

    if (dx == -1 && dy == -1)
    {
	if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	{
	    dx = ((LPBITMAPCOREHEADER)lpbi)->bcWidth;
	    dy = ((LPBITMAPCOREHEADER)lpbi)->bcHeight;
	}
	else
	{
	    dx = (int)lpbi->biWidth;
	    dy = (int)lpbi->biHeight;
	}
    }

    pBuf = (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi);

#if 0
    f = SetDIBitsToDevice(hdc, x0, y0, dx, dy,
	x1,y1,
	x1,
	dy,
	pBuf, (LPBITMAPINFO)lpbi,
	wUsage );
#else
    f = StretchDIBits (
	hdc,
	x0,y0,
	dx,dy,
	x1,y1,
	dx,dy,
	pBuf, (LPBITMAPINFO)lpbi,
	wUsage,
	rop);
#endif

    GlobalUnlock(hdib);
    return f;
}

LPVOID DibLock(HANDLE hdib,int x, int y)
{
    return DibXY((LPBITMAPINFOHEADER)GlobalLock(hdib),x,y);
}

VOID DibUnlock(HANDLE hdib)
{
    GlobalUnlock(hdib);
}

LPVOID DibXY(LPBITMAPINFOHEADER lpbi,int x, int y)
{
    BYTE HUGE_T *pBits;
    DWORD ulWidthBytes;

    pBits = (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi);

    ulWidthBytes = DIBWIDTHBYTES(*lpbi);

    pBits += (ulWidthBytes * (long)y) + x;

    return (LPVOID)pBits;
}

    //
    // These are the standard VGA colors, we will be stuck with until the
    // end of time!
    //
    static DWORD CosmicColors[16] = {
	 0x00000000        // 0000  black
	,0x00800000        // 0001  dark red
	,0x00008000        // 0010  dark green
	,0x00808000        // 0011  mustard
	,0x00000080        // 0100  dark blue
	,0x00800080        // 0101  purple
	,0x00008080        // 0110  dark turquoise
	,0x00C0C0C0        // 1000  gray
	,0x00808080        // 0111  dark gray
	,0x00FF0000        // 1001  red
	,0x0000FF00        // 1010  green
	,0x00FFFF00        // 1011  yellow
	,0x000000FF        // 1100  blue
	,0x00FF00FF        // 1101  pink (magenta)
	,0x0000FFFF        // 1110  cyan
	,0x00FFFFFF        // 1111  white
	};

HANDLE CreateDib(WORD bits, int dx, int dy)
{
    HANDLE              hdib;
    BITMAPINFOHEADER    bi;
    LPBITMAPINFOHEADER  lpbi;
    DWORD FAR *         pRgb;
    UINT                i;


    bi.biSize           = sizeof(BITMAPINFOHEADER);
    bi.biPlanes         = 1;
    bi.biBitCount       = bits;
    bi.biWidth          = dx;
    bi.biHeight         = dy;
    bi.biCompression    = BI_RGB;
    bi.biSizeImage      = 0;
    bi.biXPelsPerMeter  = 0;
    bi.biYPelsPerMeter  = 0;
    bi.biClrUsed                = 0;
    bi.biClrImportant   = 0;
    bi.biClrUsed        = DibNumColors(&bi);

    hdib = GlobalAlloc(GMEM_MOVEABLE,sizeof(BITMAPINFOHEADER) +
		+ (long)bi.biClrUsed * sizeof(RGBQUAD)
		+ (long)DIBWIDTHBYTES(bi) * (long)dy);

    if (hdib)
    {
	lpbi  = (BITMAPINFOHEADER*)GlobalLock(hdib);
	*lpbi = bi;

	pRgb  = (unsigned long*)((LPBYTE)lpbi + lpbi->biSize);

	//
	//  setup the color table
	//
	if (bits == 1)
	{
	    pRgb[0] = CosmicColors[0];
	    pRgb[1] = CosmicColors[15];
	}
	else
	{
	    for (i=0; i<bi.biClrUsed; i++)
				pRgb[i] = CosmicColors[i % 16];
	}

	GlobalUnlock(hdib);
    }

    return hdib;
}

/*
 * Private routines to read/write more than 64k
 */

#define MAXREAD (UINT)(32u * 1024)

static DWORD NEAR PASCAL lread(HFILE fh, VOID FAR *pv, DWORD ul)
{
    DWORD  ulT = ul;
    BYTE HUGE_T *hp = (unsigned char*)pv;

    while (ul > MAXREAD) {
	if (_lread(fh, (LPBYTE)hp, MAXREAD) != MAXREAD)
		return 0;
	ul -= MAXREAD;
	hp += MAXREAD;
    }
    if (_lread(fh, (LPBYTE)hp, (UINT)ul) != (UINT)ul)
	return 0;
    return ulT;
}

static DWORD NEAR PASCAL lwrite(HFILE fh, VOID FAR *pv, DWORD ul)
{
    DWORD  ulT = ul;
    BYTE HUGE_T *hp = (unsigned char*)pv;

    while (ul > MAXREAD) {
	if (_lwrite(fh, (const char*)hp, MAXREAD) != MAXREAD)
		return 0;
	ul -= MAXREAD;
	hp += MAXREAD;
    }
    if (_lwrite(fh, (const char*)hp, (UINT)ul) != (UINT)ul)
	return 0;
    return ulT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\frame.cpp ===
#include "windows.h"
#include "frame.h"
#include "dib.h"
#include "resource.h"
#include "mmfw.h"

//constants for bitmap placement in FRAME.BMP
#define PIECE_WIDTH         9
#define PIECE_HEIGHT        10
#define SMALL_MODE_OFFSET   90

//outer edges
#define TOP_LEFT_CORNER     0
#define TOP_STRIP           1
#define TOP_RIGHT_CORNER    2
#define LEFT_STRIP          3
#define SEPARATOR_BAR       4
#define RIGHT_STRIP         5
#define BOTTOM_LEFT_CORNER  6
#define BOTTOM_STRIP        7
#define BOTTOM_RIGHT_CORNER 8

//inner edges
#define TOP_LEFT_CORNER_VIEW     9
#define TOP_STRIP_VIEW           10
#define TOP_RIGHT_CORNER_VIEW    11
#define LEFT_STRIP_VIEW          12
#define RIGHT_STRIP_VIEW         13
#define BOTTOM_LEFT_CORNER_VIEW  14
#define BOTTOM_STRIP_VIEW        15
#define BOTTOM_RIGHT_CORNER_VIEW 16
#define LEFT_INNER_STRIP_VIEW    17
#define RIGHT_INNER_STRIP_VIEW   18

#define LEFT_INNER_X_OFFSET 5
#define LEFT_INNER_Y_OFFSET 7
#define RIGHT_INNER_X_OFFSET 9
#define RIGHT_INNER_Y_OFFSET 7

//system menu icon
#define SYSTEM_MENU_INDEX 52
#define SYSTEM_MENU_WIDTH 12
#define SYSTEM_MENU_HEIGHT 14

//volume control notch
#define VOLUME_X_OFFSET 2

#define BACKGROUND_COLOR    RGB(0x7F, 0x7F, 0x7F)
#define BACKGROUND_COLOR_16 RGB(0xC0, 0xC0, 0xC0)
#define BACKGROUND_COLOR_HI RGB(0xFF, 0xFF, 0xFF)

extern HPALETTE hpalMain; //main palette of app
extern HINSTANCE hInst;   //instance of app
extern int g_nColorMode;  //color mode

HANDLE BuildFrameBitmap(HDC hDC,            //dc to be compatible with
                        LPRECT pMainRect,   //overall window size
                        LPRECT pViewRect,   //rect of black viewport window,
                                            //where gradient should begin,
                                            //with 0,0 as top left of main
                        int nViewMode,      //if in normal, restore, small
                        LPPOINT pSysMenuPt, //point where sys menu icon is placed
                        LPRECT pSepRects,   //array of rects for separator bars
                        int nNumSeps,       //number of separtors in array
                        BITMAP* pBM)        //bitmap info
{
	HDC memDC = CreateCompatibleDC(hDC);
	HPALETTE hpalOld = SelectPalette(memDC, hpalMain, FALSE);
	
    HBITMAP hbmpOld;
    HBITMAP hbmpTemp;
    HBITMAP hbmpFinal;

    int nSmallOffset = 0;
    if ((nViewMode != VIEW_MODE_NORMAL) && (nViewMode != VIEW_MODE_NOBAR))
    {
        nSmallOffset = SMALL_MODE_OFFSET;
    }

    //load frame bitmap
    int nBitmap = IDB_FRAME_TOOLKIT;
    switch (g_nColorMode)
    {
        case COLOR_16 : nBitmap = IDB_FRAME_TOOLKIT_16; break;
        case COLOR_HICONTRAST : nBitmap = IDB_FRAME_TOOLKIT_HI; break;
    }

    hbmpTemp = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	HANDLE hbmpFrame = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    DeleteObject(hbmpTemp);

    hbmpFinal = CreateCompatibleBitmap(hDC,
                                       pMainRect->right - pMainRect->left,
                                       pMainRect->bottom - pMainRect->top);

    hbmpOld = (HBITMAP)SelectObject(memDC, hbmpFinal);

    //first paint the background
    COLORREF colorBackground = BACKGROUND_COLOR;
    switch (g_nColorMode)
    {
        case COLOR_16 : colorBackground = BACKGROUND_COLOR_16; break;
        case COLOR_HICONTRAST : colorBackground = BACKGROUND_COLOR_HI; break;
    }

    HBRUSH hbrBack = CreateSolidBrush(colorBackground);
    FillRect(memDC,pMainRect,hbrBack);
    DeleteObject(hbrBack);

    //now draw the separators
    for (int i = 0; i < nNumSeps; i++)
    {
	    StretchDibBlt(memDC,
		    pSepRects[i].left,
		    pSepRects[i].top,
		    PIECE_WIDTH,
		    pSepRects[i].bottom - pSepRects[i].top,
		    hbmpFrame,
		    SEPARATOR_BAR*PIECE_WIDTH,0,
		    PIECE_WIDTH,
		    PIECE_HEIGHT,
		    SRCCOPY,0);
    }

    //draw each side
    StretchDibBlt(memDC,
            pMainRect->left,
            pMainRect->top,
            pMainRect->right - pMainRect->left,
            PIECE_HEIGHT,
            hbmpFrame,
            TOP_STRIP*PIECE_WIDTH,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    StretchDibBlt(memDC,
            pMainRect->left,
            pMainRect->top,
            PIECE_WIDTH,
            pMainRect->bottom - pMainRect->top,
            hbmpFrame,
            LEFT_STRIP*PIECE_WIDTH,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    StretchDibBlt(memDC,
            pMainRect->right - PIECE_WIDTH,
            pMainRect->top,
            PIECE_WIDTH,
            pMainRect->bottom - pMainRect->top,
            hbmpFrame,
            RIGHT_STRIP*PIECE_WIDTH,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    StretchDibBlt(memDC,
            pMainRect->left,
            pMainRect->bottom - PIECE_HEIGHT,
            pMainRect->right - pMainRect->left,
            PIECE_HEIGHT,
            hbmpFrame,
            BOTTOM_STRIP*PIECE_WIDTH,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    //draw each corner
    DibBlt(memDC,
            pMainRect->left,
            pMainRect->top,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            TOP_LEFT_CORNER*PIECE_WIDTH,0,
            SRCCOPY,0);            

    DibBlt(memDC,
            pMainRect->right-PIECE_WIDTH,
            pMainRect->top,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            TOP_RIGHT_CORNER*PIECE_WIDTH,0,
            SRCCOPY,0);            

    DibBlt(memDC,
            pMainRect->left,
            pMainRect->bottom - PIECE_HEIGHT,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            BOTTOM_LEFT_CORNER*PIECE_WIDTH,0,
            SRCCOPY,0);            

    DibBlt(memDC,
            pMainRect->right - PIECE_WIDTH,
            pMainRect->bottom - PIECE_HEIGHT,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            BOTTOM_RIGHT_CORNER*PIECE_WIDTH,0,
            SRCCOPY,0);            

    //draw each side of the interior viewport
    StretchDibBlt(memDC,
            pViewRect->left,
            pViewRect->top,
            pViewRect->right - pViewRect->left,
            PIECE_HEIGHT,
            hbmpFrame,
            TOP_STRIP_VIEW*PIECE_WIDTH+nSmallOffset,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    StretchDibBlt(memDC,
            pViewRect->left,
            pViewRect->top,
            PIECE_WIDTH,
            pViewRect->bottom - pViewRect->top,
            hbmpFrame,
            LEFT_STRIP_VIEW*PIECE_WIDTH+nSmallOffset,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    StretchDibBlt(memDC,
            pViewRect->right - PIECE_WIDTH,
            pViewRect->top,
            PIECE_WIDTH,
            pViewRect->bottom - pViewRect->top,
            hbmpFrame,
            RIGHT_STRIP_VIEW*PIECE_WIDTH+nSmallOffset,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);

    StretchDibBlt(memDC,
            pViewRect->left,
            pViewRect->bottom - PIECE_HEIGHT,
            pViewRect->right - pViewRect->left,
            PIECE_HEIGHT,
            hbmpFrame,
            BOTTOM_STRIP_VIEW*PIECE_WIDTH+nSmallOffset,0,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            SRCCOPY,0);
    
    //draw each corner of the interior viewport
    DibBlt(memDC,
            pViewRect->left,
            pViewRect->top,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            TOP_LEFT_CORNER_VIEW*PIECE_WIDTH+nSmallOffset,0,
            SRCCOPY,0);            

    DibBlt(memDC,
            pViewRect->right-PIECE_WIDTH,
            pViewRect->top,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            TOP_RIGHT_CORNER_VIEW*PIECE_WIDTH+nSmallOffset,0,
            SRCCOPY,0);            

    DibBlt(memDC,
            pViewRect->left,
            pViewRect->bottom - PIECE_HEIGHT,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            BOTTOM_LEFT_CORNER_VIEW*PIECE_WIDTH+nSmallOffset,0,
            SRCCOPY,0);            

    DibBlt(memDC,
            pViewRect->right - PIECE_WIDTH,
            pViewRect->bottom - PIECE_HEIGHT,
            PIECE_WIDTH,
            PIECE_HEIGHT,
            hbmpFrame,
            BOTTOM_RIGHT_CORNER_VIEW*PIECE_WIDTH+nSmallOffset,0,
            SRCCOPY,0);
            
    if ((nViewMode == VIEW_MODE_NORMAL) || (nViewMode == VIEW_MODE_NOBAR))
    {
        //draw the interiors of the viewport
        StretchDibBlt(memDC,
                pViewRect->left + LEFT_INNER_X_OFFSET,
                pViewRect->top + LEFT_INNER_Y_OFFSET,
                PIECE_WIDTH,
                (pViewRect->bottom - PIECE_HEIGHT) - (pViewRect->top + LEFT_INNER_Y_OFFSET),
                hbmpFrame,
                LEFT_INNER_STRIP_VIEW*PIECE_WIDTH,0,
                PIECE_WIDTH,
                PIECE_HEIGHT,
                SRCCOPY,0);

        StretchDibBlt(memDC,
                (pViewRect->right - RIGHT_INNER_X_OFFSET) - PIECE_WIDTH,
                pViewRect->top + RIGHT_INNER_Y_OFFSET,
                PIECE_WIDTH,
                (pViewRect->bottom - PIECE_HEIGHT) - (pViewRect->top + RIGHT_INNER_Y_OFFSET),
                hbmpFrame,
                RIGHT_INNER_STRIP_VIEW*PIECE_WIDTH,0,
                PIECE_WIDTH,
                PIECE_HEIGHT,
                SRCCOPY,0);

        //draw the "notch" for the volume knob in this mode
        nBitmap = IDB_NOTCH;
        switch (g_nColorMode)
        {
            case COLOR_16 : nBitmap = IDB_NOTCH_16; break;
            case COLOR_HICONTRAST : nBitmap = IDB_NOTCH_HI; break;
        }

        HBITMAP hbmpNotch = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
        HDC memDC2 = CreateCompatibleDC(memDC);
        HBITMAP hbmpOld2 = (HBITMAP)SelectObject(memDC2,hbmpNotch);
        BITMAP bm;
        GetObject(hbmpNotch,sizeof(bm),&bm);

        BitBlt(memDC,
                pViewRect->right - bm.bmWidth,
                (pViewRect->bottom - PIECE_HEIGHT) - VOLUME_X_OFFSET,
                bm.bmWidth,
                bm.bmHeight,
                memDC2,
                0,0,SRCCOPY);

        SelectObject(memDC2,hbmpOld2);
        DeleteObject(hbmpNotch);
        DeleteDC(memDC2);
    }            

    //blit the system menu onto the picture, from the button toolkit bitmap
    if (nViewMode < VIEW_MODE_SMALL)
    {
        nBitmap = IDB_BUTTON_TOOLKIT;
        switch (g_nColorMode)
        {
            case COLOR_16 : nBitmap = IDB_BUTTON_TOOLKIT_16; break;
            case COLOR_HICONTRAST : nBitmap = IDB_BUTTON_TOOLKIT_HI; break;
        }
        
        HBITMAP hbmpSys = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
        HDC memDC2 = CreateCompatibleDC(memDC);
        HBITMAP hbmpOld2 = (HBITMAP)SelectObject(memDC2,hbmpSys);

        BitBlt(memDC,
                pSysMenuPt->x,
                pSysMenuPt->y,
                SYSTEM_MENU_WIDTH,
                SYSTEM_MENU_HEIGHT,
                memDC2,
                SYSTEM_MENU_INDEX,0,
                SRCCOPY);
        
        SelectObject(memDC2,hbmpOld2);
        DeleteObject(hbmpSys);
        DeleteDC(memDC2);
    }

    SelectObject(memDC,hbmpOld);
	SelectPalette(memDC, hpalOld, TRUE);
    DeleteDC(memDC);

    GlobalFree(hbmpFrame);

    if (pBM)
    {
        GetObject(hbmpFinal,sizeof(BITMAP),pBM);
    }

	HANDLE hdib = DibFromBitmap((HBITMAP)hbmpFinal,0,0,hpalMain,0);
    DeleteObject(hbmpFinal);

    return hdib;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\cdplay\scan.cpp ===
/******************************Module*Header*******************************\
* Module Name: scan.c
*
* Code for scanning the available CD Rom devices.
*
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>    /* required for all Windows applications */
#include <windowsx.h>

#include <string.h>
#include <tchar.h>              /* contains portable ascii/unicode macros */

#include "playres.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"
#include "database.h"



/*****************************Private*Routine******************************\
* ScanForCdromDevices
*
* Returns the number of CD-ROM devices installed in the system.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
int
ScanForCdromDevices(
    void
    )
{
    DWORD   dwDrives;
    TCHAR   chDrive[] = TEXT("A:\\");
    int     iNumDrives;

    iNumDrives  = 0;

    for (dwDrives = GetLogicalDrives(); dwDrives != 0; dwDrives >>= 1 ) {

        /*
        ** Is there a logical drive ??
        */
        if (dwDrives & 1) {

            if ( GetDriveType(chDrive) == DRIVE_CDROM ) {

                g_Devices[iNumDrives] = (CDROM*)AllocMemory( sizeof(CDROM) );

                g_Devices[iNumDrives]->drive = chDrive[0];
                g_Devices[iNumDrives]->State = CD_BEING_SCANNED;

                iNumDrives++;
            }
        }

        /*
        ** Go look at the next drive
        */
        chDrive[0] = chDrive[0] + 1;
    }

    return iNumDrives;
}


/******************************Public*Routine******************************\
* RescanDevice
*
*
* This routine is called to scan the disc in a given cdrom by
* reading its table of contents.  If the cdrom is playing the user is
* notified that the music will stop.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void RescanDevice(
    HWND hwndNotify,
    int cdrom
    )
{
    TOC_THREAD_PARMS    *ptoc;
    HWND                hwndButton;
    int                 iMsgBoxRtn;

    if ( g_Devices[cdrom]->State & CD_PLAYING ) {

        TCHAR   s1[256];
        TCHAR   s2[256];

        _tcscpy( s1, IdStr( STR_CANCEL_PLAY ) );
        _tcscpy( s2, IdStr( STR_RESCAN ) );

        iMsgBoxRtn = MessageBox( g_hwndApp, s1, s2,
                                 MB_APPLMODAL | MB_DEFBUTTON1 |
                                 MB_ICONQUESTION | MB_YESNO);

        if ( iMsgBoxRtn == IDYES ) {

            hwndButton = g_hwndControls[INDEX(IDM_PLAYBAR_STOP)];

            SendMessage( hwndButton, WM_LBUTTONDOWN, 0, 0L );
            SendMessage( hwndButton, WM_LBUTTONUP, 0, 0L );
        }
        else {

            return;
        }
    }


    /*
    ** Attempt to read table of contents of disc in this drive.  We
    ** now spawn off a separate thread to do this.  Note that the child
    ** thread frees the storage allocated below.
    */
    ptoc = (TOC_THREAD_PARMS*)AllocMemory( sizeof(TOC_THREAD_PARMS) );
    ptoc->hwndNotify = hwndNotify;
    ptoc->cdrom = cdrom;
    ReadTableOfContents( ptoc );

}


/*****************************Private*Routine******************************\
* ReadTableofContents
*
* This function reads in the table of contents (TOC) for the specified cdrom.
* All TOC's are read on a worker thread.  The hi-word of thread_info variable
* is a boolean that states if the display should been updated after the TOC
* has been reads.  The lo-word of thread_info is the id of the cdrom device
* to be read.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ReadTableOfContents(
    TOC_THREAD_PARMS *ptoc
    )
{
    DWORD   dwThreadId;
    int     cdrom;

    cdrom = ptoc->cdrom;
    g_Devices[ cdrom ]->fIsTocValid = FALSE;
    g_Devices[cdrom]->fShowLeadIn = FALSE;
    g_Devices[cdrom]->fProcessingLeadIn = FALSE;

    if (g_Devices[ cdrom ]->hThreadToc != NULL) {

        /*
        ** We have a thread TOC handle see if the thread is
        ** still running.  If so just return, otherwise
        */
        switch ( WaitForSingleObject(g_Devices[ cdrom ]->hThreadToc, 0L) ) {

        /*
        ** Thread has finished to continue
        */
        case WAIT_OBJECT_0:
            break;

        /*
        ** The thread is still running so just return
        */
        case WAIT_TIMEOUT:
        default:
            {
                LocalFree( ptoc );
                return;
            }
        }

        CloseHandle( g_Devices[ cdrom ]->hThreadToc );
    }

    g_Devices[ cdrom ]->hThreadToc = CreateThread(
        NULL, 0L, (LPTHREAD_START_ROUTINE)TableOfContentsThread,
        (LPVOID)ptoc, 0L, &dwThreadId );

    /*
    ** For now I will kill the app if I cannot create the
    ** ReadTableOfContents thread.  This is probably a bit
    ** harsh.
    */

    if (g_Devices[ cdrom ]->hThreadToc == NULL) {
        FatalApplicationError( STR_NO_RES, GetLastError() );
    }

}

/*****************************Private*Routine******************************\
* TableOfContentsThread
*
* This is the worker thread that reads the table of contents for the
* specified cdrom.
*
* Before the thread exits we post a message to the UI threads main window to
* notify it that the TOC for this cdrom has been updated.  It then  examines the
* database to determine if this cdrom is known and updates the screen ccordingly.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TableOfContentsThread(
    TOC_THREAD_PARMS *ptoc
    )
{
    DWORD   status = 0;
    UCHAR   num, numaudio;
    int     cdrom;
    HWND    hwndNotify;

    //  This serializes access to this function 
    //  between multiple threads and the CDPlayer_OnTocRead
    //  function on the main thread. 
    //  This prevents resource contention on CDROM Multi-changers
    EnterCriticalSection (&g_csTOCSerialize);

    cdrom = ptoc->cdrom;
    hwndNotify = ptoc->hwndNotify;

    LocalFree( ptoc );

    /*
    ** Try to read the TOC from the drive.
    */

#ifdef USE_IOCTLS

    status = GetCdromTOC( g_Devices[cdrom]->hCd, &(g_Devices[cdrom]->toc) );
    num = g_Devices[cdrom]->toc.LastTrack - g_Devices[cdrom]->toc.FirstTrack+1;
    {
        int     i;

        numaudio = 0;

        /*
        ** Look for audio tracks...
        */
        for( i = 0; i < num; i++ ) {

            if ( (g_Devices[cdrom]->toc.TrackData[i].Control &
                  TRACK_TYPE_MASK ) == AUDIO_TRACK ) {

                numaudio++;
            }

        }
    }

    /*
    ** Need to check if we got data tracks or audio
    ** tracks back...if there is a mix, strip out
    ** the data tracks...
    */
    if (status == ERROR_SUCCESS) {


        /*
        ** If there aren't any audio tracks, then we (most likely)
        ** have a data CD loaded.
        */

        if (numaudio == 0) {

            status == ERROR_UNRECOGNIZED_MEDIA;
            g_Devices[cdrom]->State = CD_DATA_CD_LOADED | CD_STOPPED;

        }
        else {

            g_Devices[cdrom]->State = CD_LOADED | CD_STOPPED;
        }
    }
    else {

        g_Devices[cdrom]->State = CD_NO_CD | CD_STOPPED;
    }

#else
    {
        MCIDEVICEID wDeviceID;
        DWORD       dwCDPlayerMode = 0L;

    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    GetVersionEx(&os);
    if (os.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        if (g_Devices[cdrom]->hCd == 0) {
            g_Devices[cdrom]->hCd = OpenCdRom( g_Devices[cdrom]->drive,
                                               &status );
        }
        wDeviceID = g_Devices[cdrom]->hCd;
    }
    else
    {
        wDeviceID = OpenCdRom( g_Devices[cdrom]->drive, &status );
    }

        if ( wDeviceID != 0 ) {

            int     i;

            numaudio = 0;
            status = GetCdromTOC( wDeviceID, &(g_Devices[cdrom]->toc) );

            /*
            ** Need to check if we got data tracks or audio
            ** tracks back...if there is a mix, strip out
            ** the data tracks...
            */
            if ( status == ERROR_SUCCESS) {
                num = g_Devices[cdrom]->toc.LastTrack -
                      g_Devices[cdrom]->toc.FirstTrack + 1;

                for( i = 0; i < num; i++ ) {

                    if ( IsCdromTrackAudio(wDeviceID, i) ) {

                        numaudio++;
                    }
                }
            }

            dwCDPlayerMode = GetCdromMode( wDeviceID );

            OSVERSIONINFO os;
            os.dwOSVersionInfoSize = sizeof(os);
            GetVersionEx(&os);
            if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
            {
                CloseCdRom( wDeviceID );
            }
        }

        /*
        ** Need to check if we got data tracks or audio
        ** tracks back...if there is a mix, strip out
        ** the data tracks...
        */
        if (status == ERROR_SUCCESS) {

            /*
            ** If there aren't any audio tracks, then we (most likely)
            ** have a data CD loaded.
            */

            if (numaudio == 0) {

                g_Devices[cdrom]->State = CD_DATA_CD_LOADED | CD_STOPPED;
            }
            else {

                g_Devices[cdrom]->State = CD_LOADED;

                switch (dwCDPlayerMode) {

                case MCI_MODE_PAUSE:
                    g_Devices[cdrom]->State |= CD_PAUSED;
                    break;

                case MCI_MODE_PLAY:
                    g_Devices[cdrom]->State |= CD_PLAYING;
                    break;

                default:
                    g_Devices[cdrom]->State |= CD_STOPPED;
                    break;
                }
            }

        }
        else {

            if (status == (DWORD)MCIERR_MUST_USE_SHAREABLE) {
                g_Devices[cdrom]->State = CD_IN_USE;
            }

            if (g_Devices[cdrom]->State != CD_IN_USE) {
                g_Devices[cdrom]->State = CD_NO_CD | CD_STOPPED;
            }
        }
    }
#endif

    /*
    ** Notify the UI thread that a TOC has been read and then terminate the
    ** thread.
    */

    PostMessage( hwndNotify, WM_NOTIFY_TOC_READ,
                 (WPARAM)cdrom, (LPARAM)numaudio );

    LeaveCriticalSection (&g_csTOCSerialize);
    
    ExitThread( 1L );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\knob.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  KNOB.CPP
//
//      Multimedia Knob Control class; helper functions
//
//      Copyright (c) Microsoft Corporation     1997
//    
//      12/18/97 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "knob.h"
#include "windowsx.h"
#include <TCHAR.H>
#include "resource.h"
#include "dib.h"
#include "math.h"
#include "mmfw.h"

#ifdef UNICODE
    #define WC_KNOB L"DES_KnobClass"
#else
    #define WC_KNOB "DES_KnobClass"
#endif

//externals
extern  HPALETTE hpalMain;
extern  int g_nColorMode;

#define LIGHT_OFFSET 9
#define RADIAN_45DEG  0.785398163397448309615
#define RADIAN_90DEG  1.57079632679489661923
#define RADIAN_135DEG 2.356194490192344899999999999925
#define DEGREE_CONVERTER 57.295779513082320876846364344191
#define RADIAN_CONVERTER 0.017453292519943295769222222222222

#define TRACK_TICK 5
#define FAST_TRACK_TICK 1
#define TRACK_DEGREES_PER_TICK 10

#define FLASH_TICK      150

#define KEYBOARD_STEP 3000

//static data members ... these control the Window Class
HINSTANCE CKnob::m_hInst = NULL;
DWORD CKnob::m_dwKnobClassRef = 0;
ATOM CKnob::m_KnobAtom = NULL;
HANDLE CKnob::m_hbmpKnob = NULL;
HANDLE CKnob::m_hbmpKnobTab = NULL;
HANDLE CKnob::m_hbmpLight = NULL;
HANDLE CKnob::m_hbmpLightBright = NULL;
HANDLE CKnob::m_hbmpLightMask = NULL;
int CKnob::m_nLightWidth = 0;
int CKnob::m_nLightHeight = 0;

CKnob* CreateKnob(DWORD dwWindowStyle,
		  DWORD dwRange,
		  DWORD dwInitialPosition,
		  int x,
		  int y,
		  int width,
		  int height,
		  HWND hwndParent,
		  int nID,
		  HINSTANCE hInst)
{
    if (CKnob::m_KnobAtom == NULL)
    {
    	CKnob::InitKnobs(hInst);
    }

    CKnob* pKnob = new CKnob;

    //ensure this is a child window
    dwWindowStyle = dwWindowStyle|WS_CHILD;

	TCHAR szCaption[MAX_PATH];
	LoadString(hInst,IDB_TT_VOLUME,szCaption,sizeof(szCaption)/sizeof(TCHAR));

    HWND hwnd = CreateWindowEx(0,
			       WC_KNOB,
			       szCaption,
			       dwWindowStyle,
			       x,
			       y,
			       width,
			       height,
			       hwndParent,
			       (HMENU)IntToPtr(nID),
			       hInst,
			       NULL);

    if (hwnd == NULL)
    {
	    //if we can't create the window, nuke it and fail
	    DWORD dwErr = GetLastError();
	    delete pKnob;
	    return NULL;
    }

    SetWindowLongPtr(hwnd,0,(LONG_PTR)pKnob);

    pKnob->m_hwnd = hwnd;
    pKnob->m_nID = nID;
    pKnob->SetRange(dwRange);
    pKnob->SetPosition(dwInitialPosition,FALSE);

    return (pKnob);
}

BOOL CKnob::InitKnobs(HINSTANCE hInst)
{
    m_hInst = hInst;
    
    if (m_KnobAtom == NULL)
    {
	    WNDCLASSEX wc;

	    ZeroMemory(&wc,sizeof(wc));
 
	    wc.cbSize = sizeof(wc);
	    wc.lpszClassName = WC_KNOB;
	    wc.lpfnWndProc = CKnob::KnobProc;
	    wc.hInstance = hInst;
	    wc.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
	    wc.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_MMFW));
	    wc.hCursor = LoadCursor(hInst, MAKEINTRESOURCE(IDC_VOLHAND));
	    wc.hbrBackground = (HBRUSH)(CTLCOLOR_DLG+1);
	    wc.cbWndExtra = sizeof(CKnob*);

	    m_KnobAtom = RegisterClassEx(&wc);
    }

    int nBitmap = IDB_KNOB;
    switch (g_nColorMode)
    {
        case COLOR_16 : nBitmap = IDB_KNOB_16; break;
        case COLOR_HICONTRAST : nBitmap = IDB_KNOB_HI; break;
    }

    HBITMAP hbmpTemp = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	CKnob::m_hbmpKnob = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    DeleteObject(hbmpTemp);

    nBitmap = IDB_KNOB_TABSTATE;
    switch (g_nColorMode)
    {
        case COLOR_16 : nBitmap = IDB_KNOB_TABSTATE_16; break;
        case COLOR_HICONTRAST : nBitmap = IDB_KNOB_TABSTATE_HI; break;
    }
    
    hbmpTemp = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	CKnob::m_hbmpKnobTab = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    DeleteObject(hbmpTemp);

    nBitmap = IDB_KNOB_LIGHT_DIM;
    switch (g_nColorMode)
    {
        case COLOR_16 : nBitmap = IDB_KNOB_LIGHT_16; break;
        case COLOR_HICONTRAST : nBitmap = IDB_KNOB_LIGHT_16; break;
    }
    
    hbmpTemp = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	CKnob::m_hbmpLight = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    BITMAP bm;
    GetObject(hbmpTemp,sizeof(bm),&bm);
    CKnob::m_nLightWidth = bm.bmWidth;
    CKnob::m_nLightHeight = bm.bmHeight;
    DeleteObject(hbmpTemp);

    nBitmap = IDB_KNOB_LIGHT;
    switch (g_nColorMode)
    {
        case COLOR_16 : nBitmap = IDB_KNOB_LIGHT_16; break;
        case COLOR_HICONTRAST : nBitmap = IDB_KNOB_LIGHT_HI; break;
    }
    
    hbmpTemp = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	CKnob::m_hbmpLightBright = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    DeleteObject(hbmpTemp);

    m_hbmpLightMask = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(IDB_KNOB_LIGHTMASK),IMAGE_BITMAP,0,0,LR_MONOCHROME);

    return (m_KnobAtom != NULL);
}

void CKnob::UninitKnobs()
{
    UnregisterClass(WC_KNOB,m_hInst);
    DeleteObject(CKnob::m_hbmpLightMask);
    GlobalFree(CKnob::m_hbmpLight);
    GlobalFree(CKnob::m_hbmpKnob);
    GlobalFree(CKnob::m_hbmpKnobTab);
    GlobalFree(CKnob::m_hbmpLightBright);
    m_KnobAtom = NULL;
    CKnob::m_hbmpLight = NULL;
    CKnob::m_hbmpKnob = NULL;
    CKnob::m_hbmpKnobTab = NULL;
    CKnob::m_hbmpLightMask = NULL;
    CKnob::m_hbmpLightBright = NULL;
}

//Given a parent window and a control ID, return the CMButton object
CKnob* GetKnobFromID(HWND hwndParent, int nID)
{
    HWND hwnd = GetDlgItem(hwndParent, nID);
    return (GetKnobFromHWND(hwnd));
}

//Given the window handle of the button, return the CMButton object
CKnob* GetKnobFromHWND(HWND hwnd)
{
    CKnob* pKnob = (CKnob*)GetWindowLongPtr(hwnd, 0);
    return (pKnob);    
}

CKnob::CKnob()
{
    m_dwKnobClassRef++;

    m_hwnd = NULL;
    m_nID = -1;
    m_nLightX = 0;
    m_nLightY = 0;
    m_dwRange = 100;
    m_dwPosition = 0;
    m_dwCurPosition = 0;
    m_fDim = TRUE;
}

CKnob::~CKnob()
{
    m_dwKnobClassRef--;

    if (m_dwKnobClassRef==0)
    {
	    UninitKnobs();
    }
}

void CALLBACK CKnob::TrackProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    CKnob* pKnob = (CKnob*)UIntToPtr(idEvent); //idEvent holds pointer to knob object that created timer
    if (pKnob!=NULL)
    {
        pKnob->OnTimer();
    }
}

void CALLBACK CKnob::FlashProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    CKnob* pKnob = (CKnob*)GetWindowLongPtr(hwnd, 0);
    if (pKnob!=NULL)
    {
        pKnob->OnFlashTimer();
    }
}

LRESULT CALLBACK CKnob::KnobProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    CKnob* pKnob = (CKnob*)GetWindowLongPtr(hwnd, 0);

    if (pKnob != NULL)
    {
	    switch (iMsg)
	    {
            case WM_SETFOCUS :
            {
                SendMessage(GetParent(pKnob->m_hwnd),DM_SETDEFID,pKnob->m_nID,0);

                pKnob->m_fDim = FALSE;
                InvalidateRect(hwnd,NULL,FALSE);
                UpdateWindow(hwnd);

                pKnob->m_uFlashTimerID = SetTimer(hwnd,(UINT_PTR)hwnd,FLASH_TICK,(TIMERPROC)CKnob::FlashProc);
            }
            break;

            case WM_KILLFOCUS :
            {
                KillTimer(hwnd,pKnob->m_uFlashTimerID);
                pKnob->m_fDim = TRUE;
                InvalidateRect(hwnd,NULL,FALSE);
                UpdateWindow(hwnd);
            }
            break;
            
            case WM_GETDLGCODE :
            {
                return (DLGC_WANTARROWS);
            }
            break;

            case WM_KEYDOWN :
            {
                int nVirtKey = (int)wParam;
                DWORD dwCurrent = pKnob->GetPosition();

                switch (nVirtKey)
                {
                    case VK_LEFT :
                    case VK_DOWN : 
                    {
                        if (dwCurrent - KEYBOARD_STEP > 65535)
                        {
                            dwCurrent = KEYBOARD_STEP;
                        }
                        pKnob->SetPosition(dwCurrent - KEYBOARD_STEP,TRUE);

                        NMHDR nmhdr;
                        nmhdr.hwndFrom = pKnob->m_hwnd;
                        nmhdr.idFrom = pKnob->m_nID;
                        nmhdr.code = TRUE;

                        SendMessage(GetParent(pKnob->m_hwnd),WM_NOTIFY,(WPARAM)pKnob->m_nID,(LPARAM)&nmhdr);
                    }
                    break;

                    case VK_RIGHT :
                    case VK_UP :
                    {
                        if (dwCurrent + KEYBOARD_STEP > 65535)
                        {
                            dwCurrent = 65535 - KEYBOARD_STEP;
                        }
                        pKnob->SetPosition(dwCurrent + KEYBOARD_STEP,TRUE);

                        NMHDR nmhdr;
                        nmhdr.hwndFrom = pKnob->m_hwnd;
                        nmhdr.idFrom = pKnob->m_nID;
                        nmhdr.code = TRUE;

                        SendMessage(GetParent(pKnob->m_hwnd),WM_NOTIFY,(WPARAM)pKnob->m_nID,(LPARAM)&nmhdr);
                    }
                    break;

                    default: 
                    {
                        //not a key we want ... tell our parent about it
                        SendMessage(GetParent(hwnd),WM_KEYDOWN,wParam,lParam);
                    }
                    break;
                } //end switch
            }
            break;

            case WM_ERASEBKGND :
            {
                pKnob->Draw((HDC)wParam);
                return TRUE;
            }

	        case WM_PAINT :
	        {
		        HDC hdc;
		        PAINTSTRUCT ps;

		        hdc = BeginPaint( hwnd, &ps );
		        
		        pKnob->Draw(hdc);
		        
		        EndPaint(hwnd,&ps);

                return 0;
	        }
	        break;

	        case WM_RBUTTONDOWN :
	        {
                pKnob->m_fFastKnob = TRUE;
    		    pKnob->OnButtonDown(LOWORD(lParam),HIWORD(lParam));
	    	    pKnob->OnMouseMove(LOWORD(lParam),HIWORD(lParam));
	        }
	        break;

	        case WM_RBUTTONUP :
	        {
    		    pKnob->OnButtonUp();
	        }
	        break;

	        case WM_LBUTTONDOWN :
	        {
                pKnob->m_fFastKnob = FALSE;
    		    pKnob->OnButtonDown(LOWORD(lParam),HIWORD(lParam));
	    	    pKnob->OnMouseMove(LOWORD(lParam),HIWORD(lParam));
	        }
	        break;

	        case WM_LBUTTONUP :
	        {
    		    pKnob->OnButtonUp();
	        }
	        break;

	        case WM_MOUSEMOVE :
	        {
	    	    pKnob->OnMouseMove(LOWORD(lParam),HIWORD(lParam));
	        }
	        break;

	    } //end switch
    } //end if class pointer assigned

    LRESULT lResult = DefWindowProc(hwnd, iMsg, wParam, lParam);

    if (iMsg == WM_DESTROY)
    {
	    //auto-delete the knob class
	    SetWindowLongPtr(hwnd,0,0);
	    if (pKnob)
	    {
	        delete pKnob;
	    }
	    pKnob = NULL;
    }

    return (lResult);
}

void CKnob::OnButtonDown(int x, int y)
{
    SetCapture(m_hwnd);

    m_fDim = FALSE;
    InvalidateRect(m_hwnd,NULL,FALSE);
    UpdateWindow(m_hwnd);

    m_uFlashTimerID = SetTimer(m_hwnd,(UINT_PTR)m_hwnd,FLASH_TICK,(TIMERPROC)CKnob::FlashProc);
}

void CKnob::OnButtonUp()
{
    KillTimer(m_hwnd,m_uTrackTimerID);
    KillTimer(m_hwnd,m_uFlashTimerID);

    //we want to be sure the light is dim when we're done
    if (!m_fDim)
    {
        m_fDim = TRUE;
        InvalidateRect(m_hwnd,NULL,FALSE);
        UpdateWindow(m_hwnd);
    }

    ReleaseCapture();
}

void CKnob::OnFlashTimer()
{
    m_fDim = !m_fDim;
    InvalidateRect(m_hwnd,NULL,FALSE);
    UpdateWindow(m_hwnd);
}

void CKnob::OnTimer()
{
    RECT rect;
    GetClientRect(m_hwnd,&rect);
    int nWidth = rect.right - rect.left;
    int radius = (nWidth / 2) - LIGHT_OFFSET;

    double degree = ((double)m_dwPosition / m_dwRange) * 270;
    degree = degree + 135;

    if (abs((int)m_trackdegree-(int)degree) < TRACK_DEGREES_PER_TICK)
    {
        m_trackdegree = degree;
        KillTimer(m_hwnd,m_uTrackTimerID);
    }
    else
    {
        if (m_trackdegree > degree)
        {
            m_trackdegree -= TRACK_DEGREES_PER_TICK;
        }
        else
        {
            m_trackdegree += TRACK_DEGREES_PER_TICK;
        }
    }

    double angle = m_trackdegree * RADIAN_CONVERTER;

    double fLightX = radius * cos(angle);
    double fLightY = radius * sin(angle);

    //convert to proper gdi coordinates
    m_nLightX = ((int)fLightX) - (m_nLightWidth / 2) + (nWidth / 2);
    m_nLightY = ((int)fLightY) - (m_nLightHeight / 2) + (nWidth / 2);

    InvalidateRect(m_hwnd,NULL,FALSE);
    UpdateWindow(m_hwnd);

	degree = m_trackdegree - 135;
	if (degree < 0) degree = degree + 360;
	double percentage = degree / 270; 
	m_dwCurPosition = (DWORD)(m_dwRange * percentage);

    NMHDR nmhdr;
    nmhdr.hwndFrom = m_hwnd;
    nmhdr.idFrom = m_nID;
    nmhdr.code = TRUE;

    SendMessage(GetParent(m_hwnd),WM_NOTIFY,(WPARAM)m_nID,(LPARAM)&nmhdr);
}


BOOL CKnob::ComputeCursor(int deltaX, int deltaY, int maxdist)
{
    double  distance = sqrt(double((deltaX * deltaX) + (deltaY * deltaY)));
    double  degrees =  -((atan2(deltaX,deltaY) * DEGREE_CONVERTER) - double(180.0));
    BOOL    fDeadZone = FALSE;

    if (distance < double(4))
    {
        fDeadZone = TRUE;
    }

    if (distance <= maxdist)
    {
        SetCursor(LoadCursor(m_hInst, MAKEINTRESOURCE(IDC_VOLHAND)));
    }
    else
    {
        int volcur;

        if ((degrees < double( 22.5) || degrees > double(337.5)) ||
            (degrees > double(157.5) && degrees < double(202.5)))
        {
            volcur = IDC_VOLHORZ;
        }
        else if ((degrees > double( 22.5) && degrees < double( 67.5)) ||
                 (degrees > double(202.5) && degrees < double(247.5)))
        {
            volcur = IDC_VOLDNEG;
        }
        else if ((degrees > double( 67.5) && degrees < double(112.5)) ||
                 (degrees > double(247.5) && degrees < double(292.5)))
        {
            volcur = IDC_VOLVERT;
        }
        else 
        {
            volcur = IDC_VOLDPOS;
        }

        SetCursor(LoadCursor(m_hInst, MAKEINTRESOURCE(volcur)));
    }

    return fDeadZone;
}

void CKnob::OnMouseMove(int x, int y)
{
    if (GetCapture()==m_hwnd)
    {
        //do the calculations as if 0,0 were the center of the control,
	    //then translate to gdi coordinates later (0,0 = top left of control in gdi)
	    RECT rect;
	    GetClientRect(m_hwnd,&rect);
	    int nWidth = rect.right - rect.left;
	    int nHeight = rect.bottom - rect.top;

        int maxdist = (nWidth / 2) + 3;
	    int radius = (nWidth / 2) - LIGHT_OFFSET;

	    //convert to short to force negative numbers for coordinates
	    short sx = (short)x;
	    short sy = (short)y;

	    int deltaX = sx - (nWidth / 2);
	    int deltaY = sy - (nHeight / 2);

        ComputeCursor(deltaX, deltaY, maxdist);

	    double angle = atan2(deltaY,deltaX);
	    double degrees = angle * DEGREE_CONVERTER;

	    degrees = degrees + 225;

	    if (degrees < 0) degrees = 0;
    
        if (degrees >= 360)
        {
            degrees = degrees - 360;
        }        
    
        double percentage = degrees / 270;
        
        m_dwPosition = (DWORD)(m_dwRange * percentage);

        //special-case the "dead zone"
        if ((degrees >= 270) && (degrees <= 315))
        {
            m_dwPosition = m_dwRange;
        }

        if (degrees > 315)
        {
            m_dwPosition = 0;
        }

        if (m_fFastKnob)
        {
             m_uTrackTimerID = SetTimer(m_hwnd,(UINT_PTR)this,FAST_TRACK_TICK,(TIMERPROC)CKnob::TrackProc);
        }
        else
        {
            m_uTrackTimerID = SetTimer(m_hwnd,(UINT_PTR)this,TRACK_TICK,(TIMERPROC)CKnob::TrackProc);
        }
    }
}

void CKnob::SetPosition(DWORD dwPosition, BOOL fNotify)
{
    if (GetCapture()==m_hwnd)
    {
        //we're in a feedback loop, return immediately
        return;
    }
    
    m_dwPosition = dwPosition;
    m_dwCurPosition = dwPosition;

    RECT rect;
    GetClientRect(m_hwnd,&rect);
    int nWidth = rect.right - rect.left;
    int radius = (nWidth / 2) - LIGHT_OFFSET;

    double degree = ((double)m_dwPosition / m_dwRange) * 270;
    degree = degree + 135;

    m_trackdegree = degree; //instantly track when position is set programmatically

    double angle = degree * RADIAN_CONVERTER;

    double fLightX = radius * cos(angle);
    double fLightY = radius * sin(angle);

    //convert to proper gdi coordinates
    m_nLightX = ((int)fLightX) - (m_nLightWidth / 2) + (nWidth / 2);
    m_nLightY = ((int)fLightY) - (m_nLightHeight / 2) + (nWidth / 2);

    InvalidateRect(m_hwnd,NULL,FALSE);
    UpdateWindow(m_hwnd);

    if (fNotify)
    {
        NMHDR nmhdr;
        nmhdr.hwndFrom = m_hwnd;
        nmhdr.idFrom = m_nID;
        nmhdr.code = FALSE;

        SendMessage(GetParent(m_hwnd),WM_NOTIFY,(WPARAM)m_nID,(LPARAM)&nmhdr);
    }
}

//kmaskblt -- cuz MaskBlt doesn't work on all platforms.  This is all it does anyway.
//            uses same params as MaskBlt, ignoring the flags part as dwDummy
void CKnob::KMaskBlt(HDC hdcDest, int x, int y, int width, int height, HDC hdcSource, int xs, int ys, HBITMAP hMask, int xm, int ym, DWORD dwDummy)
{
    HDC hdcMask = CreateCompatibleDC(hdcDest);
    HBITMAP holdbmp = (HBITMAP)SelectObject(hdcMask,hMask);

    BitBlt(hdcDest, x, y, width, height, hdcSource, xs, ys, SRCINVERT);
    BitBlt(hdcDest, x, y, width, height, hdcMask, xm, ym, SRCAND);
    BitBlt(hdcDest, x, y, width, height, hdcSource, xs, ys, SRCINVERT);

    SelectObject(hdcMask,holdbmp);
    DeleteDC(hdcMask);
}

void CKnob::Draw(HDC hdc)
{
    RECT rect;
    GetClientRect(m_hwnd,&rect);
    int nWidth = rect.right - rect.left;
    int nHeight = rect.bottom - rect.top;

    HPALETTE hpalOld = SelectPalette(hdc,hpalMain,FALSE);
    RealizePalette(hdc);
    
    HDC memDC = CreateCompatibleDC(hdc);
    HPALETTE hpalmemOld = SelectPalette(memDC,hpalMain,FALSE);
    RealizePalette(memDC);
    
    HBITMAP hbmp = CreateCompatibleBitmap(hdc,nWidth,nHeight);
    HBITMAP hbmpOld = (HBITMAP)SelectObject(memDC,hbmp);

    HDC maskmemDC = CreateCompatibleDC(hdc);
    HBITMAP hmaskbmp = CreateCompatibleBitmap(hdc,nWidth,nHeight);
    HBITMAP hmaskbmpOld = (HBITMAP)SelectObject(maskmemDC,hmaskbmp);

    if (GetFocus()==m_hwnd)
    {
        DibBlt(memDC, 0, 0, -1, -1, m_hbmpKnobTab, 0, 0, SRCCOPY, 0);
    }
    else
    {
        DibBlt(memDC, 0, 0, -1, -1, m_hbmpKnob, 0, 0, SRCCOPY, 0);
    }

    DibBlt(maskmemDC, 0, 0, -1, -1, m_fDim ? m_hbmpLight : m_hbmpLightBright, 0, 0, SRCCOPY, 0);
    KMaskBlt(memDC,
	    m_nLightX,
	    m_nLightY,
	    m_nLightWidth,
	    m_nLightHeight,
	    maskmemDC,
	    0,
	    0,
	    (HBITMAP)m_hbmpLightMask,
	    0,
	    0,
	    MAKEROP4(SRCAND,SRCCOPY));

    BitBlt(hdc,0,0,nWidth,nHeight,memDC,0,0,SRCCOPY);
    
    SelectObject(memDC,hbmpOld);
    SelectPalette(memDC,hpalmemOld,TRUE);
    RealizePalette(memDC);
    DeleteObject(hbmp);
    DeleteDC(memDC);

    SelectObject(maskmemDC, hmaskbmpOld);
    DeleteObject(hmaskbmp);
    DeleteDC(maskmemDC);

    SelectPalette(hdc,hpalOld,TRUE);
    RealizePalette(hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\mbutton.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  MBUTTON.CPP
//
//      Multimedia Button Control class; helper functions
//
//      Copyright (c) Microsoft Corporation     1997
//    
//      12/14/97 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "mbutton.h"
#include <windowsx.h>   //for GetWindowFont
#include <winuser.h>    //for TrackMouseEvent
#include <commctrl.h>   //for WM_MOUSELEAVE
#include <TCHAR.H>
#include "resource.h"
#include "dib.h"
#include "mmfw.h"

//file-local default values for buttons
#define NUM_STATES  3
#define STATE_UP    0
#define STATE_DN    1
#define STATE_HI    2
#define BOFF_STANDARDLEFT   0
#define BOFF_TOGGLELEFT     1
#define BOFF_STANDARDRIGHT  2
#define BOFF_DROPRIGHT      3
#define BOFF_TOGGLERIGHT    4
#define BOFF_MIDDLE         5
#define BOFF_SYSTEM         6
#define BOFF_MINIMIZE       7
#define BOFF_RESTORE        8
#define BOFF_MAXIMIZE       9
#define BOFF_CLOSE          10
#define BOFF_MUTE           11
#define BOFF_END            12
#define BUTTON_BITMAP_HEIGHT    19
#define BUTTON_FONT_SIZE        8
#define BUTTON_DBCS_FONT_SIZE   9
#define BUTTON_FONT_WEIGHT      FW_BOLD

#define MBUTTON_TEXT_COLOR RGB(0xFF,0xFF,0xFF)

HFONT    hFont = NULL;
HANDLE   hbmpButtonToolkit = NULL;
int      nStateOffset = 0;
int      nButtonOffsets[BOFF_END+1];
extern   HPALETTE hpalMain;
extern  int g_nColorMode;
CMButton* pButtonFocus = NULL;
CMButton* pButtonMouse = NULL;
BOOL      fAllowFocus = TRUE;


//for this to work on a Win95 machine, we need to make TrackMouseEvent
//a dynamically loaded thing ... but then you get NO HOVER-OVER EFFECT
typedef BOOL (PASCAL *TRACKPROC)(LPTRACKMOUSEEVENT);
TRACKPROC procTrackMouseEvent = NULL;

BOOL InitMButtons(HINSTANCE hInst, HWND hwnd)
{
    BOOL fReturn = TRUE;

    //if TrackMouseEvent exists, use it
    HMODULE hUser = GetModuleHandle(TEXT("USER32"));
    if (hUser)
    {
        procTrackMouseEvent = (TRACKPROC)GetProcAddress(hUser,"TrackMouseEvent");
    }

    //create font, named store in IDS_MBUTTON_FONT in string table
    LOGFONT     lf;
    ZeroMemory( &lf, sizeof(lf) );

    HFONT hTempFont = GetWindowFont( hwnd );
    if (hTempFont == NULL)
    {
        hTempFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    }

    GetObject(hTempFont,sizeof(lf),&lf);

    lf.lfHeight = (-BUTTON_FONT_SIZE * STANDARD_PIXELS_PER_INCH) / 72;
    if (lf.lfCharSet == ANSI_CHARSET)
    {
        lf.lfWeight = BUTTON_FONT_WEIGHT;
    }
    else if (IS_DBCS_CHARSET(lf.lfCharSet)) {
        lf.lfHeight = (-BUTTON_DBCS_FONT_SIZE * STANDARD_PIXELS_PER_INCH) / 72;
    }

    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;

    LoadString(hInst,IDS_MBUTTON_FONT,lf.lfFaceName,LF_FACESIZE-1);

    hFont = CreateFontIndirect(&lf);

    //create bitmap, has all states for all buttons
    int nBitmap = IDB_BUTTON_TOOLKIT;
    switch (g_nColorMode)
    {
        case COLOR_16 : nBitmap = IDB_BUTTON_TOOLKIT_16; break;
        case COLOR_HICONTRAST : nBitmap = IDB_BUTTON_TOOLKIT_HI; break;
    }

    HBITMAP hbmpTemp = (HBITMAP)LoadImage(hInst,MAKEINTRESOURCE(nBitmap),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	hbmpButtonToolkit = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
    BITMAP bm;
    GetObject(hbmpTemp,sizeof(bm),&bm);
    DeleteObject(hbmpTemp);

    nStateOffset = bm.bmWidth / NUM_STATES;

    //offsets within bitmap
    nButtonOffsets[BOFF_STANDARDLEFT]   = 0;
    nButtonOffsets[BOFF_TOGGLELEFT]     = 9;
    nButtonOffsets[BOFF_STANDARDRIGHT]  = 11;
    nButtonOffsets[BOFF_DROPRIGHT]      = 20;
    nButtonOffsets[BOFF_TOGGLERIGHT]    = 42;
    nButtonOffsets[BOFF_MIDDLE]         = 44; 
    nButtonOffsets[BOFF_SYSTEM]         = 52; 
    nButtonOffsets[BOFF_MINIMIZE]       = 64;
    nButtonOffsets[BOFF_RESTORE]        = 78; 
    nButtonOffsets[BOFF_MAXIMIZE]       = 92; 
    nButtonOffsets[BOFF_CLOSE]          = 106; 
    nButtonOffsets[BOFF_MUTE]           = 121;
    nButtonOffsets[BOFF_END]            = nStateOffset;

	//SetDibUsage(hbmpButtonToolkit,hpalMain,DIB_RGB_COLORS);

    return (fReturn);
}

void UninitMButtons()
{
    GlobalFree(hbmpButtonToolkit);
    DeleteObject(hFont);
}

//Given a parent window and a control ID, return the CMButton object
CMButton* GetMButtonFromID(HWND hwndParent, int nID)
{
    HWND hwnd = GetDlgItem(hwndParent, nID);
    return (GetMButtonFromHWND(hwnd));
}

//Given the window handle of the button, return the CMButton object
CMButton* GetMButtonFromHWND(HWND hwnd)
{
    CMButton* pButton = (CMButton*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    return (pButton);    
}

CMButton* CreateMButton(TCHAR* szCaption, int nIconID, DWORD dwWindowStyle, DWORD dwMButtonStyle, int x, int y, int width, int height, HWND hwndParentOrSub, BOOL fSubExisting, int nID, int nToolTipID, HINSTANCE hInst)
{
    CMButton* pButton = new CMButton;

    //ensure the button is a child, pushbutton, owner-draw
    //caller should specify WS_VISIBLE|WS_TABSTOP if desired
    dwWindowStyle = dwWindowStyle|WS_CHILD|BS_PUSHBUTTON|BS_OWNERDRAW;

    HWND hwnd;
    
    if (fSubExisting)
    {
	    //user already created button, is probably calling from WM_INITDIALOG
	    hwnd = hwndParentOrSub;
    }
    else
    {
	    //need to create the button ourselves
	    hwnd = CreateWindow(TEXT("BUTTON"),
			         szCaption,
			         dwWindowStyle,
			         x,
			         y,
			         width,
			         height,
			         hwndParentOrSub,
			         (HMENU)IntToPtr(nID),
			         hInst,
			         NULL);
    }

    if (hwnd == NULL)
    {
	    //if we can't create the window, nuke it and fail
	    delete pButton;
	    return NULL;
    }

    pButton->m_hInst = hInst;
    pButton->m_fRedraw = FALSE;
    pButton->m_dwStyle = dwMButtonStyle;
    pButton->m_hwnd = hwnd;
    pButton->SetIcon(nIconID);
    pButton->SetFont(hFont);
    pButton->m_fRedraw = TRUE;
    pButton->m_nID = nID;
    pButton->SetToolTipID(nToolTipID);

    pButton->PreDrawUpstate(width,height);

    //subclass the button; allows tracking of mouse events
    pButton->m_fnOldButton = (WNDPROC)SetWindowLongPtr(hwnd,GWLP_WNDPROC,(LONG_PTR)CMButton::ButtonProc);

    //put the button's pointer into the window's user bytes
    SetWindowLongPtr(hwnd,GWLP_USERDATA,(LONG_PTR)pButton);

    return (pButton);
}

void CMButton::PreDrawUpstate(int width, int height)
{
    //pre-draw the up states of the buttons for a faster-seeming first blit
    if (m_hbmpUp) DeleteObject(m_hbmpUp);
    if (m_hbmpDn) DeleteObject(m_hbmpDn);
    if (m_hbmpHi) DeleteObject(m_hbmpHi);
    m_hbmpUp = NULL;
    m_hbmpDn = NULL;
    m_hbmpHi = NULL;

    DRAWITEMSTRUCT drawItem;

    drawItem.rcItem.left = 0;
    drawItem.rcItem.top = 0;
    drawItem.rcItem.right = width;
    drawItem.rcItem.bottom = height;

    drawItem.itemState = 0;
    drawItem.hDC = GetDC(m_hwnd);
    HPALETTE hpalOld = SelectPalette(drawItem.hDC,hpalMain,FALSE);
    RealizePalette(drawItem.hDC);

    DrawButtonBitmap(&drawItem,FALSE,NULL);

    SelectPalette(drawItem.hDC,hpalOld,TRUE);
    RealizePalette(drawItem.hDC);
    ReleaseDC(m_hwnd,drawItem.hDC);
}

LRESULT CALLBACK CMButton::ButtonProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    CMButton* pButton = (CMButton*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    if (pButton == NULL)
    {
    	return (0);
    }

    switch (iMsg)
    {
	    case WM_MOUSEMOVE :
	    {
	        if (!pButton->m_fMouseInButton)
	        {
		        if (procTrackMouseEvent)
                {
		            //only do this if the trackmouseevent function exists,
                    //otherwise, the button color will never turn off
                    pButton->m_fMouseInButton = TRUE;
		            TRACKMOUSEEVENT tme;
		            tme.cbSize = sizeof(tme);
		            tme.dwFlags = TME_LEAVE;
		            tme.dwHoverTime = HOVER_DEFAULT;
		            tme.hwndTrack = hwnd;
                    procTrackMouseEvent(&tme);
		            InvalidateRect(hwnd,NULL,FALSE);
                } //end proctrackmouseevent is valid
	        }
	    }
	    break;

        case WM_KEYUP :
        {
            //for the close, min, and view buttons, we want to shunt
            //any keyboard movement to the knob ... although tempting,
            //don't do this on the setfocus, or the mouse won't work right

            if (
                (pButton->m_nID == IDB_CLOSE) ||
                (pButton->m_nID == IDB_MINIMIZE) ||
                (pButton->m_nID == IDB_SET_TINY_MODE) ||
                (pButton->m_nID == IDB_SET_NORMAL_MODE)
               )
            {
                HWND hwndFocus = GetDlgItem(GetParent(hwnd),IDB_VOLUME);
                if (IsWindowVisible(hwndFocus))
                {
                    SetFocus(hwndFocus);
                }
                else
                {
                    hwndFocus = GetDlgItem(GetParent(hwnd),IDB_OPTIONS);
                    SetFocus(hwndFocus);
                }
            } //end if
        }
        break;

        case WM_SETFOCUS :
        {
            SendMessage(GetParent(pButton->m_hwnd),DM_SETDEFID,pButton->m_nID,0);
        }
        break;

	    case WM_MOUSELEAVE :
	    {
	        pButton->m_fMouseInButton = FALSE;
	        InvalidateRect(hwnd,NULL,FALSE);
	    }
	    break;

        case WM_ERASEBKGND :
        {
            DRAWITEMSTRUCT drawItem;
            drawItem.hDC = (HDC)wParam;
            GetClientRect(hwnd,&(drawItem.rcItem));
            drawItem.itemState = pButton->m_LastState;
            pButton->Draw(&drawItem);
            return TRUE;
        }
        break;

    } //end switch

    LRESULT lResult = CallWindowProc((WNDPROC)pButton->m_fnOldButton,hwnd,iMsg,wParam,lParam);

    if ((iMsg == WM_DESTROY) && ((pButton->m_dwStyle & MBS_NOAUTODELETE) == 0))
    {
	    //auto-delete the button class
	    SetWindowLongPtr(hwnd,GWLP_USERDATA,0);
	    delete pButton;
	    pButton = NULL;
    }

    return (lResult);
}

CMButton::CMButton()
{
    //init all data values
    m_fMouseInButton = FALSE;
    m_dwStyle = MBS_STANDARDLEFT | MBS_STANDARDRIGHT;
    m_hFont = hFont;
    m_nID = 0;
    m_IconID = 0;
    m_hwnd = NULL;
    m_hbmpUp = NULL;
    m_hbmpDn = NULL;
    m_hbmpHi = NULL;
    m_fRedraw = FALSE;
    m_fMenu = FALSE;
    m_fMenuingOff = FALSE;
    m_LastState = 0;
}

CMButton::~CMButton()
{
    if (m_hbmpUp) DeleteObject(m_hbmpUp);
    if (m_hbmpDn) DeleteObject(m_hbmpDn);
    if (m_hbmpHi) DeleteObject(m_hbmpHi);
}

void CMButton::SetText(TCHAR* szCaption)
{
    SetWindowText(m_hwnd,szCaption);

    if (m_fRedraw)
    {
	    InvalidateRect(m_hwnd,NULL,FALSE);
    }
}

void CMButton::SetIcon(int nIconID)
{
    //assuming caller is responsible for cleaning up
    m_IconID = nIconID;

    if (m_fRedraw)
    {
	    InvalidateRect(m_hwnd,NULL,FALSE);
    }
}

void CMButton::SetFont(HFONT hFont)
{
    //assume caller is responsible for cleaning up
    m_hFont = hFont;
}

void CMButton::DrawButtonBitmap(LPDRAWITEMSTRUCT lpdis, BOOL fDrawToScreen, RECT* pMidRect)
{
    HANDLE hTemp = m_hbmpUp;
    int nState = STATE_UP;
	
    if (m_fMouseInButton)
    {
        pButtonMouse = this;
	    hTemp = m_hbmpHi;
	    nState = STATE_HI;

        if (pButtonFocus!=NULL)
        {
            fAllowFocus = FALSE;
            if (this != pButtonFocus)
            {
                InvalidateRect(pButtonFocus->GetHWND(),NULL,FALSE);
                UpdateWindow(pButtonFocus->GetHWND());
            }
        }
    }
    else
    {
        if (lpdis->itemState & ODS_FOCUS)
        {
            if (this == pButtonFocus)
            {
                if (fAllowFocus)
                {
                    hTemp = m_hbmpHi;
                    nState = STATE_HI;
                }
                else
                {
                    hTemp = m_hbmpUp;
                    nState = STATE_UP;
                }
            }
            else
            {
                pButtonFocus = this;
                hTemp = m_hbmpHi;
                nState = STATE_HI;
                fAllowFocus = TRUE;
                if ((pButtonMouse!=NULL) && (pButtonMouse!=this))
                {
	                pButtonMouse->m_fMouseInButton = FALSE;
	                InvalidateRect(pButtonMouse->GetHWND(),NULL,FALSE);
                    UpdateWindow(pButtonMouse->GetHWND());
                    pButtonMouse = NULL;
                } //end if removing mouse highlight
            }
        }
    } //end if mouse in or out of button

    if ((lpdis->itemState & ODS_SELECTED) || (m_fMenu))
    {
	    hTemp = m_hbmpDn;
	    nState = STATE_DN;
    }

	int offLeft, widLeft;
	int offRight, widRight;
	int offMid, widMid;

	offLeft = nButtonOffsets[BOFF_STANDARDLEFT] + (nState * nStateOffset);
	widLeft = nButtonOffsets[BOFF_STANDARDLEFT+1] - nButtonOffsets[BOFF_STANDARDLEFT];

	if ((m_dwStyle & MBS_TOGGLELEFT) == MBS_TOGGLELEFT)
	{
	    offLeft = nButtonOffsets[BOFF_TOGGLELEFT] + (nState * nStateOffset);
	    widLeft = nButtonOffsets[BOFF_TOGGLELEFT+1] - nButtonOffsets[BOFF_TOGGLELEFT];
	}

	if ((m_dwStyle & MBS_SYSTEMTYPE) == MBS_SYSTEMTYPE)
	{
	    switch (m_IconID)
	    {
		    case IDB_CLOSE :
		    {
		        offLeft = nButtonOffsets[BOFF_CLOSE] + (nState * nStateOffset);
		        widLeft = nButtonOffsets[BOFF_CLOSE+1] - nButtonOffsets[BOFF_CLOSE];
		    }
		    break;

		    case IDB_MINIMIZE :
		    {
		        offLeft = nButtonOffsets[BOFF_MINIMIZE] + (nState * nStateOffset);
		        widLeft = nButtonOffsets[BOFF_MINIMIZE+1] - nButtonOffsets[BOFF_MINIMIZE];
		    }
		    break;

		    case IDB_SET_TINY_MODE :
		    {
		        offLeft = nButtonOffsets[BOFF_RESTORE] + (nState * nStateOffset);
		        widLeft = nButtonOffsets[BOFF_RESTORE+1] - nButtonOffsets[BOFF_RESTORE];
		    }
		    break;

		    case IDB_SET_NORMAL_MODE :
		    {
		        offLeft = nButtonOffsets[BOFF_MAXIMIZE] + (nState * nStateOffset);
		        widLeft = nButtonOffsets[BOFF_MAXIMIZE+1] - nButtonOffsets[BOFF_MAXIMIZE];
		    }
		    break;

            case IDB_MUTE :
            {
                offLeft = nButtonOffsets[BOFF_MUTE] + (nState * nStateOffset);
                widLeft = nButtonOffsets[BOFF_MUTE+1]  - nButtonOffsets[BOFF_MUTE];
            }
	    }
	}

	offRight = nButtonOffsets[BOFF_STANDARDRIGHT] + (nState * nStateOffset);
	widRight = nButtonOffsets[BOFF_STANDARDRIGHT+1] - nButtonOffsets[BOFF_STANDARDRIGHT];

	if ((m_dwStyle & MBS_TOGGLERIGHT) == MBS_TOGGLERIGHT)
	{
	    offRight = nButtonOffsets[BOFF_TOGGLERIGHT] + (nState * nStateOffset);
	    widRight = nButtonOffsets[BOFF_TOGGLERIGHT+1] - nButtonOffsets[BOFF_TOGGLERIGHT];
	}

	if ((m_dwStyle & MBS_DROPRIGHT) == MBS_DROPRIGHT)
	{
	    offRight = nButtonOffsets[BOFF_DROPRIGHT] + (nState * nStateOffset);
	    widRight = nButtonOffsets[BOFF_DROPRIGHT+1] - nButtonOffsets[BOFF_DROPRIGHT];
	}

	offMid = nButtonOffsets[BOFF_MIDDLE] + (nState * nStateOffset);
	widMid = (lpdis->rcItem.right - lpdis->rcItem.left) - widLeft - widRight;

    if (pMidRect)
    {
        if (m_dwStyle & MBS_DROPRIGHT)
        {
            //set rect to just the middle of the button part
            SetRect(pMidRect,
                    lpdis->rcItem.left,
                    lpdis->rcItem.top,
                    lpdis->rcItem.left + widLeft + widMid,
                    lpdis->rcItem.top + BUTTON_BITMAP_HEIGHT);
        }
        else
        {
            //set rect to whole button
            SetRect(pMidRect,
                    lpdis->rcItem.left,
                    lpdis->rcItem.top,
                    lpdis->rcItem.right,
                    lpdis->rcItem.bottom);
        }
    }

    if (hTemp == NULL)
    {
	    //draw and save bumps
	    HDC memDC = CreateCompatibleDC(lpdis->hDC);
	    HPALETTE hpalOld = SelectPalette(memDC, hpalMain, FALSE);
	    HBITMAP holdbmp;

        switch (nState)
        {
            case STATE_UP :
            {
		        m_hbmpUp = CreateCompatibleBitmap(lpdis->hDC,
						          lpdis->rcItem.right - lpdis->rcItem.left,
						          BUTTON_BITMAP_HEIGHT);

		        holdbmp = (HBITMAP)SelectObject(memDC,m_hbmpUp);
            }
            break;

            case STATE_DN :
            {
		        m_hbmpDn = CreateCompatibleBitmap(lpdis->hDC,
						          lpdis->rcItem.right - lpdis->rcItem.left,
						          BUTTON_BITMAP_HEIGHT);
		        holdbmp = (HBITMAP)SelectObject(memDC,m_hbmpDn);
            }
            break;

            case STATE_HI :
            {
	            m_hbmpHi = CreateCompatibleBitmap(lpdis->hDC,
					              lpdis->rcItem.right - lpdis->rcItem.left,
					              BUTTON_BITMAP_HEIGHT);
	            holdbmp = (HBITMAP)SelectObject(memDC,m_hbmpHi);
            }
            break;
        }

	    //draw left
	    DibBlt(memDC,
		        lpdis->rcItem.left,
		        lpdis->rcItem.top,
		        -1, 
		        -1, 
		        hbmpButtonToolkit,
		        offLeft,0,
		        SRCCOPY,0);

	    if ((m_dwStyle & MBS_SYSTEMTYPE) != MBS_SYSTEMTYPE)
	    {
	        //draw middle
	        StretchDibBlt(memDC,
		        lpdis->rcItem.left + widLeft,
		        lpdis->rcItem.top,
		        widMid,
		        BUTTON_BITMAP_HEIGHT,
		        hbmpButtonToolkit,
		        offMid,0,
		        nButtonOffsets[BOFF_MIDDLE+1] - nButtonOffsets[BOFF_MIDDLE],
		        BUTTON_BITMAP_HEIGHT,
		        SRCCOPY,0);

	        //draw right
	        DibBlt(memDC,
		        lpdis->rcItem.right - widRight,
		        lpdis->rcItem.top,
		        -1,
		        -1,
		        hbmpButtonToolkit,
		        offRight,0,
		        SRCCOPY,0);
	    }

	    SelectObject(memDC,holdbmp);
	    SelectPalette(memDC, hpalOld, TRUE);
	    DeleteDC(memDC);
    } //end not already drawn

    if (fDrawToScreen)
    {
	    //should have bumps ready to go now
	    hTemp = m_hbmpUp;

	    if (m_fMouseInButton)
	    {
	        hTemp = m_hbmpHi;
	    }

        if (lpdis->itemState & ODS_FOCUS)
        {
            if (fAllowFocus)
            {
                hTemp = m_hbmpHi;
            }
        }

	    if ((lpdis->itemState & ODS_SELECTED) || (m_fMenu))
	    {
	        hTemp = m_hbmpDn;
	    }

	    if (!(lpdis->itemState & ODS_SELECTED) && (m_fMenuingOff))
        {
            m_fMenu = FALSE;
            m_fMenuingOff = FALSE;
            hTemp = m_hbmpUp;
        }

	    HDC memDC = CreateCompatibleDC(lpdis->hDC);
	    HBITMAP holdbmp = (HBITMAP)SelectObject(memDC,hTemp);

	    BitBlt(lpdis->hDC,
		        lpdis->rcItem.left,
		        lpdis->rcItem.top,
		        lpdis->rcItem.right - lpdis->rcItem.left, 
		        lpdis->rcItem.bottom - lpdis->rcItem.top, 
		        memDC,
		        0,0,
		        SRCCOPY);

	    SelectObject(memDC,holdbmp);
	    DeleteDC(memDC);
    }
}

void CMButton::Draw(LPDRAWITEMSTRUCT lpdis)
{
    HPALETTE hpalOld = SelectPalette(lpdis->hDC,hpalMain,FALSE);
    RealizePalette(lpdis->hDC);

    SetTextColor(lpdis->hDC, MBUTTON_TEXT_COLOR);

    m_LastState = lpdis->itemState;

    if (lpdis->itemState & ODS_DISABLED)
    {
        SetTextColor(lpdis->hDC, GetSysColor(COLOR_GRAYTEXT));
    }

    RECT midRect;
    DrawButtonBitmap(lpdis,TRUE,&midRect);

    if ((m_dwStyle & MBS_SYSTEMTYPE) == MBS_SYSTEMTYPE)
    {
        SelectPalette(lpdis->hDC,hpalOld,TRUE);
        RealizePalette(lpdis->hDC);
	    return;
    }

    SetBkMode(lpdis->hDC,TRANSPARENT);

    if (m_IconID == 0)
    {
	    HFONT hOldFont = (HFONT)SelectObject(lpdis->hDC,m_hFont);

	    TCHAR szCaption[MAX_PATH];
	    GetWindowText(m_hwnd,szCaption,sizeof(szCaption)/sizeof(TCHAR));
	    SIZE size;

	    GetTextExtentPoint32( lpdis->hDC, szCaption, _tcslen(szCaption), &size );

	    //center text
	    int x = (((midRect.right - midRect.left) - size.cx) / 2) + midRect.left;
	    int y = (((lpdis->rcItem.bottom - lpdis->rcItem.top) - size.cy) / 2) + lpdis->rcItem.top;

	    //simulate a press
	    if ((lpdis->itemState & ODS_SELECTED) || (m_fMenu))
	    {
	        x++;
	        y++;
	    }

	    ExtTextOut( lpdis->hDC, x, y, 0, NULL, szCaption, _tcslen(szCaption), NULL );

	    SelectObject(lpdis->hDC,hOldFont);
    } //end if no icon
    else
    {
	    //center icon
	    int x = (((midRect.right - midRect.left) - 32) / 2) + midRect.left;
	    int y = (((lpdis->rcItem.bottom - lpdis->rcItem.top) - 32) / 2) + lpdis->rcItem.top;
	    //simulate a press
	    if ((lpdis->itemState & ODS_SELECTED) || (m_fMenu))
	    {
	        x++;
	        y++;
	    }

	    HICON hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(m_IconID), IMAGE_ICON, 32, 32, LR_MONOCHROME);
	    DrawIcon(lpdis->hDC,x,y,hIcon);
        DestroyIcon(hIcon);
    }

    SelectPalette(lpdis->hDC,hpalOld,TRUE);
    RealizePalette(lpdis->hDC);
}

void CMButton::SetMenuingState(BOOL fMenuOn)
{
    if (fMenuOn)
    {
        m_fMenu = fMenuOn;
        m_fMenuingOff = FALSE;
    }
    else
    {
        m_fMenuingOff = TRUE;
        InvalidateRect(m_hwnd,NULL,FALSE);
        UpdateWindow(m_hwnd);
    }
}

void CMButton::SetToolTipID(int nID)
{
    m_nToolTipID = nID;

    //for buttons with icons, set the window text to equal the tooltip text.
    //this helps for accessibility aids, so they can read the button's function
    if (m_IconID != 0)
    {
        TCHAR szCaption[MAX_PATH];
        LoadString(m_hInst,nID,szCaption,sizeof(szCaption)/sizeof(TCHAR));
        SetWindowText(m_hwnd,szCaption);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\mbutton.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  MBUTTON.H
//
//	Defines CMButton class; helper functions
//
//	Copyright (c) Microsoft Corporation	1997
//    
//	12/14/97 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MBUTTON_HEADER_
#define _MBUTTON_HEADER_

#include "windows.h"

#ifdef __cplusplus
extern "C" {
#endif

//extended multimedia button styles
#define MBS_STANDARDLEFT    0x00000000L
#define MBS_TOGGLELEFT      0x00000001L
#define MBS_STANDARDRIGHT   0x00000002L
#define MBS_DROPRIGHT       0x00000004L
#define MBS_TOGGLERIGHT     0x00000008L
#define MBS_SYSTEMTYPE      0x00000010L
#define MBS_NOAUTODELETE    0x00000020L

#define STANDARD_PIXELS_PER_INCH 96

#define IS_DBCS_CHARSET( CharSet )									\
                   ( ((CharSet) == SHIFTJIS_CHARSET)    ? TRUE :       \
                     ((CharSet) == HANGEUL_CHARSET)     ? TRUE :       \
                     ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :       \
                     ((CharSet) == GB2312_CHARSET)      ? TRUE :       \
                     ((CharSet) == JOHAB_CHARSET)	? TRUE : FALSE \
                   )

//forward declaration of class
class CMButton;

//c-style helper functions

BOOL InitMButtons(HINSTANCE hInst, HWND hwnd);
void UninitMButtons();

CMButton* GetMButtonFromID(HWND hwndParent, int nID);
CMButton* GetMButtonFromHWND(HWND hwnd);

class CMButton
{
    public:
        friend CMButton* CreateMButton(TCHAR* szCaption,
                                       int nIconID,
                                       DWORD dwWindowStyle,
                                       DWORD dwMButtonStyle,
                                       int x,
                                       int y,
                                       int width,
                                       int height,
                                       HWND hwndParentOrSub,
                                       BOOL fSubExisting,
                                       int nID,
                                       int nToolTipID,
                                       HINSTANCE hInst);

        CMButton(); //constructor
        ~CMButton(); //destructor

        HWND GetHWND() {return m_hwnd;}
        int GetID() {return m_nID;}
        int GetToolTipID() {return m_nToolTipID;}
        void SetToolTipID(int nID);
        void SetText(TCHAR* szCaption);
        void SetIcon(int nIconID);
        void SetFont(HFONT hFont);
        void Draw(LPDRAWITEMSTRUCT lpdis);
        void PreDrawUpstate(int width, int height);
        BOOL MouseInButton() {return m_fMouseInButton;}
        BOOL GetMenuingState() {return m_fMenu;}
        void SetMenuingState(BOOL fMenuOn);

    private:
        //non-static privates
        HFONT m_hFont;
        int m_nID;
        int m_nToolTipID;
        HWND m_hwnd;
        BOOL m_fMouseInButton;
        DWORD m_dwStyle;
        WNDPROC m_fnOldButton;
        BOOL m_fRedraw;
        HINSTANCE m_hInst;
        int m_IconID;
        BOOL m_fMenu;
        BOOL m_fMenuingOff;
        int m_LastState;

        HANDLE m_hbmpUp;
        HANDLE m_hbmpDn;
        HANDLE m_hbmpHi;
        
        void DrawButtonBitmap(LPDRAWITEMSTRUCT lpdis, BOOL fDrawToScreen, RECT* pMidRect);

    private:
        //static stuff for all buttons
        static LRESULT CALLBACK ButtonProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
};

#ifdef __cplusplus
};
#endif

#endif  //_MBUTTON_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\shellico.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  SHELLICO.H
//
//      Shell tray icon handler
//
//      Copyright (c) Microsoft Corporation     1997, 1998
//    
//      3/15/98 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "mmfw.h"
#include "sink.h"

#define SHELLMESSAGE_CDICON (WM_USER+210)
#define IDM_TRACKLIST_SHELL_BASE        15000
#define PLAY_ICON 0
#define PAUSE_ICON 1
#define NODISC_ICON 2

BOOL CreateShellIcon(HINSTANCE hInst, HWND hwndOwner, PCOMPNODE pNode, TCHAR* szTip);
void DestroyShellIcon();
void ShellIconSetTooltip();
void ShellIconSetState(int nIconType);
LRESULT ShellIconHandeMessage(LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\mmenu.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MMENU.H: Declares custom menu interface for multimedia applet
//
// Copyright (c) Microsoft Corporation 1998
//    
// 1/28/98 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MMENUHEADER_
#define _MMENUHEADER_

#ifdef __cplusplus
extern "C" {
#endif

BOOL IsBiDiLocalizedSystem( LANGID *pLangID );

class CustomMenu;
class CCustomMenu;

class CustomMenu
{
    public:
        //append a string value
        virtual BOOL AppendMenu(int nMenuID, TCHAR* szMenu) = 0;
        //append a string from your resources
        virtual BOOL AppendMenu(int nMenuID, HINSTANCE hInst, int nStringID) = 0;
        //append a string and an icon from your resources
        virtual BOOL AppendMenu(int nMenuID, HINSTANCE hInst, int nIconID, int nStringID) = 0;
        //append another custom menu, with a resource string
        virtual BOOL AppendMenu(HINSTANCE hInst, int nStringID, CustomMenu* pMenu) = 0;

        virtual BOOL AppendSeparator() = 0;
        virtual BOOL TrackPopupMenu(UINT uFlags, int x, int y, HWND hwnd, CONST RECT* pRect) = 0;
        virtual BOOL SetMenuDefaultItem(UINT uItem, UINT fByPos) = 0;
        virtual void MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pMeasure) = 0;
        virtual void DrawItem(HWND hwnd, LPDRAWITEMSTRUCT pDraw) = 0;
        virtual LRESULT MenuChar(TCHAR tChar, UINT fuFlag, HMENU hMenu) = 0;
        virtual HMENU GetMenuHandle() = 0;
        virtual void Destroy() = 0;
};

class CCustomMenu : CustomMenu
{
    public:
        friend HRESULT AllocCustomMenu(CustomMenu** ppMenu);

        CCustomMenu();

        BOOL AppendMenu(int nMenuID, TCHAR* szMenu);
        BOOL AppendMenu(int nMenuID, HINSTANCE hInst, int nStringID);
        BOOL AppendMenu(int nMenuID, HINSTANCE hInst, int nIconID, int nStringID);
        BOOL AppendMenu(HINSTANCE hInst, int nStringID, CustomMenu* pMenu);
        BOOL AppendSeparator();
        BOOL TrackPopupMenu(UINT uFlags, int x, int y, HWND hwnd, CONST RECT* pRect);
        BOOL SetMenuDefaultItem(UINT uItem, UINT fByPos);
        void MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pMeasure);
        void DrawItem(HWND hwnd, LPDRAWITEMSTRUCT pDraw);
        LRESULT MenuChar(TCHAR tChar, UINT fuFlag, HMENU hMenu);
        HMENU GetMenuHandle() {return m_hMenu;}
        void Destroy();

    protected:
        ~CCustomMenu();
        BOOL IsItemFirst(int nMenuID);
        BOOL IsItemLast(int nMenuID);

    private:
        HMENU m_hMenu;
        HFONT m_hFont;
        HFONT m_hBoldFont;
        BOOL  m_bRTLMenu;
};

#ifdef __cplusplus
};
#endif //c++

#endif //_MMENUHEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxecd\main\main.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  MAIN.CPP
//
//      Main window of multimedia framework
//
//      Copyright (c) Microsoft Corporation     1997
//    
//      12/14/97 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <TCHAR.H>
#include "resource.h"
#include "objbase.h"
#include "initguid.h"
#include "sink.h"
#include "dib.h"
#include "resource.h"
#include "mbutton.h"  
#include "knob.h"
#include "winuser.h"
#include "img.h"
#include "frame.h"
#include <htmlhelp.h>
#include "..\cdopt\cdopt.h"
#include "..\cdnet\cdnet.h"
#include "mmenu.h"
#include <stdio.h>
#include "shellico.h"
#include <shellapi.h>
#include "..\cdplay\playres.h"
#include "wininet.h"

//Support for new WM_DEVICECHANGE behaviour in NT5
/////////////////////////////////////////////////
#include <objbase.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <dbt.h>
#include <devguid.h>
#include <mmddkp.h>
#include <ks.h>
#include <ksmedia.h>

HDEVNOTIFY DeviceEventContext = NULL;

void Volume_DeviceChange_Init(HWND hWnd, DWORD dwMixerID);
void Volume_DeviceChange_Cleanup();
void Volume_DeviceChange(HWND hDlg, WPARAM wParam, LPARAM lParam);

//////////////////////////////////////////////////////
//////////////////////////////////////////////////////


// Next 2 lines added to add multimon support
#define COMPILE_MULTIMON_STUBS
#include "multimon.h"

////////////////////////////////////////////////////////////////////////////////////////////
// #defines for main ui and call-downs to cd player unit

#define IDC_LEDWINDOW                   IDC_LED
#define WM_LED_INFO_PAINT               (WM_USER+2000) //wparam = bool (allow self-draw), lparam = vol info
#define WM_LED_MUTE                     (WM_USER+2001) //wparam = unused, lparam = bool (mute)
#define WM_LED_DOWNLOAD                 (WM_USER+2002) //wparam = unused, lparam = download flag

//command ids from cdplayer
#define ID_CDUPDATE                     IDM_NET_CD

//battery power limit, stated as a percentage
#define BATTERY_PERCENTAGE_LIMIT        10

//helpers for detecting where the mouse is hitting
#define TITLEBAR_HEIGHT                 15
#define TITLEBAR_YOFFSET_LARGE          7
#define TITLEBAR_YOFFSET_SMALL          4
#define SYSMENU_XOFFSET                 7
#define SYSMENU_WIDTH                   12

//volume bar timer stuff
#define VOLUME_PERSIST_TIMER_RATE       2000
#define VOLUME_PERSIST_TIMER_EVENT      1000
#define SYSTIMERID                      1001

//don't remove the parens on these, or My Dear Aunt Sally will getcha
#define IDM_HOMEMENU_BASE               (LAST_SEARCH_MENU_ID + 1)
#define IDM_NETMENU_BASE                (LAST_SEARCH_MENU_ID + 100)
#define IDM_TRACKLIST_BASE              10000
#define IDM_DISCLIST_BASE               20000

#define TYPICAL_DISPLAY_AREA            48  //this value is the offset for large fonts
#define EDGE_CURVE_WIDTH                24
#define EDGE_CURVE_HEIGHT               26

#define VENDORLOGO_WIDTH                44
#define VENDORLOGO_HEIGHT               22
#define LOGO_Y_OFFSET                   10

//if button is re-hit within the time limit, don't allow it to trigger
#define MENU_TIMER_RATE 400

//ie autosearch url
#define REG_KEY_SEARCHURL TEXT("Software\\Microsoft\\Internet Explorer\\SearchUrl")
#define REG_KEY_SHELLSETTINGS REG_KEY_NEW_FRAMEWORK TEXT("\\Settings")
#define REG_KEY_SHELLENABLE TEXT("Tray")
#define PLAYCOMMAND1 TEXT("/play")
#define PLAYCOMMAND2 TEXT("-play")
#define TRAYCOMMAND1 TEXT("/tray")
#define TRAYCOMMAND2 TEXT("-tray")

//////////////////////////////////////////////////////////////////////////////////////
// Gradient stuff

#ifndef SPI_GETGRADIENTCAPTIONS
//from nt50 version of winuser.h
#define SPI_GETGRADIENTCAPTIONS             0x1008
#define COLOR_GRADIENTACTIVECAPTION     27
#define COLOR_GRADIENTINACTIVECAPTION   28
#endif

typedef BOOL (WINAPI *GRADIENTPROC)(HDC,PTRIVERTEX,ULONG,PUSHORT,ULONG,ULONG);


////////////////////////////////////////////////////////////////////////////////////////////
// Main functions in this file, forward-declared
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL LoadComponents(void);
void AddComponent(IMMComponent*);
void CleanUp(void);
void InitComponents(HWND);
BOOL CreateToolTips(HWND);

////////////////////////////////////////////////////////////////////////////////////////////
// Globals to this file

//Component information ... we only have one component now ... 
//this is in here to handle eventual move to multi-component design
PCOMPNODE pCompList = NULL;             //head of component list
PCOMPNODE pCompListTail = NULL;         //tail of component list
PCOMPNODE pNodeCurrent = NULL;          //currently selected component
int nNumComps = 0;                      //number of components
HWND hwndCurrentComp = NULL;            //window handle of current component

HINSTANCE hInst = NULL;                 //global instance of exe
int g_nColorMode = COLOR_VERYHI;        //global containing color mode (hi contract, 16 color, etc)

HWND hwndMain = NULL;                   //main window handle
HWND g_hwndTT = NULL;                   //tooltips
HHOOK g_hhk = NULL;                     //tooltips message hook
TCHAR g_tooltext[MAX_PATH];             //tooltip text holder
HANDLE hbmpMain = NULL;                 //main window bitmap, normal size
HANDLE hbmpMainRestore = NULL;          //main window bitmap, restored size
HANDLE hbmpMainSmall = NULL;            //main window bitmap, small size
HANDLE hbmpMainNoBar = NULL;            //main window bitmap, normal with no title bar
BITMAP bmMain;                          //bitmap metrics for normal size
BITMAP bmMainRestore;                   //bitmap metrics for restored size
BITMAP bmMainSmall;                     //bitmap metrics for small size
BITMAP bmMainNoBar;                     //bitmap metrics for no bar size
HPALETTE hpalMain = NULL;               //Palette of application
BOOL fPlaying = FALSE;                  //Play state of CD for play/pause
BOOL fIntro   = FALSE;                  //Intro mode state
BOOL fShellMode = FALSE;                //are we in shell icon mode?
int nCDMode = IDM_MODE_NORMAL;          //Current mode of CD (starts on normal mode)
int nDispAreaOffset = 0;                //Display area offset for large font mode
CustomMenu* g_pMenu = NULL;             //Pointer to current custom menu
UINT nLastMenu = 0;                      //ID of last button to display a menu
BOOL fBlockMenu = 0;                    //Flag to block menu re-entry
BOOL fOptionsDlgUp = FALSE;             //is options dialog active?
LPCDTITLE pSingleTitle = NULL;            //Disc ID for a direct download from tree control
LPCDOPT g_pOptions = NULL;              //for download callbacks when dialog is up
LPCDDATA g_pData = NULL;                //for callbacks to cd when dialog is up
TCHAR szAppName[MAX_PATH/2];            //IDS_APPNAME "Deluxe CD Player"
DWORD dwLastMixID = (DWORD)-1;          //Last mixer ID
HMIXEROBJ hmix = NULL;                  //current open mixer handle
TCHAR szLineName[MIXER_LONG_NAME_CHARS];//current volume line name
MIXERCONTROLDETAILS mixerlinedetails;   //current volume details
MIXERCONTROLDETAILS mutelinedetails;    //current mute details
DWORD mixervalue[2];                    //current volume level
LONG lCachedBalance = 0;                //last balance level
BOOL fmutevalue;                        //current mute value
HANDLE hMutex = NULL;                   //hMutex to prevent multiple instances of EXE
int  g_nViewMode = VIEW_MODE_NORMAL;    //view mode setting (default to normal)
WORD wDefButtonID = IDB_OPTIONS;         //default button
HCURSOR hCursorMute = NULL;             //mute button cursor
HMODULE hmImage = NULL;                 //module handle of dll with gradient function
GRADIENTPROC fnGradient = NULL;         //gradient function
UINT g_uTaskbarRestart = 0;             //registered message for taskbar re-creation
UINT giVolDevChange = 0;                //registered message for mmsystem device change

#ifdef UNICODE
#define CANONFUNCTION "InternetCanonicalizeUrlW"
#else
#define CANONFUNCTION "InternetCanonicalizeUrlA"
#endif

////////////////////////////////////////////////////////////////////////////////////////////
// Structures and defines for custom button controls
#define NUM_BUTTONS 16
typedef struct BUTTONINFO
{
    int     id;             //id of control
    POINT   uixy;           //x, y location on screen
    POINT   uixy2;          //x, y location when restored or small
    int     width;          //width of control in bitmap and on screen
    int     height;         //height of control in bitmap and on screen
    int     width2;         //width of control on screen when restored
    int     nIconID;        //id of icon, if any
    int     nToolTipID;     //id of tooltip string
    BOOL    fBlockTab;      //true = don't tab stop here
    DWORD   dwStyle;        //style for toolkit, see mbutton.h
} BUTTONINFO, *LPBUTTONINFO;
BUTTONINFO biButtons[NUM_BUTTONS];

////////////////////////////////////////////////////////////////////////////////////////////
// * GetSettings
// Reads the x and y positions of app for startup
// Also gets the view mode
////////////////////////////////////////////////////////////////////////////////////////////
void GetSettings(int& x, int& y)
{
    x = CW_USEDEFAULT;
    y = CW_USEDEFAULT;
    g_nViewMode = VIEW_MODE_NORMAL;

    LPCDOPT pOpt = GetCDOpt();

    if( pOpt )
    {
        LPCDOPTIONS pOptions = pOpt->GetCDOpts();
        LPCDOPTDATA pOptionData = pOptions->pCDData;

        x = pOptionData->dwWindowX;
        y = pOptionData->dwWindowY;
        g_nViewMode = pOptionData->dwViewMode;
        nCDMode = pOptionData->dwPlayMode;
        if (nCDMode < IDM_MODE_NORMAL)
        {
            nCDMode = IDM_MODE_NORMAL;
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetSettings
// Sets X, Y and view mode of app on shutdown
////////////////////////////////////////////////////////////////////////////////////////////
void SetSettings(int x, int y)
{
    LPCDOPT pOpt = GetCDOpt();

    if(pOpt)
    {
        LPCDOPTIONS pOptions = pOpt->GetCDOpts();
        LPCDOPTDATA pOptionData = pOptions->pCDData;

        pOptionData->dwWindowX = x;
        pOptionData->dwWindowY = y;
        pOptionData->dwViewMode = g_nViewMode;
        pOptionData->dwPlayMode = nCDMode;

        pOpt->UpdateRegistry();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetXOffset
// Returns 0 normally, or size of a single border if captions are turned on
////////////////////////////////////////////////////////////////////////////////////////////
int GetXOffset()
{
    #ifndef MMFW_USE_CAPTION
    return 0;
    #else
    return GetSystemMetrics(SM_CXFIXEDFRAME);
    #endif
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetYOffset
// Returns 0 normally, or size of a single border if captions are turned on
////////////////////////////////////////////////////////////////////////////////////////////
int GetYOffset()
{
    #ifndef MMFW_USE_CAPTION
    return 0;
    #else
    return GetSystemMetrics(SM_CYFIXEDFRAME);
    #endif
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetYOffsetCaption
// Returns 0 normally, or size of a caption if captions are turned on
////////////////////////////////////////////////////////////////////////////////////////////
int GetYOffsetCaption()
{
    #ifndef MMFW_USE_CAPTION
    return 0;
    #else
    return GetSystemMetrics(SM_CYCAPTION);
    #endif
}

////////////////////////////////////////////////////////////////////////////////////////////
// * DetermineColorMode
// Sets the g_nColorMode variable for use in creating the bumps for the app
////////////////////////////////////////////////////////////////////////////////////////////
void DetermineColorMode()
{
    g_nColorMode = COLOR_VERYHI;

    HDC hdcScreen = GetDC(NULL);
    UINT uBPP = GetDeviceCaps(hdcScreen, PLANES) * GetDeviceCaps(hdcScreen, BITSPIXEL);
    ReleaseDC(NULL, hdcScreen);

    switch (uBPP)
    {
        case 8 :
        {
            g_nColorMode = COLOR_256;
        }
        break;

        case 4 : 
        {
            g_nColorMode = COLOR_16;
        }
        break;

        case 2 :
        {
            g_nColorMode = COLOR_HICONTRAST; 
        }
        break;
    }

    //check directly for accessibility mode
    HIGHCONTRAST hi_con;
    ZeroMemory(&hi_con,sizeof(hi_con));
    hi_con.cbSize = sizeof(hi_con);

    SystemParametersInfo(SPI_GETHIGHCONTRAST,sizeof(hi_con),&hi_con,0);

    if (hi_con.dwFlags &  HCF_HIGHCONTRASTON)
    {
        g_nColorMode = COLOR_HICONTRAST;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetPalette
// Sets the palette for the app, generated from all bitmaps in the application and DLLs
////////////////////////////////////////////////////////////////////////////////////////////
HPALETTE SetPalette()
{
    #define NUMPALCOLORS 94

BYTE byVals[NUMPALCOLORS][3] = {
	      6,   6,   6,
	     18,  19,  45,
	     25,  40,   1,
	     17,  46,  46,
	     49,   7,   7,
	     45,  52,   3,
	     49,  49,  49,
	     24,  24,  91,
	      0,  90,   8,
	      1, 108,   5,
	     55,  67,   2,
	     33,  76,  76,
	     94,  29,  24,
	    102,  18, 102,
	     93,  94,  23,
	     78,  78,  78,
	     84,  84, 108,
	     78, 111, 111,
	    109,  80,  80,
	    108, 107,  79,
	    120, 120, 120,
	     15,   9, 157,
	     17,   8, 246,
	     55,  93, 175,
	     20,  91, 231,
	     83,  39, 167,
	     92,  16, 223,
	     96,  94, 150,
	     88,  87, 217,
	      0, 157,  15,
	      0, 153,  51,
	      0, 190,  18,
	     10, 155, 120,
	      6, 252,  17,
	      9, 236,  92,
	    127, 135,  35,
	     83, 142, 117,
	     92, 241,  21,
	     87, 223,  81,
	     14, 171, 171,
	     39, 147, 223,
	     18, 252, 157,
	     15, 244, 236,
	     87, 137, 136,
	     80, 184, 184,
	    112, 141, 141,
	    106, 170, 153,
	    119, 171, 168,
	     87, 155, 213,
	    101, 218, 170,
	     90, 233, 226,
	    154,  19,  24,
	    155,  26, 109,
	    138, 116,   8,
	    170,  98, 101,
	    243,  18,   6,
	    245,  10,  96,
	    233,  89,  17,
	    229, 103, 101,
	    154,  39, 161,
	    163,  26, 249,
	    158,  77, 159,
	    149,  94, 254,
	    234,  20, 160,
	    234,  29, 242,
	    233,  76, 163,
	    218,  81, 244,
	    163, 151,  10,
	    157, 156, 102,
	    164, 214,  45,
	    165, 242,  87,
	    223, 174,  17,
	    228, 160,  77,
	    242, 232,  15,
	    233, 218, 102,
	    138, 138, 138,
	    142, 141, 176,
	    148, 180, 180,
	    174, 141, 140,
	    169, 130, 168,
	    181, 179, 136,
	    176, 176, 177,
	    172, 170, 220,
	    133, 207, 177,
	    171, 236, 233,
	    231, 169, 157,
	    252, 170, 253,
	    247, 243, 168,
	    202, 204, 204,
	    201, 201, 243,
	    208, 238, 238,
	    246, 212, 212,
	    248, 244, 198,
	    250, 250, 250
    };

    struct
    {
	    LOGPALETTE lp;
	    PALETTEENTRY ape[NUMPALCOLORS-1];
    } pal;

    LOGPALETTE* pLP = (LOGPALETTE*)&pal;
    pLP->palVersion = 0x300;
    pLP->palNumEntries = NUMPALCOLORS;

    for (int i = 0; i < pLP->palNumEntries; i++)
    {
	    pLP->palPalEntry[i].peRed = byVals[i][0];
	    pLP->palPalEntry[i].peGreen = byVals[i][1];
	    pLP->palPalEntry[i].peBlue = byVals[i][2];
	    pLP->palPalEntry[i].peFlags = 0;
    }

    return (CreatePalette(pLP));
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetCurrentCDDrive
// returns the drive number of the cd that is currently selected in the cdplayer ui
////////////////////////////////////////////////////////////////////////////////////////////
int GetCurrentCDDrive()
{
	IMMComponentAutomation* pAuto = NULL;
	HRESULT hr = pNodeCurrent->pComp->QueryInterface(IID_IMMComponentAutomation,(void**)&pAuto);
	if ((SUCCEEDED(hr)) && (pAuto != NULL))
	{
        MMMEDIAID mmMedia;
        mmMedia.nDrive = -1;
        pAuto->OnAction(MMACTION_GETMEDIAID,&mmMedia);
        pAuto->Release();
        return (mmMedia.nDrive);
    }

    return -1;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * InitCDVol
// Sets up the mixer structures for the current cd drive
////////////////////////////////////////////////////////////////////////////////////////////
BOOL InitCDVol(HWND hwndCallback, LPCDOPTIONS pCDOpts)
{
    //figure out which drive we're on
    int nDrive = GetCurrentCDDrive();

    //return if the drive is bogus
    if (nDrive < 0)
    {
        return FALSE;
    }

    //get the cdunit info from the options
    CDUNIT* pCDUnit = pCDOpts->pCDUnitList;
    
    //scan the list to find the one we want
    for (int index = 0; index < nDrive; index++)
    {
        pCDUnit = pCDUnit->pNext;
    }
    
    //check to see if we already have an open mixer
    if (hmix!=NULL)
    {
        //we've been here before ... may not need to be here now,
        //if both the mixer id and the control id are the same
        if ((dwLastMixID == pCDUnit->dwMixID) &&
            (mixerlinedetails.dwControlID == pCDUnit->dwVolID))
        {
            return FALSE;
        }

        //a change is coming, go ahead and close this mixer
        mixerClose((HMIXER)hmix);
    }

    //remember our last mixer id
    dwLastMixID = pCDUnit->dwMixID;

    //open the mixer
    mixerOpen((HMIXER*)(&hmix),pCDUnit->dwMixID,(DWORD_PTR)hwndCallback,0,CALLBACK_WINDOW|MIXER_OBJECTF_MIXER);
	
	Volume_DeviceChange_Init(hwndCallback, pCDUnit->dwMixID);
	
	MIXERLINE           mlDst;
	MMRESULT            mmr;
	int					newDest;
    
    ZeroMemory(&mlDst, sizeof(mlDst));
    
    mlDst.cbStruct      = sizeof(mlDst);
    mlDst.dwDestination = pCDUnit->dwDestID;
    
    mmr = mixerGetLineInfo((HMIXEROBJ)hmix
                           , &mlDst
                           , MIXER_GETLINEINFOF_DESTINATION);

    //save the details of the volume line
    mixerlinedetails.cbStruct = sizeof(mixerlinedetails);
    mixerlinedetails.dwControlID = pCDUnit->dwVolID;
    mixerlinedetails.cChannels = mlDst.cChannels;
    mixerlinedetails.hwndOwner = 0;
    mixerlinedetails.cMultipleItems = 0;
    mixerlinedetails.cbDetails = sizeof(DWORD); //seems like it would be sizeof(mixervalue),
                                                //but actually, it is the size of a single value
                                                //and is multiplied by channel in the driver.
    mixerlinedetails.paDetails = &mixervalue[0];
                    
    //save the details of the mute line
    mutelinedetails.cbStruct = sizeof(mutelinedetails);
    mutelinedetails.dwControlID = pCDUnit->dwMuteID;
    mutelinedetails.cChannels = 1;
    mutelinedetails.hwndOwner = 0;
    mutelinedetails.cMultipleItems = 0;
    mutelinedetails.cbDetails = sizeof(fmutevalue);
    mutelinedetails.paDetails = &fmutevalue;

    //save the name of the volume line
    _tcscpy(szLineName,pCDUnit->szVolName);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetVolume
////////////////////////////////////////////////////////////////////////////////////////////
DWORD GetVolume()
{
    //get the value of this mixer control line
    ZeroMemory(mixervalue,sizeof(DWORD)*2);
    mixerGetControlDetails(hmix,&mixerlinedetails,MIXER_GETCONTROLDETAILSF_VALUE);
    return ((mixervalue[0] > mixervalue[1]) ? mixervalue[0] : mixervalue[1]);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetVolume
////////////////////////////////////////////////////////////////////////////////////////////
void SetVolume(DWORD dwVol)
{
    LONG        lBalance = 0;

    //if this is a stereo device, we need to check the balance
    if (mixerlinedetails.cChannels > 1)
    {
        ZeroMemory(mixervalue,sizeof(DWORD)*2);
        mixerGetControlDetails(hmix,&mixerlinedetails,MIXER_GETCONTROLDETAILSF_VALUE);

        LONG lDiv =  (LONG)(max(mixervalue[0], mixervalue[1]) - 0);

        //
        // if we're pegged, don't try to calculate the balance.
        //
        if (mixervalue[0] == 0 && mixervalue[1] == 0)
            lBalance = lCachedBalance;
        else if (mixervalue[0] == 0)
            lBalance = 32;
        else if (mixervalue[1] == 0) 
            lBalance = -32;
        else if (lDiv > 0)
        {
            lBalance = (32 * ((LONG)mixervalue[1]-(LONG)mixervalue[0]))
                       / lDiv;
            //
            // we always lose precision doing this.
            //
            if (lBalance > 0) lBalance++;
            if (lBalance < 0) lBalance--;

            //if we lost precision above, we can get it back by checking
            //the previous value of our balance.  We're usually only off by
            //one if this is the result of a rounding error.  Otherwise,
            //we probably have a different balance because the user set it.
            if (((lCachedBalance - lBalance) == 1) ||
                ((lCachedBalance - lBalance) == -1))
            {
                lBalance = lCachedBalance;
            }
        
        }
        else
            lBalance = 0;
    }

    //save this balance setting so we can use it if we're pegged later
    lCachedBalance = lBalance;

    //
    // Recalc channels based on Balance vs. Volume
    //
    mixervalue[0] = dwVol;
    mixervalue[1] = dwVol;
                   
    if (lBalance > 0)
        mixervalue[0] -= (lBalance * (LONG)(mixervalue[1]-0))
                        / 32;
    else if (lBalance < 0)
        mixervalue[1] -= (-lBalance * (LONG)(mixervalue[0]-0))
                        / 32;

    mixerSetControlDetails(hmix,&mixerlinedetails,MIXER_SETCONTROLDETAILSF_VALUE);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * GetMute
////////////////////////////////////////////////////////////////////////////////////////////
BOOL GetMute()
{
    if (mutelinedetails.dwControlID != DWORD(-1))
    {
        mixerGetControlDetails(hmix,&mutelinedetails,MIXER_GETCONTROLDETAILSF_VALUE);
    }
    else
    {
        //mixer line doesn't exist, assume not muted
        fmutevalue = FALSE;
    }

    return (fmutevalue);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetMute
// Implemented as a toggle from current state
////////////////////////////////////////////////////////////////////////////////////////////
void SetMute()
{
    if (mutelinedetails.dwControlID != DWORD(-1))
    {
        if (GetMute())
        {
            //muted, so unmute
            fmutevalue = FALSE;
            mixerSetControlDetails(hmix,&mutelinedetails,MIXER_SETCONTROLDETAILSF_VALUE);
        }
        else
        {
            //not muted, so mute
            fmutevalue = TRUE;
            MMRESULT mmr = mixerSetControlDetails(hmix,&mutelinedetails,MIXER_SETCONTROLDETAILSF_VALUE);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CanStartShell()
// Checks to see if we can launch if wanting to do so in shell mode
// Returns FALSE only if asking for "tray mode" and if reg setting is FALSE (or not present)
////////////////////////////////////////////////////////////////////////////////////////////
BOOL CanStartShell()
{
    BOOL retval = TRUE; //default to allowing launch
    fShellMode = FALSE;

    //if asking for permission to launch try, see if the registry setting is there
    HKEY hKeySettings;
	long lResult = ::RegOpenKeyEx( HKEY_CURRENT_USER,
							  REG_KEY_SHELLSETTINGS,
							  0, KEY_READ, &hKeySettings );

    if (lResult == ERROR_SUCCESS)
    {
        DWORD fEnable = FALSE;
        DWORD dwType = REG_DWORD;
        DWORD dwCbData = sizeof(fEnable);
        lResult  = ::RegQueryValueEx( hKeySettings, REG_KEY_SHELLENABLE, NULL,
						          &dwType, (LPBYTE)&fEnable, &dwCbData );

        if (fEnable)
        {
            fShellMode = TRUE;
        }

        RegCloseKey(hKeySettings);

        //check for the query on the command line
        TCHAR szCommand[MAX_PATH];
    
        _tcscpy(szCommand,GetCommandLine());
        _tcslwr(szCommand);
        if ((_tcsstr(szCommand,TRAYCOMMAND1) != NULL)
            ||
            (_tcsstr(szCommand,TRAYCOMMAND2) != NULL))
        {
            //user wants to check try status ... base on fenable
            retval = (BOOL)fEnable;
        }
    } //end if regkey

    return (retval);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * ShellOnly()
// Returns TRUE if we should not make the main UI visible.
////////////////////////////////////////////////////////////////////////////////////////////
BOOL ShellOnly()
{
    BOOL retval = FALSE;

    if (fShellMode)
    {
        //check for the query on the command line
        TCHAR szCommand[MAX_PATH];
    
        _tcscpy(szCommand,GetCommandLine());
        _tcslwr(szCommand);
        if ((_tcsstr(szCommand,TRAYCOMMAND1) != NULL)
            ||
            (_tcsstr(szCommand,TRAYCOMMAND2) != NULL))
        {
            retval = TRUE;
        }
    }

    return (retval);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * IsOnlyInstance 
// Check to see if this is the only instance, based on the webcd mutex
////////////////////////////////////////////////////////////////////////////////////////////
BOOL IsOnlyInstance()
{
    hMutex = CreateMutex(NULL,TRUE,WEBCD_MUTEX);
    if (GetLastError()==ERROR_ALREADY_EXISTS)
    {
        if (hMutex!=NULL)
        {
            ReleaseMutex(hMutex);
            CloseHandle(hMutex);
            hMutex = NULL;
        }

        //send the command line to the app that is already running
        HWND hwndFind = FindWindow(FRAMEWORK_CLASS, NULL);

        if (hwndFind)
        {
            //we only want to do this if NOT "autoplayed" ... that is, if /play is on the
            //command line, don't refocus us ... see bug 1244
            //(the old cdplayer implements it this way, too!)
            TCHAR szCommand[MAX_PATH];
            
            _tcscpy(szCommand,GetCommandLine());
            _tcslwr(szCommand);
            if ((_tcsstr(szCommand,PLAYCOMMAND1) == NULL)
                &&
                (_tcsstr(szCommand,PLAYCOMMAND2) == NULL))
            {
                //get the most recent "child" window
                hwndFind = GetLastActivePopup(hwndFind);

                //bring the window up if it is iconic
                if (IsIconic(hwndFind))
                {
                    ShowWindow(hwndFind,SW_RESTORE);
                }

                //display the window
                ShowWindow(hwndFind,SW_SHOW); //this "wakes up" if in shell mode in other inst.
		        BringWindowToTop(hwndFind);
		        SetForegroundWindow(hwndFind);
            }

            //forward the command line found to the second instance,
            //only if it is NOT an "autoplay" message -- we'll  scan that instead
            TCHAR tempCmdLine[MAX_PATH];
            _tcscpy(tempCmdLine,GetCommandLine());
            if (_tcslen(tempCmdLine) > 0)
            {
                if (tempCmdLine[_tcslen(tempCmdLine)-1] != TEXT('\\'))
                {
                    COPYDATASTRUCT  cpds;
	                cpds.dwData = 0L;
	                cpds.cbData = (_tcslen(GetCommandLine()) + 1) * sizeof(TCHAR);
	                cpds.lpData = LocalAlloc(LPTR,cpds.cbData);
	                if (cpds.lpData == NULL) {
	                    // Error - not enough memory to continue
	                    return (FALSE);
	                }

	                _tcscpy((LPTSTR)cpds.lpData, GetCommandLine());

	                SendMessage(hwndFind, WM_COPYDATA, 0, (LPARAM)(LPVOID)&cpds);
	                LocalFree((HLOCAL)cpds.lpData);
                } //end if not autoplay command line
            } //end if non-0 command line

        } //end if found other window

        return (FALSE);
    }

    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CalculateDispAreaOffset 
// Figures out how big the display area should be if we're not in standard font mode
////////////////////////////////////////////////////////////////////////////////////////////
void CalculateDispAreaOffset(IMMComponent* pComp)
{
    if (!pComp)
    {
        return;
    }
    
    MMCOMPDATA mmComp;
    mmComp.dwSize = sizeof(mmComp);
    pComp->GetInfo(&mmComp);

    //mmComp.rect (height) contains the min height of the display area on this monitor
    //for the largest view ... other views seem to be OK with different font settings

    //calculate how big the view must be compared to its normal min size
     nDispAreaOffset = (mmComp.rect.bottom - mmComp.rect.top) - TYPICAL_DISPLAY_AREA;

     //don't let the display area shrink, only grow
     if (nDispAreaOffset < 0)
     {
        nDispAreaOffset = 0;
     }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * BuildFrameworkBitmaps 
// Creates the bitmaps for normal, restored, and small sizes
////////////////////////////////////////////////////////////////////////////////////////////
BOOL BuildFrameworkBitmaps()
{
    POINT ptSys = {SYSMENU_XOFFSET,TITLEBAR_YOFFSET_LARGE};
    RECT rectMain = {0,0,480,150};
    RECT rectView = {10,25,472,98};
    RECT rectSeps[2] = {93,97,95,146,302,97,304,146};
    
    rectView.bottom += nDispAreaOffset;
    rectMain.bottom += nDispAreaOffset;

    for (UINT i = 0; i < sizeof(rectSeps) / sizeof(RECT); i++)
    {
        rectSeps[i].top += nDispAreaOffset;
        rectSeps[i].bottom += nDispAreaOffset;
    }

    HDC hdcMain = GetDC(hwndMain);
    hbmpMain = BuildFrameBitmap(hdcMain,&rectMain,&rectView,VIEW_MODE_NORMAL,&ptSys,rectSeps,2,&bmMain);

    //"no title bar" mode
    ptSys.x = SYSMENU_XOFFSET;
    ptSys.y = TITLEBAR_YOFFSET_LARGE;
    SetRect(&rectMain,0,0,480,134);
    SetRect(&rectView,10,9,472,82);
    SetRect(&rectSeps[0],93,81,95,130);
    SetRect(&rectSeps[1],302,81,304,130);
    hbmpMainNoBar = BuildFrameBitmap(hdcMain,&rectMain,&rectView,VIEW_MODE_NOBAR,&ptSys,rectSeps,2,&bmMainNoBar);

    //"restored" mode
    ptSys.x = SYSMENU_XOFFSET;
    ptSys.y = TITLEBAR_YOFFSET_SMALL;
    SetRect(&rectMain,0,0,393,50);
    SetRect(&rectView,301,21,386,43);
    SetRect(&rectSeps[0],92,25,101,38);
    SetRect(&rectSeps[1],211,25,220,38);
    hbmpMainRestore = BuildFrameBitmap(hdcMain,&rectMain,&rectView,VIEW_MODE_RESTORE,&ptSys,rectSeps,2,&bmMainRestore);

    //"very small" mode, no title bar
    SetRect(&rectMain,0,0,393,38);
    SetRect(&rectView,301,9,386,30);
    SetRect(&rectSeps[0],92,13,101,26);
    SetRect(&rectSeps[1],211,13,220,26);
    hbmpMainSmall = BuildFrameBitmap(hdcMain,&rectMain,&rectView,VIEW_MODE_SMALL,&ptSys,rectSeps,2,&bmMainSmall);

    ReleaseDC(hwndMain,hdcMain);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetCurvedEdges
// Changes clipping region of an HWND to have curved corners
////////////////////////////////////////////////////////////////////////////////////////////
void SetCurvedEdges(HWND hwnd)
{
    RECT rect;
    GetWindowRect(hwnd,&rect);

    //set the rect to "client" coordinates
    rect.bottom = rect.bottom - rect.top;
    rect.right = rect.right - rect.left;
    rect.top = 0;
    rect.left = 0;
    
    HRGN region = CreateRoundRectRgn(GetXOffset(),
                                     GetYOffsetCaption() + GetYOffset(),
                                     (rect.right - GetXOffset())+1,
                                     (rect.bottom - GetYOffset())+1,
                                     EDGE_CURVE_WIDTH,
                                     EDGE_CURVE_HEIGHT);

    SetWindowRgn(hwnd,region,TRUE);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetNoBarMode(HWND hwnd)
// Changes the view mode to have no title bar
////////////////////////////////////////////////////////////////////////////////////////////
void SetNoBarMode(HWND hwnd)
{
    g_nViewMode = VIEW_MODE_NOBAR;

    HDWP hdwp = BeginDeferWindowPos(NUM_BUTTONS+3);

    //move/size/hide buttons
    for (int i = 0; i < NUM_BUTTONS; i++)
    {
		hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,biButtons[i].id),hwnd,
			 biButtons[i].uixy.x,
			 biButtons[i].uixy.y - (bmMain.bmHeight - bmMainNoBar.bmHeight),
			 biButtons[i].width,
			 biButtons[i].height,
			 SWP_NOACTIVATE|SWP_NOZORDER);

        if (biButtons[i].dwStyle == MBS_SYSTEMTYPE)
        {
            ShowWindow(GetDlgItem(hwnd,biButtons[i].id),SW_HIDE); 
        }
    }

    //move volume and mute
	hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,IDB_VOLUME),hwnd,
		 403,
		 (93+nDispAreaOffset) - (bmMain.bmHeight - bmMainNoBar.bmHeight),
		 45,
		 45,
		 SWP_NOACTIVATE|SWP_NOZORDER);

	hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,IDB_MUTE),hwnd,
		 450,
		 (122+nDispAreaOffset) - (bmMain.bmHeight - bmMainNoBar.bmHeight),
		 13,
		 13,
		 SWP_NOACTIVATE|SWP_NOZORDER);

    //move display screen
    hdwp = DeferWindowPos(hdwp,hwndCurrentComp,hwnd,24,32-(bmMain.bmHeight - bmMainNoBar.bmHeight),431,56+nDispAreaOffset,SWP_NOACTIVATE|SWP_NOZORDER);
    InvalidateRect(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),NULL,TRUE);

    //size main window
    int sx = GetXOffset()*2;
    int sy = (GetYOffset()*2) + GetYOffsetCaption();
    SetWindowPos(hwnd,NULL,0,0,
	     bmMainNoBar.bmWidth+sx,
	     bmMainNoBar.bmHeight+sy,
	     SWP_NOMOVE|SWP_NOZORDER);

    SetCurvedEdges(hwnd);

    InvalidateRect(hwnd,NULL,TRUE);
    EndDeferWindowPos(hdwp);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetRestoredMode
// Changes the view mode to restored
////////////////////////////////////////////////////////////////////////////////////////////
void SetRestoredMode(HWND hwnd)
{
    if (g_nViewMode == VIEW_MODE_NORMAL)
    {
        //pre-blit the new button sizes
        CMButton* pButton;
        pButton = GetMButtonFromID(hwnd,IDB_PLAY);
        pButton->PreDrawUpstate(biButtons[2].width2,biButtons[2].height);
        pButton = GetMButtonFromID(hwnd,IDB_STOP);
        pButton->PreDrawUpstate(biButtons[3].width2,biButtons[3].height);
        pButton = GetMButtonFromID(hwnd,IDB_EJECT);
        pButton->PreDrawUpstate(biButtons[4].width2,biButtons[4].height);
        pButton = GetMButtonFromID(hwnd,IDB_TRACK);
        pButton->PreDrawUpstate(biButtons[10].width2,biButtons[10].height);
    }

    g_nViewMode = VIEW_MODE_RESTORE;

    HDWP hdwp = BeginDeferWindowPos(NUM_BUTTONS+2);

    //move/size/hide buttons
    for (int i = 0; i < NUM_BUTTONS; i++)
    {
	    if (biButtons[i].uixy2.x != 0)
	    {
		    hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,biButtons[i].id),hwnd,
			     biButtons[i].uixy2.x,
			     biButtons[i].uixy2.y,
			     biButtons[i].width2,
			     biButtons[i].height,
			     SWP_NOACTIVATE|SWP_NOZORDER);
	    }
        else
        {
            ShowWindow(GetDlgItem(hwnd,biButtons[i].id),SW_HIDE); //prevents tabbing
        }

        if (biButtons[i].dwStyle == MBS_SYSTEMTYPE)
        {
            ShowWindow(GetDlgItem(hwnd,biButtons[i].id),SW_SHOW); 
        }
    }

    //move display screen
    hdwp = DeferWindowPos(hdwp,hwndCurrentComp,hwnd,303,24,81,17,SWP_NOACTIVATE|SWP_NOZORDER);
    InvalidateRect(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),NULL,TRUE);

    //size main window
    int sx = GetXOffset()*2;
    int sy = (GetYOffset()*2) + GetYOffsetCaption();
    SetWindowPos(hwnd,NULL,0,0,
	     bmMainRestore.bmWidth+sx,
	     bmMainRestore.bmHeight+sy,
	     SWP_NOMOVE|SWP_NOZORDER);

    ShowWindow(GetDlgItem(hwnd,IDB_VOLUME),SW_HIDE);
    ShowWindow(GetDlgItem(hwnd,IDB_MUTE),SW_HIDE);
    ShowWindow(GetDlgItem(hwnd,IDB_SET_NORMAL_MODE),SW_SHOW);
    ShowWindow(GetDlgItem(hwnd,IDB_SET_TINY_MODE),SW_HIDE);

    SetCurvedEdges(hwnd);

    InvalidateRect(hwnd,NULL,TRUE);
    EndDeferWindowPos(hdwp);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetNormalMode
// Changes the view mode to normal
////////////////////////////////////////////////////////////////////////////////////////////
void SetNormalMode(HWND hwnd)
{
    //going from restore to max
    g_nViewMode = VIEW_MODE_NORMAL;

    //pre-blit the new button sizes
    CMButton* pButton;
    pButton = GetMButtonFromID(hwnd,IDB_PLAY);
    pButton->PreDrawUpstate(biButtons[2].width,biButtons[2].height);
    pButton = GetMButtonFromID(hwnd,IDB_STOP);
    pButton->PreDrawUpstate(biButtons[3].width,biButtons[3].height);
    pButton = GetMButtonFromID(hwnd,IDB_EJECT);
    pButton->PreDrawUpstate(biButtons[4].width,biButtons[4].height);
    pButton = GetMButtonFromID(hwnd,IDB_TRACK);
    pButton->PreDrawUpstate(biButtons[10].width,biButtons[10].height);

    HDWP hdwp = BeginDeferWindowPos(NUM_BUTTONS+3);

    //move/size/show buttons
    for (int i = 0; i < NUM_BUTTONS; i++)
    {
        ShowWindow(GetDlgItem(hwnd,biButtons[i].id),SW_SHOW);
        hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,biButtons[i].id),hwnd,
			          biButtons[i].uixy.x,
			          biButtons[i].uixy.y,
			          biButtons[i].width,
			          biButtons[i].height,
			          SWP_NOACTIVATE|SWP_NOZORDER);
    }

    //move volume and mute
	hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,IDB_VOLUME),hwnd,
		 403,
		 93+nDispAreaOffset,
		 45,
		 45,
		 SWP_NOACTIVATE|SWP_NOZORDER);

	hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,IDB_MUTE),hwnd,
		 450,
		 122+nDispAreaOffset,
		 13,
		 13,
		 SWP_NOACTIVATE|SWP_NOZORDER);

    //move display screen
    hdwp = DeferWindowPos(hdwp,hwndCurrentComp,hwnd,24,32,431,56+nDispAreaOffset,SWP_NOACTIVATE|SWP_NOZORDER);
    InvalidateRect(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),NULL,TRUE);

    ShowWindow(GetDlgItem(hwnd,IDB_VOLUME),SW_SHOW);
    ShowWindow(GetDlgItem(hwnd,IDB_MUTE),SW_SHOW);
    ShowWindow(GetDlgItem(hwnd,IDB_SET_NORMAL_MODE),SW_HIDE);
    ShowWindow(GetDlgItem(hwnd,IDB_SET_TINY_MODE),SW_SHOW);

    //Resize window
    int sx = GetXOffset()*2;
    int sy = (GetYOffset()*2) + GetYOffsetCaption();
    SetWindowPos(hwnd,NULL,0,0,
	     bmMain.bmWidth+sx,
	     bmMain.bmHeight+sy,
	     SWP_NOMOVE|SWP_NOZORDER);

    SetCurvedEdges(hwnd);

    InvalidateRect(hwnd,NULL,TRUE);
    EndDeferWindowPos(hdwp);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * SetSmallMode
// Changes the view mode to small
////////////////////////////////////////////////////////////////////////////////////////////
void SetSmallMode(HWND hwnd)
{
    g_nViewMode = VIEW_MODE_SMALL;

    HDWP hdwp = BeginDeferWindowPos(NUM_BUTTONS+2);

    //move/size/hide buttons
    for (int i = 0; i < NUM_BUTTONS; i++)
    {
	    if (biButtons[i].uixy2.x != 0)
	    {
		    hdwp = DeferWindowPos(hdwp,GetDlgItem(hwnd,biButtons[i].id),hwnd,
			     biButtons[i].uixy2.x,
			     biButtons[i].uixy2.y - (bmMainRestore.bmHeight - bmMainSmall.bmHeight),
			     biButtons[i].width2,
			     biButtons[i].height,
			     SWP_NOACTIVATE|SWP_NOZORDER);
	    }

        if (biButtons[i].dwStyle == MBS_SYSTEMTYPE)
        {
            ShowWindow(GetDlgItem(hwnd,biButtons[i].id),SW_HIDE); 
        }
    }

    //move display screen
    hdwp = DeferWindowPos(hdwp,hwndCurrentComp,hwnd,303,24-(bmMainRestore.bmHeight - bmMainSmall.bmHeight),81,17,SWP_NOACTIVATE|SWP_NOZORDER);
    InvalidateRect(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),NULL,TRUE);

    //size main window
    int sx = GetXOffset()*2;
    int sy = (GetYOffset()*2) + GetYOffsetCaption();
    SetWindowPos(hwnd,NULL,0,0,
	     bmMainSmall.bmWidth+sx,
	     bmMainSmall.bmHeight+sy,
	     SWP_NOMOVE|SWP_NOZORDER);

    SetCurvedEdges(hwnd);

    InvalidateRect(hwnd,NULL,TRUE);
    EndDeferWindowPos(hdwp);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * AdjustForMultimon
// Will move the app onto the primary display if its x,y settings are not on a monitor
////////////////////////////////////////////////////////////////////////////////////////////
void AdjustForMultimon(HWND hwnd)
{
    RECT rect;
    GetWindowRect(hwnd,&rect);

    int cxWnd = rect.right - rect.left;
    int cyWnd = rect.bottom - rect.top;

	// Check if the app's rect is visible is any of the monitors
	if( NULL == MonitorFromRect( &rect, 0L ) )
	{
		//The window is not visible. Let's center it in the primary monitor.
		//Note: the window could be in this state if (1) the display mode was changed from 
		//a high-resolution to a lower resolution, with the cdplayer in the corner. Or,
		//(2) the multi-mon configuration was rearranged.

		RECT rcDesktop;

        GetWindowRect( GetDesktopWindow(), &rcDesktop );
		int cxDesktop = (rcDesktop.right - rcDesktop.left);
		int cyDesktop = (rcDesktop.bottom - rcDesktop.top);

		int x = (cxDesktop - cxWnd) / 2; //center in x
		int y = (cyDesktop - cyWnd) / 3; //and a little towards the top

        SetWindowPos(hwnd,NULL,x,y,0,0,SWP_NOSIZE|SWP_NOZORDER);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////
// * WinMain
// Entry point for application
////////////////////////////////////////////////////////////////////////////////////////////
int WINAPI WinMain(HINSTANCE hInstEXE, HINSTANCE hInstEXEPrev, PSTR lpszCmdLine, int nCmdShow)
{
    //first thing, must check tray icon state
    if (!CanStartShell())
    {
        return (0);
    }
        
    if (!IsOnlyInstance())
    {
        //can't have more than one of these
        return (0);
    }
    
    //save the global hinstance
    hInst = hInstEXE;

    DetermineColorMode();
    
    //start our linked list of components
    pCompList = new COMPNODE;
    ZeroMemory(pCompList,sizeof(COMPNODE));
    pCompListTail = pCompList;

    //load the app name
    LoadString(hInstEXE,IDS_APPNAME,szAppName,sizeof(szAppName)/sizeof(TCHAR));

    //init the networking component (this just inits some crit sections)
    CDNET_Init(hInstEXE);

    //load components from registry
    if (!LoadComponents())
    {
	    CleanUp();
	    return (0);
    }
    
    //register our main window class  
    WNDCLASSEX wc;
    ATOM atomClassName;
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(wc);
    wc.lpszClassName = FRAMEWORK_CLASS;
    wc.lpfnWndProc = MainWndProc;
    wc.hInstance = hInstEXE;
    wc.style = CS_DBLCLKS;
    wc.hIcon = LoadIcon(hInstEXE, MAKEINTRESOURCE(IDI_MMFW));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.hIconSm = (HICON)LoadImage(hInstEXE, MAKEINTRESOURCE(IDI_MMFW), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
    
    atomClassName = RegisterClassEx(&wc);

    int x = CW_USEDEFAULT;
    int y = CW_USEDEFAULT;
    
    GetSettings(x,y);

	hpalMain = SetPalette();

    #ifndef MMFW_USE_CAPTION
    DWORD dwStyle = WS_POPUP|WS_SYSMENU|WS_MINIMIZEBOX|WS_CLIPCHILDREN;
    #else
    DWORD dwStyle = WS_POPUP|WS_SYSMENU|WS_MINIMIZEBOX|WS_CAPTION|WS_CLIPCHILDREN;
    #endif

    //create our main window
    HWND hwnd = CreateWindowEx(WS_EX_APPWINDOW,
			     MAKEINTATOM(atomClassName),
			     szAppName,
			     dwStyle,
			     x,
			     y,
			     0,
			     0,
			     NULL,
			     NULL,
			     hInstEXE,
			     NULL);

    if (hwnd == NULL)
    {
        //major failure here!
        CleanUp();
        return 0;
    }

    hwndMain = hwnd;

    //tell our sink what our main window is
    CFrameworkNotifySink::m_hwndTitle = hwnd;

    //create the bitmaps of the main ui
    if (!BuildFrameworkBitmaps())
    {
        //failure -- can't create bitmaps for framework
        CleanUp();
        return 0;
    }

    int bmWidth = bmMain.bmWidth;
    int bmHeight = bmMain.bmHeight;

    //set window size to match the width and height of the correct mode's bitmap
    switch (g_nViewMode)
    {
        case VIEW_MODE_RESTORE :
        {
            bmWidth = bmMainRestore.bmWidth;
            bmHeight = bmMainRestore.bmHeight;
        }
        break;

        case VIEW_MODE_SMALL :
        {
            bmWidth = bmMainSmall.bmWidth;
            bmHeight = bmMainSmall.bmHeight;
        }
        break;

        case VIEW_MODE_NOBAR :
        {
            bmWidth = bmMainNoBar.bmWidth;
            bmHeight = bmMainNoBar.bmHeight;
        }
        break;
    }

    int sx = GetXOffset()*2;
    int sy = (GetYOffset()*2) + GetYOffsetCaption();
    SetWindowPos(hwnd,NULL,0,0,bmWidth+sx,bmHeight+sy,SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER);

    //check the window pos against multimon
    AdjustForMultimon(hwnd);

    SetCurvedEdges(hwnd);

    //Send us a message to set the initial mode of the player
    SendMessage(hwnd,WM_COMMAND,MAKEWPARAM(nCDMode,0),0);

    //show us!
    if (!ShellOnly())
    {
        ShowWindow(hwnd, nCmdShow);
        UpdateWindow(hwnd);

        LPCDDATA pCDData = GetCDData();

        if (pCDData)
        {
            pCDData->Initialize(hwnd);
            pCDData->CheckDatabase(hwnd);
        }
    }

    if (fShellMode)
    {
        CreateShellIcon(hInst,hwnd,pNodeCurrent,szAppName);
    }

    //main message loop
    MSG msg;

    for (;;)
    {
        if (PeekMessage(&msg, NULL, 0, 0,PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
                break;

	        /*
            if (hAccelApp && TranslateAccelerator(hwndApp, hAccelApp, &msg))
		    continue;
            */

	        if (!IsDialogMessage(hwnd,&msg))
	        {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            } //end if dialg msg
        }
        else
	    {
            WaitMessage();
        }
    } //end for

    //get outta here!
    CleanUp();

    return ((int)msg.wParam);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * ShowNewComponentWindow
// Displays the chosen component
// (Sort of a holdover from the old multi-component days, but it also serves to
// initialize the first component loaded)
////////////////////////////////////////////////////////////////////////////////////////////
void ShowNewComponentWindow(PCOMPNODE pNode, HWND hwnd)
{
    if (pNode == NULL)
    {
    	return;
    }

    //don't bother if we're already there
    if (pNode->hwndComp == hwndCurrentComp)
    {
	    return;
    }
    
    if (hwndCurrentComp != NULL)
    {
	    ShowWindow(hwndCurrentComp,SW_HIDE);
    }

    hwndCurrentComp = pNode->hwndComp;
    
    ShowWindow(hwndCurrentComp,SW_SHOW);

    pNodeCurrent = pNode;

    MMCOMPDATA mmComp;
    mmComp.dwSize = sizeof(mmComp);
    pNode->pComp->GetInfo(&mmComp);

    if (_tcslen(pNode->szTitle)==0)
    {
	    _tcscpy(pNode->szTitle,mmComp.szName);
    }

    SetWindowText(hwnd,szAppName);

    //also set icons
    if (mmComp.hiconLarge != NULL)
    {
    	SendMessage(hwnd, WM_SETICON, TRUE, (LPARAM)mmComp.hiconLarge);
    }

    if (mmComp.hiconSmall != NULL)
    {
	    SendMessage(hwnd, WM_SETICON, FALSE, (LPARAM)mmComp.hiconSmall);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * InitButtonProperties
// Set up the button info structure for all the transport buttons
//
// bugbug: this is pretty ugly and hard-coded.  Implement to read from some kind of
//         easily-editable resource for when layout changes come?
////////////////////////////////////////////////////////////////////////////////////////////
void InitButtonProperties()
{
    //set up each button's properties
    ZeroMemory(biButtons,sizeof(BUTTONINFO)*NUM_BUTTONS);

    //order of buttons in this array affects the tab order
    biButtons[0].id = IDB_OPTIONS;
    biButtons[0].nToolTipID = IDB_TT_OPTIONS;
    biButtons[0].uixy.x = 11;
    biButtons[0].uixy.y = 102 + nDispAreaOffset;
    biButtons[0].width = 76;
    biButtons[0].height = 19;
    biButtons[0].uixy2.x = 9;
    biButtons[0].uixy2.y = 23;
    biButtons[0].width2 = 76;
    biButtons[0].dwStyle = MBS_STANDARDLEFT | MBS_DROPRIGHT;

    biButtons[1].id = IDB_NET;
    biButtons[1].nToolTipID = IDB_TT_NET;
    biButtons[1].uixy.x = 11;
    biButtons[1].uixy.y = 125 + nDispAreaOffset;
    biButtons[1].width = 76;
    biButtons[1].height = 19;
    biButtons[1].dwStyle = MBS_STANDARDLEFT | MBS_DROPRIGHT;

    biButtons[2].id = IDB_PLAY;
    biButtons[2].nToolTipID = IDB_TT_PLAY;
    biButtons[2].uixy.x = 103;
    biButtons[2].uixy.y = 102 + nDispAreaOffset;
    biButtons[2].width = 64;
    biButtons[2].height = 19; 
    biButtons[2].uixy2.x = 102;
    biButtons[2].uixy2.y = 23;
    biButtons[2].width2 = 34;
    biButtons[2].dwStyle = MBS_STANDARDLEFT | MBS_STANDARDRIGHT;
    biButtons[2].nIconID = IDI_ICON_PLAY;

    biButtons[3].id = IDB_STOP;
    biButtons[3].nToolTipID = IDB_TT_STOP;
    biButtons[3].uixy.x = 174;
    biButtons[3].uixy.y = 102 + nDispAreaOffset;
    biButtons[3].width = 64;
    biButtons[3].height = 19;
    biButtons[3].uixy2.x = 136;
    biButtons[3].uixy2.y = 23;
    biButtons[3].width2 = 34;
    biButtons[3].dwStyle = MBS_STANDARDLEFT | MBS_STANDARDRIGHT;
    biButtons[3].nIconID = IDI_ICON_STOP;

    biButtons[4].id = IDB_EJECT;    
    biButtons[4].nToolTipID = IDB_TT_EJECT;
    biButtons[4].uixy.x = 245;
    biButtons[4].uixy.y = 102 + nDispAreaOffset;
    biButtons[4].width = 51;
    biButtons[4].height = 19;
    biButtons[4].uixy2.x = 170;
    biButtons[4].uixy2.y = 23;
    biButtons[4].width2 = 34;
    biButtons[4].dwStyle = MBS_STANDARDLEFT | MBS_STANDARDRIGHT;
    biButtons[4].nIconID = IDI_ICON_EJECT;

    biButtons[5].id = IDB_REW;
    biButtons[5].nToolTipID = IDB_TT_REW;
    biButtons[5].uixy.x = 103;
    biButtons[5].uixy.y = 125 + nDispAreaOffset;
    biButtons[5].width = 33;
    biButtons[5].height = 19;
    biButtons[5].dwStyle = MBS_STANDARDLEFT | MBS_TOGGLERIGHT;
    biButtons[5].nIconID = IDI_ICON_REW;

    biButtons[6].id = IDB_FFWD;
    biButtons[6].nToolTipID = IDB_TT_FFWD;
    biButtons[6].uixy.x = 136;
    biButtons[6].uixy.y = 125 + nDispAreaOffset;
    biButtons[6].width = 31;
    biButtons[6].height = 19;
    biButtons[6].dwStyle = MBS_TOGGLELEFT | MBS_STANDARDRIGHT;
    biButtons[6].nIconID = IDI_ICON_FFWD;

    biButtons[7].id = IDB_PREVTRACK;
    biButtons[7].nToolTipID = IDB_TT_PREVTRACK;
    biButtons[7].uixy.x = 174;
    biButtons[7].uixy.y = 125 + nDispAreaOffset;
    biButtons[7].width = 33;
    biButtons[7].height = 19;
    biButtons[7].dwStyle = MBS_STANDARDLEFT | MBS_TOGGLERIGHT;
    biButtons[7].nIconID = IDI_ICON_PREV;

    biButtons[8].id = IDB_NEXTTRACK;
    biButtons[8].nToolTipID = IDB_TT_NEXTTRACK;
    biButtons[8].uixy.x = 207;
    biButtons[8].uixy.y = 125 + nDispAreaOffset;
    biButtons[8].width = 31;
    biButtons[8].height = 19;
    biButtons[8].dwStyle = MBS_TOGGLELEFT | MBS_STANDARDRIGHT;
    biButtons[8].nIconID = IDI_ICON_NEXT;

    biButtons[9].id = IDB_MODE;
    biButtons[9].nToolTipID = IDB_TT_MODE;
    biButtons[9].uixy.x = 245;
    biButtons[9].uixy.y = 125 + nDispAreaOffset;
    biButtons[9].width = 51;
    biButtons[9].height = 19;
    biButtons[9].dwStyle = MBS_STANDARDLEFT | MBS_DROPRIGHT;
    biButtons[9].nIconID = IDI_MODE_NORMAL;

    biButtons[10].id = IDB_TRACK;
    biButtons[10].nToolTipID = IDB_TT_TRACK;
    biButtons[10].uixy.x = 312;
    biButtons[10].uixy.y = 102 + nDispAreaOffset;
    biButtons[10].width = 76;
    biButtons[10].height = 19;
    biButtons[10].uixy2.x = 221;
    biButtons[10].uixy2.y = 23;
    biButtons[10].width2 = 72;
    biButtons[10].dwStyle = MBS_STANDARDLEFT | MBS_DROPRIGHT;

    biButtons[11].id = IDB_DISC;
    biButtons[11].nToolTipID = IDB_TT_DISC;
    biButtons[11].uixy.x = 312;
    biButtons[11].uixy.y = 125 + nDispAreaOffset;
    biButtons[11].width = 76;
    biButtons[11].height = 19;
    biButtons[11].dwStyle = MBS_STANDARDLEFT | MBS_DROPRIGHT;

    biButtons[12].id = IDB_CLOSE;
    biButtons[12].nToolTipID = IDB_TT_CLOSE;
    biButtons[12].uixy.x = 456;
    biButtons[12].uixy.y = 7;
    biButtons[12].width = 15;
    biButtons[12].height = 14;
    biButtons[12].fBlockTab = TRUE;
    biButtons[12].uixy2.x = 371;
    biButtons[12].uixy2.y = 4;
    biButtons[12].width2 = 15;
    biButtons[12].dwStyle = MBS_SYSTEMTYPE;
    biButtons[12].nIconID = IDB_CLOSE;

    biButtons[13].id = IDB_MINIMIZE;
    biButtons[13].nToolTipID = IDB_TT_MINIMIZE;
    biButtons[13].uixy.x = 427;
    biButtons[13].uixy.y = 7;
    biButtons[13].width = 14;
    biButtons[13].height =  14;
    biButtons[13].fBlockTab = TRUE;
    biButtons[13].uixy2.x = 343;
    biButtons[13].uixy2.y = 4;
    biButtons[13].width2 = 14;
    biButtons[13].dwStyle = MBS_SYSTEMTYPE;
    biButtons[13].nIconID = IDB_MINIMIZE;

    biButtons[14].id = IDB_SET_TINY_MODE;
    biButtons[14].nToolTipID = IDB_TT_RESTORE;
    biButtons[14].uixy.x = 442;
    biButtons[14].uixy.y = 7;
    biButtons[14].width = 14;
    biButtons[14].height =  14;
    biButtons[14].fBlockTab = TRUE;
    biButtons[14].uixy2.x = 357;
    biButtons[14].uixy2.y = 4;
    biButtons[14].width2 = 14;
    biButtons[14].dwStyle = MBS_SYSTEMTYPE;
    biButtons[14].nIconID = IDB_SET_TINY_MODE;

    biButtons[15].id = IDB_SET_NORMAL_MODE;
    biButtons[15].nToolTipID = IDB_TT_MAXIMIZE;
    biButtons[15].uixy.x = 442;
    biButtons[15].uixy.y = 7;
    biButtons[15].width = 14;
    biButtons[15].height =  14;
    biButtons[15].fBlockTab = TRUE;
    biButtons[15].uixy2.x = 357;
    biButtons[15].uixy2.y = 4;
    biButtons[15].width2 = 14;
    biButtons[15].dwStyle = MBS_SYSTEMTYPE;
    biButtons[15].nIconID = IDB_SET_NORMAL_MODE;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CreateMuteButton
// Make the little mute button guy
////////////////////////////////////////////////////////////////////////////////////////////
void CreateMuteButton(HWND hwndOwner)
{
	//first load mute button's cursor
    hCursorMute = LoadCursor(hInst,MAKEINTRESOURCE(IDC_MUTE));
    
    CMButton* pButton = NULL;

	TCHAR szCaption[MAX_PATH];
	LoadString(hInst,IDB_MUTE,szCaption,sizeof(szCaption)/sizeof(TCHAR));
	
    int yOffset = 122+nDispAreaOffset;
    if (g_nViewMode == VIEW_MODE_NOBAR)
    {
        yOffset -= 16;
    }

    pButton = CreateMButton(szCaption,IDB_MUTE,WS_VISIBLE|WS_TABSTOP,
				    MBS_SYSTEMTYPE,
				    450,
				    yOffset,
				    13,
				    13,
				    hwndOwner,
				    FALSE,  //create original, not subclass
				    IDB_MUTE,
                    IDB_TT_MUTE,
				    hInst);

    //hide this button in small mode
    if ((g_nViewMode==VIEW_MODE_RESTORE)||((g_nViewMode==VIEW_MODE_SMALL)))
    {
        ShowWindow(pButton->GetHWND(),SW_HIDE); 
    }

    //set up tool tip
    TOOLINFO ti;
    ti.cbSize = sizeof(TOOLINFO); 
    ti.uFlags = TTF_IDISHWND;
    ti.hwnd =  hwndOwner; 
    ti.uId = (UINT_PTR)(pButton->GetHWND());
    ti.hinst = hInst; 
    ti.lpszText = LPSTR_TEXTCALLBACK;
    SendMessage(g_hwndTT, TTM_ADDTOOL, 0,  (LPARAM) (LPTOOLINFO) &ti);

    //make sure button is in correct state if muted on start up
    SendMessage(pButton->GetHWND(),BM_SETSTATE,(WPARAM)GetMute(),0);
    SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_MUTE,0,GetMute());
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CreateVolumeKnob
// Put up the volume knob that EVERYONE LOVES
////////////////////////////////////////////////////////////////////////////////////////////
void CreateVolumeKnob(HWND hwndOwner)
{
    LPCDOPT pOpt = GetCDOpt();
    if( pOpt )
    {
        LPCDOPTIONS pCDOpts = pOpt->GetCDOpts();
        InitCDVol(hwndOwner,pCDOpts);

        //ok, this is bad, but I have the options here and the only other thing
        //I need from them is the "topmost" setting for the main window ...
        //so I'll go ahead and take care of that here rather than recreating
        //this struct somewhere or making it global.
        SetWindowPos(hwndOwner,
                     pCDOpts->pCDData->fTopMost ? HWND_TOPMOST : HWND_NOTOPMOST,
                     0,0,0,0,
                     SWP_NOMOVE|SWP_NOSIZE);
    
        DWORD dwVol = GetVolume();
        int yOffset = 93+nDispAreaOffset;
        if (g_nViewMode == VIEW_MODE_NOBAR)
        {
            yOffset -= 16;
        }

        CKnob* pKnob = CreateKnob(WS_VISIBLE | WS_TABSTOP,
	                               0xFFFF,
	                               dwVol,
	                               403,
	                               yOffset,
	                               45,
	                               45,
	                               hwndOwner,
	                               IDB_VOLUME,
	                               hInst);

        TOOLINFO ti;
        ti.cbSize = sizeof(TOOLINFO); 
        ti.uFlags = TTF_IDISHWND;
        ti.hwnd =  hwndOwner; 
        ti.uId = (UINT_PTR)(pKnob->GetHWND());
        ti.hinst = hInst; 
        ti.lpszText = LPSTR_TEXTCALLBACK;
        SendMessage(g_hwndTT, TTM_ADDTOOL, 0,  (LPARAM) (LPTOOLINFO) &ti);

        if ((g_nViewMode==VIEW_MODE_RESTORE)||((g_nViewMode==VIEW_MODE_SMALL)))
        {
            ShowWindow(pKnob->GetHWND(),SW_HIDE);
        }
    
        CreateMuteButton(hwndOwner);
    }
    else
    {
        //fix for bug 886 ... turns off mute line in case of cdopt.dll failure
        SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_MUTE,0,FALSE);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CreateButtonWindows
// Put the transport control buttons onto the screen
////////////////////////////////////////////////////////////////////////////////////////////
void CreateButtonWindows(HWND hwndOwner)
{
    InitMButtons(hInst,hwndOwner);

    InitButtonProperties();

    for (int i = 0; i < NUM_BUTTONS; i++)
    {
	    DWORD wsTab = biButtons[i].fBlockTab ? 0 : WS_TABSTOP;

	    CMButton* pButton = NULL;
    
	    TCHAR szCaption[MAX_PATH];
	    LoadString(hInst,biButtons[i].id,szCaption,sizeof(szCaption)/sizeof(TCHAR));
	    
	    int x, y, width;
        int nView = SW_SHOW;

        switch (g_nViewMode)
        {
            case VIEW_MODE_NORMAL :
            {
                x = biButtons[i].uixy.x;
                y = biButtons[i].uixy.y;
                width = biButtons[i].width;
                if (biButtons[i].id == IDB_SET_NORMAL_MODE)
                {
                    nView = SW_HIDE;
                }
            }
            break;

            case VIEW_MODE_NOBAR :
            {
                x = biButtons[i].uixy.x;
                y = biButtons[i].uixy.y - 16;
                width = biButtons[i].width;
                if (biButtons[i].dwStyle == MBS_SYSTEMTYPE)
                {
                    nView = SW_HIDE;
                }
            }
            break;

            case VIEW_MODE_RESTORE :
            {
                x = biButtons[i].uixy2.x;
                y = biButtons[i].uixy2.y;
                width = biButtons[i].width2;
                if (biButtons[i].id == IDB_SET_TINY_MODE)
                {
                    nView = SW_HIDE;
                }
            }
            break;

            case VIEW_MODE_SMALL :
            {
                x = biButtons[i].uixy2.x;
                y = biButtons[i].uixy2.y - 12;
                width = biButtons[i].width2;
            }
            break;
        }

        //for buttons that aren't going to blit in smaller modes
        if (width == 0)
        {
            //set to normal width
            width = biButtons[i].width;
            nView = SW_HIDE;
        }

        pButton = CreateMButton(szCaption,biButtons[i].nIconID,WS_VISIBLE|wsTab,
				        biButtons[i].dwStyle,
				        x,
				        y,
				        width,
				        biButtons[i].height,
				        hwndOwner,
				        FALSE,  //create original, not subclass
				        biButtons[i].id,
                        biButtons[i].nToolTipID,
				        hInst);

        //hide system buttons in small mode
        if (g_nViewMode == VIEW_MODE_SMALL)
        {
            if (biButtons[i].dwStyle == MBS_SYSTEMTYPE)
            {
                ShowWindow(pButton->GetHWND(),SW_HIDE); 
            }
        }

        if (nView == SW_HIDE)
        {
            ShowWindow(pButton->GetHWND(),SW_HIDE);
        }

        TOOLINFO ti;
        ti.cbSize = sizeof(TOOLINFO); 
        ti.uFlags = TTF_IDISHWND;
        ti.hwnd =  hwndOwner; 
        ti.uId = (UINT_PTR)(pButton->GetHWND());
        ti.hinst = hInst; 
        ti.lpszText = LPSTR_TEXTCALLBACK;
        SendMessage(g_hwndTT, TTM_ADDTOOL, 0,  (LPARAM) (LPTOOLINFO) &ti);

	    //set focus and default to first control
	    if (i == 0)
	    {
	        SetFocus(pButton->GetHWND());
	    }
    } //end for buttons

    SendMessage(hwndOwner, DM_SETDEFID, biButtons[0].id, 0);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * VolPersistTimerProc
// When we're done displaying the volume, tell CD player to repaint normally
////////////////////////////////////////////////////////////////////////////////////////////
void CALLBACK VolPersistTimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    //turn on painting in the led window
    SendMessage(GetDlgItem(hwndCurrentComp,IDC_LEDWINDOW),WM_LED_INFO_PAINT,1,0);
    InvalidateRect(hwndCurrentComp,NULL,FALSE);
    KillTimer(hwnd,idEvent);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * IsNetOK
// Returns TRUE if it is OK to do networking-related stuff (i.e. the database is all right)
////////////////////////////////////////////////////////////////////////////////////////////
BOOL IsNetOK(HWND hwnd)
{
    DWORD dwRet = FALSE;
    
    LPCDDATA pData = GetCDData();
    if (pData)
    {
        if (SUCCEEDED(pData->CheckDatabase(hwnd)))
        {
            dwRet = TRUE;
        }
    }

    return (dwRet);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * IsDownloading
// Check on the networking thread to see if it is active
////////////////////////////////////////////////////////////////////////////////////////////
BOOL IsDownloading()
{
    BOOL retcode = FALSE;
    
    ICDNet* pICDNet = NULL;
    if (SUCCEEDED(CDNET_CreateInstance(NULL, IID_ICDNet, (void**)&pICDNet)))
    {
		    retcode = pICDNet->IsDownloading();
            pICDNet->Release();
    }

    return (retcode);
}

////////////////////////////////////////////////////////////////////////////////////////////
// * CancelDownload
// Tell the networking thread to quit as soon as it can
////////////////////////////////////////////////////////////////////////////////////////////
void Cancel