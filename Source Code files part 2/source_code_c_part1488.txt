g
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR sz:
//
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;
void DbgQueueString(LPSTR pString)
{
    listAddTail(pString);
}


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;
    BOOL		fQueue	    = FALSE;
    BOOL		fDumpQueue  = FALSE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;

	    case ';':
		fQueue = TRUE;
		if (';' == *(szFormat+1)) {
		    fQueue = FALSE;
		    fDumpQueue = TRUE;
		    szFormat++;
		}
		szFormat++;
		continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,szFormat);									// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))						// find each %p
			*(psz+1) = 'x';										// replace each %p with %x
#ifdef _WIN32
	    wvsprintfA(ach + lstrlenA(ach), szDfs, va);	    		// use the local format string
#else
		wvsprintf(ach + lstrlenA(ach), szDfs, (LPSTR)va);  		// use the local format string
#endif
	}
#else
	{
#ifdef _WIN32
	    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
		wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif
	}
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    if (fDumpQueue)
    {
	DbgDumpQueue();
    }

    if (fQueue) {
	DbgQueueString(ach);
    } else {
	OutputDebugStringA(ach);
    }

    if (fDebugBreak)
    {
        DebugBreak();
    }
} // DbgVPrintF()

#endif // USERPF || USEDPF


#ifdef USEDPF

//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif // #ifdef USEDPF


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

#ifdef USEASSERT

#ifndef _WIN32
#pragma warning(disable:4704)
#endif

void WINAPI _Assert
(
    char *  szFile,
    int     iLine,
    char *  szExpression
)
{
    static char     ach[400];       // debug output (avoid stack overflow)
    int             id;
#ifndef _WIN32
    int             iExitCode;
#endif

#ifdef DEBUG
    if (__gfDbgEnabled)
    {
	
	wsprintfA(ach, "Assertion failed in file %s, line %d: (%s)", (LPSTR)szFile, iLine, (LPSTR)szExpression);
	OutputDebugString(ach);
	DebugBreak();
	
    }
    else
#endif
    {
	
	wsprintfA(ach, "Assertion failed in file %s, line %d: (%s)  [Press RETRY to debug.]", (LPSTR)szFile, iLine, (LPSTR)szExpression);

	id = MessageBoxA(NULL, ach, "Assertion Failed",
			 MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	    case IDABORT:               // Kill the application.
#ifndef _WIN32
		iExitCode = 0;
		_asm {
		    mov ah, 4Ch;
		    mov al, BYTE PTR iExitCode;
		    int     21h;
		}
#else
		FatalAppExit(0, TEXT("Good Bye"));
#endif // WIN16
		break;

	    case IDRETRY:               // Break into the debugger.
		DebugBreak();
		break;

	    case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
    }
} // _Assert

#endif // #ifdef USEASSERT


//--------------------------------------------------------------------------;
//  
//  void rprintf
//  
//  Description:
//      rprintf() is called by the RPF() macro.  It is just like dprintf,
//      except that there is no level defined.  RPF statements always
//      translate to a debug output, regardless of level.
//      
//  Arguments:
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

#ifdef USERPF

void CDECL rprintf
(
    LPSTR                  szFormat,
    ...
)
{
    va_list va;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
}

#endif // USERPF

#ifndef _WIN32
#pragma warning(default:4704)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtabout.h ===
//===========================================================================
// dmtabout.h
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================

#ifndef _DMTABOUT_H
#define _DMTABOUT_H

//---------------------------------------------------------------------------

// prototypes
BOOL CALLBACK dmtaboutDlgProc(HWND hwnd,
                            UINT uMsg,
                            WPARAM wparam,
                            LPARAM lparam);
BOOL dmtaboutOnInitDialog(HWND hwnd, 
                        HWND hwndFocus, 
                        LPARAM lparam);
BOOL dmtaboutOnClose(HWND hwnd);
BOOL dmtaboutOnCommand(HWND hwnd,
                    WORD wId,
                    HWND hwndCtrl,
                    WORD wNotifyCode);

//---------------------------------------------------------------------------
#endif // _DMTABOUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dimaptst.h ===
//===========================================================================
// dimaptst.h
//
// History:
//  08/19/1999 - davidkl - created
//===========================================================================

#ifndef _DIMAPTST_H
#define _DIMAPTST_H

//---------------------------------------------------------------------------

#include <windows.h>
#include <commctrl.h>
#include <dinput.h>
#include "dmterror.h"
#include "debug.h"
#include "resource.h"

//---------------------------------------------------------------------------

// app global variables
extern HINSTANCE        ghinst;
extern HANDLE           ghEvent;
extern CRITICAL_SECTION gcritsect;

//JJ FIX
extern UINT_PTR			g_NumSubGenres;
//---------------------------------------------------------------------------

// custom window messages
#define WM_DMT_UPDATE_LISTS         WM_USER+1
#define WM_DMT_FILE_SAVE            WM_USER+3

//---------------------------------------------------------------------------

#define GENRES_INI              ".\\genre.ini"

//---------------------------------------------------------------------------

#define DMT_DI_STRING_VER       "0x800"

//---------------------------------------------------------------------------

#define ID_POLL_TIMER           97
#define DMT_POLL_TIMEOUT        100

//---------------------------------------------------------------------------

#define NUM_DISPBTNS            32

//---------------------------------------------------------------------------

#ifndef COUNT_ARRAY_ELEMENTS
#define COUNT_ARRAY_ELEMENTS(a) (sizeof(a) / sizeof(a[0]))
#endif

//---------------------------------------------------------------------------

#define MAX_ACTION_ID_STRING    MAX_PATH

//---------------------------------------------------------------------------

#define DMT_GENRE_MASK          0xFF000000
#define DMT_ACTION_MASK         0x000000FF

//---------------------------------------------------------------------------

// control type IDs
#define DMTA_TYPE_AXIS          0
#define DMTA_TYPE_BUTTON        1
#define DMTA_TYPE_POV           2
#define DMTA_TYPE_UNKNOWN       0xFFFFFFFF

//---------------------------------------------------------------------------

typedef struct _actionname
{
    DWORD   dw;
    char    sz[MAX_PATH];

} ACTIONNAME, *PACTIONNAME;

//---------------------------------------------------------------------------

//===========================================================================
// GUID_DIMapTst
//
// GUID uniquely identifying our application
//
// DDK App:
// {87480CC9-C186-4270-914B-CF9EC33839CA}
// SDK App:
// {87480CCA-C186-4270-914B-CF9EC33839CA}
// Internal App:
// {87480CCB-C186-4270-914B-CF9EC33839CA}
//===========================================================================
#ifdef DDKAPP
    DEFINE_GUID(GUID_DIMapTst, 
    0x87480cc9, 0xc186, 0x4270, 0x91, 0x4b, 0xcf, 0x9e, 0xc3, 0x38, 0x39, 0xca);
#else
    DEFINE_GUID(GUID_DIMapTst, 
    0x87480ccb, 0xc186, 0x4270, 0x91, 0x4b, 0xcf, 0x9e, 0xc3, 0x38, 0x39, 0xca);
#endif

//===========================================================================
// GUID_DIConfigAppEditLayout
//
// Make IDirectInput8::ConfigureDevices() launch in "edit mode"
//
// {FD4ACE13-7044-4204-8B15-095286B12EAD}
//===========================================================================
DEFINE_GUID(GUID_DIConfigAppEditLayout, 
0xfd4ace13, 0x7044, 0x4204, 0x8b, 0x15, 0x09, 0x52, 0x86, 0xb1, 0x2e, 0xad);

//---------------------------------------------------------------------------

#ifdef DDKAPP
    #define DMT_APP_CAPTION "DirectInput Mapper Device Configuration Tool"
#else
    #define DMT_APP_CAPTION "DirectInput Mapper Test Tool - MICROSOFT INTERNAL BUILD"
#endif

//---------------------------------------------------------------------------

//===========================================================================
// DMTDEVICEOBJECT_NODE
// PDMTDEVICEOBJECT_NODE
//
// Linked list node for DirectInput device objects (buttons, axes, povs)
//
// Struct contents:
//  DMTDEVICEOBJECT_NODE    *pNext              - next device object in the 
//                                              list
//  char                    szName              - display name of the device 
//                                              object (ANSI string)
//  DWORD                   dwObjectType        - type (axis, button, pov)
//  DWORD                   dwObjectOffset      - offset into the device data 
//                                              format
//  WORD                    wUsagePage          - HID usage page
//  WORD                    wUsage              - HID usage
//  GUID                    guidDeviceInstance  - parent device's instance
//                                              GUID
//  WORD                    wCtrlId             - "identifier" for integrated 
//                                              test UI control
//
//===========================================================================
typedef struct _dmtdeviceobject_node
{
    struct _dmtdeviceobject_node    *pNext;
    
    char                            szName[MAX_PATH];
    DWORD                           dwObjectType;
    DWORD                           dwObjectOffset;
    
    WORD                            wUsagePage;
    WORD                            wUsage;

    GUID                            guidDeviceInstance;
    WORD                            wCtrlId;

} DMTDEVICEOBJECT_NODE, *PDMTDEVICEOBJECT_NODE;

//===========================================================================
// DMTDEVICE_NODE
// PDMTDEVICE_NODE
//
// Linked list node for DirectInput devices
//
// Struct contents:
//  DMTDEVICE_NODE          *pNext          - next device in the list
//  char                    szName          - display name of the device 
//                                          (ANSI string)
//  char                    szShorthandName - 
//  WORD                    wVendorId       - vendor id
//  WORD                    wProductId      - product id
//  DMTDEVICEOBJECT_NODE    *pObjectList    - list of device controls
//  char                    szFileTitle     - 
//
//===========================================================================
typedef struct _dmtdevice_node
{
    struct _dmtdevice_node  *pNext;
    
    IDirectInputDevice8A    *pdid;
    char                    szName[MAX_PATH];
    char                    szShorthandName[MAX_PATH];
    WORD                    wVendorId;
    WORD                    wProductId;
    GUID                    guidInstance;
    DWORD                   dwDeviceType;
    BOOL                    fPolled;
    char                    szProductName[MAX_PATH];

    DWORD                   dwAxes;
    DWORD                   dwButtons;
    DWORD                   dwPovs;

    DMTDEVICEOBJECT_NODE    *pObjectList;

    char                    szFilename[MAX_PATH];

} DMTDEVICE_NODE, *PDMTDEVICE_NODE;

//===========================================================================
// DMTMAPPING_NODE
// PDMTMAPPING_NODE
//
// Linked list node for action maps
//
// Struct contents:
//  DMTMAPPING_NODE *pNext          - next mapping in the list
//  GUID            guidInstance    - device's instance guid
//  BOOL            fChanged        - has this data changed?
//                                  (this gets set to FALSE on load & save)
//  DIACTIONA       *pdia           - array of DIACTIONA structures
//  UINT            uActions        - number of actions referenced by pdia
//
//===========================================================================
typedef struct _dmtmapping_node
{
    struct _dmtmapping_node *pNext;

    GUID                    guidInstance;

    BOOL                    fChanged;

    DIACTIONA               *pdia;
    UINT                    uActions;

} DMTMAPPING_NODE, *PDMTMAPPING_NODE;

//===========================================================================
// DMTACTION_NODE
// PDMTACTION_NODE
//
// Linked list node for DirectInput Mapper actions
//
// Struct contents:
//  DMTACTION_NODE  *pNext      - next action in the list
//  char            szName      - name of the action (ANSI string)
//  DWORD           dwType      - action type (button, axis, pov)
//  DWORD           dwPriority  - priority level of control mapping
//  DWORD           dwActionId  - ID as defined by DirectInput
//  char            szActionId  - text representation of action ID (ANSI 
//                              string)
//
//===========================================================================
typedef struct _dmtaction_node
{
    struct _dmtaction_node  *pNext;

    char                    szName[MAX_PATH];
    DWORD                   dwType;
    DWORD                   dwPriority;
    DWORD                   dwActionId;
    char                    szActionId[MAX_ACTION_ID_STRING];

} DMTACTION_NODE, *PDMTACTION_NODE;


//===========================================================================
// DMTSUBGENRE_NODE
// PDMTSUBGENRE_NODE
//
// Linked list node for DirectInput Mapper subgenres
//
// Struct contents:
//  DMTSUBGENRE_NODE    *pNext          - next subgenre in the list
//  char                szName          - name of the subgenre (ANSI string)
//  char                szDescription   - brief description text (ANSI string)
//  DWORD               dwGenreId       - genre identifier
//  DMTACTION_NODE      *pActionList    - linked list of available actions
//  DMTMAPPING_NODE     *pMappingList   - linked list of mapping information
//
//===========================================================================
typedef struct _dmtsubgenre_node
{
    struct _dmtsubgenre_node    *pNext;

    char                        szName[MAX_PATH];
    char                        szDescription[MAX_PATH];
    DWORD                       dwGenreId;
    DMTACTION_NODE              *pActionList;
    DMTMAPPING_NODE             *pMappingList;

} DMTSUBGENRE_NODE, *PDMTSUBGENRE_NODE;


//===========================================================================
// DMTGENRE_NODE
// PDMTGENRE_NODE
//
// Linked list node for DirectInput Mapper genres
//
// Struct contents:
//  DMTGENRE_NODE       *pNext          - next genre in the list
//  char                szName          - name of the genre (ANSI string)
//  DMTSUBGENRE_NODE    *pSubGenreList  - linked list of subgenres
//
//===========================================================================
typedef struct _dmtgenre_node
{
    struct _dmtgenre_node   *pNext;

    char                    szName[MAX_PATH];
    DMTSUBGENRE_NODE        *pSubGenreList;
        
} DMTGENRE_NODE, *PDMTGENRE_NODE;

//===========================================================================
// DMT_APPINFO
// PDMT_APPINFO
//
// Structure for data needed by main application dialog
//
// Struct contents:
//  DMTGENRE_NODE       *pGenreList         - linked list of device genres
//  DMTSUBGENRE_NODE    *pSubGenre
//  DMTDEVICE_NODE      *pDeviceList        - linked list of gaming devices
//  BOOL                fStartWithDefaults  - initially provide DirectInput's
//                                          "default" object mappings
//  BOOL                fLaunchCplEditMode  - launch the mapper cpl in edit
//                                          mode so object offsets, etc can
//                                          be added to the device map file
//
//===========================================================================
typedef struct _dmt_appinfo
{
    DMTGENRE_NODE       *pGenreList;
    DMTSUBGENRE_NODE    *pSubGenre;

    DMTDEVICE_NODE      *pDeviceList;

    BOOL                fStartWithDefaults;
    BOOL                fLaunchCplEditMode;

    ACTIONNAME          *pan;
    DWORD               dwActions;

} DMT_APPINFO, *PDMTAPPINFO;


//---------------------------------------------------------------------------

#ifndef COUNT_ARRAY_ELEMENTS
#define COUNT_ARRAY_ELEMENTS (sizeof(a)/sizeof(a[0])
#endif

#ifndef SAFE_RELEASE
#define SAFE_RELEASE(o) if(o)               \
                        {                   \
                            o->Release();   \
                            o = NULL;       \
                        }
#endif

//---------------------------------------------------------------------------
#include "dmtxlat.h"
//---------------------------------------------------------------------------


INT_PTR CALLBACK dimaptstMainDlgProc(HWND hwnd,
									 UINT uMsg,
									 WPARAM wparam,
									 LPARAM lparam);
BOOL dimaptstOnInitDialog(HWND hwnd, 
                        HWND hwndFocus, 
                        LPARAM lparam);
BOOL dimaptstOnClose(HWND hwnd);
BOOL dimaptstOnCommand(HWND hwnd,
                    WORD wId,
                    HWND hwndCtrl,
                    WORD wNotifyCode);
BOOL dimaptstOnTimer(HWND hwnd,
                    WPARAM wparamTimerId);
BOOL dimaptstOnUpdateLists(HWND hwnd);

UINT dmtGetCheckedRadioButton(HWND hWnd, 
                            UINT uCtrlStart, 
                            UINT uCtrlStop);
void dimaptstPostEnumEnable(HWND hwnd,
                            BOOL fEnable);

// ini file reading helper functions
DWORD BigFileGetPrivateProfileStringA(LPCSTR lpAppName,
                                    LPCSTR lpKeyName,
                                    LPCSTR lpDefault,
                                    LPSTR lpReturnedString,
                                    DWORD nSize,
                                    LPCSTR lpFileName);
UINT BigFileGetPrivateProfileIntA(LPCSTR lpAppName,
                                    LPCSTR lpKeyName,
                                    UINT nDefault,
                                    LPCSTR lpFileName);

HRESULT dmtGetListItemData(HWND hwnd,
                        WORD wCtrlId,
                        BOOL fCombo,
                        void *pvData,
                        DWORD cbSize);

//---------------------------------------------------------------------------
#endif // _DIMAPTST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtabout.cpp ===
//===========================================================================
// dmtabout.cpp
//
// About box functionality
//
// Functions:
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================

#include "dimaptst.h"
#include "dmtabout.h"

//---------------------------------------------------------------------------


//===========================================================================
// dmtaboutDlgProc
//
// About box dialog processing function
//
// Parameters: (see SDK help for parameter details)
//  HWND    hwnd
//  UINT    uMsg
//  WPARAM  wparam
//  LPARAM  lparam
//
// Returns: (see SDK help for return value details)
//  BOOL
//
// History:
//  08/20/1999 - davidkl - created  
//===========================================================================
BOOL CALLBACK dmtaboutDlgProc(HWND hwnd,
                            UINT uMsg,
                            WPARAM wparam,
                            LPARAM lparam)
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
            return dmtaboutOnInitDialog(hwnd, 
                                        (HWND)wparam, 
                                        lparam);

        case WM_CLOSE:
            return dmtaboutOnClose(hwnd);

        case WM_COMMAND:
            return dmtaboutOnCommand(hwnd,
                                    LOWORD(wparam),
                                    (HWND)lparam,
                                    HIWORD(wparam));

    }

    return FALSE;

} //*** end dmtaboutDlgProc()


//===========================================================================
// dmtaboutOnInitDialog
//
// Handle WM_INITDIALOG processing for the about box
//
// Parameters:
//
// Returns: BOOL
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================
BOOL dmtaboutOnInitDialog(HWND hwnd, 
                        HWND hwndFocus, 
                        LPARAM lparam)
{
	DPF(5, "dmtaboutOnInitDialog");

    return TRUE;

} //*** end dmtaboutOnInitDialog()


//===========================================================================
// dmtaboutOnClose
//
// Handle WM_CLOSE processing for the about box
//
// Parameters:
//
// Returns: BOOL
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================
BOOL dmtaboutOnClose(HWND hwnd)
{
	DPF(5, "dmtaboutOnClose");

    return FALSE;

} //*** end dmtaboutOnClose()


//===========================================================================
// dmtaboutOnCommand
//
// Handle WM_COMMAND processing for the about box
//
// Parameters:
//
// Returns: BOOL
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================
BOOL dmtaboutOnCommand(HWND hwnd,
                    WORD wId,
                    HWND hwndCtrl,
                    WORD wNotifyCode)
{
	DPF(5, "dmtaboutOnCommand");

    switch(wId)
    {
        case IDOK:
        case IDCANCEL:
            EndDialog(hwnd, 0);
            break;
    }

    // done
    return FALSE;

} //*** end dmtaboutOnCommand()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dimaptst.cpp ===
//===========================================================================
// dimaptst.cpp
//
// DirectInput Mapper test tool
//
// Build options:
//  Internal Test Tool
//      -DINTERNAL -DTESTAPP
//
//  External DDK Configuration Tool
//      -DDDKAPP
//
// Functions:
//  WinMain
//  dimaptstMainDlgProc
//  dimaptstOnInitDialog
//  dimaptstOnClose
//  dimaptstOnCommand
//  dimaptstOnUpdateControlData
//  dmtGetCheckedRadioButton
//
// History:
//  08/19/1999 - davidkl - created
//===========================================================================

#define INITGUID

#include "dimaptst.h"
#include "dmtabout.h"
#include "dmtinput.h"
#include "dmtcfg.h"
#include "dmttest.h"
//#include "dmtwrite.h"
#include "dmtstress.h"

//---------------------------------------------------------------------------

#ifndef NTAPI
#define NTAPI __stdcall
#endif

#ifndef NTSYSAPI
#define NTSYSAPI __declspec(dllimport)
#endif

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif

#ifndef PCSZ
typedef CONST char *PCSZ;
#endif

extern "C"
{
NTSYSAPI NTSTATUS NTAPI RtlCharToInteger(PCSZ szString, 
                                        ULONG ulBase, 
                                        ULONG *puValue);
NTSYSAPI ULONG NTAPI RtlNtStatusToDosError(NTSTATUS nts);
}

//---------------------------------------------------------------------------

// app global variables
HINSTANCE           ghinst          = NULL;
HANDLE              ghEvent         = NULL;
CRITICAL_SECTION    gcritsect;

//---------------------------------------------------------------------------

// file global variables

//---------------------------------------------------------------------------


//===========================================================================
// WinMain
//
// App entry point
//
// Parameters: (see SDK help for parameter details)
//  HINSTANCE   hinst
//  HINSTANCE   hinstPrev
//  LPSTR       szCmdParams
//  int         nShow
//
// Returns: (see SDK help for return value details)
//  int
//
// History:
//  08/19/1999 - davidkl - created  
//===========================================================================
int WINAPI WinMain(HINSTANCE hinst,
					   HINSTANCE hinstPrev,
					   PSTR szCmdParams,
					   int nShow)
{
    //int n   = 0;
	//JJ 64Bit Compat
	INT_PTR n = 0;

    // initialize DPF
    DbgInitialize(TRUE);
    DbgEnable(TRUE);

    // see if our ini file exists
    n = GetPrivateProfileIntA("0",
                            "AI0",
                            0,
                            GENRES_INI);
    if(0 == n)
    {
        // file does not exist
        //
        // inform user and bail
        MessageBoxA(NULL,
                    "Please copy genre.ini to the current folder.",
                    "Unable to locate genre.ini",
                    MB_OK);
        return FALSE;
    }

    // initialize Win9x common controls (progress bars, etc)
    InitCommonControls();


    // intialize COM
    if(FAILED(CoInitialize(NULL)))
    {
        DPF(0, "COM initialization failed... exiting");
        return -1;
    }

    // save our instance handle
    ghinst = hinst;

    // create our critical section
    InitializeCriticalSection(&gcritsect);
    
    // create our signal event
    ghEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    // create our main dialog window
    n = DialogBoxParamA(hinst,
                        MAKEINTRESOURCEA(IDD_MAIN),
                        (HWND)NULL,
                        dimaptstMainDlgProc,
                        (LPARAM)NULL);
    if(-1 == n)
    {
        DPF(0, "WinMain - DialogBoxParamA returned an error (%d)",
            GetLastError());
    }

    // done
    CloseHandle(ghEvent);
    DeleteCriticalSection(&gcritsect);
    CoUninitialize();
    return (int)n;

} //*** end WinMain()


//===========================================================================
// dimaptstMainDlgProc
//
// Main application dialog processing function
//
// Parameters: (see SDK help for parameter details)
//  HWND    hwnd
//  UINT    uMsg
//  WPARAM  wparam
//  LPARAM  lparam
//
// Returns: (see SDK help for return value details)
//  BOOL
//
// History:
//  08/19/1999 - davidkl - created  
//===========================================================================
/*BOOL*/INT_PTR CALLBACK dimaptstMainDlgProc(HWND hwnd,
                                UINT uMsg,
                                WPARAM wparam,
                                LPARAM lparam)
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
            return dimaptstOnInitDialog(hwnd, 
                                        (HWND)wparam, 
                                        lparam);

        case WM_CLOSE:
            return dimaptstOnClose(hwnd);

        case WM_COMMAND:
            return dimaptstOnCommand(hwnd,
                                    LOWORD(wparam),
                                    (HWND)lparam,
                                    HIWORD(wparam));


		//JJ Comment:  I am keeping the timer stuff around for now while getting rid of 
		//input polling because we are going to use it later in a different way;  I will 
		//leave the timer stuff in for now and then add in the input stuff when more specific
		//decisions are made concerning *what* exact performance/implementation is desired.
        case WM_TIMER:
            return dimaptstOnTimer(hwnd,
                                wparam);

        case WM_DMT_UPDATE_LISTS:
            return dimaptstOnUpdateLists(hwnd);

   }

    return FALSE;
}


//===========================================================================
// dimaptstOnInitDialog
//
// Handle WM_INITDIALOG processing for the main dialogfs
//
// Parameters:
//
// Returns: BOOL
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================
BOOL dimaptstOnInitDialog(HWND hwnd, 
                        HWND hwndFocus, 
                        LPARAM lparam)
{
    HRESULT         hRes    = S_OK;

    /*int*/
	//JJ 64Bit Compat
	UINT_PTR        nIdx    = 0;
    //LONG            lPrev   = 0L;
	//JJ 64Bit Compat
	LONG_PTR		lPrev	= 0;
    DMT_APPINFO     *pdmtai = NULL;
    DMTGENRE_NODE   *pNode  = NULL;

    DPF(5, "dimaptstOnInitDialog");

    // give the system menu our icon
    SendMessageA(hwnd, 
                WM_SETICON, 
                ICON_BIG,
                (LPARAM)LoadIcon(ghinst,
                                MAKEINTRESOURCEA(IDI_DIMAPTST)));
    SendMessageA(hwnd, 
                WM_SETICON, 
                ICON_SMALL,
                (LPARAM)LoadIcon(ghinst,
                                MAKEINTRESOURCEA(IDI_DIMAPTST)));

    // allocate the appinfo structure
    pdmtai = (DMT_APPINFO*)LocalAlloc(LMEM_FIXED,
                                    sizeof(DMT_APPINFO));
    if(!pdmtai)
    {
        // serious app problem.  
        //  we need to stop things right here and now
        DPF(0, "dimaptstOnInitDialog - This is bad... "
            "We failed to allocate appinfo");
        DPF(0, "dimaptstOnInitDialog - Please find someone "
            "to look at this right away");
        DebugBreak();
        return FALSE;
    }
    pdmtai->pGenreList          = NULL;
    pdmtai->pSubGenre           = NULL;
    pdmtai->pDeviceList         = NULL;
    pdmtai->fStartWithDefaults  = FALSE;

    // allocate the genre list
    hRes = dmtcfgCreateGenreList(&(pdmtai->pGenreList));
    if(FAILED(hRes))
    {
        //  this is potentially very bad
        // ISSUE-2001/03/29-Marcand we fault if we hit this
        // really need to kill the app at this point
        DPF(0, "dimaptstOnInitDialog - This is bad... "
            "We failed to create genre list "
            "(%s == %08Xh)",
            dmtxlatHRESULT(hRes), hRes);
        DPF(0, "dimaptstOnInitDialog - Check to be sure that %s "
            " exists in the current directory",
            GENRES_INI);
        return FALSE;
    }

    // set the hwnd userdata
    SetLastError(0);

	//JJ- 64Bit compat change
	lPrev = SetWindowLongPtr(hwnd,
							 GWLP_USERDATA,
							 (LONG_PTR)pdmtai);

    if(!lPrev && GetLastError())
    {
        // serious app problem.  
        //  we need to stop things right here and now
        DPF(0, "dimaptstOnInitDialog - This is bad... "
            "We failed to store pList");
        DPF(0, "dimaptstOnInitDialog - Please find someone "
            "to look at this right away");
        DebugBreak();
        return FALSE;
    }

    // populate the controls

    // genre list
    pNode = pdmtai->pGenreList;
    while(pNode)
    {
        // add the name to the list
        nIdx = SendMessageA((HWND)GetDlgItem(hwnd, IDC_DEVICE_GENRES),
                            CB_ADDSTRING,
                            0,
                            (LPARAM)(pNode->szName));


        // add the node to the item data
        SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_GENRES),
                    CB_SETITEMDATA,
                    nIdx,
                    (LPARAM)pNode);

        // next node
        pNode = pNode->pNext;
    }

    // set the selection to the first in the list
    SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_GENRES),
                CB_SETCURSEL,
                0,
                0L);

    // populate the subgenre list
    SendMessageA(hwnd,
                WM_DMT_UPDATE_LISTS,
                0,
                0L);

    // set the testing option
//    CheckRadioButton(hwnd,
 //                   IDC_USE_INTEGRATED,
 //                   IDC_USE_CPL,
 //                   IDC_USE_CPL);

#ifdef TESTAPP
    //***************************************
    // Internal app specific control settings
    //***************************************
    // set the verification option to automatic    
    CheckRadioButton(hwnd,
                    IDC_VERIFY_AUTOMATIC,
                    IDC_VERIFY_MANUAL,
                    IDC_VERIFY_AUTOMATIC);

#endif // TESTAPP

#ifdef DDKAPP
    //***************************************
    // DDK Tool specific control settings
    //***************************************
    
    // set default state for "start with defaults"
    CheckDlgButton(hwnd,
                IDC_START_WITH_DEFAULTS,
                BST_CHECKED);

#endif // DDKAPP

	 SendMessageA(hwnd,
                  WM_COMMAND,
                  IDC_ENUM_DEVICES,
                  0L);
 
    // done
    return TRUE;

} //*** end dimaptstOnInitDialog()


//===========================================================================
// dimaptstOnClose
//
// Handle WM_CLOSE processing for the main dialog
//
// Parameters:
//
// Returns: BOOL
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================
BOOL dimaptstOnClose(HWND hwnd)
{
	HRESULT     hRes    = S_OK;
    HRESULT     hr      = S_OK;
    DMT_APPINFO *pdmtai = NULL;

    DPF(5, "dimaptstOnClose");

    __try
    {
        // get appinfo
        
		//JJ- 64Bit Compat
		pdmtai = (DMT_APPINFO*)GetWindowLongPtr(hwnd,
												GWLP_USERDATA);

        if(!pdmtai)
        {
            DPF(0, "dimaptstOnClose - unable to retrieve app info");
            hRes = E_UNEXPECTED;
            __leave;
        }

        // free appinfo

        // device list first
        hr = dmtinputFreeDeviceList(&(pdmtai->pDeviceList));
        if(S_OK == hRes)
        {
            DPF(2, "dimaptstOnClose - dmtinputFreeDeviceList (%s == %08Xh)",
                dmtxlatHRESULT(hr), hr);
            hRes = hr;
        }
        pdmtai->pDeviceList = NULL;

        // then genre list
        hRes = dmtcfgFreeGenreList(&(pdmtai->pGenreList));
        if(S_OK == hRes)
        {
            DPF(2, "dimaptstOnClose - dmtinputFreeGenreList (%s == %08Xh)",
                dmtxlatHRESULT(hr), hr);
            hRes = hr;
        }
        pdmtai->pGenreList = NULL;
        
        // parent structure
        if(LocalFree((HLOCAL)pdmtai))
        {
            DPF(0, "dimaptstOnClose - LocalFree(app info) failed!");
            if(S_OK == hRes)
            {
                hRes = DMT_S_MEMORYLEAK;
            }
        }
        pdmtai = NULL;

    }
    _finally
    {   
        // time to leave
        EndDialog(hwnd, (int)hRes);
        PostQuitMessage((int)hRes);
    }
    
    // done
    return FALSE;

} //*** end dimaptstOnClose()


//===========================================================================
// dimaptstOnCommand
//
// Handle WM_COMMAND processing for the main dialog
//
// Parameters:
//
// Returns: BOOL
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================
BOOL dimaptstOnCommand(HWND hwnd,
                    WORD wId,
                    HWND hwndCtrl,
                    WORD wNotifyCode)
{
    HRESULT             hRes            = S_OK;
    BOOL                fEnable         = FALSE;
    BOOL                fEnumSuitable   = FALSE;
	//JJ Added 64Bit Compat
	LONG_PTR			nIdx			= -1;
	UINT_PTR			u				= 0;
	static UINT_PTR     uGenSel         = 0;

    static UINT         uSubSel         = 0;
    DMT_APPINFO         *pdmtai         = NULL;
    DMTDEVICE_NODE      *pDevice        = NULL;    
    DMTGENRE_NODE       *pGenre         = NULL;
    DMTSUBGENRE_NODE    *pSubGenre      = NULL;
#ifdef TESTAPP
    int                 nWidth          = 597;
    int                 nHeight         = 0;
#endif // TESTAPP

	DPF(5, "dimaptstOnCommand");

    // get app info (stored in hwnd userdata)
  
	//JJ- 64Bit Compat
	pdmtai = (DMT_APPINFO*)GetWindowLongPtr(hwnd,
											GWLP_USERDATA);
    if(!pdmtai)
    {
            // ISSUE-2001/03/29-timgill Needs error case handling
    }

    switch(wId)
    {
        case IDOK:  
            //JJ FIX UI
			
            hRes = dmttestRunMapperCPL(hwnd,
                                       FALSE);       
            break;

        case IDCANCEL:
            // ISSUE-2001/03/29-timgill need to check return value
            dmttestStopIntegrated(hwnd);
            break;
            
        case IDC_DEVICE_GENRES:
            // check for selection change
            if(CBN_DROPDOWN == wNotifyCode)
            {
                // memorize current selection
                uGenSel = SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_GENRES),
                                        CB_GETCURSEL,
                                        0,
										//JJ- 64Bit Compat
                                        //0L);
										0);
            }
            if(CBN_SELCHANGE == wNotifyCode)
            {
                // selection changed
                //
                // get the new selection
                u = SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_GENRES),
                                CB_GETCURSEL,
                                0,
                                0L);

                if(uGenSel != u)
                {
                    SendMessageA(hwnd,
                                WM_DMT_UPDATE_LISTS,
                                0,
                                0L);
                }
            }
            break;

        case IDC_SUBGENRES:
#ifndef DDKAPP
            // check for selection change
            if(CBN_DROPDOWN == wNotifyCode)
            {
                // memorize current selection
                uSubSel = SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRES),
                                        CB_GETCURSEL,
                                        0,
                                        0L);
            }
            if(CBN_SELCHANGE == wNotifyCode)
            {
                // selection changed
                //
                // get the new selection
                u = SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRES),
                                CB_GETCURSEL,
                                0,
                                0L);

                if(uSubSel != u)
                {
                    // clear the device combo box
                    SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_LIST),
                                CB_RESETCONTENT,
                                0,
                                0L);

                    // release device list
                    dmtinputFreeDeviceList(&(pdmtai->pDeviceList));

                    // release the mapping lists for each subgenre
                    dmtcfgFreeAllMappingLists(pdmtai->pGenreList);

                    // disable appropriate controls
                    dimaptstPostEnumEnable(hwnd, FALSE);
                }
            }
#endif
            break;

        case IDC_ENUM_DEVICES:
            // ISSUE-2001/03/29-timgill Long conditional branch
            // should really make a sep. fn
/*
#ifdef DDKAPP
            // we only want to enumerate all gaming 
            //  devices if we are the DDK tool
            fEnumSuitable = FALSE;
#else            
*/
            fEnumSuitable = TRUE;

            u = SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRES),
                            CB_GETCURSEL,
                            0,
                            0L);
            pSubGenre = (DMTSUBGENRE_NODE*)SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRES),
                                                    CB_GETITEMDATA,
                                                    u,
                                                    0L);
            if(!pSubGenre)
            {
                 // ISSUE-2001/03/29-timgill Needs error case handling
            }
//#endif
            // first, free the existing device list
            hRes = dmtinputFreeDeviceList(&(pdmtai->pDeviceList));
            if(FAILED(hRes))
            {
                // ISSUE-2001/03/29-timgill Needs error case handling
            }

            // then, flush the combo box
            SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_LIST),
                        CB_RESETCONTENT,
                        0,
                        0L);

            // now, re-create the device list
            hRes = dmtinputCreateDeviceList(hwnd,
                                            fEnumSuitable,
                                            pSubGenre,
                                            &(pdmtai->pDeviceList));
            if(FAILED(hRes))
            {
                   // ISSUE-2001/03/29-timgill Needs error case handling
            }

            // free the existing mapping lists
            dmtcfgFreeAllMappingLists(pdmtai->pGenreList);

            // create the mapping lists within the subgenres
            hRes = dmtcfgCreateAllMappingLists(pdmtai);
            if(FAILED(hRes))
            {
                    // ISSUE-2001/03/29-timgill Needs error case handling
            }
            
            // populate the devices control
            pDevice = pdmtai->pDeviceList;
            while(pDevice)
            {
                // add device name
                nIdx = SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_LIST),
                                    CB_ADDSTRING,
                                    0,
                                    (LPARAM)&(pDevice->szName));
                
                // add device node to item data
                SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_LIST),
                        CB_SETITEMDATA,
                        nIdx,
                        (LPARAM)pDevice);

                // next device
                pDevice = pDevice->pNext;
            }

            // select the 1st entry
            SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_LIST),
                        CB_SETCURSEL,
                        0,
                        0L);

            // enable appropriate ui elements
            dimaptstPostEnumEnable(hwnd, TRUE);
            break;

#ifdef TESTAPP
        //***************************************
        // Internal app specific message handling
        //***************************************
        case IDC_VERIFY_MANUAL:
        case IDC_VERIFY_AUTOMATIC:
            // enable/disable manual override option
            fEnable = (BOOL)(IDC_VERIFY_MANUAL - dmtGetCheckedRadioButton(hwnd, 
                                        IDC_VERIFY_AUTOMATIC, 
                                        IDC_VERIFY_MANUAL));
            EnableWindow(GetDlgItem(hwnd, IDC_VERIFY_MANUAL_OVERRIDE), fEnable);

            break;
        
        case IDC_STRESS_MODE:
            // expand/shrink dialog
            nHeight = IsDlgButtonChecked(hwnd, IDC_STRESS_MODE) ? 490 : 361;
            SetWindowPos(hwnd,
                        HWND_TOP,
                        0, 0,
                        nWidth, nHeight,
                        SWP_NOMOVE | SWP_NOOWNERZORDER);

            // enable / disable stress configuration & launch
            fEnable = (BOOL)IsDlgButtonChecked(hwnd, IDC_STRESS_MODE);
           // EnableWindow(GetDlgItem(hwnd, IDC_CONFIGURE),    fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_STRESS_START),        fEnable);
            break;       
#endif // TESTAPP


#ifdef DDKAPP
        case IDC_LAUNCH_CPL_EDIT_MODE:
            // get the currently selected device?
            nIdx = SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_LIST),
                            CB_GETCURSEL,
                            0,
                            0L);
            if (nIdx == CB_ERR)
            {
                // Error has occurred. Most likely no device is available.
                MessageBox(hwnd, "No device selected.", "Error", MB_OK);
                return TRUE;
            }
            pDevice = (DMTDEVICE_NODE*)SendMessageA(GetDlgItem(hwnd, 
                                                            IDC_DEVICE_LIST),
                                                CB_GETITEMDATA,
                                                nIdx,
                                                0L);
            if(!pDevice)
            {
                // ISSUE-2001/03/29-timgill Needs error case handling
            }

            

            // launch the mapper cpl in edit mode
            hRes = dmttestRunMapperCPL(hwnd,
                                    TRUE);
            if(FAILED(hRes))
            {
                // ISSUE-2001/03/29-timgill Needs error case handling
            }

            break;
#endif // DDKAPP

    }
 
    // done
    return FALSE;

} //*** end dimaptstOnCommand()


//===========================================================================
// dimaptstOnTimer
//
// Handles WM_TIMER messages for the main app dialog
//
// Parameters:
//
// Returns: BOOL
//
// History:
//  11/02/1999 - davidkl - created
//===========================================================================
BOOL dimaptstOnTimer(HWND hwnd,
                    WPARAM wparamTimerId)
{
    //int             nSel        = -1;
	//JJ 64Bit Compat
	LONG_PTR		nSel		= -1;
    DMTDEVICE_NODE  *pDevice    = NULL;

    DPF(5, "dimaptstOnTimer - ID == %d",
        wparamTimerId);

    if(ID_POLL_TIMER == wparamTimerId)
    {
        // get the current device
        nSel = SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_LIST),
                            CB_GETCURSEL,
                            0,
                            0L);
        if(-1 == nSel)
        {
            DPF(0, "dimaptstOnTimer - invalid device selection");
            return FALSE;
        }
        pDevice = (DMTDEVICE_NODE*)SendMessageA(GetDlgItem(hwnd, 
                                                        IDC_DEVICE_LIST),
                                            CB_GETITEMDATA,
                                            nSel,
                                            0L);
        if(!pDevice)
        {
            DPF(0, "dimaptstOnTimer - failed to retrieve device node");
            return FALSE;
        }

        // get data from the device
		//JJ Removed
        //dmttestGetInput(hwnd,
          //              pDevice);
    }

    // done
    return FALSE;
    
} //*** end dimaptstOnTimer()


//===========================================================================
// dimaptstOnUpdateLists
//
// Updates the subgenre list in response to a genre bucket change
//
// NOTE: INTERNAL only - This also clears the devices list, frees
//  all associated linked lists and performs some window enabling/disabling
//  tasks.
//
// Parameters:
//  HWND    hwnd    - handle to app window
//
// Returns: BOOL
//
// History:
//  10/01/1999 - davidkl - created
//===========================================================================
BOOL dimaptstOnUpdateLists(HWND hwnd)
{
	//JJ 64Bit Compat
	UINT_PTR			uSel		= 0;
    DMTGENRE_NODE       *pGenre     = NULL;
    DMTSUBGENRE_NODE    *pSubNode   = NULL;
    DMT_APPINFO         *pdmtai     = NULL;

    // get the genre bucket node
    uSel = SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_GENRES),
                    CB_GETCURSEL,
                    0,
                    0L);
    pGenre = (DMTGENRE_NODE*)SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_GENRES),
                                        CB_GETITEMDATA,
                                        uSel,
                                        0L);
    if(!pGenre)
    {
        // this is bad
        DebugBreak();
        return TRUE;
    }

    // clear the existing list contents
    SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRES),
                CB_RESETCONTENT,
                0, 
                0L);

    // update (sub)genres list
    pSubNode = pGenre->pSubGenreList;
    while(pSubNode)
    {
        uSel = SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRES),
                        CB_ADDSTRING,
                        0,
                        (LPARAM)(pSubNode->szName));
        SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRES),
                    CB_SETITEMDATA,
                    uSel,
                    (LPARAM)pSubNode);

        // next subgenre
        pSubNode = pSubNode->pNext;
    }
    
    // select the first list entry
    SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRES),
                CB_SETCURSEL,
                0,
                0L);

#ifndef DDKAPP
    //============================================
    // only do this part for SDK and INTERNAL apps
    //============================================

    // get the device list
    pdmtai = (DMT_APPINFO*)GetWindowLong(hwnd,
                                        GWL_USERDATA);
    if(!pdmtai)
    {
       // ISSUE-2001/03/29-timgill Needs error case handling
    }

    // clear the device combo box
    SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_LIST),
                CB_RESETCONTENT,
                0,
                0L);

    // release device list
    dmtinputFreeDeviceList(&(pdmtai->pDeviceList));

    // release the mapping lists for each subgenre
    dmtcfgFreeAllMappingLists(pdmtai->pGenreList);

    // disable appropriate controls
    dimaptstPostEnumEnable(hwnd, FALSE);

#endif

    // done
    return FALSE;

} //*** end dimaptstOnUpdateLists()



//===========================================================================
// dmtGetCheckedRadioButton
//
// Returns the checked radio button in a group.
//
// Parameters:
//
// Returns: 
//
// History:
//  08/25/1998 - davidkl - created (copied from dmcs sources)
//===========================================================================
UINT dmtGetCheckedRadioButton(HWND hWnd, 
                            UINT uCtrlStart, 
                            UINT uCtrlStop)
{
    UINT uCurrent   = 0;

    for(uCurrent = uCtrlStart; uCurrent <= uCtrlStop; uCurrent++)
    {
        if(IsDlgButtonChecked(hWnd, uCurrent))
        {
            return uCurrent;
        }
    }

    // if we get here, none were checked
    return 0;

} //*** end dmtGetCheckedRadioButton()


//===========================================================================
// dimaptstPostEnumEnable
//
// Enables/disables main app UI elements in response to enumerating devices
//
// Parameters:
//  HWND    hwnd    - main app window handle
//  BOOL    fEnable - enable or disable controls
//
// Returns: nothing
//
// History:
//  10/01/1999 - davidkl - created
//===========================================================================
void dimaptstPostEnumEnable(HWND hwnd,
                            BOOL fEnable)
{
    UINT    u   = 0;

    // devices list
    EnableWindow(GetDlgItem(hwnd, IDC_DEVICES_LABEL), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_DEVICE_LIST), fEnable);

	//JJ UI FIX
    // test controls
    //for(u = IDC_TEST_CTRL_GROUP; u <= IDC_USE_CPL; u++)
    //{
    //    EnableWindow(GetDlgItem(hwnd, u), fEnable);
   // }

 // ISSUE-2000/02/21-timgill disable integration control and start button for the preview
 // should be re-enabled once test mode code is fixed
 //   EnableWindow(GetDlgItem(hwnd, IDC_USE_INTEGRATED), FALSE);
    // start button
//    EnableWindow(GetDlgItem(hwnd, IDOK), fEnable);

#ifdef DDKAPP
            // mapping file group
            for(u = IDC_MAPPING_FILE_GROUP; u <= IDC_LAUNCH_CPL_EDIT_MODE; u++)
            {
                EnableWindow(GetDlgItem(hwnd, u), TRUE);
            }
#else
    #ifdef TESTAPP
            // verification mode
            for(u = IDC_VERIFY_GROUP; u <= IDC_VERIFY_MANUAL; u++)
            {
                EnableWindow(GetDlgItem(hwnd, u), TRUE);
            }

            // this will enable the manual overrride option as appropriate
            SendMessageA(hwnd,
                        WM_COMMAND,
                        IDC_VERIFY_AUTOMATIC,
                        0L);

            // this will enable the configuration button and 
            //  expand the application window as appropriate
            SendMessageA(hwnd,
                        WM_COMMAND,
                        IDC_STRESS_MODE,
                        0L);

    #endif
#endif

} //*** end dimaptstPostEnumEnable()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtfail.h ===
//===========================================================================
// dmtfail.h
//
// History:
//  10/11/1999 - davidkl - created
//===========================================================================

#ifndef _DMTFAIL_H
#define _DMTFAIL_H

//---------------------------------------------------------------------------

// prototypes
/*BOOL*/INT_PTR CALLBACK dmtfailDlgProc(HWND hwnd,
                            UINT uMsg,
                            WPARAM wparam,
                            LPARAM lparam);
BOOL dmtfailOnInitDialog(HWND hwnd, 
                        HWND hwndFocus, 
                        LPARAM lparam);
BOOL dmtfailOnCommand(HWND hwnd,
                    WORD wId,
                    HWND hwndCtrl,
                    WORD wNotifyCode);

//---------------------------------------------------------------------------
#endif // _DMTFAIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtcfg.h ===
//===========================================================================
// dmtcfg.h
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================

#ifndef _DMTCFG_H
#define _DMTCFG_H

//---------------------------------------------------------------------------

// property sheet "Apply" button ID
#define IDC_PS_APPLY    0x3021

//---------------------------------------------------------------------------

// prototypes
HRESULT dmtcfgCreatePropertySheet(HINSTANCE hinst, 
                                HWND hwndParent,
                                LPSTR szSelectedGenre,
                                DMTGENRE_NODE *pGenreList,
                                DMTDEVICE_NODE *pDeviceNode,
                                BOOL fStartWithDefaults);
BOOL CALLBACK dmtcfgDlgProc(HWND hwnd,
                            UINT uMsg,
                            WPARAM wparam,
                            LPARAM lparam);
BOOL dmtcfgOnInitDialog(HWND hwnd, 
                        HWND hwndFocus, 
                        LPARAM lparam);
BOOL dmtcfgOnCommand(HWND hwnd,
                    WORD wId,
                    HWND hwndCtrl,
                    WORD wNotifyCode);
BOOL dmtcfgOnNotify(HWND hwnd,
                    PSHNOTIFY *pNotify);
BOOL dmtcfgOnUpdateLists(HWND hwnd);
BOOL dmtcfgOnFileSave(HWND hwnd);
BOOL CALLBACK dmtcfgSourceDlgProc(HWND hwnd,
                                UINT uMsg,
                                WPARAM wparam,
                                LPARAM lparam);
BOOL dmtcfgSourceOnInitDialog(HWND hwnd, 
                            HWND hwndFocus, 
                            LPARAM lparam);
BOOL dmtcfgSourceOnCommand(HWND hwnd,
                        WORD wId,
                        HWND hwndCtrl,
                        WORD wNotifyCode);
BOOL dmtcfgSourceOnUpdateLists(HWND hwnd);
HRESULT dmtcfgCreateGenreList(DMTGENRE_NODE **ppdmtgList);
HRESULT dmtcfgFreeGenreList(DMTGENRE_NODE **ppdmtgList);
HRESULT dmtcfgCreateSubGenreList(LPSTR szGenre,
                                DMTSUBGENRE_NODE **ppdmtsgList);
HRESULT dmtcfgFreeSubGenreList(DMTSUBGENRE_NODE **ppdmtsgList);
HRESULT dmtcfgCreateActionList(LPSTR szGenreSubgenre,
                            DMTACTION_NODE **ppdmtaList);
HRESULT dmtcfgFreeActionList(DMTACTION_NODE **ppdmtaList);
HRESULT dmtcfgCreateMappingList(DMTDEVICE_NODE *pDevice,
                                DMTACTION_NODE *pActions,
                                DMTMAPPING_NODE **ppdmtmList);
HRESULT dmtcfgFreeMappingList(DMTMAPPING_NODE **ppdmtmList);
HRESULT dmtcfgCreateAllMappingLists(DMT_APPINFO *pdmtai);
HRESULT dmtcfgFreeAllMappingLists(DMTGENRE_NODE *pdmtgList);
HRESULT dmtcfgMapAction(HWND hwnd,
                        REFGUID guidInstance,
                        DIACTIONA *pdia,
                        UINT uActions);
HRESULT dmtcfgUnmapAction(HWND hwnd,
                        DIACTIONA *pdia,
                        UINT uActions);
HRESULT dmtcfgUnmapAllActions(HWND hwnd,
                            DIACTIONA *pdia,
                            UINT uActions);
BOOL dmtcfgIsControlMapped(HWND hwnd,
                        DIACTIONA *pdia,
                        UINT uActions);
BOOL dmtcfgAreAnyControlsMapped(HWND hwnd,
                                DIACTIONA *pdia,
                                UINT uActions);
HRESULT dmtcfgGetGenreGroupName(PSTR szGenreName,
                                PSTR szGenreGroupName);


//---------------------------------------------------------------------------
#endif // _DMTCFG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmterror.h ===
//===========================================================================
// dmterror.h
//
// Custom error messages for the DIMapTst project
// 
// History:
//  09/29/1999 - davidkl - created
//===========================================================================

#ifndef _DMTERROR_H
#define _DMTERROR_H

#include <objbase.h>

//---------------------------------------------------------------------------
// macros to create HRESULT codes
//---------------------------------------------------------------------------

// facility code for HRESULTS
//
// D15 == DirectInputSemantic
#define DMT_FACILITY_CODE       0xD15

// create success code
#define MAKE_DMT_HRSUCCESS(n)   MAKE_HRESULT(0, DMT_FACILITY_CODE, n)

// create failure code
#define MAKE_DMT_HRFAILURE(n)   MAKE_HRESULT(1, DMT_FACILITY_CODE, n)

//---------------------------------------------------------------------------
// custom return codes for DIMapTst
//---------------------------------------------------------------------------
// success
#define DMT_S_MEMORYLEAK            MAKE_DMT_HRSUCCESS(0)
#define DMT_S_NO_MAPPINGS           MAKE_DMT_HRSUCCESS(1)
// -- values intentionally skipped --
#define DMT_S_FILE_ALMOST_TOO_BIG   MAKE_DMT_HRSUCCESS(4)
// failure
#define DMT_E_NO_MATCHING_MAPPING   MAKE_DMT_HRFAILURE(0)
#define DMT_E_INPUT_CREATE_FAILED   MAKE_DMT_HRFAILURE(1)
#define DMT_E_FILE_WRITE_FAILED     MAKE_DMT_HRFAILURE(2)
#define DMT_E_FILE_READ_FAILED      MAKE_DMT_HRFAILURE(3)
#define DMT_E_FILE_TOO_BIG          MAKE_DMT_HRFAILURE(4)

//---------------------------------------------------------------------------
#endif // _DMTERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtcfg.cpp ===
//===========================================================================
// dmtcfg.cpp
//
// File / code creation functionality
//
// Functions:
//  dmtcfgCreatePropertySheet
//  dmtcfgDlgProc
//  dmtcfgOnInitDialog
//  dmtcfgOnClose
//  dmtcfgOnCommand
//  dmtcfgOnNotify
//  dmtcfgCreateGenreList
//  dmtcfgFreeGenreList
//  dmtcfgCreateSubGenreList
//  dmtcfgFreeSubGenreList
//  dmtcfgCreateActionList
//  dmtcfgFreeActionList
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================

#include "dimaptst.h"
#include "dmtinput.h"
//#include "dmtwrite.h"
#include "dmtcfg.h"

//---------------------------------------------------------------------------


//===========================================================================
// dmtcfgCreatePropertySheet
//
// Create property sheet dialog for device action map configuration
//
// Parameters:
//  HINSTANCE   hinst           - app instance handle
//  HWND        hwndParent      - parent window handle
//  LPSTR       szSelectedGenre 
//  DMTGENRE_NODE*   pGenreList
//  DMTGENRE_NODE*   pDeviceNode
//  BOOL        fStartWithDefaults
//
// Returns: HRESULT
//
// History:
//  08/23/1999 - davidkl - created
//  09/08/1999 - davidkl - changed param list
//===========================================================================
HRESULT dmtcfgCreatePropertySheet(HINSTANCE hinst, 
                                HWND hwndParent,
                                LPSTR szSelectedGenre,
                                DMTGENRE_NODE *pGenreList,
                                DMTDEVICE_NODE *pDeviceNode,
                                BOOL fStartWithDefaults)
{
    HRESULT             hRes        = S_OK;
    UINT                u           = 0;
    UINT                uSel        = 0;
    DMTGENRE_NODE       *pNode      = NULL;
    PROPSHEETPAGEA      *pPages     = NULL;
    PROPSHEETHEADERA    psh;
    char                szCaption[MAX_PATH];
    DMT_APPINFO         *pdmtai     = NULL;
    DMTDEVICE_NODE      dmtd;

    // validate pGenreList
    if(IsBadReadPtr((void*)pGenreList, sizeof(DMTGENRE_NODE)))
    {
        DPF(0, "dmtcfgCreatePropertySheet - invalid pGenreList (%016Xh)",
            pGenreList);
        return E_POINTER;
    }

    // validate pDeviceNode
    if(IsBadReadPtr((void*)pDeviceNode, sizeof(DMTDEVICE_NODE)))
    {
        DPF(0, "dmtcfgCreatePropertySheet - invalid pDeviceNode (%016Xh)",
            pDeviceNode);
        return E_POINTER;
    }

    __try
    {
        // count the genres
        //
        // find the node we care about
        u = 0;
        pNode = pGenreList;
        while(pNode)
        {
            // if we find our genre, start on that page
            if(!lstrcmpiA(szSelectedGenre, pNode->szName))
            {
                uSel = u;    
            }

            // increment the number of genres
            u++;

            pNode = pNode->pNext;
        }

        // allocate the page array (dw pages)
        pPages = (PROPSHEETPAGEA*)LocalAlloc(LMEM_FIXED,
                                        sizeof(PROPSHEETPAGEA) * u);
        if(!pPages)
        {
            DPF(0, "dmtcfgCreatePropertySheet - insufficient mempory to "
                "allocate pPages array");
            hRes = E_OUTOFMEMORY;
            __leave;
        }

        // add device name to caption
        wsprintfA(szCaption, 
                "Configure Device Action Map - %s",
                pDeviceNode->szName);


        // strip the next ptr from the selected device node
        CopyMemory((void*)&dmtd, (void*)pDeviceNode, sizeof(DMTDEVICE_NODE));
        dmtd.pNext = NULL;

        // allocate app info data struct for pages
        pdmtai = (DMT_APPINFO*)LocalAlloc(LMEM_FIXED,
                                        u * sizeof(DMT_APPINFO));
		if(!pdmtai)
		{
			hRes = E_OUTOFMEMORY;
			__leave;
		}

		ZeroMemory((void*)pdmtai, u * sizeof(DMT_APPINFO));

        // prepare property sheet header
	    psh.dwSize              = sizeof(PROPSHEETHEADERA);
	    psh.dwFlags             = PSH_PROPSHEETPAGE     | 
                                PSP_USETITLE | PSH_NOAPPLYNOW;
	    psh.hwndParent          = hwndParent;
	    psh.hInstance           = hinst;
	    psh.pszCaption          = szCaption;
	    psh.nPages              = u;
	    psh.nStartPage			= uSel;
	    psh.ppsp                = pPages;

        // describe sheets  
        pNode = pGenreList;
        for(u = 0; u < (DWORD)(psh.nPages); u++)
        {
            if(!pNode)
            {
                DPF(0, "dmtcfgCreatePropertySheet - we messed up! "
                    "we allocated less than %d pages",
                    psh.nPages);
                DPF(0, "PLEASE find someone to look at this NOW");
                hRes = E_UNEXPECTED;
                DebugBreak();
                __leave;
            }

            // populate the app info for the page
            (pdmtai + u)->pGenreList            = pNode;
            (pdmtai + u)->pDeviceList           = &dmtd;
            (pdmtai + u)->fStartWithDefaults    = fStartWithDefaults;
            (pdmtai + u)->fLaunchCplEditMode    = FALSE;

            // populate the page array entry
            ZeroMemory((void*)(pPages + u), sizeof(PROPSHEETPAGEA));
	        (pPages + u)->dwSize        = sizeof(PROPSHEETPAGEA);
			(pPages + u)->dwFlags       = PSP_USETITLE;
    	    (pPages + u)->hInstance     = hinst;
    	    (pPages + u)->pszTemplate   = MAKEINTRESOURCEA(IDD_CONFIGURE_MAPPING_PAGE);
    	    (pPages + u)->pfnDlgProc    = (DLGPROC)dmtcfgDlgProc;
            (pPages + u)->pszTitle      = pNode->szName;
            (pPages + u)->lParam        = (LPARAM)(pdmtai + u);

            // next node
            pNode = pNode->pNext;
        }

        // create this thing
        if(0 > PropertySheetA(&psh))
        {
            DPF(0, "dmtcfgCreatePropertySheet - dialog creation failed (%08Xh)",
                GetLastError());
            hRes = E_UNEXPECTED;
            __leave;
        }
    }
    __finally
    {
        // free the app info array
        if(pdmtai)
        {
            if(LocalFree((HLOCAL)pdmtai))
            {
                DPF(0, "dmtcfgCreaatePropertySheet - !!!MEMORY LEAK!!! "
                    "LocalFree(pdmtai) failed (%08X)",
                    GetLastError());
                hRes = S_FALSE;
            }
            pdmtai = NULL;
        }

        // free the page array
        if(pPages)
        {
            if(LocalFree((HLOCAL)pPages))
            {
                DPF(0, "dmtcfgCreaatePropertySheet - !!!MEMORY LEAK!!! "
                    "LocalFree(pPages) failed (%08X)",
                    GetLastError());
                hRes = S_FALSE;
            }
            pPages = NULL;
        }

    }

    // done
    return hRes;

} //*** end dmtcfgCreatePropertySheet()



//===========================================================================
// dmtcfgDlgProc
//
// Configure Device Action Map dialog processing function
//
// Parameters: (see SDK help for parameter details)
//  HWND    hwnd
//  UINT    uMsg
//  WPARAM  wparam
//  LPARAM  lparam
//
// Returns: (see SDK help for return value details)
//  BOOL
//
// History:
//  08/20/1999 - davidkl - created  
//===========================================================================
BOOL CALLBACK dmtcfgDlgProc(HWND hwnd,
                            UINT uMsg,
                            WPARAM wparam,
                            LPARAM lparam)
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
            return dmtcfgOnInitDialog(hwnd, 
                                    (HWND)wparam, 
                                    lparam);

        case WM_COMMAND:
            return dmtcfgOnCommand(hwnd,
                                    LOWORD(wparam),
                                    (HWND)lparam,
                                    HIWORD(wparam));

        case WM_NOTIFY:
            return dmtcfgOnNotify(hwnd,
                                (PSHNOTIFY *)lparam);

        case WM_DMT_UPDATE_LISTS:
            return dmtcfgOnUpdateLists(hwnd);

        }

    return FALSE;

} //*** end dmtcfgDlgProc()


//===========================================================================
// dmtcfgOnInitDialog
//
// Handle WM_INITDIALOG processing for the config device box
//
// Parameters:
//  HWND    hwnd        - handle to property page
//  HWND    hwndFocus   - handle of ctrl with focus
//  LPARAM  lparam      - user data (in this case, PROPSHEETPAGE*)
//
// Returns: BOOL
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================
BOOL dmtcfgOnInitDialog(HWND hwnd, 
                        HWND hwndFocus, 
                        LPARAM lparam)
{
    HRESULT             hRes        = S_OK;
    PROPSHEETPAGEA      *ppsp       = (PROPSHEETPAGEA*)lparam;
    DMTGENRE_NODE       *pGenre     = NULL;
    DMTSUBGENRE_NODE    *pSubNode   = NULL;
    DMTMAPPING_NODE     *pMapNode   = NULL;
    //LONG                lPrev       = 0L;
	//JJ 64Bit Compat
	LONG_PTR			lPrev		= 0;
   // int                 nIdx        = 0;
	LONG_PTR			nIdx		= 0;
    DMTDEVICE_NODE      *pDevice    = NULL;
    DMT_APPINFO         *pdmtai     = NULL;
    UINT                u           = 0;
    WORD                wTypeCtrl   = 0;
    DIACTIONFORMATA     diaf;
    
    DPF(5, "dmtcfgOnInitDialog");

    // validate ppsp (lparam)
    if(IsBadWritePtr((void*)ppsp, sizeof(PROPSHEETPAGEA)))
    {
        DPF(0, "dmtcfgOnInitDialog - invalid lParam (%016Xh)",
            ppsp);
        return FALSE;
    }

    // pdmtai == ppsp->lParam
    pdmtai = (DMT_APPINFO*)(ppsp->lParam);

    // validate pdmtai
    if(IsBadWritePtr((void*)pdmtai, sizeof(DMT_APPINFO)))
    {
        DPF(0, "dmtcfgOnInitDialog - invalid ppsp.ptp (%016Xh)",
            pdmtai);
        return FALSE;
    }

    // pGenre == pdmtai->pGenreList
    pGenre = pdmtai->pGenreList;

    // valdiate pGenre
    if(IsBadWritePtr((void*)pGenre, sizeof(DMTGENRE_NODE)))
    {
        DPF(0, "dmtcfgOnInitDialog - invalid pGenre (%016Xh)",
            pGenre);
        return FALSE;
    }

    // pDevice == pdmtai->pDeviceList
    pDevice = pdmtai->pDeviceList;
    // valdiate pGenre
    if(IsBadWritePtr((void*)pDevice, sizeof(DMTDEVICE_NODE)))
    {
        DPF(0, "dmtcfgOnInitDialog - invalid pDevice (%016Xh)",
            pDevice);
        return FALSE;
    }

    // change the property sheet dialog button text
    // Ok -> Save
    SetWindowTextA(GetDlgItem(GetParent(hwnd), IDOK),
                "&Save");
    // Apply -> Load
    //SetWindowTextA(GetDlgItem(GetParent(hwnd), IDC_PS_APPLY),
    //              "Load");
    // Cancel -> Close
    SetWindowTextA(GetDlgItem(GetParent(hwnd), IDCANCEL),
                "&Close");

    __try
    {
        // store the app info in the property page's user data
        SetLastError(0);
        //lPrev = SetWindowLong(hwnd, 
          //                  GWL_USERDATA, 
            //                (LONG)pdmtai);
		//JJ 64Bit Compat
		lPrev = SetWindowLongPtr(hwnd, 
								 GWLP_USERDATA, 
								(LONG_PTR)pdmtai);
        if(!lPrev && GetLastError())
        {
            // serious app problem.  
            //  we need to stop things right here and now
            DPF(0, "dmtcfgOnInitDialog - This is bad... "
                "We failed to store pdmtai");
            DPF(0, "dmtcfgOnInitDialog  - Please find someone "
                "to look at this right away");
            DebugBreak();
            hRes = E_FAIL;
            __leave;
        }

        // walk the list and populate the subgenre list box
        //
        // store the ptr to the subgenre node in the listbox 
        //  entry user data
        pSubNode = pGenre->pSubGenreList;
        while(pSubNode)
        {
            // add the subgenre name to the list
            nIdx = SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRE),
                                CB_ADDSTRING,
                                0,
                                (LPARAM)(pSubNode->szName));
        
            // store the subgenre node in the list entry
            SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRE),
                        CB_SETITEMDATA,
                        nIdx,
                        (LPARAM)pSubNode);

            // if the user has requested default mappings
            //  get them for the specified device
            if(pdmtai->fStartWithDefaults)
            {
                // walk the mappings list until the selected
                //  device is found
                pMapNode = pSubNode->pMappingList;
                while(pMapNode)
                {
                    // try to match on guidInstance
                    if(IsEqualGUID(pDevice->guidInstance,
                                pMapNode->guidInstance))
                    {
                        // match found
                        break;
                    }

                    // next mapping
                    pMapNode = pMapNode->pNext;
                }
                
                if(pMapNode)
                {
                    ZeroMemory((void*)&diaf, sizeof(DIACTIONFORMATA));
                    diaf.dwSize                 = sizeof(DIACTIONFORMATA);
                    diaf.dwActionSize           = sizeof(DIACTIONA);
                    diaf.dwNumActions           = (DWORD)(pMapNode->uActions);
                    diaf.rgoAction              = pMapNode->pdia;
                    diaf.dwDataSize             = 4 * diaf.dwNumActions;
                    diaf.guidActionMap          = GUID_DIMapTst;
                    diaf.dwGenre                = pSubNode->dwGenreId;
                    diaf.dwBufferSize           = DMTINPUT_BUFFERSIZE;
                    lstrcpyA(diaf.tszActionMap, DMT_APP_CAPTION);

                    // get the default mappings
                    hRes = (pDevice->pdid)->BuildActionMap(&diaf,
                                                        (LPCSTR)NULL,
                                                        DIDBAM_HWDEFAULTS);
                    if(FAILED(hRes))
                    {
                       // ISSUE-2001/03/29-timgill Needs error case handling
                    }
                }
                else
                {
                    // ISSUE-2001/03/29-timgill needs error handling
                }

            }

            // next subgenre
            pSubNode = pSubNode->pNext;
        }

        // set the subgenre list selection
        SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRE),
                    CB_SETCURSEL,
                    0,
                    0);

        // selectively disable axis/button/pov radio buttons
        //
        // this is done if the selected device does not
        //  actually have one of these objects
        //
        // since axes are our "prefered" initial display
        //  option, check them last
        if(dmtinputDeviceHasObject(pDevice->pObjectList,
                                        DMTA_TYPE_POV))
        {
            EnableWindow(GetDlgItem(hwnd, IDC_TYPE_POV), TRUE);
            wTypeCtrl = IDC_TYPE_POV;
        }
        if(dmtinputDeviceHasObject(pDevice->pObjectList,
                                        DMTA_TYPE_BUTTON))
        {
            EnableWindow(GetDlgItem(hwnd, IDC_TYPE_BUTTON), TRUE);
            wTypeCtrl = IDC_TYPE_BUTTON;
        }
        if(dmtinputDeviceHasObject(pDevice->pObjectList,
                                        DMTA_TYPE_AXIS))
        {
            EnableWindow(GetDlgItem(hwnd, IDC_TYPE_AXIS), TRUE);
            wTypeCtrl = IDC_TYPE_AXIS;
        }


        // select the axes radio button
        if(0 == wTypeCtrl)
        {
            // we have a "device" that has no objects...
            //
            // this is very bad
            DebugBreak();
            return TRUE;
        }

        CheckRadioButton(hwnd,
                        IDC_TYPE_POV,
                        IDC_TYPE_AXIS,
                        wTypeCtrl);

        // for the default subgenre, walk the list and populate 
        //  the actions list box
        //
        // store the ptr to the actions node in the listbox 
        //  entry user data
        pSubNode = (DMTSUBGENRE_NODE*)SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRE),
                                                CB_GETITEMDATA,
                                                0,
                                                0L);

        // update the lists
        SendMessageA(hwnd,
                    WM_DMT_UPDATE_LISTS,
                    0,
                    0L);

        // select the first entry in each list
        SendMessageA(GetDlgItem(hwnd, IDC_CONTROLS),
                    LB_SETCURSEL,
                    0,
                    0L);
        SendMessageA(GetDlgItem(hwnd, IDC_ACTIONS),
                    LB_SETCURSEL,
                    0,
                    0L);

        // display the subgenre description
        SetDlgItemTextA(hwnd,
                        IDC_DESCRIPTION,
                        pSubNode->szDescription);

        // make sure the map/unmap buttons are enabled correctly
        SendMessageA(hwnd,
                    WM_COMMAND,
                    IDC_CONTROLS,
                    0L);

    }
    __finally
    {
        // if failure case, clean house
        if(FAILED(hRes))
        {
            // ISSUE-2001/03/29-timgill Needs error case handling
        }
    }
    
    // done
    return TRUE;

} //*** end dmtcfgOnInitDialog()


//===========================================================================
// dmtcfgOnCommand
//
// Handle WM_COMMAND processing for the config device box
//
// Parameters:
//  HWND    hwnd        - handle to property page
//  WORD    wId         - control identifier    (LOWORD(wparam))
//  HWND    hwndCtrl    - handle to control     ((HWND)lparam)
//  WORD    wNotifyCode - notification code     (HIWORD(wparam))
//
// Returns: BOOL
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================
BOOL dmtcfgOnCommand(HWND hwnd,
                    WORD wId,
                    HWND hwndCtrl,
                    WORD wNotifyCode)
{
    HRESULT             hRes            = S_OK;
   // UINT                uSel            = 0; 
	//JJ 64Bit Compat
	UINT_PTR			uSel			= 0;
    UINT                uActions        = 0;   
    BOOL                fEnable         = FALSE;
    DMT_APPINFO         *pdmtai         = NULL;
    DMTSUBGENRE_NODE    *pSubGenre      = NULL;
    DMTMAPPING_NODE     *pMapping       = NULL;
    DIACTIONA           *pdia           = NULL;

	DPF(5, "dmtcfgOnCommand");

    // get the window data   
    //pdmtai = (DMT_APPINFO*)GetWindowLong(hwnd, GWL_USERDATA);
	//JJ 64Bit Compat
	pdmtai = (DMT_APPINFO*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(!pdmtai)
    {
        // big problem
        //
        // this should NEVER happen
       // ISSUE-2001/03/29-timgill Needs error case handling
    }

    // what is the currently selected subgenre?
    uSel = SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRE),
                    CB_GETCURSEL,
                    0,
                    0L);
    pSubGenre = (DMTSUBGENRE_NODE*)SendMessageA(GetDlgItem(hwnd, 
                                                        IDC_SUBGENRE),
                                            CB_GETITEMDATA,
                                            uSel,
                                            0L);
    if(!pSubGenre)
    {
        // big problem
        //
        // this should NEVER happen
        // ISSUE-2001/03/29-timgill Needs error case handling
    }

    // get the active DIACTION array
    pMapping = pSubGenre->pMappingList;
    while(pMapping)
    {
        // match pdmtai->pDeviceList->guidInstance with
        //  pMapping->guidInstance
        if(IsEqualGUID(pdmtai->pDeviceList->guidInstance,
                    pMapping->guidInstance))
        {
            break;
        }

        // next mapping
        pMapping = pMapping->pNext;
    }

    if(pMapping)
    {
        pdia = pMapping->pdia;
        uActions = pMapping->uActions;
    }

    // update genre description
    SetDlgItemTextA(hwnd,
                    IDC_DESCRIPTION,
                    pSubGenre->szDescription);

    switch(wId)
    {
        case IDC_SUBGENRE:
            // based on the selected subgenre
            //
            // display the objects/actions for the selected type
            //  (see type IDs below)
            if(CBN_SELCHANGE == wNotifyCode)
            {
                // update the lists
                SendMessageA(hwnd,
                            WM_DMT_UPDATE_LISTS,
                            0,
                            0L);                            
            }
            break;

        case IDC_TYPE_AXIS:
        case IDC_TYPE_BUTTON:
        case IDC_TYPE_POV:
            // update the lists
            SendMessageA(hwnd,
                        WM_DMT_UPDATE_LISTS,
                        0,
                        0L);   
            // make sure the unmap button is selected as appropriate
            SendMessageA(hwnd,
                        WM_COMMAND,
                        IDC_CONTROLS,
                        0L);
            break;

        case IDC_CONTROLS:
            // if a mapped action is selected
            //  enable the "Unmap action" button
            fEnable = dmtcfgIsControlMapped(hwnd,
                                            pdia,
                                            uActions);
            EnableWindow(GetDlgItem(hwnd, IDC_UNMAP),
                    fEnable);
            // do NOT enable the map button if there are no
            //  more actions
            if(!SendMessage(GetDlgItem(hwnd, IDC_ACTIONS),
                        LB_GETCOUNT,
                        0, 0L))
            {
                EnableWindow(GetDlgItem(hwnd, IDC_STORE_MAPPING),
                        FALSE);
            }
            else
            {
                EnableWindow(GetDlgItem(hwnd, IDC_STORE_MAPPING),
                        !fEnable);
            }
            // if >any< controls are mapped
            //  enable the "Unmap all" button
            fEnable = dmtcfgAreAnyControlsMapped(hwnd,
                                                pdia,
                                                uActions);
            EnableWindow(GetDlgItem(hwnd, IDC_UNMAP_ALL),
                    fEnable);
            break;

        case IDC_STORE_MAPPING:     // "Map action"
            // map it
            hRes = dmtcfgMapAction(hwnd,
                                pdmtai->pDeviceList->guidInstance,
                                pdia,
                                uActions);
            if(FAILED(hRes))
            {
               // ISSUE-2001/03/29-timgill Needs error case handling
            }            

            // set the changed flag
            pMapping->fChanged = TRUE;
            break;

        case IDC_UNMAP:  // "Unmap action"
            // unmap it
            hRes = dmtcfgUnmapAction(hwnd,
                                    pdia,
                                    uActions);
            if(FAILED(hRes))
            {
                // ISSUE-2001/03/29-timgill Needs error case handling
            }

            // set the changed flag
            pMapping->fChanged = TRUE;
            break;

        case IDC_UNMAP_ALL:       // "Unmap all"
            hRes = dmtcfgUnmapAllActions(hwnd,
                                    pdia,
                                    uActions);
            if(FAILED(hRes))
            {
                // ISSUE-2001/03/29-timgill Needs error case handling
            }

            // set the changed flag
            pMapping->fChanged = TRUE;
            break;

    }

    // done
    return FALSE;

} //*** end dmtcfgOnCommand()


//===========================================================================
// dmtcfgOnNotify
//
// Handle WM_NOTIFY processing for the config device box
//
// Parameters:
//  HWND        hwnd    - handle to property page
//  PSHNOTIFY   *ppsh   - PSHNOTIFY ptr
//
// Returns: BOOL
//
// History:
//  08/20/1999 - davidkl - created
//  10/14/1999 - davidkl - implemented save calls
//===========================================================================
BOOL dmtcfgOnNotify(HWND hwnd,
                    PSHNOTIFY *pNotify)    
{
    //int         n           = 0;
	//JJ 64Bit Compat
	INT_PTR		n			= 0;
    BOOL        fSave       = FALSE;
    DMT_APPINFO *pdmtai     = NULL;

	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF(5, "dmtcfgOnNotify: hwnd == %Ph", hwnd);

    // get the window data   
    //pdmtai = (DMT_APPINFO*)GetWindowLong(hwnd, GWL_USERDATA);
	//JJ 64Bit Compat
	pdmtai = (DMT_APPINFO*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(!pdmtai)
    {
        // bad news
        // ISSUE-2001/03/29-timgill Needs error case handling
    }

    switch(pNotify->hdr.code)
    {
		case PSN_SETACTIVE:
            DPF(5, "PSN_SETACTIVE");
            // force the apply button to be enabled
            SendMessageA(GetParent(hwnd),
                        PSM_CHANGED,
                        (WPARAM)hwnd,
                        0L);
            break;

        case PSN_KILLACTIVE:
            DPF(5, "PSN_KILLACTIVE");
            // make sure we get a PSN_APPLY message
            //SetWindowLong(hwnd, DWL_MSGRESULT, (LONG)FALSE);
			SetWindowLong(hwnd, DWLP_MSGRESULT, (LONG)FALSE);
            break;

        case PSN_APPLY:
            DPF(5, "PSN_APPLY - %s",
                (pNotify->lParam) ? "Ok" : "Apply");

            // save/load mapping data
            //
            // OK       == Save
            // Apply    == Load

            // which button was clicked?
            if(pNotify->lParam)
            {
                // save mapping data
                SendMessage(hwnd,
                            WM_DMT_FILE_SAVE,
                            0,0L);
            }
            else
            {
                // load mapping data
                // ISSUE-2001/03/29-timgill Load Mapping Data not yet implemented
                MessageBoxA(hwnd, "Load - Not Yet Implemented",
                            pdmtai->pDeviceList->szName, 
                            MB_OK);
            }

            // DO NOT allow the dialog to close
            //SetWindowLong(hwnd, 
              //          DWL_MSGRESULT, 
                //        (LONG)PSNRET_INVALID_NOCHANGEPAGE);

			//JJ 64Bit Compat
			SetWindowLongPtr(hwnd, 
                        DWLP_MSGRESULT, 
                        (LONG_PTR)PSNRET_INVALID_NOCHANGEPAGE);

            break;
            
    }

    // done
    return TRUE;

} //*** end dmtcfgOnNotify()


//===========================================================================
// dmtcfgOnUpdateLists
//
// Handle WM_DMT_UPDATE_LISTS message
//
// Parameters:
//
// Returns: BOOL
//
// History:
//  08/25/1999 - davidkl - created
//  11/12/1999 - dvaidkl - fixed problem with control selection setting
//===========================================================================
BOOL dmtcfgOnUpdateLists(HWND hwnd)
{
    //int                     nIdx            = -1;
    //int                     nSelCtrl        = -1;
	//JJ 64Bit Compat
	INT_PTR					nSelCtrl		= -1;
	INT_PTR					nIdx			= -1;
    int                     n               = 0;

    INT_PTR					nControls		= 0;
	INT_PTR					nActions		= 0;
	//int                     nControls       = 0;
    //int                     nActions        = 0;
    DWORD                   dwType          = DMTA_TYPE_UNKNOWN;
    DWORD                   dwObjType       = DMTA_TYPE_UNKNOWN;
    DMTSUBGENRE_NODE        *pSubGenre      = NULL;
    DMTACTION_NODE          *pAction        = NULL;
    DMTMAPPING_NODE         *pMapping       = NULL;
    DMTDEVICEOBJECT_NODE    *pObjectList    = NULL;
    DMTDEVICEOBJECT_NODE    *pObjectNode    = NULL;
    DMT_APPINFO             *pdmtai         = NULL;
    DIACTION                *pdia           = NULL;
    BOOL                    fFound          = FALSE;
    char                    szBuf[MAX_PATH];

    DPF(5, "dmtcfgOnUpdateLists");

    // get the window data   
    //pdmtai = (DMT_APPINFO*)GetWindowLong(hwnd, GWL_USERDATA);
	//JJ 64Bit Compat
	pdmtai = (DMT_APPINFO*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(!pdmtai)
    {
        // bad news
        // ISSUE-2001/03/29-timgill Needs error case handling
    }

    // device object list
    pObjectList = pdmtai->pDeviceList->pObjectList;

    // get the currently selected control
    nSelCtrl = SendMessageA(GetDlgItem(hwnd, IDC_CONTROLS),
                            LB_GETCURSEL,
                            0,
                            0L);

    // clear the list box contents
    // actions
    SendMessageA(GetDlgItem(hwnd, IDC_ACTIONS),
                LB_RESETCONTENT,
                0,
                0L);
    // controls
    SendMessageA(GetDlgItem(hwnd, IDC_CONTROLS),
                LB_RESETCONTENT,
                0,
                0L);

    // get the current selection
    nIdx = SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRE),
                    CB_GETCURSEL,
                    0,
                    0L);

    // get the item data
    pSubGenre = (DMTSUBGENRE_NODE*)SendMessageA(GetDlgItem(hwnd, 
                                                        IDC_SUBGENRE),
                                            CB_GETITEMDATA,
                                            nIdx,
                                            0L);
    
    // get the DIACTION array specific to the current device
    pMapping = pSubGenre->pMappingList;
    while(pMapping)
    {
        // match pdmtai->pDeviceList->guidInstance
        //  with pMapping->guidInstance
        if(IsEqualGUID(pdmtai->pDeviceList->guidInstance,
                    pMapping->guidInstance))
        {
            break;
        }

        // next mapping
        pMapping = pMapping->pNext;

    }
    if(!pMapping)
    {
        // this is very bad and should NEVER happen
        // ISSUE-2001/03/29-timgill Needs error case handling
        DebugBreak();
    }
    pdia = pMapping->pdia;
    nActions = (int)pMapping->uActions;

    // what control type is selected?
    dwType = IDC_TYPE_AXIS - (dmtGetCheckedRadioButton(hwnd,
                                                    IDC_TYPE_POV,
                                                    IDC_TYPE_AXIS));
    // populate the action list
    nIdx = 0;
    pAction = pSubGenre->pActionList;
    while(pAction)
    {
        // filter to the selected control type
        if(dwType == pAction->dwType)
        {
            // filter actions that are already assigned

            // first, find a matching action in the array
            fFound = FALSE;
            for(n = 0; n < nActions; n++)
            {
                // match based on the semantic / action id
                if((pdia+n)->dwSemantic == pAction->dwActionId)
                {
                    DPF(2, "dmtcfgOnUpdateLists- found matching action "
                        "pAction->dwActionId (%08Xh) == "
                        "(pdia+u)->dwSemantic (%08Xh)",
                        pAction->dwActionId,
                        (pdia+n)->dwSemantic);
                    fFound = TRUE;
                    break;
                }
            }

            // next, read the action array entry, 
            //  if GUID_NULL == guidInstance, add the entry
            if(!fFound || 
                IsEqualGUID(GUID_NULL, (pdia+n)->guidInstance))
            {                            
                // prepend the action priority
                wsprintfA(szBuf, "(Pri%d) %s",
                        pAction->dwPriority,
                        pAction->szName);

                // add the action name
                nIdx = SendMessageA(GetDlgItem(hwnd, IDC_ACTIONS),
                                    LB_ADDSTRING,
                                    0,
                                    (LPARAM)szBuf);

                // add the item data (action node)
                SendMessageA(GetDlgItem(hwnd, IDC_ACTIONS),
                            LB_SETITEMDATA,
                            nIdx,
                            (LPARAM)pAction);

            } //* assigned action filter

        } //* control type filter

        // next action
        pAction = pAction->pNext;
    
    }

    // populate the control list
    nIdx = 0;
    pObjectNode = pObjectList;
    while(pObjectNode)
    {
        // convert dinput's DIDFT to our 
        //  internal control type
        if(FAILED(dmtinputXlatDIDFTtoInternalType(pObjectNode->dwObjectType,
                                            &dwObjType)))
        {
            // ISSUE-2001/03/29-timgill Needs error case handling
        }
        DPF(3, "dmtcfgOnUpdateLists - %s : DIDFT type %08Xh, internal type %d",
            pObjectNode->szName,
            pObjectNode->dwObjectType,
            dwObjType);

        // filter on control type
        //
        // dwType populated above
        if(dwType == dwObjType)
        {

            // check to if mapped
            //
            // we do this by scanning the DIACTION array, looking
            //  for actions that contain our device's guidInstance
            //  and our object's offset
            //  if so, put the mapping info in ()
            wsprintfA(szBuf, "%s",
                    pObjectNode->szName);
            for(n = 0; n < nActions; n++)
            {
                if(IsEqualGUID((pdia+n)->guidInstance,
                            pdmtai->pDeviceList->guidInstance) &&
                            ((pdia+n)->dwObjID == 
                                pObjectNode->dwObjectType))
                {
                    wsprintfA(szBuf, "%s (%s)",
                            pObjectNode->szName,
                            (pdia+n)->lptszActionName);
                    break;
                }
            }

            // add the control name
            nIdx = SendMessageA(GetDlgItem(hwnd, IDC_CONTROLS),
                                LB_ADDSTRING,
                                0,
                                (LPARAM)szBuf);

            // add the item data (object node)
            SendMessageA(GetDlgItem(hwnd, IDC_CONTROLS),
                        LB_SETITEMDATA,
                        nIdx,
                        (LPARAM)pObjectNode);

        } //* control type filter

        // next control
        pObjectNode = pObjectNode->pNext;

    }

    // count the number of entries in each list
    nControls = SendMessage(GetDlgItem(hwnd, IDC_CONTROLS),
                            LB_GETCOUNT,
                            0,
                            0L);
    nActions = SendMessage(GetDlgItem(hwnd, IDC_ACTIONS),
                            LB_GETCOUNT,
                            0,
                            0L);                   

    // set the selected entry in each list
    //
    // only do this if there are entries in the lists
    if(nControls)
    {
        if(nSelCtrl > nControls)
        {
            nSelCtrl = 0;
        }

        SendMessageA(GetDlgItem(hwnd, IDC_CONTROLS),
                    LB_SETCURSEL,
                    nSelCtrl,
                    0L);
    }
    if(nActions)
    {
        SendMessageA(GetDlgItem(hwnd, IDC_ACTIONS),
                    LB_SETCURSEL,
                    0,
                    0L);
    }

    // if there are no controls or no actions
    //
    // disable the map button
    if(!nControls || !nActions)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_STORE_MAPPING), FALSE);
    }

    // done
    return FALSE;

} //*** end dmtcfgOnUpdateLists()


//===========================================================================
// dmtcfgSourceDlgProc
//
// Configure Device Mapping Source Code dialog processing function
//
// Parameters: (see SDK help for parameter details)
//  HWND    hwnd
//  UINT    uMsg
//  WPARAM  wparam
//  LPARAM  lparam
//
// Returns: (see SDK help for return value details)
//  BOOL
//
// History:
//  08/31/1999 - davidkl - created  
//===========================================================================
BOOL CALLBACK dmtcfgSourceDlgProc(HWND hwnd,
                                UINT uMsg,
                                WPARAM wparam,
                                LPARAM lparam)
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
            return dmtcfgSourceOnInitDialog(hwnd, 
                                            (HWND)wparam, 
                                            lparam);
        
        case WM_COMMAND:
            return dmtcfgSourceOnCommand(hwnd,
                                        LOWORD(wparam),
                                        (HWND)lparam,
                                        HIWORD(wparam));

        case WM_DMT_UPDATE_LISTS:
            return dmtcfgSourceOnUpdateLists(hwnd);
    }

    return FALSE;

} //*** end dmtcfgSourceDlgProc()


//===========================================================================
// dmtcfgSourceOnInitDialog
//
// Handle WM_INITDIALOG processing for the config source box
//
// Parameters:
//  HWND    hwnd        - handle to property page
//  HWND    hwndFocus   - handle of ctrl with focus
//  LPARAM  lparam      - user data (in this case, PROPSHEETPAGE*)
//
// Returns: BOOL
//
// History:
//  08/31/1999 - davidkl - created
//  10/07/1999 - davidkl - reworked code to match UI change
//===========================================================================
BOOL dmtcfgSourceOnInitDialog(HWND hwnd, 
                            HWND hwndFocus, 
                            LPARAM lparam)
{
    DMTSUBGENRE_NODE    *pSubGenre  = (DMTSUBGENRE_NODE*)lparam;
    //LONG                lPrev       = 0L;
	//JJ 64Bit Compat
	LONG_PTR			lPrev		= 0;
    int                 nIdx        = 0;
    char                szBuf[MAX_PATH];

    DPF(5, "dmtcfgSourceOnInitDialog");

    // validate pSubGenre (lparam)
    if(IsBadWritePtr((void*)pSubGenre, sizeof(DMTSUBGENRE_NODE)))
    {
        DPF(0, "dmtcfgOnInitDialog - invalid ppsp.ptp (%016Xh)",
            pSubGenre);
        return FALSE;
    }

    // set the window caption to include the subgenre name
    wsprintfA(szBuf, "Configure Device Mapping Source Code - %s",
            pSubGenre->szName);
    SetWindowTextA(hwnd, szBuf);

    // store the subgenre node in the window's user data
    SetLastError(0);
    //lPrev = SetWindowLong(hwnd, 
      //                  GWL_USERDATA, 
        //                (LONG)pSubGenre);

	//JJ 64Bit Compat
	lPrev = SetWindowLongPtr(hwnd, 
							GWLP_USERDATA, 
							(LONG_PTR)pSubGenre);
    if(!lPrev && GetLastError())
    {
        // serious app problem.  
        //  we need to stop things right here and now
        DPF(0, "dmtcfgSourceOnInitDialog - This is bad... "
            "We failed to store pSubGenre");
        DPF(0, "dmtcfgSourceOnInitDialog  - Please find someone "
            "to look at this right away");
        DebugBreak();
        return FALSE;
    }

    // populate the subgenre edit box
    SetWindowTextA(GetDlgItem(hwnd, IDC_SUBGENRE),
                pSubGenre->szName);

    // display the subgenre description
    SetWindowTextA(GetDlgItem(hwnd, IDC_DESCRIPTION),
                pSubGenre->szDescription);


    // select the axes radio button
    CheckRadioButton(hwnd,
                    IDC_TYPE_POV,
                    IDC_TYPE_AXIS,
                    IDC_TYPE_AXIS);

    // populate the actions list box
    //
    // store the ptr to the actions node in the listbox 
    //  entry user data
    SendMessageA(hwnd,
                WM_DMT_UPDATE_LISTS,
                0,
                0L);
    
    // done
    return TRUE;

} //*** end dmtcfgSourceOnInitDialog()


//===========================================================================
// dmtcfgSourceOnCommand
//
// Handle WM_COMMAND processing for the config source box
//
// Parameters:
//  HWND    hwnd        - handle to property page
//  WORD    wId         - control identifier    (LOWORD(wparam))
//  HWND    hwndCtrl    - handle to control     ((HWND)lparam)
//  WORD    wNotifyCode - notification code     (HIWORD(wparam))
//
// Returns: BOOL
//
// History:
//  08/31/1999 - davidkl - created
//===========================================================================
BOOL dmtcfgSourceOnCommand(HWND hwnd,
                    WORD wId,
                    HWND hwndCtrl,
                    WORD wNotifyCode)
{
    DMTGENRE_NODE   *pGenre = NULL;

	DPF(5, "dmtcfgOnCommand");

    // get the genre from the window's user data
    // ISSUE-2001/03/29-timgill config source box fails to handle many UI messages
    // IDC_ADD_ACTION, IDC_REMOVE_ACTION, IDC_RENAME_ACTION, IDC_CUSTOM_ACTION all do nothing
    // IDOK/IDCANCEL merely do default processing

    switch(wId)
    {
        case IDOK:
            EndDialog(hwnd, 0);
            break;

        case IDCANCEL:
            EndDialog(hwnd, -1);
            break;

        case IDC_SUBGENRE:
            // based on the selected subgenre
            //
            // display the objects/actions for the selected type
            //  (see type IDs below)
            if(CBN_SELCHANGE == wNotifyCode)
            {
                // update the lists
                SendMessageA(hwnd,
                            WM_DMT_UPDATE_LISTS,
                            0,
                            0L);   
            }
            break;

        case IDC_TYPE_AXIS:
        case IDC_TYPE_BUTTON:
        case IDC_TYPE_POV:
            // update the lists
            SendMessageA(hwnd,
                        WM_DMT_UPDATE_LISTS,
                        0,
                        0L);   
            break;

        case IDC_ADD_ACTION:
            break;

        case IDC_REMOVE_ACTION:
            break;

        case IDC_RENAME_ACTION:
            break;

        case IDC_CUSTOM_ACTION:
            break;

    }

    // done
    return FALSE;

} //*** end dmtcfgSourceOnCommand()


//===========================================================================
// dmtcfgSourceOnUpdateLists
//
// Handle WM_DMT_UPDATE_LISTS message
//
// Parameters:
//
// Returns: BOOL
//
// History:
//  08/31/1999 - davidkl - created
//  10/07/1999 - davidkl - modified to match UI change
//===========================================================================
BOOL dmtcfgSourceOnUpdateLists(HWND hwnd)
{
    //int                 nIdx        = -1;
	//JJ 64Bit Compat
	INT_PTR				nIdx		= -1;
    DWORD               dwType      = 0x0badbad0;
    DMTSUBGENRE_NODE    *pSubGenre  = NULL;
    DMTACTION_NODE      *pAction    = NULL;
    char                szBuf[MAX_PATH];
    
    // get the subgenre node from the window's user data
    //pSubGenre = (DMTSUBGENRE_NODE*)GetWindowLong(hwnd,
      //                                          GWL_USERDATA);

	//JJ 64Bit Compat
	pSubGenre = (DMTSUBGENRE_NODE*)GetWindowLongPtr(hwnd,
                                                GWLP_USERDATA);

    if(!pSubGenre)
    {
        // this is very bad
        // ISSUE-2001/03/29-timgill Needs error case handling
        DebugBreak();
        return TRUE;
    }

    // clear the list box contents
    SendMessageA(GetDlgItem(hwnd, IDC_ACTIONS),
                LB_RESETCONTENT,
                0,
                0L);
   
    // what control type is selected?
    dwType = IDC_TYPE_AXIS - (dmtGetCheckedRadioButton(hwnd,
                                                    IDC_TYPE_POV,
                                                    IDC_TYPE_AXIS));
    // populate the action list
    pAction = pSubGenre->pActionList;
    while(pAction)
    {
        // filter to the selected control type
        if(dwType == pAction->dwType)
        {

            // filter actions that are already selected
/*
            if(DMT_ACTION_NOTASSIGNED == pAction->dwDevObj)
            {
*/
                // if the priority is NOT 1, append that info to the name string
                //
                // ISSUE-2001/03/29-timgill Should the priority 1 mapping display colour be different (eg. red)?
                // Do game developers CARE about action priorities?
/*
                if(1 < pAction->dwPriority)
                {
                    wsprintfA(szBuf, "(Pri%d) %s",
                            pAction->dwPriority,
                            pAction->szName);
                }
                else
                {
*/
                    lstrcpyA(szBuf, pAction->szName);
//                }

                // add the action name
                nIdx = SendMessageA(GetDlgItem(hwnd, IDC_ACTIONS),
                                    LB_ADDSTRING,
                                    0,
                                    (LPARAM)szBuf);

                // add the extra data (action node)
                SendMessageA(GetDlgItem(hwnd, IDC_ACTIONS),
                            LB_SETITEMDATA,
                            nIdx,
                            (LPARAM)&(pAction));

/*
            } //* assigned action filter
*/

        } // control type filter

        // next action
        pAction = pAction->pNext;
    
    }

    // done
    return FALSE;

} //*** end dmtcfgSourceOnUpdateLists()


//===========================================================================
// dmtcfgCreateGenreList
//
// Reads genres.ini and creates the genre list used to populate the
//  Configure Device Action Map property sheet dialog.  Returns the number of
//  parent genres (NOT subgenres) found
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  08/23/1999 - davidkl - created
//  09/28/1999 - davidkl - modified to match new ini format
//===========================================================================
HRESULT dmtcfgCreateGenreList(DMTGENRE_NODE **ppdmtgList)
{
    HRESULT         hRes        = S_OK;
    UINT            u           = 0;
    BOOL            fFound      = FALSE;
    DMTGENRE_NODE   *pCurrent   = NULL;
    DMTGENRE_NODE   *pNew       = NULL;
	DMTGENRE_NODE	*pHold		= NULL;
    char            szItem[64];
    char            szBuf[MAX_PATH];
    char            szGroup[MAX_PATH];


    // validate  ppmdtgList
    if(IsBadWritePtr((void*)ppdmtgList, sizeof(DMTGENRE_NODE*)))
    {
        DPF(0, "dmtcfgCreateGenreList - invalid ppdmtgList (%016Xh)",
            ppdmtgList);
        return E_POINTER;
    }
    
    // check to make sure we are not being asked 
    //  to append to an existing list
    //
    // callers MUST pass a NULL list
    if(*ppdmtgList)
    {
        DPF(0, "dmtcfgCreateGenreList - ppdmtgList points to "
            "existing list! (%016Xh)", *ppdmtgList);
        return E_INVALIDARG;
    }

    __try
    {
        // get the genre names from genres.ini
        pCurrent = *ppdmtgList;
        lstrcpyA(szBuf, "");
        u = 0;
        while(lstrcmpA("<<>>", szBuf))
        {
            // get the name of the genre
            wsprintfA(szItem, "%d", u);
            GetPrivateProfileStringA(szItem,
                                    "N",
                                    "<<>>",
                                    szBuf,
                                    MAX_PATH,
                                    GENRES_INI);

            if(!lstrcmpA("<<>>", szBuf))
            {
                DPF(3, "end of genre list");
                continue;
            }
            DPF(3, "Genre name == %s", szBuf);

            // extract the group name
            hRes = dmtcfgGetGenreGroupName(szBuf,
                                        szGroup);
            if(FAILED(hRes))
            {
                // ISSUE-2001/03/29-timgill Needs error case handling
            }
            
            // walk the list
            //
            // make sure we did not get a duplicate name
            fFound = FALSE;
			pHold = pCurrent;
			pCurrent = *ppdmtgList;
            while(pCurrent)
            {
                if(!lstrcmpiA(pCurrent->szName,
                            szGroup))
                {
                    // match found
                    fFound = TRUE;
                    break;
                }

                // next node
                pCurrent = pCurrent->pNext;
            }
            if(!fFound)
            {
                // no match, allocate a new node

                // allocate the genre node
                pNew = (DMTGENRE_NODE*)LocalAlloc(LMEM_FIXED,
                                                    sizeof(DMTGENRE_NODE));
                if(!pNew)
                {
                    DPF(0, "dmtcfgCreateGenreList - insufficient memory to "
                        "allocate genre list node");
                    hRes = E_OUTOFMEMORY;
                    __leave;
                }

                // initialize the new node
                ZeroMemory((void*)pNew, sizeof(DMTGENRE_NODE));

                // set the name field
                lstrcpyA(pNew->szName, szGroup);

                // get the list of subgenres
                hRes = dmtcfgCreateSubGenreList(pNew->szName,
                                                &(pNew->pSubGenreList));
                if(FAILED(hRes))
                {
                    // ISSUE-2001/03/29-timgill Needs error case handling
                }

                // add it to the end of the list
                pCurrent = pHold;
                if(pCurrent)
                {
                    // append the list
                    pCurrent->pNext = pNew;

                    // go to the next node
                    pCurrent = pCurrent->pNext;
                }
                else
                {
                    // new list head
                    pCurrent = pNew;
                    *ppdmtgList = pCurrent;
                }

            }

            // next genre
            u++;

        }
    }
    __finally
    {
        if(FAILED(hRes))
		{
			// cleanup allocations
            DPF(1, "dmtcfgCreateGenreList - Failure occurred, "
                "freeing genre list");
			dmtcfgFreeGenreList(ppdmtgList);
            *ppdmtgList = NULL;
		}
    }

    // done
    return hRes;

} //*** end dmtcfgCreateGenreList()


//===========================================================================
// dmtcfgFreeGenreList
//
// Frees the linked list (and sub-lists) created by dmtcfgCreateGenreList
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  08/23/1999 - davidkl - created
//===========================================================================
HRESULT dmtcfgFreeGenreList(DMTGENRE_NODE **ppdmtgList)
{
    HRESULT         hRes    = S_OK;
    DMTGENRE_NODE   *pNode  = NULL;

    // validate ppdmtgList
    if(IsBadWritePtr((void*)ppdmtgList, sizeof(PDMTGENRE_NODE)))
    {
        DPF(0, "dmtcfgFreeGenreList - Invalid ppdmtgList (%016Xh)",
            ppdmtgList);
        return E_POINTER;
    }

    // validate *ppdmtgList
    if(IsBadReadPtr((void*)*ppdmtgList, sizeof(DMTGENRE_NODE)))
    {
        if(NULL != *ppdmtgList)
        {
            DPF(0, "dmtcfgFreeGenreList - Invalid *ppdmtgList (%016Xh)",
                *ppdmtgList);        
            return E_POINTER;
        }
        else
        {
            // if NULL, then return "did nothing"
            DPF(3, "dmtcfgFreeGenreList - Nothing to do....");
            return S_FALSE;
        }
    }

    // walk the list and free each object
    while(*ppdmtgList)
    {
        pNode = *ppdmtgList;
        *ppdmtgList = (*ppdmtgList)->pNext;

        // first, free the action list
        DPF(5, "dmtcfgFreeGenreList - "
            "freeing subgenre list (%016Xh)", 
            pNode->pSubGenreList);
        hRes = dmtcfgFreeSubGenreList(&(pNode->pSubGenreList));
        if(FAILED(hRes))
        {
            // ISSUE-2001/03/29-timgill Needs error case handling
        }

        DPF(5, "dmtcfgFreeGenreList - Deleting Node (%016Xh)", pNode);
        if(LocalFree((HLOCAL)pNode))
        {
            DPF(0, "dmtcfgFreeSubGenreList - MEMORY LEAK - "
                "LocalFree() failed (%d)...", 
                GetLastError());
            hRes = DMT_S_MEMORYLEAK;
        }
        DPF(5, "dmtcfgFreeGenreList - Node deleted");
    }

    // make sure that we set *ppdmtgList to NULL
    *ppdmtgList = NULL;

    // done
    return hRes;

} //*** end dmtcfgFreeGenreList()


//===========================================================================
// dmtcfgCreateSubGenreList
//
// Reads genres.ini and creates the subgenre list used to populate the
//  Configure Device Action Map property sheet dialog.
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  08/24/1999 - davidkl - created
//  09/29/1999 - davidkl - modified to match new ini format
//===========================================================================
HRESULT dmtcfgCreateSubGenreList(LPSTR szGenre,
                                DMTSUBGENRE_NODE **ppdmtsgList)
{
    HRESULT             hRes        = S_OK;
    UINT                u           = 0;
    DMTSUBGENRE_NODE    *pCurrent   = NULL;
    DMTSUBGENRE_NODE    *pNew       = NULL;
    char                szItem[64];
    char                szGroup[MAX_PATH];
    char                szBuf[MAX_PATH];

    // validate  ppmdtsgList
    if(IsBadWritePtr((void*)ppdmtsgList, sizeof(DMTSUBGENRE_NODE*)))
    {
        return E_POINTER;
    }
    
    // check to make sure we are not being asked 
    //  to append to an existing list
    //
    // callers MUST pass a NULL list
    if(*ppdmtsgList)
    {
        return E_INVALIDARG;
    }


    __try
    {
        // get the subgenre names from genres.ini
        pCurrent = *ppdmtsgList;
        lstrcpyA(szBuf, "");
        u = 0;
        while(lstrcmpA("<<>>", szBuf))
        {
            // look for subgenres belonging to szGenre
            wsprintfA(szItem, "%d", u);
            GetPrivateProfileStringA(szItem,
                                    "N",
                                    "<<>>",
                                    szBuf,
                                    MAX_PATH,
                                    GENRES_INI);

            if(!lstrcmpA("<<>>", szBuf))
            {
                DPF(3, "end of subgenre list");
                continue;
            }
            hRes = dmtcfgGetGenreGroupName(szBuf,
                                        szGroup);
            if(FAILED(hRes))
            {
                // ISSUE-2001/03/29-timgill Needs error case handling
            }

            // if we do not belong to the genre group
            //
            // make believe we found nothing
            if(lstrcmpiA(szGenre, szGroup))
            {
                u++;
                DPF(4, "bucket mismatch... skipping");
                continue;
            }

            // we fit in the szGenre bucket
            //
            // allocate the genre node
            pNew = (DMTSUBGENRE_NODE*)LocalAlloc(LMEM_FIXED,
                                                sizeof(DMTSUBGENRE_NODE));

			if(!pNew)
			{
				hRes = E_OUTOFMEMORY;
				__leave;
			}

            // initialize the new node
            ZeroMemory((void*)pNew, sizeof(DMTSUBGENRE_NODE));

            // get the genreid
            pNew->dwGenreId = GetPrivateProfileInt(szItem,
                                                "AI0",
                                                0,
                                                GENRES_INI);
            pNew->dwGenreId &= DMT_GENRE_MASK;
            DPF(4, "SubGenre ID == %08Xh", pNew->dwGenreId);

            // get the "name" (Txt1)
            GetPrivateProfileStringA(szItem,
                                    "T1",
                                    "<<>>",
                                    pNew->szName,
                                    MAX_PATH,
                                    GENRES_INI);
            DPF(3, "SubGenre name == %s", pNew->szName);

            // get the description (Txt2)
            GetPrivateProfileStringA(szItem,
                                    "T2",
                                    "<<>>",
                                    pNew->szDescription,
                                    MAX_PATH,
                                    GENRES_INI);
            DPF(4, "SubGenre description == %s", pNew->szDescription);

            // get the list of actions
            hRes = dmtcfgCreateActionList(szItem,
                                        &(pNew->pActionList));
            if(FAILED(hRes) || DMT_S_MEMORYLEAK == hRes)
            {
                // ISSUE-2001/03/29-timgill Needs error case handling
            }

            // add it to the end of the list
            if(pCurrent)
            {
                // append the list
                pCurrent->pNext = pNew;

                // go to the next node
                pCurrent = pCurrent->pNext;
            }
            else
            {
                // new list head
                pCurrent = pNew;
                *ppdmtsgList = pCurrent;
            }

            // next subgenre
            u++;

        }
    }
    __finally
    {
        // cleanup in failure case
        if(FAILED(hRes))
		{
            DPF(1, "dmtcfgCreateSubGenreList - Failure occurred, "
                "freeing subgenre list");
            dmtcfgFreeSubGenreList(ppdmtsgList);
            *ppdmtsgList = NULL;
		}
    }

	//JJ_FIX
	g_NumSubGenres = u;

    // done
    return S_OK;

} //*** end dmtcfgCreateSubGenreList()


//===========================================================================
// dmtcfgFreeSubGenreList
//
// Frees the linked list created by dmtcfgCreateSubGenreList
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  08/24/1999 - davidkl - created
//  08/25/1999 - davidkl - implemented
//===========================================================================
HRESULT dmtcfgFreeSubGenreList(DMTSUBGENRE_NODE **ppdmtsgList)
{
    HRESULT             hRes    = S_OK;
    DMTSUBGENRE_NODE    *pNode  = NULL;

    // validate ppdmtaList
    if(IsBadWritePtr((void*)ppdmtsgList, sizeof(PDMTSUBGENRE_NODE)))
    {
        DPF(0, "dmtcfgFreeSubGenreList - Invalid ppdmtsgList (%016Xh)",
            ppdmtsgList);
        return E_POINTER;
    }

    // validate *ppPortList
    if(IsBadReadPtr((void*)*ppdmtsgList, sizeof(DMTSUBGENRE_NODE)))
    {
        if(NULL != *ppdmtsgList)
        {
            DPF(0, "dmtcfgFreeSubGenreList - Invalid *ppdmtsgList (%016Xh)",
                *ppdmtsgList);        
            return E_POINTER;
        }
        else
        {
            // if NULL, then return "did nothing"
            DPF(3, "dmtcfgFreeSubGenreList - Nothing to do....");
            return S_FALSE;
        }
    }

    // walk the list and free each object
    while(*ppdmtsgList)
    {
        pNode = *ppdmtsgList;
        *ppdmtsgList = (*ppdmtsgList)->pNext;

        // first, free the action list
        DPF(5, "dmtcfgFreeSubGenreList - "
            "freeing action list (%016Xh)", 
            pNode->pActionList);
        hRes = dmtcfgFreeActionList(&(pNode->pActionList));
        if(FAILED(hRes))
        {
            hRes = DMT_S_MEMORYLEAK;
        }

        // then free the mapping list array
        if(pNode->pMappingList)
        {
            hRes = dmtcfgFreeMappingList(&(pNode->pMappingList));
            if(FAILED(hRes) || DMT_S_MEMORYLEAK == hRes)
            {
                hRes = DMT_S_MEMORYLEAK;
            }
            pNode->pMappingList = NULL;
        }

        // finally, free the node
        DPF(5, "dmtcfgFreeSubGenreList - Deleting Node (%016Xh)", pNode);
        if(LocalFree((HLOCAL)pNode))
        {
            DPF(0, "dmtcfgFreeSubGenreList - MEMORY LEAK - "
                "LocalFree(Node) failed (%d)...", 
                GetLastError());
            hRes = DMT_S_MEMORYLEAK;
        }
        DPF(5, "dmtcfgFreeSubGenreList - Node deleted");
    }

    // make sure that we set *ppdmtsgList to NULL
    *ppdmtsgList = NULL;

    // done
    return hRes;

} //*** end dmtcfgFreeSubGenreList()


//===========================================================================
// dmtcfgCreateActionList
//
// Reads genres.ini and creates the action list used to populate the
//  Configure Device Action Map property sheet dialog.
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  08/24/1999 - davidkl - created
//  09/07/1999 - davidkl - added DIACTION**
//  09/28/1999 - davidkl - updated to use info extraction macros
//  02/14/2000 - davidkl - started conversion to GetPrivateProfileSectionA
//===========================================================================
HRESULT dmtcfgCreateActionList(LPSTR szGenreSubgenre,
                            DMTACTION_NODE **ppdmtaList)
{
    HRESULT         hRes        = S_OK;
    UINT            u           = 0;
    BYTE            bTypeMask   = 0x03;
    DMTACTION_NODE  *pCurrent   = NULL;
    DMTACTION_NODE  *pNew       = NULL;
    char            szItem[MAX_PATH];
    char            szBuf[MAX_PATH];

    // validate ppmdtsgList
    if(IsBadWritePtr((void*)ppdmtaList, sizeof(DMTACTION_NODE*)))
    {
        DPF(0, "dmtcfgCreateActionList - invalid ppdmtaList (%016Xh)",
            ppdmtaList);
        return E_POINTER;
    }
    
    // check to make sure we are not being asked 
    //  to append to an existing list
    //
    // callers MUST pass a NULL list
    if(*ppdmtaList)
    {
        DPF(0, "dmtcfgCreateActionList - ppdmtaList points to "
            "existing list! (%016Xh)", *ppdmtaList);
        return E_INVALIDARG;
    }

    __try
    {
        // get the action info from genres.ini
        pCurrent = *ppdmtaList;
#ifdef BNW
    char    *pszSection = NULL;
    char    *pCurrent   = NULL;
    int     nAlloc      = 0;

        // allocate space for the (Win9x) max size of an ini section
        nAlloc = 32727;
        pszSection = (char*)LocalAlloc(LMEM_FIXED,
                                    sizeof(char) * nAlloc);
        if(!pszSection)
        {
            // alloc failed,
            //  try ~1/2 of the max (that should still cover the 
            //  fill size of the section)
            nAlloc = 16386;
            pszSection = (char*)LocalAlloc(LMEM_FIXED,
                                        sizeof(char) * nAlloc);
            if(!pszSection)
            {
                // alloc failed,
                //  try ~1/4 of the max (that should still cover the 
                //  fill size of the section)
                nAlloc = 8192;
                pszSection = (char*)LocalAlloc(LMEM_FIXED,
                                            sizeof(char) * nAlloc);
                if(!pszSection)
                {
                    // alloc failed,
                    //  try ~1/8 of the max (that should still cover the 
                    //  fill size of the section)
                    nAlloc = 4096;
                    pszSection = (char*)LocalAlloc(LMEM_FIXED,
                                                sizeof(char) * nAlloc);
                    if(!pszSection)
                    {
                        // alloc failed,
                        //  try ~1/16 of the max (that should still cover the 
                        //  fill size of the section) - this is our last attempt
                        nAlloc = 2048;
                        pszSection = (char*)LocalAlloc(LMEM_FIXED,
                                                    sizeof(char) * nAlloc);
                        if(!pszSection)
                        {
                            // alloc failed, we give up
                            __leave;
                        }
                    }
                }
            }
        }
        DPF(2, "dmtcfgCreateActionList - section allocation: %d bytes", nAlloc);
        
        // read the section specified by szGenreSubgenre
        GetPrivateProfileSectionA(szGenreSubgenre,
                                pszSection,
                                nAlloc,
                                GENRES_INI);

/* the following code fragment does nothing - u is incremented and then never used again
        // parse the action information from the section
        for(u = 0; ; u++)
        {
            break;
        }
*/
#else
        lstrcpyA(szBuf, "");
        u = 0;

        while(lstrcmpA("<<>>", szBuf))
        {
            // add the name of the action to the node
            wsprintfA(szItem, "AN%d", u);
            GetPrivateProfileStringA(szGenreSubgenre,
                                    szItem,
                                    "<<>>",
                                    szBuf,
                                    MAX_PATH,
                                    GENRES_INI);
            if(!lstrcmpA("<<>>", szBuf))
            {
                DPF(3, "end of action list");
                continue;
            }
            DPF(3, "Action name == %s", szBuf);

            // allocate the genre node
            pNew = (DMTACTION_NODE*)LocalAlloc(LMEM_FIXED,
                                                sizeof(DMTACTION_NODE));

			if(!pNew)
			{
				hRes = E_OUTOFMEMORY;
				__leave;
			}

            // initialize the new node
            ZeroMemory((void*)pNew, sizeof(DMTACTION_NODE));

            lstrcpyA(pNew->szName, szBuf);

    
            // get the action id
            wsprintfA(szItem, "AI%d", u);
            pNew->dwActionId = GetPrivateProfileIntA(szGenreSubgenre,
                                                szItem,
                                                0x0badbad0,
                                                GENRES_INI);
            DPF(4, "Action ID == %08Xh", pNew->dwActionId);

            // get the action priority
            pNew->dwPriority = dmtinputGetActionPri(pNew->dwActionId);
            DPF(4, "Action priority == %d", pNew->dwPriority);

            // get action type
            pNew->dwType = dmtinputGetActionObjectType(pNew->dwActionId);
            DPF(4, "Action type == %d", pNew->dwType);
   
            // get the action type name
            wsprintfA(szItem, "AIN%d", u);
            GetPrivateProfileStringA(szGenreSubgenre,
                                    szItem,
                                    "<<>>",
                                    pNew->szActionId,
                                    MAX_ACTION_ID_STRING,
                                    GENRES_INI);
            DPF(4, "Action ID name == %s", pNew->szActionId);

            // add it to the end of the list
            if(pCurrent)
            {
                // append the list
                pCurrent->pNext = pNew;

                // go to the next node
                pCurrent = pCurrent->pNext;
            }
            else
            {
                // new list head
                pCurrent = pNew;
                *ppdmtaList = pCurrent;
            }

            // net action
            u++;

        }
#endif // BNW
    }
    __finally
    {
#ifdef BNW
        // free the section memory we allocated
        if(LocalFree((HLOCAL)pszSection))
        {
            // memory leak
            DPF(0, "dmtcfgCreateActionList - !! MEMORY LEAK !! - LocalFree(section) failed");
        }
#endif // BNW

        // cleanup in failure case
        if(FAILED(hRes))
        {
            // free action list
            DPF(1, "dmtcfgCreateActionList - Failure occurred, "
                "freeing action list");
            dmtcfgFreeActionList(ppdmtaList);
            *ppdmtaList = NULL;
        }
    }

    // done
    return S_OK;

} //*** end dmtCreateActionList()


//===========================================================================
// dmtcfgFreeActionList
//
// Frees the linked list created by dmtcfgCreateActionList
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  08/24/1999 - davidkl - created
//  08/25/1999 - davidkl - implemented
//===========================================================================
HRESULT dmtcfgFreeActionList(DMTACTION_NODE **ppdmtaList)
{
    HRESULT         hRes    = S_OK;
    DMTACTION_NODE  *pNode  = NULL;

    // validate ppdmtaList
    if(IsBadWritePtr((void*)ppdmtaList, sizeof(PDMTACTION_NODE)))
    {
        DPF(0, "dmtcfgFreeActionList - Invalid ppdmtaList (%016Xh)",
            ppdmtaList);
        return E_POINTER;
    }

    // validate *ppdmtaList
    if(IsBadReadPtr((void*)*ppdmtaList, sizeof(DMTACTION_NODE)))
    {
        if(NULL != *ppdmtaList)
        {
            DPF(0, "dmtcfgFreeActionList - Invalid *ppdmtaList (%016Xh)",
                *ppdmtaList);        
            return E_POINTER;
        }
        else
        {
            // if NULL, then return "did nothing"
            DPF(3, "dmtcfgFreeActionList - Nothing to do....");
            return S_FALSE;
        }
    }

    // walk the list and free each object
    while(*ppdmtaList)
    {
        pNode = *ppdmtaList;
        *ppdmtaList = (*ppdmtaList)->pNext;

        // free the node
        DPF(5, "dmtcfgFreeActionList - deleting Node (%016Xh)", pNode);
        if(LocalFree((HLOCAL)pNode))
        {
            DPF(0, "dmtcfgFreeActionList - MEMORY LEAK - "
                "LocalFree(Node) failed (%d)...",
                GetLastError());
            hRes = DMT_S_MEMORYLEAK;
        }
        DPF(5, "dmtcfgFreeActionList - Node deleted");
    }

    // make sure that we set *ppObjList to NULL
    *ppdmtaList = NULL;

    // done
    return hRes;

} //*** end dmtcfgFreeActionList()


//===========================================================================
// dmtcfgCreateMappingList
//
// Creates a device mapping list
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  09/23/1999 - davidkl - created
//===========================================================================
HRESULT dmtcfgCreateMappingList(DMTDEVICE_NODE *pDeviceList,
                                DMTACTION_NODE *pActions,
                                DMTMAPPING_NODE **ppdmtmList)
{
    HRESULT         hRes            = S_OK;
    UINT            uActions        = NULL;
    DMTACTION_NODE  *pActionNode    = NULL;
    DMTMAPPING_NODE *pNew           = NULL;
    DMTMAPPING_NODE *pCurrent       = NULL;
	DMTDEVICE_NODE	*pDeviceNode	= NULL;

    // validate pDeviceList
    if(IsBadReadPtr((void*)pDeviceList, sizeof(DMTDEVICE_NODE)))
    {
        DPF(0, "dmtcfgCreateMappingList - invalid pDeviceList (%016Xh)", 
            pDeviceList);
        return E_POINTER;
    }

    // validate pActions
    if(IsBadReadPtr((void*)pActions, sizeof(DMTACTION_NODE)))
    {
        if(NULL != pActions)
        {
            DPF(0, "dmtcfgCreateMappingList - invalid pActions (%016Xh)", 
                pActions);
            return E_POINTER;
        }
        else
        {
            // no actions for this subgenre
            DPF(3, "dmtcfgCreateMappingList - No actions for this subgenre, "
                "nothing to do...");
            return S_FALSE;
        }

    }
    
    // validate ppdmtmList
    if(IsBadWritePtr((void*)ppdmtmList, sizeof(DMTMAPPING_NODE)))
    {
        DPF(0, "dmtcfgCreateMappingList - invalid ppdmtmList (%016Xh)", 
            ppdmtmList);
        return E_POINTER;
    }


    // check to make sure we are not being asked 
    //  to append to an existing list
    //
    // callers MUST pass a NULL list
    if(*ppdmtmList)
    {
        DPF(0, "dmtcfgCreateMappingList - ppdmtmList points to "
            "existing list! (%016Xh)", *ppdmtmList);
        return E_INVALIDARG;
    }

    __try
    {
        // count the actions
        //
        // this lets us know how much space to allocate for the 
        uActions = 0;
        pActionNode = pActions;
        while(pActionNode)
        {
            uActions++;
            
            // next node
            pActionNode = pActionNode->pNext;
        }

        // for each device
		pDeviceNode = pDeviceList;
		while(pDeviceNode)
		{
			// allocate the mapping node
			pNew = (DMTMAPPING_NODE*)LocalAlloc(LMEM_FIXED,
													sizeof(DMTMAPPING_NODE));
			if(!pNew)
			{
                DPF(3, "dmtcfgCreateMappingList - Insufficient memory to "
                    "allocate mapping list node");
				hRes = E_OUTOFMEMORY;
				__leave;
			}

			// initialize the new node
			ZeroMemory((void*)pNew, sizeof(DMTMAPPING_NODE));

			// allocate the action array
			pNew->pdia = (DIACTIONA*)LocalAlloc(LMEM_FIXED,
												uActions * sizeof(DIACTIONA));
			if(!(pNew->pdia))
			{
				hRes = E_OUTOFMEMORY;
				__leave;
			}

			// initial population of the action array
			hRes = dmtinputPopulateActionArray(pNew->pdia,
											uActions,
											pActions);
			if(FAILED(hRes))
			{
				__leave;
			}

			// add the number of actions
			pNew->uActions = uActions;

			// add the device instance guid
			pNew->guidInstance = pDeviceNode->guidInstance;

			// add the new node to the list
			if(pCurrent)
			{
				// append the list
				pCurrent->pNext = pNew;

				// go to the next node
				pCurrent = pCurrent->pNext;
			}
			else
			{
				// new list head
				pCurrent = pNew;
				*ppdmtmList = pCurrent;
			}

			// next device
			pDeviceNode = pDeviceNode->pNext;

		}

    }
    __finally
    {
        // in case of error...
        if(FAILED(hRes))
        {
            // free list
            dmtcfgFreeMappingList(ppdmtmList);
            *ppdmtmList = NULL;
        }
    }

    // done
    return hRes;

} //*** end dmtcfgCreateMappingList()


//===========================================================================
// dmtcfgFreeMappingList
//
// Completely frees a mapping list
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  09/23/1999 - davidkl - created
//===========================================================================
HRESULT dmtcfgFreeMappingList(DMTMAPPING_NODE **ppdmtmList)
{    
    HRESULT         hRes    = S_OK;
    DMTMAPPING_NODE *pNode  = NULL;

    // validate ppdmtmList
    if(IsBadWritePtr((void*)ppdmtmList, sizeof(DMTMAPPING_NODE*)))
    {
        return E_POINTER;
    }

    // validate *ppdmtmList
    if(IsBadWritePtr((void*)*ppdmtmList, sizeof(DMTMAPPING_NODE)))
    {
        if(NULL != *ppdmtmList)
        {
            return E_POINTER;
        }
        else
        {
            // nothing to do
            return S_FALSE;
        }
    }

    // walk the list and free each object
    while(*ppdmtmList)
    {
        pNode = *ppdmtmList;
        *ppdmtmList = (*ppdmtmList)->pNext;

        // first free the action array
        if(LocalFree((HLOCAL)(pNode->pdia)))
        {
            DPF(0, "dmtcfgFreeMappingList - MEMORY LEAK - "
                "LocalFree(pdia) failed (%d)...",
                GetLastError());
            hRes = DMT_S_MEMORYLEAK;
        }

        // lastly, free the node
        DPF(5, "dmtcfgFreeMappingList - deleting Node (%016Xh)", pNode);
        if(LocalFree((HLOCAL)pNode))
        {
            DPF(0, "dmtcfgFreeMappingList - MEMORY LEAK - "
                "LocalFree(Node) failed (%d)...",
                GetLastError());
            hRes = DMT_S_MEMORYLEAK;
        }
        DPF(5, "dmtcfgFreeMappingList - Node deleted");
    }

    // make sure that we set *ppObjList to NULL
    *ppdmtmList = NULL;

    // done
    return hRes;

} //*** end dmtcfgFreeMappingList


//===========================================================================
// dmtcfgCreateAllMappingLists
//
// Uses dmtcfgCreateMappingList to create mapping lists for each subgenre
//  referenced by pdmtai->pGenreList for each device refereced by 
//  pdmtai->pDeviceList
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  09/23/1999 - davidkl - created
//===========================================================================
HRESULT dmtcfgCreateAllMappingLists(DMT_APPINFO *pdmtai)
{
    HRESULT             hRes            = S_OK;
    HRESULT             hr              = S_OK;
    DMTGENRE_NODE       *pGenreNode     = NULL;
    DMTSUBGENRE_NODE    *pSubGenreNode  = NULL;

    // validate pdmtai
    if(IsBadReadPtr((void*)pdmtai, sizeof(DMT_APPINFO)))
    {
        return E_POINTER;
    }

    // validate pdmtai->pGenreList
    if(IsBadReadPtr((void*)(pdmtai->pGenreList), sizeof(DMTGENRE_NODE)))
    {
        return E_POINTER;
    }

    // validate pdmtai->pDeviceList
    if(IsBadReadPtr((void*)(pdmtai->pDeviceList), sizeof(DMTDEVICE_NODE)))
    {
        return E_POINTER;
    }   
    
    // for each genre
    pGenreNode = pdmtai->pGenreList;
    while(pGenreNode)
    {
        // for each subgenre of the genre
        pSubGenreNode = pGenreNode->pSubGenreList;
        while(pSubGenreNode)
        {
            // create the mapping list
            hr = dmtcfgCreateMappingList(pdmtai->pDeviceList,
                                        pSubGenreNode->pActionList,
                                        &(pSubGenreNode->pMappingList));
            if(FAILED(hr))
            {
                hRes = S_FALSE;
            }
            
            // next subgenre
            pSubGenreNode = pSubGenreNode->pNext;
        }
         
        // next genre
        pGenreNode = pGenreNode->pNext;
    }

    // done
    return hRes;

} //*** end dmtcfgCreateAllMappingLists()


//===========================================================================
// dmtcfgFreeAllMappingLists
//
// Walks the provided genre list and frees the mapping list found in each
//  subgenre node
//
// Parameters:
//  DMTGENRE_NODE   *pdmtgList  - list of genres
//
// Returns: HRESULT
//
// History:
//  10/05/1999 - davidkl - created
//===========================================================================
HRESULT dmtcfgFreeAllMappingLists(DMTGENRE_NODE *pdmtgList)
{
    HRESULT             hRes        = S_OK;
    HRESULT             hr          = S_OK;
    DMTGENRE_NODE       *pGenre     = NULL;
    DMTSUBGENRE_NODE    *pSubGenre  = NULL;

    // validate pdmtgList
    if(IsBadReadPtr((void*)pdmtgList, sizeof(DMTGENRE_NODE)))
    {
        return E_POINTER;
    }

    // walk the genre list
    pGenre = pdmtgList;
    while(pGenre)
    {
        // walk each subgenre list
        pSubGenre = pGenre->pSubGenreList;
        while(pSubGenre)
        {
            // free the mapping list
            hr = dmtcfgFreeMappingList(&(pSubGenre->pMappingList));
            if(S_OK != hr)
            {
                hRes = hr;
            }

            // next subgenre
            pSubGenre = pSubGenre->pNext;
        }

        // next genre
        pGenre = pGenre->pNext;
    }    

    // done
    return hRes;

} //*** end dmtcfgFreeAllMappingLists()


//===========================================================================
// dmtcfgMapAction
//
// Connects the dots between an action (in the map config dialog) to a device
//   object
//
// Parameters:
//  HWND        hwnd            - handle to property page window
//  REFGUID     guidInstance    - instance GUID of DirectInputDevice object
//  DIACTIONA   *pdia           - ptr to array of DIACTIONA structuresfs
//  UINT        uActions        - number of actions in pdia
//
// Returns: HRESULT
//
// History:
//  09/14/1999 - davidkl - created
//===========================================================================
HRESULT dmtcfgMapAction(HWND hwnd,
                        REFGUID guidInstance,
                        DIACTIONA *pdia,
                        UINT uActions)
{
    HRESULT                 hRes        = S_OK;
   // UINT                    uObjectSel  = 0;
	//JJ 64Bit Compat
	UINT_PTR				uObjectSel	= 0;
	UINT_PTR				uActionSel	= 0;
   // UINT                    uActionSel  = 0;
    UINT                    u           = 0;
    BOOL                    fFound      = FALSE;
    DMTDEVICEOBJECT_NODE    *pObject    = NULL;
    DMTACTION_NODE          *pAction    = NULL;

    // valudate pdia
    if(IsBadWritePtr((void*)pdia, sizeof(DIACTION)))
    {
        DPF(0, "dmtinputMapAction - invalid pdia (%016Xh)",
            pdia);
        return E_POINTER;
    }

    __try
    {
        // get the object & it's data
        uObjectSel = SendMessageA(GetDlgItem(hwnd, IDC_CONTROLS),
                                LB_GETCURSEL,
                                0,
                                0L);
        pObject = (DMTDEVICEOBJECT_NODE*)SendMessageA(GetDlgItem(hwnd, 
                                                                IDC_CONTROLS),
                                                    LB_GETITEMDATA,
                                                    (WPARAM)uObjectSel,
                                                    0L);
        if(!pObject)
        {
            hRes = E_UNEXPECTED;
            __leave;
        }

        // get the action's data
        uActionSel = SendMessageA(GetDlgItem(hwnd, IDC_ACTIONS),
                                LB_GETCURSEL,
                                0,
                                0L);
        pAction = (DMTACTION_NODE*)SendMessageA(GetDlgItem(hwnd, IDC_ACTIONS),
                                            LB_GETITEMDATA,
                                            (WPARAM)uActionSel,
                                            0L);
        if(!pAction)
        {
            hRes = E_UNEXPECTED;
            __leave;
        }

        // find the appropriate action in the array
        fFound = FALSE;
        for(u = 0; u < uActions; u++)
        {
            // match based on the semantic / action id
            if((pdia + u)->dwSemantic == pAction->dwActionId)
            {
                DPF(2, "dmtcfgMapAction - found matching action "
                    "pAction->dwActionId (%08Xh) == "
                    "(pdia+u)->dwSemantic (%08Xh)",
                    pAction->dwActionId,
                    (pdia + u)->dwSemantic);
                fFound = TRUE;
                break;
            }
        }

        // did we find the action in the array?
        if(!fFound)
        {
            // no.  this is very bad!
            //
            // if this EVER happens, 
            //  we have a serious bug in this app
            hRes = E_FAIL;
            // since this should NEVER happen, 
            //  break into the debugger and alert the tester
            DPF(0, "dmtcfgMapAction - action not found in pdia!");
            DPF(0, "dmtcfgMapAction - we were looking for "
                "%08Xh (%s)",
                pAction->dwActionId,
                pAction->szActionId);
            DPF(0, "dmtcfgMapAction - CRITICAL failure.  "
                "This should have never happened!");
            DPF(0, "dmtcfgMapAction - Please find someone "
                "to look at this right away.  ");
            DebugBreak();
            __leave;
        }

        // update the action array
        (pdia + u)->dwObjID    = pObject->dwObjectType;
        (pdia + u)->guidInstance        = guidInstance;
        // HIWORD((DWORD)uAppData) == object type
        // LOWORD((DWORD)uAppData) == pObject->wCtrlId
        (pdia + u)->uAppData            = (DIDFT_GETTYPE(pObject->dwObjectType) << 16) | 
                                        (pObject->wCtrlId);

        // update the list boxes
        SendMessageA(hwnd,
                    WM_DMT_UPDATE_LISTS,
                    0,
                    0L);

        // enable the unmap & unmap all buttons
        EnableWindow(GetDlgItem(hwnd, IDC_UNMAP_ALL),         TRUE);
        EnableWindow(GetDlgItem(hwnd, IDC_UNMAP),    TRUE);
        // disable the map button
        EnableWindow(GetDlgItem(hwnd, IDC_STORE_MAPPING),       FALSE);

    }
    __finally
    {
        // cleanup

        // nothing to do... yet
    }

    // done
    return hRes;

} //*** end dmtcfgMapAction()


//===========================================================================
// dmtcfgUnmapAction
//
// Disconnects the dots between an action (in the map config dialog) and a 
//  device object
//
// Parameters:
//  HWND        hwnd        - handle to property page window
//  DIACTIONA   *pdia       - ptr to DIACTIONA array
//  UINNT       uActions    - number of elements in pdia
//
// Returns: HRESULT
//
// History:
//  09/15/1999 - davidkl - created
//===========================================================================
HRESULT dmtcfgUnmapAction(HWND hwnd,
                        DIACTIONA *pdia,
                        UINT uActions)
{
    HRESULT                 hRes        = S_OK;
    UINT                    u           = 0;
   // UINT                    uSel        = 0;
	//JJ 64Bit Compat
	UINT_PTR				uSel		= 0;
    BOOL                    fFound      = FALSE;
    DMTSUBGENRE_NODE        *pSubGenre  = NULL;
    DMTDEVICEOBJECT_NODE    *pObject    = NULL;

    // validate pdia
    if(IsBadWritePtr((void*)pdia, uActions * sizeof(DIACTIONA)))
    {
        return E_POINTER;
    }

    __try
    {
        // get the current control selection
        uSel = SendMessageA(GetDlgItem(hwnd, IDC_CONTROLS),
                            LB_GETCURSEL,
                            0,
                            0L);
        pObject = (DMTDEVICEOBJECT_NODE*)SendMessageA(GetDlgItem(hwnd, IDC_CONTROLS),
                                                    LB_GETITEMDATA,
                                                    (WPARAM)uSel,
                                                    0L);
        if(!pObject)
        {
            // this is bad
            hRes = E_UNEXPECTED;
            __leave;
        }

        // spin through pdia 
        //  look for an action with our object's offset
        fFound = FALSE;
        for(u = 0; u < uActions; u++)
        {
            // first check the guid
            if(IsEqualGUID(pObject->guidDeviceInstance, (pdia+u)->guidInstance))
            {
                // then compare the offset
                if((pdia+u)->dwObjID == pObject->dwObjectType)
                {
                    fFound = TRUE;
                    break;
                }
            }
        }

        // if nothing is found, 
        //  the selected object is not mapped 
        //
        // (non-critical internal error condition)
        if(!fFound)
        {
            hRes = S_FALSE;
            __leave;
        }

        // reset the guidInstance and dwSemantic fields
        (pdia + u)->guidInstance        = GUID_NULL;
        (pdia + u)->dwObjID    = 0;
        (pdia + u)->uAppData            = 0;

        // update the lists
        SendMessageA(hwnd,
                    WM_DMT_UPDATE_LISTS,
                    0,
                    0L);

        // enable the map button
        EnableWindow(GetDlgItem(hwnd, IDC_STORE_MAPPING),    TRUE);
        // disable the unmap button
        EnableWindow(GetDlgItem(hwnd, IDC_UNMAP), FALSE);

        // if no other actions are mapped,
        //  disable the unmap all button
        fFound = FALSE;
        for(u = 0; u < uActions; u++)
        {
            if(!IsEqualGUID(GUID_NULL, (pdia+u)->guidInstance))
            {
                fFound = TRUE;
            }
        }
        if(!fFound)
        {
            EnableWindow(GetDlgItem(hwnd, IDC_UNMAP_ALL), FALSE);
        }

    }
    __finally
    {
        // cleanup

        // nothing to do... yet
    }

    // done
    return hRes;

} //*** end dmtcfgUnmapAction()


//===========================================================================
// dmtcfgUnmapAllActions
//
// Disconnects the all connections between an action (in the map config 
//  dialog) and a device object
//
// Parameters:
//  HWND        hwnd        - handle to property page window
//  DIACTIONA   *pdia       - ptr to DIACTIONA array
//  UINNT       uActions    - number of elements in pdia
//
// Returns: HRESULT
//
// History:
//  09/15/1999 - davidkl - created
//===========================================================================
HRESULT dmtcfgUnmapAllActions(HWND hwnd,
                            DIACTIONA *pdia,
                            UINT uActions)
{
    UINT u = 0;

    // validate pdia
    if(IsBadWritePtr((void*)pdia, uActions * sizeof(DIACTIONA)))
    {
        return E_POINTER;
    }

    // spin through pdia 
    //  reset the guidInstance and dwSemantic fields
    for(u = 0; u < uActions; u++)
    {
        (pdia + u)->guidInstance        = GUID_NULL;
        (pdia + u)->dwObjID    = 0;
        (pdia + u)->uAppData            = 0;
    }

    // update the lists
    SendMessageA(hwnd,
                WM_DMT_UPDATE_LISTS,
                0,
                0L);

    // disable the unmap & unmap all buttons
    EnableWindow(GetDlgItem(hwnd, IDC_UNMAP),    FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_UNMAP_ALL),         FALSE);
    // enable the map button
    EnableWindow(GetDlgItem(hwnd, IDC_STORE_MAPPING),       TRUE);

    // done
    return S_OK;

} //*** end dmtcfgUnmapAllActions()


//===========================================================================
// dmtcfgIsControlMapped
//
// Checks to see if a control is mapped to an action
//
// Parameters:
//
// Returns:
//
// History:
//  09/15/1999 - davidkl - created
//===========================================================================
BOOL dmtcfgIsControlMapped(HWND hwnd,
                        DIACTIONA *pdia,
                        UINT uActions)
{   
    BOOL                    fMapped     = FALSE;
    UINT                    u           = 0;
   // UINT                    uSel        = 0;
	//JJ 64Bit Compat
	UINT_PTR				uSel		= 0;
    DMTDEVICEOBJECT_NODE    *pObject    = NULL;

    // validate pdia
    if(IsBadReadPtr((void*)pdia, uActions * sizeof(pdia)))
    {
        DPF(0, "dmtcfgIsControlMapped - invalid pdia (%016Xh)",
            pdia);
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    // get the currently selected control
    uSel = SendMessageA(GetDlgItem(hwnd, IDC_CONTROLS),
                        LB_GETCURSEL,
                        0,
                        0L);
    pObject = (DMTDEVICEOBJECT_NODE*)SendMessageA(GetDlgItem(hwnd, IDC_CONTROLS),
                                                LB_GETITEMDATA,
                                                (WPARAM)uSel,
                                                0L);
    if(!pObject)
    {
        // this is bad
        //
        // (serious internal app error)
        SetLastError(ERROR_GEN_FAILURE);
        DebugBreak();
        return FALSE;
    }

    // check the array, 
    //  see if this control is mapped to anything
    fMapped = FALSE;
    for(u = 0; u < uActions; u++)
    {
        // first check the guid
        if(IsEqualGUID(pObject->guidDeviceInstance, (pdia+u)->guidInstance))
        {
            // then compare the offset
            if((pdia+u)->dwObjID == pObject->dwObjectType)
//            if((pdia+u)->dwObjID == pObject->dwObjectOffset)
            {
                fMapped = TRUE;
                break;
            }
        }
    }

    // done
    SetLastError(ERROR_SUCCESS);
    return fMapped;

} //*** end dmtcfgIsControlMapped()


//===========================================================================
// dmtcfgAreAnyControlsMapped
//
// Checks to see if any controls are mapped to an action.
//
// Parameters:
//
// Returns:
//
// History:
//  11/01/1999 - davidkl - created
//===========================================================================
BOOL dmtcfgAreAnyControlsMapped(HWND hwnd,
                                DIACTIONA *pdia,
                                UINT uActions)
{
    BOOL                    fMapped     = FALSE;
    UINT                    u           = 0;

    // validate pdia
    if(IsBadReadPtr((void*)pdia, uActions * sizeof(pdia)))
    {
        DPF(0, "dmtcfgAreAnyControlsMapped - invalid pdia (%016Xh)",
            pdia);
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    // check the array, 
    //  see if this control is mapped to anything
    fMapped = FALSE;
    for(u = 0; u < uActions; u++)
    {
        // check guid
        //
        // if not GUID_NULL, this action is mapped
        if(!IsEqualGUID(GUID_NULL, (pdia+u)->guidInstance))
        {
            fMapped = TRUE;
            break;
        }
    }

    // done
    SetLastError(ERROR_SUCCESS);
    return fMapped;

} //*** end dmtcfgAreAnyControlsMapped()


//===========================================================================
// dmtcfgGetGenreGroupName
//
// Extracts the genre group name from the genres.ini entry
//
// Paramters:
//
// Returns: HRESULT
//
// History:
//  09/28/1999 - davidkl - created
//	09/29/1999 - davidkl - modified "buckets"
//===========================================================================
HRESULT dmtcfgGetGenreGroupName(PSTR szGenreName,
                                PSTR szGenreGroupName)
{
    HRESULT hRes        = S_OK;
    char    *pcFirst    = NULL;
    char    *pcCurrent  = NULL;
    
    // find the first '_'
    pcFirst = strchr(szGenreName, '_');

    // copy the characters between pcFirst and pcLast
	pcCurrent = pcFirst+1;		// skip past the first '_'
    while((*pcCurrent != '_') && (*pcCurrent != '\0'))
    {
        *szGenreGroupName = *pcCurrent;

        // next character
        pcCurrent++;
        szGenreGroupName++;
    }
	*szGenreGroupName = '\0';

    // done
    return hRes;

} //*** end dmtcfgGetGenreGroupName()


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtfail.cpp ===
//===========================================================================
// dmtfail.cpp
//
// Failure details dialog processing
//
// Functions:
//  dmtfailDlgProc
//  dmtfailOnInitDialog
//  dmtfailOnCommand
//
// History:
//  10/11/1999 - davidkl - created
//===========================================================================

#include "dimaptst.h"
#include "dmtfail.h"

//---------------------------------------------------------------------------


//===========================================================================
// dmtfailDlgProc
//
// Dialog procedure for Failure Details box
//
// Parameters: (see SDK help for parameter details)
//  HWND    hwnd
//  UINT    uMsg
//  WPARAM  wparam
//  LPARAM  lparam
//
// Returns: (see SDK help for return value details)
//  BOOL
//
// History:
//  10/11/1999 - davidkl - created
//===========================================================================
/*BOOL*/INT_PTR CALLBACK dmtfailDlgProc(HWND hwnd,
                    UINT uMsg,
                    WPARAM wparam,
                    LPARAM lparam)
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
            return dmtfailOnInitDialog(hwnd,
                                    (HWND)wparam, 
                                    lparam);                                   

        case WM_COMMAND:
            return dmtfailOnCommand(hwnd,
                                    LOWORD(wparam),
                                    (HWND)lparam,
                                    HIWORD(wparam));            
    }

    return FALSE;

} //*** end dmtfailDlgProc


//===========================================================================
// dmtfailOnInitDialog
//
// Handle WM_INITDIALOG processing for the failure details box
//
// Parameters:
//  HWND    hwnd        - handle to property page
//  HWND    hwndFocus   - handle of ctrl with focus
//  LPARAM  lparam      - user data (in this case, PROPSHEETPAGE*)
//
// Returns: BOOL
//
// History:
//  10/11/1999 - davidkl - created
//===========================================================================
BOOL dmtfailOnInitDialog(HWND hwnd, 
                        HWND hwndFocus, 
                        LPARAM lparam)
{
    return TRUE;

} //*** end dmtfailOnInitDialog()


//===========================================================================
// dmtfailOnCommand
//
// Handle WM_COMMAND processing for the failure details box
//
// Parameters:
//  HWND    hwnd        - handle to property page
//  WORD    wId         - control identifier    (LOWORD(wparam))
//  HWND    hwndCtrl    - handle to control     ((HWND)lparam)
//  WORD    wNotifyCode - notification code     (HIWORD(wparam))
//
// Returns: BOOL
//
// History:
//  10/11/1999 - davidkl - created
//===========================================================================
BOOL dmtfailOnCommand(HWND hwnd,
                    WORD wId,
                    HWND hwndCtrl,
                    WORD wNotifyCode)
{
    switch(wId)
    {
        case IDOK:
            EndDialog(hwnd, 0);
            break;

        case IDCANCEL:
            EndDialog(hwnd, -1);
            break;
    }

    // done
    return FALSE;

} //*** dmtfailOnCommand()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtinput.h ===
//===========================================================================
// dmtinput.h
//
// History:
//  08/30/1999 - davidkl - created
//===========================================================================

#ifndef _DMTINPUT_H
#define _DMTINPUT_H

//---------------------------------------------------------------------------

#include <dinputd.h>

//---------------------------------------------------------------------------

// if we ever decide to include dinputp.h
//  these will get skipped.  for now, we need
//  to be sure we update these macros as they
//  change
#ifndef DISEM_PRI_GET
#define DISEM_PRI_GET(x)                   (( (x) & 0x00004000 ) >>14 )      
#endif

#ifndef DISEM_TYPE_GET
#define DISEM_TYPE_GET(x)                  (( (x) & 0x00000600 ) >>9 )  
#endif

//---------------------------------------------------------------------------

#define DMTINPUT_BUFFERSIZE     32

//---------------------------------------------------------------------------

// prototypes
HRESULT dmtinputCreateDeviceList(HWND hwnd,
                                BOOL fEnumSuitable,
                                DMTSUBGENRE_NODE *pdmtsg,
                                DMTDEVICE_NODE **ppdmtdList);
HRESULT dmtinputFreeDeviceList(DMTDEVICE_NODE **ppdmtdList);
HRESULT dmtinputCreateObjectList(IDirectInputDevice8A *pdid,
                                GUID guidInstance,
                                DMTDEVICEOBJECT_NODE **ppdmtoList);
HRESULT dmtinputFreeObjectList(DMTDEVICEOBJECT_NODE **ppdmtoList);
BOOL CALLBACK dmtinputEnumDevicesCallback(LPCDIDEVICEINSTANCEA pddi,
                                        IDirectInputDevice8A *pdid,
                                        DWORD,
                                        DWORD,
                                        void *pvData);
BOOL CALLBACK dmtinputEnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCEA pddoi,
                                                void *pvData);
HRESULT dmtinputPopulateActionArray(DIACTIONA *pdia,
                                    UINT uElements,
                                    DMTACTION_NODE *pdmtaList);
HRESULT dmtinputXlatDIDFTtoInternalType(DWORD dwType,
                                        DWORD *pdwInternalType);
HRESULT dmtinputPrepDevice(HWND hwnd,
                        DWORD dwGenreId,
                        DMTDEVICE_NODE *pDevice,
                        DWORD dwActions,
                        DIACTION *pdia);
DWORD dmtinputGetActionPri(DWORD dwSemantic);
DWORD dmtinputGetActionObjectType(DWORD dwSemantic);
HRESULT dmtinputCreateDirectInput(HINSTANCE hinst,
                                IDirectInput8A **ppdi);
BOOL dmtinputDeviceHasObject(DMTDEVICEOBJECT_NODE *pObjectList,
                            DWORD dwType);
HRESULT dmtinputRegisterMapFile(HWND hwnd,
                                DMTDEVICE_NODE *pDevice);
HRESULT dmtinputGetRegisteredMapFile(HWND hwnd,
                                    DMTDEVICE_NODE *pDevice,
                                    PSTR pszFilename,
                                    DWORD cbFilename);

HRESULT dmtOpenTypeKey( LPCWSTR wszType, 
					   DWORD hKey, 
					   PHKEY phKey );

//---------------------------------------------------------------------------
#endif // _DMTINPUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtstress.h ===
//===========================================================================
// dmtstress.h
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================

#ifndef _DMTSTRESS_H
#define _DMTSTRESS_H

//---------------------------------------------------------------------------

// prototypes
BOOL CALLBACK dmtstressDlgProc(HWND hwnd,
                            UINT uMsg,
                            WPARAM wparam,
                            LPARAM lparam);
BOOL dmtstressOnInitDialog(HWND hwnd, 
                        HWND hwndFocus, 
                        LPARAM lparam);
BOOL dmtstressOnClose(HWND hwnd);
BOOL dmtstressOnCommand(HWND hwnd,
                    WORD wId,
                    HWND hwndCtrl,
                    WORD wNotifyCode);
DWORD WINAPI dmtstressThreadProc(void *pvData);

//---------------------------------------------------------------------------
#endif // _DMTSTRESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmttest.h ===
//===========================================================================
// dmttest.h
//
// History:
//  08/27/1999 - davidkl - created
//===========================================================================

#ifndef _DMTTEST_H
#define _DMTTEST_H

//---------------------------------------------------------------------------

#define DMTTEST_MIN_AXIS_RANGE  0
#define DMTTEST_MAX_AXIS_RANGE  10000

//---------------------------------------------------------------------------

#define DMTTEST_BUTTON_OFF      0
#define DMTTEST_BUTTON_ON       1

//---------------------------------------------------------------------------

#define DMTTEST_POV_CENTERED    0
#define DMTTEST_POV_NORTH       1
#define DMTTEST_POV_SOUTH       2
#define DMTTEST_POV_WEST        3
#define DMTTEST_POV_EAST        4
#define DMTTEST_POV_NORTHWEST   5
#define DMTTEST_POV_NORTHEAST   6
#define DMTTEST_POV_SOUTHWEST   7
#define DMTTEST_POV_SOUTHEAST   8

//---------------------------------------------------------------------------

// prototypes
HRESULT dmttestRunIntegrated(HWND hwnd);
HRESULT dmttestRunMapperCPL(HWND hwnd,
                            BOOL fEditMode);
BOOL dmttestStopIntegrated(HWND hwnd);



//---------------------------------------------------------------------------
#endif // _DMTTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtstress.cpp ===
//===========================================================================
// dmtstress.cpp
//
// Stress mode functionality
//
// Functions:
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================

#include "dimaptst.h"
#include "dmtstress.h"

//---------------------------------------------------------------------------


//===========================================================================
// dmtstressDlgProc
//
// About box dialog processing function
//
// Parameters: (see SDK help for parameter details)
//  HWND    hwnd
//  UINT    uMsg
//  WPARAM  wparam
//  LPARAM  lparam
//
// Returns: (see SDK help for return value details)
//  BOOL
//
// History:
//  08/20/1999 - davidkl - created  
//===========================================================================
BOOL CALLBACK dmtstressDlgProc(HWND hwnd,
                            UINT uMsg,
                            WPARAM wparam,
                            LPARAM lparam)
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
            return dmtstressOnInitDialog(hwnd, 
                                        (HWND)wparam, 
                                        lparam);

        case WM_CLOSE:
            return dmtstressOnClose(hwnd);

        case WM_COMMAND:
            return dmtstressOnCommand(hwnd,
                                    LOWORD(wparam),
                                    (HWND)lparam,
                                    HIWORD(wparam));

    }

    return FALSE;

} //*** end dmtstressDlgProc()


//===========================================================================
// dmtstressOnInitDialog
//
// Handle WM_INITDIALOG processing for the about box
//
// Parameters:
//
// Returns: BOOL
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================
BOOL dmtstressOnInitDialog(HWND hwnd, 
                        HWND hwndFocus, 
                        LPARAM lparam)
{
	DPF(5, "dmtstressOnInitDialog");

    return TRUE;

} //*** end dmtstressOnInitDialog()


//===========================================================================
// dmtstressOnClose
//
// Handle WM_CLOSE processing for the about box
//
// Parameters:
//
// Returns: BOOL
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================
BOOL dmtstressOnClose(HWND hwnd)
{
	DPF(5, "dmtstressOnClose");

    return FALSE;

} //*** end dmtstressOnClose()


//===========================================================================
// dmtstressOnCommand
//
// Handle WM_COMMAND processing for the about box
//
// Parameters:
//
// Returns: BOOL
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================
BOOL dmtstressOnCommand(HWND hwnd,
                    WORD wId,
                    HWND hwndCtrl,
                    WORD wNotifyCode)
{
	DPF(5, "dmtstressOnCommand");

    switch(wId)
    {
        case IDOK:
            // close the dialog
            EndDialog(hwnd, 0);
            break;

        case IDCANCEL:
            // close the dialog
            EndDialog(hwnd, 1);
            break;
    }

    // done
    return FALSE;

} //*** end dmtstressOnCommand()


//===========================================================================
// dmtstressThreadProc
//
// Thread proceedure for stress testing
//
// Parameters:
//  void *pvData    - thread defined data
//
// Returns: DWORD
//
// History:
//  12/03/1999 - davidkl - created
//===========================================================================
DWORD WINAPI dmtstressThreadProc(void *pvData)
{
    HRESULT hRes    = S_OK;

    // ISSUE-2001/03/29-timgill Stress thread procedure does nothing

    // done
    return (DWORD)hRes;

} //*** end dmtstressThreadProc()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtinput.cpp ===
//===========================================================================
// dmtinput.cpp
//
// DirectInput functionality
//
// Functions:
//
// History:
//  08/30/1999 - davidkl - created
//===========================================================================

#include "dimaptst.h"
#include "dmtinput.h"
#include "dmttest.h"

//---------------------------------------------------------------------------

//===========================================================================
// dmtinputCreateDeviceList
//
// Creates a linked list of DirectInputDevice8A objects.  Either enumerates
//  suitable or all joystick/gamepad devices.
//
// NOTE: The actual work of adding a node to the list is performed by the
//  dmtinputEnumDevicesCallback() function.  This function exists merely to
//  present a consistant look & feel with the rest of the list creation 
//  functions used in this app.
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  08/27/1999 - davidkl - created
//  08/30/1999 - davidkl - moved & renamed
//  10/26/1999 - davidkl - added axis range setting
//  10/27/1999 - davidkl - house cleaning
//  02/21/2000 - davidkl - added hwnd and call to dmtinputGetRegisteredMapFile
//===========================================================================
HRESULT dmtinputCreateDeviceList(HWND hwnd,
                                BOOL fEnumSuitable,
                                DMTSUBGENRE_NODE *pdmtsg,
                                DMTDEVICE_NODE **ppdmtdList)
{
    HRESULT                 hRes        = S_OK;
    DWORD                   dwActions   = 0;
    DWORD                   dwType      = 0;
    DMTDEVICE_NODE          *pDevice    = NULL;
    DMTDEVICEOBJECT_NODE    *pObject    = NULL;
    DMTACTION_NODE          *pAction    = NULL;
    IDirectInput8A          *pdi        = NULL;
    DIACTIONA               *pdia       = NULL;
    DIACTIONFORMATA         diaf;
    DIPROPRANGE             dipr;

    // validate pdmtsg
    //
    // this only needs to be valid if fEnumSuitable == TRUE
//    if(fEnumSuitable)
//    {
        DPF(4, "dmtinputCreateDeviceList - Enumerating for "
            "suitable devices... validating pdmtsg");

        if(IsBadReadPtr((void*)pdmtsg, sizeof(DMTSUBGENRE_NODE)))
        {
            DPF(0, "dmtinputCreateDeviceList - invalid pdmtsg (%016Xh)",
                pdmtsg);
            return E_POINTER;
        }
//    }

    // validate ppdmtdList
    //
    // This validation will be performed by dmtinputEnumDevicesCallback

    __try
    {
        // create the dinput object
        hRes = dmtinputCreateDirectInput(ghinst,
                                        &pdi);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputCreateDeviceList - unable to create "
                "DirectInput object (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            hRes = DMT_E_INPUT_CREATE_FAILED;
            __leave;
        }

        // enumerate devices
        //
        // NOTE: this will create the linked list we want
        //  however, it will not create the object list.
//        if(fEnumSuitable)
//        {
            // count the actions
            dwActions = 0;
            pAction = pdmtsg->pActionList;
            while(pAction)
            {
                dwActions++;
                pAction = pAction->pNext;
            }

            // allocate the diaction array
            pdia = (DIACTIONA*)LocalAlloc(LMEM_FIXED,
                                        dwActions * sizeof(DIACTIONA));
            if(!pdia)
            {
                DPF(0, "dmtinputCreateDeviceList - unable to allocate "
                    "DIACTION array");
                hRes = E_OUTOFMEMORY;
                __leave;
            }

            // fill the array with ALL of the actions
            //  for the selected subgenre
            hRes = dmtinputPopulateActionArray(pdia,
                                            (UINT)dwActions,
                                            pdmtsg->pActionList);
            if(FAILED(hRes))
            {
                DPF(0, "dmtinputCreateDeviceList - unable to populate "
                    "DIACTION array (%s == %08Xh)",
                    dmtxlatHRESULT(hRes), hRes);
                __leave;
            }

            // build the diactionformat structure
            ZeroMemory((void*)&diaf, sizeof(DIACTIONFORMATA));
            diaf.dwSize                 = sizeof(DIACTIONFORMATA);
            diaf.dwActionSize           = sizeof(DIACTIONA);
            diaf.dwNumActions           = dwActions;
            diaf.rgoAction              = pdia;
            diaf.dwDataSize             = 4 * diaf.dwNumActions;
            diaf.guidActionMap          = GUID_DIMapTst;
            diaf.dwGenre                = pdmtsg->dwGenreId;
            diaf.dwBufferSize           = DMTINPUT_BUFFERSIZE;
            lstrcpyA(diaf.tszActionMap, DMT_APP_CAPTION);

            // now, enumerate for joystick devices
/*
            hRes = pdi->EnumDevicesBySemantics((LPCSTR)NULL,
                                            &diaf,
                                            dmtinputEnumDevicesCallback,
                                            (void*)ppdmtdList,
                                            DIEDFL_ATTACHEDONLY);
*/
//        }
//        else
//        {
DPF(0, "Calling EnumDevicesBySemantics");
//            hRes = pdi->EnumDevicesBySemantics("TestMe",
            hRes = pdi->EnumDevicesBySemantics((LPCSTR)NULL,
                                            &diaf,
                                            dmtinputEnumDevicesCallback,
                                            (void*)ppdmtdList,
                                            0);//JJFix 34616//DIEDBSFL_ATTACHEDONLY);
//        }
DPF(0, "Returned from EnumDevicesBySemantics");
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputCreateDeviceList - Enum%sDevices "
                "failed (%s == %08Xh)",
                fEnumSuitable ? "Suitable" : "",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // the device enumeration function does not create
        //  the object linked list, we will create it now
        // 
        // steps to do this:
        //  * walk the list.  for each node:
        //  ** call dmtinputCreateObjectList()
        pDevice = *ppdmtdList;
        while(pDevice)
        {            
            // get a list of the device's objects
            hRes = dmtinputCreateObjectList(pDevice->pdid,
                                            pDevice->guidInstance,
                                            &(pDevice->pObjectList));
            if(FAILED(hRes))
            {
                DPF(0, "dmtinputCreateDeviceList - failed to create "
                    "device %s object list (%s == %08Xh)",
                    pDevice->szName,
                    dmtxlatHRESULT(hRes), hRes);
                hRes = S_FALSE;
            }

            // get the registered map file name (if exists)
            // ISSUE-2001/03/29-timgill possible S_FALSE hResult from previous call is ignored
            // (previous call to dmtinputCreateObjectList)
            hRes = dmtinputGetRegisteredMapFile(hwnd,
                                                pDevice,
                                                pDevice->szFilename,
                                                sizeof(char) * MAX_PATH);
            if(FAILED(hRes))
            {
                DPF(0, "dmtinputCreateDeviceList - failed to retrieve "
                    "device %s mapfile name (%s == %08Xh)",
                    pDevice->szName,
                    dmtxlatHRESULT(hRes), hRes);
                hRes = S_FALSE;
            }
          
            // next device
            pDevice = pDevice->pNext;
        }

    }
    __finally
    {
        // free the action array
        if(pdia)
        {
            if(LocalFree((HLOCAL)pdia))
            {
                // memory leak
                DPF(0, "dmtinputCreateDeviceList - MEMORY LEAK - pdia");
                pdia = NULL;
            }
        }

        // if something failed, cleanup the linked list
        if(FAILED(hRes))
        {
            dmtinputFreeDeviceList(ppdmtdList);
        }

        // we don't need the dinput object any more
        SAFE_RELEASE(pdi);
    }

    // done
    return hRes;

} //*** end dmtinputCreateDeviceList()


//===========================================================================
// dmtinputFreeDeviceList
//
// Frees the linked list created by dmtinputCreateDeviceList
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  08/27/1999 - davidkl - created
//  08/30/1999 - davidkl - moved & renamed. added call to pdid->Release()
//===========================================================================
HRESULT dmtinputFreeDeviceList(DMTDEVICE_NODE **ppdmtdList)
{
    HRESULT         hRes    = S_OK;
    DMTDEVICE_NODE  *pNode  = NULL;

    // validate ppdmtaList
    if(IsBadWritePtr((void*)ppdmtdList, sizeof(DMTDEVICE_NODE*)))
    {
        DPF(0, "dmtFreeDeviceList - Invalid ppdmtaList (%016Xh)",
            ppdmtdList);
        return E_POINTER;
    }

    // validate *ppdmtdList
    if(IsBadReadPtr((void*)*ppdmtdList, sizeof(DMTDEVICE_NODE)))
    {
        if(NULL != *ppdmtdList)
        {
            DPF(0, "dmtFreeDeviceList - Invalid *ppdmtdList (%016Xh)",
                *ppdmtdList);        
            return E_POINTER;
        }
        else
        {
            // if NULL, then return "did nothing"
            DPF(3, "dmtFreeDeviceList - Nothing to do....");
            return S_FALSE;
        }
    }

    // walk the list and free each object
    while(*ppdmtdList)
    {
        pNode = *ppdmtdList;
        *ppdmtdList = (*ppdmtdList)->pNext;

        // free the object list first
        //
        // no need to check error results here..
        //
        // error reporting is handled in dmtinputFreeObjectList
        dmtinputFreeObjectList(&(pNode->pObjectList));
                
        // release the device object
        SAFE_RELEASE((pNode->pdid));

        // delete the node
        DPF(5, "dmtFreeDeviceList - deleting Node (%016Xh)", pNode);
        if(LocalFree((HLOCAL)pNode))
        {
            DPF(0, "dmtFreeDeviceList - MEMORY LEAK - "
                "LocalFree() failed (%d)...",
                GetLastError());
            hRes = DMT_S_MEMORYLEAK;
        }
        DPF(5, "dmtFreeDeviceList - Node deleted");
    }

    // make sure that we set *ppObjList to NULL
    *ppdmtdList = NULL;

    // done
    return hRes;

} //*** end dmtinputFreeDeviceList()


//===========================================================================
// dmtinputCreateObjectList
//
// Creates a linked list of device's objects (axes, buttons, povs).
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  08/30/1999 - davidkl - created
//  09/01/1999 - dvaidkl - added pdid
//  02/18/2000 - davidkl - fixed object enumeration to filter anything not
//                      an axis, button or pov
//===========================================================================
HRESULT dmtinputCreateObjectList(IDirectInputDevice8A *pdid,
                                GUID guidInstance,
                                DMTDEVICEOBJECT_NODE **ppdmtoList)
{
    HRESULT                 hRes        = S_OK;
    DMTDEVICEOBJECT_NODE    *pObject    = NULL;

    // validate pdid
    if(IsBadReadPtr((void*)pdid, sizeof(IDirectInputDevice8A)))
    {
        DPF(0, "dmtinputCreateObjectList - invalid pdid (%016Xh)",
            pdid);
        return E_POINTER;
    }

    // validate ppdmtoList
    if(IsBadReadPtr((void*)ppdmtoList, sizeof(DMTDEVICEOBJECT_NODE*)))
    {
        DPF(0, "dmtinputCreateObjectList - invalid ppdmtoList (%016Xh)",
            ppdmtoList);
        return E_POINTER;
    }

    // validate guidInstance
    if(IsEqualGUID(GUID_NULL, guidInstance))
    {
        DPF(0, "dmtinputCreateObjectList - invalid guidInstance (GUID_NULL)");
        return E_INVALIDARG;
    }

    __try
    {
        // enumerate device objects
        //
        // NOTE: this call will create the linked list we want
        hRes = pdid->EnumObjects(dmtinputEnumDeviceObjectsCallback,
                                (void*)ppdmtoList,
                                DIDFT_AXIS | DIDFT_BUTTON | DIDFT_POV);
        if(FAILED(hRes))
        {
            __leave;
        }

        // walk the list and add the guidInstance of the device
        pObject = *ppdmtoList;
        while(pObject)
        {
            // copy the device's guidInstance
            pObject->guidDeviceInstance = guidInstance;

            // next object
            pObject = pObject->pNext;
        }

    }
    __finally
    {
        // if something failed, cleanup the linked list
        if(FAILED(hRes))
        {
            // ISSUE-2001/03/29-timgill Needs error case handling
        }
    }

    // done
    return hRes;

} //*** end dmtinputCreateObjectList()


//===========================================================================
// dmtinputFreeObjectList
//
// Frees the linked list created by dmtinputCreateObjectList
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  08/30/1999 - davidkl - created
//  09/01/1999 - davidkl - implemented
//===========================================================================
HRESULT dmtinputFreeObjectList(DMTDEVICEOBJECT_NODE **ppdmtoList)
{
    HRESULT                 hRes    = S_OK;
    DMTDEVICEOBJECT_NODE    *pNode  = NULL;

    // validate ppdmtaList
    if(IsBadWritePtr((void*)ppdmtoList, sizeof(DMTDEVICEOBJECT_NODE*)))
    {
        DPF(0, "dmtinputFreeObjectList - Invalid ppdmtoList (%016Xh)",
            ppdmtoList);
        return E_POINTER;
    }

    // validate *ppdmtdList
    if(IsBadReadPtr((void*)*ppdmtoList, sizeof(DMTDEVICEOBJECT_NODE)))
    {
        if(NULL != *ppdmtoList)
        {
            DPF(0, "dmtinputFreeObjectList - Invalid *ppdmtdList (%016Xh)",
                *ppdmtoList);        
            return E_POINTER;
        }
        else
        {
            // if NULL, then return "did nothing"
            DPF(3, "dmtinputFreeObjectList - Nothing to do....");
            return S_FALSE;
        }
    }

    // walk the list and free each object
    while(*ppdmtoList)
    {
        pNode = *ppdmtoList;
        *ppdmtoList = (*ppdmtoList)->pNext;

        // delete the node
        DPF(5, "dmtinputFreeObjectList - deleting Node (%016Xh)", pNode);
        if(LocalFree((HLOCAL)pNode))
        {
            DPF(0, "dmtinputFreeObjectList - MEMORY LEAK - "
                "LocalFree() failed (%d)...",
                GetLastError());
            hRes = DMT_S_MEMORYLEAK;
        }
        DPF(5, "dmtinputFreeObjectList - Node deleted");
    }

    // make sure that we set *ppObjList to NULL
    *ppdmtoList = NULL;

    // done
    return hRes;

} //*** end dmtinputFreeObjectList()


//===========================================================================
// dmtinputEnumDevicesCallback
//
// Enumeration callback funtion called by DirectInput in response to an app
//  calling IDirectInput#A::EnumDevices().  
//
// Parameters:
//  LPCDIDEVICEINSTANCEA    pddi    - device instance data (ANSI version)
//  void                    *pvData - app specific data
//
// Returns:
//  BOOL : DIENUM_CONTINUE or DIENUM_STOP
//
// History:
//  08/30/1999 - davidkl - created
//  11/08/1999 - davidkl - added object counts
//  12/01/1999 - davidkl - now keeping product name
//  02/23/2000 - davidkl - updated to EnumDevicesBySemantic
//===========================================================================
BOOL CALLBACK dmtinputEnumDevicesCallback(LPCDIDEVICEINSTANCEA pddi,
                                        IDirectInputDevice8A *pdid,
                                        DWORD,
                                        DWORD,
                                        void *pvData)
{
    HRESULT         hRes        = S_OK;
    BOOL            fDirective  = DIENUM_CONTINUE;
    DMTDEVICE_NODE  **ppList    = (DMTDEVICE_NODE**)pvData;
    DMTDEVICE_NODE  *pCurrent   = NULL;
    DMTDEVICE_NODE  *pNew       = NULL;
    DIDEVCAPS       didc;
    DIPROPDWORD     dipdw;
DPF(0, "dmtinputEnumDevicesCallback - IN");

    // validate pddi
    // 
    // NOTE: we are going to trust (for now) that DirectInput will
    //  pass us valid data

    // validate pdid
    // 
    // NOTE: we are going to trust (for now) that DirectInput will
    //  pass us valid data

    // validate ppList
    if(IsBadWritePtr((void*)ppList, sizeof(DMTDEVICE_NODE*)))
    {
        return DIENUM_STOP;
    }

    // validate *ppList
    if(IsBadWritePtr((void*)*ppList, sizeof(DMTDEVICE_NODE)))
    {
        if(NULL != *ppList)
        {
            return DIENUM_STOP;
        }
    }

    __try
    {
        // we are handed a mouse or keyboard
        //
        // skip to the next device
        if((DI8DEVTYPE_MOUSE == DIDFT_GETTYPE(pddi->dwDevType)) || 
            (DI8DEVTYPE_KEYBOARD == DIDFT_GETTYPE(pddi->dwDevType)))
        {
            DPF(2, "dmtinputEnumDevicesCallback - "
                "Keyboard/Mouse found.  Skipping.");
            fDirective = DIENUM_CONTINUE;
            __leave;
        }

        pCurrent = *ppList;

        // default to "keep enumerating, unless there is nothing else to find"
        fDirective = DIENUM_CONTINUE;

        // get info regarding the device
        ZeroMemory((void*)&didc, sizeof(DIDEVCAPS));
        didc.dwSize = sizeof(DIDEVCAPS);
        hRes = pdid->GetCapabilities(&didc);
        if(FAILED(hRes))
        {
            // unable to retrieve device info... this is bad
            DPF(0, "dmtinputEnumDevicesCallback - failed to "
                "retrieve dev caps (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            DebugBreak();
            hRes = E_UNEXPECTED;
            __leave;
        }

        DPF(3, "dmtinputEnumDevicesCallback - Device: %s",
            pddi->tszProductName);

        // allocate a new node
        pNew = (DMTDEVICE_NODE*)LocalAlloc(LMEM_FIXED,
                                        sizeof(DMTDEVICE_NODE));
        if(!pNew)
        {
            DPF(1, "dmtinputEnumDevicesCallback - insufficient "
                "memory to allocate device node");
            fDirective = DIENUM_STOP;
            __leave;
        }

        // populate the new node
        ZeroMemory((void*)pNew, sizeof(DMTDEVICE_NODE));

        // name(s)
        lstrcpyA(pNew->szName, pddi->tszInstanceName);
        lstrcpyA(pNew->szProductName, pddi->tszProductName);

        // instance guid
        pNew->guidInstance = pddi->guidInstance;

        // device type/subtype
        pNew->dwDeviceType = pddi->dwDevType;

        // # axes
        pNew->dwAxes = didc.dwAxes;

        // # buttons
        pNew->dwButtons = didc.dwButtons;

        // # povs
        pNew->dwPovs = didc.dwPOVs;

        // is this a polled device?
        if(DIDC_POLLEDDEVICE & didc.dwFlags)
        {
            // yep, 
            //
            // better make sure we call IDirectInputDevice8A::Poll
            DPF(4, "dmttestGetInput - Polled device");
            pNew->fPolled = TRUE;
        }

        // device object ptr
        pNew->pdid = pdid;
        pdid->AddRef();

        // vendor id / product id
        ZeroMemory((void*)&dipdw, sizeof(DIPROPDWORD));
        dipdw.diph.dwSize       = sizeof(DIPROPDWORD);
        dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
        dipdw.diph.dwHow        = DIPH_DEVICE;
        hRes = (pNew->pdid)->GetProperty(DIPROP_VIDPID,
                                        &(dipdw.diph));
        if(SUCCEEDED(hRes))
        {
            // extract the VID and PID
            pNew->wVendorId  = LOWORD(dipdw.dwData);
            pNew->wProductId = HIWORD(dipdw.dwData);
        }
        else
        {
            // property call failed, assume no VID|PID
            pNew->wVendorId = 0;
            pNew->wProductId = 0;

            // this property call is not critical
            //  it's ok to mask the failure
            hRes = S_FALSE;
        }

        // filename
        lstrcpyA(pNew->szFilename, "\0");


        // append to the end of the list
        if(!pCurrent)
        {
            // make sure we return the head
            *ppList = pNew;
        }
        else
        {
            // walk to the end of the list
            while(pCurrent->pNext)
            {
                pCurrent = pCurrent->pNext;
            }

            // add the node
            pCurrent->pNext = pNew;
        }

    }
    __finally
    {
        // general cleanup

        // in failure case, free pNew
        if(FAILED(hRes))
        {
            DPF(1, "dmtinputEnumDevicesCallback - something failed... ");

            if(pNew)
            {
                DPF(1, "dmtinputEnumDevicesCallback - freeing new device node");
                if(LocalFree((HLOCAL)pNew))
                {
                    // ISSUE-2001/03/29-timgill Needs error case handling
                }
            }
        }
    }

    // continue enumerating
    return fDirective;

} //*** end dmtinputEnumDevicesCallback()


//===========================================================================
// dmtinputEnumDeviceObjectsCallback
//
// Enumeration callback funtion called by DirectInput in response to an app
//  calling IDirectInpuDevice#A::EnumDevices()
//
// Parameters:
//  LPCDIDEVICEOBJECTINSTANCEA  pddi    - device object instance data 
//                                      (ANSI version)
//  void                        *pvData - app specific data
//
// Returns:
//  BOOL : DIENUM_CONTINUE or DIENUM_STOP
//
// History:
//  08/30/1999 - davidkl - created
//  10/21/1999 - davidkl - added object type filtering
//===========================================================================
BOOL CALLBACK dmtinputEnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCEA pddoi,
                                                void *pvData)
{
    BOOL                    fDirective  = DIENUM_CONTINUE;
    WORD                    wOffset     = 0;
    DMTDEVICEOBJECT_NODE    **ppList    = (DMTDEVICEOBJECT_NODE**)pvData;
    DMTDEVICEOBJECT_NODE    *pCurrent   = NULL;
    DMTDEVICEOBJECT_NODE    *pNew       = NULL;

    // validate ppList
    if(IsBadWritePtr((void*)ppList, sizeof(DMTDEVICEOBJECT_NODE*)))
    {
        return DIENUM_STOP;
    }

    // validate *ppList
    if(IsBadWritePtr((void*)*ppList, sizeof(DMTDEVICEOBJECT_NODE)))
    {
        if(NULL != *ppList)
        {
            return DIENUM_STOP;
        }
    }

    __try
    {
        pCurrent = *ppList;

        // default to "keep enumerating, unless there is nothing else to find"
        fDirective = DIENUM_CONTINUE;

/*
        // filter HID collections
        if(DIDFT_COLLECTION & (pddoi->dwType))
        {
            // skip this object
            DPF(3, "dmtinputEnumDeviceObjectsCallback - "
                "object is a collection... skipping");
            __leave;
        }
*/

        // allocate a new node
        pNew = (DMTDEVICEOBJECT_NODE*)LocalAlloc(LMEM_FIXED,
                                        sizeof(DMTDEVICEOBJECT_NODE));
        if(!pNew)
        {
            fDirective = DIENUM_STOP;
            __leave;
        }

        // populate the new node
        ZeroMemory((void*)pNew, sizeof(DMTDEVICEOBJECT_NODE));

        // name
        lstrcpyA(pNew->szName, (LPSTR)pddoi->tszName);

        // object type
        pNew->dwObjectType = pddoi->dwType;

        // object offset
        pNew->dwObjectOffset = pddoi->dwOfs;

        // HID usage page
        pNew->wUsagePage = pddoi->wUsagePage;

        // HID usage
        pNew->wUsage = pddoi->wUsage;

        // control "identifier"
        switch(DIDFT_GETTYPE(pddoi->dwType))
        {
            case DIDFT_AXIS:
            case DIDFT_ABSAXIS:
            case DIDFT_RELAXIS:
                pNew->wCtrlId = IDC_AXIS_X + DIDFT_GETINSTANCE(pddoi->dwType);
                break;

            case DIDFT_BUTTON:
            case DIDFT_PSHBUTTON:
            case DIDFT_TGLBUTTON:
                // this is a button, encode as follows:
                //  (BTN1 + (instance % NUM_DISPBTNS)) + 
                //   (BTNS_1_32 + (instance / NUM_DISPBTNS))
                wOffset = DIDFT_GETINSTANCE(pddoi->dwType) / NUM_DISPBTNS;
                pNew->wCtrlId = (wOffset << 8) |
                                (DIDFT_GETINSTANCE(pddoi->dwType) % NUM_DISPBTNS);
                break;

            case DIDFT_POV:
                pNew->wCtrlId = IDC_POV1 + DIDFT_GETINSTANCE(pddoi->dwType);
                break;

            default:
                // we should never hit this
                //  as we filter out objects that are
                //  not one of the types we care about
                break;
        }

        // append to the end of the list
        if(!pCurrent)
        {
            // list head
            pCurrent = pNew;

            // make sure we return the head
            *ppList = pCurrent;
        }
        else
        {
            // walk to the end of the list
            while(pCurrent->pNext)
            {
                pCurrent = pCurrent->pNext;
            }

            // add the node
            pCurrent->pNext = pNew;
        }

    }
    __finally
    {
        // ISSUE-2001/03/29-timgill Needs error case handling
        // Needs some sort of error handling
    }

    // continue enumerating
    return fDirective;

} //*** end dmtinputEnumDeviceObjectsCallback()


//===========================================================================
// dmtinputPopulateActionArray
//
// Fills DIACTIONA array with data from the DMTACTION_NODE list
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  09/08/1999 - davidkl - created
//===========================================================================
HRESULT dmtinputPopulateActionArray(DIACTIONA *pdia,
                                    UINT uElements,
                                    DMTACTION_NODE *pdmtaList)
{
    HRESULT hRes    = S_OK;
    UINT    u       = 0;    

    // validate pdia
    if(IsBadWritePtr((void*)pdia, uElements * sizeof(DIACTIONA)))
    {
        DPF(0, "dmtinputPopulateActionArray - invalid pdia (%016Xh)",
            pdia);
        return E_POINTER;
    }

    // validate pdmtaList
    if(IsBadReadPtr((void*)pdmtaList, sizeof(DMTACTION_NODE)))
    {
        DPF(0, "dmtinputPopulateActionArray - invalid pdmtaList (%016Xh)",
            pdmtaList);
        return E_POINTER;
    }

    // first, flush whatever is currently in the array
    ZeroMemory((void*)pdia, uElements * sizeof(DIACTIONA));

    // next, copy the following DIACTION elements
    //  from the action list to the action array
    //
    // NOTE: All strings referenced in these structurs
    //  are ANSI strings (we are using DIACTIONA)
    //
    //  DIACTION                    DMTACTION_NODE
    //  ========                    ==============
    //  dwSemantic                  dwActionId
    //  lptszActionName             szName
    //
    for(u = 0; u < uElements; u++)
    {
        // make sure there is some data to copy
        if(!pdmtaList)
        {
            DPF(1, "dmtinputPopulateActionArray - Ran out of "
                "list nodes before fully populating DIACTION array");
            hRes = S_FALSE;
            break;
        }

        // copy the data
        (pdia+u)->dwSemantic        = pdmtaList->dwActionId;
        (pdia+u)->lptszActionName   = pdmtaList->szName;

        // go to next list element
        pdmtaList = pdmtaList->pNext;
    }

    // done
    return hRes;

} //*** end dmtinputPopulateActionArray()


//===========================================================================
// dmtinputXlatDIDFTtoInternalType
//
// Converts from the DIDFT_* value (DIDEVICEOBJECTINSTANCE.dwType) to our
//  internal control type value (DMTA_TYPE_*)
//
// Parameters:
//  DWORD   dwType              - value of DIDEVICEOBJECTINSTANCE.dwType
//  DWORD   *pdwInternalType    - ptr to recieve DMTA_TYPE_* value
//
// Returns: HRESULT
//
// History:
//  09/09/1999 - davidkl - created
//===========================================================================
HRESULT dmtinputXlatDIDFTtoInternalType(DWORD dwType,
                                        DWORD *pdwInternalType)
{
    HRESULT hRes    = S_OK;

    // validate pdwInternalType
    if(IsBadWritePtr((void*)pdwInternalType, sizeof(DWORD)))
    {
        DPF(0, "dmtinputXlatDIDFTtoInternalType - invalid pdwInternalType "
            "(%016Xh)", pdwInternalType);
        return E_POINTER;
    }

    // translate
    //
    // OR together axis, button and pov masks, 
    // AND that with the type passed in
    //
    switch((DIDFT_AXIS | DIDFT_BUTTON | DIDFT_POV) & dwType)
    {
        case DIDFT_AXIS:
        case DIDFT_RELAXIS:
        case DIDFT_ABSAXIS:
            DPF(5, "dmtinputXlatDIDFTtoInternalType - AXIS");
            *pdwInternalType = DMTA_TYPE_AXIS;
            break;

        case DIDFT_PSHBUTTON:
        case DIDFT_TGLBUTTON:
        case DIDFT_BUTTON:
            DPF(5, "dmtinputXlatDIDFTtoInternalType - BUTTON");
            *pdwInternalType = DMTA_TYPE_BUTTON;
            break;

        case DIDFT_POV:
            DPF(5, "dmtinputXlatDIDFTtoInternalType - POV");
            *pdwInternalType = DMTA_TYPE_POV;
            break;

        default:
            DPF(5, "dmtinputXlatDIDFTtoInternalType - WHAT IS THIS?");
            *pdwInternalType = DMTA_TYPE_UNKNOWN;
            hRes = S_FALSE;
            break;

    }

    // done
    return hRes;

} //*** end dmtinputXlatDIDFTtoInternalType()


//===========================================================================
// dmtinputPrepDevice
//
// Prepares the device for data retrieval.  Performs the following steps:
//  * Set the cooperative level
//  * Set the data format
//  * Set the buffer size
//
// Parameters:
//  HWND                    hwnd        - handle of app window
//  DWORD                   dwGenreId   - identifier of genre to be tested
//  IDirectInputDevice8A    *pdid       - ptr to device object
//
// Returns: HRESULT
//
// History:
//  09/21/1999 - davidkl - created
//  10/07/1999 - davidkl - added Get/ApplyActionMap calls
//  10/27/1999 - davidkl - added uAppData to pdia, changed param list
//===========================================================================
HRESULT dmtinputPrepDevice(HWND hwnd,
                        DWORD dwGenreId,
                        DMTDEVICE_NODE *pDevice,
                        DWORD dwActions,
                        DIACTIONA *pdia)
{
    HRESULT                 hRes        = S_OK;
    DWORD                   dw          = 0;
    IDirectInputDevice8A    *pdid       = NULL;
    DMTDEVICEOBJECT_NODE    *pObject    = NULL;
    DIACTIONFORMATA         diaf;
    DIPROPDWORD             dipdw;

    // validate pDevice
    if(IsBadReadPtr((void*)pDevice, sizeof(DMTDEVICE_NODE)))
    {
        DPF(0, "dmtinputPrepDevice - invalid pDevice (%016Xh)",
            pDevice);
        return E_POINTER;
    }

    // validate pdia
    if(IsBadReadPtr((void*)pdia, dwActions * sizeof(DIACTIONA)))
    {
        DPF(0, "dmtinputPrepDevice - invalid pdia (%016Xh)",
            pdia);
        return E_POINTER;
    }


    // validate pDevice->pdid
    if(IsBadReadPtr((void*)(pDevice->pdid), sizeof(IDirectInputDevice8A)))
    {
        DPF(0, "dmtinputPrepDevice - invalid pDevice->pdid (%016Xh)",
            pDevice->pdid);
        return E_INVALIDARG;
    }

    // save some typing
    pdid = pDevice->pdid;

    __try
    {
        // set the cooperative level
        hRes = pdid->SetCooperativeLevel(hwnd,
                                        DISCL_NONEXCLUSIVE | DISCL_BACKGROUND);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputPrepDevice - SetCooperativeLevel(non-exclusive | "
                "background) failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // set data buffer size
        ZeroMemory((void*)&dipdw, sizeof(DIPROPDWORD));
        dipdw.diph.dwSize       = sizeof(DIPROPDWORD);
        dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
        dipdw.diph.dwHow        = DIPH_DEVICE;
        dipdw.diph.dwObj        = 0;
        dipdw.dwData            = DMTINPUT_BUFFERSIZE;
        hRes = pdid->SetProperty(DIPROP_BUFFERSIZE,
                                &(dipdw.diph));
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputPrepDevice - SetProperty(buffer size) "
                "failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // populate the diactionformat structure 
        ZeroMemory((void*)&diaf, sizeof(DIACTIONFORMATA));
        diaf.dwSize                 = sizeof(DIACTIONFORMATA);
        diaf.dwActionSize           = sizeof(DIACTIONA);
        diaf.dwNumActions           = dwActions;
        diaf.rgoAction              = pdia;
        diaf.dwDataSize             = 4 * diaf.dwNumActions;
        diaf.guidActionMap          = GUID_DIMapTst;
        diaf.dwGenre                = dwGenreId;
        diaf.dwBufferSize           = DMTINPUT_BUFFERSIZE;
        lstrcpyA(diaf.tszActionMap, DMT_APP_CAPTION);


        // get the action map for this genre (from the device)
        hRes = pdid->BuildActionMap(&diaf,
                                (LPCSTR)NULL,
                                DIDBAM_HWDEFAULTS); 
        DPF(1, "dmtinputPrepDevice - GetActionMap returned %s (%08Xh)",
            dmtxlatHRESULT, hRes);

        if(FAILED(hRes))
        {
            DPF(0, "dmtinputPrepDevice - GetActionMap failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // add the control id/type info to the 
        //  action array
        pObject = pDevice->pObjectList;
        while(pObject)
        {
            // spin through the array
            //
            // look for matching elements
            //  (match == same guidInstance & same offset
            for(dw = 0; dw < dwActions; dw++)
            {
                // first check the guid
                if(IsEqualGUID(pObject->guidDeviceInstance, (pdia+dw)->guidInstance))
                {
                    // then compare the offset
                    if((pdia+dw)->dwObjID == pObject->dwObjectType)
                    {
                        // store the CtrlId and Type
                        (pdia+dw)->uAppData = (DIDFT_GETTYPE(pObject->dwObjectType) << 16) | 
                                            (pObject->wCtrlId);

                        // skip out of the for loop
                        break;
                    }
                }
            }

            // next object
            pObject = pObject->pNext;
        }

        // apply the action map for this genre
        //
        // this accomplishes the same task as calling SetDataFormat
        hRes = pdid->SetActionMap(&diaf,
                                NULL,
                                DIDSAM_DEFAULT);
        DPF(1, "dmtinputPrepDevice - ApplyActionMap returned %s (%08Xh)",
            dmtxlatHRESULT, hRes);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputPrepDevice - ApplyActionMap failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

    }
    __finally
    {
        // ISSUE-2001/03/29-timgill Needs error case handling
    }

    // done
    return hRes;

} //*** end dmtinputPrepDevice()


//===========================================================================
// dmtinputGetActionPri
//
// Extracts the action priority from the DirectInput semantic
//
// Parameters:
//  DWORD   dwSemantic  - DirectInput action semantic
//
// Returns: int (Action priority)
//
// History:
//  09/28/1999 - davidkl - created
//  10/27/1999 - davidkl - code review cleanup
//===========================================================================
DWORD dmtinputGetActionPri(DWORD dwSemantic)
{

    // action priority is 0 based, we want to return
    //  priority 1 based for display purposes
    return (DWORD)(DISEM_PRI_GET(dwSemantic) + 1);

} //*** end dmtinputGetActionPri()


//===========================================================================
// dmtinputGetActionObjectType
//
// Extracts the object type from the DirectInput semantic and returns it
//  as one of DIMapTst's internal object types.
//
// Parameters:
//  DWORD   dwSemantic  - DirectInput action semantic
//
// Returns: DWORD (internal object type)
//
// History:
//  09/28/1999 - davidkl - created
//===========================================================================
DWORD dmtinputGetActionObjectType(DWORD dwSemantic)
{
    DWORD dwObjType = DMTA_TYPE_UNKNOWN;

    // we achieve our goal by:
    //  * extracting and shifting object typw with DISEM_TYPE_GET
    //  ** value becomes 1, 2, or 3 (DirectInput's system)
    //  * subtracting 1 to be 0 based
    //  ** value becomes 0, 1, or 2 (DIMapTst's system)
    dwObjType = DISEM_TYPE_GET(dwSemantic) - 1;

    // done
    return dwObjType;

} //*** end dmtinputGetActionObjectType()


//===========================================================================
// dmtinputCreateDirectInput
//
// Creates a DirectInpu8A object
//
// Parameters:
//  IDirectInput8A  **ppdi  - ptr to directinput object ptr
//
// Returns: HRESULT
//
// History:
//  10/06/1999 - davidkl - created
//  10/27/1999 - davidkl - house cleaning
//===========================================================================
HRESULT dmtinputCreateDirectInput(HINSTANCE hinst,
                                IDirectInput8A **ppdi)
{
    HRESULT hRes    = S_OK;

    // validate ppdi
    if(IsBadWritePtr((void*)ppdi, sizeof(IDirectInput8A*)))
    {
        DPF(0, "dmtinputCreateDirectInput - invalid ppdi (%016Xh)",
            ppdi);
        return E_POINTER;
    }

    __try
    {
        // cocreate IDirectInput8A
        hRes = CoCreateInstance(CLSID_DirectInput8,
                                NULL,
                                CLSCTX_ALL,
                                IID_IDirectInput8A,
                                (void**)ppdi);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputCreateDirectInput - "
                "CoCreateInstance failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // initialize the new dinput object
        hRes = (*ppdi)->Initialize(hinst,
                            DIRECTINPUT_VERSION);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputCreateDirectInput - IDirectInput8A::"
                "Initialize failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }
    }
    __finally
    {
        // if something fails...

        // release the device object
        if(FAILED(hRes))
        {   
            SAFE_RELEASE((*ppdi));
        }
    }

    // done
    return hRes;

} //*** end dmtinputCreateDirectInput()


//===========================================================================
// dmtinputDeviceHasObject
//
// Determines (from a the supplied object list) whether or not a device
//  reports as having at least one object of the specified type.
//
// Parameters:
//
// Returns: BOOL (FALSE if any invalid parameters)
//
// History:
//  10/28/1999 - davidkl - created
//===========================================================================
BOOL dmtinputDeviceHasObject(DMTDEVICEOBJECT_NODE *pObjectList,
                            DWORD dwType)
{
    BOOL                    fRet        = FALSE;
    DWORD                   dwObjType   = DMTA_TYPE_UNKNOWN;
    DMTDEVICEOBJECT_NODE    *pObject    = NULL;

    pObject = pObjectList;
    while(pObject)
    {
        if(FAILED(dmtinputXlatDIDFTtoInternalType(pObject->dwObjectType,
                                            &dwObjType)))
        {
            // ISSUE-2001/03/29-timgill Needs error case handling
        }
        DPF(3, "dmtinputDeviceHasObject - %s : DIDFT type %08Xh, internal type %d",
            pObject->szName,
            pObject->dwObjectType,
            dwObjType);

        if(dwType == dwObjType)
        {
            fRet = TRUE;
            break;
        }

        // next object
        pObject = pObject->pNext;
    }


    // done
    return fRet;

} //*** end dmtinputDeviceHasObject()


//===========================================================================
// dmtinputRegisterMapFile
//
// Queries DirectInput for the proper location and registers the map file
//  for the specified device.
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  11/04/1999 - davidkl - created
//===========================================================================
HRESULT dmtinputRegisterMapFile(HWND hwnd,
                                DMTDEVICE_NODE *pDevice)
{
    HRESULT                 hRes        = S_OK;
    LONG                    lRet        = 0L;
    HKEY                    hkType      = NULL;
    IDirectInput8A          *pdi        = NULL;
    IDirectInputJoyConfig   *pjoycfg    = NULL;
    DIPROPDWORD             dipdw;
    DIJOYCONFIG             dijc;

    // validate pDevice
    if(IsBadReadPtr((void*)pDevice, sizeof(DMTDEVICE_NODE)))
    {
        DPF(0, "dmtinputRegisterMapFile - invalid pDevice (%016Xh)",
            pDevice);
        return E_POINTER;
    }

    // validate pDevice->pdid
    if(IsBadReadPtr((void*)(pDevice->pdid), sizeof(IDirectInputDevice8A)))
    {
        DPF(0, "dmtinputRegisterMapFile - invalid pDevice->pdid (%016Xh)",
            pDevice->pdid);
        return E_INVALIDARG;
    }

    __try
    {
        // create a directinput object
        hRes = dmtinputCreateDirectInput(ghinst,
                                        &pdi);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputRegisterMapFile - unable to create pdi (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // query for the joyconfig interface
        hRes = pdi->QueryInterface(IID_IDirectInputJoyConfig8,
                                (void**)&pjoycfg);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputRegisterMapFile - QI(JoyConfig) failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // get the device id
        //
        // use DIPROP_JOYSTICKID
        ZeroMemory((void*)&dipdw, sizeof(DIPROPDWORD));
        dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
        dipdw.diph.dwSize       = sizeof(DIPROPDWORD);
        dipdw.diph.dwHow        = DIPH_DEVICE;
        dipdw.diph.dwObj        = 0;
        hRes = (pDevice->pdid)->GetProperty(DIPROP_JOYSTICKID,
                                            &(dipdw.diph));
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputRegisterMapFile - GetProperty(joystick id) failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // prepare the config structure
        ZeroMemory((void*)&dijc, sizeof(DIJOYCONFIG));
        dijc.dwSize         = sizeof(DIJOYCONFIG);

        // set the joycfg cooperative level
        hRes = pjoycfg->SetCooperativeLevel(hwnd, 
                                            DISCL_EXCLUSIVE | DISCL_BACKGROUND);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputRegisterMapFile - SetCooperativeLevel failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // acquire joyconfig
        hRes = pjoycfg->Acquire();
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputRegisterMapFile - Acquire() failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        
        // retrieve the config data
        hRes = pjoycfg->GetConfig((UINT)(dipdw.dwData),
                                &dijc,
                                DIJC_GUIDINSTANCE   |
                                 DIJC_REGHWCONFIGTYPE);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputRegisterMapFile - GetConfig failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // open the type key
        //
        // we are opening for read as well as write so we can
        //  save the previous value
		hRes = 	dmtOpenTypeKey(dijc.wszType,
                                    KEY_READ|KEY_WRITE,
                                    &hkType);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputRegisterMapFile - OpenTypeKey failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // write the map file name
        lRet = RegSetValueExA(hkType,
                            "OEMMapFile",
                            0,
                            REG_SZ,
                            (CONST BYTE*)(pDevice->szFilename),
                            sizeof(char) * 
                                (lstrlenA(pDevice->szFilename) + 1));
        if(ERROR_SUCCESS)
        {
            DPF(0, "dmtinputRegisterMapFile - RegSetValueExA failed (%d)",
                GetLastError());
            __leave;
        }

        // notify dinput that we changed something
        hRes = pjoycfg->SendNotify();
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputRegisterMapFile - SendNotify failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            hRes = S_FALSE;
            __leave;
        }
    }
    __finally
    {
        // cleanup
        if(pjoycfg)
        {
            pjoycfg->Unacquire();
        }

        SAFE_RELEASE(pjoycfg);
        SAFE_RELEASE(pdi);
    }

    // done
    return hRes;

} //*** end dmtinputRegisterMapFile()


//===========================================================================
// dmtinputGetRegisteredMapFile
//
// Retrieves the map file name for the specified device
//
// Parameters:
//  HWND            hwnd
//  DMTDEVICE_NODE  *pDevice
//  PSTR            pszFilename
//
// Returns: HRESULT
//
// History:
//  12/01/1999 - davidkl - created
//  02/21/2000 - davidkl - initial implementation
//===========================================================================
HRESULT dmtinputGetRegisteredMapFile(HWND hwnd,
                                    DMTDEVICE_NODE *pDevice,
                                    PSTR pszFilename,
                                    DWORD cbFilename)
{
    HRESULT                 hRes        = S_OK;
    LONG                    lRet        = 0L;
    HKEY                    hkType      = NULL;
    HKEY                    hKey	    = NULL;
    IDirectInput8A          *pdi        = NULL;
    IDirectInputJoyConfig   *pjoycfg    = NULL;
    DIPROPDWORD             dipdw;
    DIJOYCONFIG             dijc;


    // validate pDevice
    if(IsBadReadPtr((void*)pDevice, sizeof(DMTDEVICE_NODE)))
    {
        DPF(0, "dmtinputGetRegisteredMapFile - invalid pDevice (%016Xh)",
            pDevice);
        return E_POINTER;
    }

    // validate pDevice->pdid
    if(IsBadReadPtr((void*)(pDevice->pdid), sizeof(IDirectInputDevice8A)))
    {
        DPF(0, "dmtinputGetRegisteredMapFile - invalid pDevice->pdid (%016Xh)",
            pDevice->pdid);
        return E_INVALIDARG;
    }

    __try
    {
        // create a directinput object
        hRes = dmtinputCreateDirectInput(ghinst,
                                        &pdi);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputGetRegisteredMapFile - unable to create pdi (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // query for the joyconfig interface
        hRes = pdi->QueryInterface(IID_IDirectInputJoyConfig8,
                                (void**)&pjoycfg);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputGetRegisteredMapFile - QI(JoyConfig) failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // get the device id
        //
        // use DIPROP_JOYSTICKID
        ZeroMemory((void*)&dipdw, sizeof(DIPROPDWORD));
        dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
        dipdw.diph.dwSize       = sizeof(DIPROPDWORD);
        dipdw.diph.dwHow        = DIPH_DEVICE;
        dipdw.diph.dwObj        = 0;
        hRes = (pDevice->pdid)->GetProperty(DIPROP_JOYSTICKID,
                                            &(dipdw.diph));
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputGetRegisteredMapFile - GetProperty(joystick id) failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // prepare the config structure
        ZeroMemory((void*)&dijc, sizeof(DIJOYCONFIG));
        dijc.dwSize         = sizeof(DIJOYCONFIG);

        // set the joycfg cooperative level
        hRes = pjoycfg->SetCooperativeLevel(hwnd, 
                                            DISCL_EXCLUSIVE | DISCL_BACKGROUND);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputGetRegisteredMapFile - SetCooperativeLevel failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // acquire joyconfig
        hRes = pjoycfg->Acquire();
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputGetRegisteredMapFile - Acquire() failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }
        
        // retrieve the config data
        hRes = pjoycfg->GetConfig((UINT)(dipdw.dwData),
                                &dijc,
                                DIJC_GUIDINSTANCE   |
                                 DIJC_REGHWCONFIGTYPE);
        if(FAILED(hRes))
        {
            DPF(0, "dmtinputGetRegisteredMapFile - GetConfig failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

	
	// open the type key
        //
        // we are opening for read as well as write so we can
        //  save the previous value

		hRes = 	dmtOpenTypeKey(dijc.wszType,
                                    KEY_ALL_ACCESS,
                                    &hkType);

        if(FAILED(hRes))
        {
            DPF(0, "dmtinputGetRegisteredMapFile - OpenTypeKey failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

        // read the value of OEMMapfile
        lRet = RegQueryValueExA(hkType,
                            "OEMMapFile",
                            NULL,
                            NULL,
                            (BYTE*)pszFilename,
                            &cbFilename);
        if(ERROR_SUCCESS != lRet)
        {
            // ISSUE-2001/03/29-timgill Need to determine what the error code means and translate -> HRESULT
            hRes = S_FALSE;
            DPF(0, "dmtinputGetRegisteredMapFile - RegQueryValueEx failed (%08Xh)",
                lRet);
            lstrcpyA(pszFilename, "");
            __leave;
        }

    }
    __finally
    {
        // cleanup
        if(pjoycfg)
        {
            pjoycfg->Unacquire();
        }

        SAFE_RELEASE(pjoycfg);
        SAFE_RELEASE(pdi);
    }

    // done
    return hRes;

} //*** end dmtinputGetRegisteredMapFile()


//===========================================================================
// dmtOpenTypeKey
//
// Opens the hard coded DInput registry key...replaces IDirectInputJoyConfig::OpenTypeKey
//
// Parameters:
//  LPCWSTR			wszType
//  DWORD			hKey
//  PHKEY			phKey
//
// Returns: HRESULT
//
// History:
//  08/09/2000 - rossy - initial implementation
//===========================================================================
HRESULT dmtOpenTypeKey( LPCWSTR wszType, DWORD hKey, PHKEY phKey )
{

	char szRegStr[200];
	char* szReg	= "System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\DirectInput\\";

	wsprintf(szRegStr, TEXT("%s%S"), szReg, wszType);

	if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegStr , 0, hKey, phKey))
	{
		return S_OK;
	}
    else
	{
		return E_FAIL;
	}

}//*** end dmtOpenTypeKey()

//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmttest.cpp ===
//===========================================================================
// dmttest.cpp
//
// Device test functionality
//
// Functions:
//  dmttestRunIntegrated
//  dmttestRunMapperCPL
//
// History:
//  08/27/1999 - davidkl - created
//===========================================================================

#include "dimaptst.h"
#include "dmtinput.h"
#include "dmtwrite.h"
#include "dmtfail.h"
#include "dmttest.h"
#include "d3d.h"
#include "assert.h"
#include <tchar.h>
#include <stdio.h>
#include <commdlg.h>

#define DIPROP_MAPFILE MAKEDIPROP(0xFFFD)

//---------------------------------------------------------------------------

// file global variables
HANDLE                  ghthDeviceTest  = NULL;
DIDEVICEOBJECTDATA      *gpdidod        = NULL;
HICON                   ghiButtonState[2];
HICON                   ghiPovState[9];

UINT_PTR				g_NumSubGenres	= 0;


//---------------------------------------------------------------------------


//===========================================================================
// dmttestRunIntegrated
//
// Runs integrated device test, prompts for test results
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  08/27/1999 - davidkl - created
//  11/02/1999 - davidkl - now does all preparation and starts input timer
//  11/10/1999 - davidkl - now allocates and populates pdmtai->pan
//===========================================================================
HRESULT dmttestRunIntegrated(HWND hwnd)
{
    HRESULT                 hRes        = S_OK;

	//JJ 64Bit Compat
	INT_PTR					nIdx		= -1;
    UINT                    u           = 0;
    DWORD                   dw          = 0;
    DMTDEVICE_NODE          *pDevice    = NULL;
    DMTSUBGENRE_NODE        *pSubGenre  = NULL;
    DMTMAPPING_NODE         *pMapping   = NULL;
    DMTACTION_NODE          *pAction    = NULL;
    DMT_APPINFO             *pdmtai     = NULL;
    ACTIONNAME              *pan        = NULL;
    DIACTIONA               *pdia       = NULL;

    // get the app info structure
	//JJ 64Bit Compat
	pdmtai = (DMT_APPINFO*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(!pdmtai)
    {
        return E_UNEXPECTED;
    }

    __try
    {
        // get the currently selected device
        nIdx = SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_LIST),
                        CB_GETCURSEL,
                        0,
                        0L);
        if(-1 == nIdx)
        {
            // this is bad
            hRes = E_UNEXPECTED;
            __leave;
        }
        pDevice = (DMTDEVICE_NODE*)SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_LIST),
                                            CB_GETITEMDATA,
                                            nIdx,
                                            0L);
        if(!pDevice)
        {
            // this is bad
            hRes = E_UNEXPECTED;
            __leave;
        }

        // get the currently selected genre
        nIdx = SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRES),
                        CB_GETCURSEL,
                        0,
                        0L);
        if(-1 == nIdx)
        {
            // this is bad
            hRes = E_UNEXPECTED;
            __leave;
        }
        pSubGenre = (DMTSUBGENRE_NODE*)SendMessageA(GetDlgItem(hwnd, IDC_SUBGENRES),
                                            CB_GETITEMDATA,
                                            nIdx,
                                            0L);
        if(!pSubGenre)
        {
            // this is bad
            hRes = E_UNEXPECTED;
            __leave;
        }

        // match the device with the mapping node
        pMapping = pSubGenre->pMappingList;
        while(pMapping)
        {
            // is this our device's mapping info?
            if(IsEqualGUID(pDevice->guidInstance, pMapping->guidInstance))
            {
                break;
            }

            // next mapping node
            pMapping = pMapping->pNext;
        }
        if(!pMapping)
        {
            // no match found
            hRes = E_UNEXPECTED;
            __leave;
        }

        // allocate the app info's actionname list
        if(pdmtai->pan)
        {
            // for some reason, 
            //  we are attempting to clobber existing data!
            // ISSUE-2001/03/29-timgill Need to raise an error code here
            DebugBreak();
        }
        pdmtai->pan = (ACTIONNAME*)LocalAlloc(LMEM_FIXED, sizeof(ACTIONNAME) * pMapping->uActions);
        if(!(pdmtai->pan))
        {
            hRes = E_UNEXPECTED;
            __leave;
        }
        ZeroMemory((void*)(pdmtai->pan), sizeof(ACTIONNAME) * pMapping->uActions);
        pdmtai->dwActions = (DWORD)(pMapping->uActions);
        pan = pdmtai->pan;

   
        // allocate data buffer
        gpdidod = (DIDEVICEOBJECTDATA*)LocalAlloc(LMEM_FIXED,
                                                DMTINPUT_BUFFERSIZE * 
                                                    sizeof(DIDEVICEOBJECTDATA));
        if(!gpdidod)
        {
            // nothing we can do if we are out of memory
            DPF(0, "dmttestGetInput - unable to allocate data buffer (%d)",
                GetLastError());
            hRes = E_OUTOFMEMORY;
            __leave;
        }

        // setup the device
        hRes = dmtinputPrepDevice(hwnd,
                                pSubGenre->dwGenreId,
                                pDevice,
                                pMapping->uActions,
                                pMapping->pdia);
        if(FAILED(hRes))
        {
            __leave;
        }
   
        // populate the actionname list
        //
        // match pdia->dwSemantic with pAction->dwActionId
        //  if found, copy pAction->szName to pdia->lptszActionName
        pdia = pMapping->pdia;
        for(u = 0; u < pMapping->uActions; u++)
        {
            (pan+u)->dw = (DWORD)/*JJ 64Bit*/(pdia+u)->uAppData;
            lstrcpyA((pan+u)->sz, (pdia+u)->lptszActionName);
        }

        // start the input timer
        DPF(4, "dmttestRunIntegrated - Starting input timer...");
        // ISSUE-2001/03/29-timgill Should check return value here
        SetTimer(hwnd,
                ID_POLL_TIMER,
                DMT_POLL_TIMEOUT,
                NULL);
        
        // en/disable appropriate ui elements
        EnableWindow(GetDlgItem(hwnd, IDOK),                        FALSE);
        EnableWindow(GetDlgItem(hwnd, IDCANCEL),                    TRUE);
        EnableWindow(GetDlgItem(hwnd, IDC_GENRES_LABEL),            FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_DEVICE_GENRES),           FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_ENUM_DEVICES),            FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_DEVICES_LABEL),           FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_DEVICE_LIST),             FALSE);
    //    EnableWindow(GetDlgItem(hwnd, IDC_CONFIGURE),               FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_LAUNCH_CPL_EDIT_MODE),    FALSE);
      //  EnableWindow(GetDlgItem(hwnd, IDC_SAVE_STD),                FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_SAVE_HID),                FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_SAVE_BOTH),               FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_START_WITH_DEFAULTS),     FALSE);
    }
    __finally
    {
        // if something failed
        if(FAILED(hRes))
        {
            if(LocalFree((HLOCAL)(pdmtai->pan)))
            {
                // memory leak
                // ISSUE-2001/03/29-timgill Needs error case handling
            }
        }
    }

    // done
    return S_OK;

} //*** end dmttestRunIntegrated()

BOOL CALLBACK EnumDeviceCallback(const DIDEVICEINSTANCE *lpdidi, LPDIRECTINPUTDEVICE8 lpDID, DWORD dwFlags, DWORD dwDeviceRemaining, LPVOID hwnd)
{
	DIPROPSTRING dips;
	HRESULT hr;

	ZeroMemory(&dips, sizeof(dips));
	dips.diph.dwSize = sizeof(dips);
	dips.diph.dwHeaderSize = sizeof(DIPROPHEADER);
	dips.diph.dwObj = 0;
	dips.diph.dwHow = DIPH_DEVICE;
	hr = lpDID->GetProperty(DIPROP_MAPFILE, &dips.diph);
	if (hr == DIERR_OBJECTNOTFOUND)
	{
		// Map file not specified.  Let the use specify it.
		TCHAR tszMsg[MAX_PATH];
		_stprintf(tszMsg, _T("INI path not specified for %s.  You need to specify it now."), lpdidi->tszInstanceName);
		MessageBox(NULL, tszMsg, _T("Error"), MB_OK);
		// Obstain a file name
		TCHAR tszFilePath[MAX_PATH] = _T("");
		TCHAR tszFileName[MAX_PATH];
		OPENFILENAME ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = (HWND)hwnd;
		ofn.lpstrFilter = _T("INI Files (*.ini)\0*.ini\0All Files (*.*)\0*.*\0");
		ofn.lpstrFile = tszFilePath;
		ofn.nMaxFile = MAX_PATH;
		ofn.lpstrTitle = _T("INI File Path");
		ofn.Flags = OFN_FILEMUSTEXIST;
		GetOpenFileName(&ofn);
		// Obtain the registry key
		LPDIRECTINPUT8 lpDI = NULL;
		LPDIRECTINPUTJOYCONFIG8 lpDIJC = NULL;
		DIJOYCONFIG jc;
		DIPROPDWORD diPropDword;
		HKEY hkType;

		DirectInput8Create(GetModuleHandle(NULL), DIRECTINPUT_VERSION, IID_IDirectInput8, (LPVOID*)&lpDI, NULL);
		if (lpDI)
		{
			lpDI->QueryInterface(IID_IDirectInputJoyConfig8, (LPVOID*)&lpDIJC);
			lpDI->Release();
		}
		if (lpDIJC)
		{
			diPropDword.diph.dwSize = sizeof( diPropDword );
			diPropDword.diph.dwHeaderSize = sizeof( diPropDword.diph );
			diPropDword.diph.dwObj = 0;
			diPropDword.diph.dwHow = DIPH_DEVICE;
			lpDID->GetProperty( DIPROP_JOYSTICKID, &diPropDword.diph );
 
			jc.dwSize = sizeof( jc );
			lpDIJC->GetConfig( diPropDword.dwData, &jc, DIJC_REGHWCONFIGTYPE );
			lpDIJC->SetCooperativeLevel((HWND)hwnd, DISCL_EXCLUSIVE|DISCL_BACKGROUND);
			lpDIJC->Acquire();

			dmtOpenTypeKey(jc.wszType, KEY_ALL_ACCESS, &hkType);

			// Write the INI file name
			RegSetValueEx(hkType, _T("OEMMapFile"), 0, REG_SZ, (LPBYTE)ofn.lpstrFile, (lstrlen(ofn.lpstrFile)+1) * sizeof(TCHAR));

			RegCloseKey(hkType);
			lpDIJC->Unacquire();
			lpDIJC->Release();
		}
	}

	return DIENUM_CONTINUE;
}

//===========================================================================
// ModifyDiactfrmDllPath
//
// Modifies the path of the diactfrm.dll COM server in the registry
// to same as the exe path.
//
// Parameters:
//
// Returns: TRUE if path is modified. FALSE if an error occurred.
//
// History:
//  08/02/2001 - jacklin - created
//===========================================================================
static BOOL ModifyDiactfrmDllPath()
{
	const TCHAR tszFrmwrkPath[] = _T("SOFTWARE\\Classes\\CLSID\\{18AB439E-FCF4-40D4-90DA-F79BAA3B0655}\\InProcServer32");
	const TCHAR tszPagePath[] =   _T("SOFTWARE\\Classes\\CLSID\\{9F34AF20-6095-11D3-8FB2-00C04F8EC627}\\InProcServer32");
	HKEY hKey;
	LONG lResult;

	// Construct the full path of the DLL using current exe path.
	TCHAR tszNewPath[MAX_PATH];
	if (!GetModuleFileName(NULL, tszNewPath, MAX_PATH))
	{
		return FALSE;
	}
	TCHAR *pcLastSlash;
	pcLastSlash = _tcsrchr(tszNewPath, _T('\\'));
	// Replace the exe name with diactfrm.dll
	lstrcpy(pcLastSlash + 1, _T("diactfrm.dll"));

	// Check that the DLL exists
	HANDLE hDllFile = CreateFile(tszNewPath, 0, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
	                             FILE_ATTRIBUTE_NORMAL, NULL);
	if (hDllFile == INVALID_HANDLE_VALUE)
		return FALSE;
	CloseHandle(hDllFile);

	//// Modify the path for framework object

	// Open the key for write access
	lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, tszFrmwrkPath, 0, KEY_WRITE, &hKey);
	if (lResult != ERROR_SUCCESS)
	{
		// Cannot open the key. Most likely some bad error happened.
		// We will do nothing in this case.
		return FALSE;
	}
	// Write the new path to the default value
	lResult = RegSetValue(hKey, NULL, REG_SZ, tszNewPath, lstrlen(tszNewPath));
	RegCloseKey(hKey);
	if (lResult != ERROR_SUCCESS)
	{
		// Error occurred while writing the value.
		return FALSE;
	}

	//// Modify the path for framework page object

	// Open the key for write access
	lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, tszPagePath, 0, KEY_WRITE, &hKey);
	if (lResult != ERROR_SUCCESS)
	{
		// Cannot open the key. Most likely some bad error happened.
		// We will do nothing in this case.
		return FALSE;
	}
	// Write the new path to the default value
	lResult = RegSetValue(hKey, NULL, REG_SZ, tszNewPath, lstrlen(tszNewPath));
	RegCloseKey(hKey);
	if (lResult != ERROR_SUCCESS)
	{
		// Error occurred while writing the value.
		return FALSE;
	}

	return TRUE;
}

//===========================================================================
// RestoreDiactfrmDllPath
//
// Restores the path of the diactfrm.dll COM server in the registry
// to the system directory, which should be the default.
//
// Parameters:
//
// Returns: TRUE if path is modified. FALSE if an error occurred.
//
// History:
//  08/02/2001 - jacklin - created
//===========================================================================
static BOOL RestoreDiactfrmDllPath()
{
	const TCHAR tszFrmwrkPath[] = _T("SOFTWARE\\Classes\\CLSID\\{18AB439E-FCF4-40D4-90DA-F79BAA3B0655}\\InProcServer32");
	const TCHAR tszPagePath[] =   _T("SOFTWARE\\Classes\\CLSID\\{9F34AF20-6095-11D3-8FB2-00C04F8EC627}\\InProcServer32");
	HKEY hKey;
	LONG lResult;

	// Construct the full path of the DLL using current exe path.
	TCHAR tszNewPath[MAX_PATH];
	if (!GetSystemDirectory(tszNewPath, MAX_PATH))
	{
		return FALSE;
	}
	lstrcat(tszNewPath, _T("\\diactfrm.dll"));

	//// Modify the path for framework object

	// Open the key for write access
	lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, tszFrmwrkPath, 0, KEY_WRITE, &hKey);
	if (lResult != ERROR_SUCCESS)
	{
		// Cannot open the key. Most likely some bad error happened.
		// We will do nothing in this case.
		return FALSE;
	}
	// Write the new path to the default value
	lResult = RegSetValue(hKey, NULL, REG_SZ, tszNewPath, lstrlen(tszNewPath));
	RegCloseKey(hKey);
	if (lResult != ERROR_SUCCESS)
	{
		// Error occurred while writing the value.
		return FALSE;
	}

	//// Modify the path for framework page object

	// Open the key for write access
	lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, tszPagePath, 0, KEY_WRITE, &hKey);
	if (lResult != ERROR_SUCCESS)
	{
		// Cannot open the key. Most likely some bad error happened.
		// We will do nothing in this case.
		return FALSE;
	}
	// Write the new path to the default value
	lResult = RegSetValue(hKey, NULL, REG_SZ, tszNewPath, lstrlen(tszNewPath));
	RegCloseKey(hKey);
	if (lResult != ERROR_SUCCESS)
	{
		// Error occurred while writing the value.
		return FALSE;
	}

	return TRUE;
}

//===========================================================================
// dmttestRunMapperCPL
//
// Launches DirectInput Mapper CPL, prompts for test results
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  08/27/1999 - davidkl - created
//  11/04/1999 - davidkl - added support for launching in IHV Edit Mode
//===========================================================================
HRESULT dmttestRunMapperCPL(HWND hwnd,
                            BOOL fEditMode)
{
    HRESULT             hRes                = S_OK;
   // int                 n                   = -1;
	//JJ 64Bit Compat
	INT_PTR				n					= -1;
    UINT                u                   = 0;
    BOOL                fUserMadeChanges    = FALSE;
    DMTDEVICE_NODE      *pDevice            = NULL;
    DMTSUBGENRE_NODE    *pSubGenre          = NULL;
    DMTMAPPING_NODE     *pMapping           = NULL;
    IDirectInput8A      *pdi                = NULL;
    char                szBuf[MAX_PATH];
    //DIACTIONFORMATA             diaf;
	//JJ Fix
	DMTGENRE_NODE		*pGenre				= NULL;
	DIACTIONFORMATA*	pDiaf				= NULL;
	DMT_APPINFO         *pdmtai				= NULL;
	ULONG				i					= 0;
	//JJ TEST
	DICONFIGUREDEVICESPARAMSA   dicdp;

	GUID				guidActionMap;
    DWORD               dwMapUIMode			= 0;

	/////////////////THIS IS WHERE THE FIX FOR USING AN ACTION ARRAY STARTS////////////

	//initialize appropriate mapper UI GUID and display mode
	//RY fix for bug #35577
	if(fEditMode)
	{
		guidActionMap	= GUID_DIConfigAppEditLayout;
		dwMapUIMode		= DICD_EDIT;
	}
	else
	{
		guidActionMap	= GUID_DIMapTst;
		dwMapUIMode		= DICD_DEFAULT;
	}

	pdmtai = (DMT_APPINFO*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
	if(!pdmtai)
    {
        // big problem
        // this should NEVER happen
        // ISSUE-2001/03/29-timgill Needs error case handling
    }

    __try
    {
	//	pDevice = pdmtai->pDeviceList;
        // get the currently selected device
       n = SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_LIST),
                        CB_GETCURSEL,
                        0,
                        0L);
        pDevice = (DMTDEVICE_NODE*)SendMessageA(GetDlgItem(hwnd, IDC_DEVICE_LIST),
                                                CB_GETITEMDATA,
                                                n,
                                                0L);


		//JJ Fix 34157
        if(CB_ERR == (INT_PTR)pDevice)
        {
			MessageBox(hwnd,
					   TEXT("Please install a gaming device"),
					   TEXT("NO DEVICES"),
					   0);
            hRes = E_UNEXPECTED;
            __leave;
        }


		if(fEditMode)
		{
			hRes = dmtwriteWriteFileHeader(hwnd, pDevice);
            if(FAILED(hRes))
            {
                __leave;
            }

			if (S_FALSE == hRes)
			{
				hRes = S_OK;
				__leave;
			}
		
		}

		//JJ FIX
		// create a directinput object
        hRes = dmtinputCreateDirectInput(ghinst,
                                        &pdi);
        if(FAILED(hRes))
        {
            hRes = DMT_E_INPUT_CREATE_FAILED;
            __leave;
        }

		pGenre = pdmtai->pGenreList;
		
		//Allocate out the array...
		pDiaf = (DIACTIONFORMATA*)malloc(sizeof(DIACTIONFORMATA) * g_NumSubGenres);

		ZeroMemory((void*)pDiaf, sizeof(DIACTIONFORMATA) * g_NumSubGenres);

		while(pGenre)
		{
			
			pSubGenre = pGenre->pSubGenreList;
			while(pSubGenre)
			{

				// find the mapping node for the selected device
				pMapping = pSubGenre->pMappingList;

			
				pMapping = pSubGenre->pMappingList;
				while(pMapping)
				{
				if(IsEqualGUID(pDevice->guidInstance,
					        pMapping->guidInstance))
				{
					break;
				}

				// next mapping
				pMapping = pMapping->pNext;
			}
			if(!pMapping)
			{
				// this should never happen

		        hRes = DMT_E_NO_MATCHING_MAPPING;
			    DebugBreak();
				__leave;
			}

				// prepare the DIACTIONFORMAT structure
				pDiaf[i].dwSize                 = sizeof(DIACTIONFORMAT);
				pDiaf[i].dwActionSize           = sizeof(DIACTIONA);
				pDiaf[i].dwNumActions           = (DWORD)(pMapping->uActions);
				pDiaf[i].rgoAction              = pMapping->pdia;
				pDiaf[i].dwDataSize             = 4 * pDiaf[i].dwNumActions;
				pDiaf[i].dwGenre                = pSubGenre->dwGenreId;
				pDiaf[i].dwBufferSize           = DMTINPUT_BUFFERSIZE;
	
	
				//Set up the proper names
				wsprintfA(szBuf, "%s: %s",
							pSubGenre->szName, pSubGenre->szDescription);
				pDiaf[i].guidActionMap  = guidActionMap;
				lstrcpyA(pDiaf[i].tszActionMap, szBuf);

				//Increment the counter
				i++;

				//Next Subgenre
				pSubGenre = pSubGenre->pNext;

			}
			
			//Next Genre
			pGenre = pGenre->pNext;
		}

		assert(i == g_NumSubGenres);

		// Enumerate the devices and check if INI path is set
		pdi->EnumDevicesBySemantics(NULL, pDiaf, ::EnumDeviceCallback, (LPVOID)hwnd, DIEDBSFL_ATTACHEDONLY);


        // prepare the configure devices params
        ZeroMemory((void*)&dicdp, sizeof(DICONFIGUREDEVICESPARAMSA));
        dicdp.dwSize            = sizeof(DICONFIGUREDEVICESPARAMSA);
        dicdp.dwcUsers          = 0;
        dicdp.lptszUserNames    = NULL;
        //dicdp.dwcFormats        = 1;
		dicdp.dwcFormats		= i;//g_NumSubGenres;
        dicdp.lprgFormats       = pDiaf;//&diaf;
        dicdp.hwnd              = hwnd;
        dicdp.lpUnkDDSTarget    = NULL;
        // colors
        
        dicdp.dics.dwSize           = sizeof(DICOLORSET);
/*        dicdp.dics.cTextFore        = D3DRGB(0,0,255);    
        dicdp.dics.cTextHighlight   = D3DRGB(0,255,255);    
        dicdp.dics.cCalloutLine     = D3DRGB(255,255,255);    
        dicdp.dics.cCalloutHighlight= D3DRGB(255,255,0);    
        dicdp.dics.cBorder          = D3DRGB(0,128,255);
        dicdp.dics.cControlFill     = D3DRGB(128,128,255);
        dicdp.dics.cHighlightFill   = D3DRGB(255,0,0);
        dicdp.dics.cAreaFill        = D3DRGB(192,192,192);       */

        // display mapper cpl
		///////////////////////////////END FIX///////////////////////////////////////
		//JJ Fix34958
		EnableWindow(hwnd,
					 FALSE);

		// 8/2/2001 (jacklin): Modify the path of diactfrm.dll COM server to
		//                     use the DDK version of the DLL.
		BOOL bModified = ModifyDiactfrmDllPath();

        hRes = pdi->ConfigureDevices(NULL,
                                    &dicdp,
                                    dwMapUIMode,    // flags
                                    NULL);          // user data for callback fn

		// 8/2/2001 (jacklin): Restore the path of diactfrm.dll COM server
		if (bModified)
			RestoreDiactfrmDllPath();

		EnableWindow(hwnd,
					 TRUE);

        if(FAILED(hRes))
        {
            DPF(0, "ConfigureDevices failed (%s == %08Xh)",
                dmtxlatHRESULT(hRes), hRes);
            __leave;
        }

    }
    __finally
    {
        // general cleanup

        SAFE_RELEASE(pdi);
		if(pDiaf)
		{
			free(pDiaf);
			pDiaf = NULL;
		}
    }

    // done
    return hRes;

} //*** end dmttestRunMapperCPL()


//===========================================================================
// dmttestStopIntegrated
//
// Stops integrated device test
//
// Parameters:
//  HWND    hwnd    - handle of app window
//
// Returns: BOOL
//  TRUE    - Passed
//  FALSE   - Failed
//
// History:
//  09/22/1999 - davidkl - created
//  11/02/1999 - davidkl - stops timer and performs cleanup
//  11/09/1999 - davidkl - added freeing of actionname allocation
//===========================================================================
BOOL dmttestStopIntegrated(HWND hwnd)
{
    int         n       = 0;
    DWORD       dw      = WAIT_ABANDONED;
    BOOL        fPassed = TRUE;
    DMT_APPINFO *pdmtai = NULL;

    // get the app info structure
	//JJ 64Bit Compat
	pdmtai = (DMT_APPINFO*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(!pdmtai)
    {
    // ISSUE-2001/03/29-timgill Needs error case handling
    }

    // stop the input timer
    // ISSUE-2001/03/29-timgill Should check timer was set and  return value
    KillTimer(hwnd,
            ID_POLL_TIMER);

    // free the buffer
    if(gpdidod)
    {
        if(LocalFree((HLOCAL)gpdidod))
        {
            // memory leak
            // ISSUE-2001/03/29-timgill Needs error case handling
        }
    }

    // free the pdmtai actionname list
    if(pdmtai->pan)
    {
        if(LocalFree((HLOCAL)(pdmtai->pan)))
        {
            // memory leak
            // ISSUE-2001/03/29-timgill Needs error case handling
        }
        pdmtai->pan = NULL;
    }


    // prompt for test results
    n = MessageBoxA(hwnd, "Were the correct semantics displayed\r\n"
                "for each device control?",
                "Test Results",
                MB_YESNO);
    if(IDNO == n)
    {
        // display dialog prompting for details
        // ISSUE-2001/03/29-timgill Should test type (cpl/integrated)
        DialogBoxParamA(ghinst,
                    MAKEINTRESOURCEA(IDD_FAILURE_DETAILS),
                    hwnd,
                    dmtfailDlgProc,
                    (LPARAM)NULL);  
    }


    // en/disable appropriate ui elements
    EnableWindow(GetDlgItem(hwnd, IDOK),                        TRUE);
    EnableWindow(GetDlgItem(hwnd, IDCANCEL),                    FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_GENRES_LABEL),            TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_DEVICE_GENRES),           TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_ENUM_DEVICES),            TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_DEVICES_LABEL),           TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_DEVICE_LIST),             TRUE);
  //  EnableWindow(GetDlgItem(hwnd, IDC_CONFIGURE),               TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_LAUNCH_CPL_EDIT_MODE),    TRUE);
 //   EnableWindow(GetDlgItem(hwnd, IDC_SAVE_STD),                TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_SAVE_HID),                TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_SAVE_BOTH),               TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_START_WITH_DEFAULTS),     TRUE);

    // done
    return fPassed;

} //*** end dmttestStopIntegrated()



//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtwrite.cpp ===
//===========================================================================
// dmtwrite.cpp
//
// File / code creation functionality
//
// Functions:
//  dmtwriteBrowse
//  dmtwriteWriteFileHeader
//  dmtwriteReadMappingFile
//  dmtwriteWriteDIHeader
//  dmtwriteWriteDeviceHeader
//  dmtwriteWriteObjectSection
//  dmtwriteWriteAllObjectSections
//  dmtwriteWriteGenreSection
//  dmtwriteWriteAllGenreSections
//  dmtwriteCreateDeviceShorthand
//  dmtwriteDisplaySaveDialog
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================

#include "dimaptst.h"
#include "commdlg.h"
#include "cderr.h"
#include "dmtinput.h"
#include "dmtwrite.h"

//---------------------------------------------------------------------------

//===========================================================================
// dmtwriteWriteFileHeader
//
// Writes the semantic mapping file for the provided device
//    
// Parameters:
//  
// Returns: HRESULT
//
// History:
//  10/11/1999 - davidkl - stubbed
//  10/14/1999 - davidkl - renamed and tweaked
//  11/04/1999 - davidkl - reduced parameter list
//  12/01/1999 - davidkl - now registers file HERE
//===========================================================================
HRESULT dmtwriteWriteFileHeader(HWND hwnd,
                                DMTDEVICE_NODE *pDevice)
{
    HRESULT hRes        = S_OK;
    DWORD   dwGenres    = 0;
	HANDLE hDoesFileExist = NULL;

    // validate pDevice
    if(IsBadReadPtr((void*)pDevice, sizeof(DMTDEVICE_NODE)))
    {
        return E_POINTER;
    }

    __try
    {
        // prompt the user for where to save
        //
        // if we are handed a non-empty filename 
        //  (not == ""), skip this step
//        if(!lstrcmpA("", pDevice->szFilename))
        {
            // display the save dialog
			hRes = dmtwriteDisplaySaveDialog(hwnd, pDevice);

            if(FAILED(hRes))
            {
                __leave;
            }
			    
            if(S_FALSE == hRes)
            {
				//user canceled
                __leave;
            }

        }

        // generate the device shorthand string
        lstrcpyA(pDevice->szShorthandName, pDevice->szName);
/*
        //02/21/2000 - taking this out for now
        hRes = dmtwriteCreateDeviceShorthand(pDevice->szName,
                                            pDevice->szShorthandName);
        if(FAILED(hRes))
        {
            __leave;
        }
*/
		//JT - Fix for 38829 added create to check if file exists prior to writing all the header info back to the file.
		hDoesFileExist = CreateFile(pDevice->szFilename,GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

		if (INVALID_HANDLE_VALUE == hDoesFileExist)
		{
			DPF(0,"This file doesn't exist so we will write the header");
				
        
			// write the DirectInput header
			hRes = dmtwriteWriteDIHeader(pDevice->szFilename,
										pDevice->szShorthandName,
										dwGenres);
			if(FAILED(hRes))
			{
				__leave;
			}

			// write the device header
			hRes = dmtwriteWriteDeviceHeader(pDevice);
			if(FAILED(hRes))
			{
				__leave;
			}

			// write the device object sections
			hRes = dmtwriteWriteAllObjectSections(pDevice->szFilename,
												pDevice->szShorthandName,
												pDevice->pObjectList);
			if(FAILED(hRes))
			{
				__leave;
			}

		} 
		else
		{
			//Otherwise the file does exist and we have to close the handle
			CloseHandle(hDoesFileExist);
		}

		// update the registry
		//
		// this is needed so that dinput can find our new file
		hRes = dmtinputRegisterMapFile(hwnd,
									pDevice);
		if(FAILED(hRes))
		{
			__leave;
		}
    }
    __finally
    {
        // general cleanup

        // nothing to do... yet
    }

    // done
    return hRes;

} //*** end dmtwriteWriteFileHeader()



//===========================================================================
// dmtwriteWriteDIHeader
//
// Writes the DirectInput section of the device mapping ini file.
//
// Parameters:
//
// Returns:
//
// History:
//  10/12/1999 - davidkl - created
//  10/15/1999 - davidkl - tweaked section entries
//===========================================================================
HRESULT dmtwriteWriteDIHeader(PSTR szFilename,
                            PSTR szDeviceShorthand,
                            DWORD dwGenres)
{
    HRESULT hRes        = S_OK;

    __try
    {
        // * di version
        if(!WritePrivateProfileStringA("DirectInput",
                                "DirectXVersion",
                                DMT_DI_STRING_VER,
                                szFilename))
        {
            hRes = DMT_E_FILE_WRITE_FAILED;
            __leave;
        }

        // * device
        // ISSUE-2001/03/29-timgill Need to read original value and support multiple devices
        if(!WritePrivateProfileStringA("DirectInput",
                                "Devices",
                                szDeviceShorthand,
                                szFilename))
        {
            hRes = DMT_E_FILE_WRITE_FAILED;
            __leave;
        }

    }
    __finally
    {
        // cleanup

        // nothing to do... yet
    }

    // done
    return hRes;

} //*** end dmtwriteWriteDIHeader()


//===========================================================================
// dmtwriteWriteDeviceHeader
//
// Writes the device summary section of the device mapping ini file.
//
// Parameters:
//
// Returns:
//
// History:
//  10/12/1999 - davidkl - created
//  11/01/1999 - davidkl - file size reduction changes
//  11/04/1999 - davidkl - reduced parameter list
//===========================================================================
HRESULT dmtwriteWriteDeviceHeader(DMTDEVICE_NODE *pDevice)
{
    HRESULT                 hRes        = S_OK;
    DMTDEVICEOBJECT_NODE    *pObjNode   = NULL;
    UINT                    uAxes       = 0;
    UINT                    uBtns       = 0;
    UINT                    uPovs       = 0;
    char                    szBuf[MAX_PATH];

    // validate pDevice
    if(IsBadReadPtr((void*)pDevice, sizeof(DMTDEVICE_NODE)))
    {
        return E_POINTER;
    }

   __try
    {
        // vendor id
        //
        // only write this if the vid is non-zero
        if(0 != pDevice->wVendorId)
        {
            wsprintfA(szBuf, "%d", pDevice->wVendorId);
            if(!WritePrivateProfileStringA(pDevice->szShorthandName,
                                        "VID",
                                        szBuf,
                                        pDevice->szFilename))
            {
                hRes = DMT_E_FILE_WRITE_FAILED;
                __leave;
            }
        }

        // product id
        //
        // only write this if the pid is non-zero
        if(0 != pDevice->wProductId)
        {
            wsprintfA(szBuf, "%d", pDevice->wProductId);
            if(!WritePrivateProfileStringA(pDevice->szShorthandName,
                                        "PID",
                                        szBuf,
                                        pDevice->szFilename))
            {
                hRes = DMT_E_FILE_WRITE_FAILED;
                __leave;
            }
        }

        // name
        //
        if(!WritePrivateProfileStringA(pDevice->szShorthandName,
                                       "Name",
                                       pDevice->szName,
                                       pDevice->szFilename))
        {
            hRes = DMT_E_FILE_WRITE_FAILED;
            __leave;
        }
 
        // control list
        lstrcpyA(szBuf, "");
        pObjNode = pDevice->pObjectList;  
        while(pObjNode)
        {           
DPF(0, "dmtwriteWriteDeviceHeader - pObjNode         == %016Xh", pObjNode);
DPF(0, "dmtwriteWriteDeviceHeader - pObjNode->szName == %s", pObjNode->szName);
            wsprintfA(szBuf, "%s%s,", szBuf, pObjNode->szName);
DPF(0, "dmtwriteWriteDeviceHeader - szBuf == %s", szBuf);

            // next object
            pObjNode = pObjNode->pNext;
        }
        if(!WritePrivateProfileStringA(pDevice->szShorthandName,
                                    "Controls",
                                    szBuf,
                                    pDevice->szFilename))
        {
DPF(0, "dmtwriteWriteDeviceHeader - writing controls == %s", szBuf);
            hRes = DMT_E_FILE_WRITE_FAILED;
            __leave;
        }

    }
    __finally
    {
        // cleanup

        // nothing to do... yet
    }

    // done
    return hRes;

} //*** end dmtwriteWriteDeviceHeader()


//===========================================================================
// dmtwriteWriteObjectSection
//
// Writes an individual object section of the device mapping ini file.
//
// Parameters:
//
// Returns:
//
// History:
//  10/12/1999 - davidkl - stubbed
//  10/13/1999 - davidkl - initial implementation
//  10/15/1999 - davidkl - added name to section
//  11/01/1999 - davidkl - file size reduction changes
//===========================================================================
HRESULT dmtwriteWriteObjectSection(PSTR szFilename,
                            PSTR szDeviceShorthand,
                            PSTR szObjectName,
                            WORD wUsagePage,
                            WORD wUsage)
{
    HRESULT hRes    = S_OK;
    char    szBuf[MAX_PATH];
    char    szSection[MAX_PATH];

    // construct section name
/*
    wsprintfA(szSection, "%s.%s",
            szDeviceShorthand,
*/
    wsprintfA(szSection, "%s",
            szObjectName);

    // usage page
    //
    // only write this if it is non-zero
    if(0 != wUsagePage)
    {
        wsprintfA(szBuf, "%d", wUsagePage);
        if(!WritePrivateProfileStringA(szSection,
                                    "UsagePage",
                                    szBuf,
                                    szFilename))
        {
            return DMT_E_FILE_WRITE_FAILED;
        }
    }

    // usage
    //
    // only write this if it is non-zero
    if(0 != wUsage)
    {
        wsprintfA(szBuf, "%d", wUsage);
        if(!WritePrivateProfileStringA(szSection,
                                    "Usage",
                                    szBuf,
                                    szFilename))
        {
            return DMT_E_FILE_WRITE_FAILED;
        }
    }

    // name
    //
    // only write this if >both< wUsagePage and wUsage are zero
    if((0 == wUsagePage) && (0 == wUsage))
    {
        if(!WritePrivateProfileStringA(szSection,
                                    "Name",
                                    szObjectName,
                                    szFilename))
        {
            return DMT_E_FILE_WRITE_FAILED;
        }
    }

    // done
    return S_OK;

} //*** end dmtwriteWriteObjectSection()


//===========================================================================
// dmtwriteWriteAllObjectSections
//
// Writes all object sections of the device mapping ini file.
//
// Parameters:
//
// Returns:
//
// History:
//  10/12/1999 - davidkl - stubbed
//  10/13/1999 - davidkl - initial implementation
//===========================================================================
HRESULT dmtwriteWriteAllObjectSections(PSTR szFilename,
                            PSTR szDeviceShorthand,
                            DMTDEVICEOBJECT_NODE *pObjectList)
{
    HRESULT hRes    = S_OK;
    DMTDEVICEOBJECT_NODE    *pObject    = NULL;

    // validate pObjectList
    if(IsBadReadPtr((void*)pObjectList, sizeof(DMTDEVICEOBJECT_NODE)))
    {
        return E_POINTER;
    }
    
    pObject = pObjectList;
    while(pObject)
    {
        hRes = dmtwriteWriteObjectSection(szFilename,
                                        szDeviceShorthand,
                                        pObject->szName,
                                        pObject->wUsagePage,
                                        pObject->wUsage);
        if(FAILED(hRes))
        {
            break;
        }

        // next object
        pObject = pObject->pNext;
    }

    // done
    return hRes;

} //*** end dmtwriteWriteAllObjectSections()


//===========================================================================
// dmtwriteDisplaySaveDialog
//
// Displays Save (As) dialog box promting the user for the filename
//
// Parameters:
//  HWND    hwnd            - handle to owner of save dialog
//  PSTR    szFilename      - receives selected filename (incl. drive & path)
//  int     cchFilename     - count of characters in szFilename buffer
//
// Returns: HRESULT
//
// History:
//  10/14/1999 - davidkl - created
//===========================================================================
HRESULT dmtwriteDisplaySaveDialog(HWND hwnd,
                                DMTDEVICE_NODE *pDevice)
{
    HRESULT         hRes            = S_OK;
	USHORT			nOffsetFilename = 0;
	USHORT			nOffsetExt		= 0;
	
    DWORD           dw              = 0;
    OPENFILENAMEA   ofn;
	char			szTitle[MAX_PATH];

    // initialize Title Text
    lstrcpyA(szTitle, "Select DirectInput(TM) Mapping File");
	lstrcatA(szTitle, " for ");
	lstrcatA(szTitle, pDevice->szName);

    // initialize the ofn struct
    ZeroMemory((void*)&ofn, sizeof(OPENFILENAMEA));
    ofn.lStructSize         = sizeof(OPENFILENAMEA);
    ofn.hwndOwner           = hwnd;
    ofn.hInstance           = (HINSTANCE)NULL;      // not using dlg template
    ofn.lpstrFilter         = "DirectInput(TM) Mapping Files\0*.ini\0";
    ofn.lpstrCustomFilter   = (LPSTR)NULL;          // don't save custom
    ofn.nMaxCustFilter      = 0;                    // ignored based on above
    ofn.nFilterIndex        = 1;                    // display first filter
    ofn.lpstrFile           = pDevice->szFilename;  // filename w/ path
    ofn.nMaxFile            = MAX_PATH;
    ofn.lpstrFileTitle      = (LPSTR)NULL;          // filename w/o path
    ofn.nMaxFileTitle       = 0;
    ofn.lpstrInitialDir     = (LPSTR)NULL;          // use default initial dir
    ofn.lpstrTitle          = szTitle;
    ofn.Flags               = OFN_CREATEPROMPT      |
                            OFN_OVERWRITEPROMPT     |
                            OFN_HIDEREADONLY        |
                            OFN_NOREADONLYRETURN    |
                            OFN_NOTESTFILECREATE;
    ofn.nFileOffset         = (WORD)nOffsetFilename;
    ofn.nFileExtension      = (WORD)nOffsetExt;
    ofn.lpstrDefExt         = "ini";
    ofn.lCustData           = NULL;
    ofn.lpfnHook            = NULL;
    ofn.lpTemplateName      = NULL;

    // display the save dialog
    if(!GetOpenFileNameA(&ofn))
    {
        // either something failed, or the user canceled
        //
        // find out which
        dw = CommDlgExtendedError();
        if( 0 == dw )
        {
            // user canceled
            DPF(2, "dmtwriteDisplaySaveDialog - user canceled");
            hRes = S_FALSE;
        } 
        else
        {
            // failure
            DPF(2, "dmtwriteDisplaySaveDialog - GetSaveFileNameA failed (%d)", dw);
            hRes = E_UNEXPECTED;
        }
    }

    // done
    return hRes;

} //*** end dmtwriteDisplaySaveDialog()


//===========================================================================
// dmtwriteSaveConfDlgProc
//
// Save confirmation dialog processing function
//
// Parameters: (see SDK help for parameter details)
//  HWND    hwnd
//  UINT    uMsg
//  WPARAM  wparam
//  LPARAM  lparam
//
// Returns: (see SDK help for return value details)
//  BOOL
//
// History:
//  10/18/1999 - davidkl - created  
//===========================================================================
INT_PTR WINAPI CALLBACK dmtwriteSaveConfDlgProc(HWND hwnd,
                                    UINT uMsg,
                                    WPARAM wparam,
                                    LPARAM lparam)
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
            return dmtwriteSaveConfOnInitDialog(hwnd, 
                                                (HWND)wparam, 
                                                lparam);

        case WM_COMMAND:
            return dmtwriteSaveConfOnCommand(hwnd,
                                            LOWORD(wparam),
                                            (HWND)lparam,
                                            HIWORD(wparam));
    }

    return FALSE;

} //*** end dmtwriteSaveConfDlgProc()


//===========================================================================
// dmtwriteSaveConfOnInitDialog
//
// Handle WM_INITDIALOG processing for the save confirmation box
//
// Parameters:
//  HWND    hwnd        - handle to property page
//  HWND    hwndFocus   - handle of ctrl with focus
//  LPARAM  lparam      - user data (in this case, PROPSHEETPAGE*)
//
// Returns: BOOL
//
// History:
//  10/18/1999 - davidkl - created
//===========================================================================
BOOL dmtwriteSaveConfOnInitDialog(HWND hwnd, 
                                HWND hwndFocus, 
                                LPARAM lparam)
{
    char    szBuf[MAX_PATH];

    wsprintfA(szBuf, 
            "Save genre group %s action map?",
            (PSTR)lparam);
    SetWindowTextA(hwnd, szBuf);

    SetDlgItemTextA(hwnd, 
                    IDC_GENRE_GROUP, 
                    (PSTR)lparam);

    // done
    return TRUE;

} //*** end dmtwriteSaveConfOnInitDialog()


//===========================================================================
// dmtwriteSaveConfOnCommand
//
// Handle WM_COMMAND processing for the save confirmation box
//
// Parameters:
//  HWND    hwnd        - handle to property page
//  WORD    wId         - control identifier    (LOWORD(wparam))
//  HWND    hwndCtrl    - handle to control     ((HWND)lparam)
//  WORD    wNotifyCode - notification code     (HIWORD(wparam))
//
// Returns: BOOL
//
// History:
//  10/18/1999 - davidkl - created
//===========================================================================
BOOL dmtwriteSaveConfOnCommand(HWND hwnd,
                            WORD wId,
                            HWND hwndCtrl,
                            WORD wNotifyCode)
{
    int nRet = -1;

    switch(wId)
    {
        case IDOK:
            EndDialog(hwnd, (int)IDYES);
            break;

        case IDC_DONT_SAVE:
            EndDialog(hwnd, (int)IDNO);
            break;

        case IDCANCEL:
            EndDialog(hwnd, (int)IDCANCEL);
            break;
    }

    // done
    return FALSE;

} //*** end dmtwriteSaveConfOnCommand()



//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtxlat.h ===
//===========================================================================
// dmtxlat.h
//
// History:
//  11/09/1999 - davidkl - created
//===========================================================================

#ifndef _DMTXLAT_H
#define _DMTXLAT_H

//---------------------------------------------------------------------------

PSTR dmtxlatHRESULT(HRESULT hRes);
PSTR dmtxlatAppData(UINT_PTR uAppData,
                    ACTIONNAME *pan,
                    DWORD dwActions);

//---------------------------------------------------------------------------
#endif // _DMTXLAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtwrite.h ===
//===========================================================================
// dmtwrite.h
//
// History:
//  08/20/1999 - davidkl - created
//===========================================================================

#ifndef _DMTWRITE_H
#define _DMTWRITE_H

//---------------------------------------------------------------------------

// prototypes

HRESULT dmtwriteWriteFileHeader(HWND hwnd,
                                DMTDEVICE_NODE *pDevice);

HRESULT dmtwriteWriteDIHeader(PSTR szFilename,
                            PSTR szDeviceShorthand,
                            DWORD dwGenres);

HRESULT dmtwriteWriteDeviceHeader(DMTDEVICE_NODE *pDevice);

HRESULT dmtwriteWriteObjectSection(PSTR szFilename,
                            PSTR szDeviceShorthand,
                            PSTR szObjectName,
                            WORD wUsagePage,
                            WORD wUsage);

HRESULT dmtwriteWriteAllObjectSections(PSTR szFilename,
                            PSTR szDeviceShorthand,
                            DMTDEVICEOBJECT_NODE *pObjectList);

HRESULT dmtwriteDisplaySaveDialog(HWND hwnd,
                                DMTDEVICE_NODE *pDevice);

INT_PTR WINAPI CALLBACK dmtwriteSaveConfDlgProc(HWND hwnd,
												UINT uMsg,
												WPARAM wparam,
												LPARAM lparam);
BOOL dmtwriteSaveConfOnInitDialog(HWND hwnd, 
									HWND hwndFocus, 
									LPARAM lparam);
BOOL dmtwriteSaveConfOnCommand(HWND hwnd,
									WORD wId,
									HWND hwndCtrl,
									WORD wNotifyCode);


//---------------------------------------------------------------------------
#endif // _DMTWRITE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dmtmsdev.rc
//
#define IDD_ABOUT                       102
#define IDI_DIMAPTST                    103
#define IDI_TESTAPP                     104
#define IDI_DDKAPP                      105
#define IDD_STRESS_CFG                  107
#define IDD_MAIN                        108
#define IDI_INTERNAL                    112
#define IDD_DDKMAIN                     115
#define IDD_DDKAPP                      117
#define IDD_CONFIGURE_MAPPING_PAGE      119
#define IDD_CONFIGURE_GAME_SOURCE       120
#define IDD_FAILURE_DETAILS             121
#define IDD_SAVE_CONFIRMATION           123
#define IDD_INTERNAL                    150
#define IDC_ENUM_DEVICES                1000
#define IDC_DEVICES_LABEL               1001
#define IDC_DEVICE_LIST                 1002
#define IDC_GENRE_LABEL                 1003
#define IDC_SUBGENRES                   1004
#define IDC_TEST_CTRL_GROUP             1010
#define IDC_USE_INTEGRATED              1011
#define IDC_USE_CPL                     1012
#define IDC_VERIFY_GROUP                1020
#define IDC_VERIFY_AUTOMATIC            1021
#define IDC_VERIFY_MANUAL               1022
#define IDC_VERIFY_MANUAL_OVERRIDE      1023
#define IDC_STRESS_OPTS_GROUP           1030
#define IDC_MAPPING_FILE_GROUP          1030
#define IDC_CODE_FRAG_GROUP             1030
#define IDC_CONFIGURE                   1031
#define IDC_STRESS_MODE                 1032
#define IDC_SAVE_STD                    1032
#define IDC_FILENAME_LABEL              1032
#define IDC_STRESS_START                1033
#define IDC_SAVE_HID                    1033
#define IDC_FILENAME                    1033
#define IDC_SAVE_BOTH                   1034
#define IDC_BROWSE                      1034
#define IDC_START_WITH_DEFAULTS         1035
#define IDC_USE_FILE                    1035
#define IDC_LAUNCH_CPL_EDIT_MODE        1036
#define IDC_USE_NOTEPAD                 1036
#define IDC_CREATE                      1037
#define IDC_AXES_LABEL                  1100
#define IDC_AXIS_X_LABEL                1101
#define IDC_AXIS_Y_LABEL                1102
#define IDC_AXIS_Z_LABEL                1103
#define IDC_AXIS_RX_LABEL               1104
#define IDC_AXIS_RY_LABEL               1105
#define IDC_AXIS_RZ_LABEL               1106
#define IDC_AXIS_X                      1107
#define IDC_AXIS_Y                      1108
#define IDC_AXIS_Z                      1109
#define IDC_AXIS_RX                     1110
#define IDC_AXIS_RY                     1111
#define IDC_AXIS_RZ                     1112
#define IDC_BTNS_LABEL                  1200
#define IDC_BTNS_1_32                   1201
#define IDC_BTNS_33_64                  1202
#define IDC_BTNS_65_96                  1203
#define IDC_BTNS_97_128                 1204
#define IDC_BTN1                        1205
#define IDC_BTN2                        1206
#define IDC_BTN3                        1207
#define IDC_BTN4                        1208
#define IDC_BTN5                        1209
#define IDC_BTN6                        1210
#define IDC_BTN7                        1211
#define IDC_BTN8                        1212
#define IDC_BTN9                        1213
#define IDC_BTN10                       1214
#define IDC_BTN11                       1215
#define IDC_BTN12                       1216
#define IDC_BTN13                       1217
#define IDC_BTN14                       1218
#define IDC_BTN15                       1219
#define IDC_BTN16                       1220
#define IDC_BTN17                       1221
#define IDC_BTN18                       1222
#define IDC_BTN19                       1223
#define IDC_BTN20                       1224
#define IDC_BTN21                       1225
#define IDC_BTN22                       1226
#define IDC_BTN23                       1227
#define IDC_BTN24                       1228
#define IDC_BTN25                       1229
#define IDC_BTN26                       1230
#define IDC_BTN27                       1231
#define IDC_BTN28                       1232
#define IDC_BTN29                       1233
#define IDC_BTN30                       1234
#define IDC_BTN31                       1235
#define IDC_BTN32                       1236
#define IDC_POVS_LABEL                  1300
#define IDC_POV1                        1301
#define IDC_POV2                        1302
#define IDC_POV3                        1303
#define IDC_POV4                        1304
#define IDC_SEMANTIC_LABEL              1400
#define IDC_SEMANTIC_ACTION             1401
#define IDC_STRESS_RESULTS_GROUP        1500
#define IDC_RUNNING_THREADS_LABEL       1501
#define IDC_RUNNING_THREADS             1502
#define IDC_TESTED_GENRES_LABEL         1503
#define IDC_TESTED_GENRES               1504
#define IDC_SUITABLE_DEVICES_LABEL      1505
#define IDC_SUITABLE_DEVICES            1506
#define IDC_FAIL_EXPECTED_LABEL         1507
#define IDC_FAIL_EXPECTED               1508
#define IDC_FAILURES_LABEL              1509
#define IDC_FAILURES                    1510
#define IDC_GENRES_LABEL                1900
#define IDC_DEVICE_GENRES               1901
#define IDC_NUMTHREADS                  2000
#define IDC_NUMTHREADS_LABEL            2001
#define IDC_ALL_THREADS_USE_SAME        2002
#define IDC_USE_USERNAME                2003
#define IDC_USERNAME                    2004
#define IDC_USE_APP_GUID                2005
#define IDC_THREADNUM_LABEL             2006
#define IDC_THREADNUM                   2007
#define IDC_USE_CUSTOM_GENRES           2008
#define IDC_DESCRIPTION                 3000
#define IDC_STORE_MAPPING               3001
#define IDC_UNMAP                       3002
#define IDC_UNMAP_ALL                   3003
#define IDC_CONTROL_LABEL               3004
#define IDC_CONTROLS                    3005
#define IDC_ACTIONS_LABEL               3006
#define IDC_ACTIONS                     3007
#define IDC_SUBGENRE_LABEL              3900
#define IDC_SUBGENRE                    3901
#define IDC_TYPE_POV                    3902
#define IDC_TYPE_BUTTON                 3903
#define IDC_TYPE_AXIS                   3904
#define IDC_ADD_ACTION                  4000
#define IDC_REMOVE_ACTION               4001
#define IDC_RENAME_ACTION               4002
#define IDC_CUSTOM_ACTION               4003
#define IDC_SELECTED_ACTIONS            4004
#define IDC_SELECTED_ACTION_LABEL       4005
#define IDC_FAILURE_INFO                5000
#define IDC_NO_PROMPT                   6000
#define IDC_GENRE_GROUP                 6001
#define IDC_DONT_SAVE                   6002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         10009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\dinput.c ===
#define INITGUID
#include "dinput.h"
#include "dinputd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqary.c ===
/*****************************************************************************
 *
 *      diqary.c
 *
 *      Dynamic array manager.
 *
 *****************************************************************************/

#include "diquick.h"

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *      Dary_AppendCbx
 *
 *      Grow if necessary, then copy the goo in if requested.
 *
 *****************************************************************************/

int EXTERNAL
Dary_AppendCbx(PDARY pdary, PCV pvX, int cbX)
{
    if (pdary->cx >= pdary->cxMax) {
        PV rg2;
        int cxNew;

        if (pdary->rgx) {
            cxNew = pdary->cxMax * 2 + 1;
            rg2 = LocalReAlloc(pdary->rgx, cxNew * cbX, LMEM_MOVEABLE);
        } else {
            cxNew = 5;
            rg2 = LocalAlloc(LMEM_FIXED, cxNew * cbX);
        }

        if (rg2) {
            pdary->cxMax = cxNew;
            pdary->rgx = rg2;
        } else {
            return -1;
        }
    }

    if (pvX) {
        CopyMemory(Dary_GetPtrCbx(pdary, pdary->cx, cbX), pvX, cbX);
    }
    return pdary->cx++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dimapcfg\dmtxlat.cpp ===
//===========================================================================
// dmtxlat.cpp
//
// Value lookup tables
//
// Functions:
//  dmtxlatHRESULT
//
// History:
//  11/09/1999 - davidkl - created
//===========================================================================

#include "dimaptst.h"

//---------------------------------------------------------------------------

// HRESULT error list (used by dmtxlatHRESULT)
typedef struct _errlist
{
    HRESULT rval;
    PSTR    sz;
} ERRLIST;

static ERRLIST elErrors[] =
{
    // these are listed as found in dinput.h

    // success codes
    { DI_OK,                            "S_OK" },
    { S_FALSE,                          "DI_NOTATTACHED | DI_BUFFEROVERFLOW | DI_PROPNOEFFECT | DI_NOEFFECT" },
    { DI_POLLEDDEVICE,                  "DI_POLLEDDEVICE" },
    { DI_DOWNLOADSKIPPED,               "DI_DOWNLOADSKIPPED" },
    { DI_EFFECTRESTARTED,               "DI_EFFECTRESTARTED" },
    { DI_TRUNCATED,                     "DI_TRUNCATED" },
    { DI_TRUNCATEDANDRESTARTED,         "DI_TRUNCATEDANDRESTARTED" },
    // failure codes
    { DIERR_OLDDIRECTINPUTVERSION,      "DIERR_OLDDIRECTINPUTVERSION" },
    { DIERR_BETADIRECTINPUTVERSION,     "DIERR_BETADIRECTINPUTVERSION" },
    { DIERR_BADDRIVERVER,               "DIERR_BADDRIVERVER" },
    { REGDB_E_CLASSNOTREG,              "DIERR_DEVICENOTREG" },
    { DIERR_NOTFOUND,                   "DIERR_NOTFOUND | DIERR_OBJECTNOTFOUND" },
    { E_INVALIDARG,                     "DIERR_INVALIDPARAM" },
    { E_NOINTERFACE,                    "DIERR_NOINTERFACE" },
    { E_FAIL,                           "DIERR_GENERIC" },
    { E_OUTOFMEMORY,                    "DIERR_OUTOFMEMORY" },
    { E_NOTIMPL,                        "DIERR_UNSUPPORTED" },
    { DIERR_NOTINITIALIZED,             "DIERR_NOTINITIALIZED" },
    { DIERR_ALREADYINITIALIZED,         "DIERR_ALREADYINITIALIZED" },
    { CLASS_E_NOAGGREGATION,            "DIERR_NOAGGREGATION" },
    { E_ACCESSDENIED,                   "DIERR_OTHERAPPHASPRIO | DIERR_READONLY | DIERR_HANDLEEXISTS" },
    { DIERR_INPUTLOST,                  "DIERR_INPUTLOST" },
    { DIERR_ACQUIRED,                   "DIERR_ACQUIRED" },
    { DIERR_NOTACQUIRED,                "DIERR_NOTACQUIRED" },
    { E_PENDING,                        "E_PENDING" },
    { DIERR_INSUFFICIENTPRIVS,          "DIERR_INSUFFICIENTPRIVS" },
    { DIERR_DEVICEFULL,                 "DIERR_DEVICEFULL" },
    { DIERR_MOREDATA,                   "DIERR_MOREDATA" },
    { DIERR_NOTDOWNLOADED,              "DIERR_NOTDOWNLOADED" },
    { DIERR_HASEFFECTS,                 "DIERR_HASEFFECTS" },
    { DIERR_NOTEXCLUSIVEACQUIRED,       "DIERR_NOTEXCLUSIVEACQUIRED" },
    { DIERR_INCOMPLETEEFFECT,           "DIERR_INCOMPLETEEFFECT" },
    { DIERR_NOTBUFFERED,                "DIERR_NOTBUFFERED" },
    { DIERR_EFFECTPLAYING,              "DIERR_EFFECTPLAYING" },
    { DIERR_UNPLUGGED,                  "DIERR_UNPLUGGED" },
    { DIERR_REPORTFULL,                 "DIERR_REPORTFULL" } 
};


//---------------------------------------------------------------------------


//===========================================================================
// dmtxlatHRESULT
//
// Translates HRESULT codes into human readable form.
//
// Parameters:
//  HRESULT hRes    - result code to translate
//
// Returns: PSTR
//
// History:
//  11/09/1999 - davidkl - created (adapted from tdmusic sources)
//===========================================================================
PSTR dmtxlatHRESULT(HRESULT hRes)
{
    int i   = 0;

    for(i = 0; i < COUNT_ARRAY_ELEMENTS(elErrors); i++ )
    {
        if(hRes == elErrors[i].rval)
        {
            return elErrors[i].sz;
        }
    }

    return (PSTR)"Unknown HRESULT";

} //*** end dmtxlatHRESULT()


//===========================================================================
// dmtxlatAppData
//
// Translates DIDEVICEOBJECTDATA.uAppData into text string representing 
//  semantic action.
//
// Parameters:
//
// Returns: PSTR
//
// History:
//  11/11/1999 - davidkl - created
//===========================================================================
PSTR dmtxlatAppData(UINT_PTR uAppData,
                    ACTIONNAME *pan,
                    DWORD dwActions)
{
    DWORD   dw  = 0;

    for(dw = 0; dw < dwActions; dw++)
    {
        if(((DWORD)uAppData) == (pan+dw)->dw)
        {
            return (pan+dw)->sz;
        }
    }

    return (PSTR)"Unknown action";

} //*** end dmtxlatAppData()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqacq.c ===
/*****************************************************************************
 *
 *      diqacq.c
 *
 *      "Data" (acquire) property sheet page.
 *
 *****************************************************************************/

#include "diquick.h"

/*****************************************************************************
 *
 *      Acq_AddDeviceData
 *
 *****************************************************************************/

void INTERNAL
Acq_AddDeviceData(PDEVDLGINFO pddi, LPTSTR ptsz)
{
    if (pddi->celtData >= pddi->celtDataMax) {
        ListBox_DeleteString(pddi->hwndData, 0);
    } else {
        pddi->celtData++;
    }

    ListBox_AddString(pddi->hwndData, ptsz);
}

/*****************************************************************************
 *
 *      Acq_OnDataAvailable
 *
 *****************************************************************************/

void INTERNAL
Acq_OnDataAvailable(HWND hdlg)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);
    HRESULT hres;
    TCHAR tszBuf[1024];
    DWORD dw;
    DIDEVICEOBJECTDATA rgdod[10];

    ResetEvent(pddi->hevt);

    hres = pddi->pvtbl->UpdateStatus(pddi, tszBuf);
    if (SUCCEEDED(hres)) {
        TCHAR tszPrev[256];
        GetWindowText(pddi->hwndState, tszPrev, cA(tszPrev));
        /* Don't set text if same as before; avoids flicker */
        if (lstrcmp(tszBuf, tszPrev)) {
            SetWindowText(pddi->hwndState, tszBuf);
            UpdateWindow(pddi->hwndState);
        }
    } else {
        if (hres == DIERR_INPUTLOST) {
            SetWindowText(pddi->hwndState, TEXT("Input lost"));
        } else if (hres == DIERR_NOTACQUIRED) {
            SetWindowText(pddi->hwndState, TEXT("Not acquired"));
        } else {
            wsprintf(tszBuf, TEXT("Error %08x"), hres);
            SetWindowText(pddi->hwndState, tszBuf);
        }
    }

    dw = cA(rgdod);
    hres = IDirectInputDevice_GetDeviceData(pddi->pdid, cbX(rgdod[0]), rgdod,
                                            &dw, 0);
    if (SUCCEEDED(hres)) {
        DWORD idod;

        for (idod = 0; idod < dw; idod++) {
            DIDEVICEOBJECTINSTANCE doi;
            if (SUCCEEDED(GetObjectInfo(pddi, &doi, rgdod[idod].dwOfs,
                                        DIPH_BYOFFSET))) {
            } else {
                lstrcpy(doi.tszName, TEXT("?"));
            }

            wsprintf(tszBuf, TEXT("%04x %04x %5d %02x [%s]"),
                     rgdod[idod].dwSequence & 0xFFFF,
                     rgdod[idod].dwTimeStamp & 0xFFFF,
                     rgdod[idod].dwData,
                     rgdod[idod].dwOfs,
                     doi.tszName);
            Acq_AddDeviceData(pddi, tszBuf);
        }
        if (hres == S_FALSE) {
            Acq_AddDeviceData(pddi, TEXT("<data lost>"));
        }
    }

}

#define TEST_SENDDEVICEDATA
#ifdef TEST_SENDDEVICEDATA
#include <hidusage.h>

DWORD INTERNAL
Acq_GetUsageId(IDirectInputDevice2 *pdid2, DWORD dwUsage)
{
    HRESULT hres;
    DIDEVICEOBJECTINSTANCE inst;
    inst.dwSize = cbX(inst);
    hres = IDirectInputDevice_GetObjectInfo(pdid2, &inst, dwUsage, DIPH_BYUSAGE);
    if (SUCCEEDED(hres)) {
        return inst.dwType;
    } else {
        return 0;
    }
}
#endif

/*****************************************************************************
 *
 *      Acq_CheckDataAvailable
 *
 *      Timer callback procedure
 *
 *****************************************************************************/

void CALLBACK
Acq_CheckDataAvailable(HWND hdlg, UINT wm, UINT_PTR id, DWORD tm)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);

    /*
     *  If we can QI for IDirectInputDevice2::Poll, then call it.
     */
    IDirectInputDevice2 *pdid2;
    HRESULT hres;

    hres = IDirectInputDevice_QueryInterface(pddi->pdid,
                                             &IID_IDirectInputDevice2,
                                             (PV)&pdid2);
    if (SUCCEEDED(hres)) {
        IDirectInputDevice2_Poll(pdid2);

#ifdef TEST_SENDDEVICEDATA
    {
//    static int rgiBlah[] = { 1, 3, 2, 6, 4, 6, 2, 3 };
    static int rgiBlah[] = { 1, 2, 4, 2 };
    static int iBlah;
    DWORD cdod = 3;
    static DIDEVICEOBJECTDATA rgdod[3];
    HRESULT hres;
    iBlah = (iBlah + 1) % cA(rgiBlah);
//    ZeroMemory(rgdod, sizeof(rgdod));
    if (rgdod[2].dwOfs == 0) {
        rgdod[0].dwOfs = Acq_GetUsageId(pdid2,
        DIMAKEUSAGEDWORD(HID_USAGE_PAGE_LED, HID_USAGE_LED_NUM_LOCK));
        rgdod[1].dwOfs = Acq_GetUsageId(pdid2,
        DIMAKEUSAGEDWORD(HID_USAGE_PAGE_LED, HID_USAGE_LED_CAPS_LOCK));
        rgdod[2].dwOfs = Acq_GetUsageId(pdid2,
        DIMAKEUSAGEDWORD(HID_USAGE_PAGE_LED, HID_USAGE_LED_SCROLL_LOCK));
    }
//    rgdod[0].dwOfs = 0x80006e84;
//    rgdod[1].dwOfs = 0x80006f84;
//    rgdod[2].dwOfs = 0x80007084;
    rgdod[0].dwData = (rgiBlah[iBlah] & 1) != 0;
    rgdod[1].dwData = (rgiBlah[iBlah] & 2) != 0;
    rgdod[2].dwData = (rgiBlah[iBlah] & 4) != 0;

    hres = IDirectInputDevice2_SendDeviceData(pdid2,
                sizeof(DIDEVICEOBJECTDATA), rgdod, &cdod, 0);

    }
#endif
        IDirectInputDevice_Release(pdid2);
    }

    Acq_OnDataAvailable(hdlg);
}

/*****************************************************************************
 *
 *      Acq_Listbox_Subclass
 *
 *      Subclass procedure for the list box control, so that we eat
 *      every single key.  Except that we allow syskeys to go through
 *      so that keyboard accelerators work.
 *
 *****************************************************************************/

LRESULT CALLBACK
Acq_Listbox_Subclass(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    PDEVDLGINFO pddi = GetDialogPtr(GetParent(hwnd));

    if (pddi->fAcquired) {
        switch (wm) {
        case WM_GETDLGCODE:
            return DLGC_WANTALLKEYS;

        case WM_KEYDOWN:
            return 0;
        }
    }

    return CallWindowProc(pddi->wpListbox, hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *      Acq_OnInitDialog
 *
 *      Init random goo.
 *
 *****************************************************************************/

BOOL INTERNAL
Acq_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PDEVDLGINFO pddi = (PV)(((LPPROPSHEETPAGE)lp)->lParam);
    RECT rc;

    SetDialogPtr(hdlg, pddi);

    pddi->hevt = CreateEvent(0, 1, 0, 0);

    pddi->hwndState = GetDlgItem(hdlg, IDC_ACQ_STATE);
    pddi->hwndData  = GetDlgItem(hdlg, IDC_ACQ_DATA);
    pddi->celtData  = 0;

    GetClientRect(pddi->hwndData, &rc);
    pddi->celtDataMax = (rc.bottom - rc.top) /
                            ListBox_GetItemHeight(pddi->hwndData, 0);

    pddi->wpListbox = SubclassWindow(pddi->hwndData, Acq_Listbox_Subclass);

    SetFocus(pddi->hwndData);
    return 0;
}

/*****************************************************************************
 *
 *      Acq_OnSetActive
 *
 *      Don't put up message boxes, because we aren't visible yet.
 *
 *****************************************************************************/

BOOL INTERNAL
Acq_OnSetActive(HWND hdlg)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);
    HRESULT hres;
    UINT ids = 0;

    hres = IDirectInputDevice_SetEventNotification(pddi->pdid,
                                        pddi->fPoll ? 0 : pddi->hevt);

    if (SUCCEEDED(hres)) {

        hres = IDirectInputDevice_Acquire(pddi->pdid);
        if (SUCCEEDED(hres)) {
            pddi->fAcquired = 1;
            SetFocus(pddi->hwndData);
            if (pddi->fPoll) {
                SetTimer(hdlg, IDT_DATA, msData, Acq_CheckDataAvailable);
            }
        } else {
            ids = IDS_ERR_ACQUIRE;
        }
    } else {
        ids = IDS_ERR_SETEVENTNOT;
    }

    if (ids) {
        TCHAR tsz[256];
        LoadString(g_hinst, ids, tsz, cA(tsz));
        SetDlgItemText(hdlg, IDC_ACQ_STATE, tsz);
    } else {
        Acq_OnDataAvailable(hdlg);
    }
    return 0;
}

/*****************************************************************************
 *
 *      Acq_OnKillActive
 *
 *****************************************************************************/

BOOL INTERNAL
Acq_OnKillActive(HWND hdlg)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);
    if (pddi) {
        if (pddi->fAcquired) {
            pddi->fAcquired = 0;
            IDirectInputDevice_Unacquire(pddi->pdid);
        }
        if (pddi->fPoll) {
            KillTimer(hdlg, IDT_DATA);
        } else {
            IDirectInputDevice_SetEventNotification(pddi->pdid, 0);
        }
    }

    return 0;
}

/*****************************************************************************
 *
 *      Acq_OnDestroy
 *
 *      Clean up.
 *
 *****************************************************************************/

BOOL INTERNAL
Acq_OnDestroy(HWND hdlg)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);
    Acq_OnKillActive(hdlg);
    if (pddi && pddi->hevt) {
        CloseHandle(pddi->hevt);
    }
    return 1;
}

/*****************************************************************************
 *
 *      Acq_OnSelfEnterIdle
 *
 *      This dialog box is idle.  Do a custom message loop if needed.
 *
 *****************************************************************************/

BOOL INTERNAL
Acq_OnSelfEnterIdle(HWND hdlg)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);
    if (pddi->fAcquired && !pddi->fPoll) {
        for (;;) {
            DWORD dwRc;
            MSG msg;
            dwRc = MsgWaitForMultipleObjects(1, &pddi->hevt,
                                             0, INFINITE, QS_ALLINPUT);

            switch (dwRc) {

            case WAIT_OBJECT_0:             /* Data available */
                Acq_OnDataAvailable(hdlg);
                break;

            /* Sometimes we get woken spuriously */
            case WAIT_OBJECT_0 + 1:
                if (PeekMessage(&msg, 0, 0, 0, PM_NOREMOVE)) {
                    goto stop;
                }
                break;

            default:
                /* Return and let the dialog box loop handle the message */
                goto stop;
            }
        }
    stop:;
    }
    return 1;
}

/*****************************************************************************
 *
 *      Acq_OnNotify
 *
 *****************************************************************************/

BOOL INLINE
Acq_OnNotify(HWND hdlg, NMHDR *pnm)
{
    switch (pnm->code) {
    case PSN_SETACTIVE:  return Acq_OnSetActive(hdlg);
    case PSN_KILLACTIVE: return Acq_OnKillActive(hdlg);
    }
    return 0;
}

/*****************************************************************************
 *
 *      Acq_OnUnacquire
 *
 *****************************************************************************/

BOOL INTERNAL
Acq_OnUnacquire(PDEVDLGINFO pddi, HWND hdlg)
{
    HRESULT hres;
    hres = IDirectInputDevice_Unacquire(pddi->pdid);

    return 1;
}

/*****************************************************************************
 *
 *      Acq_OnCommand
 *
 *****************************************************************************/

BOOL INTERNAL
Acq_OnCommand(HWND hdlg, int id, UINT cmd)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);

    if (cmd == BN_CLICKED) {

        switch (id) {

        case IDC_ACQ_UNACQ:
            return Acq_OnUnacquire(pddi, hdlg);

        break;
        }
    }
    return 0;
}

/*****************************************************************************
 *
 *      Acq_DlgProc
 *
 *****************************************************************************/

INT_PTR CALLBACK
Acq_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG:     return Acq_OnInitDialog(hdlg, lp);
    case WM_DESTROY:        return Acq_OnDestroy(hdlg);
    case WM_SELFENTERIDLE:  return Acq_OnSelfEnterIdle(hdlg);
    case WM_NOTIFY:         return Acq_OnNotify(hdlg, (NMHDR *)lp);

    case WM_COMMAND:
        return Acq_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqcpl.c ===
/*****************************************************************************
 *
 *      diqacq.c
 *
 *      The dialog box that tinkers with the control panel interface.
 *
 *****************************************************************************/

#include "diquick.h"
#include <dinputd.h>
#include <gameport.h>

#define JOY_HWS_ISGAMEPORTDRIVER    0x04000000l
#define JOY_HWS_ISANALOGPORTDRIVER  0x08000000l
#define JOY_HWS_ISGAMEPORTBUS       0x80000000l

/*****************************************************************************
 *
 *      Mapping from class strings to class GUIDs.
 *
 *****************************************************************************/

typedef struct CLASSMAP {
    UINT    ids;
    REFGUID rguid;
} CLASSMAP, *PCLASSMAP;

#pragma BEGIN_CONST_DATA

CLASSMAP c_rgcmap[] = {
#ifdef DEBUG
    {   IDS_INVALID,        &GUID_SysKeyboard,      },  /* Bogus class */
#endif
    {   IDS_CLASS_KBD,      &GUID_KeyboardClass,    },
    {   IDS_CLASS_MEDIA,    &GUID_MediaClass,       },
    {   IDS_CLASS_MOUSE,    &GUID_MouseClass,       },
    {   IDS_CLASS_HID,      &GUID_HIDClass,         },
};

#pragma END_CONST_DATA


/*****************************************************************************
 *
 *      Control panel dialog instance data
 *
 *      Instance data for control panel dialog box.
 *
 *****************************************************************************/

typedef struct TYPENAME {
    WCHAR   wsz[MAX_JOYSTRING];
} TYPENAME, *PTYPENAME;

typedef struct CPLDLGINFO {
    HWND    hdlgOwner;          /* Owner window */
    BOOL    fOle;               /* Should we create via OLE? */
    UINT    flCreate;           /* Flags */
    HWND    hwndTypes;          /* Listbox for types */
    HWND    hwndConfigs;        /* Listbox for configs */

    IDirectInputJoyConfig *pdjc;/* The thing we created */

    DARY    daryTypes;          /* Array of type names */

} CPLDLGINFO, *PCPLDLGINFO;

/*****************************************************************************
 *
 *      Cpl_AddType
 *
 *****************************************************************************/

void INTERNAL
Cpl_AddType(LPCWSTR pwszType, LPCTSTR ptszName, PCPLDLGINFO pcpl)
{
    int item;

    item = ListBox_AddString(pcpl->hwndTypes, ptszName);
    if (item >= 0) {
        int itype;
        itype = Dary_Append(&pcpl->daryTypes, (PTYPENAME)0);

        if (itype >= 0) {
            PTYPENAME ptype;
            ptype = Dary_GetPtr(&pcpl->daryTypes, itype, TYPENAME);

            /*
             *  Must do this because Win95 doesn't have lstrcpyW.
             */
            CopyMemory(ptype->wsz, pwszType,
                       sizeof(WCHAR) * (1 + lstrlenW(pwszType)));

            ListBox_SetItemData(pcpl->hwndTypes, item, itype);
        }
    }
}

/*****************************************************************************
 *
 *      Cpl_TypeEnumProc
 *
 *****************************************************************************/

BOOL CALLBACK
Cpl_TypeEnumProc(LPCWSTR pwszType, LPVOID pvRef)
{
    PCPLDLGINFO pcpl = pvRef;
    HRESULT hres;
    DIJOYTYPEINFO jti;

    jti.dwSize = cbX(jti);
    hres = pcpl->pdjc->lpVtbl->GetTypeInfo(pcpl->pdjc, pwszType, &jti,
               DITC_REGHWSETTINGS | DITC_CLSIDCONFIG |DITC_DISPLAYNAME);

    if (SUCCEEDED(hres)) {
        TCHAR tsz[MAX_JOYSTRING];

        ConvertString(TRUE, jti.wszDisplayName, tsz, cA(tsz));
        Cpl_AddType(pwszType, tsz, pcpl);
    }

    return DIENUM_CONTINUE;
}

/*****************************************************************************
 *
 *      Cpl_OnInitDialog
 *
 *****************************************************************************/

BOOL INTERNAL
Cpl_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PCPLDLGINFO pcpl = (PV)lp;
    DIJOYTYPEINFO jti;
    DIJOYCONFIG jc;
    int icmap, ijoy;
    HWND hwnd;
    HRESULT hres;
    TCHAR tsz[MAX_JOYSTRING];

    SetDialogPtr(hdlg, pcpl);

    /*
     *  Initialize the list of installable hardware.
     */
    hwnd = GetDlgItem(hdlg, IDC_CPL_CLASSES);
    for (icmap = 0; icmap < cA(c_rgcmap); icmap++) {
        int item;
        LoadString(g_hinst, c_rgcmap[icmap].ids, tsz, cA(tsz));
        item = ComboBox_AddString(hwnd, tsz);
        if (item >= 0) {
            ComboBox_SetItemData(hwnd, item, icmap);
        }
    }
    ComboBox_SetCurSel(hwnd, 0);

    /*
     *  Initialize the cooperative level information.
     */
    pcpl->pdjc->lpVtbl->SetCooperativeLevel(pcpl->pdjc, hdlg,
                                            DISCL_EXCLUSIVE |
                                            DISCL_BACKGROUND);

    /*
     *  Initialize the list of joystick types.
     */
    pcpl->hwndTypes = GetDlgItem(hdlg, IDC_CPL_TYPES);

    pcpl->pdjc->lpVtbl->EnumTypes(pcpl->pdjc, Cpl_TypeEnumProc, pcpl);

#ifdef DEBUG
    /*
     *  And add the obligatory invalid item.
     */
    Cpl_AddType(L"<invalid>", g_tszInvalid, pcpl);
#endif

    /*
     *  Initialize the list of joystick configs.
     */
    pcpl->hwndConfigs = GetDlgItem(hdlg, IDC_CPL_CONFIGS);

    jc.dwSize = cbX(jc);
    jti.dwSize = cbX(jti);

    for (ijoy = 0; ijoy<15; ijoy++) {

         hres = pcpl->pdjc->lpVtbl->GetConfig(pcpl->pdjc,
                                           ijoy, &jc, 
                                           DIJC_GUIDINSTANCE | 
                                           DIJC_REGHWCONFIGTYPE
                                            ); 

        if (hres == DI_OK) {
            hres = pcpl->pdjc->lpVtbl->GetTypeInfo(pcpl->pdjc,
                        jc.wszType, &jti, DITC_DISPLAYNAME);
            if (SUCCEEDED(hres)) {
                int item;
                wsprintf(tsz, TEXT("%d (%ls)"), ijoy+1, jti.wszDisplayName);
                item = ListBox_AddString(pcpl->hwndConfigs, tsz);
                if (item >= 0) {
                    ListBox_SetItemData(pcpl->hwndConfigs, item, ijoy);
                }
            }
        }
    }


    return 1;
}



//////////////////////////////////////////////////////////

/*
#if 0
    {
    HKEY hk;

    _asm int 3
    hres = pcpl->pdjc->lpVtbl->OpenConfigKey(pcpl->pdjc, ijoy,
                                           KEY_QUERY_VALUE, &hk);
    if (SUCCEEDED(hres)) RegCloseKey(hk);

    }
#endif

#if 0
    jti.dwSize = cbX(jti);
    jti.hws.dwFlags = 0x12345678;
    jti.hws.dwNumButtons = 0;
    CopyMemory(jti.wszDisplayName, L"Fred's Joystick", 2*16);
    jti.wszCallout[0] = TEXT('\0');
    jti.clsidConfig.Data1 = 1;

    pcpl->pdjc->lpVtbl->Acquire(pcpl->pdjc);
//    pcpl->pdjc->lpVtbl->SetTypeInfo(pcpl->pdjc, L"Fred", &jti, DITC_CLSIDCONFIG);
    pcpl->pdjc->lpVtbl->SendNotify(pcpl->pdjc);
//    pcpl->pdjc->lpVtbl->Unacquire(pcpl->pdjc);
#endif

#if 0
//    memset(&jc, 0xCC, cbX(jc));
    jc.dwSize = cbX(jc);
    pcpl->pdjc->lpVtbl->GetConfig(pcpl->pdjc, 0, &jc,
DIJC_GUIDINSTANCE           |
DIJC_REGHWCONFIGTYPE        |
//DIJC_GAIN                   |
0);//DIJC_CALLOUT);
    tsz;
    #if 0 // HACKHACK NT
    wsprintf(tsz, "GUID=%08x, Flags=%08x, buttons=%d gain=%d type=%ls\r\n",
             jc.guidInstance.Data1,
             jc.hwc.hws.dwFlags, jc.hwc.hws.dwNumButtons, jc.dwGain,
            jc.wszType);
    OutputDebugString(tsz);
    #endif
    pcpl->pdjc->lpVtbl->Acquire(pcpl->pdjc);
//    MultiByteToWideChar(CP_ACP, 0, "#3", -1, jc.wszType, MAX_JOYSTRING);
    jc.dwGain = 5000;
//    pcpl->pdjc->lpVtbl->SetConfig(pcpl->pdjc, 0, &jc, DIJC_GAIN);

    pcpl->pdjc->lpVtbl->Unacquire(pcpl->pdjc);
#endif
*/

////////////////////////////////////////////////////////////////////////////////


/*****************************************************************************
 *
 *      Cpl_OnAddNewHardware
 *
 *****************************************************************************/

BOOL INTERNAL
Cpl_OnAddNewHardware(HWND hdlg)
{
    PCPLDLGINFO pcpl = GetDialogPtr(hdlg);
    HWND hwnd = GetDlgItem(hdlg, IDC_CPL_CLASSES);
    int item;
    int icmap;

    if ((item = (int)ComboBox_GetCurSel(hwnd)) >= 0 &&
        (icmap = (int)ComboBox_GetItemData(hwnd, item)) >= 0) {
        HRESULT hres;

        hres = pcpl->pdjc->lpVtbl->AddNewHardware(
                        pcpl->pdjc, hdlg, c_rgcmap[icmap].rguid);
        if (SUCCEEDED(hres)) {
        } else if (hres == DIERR_CANCELLED) {
        } else {
            MessageBoxV(hdlg, IDS_ERR_ADDNEWHARDWARE, hres);
        }
    }
    return TRUE;
}

/*****************************************************************************
 *
 *      Cpl_OnTypeDblClk
 *
 *      An item in the types list box was double-clicked.  Display details.
 *
 *****************************************************************************/

BOOL INTERNAL
Cpl_OnTypeDblClk(HWND hdlg)
{
    PCPLDLGINFO pcpl = GetDialogPtr(hdlg);
    int iItem;

    iItem = ListBox_GetCurSel(pcpl->hwndTypes);

    if (iItem >= 0) {
        int itype = (int)ListBox_GetItemData(pcpl->hwndTypes, iItem);
        if (itype >= 0) {
            PTYPENAME ptype = Dary_GetPtr(&pcpl->daryTypes, itype, TYPENAME);
            Type_Create(hdlg, pcpl->pdjc, ptype->wsz);
        }

        /*
         *  That dialog screws up the vwi state.
         */
        SetActiveWindow(hdlg);
    }

    return 1;
}

/*****************************************************************************
 *
 *      Cpl_GetFirstFreeID
 *
 *****************************************************************************/

int INTERNAL
Cpl_GetFirstFreeID(HWND hdlg)
{
    PCPLDLGINFO pcpl = GetDialogPtr(hdlg);
    int ijoy;
    DIJOYCONFIG jc;
    HRESULT hres;

    jc.dwSize = cbX(jc);
    for (ijoy = 0; ijoy < 15; ijoy++ ){
        hres = pcpl->pdjc->lpVtbl->GetConfig(pcpl->pdjc,
                                             ijoy, &jc, 
                                             DIJC_GUIDINSTANCE | 
                                             DIJC_REGHWCONFIGTYPE
                                            ); 

       if (hres != DI_OK) {
           break;
       }
    }

    return ijoy;
}

/*****************************************************************************
 *
 *      Cpl_AddSelectedItem
 *
 *****************************************************************************/

GUID GUID_GAMEENUM_BUS_ENUMERATOR2 = {0xcae56030, 0x684a, 0x11d0, 0xd6, 0xf6, 0x00, 0xa0, 0xc9, 0x0f, 0x57, 0xda};

BOOL INTERNAL
Cpl_AddSelectedItem( HWND hdlg, DIJOYTYPEINFO *pjti, DWORD dwType, PTYPENAME ptype )
{
    PCPLDLGINFO pcpl = GetDialogPtr(hdlg);
    DIJOYTYPEINFO jti;
    DIJOYCONFIG jc;
    int         ijoy;
    TCHAR       tsz[MAX_JOYSTRING];
    HRESULT     hres;
    BOOL        bRet = FALSE;

    ijoy = Cpl_GetFirstFreeID(hdlg);
    if ( ijoy >= 15 ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("No available ID to SetConfig.\n"));
#endif 
        return FALSE;
    }

    memset( &jc, 0, cbX(jc) );
    jc.dwSize = cbX(DIJOYCONFIG);
    jc.hwc.hws = pjti->hws;
    jc.hwc.hws.dwFlags |= JOY_HWS_ISANALOGPORTDRIVER;
    jc.hwc.dwUsageSettings |= JOY_US_PRESENT;
    jc.hwc.dwType = dwType;
    lstrcpyW(jc.wszCallout, pjti->wszCallout);
    lstrcpyW(jc.wszType, ptype->wsz);

    jc.guidGameport = GUID_GAMEENUM_BUS_ENUMERATOR2;

    if ( SUCCEEDED(pcpl->pdjc->lpVtbl->Acquire(pcpl->pdjc)) ) {
        hres = pcpl->pdjc->lpVtbl->SetConfig(pcpl->pdjc, ijoy, &jc, DIJC_REGHWCONFIGTYPE | DIJC_CALLOUT | DIJC_WDMGAMEPORT);

        if ( SUCCEEDED(hres) ) {
            bRet = TRUE;
        } else {
            #ifdef DEBUG
            OutputDebugString(TEXT("SetConfig failed.\n"));
            #endif 
            goto _done;
        } 

        ZeroX(jc);
        ZeroX(jti);
        jc.dwSize = cbX(jc);
        jti.dwSize = cbX(jti);

        hres = pcpl->pdjc->lpVtbl->GetConfig(pcpl->pdjc,
                                               ijoy, &jc, 
                                               DIJC_GUIDINSTANCE | 
                                               DIJC_REGHWCONFIGTYPE
                                             ); 

        if (hres == DI_OK) {
            hres = pcpl->pdjc->lpVtbl->GetTypeInfo(pcpl->pdjc,
                                                   jc.wszType, &jti, 
												   DITC_DISPLAYNAME);
            if (SUCCEEDED(hres)) {
                int item;
                wsprintf(tsz, TEXT("%d (%ls)"), ijoy+1, jti.wszDisplayName);
                item = ListBox_AddString(pcpl->hwndConfigs, tsz);
                if (item >= 0) {
                    ListBox_SetItemData(pcpl->hwndConfigs, item, ijoy);
                }
            }
        }

        pcpl->pdjc->lpVtbl->Unacquire(pcpl->pdjc);
        pcpl->pdjc->lpVtbl->SendNotify(pcpl->pdjc);
    }

_done:
    return bRet;
}

/*****************************************************************************
 *
 *      Cpl_AddJoystick
 *
 *      The joystick selected in the types list box is added.
 *
 *****************************************************************************/

BOOL INTERNAL
Cpl_AddJoystick(HWND hdlg)
{
    PCPLDLGINFO pcpl = GetDialogPtr(hdlg);
    int         iItem;
    BOOL        bRet = FALSE;

    iItem = ListBox_GetCurSel(pcpl->hwndTypes);

    if (iItem >= 0) {
        int itype = (int)ListBox_GetItemData(pcpl->hwndTypes, iItem);
        if (itype >= 0) {
            PTYPENAME ptype = Dary_GetPtr(&pcpl->daryTypes, itype, TYPENAME);
            
            DIJOYTYPEINFO jti;
            HRESULT hres;

            jti.dwSize = cbX(jti);
            hres = pcpl->pdjc->lpVtbl->GetTypeInfo(pcpl->pdjc, ptype->wsz, &jti,
                                                   DITC_REGHWSETTINGS |
                                                   DITC_DISPLAYNAME);
            if (SUCCEEDED(hres)) {
                bRet = Cpl_AddSelectedItem( hdlg, &jti, iItem, ptype );
            }
        }

        SetActiveWindow(hdlg);
    }

    return bRet;
}

/*****************************************************************************
 *
 *      Cpl_DeleteSelectedItem
 *
 *****************************************************************************/


BOOL INTERNAL
Cpl_DeleteSelectedItem( HWND hdlg, int iItem, int iJoy )
{
    PCPLDLGINFO pcpl = GetDialogPtr(hdlg);
    HRESULT hres;
    BOOL bRet = FALSE;

    hres = pcpl->pdjc->lpVtbl->Acquire(pcpl->pdjc);

    if(SUCCEEDED(hres))
    {
        hres = pcpl->pdjc->lpVtbl->DeleteConfig(pcpl->pdjc, iJoy);

        if(SUCCEEDED(hres))
        {
            pcpl->pdjc->lpVtbl->SendNotify(pcpl->pdjc);
          
            ListBox_DeleteString(pcpl->hwndConfigs, iItem);

            pcpl->pdjc->lpVtbl->Unacquire(pcpl->pdjc);

            bRet = TRUE;
        }
    }

    return bRet;
}


/*****************************************************************************
 *
 *      Cpl_DeleteJoystick
 *
 *      The joystick selected in the types list box is added.
 *
 *****************************************************************************/


BOOL INTERNAL
Cpl_DeleteJoystick(HWND hdlg)
{
    PCPLDLGINFO pcpl = GetDialogPtr(hdlg);
    int         iItem;
    BOOL        bRet = FALSE;

    iItem = ListBox_GetCurSel(pcpl->hwndConfigs);

    if (iItem >= 0) {
        int iJoy = (int)ListBox_GetItemData(pcpl->hwndConfigs, iItem);
        if (iJoy >= 0) {
            bRet = Cpl_DeleteSelectedItem( hdlg, iItem, iJoy );
        }

        SetActiveWindow(hdlg);
    }

    return bRet;
}


/*****************************************************************************
 *
 *      Cpl_OnUserValues
 *
 *      Open the User Values dialog.
 *
 *****************************************************************************/

BOOL INTERNAL
Cpl_OnUserValues(HWND hdlg)
{
    PCPLDLGINFO pcpl = GetDialogPtr(hdlg);

    Uv_Create(hdlg, pcpl->pdjc);

    return 1;
}

/*****************************************************************************
 *
 *      Cpl_OnCommand
 *
 *****************************************************************************/

BOOL INTERNAL
Cpl_OnCommand(HWND hdlg, int id, UINT cmd)
{
    switch (id) {

    case IDC_CPL_ADD:   
        return Cpl_OnAddNewHardware(hdlg);

    case IDC_CPL_TYPES:
        if (cmd == LBN_DBLCLK) {
            return Cpl_OnTypeDblClk(hdlg);
        }
        break;

    case IDC_CPL_ADDJOYSTICK:
        if (cmd == BN_CLICKED) {
            return Cpl_AddJoystick(hdlg);
        }
        break;

    case IDC_CPL_DELJOYSTICK:
        if (cmd == BN_CLICKED) {
            return Cpl_DeleteJoystick(hdlg);
        }
        break;

    case IDC_CPL_USERVALUES:
        if (cmd == BN_CLICKED) {
            return Cpl_OnUserValues(hdlg);
        }
        break;

    }
    return 0;
}

/*****************************************************************************
 *
 *      Cpl_DlgProc
 *
 *****************************************************************************/

INT_PTR INTERNAL
Cpl_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG:
        return Cpl_OnInitDialog(hdlg, lp);

    case WM_DESTROY:
        /*
         *  Cpl_ThreadStart will do the cleanup for us.
         */
        break;

    case WM_COMMAND:
        return Cpl_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));

    case WM_CLOSE:
        DestroyWindow(hdlg);
        return TRUE;
    }

    return 0;
}

/*****************************************************************************
 *
 *      Cpl_DoCpl
 *
 *****************************************************************************/

void INLINE
Cpl_DoCpl(PCPLDLGINFO pcpl)
{
    SendNotifyMessage(pcpl->hdlgOwner, WM_THREADSTARTED, 0, 0);

    /*
     *  This function also sends the WM_CHILDEXIT.
     */
    SemimodalDialogBoxParam(IDD_CPL, pcpl->hdlgOwner, Cpl_DlgProc,
                            (LPARAM)pcpl);

}

/*****************************************************************************
 *
 *      Cpl_ThreadStart
 *
 *      Runs on the new thread.  Creates the object and spins the dialog
 *      box to control it.
 *
 *****************************************************************************/

DWORD WINAPI
Cpl_ThreadStart(PCPLDLGINFO pcpl)
{
    HRESULT hres;
    LPDIRECTINPUTA pdia;

    hres = CoInitialize(0);

    if (SUCCEEDED(hres)) {
        hres = CreateDI(pcpl->fOle, pcpl->flCreate, (PPV)&pdia);

        if (SUCCEEDED(hres)) {
            hres = IDirectInput_QueryInterface(pdia,
                                               &IID_IDirectInputJoyConfig,
                                               (PV)&pcpl->pdjc);
            if (SUCCEEDED(hres)) {

                Cpl_DoCpl(pcpl);

                if( pcpl->pdjc )
                    IDirectInputJoyConfig_Release(pcpl->pdjc);
            } else {
                ThreadFailHres(pcpl->hdlgOwner, IDS_ERR_QICONFIG, hres);
            }

            pdia->lpVtbl->Release(pdia);

        } else {
            ThreadFailHres(pcpl->hdlgOwner, IDS_ERR_CREATEOBJ, hres);
        }

        CoUninitialize();
    } else {
        ThreadFailHres(pcpl->hdlgOwner, IDS_ERR_COINIT, hres);
    }

    Dary_Term(&pcpl->daryTypes);
    LocalFree(pcpl);
    return 0;
}

/*****************************************************************************
 *
 *      Cpl_Create
 *
 *      Spin a thread to create a DirectInput device interface.
 *
 *****************************************************************************/

INT_PTR EXTERNAL
Cpl_Create(HWND hdlg, BOOL fOle, UINT flCreate)
{
    PCPLDLGINFO pcpl = LocalAlloc(LPTR, cbX(CPLDLGINFO));

    if (pcpl) {
        DWORD id;
        HANDLE h;

        pcpl->hdlgOwner     = hdlg         ;
        pcpl->fOle          = fOle         ;
        pcpl->flCreate      = flCreate     ;

        h = CreateThread(0, 0, Cpl_ThreadStart, pcpl, 0, &id);

        if (h) {
            ;
        } else {
            LocalFree(pcpl);
            pcpl = 0;
        }
    }
    return (INT_PTR)pcpl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqdevg.c ===
/*****************************************************************************
 *
 *      diqdevg.c
 *
 *      Acquire an IDirectInputDevice as a generic device.
 *
 *      We build a private data format with all the axes first, then
 *      all the buttons.
 *
 *      We display the axes parenthesized, followed by a space-separated
 *      list of buttons.
 *
 *****************************************************************************/

#include "diquick.h"

/*****************************************************************************
 *
 *      DEVGINFO
 *
 *      Structure used to track generic device state.
 *
 *****************************************************************************/

typedef struct DEVGINFO {
    DWORD cbState;                  /* Size of state buffer */
    LPVOID pvState;                 /* State buffer */
    int cAxes;                      /* Number of axes (start at offset 0) */
    int cButtons;                   /* Number of buttons (start after axes) */
} DEVGINFO, *PDEVGINFO;

/*****************************************************************************
 *
 *      Devg_UpdateStatus
 *
 *      Warning!  ptszBuf is only 256 characters long!
 *
 *****************************************************************************/

STDMETHODIMP
Devg_UpdateStatus(PDEVDLGINFO pddi, LPTSTR ptszBuf)
{
    HRESULT hres;
    PDEVGINFO pdevg = pddi->pvAcq;
    IDirectInputDevice *pdev = pddi->pdid;

    hres = IDirectInputDevice_GetDeviceState(pdev, pdevg->cbState,
                                                   pdevg->pvState);
    if (SUCCEEDED(hres)) {
        LPVOID pvData = pdevg->pvState;
        int iButton;

        if (pdevg->cAxes) {
            int iAxis;

            for (iAxis = 0; iAxis < pdevg->cAxes; iAxis++) {
                LPLONG pl = pvData;
                pvData = pvAddPvCb(pvData, sizeof(LONG));
                ptszBuf += wsprintf(ptszBuf, iAxis == 0 ? TEXT("\050%d") :
                                                          TEXT(", %d"), *pl);
            }
            ptszBuf += wsprintf(ptszBuf, TEXT("\051"));
        }

        for (iButton = 0; iButton < pdevg->cButtons; iButton++) {
            LPBYTE pb = pvData;
            pvData = pvAddPvCb(pvData, sizeof(BYTE));
            if (*pb & 0x80) {
                ptszBuf += wsprintf(ptszBuf, TEXT(" %d"), iButton);
            }
        }
    }
    *ptszBuf = TEXT('\0');

    return hres;
}

/*****************************************************************************
 *
 *      Devg_Destroy
 *
 *****************************************************************************/

STDMETHODIMP_(void)
Devg_Destroy(PDEVDLGINFO pddi)
{
    PDEVGINFO pdevg = pddi->pvAcq;

    if (pdevg) {
        if (pdevg->pvState) {
            LocalFree(pdevg->pvState);
        }
       LocalFree(pdevg);
    }
}

/*****************************************************************************
 *
 *      Devg_DataFormatEnumProc
 *
 *      Callback function for each object.  If it's a button or axis,
 *      we put it in the data format.  But only if it generates data!
 *
 *****************************************************************************/

typedef struct DEVGENUM {
    DWORD dwNumObjs;
    DIDATAFORMAT df;
    PDEVGINFO pdevg;
    PDEVDLGINFO pddi;
} DEVGENUM, *PDEVGENUM;

BOOL CALLBACK
Devg_DataFormatEnumProc(LPCDIDEVICEOBJECTINSTANCE pinst, LPVOID pv)
{
    PDEVGENUM pge = pv;
    LPDIOBJECTDATAFORMAT podf;
    DIDEVICEOBJECTINSTANCE doi;
    DWORD cbObj;


    if( pge->df.dwNumObjs == pge->dwNumObjs -1 )
    {
        HLOCAL hloc;
        pge->dwNumObjs *=2;
        hloc =  LocalReAlloc((HLOCAL)pge->df.rgodf, pge->dwNumObjs * pge->df.dwObjSize , LMEM_MOVEABLE+LMEM_ZEROINIT);
        
        if(hloc)
        {
            pge->df.rgodf = hloc;
        }else
        {
            goto done;
        }
    }

    ConvertDoi(pge->pddi, &doi, pinst);

    /*
     *  Ignore no-data elements.
     */
    if (doi.dwType & DIDFT_NODATA) {
    } else {

        if (doi.dwType & (DIDFT_AXIS | DIDFT_POV)) {
            pge->pdevg->cAxes++;
            cbObj = cbX(LONG);
        } else if (doi.dwType & DIDFT_BUTTON) {
            pge->pdevg->cButtons++;
            cbObj = cbX(BYTE);
        } else {
            /*
             *  Theoretical impossibility!
             */
            goto done;
        }

        podf = &pge->df.rgodf[pge->df.dwNumObjs];

        podf->dwOfs = pge->df.dwDataSize;
#ifdef USE_HID_USAGE_DATA_FORMATS
        if (doi.wUsagePage) {
                podf->dwType = (doi.dwType &
                                (DIDFT_AXIS | DIDFT_BUTTON | DIDFT_POV)) |
                               DIDFT_ANYINSTANCE;
                podf->pguid = (PV)DIMAKEUSAGEDWORD(doi.wUsagePage, doi.wUsage);
                podf->dwFlags |= DIDOI_GUIDISUSAGE;
        } else {
                podf->dwType = doi.dwType;
        }
#else
        podf->dwType = doi.dwType;
#endif

        pge->df.dwDataSize += cbObj;
        pge->df.dwNumObjs++;            
    }

done:;
    return DIENUM_CONTINUE;
}

/*****************************************************************************
 *
 *      Devg_SetDataFormat
 *
 *      Build a custom data format for the device.
 *
 *****************************************************************************/

STDMETHODIMP
Devg_SetDataFormat(PDEVDLGINFO pddi)
{
    HRESULT hres;
    DEVGENUM ge;

    ge.pddi = pddi;
    ge.pdevg = LocalAlloc(LPTR, cbX(DEVGINFO));
    if (ge.pdevg) {
        DIDEVCAPS_DX3 caps;

        pddi->pvAcq = ge.pdevg;

        /*
         *  Get worst-case axis and button count.
         */
        caps.dwSize = cbX(caps);
        hres = IDirectInputDevice_GetCapabilities(pddi->pdid,
                                                  (PV)&caps);
        if (SUCCEEDED(hres)) {

            ge.df.dwSize = cbX(ge.df);
            ge.df.dwObjSize = cbX(DIOBJECTDATAFORMAT);
            ge.df.dwFlags = 0;
            ge.df.dwNumObjs = 0;
            ge.df.dwDataSize = 0;

            ge.dwNumObjs = caps.dwAxes + caps.dwPOVs + caps.dwButtons;
            ge.df.rgodf = LocalAlloc(LPTR,
                    (caps.dwAxes + caps.dwPOVs + caps.dwButtons) *
                                                ge.df.dwObjSize);

            if (ge.df.rgodf) {
                if (SUCCEEDED(hres =
                        IDirectInputDevice_EnumObjects(pddi->pdid,
                            Devg_DataFormatEnumProc, &ge,
                            DIDFT_AXIS | DIDFT_POV | DIDFT_ALIAS | DIDFT_VENDORDEFINED )) &&
                    SUCCEEDED(hres =
                        IDirectInputDevice_EnumObjects(pddi->pdid,
                            Devg_DataFormatEnumProc, &ge, DIDFT_BUTTON| DIDFT_ALIAS | DIDFT_VENDORDEFINED))) {
                    ge.df.dwDataSize = (ge.df.dwDataSize + 3) & ~3;

                    ge.pdevg->cbState = ge.df.dwDataSize;
                    ge.pdevg->pvState = LocalAlloc(LPTR, ge.pdevg->cbState);

                    if (ge.pdevg->pvState) {
                        hres = IDirectInputDevice_SetDataFormat(
                                        pddi->pdid, &ge.df);
                    } else {
                        hres = E_OUTOFMEMORY;
                    }
                }

                LocalFree(ge.df.rgodf);
            } else {
                hres = E_OUTOFMEMORY;
            }

        }
    } else {
        hres = E_OUTOFMEMORY;
    }
    return hres;
}

/*****************************************************************************
 *
 *      c_acqvtblDev
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

ACQVTBL c_acqvtblDev = {
    Devg_UpdateStatus,
    Devg_SetDataFormat,
    Devg_Destroy,
    0,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqchk.c ===
/*****************************************************************************
 *
 *      diqchk.c
 *
 *      Wrappers that turn a listview into a checked listbox.
 *
 *****************************************************************************/

#include "diquick.h"

HIMAGELIST g_himlState;

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *      Checklist_Init
 *
 *      One-time initialization.
 *
 *****************************************************************************/

INT_PTR EXTERNAL
Checklist_Init(void)
{
    g_himlState = ImageList_LoadImage(g_hinst, MAKEINTRESOURCE(IDB_CHECK),
                                      0, 2, RGB(0xFF, 0x00, 0xFF),
                                      IMAGE_BITMAP, 0);

    return (INT_PTR)g_himlState;
}

/*****************************************************************************
 *
 *      Checklist_Term
 *
 *      One-time shutdown
 *
 *****************************************************************************/

void EXTERNAL
Checklist_Term(void)
{
    if (g_himlState) {
        ImageList_Destroy(g_himlState);
    }
}

/*****************************************************************************
 *
 *      Checklist_OnInitDialog
 *
 *      Initialize a single checklist control.
 *
 *****************************************************************************/

void EXTERNAL
Checklist_OnInitDialog(HWND hwnd, BOOL fReadOnly)
{
    ListView_SetImageList(hwnd, g_himlState, LVSIL_STATE);
    if (fReadOnly) {
        SetProp(hwnd, propReadOnly, LongToHandle((LONG)fReadOnly) );
        ListView_SetBkColor(hwnd, GetSysColor(COLOR_3DFACE));
        ListView_SetTextBkColor(hwnd, GetSysColor(COLOR_3DFACE));
    }
}

/*****************************************************************************
 *
 *      Checklist_AddString
 *
 *      Add a string and maybe a checkbox.
 *
 *****************************************************************************/

int EXTERNAL
Checklist_AddString(HWND hwnd, UINT ids, BOOL fCheck)
{
    TCHAR tsz[256];
    LV_ITEM lvi;

    LoadString(g_hinst, ids, tsz, cA(tsz));

    lvi.mask = LVIF_TEXT | LVIF_STATE;
    lvi.iSubItem = 0;
    lvi.pszText = tsz;
    lvi.state = INDEXTOSTATEIMAGEMASK(fCheck ? 2 : 1);
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.iItem = ListView_GetItemCount(hwnd);

    return ListView_InsertItem(hwnd, &lvi);
}

/*****************************************************************************
 *
 *      Checklist_InitFinish
 *
 *      Wind up the initialization.
 *
 *****************************************************************************/

void EXTERNAL
Checklist_InitFinish(HWND hwnd)
{
    RECT rc;
    LV_COLUMN col;
    int icol;

    /*
     *  Add the one and only column.
     */
    GetClientRect(hwnd, &rc);
    col.mask = LVCF_WIDTH;
    col.cx = 10;
    icol = ListView_InsertColumn(hwnd, 0, &col);

    ListView_SetColumnWidth(hwnd, icol, LVSCW_AUTOSIZE);
}

/*****************************************************************************
 *
 *      Checklist_OnDestroy
 *
 *      Clean up a checklist.
 *
 *****************************************************************************/

void EXTERNAL
Checklist_OnDestroy(HWND hwnd)
{

    /*
     *  Don't remove unless it's already there.
     *  This avoids a RIP.
     */

    if (GetProp(hwnd, propReadOnly)) {
        RemoveProp(hwnd, propReadOnly);
    }
}

/*****************************************************************************
 *
 *      Checklist_InitFlags
 *
 *      Add a bunch of strings corresponding to flag bits.
 *
 *****************************************************************************/

void EXTERNAL
Checklist_InitFlags(HWND hdlg, int idc,
                    DWORD fl, PCHECKLISTFLAG rgclf, UINT cclf)
{
    HWND hwndList = GetDlgItem(hdlg, idc);
    UINT iclf;

    Checklist_OnInitDialog(hwndList, TRUE);
    for (iclf = 0; iclf < cclf; iclf++) {
        Checklist_AddString(hwndList, rgclf[iclf].ids,
                            fl & rgclf[iclf].flMask);
    }
    Checklist_InitFinish(hwndList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqdevj.c ===
/*****************************************************************************
 *
 *      diqdevj.c
 *
 *      Acquire an IDirectInputDevice as if it were a joystick.
 *
 *****************************************************************************/

#include "diquick.h"

/*****************************************************************************
 *
 *      Devj_UpdateStatus
 *
 *****************************************************************************/

STDMETHODIMP
Devj_UpdateStatus(PDEVDLGINFO pddi, LPTSTR ptszBuf)
{
    HRESULT hres;
    DIJOYSTATE js;
    IDirectInputDevice *pdid = pddi->pdid;

    hres = IDirectInputDevice_GetDeviceState(pdid, sizeof(js), &js);
    if (SUCCEEDED(hres)) {
        UINT ib;
        ptszBuf += wsprintf(ptszBuf,
                            TEXT("X = %d\r\n")
                            TEXT("Y = %d\r\n")
                            TEXT("Z = %d\r\n")
                            TEXT("Rx = %d\r\n")
                            TEXT("Ry = %d\r\n")
                            TEXT("Rz = %d\r\n")
                            TEXT("S0 = %d\r\n")
                            TEXT("S1 = %d\r\n")
                            TEXT("POV = %d %d %d %d\r\n"),
                            js.lX, js.lY, js.lZ,
                            js.lRx, js.lRy, js.lRz,
                            js.rglSlider[0], js.rglSlider[1],
                            js.rgdwPOV[0],
                            js.rgdwPOV[1],
                            js.rgdwPOV[2],
                            js.rgdwPOV[3]);
        for (ib = 0; ib < 32; ib++) {
            if (js.rgbButtons[ib] & 0x80) {
                ptszBuf += wsprintf(ptszBuf, TEXT(" %d"), ib);
            }
        }
    }
    return hres;
}

/*****************************************************************************
 *
 *      c_acqvtblDevJoy
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

ACQVTBL c_acqvtblDevJoy = {
    Devj_UpdateStatus,
    Common_AcqSetDataFormat,
    Common_AcqDestroy,
    &c_dfDIJoystick,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqdevk.c ===
/*****************************************************************************
 *
 *      diqdevk.c
 *
 *      Acquire an IDirectInputDevice as if it were a mouse.
 *
 *****************************************************************************/

#include "diquick.h"

/*****************************************************************************
 *
 *      Devk_UpdateStatus
 *
 *****************************************************************************/

STDMETHODIMP
Devk_UpdateStatus(PDEVDLGINFO pddi, LPTSTR ptszBuf)
{
    HRESULT hres;
    BYTE rgb[256];
    IDirectInputDevice *pdid = pddi->pdid;

    hres = IDirectInputDevice_GetDeviceState(pdid, cbX(rgb), rgb);
    if (SUCCEEDED(hres)) {
        int i;
        int ckey = 0;

        *ptszBuf = TEXT('\0');
        for (i = 0; i < 256; i++) {
            if (rgb[i] & 0x80) {
                ptszBuf += wsprintf(ptszBuf, TEXT("%02x "), i);
                ckey++;
                if (ckey > 10) break;
            }
        }
    }
    return hres;
}

/*****************************************************************************
 *
 *      c_acqvtblDevKbd
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

ACQVTBL c_acqvtblDevKbd = {
    Devk_UpdateStatus,
    Common_AcqSetDataFormat,
    Common_AcqDestroy,
    &c_dfDIKeyboard,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqdevm.c ===
/*****************************************************************************
 *
 *      diqdevm.c
 *
 *      Acquire an IDirectInputDevice as if it were a mouse.
 *
 *****************************************************************************/

#include "diquick.h"

/*****************************************************************************
 *
 *      Devm_UpdateStatus
 *
 *****************************************************************************/

STDMETHODIMP
Devm_UpdateStatus(PDEVDLGINFO pddi, LPTSTR ptszBuf)
{
    HRESULT hres;
#if DIRECTINPUT_VERSION >= 0x700
    DIMOUSESTATE2 md;
#else
    DIMOUSESTATE md;
#endif
    
    IDirectInputDevice *pdid = pddi->pdid;

    hres = IDirectInputDevice_GetDeviceState(pdid, sizeof(md), &md);
    if (SUCCEEDED(hres)) {
#if DIRECTINPUT_VERSION >= 0x700
        wsprintf(ptszBuf, TEXT("(%d, %d, %d) %c %c %c %c %c"),
                 md.lX, md.lY, md.lZ,
                 md.rgbButtons[0] & 0x80 ? '0' : ' ',
                 md.rgbButtons[1] & 0x80 ? '1' : ' ',
                 md.rgbButtons[2] & 0x80 ? '2' : ' ',
                 md.rgbButtons[3] & 0x80 ? '3' : ' ',
                 md.rgbButtons[4] & 0x80 ? '4' : ' ',
                 md.rgbButtons[5] & 0x80 ? '5' : ' ',
                 md.rgbButtons[6] & 0x80 ? '6' : ' ',
                 md.rgbButtons[7] & 0x80 ? '7' : ' '
                 );
#else
        wsprintf(ptszBuf, TEXT("(%d, %d, %d) %c %c %c %c"),
                 md.lX, md.lY, md.lZ,
                 md.rgbButtons[0] & 0x80 ? '0' : ' ',
                 md.rgbButtons[1] & 0x80 ? '1' : ' ',
                 md.rgbButtons[2] & 0x80 ? '2' : ' ',
                 md.rgbButtons[3] & 0x80 ? '3' : ' '
                 );
#endif

    }
    return hres;
}

/*****************************************************************************
 *
 *      c_acqvtblDevMouse
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

ACQVTBL c_acqvtblDevMouse = {
    Devm_UpdateStatus,
    Common_AcqSetDataFormat,
    Common_AcqDestroy,
    &c_dfDIMouse,
};

ACQVTBL c_acqvtblDevMouse2 = {
    Devm_UpdateStatus,
    Common_AcqSetDataFormat,
    Common_AcqDestroy,
    &c_dfDIMouse2,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqcaps.c ===
/*****************************************************************************
 *
 *      diqcaps.c
 *
 *      "Caps" property sheet page.
 *
 *      Also does GetDeviceInfo (as well as GetDeviceCaps).
 *
 *****************************************************************************/

#include "diquick.h"

#pragma BEGIN_CONST_DATA

CHECKLISTFLAG c_rgcfDidc[] = {
    { DIDC_ATTACHED,            IDS_ATTACHED,           },
    { DIDC_POLLEDDEVICE,        IDS_POLLEDDEVICE,       },
    { DIDC_POLLEDDATAFORMAT,    IDS_POLLEDDATAFORMAT,   },
    { DIDC_EMULATED,            IDS_EMULATED,           },
    { DIDC_FORCEFEEDBACK,       IDS_FORCEFEEDBACK,      },
    { DIDC_FFATTACK,            IDS_FFATTACK,           },
    { DIDC_FFFADE,              IDS_FFFADE,             },
    { DIDC_SATURATION,          IDS_SATURATION,         },
    { DIDC_POSNEGCOEFFICIENTS,  IDS_POSNEGCOEFFICIENTS, },
    { DIDC_POSNEGSATURATION,    IDS_POSNEGSATURATION,   },
    { DIDC_ALIAS,               IDS_ALIASDEVICE,        },
    { DIDC_PHANTOM,             IDS_PHANTOMDEVICE,      },
};

CHECKLISTFLAG c_rgcfDevType[] = {
    { DIDEVTYPE_HID,            IDS_CAPS_HID,           },
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *      Caps_GetGuidPath
 *
 *      Getting the GUID and path is a bit annoying, so we put it in
 *      a separate function.
 *
 *****************************************************************************/

void INTERNAL
Caps_GetGuidPath(HWND hwndList, PDEVDLGINFO pddi)
{
    DIPROPGUIDANDPATH gp;
    HRESULT hres;

    gp.diph.dwSize = sizeof(DIPROPGUIDANDPATH);
    gp.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    gp.diph.dwObj = 0;
    gp.diph.dwHow = DIPH_DEVICE;

    hres = IDirectInputDevice_GetProperty(pddi->pdid, DIPROP_GUIDANDPATH,
                                          &gp.diph);

    if (SUCCEEDED(hres)) {
        TCHAR tsz[MAX_PATH];

        Vlist_AddValue(hwndList, IDS_CAPS_CLASSGUID,
                       MapGUID(&gp.guidClass, tsz));
        ConvertString(TRUE, gp.wszPath, tsz, cA(tsz));
        Vlist_AddValue(hwndList, IDS_CAPS_PATH, tsz);
    }
}

/*****************************************************************************
 *
 *      Caps_SetStringPropCallback
 *
 *****************************************************************************/

HRESULT CALLBACK
Caps_SetStringPropCallback(LPCTSTR ptszValue, PV pvRef1, PV pvRef2)
{
    PDEVDLGINFO pddi = pvRef1;
    const GUID *prop = pvRef2;
    DIPROPSTRING str;
    HRESULT hres;

    str.diph.dwSize = sizeof(DIPROPSTRING);
    str.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    str.diph.dwObj = 0;
    str.diph.dwHow = DIPH_DEVICE;

    UnconvertString(TRUE, ptszValue, str.wsz, cA(str.wsz));

    hres = IDirectInputDevice_SetProperty(pddi->pdid, prop, &str.diph);

    return hres;
}


/*****************************************************************************
 *
 *      Caps_GetStringProp
 *
 *****************************************************************************/

void INTERNAL
Caps_GetStringProp(HWND hwndList, UINT ids, const GUID *prop, PDEVDLGINFO pddi)
{
    DIPROPSTRING str;
    HRESULT hres;

    str.diph.dwSize = sizeof(DIPROPSTRING);
    str.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    str.diph.dwObj = 0;
    str.diph.dwHow = DIPH_DEVICE;

    hres = IDirectInputDevice_GetProperty(pddi->pdid, prop, &str.diph);

    /*
     *  Anything other than E_NOTIMPL means that it's supported but
     *  didn't work.
     */
    if (FAILED(hres) && hres != E_NOTIMPL) {
        str.wsz[0] = TEXT('\0');
        hres = S_OK;
    }

    if (SUCCEEDED(hres)) {
        TCHAR tsz[MAX_PATH];

        ConvertString(TRUE, str.wsz, tsz, cA(tsz));
        Vlist_AddValueRW(hwndList, ids, tsz, Caps_SetStringPropCallback,
                         pddi, (PV)prop);
    }
}

/*****************************************************************************
 *
 *      Caps_SetPropCallback
 *
 *****************************************************************************/

HRESULT CALLBACK
Caps_SetPropCallback(LPDIPROPHEADER pdiph, PV pvRef1, PV pvRef2)
{
    PDEVDLGINFO pddi = pvRef1;
    const GUID *prop = (const GUID *)pvRef2;
    HRESULT hres;

    hres = IDirectInputDevice_SetProperty(pddi->pdid, prop, pdiph);

    return hres;
}

/*****************************************************************************
 *
 *      Caps_Refresh
 *
 *      Get the caps and show them, preserving the current selection.
 *
 *****************************************************************************/

void INTERNAL
Caps_Refresh(HWND hdlg)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);
    DIDEVCAPS didc;
    DIDEVICEINSTANCE didi;
    HRESULT hres;
    TCHAR tsz[1024];
    HWND hwndList;
    int iItem;
    union {
        DIPROPHEADER diph;
        DIPROPDWORD dipdw;
        DIPROPRANGE diprg;
        DIPROPCAL dipcal;
    } u;
    
    hwndList = GetDlgItem(hdlg, IDC_CAPS_LIST);

    SetWindowRedraw(hwndList, FALSE);
    iItem = ListBox_GetCurSel(hwndList);
    if (iItem < 0) {
        iItem = 0;
    }

    Vlist_OnDestroy(hwndList);

    Vlist_OnInitDialog(hwndList);

    didc.dwSize = cbX(DIDEVCAPS_DX3);
    hres = IDirectInputDevice_GetCapabilities(pddi->pdid, &didc);
    if (SUCCEEDED(hres)) {

        LoadString(g_hinst, IDS_TYPEARRAY + GET_DIDEVICE_TYPE(didc.dwDevType),
                            tsz, cA(tsz));
        if (tsz[0]) {
            Vlist_AddValue(hwndList, IDS_CAPS_TYPE, tsz);

            LoadString(g_hinst, IDS_TYPEARRAY +
                                MAKEWORD(GET_DIDEVICE_SUBTYPE(didc.dwDevType),
                                         GET_DIDEVICE_TYPE(didc.dwDevType)),
                                tsz, cA(tsz));
            if (tsz[0]) {
                Vlist_AddValue(hwndList, IDS_CAPS_SUBTYPE, tsz);
            } else {
                Vlist_AddIntValue(hwndList, IDS_CAPS_SUBTYPE,
                                  GET_DIDEVICE_SUBTYPE(didc.dwDevType));
            }
        } else {
            Vlist_AddIntValue(hwndList, IDS_CAPS_TYPE,
                                GET_DIDEVICE_TYPE(didc.dwDevType));
            Vlist_AddIntValue(hwndList, IDS_CAPS_SUBTYPE,
                              GET_DIDEVICE_SUBTYPE(didc.dwDevType));
        }

        Vlist_AddFlags(hwndList, didc.dwDevType,
                       c_rgcfDevType, cA(c_rgcfDevType));

        Vlist_AddIntValue(hwndList, IDS_CAPS_AXES,    didc.dwAxes);
        Vlist_AddIntValue(hwndList, IDS_CAPS_BUTTONS, didc.dwButtons);
        Vlist_AddIntValue(hwndList, IDS_CAPS_POVS,    didc.dwPOVs);

        Vlist_AddFlags(hwndList, didc.dwFlags,
                       c_rgcfDidc, cA(c_rgcfDidc));

    }

    didc.dwSize = cbX(DIDEVCAPS);
    hres = IDirectInputDevice_GetCapabilities(pddi->pdid, &didc);
    if (SUCCEEDED(hres)) {
        Vlist_AddIntValue(hwndList, IDS_CAPS_FFSAMPLEPERIOD,
                                      didc.dwFFSamplePeriod);

        Vlist_AddIntValue(hwndList, IDS_CAPS_FFMINTIMERESOLUTION,
                                      didc.dwFFMinTimeResolution);
        Vlist_AddHexValue(hwndList, IDS_CAPS_FIRMWAREREVISION,
                                      didc.dwFirmwareRevision);
        Vlist_AddHexValue(hwndList, IDS_CAPS_HARDWAREREVISION,
                                      didc.dwHardwareRevision);
        Vlist_AddHexValue(hwndList, IDS_CAPS_FFDRIVERVERSION,
                                      didc.dwFFDriverVersion);
    }

    // BUGBUG -- character set
    didi.dwSize = cbX(DIDEVICEINSTANCE_DX3);
    hres = GetDeviceInfo(pddi, &didi);
    if (SUCCEEDED(hres)) {

        Vlist_AddValue(hwndList, IDS_CAPS_GUIDINSTANCE,
                       MapGUID(&didi.guidInstance, tsz));

        Vlist_AddValue(hwndList, IDS_CAPS_GUIDPRODUCT,
                       MapGUID(&didi.guidProduct, tsz));

//      Vlist_AddHexValue(hwndList, IDS_CAPS_DEVTYPE, didi.dwDevType);

        Vlist_AddValue(hwndList, IDS_CAPS_INSTANCENAME, didi.tszInstanceName);
        Vlist_AddValue(hwndList, IDS_CAPS_PRODUCTNAME, didi.tszProductName);
    }

    didi.dwSize = cbX(DIDEVICEINSTANCE);
    hres = GetDeviceInfo(pddi, &didi);
    if (SUCCEEDED(hres)) {
        Vlist_AddValue(hwndList, IDS_CAPS_GUIDFFDRIVER,
                       MapGUID(&didi.guidFFDriver, tsz));
        Vlist_AddHexValue(hwndList, IDS_CAPS_USAGEPAGE, didi.wUsagePage);
        Vlist_AddHexValue(hwndList, IDS_CAPS_USAGE, didi.wUsage);
    }

    Caps_GetGuidPath(hwndList, pddi);

    Caps_GetStringProp(hwndList, IDS_CAPS_INSTPROP, DIPROP_INSTANCENAME, pddi);
    Caps_GetStringProp(hwndList, IDS_CAPS_MFGPROP, DIPROP_PRODUCTNAME, pddi);
    Caps_GetStringProp(hwndList, IDS_CAPS_PORTNAME, DIPROP_GETPORTDISPLAYNAME, pddi);

    hres = IDirectInputDevice_GetProperty(pddi->pdid, DIPROP_JOYSTICKID, 
                                          &u.diph);

    if (SUCCEEDED(hres)) {
        Vlist_AddIntValue(hwndList, IDS_CAPS_JOYSTICKID, u.dipdw.dwData);
    }

    if( iItem >=0 ) {
        ListBox_SetCurSel(hwndList, iItem);
        Vlist_OnSelChange(hwndList);
    }

    SetWindowRedraw(hwndList, TRUE);
}


/*****************************************************************************
 *
 *      Caps_OnInitDialog
 *
 *      Get the caps and show them.  That's all.
 *
 *****************************************************************************/

BOOL INTERNAL
Caps_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PDEVDLGINFO pddi = (PV)(((LPPROPSHEETPAGE)lp)->lParam);

    SetDialogPtr(hdlg, pddi);

    Caps_Refresh(hdlg);

    return 1;
}

/*****************************************************************************
 *
 *      Caps_OnDestroy
 *
 *      Tell the checklist to go away, too.
 *
 *****************************************************************************/

void INTERNAL
Caps_OnDestroy(HWND hdlg)
{
    Vlist_OnDestroy(GetDlgItem(hdlg, IDC_CAPS_LIST));
//    Checklist_OnDestroy(GetDlgItem(hdlg, IDC_CAPS_CHECKLIST));
}

/*****************************************************************************
 *
 *      Caps_OnControlPanel
 *
 *****************************************************************************/

BOOL INTERNAL
Caps_OnControlPanel(HWND hdlg)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);
    HRESULT hres;

    hres = IDirectInputDevice_RunControlPanel(pddi->pdid, hdlg, 0);
    if (SUCCEEDED(hres)) {
    } else {
        MessageBoxV(hdlg, IDS_ERR_RUNCPL, hres);
    }
    return 1;
}

/*****************************************************************************
 *
 *      Caps_OnCommand
 *
 *****************************************************************************/

BOOL INLINE
Caps_OnCommand(HWND hdlg, int id, UINT cmd)
{
    switch (id) {

    case IDC_CAPS_CPL:    return Caps_OnControlPanel(hdlg);

    case IDC_CAPS_LIST:
        if (cmd == LBN_SELCHANGE) {
            Vlist_OnSelChange(GetDlgItem(hdlg, IDC_CAPS_LIST));
            return TRUE;
        }
        break;

    case IDC_CAPS_REFRESH: Caps_Refresh(hdlg); return TRUE;

    }
    return 0;
}

/*****************************************************************************
 *
 *      Caps_DlgProc
 *
 *****************************************************************************/

INT_PTR CALLBACK
Caps_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG: return Caps_OnInitDialog(hdlg, lp);
    case WM_COMMAND:
        return Caps_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));

    case WM_SYSCOLORCHANGE:
    case WM_SETTINGCHANGE:
    case WM_FONTCHANGE:
    case WM_DEVMODECHANGE:
    case WM_TIMECHANGE:
    case WM_DEVICECHANGE:
//        SendDlgItemMessage(hdlg, IDC_CAPS_CHECKLIST, wm, wp, lp);
        break;

    case WM_DESTROY:
        Caps_OnDestroy(hdlg);
        break;

    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqdev.c ===
/*****************************************************************************
 *
 *      diqdev.c
 *
 *      The dialog box that asks what to do with the DirectInput device.
 *
 *****************************************************************************/

#include "diquick.h"

/*****************************************************************************
 *
 *      Property sheet goo
 *
 *****************************************************************************/


#pragma BEGIN_CONST_DATA

#define MAKE_PSP(idd, dlgproc) {                        \
    cbX(PROPSHEETPAGE),             /* dwSize      */   \
    PSP_DEFAULT,                    /* dwFlags     */   \
    0,                              /* hInstance   */   \
    MAKEINTRESOURCE(idd),           /* pszTemplate */   \
    0,                              /* hIcon       */   \
    0,                              /* pszTitle    */   \
    dlgproc,                        /* pfnDlgProc  */   \
    idd == IDD_ENUMEFF,             /* lParam      */   \
    0,                              /* pfnCallback */   \
    0,                              /* pcRefParent */   \
}                                                       \

PROPSHEETPAGE c_rgpsp[] = {
    EACH_PROPSHEET(MAKE_PSP)
};

#undef MAKE_PSP

RIID c_rgriid[] = {
    &IID_IDirectInputDeviceA,
    &IID_IDirectInputDeviceW,
    &IID_IDirectInputDevice2A,
    &IID_IDirectInputDevice2W,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *      Dev_DoPropertySheet
 *
 *****************************************************************************/

BOOL INTERNAL
Dev_DoPropertySheet(PDEVDLGINFO pddi)
{
    PROPSHEETPAGE rgpsp[cA(c_rgpsp)];
    PROPSHEETHEADER psh;
    int ipsp;

    psh.dwSize          = cbX(psh);
    psh.dwFlags         = PSH_PROPSHEETPAGE | PSH_MODELESS | PSH_NOAPPLYNOW;
    psh.hwndParent      = 0; /* pddi->hdlgOwner */
    psh.pszCaption      = pddi->ptszDesc;
    psh.nPages          = 0;
    psh.nStartPage      = 0;
    psh.ppsp            = rgpsp;

    /*
     *  The lParam of the structure is nonzero iff the page should
     *  be shown only if the DX 5 interface is being used.
     */
    for (ipsp = 0; ipsp < cA(c_rgpsp); ipsp++) {
        if (fLimpFF(c_rgpsp[ipsp].lParam, pddi->pdid2)) {
            rgpsp[psh.nPages] = c_rgpsp[ipsp];
            rgpsp[psh.nPages].hInstance  = g_hinst;
            rgpsp[psh.nPages].lParam     = (LPARAM)pddi;
            psh.nPages++;
        }
    }

    return SemimodalPropertySheet(pddi->hdlgOwner, &psh);
}

/*****************************************************************************
 *
 *      Dev_DoDevice
 *
 *****************************************************************************/

HRESULT INTERNAL
Dev_DoDevice(PDEVDLGINFO pddi, LPDIRECTINPUTA pdia)
{
    HRESULT hres;
    UINT idsError;

    if (pdia) {

        /*
         *  To create an uninitialized device, we CoCreateInstance it
         *  and "forget" to call Initialize().
         */
        if (IsEqualGUID(pddi->pguidInstance, &GUID_Uninit)) {
            REFIID riid = IsUnicodeDidc(pddi->didcItf)
                                ? &IID_IDirectInputDeviceW
                                : &IID_IDirectInputDeviceA;

            hres = CoCreateInstance(&CLSID_DirectInputDevice, 0,
                                    CLSCTX_INPROC_SERVER,
                                    riid, (PV)&pddi->pdid);

        } else {
            hres = IDirectInput_CreateDevice(pdia, pddi->pguidInstance,
                                             (PV)&pddi->pdid, 0);
        }

        /*
         *  If we need to change character set, then do so in-place.
         */
        if (SUCCEEDED(hres) && pddi->flCreate != (BOOL)pddi->didcItf) {
            IDirectInputDevice *pdid;
            hres = IDirectInputDevice_QueryInterface(pddi->pdid,
                                                     c_rgriid[pddi->didcItf],
                                                     (PV)&pdid);
            IDirectInputDevice_Release(pddi->pdid);
            pddi->pdid = pdid;

            if (IsFFDidc(pddi->didcItf)) {
                pddi->pdid2 = (PV)pdid;
            } else {
                pddi->pdid2 = 0;
            }
        }

    } else {
        hres = E_FAIL;
    }

    SendNotifyMessage(pddi->hdlgOwner, WM_THREADSTARTED, 0, 0);

    if (SUCCEEDED(hres)) {
        idsError = Dev_DoPropertySheet(pddi) ? IDS_ERR_CREATEDEV : 0;
        pddi->pdid->lpVtbl->Release(pddi->pdid);
    } else {
        idsError = IDS_ERR_CREATEDEV;
    }

    if (idsError) {
        MessageBoxV(pddi->hdlgOwner, idsError);
        SendNotifyMessage(pddi->hdlgOwner, WM_CHILDEXIT, 0, 0);
    }
    return hres;

}

/*****************************************************************************
 *
 *      Dev_ThreadStart
 *
 *      Runs on the new thread.  Creates the object and spins the dialog
 *      box to control it.
 *
 *****************************************************************************/

DWORD WINAPI
Dev_ThreadStart(PDEVDLGINFO pddi)
{
    HRESULT hres;
    LPDIRECTINPUTA pdia;

    hres = CoInitialize(0);

    if (SUCCEEDED(hres)) {
        hres = CreateDI(pddi->fOle, pddi->flCreate, (PPV)&pdia);

        if (SUCCEEDED(hres)) {
            hres = Dev_DoDevice(pddi, pdia);
            pdia->lpVtbl->Release(pdia);
        } else {
            ThreadFailHres(pddi->hdlgOwner, IDS_ERR_CREATEOBJ, hres);
        }

        CoUninitialize();
    } else {
        ThreadFailHres(pddi->hdlgOwner, IDS_ERR_COINIT, hres);
    }
    LocalFree(pddi);
    return 0;
}

/*****************************************************************************
 *
 *      Dev_Create
 *
 *      Spin a thread to create a DirectInput device interface.
 *
 *****************************************************************************/

INT_PTR EXTERNAL
Dev_Create(HWND hdlg, BOOL fOle, UINT flCreate,
           const GUID *pguidInstance, LPCTSTR ptszDesc, UINT didcItf)
{
    PDEVDLGINFO pddi = LocalAlloc(LPTR, cbX(DEVDLGINFO));

    if (pddi) {
        DWORD id;
        HANDLE h;

        pddi->hdlgOwner     = hdlg         ;
        pddi->fOle          = fOle         ;
        pddi->flCreate      = flCreate     ;
        pddi->pguidInstance = pguidInstance;
        pddi->ptszDesc      = ptszDesc     ;
        pddi->didcItf       = didcItf      ;

        h = CreateThread(0, 0, Dev_ThreadStart, pddi, 0, &id);

        if (h) {
        } else {
            if (pddi->pvtbl) {
                pddi->pvtbl->Destroy(pddi);
            }
            LocalFree(pddi);
            pddi = 0;
        }
    }
    return (INT_PTR)pddi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqeobj.c ===
/*****************************************************************************
 *
 *      diqeobj.c
 *
 *      Property sheet page for device "enum objects".
 *
 *****************************************************************************/

#include "diquick.h"

/*****************************************************************************
 *
 *      EObj_EnumCallback
 *
 *      Called one for each object.
 *
 *****************************************************************************/

typedef struct EOBJENUMINFO {
    HWND        hwndList;
    PDEVDLGINFO pddi;
} EOBJENUMINFO, *PEOBJENUMINFO;

BOOL CALLBACK
EObj_EnumCallback(const void *pvDoi, LPVOID pv)
{
    PEOBJENUMINFO peoei = pv;
    int iItem;
    DIDEVICEOBJECTINSTANCE doi;

    ConvertDoi(peoei->pddi, &doi, pvDoi);

    iItem = ListBox_AddString(peoei->hwndList, doi.tszName);
    ListBox_SetItemData(peoei->hwndList, iItem, doi.dwType);

    return DIENUM_CONTINUE;
}

/*****************************************************************************
 *
 *      EObj_Enum
 *
 *      Enumerate the objects in the device and populate the list box.
 *
 *****************************************************************************/

BOOL INTERNAL
EObj_Enum(HWND hdlg, DWORD dwType)
{
    EOBJENUMINFO eoei;
#ifdef DEBUG
    int iItem;
#endif

    eoei.pddi = GetDialogPtr(hdlg);
    eoei.hwndList = GetDlgItem(hdlg, IDC_ENUMOBJ_LIST);

    SetWindowRedraw(eoei.hwndList, 0);
    ListBox_ResetContent(eoei.hwndList);

    if (eoei.pddi->didcItf & 1) {
        IDirectInputDevice_EnumObjects(eoei.pddi->pdid,
                                       EObj_EnumCallback, &eoei, dwType);
    } else {
        IDirectInputDevice_EnumObjects(eoei.pddi->pdid,
                                       EObj_EnumCallback, &eoei, dwType);
    }

#ifdef DEBUG
    iItem = ListBox_AddString(eoei.hwndList, TEXT("<invalid>"));
    ListBox_SetItemData(eoei.hwndList, iItem, 0);
#endif

    SetWindowRedraw(eoei.hwndList, 1);

    return 1;
}

/*****************************************************************************
 *
 *      EObj_OnInitDialog
 *
 *      Start out by enumerating everything.
 *
 *****************************************************************************/

BOOL INTERNAL
EObj_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PDEVDLGINFO pddi = (PV)(((LPPROPSHEETPAGE)lp)->lParam);

    SetDialogPtr(hdlg, pddi);

    CheckRadioButton(hdlg, IDC_ENUMOBJ_AXES, IDC_ENUMOBJ_ALL, IDC_ENUMOBJ_ALL);
    EObj_Enum(hdlg, DIDFT_ALL);

    return 1;
}

/*****************************************************************************
 *
 *      EObj_OnDblClk
 *
 *      An item in the list box was double-clicked.  Display details.
 *
 *****************************************************************************/

BOOL INTERNAL
EObj_OnDblClk(HWND hdlg)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);
    HWND hwndList = GetDlgItem(hdlg, IDC_ENUMOBJ_LIST);
    int iItem;

    iItem = ListBox_GetCurSel(hwndList);

    if (iItem >= 0) {
        DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_OBJPROP),
                       GetParent(hdlg), Prop_DlgProc, (LPARAM)hdlg);

        /*
         *  That dialog screws up the vwi state.
         */
        SetActiveWindow(hdlg);
    }

    return 1;
}

/*****************************************************************************
 *
 *      EObj_OnCommand
 *
 *****************************************************************************/

BOOL INLINE
EObj_OnCommand(HWND hdlg, int id, UINT cmd)
{
    switch (id) {

    case IDC_ENUMOBJ_AXES:    return EObj_Enum(hdlg, DIDFT_AXIS);
    case IDC_ENUMOBJ_BUTTONS: return EObj_Enum(hdlg, DIDFT_BUTTON);
    case IDC_ENUMOBJ_POVS:    return EObj_Enum(hdlg, DIDFT_POV);
    case IDC_ENUMOBJ_ALL:     return EObj_Enum(hdlg, DIDFT_ALL | DIDFT_ALIAS | DIDFT_VENDORDEFINED);
    case IDC_ENUMOBJ_LIST:
        if (cmd == LBN_DBLCLK)return EObj_OnDblClk(hdlg);
        break;

    case IDC_ENUMOBJ_PROP:    return EObj_OnDblClk(hdlg);
    }
    return 0;
}

/*****************************************************************************
 *
 *      EObj_DlgProc
 *
 *****************************************************************************/

INT_PTR CALLBACK
EObj_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG: return EObj_OnInitDialog(hdlg, lp);

    case WM_COMMAND:
        return EObj_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));

    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqedev.c ===
/*****************************************************************************
 *
 *      diqedev.c
 *
 *      The dialog box that modifies device enumeration.
 *
 *****************************************************************************/

#include "diquick.h"

/*****************************************************************************
 *
 *      DEnum_OnInitDialog
 *
 *      Initialize the enumeration controls based on the current settings.
 *
 *****************************************************************************/

BOOL INTERNAL
DEnum_OnInitDialog(HWND hdlg)
{
    if (g_dwEnumType & DIDEVTYPE_HID) {
        CheckDlgButton(hdlg, IDC_ENUMDEV_HID, TRUE);
    }

    if (g_dwEnumFlags & DIEDFL_ATTACHEDONLY) {
        CheckDlgButton(hdlg, IDC_ENUMDEV_ATT, TRUE);
    }

    if (g_dwEnumFlags & DIEDFL_FORCEFEEDBACK) {
        CheckDlgButton(hdlg, IDC_ENUMDEV_FF, TRUE);
    }

    if (g_dwEnumFlags & DIEDFL_INCLUDEALIASES) {
        CheckDlgButton(hdlg, IDC_ENUMDEV_ALIAS, TRUE);
    }

    if (g_dwEnumFlags & DIEDFL_INCLUDEPHANTOMS) {
        CheckDlgButton(hdlg, IDC_ENUMDEV_PHANTOM, TRUE);
    }

    CheckRadioButton(hdlg, IDC_ENUMDEV_ALL, IDC_ENUMDEV_LAST,
                     IDC_ENUMDEV_ALL + GET_DIDEVICE_TYPE(g_dwEnumType));

    return 1;
}

/*****************************************************************************
 *
 *      DEnum_Apply
 *
 *      Suck out the settings and stash them back.
 *
 *****************************************************************************/

void INTERNAL
DEnum_Apply(HWND hdlg)
{
    DWORD dw;

    dw = GetCheckedRadioButton(hdlg, IDC_ENUMDEV_ALL, IDC_ENUMDEV_LAST) -
                                     IDC_ENUMDEV_ALL;

    if (IsDlgButtonChecked(hdlg, IDC_ENUMDEV_HID)) {
        dw |= DIDEVTYPE_HID;
    }

    g_dwEnumType = dw;


    dw = 0;

    if (IsDlgButtonChecked(hdlg, IDC_ENUMDEV_ATT)) {
        dw |= DIEDFL_ATTACHEDONLY;
    }

    if (IsDlgButtonChecked(hdlg, IDC_ENUMDEV_FF)) {
        dw |= DIEDFL_FORCEFEEDBACK;
    }

    if (IsDlgButtonChecked(hdlg, IDC_ENUMDEV_ALIAS)) {
        dw |= DIEDFL_INCLUDEALIASES;
    }

    if (IsDlgButtonChecked(hdlg, IDC_ENUMDEV_PHANTOM)) {
        dw |= DIEDFL_INCLUDEPHANTOMS;
    }

    g_dwEnumFlags  = dw;

}


/*****************************************************************************
 *
 *      DEnum_OnCommand
 *
 *****************************************************************************/

BOOL INLINE
DEnum_OnCommand(HWND hdlg, int id, UINT cmd)
{
    switch (id) {

    case IDOK: DEnum_Apply(hdlg); EndDialog(hdlg, 1); return TRUE;
    case IDCANCEL: EndDialog(hdlg, 0); return TRUE;
    }
    return FALSE;
}

/*****************************************************************************
 *
 *      DEnum_DlgProc
 *
 *****************************************************************************/

INT_PTR EXTERNAL
DEnum_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG:
        return DEnum_OnInitDialog(hdlg);

    case WM_COMMAND:
        return DEnum_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqhack.c ===
/*****************************************************************************
 *
 *      diqhack.c
 *
 *      Property sheet hacks.
 *
 *      COMMCTRL's property sheet manager assume that all property sheet
 *      pages use "MS Shell Dlg" as their font.  We might not (especially
 *      in Japan), so we need to touch up our dialog dimensions so that
 *      when COMMCTRL computes page dimensions, it comes out okay again.
 *
 *****************************************************************************/

#include "diquick.h"

/*****************************************************************************
 *
 *      Diq_HackPropertySheets
 *
 *      hdlg -  a sample dialog box whose font is the one we are actually
 *              using.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define EMIT_IDD(idd, fn)   idd

UINT c_rgidd[] = {
    EACH_PROPSHEET(EMIT_IDD)
};

typedef struct DLGTEMPLATEEX {
    WORD wDlgVer;
    WORD wSignature;
    DWORD dwHelpID;
    DWORD dwExStyle;
    DWORD style;
    WORD cDlgItems;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATEEX, *PDLGTEMPLATEEX;

INT_PTR INTERNAL
Diq_HackPropertySheets(HWND hdlg)
{
    LOGFONT lf;
    HFONT hfShell, hfDlg, hfOld;
    HDC hdc;
    TEXTMETRIC tmDlg, tmShell;
    BOOL fRc = TRUE;
    int idlg;

    hdc = GetDC(hdlg);

    if( hdc == NULL ) {
    	return FALSE;
    }
    
    /*
     *  For comparison purposes, we need "MS Shell Dlg" at 8pt.
     *
     *  On Windows NT, "MS Shell Dlg" is a real font.
     *  On Windows 95, it's a fake font that is special-cased by
     *  the dialog manager.  So first try to create it for real.
     *  If that fails, then create it for fake.
     */

    ZeroX(lf);
    lf.lfHeight = -MulDiv(8, GetDeviceCaps(hdc, LOGPIXELSY), 72);
    lf.lfWeight = FW_NORMAL;
    lf.lfCharSet = DEFAULT_CHARSET;
    lstrcpy(lf.lfFaceName, TEXT("MS Shell Dlg"));
    hfShell = CreateFontIndirect(&lf);
    if (hfShell == 0) {
        lstrcpy(lf.lfFaceName, TEXT("MS Sans Serif"));
        hfShell = CreateFontIndirect(&lf);
        if (hfShell == 0) {
            fRc = FALSE;
            goto done;
        }
    }

    hfDlg = GetWindowFont(hdlg);
    if (hfDlg == 0) {
        hfDlg = GetStockObject(SYSTEM_FONT);
    }

    hfOld = SelectFont(hdc, hfDlg);
    GetTextMetrics(hdc, &tmDlg);
    SelectFont(hdc, hfShell);
    GetTextMetrics(hdc, &tmShell);
    SelectFont(hdc, hfOld);
    DeleteObject(hfShell);

    /*
     *  Now adjust all the property sheet page dimensions so that
     *  when COMMCTRL tries to adjust them, the two adjustments cancel
     *  out and everybody is happy.
     */
    for (idlg = 0; idlg < cA(c_rgidd); idlg++) {
        HRSRC hrsrc = FindResource(g_hinst, (PV)(UINT_PTR)c_rgidd[idlg], RT_DIALOG);
        if (hrsrc) {
            HGLOBAL hglob = LoadResource(g_hinst, hrsrc);
            if (hglob) {
                LPDLGTEMPLATE ptmp = LockResource(hglob);
                if (ptmp) {
                    short *psi;
                    DWORD dwScratch;

                    if (ptmp->style == 0xFFFF0001) {
                        PDLGTEMPLATEEX pdex = (PV)ptmp;
                        psi = &pdex->cx;
                    } else {
                        psi = &ptmp->cx;
                    }

                    VirtualProtect(psi, 2 * sizeof(short),
                                   PAGE_READWRITE, &dwScratch);

                    psi[0] = (short)MulDiv(psi[0], tmDlg.tmAveCharWidth,
                                            tmShell.tmAveCharWidth);
                    psi[1] = (short)MulDiv(psi[1], tmDlg.tmHeight,
                                            tmShell.tmHeight);
                }
            }
        }
    }

done:;
    ReleaseDC(hdlg, hdc);

    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqeeff.c ===
/*****************************************************************************
 *
 *      diqeeff.c
 *
 *      Property sheet page for device "enumerate effects".
 *
 *****************************************************************************/

#include "diquick.h"

/*****************************************************************************
 *
 *      EEff_AddGuid
 *
 *      Add a GUID to the list, or -1 on error.
 *
 *****************************************************************************/

int INLINE
EEff_AddGuid(PDEVDLGINFO pddi, REFGUID rguid)
{
    return Dary_Append(&pddi->daryGuid, rguid);
}

/*****************************************************************************
 *
 *      EEff_EnumCallback
 *
 *      Called once for each effect.
 *
 *****************************************************************************/

typedef struct EFFENUMINFO {
    HWND        hwndList;
    PDEVDLGINFO pddi;
} EFFENUMINFO, *PEFFENUMINFO;

BOOL CALLBACK
EEff_EnumCallback(PCV pvEffi, LPVOID pv)
{
    PEFFENUMINFO peei = pv;
    PDEVDLGINFO pddi = peei->pddi;
    DIEFFECTINFO ei;
    int iguid;

    ConvertEffi(pddi, &ei, pvEffi);
    iguid = EEff_AddGuid(pddi, &ei.guid);

    if (iguid >= 0) {
        int iItem;

        iItem = ListBox_AddString(peei->hwndList, ei.tszName);
        ListBox_SetItemData(peei->hwndList, iItem, iguid);
    }

    return DIENUM_CONTINUE;
}

/*****************************************************************************
 *
 *      EEff_Enum
 *
 *      Enumerate the objects in the device and populate the list box.
 *
 *****************************************************************************/

BOOL INTERNAL
EEff_Enum(HWND hdlg)
{
    EFFENUMINFO eei;
#ifdef DEBUG
    int iItem;
#endif

    eei.pddi = GetDialogPtr(hdlg);
    eei.hwndList = GetDlgItem(hdlg, IDC_ENUMEFF_LIST);

    SetWindowRedraw(eei.hwndList, FALSE);
    ListBox_ResetContent(eei.hwndList);

    IDirectInputDevice2_EnumEffects(eei.pddi->pdid2,
                                    EEff_EnumCallback, &eei, 0);

#ifdef DEBUG
    iItem = ListBox_AddString(eei.hwndList, TEXT("<invalid>"));
    ListBox_SetItemData(eei.hwndList, iItem,
                        EEff_AddGuid(eei.pddi, &IID_IDirectInputDevice2A));
#endif

    SetWindowRedraw(eei.hwndList, TRUE);

    return 1;
}

/*****************************************************************************
 *
 *      EEff_OnInitDialog
 *
 *      Start out by enumerating everything.
 *
 *****************************************************************************/

BOOL INTERNAL
EEff_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PDEVDLGINFO pddi = (PV)(((LPPROPSHEETPAGE)lp)->lParam);

    SetDialogPtr(hdlg, pddi);

    EEff_Enum(hdlg);

    return 1;
}

/*****************************************************************************
 *
 *      EEff_OnDestroy
 *
 *      Clean up.
 *
 *****************************************************************************/

BOOL INTERNAL
EEff_OnDestroy(HWND hdlg)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);
    if (pddi) {
        Dary_Term(&pddi->daryGuid);
    }
    return 1;
}

/*****************************************************************************
 *
 *      EEff_OnDblClk
 *
 *      An item in the list box was double-clicked.  Show its properties.
 *
 *****************************************************************************/

#if 0
BOOL CALLBACK EnumCallback(LPDIRECTINPUTEFFECT peff, LPVOID pv)
{
peff;
pv;
OutputDebugString("Got an effect\r\n");
peff->lpVtbl->Stop(peff);
return DIENUM_CONTINUE;
}

void __cdecl Squirt(LPCSTR ptszFormat, ...)
{
    TCHAR tsz[1024];
    va_list ap;

    va_start(ap, ptszFormat);
    wvsprintf(tsz, ptszFormat, ap);
    OutputDebugString(tsz);
    OutputDebugString(TEXT("\r\n"));
}

BOOL INTERNAL
EEff_OnDblClk(HWND hdlg)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);
    HWND hwndList = GetDlgItem(hdlg, IDC_ENUMEFF_LIST);
    int iItem;

    iItem = ListBox_GetCurSel(hwndList);

    if (iItem >= 0) {
        int iguid;

        iguid = ListBox_GetItemData(hwndList, iItem);
        if (iguid >= 0) {
            LPDIRECTINPUTDEVICE2 pdev2 = (PV)pddi->pdid;
            LPDIRECTINPUTEFFECT peff;
            REFGUID rguid = Dary_GetPtr(&pddi->daryGuid, iguid, GUID);
            DWORD rgdw[2] = { DIJOFS_X, DIJOFS_Y };
            LONG rgl[2] = { 100, 99 };
            DICONSTANTFORCE cf = { 0 };
            DICONDITION cond[2] = { { 0 } };
            HRESULT hres;
            DIEFFECT deff;
            DIENVELOPE env;

        hres = SetDwordProperty(pddi->pdid, DIPROP_AUTOCENTER, DIPROPAUTOCENTER_OFF);

            ZeroX(env);
            env.dwSize = cbX(env);

            ZeroX(deff);
            deff.dwSize = cbX(deff);
            deff.dwFlags = DIEFF_OBJECTOFFSETS | DIEFF_POLAR;
            deff.cAxes = 2;
            deff.rgdwAxes = rgdw;
            deff.rglDirection = rgl;
            deff.dwTriggerButton = DIEB_NOTRIGGER;//DIJOFS_BUTTON0;
            deff.cbTypeSpecificParams = cbX(cf);
            deff.lpvTypeSpecificParams = &cf;
//            deff.lpEnvelope = &env;

                pdev2->lpVtbl->Acquire(pdev2);

            hres = IDirectInputDevice2_CreateEffect(pdev2, rguid,
                                                    &deff, &peff, 0);
            if (SUCCEEDED(hres)) {

                hres = IDirectInputDevice2_EnumCreatedEffectObjects(pdev2,
                EnumCallback, 0, 0);

                memset(&env, 0xCC, cbX(env));
                deff.lpEnvelope = &env;
            env.dwSize = cbX(env);
//deff.cbTypeSpecificParams = 0;

            deff.dwFlags = DIEFF_OBJECTIDS |
                DIEFF_SPHERICAL | DIEFF_CARTESIAN | DIEFF_POLAR;
                hres = IDirectInputEffect_GetParameters(peff, &deff,
DIEP_ALLPARAMS);

Squirt("------------------------------------");
Squirt("----- dwFlags = %08x", deff.dwFlags);
Squirt("----- dwDuration = %d", deff.dwDuration);
Squirt("----- dwSamplePeriod = %d", deff.dwSamplePeriod);
Squirt("----- dwGain = %d", deff.dwGain);
Squirt("----- dwTriggerButton = %08x", deff.dwTriggerButton);
Squirt("----- dwTriggerRepeatInterval = %d", deff.dwTriggerRepeatInterval);
Squirt("----- cAxes = %d", deff.cAxes);
Squirt("----- rgdwAxes = %08x", deff.rgdwAxes);
Squirt("----- rglDirection = %08x", deff.rglDirection);
Squirt("----- rglDirection[0] = %d", rgl[0]);
Squirt("----- rglDirection[1] = %d", rgl[1]);
Squirt("----- cbTSP = %d", deff.cbTypeSpecificParams);
Squirt("------------------------------------");

                hres = IDirectInputEffect_Start(peff, 1, 0);
                hres = IDirectInputEffect_Stop(peff);
                hres = IDirectInputEffect_GetEffectStatus(peff, rgdw);

                peff->lpVtbl->Release(peff);

            }
                pdev2->lpVtbl->Unacquire(pdev2);

        }
    }

    return 1;
}

#else

BOOL INTERNAL
EEff_OnDblClk(HWND hdlg)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);
    HWND hwndList = GetDlgItem(hdlg, IDC_ENUMEFF_LIST);
    int iItem;

    iItem = ListBox_GetCurSel(hwndList);

    if (iItem >= 0) {
        int iguid;

        iguid = (int)(INT_PTR)ListBox_GetItemData(hwndList, iItem);
        if (iguid >= 0) {
            REFGUID rguid = Dary_GetPtr(&pddi->daryGuid, iguid, GUID);
            EffProp_Create(hdlg, pddi, rguid);
        }
    }

    return TRUE;
}

#endif

/*****************************************************************************
 *
 *      EEff_OnCommand
 *
 *****************************************************************************/

BOOL INLINE
EEff_OnCommand(HWND hdlg, int id, UINT cmd)
{
    switch (id) {

    case IDC_ENUMEFF_LIST:
        if (cmd == LBN_DBLCLK) return EEff_OnDblClk(hdlg);
        break;
    }
    return 0;
}

/*****************************************************************************
 *
 *      EEff_DlgProc
 *
 *****************************************************************************/

INT_PTR CALLBACK
EEff_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG: return EEff_OnInitDialog(hdlg, lp);

    case WM_COMMAND:
        return EEff_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));

    case WM_DESTROY: return EEff_OnDestroy(hdlg);

    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqeprop.c ===
/*****************************************************************************
 *
 *      diqeprop.c
 *
 *      The dialog box that displays effect properties.
 *
 *****************************************************************************/

#include "diquick.h"

#pragma BEGIN_CONST_DATA

CHECKLISTFLAG c_rgclfDieft[] = {
    { DIEFT_FFATTACK,           IDS_FFATTACK,           },
    { DIEFT_FFFADE,             IDS_FFFADE,             },
    { DIEFT_SATURATION,         IDS_SATURATION,         },
    { DIEFT_POSNEGCOEFFICIENTS, IDS_POSNEGCOEFFICIENTS  },
    { DIEFT_POSNEGSATURATION,   IDS_POSNEGSATURATION,   },
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *      Effect property dialog instance data
 *
 *****************************************************************************/

typedef struct EFFPROPINFO {

    PDEVDLGINFO pddi;
    const GUID *rguidEff;

} EFFPROPINFO, *PEFFPROPINFO;

/*****************************************************************************
 *
 *      EffProp_OnInitDialog
 *
 *****************************************************************************/

BOOL INTERNAL
EffProp_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PEFFPROPINFO pepi = (PV)lp;
    DIEFFECTINFO ei;
    HRESULT hres;

    /*
     *  Don't SetDialogPtr until we're finished.  This prevents
     *  WM_COMMAND from causing us to do wacky things before
     *  we're ready.
     */

    ei.dwSize = cbX(ei);
    hres = GetEffectInfo(pepi->pddi, &ei, pepi->rguidEff);
    if (SUCCEEDED(hres)) {

        SetWindowText(hdlg, ei.tszName);

        SetDlgItemText(hdlg, IDC_EPROP_GUID, MapGUID(&ei.guid, ei.tszName));

        LoadString(g_hinst, IDS_EFFECT_TYPEARRAY +
                            DIEFT_GETTYPE(ei.dwEffType),
                            ei.tszName, cA(ei.tszName));

        if (ei.tszName[0]) {
            SetDlgItemText(hdlg, IDC_EPROP_TYPE, ei.tszName);
        } else {
            SetDlgItemInt(hdlg, IDC_EPROP_TYPE, DIEFT_GETTYPE(ei.dwEffType), 0);
        }

        Checklist_InitFlags(hdlg, IDC_EPROP_FLAGS, ei.dwEffType,
                            c_rgclfDieft, cA(c_rgclfDieft));

        wsprintf(ei.tszName, TEXT("%08x"), ei.dwStaticParams);
        SetDlgItemText(hdlg, IDC_EPROP_STATICPARM, ei.tszName);

        wsprintf(ei.tszName, TEXT("%08x"), ei.dwDynamicParams);
        SetDlgItemText(hdlg, IDC_EPROP_DYNAMICPARM, ei.tszName);

    }

    SetDialogPtr(hdlg, pepi);

    #if 0   // temp hack to test effect goo
    _asm int 3
    hres = IDirectInputDevice_Acquire(pepi->pddi->pdid);
    {
            LPDIRECTINPUTEFFECT peff;
            hres = IDirectInputDevice2_CreateEffect(
                        pepi->pddi->pdid2, &ei.guid, 0, &peff, 0);
            if (SUCCEEDED(hres)) {
                DWORD dw = 3;
                DIEFFESCAPE esc = { cbX(esc), 0, &dw, 4, &dw, 4 };
                peff->lpVtbl->Escape(peff, &esc);
//                hres = IDirectInputDevice2_EnumCreatedEffects(pdev2,
//                EnumCallback, 0, 0);

                peff->lpVtbl->Release(peff);

            }

    }
    hres = IDirectInputDevice_Unacquire(pepi->pddi->pdid);

    #endif

    return 1;
}

/*****************************************************************************
 *
 *      EffProp_DlgProc
 *
 *****************************************************************************/

INT_PTR INTERNAL
EffProp_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG:
        return EffProp_OnInitDialog(hdlg, lp);

    case WM_DESTROY:
        Checklist_OnDestroy(GetDlgItem(hdlg, IDC_EPROP_FLAGS));
        break;

    case WM_CLOSE:
        EndDialog(hdlg, TRUE);
        return TRUE;
    }

    return 0;
}

/*****************************************************************************
 *
 *      EffProp_Create
 *
 *      Display info about an effect.
 *
 *****************************************************************************/

INT_PTR EXTERNAL
EffProp_Create(HWND hdlg, PDEVDLGINFO pddi, REFGUID rguidEff)
{
    EFFPROPINFO epi;

    epi.pddi = pddi;
    epi.rguidEff = rguidEff;

    return DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_EFFPROP),
                          hdlg, EffProp_DlgProc, (LPARAM)&epi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqmain.c ===
/*****************************************************************************
 *
 *      diqmain.c
 *
 *      The main dialog box.
 *
 *****************************************************************************/

#include "diquick.h"

GUID GUID_Uninit = { 1 };

DWORD g_dwEnumType;
DWORD g_dwEnumFlags;

/*****************************************************************************
 *
 *      Dialog instance data
 *
 *      Instance data for main dialog box.
 *
 *****************************************************************************/

typedef struct MAINDLGINFO {
    HWND    hwndDevices;                /* Devices combo box */
    UINT    cBusy;                      /* Number of threads starting */
    UINT    cDevs;                      /* Number of devices created */
    IDirectInput *pdi;                  /* Cached interface */
    BOOL    fW;                         /* Is pdi a pdiW? (else, pdiA) */
    DARY    daryDevs;                   /* Device info lives here */
} MAINDLGINFO, *PMAINDLGINFO;

/*****************************************************************************
 *
 *      Diq_DeviceEnumProc
 *
 *      Device enumeration procedure which is called one for each device.
 *
 *      Add the item to our dialog instance data and to the combo box.
 *
 *****************************************************************************/

BOOL INTERNAL
Diq_DeviceEnumProc(PCV pvDi, LPVOID pv)
{
    PMAINDLGINFO pmdi = pv;
    DIDEVICEINSTANCE didi;
    TCHAR tsz[1024];
    int ich;

    if (pmdi->fW) {
        LPCDIDEVICEINSTANCEW pdiW = pvDi;
        didi.guidInstance = pdiW->guidInstance;
        didi.guidProduct  = pdiW->guidProduct;
        didi.dwDevType    = pdiW->dwDevType;
        ConvertString(pmdi->fW, pdiW->tszProductName,
                                didi.tszProductName,
                             cA(didi.tszProductName));
        ConvertString(pmdi->fW, pdiW->tszInstanceName,
                                didi.tszInstanceName,
                             cA(didi.tszInstanceName));
    } else {
        LPCDIDEVICEINSTANCEA pdiA = pvDi;
        didi.guidInstance = pdiA->guidInstance;
        didi.guidProduct  = pdiA->guidProduct;
        didi.dwDevType    = pdiA->dwDevType;
        ConvertString(pmdi->fW, pdiA->tszProductName,
                                didi.tszProductName,
                             cA(didi.tszProductName));
        ConvertString(pmdi->fW, pdiA->tszInstanceName,
                                didi.tszInstanceName,
                             cA(didi.tszInstanceName));
    }

    ich = wsprintf(tsz, TEXT("%s (%s)"),
                   didi.tszInstanceName,
                   didi.tszProductName);


    if (didi.dwDevType & DIDEVTYPE_HID) {
        LoadString(g_hinst, IDS_SPACEPARENHID, &tsz[ich], 10);
    }

    ComboBox_AddString(pmdi->hwndDevices, tsz);
    Dary_Append(&pmdi->daryDevs, &didi);

    return DIENUM_CONTINUE;
}

/*****************************************************************************
 *
 *      Diq_EnumDevices
 *
 *      Rebuild the list of enumerated devices.  Try to preserve the
 *      current selection index.
 *
 *****************************************************************************/

void INTERNAL
Diq_EnumDevices(PMAINDLGINFO pmdi)
{
    HRESULT hres;
    int iSel = ComboBox_GetCurSel(pmdi->hwndDevices);
    HCURSOR hcurPrev = GetCursor();
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    Dary_Term(&pmdi->daryDevs);
    ZeroX(pmdi->daryDevs);
    ComboBox_ResetContent(pmdi->hwndDevices);

#if defined(_DEBUG) || defined(DEBUG)
  {
    /*
     *  Create the intentionally invalid device.
     */
    DIDEVICEINSTANCE didi;
    ComboBox_AddString(pmdi->hwndDevices, g_tszInvalid);
    ZeroX(didi);
    Dary_Append(&pmdi->daryDevs, &didi);

    ComboBox_AddString(pmdi->hwndDevices, "<uninit>");
    ZeroX(didi);
    didi.guidInstance = GUID_Uninit;
    lstrcpyn(didi.tszInstanceName, "<uninit instance>",
             cA(didi.tszInstanceName));
    Dary_Append(&pmdi->daryDevs, &didi);
  }
#endif

    pmdi->fW = 1;
    hres = DirectInputCreateW(g_hinst, g_dwDIVer, (PVOID)&pmdi->pdi, 0);

    /* For each object, add it to the menu */
    if (SUCCEEDED(hres)) {

        IDirectInput_EnumDevices(pmdi->pdi, g_dwEnumType, Diq_DeviceEnumProc,
                                 pmdi, g_dwEnumFlags);
        IDirectInput_Release(pmdi->pdi);
        pmdi->pdi = 0;
    }

    ComboBox_SetCurSel(pmdi->hwndDevices, max(iSel, 0));

    SetCursor(hcurPrev);
}

/*****************************************************************************
 *
 *      Diq_OnInitDialog
 *
 *      Populate the combo box with the list of devices.
 *
 *****************************************************************************/

BOOL INTERNAL
Diq_OnInitDialog(HWND hdlg)
{
    PMAINDLGINFO pmdi;

    Diq_HackPropertySheets(hdlg);

    pmdi = LocalAlloc(LPTR, cbX(MAINDLGINFO));

    if ( !pmdi ) {
    	return 0;
    }
    
    SetDialogPtr(hdlg, pmdi);

    pmdi->hwndDevices = GetDlgItem(hdlg, IDC_MAIN_DEVICES);

    Diq_EnumDevices(pmdi);

    CheckRadioButton(hdlg, IDC_MAIN_OLE,  IDC_MAIN_DI,   IDC_MAIN_DI);
    CheckRadioButton(hdlg, IDC_MAIN_DIA,  IDC_MAIN_DIW,     IDC_MAIN_DIW);
    CheckRadioButton(hdlg, IDC_MAIN_DIDA, IDC_MAIN_ITFMAC, IDC_MAIN_DIDW);

    if (g_dwDIVer <= 0x0300) {
        EnableWindow(GetDlgItem(hdlg, IDC_MAIN_DID2A), FALSE);
        EnableWindow(GetDlgItem(hdlg, IDC_MAIN_DID2W), FALSE);
        EnableWindow(GetDlgItem(hdlg, IDC_MAIN_DIDJC), FALSE);
    }

    return 1;
}

/*****************************************************************************
 *
 *      Diq_OnDestroy
 *
 *      Clean up.
 *
 *****************************************************************************/

BOOL INTERNAL
Diq_OnDestroy(PMAINDLGINFO pmdi, HWND hdlg)
{
    if (pmdi) {
        Dary_Term(&pmdi->daryDevs);
        LocalFree(pmdi);
    }
    return 1;
}

/*****************************************************************************
 *
 *      Diq_RecalcClose
 *
 *      Enable or disable the SC_CLOSE option accordingly.
 *
 *****************************************************************************/

void INTERNAL
Diq_RecalcClose(PMAINDLGINFO pmdi, HWND hdlg)
{
    EnableMenuItem(GetSystemMenu(hdlg, 0), SC_CLOSE,
                   MF_BYCOMMAND |
                    (pmdi->cDevs ? MF_DISABLED | MF_GRAYED : MF_ENABLED));
}

/*****************************************************************************
 *
 *      Diq_OnGetStatus
 *
 *      Somebody asked for the status of the device.
 *
 *****************************************************************************/

BOOL INTERNAL
Diq_OnGetStatus(HWND hdlg)
{
    PMAINDLGINFO pmdi = GetDialogPtr(hdlg);
    int iSel = ComboBox_GetCurSel(pmdi->hwndDevices);

    if ((UINT)iSel < (UINT)pmdi->daryDevs.cx) {

        LPDIRECTINPUTA pdia;
        HRESULT hres;
        UINT didc;
        int ids;

        didc = GetCheckedRadioButton(hdlg,
                           IDC_MAIN_ITF, IDC_MAIN_ITFMAC) - IDC_MAIN_ITF;

        hres = CreateDI(IsDlgButtonChecked(hdlg, IDC_MAIN_OLE),
                        IsUnicodeDidc(didc),
                        (PPV)&pdia);

        if (SUCCEEDED(hres)) {
            LPDIDEVICEINSTANCE pdidi;
            pdidi = Dary_GetPtr(&pmdi->daryDevs, iSel, DIDEVICEINSTANCE);

            hres = IDirectInput_GetDeviceStatus(pdia,
                                                &pdidi->guidInstance);

            switch (hres) {
            case DI_OK:             ids = IDS_GETSTAT_OK; break;
            case DI_NOTATTACHED:    ids = IDS_GETSTAT_NOTATTACHED; break;
            default:                ids = IDS_GETSTAT_ERROR; break;
            }

        } else {
            ids = IDS_GETSTAT_ERROR;
        }
        MessageBoxV(hdlg, ids, hres);
    }
    return 1;
}

/*****************************************************************************
 *
 *      Diq_OnCreateObject
 *
 *      Somebody asked us to create an object.  Party!
 *
 *****************************************************************************/

BOOL INTERNAL
Diq_OnCreateObject(HWND hdlg)
{
    PMAINDLGINFO pmdi = GetDialogPtr(hdlg);
    int iSel = ComboBox_GetCurSel(pmdi->hwndDevices);

//#ifdef DEBUG
    if (IsDlgButtonChecked(hdlg, IDC_MAIN_DIDJC)) {
        if (Cpl_Create(hdlg,
                       IsDlgButtonChecked(hdlg, IDC_MAIN_OLE),
                       IsDlgButtonChecked(hdlg, IDC_MAIN_DIW))) {
            pmdi->cBusy++;
            pmdi->cDevs++;
            RecalcCursor(hdlg);
            Diq_RecalcClose(pmdi, hdlg);
        }
    } else
//#endif
    if ((UINT)iSel < (UINT)pmdi->daryDevs.cx) {
        UINT didc;
        LPDIDEVICEINSTANCE pdidi;

        didc = GetCheckedRadioButton(hdlg,
                           IDC_MAIN_ITF, IDC_MAIN_ITFMAC) - IDC_MAIN_ITF;
        pdidi = Dary_GetPtr(&pmdi->daryDevs, iSel, DIDEVICEINSTANCE);

        if (Dev_Create(hdlg,
                       IsDlgButtonChecked(hdlg, IDC_MAIN_OLE),
                       IsUnicodeDidc(didc),
                       &pdidi->guidInstance,
                       pdidi->tszInstanceName,
                       didc)) {
            pmdi->cBusy++;
            pmdi->cDevs++;
            RecalcCursor(hdlg);
            Diq_RecalcClose(pmdi, hdlg);
        }
    }
    return 1;
}

/*****************************************************************************
 *
 *      Diq_OnFindDevice
 *
 *      Display the "FindDevice" dialog.
 *
 *****************************************************************************/

BOOL INTERNAL
Diq_OnFindDevice(HWND hdlg)
{
    PMAINDLGINFO pmdi = GetDialogPtr(hdlg);
    UINT didc;

    didc = GetCheckedRadioButton(hdlg,
                       IDC_MAIN_ITF, IDC_MAIN_ITFMAC) - IDC_MAIN_ITF;

    if (Find_Create(hdlg,
                    IsDlgButtonChecked(hdlg, IDC_MAIN_OLE),
                    IsDlgButtonChecked(hdlg, IDC_MAIN_DIW))) {
        pmdi->cBusy++;
        pmdi->cDevs++;
        RecalcCursor(hdlg);
        Diq_RecalcClose(pmdi, hdlg);
    }
    return 1;
}

/*****************************************************************************
 *
 *      Diq_OnControlPanel
 *
 *      Run the DirectInput control panel using the indicated interface.
 *
 *****************************************************************************/

BOOL INTERNAL
Diq_OnControlPanel(HWND hdlg)
{
    HRESULT hres;
    LPDIRECTINPUTA pdia;

    hres = CreateDI(IsDlgButtonChecked(hdlg, IDC_MAIN_OLE),
                    IsDlgButtonChecked(hdlg, IDC_MAIN_DIW),
                    (PPV)&pdia);
    if (SUCCEEDED(hres)) {
        hres = pdia->lpVtbl->RunControlPanel(pdia, hdlg, 0);
        if (SUCCEEDED(hres)) {
        } else {
            MessageBoxV(hdlg, IDS_ERR_RUNCPL, hres);
        }
        pdia->lpVtbl->Release(pdia);
    } else {
        MessageBoxV(hdlg, IDS_ERR_CREATEOBJ, hres);
    }
    return 1;
}

/*****************************************************************************
 *
 *      Diq_OnRefresh
 *
 *      Refresh the device list.
 *
 *****************************************************************************/

BOOL INTERNAL
Diq_OnRefresh(HWND hdlg)
{
    if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_ENUMDEV),
                          hdlg, DEnum_DlgProc) > 0) {
        PMAINDLGINFO pmdi = GetDialogPtr(hdlg);
        Diq_EnumDevices(pmdi);
    }
    return TRUE;
}


/*****************************************************************************
 *
 *      Diq_OnCommand
 *
 *****************************************************************************/

BOOL INLINE
Diq_OnCommand(HWND hdlg, int id, UINT cmd)
{
    switch (id) {

    case IDC_MAIN_GETSTAT:return Diq_OnGetStatus(hdlg);
    case IDC_MAIN_CREATE: return Diq_OnCreateObject(hdlg);
    case IDC_MAIN_CPL:    return Diq_OnControlPanel(hdlg);
    case IDC_MAIN_FIND:   return Diq_OnFindDevice(hdlg);
    case IDC_MAIN_REFRESH:return Diq_OnRefresh(hdlg);
    }
    return 0;
}

/*****************************************************************************
 *
 *      Diq_OnChildExit
 *
 *      A client device has exited.  Decrement the dev count.
 *
 *****************************************************************************/

BOOL INTERNAL
Diq_OnChildExit(PMAINDLGINFO pmdi, HWND hdlg)
{
    if (pmdi) {
        pmdi->cDevs--;
        if (pmdi->cDevs == 0) {
            Diq_RecalcClose(pmdi, hdlg);
        }
    }
    return 1;
}

/*****************************************************************************
 *
 *      Diq_OnThreadStarted
 *
 *      A worker thread has finished starting.  Decrement our busy count.
 *
 *****************************************************************************/

BOOL INTERNAL
Diq_OnThreadStarted(PMAINDLGINFO pmdi, HWND hdlg)
{
    if (pmdi) {
        pmdi->cBusy--;
        if (pmdi->cBusy == 0) {     /* Set the cursor back if it's us */
            RecalcCursor(hdlg);
        }
    }
    return 1;
}

/*****************************************************************************
 *
 *      Diq_OnSetCursor
 *
 *      Set the cursor to match our pending thread create count.
 *
 *****************************************************************************/

BOOL INTERNAL
Diq_OnSetCursor(PMAINDLGINFO pmdi, HWND hdlg, WPARAM wp, LPARAM lp)
{
    if (LOWORD(lp) == HTCLIENT && pmdi->cBusy) {
        SetCursor(g_hcurStarting);
        return SetDlgMsgResult(hdlg, WM_SETCURSOR, 1);
    } else {
        return 0;
    }
}

/*****************************************************************************
 *
 *      Diq_DlgProc
 *
 *****************************************************************************/

INT_PTR CALLBACK
Diq_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    PMAINDLGINFO pmdi = GetDialogPtr(hdlg);
    switch (wm) {
    case WM_INITDIALOG: return Diq_OnInitDialog(hdlg);
    case WM_DESTROY: return Diq_OnDestroy(pmdi, hdlg);

    case WM_CLOSE: EndDialog(hdlg, 0); break;

    case WM_COMMAND:
        return Diq_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));

    case WM_SETCURSOR:
        return Diq_OnSetCursor(pmdi, hdlg, wp, lp);

    case WM_THREADSTARTED:
        return Diq_OnThreadStarted(pmdi, hdlg);

    case WM_CHILDEXIT:
        return Diq_OnChildExit(pmdi, hdlg);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqfind.c ===
/*****************************************************************************
 *
 *      diqfind.c
 *
 *      The dialog box that tests IDirectInput2::FindDevice.
 *
 *****************************************************************************/

#include "diquick.h"
#include "dinputd.h"

/*****************************************************************************
 *
 *      Find dialog instance data
 *
 *      Instance data for FindDevice dialog box.
 *
 *****************************************************************************/

typedef struct FINDDLGINFO {
    HWND    hdlgOwner;          /* Owner window */
    BOOL    fOle;               /* Should we create via OLE? */
    UINT    flCreate;           /* Flags */

    IDirectInput2 *pdi2;        /* The thing we created */

} FINDDLGINFO, *PFINDDLGINFO;

/*****************************************************************************
 *
 *      Find_OnInitDialog
 *
 *****************************************************************************/

BOOL INTERNAL
Find_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PFINDDLGINFO pfind = (PV)lp;
    HWND hwnd;

    SetDialogPtr(hdlg, pfind);

    hwnd = GetDlgItem(hdlg, IDC_FIND_NAME);
    Edit_LimitText(hwnd, MAX_PATH);

    return 1;
}

/*****************************************************************************
 *
 *      Find_OnInitDialog
 *
 *****************************************************************************/

BOOL INTERNAL
Find_OnFind(HWND hdlg)
{
    PFINDDLGINFO pfind = GetDialogPtr(hdlg);
    GUID guid;
    HRESULT hres;
    TCHAR tsz[MAX_PATH];
    union {
        CHAR sz[MAX_PATH];
        WCHAR wsz[MAX_PATH];
    } u;

    /*
     *  tsz must be a separate buffer because
     *  WideCharToMultiByte / MultiByteToWideChar
     *  don't support converting to/from the same buffer...
     */

    GetDlgItemText(hdlg, IDC_FIND_NAME, tsz, cA(tsz));

    UnconvertString(pfind->flCreate & CDIFL_UNICODE,
                    tsz, &u, MAX_PATH);

    hres = IDirectInput2_FindDevice(pfind->pdi2, &GUID_HIDClass,
                                    (LPVOID)&u, &guid);

    if (SUCCEEDED(hres)) {
        StringFromGuid(tsz, &guid);
    } else {
        wsprintf(tsz, TEXT("Device not found, or wrong device name. (%08x)"), hres);
    }

    SetDlgItemText(hdlg, IDC_FIND_GUID, tsz);

    return 1;
}

/*****************************************************************************
 *
 *      Find_OnCommand
 *
 *****************************************************************************/

BOOL INTERNAL
Find_OnCommand(HWND hdlg, int id, UINT cmd)
{
    switch (id) {

    case IDC_FIND_FIND:  return Find_OnFind(hdlg);

    }
    return 0;
}

/*****************************************************************************
 *
 *      Find_DlgProc
 *
 *****************************************************************************/

INT_PTR INTERNAL
Find_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG:
        return Find_OnInitDialog(hdlg, lp);

    case WM_DESTROY:
        /*
         *  Find_ThreadStart will do the cleanup for us.
         */
        break;

    case WM_COMMAND:
        return Find_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));

    case WM_CLOSE:
        DestroyWindow(hdlg);
        return TRUE;
    }

    return 0;
}

/*****************************************************************************
 *
 *      Find_DoFind
 *
 *****************************************************************************/

void INLINE
Find_DoFind(PFINDDLGINFO pfind)
{
    SendNotifyMessage(pfind->hdlgOwner, WM_THREADSTARTED, 0, 0);

    /*
     *  This function also sends the WM_CHILDEXIT.
     */
    SemimodalDialogBoxParam(IDD_FIND, pfind->hdlgOwner, Find_DlgProc,
                            (LPARAM)pfind);

}

/*****************************************************************************
 *
 *      Find_ThreadStart
 *
 *      Runs on the new thread.  Creates the object and spins the dialog
 *      box to control it.
 *
 *****************************************************************************/

DWORD WINAPI
Find_ThreadStart(PFINDDLGINFO pfind)
{
    HRESULT hres;

    hres = CoInitialize(0);

    if (SUCCEEDED(hres)) {
        hres = CreateDI(pfind->fOle, CDIFL_DI2 | pfind->flCreate,
                        (PPV)&pfind->pdi2);
        if (SUCCEEDED(hres)) {
            Find_DoFind(pfind);

            IDirectInput_Release(pfind->pdi2);

        } else {
            ThreadFailHres(pfind->hdlgOwner, IDS_ERR_CREATEOBJ, hres);
        }

        CoUninitialize();
    } else {
        ThreadFailHres(pfind->hdlgOwner, IDS_ERR_COINIT, hres);
    }

    LocalFree(pfind);
    return 0;
}

/*****************************************************************************
 *
 *      Find_Create
 *
 *      Spin a thread to create a DirectInput device interface.
 *
 *****************************************************************************/

INT_PTR EXTERNAL
Find_Create(HWND hdlg, BOOL fOle, UINT flCreate)
{
    PFINDDLGINFO pfind = LocalAlloc(LPTR, cbX(FINDDLGINFO));

    if (pfind) {
        DWORD id;
        HANDLE h;

        pfind->hdlgOwner     = hdlg         ;
        pfind->fOle          = fOle         ;
        pfind->flCreate      = flCreate     ;

        h = CreateThread(0, 0, Find_ThreadStart, pfind, 0, &id);

        if (h) {
        } else {
            LocalFree(pfind);
            pfind = 0;
        }
    }
    return (INT_PTR)pfind;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqmode.c ===
/*****************************************************************************
 *
 *      diqmode.c
 *
 *      "Mode" property sheet page.
 *
 *****************************************************************************/

#include "diquick.h"

/*****************************************************************************
 *
 *      Common_AcqSetDataFormat
 *
 *      Common worker function that sets the data format.
 *
 *****************************************************************************/

STDMETHODIMP
Common_AcqSetDataFormat(PDEVDLGINFO pddi)
{
    return IDirectInputDevice_SetDataFormat(pddi->pdid, pddi->pvtbl->pdf);
}

/*****************************************************************************
 *
 *      Common_AcqDestroy
 *
 *      Common worker function that doesn't do anything.
 *
 *****************************************************************************/

STDMETHODIMP_(void)
Common_AcqDestroy(PDEVDLGINFO pddi)
{
}

/*****************************************************************************
 *
 *      Mode_SyncCheckButtons
 *
 *      Sync the dialog buttons with the IDirectInputXxx object.
 *
 *****************************************************************************/

void INTERNAL
Mode_SyncCheckButtons(PDEVDLGINFO pddi, HWND hdlg)
{
    UINT idc;
    DWORD dw;

    switch (pddi->discl) {
    default:
    case DISCL_BACKGROUND | DISCL_NONEXCLUSIVE:
         idc = IDC_DEV_PASSIVE; break;

    case DISCL_FOREGROUND | DISCL_NONEXCLUSIVE:
         idc = IDC_DEV_PASSIVE_FOREGROUND; break;

    case DISCL_BACKGROUND | DISCL_EXCLUSIVE:
         idc = IDC_DEV_ACTIVE_BACKGROUND; break;

    case DISCL_FOREGROUND | DISCL_EXCLUSIVE:
         idc = IDC_DEV_ACTIVE; break;

    }

    CheckRadioButton(hdlg, IDC_DEV_PASSIVE, IDC_DEV_ACTIVE, idc);

    CheckRadioButton(hdlg, IDC_DEV_POLLED, IDC_DEV_EVENT,
                     pddi->fPoll ? IDC_DEV_POLLED : IDC_DEV_EVENT);

    EnableWindow(GetDlgItem(hdlg, IDC_DEV_NOWINKEY), FALSE);
    
    if (pddi->pvtbl == &c_acqvtblDevMouse || pddi->pvtbl == &c_acqvtblDevMouse2 ) {
        idc = IDC_DEV_MOUSE;
    } else if (pddi->pvtbl == &c_acqvtblDevKbd) {
        idc = IDC_DEV_KEYBOARD;
        EnableWindow(GetDlgItem(hdlg, IDC_DEV_NOWINKEY), TRUE);
    } else if (pddi->pvtbl == &c_acqvtblDevJoy) {
        idc = IDC_DEV_JOYSTICK;
    } else if (pddi->pvtbl == &c_acqvtblDev) {
        idc = IDC_DEV_DEVICE;
    } else {
        idc = 0;
    }

    CheckRadioButton(hdlg, IDC_DEV_MOUSE, IDC_DEV_DEVICE, idc);

    if (SUCCEEDED(GetDwordProperty(pddi->pdid, DIPROP_AXISMODE, &dw))) {
        CheckRadioButton(hdlg, IDC_DEV_ABS, IDC_DEV_REL,
                         dw == DIPROPAXISMODE_ABS ? IDC_DEV_ABS
                                                  : IDC_DEV_REL);
    }

    if (SUCCEEDED(GetDwordProperty(pddi->pdid, DIPROP_CALIBRATIONMODE, &dw))) {
    } else {
        dw = 0;
    }
    CheckDlgButton(hdlg, IDC_DEV_CAL, dw);

}

/*****************************************************************************
 *
 *      Mode_OnDataFormat
 *
 *      Change the device data format.
 *
 *****************************************************************************/

BOOL INTERNAL
Mode_OnDataFormat(PDEVDLGINFO pddi, HWND hdlg, UINT id)
{
    DIDEVCAPS didc;
    HRESULT hres;
	UINT idDev;

    /*
     *  Kill the old data format before setting the new one.
     */
    if (pddi->pvtbl) {
        pddi->pvtbl->Destroy(pddi);
    }

	if( id == 0 ) {		//from On_InitDialog
		didc.dwSize = cbX(DIDEVCAPS_DX3);
		hres = IDirectInputDevice_GetCapabilities(pddi->pdid, &didc);
		if (SUCCEEDED(hres)) 
			idDev = GET_DIDEVICE_TYPE(didc.dwDevType);
	} else
		idDev = id;

	switch (idDev) {

    case DIDEVTYPE_MOUSE:
    case IDC_DEV_MOUSE:
#if DIRECTINPUT_VERSION >= 0x700
        pddi->pvtbl = &c_acqvtblDevMouse2;
#else
        pddi->pvtbl = &c_acqvtblDevMouse;
#endif
        break;

    case DIDEVTYPE_KEYBOARD:
    case IDC_DEV_KEYBOARD:
        pddi->pvtbl = &c_acqvtblDevKbd;
        break;

    case DIDEVTYPE_JOYSTICK:
    case IDC_DEV_JOYSTICK:
        pddi->pvtbl = &c_acqvtblDevJoy;
        break;

    case DIDEVTYPE_DEVICE:
    case IDC_DEV_DEVICE:
        pddi->pvtbl = &c_acqvtblDev;
        break;
    }

    if (pddi->pvtbl) {
        HRESULT hres;
        hres = pddi->pvtbl->SetDataFormat(pddi);
        if (FAILED(hres)) {
            MessageBoxV(GetParent(hdlg), IDS_ERR_DATAFORMAT);
        }
    }

    /* Always sync buttons, because the data format may change axis modes */
    Mode_SyncCheckButtons(pddi, hdlg);

    return 1;
}


/*****************************************************************************
 *
 *      Mode_OnInitDialog
 *
 *      Set up all the random switches.
 *
 *      Notice that GetCapabilities is in the same location in all the
 *      DirectInputXxx interfaces.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

/*
 *  Acceleration info: Accelerate in steps of 32, then 128.
 */

UDACCEL c_uda[] = {
    {   0,  32  },
    {   1, 128  },
};

#pragma END_CONST_DATA

BOOL INTERNAL
Mode_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PDEVDLGINFO pddi = (PV)(((LPPROPSHEETPAGE)lp)->lParam);

    SetDialogPtr(hdlg, pddi);

    CheckRadioButton(hdlg, IDC_DEV_ABS,    IDC_DEV_REL,     IDC_DEV_ABS);

    /*
     *  Note that we do not check any device format.
     *  This lets us make sure that things work when nothing is selected.
     */

    Mode_SyncCheckButtons(pddi, hdlg);

    /*
     *  Configure the buffer size edit and its updown control.
     */
    SetDlgItemInt(hdlg, IDC_DEV_BUFSIZE, 0, 0);
    SendDlgItemMessage(hdlg, IDC_DEV_BUFSIZEUD, UDM_SETACCEL,
                       cA(c_uda), (LPARAM)&c_uda);
    SendDlgItemMessage(hdlg, IDC_DEV_BUFSIZEUD, UDM_SETRANGE,
                       0, MAKELONG(1025, 0));       /* 1025 is illegal */

	Mode_OnDataFormat( pddi, hdlg, 0 );

    return 1;
}

/*****************************************************************************
 *
 *      Mode_OnCooperativity
 *
 *****************************************************************************/

BOOL INTERNAL
Mode_OnCooperativity(PDEVDLGINFO pddi, HWND hdlg, int id)
{
    HRESULT hres;
    DWORD discl = 0;

    switch (id) {
    case IDC_DEV_ACTIVE_BACKGROUND:
        discl = DISCL_BACKGROUND | DISCL_EXCLUSIVE; break;
    case IDC_DEV_ACTIVE:
        discl = DISCL_FOREGROUND | DISCL_EXCLUSIVE; break;
    case IDC_DEV_PASSIVE_FOREGROUND:
        discl = DISCL_FOREGROUND | DISCL_NONEXCLUSIVE; break;
    case IDC_DEV_PASSIVE:
        discl = DISCL_BACKGROUND | DISCL_NONEXCLUSIVE; break;
    case IDC_DEV_NOWINKEY:
        if( IsDlgButtonChecked(hdlg, IDC_DEV_NOWINKEY) ) {
            discl = pddi->disclLastTry | DISCL_NOWINKEY;
        } else {
            discl = pddi->disclLastTry & ~DISCL_NOWINKEY;
        }    	
    }

    if( id != IDC_DEV_NOWINKEY ) {
        if( IsDlgButtonChecked(hdlg, IDC_DEV_NOWINKEY) ) {
            discl = discl | DISCL_NOWINKEY;
        } else {
            discl = discl & ~DISCL_NOWINKEY;
        }
    }

    if (discl != pddi->disclLastTry  && discl != pddi->discl) {
        pddi->disclLastTry = discl;
        hres = IDirectInputDevice_SetCooperativeLevel(pddi->pdid,
                                                    GetParent(hdlg), discl);
        if (SUCCEEDED(hres)) {
            pddi->discl = discl;
        } else {
            CheckDlgButton( hdlg, IDC_DEV_NOWINKEY, BST_UNCHECKED );
            Mode_SyncCheckButtons(pddi, hdlg);
            MessageBoxV(GetParent(hdlg), IDS_ERR_COOPERATIVITY);
        }
    }

    return 1;
}

/*****************************************************************************
 *
 *      Mode_OnDataMode
 *
 *****************************************************************************/

BOOL INTERNAL
Mode_OnDataMode(PDEVDLGINFO pddi, HWND hdlg, int id)
{
    pddi->fPoll = (id == IDC_DEV_POLLED);
    return 1;
}

/*****************************************************************************
 *
 *      Mode_OnAxisMode
 *
 *****************************************************************************/

BOOL INTERNAL
Mode_OnAxisMode(PDEVDLGINFO pddi, HWND hdlg, int id)
{
    if (pddi && pddi->pdid) {
        DWORD dwMode;
        HRESULT hres;
        if (id == IDC_DEV_ABS) {
            dwMode = DIPROPAXISMODE_ABS;
        } else {
            dwMode = DIPROPAXISMODE_REL;
        }
        hres = SetDwordProperty(pddi->pdid, DIPROP_AXISMODE, dwMode);
        if (SUCCEEDED(hres)) {
        } else {
            MessageBoxV(GetParent(hdlg), IDS_ERR_AXISMODE);
        }

    }
    return 1;
}

/*****************************************************************************
 *
 *      Mode_OnCalMode
 *
 *****************************************************************************/

BOOL INTERNAL
Mode_OnCalMode(PDEVDLGINFO pddi, HWND hdlg)
{
    if (pddi && pddi->pdid) {
        DWORD dwMode;
        HRESULT hres;

        dwMode = IsDlgButtonChecked(hdlg, IDC_DEV_CAL);
        hres = SetDwordProperty(pddi->pdid, DIPROP_CALIBRATIONMODE, dwMode);
        if (SUCCEEDED(hres)) {
        } else {
            MessageBoxV(GetParent(hdlg), IDS_ERR_CALMODE);
        }

    }
    return 1;
}

/*****************************************************************************
 *
 *      Mode_SyncBufferSize
 *
 *****************************************************************************/

BOOL INTERNAL
Mode_SyncBufferSize(PDEVDLGINFO pddi, HWND hdlg)
{
    if (pddi && pddi->pdid) {
        UINT ui = GetDlgItemInt(hdlg, IDC_DEV_BUFSIZE, 0, 0);
        HRESULT hres;

        hres = SetDwordProperty(pddi->pdid, DIPROP_BUFFERSIZE, ui);
        if (SUCCEEDED(hres)) {
        } else {
            MessageBoxV(GetParent(hdlg), IDS_ERR_BUFFERSIZE);
        }
    }

    return 1;
}


/*****************************************************************************
 *
 *      Mode_OnCommand
 *
 *****************************************************************************/

BOOL INTERNAL
Mode_OnCommand(HWND hdlg, int id, UINT cmd)
{
    PDEVDLGINFO pddi = GetDialogPtr(hdlg);

    if (cmd == BN_CLICKED) {

        switch (id) {

        case IDC_DEV_PASSIVE:
        case IDC_DEV_PASSIVE_FOREGROUND:
        case IDC_DEV_ACTIVE_BACKGROUND:
        case IDC_DEV_ACTIVE:
        case IDC_DEV_NOWINKEY:
            return Mode_OnCooperativity(pddi, hdlg, id);

        case IDC_DEV_POLLED:
        case IDC_DEV_EVENT:   return Mode_OnDataMode(pddi, hdlg, id);

        case IDC_DEV_ABS:
        case IDC_DEV_REL:     return Mode_OnAxisMode(pddi, hdlg, id);

        case IDC_DEV_CAL:     return Mode_OnCalMode(pddi, hdlg);

        case IDC_DEV_MOUSE:
        case IDC_DEV_KEYBOARD:
        case IDC_DEV_JOYSTICK:
        case IDC_DEV_DEVICE:  return Mode_OnDataFormat(pddi, hdlg, id);

        }
    } else if (cmd == EN_UPDATE) {
        if (id == IDC_DEV_BUFSIZE) {
            return Mode_SyncBufferSize(pddi, hdlg);
        }
    }
    return 0;
}

/*****************************************************************************
 *
 *      Mode_DlgProc
 *
 *****************************************************************************/

INT_PTR CALLBACK
Mode_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG: return Mode_OnInitDialog(hdlg, lp);

    case WM_COMMAND:
        return Mode_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqtype.c ===
/*****************************************************************************
 *
 *      diqtype.c
 *
 *      The dialog box that tinkers with joystick type info.
 *
 *****************************************************************************/

#include "diquick.h"
#include "dinputd.h"

//#ifdef DEBUG

/*****************************************************************************
 *
 *      Mapping from JOYREGHWSETTINGS flags to strings.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

CHECKLISTFLAG c_rgclkHws[] = {
    { JOY_HWS_HASZ,                 IDS_HWS_HASZ,               },
    { JOY_HWS_HASPOV,               IDS_HWS_HASPOV,             },
    { JOY_HWS_POVISBUTTONCOMBOS,    IDS_HWS_POVISBUTTONCOMBOS,  },
    { JOY_HWS_POVISPOLL,            IDS_HWS_POVISPOLL,          },
    { JOY_HWS_ISYOKE,               IDS_HWS_ISYOKE,             },
    { JOY_HWS_ISGAMEPAD,            IDS_HWS_ISGAMEPAD,          },
    { JOY_HWS_ISCARCTRL,            IDS_HWS_ISCARCTRL,          },
    { JOY_HWS_XISJ1Y,               IDS_HWS_XISJ1Y,             },
    { JOY_HWS_XISJ2X,               IDS_HWS_XISJ2X,             },
    { JOY_HWS_XISJ2Y,               IDS_HWS_XISJ2Y,             },
    { JOY_HWS_YISJ1X,               IDS_HWS_YISJ1X,             },
    { JOY_HWS_YISJ2X,               IDS_HWS_YISJ2X,             },
    { JOY_HWS_YISJ2Y,               IDS_HWS_YISJ2Y,             },
    { JOY_HWS_ZISJ1X,               IDS_HWS_ZISJ1X,             },
    { JOY_HWS_ZISJ1Y,               IDS_HWS_ZISJ1Y,             },
    { JOY_HWS_ZISJ2X,               IDS_HWS_ZISJ2X,             },
    { JOY_HWS_POVISJ1X,             IDS_HWS_POVISJ1X,           },
    { JOY_HWS_POVISJ1Y,             IDS_HWS_POVISJ1Y,           },
    { JOY_HWS_POVISJ2X,             IDS_HWS_POVISJ2X,           },
    { JOY_HWS_HASR,                 IDS_HWS_HASR,               },
    { JOY_HWS_RISJ1X,               IDS_HWS_RISJ1X,             },
    { JOY_HWS_RISJ1Y,               IDS_HWS_RISJ1Y,             },
    { JOY_HWS_RISJ2Y,               IDS_HWS_RISJ2Y,             },
    { JOY_HWS_HASU,                 IDS_HWS_HASU,               },
    { JOY_HWS_HASV,                 IDS_HWS_HASV,               },
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *      Joystick type dialog instance data
 *
 *      Instance data for control panel joystick type dialog box.
 *
 *****************************************************************************/

typedef struct TYPEDLGINFO {

    IDirectInputJoyConfig *pdjc;/* The thing we created */
    LPCWSTR pwszType;

} TYPEDLGINFO, *PTYPEDLGINFO;

/*****************************************************************************
 *
 *      Type_OnInitDialog
 *
 *****************************************************************************/

BOOL INTERNAL
Type_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PTYPEDLGINFO ptdi = (PV)lp;
    DIJOYTYPEINFO jti;
    HRESULT hres;

    SetDialogPtr(hdlg, ptdi);

    jti.dwSize = cbX(jti);
    hres = ptdi->pdjc->lpVtbl->GetTypeInfo(ptdi->pdjc, ptdi->pwszType, &jti,
                                           DITC_REGHWSETTINGS |
                                           DITC_DISPLAYNAME);
    if (SUCCEEDED(hres)) {

        TCHAR tsz[MAX_JOYSTRING];

        Checklist_InitFlags(hdlg, IDC_TYPE_CHECKLIST, jti.hws.dwFlags,
                            c_rgclkHws, cA(c_rgclkHws));

        SetDlgItemInt(hdlg, IDC_TYPE_NUMBUTTONS, jti.hws.dwNumButtons, 0);

        ConvertString(TRUE, jti.wszDisplayName, tsz, cA(tsz));
        SetWindowText(hdlg, tsz);
    }

#if 0
    {
    HKEY hk;

    _asm int 3
    hres = ptdi->pdjc->lpVtbl->OpenTypeKey(ptdi->pdjc, ptdi->pwszType,
                                           KEY_QUERY_VALUE, &hk);
    if (SUCCEEDED(hres)) RegCloseKey(hk);

    }
#endif
    return 1;
}

/*****************************************************************************
 *
 *      Type_DlgProc
 *
 *****************************************************************************/

INT_PTR INTERNAL
Type_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG:
        return Type_OnInitDialog(hdlg, lp);

    case WM_DESTROY:
        Checklist_OnDestroy(GetDlgItem(hdlg, IDC_TYPE_CHECKLIST));
        break;

    case WM_CLOSE:
        EndDialog(hdlg, TRUE);
        return TRUE;
    }

    return 0;
}

/*****************************************************************************
 *
 *      Type_Create
 *
 *      Display info about a type.
 *
 *****************************************************************************/

INT_PTR EXTERNAL
Type_Create(HWND hdlg, struct IDirectInputJoyConfig *pdjc, LPCWSTR pwszType)
{
    TYPEDLGINFO tdi;

    tdi.pdjc = pdjc;
    tdi.pwszType = pwszType;

    return DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_JOYTYPE),
                          hdlg, Type_DlgProc, (LPARAM)&tdi);
}

//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqprop.c ===
/*****************************************************************************
 *
 *      diqprop.c
 *
 *      Property sheet page for device object properties.
 *
 *****************************************************************************/

#include "diquick.h"

#pragma BEGIN_CONST_DATA

CHECKLISTFLAG c_rgcfDidoi[] = {
    {   DIDOI_FFACTUATOR,       IDS_PROP_FFACTUATOR,        },
    {   DIDOI_FFEFFECTTRIGGER,  IDS_PROP_FFEFFECTTRIGGER,   },
    {   DIDOI_POLLED,           IDS_PROP_POLLED,            },
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *      Prop_SetPropCallback
 *
 *****************************************************************************/

HRESULT CALLBACK
Prop_SetPropCallback(LPDIPROPHEADER pdiph, PV pvRef1, PV pvRef2)
{
    PDEVDLGINFO pddi = pvRef1;
    const GUID *prop = (const GUID *)pvRef2;
    HRESULT hres;

    hres = IDirectInputDevice_SetProperty(pddi->pdid, prop, pdiph);

    return hres;
}

/*****************************************************************************
 *
 *      Prop_OnInitDialog
 *
 *      Fill with the properties of the item.
 *
 *****************************************************************************/

BOOL INTERNAL
Prop_OnInitDialog(HWND hdlg, LPARAM lp)
{
    HWND hdlgParent = (HWND)lp;
    HWND hwndList = GetDlgItem(hdlgParent, IDC_ENUMOBJ_LIST);
    PDEVDLGINFO pddi = GetDialogPtr(hdlgParent);
    DWORD dwObj;
    DIDEVICEOBJECTINSTANCE doi;
    HRESULT hres;
    int iItem;
    union {
        DIPROPDWORD dipdw;
        DIPROPRANGE diprg;
        DIPROPCAL dipcal;
        DIPROPSTRING dipwsz;
    } u;

    iItem = ListBox_GetCurSel(hwndList);
    dwObj = (DWORD)ListBox_GetItemData(hwndList, iItem);
    SetWindowLongPtr(hdlg, GWLP_USERDATA, dwObj);

    /*
     *  Don't SetDialogPtr until we're finished.  This prevents
     *  WM_COMMAND from causing us to do wacky things before
     *  we're ready.
     */

    hwndList = GetDlgItem(hdlg, IDC_PROP_LIST);

    Vlist_OnInitDialog(hwndList);

    hres = GetObjectInfo(pddi, &doi, dwObj, DIPH_BYID);

    if (SUCCEEDED(hres)) {
        REFCLSID rclsid = &doi.guidType;

        SetWindowText(hdlg, doi.tszName);

        Vlist_AddValue(hwndList, IDS_PROP_TYPE,
                       MapGUID(rclsid, doi.tszName));

        Vlist_AddIntValue(hwndList, IDS_PROP_OFS, doi.dwOfs);

        Vlist_AddHexValue(hwndList, IDS_PROP_OBJTYPE, doi.dwType);

        Vlist_AddFlags(hwndList, doi.dwFlags, c_rgcfDidoi, cA(c_rgcfDidoi));

        LoadString(g_hinst,
                   IDS_PROP_ASPECTS + ((doi.dwFlags & DIDOI_ASPECTMASK) >> 8),
                   doi.tszName, cA(doi.tszName));
        if (doi.tszName[0]) {
            Vlist_AddValue(hwndList, IDS_PROP_ASPECT, doi.tszName);
        } else {
            Vlist_AddHexValue(hwndList, IDS_PROP_ASPECT,
                              doi.dwFlags & DIDOI_ASPECTMASK);
        }

        if (doi.dwSize > sizeof(DIDEVICEOBJECTINSTANCE_DX3)) {
            Vlist_AddIntValue(hwndList, IDS_PROP_FFMAXFORCE, doi.dwFFMaxForce);
            Vlist_AddIntValue(hwndList, IDS_PROP_FFFORCERESOLUTION,
                                                      doi.dwFFForceResolution);
            Vlist_AddIntValue(hwndList, IDS_PROP_COLLECTIONNUMBER,
                                                      doi.wCollectionNumber);
            Vlist_AddIntValue(hwndList, IDS_PROP_DESIGNATORINDEX,
                                                      doi.wDesignatorIndex);
            Vlist_AddIntValue(hwndList, IDS_PROP_USAGEPAGE,
                                                      doi.wUsagePage);
            Vlist_AddIntValue(hwndList, IDS_PROP_USAGE,
                                                      doi.wUsage);
            Vlist_AddIntValue(hwndList, IDS_PROP_REPORTID, 
                                                      doi.wReportId);
        }
    }
    
    u.dipdw.diph.dwSize = cbX(u.dipdw);
    u.dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    u.dipdw.diph.dwObj = dwObj;
    u.dipdw.diph.dwHow = DIPH_BYID;

    hres = IDirectInputDevice_GetProperty(pddi->pdid, DIPROP_GRANULARITY,
                                          &u.dipdw.diph);

    if (SUCCEEDED(hres)) {
        Vlist_AddIntValue(hwndList, IDS_PROP_GRANULARITY, u.dipdw.dwData);
    }

    hres = IDirectInputDevice_GetProperty(pddi->pdid, DIPROP_DEADZONE,
                                          &u.dipdw.diph);

    if (SUCCEEDED(hres)) {
        Vlist_AddNumValueRW(hwndList, IDS_PROP_DEADZONE, &u.dipdw,
                            0, 10001, 10,
                            Prop_SetPropCallback, pddi, (PV)DIPROP_DEADZONE);
    }

    hres = IDirectInputDevice_GetProperty(pddi->pdid, DIPROP_SATURATION,
                                          &u.dipdw.diph);

    if (SUCCEEDED(hres)) {
        Vlist_AddNumValueRW(hwndList, IDS_PROP_SATURATION, &u.dipdw,
                            0, 10001, 10,
                            Prop_SetPropCallback, pddi, (PV)DIPROP_SATURATION);
    }

    hres = IDirectInputDevice_GetProperty(pddi->pdid, DIPROP_CALIBRATIONMODE,
                                          &u.dipdw.diph);
    if (SUCCEEDED(hres)) {
        Vlist_AddBoolValueRW(hwndList, IDS_PROP_CALIBRATIONMODE, &u.dipdw,
                             Prop_SetPropCallback, pddi,
                             (PV)DIPROP_CALIBRATIONMODE);
    }
    
    u.diprg.diph.dwSize  = cbX(u.diprg);

    hres = IDirectInputDevice_GetProperty(pddi->pdid, DIPROP_RANGE,
                                          &u.dipcal.diph);

    if (SUCCEEDED(hres)) {
        Vlist_AddRangeValueRW(hwndList, IDS_PROP_RANGE,
                              &u.diprg, 10,
                              Prop_SetPropCallback, pddi, (PV)DIPROP_RANGE);
    }

    u.dipcal.diph.dwSize = cbX(u.dipcal);

    hres = IDirectInputDevice_GetProperty(pddi->pdid, DIPROP_CALIBRATION,
                                          &u.dipcal.diph);

    if (SUCCEEDED(hres)) {
        Vlist_AddCalValueRW(hwndList, IDS_PROP_CAL,
                            &u.dipcal, 10,
                            Prop_SetPropCallback, pddi, (PV)DIPROP_CALIBRATION);
    }


    ListBox_SetCurSel(hwndList, 0);
    Vlist_OnSelChange(hwndList);

    SetDialogPtr(hdlg, pddi);

    return 1;
}

/*****************************************************************************
 *
 *      Prop_SyncVlist
 *
 *      Synchronize the value half of the list/value.
 *
 *****************************************************************************/

BOOL INLINE
Prop_SyncVlist(HWND hdlg)
{
    Vlist_OnSelChange(GetDlgItem(hdlg, IDC_PROP_LIST));
    return TRUE;
}

/*****************************************************************************
 *
 *      Prop_OnCommand
 *
 *****************************************************************************/

BOOL INTERNAL
Prop_OnCommand(HWND hdlg, int id, UINT cmd)
{
    switch (id) {

    case IDC_PROP_LIST:
        if (cmd == LBN_SELCHANGE) {
            return Prop_SyncVlist(hdlg);
        }
        break;
    }

    return 0;
}

/*****************************************************************************
 *
 *      Prop_OnDestroy
 *
 *      Clean up
 *
 *****************************************************************************/

void INLINE
Prop_OnDestroy(HWND hdlg)
{
    Vlist_OnDestroy(GetDlgItem(hdlg, IDC_PROP_LIST));
}

/*****************************************************************************
 *
 *      Prop_DlgProc
 *
 *****************************************************************************/

INT_PTR CALLBACK
Prop_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG: return Prop_OnInitDialog(hdlg, lp);

    case WM_COMMAND:
        return Prop_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));

    case WM_CLOSE: EndDialog(hdlg, 0); break;

    case WM_DESTROY:
        Prop_OnDestroy(hdlg);
        break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diquick.h ===
#define STRICT
#include <windows.h>
#include <commctrl.h>

#ifdef DBG
#define DEBUG
#endif

#define IDT_DATA        1           /* Timer for data acquisition */
#define msData          100         /* Time interval for polled acquisition */

#define IDD_MAIN        1

    #define IDC_MAIN_GETSTAT    16
    #define IDC_MAIN_CREATE     17
    #define IDC_MAIN_CPL        18
    #define IDC_MAIN_REFRESH    19
    #define IDC_MAIN_FIND       20

    #define IDC_MAIN_OLE        32
    #define IDC_MAIN_DI         33

    #define IDC_MAIN_DIA        34
    #define IDC_MAIN_DIW        35

    #define IDC_MAIN_DEVICES    36

    /*
     *  The precise numerical values are important.
     *
     *  Bottom bit must be set on unicode interfaces.
     *  Dev_DoDevice assumes that the first two interfaces
     *  are IDirectInputDeviceA and IDirectInputDeviceW, respectively.
     *
     *  c_rgriid must parallel this table.
     */

    #define DIDC_MAIN_DIDA      0
    #define DIDC_MAIN_DIDW      1
    #define DIDC_MAIN_DID2A     2
    #define DIDC_MAIN_DID2W     3
    #define DIDC_MAIN_DIDJC     4
    #define DIDC_MAIN_ITFMAC    4
    #define DIDC_MAIN_ITFMAX    5

/*
 *  Warning!  IsUnicodeDidc must return exactly 0 or 1
 *  because CreateDI relies on it.
 */
#define IsUnicodeDidc(didc)     ((didc) & 1)
#define IsFFDidc(didc)          ((didc) == 2 || (didc) == 3)


    #define IDC_MAIN_ITF        48
    #define IDC_MAIN_DIDA       (IDC_MAIN_ITF + DIDC_MAIN_DIDA)
    #define IDC_MAIN_DIDW       (IDC_MAIN_ITF + DIDC_MAIN_DIDW)
    #define IDC_MAIN_DID2A      (IDC_MAIN_ITF + DIDC_MAIN_DID2A)
    #define IDC_MAIN_DID2W      (IDC_MAIN_ITF + DIDC_MAIN_DID2W)
    #define IDC_MAIN_DIDJC      (IDC_MAIN_ITF + DIDC_MAIN_DIDJC)
    #define IDC_MAIN_ITFMAC     (IDC_MAIN_ITF + DIDC_MAIN_ITFMAC)
    #define IDC_MAIN_ITFMAX     (IDC_MAIN_ITF + DIDC_MAIN_ITFMAX)

#define IDD_DEV         2

    #define IDC_DEV_PASSIVE     16
    #define IDC_DEV_PASSIVE_FOREGROUND 17
    #define IDC_DEV_ACTIVE_BACKGROUND 18
    #define IDC_DEV_ACTIVE      19
    #define IDC_DEV_NOWINKEY        31

    #define IDC_DEV_MOUSE       20
    #define IDC_DEV_KEYBOARD    21
    #define IDC_DEV_JOYSTICK    22
    #define IDC_DEV_DEVICE      23

    #define IDC_DEV_POLLED      24
    #define IDC_DEV_EVENT       25

    #define IDC_DEV_ABS         26
    #define IDC_DEV_REL         27
    #define IDC_DEV_CAL         28

    #define IDC_DEV_BUFSIZE     29
    #define IDC_DEV_BUFSIZEUD   30

#define IDD_CAPS        3

    #define IDC_CAPS_LIST       16
    #define IDC_CAPS_VALUE      17
    #define IDC_CAPS_REFRESH    31
    #define IDC_CAPS_CPL        32

#define IDD_ENUMOBJ     4

    #define IDC_ENUMOBJ_AXES    16
    #define IDC_ENUMOBJ_BUTTONS 17
    #define IDC_ENUMOBJ_POVS    18
    #define IDC_ENUMOBJ_ALL     19
    #define IDC_ENUMOBJ_LIST    20
    #define IDC_ENUMOBJ_PROP    21

#define IDD_ENUMEFF     5

    #define IDC_ENUMEFF_LIST    16

#define IDD_ACQ         6

    #define IDC_ACQ_STATE       16
    #define IDC_ACQ_DATA        17
    #define IDC_ACQ_UNACQ       18

#define IDD_OBJPROP     16

    #define IDC_PROP_LIST           16
    #define IDC_PROP_VALUE          17
    #define IDC_PROP_CAL_L          30
    #define IDC_PROP_CAL_C          31
    #define IDC_PROP_CAL_H          32

#define IDD_CPL         17

    #define IDC_CPL_CLASSES         16
    #define IDC_CPL_ADD             17
    #define IDC_CPL_TYPES           18
    #define IDC_CPL_CONFIGS         19
    #define IDC_CPL_USERVALUES      20
    #define IDC_CPL_ADDJOYSTICK     21
    #define IDC_CPL_DELJOYSTICK     22

#define IDD_JOYTYPE     18

    #define IDC_TYPE_CHECKLIST      16
    #define IDC_TYPE_NUMBUTTONS     17

#define IDD_JOYUV       19

    #define IDC_JOYUV_AXIS          16
    #define IDC_JOYUV_MIN           17
    #define IDC_JOYUV_CENTER        18
    #define IDC_JOYUV_MAX           19
    #define IDC_JOYUV_DEADZONE      20
    #define IDC_JOYUV_CALLOUT       21
    #define IDC_JOYUV_EMULATOR      22

#define IDD_FIND        20

    #define IDC_FIND_NAME           16
    #define IDC_FIND_GUID           17
    #define IDC_FIND_FIND           18

#define IDD_ENUMDEV     21

    /*
     *  These must be in the same order as DIDEVTYPE_*.
     */
    #define IDC_ENUMDEV_ALL         16
    #define IDC_ENUMDEV_GEN         17
    #define IDC_ENUMDEV_MSE         18
    #define IDC_ENUMDEV_KBD         19
    #define IDC_ENUMDEV_JOY         20
    #define IDC_ENUMDEV_LAST        20

    #define IDC_ENUMDEV_ATT         32
    #define IDC_ENUMDEV_FF          33
    #define IDC_ENUMDEV_HID         34
    #define IDC_ENUMDEV_ALIAS       35
    #define IDC_ENUMDEV_PHANTOM     36

#define IDD_EFFPROP     32

    #define IDC_EPROP_GUID          16
    #define IDC_EPROP_TYPE          17
    #define IDC_EPROP_FLAGS         18
    #define IDC_EPROP_STATICPARM    19
    #define IDC_EPROP_DYNAMICPARM   20

#define IDD_VAL_BOOL    64

    #define IDC_VBOOL_YES           16
    #define IDC_VBOOL_NO            17
    #define IDC_VBOOL_APPLY         18

#define IDD_VAL_EDIT    65

    #define IDC_VEDIT_EDIT          16
    #define IDC_VEDIT_APPLY         17

#define IDD_VAL_INT     66

    #define IDC_VINT_EDIT           16
    #define IDC_VINT_UD             17
    #define IDC_VINT_DEC            18
    #define IDC_VINT_HEX            19
    #define IDC_VINT_APPLY          20

#define IDD_VAL_RANGE   67

    #define IDC_VRANGE_MIN          16
    #define IDC_VRANGE_MINUD        17
    #define IDC_VRANGE_MAX          18
    #define IDC_VRANGE_MAXUD        19
    #define IDC_VRANGE_DEC          20
    #define IDC_VRANGE_HEX          21
    #define IDC_VRANGE_APPLY        22

#define IDD_VAL_CAL     68

    #define IDC_VCAL_MIN            16
    #define IDC_VCAL_MINUD          17
    #define IDC_VCAL_CTR            18
    #define IDC_VCAL_CTRUD          19
    #define IDC_VCAL_MAX            20
    #define IDC_VCAL_MAXUD          21
    #define IDC_VCAL_DEC            22
    #define IDC_VCAL_HEX            23
    #define IDC_VCAL_APPLY          24

#define IDS_ERR_CREATEOBJ       16
#define IDS_ERR_COOPERATIVITY   17
#define IDS_ERR_CREATEDEV       18
#define IDS_ERR_SETEVENTNOT     19
#define IDS_ERR_DATAFORMAT      20
#define IDS_ERR_ACQUIRE         21
#define IDS_ERR_BUFFERSIZE      22
#define IDS_ERR_RUNCPL          23
#define IDS_ERR_GETOBJINFO      24
#define IDS_ERR_AXISMODE        25
#define IDS_ERR_HRESULT         27
#define IDS_ERR_COINIT          29
#define IDS_ERR_QICONFIG        30
#define IDS_ERR_ADDNEWHARDWARE  31
#define IDS_ERR_CALMODE         32

#define IDS_SPACEPARENHID       124
#define IDS_INVALID             125
#define IDS_CAPS_YES            126
#define IDS_CAPS_NO             127

#define IDS_TYPEARRAY           0x0100 /* 0x0100 .. 0x01FF */
/*efine IDS_DEVICE_TYPEARRAY    ...                        */
#define IDS_MOUSE_TYPEARRAY     0x0300 /* 0x0300 .. 0x03FF */
#define IDS_KEYBOARD_TYPEARRAY  0x0400 /* 0x0400 .. 0x04FF */
#define IDS_JOYSTICK_TYPEARRAY  0x0500 /* 0x0500 .. 0x05FF */

#define IDS_ATTACHED            0x0600
#define IDS_POLLEDDEVICE        0x0601
#define IDS_EMULATED            0x0602
#define IDS_FORCEFEEDBACK       0x0603
#define IDS_FFATTACK            0x0604
#define IDS_FFFADE              0x0605
#define IDS_SATURATION          0x0606
#define IDS_POSNEGCOEFFICIENTS  0x0607
#define IDS_POSNEGSATURATION    0x0608
#define IDS_POLLEDDATAFORMAT    0x0609
#define IDS_ALIASDEVICE         0x060A
#define IDS_PHANTOMDEVICE       0x060B

#define IDS_CLASS_KBD           0x0700
#define IDS_CLASS_MEDIA         0x0701
#define IDS_CLASS_MOUSE         0x0702
#define IDS_CLASS_HID           0x0703

#define IDS_HWS_HASZ                0x0800
#define IDS_HWS_HASPOV              0x0801
#define IDS_HWS_POVISBUTTONCOMBOS   0x0802
#define IDS_HWS_POVISPOLL           0x0803
#define IDS_HWS_ISYOKE              0x0804
#define IDS_HWS_ISGAMEPAD           0x0805
#define IDS_HWS_ISCARCTRL           0x0806
#define IDS_HWS_XISJ1Y              0x0807
#define IDS_HWS_XISJ2X              0x0808
#define IDS_HWS_XISJ2Y              0x0809
#define IDS_HWS_YISJ1X              0x080A
#define IDS_HWS_YISJ2X              0x080B
#define IDS_HWS_YISJ2Y              0x080C
#define IDS_HWS_ZISJ1X              0x080D
#define IDS_HWS_ZISJ1Y              0x080E
#define IDS_HWS_ZISJ2X              0x080F
#define IDS_HWS_POVISJ1X            0x0810
#define IDS_HWS_POVISJ1Y            0x0811
#define IDS_HWS_POVISJ2X            0x0812
#define IDS_HWS_HASR                0x0813
#define IDS_HWS_RISJ1X              0x0814
#define IDS_HWS_RISJ1Y              0x0815
#define IDS_HWS_RISJ2Y              0x0816
#define IDS_HWS_HASU                0x0817
#define IDS_HWS_HASV                0x0818

#define IDS_EFFECT_TYPEARRAY        0x0900 /* 0x0900 .. 0x09FF */

#define IDS_PROP_TYPE               0x0A00
#define IDS_PROP_OFS                0x0A01
#define IDS_PROP_OBJTYPE            0x0A02
#define IDS_PROP_GRANULARITY        0x0A03
#define IDS_PROP_FFMAXFORCE         0x0A04
#define IDS_PROP_FFFORCERESOLUTION  0x0A05
#define IDS_PROP_COLLECTIONNUMBER   0x0A06
#define IDS_PROP_DESIGNATORINDEX    0x0A07
#define IDS_PROP_USAGEPAGE          0x0A08
#define IDS_PROP_USAGE              0x0A09
#define IDS_PROP_FFACTUATOR         0x0A0A
#define IDS_PROP_FFEFFECTTRIGGER    0x0A0B
#define IDS_PROP_ASPECT             0x0A0C
#define IDS_PROP_POLLED             0x0A0D
#define IDS_PROP_DEADZONE           0x0A0E
#define IDS_PROP_SATURATION         0x0A0F
#define IDS_PROP_RANGE              0x0A10
#define IDS_PROP_CALIBRATIONMODE    0x0A11
#define IDS_PROP_CAL                0x0A12
#define IDS_PROP_REPORTID           0x0A13
#define IDS_PROP_ENABLEREPORTID     0x0A14
#define IDS_PROP_SCANCODE           0x0A15
#define IDS_PROP_KEYNAME            0x0A16

#define IDS_PROP_ASPECTS            0x0AF0

#define IDS_AXIS_MIN                0x0B00
#define IDS_AXIS_X                  0x0B00
#define IDS_AXIS_Y                  0x0B01
#define IDS_AXIS_Z                  0x0B02
#define IDS_AXIS_R                  0x0B03
#define IDS_AXIS_U                  0x0B04
#define IDS_AXIS_V                  0x0B05
#define IDS_AXIS_MAX                0x0B06

#define IDS_CAPS_TYPE                   0x0C00
#define IDS_CAPS_SUBTYPE                0x0C01
#define IDS_CAPS_HID                    0x0C02
#define IDS_CAPS_AXES                   0x0C03
#define IDS_CAPS_BUTTONS                0x0C04
#define IDS_CAPS_POVS                   0x0C05
#define IDS_CAPS_FFSAMPLEPERIOD         0x0C06
#define IDS_CAPS_FFMINTIMERESOLUTION    0x0C07
#define IDS_CAPS_FIRMWAREREVISION       0x0C08
#define IDS_CAPS_HARDWAREREVISION       0x0C09
#define IDS_CAPS_FFDRIVERVERSION        0x0C0A
#define IDS_CAPS_GUIDINSTANCE           0x0C0E
#define IDS_CAPS_GUIDPRODUCT            0x0C0F
#define IDS_CAPS_DEVTYPE                0x0C10
#define IDS_CAPS_INSTANCENAME           0x0C11
#define IDS_CAPS_PRODUCTNAME            0x0C12
#define IDS_CAPS_GUIDFFDRIVER           0x0C13
#define IDS_CAPS_USAGEPAGE              0x0C14
#define IDS_CAPS_USAGE                  0x0C15
#define IDS_CAPS_CLASSGUID              0x0C16
#define IDS_CAPS_PATH                   0x0C17
#define IDS_CAPS_INSTPROP               0x0C18
#define IDS_CAPS_MFGPROP                0x0C19
#define IDS_CAPS_PORTNAME               0x0C1A
#define IDS_CAPS_PORTID                 0x0C1B
#define IDS_CAPS_JOYSTICKID             0x0C1C
#define IDS_CAPS_GUIDMAPPER             0x0C1D
#define IDS_CAPS_VID                    0x0C1E
#define IDS_CAPS_PID                    0x0C1F

#define IDS_GETSTAT_OK                  0x0D00
#define IDS_GETSTAT_NOTATTACHED         0x0D01
#define IDS_GETSTAT_ERROR               0x0D02

#define IDB_CHECK               1

#ifndef RC_INVOKED

#include <prsht.h>
#include <windowsx.h>
#include <ole2.h>

#define DIRECTINPUT_VERSION     0x700
#include <dinput.h>

/***************************************************************************
 *
 *                            Abbreviations....
 *
 *  Give shorter names to things we talk about frequently.
 *
 ***************************************************************************/

typedef LPUNKNOWN PUNK;
typedef LPVOID PV, *PPV;
typedef CONST VOID *PCV;
typedef REFIID RIID;
typedef const BYTE *PCBYTE;
typedef const GUID *PCGUID;

/*****************************************************************************
 *
 *                      Baggage
 *
 *      Stuff I carry everywhere.
 *
 *****************************************************************************/

#define INTERNAL NTAPI  /* Called only within a translation unit */
#define EXTERNAL NTAPI  /* Called from other translation units */
#define INLINE static __inline

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

/*
 *  Arithmetic on pointers.
 */
#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))

/*
 * Convert an object (X) to a count of bytes (cb).
 */
#define cbX(X) sizeof(X)

/*
 * Convert an array name (A) to a generic count (c).
 */
#define cA(a) (cbX(a)/cbX(a[0]))

/*
 * Zero an arbitrary object.
 */
#define ZeroX(x) ZeroMemory(&(x), cbX(x))

/*
 * land -- Logical and.  Evaluate the first.  If the first is zero,
 * then return zero.  Otherwise, return the second.
 */

#define fLandFF(f1, f2) ((f1) ? (f2) : 0)

/*
 * lor -- Logical or.  Evaluate the first.  If the first is nonzero,
 * return it.  Otherwise, return the second.
 *
 * Unfortunately, due to the *weirdness* of the C language, this can
 * be implemented only with a GNU extension.  In the non-GNU case,
 * we return 1 if the first is nonzero.
 */

#if defined(__GNUC__)
#define fLorFF(f1, f2) ((f1) ?: (f2))
#else
#define fLorFF(f1, f2) ((f1) ? 1 : (f2))
#endif

/*
 * limp - logical implication.  True unless the first is nonzero and
 * the second is zero.
 */
#define fLimpFF(f1, f2) (!(f1) || (f2))

/*
 * leqv - logical equivalence.  True if both are zero or both are nonzero.
 */
#define fLeqvFF(f1, f2) (!(f1) == !(f2))

/*
 * Words to keep preprocessor happy.
 */
#define comma ,
#define empty

/*
 *  Atomically exchange one value for another.
 */
#define pvExchangePpvPv(ppv, pv) \
        (PV)InterlockedExchange((PLONG)(ppv), (LONG)(pv))

/*
 *  Creating HRESULTs from a USHORT or from a LASTERROR.
 */
#define hresUs(us) MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(us))
#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))

/*
 *  Access the window long as a pointer.
 */
#define GetDialogPtr(hdlg)  (PVOID)GetWindowLongPtr(hdlg, DWLP_USER)
#define SetDialogPtr(hdlg, pv)  SetWindowLongPtr(hdlg, DWLP_USER, (LPARAM)(pv))

/*
 *  Does the fWide flag match the preferred character set?
 */
#ifdef UNICODE
#define fTchar(fWide)   fWide
#else
#define fTchar(fWide)   !(fWide)
#endif

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

extern HINSTANCE g_hinst;
extern HCURSOR g_hcurWait;
extern HCURSOR g_hcurStarting;
extern DWORD g_dwDIVer;

#ifdef DEBUG
extern TCHAR g_tszInvalid[128];
#endif
extern DWORD g_dwEnumType;
extern DWORD g_dwEnumFlags;

#define SetWaitCursor() SetCursor(g_hcurWait)

/*****************************************************************************
 *
 *      diqary.c - Dynamic arrays
 *
 *****************************************************************************/

typedef struct DARY {
    PV      rgx;
    int     cx;
    int     cxMax;
} DARY, *PDARY;

PV INLINE
Dary_GetPtrCbx(PDARY pdary, int ix, int cbX)
{
    return pvAddPvCb(pdary->rgx, ix * cbX);
}
#define Dary_GetPtr(pdary, ix, X)   Dary_GetPtrCbx(pdary, ix, cbX(X))

int EXTERNAL Dary_AppendCbx(PDARY pdary, PCV pvX, int cbX);
#define Dary_Append(pdary, pv)      Dary_AppendCbx(pdary, pv, cbX(*(pv)))

void INLINE
Dary_Term(PDARY pdary)
{
    if (pdary->rgx) {
        LocalFree(pdary->rgx);
    }
}

/*****************************************************************************
 *
 *      diqchk.c
 *
 *****************************************************************************/

INT_PTR EXTERNAL Checklist_Init(void);
void EXTERNAL Checklist_Term(void);
void EXTERNAL Checklist_OnInitDialog(HWND hwnd, BOOL fReadOnly);
int EXTERNAL Checklist_AddString(HWND hwnd, UINT ids, BOOL fCheck);
void EXTERNAL Checklist_InitFinish(HWND hwnd);
void EXTERNAL Checklist_OnDestroy(HWND hwnd);

typedef struct CHECKLISTFLAG {
    DWORD   flMask;
    UINT    ids;
} CHECKLISTFLAG, *PCHECKLISTFLAG;

void EXTERNAL Checklist_InitFlags(HWND hdlg, int idc,
                                  DWORD fl, PCHECKLISTFLAG rgclf, UINT cclf);

/*****************************************************************************
 *
 *      diqvlist.c
 *
 *****************************************************************************/

typedef HRESULT (CALLBACK *EDITUPDATEPROC)
            (LPCTSTR ptszValue, PV pvRef1, PV pvRef2);

typedef HRESULT (CALLBACK *PROPUPDATEPROC)
            (LPDIPROPHEADER pdiph, PV pvRef1, PV pvRef2);

#define CCHMAXINT       64

//#define Vlist_OnInitDialog(hwnd)
void EXTERNAL Vlist_OnInitDialog(HWND hwndList);
void EXTERNAL Vlist_AddHexValue(HWND hwnd, UINT ids, DWORD dwValue);
void EXTERNAL Vlist_AddIntValue(HWND hwnd, UINT ids, DWORD dwValue);
void EXTERNAL Vlist_AddBoolValue(HWND hwnd, UINT ids, DWORD dwValue);
void EXTERNAL Vlist_AddValue(HWND hwnd, UINT ids, LPCTSTR ptszValue);

void EXTERNAL Vlist_AddValueRW(HWND hwnd, UINT ids, LPCTSTR ptszValue,
                               EDITUPDATEPROC Update, PV pvRef1, PV pvRef2);

void EXTERNAL Vlist_AddNumValueRW(HWND hwnd, UINT ids,
                    LPDIPROPDWORD pdipdw, int iMin, int iMax, int iRadix,
                    PROPUPDATEPROC Update, PV pvRef1, PV pvRef2);

void EXTERNAL
Vlist_AddBoolValueRW(HWND hwnd, UINT ids, LPDIPROPDWORD pdipdw,
                     PROPUPDATEPROC Update, PV pvRef1, PV pvRef2);

void EXTERNAL
Vlist_AddRangeValueRW(HWND hwnd, UINT ids,
                      LPDIPROPRANGE pdiprg, int iRadix,
                      PROPUPDATEPROC Update, PV pvRef1, PV pvRef2);

void EXTERNAL
Vlist_AddCalValueRW(HWND hwnd, UINT ids,
                    LPDIPROPCAL pdical, int iRadix,
                    PROPUPDATEPROC Update, PV pvRef1, PV pvRef2);

void EXTERNAL
Vlist_AddFlags(HWND hwnd, DWORD fl, PCHECKLISTFLAG rgclf, UINT cclf);

void EXTERNAL Vlist_OnSelChange(HWND hwnd);
void EXTERNAL Vlist_OnDestroy(HWND hwnd);

/*****************************************************************************
 *
 *      VLISTITEM
 *
 *      This goes at the beginning of every vlist item goofy thing.
 *
 *****************************************************************************/

typedef struct VLISTITEM {

    const struct VLISTVTBL *pvtbl;

} VLISTITEM, *PVLISTITEM;

/*
 *  This is the actual VTBL.
 */
typedef struct VLISTVTBL {

    /*
     *  The dialog is about to be shown.  Set the control
     *  values accordingly.
     */
    STDMETHOD_(void, PreDisplay)(HWND, PV);

    /*
     *  Destroy cleans up whatever needs to be cleaned up.
     *  It does not free the PVLISTITEM itself; the caller
     *  will do that.
     */
    STDMETHOD_(void, Destroy)(PV);

    /*
     *  The dialog box to create.
     */
    UINT idd;
    DLGPROC dp;

} VLISTVTBL;

typedef const VLISTVTBL *PVLISTVTBL;


PVLISTITEM EXTERNAL
VBool_Create(LPDIPROPDWORD pdipdw, PROPUPDATEPROC Update, PV pvRef1, PV pvRef2);

PVLISTITEM EXTERNAL
VEdit_Create(LPCTSTR ptsz, EDITUPDATEPROC Update, PV pvRef1, PV pvRef2);

PVLISTITEM EXTERNAL
VInt_Create(LPDIPROPDWORD pdipdw, int iMin, int iMax, int iRadix,
            PROPUPDATEPROC Update, PV pvRef1, PV pvRef2);

PVLISTITEM EXTERNAL
VRange_Create(LPDIPROPRANGE pdiprg, int iRadix,
              PROPUPDATEPROC Update, PV pvRef1, PV pvRef2);

PVLISTITEM EXTERNAL
VCal_Create(LPDIPROPCAL pdical, int iRadix,
            PROPUPDATEPROC Update, PV pvRef1, PV pvRef2);

void EXTERNAL UpDown_SetRange(HWND hwndUD, int min, int max);
void EXTERNAL UpDown_SetPos(HWND hwndUD, int iRadix, int iValue);
BOOL EXTERNAL UpDown_GetPos(HWND hwndUD, LPINT pi);

/*****************************************************************************
 *
 *      diquick.c
 *
 *****************************************************************************/

UINT EXTERNAL GetCheckedRadioButton(HWND hdlg, UINT idFirst, UINT idLast);
int EXTERNAL SemimodalDialogBoxParam(UINT, HWND, DLGPROC, LPARAM);
int EXTERNAL SemimodalPropertySheet(HWND hwndOwner, LPPROPSHEETHEADER ppsh);

int __cdecl MessageBoxV(HWND hdlg, UINT ids, ...);
int EXTERNAL ThreadFailHres(HWND hdlg, UINT ids, HRESULT hres);
void EXTERNAL RecalcCursor(HWND hdlg);

STDMETHODIMP CreateDI(BOOL fOle, UINT flCreate, PV ppvOut);

/*
 *  CDIFL_UNICODE must be 1 because we steal the return values from
 *  IsDlgButtonChecked() and IsUnicodeDidc().
 *
 *  If you change the values of any of these flags, make sure also to
 *  update the table in CreateDI().
 */
#define CDIFL_UNICODE   0x0001
#define CDIFL_DI2       0x0002

STDMETHODIMP GetDwordProperty(IDirectInputDevice *pdid, PCGUID, LPDWORD pdw);
STDMETHODIMP SetDwordProperty(IDirectInputDevice *pdid, PCGUID, DWORD dw);

typedef struct DEVDLGINFO *PDEVDLGINFO;

void EXTERNAL ConvertString(BOOL, LPCVOID, LPTSTR, UINT);
void EXTERNAL UnconvertString(BOOL, LPCTSTR, LPVOID, UINT);

void EXTERNAL ConvertDoi(PDEVDLGINFO, LPDIDEVICEOBJECTINSTANCE, LPCVOID);
HRESULT EXTERNAL GetObjectInfo(PDEVDLGINFO, LPDIDEVICEOBJECTINSTANCE,
                               DWORD, DWORD);

void EXTERNAL ConvertDdi(PDEVDLGINFO, LPDIDEVICEINSTANCE, LPCVOID);
HRESULT EXTERNAL GetDeviceInfo(PDEVDLGINFO, LPDIDEVICEINSTANCE);

void EXTERNAL ConvertEffi(PDEVDLGINFO, LPDIEFFECTINFO, LPCVOID);
HRESULT EXTERNAL GetEffectInfo(PDEVDLGINFO, LPDIEFFECTINFO, REFGUID);

void EXTERNAL StringFromGuid(LPTSTR ptsz, REFGUID rclsid);

/*
 *  Note that GUID names do not need to be localized.
 */
typedef struct GUIDMAP {
    REFGUID rguid;
    LPCTSTR ptsz;
} GUIDMAP, *PGUIDMAP;

LPCTSTR EXTERNAL MapGUID(REFGUID rguid, LPTSTR ptszBuf);

/*****************************************************************************
 *
 *      diqmain.c
 *
 *****************************************************************************/

extern GUID GUID_Uninit;

INT_PTR CALLBACK Diq_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp);

/*
 *  A worker thread has finished its startup.
 */
#define WM_THREADSTARTED        WM_APP

/*
 *  A semi-modal dialog box has exited.
 */
#define WM_CHILDEXIT            (WM_APP+1)

/*
 *  You are idle.
 */
#define WM_SELFENTERIDLE        (WM_APP+2)

/*
 *  Property used to record read-only-ness of a checklist.
 */
#define propReadOnly            MAKEINTRESOURCE(WM_APP)

/*****************************************************************************
 *
 *      diqcpl.c
 *
 *****************************************************************************/

INT_PTR EXTERNAL Cpl_Create(HWND hdlg, BOOL fOle, UINT fl);

/*****************************************************************************
 *
 *      diqfind.c
 *
 *****************************************************************************/

INT_PTR EXTERNAL Find_Create(HWND hdlg, BOOL fOle, UINT flCreate);

/*****************************************************************************
 *
 *      diqedev.c
 *
 *****************************************************************************/

INT_PTR EXTERNAL DEnum_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp);

/*****************************************************************************
 *
 *      diqhack.c
 *
 *****************************************************************************/

INT_PTR INTERNAL Diq_HackPropertySheets(HWND hdlg);

/*****************************************************************************
 *
 *      diqdev.c
 *
 *****************************************************************************/

INT_PTR EXTERNAL Dev_Create(HWND hdlg, BOOL fOle, UINT flCreate,
                         PCGUID pguidInstance, LPCTSTR ptszDesc,
                         UINT didcItf);

/*****************************************************************************
 *
 *      diqacq.c
 *
 *      Acquisition vtbl
 *
 *****************************************************************************/

typedef struct ACQVTBL {
    STDMETHOD(UpdateStatus)(PDEVDLGINFO pddi, LPTSTR ptszBuf);
    STDMETHOD(SetDataFormat)(PDEVDLGINFO pddi);
    STDMETHOD_(void, Destroy)(PDEVDLGINFO pddi);
    LPCDIDATAFORMAT pdf;
} ACQVTBL, *PACQVTBL;

STDMETHODIMP Common_AcqSetDataFormat(PDEVDLGINFO pddi);
STDMETHODIMP_(void) Common_AcqDestroy(PDEVDLGINFO pddi);

extern ACQVTBL c_acqvtblDevMouse;
extern ACQVTBL c_acqvtblDevMouse2;
extern ACQVTBL c_acqvtblDevKbd;
extern ACQVTBL c_acqvtblDevJoy;
extern ACQVTBL c_acqvtblDev;

INT_PTR CALLBACK Mode_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp);
INT_PTR CALLBACK Caps_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp);
INT_PTR CALLBACK EObj_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp);
INT_PTR CALLBACK EEff_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp);
INT_PTR CALLBACK  Acq_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp);
INT_PTR CALLBACK Prop_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp);

#define EACH_PROPSHEET(f)               \
    f(IDD_DEV,       Mode_DlgProc),     \
    f(IDD_CAPS,      Caps_DlgProc),     \
    f(IDD_ENUMOBJ,   EObj_DlgProc),     \
    f(IDD_ENUMEFF,   EEff_DlgProc),     \
    f(IDD_ACQ,        Acq_DlgProc),     \

/*****************************************************************************
 *
 *      Device dialog instance data
 *
 *      Instance data for device dialog box.
 *
 *      The first batch of information describes how the object should be
 *      created.
 *
 *      The second batch of information keeps track of the object once
 *      we've got it.
 *
 *      A pointer to this structure is the lParam of the property sheet
 *      page.
 *
 *
 *****************************************************************************/

typedef struct DEVDLGINFO {
    HWND    hdlgOwner;          /* Owner window */
    BOOL    fOle;               /* Should we create via OLE? */
    UINT    flCreate;           /* Flags */
    PCGUID  pguidInstance;      /* Device instance to use */
    LPCTSTR ptszDesc;           /* Name of device */
    UINT    didcItf;            /* Interface to create on the device */
    PACQVTBL pvtbl;

    IDirectInputDevice *pdid;   /* The thing we created */
    IDirectInputDevice2 *pdid2; /* If DX5 */

    /* Updated by the Mode page */
    DWORD   discl;              /* Cooperative level */
    DWORD   disclLastTry;       /* Last cooperative level the user clicked on */

    BOOL    fPoll;              /* Use polling mode */
    BOOL    fAbs;               /* Abs or Rel mode? */

    /* Maintained by the Data page */
    HANDLE  hevt;               /* If in event-driven mode */
    BOOL    fAcquired;          /* Is the device acquired? */
    HWND    hwndState;          /* Handle of state control */
    HWND    hwndData;           /* Handle of data control */
    int     celtData;           /* Number of items in the data control */
    int     celtDataMax;        /* Max number of items in the data control */
    WNDPROC wpListbox;          /* Previous listbox window procedure */

    /* Maintained by the AcqVtbl */
    LPVOID  pvAcq;              /* For ACQVTBL use */

    /* Maintained by the Effect page */
    DARY    daryGuid;           /* Array of enumerated effect GUIDs */

} DEVDLGINFO;

/*****************************************************************************
 *
 *      diqtype.c - joystick type info
 *
 *****************************************************************************/

INT_PTR EXTERNAL
Type_Create(HWND hdlg, struct IDirectInputJoyConfig *pdjc, LPCWSTR pwszType);

/*****************************************************************************
 *
 *      diquv - joystick user values
 *
 *****************************************************************************/

INT_PTR EXTERNAL
Uv_Create(HWND hdlg, struct IDirectInputJoyConfig *pdjc);

/*****************************************************************************
 *
 *      diqeprop.c - efect properties
 *
 *****************************************************************************/

INT_PTR EXTERNAL
EffProp_Create(HWND hdlg, PDEVDLGINFO pddi, REFGUID rguidEff);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqvbool.c ===
/*****************************************************************************
 *
 *      diqvbool.c
 *
 *      VList plug-in that does BOOLs.
 *
 *****************************************************************************/

#include "diquick.h"

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *      VLISTBOOL
 *
 *      BOOL-specific goo.
 *
 *      When we PreDisplay a control, we stash the VLISTBOOL into the
 *      DWL_USER.  We can't use the GWLP_USERDATA, because the vlist
 *      manager uses that.
 *
 *****************************************************************************/

typedef struct VLISTBOOL {

    VLISTITEM item;

    DIPROPDWORD dipdw;

    /*
     *  If non-NULL, then this is a read/write control.
     */
    PROPUPDATEPROC Update;
    PV pvRef1;
    PV pvRef2;

} VLISTBOOL, *PVLISTBOOL;

/*****************************************************************************
 *
 *      VBool_PreDisplay
 *
 *      Check the Yes or No, accordingly.
 *
 *      Note that there is no such thing as a read-only radio button.
 *      We have to disable it.
 *
 *****************************************************************************/

void INTERNAL
VBool_PreDisplay(HWND hdlg, PV pv)
{
    PVLISTBOOL pvbool = pv;

    /*
     *  Need to do this early so our subclass procedure knows who
     *  we're talking about.
     */
    SetDialogPtr(hdlg, pvbool);

    CheckRadioButton(hdlg, IDC_VBOOL_YES, IDC_VBOOL_NO,
                           pvbool->dipdw.dwData ? IDC_VBOOL_YES
                                                : IDC_VBOOL_NO);

    ShowWindow(GetDlgItem(hdlg, IDC_VBOOL_APPLY),
                       pvbool->Update ? SW_SHOW : SW_HIDE);

}

/*****************************************************************************
 *
 *      VBool_Destroy
 *
 *      Nothing to clean up.
 *
 *****************************************************************************/

void INTERNAL
VBool_Destroy(PV pv)
{
    PVLISTBOOL pvbool = pv;
}

/*****************************************************************************
 *
 *      VBool_Button_SubclassProc
 *
 *      Procedure we install that subclasses our radio buttons.
 *
 *      If we are in R/O mode, then we return DLGC_STATIC so the
 *      dialog manager won't include us in the TAB order.
 *
 *****************************************************************************/

LRESULT CALLBACK
VBool_Button_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_GETDLGCODE:
        {
            PVLISTBOOL pvbool = GetDialogPtr(GetParent(hwnd));
            if (pvbool && !pvbool->Update) {
                return DLGC_STATIC;
            }
        }
        break;

    }

    return CallWindowProc((WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA),
                          hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *      VBool_OnInitDialog
 *
 *      Subclas our buttons so they act "dumb".
 *
 *****************************************************************************/

BOOL INTERNAL
VBool_OnInitDialog(HWND hdlg)
{
    WNDPROC wp;
    HWND hwnd;

    hwnd = GetDlgItem(hdlg, IDC_VBOOL_YES);
    wp = SubclassWindow(hwnd, VBool_Button_SubclassProc);
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (INT_PTR)wp);

    hwnd = GetDlgItem(hdlg, IDC_VBOOL_NO);
    wp = SubclassWindow(hwnd, VBool_Button_SubclassProc);
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (INT_PTR)wp);

    return TRUE;
}

/*****************************************************************************
 *
 *      VBool_OnApply
 *
 *      Let the owner know.
 *
 *****************************************************************************/

void INTERNAL
VBool_OnApply(HWND hdlg)
{
    HRESULT hres;
    PVLISTBOOL pvbool = GetDialogPtr(hdlg);

    pvbool->dipdw.dwData = IsDlgButtonChecked(hdlg, IDC_VBOOL_YES);

    hres = pvbool->Update(&pvbool->dipdw.diph, pvbool->pvRef1, pvbool->pvRef2);

    if (FAILED(hres)) {
        MessageBoxV(hdlg, IDS_ERR_HRESULT, hres);
    }
}

/*****************************************************************************
 *
 *      VBool_OnCommand
 *
 *      If they clicked one of the options, change it back if we are R/O.
 *
 *      If they pressed Apply, then apply it.
 *
 *****************************************************************************/

BOOL INLINE
VBool_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {

    case IDC_VBOOL_APPLY:
        VBool_OnApply(hdlg);
        return TRUE;
    }
    return FALSE;
}

/*****************************************************************************
 *
 *      VBool_DlgProc
 *
 *      Nothing really happens here.  The real work is done externally.
 *
 *****************************************************************************/

INT_PTR CALLBACK
VBool_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG: return VBool_OnInitDialog(hdlg);

    case WM_COMMAND:
        return VBool_OnCommand(hdlg,
                              (int)GET_WM_COMMAND_ID(wp, lp),
                              (UINT)GET_WM_COMMAND_CMD(wp, lp));
    }

    return FALSE;
}

/*****************************************************************************
 *
 *      c_vvtblBool
 *
 *      Our vtbl.
 *
 *****************************************************************************/

const VLISTVTBL c_vvtblBool = {
    VBool_PreDisplay,
    VBool_Destroy,
    IDD_VAL_BOOL,
    VBool_DlgProc,
};

/*****************************************************************************
 *
 *      VBool_Create
 *
 *      Make a vlist item that tracks a BOOL.
 *
 *****************************************************************************/

PVLISTITEM EXTERNAL
VBool_Create(LPDIPROPDWORD pdipdw, PROPUPDATEPROC Update, PV pvRef1, PV pvRef2)
{
    PVLISTBOOL pvbool = LocalAlloc(LPTR, cbX(VLISTBOOL));

    if (pvbool) {
        pvbool->item.pvtbl = &c_vvtblBool;
        pvbool->dipdw = *pdipdw;
        pvbool->Update = Update;
        pvbool->pvRef1 = pvRef1;
        pvbool->pvRef2 = pvRef2;
    }

    return (PV)pvbool;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diquick.c ===
/*****************************************************************************
 *
 *      diquick.c
 *
 *      DirectInput quick test
 *
 *****************************************************************************/

#include "diquick.h"

/*****************************************************************************
 *
 *      GetCheckedRadioButton
 *
 *      Return the ID of the one that is checked.
 *
 *      If nothing is checked, we return idFirst.
 *
 *****************************************************************************/

UINT EXTERNAL
GetCheckedRadioButton(HWND hdlg, UINT idFirst, UINT idLast)
{
    for (; idFirst < idLast; idLast--) {
        if (IsDlgButtonChecked(hdlg, idLast)) {
            return idLast;
        }
    }
    return idLast;
}

/*****************************************************************************
 *
 *      MessageBoxV
 *
 *      Format a message and display a message box.
 *
 *****************************************************************************/

int __cdecl
MessageBoxV(HWND hdlg, UINT ids, ...)
{
    va_list ap;
    TCHAR tszStr[256] = {0};
    TCHAR tszBuf[1024] = {0};

    LoadString(g_hinst, ids, tszStr, cA(tszStr));
    va_start(ap, ids);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,tszStr);					// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))		// find each %p
			*(psz+1) = 'x';						// replace each %p with %x
	    wvsprintf(tszBuf, szDfs, ap);    		// use the local format string
	}
#else
	{
	    wvsprintf(tszBuf, tszStr, ap);
	}
#endif
    va_end(ap);
    return MessageBox(hdlg, tszBuf, TEXT("DirectInput QuickTest"), MB_OK);

}

/*****************************************************************************
 *
 *      ThreadFailHres
 *
 *      Tell the parent that a thread failed to start, and display
 *      an error message with an HRESULT code.
 *
 *****************************************************************************/

int EXTERNAL
ThreadFailHres(HWND hdlg, UINT ids, HRESULT hres)
{
    SendNotifyMessage(hdlg, WM_THREADSTARTED, 0, 0);
    SendNotifyMessage(hdlg, WM_CHILDEXIT, 0, 0);

    return MessageBoxV(hdlg, ids, hres);
}

/*****************************************************************************
 *
 *      RecalcCursor
 *
 *      If the cursor is over the window, force a new WM_SETCUSOR.
 *
 *****************************************************************************/

void EXTERNAL
RecalcCursor(HWND hdlg)
{
    POINT pt;
    HWND hwnd;
    GetCursorPos(&pt);
    hwnd = WindowFromPoint(pt);
    if( (hwnd != NULL) && (hwnd == hdlg || IsChild(hdlg, hwnd)) ) {
        SetCursorPos(pt.x, pt.y);
    }
}

/*****************************************************************************
 *
 *      ModalVtbl
 *
 *      Things that tell you about the modal gizmo.
 *
 *****************************************************************************/

typedef struct MODALVTBL {
    BOOL (WINAPI *IsDialogMessage)(HWND, LPMSG);
    BOOL (WINAPI *IsAlive)(HWND);
    void (INTERNAL *SendIdle)(HWND);
} MODALVTBL, *PMODALVTBL;

/*****************************************************************************
 *
 *      ModalLoop
 *
 *      Spin waiting for the dialog box to die.
 *
 *      WEIRDNESS!  We send the WM_SELFENTERIDLE message to the dialog box
 *      rather than to the owner.  This avoids inter-thread sendmessage goo.
 *
 *      Don't re-post the quit message if we get one.  The purpose of the
 *      quit message is to break the modal loop.
 *
 *****************************************************************************/

int EXTERNAL
ModalLoop(HWND hwndOwner, HWND hdlg, PMODALVTBL pvtbl)
{
    if (hdlg) {
        BOOL fSentIdle = 0;
        while (pvtbl->IsAlive(hdlg)) {
            MSG msg;
            if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE)) {
                fSentIdle = 0;
                if (msg.message == WM_QUIT) {
                    break;
                }
                if (!pvtbl->IsDialogMessage(hdlg, &msg)) {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            } else {
                if (fSentIdle) {
                    WaitMessage();
                } else {
                    fSentIdle = 1;
                    pvtbl->SendIdle(hdlg);
                }
            }
        }
        if (IsWindow(hdlg)) {
            DestroyWindow(hdlg);
        }
    }

    SendNotifyMessage(hwndOwner, WM_CHILDEXIT, 0, 0);

    return 0;
}

/*****************************************************************************
 *
 *      SendDlgIdle
 *
 *      Send the fake idle message.
 *
 *****************************************************************************/

void INTERNAL
SendDlgIdle(HWND hdlg)
{
    SendMessage(hdlg, WM_SELFENTERIDLE, MSGF_DIALOGBOX, (LPARAM)hdlg);
}

/*****************************************************************************
 *
 *      SemimodalDialogBoxParam
 *
 *      Create a non-modal dialog box, then spin waiting for it to die.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

MODALVTBL c_dlgvtbl = {
    IsDialogMessage,
    IsWindow,
    SendDlgIdle,
};

#pragma END_CONST_DATA

int EXTERNAL
SemimodalDialogBoxParam(UINT idd, HWND hwndOwner, DLGPROC dp, LPARAM lp)
{
    return ModalLoop(hwndOwner, CreateDialogParam(g_hinst,
                     (LPVOID)(UINT_PTR)idd, hwndOwner, dp, lp), &c_dlgvtbl);

}

/*****************************************************************************
 *
 *      IsPrshtMessage
 *
 *****************************************************************************/

BOOL WINAPI
IsPrshtMessage(HWND hdlg, LPMSG pmsg)
{
    return PropSheet_IsDialogMessage(hdlg, pmsg);
}

/*****************************************************************************
 *
 *      IsPrshtAlive
 *
 *****************************************************************************/

BOOL WINAPI
IsPrshtAlive(HWND hdlg)
{
    return (BOOL)(INT_PTR)PropSheet_GetCurrentPageHwnd(hdlg);
}

/*****************************************************************************
 *
 *      SendPrshtIdle
 *
 *      Send the fake idle message.
 *
 *****************************************************************************/

void INTERNAL
SendPrshtIdle(HWND hdlg)
{
    hdlg = PropSheet_GetCurrentPageHwnd(hdlg);
    SendDlgIdle(hdlg);
}

/*****************************************************************************
 *
 *      SemimodalPropertySheet
 *
 *      Create a non-modal property sheet, then spin waiting for it to die.
 *
 *      We nuke the Cancel and Apply buttons, change OK to Close, and move
 *      the button into the corner.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

MODALVTBL c_pshvtbl = {
    IsPrshtMessage,
    IsPrshtAlive,
    SendPrshtIdle,
};

#pragma END_CONST_DATA

int EXTERNAL
SemimodalPropertySheet(HWND hwndOwner, LPPROPSHEETHEADER ppsh)
{
    HWND hdlg = (HWND)PropertySheet(ppsh);
    if ( hdlg && hdlg != (HWND)-1  ) {
        RECT rcOk, rcCancel;
        HWND hwnd;
        PropSheet_CancelToClose(hdlg);

        /* Slide the Close button to where the Cancel button is */
        hwnd = GetDlgItem(hdlg, IDCANCEL);
        GetWindowRect(hwnd, &rcCancel);
        ShowWindow(hwnd, SW_HIDE);

        hwnd = GetDlgItem(hdlg, IDOK);
        GetWindowRect(hwnd, &rcOk);

        rcOk.left += rcCancel.right - rcOk.right;
        ScreenToClient(hdlg, (LPPOINT)&rcOk);
        SetWindowPos(hwnd, 0, rcOk.left, rcOk.top, 0, 0,
                     SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

        return ModalLoop(hwndOwner, hdlg, &c_pshvtbl);
    } else {
        return -1;
    }

}

/*****************************************************************************
 *
 *      CreateDI
 *
 *      Create an IDirectInput interface in the appropriate manner.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

/*
 *  This table must be in sync with the CDIFL_* values.
 */
const IID *c_rgiidDI[] = {
    &IID_IDirectInputA,             /*                           */
    &IID_IDirectInputW,             /* CDIFL_UNICODE             */
    &IID_IDirectInput2A,            /*                 CDIFL_DI2 */
    &IID_IDirectInput2W,            /* CDIFL_UNICODE | CDIFL_DI2 */
};

#pragma END_CONST_DATA


STDMETHODIMP
CreateDI(BOOL fOle, UINT flCreate, PV ppvOut)
{
    HRESULT hres;
    if (fOle) {
        const IID *piid = c_rgiidDI[flCreate];
        hres = CoCreateInstance(&CLSID_DirectInput, 0, CLSCTX_INPROC_SERVER,
                                piid, ppvOut);
        if (SUCCEEDED(hres)) {
            LPDIRECTINPUT pdi = *(PPV)ppvOut;
            hres = pdi->lpVtbl->Initialize(pdi, g_hinst, g_dwDIVer);
            if (FAILED(hres)) {
                pdi->lpVtbl->Release(pdi);
                *(PPV)ppvOut = 0;
            }
        }
    } else {                                            /* Create via DI */
        if (flCreate & CDIFL_UNICODE) {
            hres = DirectInputCreateW(g_hinst, g_dwDIVer, ppvOut, 0);
        } else {
            hres = DirectInputCreateA(g_hinst, g_dwDIVer, ppvOut, 0);
        }

        /*
         *  If necessary, QI for the 2 interface.
         */
        if (flCreate & CDIFL_DI2) {
            LPDIRECTINPUT pdi = *(PPV)ppvOut;
            hres = pdi->lpVtbl->QueryInterface(pdi, c_rgiidDI[flCreate],
                                               ppvOut);
            pdi->lpVtbl->Release(pdi);
        }
    }

    return hres;
}

/*****************************************************************************
 *
 *      GetDwordProperty
 *
 *      Get a DWORD property from an IDirectInputDevice.
 *
 *****************************************************************************/

STDMETHODIMP
GetDwordProperty(IDirectInputDevice *pdid, PCGUID pguid, LPDWORD pdw)
{
    HRESULT hres;
    DIPROPDWORD dipdw;

    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    dipdw.diph.dwObj = 0;
    dipdw.diph.dwHow = DIPH_DEVICE;

    hres = IDirectInputDevice_GetProperty(pdid, pguid, &dipdw.diph);
    if (SUCCEEDED(hres)) {
        *pdw = dipdw.dwData;
    }

    return hres;
}

/*****************************************************************************
 *
 *      SetDwordProperty
 *
 *      Set a DWORD property into an IDirectInputDevice.
 *
 *****************************************************************************/

STDMETHODIMP
SetDwordProperty(IDirectInputDevice *pdid, PCGUID pguid, DWORD dw)
{
    DIPROPDWORD dipdw;

    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    dipdw.diph.dwObj = 0;
    dipdw.diph.dwHow = DIPH_DEVICE;
    dipdw.dwData = dw;

    return IDirectInputDevice_SetProperty(pdid, pguid, &dipdw.diph);
}

/*****************************************************************************
 *
 *      ConvertString
 *
 *      Convert a string from whatever character set it is in into
 *      the preferred character set (ANSI or UNICODE, whichever we
 *      were compiled with).
 *
 *      This is used to convert strings received from DirectInput
 *      into something we like.
 *
 *****************************************************************************/

void EXTERNAL
ConvertString(BOOL fWide, LPCVOID pvIn, LPTSTR ptszOut, UINT ctchOut)
{
    if (fTchar(fWide)) {
        lstrcpyn(ptszOut, pvIn, ctchOut);
    } else {
#ifdef UNICODE
        MultiByteToWideChar(CP_ACP, 0, pvIn, -1, ptszOut, ctchOut);
#else
        WideCharToMultiByte(CP_ACP, 0, pvIn, -1, ptszOut, ctchOut, 0, 0);
#endif
    }
}

/*****************************************************************************
 *
 *      UnconvertString
 *
 *      Convert a string from the preferred character set
 *      (ANSI or UNICODE, whichever we were compiled with)
 *      into the specified character set.
 *
 *      This is used to convert strings generated from dialogs
 *      into something that DirectInput will like.
 *
 *****************************************************************************/

void EXTERNAL
UnconvertString(BOOL fWide, LPCTSTR ptszIn, LPVOID pvOut, UINT ctchOut)
{
    if (fTchar(fWide)) {
        lstrcpyn(pvOut, ptszIn, ctchOut);
    } else {
#ifdef UNICODE
        WideCharToMultiByte(CP_ACP, 0, ptszIn, -1, pvOut, ctchOut, 0, 0);
#else
        MultiByteToWideChar(CP_ACP, 0, ptszIn, -1, pvOut, ctchOut);
#endif
    }
}

/*****************************************************************************
 *
 *      ConvertDoi
 *
 *      Convert the pvDoi into the local character set.
 *
 *****************************************************************************/

void EXTERNAL
ConvertDoi(PDEVDLGINFO pddi, LPDIDEVICEOBJECTINSTANCE pdoi, LPCVOID pvDoi)
{
    if (IsUnicodeDidc(pddi->didcItf)) {
        LPCDIDEVICEOBJECTINSTANCEW pdoiW = pvDoi;
        ConvertString(TRUE,
                      pdoiW->tszName, pdoi->tszName, cA(pdoi->tszName));
        pdoi->guidType  = pdoiW->guidType;
        pdoi->dwOfs     = pdoiW->dwOfs;
        pdoi->dwType    = pdoiW->dwType;
        pdoi->dwFlags   = pdoiW->dwFlags;
        pdoi->dwSize    = sizeof(DIDEVICEOBJECTINSTANCE_DX3);
        pdoi->wReportId = pdoiW->wReportId;

        if (pdoiW->dwSize > cbX(DIDEVICEOBJECTINSTANCE_DX3W)) {
            pdoi->dwFFMaxForce          = pdoiW->dwFFMaxForce;
            pdoi->dwFFForceResolution   = pdoiW->dwFFForceResolution;
            pdoi->wCollectionNumber     = pdoiW->wCollectionNumber;
            pdoi->wDesignatorIndex      = pdoiW->wDesignatorIndex;
            pdoi->wUsagePage            = pdoiW->wUsagePage;
            pdoi->wUsage                = pdoiW->wUsage;
            pdoi->dwSize                = sizeof(DIDEVICEOBJECTINSTANCE);
        }

    } else {
        LPCDIDEVICEOBJECTINSTANCEA pdoiA = pvDoi;
        ConvertString(FALSE,
                      pdoiA->tszName, pdoi->tszName, cA(pdoi->tszName));
        pdoi->guidType  = pdoiA->guidType;
        pdoi->dwOfs     = pdoiA->dwOfs;
        pdoi->dwType    = pdoiA->dwType;
        pdoi->dwFlags   = pdoiA->dwFlags;
        pdoi->dwSize    = sizeof(DIDEVICEOBJECTINSTANCE_DX3);
        pdoi->wReportId = pdoiA->wReportId;

        if (pdoiA->dwSize > cbX(DIDEVICEOBJECTINSTANCE_DX3A)) {
            pdoi->dwFFMaxForce          = pdoiA->dwFFMaxForce;
            pdoi->dwFFForceResolution   = pdoiA->dwFFForceResolution;
            pdoi->wCollectionNumber     = pdoiA->wCollectionNumber;
            pdoi->wDesignatorIndex      = pdoiA->wDesignatorIndex;
            pdoi->wUsagePage            = pdoiA->wUsagePage;
            pdoi->wUsage                = pdoiA->wUsage;
            pdoi->dwSize                = sizeof(DIDEVICEOBJECTINSTANCE);
        }
    }
}

/*****************************************************************************
 *
 *      GetObjectInfo
 *
 *      Do a GetObjectInfo with character set conversion.
 *
 *****************************************************************************/

HRESULT EXTERNAL
GetObjectInfo(PDEVDLGINFO pddi, LPDIDEVICEOBJECTINSTANCE pdoi,
              DWORD dwObj, DWORD dwHow)
{
    HRESULT hres;
    union {
        DIDEVICEOBJECTINSTANCEA doiA;
        DIDEVICEOBJECTINSTANCEW doiW;
    } u;

    if (IsUnicodeDidc(pddi->didcItf)) {
        if (g_dwDIVer > 0x0300) {
            u.doiW.dwSize = cbX(u.doiW);
        } else {
            u.doiW.dwSize = cbX(DIDEVICEOBJECTINSTANCE_DX3W);
        }
    } else {
        if (g_dwDIVer > 0x0300) {
            u.doiA.dwSize = cbX(u.doiA);
        } else {
            u.doiA.dwSize = cbX(DIDEVICEOBJECTINSTANCE_DX3A);
        }
    }

    hres = IDirectInputDevice_GetObjectInfo(pddi->pdid, (PV)&u,
                                            dwObj, dwHow);

    if (SUCCEEDED(hres)) {
        ConvertDoi(pddi, pdoi, &u);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *      ConvertDdi
 *
 *      Convert the pvDdi into the local character set.
 *
 *****************************************************************************/

void EXTERNAL
ConvertDdi(PDEVDLGINFO pddi, LPDIDEVICEINSTANCE pinst, LPCVOID pvDdi)
{
    if (IsUnicodeDidc(pddi->didcItf)) {
        LPCDIDEVICEINSTANCEW pinstW = pvDdi;

        ConvertString(TRUE,
                      pinstW->tszInstanceName,
                      pinst->tszInstanceName, cA(pinst->tszInstanceName));
        ConvertString(TRUE,
                      pinstW->tszProductName,
                      pinst->tszProductName, cA(pinst->tszProductName));

        pinst->guidInstance = pinstW->guidInstance;
        pinst->guidProduct  = pinstW->guidProduct;
        pinst->dwDevType    = pinstW->dwDevType;
        pinst->dwSize       = sizeof(DIDEVICEINSTANCE_DX3);

        if (pinstW->dwSize > cbX(DIDEVICEINSTANCE_DX3W)) {
            pinst->guidFFDriver = pinstW->guidFFDriver;
            pinst->wUsagePage   = pinstW->wUsagePage;
            pinst->wUsage       = pinstW->wUsage;
            pinst->dwSize       = sizeof(DIDEVICEINSTANCE);
        }

    } else {
        LPCDIDEVICEINSTANCEA pinstA = pvDdi;

        ConvertString(FALSE,
                      pinstA->tszInstanceName,
                      pinst->tszInstanceName, cA(pinst->tszInstanceName));
        ConvertString(FALSE,
                      pinstA->tszProductName,
                      pinst->tszProductName, cA(pinst->tszProductName));

        pinst->guidInstance = pinstA->guidInstance;
        pinst->guidProduct  = pinstA->guidProduct;
        pinst->dwDevType    = pinstA->dwDevType;
        pinst->dwSize       = sizeof(DIDEVICEINSTANCE_DX3);

        if (pinstA->dwSize > cbX(DIDEVICEINSTANCE_DX3A)) {
            pinst->guidFFDriver = pinstA->guidFFDriver;
            pinst->wUsagePage   = pinstA->wUsagePage;
            pinst->wUsage       = pinstA->wUsage;
            pinst->dwSize       = sizeof(DIDEVICEINSTANCE);
        }

    }
}

/*****************************************************************************
 *
 *      GetDeviceInfo
 *
 *      Do a GetDeviceInfo with character set conversion.
 *
 *****************************************************************************/

HRESULT EXTERNAL
GetDeviceInfo(PDEVDLGINFO pddi, LPDIDEVICEINSTANCE pinst)
{
    HRESULT hres;
    union {
        DIDEVICEINSTANCEA ddiA;
        DIDEVICEINSTANCEW ddiW;
    } u;

    if (IsUnicodeDidc(pddi->didcItf)) {
        if (g_dwDIVer > 0x0300) {
            u.ddiW.dwSize = cbX(u.ddiW);
        } else {
            u.ddiW.dwSize = cbX(DIDEVICEINSTANCE_DX3W);
        }
    } else {
        if (g_dwDIVer > 0x0300) {
            u.ddiA.dwSize = cbX(u.ddiA);
        } else {
            u.ddiA.dwSize = cbX(DIDEVICEINSTANCE_DX3A);
        }
    }

    hres = IDirectInputDevice_GetDeviceInfo(pddi->pdid, (PV)&u);

    if (SUCCEEDED(hres)) {
        ConvertDdi(pddi, pinst, &u);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *      ConvertEffi
 *
 *      Convert the pvEffi into the local character set.
 *
 *****************************************************************************/

void EXTERNAL
ConvertEffi(PDEVDLGINFO pddi, LPDIEFFECTINFO pei, LPCVOID pvEffi)
{
    LPCDIEFFECTINFOW peiW = pvEffi;
    LPCDIEFFECTINFOA peiA = pvEffi;
    LPCVOID pvStr;

    if (IsUnicodeDidc(pddi->didcItf)) {
        pvStr = peiW->tszName;
    } else {
        pvStr = peiA->tszName;
    }

    ConvertString(IsUnicodeDidc(pddi->didcItf),
                  pvStr, pei->tszName, cA(pei->tszName));

    pei->guid           = peiA->guid;
    pei->dwEffType      = peiA->dwEffType;
    pei->dwStaticParams = peiA->dwStaticParams;
    pei->dwDynamicParams= peiA->dwDynamicParams;
}

/*****************************************************************************
 *
 *      GetEffectInfo
 *
 *      Do a GetEffectInfo with character set conversion.
 *
 *****************************************************************************/

HRESULT EXTERNAL
GetEffectInfo(PDEVDLGINFO pddi, LPDIEFFECTINFO pei, REFGUID rguid)
{
    HRESULT hres;
    union {
        DIEFFECTINFOA deiA;
        DIEFFECTINFOW deiW;
    } u;

    if (IsUnicodeDidc(pddi->didcItf)) {
        u.deiW.dwSize = cbX(u.deiW);
    } else {
        u.deiA.dwSize = cbX(u.deiA);
    }

    hres = IDirectInputDevice2_GetEffectInfo(pddi->pdid2, (PV)&u, rguid);

    if (SUCCEEDED(hres)) {
        ConvertEffi(pddi, pei, &u);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *      StringFromGuid
 *
 *****************************************************************************/

void EXTERNAL
StringFromGuid(LPTSTR ptsz, REFGUID rclsid)
{
    wsprintf(ptsz,
             TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
             rclsid->Data1, rclsid->Data2, rclsid->Data3,
             rclsid->Data4[0], rclsid->Data4[1],
             rclsid->Data4[2], rclsid->Data4[3],
             rclsid->Data4[4], rclsid->Data4[5],
             rclsid->Data4[6], rclsid->Data4[7]);
}

/*****************************************************************************
 *
 *      MapGUID
 *
 *      Convert a GUID to a string, using a friendly name if possible.
 *
 *      ptszBuf must be large enough to hold a stringized GUID.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

extern GUID GUID_HIDClass;

GUID GUID_Null;

GUIDMAP c_rggm[] = {
    {   &GUID_XAxis,        "GUID_XAxis",           },
    {   &GUID_YAxis,        "GUID_YAxis",           },
    {   &GUID_ZAxis,        "GUID_ZAxis",           },
    {   &GUID_RxAxis,       "GUID_RxAxis",          },
    {   &GUID_RyAxis,       "GUID_RyAxis",          },
    {   &GUID_RzAxis,       "GUID_RzAxis",          },
    {   &GUID_Slider,       "GUID_Slider",          },
    {   &GUID_Button,       "GUID_Button",          },
    {   &GUID_Key,          "GUID_Key",             },
    {   &GUID_POV,          "GUID_POV",             },
    {   &GUID_Unknown,      "GUID_Unknown",         },
    {   &GUID_SysMouse,     "GUID_SysMouse"         },
    {   &GUID_SysKeyboard,  "GUID_SysKeyboard"      },
    {   &GUID_Joystick,     "GUID_Joystick",        },
    {   &GUID_Unknown,      "GUID_Unknown",         },
    {   &GUID_ConstantForce,"GUID_ConstantForce",   },
    {   &GUID_RampForce,    "GUID_RampForce",       },
    {   &GUID_Square,       "GUID_Square",          },
    {   &GUID_Sine,         "GUID_Sine",            },
    {   &GUID_Triangle,     "GUID_Triangle",        },
    {   &GUID_SawtoothUp,   "GUID_SawtoothUp",      },
    {   &GUID_SawtoothDown, "GUID_SawtoothDown",    },
    {   &GUID_Spring,       "GUID_Spring",          },
    {   &GUID_Damper,       "GUID_Damper",          },
    {   &GUID_Inertia,      "GUID_Inertia",         },
    {   &GUID_Friction,     "GUID_Friction",        },
    {   &GUID_CustomForce,  "GUID_CustomForce",     },
    {   &GUID_Null,         "GUID_NULL",            },
    {   &GUID_HIDClass,     "GUID_HIDClass",        },
};

LPCTSTR EXTERNAL
MapGUID(REFGUID rguid, LPTSTR ptszBuf)
{
    int igm;

    for (igm = 0; igm < cA(c_rggm); igm++) {
        if (IsEqualGUID(rguid, c_rggm[igm].rguid)) {
            return c_rggm[igm].ptsz;
        }
    }

    StringFromGuid(ptszBuf, rguid);

    return ptszBuf;
}

/*****************************************************************************
 *
 *      ProbeDinputVersion
 *
 *      Snoop around to determine what version of DirectInput is available.
 *
 *****************************************************************************/

void INTERNAL
ProbeDinputVersion(void)
{
    IDirectInput *pdi;
    HRESULT hres;

    /*
     *  For safety's sake, start with DirectX 3.0 and gradually
     *  work upwards.
     */
    g_dwDIVer = 0x0300;
    hres = DirectInputCreate(g_hinst, 0x0300, (PVOID)&pdi, 0);

    if (SUCCEEDED(hres)) {

        /*
         *  Probe upward to see what version of DirectX is supported.
         */
        if (SUCCEEDED(IDirectInput_Initialize(pdi, g_hinst,
                                              DIRECTINPUT_VERSION))) {
            g_dwDIVer = DIRECTINPUT_VERSION;

        }

        IDirectInput_Release(pdi);

    }
}

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

HINSTANCE g_hinst;
HCURSOR g_hcurWait;
HCURSOR g_hcurStarting;
DWORD g_dwDIVer;
#ifdef DEBUG
TCHAR g_tszInvalid[128];
#endif

/*****************************************************************************
 *
 *      Entry
 *
 *****************************************************************************/

void __cdecl
Entry(void)
{
    g_hcurWait = LoadCursor(0, IDC_WAIT);
    g_hcurStarting = LoadCursor(0, IDC_APPSTARTING);
    g_hinst = GetModuleHandle(0);

#ifdef DEBUG
    LoadString(g_hinst, IDS_INVALID, g_tszInvalid, cA(g_tszInvalid));
#endif

    Checklist_Init();
    ProbeDinputVersion();
    if (SUCCEEDED(CoInitialize(0))) {
        DialogBox(g_hinst, MAKEINTRESOURCE(IDD_MAIN), 0, Diq_DlgProc);
        CoUninitialize();
    }

    Checklist_Term();
    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqvcal.c ===
/*****************************************************************************
 *
 *      diqvcal.c
 *
 *      VList plug-in that does calibrations.
 *
 *****************************************************************************/

#include "diquick.h"

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *      VLISTCAL
 *
 *      range-specific goo.
 *
 *****************************************************************************/

typedef struct VLISTCAL {

    VLISTITEM item;

    DIPROPCAL dical;
    int iRadix;

    /*
     *  If non-NULL, then this is a read/write control.
     */
    PROPUPDATEPROC Update;
    PV pvRef1;
    PV pvRef2;

} VLISTCAL, *PVLISTCAL;

/*****************************************************************************
 *
 *      VCal_InitUD
 *
 *      Common updown initialization goo.
 *
 *****************************************************************************/

void INTERNAL
VCal_InitUD(HWND hwndUD, PVLISTCAL pvcal, int iValue)
{
    ShowWindow(hwndUD, pvcal->Update ? SW_SHOW : SW_HIDE);

    UpDown_SetRange(hwndUD, 0x80000000, 0x7FFFFFFF);

    UpDown_SetPos(hwndUD, pvcal->iRadix, iValue);

    Edit_SetReadOnly(GetWindow(hwndUD, GW_HWNDPREV), !pvcal->Update);
}


/*****************************************************************************
 *
 *      VCal_PreDisplay
 *
 *      Set the edit control text and let the dialog know who it is in
 *      charge of.
 *
 *****************************************************************************/

void INTERNAL
VCal_PreDisplay(HWND hdlg, PV pv)
{
    PVLISTCAL pvcal = pv;
    HWND hwndUD;

    hwndUD = GetDlgItem(hdlg, IDC_VCAL_MINUD);
    VCal_InitUD(hwndUD, pvcal, pvcal->dical.lMin);

    hwndUD = GetDlgItem(hdlg, IDC_VCAL_CTRUD);
    VCal_InitUD(hwndUD, pvcal, pvcal->dical.lCenter);

    hwndUD = GetDlgItem(hdlg, IDC_VCAL_MAXUD);
    VCal_InitUD(hwndUD, pvcal, pvcal->dical.lMax);

    ShowWindow(GetDlgItem(hdlg, IDC_VCAL_APPLY),
               pvcal->Update ? SW_SHOW : SW_HIDE);

    CheckRadioButton(hdlg, IDC_VCAL_DEC, IDC_VCAL_HEX,
                     pvcal->iRadix == 10 ? IDC_VCAL_DEC : IDC_VCAL_HEX);

    SetDialogPtr(hdlg, pvcal);

}

/*****************************************************************************
 *
 *      VCal_Destroy
 *
 *      Nothing to clean up.
 *
 *****************************************************************************/

void INTERNAL
VCal_Destroy(PV pv)
{
    PVLISTCAL pvcal = pv;
}

/*****************************************************************************
 *
 *      VCal_OnInitDialog
 *
 *      Limit the strings to MAX_PATH characters.
 *
 *****************************************************************************/

BOOL INTERNAL
VCal_OnInitDialog(HWND hdlg)
{
    HWND hwndEdit;

    hwndEdit = GetDlgItem(hdlg, IDC_VCAL_MIN);
    Edit_LimitText(hwndEdit, CCHMAXINT);

    hwndEdit = GetDlgItem(hdlg, IDC_VCAL_CTR);
    Edit_LimitText(hwndEdit, CCHMAXINT);

    hwndEdit = GetDlgItem(hdlg, IDC_VCAL_MAX);
    Edit_LimitText(hwndEdit, CCHMAXINT);

    return TRUE;
}

/*****************************************************************************
 *
 *      VCal_OnApply
 *
 *      Read the value (tricky if hex mode) and call the Update.
 *
 *****************************************************************************/

void INLINE
VCal_OnApply(HWND hdlg, PVLISTCAL pvcal)
{
    pvcal->Update(&pvcal->dical.diph, pvcal->pvRef1, pvcal->pvRef2);
}

/*****************************************************************************
 *
 *      VCal_GetValue
 *
 *****************************************************************************/

void INTERNAL
VCal_GetValue(HWND hdlg, PVLISTCAL pvcal)
{
    HWND hwndUD;

    hwndUD = GetDlgItem(hdlg, IDC_VCAL_MINUD);
    UpDown_GetPos(hwndUD, &pvcal->dical.lMin);

    hwndUD = GetDlgItem(hdlg, IDC_VCAL_CTRUD);
    UpDown_GetPos(hwndUD, &pvcal->dical.lCenter);

    hwndUD = GetDlgItem(hdlg, IDC_VCAL_MAXUD);
    UpDown_GetPos(hwndUD, &pvcal->dical.lMax);

}

/*****************************************************************************
 *
 *      VCal_SetValue
 *
 *****************************************************************************/

void INTERNAL
VCal_SetValue(HWND hdlg, PVLISTCAL pvcal)
{
    HWND hwndUD;

    hwndUD = GetDlgItem(hdlg, IDC_VCAL_MINUD);
    UpDown_SetPos(hwndUD, pvcal->iRadix, pvcal->dical.lMin);

    hwndUD = GetDlgItem(hdlg, IDC_VCAL_CTRUD);
    UpDown_SetPos(hwndUD, pvcal->iRadix, pvcal->dical.lCenter);

    hwndUD = GetDlgItem(hdlg, IDC_VCAL_MAXUD);
    UpDown_SetPos(hwndUD, pvcal->iRadix, pvcal->dical.lMax);

}

/*****************************************************************************
 *
 *      VCal_SetRadix
 *
 *      Set a new radix by reading the old value, changing the radix,
 *      and writing out the new value.
 *
 *****************************************************************************/

void INTERNAL
VCal_SetRadix(HWND hdlg, PVLISTCAL pvcal, int iRadix)
{
    VCal_GetValue(hdlg, pvcal);
    pvcal->iRadix = iRadix;
    VCal_SetValue(hdlg, pvcal);
}

/*****************************************************************************
 *
 *      VCal_OnCommand
 *
 *      If they changed the radix, then change it.
 *
 *      If they pressed Apply, then apply it.
 *
 *****************************************************************************/

BOOL INTERNAL
VCal_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    PVLISTCAL pvcal = GetDialogPtr(hdlg);

    switch (id) {

    case IDC_VCAL_DEC:
        VCal_SetRadix(hdlg, pvcal, 10);
        return TRUE;

    case IDC_VCAL_HEX:
        VCal_SetRadix(hdlg, pvcal, 16);
        return TRUE;

    case IDC_VCAL_APPLY:
        VCal_GetValue(hdlg, pvcal);
        VCal_OnApply(hdlg, pvcal);
        return TRUE;
    }
    return FALSE;
}

/*****************************************************************************
 *
 *      VCal_DlgProc
 *
 *      Nothing really happens here.  The real work is done externally.
 *
 *****************************************************************************/

INT_PTR CALLBACK
VCal_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG:
        return VCal_OnInitDialog(hdlg);

    case WM_COMMAND:
        return VCal_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));
    }

    return FALSE;
}

/*****************************************************************************
 *
 *      c_vvtblInt
 *
 *      Our vtbl.
 *
 *****************************************************************************/

const VLISTVTBL c_vvtblCal = {
    VCal_PreDisplay,
    VCal_Destroy,
    IDD_VAL_CAL,
    VCal_DlgProc,
};

/*****************************************************************************
 *
 *      VCal_Create
 *
 *      Make a vlist item that tracks a DIPROPCAL.
 *
 *****************************************************************************/

PVLISTITEM EXTERNAL
VCal_Create(LPDIPROPCAL pdical, int iRadix,
            PROPUPDATEPROC Update, PV pvRef1, PV pvRef2)
{
    PVLISTCAL pvcal = LocalAlloc(LPTR, cbX(VLISTCAL));

    if (pvcal) {
        pvcal->item.pvtbl = &c_vvtblCal;
        pvcal->dical = *pdical;
        pvcal->iRadix = iRadix;
        pvcal->Update = Update;
        pvcal->pvRef1 = pvRef1;
        pvcal->pvRef2 = pvRef2;
    }

    return (PV)pvcal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqvedit.c ===
/*****************************************************************************
 *
 *      diqvedit.c
 *
 *      VList plug-in that does strings.
 *
 *****************************************************************************/

#include "diquick.h"

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *      VLISTEDIT
 *
 *      BOOL-specific goo.
 *
 *****************************************************************************/

typedef struct VLISTEDIT {

    VLISTITEM item;

    PTSTR ptszValue;

    /*
     *  If non-NULL, then this is a read/write control.
     */
    EDITUPDATEPROC Update;
    PV pvRef1;
    PV pvRef2;

} VLISTEDIT, *PVLISTEDIT;

/*****************************************************************************
 *
 *      VEdit_PreDisplay
 *
 *      Set the edit control text and let the dialog know who it is in
 *      charge of.
 *
 *****************************************************************************/

void INTERNAL
VEdit_PreDisplay(HWND hdlg, PV pv)
{
    PVLISTEDIT pvedit = pv;
    HWND hwndEdit = GetDlgItem(hdlg, IDC_VEDIT_EDIT);

    SetWindowText(hwndEdit, pvedit->ptszValue);

    Edit_SetReadOnly(hwndEdit, !pvedit->Update);
    ShowWindow(GetDlgItem(hdlg, IDC_VEDIT_APPLY),
               pvedit->Update ? SW_SHOW : SW_HIDE);

    SetDialogPtr(hdlg, pvedit);

}

/*****************************************************************************
 *
 *      VEdit_Destroy
 *
 *      Gotta free the string.
 *
 *****************************************************************************/

void INTERNAL
VEdit_Destroy(PV pv)
{
    PVLISTEDIT pvedit = pv;

    LocalFree(pvedit->ptszValue);
}

/*****************************************************************************
 *
 *      VEdit_OnInitDialog
 *
 *      Limit the strings to MAX_PATH characters.
 *
 *****************************************************************************/

BOOL INTERNAL
VEdit_OnInitDialog(HWND hdlg)
{
    HWND hwndEdit = GetDlgItem(hdlg, IDC_VEDIT_EDIT);
    Edit_LimitText(hwndEdit, MAX_PATH);
    return TRUE;
}

/*****************************************************************************
 *
 *      VEdit_OnCommand
 *
 *      If they pressed Apply, then apply it.
 *
 *****************************************************************************/

BOOL INTERNAL
VEdit_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    if (id == IDC_VEDIT_APPLY) {
        PVLISTEDIT pvedit = GetDialogPtr(hdlg);
        TCHAR tsz[MAX_PATH];

        GetDlgItemText(hdlg, IDC_VEDIT_EDIT, tsz, cA(tsz));
        pvedit->Update(tsz, pvedit->pvRef1, pvedit->pvRef2);

        return TRUE;
    }
    return FALSE;
}

/*****************************************************************************
 *
 *      VEdit_DlgProc
 *
 *      Nothing really happens here.  The real work is done externally.
 *
 *****************************************************************************/

INT_PTR CALLBACK
VEdit_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG:
        return VEdit_OnInitDialog(hdlg);

    case WM_COMMAND:
        return VEdit_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));

    }

    return FALSE;
}

/*****************************************************************************
 *
 *      c_vvtblEdit
 *
 *      Our vtbl.
 *
 *****************************************************************************/

const VLISTVTBL c_vvtblEdit = {
    VEdit_PreDisplay,
    VEdit_Destroy,
    IDD_VAL_EDIT,
    VEdit_DlgProc,
};

/*****************************************************************************
 *
 *      VEdit_Create
 *
 *      Make a vlist item that tracks a string.
 *
 *****************************************************************************/

PVLISTITEM EXTERNAL
VEdit_Create(LPCTSTR ptszValue, EDITUPDATEPROC Update, PV pvRef1, PV pvRef2)
{
    PVLISTEDIT pvedit = LocalAlloc(LPTR, cbX(VLISTEDIT));

    if (pvedit) {
        pvedit->item.pvtbl = &c_vvtblEdit;
        pvedit->ptszValue = LocalAlloc(LPTR,
                                       cbX(TCHAR) * (lstrlen(ptszValue) + 1));
        if (pvedit->ptszValue) {
            lstrcpy(pvedit->ptszValue, ptszValue);
            pvedit->Update = Update;
            pvedit->pvRef1 = pvRef1;
            pvedit->pvRef2 = pvRef2;
        } else {
            LocalFree(pvedit);
            pvedit = 0;
        }
    }

    return (PV)pvedit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diquv.c ===
/*****************************************************************************
 *
 *      diquv.c
 *
 *      The dialog box that tinkers with joystick user values.
 *
 *****************************************************************************/

#include "diquick.h"
#include "dinputd.h"

//#ifdef DEBUG

/*****************************************************************************
 *
 *      Joystick user values dialog instance data
 *
 *      Instance data for control panel joystick user values dialog box.
 *
 *****************************************************************************/

typedef struct UVDLGINFO {

    IDirectInputJoyConfig *pdjc;/* The thing we created */
    DIJOYUSERVALUES juv;

} UVDLGINFO, *PUVDLGINFO;

/*****************************************************************************
 *
 *      Uv_OnInitDialog
 *
 *****************************************************************************/

BOOL INTERNAL
Uv_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PUVDLGINFO puvi = (PV)lp;
    HRESULT hres;
    TCHAR tsz[MAX_JOYSTRING];

    SetDialogPtr(hdlg, puvi);

    puvi->juv.dwSize = cbX(puvi->juv);

    hres = puvi->pdjc->lpVtbl->GetUserValues(puvi->pdjc, &puvi->juv,
                                             DIJU_USERVALUES |
                                             DIJU_GLOBALDRIVER |
                                             DIJU_GAMEPORTEMULATOR);

    if (SUCCEEDED(hres)) {
        HWND hwnd;
        int ids;

        hwnd = GetDlgItem(hdlg, IDC_JOYUV_AXIS);

        for (ids = IDS_AXIS_MIN; ids < IDS_AXIS_MAX; ids++) {
            int iItem;

            LoadString(g_hinst, ids, tsz, cA(tsz));

            iItem = ListBox_AddString(hwnd, tsz);
            if (iItem >= 0) {
                ListBox_SetItemData(hwnd, iItem, ids - IDS_AXIS_MIN);
            }
        }

        ConvertString(TRUE, puvi->juv.wszGlobalDriver, tsz, cA(tsz));

        SetDlgItemText(hdlg, IDC_JOYUV_CALLOUT, tsz);

        ConvertString(TRUE, puvi->juv.wszGameportEmulator, tsz, cA(tsz));

        SetDlgItemText(hdlg, IDC_JOYUV_EMULATOR, tsz);

#if 0
    #define IDC_JOYUV_AXIS          16
    #define IDC_JOYUV_MIN           17
    #define IDC_JOYUV_CENTER        18
    #define IDC_JOYUV_MAX           19
    #define IDC_JOYUV_DEADZONE      20
$$$
#endif
    }
    return 1;
}

/*****************************************************************************
 *
 *      Uv_DlgProc
 *
 *****************************************************************************/

INT_PTR INTERNAL
Uv_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG:
        return Uv_OnInitDialog(hdlg, lp);

    case WM_CLOSE:
        EndDialog(hdlg, TRUE);
        return TRUE;
    }

    return 0;
}

/*****************************************************************************
 *
 *      Uv_Create
 *
 *      Display the user values.
 *
 *****************************************************************************/

INT_PTR EXTERNAL
Uv_Create(HWND hdlg, struct IDirectInputJoyConfig *pdjc)
{
    UVDLGINFO tdi;

    tdi.pdjc = pdjc;

    return DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_JOYUV),
                          hdlg, Uv_DlgProc, (LPARAM)&tdi);
}
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqvint.c ===
/*****************************************************************************
 *
 *      diqvint.c
 *
 *      VList plug-in that does integers.
 *
 *****************************************************************************/

#include "diquick.h"

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *      VLISTINT
 *
 *      INT-specific goo.
 *
 *****************************************************************************/

typedef struct VLISTINT {

    VLISTITEM item;

    DIPROPDWORD dipdw;
    int iMin;
    int iMax;
    int iRadix;

    /*
     *  If non-NULL, then this is a read/write control.
     */
    PROPUPDATEPROC Update;
    PV pvRef1;
    PV pvRef2;

} VLISTINT, *PVLISTINT;

#ifndef UDM_SETRANGE32
#define UDM_SETRANGE32  (WM_USER + 111)
#define UDM_GETRANGE32  (WM_USER + 112)
#endif

/*****************************************************************************
 *
 *      Some helper functions for UpDown controls since they're kind
 *      of broken.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      UpDown_SetRange
 *
 *      This is an evil hack to set the range of an UpDown control to a
 *      32-bit value, because older versions didn't support
 *      UDM_SETRANGE32.
 *
 *****************************************************************************/

void EXTERNAL
UpDown_SetRange(HWND hwndUD, int min, int max)
{
    int iTest;

    /*
     *  We detect whether UDM_SETRANGE32 is supported by first sending it,
     *  then using UDM_GETRANGE32 to see if it worked.
     */
    SendMessage(hwndUD, UDM_SETRANGE32, (WPARAM)min, (LPARAM)max);

    iTest = max + 1;        /* Make sure it's different */
    SendMessage(hwndUD, UDM_GETRANGE32, 0, (LPARAM)&iTest);

    /*
     *  If UDM_GETRANGE32 failed to return the correct value,
     *  then try it the old way, but first pin the pin/max values.
     */
    if (iTest != max) {
        if (max > UD_MAXVAL) max = UD_MAXVAL;
        if (min < UD_MINVAL) min = UD_MINVAL;

        SendMessage(hwndUD, UDM_SETRANGE, 0, MAKELPARAM(max, min));
    }

}

/*****************************************************************************
 *
 *      UpDown_SetPos
 *
 *      Set the value in the edit control part of the sub-dialog.
 *      We have to do it ourselves because there is no UDM_SETPOS32
 *      message.
 *
 *****************************************************************************/

void EXTERNAL
UpDown_SetPos(HWND hwndUD, int iRadix, int iValue)
{
    TCHAR tsz[128];

    SendMessage(hwndUD, UDM_SETBASE, iRadix, 0L);

    /*
     *  Bug in UDM_SETPOS means that we cannot use it on values
     *  greater than 65535.
     */
    if (iRadix == 10) {
        wsprintf(tsz, TEXT("%d")    , iValue);
    } else {
        wsprintf(tsz, TEXT("0x%08x"), iValue);
    }

    SetWindowText(GetWindow(hwndUD, GW_HWNDPREV), tsz);
}

/*****************************************************************************
 *
 *      VInt_AToI
 *
 *      Convert a string to an integer, allowing decimal or hex.
 *
 *****************************************************************************/

BOOL INTERNAL
VInt_AToI(LPCTSTR ptsz, PINT pi)
{
    int iVal;
    BOOL fSign = FALSE;
    UINT uiRadix;

    /*
     *  Skip leading whitespace.
     */
    while (*ptsz == TEXT(' ')) {
        ptsz++;
    }

    /*
     *  See if there is a leading negative sign.
     */
    if (*ptsz == TEXT('-')) {
        fSign = TRUE;
        ptsz++;
    }

    iVal = 0;


    if (ptsz[0] == TEXT('0') &&
        (ptsz[1] == TEXT('x') || ptsz[1] == TEXT('X'))) {
        uiRadix = 16;
        ptsz += 2;
    } else {
        uiRadix = 10;
    }

    for (;;) {
        UINT uiVal;
        if ((UINT)(*ptsz - TEXT('0')) < 10) {
            uiVal = (UINT)(*ptsz - TEXT('0'));
        } else if ((UINT)(*ptsz - TEXT('A')) < 6) {
            uiVal = (UINT)(*ptsz - TEXT('A')) + 10;
        } else if ((UINT)(*ptsz - TEXT('a')) < 6) {
            uiVal = (UINT)(*ptsz - TEXT('a')) + 10;
        } else if (*ptsz == TEXT(' ') || *ptsz == TEXT(',')) {
            continue;           /* Ignore spaces and commas */
        } else if (*ptsz == TEXT('\0')) {
            *pi = fSign ? -iVal : iVal;
            return TRUE;
        } else {
            return FALSE;
        }
        if (uiVal < uiRadix) {
            iVal = iVal * uiRadix + uiVal;
        } else {
            return FALSE;
        }
        ptsz++;
    }
}

/*****************************************************************************
 *
 *      UpDown_GetPos
 *
 *      Get the value in the edit control part of the sub-dialog.
 *      We have to do it ourselves because there is no UDM_GETPOS32
 *      message.
 *
 *****************************************************************************/

BOOL EXTERNAL
UpDown_GetPos(HWND hwndUD, LPINT pi)
{
    TCHAR tsz[CCHMAXINT];

    GetWindowText(GetWindow(hwndUD, GW_HWNDPREV), tsz, cA(tsz));
    return VInt_AToI(tsz, pi);
}

/*****************************************************************************
 *
 *      VInt_PreDisplay
 *
 *      Set the edit control text and let the dialog know who it is in
 *      charge of.
 *
 *****************************************************************************/

void INTERNAL
VInt_PreDisplay(HWND hdlg, PV pv)
{
    PVLISTINT pvint = pv;
    HWND hwndUD = GetDlgItem(hdlg, IDC_VINT_UD);
    HWND hwndEdit;

    ShowWindow(hwndUD, pvint->Update ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hdlg, IDC_VINT_APPLY),
                       pvint->Update ? SW_SHOW : SW_HIDE);

    UpDown_SetRange(hwndUD, pvint->iMin, pvint->iMax);

    UpDown_SetPos(hwndUD, pvint->iRadix, pvint->dipdw.dwData);

    hwndEdit = GetDlgItem(hdlg, IDC_VINT_EDIT);
    Edit_SetReadOnly(hwndEdit, !pvint->Update);

    CheckRadioButton(hdlg, IDC_VINT_DEC, IDC_VINT_HEX,
                     pvint->iRadix == 10 ? IDC_VINT_DEC : IDC_VINT_HEX);

    SetDialogPtr(hdlg, pvint);

}

/*****************************************************************************
 *
 *      VInt_Destroy
 *
 *      Nothing to clean up.
 *
 *****************************************************************************/

void INTERNAL
VInt_Destroy(PV pv)
{
    PVLISTINT pvint = pv;
}

/*****************************************************************************
 *
 *      VInt_OnInitDialog
 *
 *      Limit the strings to CCHMAXINT characters.
 *
 *****************************************************************************/

BOOL INTERNAL
VInt_OnInitDialog(HWND hdlg)
{
    HWND hwndEdit = GetDlgItem(hdlg, IDC_VINT_EDIT);
    Edit_LimitText(hwndEdit, CCHMAXINT);
    return TRUE;
}

/*****************************************************************************
 *
 *      VInt_OnApply
 *
 *      Let the owner know.
 *
 *****************************************************************************/

void INTERNAL
VInt_OnApply(HWND hdlg, PVLISTINT pvint)
{
    HRESULT hres;

    hres = pvint->Update(&pvint->dipdw.diph, pvint->pvRef1, pvint->pvRef2);

    if (FAILED(hres)) {
        MessageBoxV(hdlg, IDS_ERR_HRESULT, hres);
    }
}

/*****************************************************************************
 *
 *      VInt_SetRadix
 *
 *      Set a new radix by reading the old value, changing the radix,
 *      and writing out the new value.
 *
 *****************************************************************************/

void INTERNAL
VInt_SetRadix(HWND hwndUD, PVLISTINT pvint, int iRadix)
{
    UpDown_GetPos(hwndUD, &pvint->dipdw.dwData);
    pvint->iRadix = iRadix;
    UpDown_SetPos(hwndUD, pvint->iRadix, pvint->dipdw.dwData);
}

/*****************************************************************************
 *
 *      VInt_OnCommand
 *
 *      If they changed the radix, then change it.
 *
 *      If they pressed Apply, then apply it.
 *
 *****************************************************************************/

BOOL INTERNAL
VInt_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    PVLISTINT pvint = GetDialogPtr(hdlg);
    HWND hwndUD = GetDlgItem(hdlg, IDC_VINT_UD);

    switch (id) {

    case IDC_VINT_DEC:
        VInt_SetRadix(hwndUD, pvint, 10);
        return TRUE;

    case IDC_VINT_HEX:
        VInt_SetRadix(hwndUD, pvint, 16);
        return TRUE;

    case IDC_VINT_APPLY:
        UpDown_GetPos(hwndUD, &pvint->dipdw.dwData);
        VInt_OnApply(hdlg, pvint);
        return TRUE;
    }
    return FALSE;
}

/*****************************************************************************
 *
 *      VInt_DlgProc
 *
 *      Nothing really happens here.  The real work is done externally.
 *
 *****************************************************************************/

INT_PTR CALLBACK
VInt_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG:
        return VInt_OnInitDialog(hdlg);

    case WM_COMMAND:
        return VInt_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));
    }

    return FALSE;
}

/*****************************************************************************
 *
 *      c_vvtblInt
 *
 *      Our vtbl.
 *
 *****************************************************************************/

const VLISTVTBL c_vvtblInt = {
    VInt_PreDisplay,
    VInt_Destroy,
    IDD_VAL_INT,
    VInt_DlgProc,
};

/*****************************************************************************
 *
 *      VInt_Create
 *
 *      Make a vlist item that tracks an integer.
 *
 *      The LPDIPROPDWORD gets copied and handed to the Update procedure.
 *      The Update procedure can use the non-dwData fields of the
 *      DIPROPDWORD to stash extra reference data.
 *
 *****************************************************************************/

PVLISTITEM EXTERNAL
VInt_Create(LPDIPROPDWORD pdipdw, int iMin, int iMax, int iRadix,
            PROPUPDATEPROC Update, PV pvRef1, PV pvRef2)
{
    PVLISTINT pvint = LocalAlloc(LPTR, cbX(VLISTINT));

    if (pvint) {
        pvint->item.pvtbl = &c_vvtblInt;
        pvint->dipdw = *pdipdw;
        pvint->iMin = iMin;
        pvint->iMax = iMax;
        pvint->iRadix = iRadix;
        pvint->Update = Update;
        pvint->pvRef1 = pvRef1;
        pvint->pvRef2 = pvRef2;
    }

    return (PV)pvint;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\debug.h ===
/***************************************************************************
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.h
 *  Content:    DirectInput debugging macros
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1996.05.07 raymondc Somebody had to
 *
 *@@END_MSINTERNAL
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 ***************************************************************************/

#ifndef _INC_DEBUG
#define _INC_DEBUG

#ifdef __cplusplus
extern "C"
{
#endif

#ifdef XDEBUG
    #define RD(x)       x
    #ifdef DEBUG
        #define D(x)    x
    #else
        #define D(x)
    #endif
#else
    #define RD(x)
    #define D(x)
#endif

/*****************************************************************************
 *
 *	assert.c - Assertion stuff
 *
 *      A sqfl is in multiple parts.
 *
 *      The low word specifies the area that is generating the message.
 *
 *      The high word contains flags that describe why this squirty
 *      is being generated.
 *
 *****************************************************************************/

typedef enum {
    /*
     *  Areas.
     */
    sqflAlways          = 0x0000,       /* Unconditional */
    sqflDll             = 0x0001,       /* Dll bookkeeping */
    sqflFactory         = 0x0002,       /* IClassFactory */
    sqflDi              = 0x0003,       /* IDirectInput */
    sqflMouse           = 0x0004,       /* IDirectInputMouse */
    sqflDev             = 0x0005,       /* IDirectInputDevice */
    sqflKbd             = 0x0006,       /* IDirectInputKeyboard */
    sqflDf              = 0x0007,       /* DataFormat goo */
    sqflJoy             = 0x0008,       /* joystick device */
    sqflEm              = 0x0009,       /* Emulation */
    sqflSubclass        = 0x000A,       /* subclassing */
    sqflCursor          = 0x000B,       /* Cursor show/hide */
    sqflHel             = 0x000C,       /* Hardware emulation layer */
    sqflLl              = 0x000D,       /* Low-level hooks */
    sqflExcl            = 0x000E,       /* Exclusivity management */
    sqflDEnum           = 0x000F,       /* Device enumeration */
    sqflExtDll          = 0x0010,       /* External DLLs */
    sqflHid             = 0x0011,       /* HID support */
    sqflHidDev          = 0x0012,       /* HID device support */
    sqflJoyCfg          = 0x0013,       /* IDirectInputJoyConfig */
    sqflEff             = 0x0014,       /* IDirectInputEffect */
    sqflOleDup          = 0x0015,       /* OLE duplication */
    sqflEShep           = 0x0016,       /* IDirectInputEffectShepherd */
    sqflJoyEff          = 0x0017,       /* Dummy DIEffectDriver */
    sqflJoyReg          = 0x0018,       /* Joystick registry goo */
    sqflVxdEff          = 0x0019,       /* VxD DIEffectDriver */
    sqflNil             = 0x001A,       /* CNil and CDefDcb */
    sqflHidUsage        = 0x001B,       /* HID usage mapping */
    sqflUtil            = 0x001C,       /* Misc utility fns */
    sqflObj             = 0x001D,       /* Object creation/destruction */
    sqflCommon          = 0x001E,       /* common.c */
    sqflHidParse        = 0x001F,       /* HID report parsing */
    sqflCal             = 0x0020,       /* Axis calibrations */
    sqflJoyType         = 0x0021,       /* Joystick type key */
    sqflHidOutput       = 0x0022,       /* HID output reports */
    sqflHidIni          = 0x0023,       /* HID device initialization */
    sqflPort            = 0x0024,       /* GamePort Bus Enumuration */
    sqflWDM             = 0x0025,       /* WDM specific Code */
    sqflRegUtils        = 0x0026,       /* Registry utilities */
    sqflCrit            = 0x0027,       /* Critical Section tracking */
    sqflCompat          = 0x0028,       /* App Hacks */
    sqflRaw             = 0x0029,       /* Raw Input - keyboard and mouse */
    sqflMaxArea,                        /* Last area */

    /*
     *  Flags which may be combined.  For now, they all fit into a byte.
     */
    sqflTrace           = 0x00010000,   /* Trace squirties */
    sqflIn              = 0x00020000,   /* Function entry */
    sqflOut             = 0x00040000,   /* Function exit */
    sqflBenign          = 0x00080000,   /* Not a bad error */
    sqflError           = 0x00100000,   /* A bad error */
    sqflVerbose         = 0x00200000,   /* Really verbose */
    sqflMajor           = 0x00400000,   /* Significant, generally positive, events */
} SQFL;                                 /* squiffle */

void EXTERNAL WarnPszV(LPCSTR ptsz, ...);
void EXTERNAL SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...);

#ifndef DEBUG
#define SquirtSqflPtszV sizeof
#endif

#ifdef XDEBUG
    #define RPF WarnPszV
#else
    #define WarnPszV sizeof
    #define RPF sizeof
    #define s_szProc 0
    #define iarg 0
#endif

/*****************************************************************************
 *
 *      Buffer scrambling
 *
 *      All output buffers should be scrambled on entry to any function.
 *
 *      Each output bitmask should set an unused bit randomly to ensure
 *      that callers ignore bits that aren't defined.
 *
 *****************************************************************************/

#ifdef XDEBUG

void EXTERNAL ScrambleBuf(LPVOID pv, UINT cb);
void EXTERNAL ScrambleBit(LPDWORD pdw, DWORD flMask);

#else

#define ScrambleBuf(pv, cb)
#define ScrambleBit(pdw, flRandom)

#endif

/*****************************************************************************
 *
 *      Procedure enter/exit tracking.
 *
 *      Start a procedure with
 *
 *      EnterProc(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcS(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcI(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcR(ProcedureName, (_ "format", arg, arg, arg, ...));
 *
 *      The format string is documented in EmitPal.
 *
 *      Suffixing an "S" indicates that the macro should not generate
 *      a procedure name because there is a formal parameter with the
 *      name s_szProc.  This is a hack.
 *
 *      Suffixing an "R" indicates that the macro should generate a
 *      procedure name in RDEBUG.
 *
 *      Suffixing an "I" indicates that the macro should emit a dummy
 *      procedure name in RDEBUG because the interface is internal.
 *
 *      No suffix means that the macro should be active only in the
 *      DEBUG build and should vanish in RDEBUG (and RETAIL).
 *
 *      End a procedure with one of the following:
 *
 *          ExitProc();
 *
 *              Procedure returns no value.
 *
 *          ExitProcX();
 *
 *              Procedure returns an arbitrary DWORD.
 *
 *          ExitProcF();
 *
 *              Procedure returns a BOOL, where FALSE is an error.
 *
 *          ExitOleProc();
 *
 *              Procedure returns an HRESULT (named "hres").
 *
 *          ExitOleProcPpv(ppvOut);
 *
 *              Procedure returns an HRESULT (named "hres") and, on success,
 *              puts a new object in ppvOut.
 *
 *      The ExitBenign* versions consider any error to be benign.
 *
 *****************************************************************************/

#define cpvArgMax	10	/* Max of 10 args per procedure */

typedef struct ARGLIST {
    LPCSTR pszProc;
    LPCSTR pszFormat;
    PV rgpv[cpvArgMax];
} ARGLIST, *PARGLIST;

void EXTERNAL ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...);
void EXTERNAL EnterSqflPszPal(SQFL sqfl, LPCSTR psz, PARGLIST pal);
void EXTERNAL ExitSqflPalHresPpv(SQFL, PARGLIST, HRESULT, PPV);
void EXTERNAL Sqfl_Init(void);

#ifdef DEBUG

extern BYTE g_rgbSqfl[sqflMaxArea];

BOOL INLINE
IsSqflSet(SQFL sqfl)
{
    WORD wHi;
    if (LOWORD(sqfl) == sqflAlways) {
        return TRUE;
    }
    wHi = HIWORD(sqfl);
    if (wHi == 0) {
        wHi = HIWORD(sqflTrace);
    }

    return g_rgbSqfl[LOWORD(sqfl)] & wHi;
}

#endif

#define _SetupEnterProc(nm)                             \
        static CHAR s_szProc[] = #nm;                   \
        ARGLIST _al[1]                                  \

#define _ _al,

#define ppvDword ((PPV)1)
#define ppvVoid  ((PPV)2)
#define ppvBool  ((PPV)3)

#define _DoEnterProc(v)                                 \
        ArgsPalPszV v;                                  \
        EnterSqflPszPal(sqfl, s_szProc, _al)            \

#define _EnterProc(nm, v)                               \
        _SetupEnterProc(nm);                            \
        _DoEnterProc(v)                                 \

#define _ExitOleProcPpv(ppv)                            \
        ExitSqflPalHresPpv(sqfl, _al, hres, (PPV)(ppv)) \

#define _ExitOleProc()                                  \
        _ExitOleProcPpv(0)                              \

#define _ExitProc()                                     \
        ExitSqflPalHresPpv(sqfl, _al, 0, ppvVoid)       \

#define _ExitProcX(x)                                   \
        ExitSqflPalHresPpv(sqfl, _al, (HRESULT)(x), ppvDword) \

#define _ExitProcF(x)                                   \
        ExitSqflPalHresPpv(sqfl, _al, (HRESULT)(x), ppvBool) \

#define _ExitBenignOleProcPpv(ppv)                      \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, hres, (PPV)(ppv)) \

#define _ExitBenignOleProc()                            \
        _ExitBenignOleProcPpv(0)                        \

#define _ExitBenignProc()                               \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, 0, ppvVoid) \

#define _ExitBenignProcX(x)                                   \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, (HRESULT)(x), ppvDword) \

#define _ExitBenignProcF(x)                                   \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, (HRESULT)(x), ppvBool) \

#if defined(DEBUG)

#define EnterProc           _EnterProc
#define ExitOleProcPpv      _ExitOleProcPpv
#define ExitOleProc         _ExitOleProc
#define ExitProc            _ExitProc
#define ExitProcX           _ExitProcX
#define ExitProcF           _ExitProcF
#define ExitBenignOleProcPpv    _ExitBenignOleProcPpv
#define ExitBenignOleProc       _ExitBenignOleProc
#define ExitBenignProc          _ExitBenignProc
#define ExitBenignProcX         _ExitBenignProcX
#define ExitBenignProcF         _ExitBenignProcF

#define EnterProcS(nm, v)                               \
        static CHAR s_szProc2[] = #nm;                  \
        ARGLIST _al[1];                                 \
        ArgsPalPszV v;                                  \
        EnterSqflPszPal(sqfl, s_szProc2, _al)           \

#define EnterProcI          _EnterProc
#define EnterProcR          _EnterProc
#define ExitOleProcPpvR     _ExitOleProcPpv
#define ExitOleProcR        _ExitOleProc
#define ExitProcR           _ExitProc
#define ExitProcXR          _ExitProcX
#define ExitProcFR          _ExitProcF
#define ExitBenignOleProcPpvR   _ExitBenignOleProcPpv
#define ExitBenignOleProcR      _ExitBenignOleProc
#define ExitBenignProcR         _ExitBenignProc
#define ExitBenignProcXR        _ExitBenignProcX
#define ExitBenignProcFR        _ExitBenignProcF

#elif defined(RDEBUG)

#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()
#define ExitProcX(x)
#define ExitProcF(x)
#define ExitBenignOleProcPpv(ppv)
#define ExitBenignOleProc()
#define ExitBenignProc()
#define ExitBenignProcX(x)
#define ExitBenignProcF(x)

#define EnterProcS(nm, v)
#define EnterProcI(nm, v)   static CHAR s_szProc[] = ""
#define EnterProcR(nm, v)   static CHAR s_szProc[] = #nm
#define ExitOleProcPpvR(ppv)
#define ExitOleProcR()
#define ExitProcR()
#define ExitProcXR()
#define ExitProcFR()
#define ExitBenignOleProcPpvR(ppv)
#define ExitBenignOleProcR()
#define ExitBenignProcR()
#define ExitBenignProcXR()
#define ExitBenignProcFR()

#else

#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()
#define ExitProcX(x)
#define ExitProcF(x)
#define ExitBenignOleProcPpv(ppv)
#define ExitBenignOleProc()
#define ExitBenignProc()
#define ExitBenignProcX(x)
#define ExitBenignProcF(x)

#define EnterProcS(nm, v)
#define EnterProcI(nm, v)
#define EnterProcR(nm, v)
#define ExitOleProcPpvR(ppv)
#define ExitOleProcR()
#define ExitProcR()
#define ExitProcXR(x)
#define ExitProcFR(x)
#define ExitBenignOleProcPpvR(ppv)
#define ExitBenignOleProcR()
#define ExitBenignProcR()
#define ExitBenignProcXR()
#define ExitBenignProcFR()

#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqvlist.c ===
/*****************************************************************************
 *
 *      diqvlist.c
 *
 *      Wrappers that turn a listbox/edit control pair into
 *      a value-listbox.
 *
 *****************************************************************************/

#include "diquick.h"

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *      VLISTINFO
 *
 *      Stuff that tracks the vlist itself.
 *
 *****************************************************************************/

typedef struct VLISTINFO {

    /*
     *  The current visible dialog.
     */
    HWND hdlgVis;

    /*
     *  The coordinates of the child dialog area.
     */
    POINT pt;

} VLISTINFO, *PVLISTINFO;

/*****************************************************************************
 *
 *      Vlist_OnInitDialog
 *
 *      Initialize a single Vlist control.  The value control is assumed
 *      to follow the listbox in the Z-order.
 *
 *      All our goofy sub-dialogs are inserted into the Z-order between
 *      the main vlist control and the value control.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_OnInitDialog(HWND hwndList)
{
    PVLISTINFO pvi = LocalAlloc(LPTR, cbX(VLISTINFO));
    if (pvi) {
        RECT rc;
        HWND hwnd;

        SetWindowLongPtr(hwndList, GWLP_USERDATA, (INT_PTR)pvi);

        /*
         *  Get the invisible static that we use to signal the end of the
         *  list.  pull out its coordinates.
         */
        hwnd = GetWindow(hwndList, GW_HWNDNEXT);
        GetWindowRect(hwnd, &rc);
        pvi->pt.x = rc.left;
        pvi->pt.y = rc.top;
        MapWindowPoints(HWND_DESKTOP, GetParent(hwndList), &pvi->pt, 1);
    }
}

/*****************************************************************************
 *
 *      VlistItem_Destroy
 *
 *      Destroy a VLISTITEM and its associated goo.
 *
 *****************************************************************************/

void INTERNAL
VlistItem_Destroy(PVLISTITEM pitem)
{
    pitem->pvtbl->Destroy(pitem);
    LocalFree(pitem);
}

/*****************************************************************************
 *
 *      Vlist_AddItem
 *
 *      Add an item with a string id.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_AddItem(HWND hwnd, UINT ids, PVLISTITEM pitem)
{
    int iItem;
    TCHAR tsz[256];

    LoadString(g_hinst, ids, tsz, cA(tsz));
    iItem = ListBox_AddString(hwnd, tsz);
    if (iItem >= 0) {
        ListBox_SetItemData(hwnd, iItem, pitem);
    } else {
        VlistItem_Destroy(pitem);
    }

}

/*****************************************************************************
 *
 *      Vlist_AddValueRW
 *
 *      Add a mutable string with corresponding value.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_AddValueRW(HWND hwnd, UINT ids, LPCTSTR ptszValue,
                 EDITUPDATEPROC Update, PV pvRef1, PV pvRef2)
{
    PVLISTITEM pitem;
    pitem = VEdit_Create(ptszValue, Update, pvRef1, pvRef2);

    if (pitem) {
        Vlist_AddItem(hwnd, ids, pitem);
    }
}

/*****************************************************************************
 *
 *      Vlist_AddValue
 *
 *      Add a string with corresponding value.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_AddValue(HWND hwnd, UINT ids, LPCTSTR ptszValue)
{
    Vlist_AddValueRW(hwnd, ids, ptszValue, NULL, 0, 0);
}

/*****************************************************************************
 *
 *      Vlist_AddNumValueRW
 *
 *      Add an integer that can be edited.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_AddNumValueRW(HWND hwnd, UINT ids,
                    LPDIPROPDWORD pdipdw, int iMin, int iMax, int iRadix,
                    PROPUPDATEPROC Update, PV pvRef1, PV pvRef2)
{
    PVLISTITEM pitem;
    pitem = VInt_Create(pdipdw, iMin, iMax, iRadix, Update, pvRef1, pvRef2);

    if (pitem) {
        Vlist_AddItem(hwnd, ids, pitem);
    }
}

/*****************************************************************************
 *
 *      Vlist_AddRadixValue
 *
 *      Add an integer with the appropriate default radix.
 *
 *****************************************************************************/

void INTERNAL
Vlist_AddRadixValue(HWND hwnd, UINT ids, DWORD dw, int iRadix)
{
    DIPROPDWORD dipdw;
    dipdw.dwData = dw;

    Vlist_AddNumValueRW(hwnd, ids, &dipdw, (int)dw, (int)dw, iRadix,
                        NULL, 0, 0);
}

/*****************************************************************************
 *
 *      Vlist_AddHexValue
 *
 *      Add a string with corresponding value.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_AddHexValue(HWND hwnd, UINT ids, DWORD dw)
{
    Vlist_AddRadixValue(hwnd, ids, dw, 16);
}

/*****************************************************************************
 *
 *      Vlist_AddIntValue
 *
 *      Add a string with corresponding value.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_AddIntValue(HWND hwnd, UINT ids, DWORD dw)
{
    Vlist_AddRadixValue(hwnd, ids, dw, 10);
}

/*****************************************************************************
 *
 *      Vlist_AddRangeValueRW
 *
 *      Add a pair of integers that can be edited.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_AddRangeValueRW(HWND hwnd, UINT ids,
                      LPDIPROPRANGE pdiprg, int iRadix,
                      PROPUPDATEPROC Update, PV pvRef1, PV pvRef2)
{
    PVLISTITEM pitem;
    pitem = VRange_Create(pdiprg, iRadix, Update, pvRef1, pvRef2);

    if (pitem) {
        Vlist_AddItem(hwnd, ids, pitem);
    }
}

/*****************************************************************************
 *
 *      Vlist_AddCalValueRW
 *
 *      Add a pair of integers that can be edited.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_AddCalValueRW(HWND hwnd, UINT ids,
                      LPDIPROPCAL pdipcal, int iRadix,
                      PROPUPDATEPROC Update, PV pvRef1, PV pvRef2)
{
    PVLISTITEM pitem;
    pitem = VCal_Create(pdipcal, iRadix, Update, pvRef1, pvRef2);

    if (pitem) {
        Vlist_AddItem(hwnd, ids, pitem);
    }
}

/*****************************************************************************
 *
 *      Vlist_AddBoolValueRW
 *
 *      Add a boolean.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_AddBoolValueRW(HWND hwnd, UINT ids, LPDIPROPDWORD pdipdw,
                     PROPUPDATEPROC Update, PV pvRef1, PV pvRef2)
{
    PVLISTITEM pitem;
    pitem = VBool_Create(pdipdw, Update, pvRef1, pvRef2);

    if (pitem) {
        Vlist_AddItem(hwnd, ids, pitem);
    }
}


/*****************************************************************************
 *
 *      Vlist_AddBoolValue
 *
 *      Add a boolean.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_AddBoolValue(HWND hwnd, UINT ids, DWORD dw)
{
    DIPROPDWORD dipdw;
    dipdw.dwData = dw;

    Vlist_AddBoolValueRW(hwnd, ids, &dipdw, NULL, 0, 0);
}

/*****************************************************************************
 *
 *      Vlist_AddFlags
 *
 *      Add a bunch of strings corresponding to flag bits.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_AddFlags(HWND hwnd, DWORD fl, PCHECKLISTFLAG rgclf, UINT cclf)
{
    UINT iclf;

    for (iclf = 0; iclf < cclf; iclf++) {
        Vlist_AddBoolValue(hwnd, rgclf[iclf].ids,
                           fl & rgclf[iclf].flMask);
    }
}

/*****************************************************************************
 *
 *      Vlist_FindChild
 *
 *      Find the dialog box (creating it if necessary) that manages
 *      the vlist in question.  We know who it is because we stash
 *      the vtbl pointer into the GWLP_USERDATA so we know who it is.
 *
 *****************************************************************************/

HWND INTERNAL
Vlist_FindChild(HWND hwndList, PVLISTVTBL pvtbl)
{
    HWND hwnd = hwndList;
    PVLISTINFO pvi;

    while ((hwnd = GetWindow(hwnd, GW_HWNDNEXT))) {
        PVLISTVTBL pvtblT = (PVLISTVTBL)GetWindowLongPtr(hwnd, GWLP_USERDATA);

        if (!pvtblT) {
            break;
        }

        if (pvtbl == pvtblT) {
            return hwnd;
        }

    }

    /*
     *  Not found.  Gotta make it.
     */
    hwnd = CreateDialog(g_hinst, (PV)(UINT_PTR)pvtbl->idd, GetParent(hwndList),
                        pvtbl->dp);

    if( hwnd ) {
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (INT_PTR)pvtbl);

        /*
         *  Now put it in the right place.
         */
        pvi = (PVLISTINFO)GetWindowLongPtr(hwndList, GWLP_USERDATA);
        SetWindowPos(hwnd, hwndList, pvi->pt.x, pvi->pt.y, 0, 0, SWP_NOSIZE);
    }

    return hwnd;
}

/*****************************************************************************
 *
 *      Vlist_OnSelChange
 *
 *      Update the edit control to match the current gizmo in the
 *      list box.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_OnSelChange(HWND hwnd)
{
    PVLISTINFO pvi = (PVLISTINFO)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (pvi) {
        int iItem;

        iItem = ListBox_GetCurSel(hwnd);
        if (iItem >= 0) {
            PVLISTITEM pitem = (PV)ListBox_GetItemData(hwnd, iItem);
            if (pitem) {
                HWND hdlg = Vlist_FindChild(hwnd, pitem->pvtbl);
                
                if( hdlg ) {
                    pitem->pvtbl->PreDisplay(hdlg, pitem);
    
                    /*
                     *  Out with the old, in with the new.
                     */
                    if (pvi->hdlgVis != hdlg) {
                        if (pvi->hdlgVis) {
                            ShowWindow(pvi->hdlgVis, FALSE);
                        }
                        pvi->hdlgVis = hdlg;
                        ShowWindow(pvi->hdlgVis, TRUE);
                    }
                }
            }
        }
    }
}

/*****************************************************************************
 *
 *      Vlist_OnDestroy
 *
 *      Clean up a Vlist.
 *
 *****************************************************************************/

void EXTERNAL
Vlist_OnDestroy(HWND hwndList)
{
    PVLISTINFO pvi;
    HWND hwnd;
    int iItem, cItem;

    /*
     *  Empty the listbox.
     */
    cItem = ListBox_GetCount(hwndList);
    for (iItem = 0; iItem < cItem; iItem++) {
        PVLISTITEM pitem = (PV)ListBox_GetItemData(hwndList, iItem);
        if (pitem) {
            VlistItem_Destroy(pitem);
        }
    }
    ListBox_ResetContent(hwndList);

    /*
     *  Toss our instance data.
     */
    pvi = (PVLISTINFO)GetWindowLongPtr(hwndList, GWLP_USERDATA);
    if (pvi) {
        LocalFree(pvi);
        SetWindowLongPtr(hwndList, GWLP_USERDATA, 0);
    }

    /*
     *  Kill the child dialogs we created.
     */

    while ((hwnd = GetWindow(hwndList, GW_HWNDNEXT)) &&
           GetWindowLongPtr(hwnd, GWLP_USERDATA)) {
        DestroyWindow(hwnd);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\diquick\diqvrang.c ===
/*****************************************************************************
 *
 *      diqvrang.c
 *
 *      VList plug-in that does ranges.
 *
 *****************************************************************************/

#include "diquick.h"

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *      VLISTRANGE
 *
 *      range-specific goo.
 *
 *****************************************************************************/

typedef struct VLISTRANGE {

    VLISTITEM item;

    DIPROPRANGE diprg;
    int iRadix;

    /*
     *  If non-NULL, then this is a read/write control.
     */
    PROPUPDATEPROC Update;
    PV pvRef1;
    PV pvRef2;

} VLISTRANGE, *PVLISTRANGE;

/*****************************************************************************
 *
 *      VRange_InitUD
 *
 *      Common updown initialization goo.
 *
 *****************************************************************************/

void INTERNAL
VRange_InitUD(HWND hwndUD, PVLISTRANGE pvrg, int iValue)
{
    ShowWindow(hwndUD, pvrg->Update ? SW_SHOW : SW_HIDE);

    UpDown_SetRange(hwndUD, 0x80000000, 0x7FFFFFFF);

    UpDown_SetPos(hwndUD, pvrg->iRadix, iValue);

    Edit_SetReadOnly(GetWindow(hwndUD, GW_HWNDPREV), !pvrg->Update);
}


/*****************************************************************************
 *
 *      VRange_PreDisplay
 *
 *      Set the edit control text and let the dialog know who it is in
 *      charge of.
 *
 *****************************************************************************/

void INTERNAL
VRange_PreDisplay(HWND hdlg, PV pv)
{
    PVLISTRANGE pvrg = pv;
    HWND hwndUD;

    hwndUD = GetDlgItem(hdlg, IDC_VRANGE_MINUD);
    VRange_InitUD(hwndUD, pvrg, pvrg->diprg.lMin);

    hwndUD = GetDlgItem(hdlg, IDC_VRANGE_MAXUD);
    VRange_InitUD(hwndUD, pvrg, pvrg->diprg.lMax);

    ShowWindow(GetDlgItem(hdlg, IDC_VRANGE_APPLY),
               pvrg->Update ? SW_SHOW : SW_HIDE);

    CheckRadioButton(hdlg, IDC_VRANGE_DEC, IDC_VRANGE_HEX,
                     pvrg->iRadix == 10 ? IDC_VRANGE_DEC : IDC_VRANGE_HEX);

    SetDialogPtr(hdlg, pvrg);

}

/*****************************************************************************
 *
 *      VRange_Destroy
 *
 *      Nothing to clean up.
 *
 *****************************************************************************/

void INTERNAL
VRange_Destroy(PV pv)
{
    PVLISTRANGE pvrg = pv;
}

/*****************************************************************************
 *
 *      VRange_OnInitDialog
 *
 *      Limit the strings to MAX_PATH characters.
 *
 *****************************************************************************/

BOOL INTERNAL
VRange_OnInitDialog(HWND hdlg)
{
    HWND hwndEdit;

    hwndEdit = GetDlgItem(hdlg, IDC_VRANGE_MIN);
    Edit_LimitText(hwndEdit, CCHMAXINT);

    hwndEdit = GetDlgItem(hdlg, IDC_VRANGE_MAX);
    Edit_LimitText(hwndEdit, CCHMAXINT);

    return TRUE;
}

/*****************************************************************************
 *
 *      VRange_OnApply
 *
 *      Read the value (tricky if hex mode) and call the Update.
 *
 *****************************************************************************/

void INLINE
VRange_OnApply(HWND hdlg, PVLISTRANGE pvrg)
{
    pvrg->Update(&pvrg->diprg.diph, pvrg->pvRef1, pvrg->pvRef2);
}

/*****************************************************************************
 *
 *      VRange_GetValue
 *
 *****************************************************************************/

void INTERNAL
VRange_GetValue(HWND hdlg, PVLISTRANGE pvrg)
{
    HWND hwndUD;

    hwndUD = GetDlgItem(hdlg, IDC_VRANGE_MINUD);
    UpDown_GetPos(hwndUD, &pvrg->diprg.lMin);

    hwndUD = GetDlgItem(hdlg, IDC_VRANGE_MAXUD);
    UpDown_GetPos(hwndUD, &pvrg->diprg.lMax);

}

/*****************************************************************************
 *
 *      VRange_SetValue
 *
 *****************************************************************************/

void INTERNAL
VRange_SetValue(HWND hdlg, PVLISTRANGE pvrg)
{
    HWND hwndUD;

    hwndUD = GetDlgItem(hdlg, IDC_VRANGE_MINUD);
    UpDown_SetPos(hwndUD, pvrg->iRadix, pvrg->diprg.lMin);

    hwndUD = GetDlgItem(hdlg, IDC_VRANGE_MAXUD);
    UpDown_SetPos(hwndUD, pvrg->iRadix, pvrg->diprg.lMax);

}

/*****************************************************************************
 *
 *      VRange_SetRadix
 *
 *      Set a new radix by reading the old value, changing the radix,
 *      and writing out the new value.
 *
 *****************************************************************************/

void INTERNAL
VRange_SetRadix(HWND hdlg, PVLISTRANGE pvrg, int iRadix)
{
    VRange_GetValue(hdlg, pvrg);
    pvrg->iRadix = iRadix;
    VRange_SetValue(hdlg, pvrg);
}

/*****************************************************************************
 *
 *      VRange_OnCommand
 *
 *      If they changed the radix, then change it.
 *
 *      If they pressed Apply, then apply it.
 *
 *****************************************************************************/

BOOL INTERNAL
VRange_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    PVLISTRANGE pvrg = GetDialogPtr(hdlg);

    switch (id) {

    case IDC_VRANGE_DEC:
        VRange_SetRadix(hdlg, pvrg, 10);
        return TRUE;

    case IDC_VRANGE_HEX:
        VRange_SetRadix(hdlg, pvrg, 16);
        return TRUE;

    case IDC_VRANGE_APPLY:
        VRange_GetValue(hdlg, pvrg);
        VRange_OnApply(hdlg, pvrg);
        return TRUE;
    }
    return FALSE;
}

/*****************************************************************************
 *
 *      VRange_DlgProc
 *
 *      Nothing really happens here.  The real work is done externally.
 *
 *****************************************************************************/

INT_PTR CALLBACK
VRange_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_INITDIALOG:
        return VRange_OnInitDialog(hdlg);

    case WM_COMMAND:
        return VRange_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wp, lp),
                             (UINT)GET_WM_COMMAND_CMD(wp, lp));
    }

    return FALSE;
}

/*****************************************************************************
 *
 *      c_vvtblInt
 *
 *      Our vtbl.
 *
 *****************************************************************************/

const VLISTVTBL c_vvtblRange = {
    VRange_PreDisplay,
    VRange_Destroy,
    IDD_VAL_RANGE,
    VRange_DlgProc,
};

/*****************************************************************************
 *
 *      VRange_Create
 *
 *      Make a vlist item that tracks a string.
 *
 *****************************************************************************/

PVLISTITEM EXTERNAL
VRange_Create(LPDIPROPRANGE pdiprg, int iRadix,
              PROPUPDATEPROC Update, PV pvRef1, PV pvRef2)
{
    PVLISTRANGE pvrg = LocalAlloc(LPTR, cbX(VLISTRANGE));

    if (pvrg) {
        pvrg->item.pvtbl = &c_vvtblRange;
        pvrg->diprg = *pdiprg;
        pvrg->iRadix = iRadix;
        pvrg->Update = Update;
        pvrg->pvRef1 = pvRef1;
        pvrg->pvRef2 = pvRef2;
    }

    return (PV)pvrg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\assert.c ===
/*****************************************************************************
 *
 *  Assert.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Assertions and squirties.
 *
 *  Contents:
 *
 *      SquirtSqflPtszV
 *      AssertPtszPtszLn
 *      ArgsPalPszV
 *      EnterSqflPszPal
 *      ExitSqflPalHresPpv
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef XDEBUG

/*****************************************************************************
 *
 *      WarnPszV
 *
 *      Display a message, suitable for framing.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

CHAR c_szPrefix[] = "DINPUT: ";

#pragma END_CONST_DATA

void EXTERNAL
WarnPszV(LPCSTR ptsz, ...)
{
    va_list ap;
    CHAR sz[1024];

    lstrcpyA(sz, c_szPrefix);
    va_start(ap, ptsz);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,ptsz);									// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))					// find each %p
			*(psz+1) = 'x';									// replace each %p with %x
		wvsprintfA(sz + cA(c_szPrefix) - 1, szDfs, ap);		// use the local format string
	}
#else
	{
	    wvsprintfA(sz + cA(c_szPrefix) - 1, ptsz, ap);
	}
#endif
    va_end(ap);
    lstrcatA(sz, "\r\n");
    OutputDebugStringA(sz);
}

#endif

#ifdef DEBUG

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

BYTE g_rgbSqfl[sqflMaxArea];

extern TCHAR g_tszLogFile[];

/*****************************************************************************
 *
 *      Sqfl_Init
 *
 *      Load our initial Sqfl settings from win.ini[debug].
 *
 *      We take one sqfl for each area, of the form
 *
 *      dinput.n=v
 *
 *      where n = 0, ..., sqflMaxArea-1, and where v is one of the
 *      hiword sqfl values.
 *
 *      The default value for all areas is to squirt only errors.
 *
 *****************************************************************************/

void EXTERNAL
Sqfl_Init(void)
{
    int sqfl;
    TCHAR tsz[20];

    sqfl = 0x0;
    wsprintf(tsz, TEXT("dinput"));
    g_rgbSqfl[sqfl] = (BYTE)
                      GetProfileInt(TEXT("DEBUG"), tsz, HIWORD(0x0));

    for (sqfl = 0; sqfl < sqflMaxArea; sqfl++) {
        wsprintf(tsz, TEXT("dinput.%d"), sqfl);
        g_rgbSqfl[sqfl] = (BYTE)
                          GetProfileInt(TEXT("DEBUG"), tsz, g_rgbSqfl[0]);
    }

}

/*****************************************************************************
 *
 *      SquirtPtsz
 *
 *      Squirt a message to the debugger and maybe a log file.
 *
 *****************************************************************************/

void INTERNAL
SquirtPtsz(LPCTSTR ptsz)
{
    OutputDebugString(ptsz);
    if (g_tszLogFile[0]) {
        HANDLE h = CreateFile(g_tszLogFile, GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (h != INVALID_HANDLE_VALUE) {
#ifdef UNICODE
            CHAR szBuf[1024];
#endif
            SetFilePointer(h, 0, 0, FILE_END);
#ifdef UNICODE
            _lwrite((HFILE)(UINT_PTR)h, szBuf, UToA(szBuf, cA(szBuf), ptsz));
#else
            _lwrite((HFILE)(UINT_PTR)h, ptsz, cbCtch(lstrlen(ptsz)));
#endif
            CloseHandle(h);
        }
    }
}

/*****************************************************************************
 *
 *      SquirtPtszA
 *
 *      Squirt an ANSI message to the debugger and maybe a log file.
 *
 *****************************************************************************/

#ifdef UNICODE

void INTERNAL
SquirtPtszA(LPCSTR psz)
{
    OutputDebugStringA(psz);
    if (g_tszLogFile[0]) {
        HANDLE h = CreateFile(g_tszLogFile, GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (h != INVALID_HANDLE_VALUE) {
            _lwrite((HFILE)(UINT_PTR)h, psz, cbCch(lstrlenA(psz)));
            CloseHandle(h);
        }
    }
}

#else

#define SquirtPtszA                 SquirtPtsz

#endif

/*****************************************************************************
 *
 *      SquirtSqflPtszV
 *
 *      Squirt a message with a trailing crlf.
 *
 *****************************************************************************/

void EXTERNAL
SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...)
{
    if (IsSqflSet(sqfl)) {
        va_list ap;
        TCHAR tsz[1024];
        va_start(ap, ptsz);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,ptsz);					// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))	// find each %p
			*(psz+1) = 'x';					// replace each %p with %x
        wvsprintf(tsz, szDfs, ap);    		// use the local format string
	}
#else
	{
        wvsprintf(tsz, ptsz, ap);
	}
#endif
        va_end(ap);
        lstrcat(tsz, TEXT("\r\n"));
        SquirtPtsz(tsz);
    }
}

/*****************************************************************************
 *
 *      AssertPtszPtszLn
 *
 *      Something bad happened.
 *
 *****************************************************************************/

int EXTERNAL
AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine)
{
    SquirtSqflPtszV(sqflAlways, TEXT("Assertion failed: `%s' at %s(%d)"),
                    ptszExpr, ptszFile, iLine);
    DebugBreak();
    return 0;
}

/*****************************************************************************
 *
 *      Procedure call tracing is gross because of the C preprocessor.
 *
 *      Oh, if only we had support for m4...
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      dwSafeGetPdw
 *
 *      Deference a dword, but don't barf if the dword is bad.
 *
 *****************************************************************************/

DWORD INTERNAL
dwSafeGetPdw(LPDWORD pdw)
{
    if (IsBadReadPtr(pdw, cbX(*pdw))) {
        return 0xBAADBAAD;
    } else {
        return *pdw;
    }
}

/*****************************************************************************
 *
 *      ArgsPszV
 *
 *      Collect arguments to a procedure.
 *
 *      psz -> ASCIIZ format string
 *      ... = argument list
 *
 *      The characters in the format string are listed in EmitPal.
 *
 *****************************************************************************/

void EXTERNAL
ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...)
{
    va_list ap;
    va_start(ap, psz);
    if (psz) {
        PPV ppv;
        pal->pszFormat = psz;
        for (ppv = pal->rgpv; *psz; psz++) {
            *ppv++ = va_arg(ap, PV);
        }
    } else {
        pal->pszFormat = "";
    }
}

/*****************************************************************************
 *
 *      EmitPal
 *
 *      OutputDebugString the information, given a pal.  No trailing
 *      carriage return is emitted.
 *
 *      pal      -> place where info was saved
 *
 *      Format characters:
 *
 *      p   - 32-bit flat pointer
 *      x   - 32-bit hex integer
 *      s   - TCHAR string
 *      S   - SCHAR string
 *      A   - ANSI string
 *      W   - UNICODE string
 *      G   - GUID
 *      u   - unsigned integer
 *      C   - clipboard format
 *
 *****************************************************************************/

void INTERNAL
EmitPal(PARGLIST pal)
{
    char sz[MAX_PATH];
    int i;
    SquirtPtszA(pal->pszProc);
    SquirtPtsz(TEXT("("));
    for (i = 0; pal->pszFormat[i]; i++) {
        if (i) {
            SquirtPtsz(TEXT(", "));
        }
        switch (pal->pszFormat[i]) {

        case 'p':                               /* 32-bit flat pointer */
// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
#ifdef WIN95
            wsprintfA(sz, "%x", pal->rgpv[i]);
#else
            wsprintfA(sz, "%p", pal->rgpv[i]);
#endif
            SquirtPtszA(sz);
            break;

        case 'x':                               /* 32-bit hex */
            wsprintfA(sz, "%x", pal->rgpv[i]);
            SquirtPtszA(sz);
            break;

        case 's':                               /* TCHAR string */
            if (pal->rgpv[i] && lstrlen(pal->rgpv[i])) {
                SquirtPtsz(pal->rgpv[i]);
            }
            break;

#ifdef  UNICODE
        case 'S':                               /* SCHAR string */
#endif
        case 'A':                               /* ANSI string */
            if (pal->rgpv[i] && lstrlenA(pal->rgpv[i])) {
                SquirtPtszA(pal->rgpv[i]);
            }
            break;

#ifndef UNICODE
        case 'S':                               /* SCHAR string */
#endif
        case 'W':                               /* UNICODE string */
            if (pal->rgpv[i] && lstrlenW(pal->rgpv[i])) {
#ifdef  UNICODE
                OutputDebugStringW(pal->rgpv[i]);
#else
                UToA(sz, cA(sz), pal->rgpv[i]);
                SquirtPtszA(sz);
#endif
            }
            break;

        case 'G':                               /* GUID */
#if 1
			// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            wsprintfA(sz, "%p",
                      HIWORD((DWORD)(UINT_PTR)pal->rgpv[i])
                        ? dwSafeGetPdw((LPDWORD)pal->rgpv[i])
                        : (UINT_PTR)pal->rgpv[i]);
            SquirtPtszA(sz);
#else
            if( HIWORD((DWORD)(UINT_PTR)pal->rgpv[i]) 
              && !(IsBadReadPtr( pal->rgpv[i], cbX(pal->rgpv[i]) ) ) )
            {
                NameFromGUID( (PTCHAR)sz, pal->rgpv[i] );
#ifdef UNICODE
                SquirtPtsz( &((PWCHAR)sz)[ctchNamePrefix]);
#else
                SquirtPtszA( &sz[ctchNamePrefix] );
#endif
            }
            else
            {
				// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
                wsprintfA(sz, "%p",(UINT_PTR)pal->rgpv[i]);
                SquirtPtszA(sz);
            }
#endif
            break;

        case 'u':                               /* 32-bit unsigned decimal */
            wsprintfA(sz, "%u", pal->rgpv[i]);
            SquirtPtszA(sz);
            break;

        case 'C':
            if (GetClipboardFormatNameA((UINT)(UINT_PTR)pal->rgpv[i], sz, cA(sz))) {
            } else {
                wsprintfA(sz, "[%04x]", pal->rgpv[i]);
            }
            SquirtPtszA(sz);
            break;

        default: AssertF(0);                    /* Invalid */
        }
    }
    SquirtPtsz(TEXT(")"));
}

/*****************************************************************************
 *
 *      EnterSqflPtsz
 *
 *      Mark entry to a procedure.  Arguments were already collected by
 *      ArgsPszV.
 *
 *      If sqfl contains the sqflBenign flag, then any error we detect
 *      should be classified as sqflBenign and not sqflError.
 *
 *      sqfl     -> squirty flags
 *      pszProc  -> procedure name
 *      pal      -> place to save the name and get the format/args
 *
 *****************************************************************************/

void EXTERNAL
EnterSqflPszPal(SQFL sqfl, LPCSTR pszProc, PARGLIST pal)
{
    pal->pszProc = pszProc;
    sqfl |= sqflIn;
    if (IsSqflSet(sqfl)) {
        EmitPal(pal);
        SquirtPtsz(TEXT("\r\n"));
    }
}

void EXTERNAL
ExitSqflPalHresPpv(SQFL sqfl, PARGLIST pal, HRESULT hres, PPV ppvObj)
{
    BOOL fInternalError;
    SQFL sqflIsError;
    DWORD le = GetLastError();

    if (sqfl & sqflBenign) {
        sqfl &= ~sqflBenign;
        sqflIsError = sqflBenign;
    } else {
        sqflIsError = sqflError;
    }

    sqfl |= sqflOut;
    fInternalError = 0;
    if (ppvObj == ppvVoid || ppvObj == ppvDword) {
    } else if (ppvObj == ppvBool) {
        if (hres == 0) {
            sqfl |= sqflIsError;
        }
    } else {
        if (FAILED(hres)) {
            if (fLimpFF(ppvObj && !IsBadWritePtr(ppvObj, cbX(*ppvObj)),
                        *ppvObj == 0)) {
            } else {
                fInternalError = 1;
            }
            if (hres == E_NOTIMPL) {    /* E_NOTIMPL is always benign */
                sqfl |= sqflBenign;
            } else {
                sqfl |= sqflIsError;
            }
        }
    }

    if (IsSqflSet(sqfl) || fInternalError) {
        EmitPal(pal);
        SquirtPtsz(TEXT(" -> "));
        if (ppvObj != ppvVoid) {
            TCHAR tszBuf[32];
            wsprintf(tszBuf, TEXT("%08x"), hres);
            SquirtPtsz(tszBuf);
            if (HIWORD((UINT_PTR)ppvObj)) {
                wsprintf(tszBuf, TEXT(" [%08x]"),
                         dwSafeGetPdw((LPDWORD)ppvObj));
                SquirtPtsz(tszBuf);
            } else if (ppvObj == ppvDword) {
                wsprintf(tszBuf, TEXT(" [%08x]"), hres);
                SquirtPtsz(tszBuf);
            } else if (ppvObj == ppvBool) {
                wsprintf(tszBuf, hres ? TEXT(" OK ") :
                                 TEXT(" le=[%d]"), le);
                SquirtPtsz(tszBuf);
            }
        }
        SquirtPtsz(TEXT("\r\n"));
        AssertF(!fInternalError);
    }

    /*
     *  This redundant test prevents a breakpoint on SetLastError()
     *  from being hit constantly.
     */
    if (le != GetLastError()) {
        SetLastError(le);
    }
}

#endif

#ifdef XDEBUG

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | Random |
 *
 *          Returns a pseudorandom dword.  The value doesn't need to be
 *          statistically wonderful.
 *
 *  @returns
 *          A not very random dword.
 *
 *****************************************************************************/

DWORD s_dwRandom = 1;                   /* Random number seed */

DWORD INLINE
Random(void)
{
    s_dwRandom = s_dwRandom * 214013 + 2531011;
    return s_dwRandom;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ScrambleBuf |
 *
 *          Fill a buffer with garbage.  Used in RDEBUG to make sure
 *          the caller is not relying on buffer data.
 *
 *          Note: If the buffer is not a multiple of dwords in size,
 *          the leftover bytes are not touched.
 *
 *  @parm   OUT LPVOID | pv |
 *
 *          The buffer to be scrambled.
 *
 *  @parm   UINT | cb |
 *
 *          The size of the buffer.
 *
 *****************************************************************************/

void EXTERNAL
ScrambleBuf(LPVOID pv, UINT cb)
{
    UINT idw;
    UINT cdw = cb / 4;
    LPDWORD pdw = pv;
    for (idw = 0; idw < cdw; idw++) {
        pdw[idw] = Random();
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ScrambleBit |
 *
 *          Randomly set or clear a bit.
 *
 *  @parm   OUT LPDWORD | pdw |
 *
 *          The dword whose bit is to be set randomly.
 *
 *  @parm   UINT | flMask |
 *
 *          Mask for the bits to scramble.
 *
 *****************************************************************************/

void EXTERNAL ScrambleBit(LPDWORD pdw, DWORD flMask)
{
    *pdw ^= (*pdw ^ Random()) & flMask;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | Callback_CompareContexts |
 *
 *          Check if two <t CONTEXT> structures are substantially the same
 *          to the extent required by the Win32 calling convention.
 *
 *          This is necessary because lots of applications pass
 *          incorrectly prototyped functions as callbacks.  Others will
 *          write callback functions that trash registers that are
 *          supposed to be nonvolatile.
 *
 *          NOTE!  Platform-dependent code!
 *
 *  @parm   LPCONTEXT | pctx1 |
 *
 *          Context structure before we call the callback.
 *
 *  @parm   LPCONTEXT | pctx2 |
 *
 *          Context structure after we call the callback.
 *
 *  @returns
 *
 *          Nonzero if the two contexts are substantially the same.
 *
 *****************************************************************************/

BOOL INLINE  
Callback_CompareContexts(LPCONTEXT pctx1, LPCONTEXT pctx2)
{
#if defined(_X86_)
    return pctx1->Esp == pctx2->Esp;            /* Stack pointer */
  #if 0
    /*
     *  Can't test these registers because Win95 doesn't preserve
     *  them properly.  GetThreadContext() stashes what happens to
     *  be in the registers when you finally reach the bowels of
     *  kernel, at which point who knows what they contain...
     */
           pctx1->Ebx == pctx2->Ebx &&          /* Nonvolatile registers */
           pctx1->Esi == pctx2->Esi &&
           pctx1->Edi == pctx2->Edi &&
           pctx1->Ebp == pctx2->Ebp;
  #endif

#elif defined(_AMD64_)

    return pctx1->Rbx == pctx2->Rbx &&
           pctx1->Rbp == pctx2->Rbp &&
           pctx1->Rsp == pctx2->Rsp &&
           pctx1->Rdi == pctx2->Rdi &&
           pctx1->Rsi == pctx2->Rsi &&
           pctx1->R12 == pctx2->R12 &&
           pctx1->R13 == pctx2->R13 &&
           pctx1->R14 == pctx2->R14 &&
           pctx1->R15 == pctx2->R15;

#elif defined(_IA64_)

    return pctx1->IntSp == pctx2->IntSp &&      /* Stack pointer */
           pctx1->RsBSP == pctx2->RsBSP &&      /* Backing store pointer */
           pctx1->IntS0 == pctx2->IntS0 &&      /* Nonvolatile registers */
           pctx1->IntS1 == pctx2->IntS1 &&
           pctx1->IntS2 == pctx2->IntS2 &&
           pctx1->IntS3 == pctx2->IntS3;

#else
#error "No Target Architecture"
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | Callback |
 *
 *          Perform a callback the paranoid way, checking that the
 *          application used the correct calling convention and preserved
 *          all nonvolatile registers.
 *
 *          NOTE!  Platform-dependent code!
 *
 *  @parm   DICALLBACKPROC | pfn |
 *
 *          Procedure to call back.
 *
 *  @parm   PV | pv1 |
 *
 *          First parameter to callback.
 *
 *  @parm   PV | pv2 |
 *
 *          Second parameter to callback.
 *
 *  @returns
 *
 *          Whatever the callback returns.
 *
 *****************************************************************************/

BOOL EXTERNAL
Callback(DICALLBACKPROC pfn, PV pv1, PV pv2)
{
    CONTEXT ctxPre;             /* Thread context before call */
    CONTEXT ctxPost;            /* Thread context after call */
    volatile BOOL fRc;          /* To prevent compiler from enregistering */

    /* Get state of registers before the callback */
    ctxPre.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
    GetThreadContext(GetCurrentThread(), &ctxPre);

    fRc = pfn(pv1, pv2);

    ctxPost.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
    if (GetThreadContext(GetCurrentThread(), &ctxPost) &&
        !Callback_CompareContexts(&ctxPre, &ctxPost)) {
        RPF("DINPUT: Incorrectly prototyped callback! Crash soon!");
        ValidationException();
    }

    return fRc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\common.c ===
/*****************************************************************************
 *
 *  Common.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Shared stuff that operates on all classes
 *
 *      This version of the common services supports multiple
 *      inheritance natively.  You can pass any interface of an object,
 *      and the common services will do the right thing.
 *
 *  Contents:
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflCommon

/*****************************************************************************
 *
 *  USAGE FOR OLE OBJECTS
 *
 *      Suppose you want to implement an object called CObj that supports
 *      the interfaces Foo, Bar, and Baz.  Suppose that you opt for
 *      Foo as the primary interface.
 *
 *      >> NAMING CONVENTION <<
 *
 *          COM objects begin with the letter "C".
 *
 *      (1) Declare the primary and secondary vtbls.
 *
 *              Primary_Interface(CObj, IFoo);
 *              Secondary_Interface(CObj, IBar);
 *              Secondary_Interface(CObj, IBaz);
 *
 *      (3) Declare the object itself.
 *
 *              typedef struct CObj {
 *                  IFoo        foo;        // Primary must come first
 *                  IBar        bar;
 *                  IBaz        baz;
 *                  ... other fields ...
 *              } CObj;
 *
 *      (4) Implement the methods.
 *
 *          You may *not* reimplement the AddRef and Release methods!
 *          although you can subclass them.
 *
 *      (5) To allocate an object of the appropriate type, write
 *
 *              hres = Common_NewRiid(CObj, punkOuter, riid, ppvOut);
 *
 *          or, if the object is variable-sized,
 *
 *              hres = Common_NewCbRiid(cb, CObj, punkouter, riid, ppvOut);
 *
 *          Common_NewRiid and Common_NewCbRiid will initialize both the
 *          primary and secondary vtbls.
 *
 *      (6) Define the object signature.
 *
 *              #pragma BEGIN_CONST_DATA
 *
 *              #define CObj_Signature        0x204A424F      // "OBJ "
 *
 *      (7) Define the object template.
 *
 *              Interface_Template_Begin(CObj)
 *                  Primary_Interface_Template(CObj, IFoo)
 *                Secondary_Interface_Template(CObj, IBar)
 *                Secondary_Interface_Template(CObj, IBaz)
 *              Interface_Template_End(CObj)
 *
 *      (8) Define the interface descriptors.
 *
 *              // The macros will declare QueryInterface, AddRef and Release
 *              // so don't list them again
 *
 *              Primary_Interface_Begin(CObj, IFoo)
 *                  CObj_FooMethod1,
 *                  CObj_FooMethod2,
 *                  CObj_FooMethod3,
 *                  CObj_FooMethod4,
 *              Primary_Interface_End(Obj, IFoo)
 *
 *              Secondary_Interface_Begin(CObj, IBar, bar)
 *                  CObj_Bar_BarMethod1,
 *                  CObj_Bar_BarMethod2,
 *              Secondary_Interface_Begin(CObj, IBar, bar)
 *
 *              Secondary_Interface_Begin(CObj, IBaz, baz)
 *                  CObj_Baz_BazMethod1,
 *                  CObj_Baz_BazMethod2,
 *                  CObj_Baz_BazMethod3,
 *              Secondary_Interface_Begin(CObj, IBaz, baz)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  USAGE FOR NON-OLE OBJECTS
 *
 *      All objects are COM objects, even if they are never given out.
 *      In the simplest case, it just derives from IUnknown.
 *
 *      Suppose you want to implement an object called Obj which is
 *      used only internally.
 *
 *      (1) Declare the vtbl.
 *
 *              Simple_Interface(Obj);
 *
 *      (3) Declare the object itself.
 *
 *              typedef struct Obj {
 *                  IUnknown unk;
 *                  ... other fields ...
 *              } Obj;
 *
 *      (4) Implement the methods.
 *
 *          You may *not* override the QueryInterface, AddRef or
 *          Release methods!
 *
 *      (5) Allocating an object of the appropriate type is the same
 *          as with OLE objects.
 *
 *      (6) Define the "vtbl".
 *
 *              #pragma BEGIN_CONST_DATA
 *
 *              Simple_Interface_Begin(Obj)
 *              Simple_Interface_End(Obj)
 *
 *          That's right, nothing goes between the Begin and the End.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      CommonInfo
 *
 *      Information tracked for all common objects.
 *
 *      A common object looks like this:
 *
#if DIRECTINPUT_VERSION > 0x0300
 *                          rgvtbl
 *                          cbvtbl
 *            D(dwSig)      QIHelper
 *              cHoldRef    AppFinalizeProc
 *              cRef        FinalizeProc
 *              punkOuter   riid
 *              unkPrivate  0
 *      pFoo -> lpVtbl ->   QueryInterface
 *              lpVtbl2     Common_AddRef
 *              data        Common_Release
 *              ...         ...
#else
 *                          rgvtbl
 *                          cbvtbl
 *            D(dwSig)      QIHelper
 *              cRef        FinalizeProc
 *              punkOuter   riid
 *              unkPrivate  0
 *      pFoo -> lpVtbl ->   QueryInterface
 *              lpVtbl2     Common_AddRef
 *              data        Common_Release
 *              ...         ...
 *
 *      Essentially, we use the otherwise-unused space above the
 *      pointers to record our bookkeeping information.
 *
 *      punkOuter    = controlling unknown, if object is aggregated
 *      lpvtblPunk   = special vtbl for controlling unknown to use
 *      cHoldRef     = Total reference count, including holds
#if DIRECTINPUT_VERSION > 0x0300
 *      cRef         = object reference count from application
#else
 *      cRef         = object reference count
#endif
 *      riid         = object iid
 *      rgvtbl       = array of vtbls of supported interfaces
 *      cbvtbl       = size of array in bytes
 *      QIHelper     = QueryInterface helper for aggregation
 *      AppFinalizeProc = Finalization procedure when app does last Release
 *      FinalizeProc = Finalization procedure
 *
 *      For secondary interfaces, it looks like this:
 *
 *                        riid
 *                        offset to primary interface
 *      pFoo -> lpVtbl -> Forward_QueryInterface
 *                        Forward_AddRef
 *                        Forward_Release
 *                        ...
 *
#if DIRECTINPUT_VERSION > 0x0300
 *
 *      What is a hold?
 *
 *      There is this annoying situation (particularly with
 *      IDirectInputDevice) where an object wants to prevent itself
 *      from being destroyed but we don't want to do an AddRef.
 *
 *      The classic case (and for now the only one) is an
 *      IDirectInputDevice which has been acquired.  If we did
 *      an honest AddRef() on the Acquire(), and the application does
 *      a Release() without Unacquire()ing, then the device would
 *      be acquired forever.
 *
 *      If you thought that the Unacquire() in the finalization
 *      would help, you'd be wrong, because the finalization happens
 *      only when the last reference goes away, but the last reference
 *      belongs to the device itself and will never go away until
 *      the Unacquire() happens, which can't happen because the app
 *      already lost its last reference to the device.
 *
 *      So instead, we need to maintain *two* refcounts.
 *
 *      cRef is the application-visible reference count, accessible
 *      via PrivateAddRef() and PrivateRelease().  When this
 *      drops to zero, we call the AppFinalize().
 *
 *      cHoldRef is the "real" reference count.  This is the sum of
 *      cRef and the number of outstanding Common_Hold()s.  When
 *      this drops to zero, then the object is Finalize()d.
 *
#endif
 *
 *****************************************************************************/

/* WARNING!  cin_dwSig must be first:  ci_Start relies on it */
/* WARNING!  cin_unkPrivate must be last: punkPrivateThis relies on it */

typedef struct CommonInfoN {        /* This goes in front of the object */
 RD(ULONG cin_dwSig;)               /* Signature (for parameter validation) */
#if DIRECTINPUT_VERSION > 0x0300
    LONG cin_cHoldRef;             /* Total refcount, incl. holds */
#endif
    LONG cin_cRef;                 /* Object reference count */
    PUNK cin_punkOuter;             /* Controlling unknown */
    IUnknown cin_unkPrivate;        /* Private IUnknown */
} CommonInfoN, CIN, *PCIN;

typedef struct CommonInfoP {        /* This is how we pun the object itself */
    PREVTBLP *cip_prevtbl;          /* Vtbl of object (will be -1'd) */
} CommonInfoP, CIP, *PCIP;

typedef union CommonInfo {
    CIN cin[1];
    CIP cip[1];
} CommonInfo, CI, *PCI;

#define ci_dwSig        cin[-1].cin_dwSig
#define ci_cHoldRef     cin[-1].cin_cHoldRef
#define ci_cRef         cin[-1].cin_cRef
#define ci_punkOuter    cin[-1].cin_punkOuter
#define ci_unkPrivate   cin[-1].cin_unkPrivate
#define ci_rgfp         cip[0].cip_prevtbl

#define ci_tszClass     cip[0].cip_prevtbl[-1].tszClass
#define ci_rgvtbl       cip[0].cip_prevtbl[-1].rgvtbl
#define ci_cbvtbl       cip[0].cip_prevtbl[-1].cbvtbl
#define ci_QIHelper     cip[0].cip_prevtbl[-1].QIHelper
#define ci_AppFinalize  cip[0].cip_prevtbl[-1].AppFinalizeProc
#define ci_Finalize     cip[0].cip_prevtbl[-1].FinalizeProc
#define ci_riid         cip[0].cip_prevtbl[-1].prevtbl.riid
#define ci_lib          cip[0].cip_prevtbl[-1].prevtbl.lib

#ifdef XDEBUG
#define ci_Start        ci_dwSig
#else
#define ci_Start        ci_cRef
#endif

#define ci_dwSignature  0x38162378              /* typed by my cat */

/*****************************************************************************
 *
 *      Common_Finalize (from Common_Release)
 *
 *      By default, no finalization is necessary.
 *
 *****************************************************************************/

void EXTERNAL
Common_Finalize(PV pv)
{
    SquirtSqflPtszV(sqfl, TEXT("Common_Finalize(%08x)"), pv);
}

/*****************************************************************************
 *
 *      "Private" IUnknown methods
 *
 *      When a COM object is aggregated, it exports *two* IUnknown
 *      interfaces.
 *
 *      The "private" IUnknown is the one that is returned to the
 *      controlling unknown.  It is this unknown that the controlling
 *      unknown uses to manipulate the refcount on the inner object.
 *
 *      The "public" IUnknown is the one that all external callers see.
 *      For this, we just hand out the controlling unknown.
 *
 *****************************************************************************/

Secondary_Interface(CCommon, IUnknown);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PV | thisPunk |
 *
 *          Convert a private punk (&cin_unkPrivate) into the beginning of
 *          the actual object.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The private punk (&cin_unkPrivate) corresponding to some
 *          object we are managing.
 *
 *  @returns
 *
 *          The object pointer on success, or 0 on error.
 *
 *  @comm
 *
 *          We do not return an <t HRESULT> on error, because the
 *          callers of the procedure typically do not return
 *          <t HRESULT>s themselves.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define thisPunk_(punk, z)                                          \
       _thisPunk_(punk)                                             \

#endif

PV INLINE
thisPunk_(PUNK punkPrivate, LPCSTR s_szProc)
{
    PV pv;
    if (SUCCEEDED(hresFullValidPitf(punkPrivate, 0))) {
        if (punkPrivate->lpVtbl == Class_Vtbl(CCommon, IUnknown)) {
            pv = pvAddPvCb(punkPrivate,
                             cbX(CIN) - FIELD_OFFSET(CIN, cin_unkPrivate));
        } else {
            RPF("%s: Invalid parameter 0", s_szProc);
            pv = 0;
        }
    } else {
        RPF("%s: Invalid parameter 0", s_szProc);
        pv = 0;
    }
    return pv;
}

#define thisPunk(punk)                                              \
        thisPunk_(punk, s_szProc)                                   \


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Common_QIHelper |
 *
 *          Called when we can't find any interface in the standard list.
 *          See if there's a dynamic interface we can use.
 *
 *          Objects are expected to override this method if
 *          they implement dynamic interfaces.
 *
 *  @parm   PV | pv |
 *
 *          The object being queried.
 *
 *  @parm   RIID | riid |
 *
 *          The interface being requested.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *  @returns
 *
 *          Always returns <c E_NOINTERFACE>.
 *
 *****************************************************************************/

STDMETHODIMP
Common_QIHelper(PV pv, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    *ppvObj = NULL;
    hres = E_NOINTERFACE;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Common_PrivateQueryInterface |
 *
 *          Common implementation of <mf IUnknown::QueryInterface> for
 *          the "private <i IUnknown>".
 *
 *          Note that we AddRef through the public <i IUnknown>
 *          (<ie>, through the controlling unknown).
 *          That's part of the rules of aggregation,
 *          and we have to follow them in order to keep the controlling
 *          unknown from getting confused.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The object being queried.
 *
 *  @parm   RIID | riid |
 *
 *          The interface being requested.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      The "Ensure jump is to end" remark boils down to the fact that 
 *      compilers have failed to recognize this:
 *
 *      for (i = 0; i < n; i++) {
 *          if (cond) {
 *              mumble();
 *              break;
 *          }
 *      }
 *      if (i >= n) {
 *          gurgle();
 *      }
 *
 *      and turn it into this:
 *
 *      for (i = 0; i < n; i++) {
 *          if (cond) {
 *              mumble();
 *              goto done;
 *          }
 *      }
 *      gurgle();
 *      done:;
 *
 *      But even with this help, the compiler emits pretty dumb code.
 *
 *****************************************************************************/

STDMETHODIMP
Common_PrivateQueryInterface(PUNK punkPrivate, REFIID riid, PPV ppvObj)
{
    PCI pci;
    HRESULT hres;
    EnterProcR(IUnknown::QueryInterface, (_ "pG", punkPrivate, riid));

    pci = thisPunk(punkPrivate);
    if (pci) {
        if (IsEqualIID(riid, &IID_IUnknown)) {
            *ppvObj = pci;
            OLE_AddRef(pci->ci_punkOuter);
            hres = S_OK;
        } else {
            UINT ivtbl;
            for (ivtbl = 0; ivtbl * sizeof(PV) < pci->ci_cbvtbl; ivtbl++) {
                if (IsEqualIID(riid, ((PCI)(&pci->ci_rgvtbl[ivtbl]))->ci_riid)) {
                    *ppvObj = pvAddPvCb(pci, ivtbl * sizeof(PV));
                    OLE_AddRef(pci->ci_punkOuter);
                    hres = S_OK;
                    goto exit;          /* Ensure jump is to end */
                }
            }
            hres = pci->ci_QIHelper(pci, riid, ppvObj);
        }
    } else {
        hres = E_INVALIDARG;
    }

exit:;
    ExitOleProcPpv(ppvObj);
    return hres;
}

#if DIRECTINPUT_VERSION > 0x0300

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Common_FastHold |
 *
 *          Increment the object hold count inline.
 *
 *  @parm   PV | pvObj |
 *
 *          The object being held.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Common_Hold |
 *
 *          Increment the object hold count.
 *
 *  @parm   PV | pvObj |
 *
 *          The object being held.
 *
 *****************************************************************************/

void INLINE
Common_FastHold(PV pvObj)
{
    PCI pci = pvObj;

    InterlockedIncrement(&pci->ci_cHoldRef);

	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    D(SquirtSqflPtszV(sqflObj | sqflVerbose, 
                      TEXT("%s %p Common_FastHold ci_cRef(%d) ci_cHoldRef(%d)"),
                      pci->ci_tszClass,
                      pci,
                      pci->ci_cRef,
                      pci->ci_cHoldRef));
}

STDMETHODIMP_(void)
Common_Hold(PV pvObj)
{
    PCI pci = pvObj;
    AssertF(pvObj == _thisPv(pvObj));       /* Make sure it's the primary */
    AssertF(pci->ci_cHoldRef >= pci->ci_cRef);
    Common_FastHold(pvObj);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Common_FastUnhold |
 *
 *          Decrement the object hold count.  Assumes that the reference
 *          count is <y not> dropping to zero.
 *
 *  @parm   PV | pvObj |
 *
 *          The object being unheld.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Common_Unhold |
 *
 *          Decrement the object hold count.  If the hold count drops
 *          to zero, then the object is destroyed.
 *
 *  @parm   PV | pvObj |
 *
 *          The object being unheld.
 *
 *****************************************************************************/

void INLINE
Common_FastUnhold(PV pvObj)
{
    PCI pci = pvObj;

    AssertF(pci->ci_cHoldRef > 0);
    InterlockedDecrement(&pci->ci_cHoldRef);


	// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    D(SquirtSqflPtszV(sqflObj | sqflVerbose, TEXT("%s %p Common_FastUnHold  ci_cRef(%d) ci_cHoldRef(%d)"),
                      pci->ci_tszClass,
                      pci,
                      pci->ci_cRef,
                      pci->ci_cHoldRef));

}

STDMETHODIMP_(void)
Common_Unhold(PV pvObj)
{
    PCI pci = pvObj;

    AssertF(pci->ci_cHoldRef >= pci->ci_cRef);


    // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	D(SquirtSqflPtszV(sqflObj | sqflVerbose, TEXT("%s %p Common_Unhold  ci_cRef(%d) ci_cHoldRef(%d)"),
                    pci->ci_tszClass,
                    pci,
                    pci->ci_cRef,
                    pci->ci_cHoldRef-1));

    if (InterlockedDecrement(&pci->ci_cHoldRef) == 0) {

	  // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
      D(SquirtSqflPtszV(sqflObj | sqflVerbose, TEXT("Destroy %s %p "),
                        pci->ci_tszClass, 
                        pci));

        /*
         *  Last reference.  Do an artifical addref so that
         *  anybody who does an artificial addref during
         *  finalization won't accidentally destroy us twice.
         */
        pci->ci_cHoldRef = 1;
        pci->ci_Finalize(pci);
        /* Artificial release is pointless: we're being freed */

        FreePv(pvSubPvCb(pci, sizeof(CIN)));
        DllRelease();
    }
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_PrivateAddRef |
 *
 *          Increment the object refcount.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The object being addref'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_PrivateAddRef(PUNK punkPrivate)
{
    PCI pci;
    ULONG ulRef;
    EnterProcR(IUnknown::AddRef, (_ "p", punkPrivate));

    pci = thisPunk(punkPrivate);
    if (pci) {
#if DIRECTINPUT_VERSION <= 0x0300
        ulRef = ++pci->ci_cRef;
#else
        /*
         *  Don't let anyone AddRef from 0 to 1.  This happens if
         *  somebody does a terminal release, but we have an internal
         *  hold on the object, and the app tries to do an AddRef
         *  even though the object is "gone".
         *
         *  Yes, there is a race condition here, but it's not
         *  a big one, and this is only a rough test anyway.
         */
        if (pci->ci_cRef) {
            /*
             *  We must use an interlocked operation in case two threads
             *  do AddRef or Release simultaneously.  Note that the hold
             *  comes first, so that we never have the case where the
             *  hold count is less than the reference count.
             */
            Common_Hold(pci);
            InterlockedIncrement(&pci->ci_cRef);
            ulRef = pci->ci_cRef;

            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			D(SquirtSqflPtszV(sqflObj , TEXT("%s %p Common_PrivateAddref  ci_cRef(%d) ci_cHoldRef(%d)"),
                              pci->ci_tszClass,
                              pci,
                              pci->ci_cRef,
                              pci->ci_cHoldRef));
        } else {
            RPF("ERROR: %s: Attempting to addref a deleted object", s_szProc);
            ulRef = 0;
        }
#endif
    } else {
        ulRef = 0;
    }

    ExitProcX(ulRef);
    return ulRef;
}

#if DIRECTINPUT_VERSION <= 0x0300
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_PrivateRelease |
 *
 *          Decrement the object refcount.
 *
 *          If the object refcount drops to zero, finalize the object
 *          and free it, then decrement the dll refcount.
 *
 *          To protect against potential re-entrancy during finalization
 *          (in case finalization does an artificial
 *          <f AddRef>/<f Release>), we
 *          do our own artificial <f AddRef>/<f Release> up front.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The object being release'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_PrivateRelease(PUNK punkPrivate)
{
    PCI pci;
    ULONG ulRc;
    EnterProcR(IUnknown::Release, (_ "p", punkPrivate));

    pci = thisPunk(punkPrivate);
    if (pci) {

        /*
         *  Note that we don't actually decrement the refcount to
         *  zero (if that's where it's going).  This avoids a race
         *  condition in case somebody with a non-refcounted-reference
         *  to the object peeks at the refcount and gets confused
         *  because it is zero!
         */

        ulRc = pci->ci_cRef - 1;

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		D(SquirtSqflPtszV(sqflObj|sqflVerbose, TEXT("%s %p Common_PrivateRelease  ci_cRef(%d) ci_cHoldRef(%d)"),
                          pci->ci_tszClass,
                          pci,
                          ulRc,
                          pci->ci_cHoldRef));
        if (ulRc == 0) {
            /*
             *  Don't need artificial addref because we never actually
             *  dropped the refcount to zero.  We merely thought about
             *  it.
             */
            AssertF(pci->ci_cRef == 1);
            pci->ci_Finalize(pci);
            /* Artificial release is pointless: we're being freed */
            FreePv(pvSubPvCb(pci, sizeof(CIN)));
            DllRelease();
            ulRc = 0;
        } else {
            /*
             *  Not the last Release, so make this one count.
             */
            pci->ci_cRef = ulRc;
        }
    } else {
        ulRc = 0;
    }

    ExitProcX(ulRc);
    return ulRc;
}

#else

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_PrivateRelease |
 *
 *          Decrement the object refcount.  Note that decrementing
 *          the hold count may cause the object to vanish, so stash
 *          the resulting refcount ahead of time.
 *
 *          Note that we release the hold last, so that the hold
 *          count is always at least as great as the refcount.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The object being release'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_PrivateRelease(PUNK punkPrivate)
{
    PCI pci;
    ULONG ulRc;
    EnterProcR(IUnknown::Release, (_ "p", punkPrivate));

    pci = thisPunk(punkPrivate);
    if (pci) {
        LONG lRc;

        /*
         *  We must use an interlocked operation in case two threads
         *  do AddRef or Release simultaneously.  And if the count
         *  drops negative, then ignore it.  (This means that the
         *  app is Release()ing something too many times.)
         */

        lRc = InterlockedDecrement(&pci->ci_cRef);

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		D(SquirtSqflPtszV(sqflObj | sqflVerbose, TEXT("%s %p Common_PrivateRelease ci_cRef(%d) ci_cHoldRef(%d)"),
                          pci->ci_tszClass,
                          pci->ci_tszClass,
                          pci->ci_cRef,
                          pci->ci_cHoldRef));
        if (lRc > 0) {
            /*
             *  Not the last release; release the hold and return
             *  the resulting refcount.  Note that we can safely
             *  use a fast unhold here, because there will always
             *  be a hold lying around to match the refcount we
             *  just got rid of.
             */
            Common_FastUnhold(pci);

            /*
             *  This isn't 100% accurate, but it's close enough.
             *  (OLE notes that the value is good only for debugging.)
             */
            ulRc = pci->ci_cRef;

        } else if (lRc == 0) {
            /*
             *  That was the last application-visible reference.
             *  Do app-level finalization.
             */
            pci->ci_AppFinalize(pci);
            /*
             *  Note that we can't do
             *  a fast unhold here, because this might be the last
             *  hold.
             */
            Common_Unhold(pci);
            ulRc = 0;
        } else {
            /*
             *  The app messed up big time.
             */
            RPF("ERROR: %s: Attempting to release a deleted object",
                s_szProc);
            ulRc = 0;
        }
    } else {
        ulRc = 0;
    }

    ExitProcX(ulRc);
    return ulRc;
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global IUnknownVtbl * | c_lpvtblPunk |
 *
 *          The special IUnknown object that only the controlling unknown
 *          knows about.
 *
 *          This is the one that calls the "Real" services.  All the normal
 *          vtbl's go through the controlling unknown (which, if we are
 *          not aggregated, points to ourselves).
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

_Secondary_Interface_Begin(CCommon, IUnknown,
                           (ULONG)(FIELD_OFFSET(CIN, cin_unkPrivate) - cbX(CIN)),
                           Common_Private)
_Secondary_Interface_End(CCommon, IUnknown)

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *      "Public" IUnknown methods
 *
 *      These simply forward through the controlling unknown.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Common_QueryInterface |
 *
 *          Forward through the controlling unknown.
 *
 *  @parm   PUNK | punk |
 *
 *          The object being queried.
 *
 *  @parm   RIID | riid |
 *
 *          The interface being requested.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

STDMETHODIMP
Common_QueryInterface(PV pv, REFIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IUnknown::QueryInterface, (_ "pG", pv, riid));

    if (SUCCEEDED(hres = hresFullValidPitf(pv, 0)) &&
        SUCCEEDED(hres = hresFullValidRiid(riid, 1)) &&
        SUCCEEDED(hres = hresFullValidPcbOut(ppvObj, cbX(*ppvObj), 2))) {
        PCI pci = _thisPv(pv);
        AssertF(pci->ci_punkOuter);
        hres = OLE_QueryInterface(pci->ci_punkOuter, riid, ppvObj);
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_AddRef |
 *
 *          Forward through the controlling unknown.
 *
 *  @parm   PUNK | punk |
 *
 *          The object being addref'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_AddRef(PV pv)
{
    ULONG ulRef;
    HRESULT hres;
    EnterProcR(IUnknown::AddRef, (_ "p", pv));

    if (SUCCEEDED(hres = hresFullValidPitf(pv, 0))) {
        PCI pci = _thisPv(pv);
        ulRef = OLE_AddRef(pci->ci_punkOuter);
    } else {
        ulRef = 0;
    }
    ExitProcX(ulRef);
    return ulRef;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_Release |
 *
 *          Forward through the controlling unknown.
 *
 *  @parm   PUNK | punk |
 *
 *          Object being release'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_Release(PV pv)
{
    ULONG ulRc;
    HRESULT hres;
    EnterProcR(IUnknown::Release, (_ "p", pv));

    if (SUCCEEDED(hres = hresFullValidPitf(pv, 0))) {
        PCI pci = _thisPv(pv);
        ulRc = OLE_Release(pci->ci_punkOuter);
    } else {
        ulRc = 0;
    }
    ExitProcX(ulRc);
    return ulRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | __Common_New |
 *
 *          Create a new object with refcount 1 and the specific vtbl.
 *          All other fields are zero-initialized.  All parameters must
 *          already be validated.
 *
 *  @parm   ULONG | cb |
 *
 *          Size of object.  This does not include the hidden bookkeeping
 *          bytes maintained by the object manager.
 *
 *  @parm   PUNK | punkOuter |
 *
 *          Controlling unknown for OLE aggregation.  May be 0 to indicate
 *          that the object is not aggregated.
 *
 *  @parm   PV | vtbl |
 *
 *          Pointer to primary vtbl for this object.  Note that the
 *          vtbl declaration macros include other magic goo near the vtbl,
 *          which we consult in order to create the object.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

STDMETHODIMP
__Common_New(ULONG cb, PUNK punkOuter, PV vtbl, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(__Common_New, (_ "uxx", cb, punkOuter, vtbl));

    hres = AllocCbPpv(cb + sizeof(CIN), ppvObj);
    if (SUCCEEDED(hres)) {
        PCI pciO = (PV)&vtbl;
        PCI pci = pvAddPvCb(*ppvObj, sizeof(CIN));
     RD(pci->ci_dwSig = ci_dwSignature);
        pci->ci_unkPrivate.lpVtbl = Class_Vtbl(CCommon, IUnknown);
        if (punkOuter) {
            pci->ci_punkOuter = punkOuter;
        } else {
            pci->ci_punkOuter = &pci->ci_unkPrivate;
        }
        CopyMemory(pci, pciO->ci_rgvtbl, pciO->ci_cbvtbl);
        *ppvObj = pci;

        /*
         *  On an X86, it is simpler to increment a variable up
         *  from zero to one.  On a RISC, it is simpler to
         *  store the value one directly.
         */
#ifdef _X86_
#if DIRECTINPUT_VERSION > 0x0300
        pci->ci_cHoldRef++;
#endif
        pci->ci_cRef++;
#else
#if DIRECTINPUT_VERSION > 0x0300
        pci->ci_cHoldRef = 1;
#endif
        pci->ci_cRef = 1;
#endif

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		D(SquirtSqflPtszV(sqflObj | sqflVerbose, TEXT("%s %p __Common_New ci_cRef(%d) ci_cHoldRef(%d)"),
                          pci->ci_tszClass,
                          pci,
                          pci->ci_cRef,
                          pci->ci_cHoldRef
                          ));


        DllAddRef();

		// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		D(SquirtSqflPtszV(sqflObj, TEXT("Created %s %p "),
                        pci->ci_tszClass,
                        pci));

        hres = S_OK;
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | _Common_New_ |
 *
 *          Create a new object with refcount 1 and the specific vtbl.
 *          All other fields are zero-initialized.  This entry point
 *          validates parameters.
 *
 *  @parm   ULONG | cb |
 *
 *          Size of object.  This does not include the hidden bookkeeping
 *          bytes maintained by the object manager.
 *
 *  @parm   PUNK | punkOuter |
 *
 *          Controlling unknown for OLE aggregation.  May be 0 to indicate
 *          that the object is not aggregated.
 *
 *  @parm   PV | vtbl |
 *
 *          Pointer to primary vtbl for this object.  Note that the
 *          vtbl declaration macros include other magic goo near the vtbl,
 *          which we consult in order to create the object.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

STDMETHODIMP
_Common_New_(ULONG cb, PUNK punkOuter, PV vtbl, PPV ppvObj, LPCSTR pszProc)
{
    HRESULT hres;
    EnterProc(_Common_New, (_ "uxx", cb, punkOuter, vtbl));

    if (SUCCEEDED(hres = hresFullValidPitf0_(punkOuter, pszProc, 1)) &&
        SUCCEEDED(hres = hresFullValidPcbOut_(ppvObj, cbX(*ppvObj), pszProc, 3))) {
        hres = __Common_New(cb, punkOuter, vtbl, ppvObj);
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | _Common_NewRiid_ |
 *
 *          Create a new object with refcount 1 and the specific vtbl,
 *          but only if the object supports the indicated interface.
 *          All other fields are zero-initialized.
 *
 *          If punkOut is nonzero, then the object is being created for
 *          aggregation.  The interface must then be &IID_IUnknown.
 *
 *          Aggregation is used to allow multiple IDirectInputXxx interfaces
 *          to hang off one logical object.
 *
 *          It is assumed that the prototype of the calling function is
 *
 *          foo(PV this, PUNK punkOuter, RIID riid, PPV ppvObj);
 *
 *  @parm   ULONG | cb |
 *
 *          Size of object.  This does not include the hidden bookkeeping
 *          bytes maintained by the object manager.
 *
 *  @parm   PV | vtbl |
 *
 *          Pointer to primary vtbl for this object.  Note that the
 *          vtbl declaration macros include other magic goo near the vtbl,
 *          which we consult in order to create the object.
 *
 *  @parm   PUNK | punkOuter |
 *
 *          Controlling unknown for OLE aggregation.  May be 0 to indicate
 *          that the object is not aggregated.
 *
 *  @parm   RIID | riid |
 *
 *          Interface requested.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

STDMETHODIMP
_Common_NewRiid_(ULONG cb, PV vtbl, PUNK punkOuter, RIID riid, PPV ppvObj,
                 LPCSTR pszProc)
{
    HRESULT hres;
    EnterProc(Common_NewRiid, (_ "upG", cb, punkOuter, riid));

    /*
     * Note: __Common_New does not validate punkOuter or ppvObj,
     * so we have to.  Note also that we validate ppvObj first,
     * so that it will be set to zero as soon as possible.
     */

    if (SUCCEEDED(hres = hresFullValidPcbOut_(ppvObj, cbX(*ppvObj), pszProc, 3)) &&
        SUCCEEDED(hres = hresFullValidPitf0_(punkOuter, pszProc, 1)) &&
        SUCCEEDED(hres = hresFullValidRiid_(riid, pszProc, 2))) {

        if (fLimpFF(punkOuter, IsEqualIID(riid, &IID_IUnknown))) {
            hres = __Common_New(cb, punkOuter, vtbl, ppvObj);
            if (SUCCEEDED(hres)) {

                /*
                 *  Move to the requested interface if we aren't aggregated.
                 *  Don't do this if aggregated! or we will lose the private
                 *  IUnknown and then the caller will be hosed.
                 */

                if (punkOuter) {
                    PCI pci = *ppvObj;
                    *ppvObj = &pci->ci_unkPrivate;
                } else {
                    PUNK punk = *ppvObj;
                    hres = Common_QueryInterface(punk, riid, ppvObj);
                    Common_Release(punk);
                }
            }
        } else {
            RD(RPF("%s: IID must be IID_IUnknown if created for aggregation",
                   pszProc));
            *ppvObj = 0;
            hres = CLASS_E_NOAGGREGATION;
        }
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      Invoke_Release
 *
 *      Release the object (if there is one) and wipe out the back-pointer.
 *      Note that we wipe out the value before calling the release, in order
 *      to ameliorate various weird callback conditions.
 *
 *****************************************************************************/

void EXTERNAL
Invoke_Release(PV pv)
{
    LPUNKNOWN punk = (LPUNKNOWN) pvExchangePpvPv64(pv, 0);
    if (punk) {
        punk->lpVtbl->Release(punk);
    }
}

#ifdef IDirectInputDevice2Vtbl

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresPvVtbl2_ |
 *
 *          Validate that an interface pointer is what it claims to be.
 *          It must be the object associated with the <p vtbl> or
 *          the object associated with the <p vtbl2>.
 *
 *  @parm   IN PV | pv |
 *
 *          The thing that claims to be an interface pointer.
 *
 *  @parm   IN PV | vtbl |
 *
 *          What it should be, or something equivalent to this.
 *
 *  @parm   IN PV | vtbl2 |
 *
 *          The other thing it should be, if it isn't <p vtbl>.
 *
 *  @returns
 *
 *          Returns <c S_OK> if everything is okay, else
 *          <c E_INVALIDARG>.
 *
 *****************************************************************************/

HRESULT EXTERNAL
hresPvVtbl2_(PV pv, PV vtbl, PV vtbl2, LPCSTR s_szProc)
{
    PUNK punk = pv;
    HRESULT hres;

    AssertF(vtbl);
    if (SUCCEEDED(hres = hresFullValidPitf(punk, 0))) {
#ifdef XDEBUG
        if (punk->lpVtbl == vtbl || punk->lpVtbl == vtbl2) {
            hres = S_OK;
        } else {
            RPF("ERROR %s: arg %d: invalid pointer", s_szProc, 0);
            hres = E_INVALIDARG;
        }
#else
        /*
         *  ISSUE-2001/03/29-timgill Really only want to see the primary interface
         *  If we are looking for the primary interface,
         *  then allow any interface.  All the dual-character set
         *  interfaces point all the vtbls at the same function,
         *  which uses hresPvT to validate. hresPvT passes the
         *  primary interface, hence the need to allow anything
         *  if you are asking for the primary interface.
         *
         *  The problem is that this is too lenient in the case
         *  where we really want to see only the primary interface
         *  and not accept any of the secondaries.
         *
         */
        UINT ivtbl;
        PV vtblUnk = punk->lpVtbl;
        PCI pci = (PV)&vtbl;
        if (pci->ci_lib == 0) {
            for (ivtbl = 0; ivtbl * sizeof(PV) < pci->ci_cbvtbl; ivtbl++) {
                if (pci->ci_rgvtbl[ivtbl] == vtblUnk) {
                    hres = S_OK;
                    goto found;
                }
            }
            hres = E_INVALIDARG;
        found:;
        } else {
            if (punk->lpVtbl == vtbl || punk->lpVtbl == vtbl2) {
                hres = S_OK;
            } else {
                hres = E_INVALIDARG;
            }
        }
#endif
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresPvVtbl_ |
 *
 *          Validate that an interface pointer is what it claims to be.
 *          It must be the object associated with the <p vtbl>.
 *
 *  @parm   IN PV | pv |
 *
 *          The thing that claims to be an interface pointer.
 *
 *  @parm   IN PV | vtbl |
 *
 *          What it should be, or something equivalent to this.
 *
 *  @returns
 *
 *          Returns <c S_OK> if everything is okay, else
 *          <c E_INVALIDARG>.
 *
 *****************************************************************************/

HRESULT EXTERNAL
hresPvVtbl_(PV pv, PV vtbl, LPCSTR s_szProc)
{
    return hresPvVtbl2_(pv, vtbl, vtbl, s_szProc);
}

#else

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresPvVtbl_ |
 *
 *          Validate that an interface pointer is what it claims to be.
 *          It must be the object associated with the <p vtbl>.
 *
 *  @parm   IN PV | pv |
 *
 *          The thing that claims to be an interface pointer.
 *
 *  @parm   IN PV | vtbl |
 *
 *          What it should be, or something equivalent to this.
 *
 *  @returns
 *
 *          Returns <c S_OK> if everything is okay, else
 *          <c E_INVALIDARG>.
 *
 *****************************************************************************/

HRESULT EXTERNAL
hresPvVtbl_(PV pv, PV vtbl, LPCSTR s_szProc)
{
    PUNK punk = pv;
    HRESULT hres;

    AssertF(vtbl);
    if (SUCCEEDED(hres = hresFullValidPitf(punk, 0))) {
#ifdef XDEBUG
        if (punk->lpVtbl == vtbl) {
            hres = S_OK;
        } else {
            RPF("ERROR %s: arg %d: invalid pointer", s_szProc, 0);
            hres = E_INVALIDARG;
        }
#else
        /*
         *  ISSUE-2001/03/29-timgill Really only want to see the primary interface
         *  If we are looking for the primary interface,
         *  then allow any interface.  All the dual-character set
         *  interfaces point all the vtbls at the same function,
         *  which uses hresPvT to validate. hresPvT passes the
         *  primary interface, hence the need to allow anything
         *  if you are asking for the primary interface.
         *
         *  The problem is that this is too lenient in the case
         *  where we really want to see only the primary interface
         *  and not accept any of the secondaries.
         *
         */
        UINT ivtbl;
        PV vtblUnk = punk->lpVtbl;
        PCI pci = (PV)&vtbl;
        if (pci->ci_lib == 0) {
            for (ivtbl = 0; ivtbl * sizeof(PV) < pci->ci_cbvtbl; ivtbl++) {
                if (pci->ci_rgvtbl[ivtbl] == vtblUnk) {
                    hres = S_OK;
                    goto found;
                }
            }
            hres = E_INVALIDARG;
        found:;
        } else {
            if (punk->lpVtbl == vtbl) {
                hres = S_OK;
            } else {
                hres = E_INVALIDARG;
            }
        }
#endif
    }

    return hres;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dical.c ===
/*****************************************************************************
 *
 *  DICal.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Functions that manage axis ramps and calibration.
 *
 *      Structure names begin with "Joy" for historical reasons.
 *
 *  Contents:
 *
 *      CCal_CookRange
 *      CCal_RecalcRange
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflCal

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | CCal_MulDiv |
 *
 *          High-speed MulDiv for Intel x86 boxes.  Otherwise, uses
 *          the standard MulDiv.  The values involved are always
 *          nonnegative.
 *
 *  @parm   LONG | lA |
 *
 *          Multiplicand.
 *
 *  @parm   LONG | lB |
 *
 *          Multiplier.
 *
 *  @parm   LONG | lC |
 *
 *          Denominator.
 *
 *  @returns
 *
 *          lA * lB / lC, with 64-bit intermediate precision.
 *
 *****************************************************************************/

#if defined(_X86_)

#pragma warning(disable:4035)           /* no return value (duh) */

__declspec(naked) LONG EXTERNAL
CCal_MulDiv(LONG lA, LONG lB, LONG lC)
{
    lA; lB; lC;
    _asm {
        mov     eax, [esp+4]
        mul     dword ptr [esp+8]
        div     dword ptr [esp+12]
        ret     12
    }
}

#pragma warning(default:4035)

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CCal | CookAxisPOV |
 *
 *          Cook a piece of POV data into one of five defined data.
 *
 *  @cwrap  PJOYRANGECONVERT | this
 *
 *  @parm   INOUT PLONG | pl |
 *
 *          On entry, contains the raw value.  On exit, contains the
 *          cooked value.  (Or the raw value if the axis is raw.)
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/
#ifdef WINNT
void CookAxisPOV( PJOYRANGECONVERT this, LONG UNALIGNED *pl )
{
    LONG l;

    /*
     * figure out which direction this value indicates...
     */
    if( (*pl > this->lMinPOV[JOY_POVVAL_FORWARD])
      &&(*pl < this->lMaxPOV[JOY_POVVAL_FORWARD]) ) 
    {
        l = JOY_POVFORWARD;
    } 
    else if( (*pl > this->lMinPOV[JOY_POVVAL_BACKWARD])
           &&(*pl < this->lMaxPOV[JOY_POVVAL_BACKWARD]) ) 
    {
        l = JOY_POVBACKWARD;
    } 
    else if( (*pl > this->lMinPOV[JOY_POVVAL_LEFT])
           &&(*pl < this->lMaxPOV[JOY_POVVAL_LEFT]) ) 
    {
        l = JOY_POVLEFT;
    } 
    else if( (*pl > this->lMinPOV[JOY_POVVAL_RIGHT])
           &&(*pl < this->lMaxPOV[JOY_POVVAL_RIGHT]) ) 
    {
        l = JOY_POVRIGHT;
    }
    else 
    {
        l = JOY_POVCENTERED;
    }
        
    #if 0
    {
        TCHAR buf[100];
        wsprintf(buf, TEXT("calibrated pov: %d\r\n"), l);
        OutputDebugString(buf);
    }
    #endif

    *pl = l;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CCal | CookRange |
 *
 *          Cook a piece of phys data into a range.
 *
 *  @cwrap  PJOYRANGECONVERT | this
 *
 *  @parm   INOUT PLONG | pl |
 *
 *          On entry, contains the raw value.  On exit, contains the
 *          cooked value.  (Or the raw value if the axis is raw.)
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/

void EXTERNAL
CCal_CookRange(PJOYRANGECONVERT this, LONG UNALIGNED *pl)
{
    if (this->fRaw) {
        /*
         *  Nothing to do!
         */
    } 
  #ifdef WINNT
    else if ( this->fFakeRaw ) {
        if( this->dwPmin & 0x80000000 ) {
            *pl -= (long)this->dwPmin;
        }
    } 
  #endif
    else {
      #ifdef WINNT
        if( this->fPolledPOV ) {
            CookAxisPOV( this, pl );
        } else 
      #endif
        {
            LONG l;
            LONG lRc;
            PCJOYRAMP prmp;


            l = *pl;

            /*
             *  Choose the low or high ramp, depending on which side we're in.
             *
             *  This comparison could've been against Dmax or Dmin or Pc.
             *  We must use Dmax because we jiggered up the rmpHigh so
             *  that it rounds properly, so we can't use the flat part
             *  below rmpHigh.x because it's at the wrong level.
             */
            if (l < this->rmpHigh.x) {
                prmp = &this->rmpLow;
            } else {
                prmp = &this->rmpHigh;
            }

            if (l <= prmp->x) {
                lRc = 0;
            } else {
                l -= prmp->x;
                if ((DWORD)l < prmp->dx) {
                    /*
                     *  Note that prmp->dx cannot be zero because it
                     *  is greater than something!
                     */
                    lRc = CCal_MulDiv((DWORD)l, prmp->dy, prmp->dx);
                } else {
                    lRc = prmp->dy;
                }
            }
            lRc += prmp->y;

            *pl = lRc;
        }
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CCal | RecalcRange |
 *
 *          Compute all the values that derive from the user's
 *          range settings.
 *
 *          Be careful not to create values that will cause us to
 *          divide by zero later.  Fortunately,
 *          <f CCal_CookRange> never divides by zero due to the
 *          clever way it was written.
 *
 *  @cwrap  PJOYRANGECONVERT | this
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/

void EXTERNAL
CCal_RecalcRange(PJOYRANGECONVERT this)
{
    int dx;
    DWORD dwSat;

    AssertF(this->dwDz <= RANGEDIVISIONS);
    AssertF(this->dwSat <= RANGEDIVISIONS);
    AssertF(this->lMin <= this->lC);
    AssertF(this->lC   <= this->lMax);

    dwSat = max(this->dwSat, this->dwDz);


    /* Smin - Bottom of saturation range */
    dx = CCal_MulDiv(this->dwPc - this->dwPmin, dwSat, RANGEDIVISIONS);
    this->rmpLow.x = this->dwPc - dx;

    /* Dmin - Bottom of dead zone */
    dx = CCal_MulDiv(this->dwPc - this->dwPmin, this->dwDz, RANGEDIVISIONS);
    this->rmpLow.dx = (this->dwPc - dx) - this->rmpLow.x;

    /*
     *  Establish the vertical extent of the low end of the ramp.
     */
    this->rmpLow.y = this->lMin;
    this->rmpLow.dy = this->lC - this->lMin;


    /* Dmax - Top of the dead zone */
    dx = CCal_MulDiv(this->dwPmax - this->dwPc, this->dwDz, RANGEDIVISIONS);
    if ( this->dwPmax > this->dwPc+1 ){
        this->rmpHigh.x = this->dwPc + dx + 1;
    } else {
        this->rmpHigh.x = this->dwPc + dx;
        RPF("dwPmax == dwPc (%d). Possible a bug.", this->dwPmax);
    }

    /* Smax - Top of the saturation range */
    dx = CCal_MulDiv(this->dwPmax - this->dwPc, dwSat, RANGEDIVISIONS);
    this->rmpHigh.dx = (this->dwPc + dx) - this->rmpHigh.x;

    /*
     *  Establish the vertical extent of the high end of the ramp.
     *
     *  If the high end is zero, then the entire ramp is zero.
     *  Otherwise, put the bottom at +1 so that when the user
     *  just barely leaves the dead zone, we report a nonzero
     *  value.  Note: If we were really clever, we could use
     *  a bias to get "round upwards", but it's not worth it.
     *
     */
    if ( (this->lMax > this->lC) && (this->dwPmax > this->dwPc+1) ) {
        this->rmpHigh.y = this->lC + 1;
    } else {
        this->rmpHigh.y = this->lC;
    }
    this->rmpHigh.dy = this->lMax - this->rmpHigh.y;

#if 0
    RPF( "Raw: %d   Dead Zone: 0x%08x  Saturation: 0x%08x", 
        this->fRaw, this->dwDz, this->dwSat );
    RPF( "Physical min: 0x%08x  max: 0x%08x cen: 0x%08x", 
        this->lMin, this->lMax, this->lC );
    RPF( "Logical  min: 0x%08x  max: 0x%08x cen: 0x%08x", 
        this->dwPmin, this->dwPmax, this->dwPc );
    RPF( "Lo ramp X: 0x%08x   dX: 0x%08x   Y: 0x%08x   dY: 0x%08x", 
        this->rmpLow.x, this->rmpLow.dx, this->rmpLow.y, this->rmpLow.dy );
    RPF( "Hi ramp X: 0x%08x   dX: 0x%08x   Y: 0x%08x   dY: 0x%08x",
        this->rmpHigh.x, this->rmpHigh.dx, this->rmpHigh.y, this->rmpHigh.dy );
#endif    

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CCal | GetProperty |
 *
 *          Read a property from a calibration structure.
 *
 *          The caller is permitted to pass a property that doesn't
 *          apply to calibration, in which case <c E_NOTIMPL>
 *          is returned, as it should be.
 *
 *  @cwrap  PJOYRANGECONVERT | this
 *
 *  @parm   REFGUID | rguid |
 *
 *          The property being retrieved.
 *
 *  @parm   IN REFGUID | rguid |
 *
 *          The identity of the property to be obtained.
 *
 *  @parm   IN LPDIPROPHEADER | pdiph |
 *
 *          Points to the <t DIPROPHEADER> portion of a structure
 *          which depends on the property.
 *
 *  @parm   IN DWORD | dwVerion
 *          Version of DirectInput DLL.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CCal_GetProperty(PJOYRANGECONVERT this, REFGUID rguid, LPDIPROPHEADER pdiph, DWORD dwVersion)
{
    HRESULT hres;
    LPDIPROPRANGE pdiprg  = CONTAINING_RECORD(pdiph, DIPROPRANGE, diph);
    LPDIPROPDWORD pdipdw  = CONTAINING_RECORD(pdiph, DIPROPDWORD, diph);
    LPDIPROPCAL   pdipcal = CONTAINING_RECORD(pdiph, DIPROPCAL  , diph);
    EnterProc(CCal::GetProperty, (_ "pxpx", this, rguid, pdiph, dwVersion));

    switch ((DWORD)(UINT_PTR)rguid) {

    case (DWORD)(UINT_PTR)DIPROP_RANGE:
        pdiprg->lMin = this->lMin;
        pdiprg->lMax = this->lMax;
        hres = S_OK;
        break;

    case (DWORD)(UINT_PTR)DIPROP_DEADZONE:
        pdipdw->dwData = this->dwDz;
        hres = S_OK;
        break;

    case (DWORD)(UINT_PTR)DIPROP_SATURATION:
        pdipdw->dwData = this->dwSat;
        hres = S_OK;
        break;

    case (DWORD)(UINT_PTR)DIPROP_CALIBRATIONMODE:
      #ifdef WINNT
        if( (dwVersion < 0x700) && (dwVersion != 0x5B2) )
        {   
            pdipdw->dwData = this->fFakeRaw;
        } else
      #endif
        {
            pdipdw->dwData = this->fRaw;
        }
        hres = S_OK;
        break;

    case (DWORD)(UINT_PTR)DIPROP_CALIBRATION:
      #ifdef WINNT
        if( (dwVersion < 0x700) && (dwVersion != 0x5B2)  && (this->dwPmin & 0x8000) )
        {   
            pdipcal->lMin    = 0;
            pdipcal->lMax    = (long)this->dwPmax - (long)this->dwPmin;
            pdipcal->lCenter = CCal_Midpoint(pdipcal->lMin, pdipcal->lMax);;
        } else
      #endif
        {
            pdipcal->lMin    = this->dwPmin;
            pdipcal->lMax    = this->dwPmax;
            pdipcal->lCenter = this->dwPc;
        }
        hres = S_OK;
        break;

    default:
        hres = E_NOTIMPL;
        break;
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CCal | SetCalibration |
 *
 *          The app (hopefully a control panel) is changing the
 *          calibration.
 *
 *  @cwrap  PJOYRANGECONVERT | this
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   IN LPCDIPROPHEADER | pdiph |
 *
 *          Points to the <t DIPROPHEADER> portion of a structure
 *          which depends on the property.
 *
 *  @parm   HKEY | hkType |
 *
 *          Registry key to use calibration information.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CCal_SetCalibration(PJOYRANGECONVERT this, LPCDIPROPINFO ppropi,
                    LPCDIPROPHEADER pdiph, HKEY hkType)
{
    HRESULT hres;
    
  #ifdef WINNT
    if( ppropi->dwDevType == DIDFT_POV ) {
        if( this->fPolledPOV ) {
            LPCDIPROPCALPOV pdipcalpov = CONTAINING_RECORD(pdiph, DIPROPCALPOV, diph);
            if (hkType) {
                LPDIPOVCALIBRATION ppov;
                HKEY hk;
    
                /*
                 *  We pun a DIPROPCALPOV as a DIPOVCALIBRATION.
                 */
                #define CheckField(f)   \
                  CAssertF(FIELD_OFFSET(DIPROPCALPOV, l##f) - cbX(DIPROPHEADER) == \
                           FIELD_OFFSET(DIPOVCALIBRATION, l##f))
                CheckField(Min);
                CheckField(Max);
                #undef CheckField
    
                ppov = pvAddPvCb(pdipcalpov, cbX(DIPROPHEADER));
    
                AssertF( !memcmp(ppov->lMin, pdipcalpov->lMin, cbX(DIPOVCALIBRATION)) );
                AssertF( !memcmp(ppov->lMax, pdipcalpov->lMax, cbX(DIPOVCALIBRATION)) );
    
    
                hres = CType_OpenIdSubkey(hkType, ppropi->dwDevType,
                                          DI_KEY_ALL_ACCESS, &hk);
                if (SUCCEEDED(hres)) {
    
                    /*
                     * All 0x0's for calibration is our cue to reset 
                     * to default values.              
                     */
                    if( ppov->lMin[0] == ppov->lMin[1] == ppov->lMin[2] == ppov->lMin[3] == ppov->lMin[4] == 
                        ppov->lMax[0] == ppov->lMax[1] == ppov->lMax[2] == ppov->lMax[3] == ppov->lMax[4] == 0 )
                    {
                        RegDeleteValue(hk, TEXT("Calibration")) ;
                    } else
                    {
                        hres = JoyReg_SetValue(hk, TEXT("Calibration"),
                                               REG_BINARY, ppov,
                                               cbX(DIPOVCALIBRATION));
                    }
                    RegCloseKey(hk);
                }
    
            } else {
                hres = S_FALSE;
            }
    
            if (SUCCEEDED(hres)) {
                memcpy( this->lMinPOV, pdipcalpov->lMin, cbX(pdipcalpov->lMin) );
                memcpy( this->lMaxPOV, pdipcalpov->lMax, cbX(pdipcalpov->lMax) );
            }
        } else {
            hres = E_NOTIMPL;
        }
    } else 
  #endif
    {
        LPCDIPROPCAL pdipcal = CONTAINING_RECORD(pdiph, DIPROPCAL, diph);
        if (hkType) {
            LPDIOBJECTCALIBRATION pcal;
            HKEY hk;

            /*
             *  We pun a DIPROPCAL as a DIOBJECTCALIBRATION.
             */
            #define CheckField(f)   \
              CAssertF(FIELD_OFFSET(DIPROPCAL, l##f) - cbX(DIPROPHEADER) == \
                       FIELD_OFFSET(DIOBJECTCALIBRATION, l##f))
            CheckField(Min);
            CheckField(Max);
            CheckField(Center);
            #undef CheckField

            pcal = pvAddPvCb(pdipcal, cbX(DIPROPHEADER));

            AssertF(pcal->lMin == pdipcal->lMin);
            AssertF(pcal->lMax == pdipcal->lMax);
            AssertF(pcal->lCenter == pdipcal->lCenter);

            hres = CType_OpenIdSubkey(hkType, ppropi->dwDevType,
                                      DI_KEY_ALL_ACCESS, &hk);
            if (SUCCEEDED(hres)) {

                /*
                 * All 0x0's for calibration is our cue to reset 
                 * to default values.              
                 */
                if(    pcal->lMin    == pcal->lMax && 
                       pcal->lCenter == pcal->lMax &&
                       pcal->lMax == 0x0 )
                {
                    RegDeleteValue(hk, TEXT("Calibration")) ;
                } else
                {
                    hres = JoyReg_SetValue(hk, TEXT("Calibration"),
                                           REG_BINARY, pcal,
                                           cbX(DIOBJECTCALIBRATION));
                }
                RegCloseKey(hk);
            }

        } else {
            hres = S_FALSE;
        }

        if (SUCCEEDED(hres)) {
            this->dwPmin  = pdipcal->lMin;
            this->dwPmax  = pdipcal->lMax;
            this->dwPc    = pdipcal->lCenter;
            CCal_RecalcRange(this);
        }
    }

    return hres;
 }

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CCal | SetProperty |
 *
 *          Write a property to a calibration structure.
 *
 *          The caller is permitted to pass a property that doesn't
 *          apply to calibration, in which case <c E_NOTIMPL>
 *          is returned, as it should be.
 *
 *  @cwrap  PJOYRANGECONVERT | this
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   IN LPDIPROPHEADER | pdiph |
 *
 *          Points to the <t DIPROPHEADER> portion of a structure
 *          which depends on the property.
 *
 *  @parm   HKEY | hkType |
 *
 *          Registry key to use if setting calibration information.
 *
 *  @parm   IN DWORD | dwVerion
 *          Version of DirectInput DLL.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CCal_SetProperty(PJOYRANGECONVERT this, LPCDIPROPINFO ppropi,
                 LPCDIPROPHEADER pdiph, HKEY hkType, DWORD dwVersion)
{
    HRESULT hres;
    LPCDIPROPRANGE pdiprg = (PCV)pdiph;
    LPCDIPROPDWORD pdipdw = (PCV)pdiph;
    LPDWORD pdw;
    EnterProc(CCal::SetProperty, (_ "pxpx", this, ppropi->pguid, pdiph, dwVersion));

    switch ((DWORD)(UINT_PTR)ppropi->pguid) {

    case (DWORD)(UINT_PTR)DIPROP_RANGE:
        if (pdiprg->lMin <= pdiprg->lMax) {

            this->lMin = pdiprg->lMin;
            this->lMax = pdiprg->lMax;

            this->lC = CCal_Midpoint(this->lMin, this->lMax);

            CCal_RecalcRange(this);   

            SquirtSqflPtszV(sqflCal,
                        TEXT("CCal_SetProperty:DIPROP_RANGE: lMin: %08x, lMax: %08x"), 
                              this->lMin, this->lMax );
            
            hres = S_OK;
        } else {
            RPF("ERROR DIPROP_RANGE: lMin must be <= lMax");
            hres = E_INVALIDARG;
        }
        break;

    case (DWORD)(UINT_PTR)DIPROP_DEADZONE:
        pdw = &this->dwDz;
        goto finishfraction;

    case (DWORD)(UINT_PTR)DIPROP_SATURATION:
        pdw = &this->dwSat;
        goto finishfraction;

    finishfraction:;
        if (pdipdw->dwData <= RANGEDIVISIONS) {
            *pdw = pdipdw->dwData;
            CCal_RecalcRange(this);
            hres = S_OK;

        } else {
            RPF("SetProperty: Value must be 0 .. 10000");
            hres = E_INVALIDARG;
        }
        break;

    case (DWORD)(UINT_PTR)DIPROP_CALIBRATIONMODE:
        if ((pdipdw->dwData & ~DIPROPCALIBRATIONMODE_VALID) == 0) {
          /*
           * Some applications don't like negative raw data, so
           * we need cook the data for them instead of giving them
           * the real raw data. See Manbug: 45898. -qzheng
           */
          #ifdef WINNT
            if( (dwVersion < 0x700) && (dwVersion != 0x5B2) && (this->dwPmin & 0x8000))
            {
                this->fFakeRaw = pdipdw->dwData;
            } else 
          #endif  
            {
                this->fRaw = pdipdw->dwData;
            }
            hres = S_OK;
        } else {
            RPF("ERROR SetProperty: invalid calibration flags");
            hres = E_INVALIDARG;
        }
        break;

    case (DWORD)(UINT_PTR)DIPROP_CALIBRATION:
    case (DWORD)(UINT_PTR)DIPROP_SPECIFICCALIBRATION:
        hres = CCal_SetCalibration(this, ppropi, pdiph, hkType);
        break;

    default:
        hres = E_NOTIMPL;
        break;
    }

    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\diaddhw.c ===
/*****************************************************************************
 *
 *  DIAddHw.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Add New Hardware
 *
 *  Contents:
 *
 *      AddNewHardware
 *
 *****************************************************************************/

#include "dinputpr.h"
#include "dithunk.h"

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoyCfg

#ifdef IDirectInputJoyConfig_QueryInterface

#define case95(n)       case n:
#define caseNT(n)       case n:

HRESULT INTERNAL hresFromDiErr_NT(DWORD et);
HRESULT INTERNAL hresFromDiErr_95(int   et);

/*****************************************************************************
 *
 *      These are the functions we have to steal from SYSDM...
 *
 *****************************************************************************/

LPCSTR rgpszSysdm[] = {
    "InstallDevice_RunDLL",     /* InstallDevice_RunDLL     */
};

typedef struct SYSDM {          /* sysdm */
    FARPROC InstallDevice_RunDLL;
} SYSDM, *PSYSDM;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | DiDestroyDeviceInfoList |
 *
 *          Thunk down to SETUPX.DiCallClassInstaller.
 *
 *****************************************************************************/

void INLINE
InstallDevice_RunDLL(PSYSDM psysdm, HWND hwnd,
                     HINSTANCE hinst, LPCSTR psz, UINT show)
{
    TemplateThunk(psysdm->InstallDevice_RunDLL, "ssps",
                  hwnd, hinst, psz, show);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CLASSMAP |
 *
 *          Structure that establishes the relationship between
 *          <t GUIDs> for device classes and the name of the class.
 *
 *          This code needs to hang around because Windows 95
 *          doesn't have SETUPAPI.DLL, so we need to fake it.
 *
 *  @parm   HWND | hwndOwner |
 *
 *          Window to act as owner window for UI.
 *
 *  @parm   REFGUID | rguidClass |
 *
 *          <t GUID> which specifies the class of the hardware device.
 *
 *****************************************************************************/

typedef struct CLASSMAP {
    REFGUID pguidClass;
    LPCSTR ptszClass;
} CLASSMAP, *PCLASSMAP;

const CLASSMAP c_rgcmap[] = {
    {   &GUID_KeyboardClass, ("keyboard"),   },
    {   &GUID_MediaClass,    ("media"),      },
    {   &GUID_MouseClass,    ("mouse"),      },
    {   &GUID_HIDClass,      ("HID"),        },
};

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   RESULT | AddNewHardware |
 *
 *          Display the "Add new hardware" dialog.
 *
 *          We pull a gross hack because Device Manager is completely
 *          unmanageable.  We simply call the RunDll entry point and
 *          let it do its thing.  Note that this means we have no way
 *          of knowing what the result was.  Oh well.
 *
 *  @parm   HWND | hwndOwner |
 *
 *          Window to act as owner window for UI.
 *
 *  @parm   REFGUID | rguidClass |
 *
 *          <t GUID> which specifies the class of the hardware device.
 *
 *****************************************************************************/

HRESULT INTERNAL
AddNewHardware_95(HWND hwnd, REFGUID rguid)
{
    SYSDM sysdm;
    HINSTANCE hinst;
    HRESULT hres;
    EnterProcR(AddNewHardware, (_ "xG", hwnd, rguid));

    if (Thunk_GetKernelProcAddresses() &&
        (hinst = Thunk_GetProcAddresses((PV)&sysdm, rgpszSysdm,
                                        cA(rgpszSysdm),
                                        ("SYSDM.CPL")))) {
        int icmap;

        for (icmap = 0; icmap < cA(c_rgcmap); icmap++) {
            if (IsEqualGUID(rguid, c_rgcmap[icmap].pguidClass)) {
                goto found;
            }
        }
        RPF("%s: Unknown device class", s_szProc);
        hres = DIERR_INVALIDCLASSINSTALLER;
        goto done;

    found:;

        InstallDevice_RunDLL(&sysdm, hwnd, hinst,
                             c_rgcmap[icmap].ptszClass, SW_NORMAL);

        g_kpa.FreeLibrary16(hinst);

        hres = S_FALSE;

    } else {
        RPF("%s: Problems thunking to configuration manager", s_szProc);
        hres = E_FAIL;
    }


done:;
    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   RESULT | AddNewHardware |
 *
 *          Display the "Add new hardware" dialog.
 *
 *  @parm   HWND | hwndOwner |
 *
 *          Window to act as owner window for UI.
 *
 *  @parm   REFGUID | rguidClass |
 *
 *          <t GUID> which specifies the class of the hardware device.
 *
 *****************************************************************************/

HRESULT INTERNAL
AddNewHardware_NT(HWND hwnd, REFGUID rguid)
{
    HRESULT     hres;
    HINSTANCE   hInst;
    BOOL        b;
    FARPROC     proc;
    DWORD       le;

    hres = E_NOTIMPL;

    /* Load AddNewHardware proc from newdev.dll part of AddNewHardware wizard.
     */
    hInst = LoadLibrary(TEXT("newdev.dll"));

    if (hInst) {
        proc = GetProcAddress(hInst, (LPCSTR)"InstallNewDevice");

        if (proc) {
            le = ERROR_SUCCESS;
            b  = (BOOL)(*proc)(hwnd, rguid, 0); // 0 means newdev decides about reboot

            if (!b) {
                le = GetLastError();
            }

            hres = hresFromDiErr_NT(le);
        }

        FreeLibrary(hInst);
    }

    return hres;
}


HRESULT EXTERNAL
AddNewHardware(HWND hwnd, REFGUID rguid)
{
    return  ((fWinnt)? AddNewHardware_NT(hwnd, rguid) : AddNewHardware_95(hwnd, rguid));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFromDiErr |
 *
 *          Convert a device installer error code into an HRESULT.
 *
 *****************************************************************************/

HRESULT INTERNAL
hresFromDiErr_NT(DWORD et)
{
    HRESULT hres;

    switch (et) {

    case ERROR_SUCCESS:
        hres = S_OK; break;

    /*
     *  Do the default action for the requested operation.
     */
    caseNT(ERROR_DI_DO_DEFAULT);
        hres = S_OK; break;

    /*
     *  No need to copy files (in install).
     */
    caseNT(ERROR_DI_NOFILECOPY);
        hres = S_OK; break;

    /*
     *  Registry entry or DLL for class installer invalid.
     */
    caseNT(ERROR_INVALID_CLASS_INSTALLER);
        hres = DIERR_INVALIDCLASSINSTALLER; break;

    /*
     *  Insufficient memory.
     */
    caseNT(ERROR_NOT_ENOUGH_MEMORY);
    caseNT(ERROR_OUTOFMEMORY);
        hres = E_OUTOFMEMORY; break;

    /*
     *  The user cancelled the operation.
     */
    caseNT(ERROR_CANCELLED);
    caseNT(ERROR_NO_DRIVER_SELECTED);
        hres = DIERR_CANCELLED; break;

    /*
     *  Various impossible things.
     */
    caseNT(ERROR_NO_ASSOCIATED_CLASS);
    caseNT(ERROR_CLASS_MISMATCH);
    caseNT(ERROR_DUPLICATE_FOUND);
    caseNT(ERROR_KEY_DOES_NOT_EXIST);
    caseNT(ERROR_INVALID_DEVINST_NAME);
    caseNT(ERROR_INVALID_CLASS);
    caseNT(ERROR_DEVINFO_NOT_REGISTERED);
    caseNT(ERROR_DEVINST_ALREADY_EXISTS);
    caseNT(ERROR_INVALID_REG_PROPERTY);
    caseNT(ERROR_NO_SUCH_DEVINST);
    caseNT(ERROR_CANT_LOAD_CLASS_ICON);
    caseNT(ERROR_INVALID_HWPROFILE);
    caseNT(ERROR_DEVINFO_LIST_LOCKED);
    caseNT(ERROR_DEVINFO_DATA_LOCKED);
    caseNT(ERROR_NO_CLASSINSTALL_PARAMS);
    caseNT(ERROR_FILEQUEUE_LOCKED);
    caseNT(ERROR_BAD_SERVICE_INSTALLSECT);
    caseNT(ERROR_NO_CLASS_DRIVER_LIST);
    caseNT(ERROR_NO_ASSOCIATED_SERVICE);
    caseNT(ERROR_NO_DEFAULT_DEVICE_INTERFACE);
    default:;
        hres = E_FAIL; break;

    caseNT(ERROR_DI_BAD_PATH);
    caseNT(ERROR_NO_INF);
        hres = DIERR_BADINF; break;

    }
    return hres;
}


#ifndef DI_ERROR
#define DI_ERROR       (500)    // Device Installer
#endif

enum _ERR_DEVICE_INSTALL
{
    ERR_DI_INVALID_DEVICE_ID = DI_ERROR,    // Incorrectly formed device IDF
    ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST,  // Invalid compatible device list
    ERR_DI_REG_API,                         // Error returned by Reg API.
    ERR_DI_LOW_MEM,                         // Insufficient memory to complete
    ERR_DI_BAD_DEV_INFO,                    // Device Info struct invalid
    ERR_DI_INVALID_CLASS_INSTALLER,         // Registry entry / DLL invalid
    ERR_DI_DO_DEFAULT,                      // Take default action
    ERR_DI_USER_CANCEL,                     // the user cancelled the operation
    ERR_DI_NOFILECOPY,                      // No need to copy files (in install)
    ERR_DI_BAD_CLASS_INFO,                  // Class Info Struct invalid
    ERR_DI_BAD_INF,                         // Bad INF file encountered
    ERR_DI_BAD_MOVEDEV_PARAMS,              // Bad Move Device Params struct
    ERR_DI_NO_INF,                          // No INF found on OEM disk
    ERR_DI_BAD_PROPCHANGE_PARAMS,           // Bad property change param struct
    ERR_DI_BAD_SELECTDEVICE_PARAMS,         // Bad Select Device Parameters
    ERR_DI_BAD_REMOVEDEVICE_PARAMS,         // Bad Remove Device Parameters
    ERR_DI_BAD_ENABLECLASS_PARAMS,          // Bad Enable Class Parameters
    ERR_DI_FAIL_QUERY,                      // Fail the Enable Class query
    ERR_DI_API_ERROR,                       // DI API called incorrectly
    ERR_DI_BAD_PATH,                        // An OEM path was specified incorrectly
    ERR_DI_BAD_UNREMOVEDEVICE_PARAMS,       // Bad Unremove Device Parameters
    ERR_DI_NOUPDATE,                        // No Drivers Were updated
    ERR_DI_NODATE,                          // The driver does not have a Date stamp in the INF
    ERR_DI_NOVERSION,                       // There is not version string in the INF
    ERR_DI_DONT_INSTALL,                    // Don't upgrade the current driver
    ERR_DI_NO_DIGITAL_SIGNATURE_CATALOG,    // Catalog is not digitally signed
    ERR_DI_NO_DIGITAL_SIGNATURE_INF,        // Inf is not digitally signed
    ERR_DI_NO_DIGITAL_SIGNATURE_FILE,       // A file is not digitally signed
};


HRESULT INTERNAL
hresFromDiErr_95(int et)
{
    HRESULT hres;

    switch (et) {
    case ERROR_SUCCESS:
        hres = S_OK; break;


    /*
     *  Do the default action for the requested operation.
     */
    case95(ERR_DI_DO_DEFAULT);
        hres = S_OK; break;

    /*
     *  No need to copy files (in install).
     */
    case95(ERR_DI_NOFILECOPY);
        hres = S_OK; break;

    /*
     *  No Drivers Were updated.
     */
//    case95(ERR_DI_NOUPDATE);
//        hres = S_OK; break;

    /*
     *  Don't upgrade the current driver.
     */
//    case95(ERR_DI_DONT_UPGRADE);
//        hres = S_OK; break;


    /*
     *  No Drivers Were updated.
     */
    case95(ERR_DI_NOUPDATE);
        hres = S_OK; break;

    /*
     *  Registry entry or DLL for class installer invalid.
     */
    case95(ERR_DI_INVALID_CLASS_INSTALLER);
        hres = DIERR_INVALIDCLASSINSTALLER; break;

    /*
     *  Insufficient memory.
     */
    case95(ERR_DI_LOW_MEM);
        hres = E_OUTOFMEMORY; break;

    /*
     *  The user cancelled the operation.
     */
    case95(ERR_DI_USER_CANCEL);
        hres = DIERR_CANCELLED; break;

    /*
     *  Various impossible things.
     */
    case95(ERR_DI_BAD_DEV_INFO);            /* Device Info struct invalid    */
    case95(ERR_DI_BAD_CLASS_INFO);          /* Class Info Struct invalid     */
    case95(ERR_DI_API_ERROR);               /* DI API called incorrectly     */
    case95(ERR_DI_BAD_PROPCHANGE_PARAMS);   /* Bad property chg param struct */
    case95(ERR_DI_BAD_SELECTDEVICE_PARAMS); /* Bad Select Device Parameters  */
    case95(ERR_DI_BAD_REMOVEDEVICE_PARAMS); /* Bad Remove Device Parameters  */
    case95(ERR_DI_BAD_ENABLECLASS_PARAMS);  /* Bad Enable Class Parameters   */
    case95(ERR_DI_BAD_MOVEDEV_PARAMS);      /* Bad Move Device Params struct */
    case95(ERR_DI_FAIL_QUERY);              /* Fail the Enable Class query   */
    case95(ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST);
                                            /* Invalid compatible device list*/
    case95(ERR_DI_BAD_UNREMOVEDEVICE_PARAMS);
                                            /* Bad Unremove Device Parameters*/
    case95(ERR_DI_INVALID_DEVICE_ID);       /* Incorrectly formed device IDF */
    case95(ERR_DI_REG_API);                 /* Error returned by Reg API.    */
    default:;
        hres = E_FAIL; break;

    case95(ERR_DI_BAD_PATH);                /* OEM path specified incorrectly*/
    case95(ERR_DI_BAD_INF);                 /* Bad INF file encountered      */
    case95(ERR_DI_NO_INF);                  /* No INF found on OEM disk      */
    case95(ERR_DI_NOVERSION);               /* No version string in the INF  */
    case95(ERR_DI_NODATE);                  /* No Date stamp in the INF      */
        hres = DIERR_BADINF; break;

    }
    return hres;
}


#endif /* defined(IDirectInputJoyConfigVtbl) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\diaphack.c ===
/*****************************************************************************
 *
 *  DIApHack.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Support routines for app hacks
 *
 *  Contents:
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/
//ISSUE-2001/03/29-timgill Need to sort out a prefixed version of of SquirtSqflPtszV
TCHAR c_tszPrefix[]=TEXT("DINPUT: ");

#define sqfl sqflCompat

typedef enum
{
    DICOMPATID_REACQUIRE,           // Perform auto reaquire if device lost
    DICOMPATID_NOSUBCLASS,          // Do not use subclassing
    DICOMPATID_MAXDEVICENAMELENGTH, // Truncate device names
    DICOMPATID_NATIVEAXISONLY,      // Always report axis data in native mode
    DICOMPATID_NOPOLLUNACQUIRE,     // Don't unaquire the device if a poll fails
	DICOMPATID_SUCCEEDACQUIRE		// Always return a success code for calls to Acquire()
} DIAPPHACKID, *LPDIAPPHACKID;

typedef struct tagAPPHACKENTRY
{
    LPCTSTR             pszName;
    DWORD               cbData;
    DWORD               dwOSMask;
} APPHACKENTRY, *LPAPPHACKENTRY;

typedef struct tagAPPHACKTABLE
{
    LPAPPHACKENTRY      aEntries;
    ULONG               cEntries;
} APPHACKTABLE, *LPAPPHACKTABLE;

#define BEGIN_DECLARE_APPHACK_ENTRIES(name) \
            APPHACKENTRY name[] = {

#define DECLARE_APPHACK_ENTRY(name, type, osmask) \
                { TEXT(#name), sizeof(type), osmask },

#define END_DECLARE_APPHACK_ENTRIES() \
            };

#define BEGIN_DECLARE_APPHACK_TABLE(name) \
            APPHACKTABLE name = 

#define DECLARE_APPHACK_TABLE(entries) \
                { entries, cA(entries) }

#define END_DECLARE_APPHACK_TABLE() \
            ;

#define DIHACKOS_WIN2K (0x00000001L)
#define DIHACKOS_WIN9X (0x00000002L)

BEGIN_DECLARE_APPHACK_ENTRIES(g_aheAppHackEntries)
    DECLARE_APPHACK_ENTRY(ReAcquire,            BOOL,  DIHACKOS_WIN2K )
    DECLARE_APPHACK_ENTRY(NoSubClass,           BOOL,  DIHACKOS_WIN2K )
    DECLARE_APPHACK_ENTRY(MaxDeviceNameLength,  DWORD, DIHACKOS_WIN2K | DIHACKOS_WIN9X )
    DECLARE_APPHACK_ENTRY(NativeAxisOnly,       BOOL,  DIHACKOS_WIN2K | DIHACKOS_WIN9X )
    DECLARE_APPHACK_ENTRY(NoPollUnacquire,      BOOL,  DIHACKOS_WIN2K | DIHACKOS_WIN9X )
	DECLARE_APPHACK_ENTRY(SucceedAcquire,       BOOL,  DIHACKOS_WIN2K )
END_DECLARE_APPHACK_ENTRIES()

BEGIN_DECLARE_APPHACK_TABLE(g_ahtAppHackTable)
    DECLARE_APPHACK_TABLE(g_aheAppHackEntries)
END_DECLARE_APPHACK_TABLE()


/***************************************************************************
 *
 *  AhGetOSMask
 *
 *  Description:
 *      Gets the mask for the current OS
 *      This mask should be used when we get app hacks for more than just 
 *      Win2k such that hacks can be applied selectively per OS.
 *      For now just #define a value as constant.
 *
 *  Arguments:
 *      none
 *
 *  Returns: 
 *      DWORD: Mask of flags applicable for the current OS.
 *
 ***************************************************************************/

#ifdef WINNT
#define AhGetOSMask() DIHACKOS_WIN2K 
#else
#define AhGetOSMask() DIHACKOS_WIN9X 
#endif

/***************************************************************************
 *
 *  AhGetCurrentApplicationPath
 *
 *  Description:
 *      Gets the full path to the current application's executable.
 *
 *  Arguments:
 *      LPTSTR [out]: receives application id.  This buffer is assumed to be 
 *                   at least MAX_PATH characters in size.
 *      LPTSTR * [out]: receives pointer to executable part of the path.
 *
 *  Returns: 
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

BOOL AhGetCurrentApplicationPath
(
    LPTSTR                  pszPath,
    LPTSTR *                ppszModule
)
{
    BOOL                    fSuccess                = TRUE;
    TCHAR                   szOriginal[MAX_PATH];

    EnterProcI(AhGetCurrentApplicationPath, (_ ""));

    fSuccess = GetModuleFileName(GetModuleHandle(NULL), szOriginal, cA(szOriginal));

    if(fSuccess)
    {
        fSuccess = ( GetFullPathName(szOriginal, MAX_PATH, pszPath, ppszModule) != 0 );
    }

    ExitProcF(fSuccess);

    return fSuccess;
}


/***************************************************************************
 *
 *  AhGetApplicationId
 *
 *  Description:
 *      Gets the id used to identify the current application.
 *
 *  Arguments:
 *      LPTSTR [out]: receives application id.
 *
 *  Arguments:
 *      LPTSTR [out optional]: receives application name.
 *
 *  Returns: 
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

BOOL AhGetApplicationId
(
    LPTSTR                  pszAppId,
    LPTSTR                  pszAppName
)
{
    HANDLE                  hFile                   = NULL;
    TCHAR                   szExecutable[MAX_PATH];
    LPTSTR                  pszModule;
    IMAGE_NT_HEADERS        nth;
    IMAGE_DOS_HEADER        dh;
    DWORD                   cbRead;
    DWORD                   dwFileSize;
    BOOL                    fSuccess;

    EnterProcI(AhGetApplicationId, (_ ""));
    
    AssertF( pszAppId );

    // Get the application path
    fSuccess = AhGetCurrentApplicationPath(szExecutable, &pszModule);

    if(fSuccess)
    {
        SquirtSqflPtszV(sqfl | sqflVerbose, TEXT("%sApplication executable path: %s"), c_tszPrefix, szExecutable);
        SquirtSqflPtszV(sqfl | sqflVerbose, TEXT("%sApplication module: %s"), c_tszPrefix, pszModule);
    }
                    
    // Open the executable
    if(fSuccess)
    {
        hFile = CreateFile(szExecutable, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

        if(!(( hFile ) && ( hFile != INVALID_HANDLE_VALUE )))
        {
            SquirtSqflPtszV(sqfl | sqflError, TEXT("%sCreateFile failed to open %s with error %lu"), c_tszPrefix, 
                szExecutable, GetLastError());
            fSuccess = FALSE;
        }
    }

    // Read the executable's DOS header
    if(fSuccess)
    {
        fSuccess = ReadFile(hFile, &dh, sizeof(dh), &cbRead, NULL);

        if(!fSuccess || sizeof(dh) != cbRead)
        {
            SquirtSqflPtszV(sqfl | sqflError, TEXT("%sUnable to read DOS header"), c_tszPrefix);
            fSuccess = FALSE;
        }
    }

    if(fSuccess && IMAGE_DOS_SIGNATURE != dh.e_magic)
    {
        SquirtSqflPtszV(sqfl | sqflError, TEXT("%sInvalid DOS signature"), c_tszPrefix);
        fSuccess = FALSE;
    }

    // Read the executable's PE header
    if(fSuccess)
    {
        cbRead = SetFilePointer(hFile, dh.e_lfanew, NULL, FILE_BEGIN);

        if((LONG)cbRead != dh.e_lfanew)
        {
            SquirtSqflPtszV(sqfl | sqflError, TEXT("%sUnable to seek to PE header"), c_tszPrefix);
            fSuccess = FALSE;
        }
    }

    if(fSuccess)
    {
        fSuccess = ReadFile(hFile, &nth, sizeof(nth), &cbRead, NULL);

        if(!fSuccess || sizeof(nth) != cbRead)
        {
            SquirtSqflPtszV(sqfl | sqflError, TEXT("%sUnable to read PE header"), c_tszPrefix);
            fSuccess = FALSE;
        }
    }

    if(fSuccess && IMAGE_NT_SIGNATURE != nth.Signature)
    {
        SquirtSqflPtszV(sqfl | sqflError, TEXT("%sInvalid PE signature"), c_tszPrefix);
        fSuccess = FALSE;
    }

    // Get the executable's size
    if(fSuccess)
    {
        // Assuming < 4 GB
        dwFileSize = GetFileSize(hFile, NULL);

        if((DWORD)(-1) == dwFileSize)
        {
            SquirtSqflPtszV(sqfl | sqflError, TEXT("%sUnable to get file size"), c_tszPrefix);
            fSuccess = FALSE;
        }
    }

    // Create the application id
    if(fSuccess)
    {
        CharUpper(pszModule);
        wsprintf(pszAppId, TEXT("%s%8.8lX%8.8lX"), pszModule, nth.FileHeader.TimeDateStamp, dwFileSize);
        
        if( pszAppName ) 
        {
            lstrcpy(pszAppName, pszModule);
        }

        SquirtSqflPtszV(sqfl | sqflTrace, TEXT("%sApplication id: %s"), c_tszPrefix, pszAppId);
    }

    // Clean up
    if( hFile != NULL )
    {
        CloseHandle( hFile );
    }

    ExitProcF(fSuccess);

    return fSuccess;
}


/***************************************************************************
 *
 *  AhOpenApplicationKey
 *
 *  Description:
 *      Opens or creates the application's root key.
 *
 *  Arguments:
 *      LPCTSTR [in]: application id.
 *
 *  Returns: 
 *      HKEY: registry key handle.
 *
 ***************************************************************************/

HKEY AhOpenApplicationKey
(
    LPCTSTR                 pszAppId
)
{

#ifdef DEBUG

    TCHAR                   szName[0x100]   = { 0 };
    LONG                    cbName          = sizeof(szName);

#endif // DEBUG

    HKEY                    hkeyAll = NULL;
    HKEY                    hkeyApp = NULL;
    HRESULT                 hr;

    EnterProcI(AhOpenApplicationKey, (_ ""));
    
    // Open the parent key
    hr = hresMumbleKeyEx( HKEY_LOCAL_MACHINE, 
        REGSTR_PATH_DINPUT TEXT("\\") REGSTR_KEY_APPHACK, KEY_READ, 0, &hkeyAll );

    if(SUCCEEDED(hr))
    {
        hr = hresMumbleKeyEx( hkeyAll, pszAppId, KEY_READ, 0, &hkeyApp );

        RegCloseKey( hkeyAll );
#ifdef DEBUG

        // Query for the application description
        if(SUCCEEDED(hr))
        {
            JoyReg_GetValue( hkeyApp, NULL, REG_SZ, szName, cbName );
            SquirtSqflPtszV(sqfl | sqflTrace, 
                TEXT( "%sApplication description: %ls"), c_tszPrefix, szName );
        }

#endif // DEBUG
    }

    ExitProc();

    return hkeyApp;
}


/***************************************************************************
 *
 *  AhGetHackValue
 *
 *  Description:
 *      Queries an apphack value.
 *
 *  Arguments:
 *      HKEY [in]: application registry key.
 *      DSAPPHACKID [in]: apphack id.
 *      LPVOID [out]: receives apphack data.
 *      DWORD [in]: size of above data buffer.
 *
 *  Returns: 
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

BOOL AhGetHackValue
(
    HKEY                    hkey,
    DWORD                   dwOSMask,
    DIAPPHACKID             ahid,
    LPVOID                  pvData,
    DWORD                   cbData
)
{
    HRESULT                 hr;
    
    EnterProcI(AhGetHackValue, (_ ""));
    
    AssertF(ahid < (DIAPPHACKID)g_ahtAppHackTable.cEntries);
    AssertF(cbData == g_ahtAppHackTable.aEntries[ahid].cbData);

    if( !( dwOSMask & g_ahtAppHackTable.aEntries[ahid].dwOSMask ) )
    {
        hr = DI_OK;
    }
    else
    {
        hr = JoyReg_GetValue( hkey, g_ahtAppHackTable.aEntries[ahid].pszName, 
            REG_BINARY, pvData, cbData );
        if( !SUCCEEDED( hr ) )
        {
            SquirtSqflPtszV(sqfl | sqflBenign, 
                TEXT("%sfailed to read value \"%s\", code 0x%08x"), 
                c_tszPrefix, g_ahtAppHackTable.aEntries[ahid].pszName, hr);
        }
    }

    ExitProcF(DI_OK == hr);

    return DI_OK == hr;
}


/***************************************************************************
 *
 *  AhGetAppHacks
 *
 *  Description:
 *      Gets all app-hacks for the current application.
 *
 *  Arguments:
 *      LPDSAPPHACKS [out]: receives app-hack data.
 *
 *  Returns: 
 *      BOOL: TRUE if any apphacks exist for the current application.
 *
 ***************************************************************************/

BOOL AhGetAppHacks
(
    LPDIAPPHACKS            pahAppHacks
)
{
    static const DIAPPHACKS ahDefaults                  = { FALSE, FALSE, FALSE, FALSE, FALSE, MAX_PATH };
    TCHAR                   szAppId[MAX_PATH + 8 + 8] = { 0 };
    HKEY                    hkey                        = NULL;
    BOOL                    fSuccess;
    DWORD                   dwOSMask;
    
    EnterProcI(AhGetAppHacks, (_ ""));
    
    // Assume defaults
    CopyMemory(pahAppHacks, &ahDefaults, sizeof(ahDefaults));
    
    // Get the OS version mask
    dwOSMask = AhGetOSMask();

    // Get the application id
    fSuccess = AhGetApplicationId(szAppId, NULL);

    if(fSuccess)
    {
        SquirtSqflPtszV(sqfl | sqflTrace, TEXT("%sFinding apphacks for %s..."), c_tszPrefix, szAppId);
    }

    // Open the application key
    if(fSuccess)
    {
        hkey = AhOpenApplicationKey(szAppId);
        fSuccess = ( hkey && (hkey != INVALID_HANDLE_VALUE ) );
    }

#define GET_APP_HACK( hackid, field ) \
        if( !AhGetHackValue( hkey, dwOSMask, hackid, &pahAppHacks->##field, sizeof(pahAppHacks->##field) ) ) \
        { \
            pahAppHacks->##field = ahDefaults.##field; \
        }

    // Query all apphack values
    if(fSuccess)
    {
        GET_APP_HACK( DICOMPATID_REACQUIRE,             fReacquire );
        GET_APP_HACK( DICOMPATID_NOSUBCLASS,            fNoSubClass );
        GET_APP_HACK( DICOMPATID_MAXDEVICENAMELENGTH,   nMaxDeviceNameLength );
        GET_APP_HACK( DICOMPATID_NATIVEAXISONLY,        fNativeAxisOnly );
        GET_APP_HACK( DICOMPATID_NOPOLLUNACQUIRE,       fNoPollUnacquire );
		GET_APP_HACK( DICOMPATID_SUCCEEDACQUIRE,        fSucceedAcquire );
    }

#undef GET_APP_HACK

    if(fSuccess)
    {
        SquirtSqflPtszV(sqfl | sqflTrace, TEXT("%sfReacquire:    %d"), c_tszPrefix, pahAppHacks->fReacquire );
        SquirtSqflPtszV(sqfl | sqflTrace, TEXT("%sfNoSubClass:   %d"), c_tszPrefix, pahAppHacks->fNoSubClass );
        SquirtSqflPtszV(sqfl | sqflTrace, TEXT("%snMaxDeviceNameLength:   %d"), c_tszPrefix, pahAppHacks->nMaxDeviceNameLength );
        SquirtSqflPtszV(sqfl | sqflTrace, TEXT("%sfNativeAxisOnly:   %d"), c_tszPrefix, pahAppHacks->fNativeAxisOnly );
        SquirtSqflPtszV(sqfl | sqflTrace, TEXT("%sfNoPollUnacquire:   %d"), c_tszPrefix, pahAppHacks->fNoPollUnacquire );
    	SquirtSqflPtszV(sqfl | sqflTrace, TEXT("%sfSucceedAcquire:    %d"), c_tszPrefix, pahAppHacks->fSucceedAcquire );
	}
    else
    {
        SquirtSqflPtszV(sqfl | sqflTrace, TEXT("%sNo apphacks exist"), c_tszPrefix);
    }

    // Clean up
    if( hkey )
    {
        RegCloseKey(hkey);
    }

    ExitProc();

    return fSuccess;
}



HRESULT EXTERNAL AhAppRegister(DWORD dwVer)
{
    TCHAR           szAppName[MAX_PATH];
    TCHAR           szAppId[MAX_PATH + 8 + 8] = { 0 };

    BOOL fSuccess;
    HRESULT hr = E_FAIL;

    fSuccess = AhGetApplicationId(szAppId, szAppName);

    if (fSuccess)
    {
        HKEY hKey;

        hr = hresMumbleKeyEx( HKEY_CURRENT_USER, 
            REGSTR_PATH_LASTAPP, KEY_WRITE, 0, &hKey );

        if( SUCCEEDED(hr) )
        {
            FILETIME ftSysTime;
            GetSystemTimeAsFileTime( &ftSysTime );
            RegSetValueEx(hKey, DIRECTINPUT_REGSTR_VAL_VERSION, 0x0, REG_BINARY, (PUCHAR) &dwVer, cbX(dwVer) );
            RegSetValueEx(hKey, DIRECTINPUT_REGSTR_VAL_NAME, 0x0, REG_SZ, (PUCHAR) szAppName, cbCtch(lstrlen(szAppName)+1) );
            RegSetValueEx(hKey, DIRECTINPUT_REGSTR_VAL_ID, 0x0, REG_SZ, (PUCHAR) szAppId, cbCtch(lstrlen(szAppId)+1) );
            RegSetValueEx(hKey, DIRECTINPUT_REGSTR_VAL_LASTSTART, 0x0, REG_BINARY, (PUCHAR)&ftSysTime, cbX(ftSysTime));
            RegCloseKey(hKey);        
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\didev.c ===
/*****************************************************************************
 *
 *  DIDev.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The standard implementation of IDirectInputDevice.
 *
 *      This is the device-independent part.  the device-dependent
 *      part is handled by the IDirectInputDeviceCallback.
 *
 *      And the IDirectInputEffect support lives in didevef.c.
 *
 *  Contents:
 *
 *      CDIDev_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"
#define INCLUDED_BY_DIDEV
#include "didev.h"


/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Interface_Template_Begin(CDIDev)
Primary_Interface_Template(CDIDev, TFORM(ThisInterfaceT))
Secondary_Interface_Template(CDIDev, SFORM(ThisInterfaceT))
Interface_Template_End(CDIDev)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global PDD * | g_rgpddForeground |
 *
 *          A list of all devices which have obtained foreground
 *          acquisition.  Items on the list have been
 *          held (not AddRef'd).
 *
 *  @global UINT | g_cpddForeground |
 *
 *          The number of entries in <p g_rgpddForeground>.  When foreground
 *          activation is lost, all objects in the array are unacquired.
 *
 *
 *  @global UINT | g_cpddForegroundMax |
 *
 *          The size of the <p g_rgpddForeground> array, including dummy
 *          spaces that are not yet in use.
 *
 *****************************************************************************/

#ifdef IDirectInputDevice2Vtbl

/*
 *  ISSUE-2001/03/29-timgill We assume that all-zeros is a valid initialization.
 */
    GPA g_gpaExcl;
    #define g_hgpaExcl      (&g_gpaExcl)

#else

//
//  ISSUE-2001/03/29-timgill  The following variables should go into diexcl.c or didevex.c
//

PDD *g_rgpddForeground;
UINT g_cpddForeground;
UINT g_cpddForegroundMax;

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | NotAcquired |
 *
 *          Check that the device is not acquired.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns
 *          <c S_OK> if all is well, or <c DIERR_ACQUIRED> if
 *          the device is acquired.
 *
 *****************************************************************************/

#ifndef XDEBUG

    #define IDirectInputDevice_NotAcquired_(pdd, z)                     \
       _IDirectInputDevice_NotAcquired_(pdd)                        \

#endif

HRESULT INLINE
    IDirectInputDevice_NotAcquired_(PDD this, LPCSTR s_szProc)
{
    HRESULT hres;

    if(!this->fAcquired)
    {
        hres = S_OK;
    } else
    {
        RPF("ERROR %s: May not be called while device is acquired", s_szProc);
        hres = DIERR_ACQUIRED;
    }
    return hres;
}

#define IDirectInputDevice_NotAcquired(pdd)                         \
        IDirectInputDevice_NotAcquired_(pdd, s_szProc)              \

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | IsExclAcquired |
 *
 *          Check that the device is acquired exclusively.
 *
 *          The device critical section must already be held.
 *
 *  @cwrap  PDD | this
 *
 *  @returns
 *
 *          <c S_OK> if the device is exclusively acquired.
 *
 *          <c DIERR_INPUTLOST> if acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> the device is acquired,
 *          but not exclusively, or if the device is not acquired
 *          at all.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_IsExclAcquired_(PDD this, LPCSTR s_szProc)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this));

    if(this->discl & DISCL_EXCLUSIVE)
    {
        if(this->fAcquired)
        {
            hres = S_OK;
        } else
        {
            hres = this->hresNotAcquired;
            if(hres == DIERR_NOTACQUIRED)
            {
                hres = DIERR_NOTEXCLUSIVEACQUIRED;
            }
        }
    } else
    {
        hres = DIERR_NOTEXCLUSIVEACQUIRED;
    }

    if(s_szProc && hres == DIERR_NOTEXCLUSIVEACQUIRED)
    {
        RPF("ERROR %s: Device is not acquired in exclusive mode", s_szProc);
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputDevice | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *****************************************************************************/

void EXTERNAL
    CDIDev_EnterCrit_(struct CDIDev *this, LPCTSTR lptszFile, UINT line)
{
#ifdef XDEBUG
    if( ! _TryEnterCritSec(&this->crst) )
    {
        SquirtSqflPtszV(sqflCrit, TEXT("Device CritSec blocked @%s,%d"), lptszFile, line);    
        EnterCriticalSection(&this->crst);
    }

    SquirtSqflPtszV(sqflCrit, TEXT("Device CritSec Entered @%s,%d"), lptszFile, line);    
#else        
    EnterCriticalSection(&this->crst);
#endif

    this->thidCrit = GetCurrentThreadId();
    InterlockedIncrement(&this->cCrit);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputDevice | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *****************************************************************************/

void EXTERNAL
    CDIDev_LeaveCrit_(struct CDIDev *this, LPCTSTR lptszFile, UINT line)
{
#ifdef XDEBUG
    AssertF(this->cCrit);
    AssertF(this->thidCrit == GetCurrentThreadId());
    SquirtSqflPtszV(sqflCrit | sqflVerbose, TEXT("Device CritSec Leaving @%s,%d"), lptszFile, line);    
#endif

    if(InterlockedDecrement(&this->cCrit) == 0)
    {
        this->thidCrit = 0;
    }
    LeaveCriticalSection(&this->crst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputDevice | SetNotifyEvent |
 *
 *          Set the event associated with the device, if any.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *****************************************************************************/

void EXTERNAL
    CDIDev_SetNotifyEvent(PDD this)
{
    if(this->hNotify)
    {
        SetEvent(this->hNotify);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputDevice | SetForcedUnacquiredFlag |
 *
 *          When forced unacquired happens, set the fOnceForcedUnacquired flag.
 *
 *****************************************************************************/

void EXTERNAL
    CDIDev_SetForcedUnacquiredFlag(PDD this)
{
    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this->fOnceForcedUnacquired = 1;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | CDIDev | InCrit |
 *
 *          Nonzero if we are in the critical section.
 *
 *****************************************************************************/

#ifdef DEBUG

BOOL INTERNAL
    CDIDev_InCrit(PDD this)
{
    return this->cCrit && this->thidCrit == GetCurrentThreadId();
}

#endif

#ifdef DEBUG

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | IDirectInputDevice | IsConsistent |
 *
 *          Check that various state variables are consistent.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *****************************************************************************/

    #define VerifyF(f)  if (!(f)) fRc = 0

BOOL INTERNAL
    CDIDev_IsConsistent(PDD this)
{
    BOOL fRc = 1;

    /*
     *  If acquired, then we must have a translation table, a state manager,
     *  and a device callback.
     */

    if(this->fAcquired)
    {
        VerifyF(this->pdix && this->GetState && this->pdcb != c_pdcbNil);
    }

    /*
     *  If buffering, then must have a device callback.
     */
    if(this->celtBuf)
    {
        VerifyF(this->pdcb != c_pdcbNil);
    }

    /*
     *  If managing an instance, then make sure buffer variables are
     *  consistent.
     */
    if(this->pvi)
    {
        if(this->celtBuf)
        {
            VerifyF(   this->pvi->pBuffer
                       && this->pvi->pEnd
                       && this->pvi->pHead
                       && this->pvi->pTail);
            VerifyF(this->pvi->pBuffer < this->pvi->pEnd);
            VerifyF(fInOrder((DWORD)(UINT_PTR)this->pvi->pBuffer,
                             (DWORD)(UINT_PTR)this->pvi->pHead,
                             (DWORD)(UINT_PTR)this->pvi->pEnd));
            VerifyF(fInOrder((DWORD)(UINT_PTR)this->pvi->pBuffer,
                             (DWORD)(UINT_PTR)this->pvi->pTail,
                             (DWORD)(UINT_PTR)this->pvi->pEnd));
        } else
        {
            VerifyF(   this->pvi->pBuffer == 0
                       && this->pvi->pEnd == 0
                       && this->pvi->pHead == 0
                       && this->pvi->pTail == 0);
        }
    }

    /*
     *  The cooperative levels must match the cached window handle.
     */
    VerifyF(fLimpFF(this->discl & (DISCL_FOREGROUND | DISCL_EXCLUSIVE),
                    this->hwnd));

    return fRc;
}

    #undef VerifyF

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CDIDev)
Default_AddRef(CDIDev)
Default_Release(CDIDev)

#else

    #define CDIDev_QueryInterface           Common_QueryInterface
    #define CDIDev_AddRef                   Common_AddRef
    #define CDIDev_Release                  Common_Release
#endif

#ifdef IDirectInputDevice2Vtbl

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInput | QIHelper |
 *
 *          Support the original IDirectInputDevice interfaces as well
 *          as the new IDirectInputDevice2 interfaces.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_QIHelper(PDD this, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(CDIDev_QIHelper, (_ "pG", this, riid));

    if(IsEqualIID(riid, &IID_IDirectInputDeviceA))
    {

        *ppvObj = &this->ddA;
        OLE_AddRef(this);
        hres = S_OK;

    } else if(IsEqualIID(riid, &IID_IDirectInputDeviceW))
    {

        *ppvObj = &this->ddW;
        OLE_AddRef(this);
        hres = S_OK;

    #ifdef IDirectInputDevice7Vtbl
    } else if(IsEqualIID(riid, &IID_IDirectInputDevice2A))
    {

        *ppvObj = &this->ddA;
        OLE_AddRef(this);
        hres = S_OK;

    } else if(IsEqualIID(riid, &IID_IDirectInputDevice2W))
    {

        *ppvObj = &this->ddW;
        OLE_AddRef(this);
        hres = S_OK;
    #endif
    } else
    {
        hres = Common_QIHelper(this, riid, ppvObj);
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

#else

    #define CDIDev_QIHelper                 Common_QIHelper

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_Reset |
 *
 *          Releases all the resources of a generic device that
 *          are associated with a particular device instance.
 *
 *          This method is called in preparation for reinitialization.
 *
 *          It is the responsibility of the caller to have taken
 *          any necessary critical sections.
 *
 *
 *  @parm   PV | pvObj |
 *
 *          Object being reset.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_Reset(PDD this)
{
    HRESULT hres;

    if(!this->fAcquired)
    {

        /*
         *  Note! that we must release the driver before releasing
         *  the callback, because the callback will unload the
         *  driver DLL.
         *
         *  We cannot allow people to reset the device
         *  while there are still effects outstanding,
         *  because that would cause us to throw away the
         *  callback while the effects are still using
         *  the effect driver!
         */
#ifdef IDirectInputDevice2Vtbl
        if(this->gpaEff.cpv == 0)
        {
            Invoke_Release(&this->pes);
#endif
            Invoke_Release(&this->pdcb);
            this->pdcb = c_pdcbNil;
            FreePpv(&this->pdix);
            FreePpv(&this->rgiobj);
#ifdef BUGGY_DX7_WINNT
            FreePpv(&this->pdix2);
            FreePpv(&this->rgiobj2);
#endif //BUGGY_DX7_WINNT
            FreePpv(&this->pvBuffer);
            FreePpv(&this->pvLastBuffer);
            FreePpv(&this->rgdwAxesOfs);
#ifdef IDirectInputDevice2Vtbl
            FreePpv(&this->rgemi);
#endif
            FreePpv(&this->rgdwPOV);

            AssertF(!this->fAcquired);
            AssertF(!this->fAcquiredInstance);

            if(this->hNotify)
            {
                CloseHandle(this->hNotify);
            }

            ZeroBuf(&this->hwnd, FIELD_OFFSET(DD, celtBufMax) -
                    FIELD_OFFSET(DD, hwnd));
            ZeroX(this->guid);
            this->celtBufMax = 1023;
            this->GetDeviceState = CDIDev_GetAbsDeviceState;
            this->hresNotAcquired = DIERR_NOTACQUIRED;
            this->fCook = 0;

            AssertF(this->hNotify == 0);
#ifdef IDirectInputDevice2Vtbl
            AssertF(this->cemi == 0);
            AssertF(this->didcFF == 0);
            this->dwGain = 10000;               /* Default to full gain */
            this->dwAutoCenter = DIPROPAUTOCENTER_ON; /* Default to centered */
            GPA_InitFromZero(&this->gpaEff);
#endif

            /*
             *  If the app does not initialize, then assume DX 3.
             */
            this->didftInstance = 0x0000FF00;

            hres = S_OK;

#ifdef IDirectInputDevice2Vtbl
        } else
        {
            RPF("IDirectInputDevice::Initialize: Device still has effects");
            hres = DIERR_HASEFFECTS;
        }
#endif
    } else
    {
        RPF("IDirectInputDevice::Initialize: Device is busy");
        hres = DIERR_ACQUIRED;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIDev_AppFinalize |
 *
 *          The application has performed its final release.
 *
 *          If the device is acquired, then unacquire it.
 *
#ifdef IDirectInputDevice2Vtbl
 *          Release the holds on all the created effects that
 *          we have been hanging onto for enumeration purposes.
#endif
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
    CDIDev_AppFinalize(PV pvObj)
{
    PDD this = pvObj;

    if(this->fAcquired)
    {
        RPF("IDirectInputDevice::Release: Forgot to call Unacquire()");
        CDIDev_InternalUnacquire(pvObj);
    }

#ifdef IDirectInputDevice2Vtbl
    if(this->fCritInited)
    {
        /*
         *  Stop all the effects, if they are playing.
         *
         *  Then unhold them (because we're done).
         *
         *  ISSUE-2001/03/29-timgill Need to totally remove all effects created by a destroyed device
         *  We also need to neuter them so they don't
         *  do anything any more.  Otherwise, an app might
         *  destroy the parent device and then try to mess with
         *  an effect created by that device after the device
         *  is gone.
         *
         *  Note that we cannot call the effect while inside our
         *  private little critical section, because the effect
         *  may need to do crazy things to stop itself.
         *
         *  (It will almost certainly call back up into the device
         *  to remove itself from the list of created effects.)
         */
        UINT ipdie;
        PPDIE rgpdie;
        UINT cpdie;

        CDIDev_EnterCrit(this);

        rgpdie = (PV)this->gpaEff.rgpv;
        cpdie = this->gpaEff.cpv;
        GPA_Init(&this->gpaEff);

        CDIDev_LeaveCrit(this);

        for(ipdie = 0; ipdie < cpdie; ipdie++)
        {
            AssertF(rgpdie[ipdie]);
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("Device %p forgot to destroy effect %08x"),
                            this, rgpdie[ipdie]);

            IDirectInputEffect_Stop(rgpdie[ipdie]);
            Common_Unhold(rgpdie[ipdie]);
        }
        FreePpv(&rgpdie);
    }
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIDev_Finalize |
 *
 *          Releases the resources of a generic device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
    CDIDev_Finalize(PV pvObj)
{
    HRESULT hres;
    PDD this = pvObj;

#ifdef XDEBUG
    if(this->cCrit)
    {
        RPF("IDirectInputDevice::Release: Another thread is using the object; crash soon!");
    }
#endif

    AssertF(!this->fAcquired);

    /*
     *  Note that we cannot take the critical section because it
     *  might not exist.  (We might've died during initialization.)
     *  Fortunately, we finalize only after every possible client
     *  (both internal and external) has done its final Release(),
     *  so it's impossible for any other method to get called at
     *  this point.
     */
    hres = CDIDev_Reset(this);
    AssertF(SUCCEEDED(hres));

    if(this->fCritInited)
    {
        DeleteCriticalSection(&this->crst);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIDev | GetVersions |
 *
 *          Obtain version information from the device.
 *
 *          First try to get it from the effect driver.  If
 *          that doesn't work, then get it from the VxD.
 *          And if that doesn't work, then tough.
 *
 *  @parm   IN OUT LPDIDRIVERVERSIONS | pvers |
 *
 *          Receives version information.
 *
 *****************************************************************************/

void INLINE
    CDIDev_GetVersions(PDD this, LPDIDRIVERVERSIONS pvers)
{
    HRESULT hres;

    /*
     *  Pre-fill with zeros in case nobody implements GetVersions.
     */
    pvers->dwSize = cbX(*pvers);
    pvers->dwFirmwareRevision = 0;
    pvers->dwHardwareRevision = 0;
    pvers->dwFFDriverVersion  = 0;

    hres = CDIDev_CreateEffectDriver(this);
    if(SUCCEEDED(hres) &&
       SUCCEEDED(hres = this->pes->lpVtbl->
                 GetVersions(this->pes, pvers)))
    {
    } else
    {
        hres = this->pdcb->lpVtbl->GetVersions(this->pdcb, pvers);
    }
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetCapabilities |
 *
 *          Obtains information about the device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN OUT LPDIDEVCAPS | lpdc |
 *
 *          Points to a <t DIDEVCAPS> structure that is filled in
 *          by the function.  The <e DIDEVCAPS.dwSize>
 *          field "must" be filled in
 *          by the application before calling this method.
 *          See the documentation of the <t DIDEVCAPS> structure
 *          for additional information.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpDirectInputDevice> or
 *          <p lpdc> parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetCapabilities(PV pdd, LPDIDEVCAPS pdc _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::GetCapabilities, (_ "pp", pdd, pdc));

    if(SUCCEEDED(hres = hresPvT(pdd)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb2(pdc,
                                                DIDEVCAPS_DX5,
                                                DIDEVCAPS_DX3, 1)))
    {
        PDD this = _thisPv(pdd);

        CDIDev_EnterCrit(this);

        /*
         *  For the convenience of the callback, zero out all the fields,
         *  save for the dwSize.
         */
        ZeroBuf(pvAddPvCb(pdc, cbX(DWORD)), pdc->dwSize - cbX(DWORD));
        hres = this->pdcb->lpVtbl->GetCapabilities(this->pdcb, pdc);

        if(SUCCEEDED(hres))
        {
            /*
             *  We'll handle the DIDC_EMULATED and
             *  DIDC_POLLEDDATAFORMAT bits to save the callback
             *  some trouble.
             */
            AssertF(this->pvi);
            if(this->pvi->fl & VIFL_EMULATED)
            {
                pdc->dwFlags |= DIDC_EMULATED;
            }
            if(this->fPolledDataFormat)
            {
                pdc->dwFlags |= DIDC_POLLEDDATAFORMAT;
            }

#ifdef IDirectInputDevice2Vtbl
            /*
             *  Add in the force feedback flags, too.
             */
            pdc->dwFlags |= this->didcFF;

            /*
             *  If the caller wants force feedback parameters, then
             *  set them, too.
             */
            if(pdc->dwSize >= cbX(DIDEVCAPS_DX5))
            {
                DIDRIVERVERSIONS vers;

                pdc->dwFFSamplePeriod      = this->ffattr.dwFFSamplePeriod;
                pdc->dwFFMinTimeResolution = this->ffattr.dwFFMinTimeResolution;

                CDIDev_GetVersions(this, &vers);
                pdc->dwFirmwareRevision    = vers.dwFirmwareRevision;
                pdc->dwHardwareRevision    = vers.dwHardwareRevision;
                pdc->dwFFDriverVersion     = vers.dwFFDriverVersion;

            }
#endif
            hres = S_OK;
        }

        CDIDev_LeaveCrit(this);

        ScrambleBit(&pdc->dwDevType, DIDEVTYPE_RANDOM);
        ScrambleBit(&pdc->dwFlags,   DIDC_RANDOM);

    }

    ExitOleProcR();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(GetCapabilities, (PV pdd, LPDIDEVCAPS pdc), (pdd, pdc THAT_))

#else

    #define CDIDev_GetCapabilitiesA         CDIDev_GetCapabilities
    #define CDIDev_GetCapabilitiesW         CDIDev_GetCapabilities

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | GetDataFormat |
 *
 *          Get the data format for the device if we don't have it already.
 *
 *  @parm   PDD | this |
 *
 *          Device object.
 *
 *  @returns
 *
 *          COM return code.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetDataFormat(PDD this)
{
    HRESULT hres;
    LPDIDATAFORMAT pdf;

    /*
     *  If the DIDATAFORMAT structure changes, you also need to invent
     *  a new DCB message (DIDM_GETDATAFORMAT2), and then do
     *  the right thing when faced with a mix of old and new.
     */

    hres = this->pdcb->lpVtbl->GetDataFormat(this->pdcb, &pdf);


    /*
     * Note!  We don't support external drivers in this release,
     * so it's okay to treat these are Assert's and not try to recover.
     */

    if(SUCCEEDED(hres))
    {
        AssertF(pdf->dwSize == sizeof(this->df));
        this->df = *pdf;

        AssertF(!IsBadReadPtr(pdf->rgodf, cbCxX(pdf->dwNumObjs, ODF)));

        /*
         *  Prepare the axis goo in case the app sets relative mode.
         */
        if(SUCCEEDED(hres = ReallocCbPpv(pdf->dwDataSize,
                                         &this->pvLastBuffer)) &&
           SUCCEEDED(hres = ReallocCbPpv(cbCdw(pdf->dwNumObjs),
                                         &this->rgdwAxesOfs)))
        {

            UINT iobj;
            this->cAxes = 0;

            for(iobj = 0; iobj < pdf->dwNumObjs; iobj++)
            {
                AssertF(pdf->rgodf[iobj].dwOfs < pdf->dwDataSize);
                if(pdf->rgodf[iobj].dwType & DIDFT_AXIS)
                {
                    this->rgdwAxesOfs[this->cAxes++] = pdf->rgodf[iobj].dwOfs;
                }
            }
        }

    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | GetPolled |
 *
 *          Determine whether the device is polled.
 *
 *  @parm   PDD | this |
 *
 *          Device object.
 *
 *  @returns
 *
 *          COM result code.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetPolled(PDD this)
{
    HRESULT hres;
    DIDEVCAPS_DX3 dc;

    /*
     *  We intentionally use a DIDEVCAPS_DX3 because going for
     *  a full DIDEVCAPS_DX5 requires us to load the force
     *  feedback driver which is pointless for our current
     *  goal.
     */
    ZeroX(dc);
    dc.dwSize = cbX(dc);

    hres = this->pdcb->lpVtbl->GetCapabilities(this->pdcb, (PV)&dc);
    if(SUCCEEDED(hres))
    {
        if(dc.dwFlags & DIDC_POLLEDDEVICE)
        {
            this->hresPolled = DI_POLLEDDEVICE;
        } else
        {
            this->hresPolled = S_OK;
        }
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | GetObjectInfoHelper |
 *
 *          Set up all the information we can deduce ourselves and
 *          have the callback finish.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPCDIPROPINFO | ppropi |
 *
 *          Object descriptor.
 *
 *  @parm   LPDIDEVICEOBJECTINSTANCEW | pdoiW |
 *
 *          Structure to receive result.
 *
 *****************************************************************************/
 
STDMETHODIMP
    CDIDev_GetObjectInfoHelper(PDD this, LPCDIPROPINFO ppropi,
                               LPDIDEVICEOBJECTINSTANCEW pdoiW)
{
    HRESULT hres;

    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEW(pdoiW->dwSize));
    pdoiW->guidType = *this->df.rgodf[ppropi->iobj].pguid;
    pdoiW->dwType   =  this->df.rgodf[ppropi->iobj].dwType;
    pdoiW->dwFlags  =  this->df.rgodf[ppropi->iobj].dwFlags;
    ScrambleBit(&pdoiW->dwFlags, DIDOI_RANDOM);
    if( this->pdix )
    {
        /* User data format offset */
        pdoiW->dwOfs    =  this->pdix[ppropi->iobj].dwOfs;
    } else
    {
#ifdef BUGGY_DX7_WINNT
        if( (this->dwVersion < 0x700) && (this->dwVersion != 0x5B2) &&
            this->pdix2 )
        {
            pdoiW->dwOfs    =  this->pdix2[ppropi->iobj].dwOfs;
        } else 
#endif //BUGGY_DX7_WINNT
        {
            /* Internal data format offset */
            pdoiW->dwOfs    =  this->df.rgodf[ppropi->iobj].dwOfs;
        }
    }

    /*
     *  Wipe out everything starting at tszName.
     */
    ZeroBuf(&pdoiW->tszName,
            pdoiW->dwSize - FIELD_OFFSET(DIDEVICEOBJECTINSTANCEW, tszName));

    hres = this->pdcb->lpVtbl->GetObjectInfo(this->pdcb, ppropi, pdoiW);

    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | EnumObjects |
 *
 *          Enumerate the input sources (buttons, axes)
 *          available on a device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN LPDIENUMDEVICEOBJECTSCALLBACK | lpCallback |
 *
 *          Callback function.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Reference data (context) for callback.
 *
 *  @parm   IN DWORD | fl |
 *
 *          Flags specifying the type(s) of objects to be enumerated.
 *          See the section "DirectInput Data Format Types" for a
 *          list of flags that can be passed.
 *
 *          Furthermore, the enumeration can be restricted to objects
 *          from a single HID link collection by using the
 *          <f DIDFT_ENUMCOLLECTION> macro.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p fl> parameter contains invalid flags, or the callback
 *          procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumDeviceObjectsProc |
 *
 *          An application-defined callback function that receives
 *          DirectInputDevice objects as a result of a call to the
 *          <om IDirectInputDevice::EnumObjects> method.
 *
 *  @parm   IN LPCDIDEVICEOBJECTINSTANCE | lpddoi |
 *
 *          A <t DIDEVICEOBJECTINSTANCE> structure which describes
 *          the object being enumerated.
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputDevice::EnumObjects> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *  @ex
 *
 *          To enumerate all axis objects:
 *
 *          |
 *
 *          // C++
 *          HRESULT hr = pDevice->EnumObjects(EnumProc, RefData, DIDFT_AXIS);
 *
 *          // C
 *          hr = IDirectInputDevice_EnumObjects(pDevice, EnumProc, RefData,
 *                                              DIDFT_AXIS);
 *
 *  @ex
 *
 *          To enumerate all objects in the third HID link collection:
 *
 *          |
 *
 *          // C++
 *          HRESULT hr = pDevice->EnumObjects(EnumProc, RefData,
 *                                            DIDFT_ENUMCOLLECTION(3));
 *
 *          // C
 *          hr = IDirectInputDevice_EnumObjects(pDevice, EnumProc, RefData,
 *                                              DIDFT_ENUMCOLLECTION(3));
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_EnumObjectsW
    (PV pddW, LPDIENUMDEVICEOBJECTSCALLBACKW pec, LPVOID pvRef, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::EnumObjectsW, (_ "ppx", pddW, pec, fl));

    if(SUCCEEDED(hres = hresPvW(pddW)) &&
       SUCCEEDED(hres = hresFullValidPfn(pec, 1)) &&
       SUCCEEDED(hres = hresFullValidFl(fl, DIDFT_ENUMVALID, 3)))
    {
        PDD this = _thisPvNm(pddW, ddW);
        DWORD flExclude;
        WORD wCollection;

        /*
         *  We snapshot the object information underneath the critical
         *  section so we don't blow up if another thread Reset()s
         *  the device in the middle of an enumeration.  The DIDATAFORMAT
         *  contains pointers to the dcb, so we need to AddRef the
         *  dcb as well.
         */
        AssertF(!CDIDev_InCrit(this));
        CDIDev_EnterCrit(this);

        if(this->pdcb != c_pdcbNil)
        {
            DIPROPINFO propi;
            DIDATAFORMAT df;
            IDirectInputDeviceCallback *pdcb;

            pdcb = this->pdcb;
            OLE_AddRef(pdcb);
            df = this->df;

            CDIDev_LeaveCrit(this);
            AssertF(!CDIDev_InCrit(this));

            /*
             *  If the client is DX3, don't enumerate things that
             *  didn't exist in DX3.
             */
            if(this->dwVersion <= 0x0300)
            {
                flExclude = DIDFT_ALLOBJS & ~DIDFT_ALLOBJS_DX3;
            } else
            {
                flExclude = 0;

                /* Exclude alises if necessary */
                if( !(fl & DIDFT_ALIAS) )
                {
                    flExclude |= DIDFT_ALIAS;
                } else
                {
                    fl &= ~DIDFT_ALIAS;
                }

                /* Exclude Vendor Defined fields */
                if( !(fl & DIDFT_VENDORDEFINED) )
                {
                    flExclude |= DIDFT_VENDORDEFINED;
                } else
                {
                    fl &= ~DIDFT_VENDORDEFINED;
                }
            }

            if(fl == DIDFT_ALL)
            {
                fl = DIDFT_ALLOBJS;
            }

            /*
             *  Pull out the link collection we are enumerating.
             *  Note: Backwards compatibility hack.  We can't
             *  use link collection 0 to mean "no parent" because
             *  0 means "don't care".  So instead, we use 0xFFFF
             *  to mean "no parent".  This means that we need to
             *  interchange 0 and 0xFFFF before entering the main
             *  loop.
             */
            wCollection = DIDFT_GETCOLLECTION(fl);
            switch(wCollection)
            {

            case 0:
                wCollection = 0xFFFF;
                break;

            case DIDFT_GETCOLLECTION(DIDFT_NOCOLLECTION):
                wCollection = 0;
                break;
            }

            propi.pguid = 0;

#ifdef BUGGY_DX7_WINNT
            //Whistler bug 151479 - for pre-DX7 apps on WINNT only, make sure that the
            //enumeration order is same as the winmm one
            if( (this->dwVersion < 0x700) && (this->dwVersion != 0x5B2) &&
                (this->pdix2) && (this->rgiobj2))
            {
                UINT iobj;
                
                for(iobj = 0; iobj < this->dwDataSize2; iobj++)
                {
                    propi.iobj = this->rgiobj2[iobj];
                    if (propi.iobj == -1)
                    {
                        continue;
                    }

                    propi.dwDevType = df.rgodf[propi.iobj].dwType;
                    if((propi.dwDevType & fl & DIDFT_TYPEMASK) &&
                       fHasAllBitsFlFl(propi.dwDevType, fl & DIDFT_ATTRMASK) &&
                       !(propi.dwDevType & flExclude))
                    {
                        DIDEVICEOBJECTINSTANCEW doiW;
                        doiW.dwSize = cbX(doiW);

                        hres = CDIDev_GetObjectInfoHelper(this, &propi, &doiW);
                        if(SUCCEEDED(hres) &&
                           fLimpFF(wCollection != 0xFFFF,
                                   doiW.wCollectionNumber == wCollection))
                        {
                            BOOL fRc = Callback(pec, &doiW, pvRef);

                            switch(fRc)
                            {
                            case DIENUM_STOP: goto enumdoneok;
                            case DIENUM_CONTINUE: break;
                            default:
                                RPF("IDirectInputDevice::EnumObjects: Invalid return value from enumeration callback");
                                ValidationException();
                                break;
                            }
                        } else
                        {
                            goto enumdonefail;
                        }
                    }
                }
            }
            else
#endif //BUGGY_DX7_WINNT
            {
                for(propi.iobj = 0; propi.iobj < df.dwNumObjs; propi.iobj++)
                {
                    propi.dwDevType = df.rgodf[propi.iobj].dwType;
                    if((propi.dwDevType & fl & DIDFT_TYPEMASK) &&
                       fHasAllBitsFlFl(propi.dwDevType, fl & DIDFT_ATTRMASK) &&
                       !(propi.dwDevType & flExclude))
                    {
                        DIDEVICEOBJECTINSTANCEW doiW;
                        doiW.dwSize = cbX(doiW);

                        hres = CDIDev_GetObjectInfoHelper(this, &propi, &doiW);
                        if(SUCCEEDED(hres) &&
                           fLimpFF(wCollection != 0xFFFF,
                                   doiW.wCollectionNumber == wCollection))
                        {
                            BOOL fRc = Callback(pec, &doiW, pvRef);

                            switch(fRc)
                            {
                            case DIENUM_STOP: goto enumdoneok;
                            case DIENUM_CONTINUE: break;
                            default:
                                RPF("IDirectInputDevice::EnumObjects: Invalid return value from enumeration callback");
                                ValidationException();
                                break;
                            }
                        } else
                        {
                            goto enumdonefail;
                        }
                    }
                }
            }

            enumdoneok:;
            hres = S_OK;
            enumdonefail:;

            OLE_Release(pdcb);

        } else
        {
            CDIDev_LeaveCrit(this);
            RPF("ERROR: IDirectInputDevice: Not initialized");
            hres = DIERR_NOTINITIALIZED;
        }
    }

    ExitOleProcR();
    return hres;
}

#define CDIDev_EnumObjects2W            CDIDev_EnumObjectsW

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDeviceA | EnumObjectsCallbackA |
 *
 *          Custom callback that wraps
 *          <mf IDirectInputDeviceW::EnumObjects> which
 *          translates the UNICODE string to ANSI.
 *
 *  @parm   IN LPCDIENUMDEVICEOBJECTINSTANCE | pdoiW |
 *
 *          Structure to be translated to ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Pointer to <t struct ENUMDEVICEOBJECTINFO> which describes
 *          the original callback.
 *
 *  @returns
 *
 *          Returns whatever the original callback returned.
 *
 *****************************************************************************/

typedef struct ENUMOBJECTSINFO
{
    LPDIENUMDEVICEOBJECTSCALLBACKA pecA;
    PV pvRef;
} ENUMOBJECTSINFO, *PENUMOBJECTSINFO;

BOOL CALLBACK
    CDIDev_EnumObjectsCallbackA(LPCDIDEVICEOBJECTINSTANCEW pdoiW, PV pvRef)
{
    PENUMOBJECTSINFO peoi = pvRef;
    BOOL fRc;
    DIDEVICEOBJECTINSTANCEA doiA;
    EnterProc(CDIDev_EnumObjectsCallbackA,
              (_ "GxxWp", &pdoiW->guidType,
               pdoiW->dwOfs,
               pdoiW->dwType,
               pdoiW->tszName, pvRef));

    doiA.dwSize = cbX(doiA);
    ObjectInfoWToA(&doiA, pdoiW);

    fRc = peoi->pecA(&doiA, peoi->pvRef);

    ExitProcX(fRc);
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDeviceA | EnumObjects |
 *
 *          Enumerate the input sources (buttons, axes)
 *          available on a device, in ANSI.
 *          See <mf IDirectInputDevice::EnumObjects> for more information.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN LPDIENUMDEVICEOBJECTSCALLBACK | lpCallback |
 *
 *          Same as <mf IDirectInputDeviceW::EnumObjects>, except in ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Same as <mf IDirectInputDeviceW::EnumObjects>.
 *
 *  @parm   IN DWORD | fl |
 *
 *          Same as <mf IDirectInputDeviceW::EnumObjects>.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_EnumObjectsA
    (PV pddA, LPDIENUMDEVICEOBJECTSCALLBACKA pec, LPVOID pvRef, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputDeviceA::EnumDevices,
               (_ "pppx", pddA, pec, pvRef, fl));

    /*
     *  EnumObjectsW will validate the rest.
     */
    if(SUCCEEDED(hres = hresPvA(pddA)) &&
       SUCCEEDED(hres = hresFullValidPfn(pec, 1)))
    {
        ENUMOBJECTSINFO eoi = { pec, pvRef};
        PDD this = _thisPvNm(pddA, ddA);

        hres = CDIDev_EnumObjectsW(&this->ddW, CDIDev_EnumObjectsCallbackA,
                                   &eoi, fl);
    }

    ExitOleProcR();
    return hres;
}

#define CDIDev_EnumObjects2A            CDIDev_EnumObjectsA

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | SetEventNotification |
 *
 *          Specify the event that should be set when the device
 *          state changes, or turns off such notifications.
 *
 *          A device state change is defined as any of the following:
 *
 *          - A change in the position of an axis.
 *
 *          - A change in the state (pressed or released) of a button.
 *
 *          - A change in the direction of a POV control.
 *
 *          - Loss of acquisition.
 *
 *          "It is an error" to call <f CloseHandle> on the event
 *          while it has been selected into an <i IDirectInputDevice>
 *          object.  You must call
 *          <mf IDirectInputDevice::SetEventNotification> with the
 *          <p hEvent> parameter set to NULL before closing the
 *          event handle.
 *
 *          The event notification handle cannot be changed while the
 *          device is acquired.
 *
 *          If the function is successful, then the application can
 *          use the event handle in the same manner as any other
 *          Win32 event handle.  Examples of usage are shown below.
 *          For additional information on using Win32 wait functions,
 *          see the Win32 SDK and related documentation.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN HANDLE | hEvent |
 *
 *          Specifies the event handle which will be set when the
 *          device state changes.  It "must" be an event
 *          handle.  DirectInput will <f SetEvent> the handle when
 *          the state of the device changes.
 *
 *          The application should create the handle via the
 *          <f CreateEvent> function.  If the event is created as
 *          an automatic-reset event, then the operating system will
 *          automatically reset the event once a wait has been
 *          satisfied.  If the event is created as a manual-reset
 *          event, then it is the application's responsibility to
 *          call <f ResetEvent> to reset it.  DirectInput will not
 *          call <f ResetEvent> for event notification handles.
 *
 *          If the <p hEvent> is zero, then notification is disabled.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_HANDLEEXISTS>: The  <i IDirectInputDevice> object
 *          already has an event notification handle
 *          associated with it.  DirectInput supports only one event
 *          notification handle per <i IDirectInputDevice> object.
 *
 *          <c DIERR_ACQUIRED>: The <i IDirectInputDevice> object
 *          has been acquired.  You must <mf IDirectInputDevice::Unacquire>
 *          the device before you can change the notification state.
 *
 *          <c E_INVALIDARG>: The thing isn't an event handle.
 *
 *  @ex
 *
 *          To check if the handle is currently set without blocking:
 *
 *          |
 *
 *          dwResult = WaitForSingleObject(hEvent, 0);
 *          if (dwResult == WAIT_OBJECT_0) {
 *              // Event is set.  If the event was created as
 *              // automatic-reset, then it has also been reset.
 *          }
 *
 *  @ex
 *
 *          The following example illustrates blocking
 *          indefinitely until the event is set.  Note that this
 *          behavior is <y strongly> discouraged because the thread
 *          will not respond to the system until the wait is
 *          satisfied.  (In particular, the thread will not respond
 *          to Windows messages.)
 *
 *          |
 *
 *          dwResult = WaitForSingleObject(hEvent, INFINITE);
 *          if (dwResult == WAIT_OBJECT_0) {
 *              // Event has been set.  If the event was created as
 *              // automatic-reset, then it has also been reset.
 *          }
 *
 *  @ex
 *
 *          The following example illustrates a typical message loop
 *          for a message-based application that uses two events.
 *
 *          |
 *
 *          HANDLE ah[2] = { hEvent1, hEvent2 };
 *
 *          while (TRUE) {
 *
 *              dwResult = MsgWaitForMultipleObjects(2, ah, FALSE,
 *                                                   INFINITE, QS_ALLINPUT);
 *              switch (dwResult) {
 *              case WAIT_OBJECT_0:
 *                  // Event 1 has been set.  If the event was created as
 *                  // automatic-reset, then it has also been reset.
 *                  ProcessInputEvent1();
 *                  break;
 *
 *              case WAIT_OBJECT_0 + 1:
 *                  // Event 2 has been set.  If the event was created as
 *                  // automatic-reset, then it has also been reset.
 *                  ProcessInputEvent2();
 *                  break;
 *
 *              case WAIT_OBJECT_0 + 2:
 *                  // A Windows message has arrived.  Process messages
 *                  // until there aren't any more.
 *                  while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
 *                      if (msg.message == WM_QUIT) {
 *                          goto exitapp;
 *                      }
 *                      TranslateMessage(&msg);
 *                      DispatchMessage(&msg);
 *                  }
 *                  break;
 *
 *              default:
 *                  // Unexpected error.
 *                  Panic();
 *                  break;
 *              }
 *          }
 *
 *  @ex
 *
 *          The following example illustrates a typical application loop
 *          for a non-message-based application that uses two events.
 *
 *          |
 *
 *          HANDLE ah[2] = { hEvent1, hEvent2 };
 *          DWORD dwWait = 0;
 *
 *          while (TRUE) {
 *
 *              dwResult = MsgWaitForMultipleObjects(2, ah, FALSE,
 *                                                   dwWait, QS_ALLINPUT);
 *              dwWait = 0;
 *
 *              switch (dwResult) {
 *              case WAIT_OBJECT_0:
 *                  // Event 1 has been set.  If the event was created as
 *                  // automatic-reset, then it has also been reset.
 *                  ProcessInputEvent1();
 *                  break;
 *
 *              case WAIT_OBJECT_0 + 1:
 *                  // Event 2 has been set.  If the event was created as
 *                  // automatic-reset, then it has also been reset.
 *                  ProcessInputEvent2();
 *                  break;
 *
 *              case WAIT_OBJECT_0 + 2:
 *                  // A Windows message has arrived.  Process messages
 *                  // until there aren't any more.
 *                  while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
 *                      if (msg.message == WM_QUIT) {
 *                          goto exitapp;
 *                      }
 *                      TranslateMessage(&msg);
 *                      DispatchMessage(&msg);
 *                  }
 *                  break;
 *
 *              default:
 *                  // No input or messages waiting.
 *                  // Do a frame of the game.
 *                  // If the game is idle, then tell the next wait
 *                  // to wait indefinitely for input or a message.
 *                  if (!DoGame()) {
 *                      dwWait = INFINITE;
 *                  }
 *                  // Poll for data in case the device is not
 *                  // interrupt-driven.
 *                  IDirectInputDevice2_Poll(pdev);
 *                  break;
 *              }
 *          }
 *
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetEventNotification(PV pdd, HANDLE h _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::SetEventNotification, (_ "px", pdd, h));

    if(SUCCEEDED(hres = hresPvT(pdd)))
    {
        PDD this = _thisPv(pdd);

        /*
         *  Must protect with the critical section to prevent somebody from
         *  acquiring or setting a new event handle while we're changing it.
         */
        CDIDev_EnterCrit(this);

        if(!this->fAcquired)
        {
            /*
             *  Don't operate on the original handle because the app 
             *  might decide to do something to it on another thread.
             */

            hres = DupEventHandle(h, &h);

            if(SUCCEEDED(hres))
            {
                /*
                 *  Resetting the event serves two purposes.
                 *
                 *  1. It performs parameter validation for us, and
                 *  2. The event must be reset while the device is
                 *     not acquired.
                 */
                if(fLimpFF(h, ResetEvent(h)))
                {

                    if(!this->hNotify || !h)
                    {
                        hres = this->pdcb->lpVtbl->
                               SetEventNotification(this->pdcb, h);
                        
                        /*
                         *  All dcb's use default handling for now so 
                         *  assert the callback returns S_FALSE
                         *  so we are reminded to change this if need be.
                         *  An uninitialized device would fail but don't 
                         *  break if we hit one of those, just assert that 
                         *  we won't accidentally call a HEL on it.
                         */
                        AssertF( ( hres == S_FALSE )
                            || ( ( hres == DIERR_NOTINITIALIZED ) && !this->pvi ) );

                        if(this->pvi)
                        {
                            VXDDWORDDATA vhd;
                            vhd.pvi = this->pvi;
                            vhd.dw = (DWORD)(UINT_PTR)h;
                            hres = Hel_SetNotifyHandle(&vhd);
                            AssertF(SUCCEEDED(hres)); /* Should never fail */
                            h = (HANDLE)(UINT_PTR)pvExchangePpvPv64(&this->hNotify, (UINT_PTR)h);
                            hres = this->hresPolled;
                        }
                        else
                        {
                            /*
                             *  ISSUE-2001/03/29-timgill Is this actually an error case?
                             *  Can this ever validly occur?
                             *  if yes, don't we need any of the above?
                             */
                            RPF( "Device internal data missing on SetEventNotification" );
                        }

                    } else
                    {
                        /*  
                         *  Note, this is a change in behavior as 3.0 didn't
                         *  mind if you replaced an existing handle .
                         *  Nobody seems to have noticed yet though.
                         */
                        hres = DIERR_HANDLEEXISTS;
                    }
                } else
                {
                    RPF( "Handle not for Event in SetEventNotification" );
                    hres = E_HANDLE;
                }

                /*
                 *  Close the old handle if we swapped one out
                 *  or our duplicate if something went wrong
                 */
                if(h != 0)
                {
                    CloseHandle(h);
                }
            }
        } else
        {
            hres = DIERR_ACQUIRED;
        }
        CDIDev_LeaveCrit(this);
    }

    ExitOleProc();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(SetEventNotification, (PV pdd, HANDLE h), (pdd, h THAT_))

#else

    #define CDIDev_SetEventNotificationA    CDIDev_SetEventNotification
    #define CDIDev_SetEventNotificationW    CDIDev_SetEventNotification

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | hresMapHow |
 *
 *          Map the <p dwObj> and <p dwHow> fields into an object index.
 *
 *  @parm   DWORD | dwObj |
 *
 *          Object identifier.
 *
 *  @parm   DWORD | dwHow |
 *
 *          How <p dwObj> should be interpreted.
 *
 *  @parm   OUT LPDIPROPINFO | ppropi |
 *
 *          Receives object index and <p dwDevType>.
 *
 *****************************************************************************/

#ifndef XDEBUG

    #define CDIDev_hresMapHow_(this, dwObj, dwHow, ppropi, z)           \
       _CDIDev_hresMapHow_(this, dwObj, dwHow, ppropi)              \

#endif

STDMETHODIMP
    CDIDev_hresMapHow_(PDD this, DWORD dwObj, DWORD dwHow,
                       LPDIPROPINFO ppropi, LPCSTR s_szProc)
{
    HRESULT hres;

    if(this->pdcb != c_pdcbNil)
    {
        int iobj = 0;

        switch(dwHow)
        {

        case DIPH_DEVICE:
            if(dwObj == 0)
            {
                ppropi->iobj = 0xFFFFFFFF;
                ppropi->dwDevType = 0;
                hres = S_OK;
            } else
            {
                RPF("%s: dwObj must be zero if DIPH_DEVICE", s_szProc);
                hres = E_INVALIDARG;
            }
            break;

        case DIPH_BYOFFSET:
            if(this->pdix && this->rgiobj)
            {
                if(dwObj < this->dwDataSize)
                {
                    iobj = this->rgiobj[dwObj];
                    if(iobj >= 0)
                    {
                        AssertF(this->pdix[iobj].dwOfs == dwObj);
                        ppropi->iobj = iobj;
                        ppropi->dwDevType = this->df.rgodf[iobj].dwType;
                        hres = S_OK;
                        goto done;
                    } else
                    {
                        AssertF(iobj == -1);
                    }
                }

                SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%S: Invalid offset in dwObj. You may use DIPH_BYID to enum it."), s_szProc);

                //RPF("%s: Invalid offset in dwObj", s_szProc);

            } else
            {
                RPF("%s: Must have a data format to use if DIPH_BYOFFSET", s_szProc);
            }
            hres = DIERR_OBJECTNOTFOUND;
            goto done;

        case DIPH_BYID:
            for(iobj = this->df.dwNumObjs; --iobj >= 0; )
            {
                if(DIDFT_FINDMATCH(this->df.rgodf[iobj].dwType, dwObj))
                {
                    ppropi->iobj = iobj;
                    ppropi->dwDevType = this->df.rgodf[iobj].dwType;
                    hres = S_OK;
                    goto done;
                }
            }
            RPF("%s: Invalid ID in dwObj", s_szProc);
            hres = DIERR_OBJECTNOTFOUND;
            break;

        case DIPH_BYUSAGE:
            hres = IDirectInputDeviceCallback_MapUsage(this->pdcb,
                                                       dwObj, &ppropi->iobj);
            if(SUCCEEDED(hres))
            {
                ppropi->dwDevType = this->df.rgodf[ppropi->iobj].dwType;
            }
            break;

        default:
            RPF("%s: Invalid dwHow", s_szProc);
            hres = E_INVALIDARG;
            break;
        }

        done:;
    } else
    {
        RPF("ERROR: IDirectInputDevice: Not initialized");
        hres = DIERR_NOTINITIALIZED;
    }

    return hres;
}

#define CDIDev_hresMapHow(this, dwObj, dwHow, pdwOut)               \
       CDIDev_hresMapHow_(this, dwObj, dwHow, pdwOut, s_szProc)     \

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetObjectInfo |
 *
 *          Obtains information about an object.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIDEVICEOBJECTINSTANCE | pdidoi |
 *
 *          Receives information about the object.
 *          The caller "must" initialize the <e DIDEVICEOBJECTINSTANCE.dwSize>
 *          field before calling this method.
 *
 *  @parm   DWORD | dwObj |
 *
 *          Identifies the object for which the property is to be
 *          accessed.  The meaning of this value depends on the
 *          value of the <p dwHow> parameter.
 *          See the documentation of the <t DIPROPHEADER>
 *          structure for additional information.
 *
 *  @parm   DWORD | dwHow |
 *
 *          Identifies how <p dwObj> is to be interpreted.
 *          It must be one of the <c DIPH_*> values.
 *          See the documentation of the <t DIPROPHEADER>
 *          structure for additional information.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_OBJECTNOTFOUND>:  The specified object does not
 *          exist.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetObjectInfoW(PV pddW, LPDIDEVICEOBJECTINSTANCEW pdoiW,
                          DWORD dwObj, DWORD dwHow)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::GetObjectInfo,
               (_ "ppxx", pddW, pdoiW, dwObj, dwHow));

    if(SUCCEEDED(hres = hresPvW(pddW)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb2(pdoiW,
                                                DIDEVICEOBJECTINSTANCE_DX5W,
                                                DIDEVICEOBJECTINSTANCE_DX3W, 1)))
    {
        PDD this = _thisPvNm(pddW, ddW);
        DIPROPINFO propi;

        /*
         *  Must protect with the critical section to prevent
         *  another thread from Reset()ing behind our back.
         */
        CDIDev_EnterCrit(this);

        propi.pguid = 0;
        hres = CDIDev_hresMapHow(this, dwObj, dwHow, &propi);

        if(SUCCEEDED(hres))
        {
            if(dwHow != DIPH_DEVICE)
            {
                hres = CDIDev_GetObjectInfoHelper(this, &propi, pdoiW);
            } else
            {
                RPF("%s: Invalid dwHow", s_szProc);
                hres = E_INVALIDARG;
            }
        }

        if(FAILED(hres))
        {
            ScrambleBuf(&pdoiW->guidType,
                        pdoiW->dwSize -
                        FIELD_OFFSET(DIDEVICEOBJECTINSTANCEW, guidType));
        }

        CDIDev_LeaveCrit(this);
    }

    ExitBenignOleProcR();
    return hres;
}

#define CDIDev_GetObjectInfo2W          CDIDev_GetObjectInfoW

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDeviceA | GetObjectInfo |
 *
 *          ANSI version of same.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIDEVICEOBJECTINSTANCEA | pdoiA |
 *
 *          Receives information about the device's identity.
 *
 *  @parm   DWORD | dwObj |
 *
 *          Identifies the object for which the property is to be
 *          accessed.
 *
 *  @parm   DWORD | dwHow |
 *
 *          Identifies how <p dwObj> is to be interpreted.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetObjectInfoA(PV pddA, LPDIDEVICEOBJECTINSTANCEA pdoiA,
                          DWORD dwObj, DWORD dwHow)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::GetObjectInfo,
               (_ "ppxx", pddA, pdoiA, dwObj, dwHow));

    if(SUCCEEDED(hres = hresPvA(pddA)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb2(pdoiA,
                                                DIDEVICEOBJECTINSTANCE_DX5A,
                                                DIDEVICEOBJECTINSTANCE_DX3A, 1)))
    {
        PDD this = _thisPvNm(pddA, ddA);
        DIDEVICEOBJECTINSTANCEW doiW;

        doiW.dwSize = cbX(DIDEVICEOBJECTINSTANCEW);

        hres = CDIDev_GetObjectInfoW(&this->ddW, &doiW, dwObj, dwHow);

        if(SUCCEEDED(hres))
        {
            ObjectInfoWToA(pdoiA, &doiW);
            hres = S_OK;
        }
    }

    ExitBenignOleProcR();
    return hres;
}

#define CDIDev_GetObjectInfo2A          CDIDev_GetObjectInfoA

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetDeviceInfo |
 *
 *          Obtains information about the device's identity.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIDEVICEINSTANCE | pdidi |
 *
 *          Receives information about the device's identity.
 *          The caller "must" initialize the <e DIDEVICEINSTANCE.dwSize>
 *          field before calling this method.
 *
 *          If <e DIDEVICEINSTANCE.dwSize> is equal to the size of
 *          the <t DIDEVICEINSTANCE_DX3> structure, then a
 *          DirectX 3.0-compatible structure is returned instead of
 *          a DirectX 5.0 structure.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetDeviceInfoW(PV pddW, LPDIDEVICEINSTANCEW pdidiW)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::GetDeviceInfo, (_ "pp", pddW, pdidiW));

    if(SUCCEEDED(hres = hresPvW(pddW)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb2(pdidiW,
                                                DIDEVICEINSTANCE_DX5W,
                                                DIDEVICEINSTANCE_DX3W, 1)))
    {
        PDD this = _thisPvNm(pddW, ddW);

        /*
         *  Must protect with the critical section to prevent
         *  another thread from Reset()ing behind our back.
         */
        CDIDev_EnterCrit(this);

        pdidiW->guidInstance = this->guid;
        pdidiW->guidProduct  = this->guid;

        /*
         *  Don't overwrite the dwSize, guidInstance, or guidProduct.
         *  Start at the dwDevType.
         */

        ZeroBuf(&pdidiW->dwDevType,
                pdidiW->dwSize - FIELD_OFFSET(DIDEVICEINSTANCEW, dwDevType));

        hres = this->pdcb->lpVtbl->GetDeviceInfo(this->pdcb, pdidiW);

        if(FAILED(hres))
        {
            ScrambleBuf(&pdidiW->guidInstance,
                        cbX(DIDEVICEINSTANCEW) -
                        FIELD_OFFSET(DIDEVICEINSTANCEW, guidInstance));
        }

        CDIDev_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDeviceA | GetDeviceInfo |
 *
 *          ANSI version of same.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIDEVICEINSTANCEA | pdidiA |
 *
 *          Receives information about the device's identity.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetDeviceInfoA(PV pddA, LPDIDEVICEINSTANCEA pdidiA)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::GetDeviceInfo, (_ "pp", pddA, pdidiA));

    if(SUCCEEDED(hres = hresPvA(pddA)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb2(pdidiA,
                                                DIDEVICEINSTANCE_DX5A,
                                                DIDEVICEINSTANCE_DX3A, 1)))
    {
        PDD this = _thisPvNm(pddA, ddA);
        DIDEVICEINSTANCEW diW;

        diW.dwSize = cbX(DIDEVICEINSTANCEW);

        hres = CDIDev_GetDeviceInfoW(&this->ddW, &diW);

        if(SUCCEEDED(hres))
        {
            DeviceInfoWToA(pdidiA, &diW);
            hres = S_OK;
        }
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIDev | UnhookCwp |
 *
 *          Remove the CallWndProc handler.
 *
 *          See <mf CDIDev::InstallCwp> for details.
 *
 *****************************************************************************/

HWND g_hwndExclusive;
HHOOK g_hhkCwp;

void INTERNAL
    CDIDev_UnhookCwp(void)
{
    DllEnterCrit();

    if(g_hhkCwp)
    {
        UnhookWindowsHookEx(g_hhkCwp);
        g_hhkCwp = 0;
        g_hwndExclusive = 0;
    }

    DllLeaveCrit();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | AddForegroundDevice |
 *
 *          Add ourselves to the list of devices that need to be
 *          unacquired when the window loses foreground activation.
 *
 *  @parm   PDD | this |
 *
 *          Device to be added.
 *
 *  @devnote
 *
 *          Note that we do not need to AddRef the device, because
 *          <f CDIDev_Finalize> will unacquire the device for us
 *          automatically, so we will never be freed while still
 *          acquired.
 *
 *          (Note that if we did choose to AddRef, it must be done
 *          outside the DLL critical
 *          section, in order to preserve the semaphore hierarchy.)
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_AddForegroundDevice(PDD this)
{
    HRESULT hres;
    DllEnterCrit();

#ifdef IDirectInputDevice2Vtbl
    hres = GPA_Append(g_hgpaExcl, this);
    Common_Hold(this);
#else

    if(g_cpddForeground >= g_cpddForegroundMax)
    {
        AssertF(g_cpddForeground == g_cpddForegroundMax);
        hres = ReallocCbPpv(cbCxX(g_cpddForeground + 10, PDD),
                            &g_rgpddForeground);
        if(FAILED(hres))
        {
            goto failed;
        }
        g_cpddForegroundMax = g_cpddForeground + 10;
    }

    AssertF(g_cpddForeground < g_cpddForegroundMax);

    g_rgpddForeground[g_cpddForeground++] = this;
    Common_Hold(this);

    hres = S_OK;
    failed:;

#endif
    DllLeaveCrit();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIDev | DelForegroundDevice |
 *
 *          Remove ourselves from the list, if we're there.
 *          It is not an error if we aren't on the list, because
 *          in the case of forced unacquire, the list is blanked
 *          out in order to avoid race conditions where somebody
 *          tries to acquire a device immediately upon receiving
 *          foreground activation, before we get a chance to
 *          unacquire all the old guys completely.
 *
 *  @parm   PDD | this |
 *
 *          Device to be removed.
 *
 *  @devnote
 *
 *          Note that the Unhold must be done outside the DLL critical
 *          section, in order to preserve the semaphore hierarchy.
 *
 *          Theoretically, the unhold will never drop the reference count
 *          to zero (because the latest it could be called is during
 *          the AppFinalize, where there is stll the outstanding refcount
 *          from the external ref that hasn't been released yet).
 *
 *          But it's better to play it safe and always release the
 *          object outside.
 *
 *****************************************************************************/

void INTERNAL
    CDIDev_DelForegroundDevice(PDD this)
{
#ifdef IDirectInputDevice2Vtbl
    HRESULT hres;
#else
    UINT idd;
#endif

    DllEnterCrit();

#ifdef IDirectInputDevice2Vtbl
    hres = GPA_DeletePtr(g_hgpaExcl, this);
    if(hres == hresUs(0))
    {            /* If the last one went away */
        GPA_Term(g_hgpaExcl);           /* Free the tracking memory */
        CDIDev_UnhookCwp();             /* Then unhook ourselves */
    }
#else

    for(idd = 0; idd < g_cpddForeground; idd++)
    {
        if(g_rgpddForeground[idd] == this)
        {
            g_rgpddForeground[idd] = g_rgpddForeground[--g_cpddForeground];
            if(g_cpddForeground == 0)
            {
                CDIDev_UnhookCwp();
            }
            break;
        }
    }
#endif

    DllLeaveCrit();

#ifdef IDirectInputDevice2Vtbl
    if(SUCCEEDED(hres))
    {
        Common_Unhold(this);
    }
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CDIDev_CallWndProc |
 *
 *          Thread-specific CallWndProc handler.
 *
 *          Note that we need only one of these, since only the foreground
 *          window will require a hook.
 *
 *  @parm   int | nCode |
 *
 *          Notification code.
 *
 *  @parm   WPARAM | wp |
 *
 *          "Specifies whether the message is sent by the current process."
 *          We don't care.
 *
 *  @parm   LPARAM | lp |
 *
 *          Points to a <t CWPSTRUCT> which describes the message.
 *
 *  @returns
 *
 *          Always chains to the next hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
    CDIDev_CallWndProc(int nCode, WPARAM wp, LPARAM lp)
{
    LPCWPSTRUCT pcwp = (LPCWPSTRUCT)lp;
  #ifdef WINNT
    static BOOL fKillFocus = FALSE;
    static BOOL fIconic = FALSE;

    fIconic = FALSE;

    /*
     * This part of code is to fix Windows bug 430051.
     * The logic is: if WM_KILLFOCUS is followed by WM_SIZE(minimized),
     * then the app is minimized from full screen mode.
     * This combination should only happen to full screen mode game using DDraw.
     */
    if(pcwp->message == WM_KILLFOCUS)
    {
        fKillFocus = TRUE;
    } else if(pcwp->message == WM_SETFOCUS)
    {
        fKillFocus = FALSE;
    } else if (pcwp->message == WM_SIZE)
    {
        if(pcwp->wParam == SIZE_MINIMIZED){
            if( fKillFocus ) {
                fIconic = TRUE;
                fKillFocus = FALSE;
            }else{
                fKillFocus = FALSE;
            }
        } else {
            fKillFocus = FALSE;
        }
    }
  #endif
  
    if( nCode == HC_ACTION && (pcwp->message == WM_ACTIVATE 
                             #ifdef WINNT
                               || fIconic
                             #endif
                               ) 
      )
    {
        PDD *rgpdid;
        UINT ipdid, cpdid;
        HHOOK hhk;

      #ifdef WINNT
        fIconic = FALSE;
      #endif
      
        /*
         *  We cannot mess with items while inside the DLL critical section,
         *  because that would violate our semaphore hierarchy.
         *
         *  Instead, we stash the active item list and replace it with
         *  an empty list.  Then, outside the DLL critical section, we
         *  calmly operate on each item.
         */
        DllEnterCrit();
      #ifdef IDirectInputDevice2Vtbl
        rgpdid = (PV)g_hgpaExcl->rgpv;
        cpdid = g_hgpaExcl->cpv;
        GPA_Init(g_hgpaExcl);
      #else
        rgpdid = g_rgpddForeground;
        cpdid = g_cpddForeground;
        g_rgpddForeground = 0;
        g_cpddForeground = 0;
        g_cpddForegroundMax = 0;
      #endif

        /*
         *  Some sanity checking here.
         */

        for(ipdid = 0; ipdid < cpdid; ipdid++)
        {
            AssertF(rgpdid[ipdid]);
        }

        DllLeaveCrit();

        /*
         *  Note that InternalUnacquire will set the notification
         *  event so the app knows that input was lost.
         */
        for(ipdid = 0; ipdid < cpdid; ipdid++)
        {
            AssertF(rgpdid[ipdid]);
            SquirtSqflPtszV(sqfl,
                            TEXT("Forcing unacquire of %08x due to focus loss"),
                            rgpdid[ipdid]);
            CDIDev_InternalUnacquire(rgpdid[ipdid]);
            Common_Unhold(rgpdid[ipdid]);
        }
        FreePpv(&rgpdid);

        hhk = g_hhkCwp;
        CDIDev_UnhookCwp();
        return CallNextHookEx(hhk, nCode, wp, lp);
    }
    return CallNextHookEx(g_hhkCwp, nCode, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | CanAcquire |
 *
 *          Determine whether the device may be acquired exclusively.
 *
 *          If exclusive access is not requested, then the function
 *          succeeds vacuously.
 *
 *          If exclusive access is requested, then the window must
 *          be the foreground window and must belong to the current
 *          process.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_CanAcquire(PDD this)
{
    HRESULT hres;

    AssertF(CDIDev_IsConsistent(this));
    if(this->discl & DISCL_FOREGROUND)
    {
        HWND hwndForeground = GetForegroundWindow();

        AssertF(this->hwnd);
        /*
         *  Note that we don't have to do an IsWindow() on this->hwnd,
         *  because GetForegroundWindow() will always return a valid
         *  window or NULL.  Since we already tested this->hwnd != 0
         *  above, the only way the equality can occur is if the window
         *  handle is indeed valid.
         */
        
        if(this->hwnd == hwndForeground && !IsIconic(this->hwnd))
        {

            /*
             *  Need to make sure that the window "still" belongs to
             *  this process, in case the window handle got recycled.
             */
            DWORD idProcess;
            GetWindowThreadProcessId(this->hwnd, &idProcess);
            if(idProcess == GetCurrentProcessId())
            {
                hres = S_OK;
            } else
            {
                /*
                 *  Put a permanently invalid handle here so that we
                 *  won't accidentally take a new window that happens
                 *  to get a recycled handle value.
                 */
                this->hwnd = INVALID_HANDLE_VALUE;
                RPF("Error: Window destroyed while associated with a device");
                hres = E_INVALIDARG;
            }
        } else
        {
            hres = DIERR_OTHERAPPHASPRIO;
        }
    } else
    {                        /* No window; vacuous success */
        hres = S_OK;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | InstallCwp |
 *
 *          Install the CallWndProc handler.
 *
 *          There is a bit of subtlety in the way this works.
 *          Since only foreground windows may acquire exclusive access,
 *          we need only one hook (for there is but one foreground
 *          window in the system).
 *
 *          _NT_:  Does NT handle this correctly in the face of
 *          multiple window stations?
 *
 *          The tricky part is that input loss occurs asynchronously.
 *          So a device that registers a <f CallWindowProc> hook doesn't
 *          find out that the input has been lost until the app next
 *          calls <f Unacquire>.
 *
 *          So the way this is done is via a collection of global
 *          variables (which must be accessed atomically).
 *
 *          <p g_hhkCwp> is the hook handle itself.  It is zero when
 *          no hook is installed.
 *
 *          Note that we install the windows hook while inside both the
 *          object critical section and the DLL critical section.
 *          You might think we'd risk deadlocking with the hook procedure,
 *          in case the window asynchronously deactivates while we're
 *          installing the hook.  But your worries are unfounded:
 *          If the window is on the current thread, then window messages
 *          won't be dispatched because we never call <f GetMessage> or
 *          go into a modal loop.  And if the window is on another thread,
 *          then that other thread will simply have to wait until we're done.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_InstallCwp(PDD this)
{
    HRESULT hres;

    if(this->discl & DISCL_FOREGROUND)
    {
        AssertF(this->hwnd);
        hres = CDIDev_CanAcquire(this);
        if(SUCCEEDED(hres))
        {
            hres = CDIDev_AddForegroundDevice(this);
            if(SUCCEEDED(hres))
            {
                DllEnterCrit();
                if(!g_hhkCwp)
                {            /* We're the first one */
                    g_hwndExclusive = this->hwnd;
                    g_hhkCwp = SetWindowsHookEx(WH_CALLWNDPROC,
                                                CDIDev_CallWndProc, g_hinst,
                                                GetWindowThreadProcessId(this->hwnd, 0));
                } else
                {
                    AssertF(g_hwndExclusive == this->hwnd);
                }

                DllLeaveCrit();
                /*
                 *  There is a race condition up above, where the foreground
                 *  window can change between the call to CanAcquire() and
                 *  the call to SetWindowsHookEx().  Close the window by
                 *  checking a second time after the hook is installed.
                 *
                 *  If we leave the window open, it's possible that we will
                 *  perform a physical acquire while the wrong window has
                 *  foreground activation.  Then, of course, we are never told
                 *  that *our* window lost activation, and the physical device
                 *  remains acquired forever.
                 */
                hres = CDIDev_CanAcquire(this);
                if(SUCCEEDED(hres))
                {
                } else
                {
                    SquirtSqflPtszV(sqflError,
                                    TEXT("Window no longer foreground; ")
                                    TEXT("punting acquire"));
                    CDIDev_InternalUnacquire(this);
                }
            }
        } else
        {
            hres = DIERR_OTHERAPPHASPRIO;
        }
    } else
    {                        /* No window; vacuous success */
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | RealUnacquire |
 *
 *          Release access to the device, even if the device was only
 *          partially acquired.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_RealUnacquire(PDD this)
{
    HRESULT hres;

    hres = this->pdcb->lpVtbl->Unacquire(this->pdcb);
    if(hres == S_FALSE)
    {
        if(this->fAcquiredInstance)
        {
            this->fAcquiredInstance = 0;
            hres = Hel_UnacquireInstance(this->pvi);
            AssertF(SUCCEEDED(hres));
        } else
        {
            hres = S_OK;
        }
    }

    return hres;
}


#ifdef IDirectInputDevice2Vtbl
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | FFAcquire |
 *
 *          The device has been successfully acquired.  Do any
 *          necessary force feedback related acquisition goo.
 *
 *  @cwrap  PDD | pdd
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_FFAcquire(PDD this)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this));

    if(this->pes && (this->discl & DISCL_EXCLUSIVE))
    {
        if(SUCCEEDED(hres = this->pes->lpVtbl->SendForceFeedbackCommand(
                                                                       this->pes, &this->sh,
                                                                       DISFFC_FORCERESET)))
        {

            CDIDev_RefreshGain(this);

            /*
             *  If the center spring is to be disabled,
             *  then disable the center spring.
             */
            if(!this->dwAutoCenter)
            {
                this->pes->lpVtbl->SendForceFeedbackCommand(
                                                           this->pes, &this->sh,
                                                           DISFFC_STOPALL);
            }

            hres = S_OK;
        }

    } else
    {
        hres = S_OK;
    }

    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | Acquire |
 *
 *          Obtains access to the device.
 *
 *          Device acquisition does not reference-count.  If a device is
 *          acquired twice then unacquired once, the device is unacquired.
 *
 *          Before the device can be acquired, a data format must
 *          first be set via the <mf IDirectInputDevice::SetDataFormat>
 *          method.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The device has already been acquired.  Note
 *          that this value is a success code.
 *
 *          <c DIERR_OTHERAPPHASPRIO>: Access to the device was not granted.
 *          The most common cause of this is attempting to acquire a
 *          device with the <c DISCL_FOREGROUND> cooperative level when
 *          the associated window is not foreground.
 *
 *          This error code is also returned if an attempt to
 *          acquire a device in exclusive mode fails because the device
 *          is already acquired in exclusive mode by somebody else.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The device
 *          does not have a selected data format.
 */
/*
 *          The point at which we take the exclusive semaphore is important.
 *          We should do it after preliminary validation of foreground
 *          permission, so that we don't accidentally lock out somebody
 *          else who legitimately has permission.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_Acquire(PV pdd _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::Acquire, (_ "p", pdd));

    if(SUCCEEDED(hres = hresPvT(pdd)))
    {
        PDD this = _thisPv(pdd);

        /*
         *  Must protect with the critical section to prevent somebody from
         *  acquiring or changing the data format while we're acquiring.
         */
        CDIDev_EnterCrit(this);

        /*
         *  The app explicitly messed with acquisition.  Any problems
         *  retrieving data are now the apps' fault.
         */
        this->hresNotAcquired = DIERR_NOTACQUIRED;

        //We now need a pvi even in where the device doesn't use VxDs
        if(this->pdix && this->pvi)
        {
            if(this->pvi->fl & VIFL_ACQUIRED)
            {
                hres = S_FALSE;
            } else if(SUCCEEDED(hres = CDIDev_CanAcquire(this)))
            {

                hres = Excl_Acquire(&this->guid, this->hwnd, this->discl);
                if(SUCCEEDED(hres))
                {

#ifdef IDirectInputDevice2Vtbl
                    if(SUCCEEDED(hres = CDIDev_FFAcquire(this)))
                    {
#endif
                        hres = this->pdcb->lpVtbl->Acquire(this->pdcb);
                        if(SUCCEEDED(hres))
                        {
                            if(hres == S_FALSE)
                            {
                                hres = Hel_AcquireInstance(this->pvi);
                                if(SUCCEEDED(hres))
                                {
                                    this->fAcquiredInstance = 1;

                                    /*
                                     *  If relative mode, need to prime the
                                     *  pvLastBuffer with the current state.
                                     */

                                    if(this->pvi->fl & VIFL_RELATIVE)
                                    {
                                        hres = this->pdcb->lpVtbl->GetDeviceState(
                                                                                 this->pdcb, this->pvLastBuffer);
                                        if(FAILED(hres))
                                        {
                                            goto unacquire;
                                        }
                                    }

                                } else
                                {
                                    goto unacquire;
                                }
                            }

                            /*
                             *  Note that InstallCwp must be the last thing
                             *  we do, because it will add us to the foreground
                             *  list, and none of our error exit paths remove us.
                             */
                            hres = CDIDev_InstallCwp(this);
                            if(SUCCEEDED(hres))
                            {
                                this->fAcquired = 1;
                                this->fOnceAcquired = 1;

                                /*
                                 *  From now on, if we lose acquisition,
                                 *  it's not the app's fault.
                                 */
                                this->hresNotAcquired = DIERR_INPUTLOST;

                                hres = S_OK;
                            } else
                            {
                                goto unacquire;
                            }

                        } else
                        {
                            unacquire:;
                            CDIDev_RealUnacquire(this);
                        }
#ifdef IDirectInputDevice2Vtbl
                    }
#endif
                }
            }
        } else
        {
            hres = E_INVALIDARG;
        }

        // For some apps (e.g. "Sonic R") we need to always succeed Acquire() -- see Windows bug 15085
        if ((this->diHacks.fSucceedAcquire ) && (FAILED(hres)))
        {
            this->fOnceAcquired = 1;
            hres = S_OK;
        }

        CDIDev_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(Acquire, (PV pdd), (pdd THAT_))

#else

    #define CDIDev_AcquireA                 CDIDev_Acquire
    #define CDIDev_AcquireW                 CDIDev_Acquire

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | InternalUnacquire |
 *
 *          This does the real work of unacquiring.  The internal
 *          version bypasses the "the app requested this" flag,
 *          so when the app goes to request something, it gets
 *          <c DIERR_INPUTLOST> instead of <c DIERR_NOTACQUIRED>.
 *
 *          If the application error code is <c DIERR_INPUTLOST>, then
 *          we will also signal the associated event so that it knows
 *          that the state changed.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_InternalUnacquire(PDD this)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::InternalUnacquire, (_ "p", this));

    /*
     *  Must protect with the critical section to prevent confusing other
     *  methods which change their behavior depending on whether the device
     *  is acquired.
     */
    CDIDev_EnterCrit(this);

    if(this->fAcquired)
    {
        AssertF(this->pdcb != c_pdcbNil);
        this->fAcquired = 0;
        Excl_Unacquire(&this->guid, this->hwnd, this->discl);
        if(this->discl & DISCL_FOREGROUND)
        {
            AssertF(this->hwnd);
            CDIDev_DelForegroundDevice(this);
          #ifdef WINNT
            if( IsIconic(this->hwnd) ) {
                this->fUnacquiredWhenIconic = 1;
            }
          #endif
        }
#ifdef IDirectInputDevice2Vtbl
        /*
         *  ISSUE-2001/03/29-timgill multithreading means we cannot rely on Excl_Unaquire() return values
         *  We cannot trust the return value (if we made one)
         *  of Excl_Unacquire, because another instance may have
         *  snuck in and acquired the device after we Excl_Unacquire'd
         *  it and started doing force feedback on it.
         *
         *  We need to fix this with the joystick mutex.
         */
        if(this->pes && (this->discl & DISCL_EXCLUSIVE))
        {
            this->pes->lpVtbl->SendForceFeedbackCommand(
                                                       this->pes, &this->sh, DISFFC_RESET);
            this->sh.dwTag = 0;
        }
#endif

        hres = CDIDev_RealUnacquire(this);
        if(this->hresNotAcquired == DIERR_INPUTLOST)
        {
            CDIDev_SetNotifyEvent(this);
        }
    } else
    {
        hres = S_FALSE;
    }

    CDIDev_LeaveCrit(this);


    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | Unacquire |
 *
 *          Release access to the device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The object is not currently acquired.
 *          This may have been caused by a prior loss of input.
 *          Note that this is a success code.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_Unacquire(PV pdd _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::Unacquire, (_ "p", pdd));

    if(SUCCEEDED(hres = hresPvT(pdd)))
    {
        PDD this = _thisPv(pdd);

        /*
         *  The app explicitly messed with acquisition.  Any problems
         *  retrieving data are now the apps' fault.
         */
        this->hresNotAcquired = DIERR_NOTACQUIRED;

        hres = CDIDev_InternalUnacquire(this);

    }

    ExitOleProcR();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(Unacquire, (PV pdd), (pdd THAT_))

#else

    #define CDIDev_UnacquireA               CDIDev_Unacquire
    #define CDIDev_UnacquireW               CDIDev_Unacquire

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method PDIPROPVALIDINFO | IDirectInputDevice | ppviFind |
 *
 *          Locate the DIPROPVALIDINFO structure that describes
 *          the predefined property.
 *
 *  @parm   const GUID * | pguid |
 *
 *          Property guid, or predefined property.
 *
 *  @returns
 *
 *          Pointer to a const <t DIPROPVALIDINFO> that describes
 *          what is and is not valid for this property.
 *
 *          Returns 0 if the property is not one of the predefined
 *          properties.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

typedef struct DIPROPVALIDINFO
{
    PCGUID  pguid;                      /* Property name */
    DWORD   dwSize;                     /* expected size */
    DWORD   fl;                         /* flags */
} DIPROPVALIDINFO, *PDIPROPVALIDINFO;

/*
 *  Note that the flags are negative in sense.
 *  This makes validation easier.
 */
#define DIPVIFL_NOTDEVICE   0x00000001  /* Cannot be device */
#define DIPVIFL_NOTOBJECT   0x00000002  /* Cannot be object */
#define DIPVIFL_READONLY    0x00000004  /* Cannot be set */
#define DIPVIFL_NOTPRIVATE  0x00000008  /* Cannot handle private pvi */
#define DIPVIFL_NOTACQUIRED 0x00000010  /* Cannot modify while acquired */

DIPROPVALIDINFO c_rgpvi[] = {

    {
        DIPROP_BUFFERSIZE,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_NOTPRIVATE | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_AXISMODE,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_NOTPRIVATE | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_GRANULARITY,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTDEVICE | DIPVIFL_READONLY | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_RANGE,
        cbX(DIPROPRANGE),
        DIPVIFL_NOTDEVICE | DIPVIFL_NOTACQUIRED,
    },

    /*
     *  Note that you can set the dead zone on the entire device.
     *  This is the same as applying it to each axis individually.
     */
    {
        DIPROP_DEADZONE,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTACQUIRED,
    },

    /*
     *  Note that you can set the saturation on the entire device.
     *  This is the same as applying it to each axis individually.
     */
    {
        DIPROP_SATURATION,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTACQUIRED,
    },

    /*
     *  Note that you can change the gain either while acquired
     *  or not.  Your choice.
     */
    {
        DIPROP_FFGAIN,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT,
    },

    /*
     *  Note that the FF load is meaningful only when acquired,
     *  so we'd better not complain if they access it while acquired!
     */
    {
        DIPROP_FFLOAD,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_READONLY,
    },

    {
        DIPROP_AUTOCENTER,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_CALIBRATIONMODE,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_CALIBRATION,
        cbX(DIPROPCAL),
        DIPVIFL_NOTDEVICE | DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_GUIDANDPATH,
        cbX(DIPROPGUIDANDPATH),
        DIPVIFL_NOTOBJECT | DIPVIFL_READONLY,
    },

    {
        DIPROP_INSTANCENAME,
        cbX(DIPROPSTRING),
        DIPVIFL_NOTOBJECT,
    },

    {
        DIPROP_PRODUCTNAME,
        cbX(DIPROPSTRING),
        DIPVIFL_NOTOBJECT,
    },

    {
        DIPROP_MAXBUFFERSIZE,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT | DIPVIFL_NOTPRIVATE | DIPVIFL_NOTACQUIRED,
    },


    {
        DIPROP_JOYSTICKID,
        cbX(DIPROPDWORD),
        DIPVIFL_NOTOBJECT |  DIPVIFL_NOTACQUIRED,
    },

    {
        DIPROP_GETPORTDISPLAYNAME,
        cbX(DIPROPSTRING),
        DIPVIFL_NOTOBJECT | DIPVIFL_READONLY,
    },

    /*
     *  Note that you can change the report ID  while acquired
     *  or not.  Your choice.
     */
    {
        DIPROP_ENABLEREPORTID,
        cbX(DIPROPDWORD),
        0x0,
    },

#if 0
    {
        DIPROP_SPECIFICCALIBRATION,
        cbX(DIPROPCAL),
        DIPVIFL_NOTDEVICE | DIPVIFL_NOTACQUIRED,
    },
#endif

};

#pragma END_CONST_DATA

STDMETHODIMP_(PDIPROPVALIDINFO)
CDIDev_ppviFind(PCGUID pguid)
{
    PDIPROPVALIDINFO ppvi;
    UINT ipvi;

    for(ipvi = 0, ppvi = c_rgpvi; ipvi < cA(c_rgpvi); ipvi++, ppvi++)
    {
        if(ppvi->pguid == pguid)
        {
            goto found;
        }
    }
    ppvi = 0;

    found:
    return ppvi;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | hresValidProp |
 *
 *          Check that the property structure makes sense.
 *          Returns the object index for further processing.
 *
 *  @parm   const GUID * | pguid |
 *
 *          Property guid, or predefined property.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Propery header structure.
 *
 *  @parm   BOOL | fWrite |
 *
 *          Whether property should be validate for writing.
 *
 *  @parm   OUT LPDIPROPINFO | ppropi |
 *
 *          Receives object index.
 *
 *****************************************************************************/

typedef BOOL (WINAPI *PFNBAD)(PCV pv, UINT cb);

STDMETHODIMP
    CDIDev_hresValidProp(PDD this, const GUID *pguid, LPCDIPROPHEADER pdiph,
                         BOOL fWrite, LPDIPROPINFO ppropi)
{
    HRESULT hres;
    PFNBAD pfnBad;
    EnterProcR(IDirectInputDevice::Get/SetProperty,
               (_ "pxpx", this, pguid, pdiph, fWrite));

    AssertF(CDIDev_InCrit(this));

    if(fWrite)
    {
        pfnBad = (PFNBAD)IsBadWritePtr;
    } else
    {
        pfnBad = (PFNBAD)IsBadReadPtr;
    }

    if(!pfnBad(pdiph, cbX(DIPROPHEADER)) &&
       pdiph->dwHeaderSize == cbX(DIPROPHEADER) &&
       pdiph->dwSize % 4 == 0 &&
       pdiph->dwSize >= pdiph->dwHeaderSize &&
       !pfnBad(pdiph, pdiph->dwSize))
    {

        if(fWrite)
        {
            ScrambleBuf((PV)(pdiph+1), pdiph->dwSize - cbX(DIPROPHEADER));
        }

        /*
         *  Now convert the item descriptor into an index.
         */
        hres = CDIDev_hresMapHow(this, pdiph->dwObj, pdiph->dwHow, ppropi);

        if(SUCCEEDED(hres))
        {

            /*
             *  Now validate the property id or guid.
             */
            if(HIWORD((UINT_PTR)pguid) == 0)
            {

                PDIPROPVALIDINFO ppvi;

                ppvi = CDIDev_ppviFind(pguid);

                /*
                 *  Note that if we don't find the GUID in our list,
                 *  we fail it straight away.  This prevents ISVs
                 *  from trying to create properties in the Microsoft
                 *  Reserved range.
                 */
                if(ppvi)
                {
                    if( ppvi->pguid == DIPROP_CALIBRATION ) {
                        if( pdiph->dwSize == ppvi->dwSize ||
                            pdiph->dwSize == cbX(DIPROPCALPOV) ) 
                        {
                            hres = S_OK;
                        } else {
                            RPF("%s: Arg 2: Invalid dwSize for property", s_szProc);
                            hres = E_INVALIDARG;
                        }
                    } else if( pdiph->dwSize == ppvi->dwSize )
                    {
                        hres = S_OK;
                    } else
                    {
                        RPF("%s: Arg 2: Invalid dwSize for property", s_szProc);
                        hres = E_INVALIDARG;
                    }
                } else
                {
                    RPF("%s: Arg 1: Unknown property", s_szProc);
                    hres = E_NOTIMPL;
                }

            } else
            {
                hres = hresFullValidGuid(pguid, 1);
            }
        }
    } else
    {
        RPF("%s: Arg 2: Invalid pointer", s_szProc);
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | hresValidDefProp |
 *
 *          Determine whether the property is something we can handle
 *          in the default property handler.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags for forbidden things.
 *          <c DIPVIFL_READONLY> if being validated for writing.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: Passes validation.
 *
 *          <c E_NOTIMPL>: Not something we handle.
 *
 *
 *****************************************************************************/

HRESULT INTERNAL
    CDIDev_hresValidDefProp(PDD this, LPCDIPROPINFO ppropi, DWORD dwFlags)
{
    HRESULT hres;
    PDIPROPVALIDINFO ppvi;
    EnterProc(CDIDev_hresValidDefProp,
              (_ "pGxx", this, ppropi->pguid, ppropi->dwDevType, dwFlags));

    /*
     *  Note that it's okay if the device is acquired.  We want to
     *  allow GetProperty to succeed on an acquired device.
     */
    AssertF(CDIDev_InCrit(this));

    ppvi = CDIDev_ppviFind(ppropi->pguid);

    if(ppvi)
    {
        if(ppropi->iobj == 0xFFFFFFFF)
        {
            dwFlags |= DIPVIFL_NOTDEVICE;    /* Fail if devices forbidden */
        } else
        {
            dwFlags |= DIPVIFL_NOTOBJECT;    /* Fail if objects forbidden */
        }
        if(this->pvi == 0)
        {
            dwFlags |= DIPVIFL_NOTPRIVATE;   /* Fail if privates forbidden */
        }
        /*
         *  If attempting to modify property and we are acquired,
         *  then also set the "but not while acquired" filter.
         */
        if((dwFlags & DIPVIFL_READONLY) && this->fAcquired)
        {
            dwFlags |= DIPVIFL_NOTACQUIRED;  /* Fail if r/o while acq'd */
        }

        if((ppvi->fl & dwFlags) == 0)
        {
            hres = S_OK;            /* Seems reasonable */
        } else
        {
            if(ppvi->fl & dwFlags & DIPVIFL_READONLY)
            {
                RPF("SetProperty: Property is read-only");
                hres = DIERR_READONLY;
            } else if(ppvi->fl & dwFlags & DIPVIFL_NOTACQUIRED)
            {
                RPF("SetProperty: Cannot change property while acquired");
                hres = DIERR_ACQUIRED;
            } else
            {
                RPF("Get/SetProperty: Property does not exist for that object");
                hres = E_NOTIMPL;       /* Cannot do that */
            }
        }

    } else
    {
        RPF("Get/SetProperty: Property does not exist");
        hres = E_NOTIMPL;           /* Definitely way out */
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | DefGetProperty |
 *
 *          Default implementation of <mf IDirectInputDevice::GetProperty>
 *          to handle properties which the device decides not to implement.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   OUT LPDIPROPHEADER | pdiph |
 *
 *          Where to put the property value.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p pdiph> parameter is not a valid pointer.
 *
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_DefGetProperty(PDD this, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    EnterProc(CDIDev_DefGetProperty,
              (_ "pGx", this, ppropi->pguid, ppropi->dwDevType));

    AssertF(CDIDev_InCrit(this));

    hres = CDIDev_hresValidDefProp(this, ppropi, 0);
    if(SUCCEEDED(hres))
    {
        LPDIPROPDWORD pdipdw = (PV)pdiph;
        LPDIPROPRANGE pdiprg = (PV)pdiph;

        switch((DWORD)(UINT_PTR)ppropi->pguid)
        {

        case (DWORD)(UINT_PTR)DIPROP_BUFFERSIZE:
            AssertF(this->pvi);         /* Validation should've caught this */
            pdipdw->dwData = this->celtBuf;
            hres = S_OK;
            break;

        case (DWORD)(UINT_PTR)DIPROP_AXISMODE:
            AssertF(this->pvi);         /* Validation should've caught this */
            if(this->pvi->fl & VIFL_RELATIVE)
            {
                pdipdw->dwData = DIPROPAXISMODE_REL;
            } else
            {
                pdipdw->dwData = DIPROPAXISMODE_ABS;
            }
            hres = S_OK;
            break;

        case (DWORD)(UINT_PTR)DIPROP_GRANULARITY:

            if(DIDFT_GETTYPE(ppropi->dwDevType) & DIDFT_AXIS)
            {
                /* Default axis granularity is 1 */
                pdipdw->dwData = 1;
                hres = S_OK;
            } else
            {
                /*
                 * Buttons don't have granularity.
                 * POVs must be handled by device driver.
                 */
                RPF("GetProperty: Object doesn't have a granularity");
                hres = E_NOTIMPL;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_RANGE:
            if(DIDFT_GETTYPE(ppropi->dwDevType) & DIDFT_RELAXIS)
            {
                /* Default rel-axis range is infinite */
                pdiprg->lMin = DIPROPRANGE_NOMIN;
                pdiprg->lMax = DIPROPRANGE_NOMAX;
                hres = S_OK;
            } else
            {
                /*
                 * Device driver must handle abs axis range.
                 * Buttons and POVs don't have range.
                 */
                RPF("GetProperty: Object doesn't have a range");
                hres = E_NOTIMPL;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_MAXBUFFERSIZE:
            pdipdw->dwData = this->celtBufMax;
            hres = S_OK;
            break;

#ifdef IDirectInputDevice2Vtbl
        case (DWORD)(UINT_PTR)DIPROP_FFGAIN:
            pdipdw->dwData = this->dwGain;
            hres = S_OK;
            break;

        case (DWORD)(UINT_PTR)DIPROP_FFLOAD:
            hres = CDIDev_GetLoad(this, &pdipdw->dwData);
            break;

        case (DWORD)(UINT_PTR)DIPROP_AUTOCENTER:
            if(this->didcFF & DIDC_FORCEFEEDBACK)
            {
                pdipdw->dwData = this->dwAutoCenter;
                hres = S_OK;
            } else
            {
                hres = E_NOTIMPL;
            }
            break;
#endif

        default:
            /*
             *  The user is asking for some property that simply
             *  makes no sense here.  E.g., asking for the dead
             *  zone on a keyboard.
             */
            SquirtSqflPtszV(sqfl | sqflBenign, 
                            TEXT("GetProperty: Property 0x%08x not supported on device"),
                            (DWORD)(UINT_PTR)ppropi->pguid );
            hres = E_NOTIMPL;
            break;

        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetProperty |
 *
 *          Obtain information about a device or object in a device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN REFGUID | rguidProp |
 *
 *          The identity of the property to be obtained.  This can be
 *          one of the predefined <c DIPROP_*> values, or it may
 *          be a private GUID.
 *
 *  @parm   IN LPDIPROPHEADER | pdiph |
 *
 *          Points to the <t DIPROPHEADER> portion of a structure
 *          which dependson the property.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p pdiph> parameter is not a valid pointer, or the
 *          <p dwHow> field is invalid, or the <p dwObj> field
 *          is not zero when <p dwHow> is set to <c DIPH_DEVICE>.
 *
 *          <c DIERR_OBJECTNOTFOUND>:  The specified object does not
 *          exist.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>:  The property
 *          is not supported by the device or object.
 *
 *  @ex
 *
 *          The following "C" code fragment illustrates how to obtain
 *          the value of the <c DIPROP_BUFFERSIZE> property.
 *
 *          |
 *
 *          DIPROPDWORD dipdw;
 *          HRESULT hres;
 *          dipdw.diph.dwSize = sizeof(DIPROPDWORD);
 *          dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
 *          dipdw.diph.dwObj  = 0;                   // device property
 *          hres = IDirectInputDevice_GetProperty(pdid, DIPROP_BUFFERSIZE, &dipdw.diph);
 *          if (SUCCEEDED(hres)) {
 *              // dipdw.dwData contains the value of the property
 *          }
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetProperty(PV pdd, REFGUID rguid, LPDIPROPHEADER pdiph _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::GetProperty, (_ "pxp", pdd, rguid, pdiph));

    if(SUCCEEDED(hres = hresPvT(pdd)))
    {
        PDD this = _thisPv(pdd);
        DIPROPINFO propi;

        /*
         *  Must protect with the critical section to prevent somebody
         *  acquiring or changing the property we are reading.  We need
         *  to do this before validating, to prevent an acquisition.
         */
        CDIDev_EnterCrit(this);

        propi.pguid = rguid;
        if(SUCCEEDED(hres = CDIDev_hresValidProp(this, rguid, pdiph,
                                                 1, &propi)))
        {

            hres = this->pdcb->lpVtbl->GetProperty(this->pdcb, &propi, pdiph);

            if(hres == E_NOTIMPL)
            {
                hres = CDIDev_DefGetProperty(this, &propi, pdiph);
            }

        }

        CDIDev_LeaveCrit(this);
    }

    ExitBenignOleProcR();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(GetProperty, (PV pdm, REFGUID rguid, LPDIPROPHEADER pdiph),
           (pdm, rguid, pdiph THAT_))

#else

    #define CDIDev_GetPropertyA             CDIDev_GetProperty
    #define CDIDev_GetPropertyW             CDIDev_GetProperty

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | SetAxisMode |
 *
 *          Default handler for clients trying to set the axis mode.
 *          If the device doesn't handle axis modes natively, then
 *          we'll fake it ourselves.
 *
 *  @parm   DWORD | dwMode |
 *
 *          Desired new mode.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetAxisMode(PDD this, DWORD dwMode)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::SetProperty(AXISMODE),
               (_ "px", this, dwMode));

    AssertF(this->pvi);                 /* Validation should've caught this */

    hres = hresFullValidFl(dwMode, DIPROPAXISMODE_VALID, 2);
    if(SUCCEEDED(hres))
    {
        if(dwMode & DIPROPAXISMODE_REL)
        {
            this->GetDeviceState = CDIDev_GetRelDeviceState;
            this->pvi->fl |= VIFL_RELATIVE;
        } else
        {
            this->GetDeviceState = CDIDev_GetAbsDeviceState;
            this->pvi->fl &= ~VIFL_RELATIVE;
        }
        if( this->diHacks.fNativeAxisOnly )
        {
            this->pvi->fl |= VIFL_MODECOMPAT;
        }
        if(this->cAxes)
        {
            hres = S_OK;
        } else
        {
            hres = DI_PROPNOEFFECT;
        }
    }

    ExitOleProc();
    return hres;
}

#ifdef IDirectInputDevice2Vtbl
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | SetAutoCenter |
 *
 *          Default handler for clients trying to set the
 *          auto-center property.
 *
 *          If the device doesn't have control over the
 *          auto-center spring, then we fail.
 *
 *  @parm   DWORD | dwMode |
 *
 *          Desired new mode.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetAutoCenter(PDD this, DWORD dwMode)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::SetProperty(AUTOCENTER),
               (_ "px", this, dwMode));

    hres = hresFullValidFl(dwMode, DIPROPAUTOCENTER_VALID, 2);
    if(SUCCEEDED(hres))
    {
        if(this->didcFF & DIDC_FORCEFEEDBACK)
        {
            /*
             *  We need to create the effect driver if disabling
             *  autocenter so that CDIDev_FFAcquire will set the feedback
             *  mode properly.
             */
            if(fLimpFF(dwMode == DIPROPAUTOCENTER_OFF,
                       SUCCEEDED(hres = CDIDev_CreateEffectDriver(this))))
            {
                this->dwAutoCenter = dwMode;
                hres = S_OK;
            }
        } else
        {
            hres = E_NOTIMPL;
        }
    }

    ExitOleProc();
    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | SetGlobalAxisProp |
 *
 *          Default implementation of <mf IDirectInputDevice::SetProperty>
 *          to handle properties which can be applied globally to all
 *          absolute axes.
 *
 *  @parm   IN LPDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *          We edit it to avoid reallocating memory all the time.
 *
 *  @parm   IN LPCDIPROPHEADER | pdiph |
 *
 *          The property itself.
 *
 *  @returns
 *
 *          We consider the property-set a success if all candidates
 *          succeeded.  <c E_NOTIMPL> counts as success, on the assumption
 *          that the property is not meaningful on the candidate.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetGlobalAxisProp(PDD this, LPDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;

    for(ppropi->iobj = 0; ppropi->iobj < this->df.dwNumObjs; ppropi->iobj++)
    {
        DWORD dwType = this->df.rgodf[ppropi->iobj].dwType;
        if(dwType & DIDFT_ABSAXIS)
        {
            ppropi->dwDevType = this->df.rgodf[ppropi->iobj].dwType;

            hres = this->pdcb->lpVtbl->SetProperty(this->pdcb, ppropi, pdiph);
            if(FAILED(hres) && hres != E_NOTIMPL)
            {
                goto done;
            }
        }
    }
    hres = S_OK;

    done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | DefSetProperty |
 *
 *          Default implementation of <mf IDirectInputDevice::SetProperty>
 *          to handle properties which the device decides not to implement.
 *
 *  @parm   IN LPDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *          We edit it to avoid reallocating memory all the time.
 *
 *  @parm   OUT LPCDIPROPHEADER | pdiph |
 *
 *          Where to put the property value.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DI_POLLEDDEVICE>: The device is polled, so the result
 *          might not be meaningful.  (This return code is used when
 *          you attempt to set the buffer size property.)
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p pdiph> parameter is not a valid pointer.
 *
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_DefSetProperty(PDD this, LPDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    EnterProc(CDIDev_DefSetProperty,
              (_ "pGx", this, ppropi->pguid, ppropi->dwDevType));

    AssertF(CDIDev_InCrit(this));

    /*
     * Note: The indentation here is historical; I left it this way
     * to keep the diff size down.
     */

    hres = CDIDev_hresValidDefProp(this, ppropi, DIPVIFL_READONLY);
    if(SUCCEEDED(hres))
    {
        LPDIPROPDWORD pdipdw = (PV)pdiph;
        LPDIPROPRANGE pdiprg = (PV)pdiph;
        VXDDWORDDATA vdd;

        switch((DWORD)(UINT_PTR)ppropi->pguid)
        {

        case (DWORD)(UINT_PTR)DIPROP_BUFFERSIZE:
            AssertF(this->pvi);     /* Validation should've caught this */
            vdd.pvi = this->pvi;
            if( pdipdw->dwData > this->celtBufMax )
            {
                RPF( "DIPROP_BUFFERSIZE: requested size %d is larger than maximum %d, using %d", 
                    pdipdw->dwData, this->celtBufMax, this->celtBufMax );
                vdd.dw = this->celtBufMax;
            }
            else
            {
                vdd.dw = pdipdw->dwData;
            }
            
            hres = Hel_SetBufferSize(&vdd);
#ifdef DEBUG_STICKY
            {
                TCHAR tszDbg[80];
                wsprintf( tszDbg, TEXT("SetBufferSize(0x%08x) returned 0x%08x\r\n"), vdd.dw, hres );
                OutputDebugString( tszDbg );
            }
#endif /* DEBUG_STICKY */
            if(SUCCEEDED(hres))
            {
                this->celtBuf = pdipdw->dwData;
                hres = this->hresPolled;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_AXISMODE:
            hres = CDIDev_SetAxisMode(this, pdipdw->dwData);
            break;

            /*
             *  We will handle these global properties
             *  if the callback doesn't want to.
             */
        case (DWORD)(UINT_PTR)DIPROP_RANGE:
        case (DWORD)(UINT_PTR)DIPROP_DEADZONE:
        case (DWORD)(UINT_PTR)DIPROP_SATURATION:
        case (DWORD)(UINT_PTR)DIPROP_CALIBRATIONMODE:
        case (DWORD)(UINT_PTR)DIPROP_CALIBRATION:
            if(ppropi->dwDevType == 0)
            {           /* For device */
                hres = CDIDev_SetGlobalAxisProp(this, ppropi, pdiph);
            } else
            {
                goto _default;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_MAXBUFFERSIZE:
            this->celtBufMax = pdipdw->dwData;
            hres = S_OK;
            break;

#ifdef IDirectInputDevice2Vtbl
        case (DWORD)(UINT_PTR)DIPROP_FFGAIN:
            if(ISVALIDGAIN(pdipdw->dwData))
            {
                this->dwGain = pdipdw->dwData;
                CDIDev_RefreshGain(this);
                hres = S_OK;
            } else
            {
                RPF("ERROR: SetProperty(DIPROP_FFGAIN): Gain out of range");
                hres = E_INVALIDARG;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_AUTOCENTER:
            hres = CDIDev_SetAutoCenter(this, pdipdw->dwData);
            break;
#endif

            _default:;
        default:
            /*
             * The validation filter already failed invalid properties.
             * So what's left is that the property is valid but cannot
             * be set, because it doesn't exist on the device (e.g.,
             * dead zone) or because it is read-only.
             */
            SquirtSqflPtszV(sqfl | sqflBenign, 
                            TEXT("SetProperty: Property 0x%08x not supported on device"),
                            (DWORD)(UINT_PTR)ppropi->pguid );
            hres = E_NOTIMPL;
            break;

        }

    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | RealSetProperty |
 *
 *          The function that does the real work.
 *
 *          <mf IDirectInputDevice::SetDataFormat> will internally
 *          set the axis mode property, so it needs this backdoor
 *          entry point.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN REFGUID | rguidProp |
 *
 *          The identity of the property to be set.
 *
 *  @parm   IN LPDIPROPHEADER | pdiph |
 *
 *          Points to the <t DIPROPHEADER> portion of a structure
 *          which depends on the property.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_RealSetProperty(PDD this, REFGUID rguid, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    DIPROPINFO propi;
    EnterProcR(IDirectInputDevice::SetProperty, (_ "pxp", this, rguid, pdiph));

    /*
     *  Must protect with the critical section to prevent somebody
     *  acquiring or changing the property we are reading.  We need
     *  to do this before validating, to prevent an acquisition.
     */
    CDIDev_EnterCrit(this);

    propi.pguid = rguid;
    if(SUCCEEDED(hres = CDIDev_hresValidProp(this, rguid, pdiph,
                                             0, &propi)))
    {

        hres = this->pdcb->lpVtbl->SetProperty(this->pdcb, &propi, pdiph);

        if(hres == E_NOTIMPL)
        {
            hres = CDIDev_DefSetProperty(this, &propi, pdiph);
        }
    }

    CDIDev_LeaveCrit(this);

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | SetProperty |
 *
 *          Set information about a device or object in a device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN REFGUID | rguidProp |
 *
 *          The identity of the property to be set.  This can be
 *          one of the predefined <c DIPROP_*> values, or it may
 *          be a pointer to a private GUID.
 *
 *  @parm   IN LPDIPROPHEADER | pdiph |
 *
 *          Points to the <t DIPROPHEADER> portion of a structure
 *          which depends on the property.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DI_PROPNOEFFECT> <c S_FALSE>: The operation completed
 *          successfully but
 *          had no effect.  For example, changing the axis mode
 *          on a device with no axes will return this value.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p pdiph> parameter is not a valid pointer, or the
 *          <p dwHow> field is invalid, or the <p dwObj> field
 *          is not zero when <p dwHow> is set to <c DIPH_DEVICE>.
 *
 *          <c DIERR_OBJECTNOTFOUND>:  The specified object does not
 *          exist.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>:  The property
 *          is not supported by the device or object.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetProperty(PV pdd, REFGUID rguid, LPCDIPROPHEADER pdiph _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::SetProperty, (_ "pxp", pdd, rguid, pdiph));

    if(SUCCEEDED(hres = hresPvT(pdd)))
    {
        PDD this = _thisPv(pdd);
        hres = CDIDev_RealSetProperty(this, rguid, pdiph);
    }

    ExitOleProcR();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(SetProperty, (PV pdm, REFGUID rguid, LPCDIPROPHEADER pdiph),
           (pdm, rguid, pdiph THAT_))

#else

    #define CDIDev_SetPropertyA             CDIDev_SetProperty
    #define CDIDev_SetPropertyW             CDIDev_SetProperty

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | SetCooperativeLevel |
 *
 *          Establish the cooperativity level for the instance of
 *          the device.
 *
 *          The cooperativity level determines how the instance of
 *          the device interacts with other instances of the device
 *          and the rest of the system.
 *
 *          Note that if the system mouse is acquired in exclusive
 *          mode, then the mouse cursor will be removed from the screen
 *          until the device is unacquired.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   HWND | hwnd |
 *
 *          The window associated with the device.
 *          The window must be a top-level window.
 *
 *          It is an error to destroy the window while it is still
 *          active in a DirectInput device.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags which describe the cooperativity level associated
 *          with the device.
 *
 *          It consists of <c DISCL_*> flags, documented separately.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p hwnd> parameter is not a valid pointer.
 *
 *****************************************************************************/

HRESULT INLINE
    CDIDev_SetCooperativeLevel_IsValidFl(DWORD dwFlags)
{
    HRESULT hres;
    RD(static char s_szProc[] = "IDirectInputDevice::SetCooperativeLevel");

    if(!(dwFlags & ~DISCL_VALID))
    {
        if((dwFlags & DISCL_EXCLMASK) == DISCL_EXCLUSIVE ||
           (dwFlags & DISCL_EXCLMASK) == DISCL_NONEXCLUSIVE)
        {
            if((dwFlags & DISCL_GROUNDMASK) == DISCL_FOREGROUND ||
               (dwFlags & DISCL_GROUNDMASK) == DISCL_BACKGROUND)
            {
                hres = S_OK;
            } else
            {
                RPF("ERROR %s: arg %d: Must set exactly one of "
                    "DISCL_FOREGROUND or DISCL_BACKGROUND", s_szProc, 2);
                hres = E_INVALIDARG;
            }
        } else
        {
            RPF("ERROR %s: arg %d: Must set exactly one of "
                "DISCL_EXCLUSIVE or DISCL_NONEXCLUSIVE", s_szProc, 2);
            hres = E_INVALIDARG;
        }
    } else
    {
        RPF("ERROR %s: arg %d: invalid flags", s_szProc, 2);
        hres = E_INVALIDARG;

    }
    return hres;
}


HRESULT INLINE
    CDIDev_SetCooperativeLevel_IsValidHwnd(HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    RD(static char s_szProc[] = "IDirectInputDevice::SetCooperativeLevel");

#if DIRECTINPUT_VERSION == 0x0300
    if(dwFlags & DISCL_FOREGROUND)
    {
        if(SUCCEEDED(hres = hresFullValidHwnd(hwnd, 1)))
        {
            /*
             *  The window must be a top-level window to be activated.
             */
            if(!(GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD))
            {
                hres = S_OK;
            } else
            {
                RPF("ERROR %s: window may not be a child window", s_szProc);
                hres = E_HANDLE;
            }
        }
    } else if(dwFlags & DISCL_EXCLUSIVE)
    {
        RPF("IDirectInputDevice::SetCooperativeLevel: "
            "DISCL_EXCLUSIVE requires DISCL_FOREGROUND");
        hres = E_NOTIMPL;
    } else
    {
        hres = S_OK;
    }
#else

    /*
     *  If a window handle is passed, it must be valid.
     *
     *  The window must be a top-level window to be activated.
     *
     *  The window must belong to the calling process so we can
     *  hook it.
     */
    if(hwnd)
    {
        hres = hresFullValidHwnd(hwnd, 1);
        if(SUCCEEDED(hres))
        {
            if(!(GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD))
            {
                if(GetWindowPid(hwnd) == GetCurrentProcessId())
                {
                } else
                {
                    RPF("ERROR %s: window must belong to current process",
                        s_szProc);
                    hres = E_HANDLE;
                }

            } else
            {
                RPF("ERROR %s: window may not be a child window", s_szProc);
                hres = E_HANDLE;
                goto done;
            }
        } else
        {
            goto done;
        }
    }

    /*
     *  Foreground mode or exclusive mode both require a window handle.
     */
    if(dwFlags & (DISCL_FOREGROUND | DISCL_EXCLUSIVE))
    {
        if(hwnd)
        {
        } else
        {
            RPF("ERROR %s: window handle required "
                "if DISCL_EXCLUSIVE or DISCL_FOREGROUND", s_szProc);
            hres = E_HANDLE;
            goto done;
        }
    }

    hres = S_OK;
    done:;
#endif
    return hres;
}


STDMETHODIMP
    CDIDev_SetCooperativeLevel(PV pdd, HWND hwnd, DWORD dwFlags _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::SetCooperativeLevel,
               (_ "pxx", pdd, hwnd, dwFlags));

    if(SUCCEEDED(hres = hresPvT(pdd)))
    {
        PDD this = _thisPv(pdd);

        /*
         *  Must protect with the critical section to prevent somebody
         *  acquiring or Reset()ing behind our back.
         */
        CDIDev_EnterCrit(this);

        if(SUCCEEDED(hres = IDirectInputDevice_NotAcquired(this)) &&
           SUCCEEDED(hres = CDIDev_SetCooperativeLevel_IsValidFl(dwFlags)) &&
           SUCCEEDED(hres = CDIDev_SetCooperativeLevel_IsValidHwnd(hwnd, dwFlags)))
        {

            AssertF(CDIDev_IsConsistent(this));

            /*
             *  For DX7 post Gold fix, check version against co-op level.
             *  Note, GetCaps is non-trivial on a HID but this is no time
             *  for a rewrite.
             */
            if( this->dwVersion < 0x0700 )
            {
                if( dwFlags & DISCL_NOWINKEY )
                {
                    hres = E_INVALIDARG;
                }
                else if( dwFlags & DISCL_EXCLUSIVE )
                {
                    DIDEVCAPS_DX3 dc;
                    dc.dwSize = cbX(dc);
                    if( SUCCEEDED( this->pdcb->lpVtbl->GetCapabilities( this->pdcb, (PV)&dc) ) )
                    {
                        /*
                         *  Don't allow keyboard exclusive mode pre-DX7
                         */
                        if( GET_DIDEVICE_TYPE(dc.dwDevType) == DIDEVTYPE_KEYBOARD )
                        {
                            hres = E_INVALIDARG;
                        }
                    }
                    else
                    {
                        /*
                         *  PS/2 Mouse and keyboard GetCaps are trivial so 
                         *  won't fail.  HID is unlikely to fail for a mouse 
                         *  or keyboard as they generally stay plugged in so 
                         *  assume a failure to GetCaps means a joystick.
                         */
                    }
                }
            }

            if( SUCCEEDED( hres ) )
            {
                hres = this->pdcb->lpVtbl->SetCooperativeLevel(
                                                              this->pdcb, hwnd, dwFlags);
                if(SUCCEEDED(hres))
                {
                    this->discl = dwFlags;
                    this->hwnd = hwnd;
                    if(this->pvi)
                    {
                        this->pvi->hwnd = hwnd;
                    }
                }
            }
            else
            {
                AssertF( hres == E_INVALIDARG );
                RPF("ERROR %s: arg %d: invalid flags", s_szProc, 2);
            }


            AssertF(CDIDev_IsConsistent(this));

        }
        CDIDev_LeaveCrit(this);

    }

    ExitOleProcR();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(SetCooperativeLevel, (PV pdm, HWND hwnd, DWORD fl),
           (pdm, hwnd, fl THAT_))

#else

    #define CDIDev_SetCooperativeLevelA         CDIDev_SetCooperativeLevel
    #define CDIDev_SetCooperativeLevelW         CDIDev_SetCooperativeLevel

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | RunControlPanel |
 *
 *          Run the DirectInput control panel for the device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          Identifies the window handle that will be used as the
 *          parent window for subsequent UI.  NULL is a valid parameter,
 *          indicating that there is no parent window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          No flags are currently defined.  This parameter "must" be
 *          zero.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *  @devnote
 *
 *          The <p dwFlags> is eventually going to allow
 *          <c DIRCP_MODAL> to request a modal control panel.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_RunControlPanel(PV pdd, HWND hwndOwner, DWORD fl _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::RunControlPanel,
               (_ "pxx", pdd, hwndOwner, fl));

    if(SUCCEEDED(hres = hresPvT(pdd)) &&
       SUCCEEDED(hres = hresFullValidHwnd0(hwndOwner, 1)) &&
       SUCCEEDED(hres = hresFullValidFl(fl, DIRCP_VALID, 2)))
    {

        PDD this = _thisPv(pdd);
        IDirectInputDeviceCallback *pdcb;

        /*
         *  Must protect with the critical section to prevent somebody
         *  Reset()ing behind our back.  However, we cannot hold the
         *  critical section during the control panel callback, because
         *  that will yield.
         *
         *  So we copy/addref the pdcb inside the critical section,
         *  then run the control panel outside the critical section,
         *  then release the pdcb when we're finally done.
         */
        CDIDev_EnterCrit(this);

        pdcb = this->pdcb;
        OLE_AddRef(pdcb);

        CDIDev_LeaveCrit(this);

        hres = pdcb->lpVtbl->RunControlPanel(pdcb, hwndOwner, fl);

        OLE_Release(pdcb);
    }

    ExitOleProc();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(RunControlPanel, (PV pdd, HWND hwndOwner, DWORD fl),
           (pdd, hwndOwner, fl THAT_))

#else

    #define CDIDev_RunControlPanelA         CDIDev_RunControlPanel
    #define CDIDev_RunControlPanelW         CDIDev_RunControlPanel

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | Initialize |
 *
 *          Initialize a DirectInputDevice object.
 *
 *          Note that if this method fails, the underlying object should
 *          be considered to be an an indeterminate state and needs to
 *          be reinitialized before it can be subsequently used.
 *
 *          The <mf IDirectInput::CreateDevice> method automatically
 *          initializes the device after creating it.  Applications
 *          normally do not need to call this function.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInput object.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   IN REFGUID | rguid |
 *
 *          Identifies the instance of the device for which the interface
 *          should be associated.
 *          The <mf IDirectInput::EnumDevices> method
 *          can be used to determine which instance GUIDs are supported by
 *          the system.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The device had already been initialized with
 *          the instance GUID passed in <p lpGUID>.
 *
 *          <c DIERR_ACQUIRED>: The device cannot be initialized while
 *          it is acquired.
 *
 *          <c DIERR_DEVICENOTREG>: The instance GUID does not exist
 *          on the current machine.
 *
 *          <c DIERR_HASEFFECTS>:
 *          The device cannot be reinitialized because there are
 *          still effects attached to it.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_Initialize(PV pdd, HINSTANCE hinst, DWORD dwVersion, REFGUID rguid _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::Initialize,
               (_ "pxxG", pdd, hinst, dwVersion, rguid));

    if(SUCCEEDED(hres = hresPvT(pdd)) &&
       SUCCEEDED(hres = hresFullValidGuid(rguid, 1)))
    {
        PDD this = _thisPv(pdd);
        CREATEDCB CreateDcb;
        IDirectInputDeviceCallback *pdcb;

        /*
         *  Must take the critical section to avoid Reset()ing
         *  the device (or generally speaking, screwing with the
         *  internal state variables) while somebody else is
         *  messing with it.
         */
        CDIDev_EnterCrit(this);

        if(SUCCEEDED(hres = hresValidInstanceVer(hinst, dwVersion)) &&
           SUCCEEDED(hres = hresFindInstanceGUID(rguid, &CreateDcb, 1)) &&
           SUCCEEDED(hres = CDIDev_Reset(this)))
        {
            hres = CreateDcb(0, rguid, &IID_IDirectInputDeviceCallback,
                             (PPV)&pdcb);
            if(SUCCEEDED(hres))
            {
                this->pdcb = pdcb;
                AssertF(this->pvi == 0);
                if(SUCCEEDED(hres = CDIDev_GetDataFormat(this)) &&
                   SUCCEEDED(hres = CDIDev_GetPolled(this)) &&
                   SUCCEEDED(hres = this->pdcb->lpVtbl->GetInstance(
                                                                   this->pdcb, &this->pvi)))
                {
#ifdef IDirectInputDevice2Vtbl
                    this->dwVersion = dwVersion;
    #if (DIRECTINPUT_VERSION > 0x061A)
                    AhGetAppHacks( &this->diHacks );
    #endif
                    this->pdcb->lpVtbl->SetDIData(this->pdcb, dwVersion, &this->diHacks);
                   
#ifdef BUGGY_DX7_WINNT
                    if( (this->dwVersion < 0x700) && (this->dwVersion != 0x5B2) ) {
                        if( GET_DIDEVICE_TYPE(this->diHacks.dwDevType) == DIDEVTYPE_JOYSTICK ) {
                            hres = CDIDev_ParseDataFormatInternal(this, &c_dfDIJoystick);
                        }
                    }
#endif //BUGGY_DX7_WINNT
#endif //IDirectInputDevice2Vtbl 
                    
                    if(dwVersion >= DIRECTINPUT_VERSION)
                    {
                        this->didftInstance = DIDFT_ANYINSTANCE;
                    }
                    
                    this->guid = *rguid;
                    if(this->pvi && (this->pvi->fl & VIFL_EMULATED))
                    {
                        this->pvi->pdd = this;
                    }

                    hres = this->pdcb->lpVtbl->CookDeviceData(this->pdcb, 0, 0);
                    if(SUCCEEDED(hres))
                    {
                        this->fCook = 1;
                    }

#ifdef IDirectInputDevice2Vtbl
                    CDIDev_InitFF(this);
#endif
                    hres = S_OK;
                } else
                {
                    RPF("Device driver didn't provide a data format");
                }
            } else
            {
#ifdef NOISY
                RPF("Cannot create device");
#endif
            }
        }
        CDIDev_LeaveCrit(this);
    }

    ExitOleProc();
    return hres;
}

#ifdef XDEBUG

CSET_STUBS(Initialize,
           (PV pdd, HINSTANCE hinst, DWORD dwVersion, REFGUID rguid),
           (pdd, hinst, dwVersion, rguid THAT_))

#else

    #define CDIDev_InitializeA              CDIDev_Initialize
    #define CDIDev_InitializeW              CDIDev_Initialize

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputDevice | Init |
 *
 *          Initialize the internal parts of the DirectInputDevice object.
 *
 *****************************************************************************/

void INLINE
    CDIDev_Init(PDD this)
{
    /*
     *  The critical section must be the very first thing we do,
     *  because only Finalize checks for its existence.
     *
     *  (We might be finalized without being initialized if the user
     *  passed a bogus interface to CDIDev_New.)
     */
    this->fCritInited = fInitializeCriticalSection(&this->crst);

    if( this->fCritInited )
    {
        this->celtBufMax = 1023;            /* Default maximum buffer size */

        this->pdcb = c_pdcbNil;

#ifdef IDirectInputDevice2Vtbl
        GPA_InitFromZero(&this->gpaEff);
#endif
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | New |
 *
 *          Create a new DirectInputDevice object, uninitialized.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::<constructor>, (_ "Gp", riid, punkOuter));

    if (SUCCEEDED(hres = hresFullValidPcbOut(ppvObj, cbX(*ppvObj), 3)))
    {
        hres = Excl_Init();
        if(SUCCEEDED(hres))
        {
            LPVOID pvTry = NULL;
            hres = Common_NewRiid(CDIDev, punkOuter, riid, &pvTry);

            if(SUCCEEDED(hres))
            {
                PDD this = _thisPv(pvTry);
                CDIDev_Init(this);
                if( this->fCritInited )
                {
                    *ppvObj = pvTry;
                }
                else
                {
                    Common_Unhold(this);
                    *ppvObj = NULL;
                    hres = E_OUTOFMEMORY;
                }
            }
        }
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev_ModifyEffectParams |
 *
 *         Modifies parameters of DIEFFECT structure to fit the current FF device
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *
 *  @parm   IN OUT LPDIEFFECT | peff |
 *  
 *          Pointer to the effect structure
 *
 *  @parm   IN GUID | effGUID |
 *
 *         GUID for the effect
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_UNSUPPORTED>: The effect can't be supported by the current device
 *          (e.g. the number of FF axes on the device is 0)
 *
 *          <c DIERR_INVALIDPARAM>: Can't create the effect even with the modified parameters
 *
 *****************************************************************************/

HRESULT CDIDev_ModifyEffectParams
    (
    PV pdd,
    LPDIEFFECT peff,
    GUID effGUID
    )
{
    HRESULT hres = S_OK;
    HRESULT hresCreate = S_OK;
    LPDIRECTINPUTEFFECT pdeff;
    PDD this = _thisPv(pdd);

    EnterProcR(CDIDev_ModifyEffectParams, (_ "p", pdd));

    // Check to make sure that effects we enumerate will 
    // actually get created on the device.
    // try creating the effect.
#ifdef XDEBUG       
    hresCreate = CDIDev_CreateEffect(this, &effGUID, peff, &pdeff, NULL, ((LPUNKNOWN)this)->lpVtbl);
#else
    hresCreate = CDIDev_CreateEffect(this, &effGUID, peff, &pdeff, NULL);
#endif
                
    if(SUCCEEDED(hresCreate))
    {
        Invoke_Release(&pdeff);    
    }
    else
    {
        if (hresCreate == DIERR_INVALIDPARAM)
            {
                //two things can give DIERR_INVALIDPARAM:
                //invalid axes and invalid trigger button
                //check the axes first, then the trigger buttons
                //try to eliminate all DIERR_INVALIDPARAMS
                LPDIOBJECTDATAFORMAT lpObjDat = this->df.rgodf;
                DWORD dwNum = this->df.dwNumObjs;
                DWORD nCount;
                LPDWORD lpAxes;
                LPDWORD lpThisAxis;
                LPDWORD lpEffAxis;
                DWORD nAxes = 0;
                DWORD dwTrigger = DIJOFS_BUTTON(0);
                BOOL bTriggerCorrect = FALSE;
                AllocCbPpv(sizeof(DWORD)*dwNum, &lpAxes);
                lpThisAxis = lpAxes;
                for (nCount = 0; nCount < dwNum; nCount ++)
                {
                    AssertF(lpObjDat != NULL);

                    //check the axes
                    if ((lpObjDat->dwType & (DIDFT_AXIS | DIDFT_FFACTUATOR) & DIDFT_TYPEMASK) &&
                        (fHasAllBitsFlFl(lpObjDat->dwType, (DIDFT_AXIS | DIDFT_FFACTUATOR) & DIDFT_ATTRMASK)))
                    {
                        *lpAxes = lpObjDat->dwOfs;
                        nAxes++;
                        lpAxes++;
                    }
                    else
                    {
                        //check the trigger button, if there's one
                        if ((peff->dwTriggerButton != DIEB_NOTRIGGER) && 
                            (lpObjDat->dwType & DIDFT_FFEFFECTTRIGGER & DIDFT_TYPEMASK) &&
                            (fHasAllBitsFlFl(lpObjDat->dwType, DIDFT_FFEFFECTTRIGGER & DIDFT_ATTRMASK)))
            
                        {
                            if (lpObjDat->dwOfs == peff->dwTriggerButton)
                            {
                                //the trigger is valid
                                bTriggerCorrect = TRUE;
                            }
                            else
                            {
                                //remember the trigger offset for the future
                                dwTrigger = lpObjDat->dwOfs;
                            }
                        }
                    }

                    lpObjDat++;
                }

                //first, chack if there are any FF axes
                if (nAxes == 0)
                {
                        //return an error if no FF axes on device
                        hres = DIERR_UNSUPPORTED;
                }
                else
                {

                    
                    //trigger buttons are checked for validity before axes,
                    //so set the trigger button, if needed,
                    //because if it is invalid, this is what caused the error
                    if ((peff->dwTriggerButton != DIEB_NOTRIGGER) && (bTriggerCorrect == FALSE))
                    {
                        peff->dwTriggerButton = dwTrigger;

                        // and try creating again
#ifdef XDEBUG
                        hresCreate = CDIDev_CreateEffect(this, &effGUID, peff, &pdeff, NULL, ((LPUNKNOWN)this)->lpVtbl);
#else
                        hresCreate = CDIDev_CreateEffect(this, &effGUID, peff, &pdeff, NULL);
#endif
                        if(SUCCEEDED(hresCreate))
                        {
                            Invoke_Release(&pdeff);
                        }

                    }
                    
                
                    if (hresCreate == DIERR_INVALIDPARAM)
                    {
                                
                        HRESULT hresInfo = S_OK;
                        EFFECTMAPINFO emi;

                        //this time, set the axes
                        if (peff->cAxes > nAxes)
                        {
                            //change the number of axes
                            peff->cAxes = nAxes;

                            //change the flags
                            if ((nAxes < 3)  && (peff->dwFlags & DIEFF_SPHERICAL))
                            {
                                peff->dwFlags &= ~DIEFF_SPHERICAL;
                                peff->dwFlags |= DIEFF_POLAR;
                            }
                            else
                            {
                                if ((nAxes < 2) && (peff->dwFlags & DIEFF_POLAR))
                                {
                                    peff->dwFlags &= ~DIEFF_POLAR;
                                    peff->dwFlags |= DIEFF_CARTESIAN;
                                }
                            }

                        }


                        //check if size of type-specific param structures is not bigger then number of axes,
                        //since this can also give us invalid params in type-specific .

                        //need to do this only for conditions
                        if (SUCCEEDED(hresInfo = CDIDev_FindEffectGUID(this, &effGUID, &emi, 2))) 
                        {
                            //do the conditions
                            if (emi.attr.dwEffType & DIEFT_CONDITION)
                            {
                                if (peff->cbTypeSpecificParams/(sizeof(DICONDITION)) > peff->cAxes)
                                {
                                    peff->cbTypeSpecificParams = peff->cAxes*(sizeof(DICONDITION));
                                }
                            }

                            //don't need to do anything for custom forces,
                            //since DInput doesn't check number of channels against number of axes anyway
                        }


                        //write over the axes
                        lpEffAxis = peff->rgdwAxes;
                        for (nCount = 0; nCount < nAxes, nCount < peff->cAxes; nCount ++)
                        {
                            *(lpEffAxis) = *(lpThisAxis);
                            lpThisAxis ++;
                            lpEffAxis++;
                        }


                        // and try creating again
#ifdef XDEBUG
                        hresCreate = CDIDev_CreateEffect(this, &effGUID, peff, &pdeff, NULL, ((LPUNKNOWN)this)->lpVtbl);
#else
                        hresCreate = CDIDev_CreateEffect(this, &effGUID, peff, &pdeff, NULL);
#endif
                        if(SUCCEEDED(hresCreate))
                        {
                                Invoke_Release(&pdeff);    
                        }
                        
                    }
                }

                //free the axes array
                FreePpv(&lpAxes);
            }
        }

    if ((SUCCEEDED(hres)) && (hresCreate == DIERR_INVALIDPARAM))
    {
        hres = hresCreate;
    }


    ExitOleProc();
    return hres;

}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | CDIDev_IsStandardEffect |
 *
 *         Checks if the effect GUID belongs to a standard DI effect
 *
 *  @parm   IN GUID | effGUID |
 *
 *         GUID for the effect
 *
 *  @returns BOOL
 *
 *      TRUE if it is a standard DI effect;
 *      FALSE otherwise.
 *
 *
 *****************************************************************************/

BOOL CDIDev_IsStandardEffect
    (GUID effGUID)
{
    BOOL bStandard = TRUE;


    //check all the standard DX7 GUIDs
    if ((IsEqualGUID(&effGUID, &GUID_Sine))         ||
        (IsEqualGUID(&effGUID, &GUID_Triangle))     ||
        (IsEqualGUID(&effGUID, &GUID_ConstantForce)) ||
        (IsEqualGUID(&effGUID, &GUID_RampForce))        ||
        (IsEqualGUID(&effGUID, &GUID_Square))       ||
        (IsEqualGUID(&effGUID, &GUID_SawtoothUp))   ||
        (IsEqualGUID(&effGUID, &GUID_SawtoothDown)) ||
        (IsEqualGUID(&effGUID, &GUID_Spring))       ||
        (IsEqualGUID(&effGUID, &GUID_Damper))       ||
        (IsEqualGUID(&effGUID, &GUID_Inertia))      ||
        (IsEqualGUID(&effGUID, &GUID_Friction))     ||
        (IsEqualGUID(&effGUID, &GUID_CustomForce)))
    {
        bStandard = TRUE;
    }

    else
    {
        bStandard = FALSE;
    }

    return bStandard;

}



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | EnumEffectsInFile |
 *
 *          Enumerates DIEFFECT struct(s) and effect GUID from file. 
 *          An application can use this in order to create pre-authored
 *          force effects.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm  LPCSTR | lpszFileName | 
 *
 *          Name of the RIFF file that contains collection of effects. 
 *
 *  @parm   IN OUT LPENUMEFFECTSCALLBACK | pec |
 *  
 *          The callback function.
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputDevice::EnumObjects> function.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          Flags which control the enumeration.
 *
 *          It consists of <c DIFEF_*> flags, documented separately.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpDirectInputDevice> or
 *          <p lpdc> parameter is invalid.
 *
 *  @cb     BOOL CALLBACK | DIEnumEffectsCallback |
 *
 *          An application-defined callback function that receives
 *          effect GUID, DIEFFECT and repeat count as a result of a call to the
 *          <om IDirectInputDevice::EnumEffectsInFile> method.
 *
 *  @parm   OUT LPCDIFILEEFFECT | lpDiFileEf |
 *          
 *          Pointer to a DIFILEEFFECT structure. 
 *
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputDevice::EnumObjects> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *****************************************************************************/

HRESULT CDIDev_EnumEffectsInFileA
    (
    PV pddA,
    LPCSTR lpszFileName, 
    LPDIENUMEFFECTSINFILECALLBACK pec, 
    LPVOID pvRef,
    DWORD dwFlags
    )
{
    HRESULT hres = E_FAIL;

    
    EnterProcR(IDirectInputDevice::EnumEffectsInFile, (_ "s", lpszFileName));

    /* Validate incoming parameters */
    if(SUCCEEDED(hres = hresPvA(pddA)) &&
       SUCCEEDED(hres = hresFullValidReadStrA(lpszFileName, MAX_JOYSTRING,1)) &&
       SUCCEEDED(hres = hresFullValidPfn(pec, 2)) &&
       SUCCEEDED(hres = hresFullValidFl(dwFlags, DIFEF_ENUMVALID, 3)) )
    {
        PDD this = _thisPvNm(pddA, ddA);
        HMMIO       hmmio;        
        MMCKINFO    mmck;
        DWORD       dwEffectSz;

        hres = RIFF_Open(lpszFileName, MMIO_READ | MMIO_ALLOCBUF , &hmmio, &mmck, &dwEffectSz);

        if(SUCCEEDED(hres))
        {
            HRESULT hresRead;
            DIEFFECT        effect;
            DIFILEEFFECT    DiFileEf;
            DIENVELOPE      diEnvelope;
            DWORD           rgdwAxes[DIEFFECT_MAXAXES];
            LONG            rglDirection[DIEFFECT_MAXAXES];
            
            effect.rgdwAxes     = rgdwAxes;
            effect.rglDirection = rglDirection;
            effect.lpEnvelope   = &diEnvelope;

            DiFileEf.dwSize     = cbX(DiFileEf);
            DiFileEf.lpDiEffect = &effect;

            while ((SUCCEEDED(hres)) && (SUCCEEDED(hresRead = RIFF_ReadEffect(hmmio, &DiFileEf))))
            {
                BOOL fRc = DIENUM_CONTINUE; 
                BOOL bInclude = TRUE;
                HRESULT hresModify = DI_OK;

                //modify if needed
                if (dwFlags & DIFEF_MODIFYIFNEEDED)
                {
                    hresModify = CDIDev_ModifyEffectParams(this, &effect, DiFileEf.GuidEffect); 
                }

                //if necessary, check whether effect is standard
                if (!(dwFlags & DIFEF_INCLUDENONSTANDARD))
                {
                    bInclude = CDIDev_IsStandardEffect(DiFileEf.GuidEffect);
                }

                //call back only if all the conditions posed by the flags are satisfied 
                if ((SUCCEEDED(hresModify)) && (bInclude == TRUE))
                {
                    fRc = Callback(pec, &DiFileEf, pvRef);
                }

                //free type-specific only if allocated
                if(effect.cbTypeSpecificParams > 0)
                {
                    FreePv(effect.lpvTypeSpecificParams);
                    effect.cbTypeSpecificParams = 0x0;
                }

                if(fRc == DIENUM_STOP)
                {
                    break;
                } else if(fRc == DIENUM_CONTINUE)
                {
                    continue;
                } else
                {
                    RPF("IDirectInputDevice::EnumEffectsInFile: Invalid return value from enumeration callback");
                    ValidationException();
                    break;
                }
            }
            RIFF_Close(hmmio, 0);
            //if hresRead failed because couldn't descend into the chunk, it means the end of file,
            //so everything is OK;
            //else return this error
            if (SUCCEEDED(hres))
            {   
                if (hresRead == hresLe(ERROR_SECTOR_NOT_FOUND))
                {
                    hres = S_OK;
                }
                else
                {
                    hres = hresRead;
                }
            }
        }
    }

    ExitOleProc();
    return hres;
}


HRESULT CDIDev_EnumEffectsInFileW
    (
    PV pddW,
    LPCWSTR lpszFileName, 
    LPDIENUMEFFECTSINFILECALLBACK pec, 
    LPVOID pvRef,
    DWORD dwFlags
    )
{

    HRESULT hres = E_FAIL;

    EnterProcR(IDirectInputDevice::EnumEffectsInFileW, (_ "s", lpszFileName));

    /* Validate incoming parameters */
    if(SUCCEEDED(hres = hresPvW(pddW)) &&
       SUCCEEDED(hres = hresFullValidReadStrW(lpszFileName, MAX_JOYSTRING,1)) &&
       SUCCEEDED(hres = hresFullValidPfn(pec, 2)) &&
       SUCCEEDED(hres = hresFullValidFl(dwFlags, DIFEF_ENUMVALID, 3)) )
    {
        CHAR szFileName[MAX_PATH];

        PDD this = _thisPvNm(pddW, ddW);
        
        UToA(szFileName, MAX_PATH, lpszFileName);

        hres = CDIDev_EnumEffectsInFileA(&this->ddA, szFileName, pec, pvRef, dwFlags);
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | WriteEffectToFile |
 *
 *          Writes DIEFFECT struct(s) and effect GUID to a file. 
 *          An application can use this in order to create pre-authored
 *          force effects.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPCSTR | lpszFileName | 
 *
 *          Name of the RIFF file that contains collection of effects. 
 *
 *  @parm   IN DWORD  | dwEntries |
 *
 *          Number of <t DIFILEEFFECT> structures in the array.
 *
 *  @parm   IN LPCDIFILEEFFECT | rgDiFileEft |
 *
 *          Array of <t DIFILEEFFECT> structure.
 *
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          Flags which control how the effect should be written.
 *
 *          It consists of <c DIFEF_*> flags, documented separately.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpDirectInputDevice> or
 *          <p lpdc> parameter is invalid.
 *
 *****************************************************************************/


HRESULT CDIDev_WriteEffectToFileA
    (
    PV          pddA,
    LPCSTR      lpszFileName,
    DWORD       dwEntries,
    LPDIFILEEFFECT rgDiFileEffect,
    DWORD       dwFlags
    )
{
    HRESULT hres = E_NOTIMPL;

    EnterProcR(IDirectInputDevice:cd inc
               :WriteEffectToFileA, (_ "s", lpszFileName));


    /* Validate incoming parameters */
    if(SUCCEEDED(hres = hresPvA(pddA)) &&
       SUCCEEDED(hres = hresFullValidReadStrA(lpszFileName, MAX_JOYSTRING,1))&&
       SUCCEEDED(hres = hresFullValidFl(dwFlags, DIFEF_ENUMVALID, 3))  &&
       SUCCEEDED(hres = (IsBadReadPtr(rgDiFileEffect, cbX(*rgDiFileEffect))) ? E_POINTER : S_OK))

    {
        PDD this = _thisPvNm(pddA, ddA);
        HMMIO       hmmio;        
        MMCKINFO    mmck;
        DWORD       dwEffectSz;

        hres = RIFF_Open(lpszFileName, MMIO_CREATE | MMIO_WRITE | MMIO_ALLOCBUF , &hmmio, &mmck, &dwEffectSz);

        if(SUCCEEDED(hres))
        {
            UINT nCount;
            LPDIFILEEFFECT  lpDiFileEf = rgDiFileEffect;

            //write out the effects
            for(nCount = 0; nCount < dwEntries; nCount++)
            {
                BOOL bInclude = TRUE;

                hres = (IsBadReadPtr(lpDiFileEf, cbX(*lpDiFileEf))) ? E_POINTER : S_OK;

                if (FAILED(hres))
                {
                    break;
                }
                

                //if necessary, check whether the effect is standard
                if (!(dwFlags & DIFEF_INCLUDENONSTANDARD))
                {
                    bInclude = CDIDev_IsStandardEffect(lpDiFileEf->GuidEffect);
                }

                if ((SUCCEEDED(hres)) && (bInclude == TRUE))
                {
                    hres = RIFF_WriteEffect(hmmio, lpDiFileEf);
                }

                if(FAILED(hres))
                {
                    break;
                }

                lpDiFileEf++;
                
            }
            RIFF_Close(hmmio, 0);
        }
    }

    ExitOleProc();
    return hres;
}


HRESULT CDIDev_WriteEffectToFileW
    (
    PV          pddW,
    LPCWSTR      lpszFileName,
    DWORD       dwEntries,
    LPDIFILEEFFECT lpDiFileEffect,
    DWORD       dwFlags
    )
{

    HRESULT hres = E_FAIL;

    EnterProcR(IDirectInputDevice::WriteEffectToFile, (_ "s", lpszFileName));

    /* Validate incoming parameters */
    if(SUCCEEDED(hres = hresPvW(pddW)) &&
       SUCCEEDED(hres = hresFullValidReadStrW(lpszFileName, MAX_JOYSTRING,1)))
    {
        CHAR szFileName[MAX_PATH];

        PDD this = _thisPvNm(pddW, ddW);
        
        UToA(szFileName, MAX_PATH, lpszFileName);

        hres = CDIDev_WriteEffectToFileA(&this->ddA, szFileName, dwEntries, lpDiFileEffect, dwFlags);
    }

    return hres;
}
/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CDIDev_Signature        0x20564544      /* "DEV " */

Primary_Interface_Begin(CDIDev, TFORM(ThisInterfaceT))
TFORM(CDIDev_GetCapabilities),
TFORM(CDIDev_EnumObjects),
TFORM(CDIDev_GetProperty),
TFORM(CDIDev_SetProperty),
TFORM(CDIDev_Acquire),
TFORM(CDIDev_Unacquire),
TFORM(CDIDev_GetDeviceState),
TFORM(CDIDev_GetDeviceData),
TFORM(CDIDev_SetDataFormat),
TFORM(CDIDev_SetEventNotification),
TFORM(CDIDev_SetCooperativeLevel),
TFORM(CDIDev_GetObjectInfo),
TFORM(CDIDev_GetDeviceInfo),
TFORM(CDIDev_RunControlPanel),
TFORM(CDIDev_Initialize),
#ifdef IDirectInputDevice2Vtbl
TFORM(CDIDev_CreateEffect),
TFORM(CDIDev_EnumEffects),
TFORM(CDIDev_GetEffectInfo),
TFORM(CDIDev_GetForceFeedbackState),
TFORM(CDIDev_SendForceFeedbackCommand),
TFORM(CDIDev_EnumCreatedEffectObjects),
TFORM(CDIDev_Escape),
TFORM(CDIDev_Poll),
TFORM(CDIDev_SendDeviceData),
#ifdef IDirectInputDevice7Vtbl
TFORM(CDIDev_EnumEffectsInFile),
TFORM(CDIDev_WriteEffectToFile),
#endif
#endif

    Primary_Interface_End(CDIDev, TFORM(ThisInterfaceT))

Secondary_Interface_Begin(CDIDev, SFORM(ThisInterfaceT), SFORM(dd))
SFORM(CDIDev_GetCapabilities),
SFORM(CDIDev_EnumObjects),
SFORM(CDIDev_GetProperty),
SFORM(CDIDev_SetProperty),
SFORM(CDIDev_Acquire),
SFORM(CDIDev_Unacquire),
SFORM(CDIDev_GetDeviceState),
SFORM(CDIDev_GetDeviceData),
SFORM(CDIDev_SetDataFormat),
SFORM(CDIDev_SetEventNotification),
SFORM(CDIDev_SetCooperativeLevel),
SFORM(CDIDev_GetObjectInfo),
SFORM(CDIDev_GetDeviceInfo),
SFORM(CDIDev_RunControlPanel),
SFORM(CDIDev_Initialize),
#ifdef IDirectInputDevice2Vtbl
SFORM(CDIDev_CreateEffect),
SFORM(CDIDev_EnumEffects),
SFORM(CDIDev_GetEffectInfo),
SFORM(CDIDev_GetForceFeedbackState),
SFORM(CDIDev_SendForceFeedbackCommand),
SFORM(CDIDev_EnumCreatedEffectObjects),
TFORM(CDIDev_Escape),
SFORM(CDIDev_Poll),
SFORM(CDIDev_SendDeviceData),
#ifdef IDirectInputDevice7Vtbl
SFORM(CDIDev_EnumEffectsInFile),
SFORM(CDIDev_WriteEffectToFile),
#endif
#endif
    Secondary_Interface_End(CDIDev, SFORM(ThisInterfaceT), SFORM(dd))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dicf.c ===
/*****************************************************************************
 *
 *  DICF.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      DirectInput ClassFactory.
 *
 *  Contents:
 *
 *      IClassFactory::CreateInstance
 *      IClassFactory::LockServer
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflFactory

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CDIFactory, IClassFactory);

Interface_Template_Begin(CDIFactory)
    Primary_Interface_Template(CDIFactory, IClassFactory)
Interface_Template_End(CDIFactory)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CDIFactory |
 *
 *          The DirectInput <i IClassFactory>, which is how you create an
 *          <i IDirectInput> object.
 *          There really isn't anything interesting in the structure
 *          itself.
 *
 *  @field  IClassFactory | cf |
 *
 *          ClassFactory object (containing vtbl).
 *
 *  @field  CREATEFUNC | pfnCreate |
 *
 *          Function that creates new objects.
 *
 *****************************************************************************/

typedef struct CDIFactory {

    /* Supported interfaces */
    IClassFactory   cf;

    CREATEFUNC pfnCreate;

} CDIFactory, DCF, *PDCF;

typedef IClassFactory CF, *PCF;

#define ThisClass CDIFactory
#define ThisInterface IClassFactory
#define ThisInterfaceT IClassFactory

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IClassFactory | QIHelper |
 *
 *          We don't have any dynamic interfaces and simply forward
 *          to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | IClassFactory_AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | IClassFactory_Finalize |
 *
 *          We don't have any instance data, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CDIFactory)
Default_AddRef(CDIFactory)
Default_Release(CDIFactory)

#else

#define CDIFactory_QueryInterface     Common_QueryInterface
#define CDIFactory_AddRef             Common_AddRef
#define CDIFactory_Release            Common_Release

#endif

#define CDIFactory_QIHelper           Common_QIHelper
#define CDIFactory_AppFinalize        Common_AppFinalize
#define CDIFactory_Finalize           Common_Finalize

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | CreateInstance |
 *
 *          This function creates a new DirectInput object with
 *          the specified interface.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown.
 *          Aggregation is not supported in this version of DirectInput,
 *          so the value "should" be 0.
 *
 *  @parm   IN REFIID | riid |
 *          Desired interface.  This parameter "must" point to a valid
 *          interface identifier.
 *
 *  @parm   OUT LPVOID * | ppvOut |
 *          Points to where to return the pointer to the created interface,
 *          if successful.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c S_OK>: The operation completed successfully.
 *
 *          <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c CLASS_E_NOAGGREGATION>:
 *          Aggregation not supported.
 *
 *          <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c E_NOINTERFACE>:
 *          The specified interface is not supported.
 *
 *  @xref   OLE documentation for <mf IClassFactory::CreateInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIFactory_CreateInstance(PCF pcf, PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IClassFactory::CreateInstance,
               (_ "ppGp", pcf, punkOuter, riid, ppvObj));

    if (SUCCEEDED(hres = hresPv(pcf))) {
        PDCF this;
        if (Num_Interfaces(CDIFactory) == 1) {
            this = _thisPvNm(pcf, cf);
        } else {
            this = _thisPv(pcf);
        }

        /*
         *  All parameters will be validated by pfnCreate.
         */
        hres = this->pfnCreate(punkOuter, riid, ppvObj);
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | LockServer |
 *
 *          This function increments or decrements the DLL lock
 *          count.  While the DLL lock count is nonzero,
 *          it will not be removed from memory.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @parm   BOOL | fLock |
 *          If <c TRUE>, increments the lock count.
 *          If <c FALSE>, decrements the lock count.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c S_OK>: The operation completed successfully.
 *
 *          <c E_OUTOFMEMORY>: Out of memory.
 *
 *  @xref   OLE documentation for <mf IClassFactory::LockServer>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIFactory_LockServer(PCF pcf, BOOL fLock)
{
    HRESULT hres;
    EnterProcR(IClassFactory::LockServer, (_ "px", pcf, fLock));

    if (SUCCEEDED(hres = hresPv(pcf))) {
        if (fLock) {
            DllAddRef();
        } else {
            DllRelease();
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | IClassFactory | New |
 *
 *          Create a new instance of the class factory.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *          Output pointer for new object.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIFactory_New(CREATEFUNC pfnCreate, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IClassFactory::<constructor>, (_ "G", riid));

    hres = Common_NewRiid(CDIFactory, 0, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        PDCF this;
        if (Num_Interfaces(CDIFactory) == 1) {
            /* We can go directly in because we cannot be aggregated */
            this = *ppvObj;
        } else {
            this = _thisPv(*ppvObj);
        }

        this->pfnCreate = pfnCreate;
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbl.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA
#define CDIFactory_Signature  0x20204643          /* "CF  " */

Primary_Interface_Begin(CDIFactory, IClassFactory)
    CDIFactory_CreateInstance,
    CDIFactory_LockServer,
Primary_Interface_End(CDIFactory, IClassFactory)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\didev.h ===
/*****************************************************************************
 *
 *  DIDev.h
 *
 *  Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Common header file for IDirectInputDevice implementation.
 *
 *      The original didev.c file was getting too big, so the
 *      stuff that supports IDirectInputEffect has been split out
 *      into didevef.c.  Since both files need to access the
 *      internal structure of an IDirectInputDevice, we need this
 *      common header file.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDev

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

#define ThisClass CDIDev

#ifdef IDirectInputDevice7Vtbl
    #define ThisInterface TFORM(IDirectInputDevice7)
    #define ThisInterfaceA IDirectInputDevice7A
    #define ThisInterfaceW IDirectInputDevice7W
    #define ThisInterfaceT IDirectInputDevice7
#else
    #ifdef IDirectInputDevice2Vtbl

        #define ThisInterface TFORM(IDirectInputDevice2)
        #define ThisInterfaceA IDirectInputDevice2A
        #define ThisInterfaceW IDirectInputDevice2W
        #define ThisInterfaceT IDirectInputDevice2

    #else

        #define ThisInterface TFORM(IDirectInputDevice)
        #define ThisInterfaceA IDirectInputDeviceA
        #define ThisInterfaceW IDirectInputDeviceW
        #define ThisInterfaceT IDirectInputDevice

    #endif
#endif
Primary_Interface(CDIDev, TFORM(ThisInterfaceT));
Secondary_Interface(CDIDev, SFORM(ThisInterfaceT));

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @enum   DIOPT |
 *
 *          Device data format optimization levels.
 *
 *  @emem   dioptNone |
 *
 *          Device data format is not optimized at all.  We must read
 *          the device data into a private buffer and copy each field
 *          into the application buffer.
 *
 *  @emem   dioptMatch |
 *
 *          Application data format matches the device data format
 *          in the places where the application requests data at all.
 *          We can read the device data into a private buffer, then
 *          block copy the data into the application buffer.
 *
 *
 *  @emem   dioptDirect |
 *
 *          <e DIOPT.dioptMatch>, plus the entire device data
 *          format fits inside the application format.
 *          We can read the device data directly into the application
 *          buffer.
 *
 *  @emem   dioptEqual |
 *
 *          <e DIOPT.dioptDirect>, plus the device data format
 *          and application data formats are completely equal
 *          (except for fields that the app doesn't explicitly
 *          ask for).
 *          We can issue buffered reads directly into the application
 *          buffer.
 *
 *****************************************************************************/

typedef enum DIOPT
{
    dioptNone       =       0,
    dioptMatch      =       1,
    dioptDirect     =       2,
    dioptEqual      =       3,
} DIOPT;


#undef BUGGY_DX7_WINNT
#ifdef WINNT
#define BUGGY_DX7_WINNT 1
#endif //WINNT

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CDIDev |
 *
 *          The generic <i IDirectInputDevice> object.
 *
 *          The A and W versions are simply alternate interfaces on the same
 *          underlying object.
 *
 *  @field  IDirectInputDeviceA | ddA |
 *
 *          ANSI DirectInputDevice object (containing vtbl).
 *
 *  @field  IDirectInputDeviceW | ddW |
 *
 *          UNICODE DirectInputDevice object (containing vtbl).
 *
#ifdef IDirectInputDevice2Vtbl
 *  @field  IDirectInputDevice2A | dd2A |
 *
 *          ANSI DirectInputDevice2 object (containing vtbl).
 *
 *  @field  IDirectInputDevice2W | dd2W |
 *
 *          UNICODE DirectInputDevice2 object (containing vtbl).
#endif
 *
 *  @field  IDirectInputDeviceCallback * | pdcb |
 *
 *          Callback object which handles the low-level device access.
 *
 *  @field  BOOL | fAcquired:1 |
 *
 *          Set if the device has been acquired.  Before the device
 *          can be acquired, the <e CDIDev.pdix> must be set.
 *
 *  @field  BOOL | fAcquiredInstance:1 |
 *
 *          Set if the device instance has been acquired by us.
 *          This lets us know how much needs to be done on the
 *          unacquire.
 *
 *  @field  BOOL | fCritInited:1 |
 *
 *          Set if the critical section has been initialized.
 *
#if DIRECTINPUT_VERSION > 0x0300
 *  @field  BOOL | fCook:1 |
 *
 *          Set if the device requires that data be cooked.
 *
 *  @field  BOOL | fPolledDataFormat:1 |
 *
 *          Set if the device's data format requires explicit polling.
 *
 *  @field  BOOL | fOnceAcquired:1 |
 *
 *          Set once the device is acquired.
 *
 *  @field  BOOL | fOnceForcedUnacquired:1 |
 *
 *          Set once the device is forced unacquired.
 *
 *  @field  BOOL | fUnacqiredWhenIconic:1 |
 *
 *          Set once the device is unacquired (in CDIDev_CallWndProc) when the app is minimized.
 *
#endif
 *  @field  HWND | hwnd |
 *
 *          Window that has requested exclusive access when acquired.
 *
 *  @field  DWORD | discl |
 *
 *          Current value of
 *          <mf IDirectInputDevice::SetCooperativeLevel> flags.
 *
#ifdef BUGGY_DX3_SP3
 *  @field  int | cInstCwp |
 *
 *          Instance of the CallWndProc hook we installed with.
 *
#endif
 *  @field  HANDLE | hNotify |
 *
 *          The notification handle that should be set when the
 *          state of the device changes.  Note that this is actually
 *          a copy of the original handle supplied by the application,
 *          so the handle should be closed when no longer needed.
 *
 *  @field  FARPROC | GetState |
 *
 *          Function that transfers the device data in response
 *          to <mf IDirectInputDevice::GetDeviceState>.  This field
 *          is computed when the data format is set.
 *
 *  @field  PDIXLAT | pdix |
 *
 *          Pointer to table used for data format translation.
 *          It is indexed by device object; the value is the
 *          location in the application data format where the
 *          data should be stored.
 *
 *          For example, if the object described by
 *          <e CDIDev.df.rgodf[3]>
 *          should be placed at offset 8 in the application
 *          data format, then
 *          <e CDIDev.pdix[3]> = 8.
 *
 *  @field  PING | rgiobj |
 *
 *          The inverse of <e CDIDev.pdix>.  Given an offset,
 *          converts it to the device object index.
 *
 *          For example, if the object described by
 *          <e CDIDev.df.rgodf[3]>
 *          should be placed at offset 8 in the application
 *          data format, then
 *          <e CDIDev.rgiobj[8]> = 3.
 *
 *          Entries for invalid offsets are -1.
 *
 *  @field  DWORD | dwDataSize |
 *
 *          Size of the data, as requested by the application.
 *
 #ifdef BUGGY_DX7_WINNT
 *
 *  @field  PDIXLAT | pdix2 |
 *
 *          Pointer to table used for data format (c_rgodfDIJoy) translation.
 *          It is indexed by device object; the value is the
 *          location in the application data format where the
 *          data should be stored.
 *
 *          For example, if the object described by
 *          <e CDIDev.df.rgodf[3]>
 *          should be placed at offset 8 in the application
 *          data format, then
 *          <e CDIDev.pdix2[3]> = 8.
 *
 *          See @devnotes on CDIDev_ParseDataFormatInternal for detail.
 *
 *  @field  PING | rgiobj2 |
 *
 *          The inverse of <e CDIDev.pdix2>.  Given an offset,
 *          converts it to the device object index.
 *
 *          For example, if the object described by
 *          <e CDIDev.df.rgodf[3]>
 *          should be placed at offset 8 in the application
 *          data format, then
 *          <e CDIDev.rgiobj2[8]> = 3.
 *
 *          Entries for invalid offsets are -1.
 *
 *  @field  DWORD | dwDataSize2 |
 *
 *          Size of the data, as requested by the application (connected to rgiobj2).
 *
 #endif
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          Device data format.
 *
 *  @field  DIOPT | diopt |
 *
 *          Device optimization level.
 *
 *  @field  int | ibDelta |
 *
 *          If <e CDIDev.diopt> is at least <e DIOPT.dioptMatch>,
 *          contains the shift necessary in order to align the
 *          application data format with the device data format.
 *
 *  @field  int | ibMin |
 *
 *          If <e CDIDev.diopt> is at least <e DIOPT.dioptMatch>,
 *          contains the offset of the first field in the device
 *          format which is valid in both the application and
 *          device data formats.
 *
 *  @field  DWORD | cbMatch |
 *
 *          If <e CDIDev.diopt> is at least <e DIOPT.dioptMatch>,
 *          contains the number of bytes which matched.  This is the
 *          number of bytes that can be block-copied.
 *
 *  @field  PV | pvBuffer |
 *
 *          if <e CDIDev.diopt> is <e DIOPT.dioptMatch> or less,
 *          then contains a scratch buffer equal in size to the
 *          device data format which is used when an unoptimized
 *          data format has been selected.
 *
 *  @field  PV | pvLastBuffer |
 *
 *          Last instantaneous device state received.  This is used
 *          to emulate relative axes.  Only the axis fields of the
 *          structure are valid.
 *
 *  @field  PVXDINSTANCE | pvi |
 *
 *          Instance handle for talking to the VxD.
 *
 *  @field  DWORD | cAxes |
 *
 *          Number of axes on the device.  This in turn yields the
 *          size of the axis offset table.
 *
 *  @field  LPDWORD | rgdwAxesOfs |
 *
 *          Axis offset table.  This is used during relative axis
 *          acquisition mode to convert the absolute numbers into
 *          relative numbers.
 *
 *  @field  HRESULT | hresPolled |
 *
 *          <c S_OK> if the device is interrupt-driven.
 *          <c DI_POLLEDDEVICE> if the device is polled.
 *
 *  @field  HRESULT | hresNotAcquired |
 *
 *          <c DIERR_INPUTLOST> if the device was unacquired without
 *          the application's consent.  <c DIERR_NOTACQUIRED> if
 *          the application should have known better.
 *
 *  @field  DWORD | celtBuf |
 *
 *          Size of the device buffer.
 *
 *  @field  DWORD | celtBufMax |
 *
 *          The largest buffer size we will permit.  There is
 *          a secret property that lets you increase the value,
 *          in case an ISV comes up with a good reason for having
 *          a larger buffer.
 *
 *  @field  LPDWORD | rgdwPOV |
 *
 *          An array of DWORDs listing the locations (data offsets)
 *          of all the optional POVs that were in the app's requested
 *          data format and which we were unable to satisfy.  We
 *          need this so we can set them to -1 in the device state
 *          because most apps are lazy and don't check if the object
 *          actually exists before reading from it.  To keep them safe,
 *          we normally return zeros in nonexistent objects, but for
 *          POVs, the "safe" value is -1, not zero.
 *
 *  @field  DWORD | cdwPOV |
 *
 *          Number of failed optional POVs in the <e CDIDev.rgdwPOV> array.
 *
#ifdef IDirectInputDevice2Vtbl
 *
 *  @field  LPDIRECTINPUTEFFECTSHEPHERD | pes |
 *
 *          The <i IDirectInputEffectShepherd>
 *          object which does the
 *          low-level goo related to the force feedback part of the device.
 *
 *  @field  SHEPHANDLE | sh |
 *
 *          The joystick "tag" which is used by dieshep.c
 *          to determine who owns the joystick.
 *          The <e SHEPHANDLE.dwEffect> field is permanently
 *          zero, so that we can pass it to
 *          <mf IDirectInputEffectShepherd::Escape>
 *          to perform a device escape.
 *
 *  @field  DWORD | dwVersion |
 *
 *          Version number of DirectInput we are emulating.
 *
 *  @field  GPA | gpaEff |
 *
 *          Pointer array of (held) <i IDirectInputEffect> objects
 *          that have been created for this device.
 *
 *  @field  PEFFECTMAPINFO | rgemi |
 *
 *          Array of <t EFFECTMAPINFO> structures, one for each
 *          effect supported by the device.
 *
 *  @field  UINT | cemi |
 *
 *          Number of elements in the <e CDIDev.rgemi> array.
 *
 *  @field  DWORD | didcFF |
 *
 *          Cached device capability flags related to force-feedback.
 *
 *  @field  DIFFDEVICEATTRIBUTES | ffattr |
 *
 *          Contains force feedback device attributes.
 *
 *  @field  DWORD | dwGain |
 *
 *          The gain setting for the device.
 *
 *  @field  DWORD | dwAutoCenter |
 *
 *          The autocenter setting for the device.
#endif
#if DIRECTINPUT_VERSION >= 0x04F0
 *
 *  @field  DWORD | didftInstance |
 *
 *          The instance mask to use for the client.  For
 *          DX 3.0 clients, the value is 0x0000FF00, whereas
 *          DX 5.0 clients have 0x00FFFF00.  The larger
 *          mask is to accomodate HID devices with huge numbers
 *          of controls.
 *
 *
#endif
 *
 *  @field  BOOL | fNotifiedNotBuffered:1 |
 *
 *          Used only in XDEBUG to remember whether we
 *          notified the caller that the device isn't buffered.
 *
 *  @field  LONG | cCrit |
 *
 *          Number of times the critical section has been taken.
 *          Used only in XDEBUG to check whether the caller is
 *          releasing the object while another method is using it.
 *
 *  @field  DWORD | thidCrit |
 *
 *          The thread that is currently in the critical section.
 *          Used only in DEBUG for internal consistency checking.
 *
 *  @field  CRITICAL_SECTION | crst |
 *
 *          Object critical section.  Must be taken when accessing
 *          volatile member variables.
 *
 *  @field  GUID | guid |
 *
 *          The instance GUID of the device we are.
 *
 *****************************************************************************/

typedef struct DIXLAT
{
    DWORD   dwOfs;
} DIXLAT, *PDIXLAT;

typedef struct CDIDev
{

    /* Supported interfaces */
    TFORM(IDirectInputDevice) TFORM(dd);
    SFORM(IDirectInputDevice) SFORM(dd);
#ifdef IDirectInputDevice2Vtbl
    TFORM(IDirectInputDevice2) TFORM(dd2);
    SFORM(IDirectInputDevice2) SFORM(dd2);
#endif

    IDirectInputDeviceCallback *pdcb;

    BOOL fAcquired:1;
    BOOL fAcquiredInstance:1;
    BOOL fCritInited:1;
#if DIRECTINPUT_VERSION > 0x0300
    BOOL fCook:1;
    BOOL fPolledDataFormat:1;
    BOOL fOnceAcquired:1;
    BOOL fOnceForcedUnacquired:1;
  #ifdef WINNT  
    BOOL fUnacquiredWhenIconic:1;
  #endif
#endif

    /* WARNING!  EVERYTHING AFTER THIS LINE IS ZERO'd ON A RESET */

    HWND hwnd;
    DWORD discl;
#ifdef BUGGY_DX3_SP3
    int cInstCwp;
#endif
    HANDLE hNotify;

    STDMETHOD(GetState)(struct CDIDev *, PV);
    STDMETHOD(GetDeviceState)(struct CDIDev *, PV);
    PDIXLAT pdix;
    PINT rgiobj;
    DWORD dwDataSize;
#ifdef BUGGY_DX7_WINNT
    PDIXLAT pdix2;
    PINT rgiobj2;
    DWORD dwDataSize2;
#endif //BUGGY_DX7_WINNT
    
    DIDATAFORMAT df;
    DIOPT diopt;
    int ibDelta;
    int ibMin;
    DWORD cbMatch;
    PV pvBuffer;
    PV pvLastBuffer;

    PVXDINSTANCE pvi;
    PV pvData;
    DWORD cAxes;
    LPDWORD rgdwAxesOfs;
    HRESULT hresPolled;
    HRESULT hresNotAcquired;
    DWORD celtBuf;
    LPDWORD rgdwPOV;
    DWORD cdwPOV;

#ifdef IDirectInputDevice2Vtbl
    PEFFECTMAPINFO rgemi;
    UINT           cemi;
    DWORD          didcFF;
    SHEPHANDLE     sh;
    DIFFDEVICEATTRIBUTES  ffattr;
#endif

    /* WARNING!  EVERYTHING ABOVE THIS LINE IS ZERO'd ON A RESET */
    DWORD celtBufMax;           /* Must be first field after zero'd region */

#ifdef IDirectInputDevice2Vtbl
    LPDIRECTINPUTEFFECTSHEPHERD pes;
    DWORD dwVersion;
    GPA gpaEff;
    DWORD dwGain;
    DWORD dwAutoCenter;
#endif

#if DIRECTINPUT_VERSION >= 0x04F0
    DWORD   didftInstance;
#endif

    RD(BOOL fNotifiedNotBuffered:1;)
    long cCrit;
    DWORD thidCrit;
    CRITICAL_SECTION crst;

    GUID guid;                  /* This is also zero'd on a reset */

#if (DIRECTINPUT_VERSION > 0x061A)
    DIAPPHACKS  diHacks;
#endif

} CDIDev, DD, *PDD;


typedef IDirectInputDeviceA DDA, *PDDA;
typedef IDirectInputDeviceW DDW, *PDDW;
typedef DIDEVICEOBJECTDATA DOD, *PDOD;
typedef LPCDIDEVICEOBJECTDATA PCDOD;

/*****************************************************************************
 *
 *  Methods that live outside didev.c
 *
 *****************************************************************************/
#ifdef BUGGY_DX7_WINNT
    HRESULT CDIDev_ParseDataFormatInternal(PDD this, const DIDATAFORMAT *lpdf);
#endif //BUGGY_DX7_WINNT

/*****************************************************************************
 *
 *  IDirectInputDevice::SetDataFormat
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SetDataFormat(PV pdd, LPCDIDATAFORMAT lpdf _THAT);

#ifdef INCLUDED_BY_DIDEV
    #ifdef XDEBUG

CSET_STUBS(SetDataFormat, (PV pdd, LPCDIDATAFORMAT lpdf), (pdd, lpdf THAT_))

    #else

        #define CDIDev_SetDataFormatA           CDIDev_SetDataFormat
        #define CDIDev_SetDataFormatW           CDIDev_SetDataFormat

    #endif
#endif

/*****************************************************************************
 *
 *  IDirectInputDevice::GetDeviceState
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetDeviceState(PV pdd, DWORD cbDataSize, LPVOID pvData _THAT);

#ifdef INCLUDED_BY_DIDEV
    #ifdef XDEBUG

CSET_STUBS(GetDeviceState, (PV pdd, DWORD cbDataSize, LPVOID pvData),
           (pdd, cbDataSize, pvData THAT_))

    #else

        #define CDIDev_GetDeviceStateA          CDIDev_GetDeviceState
        #define CDIDev_GetDeviceStateW          CDIDev_GetDeviceState

    #endif
#endif

/*****************************************************************************
 *
 *  IDirectInputDevice::GetDeviceData
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetDeviceData(PV pdd, DWORD cbdod, PDOD rgdod,
                         LPDWORD pdwInOut, DWORD fl _THAT);

#ifdef INCLUDED_BY_DIDEV
    #ifdef XDEBUG

CSET_STUBS(GetDeviceData,
           (PV pdd, DWORD cbdod, PDOD rgdod, LPDWORD pdwInOut, DWORD fl),
           (pdd, cbdod, rgdod, pdwInOut, fl THAT_))

    #else

        #define CDIDev_GetDeviceDataA           CDIDev_GetDeviceData
        #define CDIDev_GetDeviceDataW           CDIDev_GetDeviceData

    #endif
#endif

#ifdef IDirectInputDevice2Vtbl

/*****************************************************************************
 *
 *  IDirectInputDevice2::CreateEffect
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_CreateEffect(PV pdd, REFGUID rguid, LPCDIEFFECT peff,
                        LPDIRECTINPUTEFFECT *ppdeff, LPUNKNOWN punkOuter _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(CreateEffect, (PV pdd, REFGUID rguid, LPCDIEFFECT peff,
                          LPDIRECTINPUTEFFECT *ppdeff, LPUNKNOWN punkOuter),
           (pdd, rguid, peff, ppdeff, punkOuter THAT_))

        #else

            #define CDIDev_CreateEffectA            CDIDev_CreateEffect
            #define CDIDev_CreateEffectW            CDIDev_CreateEffect

        #endif
    #endif

/*****************************************************************************
 *
 *  IDirectInputDevice2::EnumEffects
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_EnumEffectsW(PV pdd, LPDIENUMEFFECTSCALLBACKW pecW, PV pvRef, DWORD fl);

STDMETHODIMP
    CDIDev_EnumEffectsA(PV pdd, LPDIENUMEFFECTSCALLBACKA pecA, PV pvRef, DWORD fl);

/*****************************************************************************
 *
 *  IDirectInputDevice2::GetEffectInfo
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetEffectInfoW(PV pddW, LPDIEFFECTINFOW peiW, REFGUID rguid);

STDMETHODIMP
    CDIDev_GetEffectInfoA(PV pddA, LPDIEFFECTINFOA peiA, REFGUID rguid);

/*****************************************************************************
 *
 *  IDirectInputDevice2::GetForceFeedbackState
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_GetForceFeedbackState(PV pdd, LPDWORD pdwOut _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(GetForceFeedbackState, (PV pdd, LPDWORD pdwOut),
           (pdd, pdwOut THAT_))

        #else

            #define CDIDev_GetForceFeedbackStateA   CDIDev_GetForceFeedbackState
            #define CDIDev_GetForceFeedbackStateW   CDIDev_GetForceFeedbackState

        #endif
    #endif

/*****************************************************************************
 *
 *  IDirectInputDevice2::SendForceFeedbackCommand
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SendForceFeedbackCommand(PV pdd, DWORD dwCmd _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(SendForceFeedbackCommand, (PV pdd, DWORD dwCmd),
           (pdd, dwCmd THAT_))

        #else

            #define CDIDev_SendForceFeedbackCommandA    CDIDev_SendForceFeedbackCommand
            #define CDIDev_SendForceFeedbackCommandW    CDIDev_SendForceFeedbackCommand

        #endif
    #endif

/*****************************************************************************
 *
 *  IDirectInputDevice2::EnumCreatedEffects
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_EnumCreatedEffectObjects(PV pdd,
                                    LPDIENUMCREATEDEFFECTOBJECTSCALLBACK pec,
                                    LPVOID pvRef, DWORD dwFlags _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(EnumCreatedEffectObjects, (PV pdd,
                                      LPDIENUMCREATEDEFFECTOBJECTSCALLBACK pec,
                                      LPVOID pvRef, DWORD dwFlags),
           (pdd, pec, pvRef, dwFlags THAT_))

        #else

            #define CDIDev_EnumCreatedEffectObjectsA CDIDev_EnumCreatedEffectObjects
            #define CDIDev_EnumCreatedEffectObjectsW CDIDev_EnumCreatedEffectObjects

        #endif
    #endif

/*****************************************************************************
 *
 *  IDirectInputDevice2::Escape
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_Escape(PV pdd, LPDIEFFESCAPE pesc _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(Escape, (PV pdd, LPDIEFFESCAPE pesc), (pdd, pesc THAT_))

        #else

            #define CDIDev_EscapeA                  CDIDev_Escape
            #define CDIDev_EscapeW                  CDIDev_Escape

        #endif
    #endif

/*****************************************************************************
 *
 *  IDirectInputDevice2::Poll
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_Poll(PV pdd _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(Poll, (PV pdd), (pdd THAT_))

        #else

            #define CDIDev_PollA                    CDIDev_Poll
            #define CDIDev_PollW                    CDIDev_Poll

        #endif
    #endif

/*****************************************************************************
 *
 *  IDirectInputDevice2::SendDeviceData
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDev_SendDeviceData(PV pdd, DWORD cbdod, PCDOD rgdod,
                          LPDWORD pdwInOut, DWORD fl _THAT);

    #ifdef INCLUDED_BY_DIDEV
        #ifdef XDEBUG

CSET_STUBS(SendDeviceData,
           (PV pdd, DWORD cbdod, PCDOD rgdod, LPDWORD pdwInOut, DWORD fl),
           (pdd, cbdod, rgdod, pdwInOut, fl THAT_))

        #else

            #define CDIDev_SendDeviceDataA          CDIDev_SendDeviceData
            #define CDIDev_SendDeviceDataW          CDIDev_SendDeviceData

        #endif
    #endif

#endif /* IDirectInputDevice2Vtbl */

/*****************************************************************************
 *
 *      More internal worker functions.
 *
 *      IsConsists is used for assertion checking.
 *
 *      Finalize calls Unacquire to clean up in the case where the
 *      caller forgot.
 *
 *      Similarly, Reset needs to reset the GetDeviceState pointer.
 *
 *      SetDataFormat needs to set the axis mode property.
 *
 *      CDIDev_InitFF is used by CDIDev_Initialize to initialize
 *      the force-feedback portion of the device.
 *
 *****************************************************************************/

#ifdef DEBUG
BOOL INTERNAL CDIDev_IsConsistent(PDD this);
#endif

STDMETHODIMP CDIDev_InternalUnacquire(PV pdd);

STDMETHODIMP CDIDev_GetAbsDeviceState(PDD this, LPVOID pvData);
STDMETHODIMP CDIDev_GetRelDeviceState(PDD this, LPVOID pvData);

STDMETHODIMP
    CDIDev_RealSetProperty(PDD this, REFGUID rguid, LPCDIPROPHEADER pdiph);

#ifdef IDirectInputDevice2Vtbl
STDMETHODIMP CDIDev_FFAcquire(PDD this);
STDMETHODIMP CDIDev_InitFF(PDD this);
STDMETHODIMP CDIDev_GetLoad(PDD this, LPDWORD pdw);
STDMETHODIMP CDIDev_RefreshGain(PDD this);
HRESULT INTERNAL CDIDev_CreateEffectDriver(PDD this);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\didevdf.c ===
/*****************************************************************************
 *
 *  DIDevDf.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The part of IDirectInputDevice that worries about
 *      data formats and reading device data.
 *
 *****************************************************************************/

#include "dinputpr.h"
#include "didev.h"

int INTERNAL
CDIDev_OffsetToIobj(PDD this, DWORD dwOfs);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_GetAbsDeviceState |
 *
 *          Get the absolute device state.
 *
 *  @parm   OUT LPVOID | pvData |
 *
 *          Application-provided output buffer.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetAbsDeviceState(PDD this, LPVOID pvData)
{
    return this->pdcb->lpVtbl->GetDeviceState(this->pdcb, pvData);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_GetRelDeviceState |
 *
 *          Get the relative device state.
 *
 *  @parm   OUT LPVOID | pvData |
 *
 *          Application-provided output buffer.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetRelDeviceState(PDD this, LPVOID pvData)
{
    HRESULT hres;

    hres = this->pdcb->lpVtbl->GetDeviceState(this->pdcb, pvData);
    if ( SUCCEEDED(hres) ) {
        UINT iaxis;
        AssertF(fLimpFF(this->cAxes, this->pvLastBuffer && this->rgdwAxesOfs));

        /*
         *  For each axis, replace the app's buffer with the delta,
         *  and save the old value.
         */
        for ( iaxis = 0; iaxis < this->cAxes; iaxis++ ) {
            LONG UNALIGNED *plApp  = pvAddPvCb(pvData, this->rgdwAxesOfs[iaxis]);
            LONG UNALIGNED *plLast = pvAddPvCb(this->pvLastBuffer,
                                      this->rgdwAxesOfs[iaxis]);
            LONG lNew = *plApp;
            *plApp -= *plLast;
            *plLast = lNew;
        }

        hres = S_OK;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_GetDeviceStateSlow |
 *
 *          Obtains data from the DirectInput device the slow way.
 *
 *          Read the data into the private buffer, then copy it
 *          bit by bit into the application's buffer.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Application-provided output buffer.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetDeviceStateSlow(PDD this, LPVOID pvData)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::GetDeviceStateSlow, (_ "pp", this, pvData));

    AssertF(this->diopt == dioptNone);
    AssertF(this->pvBuffer);
    AssertF(this->pdcb);
    hres = this->GetDeviceState(this, this->pvBuffer);
    if ( SUCCEEDED(hres) ) {
        int iobj;
        ZeroMemory(pvData, this->dwDataSize);
        for ( iobj = this->df.dwNumObjs; --iobj >= 0; ) {
            if ( this->pdix[iobj].dwOfs != 0xFFFFFFFF ) { /* Data was requested */
                DWORD UNALIGNED *pdwOut = pvAddPvCb(pvData, this->pdix[iobj].dwOfs);
                DWORD UNALIGNED *pdwIn  = pvAddPvCb(this->pvBuffer, this->df.rgodf[iobj].dwOfs);
                if ( this->df.rgodf[iobj].dwType & DIDFT_DWORDOBJS ) {
                    *pdwOut = *pdwIn;
                } else {
                    *(LPBYTE)pdwOut = *(LPBYTE)pdwIn;
                }
            }
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_GetDeviceStateMatched |
 *
 *          Obtains data from the DirectInput device in the case
 *          where the data formats are matched.
 *
 *          Read the data into the private buffer, then block copy it
 *          into the application's buffer.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Application-provided output buffer.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetDeviceStateMatched(PDD this, LPVOID pvData)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::GetDeviceStateMatched, (_ "pp", this, pvData));

    AssertF(this->diopt == dioptMatch);
    AssertF(this->pvBuffer);
    AssertF(this->pdcb);
    hres = this->GetDeviceState(this, this->pvBuffer);

    if ( SUCCEEDED(hres) ) {
        /*
         *  To keep keyboard clients happy: Zero out the fore and aft.
         *  No need to optimize the perfect match case, because that
         *  gets a different optimization level.
         */
        ZeroMemory(pvData, this->dwDataSize);
        memcpy(pvAddPvCb(pvData, this->ibDelta + this->ibMin),
               pvAddPvCb(this->pvBuffer,         this->ibMin), this->cbMatch);
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_GetDeviceStateDirect |
 *
 *          Obtains data from the DirectInput device in the case
 *          where we can read the data directly into the client buffer.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Application-provided output buffer.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetDeviceStateDirect(PDD this, LPVOID pvData)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::GetDeviceStateDirect, (_ "pp", this, pvData));

    AssertF(this->diopt == dioptDirect);
    AssertF(!this->pvBuffer);
    AssertF(this->pdcb);

    /*
     *  To keep keyboard clients happy: Zero out the fore and aft.
     */
    ZeroBuf(pvData, this->dwDataSize);
    hres = this->GetDeviceState(this, pvAddPvCb(pvData, this->ibDelta));
    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDev_GetDeviceStateEqual |
 *
 *          Obtains data from the DirectInput device in the case
 *          where the two data formats are completely identical.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Application-provided output buffer.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetDeviceStateEqual(PDD this, LPVOID pvData)
{
    HRESULT hres;
    EnterProcR(IEqualInputDevice::GetDeviceStateEqual, (_ "pp", this, pvData));

    AssertF(this->diopt == dioptEqual);
    AssertF(this->ibDelta == 0);
    AssertF(this->dwDataSize == this->df.dwDataSize);
    AssertF(!this->pvBuffer);
    AssertF(this->pdcb);

    /*
     *  Note that this->ibMin is not necessarily zero if the device
     *  data format doesn't begin at zero (which keyboards don't).
     */
    hres = this->GetDeviceState(this, pvData);

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | CDIDev | IsMatchingGUID |
 *
 *          Helper function that checks if a <t GUID> counts as
 *          a match when parsing the data format.
 *
 *  @parm   PCGUID | pguidSrc |
 *
 *          The <t GUID> to check.
 *
 *  @parm   PCGUID | pguidDst |
 *
 *          The <t GUID> it should match.
 *
 *  @returns
 *
 *          Nonzero if this counts as a success.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

GUID GUID_Null;             /* A zero-filled guid */

#pragma END_CONST_DATA

BOOL INLINE
CDIDev_IsMatchingGUID(PDD this, PCGUID pguidSrc, PCGUID pguidDst)
{
    return IsEqualGUID(pguidSrc, &GUID_Null) ||
    IsEqualGUID(pguidSrc, pguidDst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | CDIDev | IsMatchingUsage |
 *
 *          Helper function that checks if a <f DIMAKEUSAGEDWORD>
 *          counts as a match when parsing the data format.
 *
 *  @parm   DWORD | dwUsage |
 *
 *          The <f DIMAKEUSAGEDWORD> to check.
 *
 *  @parm   int | iobj |
 *
 *          The index of hte object to check for a match.
 *
 *  @returns
 *
 *          Nonzero if this counts as a success.
 *
 *****************************************************************************/

BOOL INLINE
CDIDev_IsMatchingUsage(PDD this, DWORD dwUsage, int iobj)
{
    AssertF(this->pdcb);

    return dwUsage == this->pdcb->lpVtbl->GetUsage(this->pdcb, iobj);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CDIDev | FindDeviceObjectFormat |
 *
 *          Search the device object format table for the one that
 *          matches the guid in question.
 *
 *  @parm   PCODF | podf |
 *
 *          The object to locate.  If the <e DIOBJECTDATAFORMAT.rguid>
 *          is null, then the field is a wildcard.
 *
 *          If the <e DIOBJECTDATAFORMAT.dwType> specifies
 *          <c DIDFT_ANYINSTANCE>, then any instance will be accepted.
 *
 *  @parm   PDIXLAT | pdix |
 *
 *          The partial translation table so far.  This is used to find
 *          an empty slot in case of wildcards.
 *
 *  @returns
 *
 *          Returns the index of the object that matches, or -1 if
 *          the object is not supported by the device.
 *
 *          Someday:  Should fall back to best match if types don't match.
 *
 *****************************************************************************/

int INTERNAL
CDIDev_FindDeviceObjectFormat(PDD this, PCODF podf, PDIXLAT pdix)
{
    PCODF podfD;                        /* The format in the device */
    UINT iobj;

    /*
     *  We must count upwards, so that first-fit chooses the smallest one.
     */
    for ( iobj = 0; iobj < this->df.dwNumObjs; iobj++ ) {
        podfD = &this->df.rgodf[iobj];
        if ( 

           /*
            *  Type needs to match.
            *
            *  Note that works for output-only actuators:
            *  Since you cannot read from an output-only
            *  actuator, you can't put it in a data format.
            *
            */
           (podf->dwType & DIDFT_TYPEVALID & podfD->dwType)

           /*
            *  Attributes need to match.
            */
           &&  fHasAllBitsFlFl(podfD->dwType, podf->dwType & DIDFT_ATTRVALID)

           /*
            *  Slot needs to be empty.
            */
           &&  pdix[iobj].dwOfs == 0xFFFFFFFF

           /*
            *  "If there is a guid/usage, it must match."
            *
            *  If pguid is NULL, then the match is vacuous.
            *
            *  If DIDOI_GUIDISUSAGE is clear, then pguid points to
            *  a real GUID.  GUID_NULL means "Don't care" and matches
            *  anything.  Otherwise, it must match the actual GUID.
            *
            *  If DIDOI_GUIDISUSAGE is set, then pguid is really
            *  a DIMAKEUSAGEDWORD of the usage and usage page,
            *  which we compare against the same in the object.
            */

           &&  (podf->pguid == 0 ||
                ((podf->dwFlags & DIDOI_GUIDISUSAGE) ?
                 CDIDev_IsMatchingUsage(this, (DWORD)(UINT_PTR)podf->pguid, iobj) :
                 CDIDev_IsMatchingGUID(this, podf->pguid, podfD->pguid)))

           /*
            * If there is an instance number, it must match.
            *
            *  Note that we need to be careful how we check, because
            *  DX 3.0 and DX 5.0 uses different masks.  (DX 5.0 needs
            *  16 bits of instance data to accomodate HID devices.)
            */
           &&  fLimpFF((podf->dwType & this->didftInstance) !=
                       this->didftInstance,
                       fEqualMaskFlFl(this->didftInstance,
                                      podf->dwType, podfD->dwType))

           /*
            *  If there is an aspect, it must match.
            *
            *  If the device data format doesn't specify an aspect,
            *  then that counts as a free match too.
            */
           &&  fLimpFF((podf->dwFlags & DIDOI_ASPECTMASK) &&
                       (podfD->dwFlags & DIDOI_ASPECTMASK),
                       fEqualMaskFlFl(DIDOI_ASPECTMASK,
                                      podf->dwFlags, podfD->dwFlags))

           ) {                                 /* Criterion matches, woo-hoo */
            return iobj;
        }
    }
    return -1;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | ParseDataFormat |
 *
 *          Parse the data format passed by the application and
 *          convert it into a format that we can use to translate
 *          the device data into application data.
 *
 *  @parm   IN LPDIDATAFORMAT | lpdf |
 *
 *          Points to a structure that describes the format of the data
 *          the DirectInputDevice should return.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpvData> parameter is not a valid pointer.
 *
 *          <c DIERR_ACQUIRED>: Cannot change the data format while the
 *          device is acquired.
 *
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_ParseDataFormat(PDD this, const DIDATAFORMAT *lpdf)
{
    PDIXLAT pdix;
    // Prefix Whistler: 45081
    PINT rgiobj = NULL;
    HRESULT hres;
    DIPROPDWORD dipdw;    
    VXDDATAFORMAT vdf;
    DWORD dwDataSize;
#ifdef DEBUG
    EnterProc(CDIDev_ParseDataFormat, (_ "pp", this, lpdf));
#else
    EnterProcR(IDirectInputDevice::SetDataFormat, (_ "pp", this, lpdf));
#endif

    /*
     *  Caller should've nuked the old translation table.
     */
    AssertF(this->pdix == 0);
    AssertF(this->rgiobj == 0);
    AssertF(this->cdwPOV == 0);

    vdf.cbData = this->df.dwDataSize;
    vdf.pDfOfs = 0;

    /*
     *  If the device is cooked, then we stash the client offset
     *  into the high word of the VxD data, so it had better fit into
     *  a word...
     */
    dwDataSize = min(lpdf->dwDataSize, 0x00010000);

    if ( SUCCEEDED(hres = AllocCbPpv(cbCxX(this->df.dwNumObjs, DIXLAT), &pdix)) &&
         SUCCEEDED(hres = AllocCbPpv(cbCdw(this->df.dwDataSize), &vdf.pDfOfs)) &&
         SUCCEEDED(hres = AllocCbPpv(cbCdw(lpdf->dwDataSize), &rgiobj)) &&
         SUCCEEDED(hres =
                   ReallocCbPpv(cbCdw(lpdf->dwNumObjs), &this->rgdwPOV)) ) {
        UINT iobj;

        /*
         * Pre-init all the translation tags to -1,
         * which means "not in use"
         */
        memset(pdix, 0xFF, cbCxX(this->df.dwNumObjs, DIXLAT));
        memset(vdf.pDfOfs, 0xFF, cbCdw(this->df.dwDataSize));
        memset(rgiobj, 0xFF, cbCdw(lpdf->dwDataSize));

        SquirtSqflPtszV(sqflDf, TEXT("Begin parse data format"));

        for ( iobj = 0; iobj < lpdf->dwNumObjs; iobj++ ) {
            PCODF podf = &lpdf->rgodf[iobj];
            SquirtSqflPtszV(sqflDf, TEXT("Object %2d: offset %08x"),
                            iobj, podf->dwOfs);

            /*
             *  Note that the podf->dwOfs < dwDataSize test is safe
             *  even for DWORD objects, since we also check that both
             *  values are DWORD multiples.
             */
            if ( ((podf->dwFlags & DIDOI_GUIDISUSAGE) ||
                  fLimpFF(podf->pguid,
                          SUCCEEDED(hres = hresFullValidGuid(podf->pguid, 1)))) &&
                 podf->dwOfs < dwDataSize ) {
                int iobjDev = CDIDev_FindDeviceObjectFormat(this, podf, pdix);


                /* Hack for pre DX6 apps that only look for a Z axis, 
                 * newer USB devices use GUID_Slider for the same functionality. 
                 * 
                 */
                if ( podf->pguid != 0x0                   // Looking for matching GUID
                     && this->dwVersion < 0x600              // Only for Dx version < 0x600
                     && iobjDev == -1                        // Did not find default mapping
                     && IsEqualGUID(podf->pguid, &GUID_ZAxis) ) // Looking for GUID_ZAxis
                {
                    ODF odf = lpdf->rgodf[iobj];         // Make a copy of the object data format
                    odf.pguid = &GUID_Slider;            // Substitute Slider for Z axis
                    iobjDev = CDIDev_FindDeviceObjectFormat(this, &odf, pdix);
                }

                if ( iobjDev != -1 ) {
                    PCODF podfFound = &this->df.rgodf[iobjDev];
                    if ( podfFound->dwType & DIDFT_DWORDOBJS ) {
                        if ( (podf->dwOfs & 3) == 0 ) {
                        } else {
                            RPF("%s: Dword objects must be aligned", s_szProc);
                            goto fail;
                        }
                    }

                    if ( this->fCook ) {
                        vdf.pDfOfs[podfFound->dwOfs] =
                        (DWORD)DICOOK_DFOFSFROMOFSID(podf->dwOfs,
                                                     podfFound->dwType);
                    } else {
                        vdf.pDfOfs[podfFound->dwOfs] = podf->dwOfs;
                    }

                    pdix[iobjDev].dwOfs = podf->dwOfs;
                    rgiobj[podf->dwOfs] = iobjDev;

                    if ( podfFound->dwFlags & DIDOI_POLLED ) {
                        this->fPolledDataFormat = TRUE;
                    }
                    
                    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
                    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
                    dipdw.diph.dwObj = podfFound->dwType;
                    dipdw.diph.dwHow = DIPH_BYID;
                    dipdw.dwData     = 0x1;   // Enable this report ID
                    hres = CDIDev_RealSetProperty(this, DIPROP_ENABLEREPORTID, &dipdw.diph);
                    if ( hres == E_NOTIMPL ) 
                    {
                        SquirtSqflPtszV(sqflDf,
                                        TEXT("Could not set DIPROP_ENABLEREPORTID for offset %d"),
                                        iobj);
                        hres = S_OK;
                    }
                
                } else if ( podf->dwType & DIDFT_OPTIONAL ) {
                    SquirtSqflPtszV(sqflDf,
                                    TEXT("Object %2d: Skipped (optional)"),
                                    iobj);
                    /*
                     *  We need to remember where the failed POVs live
                     *  so we can neutralize them in GetDeviceState().
                     */
                    if ( podf->dwType & DIDFT_POV ) {
                        AssertF(this->cdwPOV < lpdf->dwNumObjs);
                        this->rgdwPOV[this->cdwPOV++] = podf->dwOfs;
                    }
                } else {
                    RPF("%s: Format not compatible with device", s_szProc);
                    goto fail;
                }
            } else {
                if ( podf->dwOfs >= lpdf->dwDataSize ) {
                    RPF("%s: Offset out of range in data format", s_szProc);
                } else if ( podf->dwOfs >= dwDataSize ) {
                    RPF("%s: Data format cannot exceed 64K", s_szProc);
                }
                fail:;
                hres = E_INVALIDARG;
                goto done;
            }
        }

#ifdef DEBUG
        /*
         *  Double-check the lookup tables just to preserve our sanity.
         */
        {
            UINT dwOfs;

            for ( dwOfs = 0; dwOfs < lpdf->dwDataSize; dwOfs++ ) {
                if ( rgiobj[dwOfs] >= 0 ) {
                    AssertF(pdix[rgiobj[dwOfs]].dwOfs == dwOfs);
                } else {
                    AssertF(rgiobj[dwOfs] == -1);
                }
            }
        }
#endif

        /*
         *  Shrink the "failed POV" array to its actual size.
         *  The shrink "should" always succeed.  Note also that
         *  even if it fails, we're okay; we just waste a little
         *  memory.
         */
        hres = ReallocCbPpv(cbCdw(this->cdwPOV), &this->rgdwPOV);
        AssertF(SUCCEEDED(hres));

        /*
         *  If we are using cooked data, then we actually hand the
         *  device driver a different translation table which
         *  combines the offset and dwDevType so data cooking can
         *  happen safely.
         */

        vdf.pvi = this->pvi;

        if ( fLimpFF(this->pvi,
                     SUCCEEDED(hres = Hel_SetDataFormat(&vdf))) ) {
            this->pdix = pdix;
            pdix = 0;
            this->rgiobj = rgiobj;
            rgiobj = 0;
            this->dwDataSize = lpdf->dwDataSize;
            hres = S_OK;
        } else {
            AssertF(FAILED(hres));
        }

    } else {
        /* Out of memory */
    }

    done:;
    FreePpv(&pdix);
    FreePpv(&rgiobj);
    FreePpv(&vdf.pDfOfs);

    ExitOleProc();
    return hres;
}

#ifdef BUGGY_DX7_WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | ParseDataFormatInternal |
 *
 *          Parse the data format passed by CDIDev_Intialize and
 *          convert it into a format that we can use to translate
 *          the device data into application data. Used on WINNT only.
 *
 *  @parm   IN LPDIDATAFORMAT | lpdf |
 *
 *          Points to a structure that describes the format of the data
 *          the DirectInputDevice should return.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpvData> parameter is not a valid pointer.
 *
 *          <c DIERR_ACQUIRED>: Cannot change the data format while the
 *          device is acquired.
 *
 *  @devnotes:
 *          This function is originaly wrote to fix manbug: 41464. 
 *          Boarder Zone gets object's data offset before it calls SetDataFormat,
 *          so Dinput returns it internal data offsets. But it uses them as user data
 *          offset, which causes the bug.
 *          To fix it, we call this function in CDIDev_Initialize with c_dfDIJoystick,
 *          which is used by many games. When an application ask for object info,
 *          we check if an user data format has been set, if not, we will assume user
 *          uses c_dfDIJoystick, hence return the data offset based on it.
 *          This function will only be called if application uses dinput (version < 0x700)
 *          && (version != 0x5B2).
 *
 *****************************************************************************/

HRESULT CDIDev_ParseDataFormatInternal(PDD this, const DIDATAFORMAT *lpdf)
{
    PDIXLAT pdix;
    PINT rgiobj = NULL;
    HRESULT hres;
#ifdef DEBUG
    EnterProc(CDIDev_ParseDataFormat2, (_ "pp", this, lpdf));
#endif

    AssertF(this->pdix2 == 0);

    if( SUCCEEDED(hres = AllocCbPpv(cbCxX(this->df.dwNumObjs, DIXLAT), &pdix)) &&
        SUCCEEDED(hres = AllocCbPpv(cbCdw(lpdf->dwDataSize), &rgiobj)))
    {
        UINT iobj;

        /*
         * Pre-init all the translation tags to -1,
         * which means "not in use"
         */
        memset(pdix, 0xFF, cbCxX(this->df.dwNumObjs, DIXLAT));
        memset(rgiobj, 0xFF, cbCdw(lpdf->dwDataSize));

        for ( iobj = 0; iobj < lpdf->dwNumObjs; iobj++ ) {
            PCODF podf = &lpdf->rgodf[iobj];
            SquirtSqflPtszV(sqflDf | sqflVerbose, TEXT("Object %2d: offset %08x"),
                            iobj, podf->dwOfs);

            /*
             *  Note that the podf->dwOfs < lpdf->dwDataSize test is safe
             *  even for DWORD objects, since we also check that both
             *  values are DWORD multiples.
             */
            if ( ((podf->dwFlags & DIDOI_GUIDISUSAGE) ||
                  fLimpFF(podf->pguid,
                          SUCCEEDED(hres = hresFullValidGuid(podf->pguid, 1)))) &&
                 podf->dwOfs < lpdf->dwDataSize ) {
                int iobjDev = CDIDev_FindDeviceObjectFormat(this, podf, pdix);

                if ( iobjDev != -1 ) {
                    PCODF podfFound = &this->df.rgodf[iobjDev];
                    if ( podfFound->dwType & DIDFT_DWORDOBJS ) {
                        if ( (podf->dwOfs & 3) == 0 ) {
                        } else {
                            RPF("%s: Dword objects must be aligned", s_szProc);
                            goto fail;
                        }
                    }
                    
                    pdix[iobjDev].dwOfs = podf->dwOfs;
                    rgiobj[podf->dwOfs] = iobjDev;
                } else if ( podf->dwType & DIDFT_OPTIONAL ) {
                    //do nothing
                } else {
                    RPF("%s: Format not compatible with device", s_szProc);
                    goto fail;
                }
            } else {
                if ( podf->dwOfs >= lpdf->dwDataSize ) {
                    RPF("%s: rgodf[%d].dwOfs of 0x%08x out of range in data format", 
                        s_szProc, iobj, podf->dwOfs );
                }
                fail:;
                hres = E_INVALIDARG;
                goto done;
            }
        }
        
#ifdef DEBUG
        /*
         *  Double-check the lookup tables just to preserve our sanity.
         */
        {
            UINT dwOfs;

            for ( dwOfs = 0; dwOfs < lpdf->dwDataSize; dwOfs++ ) {
                if ( rgiobj[dwOfs] >= 0 ) {
                    AssertF(pdix[rgiobj[dwOfs]].dwOfs == dwOfs);
                } else {
                    AssertF(rgiobj[dwOfs] == -1);
                }
            }
        }
#endif

        this->pdix2 = pdix;
        pdix = 0;
        this->rgiobj2 = rgiobj;
        rgiobj = 0;
        this->dwDataSize2 = lpdf->dwDataSize;

        hres = S_OK;
    } else {
        /* Out of memory */
        hres = ERROR_NOT_ENOUGH_MEMORY;
    }

    done:;
    FreePpv(&pdix);
    FreePpv(&rgiobj);

    ExitOleProc();
    return hres;
}
#endif //BUGGY_DX7_WINNT

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | OptimizeDataFormat |
 *
 *          Study the parsed data format to determine whether we can
 *          used an optimized <mf CDIDev::GetDeviceState> to obtain
 *          the data more quickly.
 *
 *          The data format is considered optimized if it matches the
 *          device data format, modulo possible shifting due to insertion
 *          of bonus fields at the beginning or end, and modulo missing
 *          fields.
 *
 *          The data format is considered fully-optimized if it
 *          optimized, and no shifting is necessary, and the structure size
 *          is exactly the same.  This means the buffer can be passed
 *          straight through to the driver.
 *
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIDev_OptimizeDataFormat(PDD this)
{
    int ib;
    DWORD ibMax;                        /* One past highest match point */
    DWORD ibMin;                        /* Lowest match point */
    int iobj;
    DWORD dwDataSize;
    HRESULT hres;
    EnterProc(CDIDev_OptimizeDataFormat, (_ "p", this));

    ib = -1;                            /* Not yet known */
    ibMin = 0xFFFFFFFF;
    ibMax = 0;

    /*
     *  ISSUE-2001/03/29-timgill Need to change data sentinel value
     *  -1 is not a valid sentinel; we might validly
     *  get data at an offset of -1.
     */

    for ( iobj = this->df.dwNumObjs; --iobj >= 0; ) {
        DWORD ibMaxThis;
        if ( this->pdix[iobj].dwOfs != 0xFFFFFFFF ) { /* Data was requested */

            int ibExpected = (int)(this->pdix[iobj].dwOfs -
                                   this->df.rgodf[iobj].dwOfs);
            if ( fLimpFF(ib != -1, ib == ibExpected) ) {
                ib  = ibExpected;
            } else {
                SquirtSqflPtszV(sqfl | sqflMajor,
                    TEXT("IDirectInputDevice: Optimization level 0, translation needed") );
                this->diopt = dioptNone;
                this->GetState = CDIDev_GetDeviceStateSlow;
                goto done;
            }
            if ( ibMin > this->df.rgodf[iobj].dwOfs ) {
                ibMin = this->df.rgodf[iobj].dwOfs;
            }
            if ( this->df.rgodf[iobj].dwType & DIDFT_DWORDOBJS ) {
                ibMaxThis = this->df.rgodf[iobj].dwOfs + sizeof(DWORD);
            } else {
                ibMaxThis = this->df.rgodf[iobj].dwOfs + sizeof(BYTE);
            }
            if ( ibMax < ibMaxThis ) {
                ibMax = ibMaxThis;
            }
        }
    }

    /*
     *  Make sure we actually found something.
     */
    if ( ib != -1 ) {                     /* Data format is matched */
        AssertF(ibMin < ibMax);
        AssertF( ib + (int)ibMin >= 0);
        AssertF(ib + ibMax <= this->dwDataSize);
        this->ibDelta = ib;
        this->ibMin = ibMin;
        this->cbMatch = ibMax - ibMin;
        if ( ib >= 0 && ib + this->df.dwDataSize <= this->dwDataSize ) {
            /* We can go direct */
            if ( ib == 0 && this->dwDataSize == this->df.dwDataSize ) {
                /* Data formats are equal! */
                this->diopt = dioptEqual;
                this->GetState = CDIDev_GetDeviceStateEqual;
                SquirtSqflPtszV(sqfl | sqflMajor,
                    TEXT("IDirectInputDevice: Optimization level 3, full speed ahead!") );
            } else {
                this->diopt = dioptDirect;
                this->GetState = CDIDev_GetDeviceStateDirect;
                SquirtSqflPtszV(sqfl | sqflMajor,
                    TEXT("IDirectInputDevice: Optimization level 2, direct access") );
            }
        } else {
            SquirtSqflPtszV(sqfl | sqflMajor,
                TEXT("IDirectInputDevice: Optimization level 1, okay") );
            this->diopt = dioptMatch;
            this->GetState = CDIDev_GetDeviceStateMatched;
        }

    } else {                            /* No data in data format! */
        RPF("IDirectInputDevice: Null data format; if that's what you want...");
        this->diopt = dioptNone;
        this->GetState = CDIDev_GetDeviceStateSlow;
    }

    done:;
    if ( this->diopt >= dioptDirect ) {   /* Can go direct; don't need buf */
        dwDataSize = 0;
    } else {
        dwDataSize = this->df.dwDataSize;
    }

    hres = ReallocCbPpv(dwDataSize, &this->pvBuffer);

    if ( SUCCEEDED(hres) ) {
        AssertF(this->GetState);
    } else {
        FreePpv(&this->pdix);
        D(this->GetState = 0);
    }

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | SetDataFormat |
 *
 *          Set the data format for the DirectInput device.
 *
 *          The data format must be set before the device can be
 *          acquired.
 *
 *          It is necessary to set the data format only once.
 *
 *          The data format may not be changed while the device
 *          is acquired.
 *
 *          If the attempt to set the data format fails, all data
 *          format information is lost, and a valid data format
 *          must be set before the device may be acquired.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN LPDIDATAFORMAT | lpdf |
 *
 *          Points to a structure that describes the format of the data
 *          the DirectInputDevice should return.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpvData> parameter is not a valid pointer.
 *
 *          <c DIERR_ACQUIRED>: Cannot change the data format while the
 *          device is acquired.
 *
 *
 *****************************************************************************/

HRESULT INLINE
CDIDev_SetDataFormat_IsValidDataSize(LPCDIDATAFORMAT lpdf)
{
    HRESULT hres;
    if ( lpdf->dwDataSize % 4 == 0 ) {
        hres = S_OK;
    } else {
        RPF("IDirectInputDevice::SetDataFormat: "
            "dwDataSize must be a multiple of 4");
        hres = E_INVALIDARG;
    }
    return hres;
}

HRESULT INLINE
CDIDev_SetDataFormat_IsValidObjectSize(LPCDIDATAFORMAT lpdf)
{
    HRESULT hres;
    if ( lpdf->dwObjSize == cbX(ODF) ) {
        hres = S_OK;
    } else {
        RPF("IDirectInputDevice::SetDataFormat: Invalid dwObjSize");
        hres = E_INVALIDARG;
    }
    return hres;
}


STDMETHODIMP
CDIDev_SetDataFormat(PV pdd, LPCDIDATAFORMAT lpdf _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice::SetDataFormat, (_ "pp", pdd, lpdf));

    if ( SUCCEEDED(hres = hresPvT(pdd)) &&
         SUCCEEDED(hres = hresFullValidReadPxCb(lpdf, DIDATAFORMAT, 1)) &&
         SUCCEEDED(hres = hresFullValidFl(lpdf->dwFlags, DIDF_VALID, 1)) &&
         SUCCEEDED(hres = CDIDev_SetDataFormat_IsValidDataSize(lpdf)) &&
         SUCCEEDED(hres = CDIDev_SetDataFormat_IsValidObjectSize(lpdf)) &&
         SUCCEEDED(hres = hresFullValidReadPvCb(lpdf->rgodf,
                                                cbCxX(lpdf->dwNumObjs, ODF), 1)) ) {
        PDD this = _thisPv(pdd);

        /*
         *  Must protect with the critical section to prevent two people
         *  from changing the format simultaneously, or one person from
         *  changing the data format while somebody else is reading data.
         */
        CDIDev_EnterCrit(this);

#if DIRECTINPUT_VERSION >= 0x04F0
        if ( this->dwVersion == 0 ) {
            RPF("Warning: IDirectInputDevice::Initialize not called; "
                "assuming version 3.0");
        }
#endif

        if ( !this->fAcquired ) {
            DIPROPDWORD dipdw;

            /*
             *  Nuke the old data format stuff before proceeding.
             */
            FreePpv(&this->pdix);
            FreePpv(&this->rgiobj);
            this->cdwPOV = 0;
            D(this->GetState = 0);
            this->fPolledDataFormat = FALSE;

            /* 
             * Wipe out the report IDs
             */
            dipdw.diph.dwSize = sizeof(DIPROPDWORD);
            dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
            dipdw.diph.dwObj = 0x0;
            dipdw.diph.dwHow = DIPH_DEVICE;
            dipdw.dwData     = 0;   // Nuke all knowledge of reportId's
            hres = CDIDev_RealSetProperty(this, DIPROP_ENABLEREPORTID, &dipdw.diph);
            if ( SUCCEEDED(hres) || hres == E_NOTIMPL ) 
            {
                hres = CDIDev_ParseDataFormat(this, lpdf);
                if ( SUCCEEDED(hres) ) {
                    hres = CDIDev_OptimizeDataFormat(this);

                    /*
                     *  Now set the axis mode, as a convenience.
                     */
                    CAssertF(DIDF_VALID == (DIDF_RELAXIS | DIDF_ABSAXIS));

                    switch ( lpdf->dwFlags ) {
                        case 0: 
                            hres = S_OK; 
                            goto axisdone;

                        case DIDF_RELAXIS:
                            dipdw.dwData = DIPROPAXISMODE_REL; 
                            break;

                        case DIDF_ABSAXIS:
                            dipdw.dwData = DIPROPAXISMODE_ABS; 
                            break;

                        default:
                            RPF("%s: Cannot combine DIDF_RELAXIS with DIDF_ABSAXIS",
                                s_szProc);
                            hres = E_INVALIDARG;
                            goto axisdone;

                    }

                    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
                    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
                    dipdw.diph.dwObj = 0;
                    dipdw.diph.dwHow = DIPH_DEVICE;

                    hres = CDIDev_RealSetProperty(this, DIPROP_AXISMODE, &dipdw.diph);

                    if ( SUCCEEDED(hres) ) {
                        hres = S_OK;
                    }

                }
            } else 
            {
                SquirtSqflPtszV(sqflDf,
                                TEXT("Could not set DIPROP_ENABLEREPORTID to 0x0"));

            }
            axisdone:;

        } else {                                /* Already acquired */
            hres = DIERR_ACQUIRED;
        }
        CDIDev_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetDeviceState |
 *
 *          Obtains instantaneous data from the DirectInput device.
 *
 *          Before device data can be obtained, the data format must
 *          be set via <mf IDirectInputDevice::SetDataFormat>, and
 *          the device must be acquired via
 *          <mf IDirectInputDevice::Acquire>.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   DWORD | cbData |
 *
 *          The size of the buffer pointed to by <p lpvData>, in bytes.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Points to a structure that receives the current state
 *          of the device.
 *          The format of the data is established by a prior call
 *          to <mf IDirectInputDevice::SetDataFormat>.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c E_PENDING>: The device does not have data yet.
 *          Some devices (such as USB joysticks) require a delay
 *          between the time the device is turned on and the time
 *          the device begins sending data.  During this "warm-up" time,
 *          <mf IDirectInputDevice::GetDeviceState> will return
 *          <c E_PENDING>.  When data becomes available, the event
 *          notification handle will be signalled.
 *
 *          <c DIERR_NOTACQUIRED>: The device is not acquired.
 *
 *          <c DIERR_INPUTLOST>:  Access to the device has been
 *          interrupted.  The application should re-acquire the
 *          device.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpvData> parameter is not a valid pointer or
 *          the <p cbData> parameter does not match the data size
 *          set by a previous call to <mf IDirectInputDevice::SetDataFormat>.
 *
 *****************************************************************************/
extern  STDMETHODIMP CDIDev_Acquire(PV pdd _THAT);


STDMETHODIMP
CDIDev_GetDeviceState(PV pdd, DWORD cbDataSize, LPVOID pvData _THAT)
{
    HRESULT hres;
    PDD this;
    EnterProcR(IDirectInputDevice::GetDeviceState, (_ "pp", pdd, pvData));

    /*
     *  Note that we do not validate the parameters.
     *  The reason is that GetDeviceState is an inner loop function,
     *  so it should be as fast as possible.
     */
#ifdef XDEBUG
    hresPvT(pdd);
    hresFullValidWritePvCb(pvData, cbDataSize, 1);
#endif
    this = _thisPv(pdd);

    /*
     *  Must protect with the critical section to prevent somebody from
     *  unacquiring while we're reading.
     */
    CDIDev_EnterCrit(this);

    /*
     *  Reacquire is not allowed until after Win98 SE, see OSR Bug # 89958
     */
#if (DIRECTINPUT_VERSION > 0x061A)
    if ( this->diHacks.fReacquire &&
         !this->fAcquired && (this->fOnceAcquired || this->fOnceForcedUnacquired) ) 
    {
        if ( SUCCEEDED( CDIDev_Acquire(pdd THAT_) ) ) {
            // 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            RPF(" DirectInput: Auto acquired (0x%p)", pdd);
        }
    }

  #ifdef WINNT
    if( this->fUnacquiredWhenIconic && !IsIconic(this->hwnd) ) {
        if ( SUCCEEDED( CDIDev_Acquire(pdd THAT_) ) ) {
            this->fUnacquiredWhenIconic = 0;
            RPF(" DirectInput: Auto acquired device (0x%p) after being iconic. ", pdd);
        }
    }
  #endif

#endif

    if ( this->fAcquired ) {
        AssertF(this->pdix);    /* Acquire shouldn't let you get this far */
        AssertF(this->GetState);
        AssertF(this->GetDeviceState);
        AssertF(this->pdcb);

        if ( this->dwDataSize == cbDataSize ) {
#ifndef DEBUG_STICKY
            hres = this->GetState(this, pvData);
#else
            PBYTE pbDbg;
            TCHAR tszDbg[80];

            hres = this->GetState(this, pvData);

            for( pbDbg=(PBYTE)pvData; pbDbg<((PBYTE)pvData+cbDataSize); pbDbg++ )
            {
                if( *pbDbg )
                {
                    wsprintf( tszDbg, TEXT("GotState @ 0x%02x, 0x%02x\r\n"), pbDbg-(PBYTE)pvData, *pbDbg );
                    OutputDebugString( tszDbg );
                }
            }
#endif /* DEBUG_STICKY */            
            if ( SUCCEEDED(hres) ) {
                UINT idw;

                AssertF(hres == S_OK);
                /*
                 *  Icky POV hack for apps that don't check if they have
                 *  a POV before reading from it.
                 */
                for ( idw = 0; idw < this->cdwPOV; idw++ ) {
                    DWORD UNALIGNED *pdw = pvAddPvCb(pvData, this->rgdwPOV[idw]);
                    *pdw = JOY_POVCENTERED;
                }
                hres = S_OK;
            } else if ( hres == DIERR_INPUTLOST ) {
                RPF("%s: Input lost", s_szProc);
                CDIDev_InternalUnacquire(this);

                hres = DIERR_INPUTLOST;
            }
        } else {
            RPF("ERROR %s: arg %d: invalid value", s_szProc, 1);
            hres = E_INVALIDARG;
        }
    } else {
        hres = this->hresNotAcquired;
    }

    if ( FAILED(hres) ) {
        ScrambleBuf(pvData, cbDataSize);
    }

    CDIDev_LeaveCrit(this);
    ExitOleProc();
    return hres;
}

#if DIRECTINPUT_VERSION > 0x0300
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputDevice | CookDeviceData |
 *
 *          Cook device data that was recently obtained from the
 *          device buffer.
 *
 *          Right now, only the joystick device requires cooking,
 *          and nobody in their right mind uses buffered joystick
 *          data, and the joystick has only a few objects, so we
 *          can afford to be slow on this.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   UINT | cdod |
 *
 *          Number of objects to cook.
 *
 *  @parm   LPDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of object data to cook.  The dwOfs are really
 *          device object indexes (relative to the device format).
 *          After calling the callback, we convert them into
 *          application data format offsets.
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/

void INTERNAL
CDIDev_CookDeviceData(PDD this, UINT cdod, PDOD rgdod)
{
    UINT idod;
    EnterProc(IDirectInputDevice::CookDeviceData,
              (_ "pxp", this, cdod, rgdod));

    AssertF(this->fCook);

    /*
     *  Relative data does not need to be cooked by the callback.
     */
    if( ( this->pvi->fl & VIFL_RELATIVE ) == 0 )
    {
        this->pdcb->lpVtbl->CookDeviceData(this->pdcb, cdod, rgdod);
    }

    for ( idod = 0; idod < cdod; idod++ ) {
        rgdod[idod].dwOfs = DICOOK_OFSFROMDFOFS(rgdod[idod].dwOfs);
    }

    ExitProc();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SOMEDEVICEDATA |
 *
 *          Instance data used by <mf IDirectInputDevice::GetSomeDeviceData>.
 *
 *  @field  DWORD | celtIn |
 *
 *          Number of elements remaining in output buffer.
 *
 *  @field  PDOD | rgdod |
 *
 *          Output buffer for data elements, or <c NULL> if
 *          elements should be discarded.
 *
 *  @field  DWORD | celtOut |
 *
 *          Number of elements actually copied (so far).
 *
 *****************************************************************************/

typedef struct SOMEDEVICEDATA {
    DWORD   celtIn;
    PDOD    rgdod;
    DWORD   celtOut;
} SOMEDEVICEDATA, *PSOMEDEVICEDATA;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method PDOD | IDirectInputDevice | GetSomeDeviceData |
 *
 *          Obtains a small amount of
 *          buffered data from the DirectInput device.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   PDOD | pdod |
 *
 *          First element to copy.
 *
 *  @parm   DWORD | celt |
 *
 *          Maximum number of elements to copy.
 *
 *  @parm   PSOMEDEVICEDATA | psdd |
 *
 *          Structure describing the state of the ongoing
 *          <mf IDirectInputDevice::GetDeviceData>.
 *
 *  @returns
 *
 *          Returns a pointer to the first uncopied item.
 *
 *****************************************************************************/

PDOD INTERNAL
CDIDev_GetSomeDeviceData(PDD this, PDOD pdod, DWORD celt, PSOMEDEVICEDATA psdd)
{
    EnterProc(IDirectInputDevice::GetSomeDeviceData,
              (_ "ppxx", this, pdod, celt, psdd->celtIn));

    /*
     *  Copy as many elements as fit, but not more than exist
     *  in the output buffer.
     */
    if ( celt > psdd->celtIn ) {
        celt = psdd->celtIn;
    }

    /*
     *  Copy the elements (if requested) and update the state.
     *  Note that celt might be zero; fortunately, memcpy does
     *  the right thing.
     */
    if ( psdd->rgdod ) {
        memcpy(psdd->rgdod, pdod, cbCxX(celt, DOD));
        psdd->rgdod += celt;
    }
    psdd->celtOut += celt;
    psdd->celtIn -= celt;
    pdod += celt;

    if ( pdod == this->pvi->pEnd ) {
        pdod = this->pvi->pBuffer;
    }

    ExitProcX(celt);

    return pdod;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice | GetDeviceData |
 *
 *          Obtains buffered data from the DirectInput device.
 *
 *          DirectInput devices are, by default, unbuffered.  To
 *          turn on buffering, you must set the buffer size
 *          via <mf IDirectInputDevice::SetProperty>, setting the
 *          <c DIPROP_BUFFERSIZE> property to the desired size
 *          of the input buffer.
 *
 *          Before device data can be obtained, the data format must
 *          be set via <mf IDirectInputDevice::SetDataFormat>, and
 *          the device must be acquired via
 *          <mf IDirectInputDevice::Acquire>.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   DWORD | cbObjectData |
 *
 *          The size of a single <t DIDEVICEOBJECTDATA> structure in bytes.
 *
 *  @parm   OUT LPDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures to receive
 *          the buffered data.  It must consist of
 *          *<p pdwInOut> elements.
 *
 *          If this parameter is <c NULL>, then the buffered data is
 *          not stored anywhere, but all other side-effects take place.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          On entry, contains the number of elements in the array
 *          pointed to by <p rgdod>.  On exit, contains the number
 *          of elements actually obtained.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags which control the manner in which data is obtained.
 *          It may be zero or more of the following flags:
 *
 *          <c DIGDD_PEEK>: Do not remove the items from the buffer.
 *          A subsequent <mf IDirectInputDevice::GetDeviceData> will
 *          read the same data.  Normally, data is removed from the
 *          buffer after it is read.
 *
;begin_internal dx4
 *          <c DIGDD_RESIDUAL>:  Read data from the device buffer
 *          even if the device is not acquired.  Normally, attempting
 *          to read device data from an unacquired device will return
 *          <c DIERR_NOTACQUIRED> or <c DIERR_INPUTLOST>.
;end_internal dx4
 *
 *  @returns
 *
 *          <c DI_OK> = <c S_OK>: All data were retrieved
 *          successfully.  Note that the application needs to check
 *          the output value of *<p pdwInOut> to determine whether
 *          and how much data was retrieved:  The value may be zero,
 *          indicating that the buffer was empty.
 *
 *          <c DI_BUFFEROVERFLOW> = <c S_FALSE>: Some data
 *          were retrieved successfully, but some data were lost
 *          because the device's buffer size was not large enough.
 *          The application should retrieve buffered data more frequently
 *          or increase the device buffer size.  This status code is
 *          returned only on the first <mf IDirectInput::GetDeviceData>
 *          call after the buffer has overflowed.  Note that this is
 *          a success status code.
 *
 *          <c DIERR_NOTACQUIRED>: The device is not acquired.
 *
 *          <c DIERR_INPUTLOST>:  Access to the device has been
 *          interrupted.  The application should re-acquire the
 *          device.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  One or more
 *          parameters was invalid.  A common cause for this is
 *          neglecting to set a buffer size.
 *
 *          <c DIERR_NOTBUFFERED>:  The device is not buffered.
 *          Set the <c DIPROP_BUFFERSIZE> property to enable buffering.
 *
 *  @ex
 *
 *          The following sample reads up to ten buffered data elements,
 *          removing them from the device buffer as they are read.
 *
 *          |
 *
 *          DIDEVICEOBJECTDATA rgdod[10];
 *          DWORD dwItems = 10;
 *          hres = IDirectInputDevice_GetDeviceData(
 *                      pdid,
 *                      sizeof(DIDEVICEOBJECTDATA),
 *                      rgdod,
 *                      &dwItems,
 *                      0);
 *          if (SUCCEEDED(hres)) {
 *              // Buffer successfully flushed.
 *              // dwItems = number of elements flushed
 *              if (hres == DI_BUFFEROVERFLOW) {
 *                  // Buffer had overflowed.
 *              }
 *          }
 *
 *
 *
 *
 *  @ex
 *
 *          If you pass <c NULL> for the <p rgdod> and request an
 *          infinite number of items, this has the effect of flushing
 *          the buffer and returning the number of items that were
 *          flushed.
 *
 *          |
 *
 *          dwItems = INFINITE;
 *          hres = IDirectInputDevice_GetDeviceData(
 *                      pdid,
 *                      sizeof(DIDEVICEOBJECTDATA),
 *                      NULL,
 *                      &dwItems,
 *                      0);
 *          if (SUCCEEDED(hres)) {
 *              // Buffer successfully flushed.
 *              // dwItems = number of elements flushed
 *              if (hres == DI_BUFFEROVERFLOW) {
 *                  // Buffer had overflowed.
 *              }
 *          }
 *
 *  @ex
 *
 *          If you pass <c NULL> for the <p rgdod>, request an
 *          infinite number of items, and ask that the data not be
 *          removed from the device buffer, this has the effect of
 *          querying for the number of elements in the device buffer.
 *
 *          |
 *
 *          dwItems = INFINITE;
 *          hres = IDirectInputDevice_GetDeviceData(
 *                      pdid,
 *                      sizeof(DIDEVICEOBJECTDATA),
 *                      NULL,
 *                      &dwItems,
 *                      DIGDD_PEEK);
 *          if (SUCCEEDED(hres)) {
 *              // dwItems = number of elements in buffer
 *              if (hres == DI_BUFFEROVERFLOW) {
 *                  // Buffer overflow occurred; not all data
 *                  // were successfully captured.
 *              }
 *          }
 *
 *  @ex
 *
 *          If you pass <c NULL> for the <p rgdod> and request zero
 *          items, this has the effect of querying whether buffer
 *          overflow has occurred.
 *
 *          |
 *
 *          dwItems = 0;
 *          hres = IDirectInputDevice_GetDeviceData(
 *                      pdid,
 *                      sizeof(DIDEVICEOBJECTDATA),
 *                      NULL,
 *                      &dwItems,
 *                      0);
 *          if (hres == DI_BUFFEROVERFLOW) {
 *              // Buffer overflow occurred
 *          }
 *
 *
 *//**************************************************************************
 *
 *      When reading this code, the following pictures will come in handy.
 *
 *
 *      Buffer not wrapped.
 *
 *      pBuffer                                                pEnd
 *      |                                                      |
 *      v                                                      v
 *      +----+----+----+----+----+----+----+----+----+----+----+
 *      |    |    |    |    |    |    |    |    |    |    |    |
 *      |    |    |    |data|data|data|data|data|    |    |    |
 *      |    |    |    |    |    |    |    |    |    |    |    |
 *      +----+----+----+----+----+----+----+----+----+----+----+
 *                     ^                        ^
 *                     |                        |
 *                     pTail                    pHead
 *
 *
 *      Buffer wrapped.
 *
 *      pBuffer                                                pEnd
 *      |                                                      |
 *      v                                                      v
 *      +----+----+----+----+----+----+----+----+----+----+----+
 *      |    |    |    |    |    |    |    |    |    |    |    |
 *      |data|data|    |    |    |    |    |    |data|data|data|
 *      |    |    |    |    |    |    |    |    |    |    |    |
 *      +----+----+----+----+----+----+----+----+----+----+----+
 *                ^                             ^
 *                |                             |
 *                pHead                         pTail
 *
 *
 *      Boundary wrap case.
 *
 *
 *      pBuffer                                                pEnd
 *      |                                                      |
 *      v                                                      v
 *      +----+----+----+----+----+----+----+----+----+----+----+
 *      |    |    |    |    |    |    |    |    |    |    |    |
 *      |    |    |    |    |    |    |data|data|data|data|data|
 *      |    |    |    |    |    |    |    |    |    |    |    |
 *      +----+----+----+----+----+----+----+----+----+----+----+
 *      ^                             ^
 *      |                             |
 *      pHead                         pTail
 *
 *
 *      Note!  At no point is pTail == pEnd or pHead == pEnd.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetDeviceData(PV pdd, DWORD cbdod, PDOD rgdod,
                     LPDWORD pdwInOut, DWORD fl _THAT)
{
    HRESULT hres;
    PDD this;
    SOMEDEVICEDATA sdd;
    EnterProcR(IDirectInputDevice::GetDeviceData,
               (_ "pxpxx", pdd, cbdod, rgdod,
                IsBadReadPtr(pdwInOut, cbX(DWORD)) ? 0 : *pdwInOut, fl));

    /*
     *  Note that we do not validate the parameters.
     *  The reason is that GetDeviceData is an inner loop function,
     *  so it should be as fast as possible.
     *
     *  Note also that it is legal to get device data after the device
     *  has been unacquired.  This lets you "turn on the faucet" for
     *  a short period of time, and then parse the data out later.
     */
#ifdef XDEBUG
    hresPvT(pdd);
    if ( IsBadWritePtr(pdwInOut, cbX(*pdwInOut)) ) {
        RPF("ERROR %s: arg %d: invalid value; crash soon", s_szProc, 3);
    }
    if ( rgdod ) {
        hresFullValidWritePvCb(rgdod, cbCxX(*pdwInOut, DOD), 2);
    }
#endif
    this = _thisPv(pdd);

    /*
     *  Must protect with the critical section to prevent somebody from
     *  acquiring/unacquiring or changing the data format or calling
     *  another GetDeviceData while we're reading.  (We must be serialized.)
     */
    CDIDev_EnterCrit(this);

    AssertF(CDIDev_IsConsistent(this));

    if ( SUCCEEDED(hres = hresFullValidFl(fl, DIGDD_VALID, 4)) ) {
        if ( cbdod == cbX(DOD) ) {

            if ( this->celtBuf ) {
                /*
                 *  Don't try to read more than there possibly could be.
                 *  This avoids overflow conditions in case celtIn is
                 *  some absurdly huge number.
                 */
                sdd.celtIn = *pdwInOut;
                sdd.celtOut = 0;
                if ( sdd.celtIn > this->celtBuf ) {
                    sdd.celtIn = this->celtBuf;
                }
                sdd.rgdod = rgdod;


                /*
                 *  For this version of DirectInput, we do not allow
                 *  callbacks to implement their own GetDeviceData.
                 */
                if ( this->pvi ) {

                  /*
                   *  Reacquire is not allowed until after Win98 SE, see OSR Bug # 89958.
                   */
                  #if (DIRECTINPUT_VERSION > 0x061A)
                    if ( this->diHacks.fReacquire &&
                         !this->fAcquired && (this->fOnceAcquired || this->fOnceForcedUnacquired) ) 
                    {
                        if ( SUCCEEDED( CDIDev_Acquire(pdd THAT_) ) ) {
                            // 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
                            RPF(" DirectInput: Auto acquired device (0x%p)", pdd);
                        }
                    }

                    #ifdef WINNT
                    if( this->fUnacquiredWhenIconic && !IsIconic(this->hwnd) ) {
                        if ( SUCCEEDED( CDIDev_Acquire(pdd THAT_) ) ) {
                            this->fUnacquiredWhenIconic = 0;
                            RPF(" DirectInput: Auto acquired device (0x%p) after being iconic. ", pdd);
                        }
                    }
                    #endif
                    
                  #endif

                    if ( (this->fAcquired && (this->pvi->fl & VIFL_ACQUIRED)) ||
                         (fl & DIGDD_RESIDUAL) ) {
                        LPDIDEVICEOBJECTDATA pdod, pdodHead;
                        DWORD celt;

                        /*
                         *  Snapshot the value of pdodHead, because it can
                         *  change asynchronously.  The other fields won't
                         *  change unless we ask for them to be changed.
                         */
                        pdodHead = this->pvi->pHead;

                        /*
                         *  Throughout, pdod points to the first unprocessed
                         *  element.
                         */
                        pdod = this->pvi->pTail;

                        /*
                         *  If we are wrapped, handle the initial run.
                         */
                        if ( pdodHead < this->pvi->pTail ) {
                            celt = (DWORD)(this->pvi->pEnd - this->pvi->pTail);
                            AssertF(celt);

                            pdod = CDIDev_GetSomeDeviceData(this, pdod, celt, &sdd);

                        }

                        /*
                         *  Now handle the glob from pdod to pdodHead.
                         *  Remember, pvi->pdodHead may have changed
                         *  behind our back; use the cached value to
                         *  ensure consistency.  (If we miss data,
                         *  it'll show up later.)
                         */

                        AssertF(fLimpFF(sdd.celtIn, pdodHead >= pdod));

                        celt = (DWORD)(pdodHead - pdod);
                        if ( celt ) {
                            pdod = CDIDev_GetSomeDeviceData(this, pdod, celt, &sdd);
                        }

                        *pdwInOut = sdd.celtOut;

                        if ( !(fl & DIGDD_PEEK) ) {
                            this->pvi->pTail = pdod;
                        }

                      #if DIRECTINPUT_VERSION > 0x0300
                        if ( rgdod && sdd.celtOut && this->fCook ) {
                            CDIDev_CookDeviceData(this, sdd.celtOut, rgdod);
                        }
                      #endif

                        CAssertF(S_OK == 0);
                        CAssertF(DI_BUFFEROVERFLOW == 1);

                        hres = (HRESULT)(UINT_PTR)pvExchangePpvPv(&this->pvi->fOverflow, 0);
#ifdef DEBUG_STICKY
                        if( hres == 1 )
                        {
                            OutputDebugString( TEXT( "Device buffer overflowed\r\n" ) );
                        }
                        if( sdd.celtOut )
                        {
                            PDOD pdoddbg;
                            TCHAR tszDbg[80];

                            wsprintf( tszDbg, TEXT("GotData %d elements:  "), sdd.celtOut );
                            OutputDebugString( tszDbg );
                            for( pdoddbg=rgdod; pdoddbg<&rgdod[sdd.celtOut]; pdoddbg++ )
                            {
                                wsprintf( tszDbg, TEXT("0x%02x:x0x%08x  "), pdoddbg->dwOfs, pdoddbg->dwData );
                                OutputDebugString( tszDbg );
                            }
                            OutputDebugString( TEXT("\r\n") );
                        }
#endif /* DEBUG_STICKY */
                    } else if (this->fAcquired && !(this->pvi->fl & VIFL_ACQUIRED)) {
                        RPF("ERROR %s - %s", s_szProc, "input lost");
                        hres = DIERR_INPUTLOST;
                        CDIDev_InternalUnacquire(this);
                    } else {
                        RPF("ERROR %s: %s", s_szProc,
                            this->hresNotAcquired == DIERR_NOTACQUIRED
                            ? "Not acquired" : "Input lost");
                        hres = this->hresNotAcquired;
                    }
                } else {            /* Don't support device-side GetData yet */
                    hres = E_NOTIMPL;
                }
            } else {                /* Device is not buffered */
#ifdef XDEBUG
                if ( !this->fNotifiedNotBuffered ) {
                    this->fNotifiedNotBuffered = 1;
                    RPF("ERROR %s: arg %d: device is not buffered", s_szProc, 0);
                }
#endif
              #if DIRECTINPUT_VERSION > 0x0300
                hres = DIERR_NOTBUFFERED;
              #else
                hres = E_INVALIDARG;
              #endif
            }
        } else {
            RPF("ERROR %s: arg %d: invalid value", s_szProc, 1);
        }
    }

    CDIDev_LeaveCrit(this);
    return hres;
}

#ifdef IDirectInputDevice2Vtbl

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice2 | Poll |
 *
 *          Retrieves data from polled objects on a DirectInput device.
 *          If the device does not require polling, then calling this
 *          method has no effect.   If a device that requires polling
 *          is not polled periodically, no new data will be received
 *          from the device.
 *
 *          Before a device data can be polled, the data format must
 *          be set via <mf IDirectInputDevice::SetDataFormat>, and
 *          the device must be acquired via
 *          <mf IDirectInputDevice::Acquire>.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DI_NOEFFECT> = <c S_FALSE>: The device does not require
 *          polling.
 *
 *          <c DIERR_INPUTLOST>:  Access to the device has been
 *          interrupted.  The application should re-acquire the
 *          device.
 *
 *          <c DIERR_NOTACQUIRED>: The device is not acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_Poll(PV pdd _THAT)
{
    HRESULT hres;
    PDD this;
    EnterProcR(IDirectInputDevice::Poll, (_ "p", pdd));

    /*
     *  Note that we do not validate the parameters.
     *  The reason is that Poll is an inner loop function,
     *  so it should be as fast as possible.
     */
    #ifdef XDEBUG
    hresPvT(pdd);
    #endif
    this = _thisPv(pdd);

    /*
     *  Fast out:  If the device doesn't require polling,
     *  then don't bother with the critical section or other validation.
     */
    if ( this->fPolledDataFormat ) {
        /*
         *  Must protect with the critical section to prevent somebody from
         *  unacquiring while we're polling.
         */
        CDIDev_EnterCrit(this);

        if ( this->fAcquired ) {
            hres = this->pdcb->lpVtbl->Poll(this->pdcb);

        } else {
            hres = this->hresNotAcquired;
        }

        CDIDev_LeaveCrit(this);

    } else {
        if ( this->fAcquired ) {
            if( this->dwVersion < 0x05B2 ) {
                hres = S_OK;
            } else {
                hres = S_FALSE;
            }
        } else {
            hres = this->hresNotAcquired;
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice2 | SendDeviceData |
 *
 *          Sends data to the device.
 *
 *          Before device data can be sent to a device,
 *          the device must be acquired via
 *          <mf IDirectInputDevice::Acquire>.
 *
 *          Note that no guarantees
 *          are made on the order in which the individual data
 *          elements are sent.  However, data sent by
 *          successive calls to
 *          <mf IDirectInputDevice2::SendDeviceData>
 *          will not be interleaved.
 *          Furthermore, if multiple pieces of
 *          data are sent to the same object, it is unspecified
 *          which actual piece of data is sent.
 *
 *          Consider, for example, a device which can be sent
 *          data in packets, each packet describing two pieces
 *          of information, call them A and B.  Suppose the
 *          application attempts to send three data elements,
 *          "B = 2", "A = 1", and "B = 0".
 *
 *          The actual device will be sent a single packet.
 *          The "A" field of the packet will contain the value 1,
 *          and the "B" field of the packet will be either 2 or 0.
 *
 *          If the application wishes the data to be sent to the
 *          device exactly as specified, then three calls to
 *          <mf IDirectInputDevice2::SendDeviceData> should be
 *          performed, each call sending one data element.
 *
 *          In response to the first call,
 *          the device will be sent a packet where the "A" field
 *          is blank and the "B" field contains the value 2.
 *
 *          In response to the second call,
 *          the device will be sent a packet where the "A" field
 *          contains the value 1, and the "B" field is blank.
 *
 *          Finally, in response to the third call,
 *          the device will be sent a packet where the "A" field
 *          is blank and the "B" field contains the value 0.
 *
 *
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   DWORD | cbObjectData |
 *
 *          The size of a single <t DIDEVICEOBJECTDATA> structure in bytes.
 *
 *  @parm   IN LPCDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures containing
 *          the data to send to the device.  It must consist of
 *          *<p pdwInOut> elements.
 *
 *          <y Note>:  The <e DIDEVICEOBJECTDATA.dwOfs> field of
 *          the <t DIDEVICEOBJECTDATA> structure must contain the
 *          device object identifier (as obtained from the
 *          <e DIDEVICEOBJECTINSTANCE.dwType> field of the
 *          <t DIDEVICEOBJECTINSTANCE> sturcture) for the device
 *          object at which the data is directed.
 *
 *          Furthermore, the <e DIDEVICEOBJECTDATA.dwTimeStamp>
 *          and <e DIDEVICEOBJECTDATA.dwSequence> fields are
 *          reserved for future use and must be zero.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          On entry, contains the number of elements in the array
 *          pointed to by <p rgdod>.  On exit, contains the number
 *          of elements actually sent to the device.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags which control the manner in which data is sent.
 *          It may consist of zero or more of the following flags:
 *
 *          <c DISDD_CONTINUE>:  If this flag is set, then
 *          the device data sent will be overlaid upon the previously
 *          sent device data.  Otherwise, the device data sent
 *          will start from scratch.
 *
 *          For example, suppose a device supports two button outputs,
 *          call them A and B.
 *          If an application first calls
 *          <mf IDirectInputDevice2::SendDeviceData> passing
 *          "button A pressed", then
 *          a packet of the form "A pressed, B not pressed" will be
 *          sent to the device.
 *          If an application then calls
 *          <mf IDirectInputDevice2::SendDeviceData> passing
 *          "button B pressed" and the <c DISDD_CONTINUE> flag, then
 *          a packet of the form "A pressed, B pressed" will be
 *          sent to the device.
 *          However, if the application had not passed the
 *          <c DISDD_CONTINUE> flag, then the packet sent to the device
 *          would have been "A not pressed, B pressed".
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INPUTLOST>:  Access to the device has been
 *          interrupted.  The application should re-acquire the
 *          device.
 *
 *          <c DIERR_NOTACQUIRED>: The device is not acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_SendDeviceData(PV pdd, DWORD cbdod, PCDOD rgdod,
                      LPDWORD pdwInOut, DWORD fl _THAT)
{
    HRESULT hres;
    PDD this;
    EnterProcR(IDirectInputDevice::SendDeviceData,
               (_ "pxpxx", pdd, cbdod, rgdod,
                IsBadReadPtr(pdwInOut, cbX(DWORD)) ? 0 : *pdwInOut, fl));

    /*
     *  Note that we do not validate the parameters.
     *  The reason is that SendDeviceData is an inner loop function,
     *  so it should be as fast as possible.
     */
    #ifdef XDEBUG
    hresPvT(pdd);
    if ( IsBadWritePtr(pdwInOut, cbX(*pdwInOut)) ) {
        RPF("ERROR %s: arg %d: invalid value; crash soon", s_szProc, 3);
    }
    hresFullValidReadPvCb(rgdod, cbCxX(*pdwInOut, DOD), 2);
    #endif
    this = _thisPv(pdd);

    /*
     *  Must protect with the critical section to prevent somebody from
     *  unacquiring while we're sending data.
     */
    CDIDev_EnterCrit(this);

    if ( SUCCEEDED(hres = hresFullValidFl(fl, DISDD_VALID, 4)) ) {
        if ( cbdod == cbX(DOD) ) {
    #ifdef XDEBUG
            UINT iod;
            for ( iod = 0; iod < *pdwInOut; iod++ ) {
                if ( rgdod[iod].dwTimeStamp ) {
                    RPF("%s: ERROR: dwTimeStamp must be zero", s_szProc);
                }
                if ( rgdod[iod].dwSequence ) {
                    RPF("%s: ERROR: dwSequence must be zero", s_szProc);
                }
            }
    #endif
            if ( this->fAcquired ) {
                UINT iod;

                for ( iod=0; iod < *pdwInOut; iod++ ) {
                    int   iobj = CDIDev_OffsetToIobj(this, rgdod[iod].dwOfs);
                    LPDWORD pdw = (LPDWORD)&rgdod[iod].dwOfs;
                    *pdw = this->df.rgodf[iobj].dwType;
                }

                hres = this->pdcb->lpVtbl->SendDeviceData(this->pdcb,
                                                          rgdod, pdwInOut, fl);
            } else {
                hres = this->hresNotAcquired;
            }
        } else {
            RPF("ERROR %s: arg %d: invalid value", s_szProc, 1);
        }
    }

    CDIDev_LeaveCrit(this);
    ExitOleProc();
    return hres;
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIDev_CheckId |
 *
 *          Verify that the item has the appropriate type.
 *
 *  @parm   DWORD | dwId |
 *
 *          ID to locate.
 *
 *  @parm   UINT | fl |
 *
 *          Bitmask of flags for things to validate.
 *
 *          The <c DEVCO_TYPEMASK> fields describe what type
 *          of object we should be locating.
 *
 *          The <c DEVCO_ATTRMASK> fields describe the attribute
 *          bits that are required.
 *
 *****************************************************************************/

BOOL INLINE
CDIDev_CheckId(DWORD dwId, DWORD fl)
{
    CAssertF(DIDFT_ATTRMASK == DEVCO_ATTRMASK);

    return(dwId & fl & DEVCO_TYPEMASK) &&
    fHasAllBitsFlFl(dwId, fl & DIDFT_ATTRMASK);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CDIDev | IdToIobj |
 *
 *          Locate an item which matches the specified ID.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   DWORD | dwId |
 *
 *          ID to locate.
 *
 *  @returns
 *
 *          Returns the index of the object found, or -1 on error.
 *
 *****************************************************************************/

int INTERNAL
CDIDev_IdToIobj(PDD this, DWORD dwId)
{
    int iobj;

    /* Someday: Perf:  Should have xlat table */

    for ( iobj = this->df.dwNumObjs; --iobj >= 0; ) {
        PODF podf = &this->df.rgodf[iobj];
        if ( DIDFT_FINDMATCH(podf->dwType, dwId) ) {
            goto done;
        }
    }

    iobj = -1;

    done:;
    return iobj;

}

#if 0
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | IdToId |
 *
 *          Convert a single <t DWORD> from an ID to an ID.
 *
 *          This is clearly a very simple operation.
 *
 *          It's all validation.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   LPDWORD | pdw |
 *
 *          Single item to convert.
 *
 *  @parm   UINT | fl |
 *
 *          Bitmask of flags that govern the conversion.
 *          The function should look only at
 *          <c DEVCO_AXIS> or <c DEVCO_BUTTON>.
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIDev_IdToId(PDD this, LPDWORD pdw, UINT fl)
{
    HRESULT hres;
    int iobj;

    iobj = CDIDev_FindId(this, *pdw, fl);
    if ( iobj >= 0 ) {
        *pdw = this->df.rgodf[iobj].dwType;
        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CDIDev | OffsetToIobj |
 *
 *          Convert a single <t DWORD> from an offset to an object index.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   DWORD | dwOfs |
 *
 *          Offset to convert.
 *
 *****************************************************************************/

int INTERNAL
CDIDev_OffsetToIobj(PDD this, DWORD dwOfs)
{
    int iobj;

    AssertF(this->pdix);
    AssertF(this->rgiobj);

    if ( dwOfs < this->dwDataSize ) {
        iobj = this->rgiobj[dwOfs];
        if ( iobj >= 0 ) {
            AssertF(this->pdix[iobj].dwOfs == dwOfs);
        } else {
            AssertF(iobj == -1);
        }
    } else {
        iobj = -1;
    }

    return iobj;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CDIDev | IobjToId |
 *
 *          Convert an object index to an ID.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   int | iobj |
 *
 *          Single item to convert.
 *
 *****************************************************************************/

DWORD INLINE
CDIDev_IobjToId(PDD this, int iobj)
{
    AssertF((DWORD)iobj < this->df.dwNumObjs);

    return this->df.rgodf[iobj].dwType;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CDIDev | IobjToOffset |
 *
 *          Convert an object index to an offset.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   int | iobj |
 *
 *          Single item to convert.
 *
 *****************************************************************************/

DWORD INLINE
CDIDev_IobjToOffset(PDD this, int iobj)
{
    AssertF((DWORD)iobj < this->df.dwNumObjs);
    AssertF(this->pdix);

    return this->pdix[iobj].dwOfs;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | ConvertObjects |
 *
 *          Convert between the ways of talking about device gizmos.
 *
 *          Since this is used only by the force feedback subsystem,
 *          we also barf if the device found does not support
 *          force feedback.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   UINT | cdw |
 *
 *          Number of elements to convert (in-place).
 *
 *  @parm   LPDWORD | rgdw |
 *
 *          Array of elements to convert.
 *
 *  @parm   UINT | fl |
 *
 *          Flags that describe how to do the conversion.
 *
 *          <c DEVCO_AXIS> or <c DEVCO_BUTTON> indicate whether
 *          the item being converted is an axis or button.
 *
 *          <c DEVCO_FROM*> specifies what the existing value is.
 *
 *          <c DEVCO_TO*> specifies what the new values should be.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_ConvertObjects(PDD this, UINT cdw, LPDWORD rgdw, UINT fl)
{
    HRESULT hres;

    /*
     *  Don't let somebody change the data format while we're
     *  looking at it.
     */
    CDIDev_EnterCrit(this);

    AssertF((fl & ~DEVCO_VALID) == 0);

    if ( fLimpFF(fl & (DEVCO_FROMOFFSET | DEVCO_TOOFFSET),
                 this->pdix && this->rgiobj) ) {
        UINT idw;

        for ( idw = 0; idw < cdw; idw++ ) {

            /*
             *  Convert from its source to an object index,
             *  validate the object index, then convert to
             *  the target.
             */
            int iobj;

            switch ( fl & DEVCO_FROMMASK ) {
            default:
                AssertF(0);                     /* Huh? */
            case DEVCO_FROMID:
                iobj = CDIDev_IdToIobj(this, rgdw[idw]);
                break;

            case DEVCO_FROMOFFSET:
                iobj = CDIDev_OffsetToIobj(this, rgdw[idw]);
                break;
            }

            if ( iobj < 0 ) {
                hres = E_INVALIDARG;            /* Invalid object */
                goto done;
            }

            AssertF((DWORD)iobj < this->df.dwNumObjs);

            if ( !CDIDev_CheckId(this->df.rgodf[iobj].dwType, fl) ) {
                hres = E_INVALIDARG;            /* Bad attributes */
                goto done;
            }

            switch ( fl & DEVCO_TOMASK ) {

            default:
                AssertF(0);                     /* Huh? */
            case DEVCO_TOID:
                rgdw[idw] = CDIDev_IobjToId(this, iobj);
                break;

            case DEVCO_TOOFFSET:
                rgdw[idw] = CDIDev_IobjToOffset(this, iobj);
                break;
            }

        }

        hres = S_OK;

        done:;

    } else {
        RPF("ERROR: Must have a data format to use offsets");
        hres = E_INVALIDARG;
    }

    CDIDev_LeaveCrit(this);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\didenum.c ===
/*****************************************************************************
 *
 *  DIDEnum.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The IDirectInput device enumerator.
 *
 *      We don't bother making this an honest OLE enumerator because
 *      there's no point.  There's no way to access it from the outside.
 *
 *  Contents:
 *
 *      CDIDEnum_New
 *      CDIDEnum_Next
 *      CDIDEnum_Release
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDEnum

#if DIRECTINPUT_VERSION > 0x0400

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CDIDEnum |
 *
 *          Records the state of a device enumeration.  Note that this
 *          is not free-threaded.
 *
 *  @field  PDIW | pdiW |
 *
 *          The <i IDirectInputW> object that owns the enumeration.
 *
 *  @field  DWORD | dwDevType |
 *
 *          Device type filter.
 *
 *  @field  DWORD | edfl |
 *
 *          Enumeration flags.
 *
 *  @field  int | idosdStatic |
 *
 *          The next static device to enumerate.  Static devices live
 *          in <c c_rgdosdStatic>.
 *
 *  @field  DWORD | dwVer |
 *
 *          Version of DirectX we are emulating.
 *
 *          If we are emulating DirectX 3.0 or less, then don't
 *          reveal joysticks.
 *
#ifdef HID_SUPPORT
 *  @field  int | idosdDynamic |
 *
 *          The next dynamic device to enumerate.  Dyanmic devices
 *          are kept in the <e CDIDEnum.rgdosdDynamic> array.  They
 *          are snapshotted into the enumeration structure to avoid
 *          race conditions if a device comes or goes while we are
 *          in the middle of an enumeration.
 *
 *  @field  PHIDDEVICELIST | phdl |
 *
 *          List of HID devices to be returned by the enumeration.
#endif
 *
 *****************************************************************************/

typedef struct CDIDEnum
{

    D(DWORD dwSig;)
    PDIW pdiW;
    DWORD dwDevType;
    DWORD edfl;
    int idosdStatic;
    DWORD dwVer;
    #ifdef HID_SUPPORT
    int idosdDynamic;
    PHIDDEVICELIST phdl;
    #endif

} DENUM, *PDENUM, **PPDENUM;

    #define CDIDENUM_SIGNATURE  0x4D554E45          /* "ENUM" */

    #define AssertPde(pde)          AssertF((pde)->dwSig == CDIDENUM_SIGNATURE)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTSTATICDATA | c_rgdosdStatic[] |
 *
 *          Right now, the list of device is static and hard-coded.
 *          Eventually, we'll
 *          use plug and play to enumerate devices of class "input" and
 *          get information from their config/software keys.
 *
 *****************************************************************************/

    #pragma BEGIN_CONST_DATA

/*
 *  Our array of static joystick instance guids.
 *
 */
GUID rgGUID_Joystick[cJoyMax] = {
    {   0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B71,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B72,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B73,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B74,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B75,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B76,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B77,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B78,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B79,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7A,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7B,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7C,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7D,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7E,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7F,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
};

    #if cJoyMax != 16
        #error rgGUID_Joystick supports only 16 joysticks.
    #endif

/*
 *  Note that we recycle the SysMouse GUID as the instance GUID too,
 *  since there will never be more than one system mouse installed in
 *  the system.  Similarly for SysKeyboard.
 */

DIOBJECTSTATICDATA c_rgdosdStatic[] = {
    {   &GUID_SysMouse,     DIDEVTYPE_MOUSE,    CMouse_New,},
    {   &GUID_SysMouseEm,   DIDEVTYPE_MOUSE,    CMouse_New,},
    {   &GUID_SysMouseEm2,  DIDEVTYPE_MOUSE,    CMouse_New,},
    {   &GUID_SysKeyboard,  DIDEVTYPE_KEYBOARD, CKbd_New,},
    {   &GUID_SysKeyboardEm,   DIDEVTYPE_KEYBOARD, CKbd_New,},
    {   &GUID_SysKeyboardEm2,  DIDEVTYPE_KEYBOARD, CKbd_New,},

    #ifndef WINNT
    /*
     * On WINNT all joysticks are HID devices.
     * So it is pointless to include predefined
     * Joystick GUIDs
     */
        #define MAKEJOY(n)                                                  \
    {   &rgGUID_Joystick[n],DIDEVTYPE_JOYSTICK, CJoy_New,           }
        MAKEJOY( 0),
    MAKEJOY( 1),
    MAKEJOY( 2),
    MAKEJOY( 3),
    MAKEJOY( 4),
    MAKEJOY( 5),
    MAKEJOY( 6),
    MAKEJOY( 7),
    MAKEJOY( 8),
    MAKEJOY( 9),
    MAKEJOY(10),
    MAKEJOY(11),
    MAKEJOY(12),
    MAKEJOY(13),
    MAKEJOY(14),
    MAKEJOY(15),

        #undef MAKEJOY
    #endif

};

    #pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFindInstanceGUID |
 *
 *          Locates information given an instance GUID.
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          The instance GUID to be located.
 *
 *  @parm   OUT CREATEDCB * | pcdcb |
 *
 *          Receives pointer to the <f CreateDcb> function for the object.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    hresFindInstanceGUID_(PCGUID pguid, CREATEDCB *pcdcb,
                          LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    EnterProcS(hresFindInstance, (_ "G", pguid));

    if(SUCCEEDED(hres = hresFullValidGuid(pguid, iarg)))
    {
        int idosd;

        /*
         *  First try the list of static devices.  Since this
         *  list never changes, we don't need to protect it
         *  with a critical section.
         */
        for(idosd = 0; idosd < cA(c_rgdosdStatic); idosd++)
        {
            if(IsEqualGUID(pguid, c_rgdosdStatic[idosd].rguidInstance))
            {
                *pcdcb = c_rgdosdStatic[idosd].CreateDcb;
                goto done;
            }
            
        }

      #ifdef HID_SUPPORT
        /*
         *  So it wasn't one of the static devices.  See if it's
         *  one of the dynamic HID devices we've already found.
         */
        hres = hresFindHIDInstanceGUID(pguid, pcdcb);
        if(FAILED(hres))
        {

            /*
             *  Not on our list of dynamic HID devices.
             *  Re-enumerate them and try again.  Maybe it was
             *  for a device that we recently added.
             */
            DIHid_BuildHidList(TRUE);
            hres = hresFindHIDInstanceGUID(pguid, pcdcb);
        }

        if(FAILED(hres))
        {
          #ifdef WINNT
            /*
             *  NT Bug#351951.
             *  If they are directly asking for one of the predefined joystick 
             *  IDs then see if we have a device mapped to that ID.  If so,
             *  pretend they asked for that GUID instead.
             */

            /*
             *  Weakly Assert the range of predefined static joystick instance GUIDs
             */
            AssertF( ( rgGUID_Joystick[0].Data1 & 0x0f ) == 0 );
            AssertF( ( rgGUID_Joystick[0x0f].Data1 & 0x0f ) == 0x0f );

            /*
             *  Check the GUID is the same as the first static one ignoring LS 4 bits
             */
            if( ( (pguid->Data1 & 0xf0) == (rgGUID_Joystick[0].Data1 & 0xf0) )
              && !memcmp( ((PBYTE)&rgGUID_Joystick)+1, ((PBYTE)pguid)+1, sizeof(*pguid) - 1 ) )
            {
                RPF("%s: Using predefined instance GUIDs is bad and should not work!", s_szProc);
                if( phdiFindJoyId( pguid->Data1 & 0x0f ) )
                {
                    *pcdcb = CHid_New;
                    hres = S_OK;
                }
                else
                {
                    *pcdcb = 0;
                    hres = DIERR_DEVICENOTREG;
                }
            }
            else
            {
                RPF("%s: Warning: GUID is not installed in this system", s_szProc);
                *pcdcb = 0;
                hres = DIERR_DEVICENOTREG;
            }
          #else
            RPF("%s: Warning: GUID is not installed in this system", s_szProc);
            *pcdcb = 0;
            hres = DIERR_DEVICENOTREG;
          #endif //WINNT
        }
      #else
        RPF("%s: Warning: GUID is not installed in this system", s_szProc);
        *pcdcb = 0;
        hres = DIERR_DEVICENOTREG;
      #endif //HID_SUPPORT
    }

    done:;
    ExitOleProcPpv(pcdcb);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIDEnum_Release |
 *
 *          Free the enumeration object and its associated resources.
 *
 *  @parm   CDIDEnum * | pde |
 *
 *          The enumeration state to be released.
 *
 *****************************************************************************/

void EXTERNAL
    CDIDEnum_Release(PDENUM pde)
{
    EnterProcI(CDIDEnum_Release, (_ "p", pde));

    AssertPde(pde);
    OLE_Release(pde->pdiW);
    #ifdef HID_SUPPORT
    FreePpv(&pde->phdl);
    #endif
    FreePv(pde);

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDEnum_Next |
 *
 *          Return the next device.
 *
 *          Note that this is not the same as the OLE <mf IEnumXxx::Next>
 *          function.  Not that it'd be hard to convert over; it's just
 *          not needed yet.
 *
 *  @parm   CDIDEnum * | pde |
 *
 *          Maintains enumeration state.
 *
 *  @parm   LPGUID | pguid |
 *
 *          Receives the enumerated GUID.
 *
 *  @parm   LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Receives device attributes.
 *
 *  @returns
 *
 *          Returns <c S_OK> if the object was successfully obtained,
 *          or <c S_FALSE> if there aren't any more objects.
 *
 *          Warning! <f CDIObj_EnumDevicesW> assumes that this function
 *          cannot fail.
 *
 *****************************************************************************/

    #define S_SKIP      hresUs(2)

STDMETHODIMP
    CDIDEnum_Next(PDENUM pde, LPDIDEVICEINSTANCEW pddiW)
{
    HRESULT hres;
    EnterProcI(CDIDEnum_Next, (_ "p", pde));

    AssertPde(pde);

    AssertF(pddiW->dwSize == cbX(*pddiW));

    /*
     *  Keep going until something works.
     */
    do
    {
        PDIOBJECTSTATICDATA pdosd;

        /*
         *  Pull one from the static list first.
         *  If that is empty, then pull from the dynamic list.
         *  If that is empty, then we're done.
         */
        if(pde->idosdStatic < cA(c_rgdosdStatic))
        {
            pdosd = &c_rgdosdStatic[pde->idosdStatic++];
    #ifdef HID_SUPPORT
        } else if(pde->phdl && pde->idosdDynamic < pde->phdl->chdi)
        {
            pdosd = &pde->phdl->rghdi[pde->idosdDynamic].osd;
            pdosd->rguidInstance = &pde->phdl->rghdi[pde->idosdDynamic].guid;
            pde->idosdDynamic++;
    #endif
        } else
        {
            hres = S_FALSE;
            goto done;
        }

        /*
         *  If a devtype filter is provided, then it must match.
         *
         *  If the version is 3.0 or less, then don't show joysticks
         *  because DX3 didn't have (proper) joystick support.
         */
        if(fLimpFF(GET_DIDEVICE_TYPE(pde->dwDevType),
                   GET_DIDEVICE_TYPE(pde->dwDevType) ==
                   GET_DIDEVICE_TYPE(pdosd->dwDevType)) &&
           fLimpFF(pde->dwVer <= 0x0300,
                   LOBYTE(pdosd->dwDevType) != DIDEVTYPE_JOYSTICK))
        {

            PDIDW pdidW;

            hres = IDirectInput_CreateDevice(pde->pdiW, pdosd->rguidInstance,
                                             (PV)&pdidW, 0);
            if(SUCCEEDED(hres))
            {
                if(CDIObj_TestDeviceFlags(pdidW, pde->edfl) == S_OK)
                {

                    pddiW->dwSize = cbX(*pddiW);
                    hres = IDirectInputDevice_GetDeviceInfo(pdidW, pddiW);

                    AssertF(fLimpFF(SUCCEEDED(hres),
                                    IsEqualGUID(pdosd->rguidInstance,
                                                &pddiW->guidInstance)));

                    if(SUCCEEDED(hres))
                    {
                        hres = S_OK;
                    } else
                    {
                        hres = S_SKIP;
                    }

                } else
                {
                    hres = S_SKIP;
                }
                OLE_Release(pdidW);
            } else
            {
                hres = S_SKIP;
            }
        } else
        {
            hres = S_SKIP;
        }
    } while(hres == S_SKIP);

    done:;

    AssertF(hres == S_OK || hres == S_FALSE);

    ScrambleBit(&pddiW->dwDevType, DIDEVTYPE_RANDOM);

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDEnum_New |
 *
 *          Create an enumeration object.
 *
 *          The enumeration object snapshots the system device state
 *          and farms them out one at a time.
 *
 *  @parm   PDIW | pdiW |
 *
 *          Parent <i IDirectInputW> we piggyback off of for device
 *          creation.
 *
 *  @field  DWORD | dwDevType |
 *
 *          Device type filter.
 *
 *  @field  DWORD | edfl |
 *
 *          Enumeration flags.
 *
 *  @field  DWORD | dwVer |
 *
 *          Version of DirectX we are emulating.
 *
 *          If we are emulating DirectX 3.0 or less, then don't
 *          reveal joysticks.
 *
 *  @parm   CDIDEnum ** | ppde |
 *
 *          Receives the enumeration object.
 *
 *  @returns
 *
 *          Returns <c S_OK> on success or an error code on failure.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDEnum_New(PDIW pdiW, DWORD dwDevType, DWORD edfl, DWORD dwVer, PPDENUM ppde)
{
    HRESULT hres;
    EnterProcI(CDIDEnum_New, (_ "pxx", pdiW, dwDevType, edfl));

    #ifdef HID_SUPPORT
    /*
     *  Refresh the HID device list so the enumeration is fresh.
     */
    DIHid_BuildHidList(TRUE);
    #endif

    hres = AllocCbPpv(cbX(CDIDEnum), ppde);
    if(SUCCEEDED(hres))
    {
        PDENUM pde = *ppde;

        D(pde->dwSig = CDIDENUM_SIGNATURE);
        pde->pdiW = pdiW;
        pde->dwDevType = dwDevType;
        pde->edfl = edfl;
        pde->dwVer = dwVer;
        AssertF(pde->idosdStatic == 0);
    #ifdef HID_SUPPORT

        /*
         *  If enumerating only HID devices, then skip over all
         *  the static (non-HID) devices.  This is important so
         *  we don't go into infinite recursion death with WINMM.DLL,
         *  which does an enumeration to find HID joysticks
         *  in the first place.
         */
        if(pde->dwDevType & DIDEVTYPE_HID)
        {
            pde->idosdStatic = cA(c_rgdosdStatic);
        }

        AssertF(pde->idosdDynamic == 0);
    #endif

    #ifdef HID_SUPPORT
        /*
         *  Clone the device list.  This must be done under the
         *  critical section to avoid races.
         */
        DllEnterCrit();
        if(g_phdl)
        {
            hres = AllocCbPpv(cbHdlChdi(g_phdl->chdi), &pde->phdl);
            if(SUCCEEDED(hres))
            {
                CopyMemory(pde->phdl, g_phdl, cbHdlChdi(g_phdl->chdi));
                SquirtSqflPtszV(sqfl, TEXT("%S: Have %d HID devices"),
                                s_szProc, pde->phdl->chdi);
                hres = S_OK;
            }
        } else
        {
            hres = S_OK;
        }
        DllLeaveCrit();

        if(SUCCEEDED(hres))
        {
            OLE_AddRef(pde->pdiW);
            hres = S_OK;
        }
    #else
        OLE_AddRef(pde->pdiW);
        hres = S_OK;
    #endif

    }

    ExitOleProcPpv(ppde);
    return hres;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\didevef.c ===
/*****************************************************************************
 *
 *  DIDevEf.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The part of IDirectInputDevice that worries about
 *      IDirectInputEffect.
 *
 *****************************************************************************/

#include "dinputpr.h"
#include "didev.h"

#ifdef IDirectInputDevice2Vtbl

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | CreateEffectDriver |
 *
 *          If we don't already have one, create the effect
 *          driver shepherd
 *          so we can do force feedback goo.  If we already
 *          have one, then there's nothing to do.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device does
 *          not support force feeback, or there was an error loading
 *          the force feedback driver.
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIDev_CreateEffectDriver(PDD this)
{
    HRESULT hres;

    CDIDev_EnterCrit(this);

    if (this->pes) {
        hres = S_OK;
    } else {
        hres = this->pdcb->lpVtbl->CreateEffect(this->pdcb, &this->pes);

        /*
         *  If we have acquisition, then do a force feedback
         *  acquire to get everything back in sync.
         */
        if (SUCCEEDED(hres) && this->fAcquired) {
            CDIDev_FFAcquire(this);
            hres = S_OK;
        }
    }

    CDIDev_LeaveCrit(this);

    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice2 | CreateEffect |
 *
 *          Creates and initializes an instance of an effect
 *          identified by the effect GUID.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN REFGUID | rguid |
 *
 *          The identity of the effect to be created.  This can be
 *          a predefined effect GUID, or it can be a GUID obtained
 *          from <mf IDirectInputDevice2::EnumEffects>.
 *
 *  @parm   IN LPCDIEFFECT | lpeff |
 *
 *          Pointer to a <t DIEFFECT> structure which provides
 *          parameters for the created effect.  This parameter
 *          is optional.  If it is <c NULL>, then the effect object
 *          is created without parameters.  The application must
 *          call <mf IDirectInputEffect::SetParameters> to set
 *          the parameters of the effect before it can download
 *          the effect.
 *
 *  @parm   OUT LPDIRECTINPUTEFFECT * | ppdeff |
 *
 *          Points to where to return
 *          the pointer to the <i IDirectInputEffect> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter |
 *
 *          Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The object was created and initialized
 *          successfully.
 *
 *          <c DI_TRUNCATED>: The effect was successfully created,
 *          but some of the effect parameters were
 *          beyond the capabilities of the device and were truncated
 *          to the nearest valid value.
 *          Note that this is a success code, because the effect was
 *          successfully created.
 *
 *          <c DIERR_DEVICENOTREG>: The effect GUID is not supported
 *          by the device.
 *
 *          <c DIERR_DEVICEFULL>: The device is full.
 *
 *          <c DIERR_INVALIDPARAM>: At least one of the parameters
 *          was invalid.
 *
 *
 *  @devnote
 *
 *          Future versions of DirectX will allow <p lpeff> to be NULL,
 *          indicating that the effect should not be initialized.
 *          This is important to support effects which are created
 *          but which aren't downloaded until the app explicitly
 *          requests it.
 *
 *****************************************************************************/

/*
 *  Helper function which decides how many parameters to set,
 *  based on the incoming DIEFFECT structure.
 */
DWORD INLINE
CDIDev_DiepFromPeff(LPCDIEFFECT peff)
{
#if DIRECTINPUT_VERSION >= 0x0600
    /*
     *  If we received a DIEFFECT_DX5, then we need to
     *  pass DIEP_ALLPARAMS_DX5 instead of DIEP_ALLPARAMS.
     */
    return peff->dwSize < cbX(DIEFFECT_DX6)
                        ? DIEP_ALLPARAMS_DX5
                        : DIEP_ALLPARAMS;
#else
    return DIEP_ALLPARAMS;
#endif
}

STDMETHODIMP
CDIDev_CreateEffect(PV pdd, REFGUID rguid, LPCDIEFFECT peff,
                    LPDIRECTINPUTEFFECT *ppdeff, LPUNKNOWN punkOuter _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice2::CreateEffect,
               (_ "pGpp", pdd, rguid, peff, punkOuter));

    /*
     *  CDIEff_New will validate the ppdeff and punkOuter, but
     *  we need to validate ppdeff because we're going to
     *  shove a zero into it.
     *
     *  We also need to check peff->dwSize as we need to test it 
     *  before calling IDirectInputEffect_SetParameters.
     *
     *  CDIEff_Initialize will validate the rguid.
     *
     *  CDIEff_SetParameters will validate the peff.
     */
    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = (peff && IsBadReadPtr(&peff->dwSize, cbX(peff->dwSize))) ? E_POINTER : S_OK) &&
        SUCCEEDED(hres = hresFullValidPcbOut(ppdeff, cbX(*ppdeff), 4))) {

        PDD this = _thisPv(pdd);

        hres = CDIDev_CreateEffectDriver(this);

        *ppdeff = 0;                /* If CDIDev_CreateEffectDriver fails */

        if (SUCCEEDED(hres)) {

            hres = CDIEff_New(this, this->pes, punkOuter,
                              &IID_IDirectInputEffect, (PPV)ppdeff);

            /*
             *  We assume that IDirectInputEffect is the primary interface.
             */
            AssertF(fLimpFF(SUCCEEDED(hres),
                            (PV)*ppdeff == _thisPv(*ppdeff)));

            if (SUCCEEDED(hres) && punkOuter == 0) {
                LPDIRECTINPUTEFFECT pdeff = *ppdeff;

                hres = IDirectInputEffect_Initialize(pdeff, g_hinst,
                                                     this->dwVersion, rguid);
                if (SUCCEEDED(hres)) {
                    if (fLimpFF(peff,
                                SUCCEEDED(hres =
                                    IDirectInputEffect_SetParameters(
                                        pdeff, peff,
                                        CDIDev_DiepFromPeff(peff))))) {
                        /*
                         *  Woo-hoo, all is well.
                         */
                        hres = S_OK;
                    } else {
                        Invoke_Release(ppdeff);
                    }
                } else {
                    /*
                     *  Error initializing.
                     */
                    Invoke_Release(ppdeff);
                }
            } else {
                /*
                 *  Error creating, or object is aggregated and therefore
                 *  should not be initialized.
                 */
            }
        } else {
            /*
             *  Error creating effect driver, or no effect driver.
             */
        }
    }

    ExitOleProcPpv(ppdeff);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | SyncShepHandle |
 *
 *          Synchronize the caller's <t SHEPHANDLE> with the
 *          <t SHEPHANDLE> of the parent.  This lets
 *          dieshep.c know that the two are talking about the same thing.
 *
 *  @cwrap  PDD | this
 *
 *  @returns
 *          Returns <c S_OK> if the tags already matched,
 *          or <c S_FALSE> if the tag changed.  If the tag changed,
 *          then the handle inside the <t SHEPHANDLE> is zero'd.
 *
 *          Note that <f CDIEff_DownloadWorker> assumes that the
 *          return value is exactly <c S_OK> or <c S_FALSE>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_SyncShepHandle(PDD this, PSHEPHANDLE psh)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this));

    if (psh->dwTag == this->sh.dwTag) {
        hres = S_OK;
    } else {
        psh->dwTag = this->sh.dwTag;
        psh->dwEffect = 0;
        hres = S_FALSE;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | NotifyCreateEffect |
 *
 *          Add the effect pointer to the list of effects that
 *          have been created by the device.
 *
 *          The device critical section must not be owned by the
 *          calling thread.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   IN struct CDIEff * | pdeff |
 *
 *          The effect pointer to add.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: Everything is okay.
 *
 *          <c DIERR_OUTOFMEMORY> =
 *          <c E_OUTOFMEMORY>: No memory to record the effect.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CDIDev_NotifyCreateEffect(PDD this, struct CDIEff *pdeff)
{
    HRESULT hres;

    AssertF(!CDIDev_InCrit(this));

    CDIDev_EnterCrit(this);
    hres = GPA_Append(&this->gpaEff, pdeff);

    CDIDev_LeaveCrit(this);

    /*
     *  Note that we must leave the device critical section
     *  before talking to the effect, in order to preserve
     *  the synchronization hierarchy.
     */
    if (SUCCEEDED(hres)) {
        Common_Hold(pdeff);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | NotifyDestroyEffect |
 *
 *          Remove the effect pointer from the list of effects that
 *          have been created by the device.
 *
 *          The device critical section must not be owned by the
 *          calling thread.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   IN struct CDIEff * | pdeff |
 *
 *          The effect pointer to remove.
 *
 *  @returns
 *
 *          Returns a COM error code on failure.
 *
 *          On success, returns the number of items left in the GPA.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CDIDev_NotifyDestroyEffect(PDD this, struct CDIEff *pdeff)
{
    HRESULT hres;

    AssertF(!CDIDev_InCrit(this));

    CDIDev_EnterCrit(this);
    hres = GPA_DeletePtr(&this->gpaEff, pdeff);

    CDIDev_LeaveCrit(this);

    /*
     *  Note that we must leave the device critical section
     *  before talking to the effect, in order to preserve
     *  the synchronization hierarchy.
     *
     *  Note that there you might think there's a deadlock here if
     *  effect A notifies us, and we in turn try to unhold
     *  effect B.  But that won't happen, because we only
     *  unhold the effect that notified us.
     */
    if (SUCCEEDED(hres)) {
        Common_Unhold(pdeff);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | FindEffectGUID |
 *
 *          Look for an effect <t GUID>; if found, fetch associated
 *          information.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   REFGUID | rguid |
 *
 *          Effect <t GUID> to locate.
 *
 *  @parm   PEFFECTMAPINFO | pemi |
 *
 *          Receives associated information for the effect.
 *          We must return a copy instead of a pointer, because
 *          the original might disappear suddenly if the
 *          device gets <mf CDIDev::Reset>().
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:  Out of memory.
 *
 *          <c DIERR_DEVICENOTREG> = <c REGDB_E_CLASSNOTREG>:
 *          The effect is not supported by the device.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_FindEffectGUID_(PDD this, REFGUID rguid, PEFFECTMAPINFO pemi,
                       LPCSTR s_szProc, int iarg)
{
    UINT iemi;
    HRESULT hres;

  D(iarg);

    CDIDev_EnterCrit(this);

    for (iemi = 0; iemi < this->cemi; iemi++) {
        if (IsEqualGUID(rguid, &this->rgemi[iemi].guid)) {
            *pemi = this->rgemi[iemi];
            hres = S_OK;
            goto found;
        }
    }

    RPF("%s: Effect not supported by device", s_szProc);
    hres = DIERR_DEVICENOTREG;      /* Effect not found */

found:;

    CDIDev_LeaveCrit(this);

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIDev | GetEffectInfoHelper |
 *
 *          Transfer information from an
 *          <t EFFECTMAPINFO> to a <t DIEFFECTINFOW>.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   LPDIEFFECTINFOW | pdeiW |
 *
 *          Destination.
 *
 *  @parm   PCEFFECTMAPINFO | pemi |
 *
 *          Source.
 *
 *****************************************************************************/

void INTERNAL
CDIDev_GetEffectInfoHelper(PDD this, LPDIEFFECTINFOW pdeiW,
                           PCEFFECTMAPINFO pemi)
{
    AssertF(pdeiW->dwSize == cbX(*pdeiW));

    pdeiW->guid            = pemi->guid;
    pdeiW->dwEffType       = pemi->attr.dwEffType;
    pdeiW->dwStaticParams  = pemi->attr.dwStaticParams;
    pdeiW->dwDynamicParams = pemi->attr.dwDynamicParams;
    CAssertF(cbX(pdeiW->tszName) == cbX(pemi->wszName));
    CopyMemory(pdeiW->tszName, pemi->wszName, cbX(pemi->wszName));
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice2 | EnumEffects |
 *
 *          Enumerates all of the effects supported by the force
 *          feedback system on the device.  The enumerated GUIDs
 *          may represent predefined effects as well as effects
 *          peculiar to the device manufacturer.
 *
 *          An application
 *          can use the <e DIEFFECTINFO.dwEffType> field of the
 *          <t DIEFFECTINFO> structure to obtain general
 *          information about the effect, such as its type and
 *          which envelope and condition parameters are supported
 *          by the effect.
 *
 *          In order to exploit an effect to its fullest,
 *          you must contact the device manufacturer to obtain
 *          information on the semantics of the effect and its
 *          effect-specific parameters.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPDIENUMEFFECTSCALLBACK | lpCallback |
 *
 *          Points to an application-defined callback function.
 *          For more information, see the description of the
 *          <f DIEnumEffectsProc> callback function.
 *
 *  @parm   LPVOID | pvRef |
 *
 *          Specifies a 32-bit application-defined
 *          value to be passed to the callback function.  This value
 *          may be any 32-bit value; it is prototyped as an <t LPVOID>
 *          for convenience.
 *
 *  @parm   DWORD | dwEffType |
 *
 *          Effect type filter.  If <c DIEFT_ALL>, then all
 *          effect types are
 *          enumerated.  Otherwise, it is a <c DIEFT_*> value,
 *          indicating the device type that should be enumerated.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p fl> parameter contains invalid flags, or the callback
 *          procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumEffectsProc |
 *
 *          An application-defined callback function that receives
 *          device effects as a result of a call to the
 *          <om IDirectInputDevice2::EnumEffects> method.
 *
 *  @parm   IN LPCDIEFFECTINFO | pdei |
 *
 *          A <t DIEFFECTINFO> structure that describes the enumerated
 *          effect.
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputDevice2::EnumEffects> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *//**************************************************************************
 *
 *      In DEBUG/RDEBUG, if the callback returns a bogus value, raise
 *      a validation exception.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_EnumEffectsW
    (PV pddW, LPDIENUMEFFECTSCALLBACKW pecW, PV pvRef, DWORD dwEffType)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice2W::EnumEffects,
               (_ "pppx", pddW, pecW, pvRef, dwEffType));

    if (SUCCEEDED(hres = hresPvW(pddW)) &&
        SUCCEEDED(hres = hresFullValidPfn(pecW, 1)) &&
        SUCCEEDED(hres = hresFullValidFl(dwEffType, DIEFT_ENUMVALID, 3))) {

        PDD this = _thisPvNm(pddW, ddW);
        PEFFECTMAPINFO rgemi;
        UINT iemi, cemi;


        /*
         *  We need to make a private copy of the GUID list,
         *  because somebody else might suddenly Reset() the
         *  device and mess up everything.
         *
         *  Indeed, it might've been Reset() during this comment!
         *  That's why we need to create the private copy
         *  while under the critical section.
         */

        CDIDev_EnterCrit(this);

        cemi = this->cemi;
        hres = AllocCbPpv(cbCxX(this->cemi, EFFECTMAPINFO), &rgemi);

        if (SUCCEEDED(hres)) {
            if (this->cemi) {
                CopyMemory(rgemi, this->rgemi,
                           cbCxX(this->cemi, EFFECTMAPINFO));
            }
        }

        CDIDev_LeaveCrit(this);

        if (SUCCEEDED(hres)) {
            for (iemi = 0; iemi < cemi; iemi++) {
                PEFFECTMAPINFO pemi = &rgemi[iemi];
                if (fLimpFF(dwEffType,
                            dwEffType == LOBYTE(pemi->attr.dwEffType))) {
                    BOOL fRc;
                    DIEFFECTINFOW deiW;

                    deiW.dwSize = cbX(deiW);
                    CDIDev_GetEffectInfoHelper(this, &deiW, pemi);

                    fRc = Callback(pecW, &deiW, pvRef);

                    switch (fRc) {
                    case DIENUM_STOP: goto enumdoneok;
                    case DIENUM_CONTINUE: break;
                    default:
                        RPF("%s: Invalid return value from callback", s_szProc);
                        ValidationException();
                        break;
                    }
                }
            }

        enumdoneok:;

            FreePpv(&rgemi);
            hres = S_OK;

        }

    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice2A | EnumEffectsCallbackA |
 *
 *          Custom callback that wraps
 *          <mf IDirectInputDevice2::EnumObjects> which
 *          translates the UNICODE string to an ANSI string.
 *
 *  @parm   IN LPCDIEFFECTINFOA | pdoiA |
 *
 *          Structure to be translated to ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Pointer to <t struct ENUMEFFECTSINFO> which describes
 *          the original callback.
 *
 *  @returns
 *
 *          Returns whatever the original callback returned.
 *
 *****************************************************************************/

typedef struct ENUMEFFECTSINFO {
    LPDIENUMEFFECTSCALLBACKA pecA;
    PV pvRef;
} ENUMEFFECTSINFO, *PENUMEFFECTSINFO;

BOOL CALLBACK
CDIDev_EnumEffectsCallbackA(LPCDIEFFECTINFOW pdeiW, PV pvRef)
{
    PENUMEFFECTSINFO peei = pvRef;
    BOOL fRc;
    DIEFFECTINFOA deiA;
    EnterProc(CDIObj_EnumObjectsCallbackA,
              (_ "GxWp", &pdeiW->guid,
                         &pdeiW->dwEffType,
                          pdeiW->tszName, pvRef));

    deiA.dwSize = cbX(deiA);
    EffectInfoWToA(&deiA, pdeiW);

    fRc = peei->pecA(&deiA, peei->pvRef);

    ExitProcX(fRc);
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice2A | EnumEffects |
 *
 *          Enumerate the effects available on a device, in ANSI.
 *          See <mf IDirectInputDevice2::EnumEffects> for more information.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN LPDIENUMEFFECTSCALLBACKA | lpCallback |
 *
 *          Same as <mf IDirectInputDevice2W::EnumObjects>, except in ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Same as <mf IDirectInputDevice2W::EnumObjects>.
 *
 *  @parm   IN DWORD | fl |
 *
 *          Same as <mf IDirectInputDevice2W::EnumObjects>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_EnumEffectsA
    (PV pddA, LPDIENUMEFFECTSCALLBACKA pecA, PV pvRef, DWORD dwEffType)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice2A::EnumEffects,
               (_ "pppx", pddA, pecA, pvRef, dwEffType));

    /*
     *  EnumEffectsW will validate the rest.
     */
    if (SUCCEEDED(hres = hresPvA(pddA)) &&
        SUCCEEDED(hres = hresFullValidPfn(pecA, 1))) {
        ENUMEFFECTSINFO eei = { pecA, pvRef };
        PDD this = _thisPvNm(pddA, ddA);

        hres = CDIDev_EnumEffectsW(&this->ddW, CDIDev_EnumEffectsCallbackA,
                                   &eei, dwEffType);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice2 | GetEffectInfo |
 *
 *          Obtains information about an effect.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIEFFECTINFO | pdei |
 *
 *          Receives information about the effect.
 *          The caller "must" initialize the <e DIEFFECTINFO.dwSize>
 *          field before calling this method.
 *
 *  @parm   REFGUID | rguid |
 *
 *          Identifies the effect for which information is being requested.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_DEVICENOTREG>: The effect GUID does not exist
 *          on the current device.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetEffectInfoW(PV pddW, LPDIEFFECTINFOW pdeiW, REFGUID rguid)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice2W::GetEffectInfo,
               (_ "ppG", pddW, pdeiW, rguid));

    if (SUCCEEDED(hres = hresPvW(pddW)) &&
        SUCCEEDED(hres = hresFullValidWritePxCb(pdeiW,
                                                DIEFFECTINFOW, 1))) {
        PDD this = _thisPvNm(pddW, ddW);
        EFFECTMAPINFO emi;

        if (SUCCEEDED(hres = CDIDev_FindEffectGUID(this, rguid, &emi, 2))) {

            CDIDev_GetEffectInfoHelper(this, pdeiW, &emi);
            hres = S_OK;
        }

        if (FAILED(hres)) {
            ScrambleBuf(&pdeiW->guid,
                cbX(DIEFFECTINFOW) - FIELD_OFFSET(DIEFFECTINFOW, guid));
        }
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice2A | GetEffectInfo |
 *
 *          ANSI version of same.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIEFFECTINFO | pdei |
 *
 *          Receives information about the effect.
 *          The caller "must" initialize the <e DIEFFECTINFO.dwSize>
 *          field before calling this method.
 *
 *  @parm   REFGUID | rguid |
 *
 *          Identifies the effect for which information is being requested.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_DEVICENOTREG>: The effect GUID does not exist
 *          on the current device.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetEffectInfoA(PV pddA, LPDIEFFECTINFOA pdeiA, REFGUID rguid)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice2A::GetEffectInfo,
               (_ "ppG", pddA, pdeiA, rguid));

    if (SUCCEEDED(hres = hresPvA(pddA)) &&
        SUCCEEDED(hres = hresFullValidWritePxCb(pdeiA,
                                                DIEFFECTINFOA, 1))) {
        PDD this = _thisPvNm(pddA, ddA);
        DIEFFECTINFOW deiW;

        deiW.dwSize = cbX(deiW);

        hres = CDIDev_GetEffectInfoW(&this->ddW, &deiW, rguid);

        if (SUCCEEDED(hres)) {
            EffectInfoWToA(pdeiA, &deiW);
            hres = S_OK;
        } else {
            ScrambleBuf(&pdeiA->guid,
                cbX(DIEFFECTINFOA) - FIELD_OFFSET(DIEFFECTINFOA, guid));
        }
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice2 | GetForceFeedbackState |
 *
 *          Retrieves the state of the device's force feedback system.
 *          The device must be acquired for this method to succeed.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPDWORD | pdwOut |
 *
 *          Receives a <t DWORD> of flags which describe the current
 *          state of the device's force feedback system.
 *
 *          The value is a combination of zero or more <c DIGFFS_*>
 *          flags.
 *
 *          Note that future versions of DirectInput may define
 *          additional flags.  Applications should ignore any flags
 *          that are not currently defined.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p pdwOut> parameter is not a valid pointer.
 *
 *          <c DIERR_INPUTLOST>: Acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetForceFeedbackState(PV pdd, LPDWORD pdwOut _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice2::GetForceFeedbackState, (_ "p", pdd));

    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = hresFullValidPcbOut(pdwOut, cbX(*pdwOut), 1))) {
        PDD this = _thisPv(pdd);

        /*
         *  I just know people aren't going to check the error code,
         *  so don't let them see garbage.
         */
        *pdwOut = 0;

        hres = CDIDev_CreateEffectDriver(this);

        if (SUCCEEDED(hres)) {
            DIDEVICESTATE ds;

            CDIDev_EnterCrit(this);

            /*
             *  Note that it isn't necessary to check
             *  CDIDev_IsExclAcquired(), because the effect shepherd
             *  will deny us access to a device we don't own.
             *
             *  ISSUE-2001/03/29-timgill need to handle DIERR_INPUTLOST case
             */

            ds.dwSize = cbX(ds);
            hres = this->pes->lpVtbl->
                         GetForceFeedbackState(this->pes, &this->sh, &ds);
            /*
             *  We put as many flags in matching places in
             *  DISFFC_* and DIGFFS_* because I just know
             *  app writers are going to mess it up.
             */
            if (SUCCEEDED(hres)) {

                CAssertF(DISFFC_RESET           == DIGFFS_EMPTY);
                CAssertF(DISFFC_STOPALL         == DIGFFS_STOPPED);
                CAssertF(DISFFC_PAUSE           == DIGFFS_PAUSED);
                CAssertF(DISFFC_SETACTUATORSON  == DIGFFS_ACTUATORSON);
                CAssertF(DISFFC_SETACTUATORSOFF == DIGFFS_ACTUATORSOFF);

                *pdwOut = ds.dwState;
                hres = S_OK;
            }

            CDIDev_LeaveCrit(this);

        }
        ScrambleBit(pdwOut, DIGFFS_RANDOM);

    }

    /*
     *  Can't use ExitOleProcPpv here because pdwOut might have
     *  DIFFS_RANDOM set in it, even on error.
     */
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice2 | SendForceFeedbackCommand |
 *
 *          Sends a command to the the device's force feedback system.
 *          The device must be acquired for this method to succeed.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   DWORD | dwCommand |
 *
 *          One of the <c DISFFC_*> values indicating
 *          the command to send.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p dwFlags> parameter is invalid.
 *
 *          <c DIERR_INPUTLOST>: Acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

HRESULT INLINE
CDIDev_SendForceFeedbackCommand_IsValidCommand(DWORD dwCmd)
{
    HRESULT hres;
 RD(static char s_szProc[] = "IDirectInputDevice2::SendForceFeedbackCommand");

    /*
     *  dwCmd must not be zero (therefore at least one bit set).
     *  !(dwCmd & (dwCmd - 1)) checks that at most one bit is set.
     *  (dwCmd & ~DISFFC_VALID) checks that no bad bits are set.
     */
    if (dwCmd && !(dwCmd & ~DISFFC_VALID) && !(dwCmd & (dwCmd - 1))) {

        hres = S_OK;

    } else {
        RPF("ERROR %s: arg %d: invalid command", s_szProc, 1);
        hres = E_INVALIDARG;
    }
    return hres;
}

STDMETHODIMP
CDIDev_SendForceFeedbackCommand(PV pdd, DWORD dwCmd _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice2::SendForceFeedbackCommand,
               (_ "px", pdd, dwCmd));

    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = CDIDev_SendForceFeedbackCommand_IsValidCommand
                                                                (dwCmd))) {
        PDD this = _thisPv(pdd);

        hres = CDIDev_CreateEffectDriver(this);

        if (SUCCEEDED(hres)) {

            CDIDev_EnterCrit(this);

            /*
             *  Note that it isn't necessary to check
             *  CDIDev_IsExclAcquired(), because the effect shepherd
             *  will deny us access to a device we don't own.
             *
             *  ISSUE-2001/03/29-timgill need to handle DIERR_INPUTLOST case
             */

            hres = this->pes->lpVtbl->
                        SendForceFeedbackCommand(this->pes,
                                                 &this->sh, dwCmd);

            if (SUCCEEDED(hres) && (dwCmd & DISFFC_RESET)) {
                /*
                 *  Re-establish the gain after a reset.
                 */
                CDIDev_RefreshGain(this);
            }

            CDIDev_LeaveCrit(this);

        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice2 | EnumCreatedEffectObjects |
 *
 *          Enumerates all of the currently created effect objects for
 *          this device.  Effect objects created via
 *          <mf IDirectInputDevice::CreateEffect>
 *          are enumerated.
 *
 *          Note that results will be unpredictable if you destroy
 *          or create an effect object while an enumeration is in progress.
 *          The sole exception is that the callback function itself
 *          <f DIEnumCreatedEffectObjectsProc> is permitted to
 *          <mf IDirectInputEffect::Release> the effect that it is
 *          passed as its first parameter.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN LPDIENUMCREATEDEFFECTOBJECTSCALLBACK | lpCallback |
 *
 *          Callback function.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Reference data (context) for callback.
 *
 *  @parm   IN DWORD | fl |
 *
 *          No flags are currently defined.  This parameter must be 0.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p fl> parameter contains invalid flags, or the callback
 *          procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumCreatedEffectObjectsProc |
 *
 *          An application-defined callback function that receives
 *          IDirectInputEffect effect objects as a result of a call to the
 *          <om IDirectInputDevice2::EnumCreatedEffects> method.
 *
 *  @parm   LPDIRECTINPUTEFFECT | peff |
 *
 *          A pointer to an effect object that has been created.
 *
 *  @parm   LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputDevice2::EnumCreatedEffectObjects> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_EnumCreatedEffectObjects(PV pdd,
                          LPDIENUMCREATEDEFFECTOBJECTSCALLBACK pec,
                          LPVOID pvRef, DWORD fl _THAT)

{
    HRESULT hres;
    EnterProcR(IDirectInputDevice2::EnumCreatedEffects,
               (_ "ppx", pdd, pec, fl));

    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = hresFullValidPfn(pec, 1)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, DIECEFL_VALID, 3))) {
        PDD this = _thisPv(pdd);
        GPA gpaEff;

        CDIDev_EnterCrit(this);

        /*
         *  We must snapshot the list to make sure we don't run
         *  with a stale handle later.  Actually, we also need
         *  to Hold the guys as we transfer them across so they
         *  won't vanish until we're ready.
         *
         *  Note: It is important that we Hold and not AddRef,
         *  because AddRef will talk to the controlling unknown,
         *  which is not safe to do while holding a critical
         *  section.
         */

        hres = GPA_Clone(&gpaEff, &this->gpaEff);

        if (SUCCEEDED(hres)) {
            int ipv;

            for (ipv = 0; ipv < gpaEff.cpv; ipv++) {
                Common_Hold(gpaEff.rgpv[ipv]);
            }
        }

        CDIDev_LeaveCrit(this);

        if (SUCCEEDED(hres)) {
            int ipv;

            for (ipv = 0; ipv < gpaEff.cpv; ipv++) {
                BOOL fRc;

                fRc = Callback(pec, gpaEff.rgpv[ipv], pvRef);

                switch (fRc) {
                case DIENUM_STOP: goto enumdoneok;
                case DIENUM_CONTINUE: break;
                default:
                    RPF("%s: Invalid return value from callback",
                        s_szProc);
                    ValidationException();
                    break;
                }

            }

        enumdoneok:;

            for (ipv = 0; ipv < gpaEff.cpv; ipv++) {
                Common_Unhold(gpaEff.rgpv[ipv]);
            }

            GPA_Term(&gpaEff);
        }

        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | GetLoad |
 *
 *          Retrieve the memory load setting for the device.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   LPDWORD | pdwLoad |
 *
 *          Receives memory load.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetLoad(PDD this, LPDWORD pdwOut)
{
    HRESULT hres;
    EnterProc(CDIDev_GetLoad, (_ "p", this));

    hres = CDIDev_CreateEffectDriver(this);

    if (SUCCEEDED(hres)) {
        DIDEVICESTATE ds;

        CDIDev_EnterCrit(this);

        /*
         *  Note that it isn't necessary to check
         *  CDIDev_IsExclAcquired(), because the effect shepherd
         *  will deny us access to a device we don't own.
         *
         *  ISSUE-2001/03/29-timgill need to handle DIERR_INPUTLOST case
         */

        ds.dwSize = cbX(ds);
        hres = this->pes->lpVtbl->
                    GetForceFeedbackState(this->pes, &this->sh, &ds);

        *pdwOut = ds.dwLoad;

        CDIDev_LeaveCrit(this);

    }

    /*
     *  Can't use ExitOleProcPpv here because pdwOut is garbage on error.
     */
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | Escape |
 *
 *          Send a hardware-specific command to the driver.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Pointer to a <t DIEFFESCAPE> structure which describes
 *          the command to be sent.  On success, the
 *          <e DIEFFESCAPE.cbOutBuffer> field contains the number
 *          of bytes of the output buffer actually used.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_Escape(PV pdd, LPDIEFFESCAPE pesc _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice2::Escape, (_ "p", pdd));

    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = hresFullValidPesc(pesc, 1))) {
        PDD this = _thisPv(pdd);

        AssertF(this->sh.dwEffect == 0);

        hres = CDIDev_CreateEffectDriver(this);

        if (SUCCEEDED(hres)) {

            CDIDev_EnterCrit(this);

            /*
             *  Note that it isn't necessary to check
             *  CDIDev_IsExclAcquired(), because the effect shepherd
             *  will deny us access to a device we don't own.
             *
             *  ISSUE-2001/03/29-timgill Need to handle DIERR_INPUTLOST case
             */

            hres = IDirectInputEffectShepherd_DeviceEscape(
                                    this->pes, &this->sh, pesc);

            CDIDev_LeaveCrit(this);

        }

    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | RefreshGain |
 *
 *          Set the device gain setting appropriately.
 *
 *          The device shepherd will take care of muxing in the
 *          global gain.
 *
 *  @cwrap  PDD | this
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_RefreshGain(PDD this)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this));

    if (this->pes) {
        hres = this->pes->lpVtbl->SetGain(this->pes, &this->sh, this->dwGain);
    } else {
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIDev | SnapOneEffect |
 *
 *          Read one force feedback effect key and record the
 *          information stored therein.  We also tally the
 *          flag into the <e CDIDev.didcFF> so we can return
 *          the global flags from <mf IDirectInputDevice::GetCapabilities>.
 *
 *          The <e CDIDev.rgemi> field already points to a
 *          preallocated array
 *          of <t EFFECTMAPINFO> structures, and
 *          the <e CDIDev.cemi> field contains the number
 *          of entries in that array which are already in use.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   HKEY | hkEffects |
 *
 *          The registry key containing the effects.
 *
 *  @parm   DWORD | iKey |
 *
 *          Index number of the subkey.
 *
 *  @returns
 *
 *          None.
 *
 *          If the specified subkey is damaged, it is skipped.
 *
 *****************************************************************************/

void INTERNAL
CDIDev_SnapOneEffect(PDD this, HKEY hkEffects, DWORD ihk)
{
    TCHAR tszGuid[ctchGuid];
    LONG lRc;
    PEFFECTMAPINFO pemi;

    /*
     *  Make sure that DIEFT_* and DIDC_* agree where they overlap.
     */
    CAssertF(DIEFT_FORCEFEEDBACK      == DIDC_FORCEFEEDBACK);
    CAssertF(DIEFT_FFATTACK           == DIDC_FFATTACK);
    CAssertF(DIEFT_FFFADE             == DIDC_FFFADE);
    CAssertF(DIEFT_SATURATION         == DIDC_SATURATION);
    CAssertF(DIEFT_POSNEGCOEFFICIENTS == DIDC_POSNEGCOEFFICIENTS);
    CAssertF(DIEFT_POSNEGSATURATION   == DIDC_POSNEGSATURATION);

    pemi = &this->rgemi[this->cemi];

    /*
     *  First get the GUID for the effect.
     */
    lRc = RegEnumKey(hkEffects, ihk, tszGuid, cA(tszGuid));

    if (lRc == ERROR_SUCCESS &&
        ParseGUID(&pemi->guid, tszGuid)) {
        HKEY hk;

        /*
         *  Note that we don't need to check for duplicates.
         *  The registry itself does not allow two keys to have
         *  the same name.
         */

        lRc = RegOpenKeyEx(hkEffects, tszGuid, 0, KEY_QUERY_VALUE, &hk);
        if (lRc == ERROR_SUCCESS) {

            DWORD cb;

            cb = cbX(pemi->wszName);
            lRc = RegQueryStringValueW(hk, 0, pemi->wszName, &cb);
            if (lRc == ERROR_SUCCESS) {
                HRESULT hres;
                hres = JoyReg_GetValue(hk, TEXT("Attributes"), REG_BINARY,
                                       &pemi->attr, cbX(pemi->attr));
                if (SUCCEEDED(hres) &&
                    (pemi->attr.dwCoords & DIEFF_COORDMASK)) {

                    this->didcFF |= (pemi->attr.dwEffType & DIEFT_VALIDFLAGS);
                    this->cemi++;

                }
            }

            RegCloseKey(hk);
        }
    }
 }

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | InitFF |
 *
 *          Initialize the force-feedback portion of the device.
 *
 *          Collect the force feedback attributes.
 *
 *          Snapshot the list of force feedback effects.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:  Out of memory.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>:  The device
 *          does not support force feedback.
 *
 *****************************************************************************/
STDMETHODIMP
CDIDev_InitFF(PDD this)
{
    HKEY hkFF;
    HRESULT hres;
    EnterProcI(CDIDev_InitFF, (_ "p", this));

    AssertF(this->didcFF == 0);

    hres = this->pdcb->lpVtbl->GetFFConfigKey(this->pdcb,
                             KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                             &hkFF);

    if( hres == S_FALSE )
    {
        /*
         *  Try causing the driver to be loaded so that it can initialize 
         *  the effects in the registry before we proceed.
         * 
         *   Need to exercise caution here. A driver that expects to use this
         *   functionality cannot call into Dinput query for device attributes.
         *   Can result in endless loop where we call the driver and the driver
         *   calls us back
         */
        hres = CDIDev_CreateEffectDriver(this);
        if( SUCCEEDED( hres ) )
        {
            hres = this->pdcb->lpVtbl->GetFFConfigKey(this->pdcb,
                                     KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                     &hkFF);
            if( hres == S_FALSE )
            {
                hres = E_FAIL;
            }
        }
    }

    if (SUCCEEDED(hres)) {
        DWORD chk;
        HKEY hkEffects;
        LONG lRc;
        
        AssertF( hkFF );

        lRc = JoyReg_GetValue(hkFF, TEXT("Attributes"),
                              REG_BINARY, &this->ffattr, cbX(this->ffattr));
        if (lRc != S_OK) {
            ZeroX(this->ffattr);
        }

        lRc = RegOpenKeyEx(hkFF, TEXT("Effects"), 0,
                           KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                           &hkEffects);
        if (lRc == ERROR_SUCCESS) {
            lRc = RegQueryInfoKey(hkEffects, 0, 0, 0, &chk,
                                  0, 0, 0, 0, 0, 0, 0);
            if (lRc == ERROR_SUCCESS) {
                hres = AllocCbPpv(cbCxX(chk, EFFECTMAPINFO),
                                        &this->rgemi);
                if (SUCCEEDED(hres)) {
                    DWORD ihk;

                    this->cemi = 0;
                    for (ihk = 0; ihk < chk; ihk++) {

                        CDIDev_SnapOneEffect(this, hkEffects, ihk);

                    }
                    this->didcFF &= DIDC_FFFLAGS;

                    /*
                     *  Note that we mark DIDC_FORCEFEEDBACK only if
                     *  we actually find any effects.
                     */
                    if (this->cemi) {
                        this->didcFF |= DIDC_FORCEFEEDBACK;
                    }

                    hres = S_OK;
                } else {
                    RPF("Warning: Insufficient memory for force feedback");
                }

            } else {
                hres = E_FAIL;
            }
            RegCloseKey(hkEffects);

        } else {
            hres = E_NOTIMPL;
        }

        RegCloseKey(hkFF);
    }

    ExitBenignOleProc();
    return hres;
}

#endif /* IDirectInputDevice2Vtbl */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dieffj.c ===
/*****************************************************************************
 *
 *  DIEffJ.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Dummy effect driver for joystick.
 *
 *  Contents:
 *
 *      CJoyEff_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

#if defined(IDirectInputDevice2Vtbl) && defined(DEMONSTRATION_FFDRIVER)

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoyEff

/****************************************************************************
 *
 *  @doc    DDK
 *
 *  @topic  DirectInput force feedback effect drivers |
 *
 *          DirectInput instantiates the force feedback effect driver
 *          by creating the object named by the CLSID stored in the
 *          OEMForceFeedback registry subkey of the joystick type
 *          key.
 *
 *          Note, however, that since applications using DirectInput
 *          need not load OLE, the effect driver should be careful
 *          not to rely on OLE-specific behavior.
 *          For example, applications using DirectInput cannot be
 *          relied upon to call <f CoFreeUnusedLibraries>.
 *          DirectInput will perform the standard COM operations to
 *          instantiate the effect driver object.  The only visible
 *          effect this should have on the implementation of the
 *          effect driver is as follows:
 *
 *          When DirectInput has released the last effect driver
 *          object, it will manually perform a <f FreeLibrary> of
 *          the effect driver DLL.  Consequently, if the effect
 *          driver DLL creates additional resources that are not
 *          associated with the effect driver object, it should
 *          manually <f LoadLibrary> itself to artificially
 *          increase its DLL reference count, thereby preventing
 *          the <f FreeLibrary> from DirectInput from unloading
 *          the DLL prematurely.
 *
 *          In particular, if the effect driver DLL creates a worker
 *          thread, the effect driver must perform this artificial
 *          <f LoadLibrary> for as long as the worker thread exists.
 *          When the worker thread is no longer needed (for example, upon
 *          notification from the last effect driver object as it
 *          is being destroyed), the worker thread should call
 *          <f FreeLibraryAndExitThread> to decrement the DLL reference
 *          count and terminate the thread.
 *
 *          All magnitude and gain values used by DirectInput
 *          are uniform and linear across the range.  Any
 *          nonlinearity in the physical device must be
 *          handled by the device driver so that the application
 *          sees a linear device.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CJoyEff_New!
 *
 *****************************************************************************/

Primary_Interface(CJoyEff, IDirectInputEffectDriver);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct JEFFECT |
 *
 *          Dummy structure that records information about an effect.
 *
 *  @field  DWORD | tmDuration |
 *
 *          Putative duration for effect.
 *
 *  @field  DWORD | tmStart |
 *
 *          Time the effect started, or zero if not playing.
 *
 *  @field  BOOL | fInUse |
 *
 *          Nonzero if this effect is allocated.
 *
 *****************************************************************************/

typedef struct JEFFECT {
    DWORD   tmDuration;
    DWORD   tmStart;
    BOOL    fInUse;
} JEFFECT, *PJEFFECT;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CJoyEff |
 *
 *          A dummy <i IDirectInputEffectDriver> object for the
 *          generic joystick.
 *
 *  @field  IDirectInputEffectDriver | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  BOOL | fCritInited:1 |
 *
 *          Set if the critical section has been initialized.
 *
 *  @field  DWORD | state |
 *
 *          The current device state.
 *
 *  @field  LONG | cCrit |
 *
 *          Number of times the critical section has been taken.
 *          Used only in XDEBUG to check whether the caller is
 *          releasing the object while another method is using it.
 *
 *  @field  DWORD | thidCrit |
 *
 *          The thread that is currently in the critical section.
 *          Used only in DEBUG for internal consistency checking.
 *
 *  @field  CRITICAL_SECTION | crst |
 *
 *          Object critical section.  Must be taken when accessing
 *          volatile member variables.
 *
 *  @field  JEFFECT | rgjeff[cjeffMax] |
 *
 *          Information for each effect.
 *
 *****************************************************************************/

#define cjeffMax        8           /* Up to 8 simultaneous effects */

typedef struct CJoyEff {

    /* Supported interfaces */
    IDirectInputEffectDriver ded;

    BOOL fCritInited;

    DWORD state;
    DWORD dwGain;

   RD(LONG cCrit;)
    D(DWORD thidCrit;)
    CRITICAL_SECTION crst;

    JEFFECT rgjeff[cjeffMax];

} CJoyEff, DJE, *PDJE;

typedef IDirectInputEffectDriver DED, *PDED;

#define ThisClass CJoyEff
#define ThisInterface IDirectInputEffectDriver
#define riidExpected &IID_IDirectInputEffectDriver

/*****************************************************************************
 *
 *      CJoyEff::QueryInterface   (from IUnknown)
 *      CJoyEff::AddRef           (from IUnknown)
 *      CJoyEff::Release          (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyEff | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyEff | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CJoyEff)
Default_AddRef(CJoyEff)
Default_Release(CJoyEff)

#else

#define CJoyEff_QueryInterface      Common_QueryInterface
#define CJoyEff_AddRef              Common_AddRef
#define CJoyEff_Release             Common_Release

#endif

#define CJoyEff_QIHelper            Common_QIHelper
#define CJoyEff_AppFinalize         Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CJoyEff_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CJoyEff_Finalize(PV pvObj)
{
    PDJE this = pvObj;

    if (this->fCritInited) {
        DeleteCriticalSection(&this->crst);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoyEff | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @cwrap  PDJE | this
 *
 *****************************************************************************/

void EXTERNAL
CJoyEff_EnterCrit(PDJE this)
{
    EnterCriticalSection(&this->crst);
  D(this->thidCrit = GetCurrentThreadId());
 RD(InterlockedIncrement(&this->cCrit));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoyEff | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *  @cwrap  PDJE | this
 *
 *****************************************************************************/

void EXTERNAL
CJoyEff_LeaveCrit(PDJE this)
{
#ifdef XDEBUG
    AssertF(this->cCrit);
    AssertF(this->thidCrit == GetCurrentThreadId());
    if (InterlockedDecrement(&this->cCrit) == 0) {
      D(this->thidCrit = 0);
    }
#endif
    LeaveCriticalSection(&this->crst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | CJoyEff | InCrit |
 *
 *          Nonzero if we are in the critical section.
 *
 *****************************************************************************/

#ifdef DEBUG

BOOL INTERNAL
CJoyEff_InCrit(PDJE this)
{
    return this->cCrit && this->thidCrit == GetCurrentThreadId();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyEff | IsValidId |
 *
 *          Determine whether the effect pseudo-handle is valid.
 *          If so, returns a pointer to the <t JEFFECT>.
 *
 *  @cwrap  PDJE | this
 *
 *  @parm   DWORD | dwId |
 *
 *          Putative ID number.
 *
 *  @parm   PJEFFECT * | ppjeff |
 *
 *          Receives pointer to the <t JEFFECT> on success.
 *
 *****************************************************************************/

HRESULT INTERNAL
CJoyEff_IsValidId(PDJE this, DWORD dwId, PJEFFECT *ppjeff)
{
    HRESULT hres;

    AssertF(CJoyEff_InCrit(this));

    if (dwId) {
        PJEFFECT pjeff = &this->rgjeff[dwId - 1];
        if (pjeff->fInUse) {
            *ppjeff = pjeff;
            hres = S_OK;
        } else {
            hres = E_HANDLE;
        }
    } else {
        hres = E_HANDLE;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | DeviceID |
 *
 *          Inform the driver of the identity of the device.
 *
 *          For example, if a device driver is passed
 *          <p dwExternalID> = 2 and <p dwInteralID> = 1,
 *          then this means that unit 1 on the device
 *          corresponds to joystick ID number 2.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwDirectInputVersion |
 *
 *          The version of DirectInput that loaded the
 *          effect driver.
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The joystick ID number being used.
 *          The Windows joystick subsystem allocates external IDs.
 *
 *          If the <p lpHIDInfo> field is non-<c NULL> then this
 *          parameter should be ignored.
 *
 *  @parm   DWORD | fBegin |
 *
 *          Nonzero if access to the device is beginning.
 *          Zero if the access to the device is ending.
 *
 *  @parm   DWORD | dwInternalID |
 *
 *          Internal joystick id.  The device driver manages
 *          internal IDs.
 *
 *          If the <p lpHIDInfo> field is non-<c NULL> then this
 *          parameter should be ignored.
 *
 *  @parm   LPVOID | lpHIDInfo |
 *
 *          If the underlying device is not a HID device, then this
 *          parameter is <c NULL>.
 *
 *          If the underlying device is a HID device, then this
 *          parameter points to a <t DIHIDFFINITINFO> structure
 *          which informs the driver of HID information.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_DeviceID(PDED pded, DWORD dwDIVer, DWORD dwExternalID, DWORD fBegin,
                 DWORD dwInternalID, LPVOID pvReserved)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::DeviceID,
               (_ "pxuuu", pded, dwDIVer, dwExternalID, fBegin, dwInternalID));

    this = _thisPvNm(pded, ded);

    dwDIVer;
    dwExternalID;
    fBegin;
    dwInternalID;
    pvReserved;

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | Escape |
 *
 *          Escape to the driver.  This method is called
 *          in response to an application invoking the
 *          <mf IDirectInputDevice2::Escape> or
 *          <mf IDirectInputEffect::Escape> method.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The joystick ID number being used.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          If the application invoked the
 *          <mf IDirectInputEffect::Escape> method, then
 *          <p dwEffect> contains the handle (returned by
 *          <mf IDirectInputEffectDriver::DownloadEffect>)
 *          of the effect at which the command is directed.
 *
 *          If the application invoked the
 *          <mf IDirectInputDevice2::Escape> method, then
 *          <p dwEffect> is zero.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Pointer to a <t DIEFFESCAPE> structure which describes
 *          the command to be sent.  On success, the
 *          <e DIEFFESCAPE.cbOutBuffer> field contains the number
 *          of bytes of the output buffer actually used.
 *
 *          DirectInput has already validated that the
 *          <e DIEFFESCAPE.lpvOutBuffer> and
 *          <e DIEFFESCAPE.lpvInBuffer> and fields
 *          point to valid memory.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_Escape(PDED pded, DWORD dwId, DWORD dwEffect, LPDIEFFESCAPE pesc)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::Escape,
               (_ "puxx", pded, dwId, dwEffect, pesc->dwCommand));

    this = _thisPvNm(pded, ded);

    dwId;
    dwEffect;
    pesc;

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | SetGain |
 *
 *          Set the overall device gain.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The joystick ID number being used.
 *
 *  @parm   DWORD | dwGain |
 *
 *          The new gain value.
 *
 *          If the value is out of range for the device, the device
 *          should use the nearest supported value and return
 *          <c DI_TRUNCATED>.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_SetGain(PDED pded, DWORD dwId, DWORD dwGain)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::SetGain,
               (_ "puu", pded, dwId, dwGain));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    this->dwGain = dwGain;

    CJoyEff_LeaveCrit(this);

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | SendForceFeedbackCommand |
 *
 *          Send a command to the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwCommand |
 *
 *          Command, one of the <c DISFFC_*> values.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_SendForceFeedbackCommand(PDED pded, DWORD dwId, DWORD dwCmd)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::SendForceFeedbackCommand,
               (_ "pux", pded, dwId, dwCmd));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    dwCmd;

    this->state = dwCmd;

    /*
     *  On a reset, all effects are destroyed.
     */
    if (dwCmd & DISFFC_RESET) {
        DWORD ijeff;

        for (ijeff = 0; ijeff < cjeffMax; ijeff++) {
            this->rgjeff[ijeff].fInUse = FALSE;
        }

    }

    CJoyEff_LeaveCrit(this);

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | GetForceFeedbackState |
 *
 *          Retrieve the force feedback state for the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   LPDEVICESTATE | pds |
 *
 *          Receives device state.
 *
 *          DirectInput will set the <e DIDEVICESTATE.dwSize> field
 *          to sizeof(DIDEVICESTATE) before calling this method.
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_GetForceFeedbackState(PDED pded, DWORD dwId, LPDIDEVICESTATE pds)
{
    PDJE this;
    HRESULT hres;
    DWORD ijeff, cjeff, cjeffPlaying;
    EnterProcI(IDirectInputEffectDriver::Joy::GetForceFeedbackState,
               (_ "pup", pded, dwId, pds));

    this = _thisPvNm(pded, ded);

    dwId;
    pds;

    if (pds->dwSize == cbX(*pds)) {
        CJoyEff_EnterCrit(this);

        /*
         *  Count how many effects are in use, and return it as a percentage.
         */
        cjeff = cjeffPlaying = 0;
        for (ijeff = 0; ijeff < cjeffMax; ijeff++) {
            PJEFFECT pjeff = &this->rgjeff[ijeff];
            if (pjeff->fInUse) {
                cjeff++;
                if (pjeff->tmStart &&
                    GetTickCount() - pjeff->tmStart < pjeff->tmDuration) {
                    cjeffPlaying++;
                }
            }
        }

        pds->dwLoad = MulDiv(100, cjeff, cjeffMax);

        /*
         *  If there are no effects downloaded, then we are empty.
         */
        pds->dwState = 0;

        if (cjeff == 0) {
            pds->dwState |= DIGFFS_EMPTY;
        } else

        /*
         *  If there are no effects playing, then we are stopped.
         */
        if (cjeffPlaying == 0) {
            pds->dwState |= DIGFFS_STOPPED;
        }

        /*
         *  Actuators are always on (dumb fake hardware)
         */
        pds->dwState |= DIGFFS_ACTUATORSON;

        CJoyEff_LeaveCrit(this);
        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | DownloadEffect |
 *
 *          Send an effect to the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffectId |
 *
 *          Internal identifier for the effect, taken from
 *          the <t DIEFFECTATTRIBUTES> structure for the effect
 *          as stored in the registry.
 *
 *  @parm   IN OUT LPDWORD | pdwEffect |
 *
 *          On entry, contains the handle of the effect being
 *          downloaded.  If the value is zero, then a new effect
 *          is downloaded.  If the value is nonzero, then an
 *          existing effect is modified.
 *
 *          On exit, contains the new effect handle.
 *
 *          On failure, set to zero if the effect is lost,
 *          or left alone if the effect is still valid with
 *          its old parameters.
 *
 *          Note that zero is never a valid effect handle.
 *
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The new parameters for the effect.  The axis and button
 *          values have been converted to object identifiers
 *          as follows:
 *
 *          - One type specifier:
 *          <c DIDFT_RELAXIS>,
 *          <c DIDFT_ABSAXIS>,
 *          <c DIDFT_PSHBUTTON>,
 *          <c DIDFT_TGLBUTTON>,
 *          <c DIDFT_POV>.
 *
 *          - One instance specifier:
 *          <c DIDFT_MAKEINSTANCE>(n).
 *
 *          Other bits are reserved and should be ignored.
 *
 *          For example, the value 0x0200104 corresponds to
 *          the type specifier <c DIDFT_PSHBUTTON> and
 *          the instance specifier <c DIDFT_MAKEINSTANCE>(1),
 *          which together indicate that the effect should
 *          be associated with button 1.  Axes, buttons, and POVs
 *          are each numbered starting from zero.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIEP_*> flags specifying which
 *          portions of the effect information has changed from
 *          the effect already on the device.
 *
 *          This information is passed to drivers to allow for
 *          optimization of effect modification.  If an effect
 *          is being modified, a driver may be able to update
 *          the effect <y in situ> and transmit to the device
 *          only the information that has changed.
 *
 *          Drivers are not, however, required to implement this
 *          optimization.  All fields in the <t DIEFFECT> structure
 *          pointed to by the <p peff> parameter are valid, and
 *          a driver may choose simply to update all parameters of
 *          the effect at each download.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          This implies that 0 is never a valid effect handle value.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_DownloadEffect(PDED pded, DWORD dwId, DWORD dwEffectId,
                       LPDWORD pdwEffect, LPCDIEFFECT peff, DWORD fl)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::DownloadEffect,
               (_ "puxxpx", pded, dwId, dwEffectId, *pdwEffect, peff, fl));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    fl;

    if (dwEffectId == 1) {

        PJEFFECT pjeff;
        DWORD dwGain;

        /*
         *  Parameter validation goes here, if any.
         *
         *  Envelope parameter is ignored.
         */

        if (peff->cAxes == 0) {     /* Zero axes?  Nice try */
            hres = E_INVALIDARG;
            goto done;
        }

        /*
         *  Pin above-nominal values to DI_FFNOMINALMAX because
         *  we don't support overgain.
         */
        dwGain = min(peff->dwGain, DI_FFNOMINALMAX);

        /*
         *  We do not support triggers.
         */
        if (peff->dwTriggerButton != DIEB_NOTRIGGER) {
            hres = E_NOTIMPL;
            goto done;
        }

        /*
         *  If no downloading in effect, then we're done.
         */
        if (fl & DIEP_NODOWNLOAD) {
            hres = S_OK;
            goto done;
        }

        if (*pdwEffect) {
            hres = CJoyEff_IsValidId(this, *pdwEffect, &pjeff);
            if (FAILED(hres)) {
                goto done;
            }
        } else {
            DWORD ijeff;

            for (ijeff = 0; ijeff < cjeffMax; ijeff++) {
                if (!this->rgjeff[ijeff].fInUse) {
                    this->rgjeff[ijeff].fInUse = TRUE;
                    pjeff = &this->rgjeff[ijeff];
                    goto haveEffect;
                }
            }
            hres = DIERR_DEVICEFULL;
            goto done;
        }

    haveEffect:;

        SquirtSqflPtszV(sqfl, TEXT("dwFlags=%08x"), peff->dwFlags);
        SquirtSqflPtszV(sqfl, TEXT("cAxes=%d"), peff->cAxes);
        for (fl = 0; fl < peff->cAxes; fl++) {
            SquirtSqflPtszV(sqfl, TEXT(" Axis%2d=%08x Direction=%5d"),
                            fl, peff->rgdwAxes[fl],
                                peff->rglDirection[fl]);
        }

        SquirtSqflPtszV(sqfl, TEXT("dwTrigger=%08x"), peff->dwTriggerButton);

        pjeff->tmDuration = peff->dwDuration / 1000;

        *pdwEffect = (DWORD)(pjeff - this->rgjeff) + 1;		//we are sure this cast will not cause problem
        hres = S_OK;

    } else {
        hres = E_NOTIMPL;
    }

done:;
    CJoyEff_LeaveCrit(this);

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | DestroyEffect |
 *
 *          Remove an effect from the device.
 *
 *          If the effect is playing, the driver should stop it
 *          before unloading it.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be destroyed.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_DestroyEffect(PDED pded, DWORD dwId, DWORD dwEffect)
{
    PDJE this;
    PJEFFECT pjeff;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::DestroyEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);
    dwId;

    hres = CJoyEff_IsValidId(this, dwEffect, &pjeff);
    if (SUCCEEDED(hres)) {
        pjeff->fInUse = 0;
    }

    CJoyEff_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | StartEffect |
 *
 *          Begin playback of an effect.
 *
 *          If the effect is already playing, then it is restarted
 *          from the beginning.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be played.
 *
 *  @parm   DWORD | dwMode |
 *
 *          How the effect is to affect other effects.
 *
 *          This parameter consists of zero or more
 *          <c DIES_*> flags.  Note, however, that the driver
 *          will never receive the <c DIES_NODOWNLOAD> flag;
 *          the <c DIES_NODOWNLOAD> flag is managed by
 *          DirectInput and not the driver.
 *
 *  @parm   DWORD | dwCount |
 *
 *          Number of times the effect is to be played.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_StartEffect(PDED pded, DWORD dwId, DWORD dwEffect,
                    DWORD dwMode, DWORD dwCount)
{
    PDJE this;
    PJEFFECT pjeff;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::StartEffect,
               (_ "puxxu", pded, dwId, dwEffect, dwMode, dwCount));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    hres = CJoyEff_IsValidId(this, dwEffect, &pjeff);
    if (SUCCEEDED(hres)) {
        if (pjeff->tmStart) {
            if (GetTickCount() - pjeff->tmStart < pjeff->tmDuration) {
                /* Already playing */
                hres = hresLe(ERROR_BUSY);
            } else {
                pjeff->tmStart = GetTickCount();
                hres = S_OK;
            }
        } else {
            pjeff->tmStart = GetTickCount();
            hres = S_OK;
        }
    }

    CJoyEff_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | StopEffect |
 *
 *          Halt playback of an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be stopped.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_StopEffect(PDED pded, DWORD dwId, DWORD dwEffect)
{
    PDJE this;
    PJEFFECT pjeff;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::StopEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    hres = CJoyEff_IsValidId(this, dwEffect, &pjeff);
    if (SUCCEEDED(hres)) {
        if (pjeff->tmStart) {
            if (GetTickCount() - pjeff->tmStart < pjeff->tmDuration) {
                /* It is still playing; stop it */
                hres = S_OK;
            } else {
                hres = S_FALSE;         /* It already stopped on its own */
            }
            pjeff->tmStart = 0;
        } else {
            hres = S_FALSE;         /* It was never started */
        }
    }

    CJoyEff_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | GetEffectStatus |
 *
 *          Obtain information about an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be queried.
 *
 *  @parm   LPDWORD | pdwStatus |
 *
 *          Receives the effect status.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_GetEffectStatus(PDED pded, DWORD dwId, DWORD dwEffect,
                        LPDWORD pdwStatus)
{
    PDJE this;
    PJEFFECT pjeff;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::StopEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    hres = CJoyEff_IsValidId(this, dwEffect, &pjeff);
    if (SUCCEEDED(hres)) {
        DWORD dwStatus;

        dwStatus = 0;
        if (pjeff->tmStart &&
            GetTickCount() - pjeff->tmStart < pjeff->tmDuration) {
            dwStatus |= DEV_STS_EFFECT_RUNNING;
        }
        *pdwStatus = dwStatus;
        hres = S_OK;
    }

    CJoyEff_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | GetVersions |
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   LPDIDRIVERVERSIONS | pvers |
 *
 *          A structure which should be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *          DirectInput will set the <e DIDRIVERVERSIONS.dwSize> field
 *          to sizeof(DIDRIVERVERSIONS) before calling this method.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_GetVersions(PDED pded, LPDIDRIVERVERSIONS pvers)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::GetVersions, (_ "pux", pded));

    this = _thisPvNm(pded, ded);

    /*
     *  Returning E_NOTIMPL causes DirectInput to ask the VxD for the same
     *  information.
     */
    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *      CJoyEff_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::<constructor>,
               (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CJoyEff, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv if multiple interfaces supported */
        PDJE this = _thisPvNm(*ppvObj, ded);

        /*
         *  The critical section must be the very first thing we do,
         *  because only Finalize checks for its existence.
         *
         *  (We might be finalized without being initialized if the user
         *  passed a bogus interface to CJoyEff_New.)
         */
        this->fCritInited = fInitializeCriticalSection(&this->crst);
        if( !this->fCritInited )
        {
            Common_Unhold(this);
            *ppvObj = NULL;
            hres = E_OUTOFMEMORY;
        }
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CJoyEff_Signature        0x4645454B      /* "JEFF" */

Interface_Template_Begin(CJoyEff)
    Primary_Interface_Template(CJoyEff, IDirectInputEffectDriver)
Interface_Template_End(CJoyEff)

Primary_Interface_Begin(CJoyEff, IDirectInputEffectDriver)
    CJoyEff_DeviceID,
    CJoyEff_GetVersions,
    CJoyEff_Escape,
    CJoyEff_SetGain,
    CJoyEff_SendForceFeedbackCommand,
    CJoyEff_GetForceFeedbackState,
    CJoyEff_DownloadEffect,
    CJoyEff_DestroyEffect,
    CJoyEff_StartEffect,
    CJoyEff_StopEffect,
    CJoyEff_GetEffectStatus,
Primary_Interface_End(CJoyEff, IDirectInputEffectDriver)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\diem.c ===
/*****************************************************************************
 *
 *  DIEm.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      DirectInput VxD emulation layer.  (I.e., do the things that
 *      dinput.vxd normally does.)  You may find large chunks of this
 *      code familiar:  It's exactly the same thing that happens in
 *      the VxD.
 *
 *  Contents:
 *
 *      CEm_AcquireInstance
 *      CEm_UnacquireInstance
 *      CEm_SetBufferSize
 *      CEm_DestroyInstance
 *      CEm_SetDataFormat
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEm

#define ThisClass CEm

#define CEM_SIGNATURE       0x4D4D4545      /* "EEMM" */

PEM g_pemFirst;

#ifdef WORKER_THREAD

PLLTHREADSTATE g_plts;      /* The currently active input thread */
#ifdef USE_WM_INPUT
  BOOL g_fFromKbdMse;
#endif

#endif  /* WORKER_THREAD */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_FreeInstance |
 *
 *          It's really gone now.
 *
 *  @parm   PEM | this |
 *
 *          The victim.
 *
 *****************************************************************************/

void EXTERNAL
CEm_FreeInstance(PEM this)
{
    PEM *ppem;
    EnterProc(CEm_FreeInstance, (_ "p", this));

    AssertF(this->dwSignature == CEM_SIGNATURE);
    AssertF(this->cRef == 0);

    /*
     *  It is the owner's responsibility to unacquire before releasing.
     */
    AssertF(!(this->vi.fl & VIFL_ACQUIRED));

    /*
     *  If this device has a reference to a hook, then remove
     *  the reference.
     */
#ifdef WORKER_THREAD
    if (this->fWorkerThread) {
        PLLTHREADSTATE  plts;
        DWORD           idThread;

        /*
         *  Protect test and access of g_plts with DLLCrit
         */
        DllEnterCrit();
        plts = g_plts;

        if (plts ) {
            AssertF(plts->cRef);

            /*
             *  Note that we need to keep the thread ID because
             *  the InterlockedDecrement might cause us to lose
             *  the object.
             *
             *  Note that this opens a race condition where the
             *  thread might decide to kill itself before we
             *  post it the nudge message.  That's okay, because
             *  even if the thread ID gets recycled, the message
             *  that appears is a dummy WM_NULL message that
             *  causes no harm.
             */

            idThread = plts->idThread;      /* Must save before we dec */
            if( InterlockedDecrement(&plts->cRef) == 0 ) {
                g_plts = 0;
            }
        }

        DllLeaveCrit();

        if( plts )
        {
            NudgeWorkerThread(idThread);
        }
    }
#endif

    /*
     *  Unlink the node from the master list.
     */
    DllEnterCrit();
    for (ppem = &g_pemFirst; *ppem; ppem = &(*ppem)->pemNext) {
        AssertF((*ppem)->dwSignature == CEM_SIGNATURE);
        if (*ppem == this) {
            *ppem = (*ppem)->pemNext;
            break;
        }
    }
    AssertF(ppem);
    DllLeaveCrit();

    FreePpv(&this->rgdwDf);
    FreePpv(&this->vi.pBuffer);

    if( InterlockedDecrement(&this->ped->cRef) == 0x0 )
    {
        FreePpv(&this->ped->pDevType);
    }

    D(this->dwSignature++);

    FreePv(this);

    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_CreateInstance |
 *
 *          Create a device thing.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *  @parm   PED | ped |
 *
 *          Descriptor.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut, PED ped)
{
    HRESULT hres;
    EnterProc(CEm_CreateInstance, (_ "pp", pdevf, ped));

    AssertF(pdevf->cbData == ped->cbData);

    CAssertF(FIELD_OFFSET(CEm, vi) == 0);

    hres = AllocCbPpv(cbX(CEm), ppviOut);
    if (SUCCEEDED(hres)) {
        PEM pem = (PV)*ppviOut;

      D(pem->dwSignature = CEM_SIGNATURE);
        pem->dwExtra = pdevf->dwExtra;
        pem->ped = ped;
        pem->cAcquire = -1;
        /*
         *  Make sure these functions are inverses.
         */
        AssertF(DIGETEMFL(DIMAKEEMFL(pdevf->dwEmulation)) ==
                                     pdevf->dwEmulation);

        pem->vi.fl = VIFL_EMULATED | DIMAKEEMFL(pdevf->dwEmulation);
        pem->vi.pState = ped->pState;
        CEm_AddRef(pem);

        DllEnterCrit();
        /*
         *  Build the devtype array.  This consists of one dword
         *  for each byte in the data format.
         *
         *  Someday: Do the button thing too.
         */
        if (ped->pDevType == 0) {
            hres = ReallocCbPpv(cbCdw(pdevf->cbData), &ped->pDevType);
            if (SUCCEEDED(hres)) {
                UINT iobj;

                /*
                 *  If HID is messed up, we will end up with
                 *  entries whose dwType is zero (because HID
                 *  said they existed, but when we went around
                 *  enumerating, they never showed up).
                 *
                 *  And don't put no-data items into the array!
                 */
                for (iobj = 0; iobj < pdevf->cObj; iobj++) {
                    if (pdevf->rgodf[iobj].dwType &&
                        !(pdevf->rgodf[iobj].dwType & DIDFT_NODATA)) {
                        ped->pDevType[pdevf->rgodf[iobj].dwOfs] =
                                      pdevf->rgodf[iobj].dwType;
                    }
                }
            }
        } else {
            hres = S_OK;
        }

        if (SUCCEEDED(hres)) {
            /*
             *  Link this node into the list.  This must be done
             *  under the critical section.
             */
             pem->pemNext = g_pemFirst;
             g_pemFirst = pem;

             InterlockedIncrement(&ped->cRef);

            *ppviOut = &pem->vi;
        } else {
            FreePpv(ppviOut);
        }
        DllLeaveCrit();
    }

    ExitOleProcPpv(ppviOut);
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CEm_NextSequence |
 *
 *          Increment the sequence number wherever it may be.
 *
 *****************************************************************************/

DWORD INTERNAL
CEm_NextSequence(void)
{
    /*
     *  Stashing the value into a local tells the compiler that
     *  the value can be cached.  Otherwise, the compiler has
     *  to assume that InterlockedIncrement can modify g_pdwSequence
     *  so it keeps reloading it.
     */
    LPDWORD pdwSequence = g_pdwSequence;

    AssertF(pdwSequence);

    /*
     *  Increment through zero.
     */
    if (InterlockedIncrement((LPLONG)pdwSequence) == 0) {
        InterlockedIncrement((LPLONG)pdwSequence);
    }

    return *pdwSequence;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PEM | CEm_BufferEvent |
 *
 *          Add a single event to the device, returning the next device
 *          on the global list.
 *
 *          This routine is entered with the global critical section
 *          taken exactly once.
 *
 *****************************************************************************/

PEM INTERNAL
CEm_BufferEvent(PEM pem, DWORD dwData, DWORD dwOfs, DWORD tm, DWORD dwSeq)
{
    PEM pemNext;

    /*
     *  We must release the global critical section in order to take
     *  the device critical section.
     */
    CEm_AddRef(pem);                /* Make sure it doesn't vanish */

    DllLeaveCrit();
    AssertF(!InCrit());

    /*
     * ---Windows Bug 238305---
     * Run the buffering code in __try block so that if an
     * input is receive after the device is released, we can
     * catch the AV and clean up from there.
     */
    __try
    {
        CDIDev_EnterCrit(pem->vi.pdd);

        AssertF(dwOfs < pem->ped->cbData);
        AssertF(pem->rgdwDf);

        /*
         *  If the user cares about the object...
         */
        if (pem->rgdwDf[dwOfs] != 0xFFFFFFFF) {
            LPDIDEVICEOBJECTDATA pdod = pem->vi.pHead;

            /*
             *  Set the node value.
             */

            pdod->dwOfs       = pem->rgdwDf[dwOfs];
            pdod->dwData      = dwData;
            pdod->dwTimeStamp = tm;
            pdod->dwSequence  = dwSeq;

            /*
             *  Append the node to the list if there is room.
             *  Note that we rely above on the fact that the list is
             *  never totally full.
             */
            pdod++;

            AssertF(pdod <= pem->vi.pEnd);

            if (pdod >= pem->vi.pEnd) {
                pdod = pem->vi.pBuffer;
            }

            /*
             * always keep the new data
             */
            pem->vi.pHead = pdod;

            if (pdod == pem->vi.pTail) {
                if (!pem->vi.fOverflow) {
                    RPF("Buffer overflow; discard old data");
                }

                pem->vi.pTail++;
                if (pem->vi.pTail == pem->vi.pEnd) {
                    pem->vi.pTail = pem->vi.pBuffer;
                }

                pem->vi.fOverflow = 1;
            }

        }

        CDIDev_LeaveCrit(pem->vi.pdd);
    }
    /*
     * If we get an AV, most likely input is received after the device has
     * been released.  In this case, we clean up the thread and exit as
     * soon as possible.
     */
    __except( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH )
    {
        /* Do nothing here, so we clean up the thread and exit below. */
        RPF("CEm_BufferEvent: Access Violation catched! Most likely the device has been released");
    }

    DllEnterCrit();
    pemNext = pem->pemNext;
    AssertF(fLimpFF(pemNext, pemNext->dwSignature == CEM_SIGNATURE));
    CEm_Release(pem);
    return pemNext;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | CEm_ContinueEvent |
 *
 *          Add a single event to the queues of all acquired devices
 *          of the indicated type.
 *
 *  @returns
 *
 *          TRUE if someone is interested in this data (even if they are not 
 *          buffered).
 *
 *****************************************************************************/

BOOL EXTERNAL
CEm_ContinueEvent(PED ped, DWORD dwData, DWORD dwOfs, DWORD tm, DWORD dwSeq)
{
    DWORD ddwData;                  /* delta in dwData */
    DWORD dwNativeData;             /* delta for rel, dwData for abs */
    BOOL  fRtn = FALSE;

    AssertF(!InCrit());

    /* Sanity check: Make sure the ped has been initialized */
    if (ped->pDevType) {
        PEM pem, pemNext;

        if (ped->pDevType[dwOfs] & DIDFT_DWORDOBJS) {
            DWORD UNALIGNED *pdw = pvAddPvCb(ped->pState, dwOfs);
            if (*pdw != dwData) {
                if (ped->pDevType[dwOfs] & DIDFT_POV) {
                    ddwData = dwData;   /* Don't do deltas for POV */
                } else {
                    ddwData = dwData - *pdw;
                }
                *pdw = dwData;

                /*
                 *  Assert that if it's not a relative axis, its a POV or 
                 *  an absolute axis, both of which should be absolute.
                 */
                CAssertF( DIDFT_DWORDOBJS 
                    == ( DIDFT_ABSAXIS | DIDFT_RELAXIS | DIDFT_POV ) );
                /*
                 *  DX7 had series of bugs, the net result of which was 
                 *  that emulated devices only report data in their native 
                 *  mode.  If that behavior is required make it so here.
                 */
                if( ped->pDevType[dwOfs] & DIDFT_RELAXIS )
                {
                    dwNativeData = ddwData; /* Always use relative */
                }
                else 
                {
                    dwNativeData = dwData;  /* Always use absolute */
                }
                
            } else {
                goto nop;
            }
        } else {
            LPBYTE pb = pvAddPvCb(ped->pState, dwOfs);

            AssertF((dwData & ~0x80) == 0);

            if (*pb != (BYTE)dwData) {
                *pb = (BYTE)dwData;
                dwNativeData = ddwData = dwData;       /* Don't do deltas for buttons */
                /* Someday: Button sequences go here */
            } else {
                goto nop;
            }
        }

        AssertF(!InCrit());         /* You can never be too paranoid */

        DllEnterCrit();
        for (pem = g_pemFirst; pem; pem = pemNext) {
            AssertF(pem->dwSignature == CEM_SIGNATURE);
            if ((pem->vi.fl & (VIFL_ACQUIRED|VIFL_INITIALIZE)) && pem->ped == ped) {

                if (pem->vi.pBuffer) {
                    if( pem->vi.fl & VIFL_MODECOMPAT )
                    {
                        pemNext = CEm_BufferEvent(pem, dwNativeData, dwOfs, tm, dwSeq);
                    }
                    else if( pem->vi.fl & VIFL_RELATIVE )
                    {
                        pemNext = CEm_BufferEvent(pem, ddwData, dwOfs, tm, dwSeq);
                    }
                    else
                    {
                        pemNext = CEm_BufferEvent(pem, dwData, dwOfs, tm, dwSeq);
                    }
                    AssertF(fLimpFF(pemNext,
                                    pemNext->dwSignature == CEM_SIGNATURE));
                } else {
                    pemNext = pem->pemNext;
                    AssertF(fLimpFF(pemNext,
                                    pemNext->dwSignature == CEM_SIGNATURE));
                }
                /*
                 *  Since this happens only when the device is acquired,
                 *  we don't need to worry about the notify event changing
                 *  asynchronously.
                 *
                 *  UPDATE 1/5/01 Winbug 270403 (jacklin): Moved call to CDIDev_SetNotifyEvent
                 *  below so the buffer is updated before the event is set.
                 *
                 *  It would be easy to avoid setting the event if nothing 
                 *  was buffered for better performance but people will be 
                 *  relying on getting events now, even when they are not 
                 *  using a buffer.
                 */

                fRtn = TRUE;
            } else {
                pemNext = pem->pemNext;
                AssertF(fLimpFF(pemNext,
                                pemNext->dwSignature == CEM_SIGNATURE));
            }
        }
        DllLeaveCrit();
    }

nop:;
    return fRtn;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CEm_AddEvent |
 *
 *          Increment the DirectInput sequence number, then
 *          add a single event to the queues of all acquired devices
 *          of the indicated type.
 *
 *  @parm   PED | ped |
 *
 *          Device which is adding the event.
 *
 *  @parm   DWORD | dwData |
 *
 *          The event data.
 *
 *  @parm   DWORD | dwOfs |
 *
 *          Device data format-relative offset for <p dwData>.
 *
 *  @parm   DWORD | tm |
 *
 *          Time the event was generated.
 *
 *  @returns
 *
 *          Returns the sequence number added, so that it may be
 *          continued.
 *
 *****************************************************************************/

DWORD EXTERNAL
CEm_AddEvent(PED ped, DWORD dwData, DWORD dwOfs, DWORD tm)
{
    PEM pem, pemNext;

    DWORD dwSeq = CEm_NextSequence();

    AssertF(!InCrit());         /* You can never be too paranoid */

    if( CEm_ContinueEvent(ped, dwData, dwOfs, tm, dwSeq) )
    {
        DllEnterCrit();
        for (pem = g_pemFirst; pem; pem = pemNext) {
            AssertF(pem->dwSignature == CEM_SIGNATURE);
            if ((pem->vi.fl & VIFL_ACQUIRED) && pem->ped == ped) {
                CDIDev_SetNotifyEvent(pem->vi.pdd);
            }
            pemNext = pem->pemNext;
            AssertF(fLimpFF(pemNext,
                            pemNext->dwSignature == CEM_SIGNATURE));
        }
        DllLeaveCrit();
    }

    return dwSeq;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_AddState |
 *
 *          Record a brand new device state.
 *
 *  @parm   PED | ped |
 *
 *          Device which has changed state.
 *
 *  @parm   DWORD | dwData |
 *
 *          The value to record.
 *
 *  @parm   DWORD | tm |
 *
 *          Time the state change was generated.
 *
 *****************************************************************************/

void EXTERNAL
CEm_AddState(PED ped, LPVOID pvData, DWORD tm)
{
    DWORD dwSeq = CEm_NextSequence();

    /* Sanity check: Make sure the ped has been initialized */
    if (ped->pDevType) {
        DWORD dwOfs;
        BOOL  fEvent = FALSE;

        /*
         *  Note, it is too late to improve performance by only doing events 
         *  if somebody is listening.
         */
        dwOfs = 0;
        while (dwOfs < ped->cbData) {
            /*
             *  There shouldn't be any no-data items.
             */
            AssertF(!(ped->pDevType[dwOfs] & DIDFT_NODATA));

            if (ped->pDevType[dwOfs] & DIDFT_DWORDOBJS) {
                DWORD UNALIGNED *pdw = pvAddPvCb(pvData, dwOfs);
                if( CEm_ContinueEvent(ped, *pdw, dwOfs, tm, dwSeq) ) {
                	fEvent = TRUE;
                }
                dwOfs += cbX(DWORD);
            } else {
                LPBYTE pb = pvAddPvCb(pvData, dwOfs);
                if( CEm_ContinueEvent(ped, *pb, dwOfs, tm, dwSeq) ) {
                	fEvent = TRUE;
                }
                dwOfs++;
            }
        }
        
        if( fEvent ) {
            PEM pem, pemNext;

            AssertF(!InCrit());         /* You can never be too paranoid */
    
            DllEnterCrit();
            for (pem = g_pemFirst; pem; pem = pemNext) {
                AssertF(pem->dwSignature == CEM_SIGNATURE);
                if ((pem->vi.fl & VIFL_ACQUIRED) && pem->ped == ped) {
                    CDIDev_SetNotifyEvent(pem->vi.pdd);
                }
                pemNext = pem->pemNext;
                AssertF(fLimpFF(pemNext,
                                pemNext->dwSignature == CEM_SIGNATURE));
            }
            DllLeaveCrit();
        }

    }
}

#if 0
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_InputLost |
 *
 *          Remove global hooks because something weird happened.
 *
 *          We don't need to do anything because our hooks are local.
 *
 *****************************************************************************/

HRESULT INLINE
CEm_InputLost(LPVOID pvIn, LPVOID pvOut)
{
    return S_OK;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_UnacquirePem |
 *
 *          Unacquire the device in the device-specific way.
 *
 *  @parm   PEM | pem |
 *
 *          Information about the gizmo being mangled.
 *
 *  @parm   UINT | fdufl |
 *
 *          Assorted flags describing why we are being unacquired.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_UnacquirePem(PEM this, UINT fdufl)
{
    HRESULT hres;
#ifdef DEBUG
    EnterProcR(CEm_UnacquirePem, (_ "px", this, fdufl));
#else
    EnterProcR(IDirectInputDevice::Unacquire, (_ "p", this));
#endif

    AssertF(this->dwSignature == CEM_SIGNATURE);

    AssertF((fdufl & ~FDUFL_UNPLUGGED) == 0);
    CAssertF(FDUFL_UNPLUGGED == VIFL_UNPLUGGED);

    if (this->vi.fl & VIFL_ACQUIRED) {
        this->vi.fl &= ~VIFL_ACQUIRED;
        this->vi.fl |= fdufl;
        if (InterlockedDecrement(&this->cAcquire) < 0) {
            InterlockedDecrement(&this->ped->cAcquire);
            hres = this->ped->Acquire(this, 0);
        } else {
            SquirtSqflPtszV(sqfl, TEXT("%S: Still acquired %d"),
                            s_szProc, this->cAcquire);
            hres = S_OK;
        }
    } else {
        SquirtSqflPtszV(sqfl, TEXT("%S: Not acquired %d"),
                        s_szProc, this->cAcquire);
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_ForceDeviceUnacquire |
 *
 *          Force all users of a device to unacquire.
 *
 *  @parm   PEM | pem |
 *
 *          Information about the gizmo being mangled.
 *
 *  @parm   UINT | fdufl |
 *
 *          Assorted flags describing why we are being unacquired.
 *
 *****************************************************************************/

void EXTERNAL
CEm_ForceDeviceUnacquire(PED ped, UINT fdufl)
{
    PEM pem, pemNext;

    AssertF((fdufl & ~FDUFL_UNPLUGGED) == 0);

    AssertF(!DllInCrit());

    DllEnterCrit();
    for (pem = g_pemFirst; pem; pem = pemNext) {
        AssertF(pem->dwSignature == CEM_SIGNATURE);
        if (pem->ped == ped && (pem->vi.fl & VIFL_ACQUIRED)) {
            CEm_AddRef(pem);
            DllLeaveCrit();
            CEm_UnacquirePem(pem, fdufl);

            CDIDev_SetForcedUnacquiredFlag(pem->vi.pdd);
            /*
             *  Since this happens only when the device is acquired,
             *  we don't need to worry about the notify event changing
             *  asynchronously.
             */
            CDIDev_SetNotifyEvent(pem->vi.pdd);
            DllEnterCrit();
            pemNext = pem->pemNext;
            AssertF(pem->dwSignature == CEM_SIGNATURE);
            CEm_Release(pem);
        } else {
            pemNext = pem->pemNext;
            AssertF(pem->dwSignature == CEM_SIGNATURE);
        }
    }
    DllLeaveCrit();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_DestroyInstance |
 *
 *          Clean up an instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_DestroyInstance(PVXDINSTANCE *ppvi)
{
    HRESULT hres;
    PEM this = _thisPvNm(*ppvi, vi);
    EnterProc(CEm_DestroyInstance, (_ "p", *ppvi));

    AssertF(this->dwSignature == CEM_SIGNATURE);
    AssertF((PV)this == (PV)*ppvi);

    if (this) {
        CEm_Release(this);
    }
    hres = S_OK;

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_SetDataFormat |
 *
 *          Record the application data format in the device so that
 *          we can translate it for buffering purposes.
 *
 *  @parm   PVXDDATAFORMAT | pvdf |
 *
 *          Information about the gizmo being mangled.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_SetDataFormat(PVXDDATAFORMAT pvdf)
{
    HRESULT hres;
    PEM this = _thisPvNm(pvdf->pvi, vi);
    EnterProc(CEm_SetDataFormat, (_ "p", pvdf->pvi));

    AssertF(this->dwSignature == CEM_SIGNATURE);
    hres = ReallocCbPpv( cbCdw(pvdf->cbData), &this->rgdwDf);
    if (SUCCEEDED(hres)) {
        AssertF(pvdf->cbData == this->ped->cbData);
        memcpy(this->rgdwDf, pvdf->pDfOfs, cbCdw(pvdf->cbData) );
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_AcquireInstance |
 *
 *          Acquire the device in the device-specific way.
 *
 *  @parm   PVXDINSTANCE * | ppvi |
 *
 *          The instance to acquire.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_AcquireInstance(PVXDINSTANCE *ppvi)
{
    HRESULT hres;
    PEM this = _thisPvNm(*ppvi, vi);
#ifdef DEBUG
    EnterProc(CEm_AcquireInstance, (_ "p", *ppvi));
#else
    EnterProcR(IDirectInputDevice::Acquire, (_ "p", *ppvi));
#endif

    AssertF(this->dwSignature == CEM_SIGNATURE);
    this->vi.fl |= VIFL_ACQUIRED;
    if (InterlockedIncrement(&this->cAcquire) == 0) {
        InterlockedIncrement(&this->ped->cAcquire);
        hres = this->ped->Acquire(this, 1);
        if (FAILED(hres)) {
            this->vi.fl &= ~VIFL_ACQUIRED;
            InterlockedDecrement(&this->cAcquire);
        }
    } else {
        SquirtSqflPtszV(sqfl, TEXT("%S: Already acquired %d"),
                        s_szProc, this->cAcquire);
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_UnacquireInstance |
 *
 *          Unacquire the device in the device-specific way.
 *
 *  @parm   PVXDINSTANCE * | ppvi |
 *
 *          Information about the gizmo being mangled.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_UnacquireInstance(PVXDINSTANCE *ppvi)
{
    HRESULT hres;
    PEM this = _thisPvNm(*ppvi, vi);
    EnterProc(CEm_UnacquireInstance, (_ "p", *ppvi));

    hres = CEm_UnacquirePem(this, FDUFL_NORMAL);

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_SetBufferSize |
 *
 *          Allocate a buffer of the appropriate size.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The <p dwData> is the buffer size.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_SetBufferSize(PVXDDWORDDATA pvdd)
{
    HRESULT hres;
    PEM this = _thisPvNm(pvdd->pvi, vi);
    EnterProc(CEm_SetBufferSize, (_ "px", pvdd->pvi, pvdd->dw));

    AssertF(this->dwSignature == CEM_SIGNATURE);

    hres = ReallocCbPpv(cbCxX(pvdd->dw, DIDEVICEOBJECTDATA),
                        &this->vi.pBuffer);
    if (SUCCEEDED(hres)) {
        this->vi.pHead = this->vi.pBuffer;
        this->vi.pTail = this->vi.pBuffer;
        this->vi.pEnd  = &this->vi.pBuffer[pvdd->dw];
    }

    ExitOleProc();
    return hres;
}

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @struct LLHOOKINFO |
 *
 *          Information about how to install a low-level hook.
 *
 *  @field  int | idHook |
 *
 *          The Windows hook identifier.
 *
 *  @field  HOOKPROC | hp |
 *
 *          The hook procedure itself.
 *
 *****************************************************************************/

typedef struct LLHOOKINFO {

    int      idHook;
    HOOKPROC hp;

} LLHOOKINFO, *PLLHOOKINFO;
typedef const LLHOOKINFO *PCLLHOOKINFO;

#pragma BEGIN_CONST_DATA

const LLHOOKINFO c_rgllhi[] = {
    {   WH_KEYBOARD_LL, CEm_LL_KbdHook },   /* LLTS_KBD */
    {   WH_MOUSE_LL,    CEm_LL_MseHook },   /* LLTS_MSE */
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_LL_SyncHook |
 *
 *          Install or remove a hook as needed.
 *
 *  @parm   UINT | ilts |
 *
 *          Which hook is being handled?
 *
 *  @parm   PLLTHREADSTATE | plts |
 *
 *          Thread hook state containing hook information to synchronize.
 *
 *****************************************************************************/

void INTERNAL
CEm_LL_SyncHook(PLLTHREADSTATE plts, UINT ilts)
{
    PLLHOOKSTATE plhs = &plts->rglhs[ilts];

    if (!fLeqvFF(plhs->cHook, plhs->hhk)) {
        if (plhs->hhk) {
            UnhookWindowsHookEx(plhs->hhk);
            plhs->hhk = 0;
        } else {
            PCLLHOOKINFO pllhi = &c_rgllhi[ilts];
            plhs->hhk = SetWindowsHookEx(pllhi->idHook, pllhi->hp, g_hinst, 0);
        }
    }

}

#endif /* USE_SLOW_LL_HOOKS */

#ifdef WORKER_THREAD

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | FakeMsgWaitForMultipleObjectsEx |
 *
 *          Stub function which emulates
 *          <f MsgWaitForMultipleObjectsEx>
 *          on platforms that do not support it.
 *
 *          Such platforms (namely, Windows 95) do not support HID
 *          and therefore the inability to go into an alertable
 *          wait state constitutes no loss of amenity.
 *
 *  @parm   DWORD | nCount |
 *
 *          Number of handles in handle array.
 *
 *  @parm   LPHANDLE | pHandles |
 *
 *          Pointer to an object-handle array.
 *
 *  @parm   DWORD | ms |
 *
 *          Time-out interval in milliseconds.
 *
 *  @parm   DWORD | dwWakeMask |
 *
 *          Type of input events to wait for.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Wait flags.
 *
 *  @returns
 *
 *          Same as <f MsgWaitForMultipleObjectsEx>.
 *
 *****************************************************************************/

DWORD WINAPI
FakeMsgWaitForMultipleObjectsEx(
    DWORD nCount,
    LPHANDLE pHandles,
    DWORD ms,
    DWORD dwWakeMask,
    DWORD dwFlags)
{
    /*
     *  We merely call the normal MsgWaitForMultipleObjects because
     *  the only way we can get here is on a platform that doesn't
     *  support HID.
     */
    return MsgWaitForMultipleObjects(nCount, pHandles,
                                     dwFlags & MWMO_WAITALL, ms, dwWakeMask);
}

#ifdef WINNT
// On win2k non-exclusive mode user thinks the Dinput thread is hung.
// In order to fix this we set a TimerEvent and wake up every so 
// often and execute the FakeTimerProc. This keeps user happy and
// keeps dinput thread from being marked as hung and we can get 
// events to our low level hooks
VOID CALLBACK FakeTimerProc(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
{
}
#endif

#ifdef USE_WM_INPUT

#pragma BEGIN_CONST_DATA
TCHAR c_szEmClassName[] = TEXT("DIEmWin");
#pragma END_CONST_DATA

/****************************************************************************
 *
 *      CEm_WndProc
 *
 *      Window procedure for simple sample.
 *
 ****************************************************************************/

LRESULT CALLBACK
CEm_WndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    switch (msg) {
    //case WM_INPUT:
    //    RPF("in WM_INPUT message");
    //    break;

    default:
        break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

HWND 
CEm_InitWindow(void)
{
    HWND hwnd;
    WNDCLASS wc;
    static BOOL fFirstTime = TRUE;

    if( fFirstTime ) {
        wc.hCursor        = LoadCursor(0, IDC_ARROW);
        wc.hIcon          = LoadIcon(NULL, MAKEINTRESOURCE(IDI_APPLICATION));
        wc.lpszMenuName   = NULL;
        wc.lpszClassName  = c_szEmClassName;
        wc.hbrBackground  = 0;
        wc.hInstance      = g_hinst;
        wc.style          = 0;
        wc.lpfnWndProc    = CEm_WndProc;
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = 0;

        if (!RegisterClass(&wc)) {
            return NULL;
        }

        fFirstTime = FALSE;
    }
    
    hwnd = CreateWindow(
                    c_szEmClassName,                     // Class name
                    TEXT("DIEmWin"),                     // Caption
                    WS_OVERLAPPEDWINDOW,                 // Style
                    -1, -1,                              // Position
                    1, 1,                                // Size
                    NULL,                                //parent
                    NULL,                                // No menu
                    g_hinst,                             // inst handle
                    0                                    // no params
                    );

    if( !hwnd ) {
        RPF("CreateWindow failed.");
    }

    return hwnd;
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | CEm_LL_ThreadProc |
 *
 *          The thread that manages our low-level hooks.
 *
 *          ThreadProcs are prototyped to return a DWORD but since the return
 *          would follow some form of ExitThread, it will never be reached so
 *          this function is declared to return VOID and cast.
 *
 *          When we get started, and whenever we receive any message
 *          whatsoever, re-check to see which hooks should be installed
 *          and re-synchronize ourselves with them.
 *
 *          Note that restarting can be slow, since it happens only
 *          when we get nudged by a client.
 *
 *  @parm   PLLTHREADSTATE | plts |
 *
 *          The thread state to use.
 *
 *****************************************************************************/

VOID INTERNAL
CEm_LL_ThreadProc(PLLTHREADSTATE plts)
{
    MSG msg;
    DWORD dwRc;
  #ifdef USE_WM_INPUT
    HWND hwnd = NULL;
  #endif

    AssertF(plts->idThread == GetCurrentThreadId());
    SquirtSqflPtszV(sqflLl, TEXT("CEm_LL_ThreadProc: Thread started"));
     
  #ifdef USE_SLOW_LL_HOOKS
    /*
     *  Refresh the mouse acceleration values.
     *
     *  ISSUE-2001/03/29-timgill Need a window to listen for WM_SETTINGCHANGE
     *  We need to create a window to listen for
     *  WM_SETTINGCHANGE so we can refresh the mouse acceleration
     *  as needed.
     */
    CEm_Mouse_OnMouseChange();
  #endif
  
    /*
     *  Create ourselves a queue before we go into our "hey what happened
     *  before I got here?" phase.  The thread that created us is waiting on
     *  the thread event, holding DLLCrit, so let it go as soon as the queue
     *  is ready.  We create the queue by calling a function that requires a
     *  queue.  We use this very simple one.
     */
    GetInputState();

  #ifdef WINNT
    // Look at comment block in FakeTimerProc
    SetTimer(NULL, 0, 2 * 1000 /*2 seconds*/, FakeTimerProc);
  #endif

    SetEvent(plts->hEvent);

  #ifdef USE_WM_INPUT
    ResetEvent( g_hEventThread );
    
    if( g_fRawInput ) {
        hwnd = CEm_InitWindow();
    
        if (!hwnd) {
            g_fRawInput = FALSE;
        }
    }

    g_hwndThread = hwnd;

    // Tell CEm_LL_Acquire that windows has been created.
    SetEvent( g_hEventAcquire );

    if( g_fFromKbdMse ) {
    	DWORD rc;
        rc = WaitForSingleObject(g_hEventThread, INFINITE);
        g_fFromKbdMse = FALSE;
    }
  #endif
  
#ifdef USE_SLOW_LL_HOOKS
    /*
     *  Note carefully that we sync the hooks before entering our
     *  fake GetMessage loop.  This is necessary to avoid the race
     *  condition when CEm_LL_Acquire posts us a thread message
     *  before our thread gets a queue.  By sync'ing the hooks
     *  first, we do what the lost message would've had us do
     *  anyway.
     *  ISSUE-2001/03/29-timgill  Following branch should be no longer necessary
     *  This is should not be needed now that CEm_GetWorkerThread waits for
     *  this thread to respond before continuing on to post any messages.
     */
#endif /* USE_SLOW_LL_HOOKS */

    do {
      #ifdef USE_SLOW_LL_HOOKS
        if( !g_fRawInput ) {
            CEm_LL_SyncHook(plts, LLTS_KBD);
            CEm_LL_SyncHook(plts, LLTS_MSE);
        }
      #endif

        /*
         *  We can wake up for three reasons.
         *
         *  1.  We received an APC due to an I/o completion.
         *      Just go back to sleep.
         *
         *  2.  We need to call Peek/GetMessage so that
         *      USER can dispatch a low-level hook or SendMessage.
         *      Go into a PeekMessage loop to let that happen.
         *
         *  3.  A message got posted to us.
         *      Go into a PeekMessage loop to process it.
         */

        do {
            dwRc = _MsgWaitForMultipleObjectsEx(0, 0, INFINITE, QS_ALLINPUT,
                                                MWMO_ALERTABLE);
        } while (dwRc == WAIT_IO_COMPLETION);

        while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE)) {
      #ifdef HID_SUPPORT    
            if (msg.hwnd == 0 && msg.message == WM_NULL && msg.lParam) 
            {
                /*
                 *  See if maybe the lParam is a valid PEM that we're
                 *  processing.
                 */
                PEM pem = (PEM)msg.lParam;

                if( pem && pem == plts->pemCheck  )
                {
                    AssertF(GPA_FindPtr(&plts->gpaHid, pem));

                    CEm_HID_Sync(plts, pem);
                    plts->pemCheck = NULL;

                    SetEvent(plts->hEvent);

                  #ifdef USE_WM_INPUT
                    if( g_fRawInput ) {
                        SetEvent(g_hEventHid);
                    }
                  #endif

                    continue;
                }
            }
          #ifdef USE_WM_INPUT
            else if ( g_fRawInput && msg.message == WM_INPUT && 
                      (msg.wParam == RIM_INPUT || msg.wParam == RIM_INPUTSINK) )
            {
                CDIRaw_OnInput(&msg);
            }
          #endif
      #endif //ifdef HID_SUPPORT 
  
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

    } while (plts->cRef);

#ifdef USE_SLOW_LL_HOOKS
    /*
     *  Remove our hooks before we go.
     *
     *  It is possible that there was a huge flurry of disconnects,
     *  causing us to notice that our refcount disappeared before
     *  we got a chance to remove the hooks in our message loop.
     */

    AssertF(plts->rglhs[LLTS_KBD].cHook == 0);
    AssertF(plts->rglhs[LLTS_KBD].cExcl == 0);
    AssertF(plts->rglhs[LLTS_MSE].cHook == 0);
    AssertF(plts->rglhs[LLTS_MSE].cExcl == 0);

    if( !g_fRawInput ) {
        if (plts->rglhs[LLTS_KBD].hhk) {
            UnhookWindowsHookEx(plts->rglhs[LLTS_KBD].hhk);
        }

        if (plts->rglhs[LLTS_MSE].hhk) {
            UnhookWindowsHookEx(plts->rglhs[LLTS_MSE].hhk);
        }
    }
#endif /* USE_SLOW_LL_HOOKS */

  #ifdef USE_WM_INPUT
    if( g_hwndThread ) {
        DestroyWindow( g_hwndThread );
        g_hwndThread = NULL;
    }
    
    ResetEvent( g_hEventAcquire );
    ResetEvent( g_hEventHid );
  #endif

    if( plts->gpaHid.rgpv ) {
        FreePpv(&plts->gpaHid.rgpv);
    }

    if( plts->hEvent ) {
        CloseHandle( plts->hEvent );
    }

    if( plts->hThread) {
        CloseHandle(plts->hThread);
    }

    FreePpv( &plts );

    SquirtSqflPtszV(sqflLl, TEXT("CEm_LL_ThreadProc: Thread terminating"));

    FreeLibraryAndExitThread(g_hinst, 0);
    /*NOTREACHED*/
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_GetWorkerThread |
 *
 *          Piggyback off the existing worker thread if possible;
 *          else create a new one.
 *
 *  @parm   PEM | pem |
 *
 *          Emulation state which requires a worker thread.
 *
 *  @parm   PLLTHREADSTATE * | pplts |
 *
 *          Receives thread state for worker thread.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_GetWorkerThread(PEM pem, PLLTHREADSTATE *pplts)
{
    PLLTHREADSTATE plts;
    HRESULT hres;

    DllEnterCrit();

    /*
     *  Normally, we can piggyback off the one we already have.
     */
    plts = g_plts;

    /*
     *  If we already have a ref to a worker thread, then use it.
     */
    if (pem->fWorkerThread) {

        /*
         *  The reference we created when we created the worker thread
         *  ensures that g_plts is valid.
         */
        AssertF(plts);
        AssertF(plts->cRef);
        if (plts) {
            hres = S_OK;
        } else {
            AssertF(0);                 /* Can't happen */
            hres = E_FAIL;
        }
    } else

    if (plts) {
        /*
         *  Create a reference to the existing thread.
         */
        pem->fWorkerThread = TRUE;
        InterlockedIncrement(&plts->cRef);
        hres = S_OK;
    } else {

        /*
         *  There is no worker thread (or it is irretrievably
         *  on its way out) so create a new one.
         */
        hres = AllocCbPpv(cbX(LLTHREADSTATE), &plts);
        if (SUCCEEDED(hres)) {
            DWORD dwRc = 0;
            TCHAR tsz[MAX_PATH];

            /*
             *  Assume the worst unless we find otherwise
             */
            hres = E_FAIL;

            if( GetModuleFileName(g_hinst, tsz, cA(tsz))
             && ( LoadLibrary(tsz) == g_hinst ) )
            {

                /*
                 *  Must set up everything to avoid racing with
                 *  the incoming thread.
                 */
                g_plts = plts;
                InterlockedIncrement(&plts->cRef);
                plts->hEvent = CreateEvent(0x0, 0, 0, 0x0);
                if( plts->hEvent )
                {
                    plts->hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)CEm_LL_ThreadProc, plts,
                                               0, &plts->idThread);
                    if( plts->hThread )
                    {
                        /*
                         *  Boost our priority to make sure we
                         *  can handle the messages.
                         *
                         *  RaymondC commented this out saying that it does not
                         *  help but we're hoping that it may on Win2k.
                         */
                        SetThreadPriority(plts->hThread, THREAD_PRIORITY_HIGHEST);

                        /*
                         *  Wait for the thread to signal that it is up and running
                         *  or for it to terminate.
                         *  This means that we don't have to consider the
                         *  possibility that the thread is not yet running in
                         *  NotifyWorkerThreadPem so we know a failure there is
                         *  terminal and don't retry.
                         *
                         *  Assert that the handle fields make a two handle array.
                         */
                        CAssertF( FIELD_OFFSET( LLTHREADSTATE, hThread) + sizeof(plts->hThread)
                               == FIELD_OFFSET( LLTHREADSTATE, hEvent) );

                        /*
                         *  According to a comment in CEm_LL_ThreadProc Win95 may
                         *  fail with an invalid parameter error, so if it does,
                         *  keep trying.  (Assume no valid case will occur.)
                         *
                         *  ISSUE-2001/03/29-timgill  Need to minimise waits while holding sync. objects
                         *  Waiting whilst holding DLLCrit is bad.
                         */
                        do
                        {
                            dwRc = WaitForMultipleObjects( 2, &plts->hThread, FALSE, INFINITE);
                        } while ( ( dwRc == WAIT_FAILED ) && ( GetLastError() == ERROR_INVALID_PARAMETER ) );

                        if( dwRc == WAIT_OBJECT_0 ) {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("CEm_GetWorkerThread: Created Thread terminated on first wait") );
                        } else {
                            pem->fWorkerThread = TRUE;
                            hres = S_OK;
                            if( dwRc != WAIT_OBJECT_0 + 1 )
                            {
                                /*
                                 *  This would be a bad thing if it ever happened
                                 *  but we have to assume that the thread is still
                                 *  running so we return a success anyway.
                                 */
                                SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("CEm_GetWorkerThread: First wait returned 0x%08x with LastError %d"),
                                    dwRc, GetLastError() );
                            }
                        }
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("CEm_GetWorkerThread: CreateThread failed with error %d"),
                            GetLastError() );
                    }
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("CEm_GetWorkerThread: CreateEvent failed with error %d"),
                        GetLastError() );
                }


                if( FAILED( hres ) )
                {
                    if( plts->hEvent ) {
                        CloseHandle( plts->hEvent );
                    }
                    FreeLibrary(g_hinst);
                }

            }
            else
            {
                RPF( "CEm_GetWorkerThread: failed to LoadLibrary( self ), le = %d", GetLastError() );
            }

            if( FAILED( hres ) )
            {
                FreePv(plts);
                g_plts = 0;
            }
        }
    }

    DllLeaveCrit();

    *pplts = plts;
    return hres;
}

#endif /* WORKER_THREAD */

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_LL_Acquire |
 *
 *          Acquire/unacquire a mouse or keyboard via low-level hooks.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *  @parm   BOOL | fAcquire |
 *
 *          Whether the device is being acquired or unacquired.
 *
 *  @parm   ULONG | fl |
 *
 *          Flags in VXDINSTANCE (vi.fl).
 *
 *  @parm   UINT | ilts |
 *
 *          LLTS_KBD or LLTS_MSE, depending on which is happening.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_LL_Acquire(PEM this, BOOL fAcquire, ULONG fl, UINT ilts)
{
    PLLTHREADSTATE plts;
    BOOL fExclusive = fl & VIFL_CAPTURED;
    BOOL fNoWinkey = fl & VIFL_NOWINKEY;
    HRESULT hres = S_OK;

    EnterProc(CEm_LL_Acquire, (_ "puuu", this, fAcquire, fExclusive, ilts));

    AssertF(this->dwSignature == CEM_SIGNATURE);
    AssertF(ilts==LLTS_KBD || ilts==LLTS_MSE);

  #ifdef USE_WM_INPUT
    g_fFromKbdMse = fAcquire ? TRUE : FALSE;
    ResetEvent( g_hEventAcquire );
  #endif

    hres = CEm_GetWorkerThread(this, &plts);

    if (SUCCEEDED(hres)) {
        AssertF( plts->rglhs[ilts].cHook >= plts->rglhs[ilts].cExcl );

      #ifdef USE_WM_INPUT
        if( g_fRawInput && !g_hwndThread) {
            DWORD dwRc;
            dwRc = WaitForSingleObject(g_hEventAcquire, INFINITE);
        }
      #endif
      
        if (fAcquire) {
            InterlockedIncrement(&plts->rglhs[ilts].cHook);

            if (fExclusive) {
                InterlockedIncrement(&plts->rglhs[ilts].cExcl);
            }

          #ifdef USE_WM_INPUT
            if( g_hwndThread ) {
                if( fExclusive ) {
                    hres = CDIRaw_RegisterRawInputDevice(1-ilts, DIRAW_EXCL, g_hwndThread);
                } 
                else if( fNoWinkey ) {
                    AssertF( ilts == 0 );
                    if( ilts == 0 ) {
                        hres = CDIRaw_RegisterRawInputDevice(1-ilts, DIRAW_NOHOTKEYS, g_hwndThread);
                    } else {
                        hres = E_FAIL;
                    }
                } 
                else {
                    hres = CDIRaw_RegisterRawInputDevice(1-ilts, DIRAW_NONEXCL, g_hwndThread);
                }

                if(FAILED(hres)) {
                    hres = S_FALSE;
                    g_fRawInput = FALSE;
                    RPF("CEm_LL_Acquire: RegisterRawInput failed.");
                }
            }
          #endif

        } else {                        /* Remove the hook */
            AssertF(plts->cRef);

            if (fExclusive) {
                InterlockedDecrement(&plts->rglhs[ilts].cExcl);
            }

            InterlockedDecrement(&plts->rglhs[ilts].cHook);

          #ifdef USE_WM_INPUT
            if( g_fRawInput ) {
                CDIRaw_UnregisterRawInputDevice(1-ilts, g_hwndThread);
                
                if( plts->rglhs[ilts].cHook ) {
                    CDIRaw_RegisterRawInputDevice(1-ilts, 0, g_hwndThread);
                }
            }
          #endif
        }

        NudgeWorkerThread(plts->idThread);

        // tell CEm_LL_ThreadProc that acquire finished.
      #ifdef USE_WM_INPUT
        SetEvent( g_hEventThread );
      #endif

    }

    ExitOleProc();
    return hres;
}

#endif  /* USE_SLOW_LL_HOOKS */

/*****************************************************************************
 *
 *          Joystick emulation
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Joy_Acquire |
 *
 *          Acquire a joystick.  Nothing happens.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Joy_Acquire(PEM this, BOOL fAcquire)
{
    AssertF(this->dwSignature == CEM_SIGNATURE);
    return S_OK;
}

/*****************************************************************************
 *
 *          Joystick globals
 *
 *          Since we don't use joystick emulation by default, we allocate
 *          the emulation variables dynamically so we don't blow a page
 *          of memory on them.
 *
 *****************************************************************************/

typedef struct JOYEMVARS {
    ED rged[cJoyMax];
    DIJOYSTATE2 rgjs2[cJoyMax];
} JOYEMVARS, *PJOYEMVARS;

static PJOYEMVARS s_pjev;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Joy_CreateInstance |
 *
 *          Create a joystick thing.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *****************************************************************************/

#define OBJAT(T, v) (*(T *)(v))
#define PUN(T, v)   OBJAT(T, &(v))

HRESULT INTERNAL
CEm_Joy_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    HRESULT hres;

    DllEnterCrit();
    if (s_pjev == 0) {
        DWORD uiJoy;

        hres = AllocCbPpv(cbX(JOYEMVARS), &s_pjev);
        if (SUCCEEDED(hres)) {
            for (uiJoy = 0; uiJoy < cJoyMax; uiJoy++) {
                PUN(PV, s_pjev->rged[uiJoy].pState) = &s_pjev->rgjs2[uiJoy];
                s_pjev->rged[uiJoy].Acquire = CEm_Joy_Acquire;
                s_pjev->rged[uiJoy].cbData = cbX(s_pjev->rgjs2[uiJoy]);
                s_pjev->rged[uiJoy].cRef   = 0x0;
            }
        }
    } else {
        hres = S_OK;
    }
    DllLeaveCrit();

    if (SUCCEEDED(hres)) {
        hres = CEm_CreateInstance(pdevf, ppviOut,
                                  &s_pjev->rged[pdevf->dwExtra]);
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Joy_Ping |
 *
 *          Read data from the joystick.
 *
 *  @parm   PVXDINSTANCE * | ppvi |
 *
 *          Information about the gizmo being mangled.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_Joy_Ping(PVXDINSTANCE *ppvi)
{
    HRESULT hres;
    JOYINFOEX ji;
    MMRESULT mmrc;
    PEM this = _thisPvNm(*ppvi, vi);

    AssertF(this->dwSignature == CEM_SIGNATURE);
    ji.dwSize = cbX(ji);
    ji.dwFlags = JOY_RETURNALL + JOY_RETURNRAWDATA;
    ji.dwPOV = JOY_POVCENTERED;         /* joyGetPosEx forgets to set this */

    mmrc = joyGetPosEx((DWORD)(UINT_PTR)this->dwExtra, &ji);
    if (mmrc == JOYERR_NOERROR) {
        DIJOYSTATE2 js;
        UINT uiButtons;

        ZeroX(js);                      /* Wipe out the bogus things */

        js.lX = ji.dwXpos;
        js.lY = ji.dwYpos;
        js.lZ = ji.dwZpos;
        js.lRz = ji.dwRpos;
        js.rglSlider[0] = ji.dwUpos;
        js.rglSlider[1] = ji.dwVpos;
        js.rgdwPOV[0] = ji.dwPOV;
        js.rgdwPOV[1] = JOY_POVCENTERED;
        js.rgdwPOV[2] = JOY_POVCENTERED;
        js.rgdwPOV[3] = JOY_POVCENTERED;

        for (uiButtons = 0; uiButtons < 32; uiButtons++) {
            if (ji.dwButtons & (1 << uiButtons)) {
                js.rgbButtons[uiButtons] = 0x80;
            }
        }

        CEm_AddState(&s_pjev->rged[this->dwExtra], &js, GetTickCount());

        hres = S_OK;
    } else {
        CEm_ForceDeviceUnacquire(&s_pjev->rged[this->dwExtra],
                                 FDUFL_UNPLUGGED);
        hres = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,
                                            ERROR_DEV_NOT_EXIST);
    }

    return hres;
}


HRESULT EXTERNAL
NotifyWorkerThreadPem(DWORD idThread, PEM pem)
{
    PLLTHREADSTATE plts;
    HRESULT hres;

    hres = CEm_GetWorkerThread(pem, &plts);

    if( SUCCEEDED(hres) )
    {
        AssertF(plts->idThread == idThread);

        hres = NudgeWorkerThreadPem( plts, pem );
    }
    return hres;
}





HRESULT EXTERNAL
NudgeWorkerThreadPem( PLLTHREADSTATE plts, PEM pem )
{
    //PREFIX: using uninitialized memory 'hres'
    // Millen Bug#129163, 29345
    HRESULT hres = S_FALSE;

    plts->pemCheck = pem;

    if( !PostWorkerMessage(plts->idThread, pem))
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
                        TEXT("NudgeWorkerThreadPem: PostThreadMessage Failed with error %d"),
                        GetLastError() );
        hres = S_FALSE;
    }
    else if( pem )
    {
        DWORD dwRc;

        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("NudgeWorkerThreadPem: PostThreadMessage SUCCEEDED, waiting for event ... "));


        /*
         *  According to a comment in CEm_LL_ThreadProc Win95 may
         *  fail with an invalid parameter error, so if it does,
         *  keep trying.  (Assume no valid case will occur.)
         */
        do
        {
            dwRc = WaitForMultipleObjects( 2, &plts->hThread, FALSE, INFINITE);
        } while ( ( dwRc == WAIT_FAILED ) && ( GetLastError() == ERROR_INVALID_PARAMETER ) );

        switch( dwRc )
        {
        case WAIT_OBJECT_0:
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("NotifyWorkerThreadPem: Not expecting response from dead worker thread") );
            hres = S_FALSE;
            break;
        case WAIT_OBJECT_0 + 1:
            /*
             *  The worker thread responded OK
             */
            hres = S_OK;
            AssertF(plts->pemCheck == NULL );
            break;
        default:
            SquirtSqflPtszV(sqfl | sqflError,
                TEXT("NotifyWorkerThreadPem: WaitForMultipleObjects returned 0x%08x with LastError %d"),
                dwRc, GetLastError() );
            hres = E_FAIL;
            break;
        }

    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\diem.h ===
/*****************************************************************************
 *
 *  DIEm.h
 *
 *  Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      DirectInput internal header file for emulation.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CEd |
 *
 *          Emulation descriptor.  One of these is created for each
 *          device.  It is never destroyed, so the variable must
 *          be a global variable or memory allocated inside a
 *          container that will eventually be destroyed.
 *
 *          ISSUE-2001/03/29-timgill  Need a better destructor function
 *
 *  @field  LPVOID const | pState |
 *
 *          State buffer that everybody parties into.
 *
 *          It too is never destroyed, so once again it should be
 *          a global variable or live inside something else that
 *          will be destroyed.
 *
 *  @field  LPDWORD const | pDevType |
 *
 *          Array of device type descriptors, indexed by data format
 *          offset.  Used to determine whether a particular piece of
 *          data belongs to an axis, button, or POV.
 *
 *  @field  EMULATIONPROC | Acquire |
 *
 *          Callback function for acquisition and loss thereof.
 *          It is called once when the first client acquires,
 *          and again when the last app unacquires.  It is not
 *          informed of nested acquisition.
 *
 *  @field  LONG | cAcquire |
 *
 *          Number of times the device emulation has been acquired (minus one). 
 *
 *  @field  DWORD | cbData |
 *
 *          Size of the device data type.  In other words, size of
 *          <p pState> in bytes.
 *
 *****************************************************************************/

typedef STDMETHOD(EMULATIONPROC)(struct CEm *, BOOL fAcquire);

typedef struct CEd {

    LPVOID const    pState;
    LPDWORD const   pDevType;
    EMULATIONPROC   Acquire;
    LONG            cAcquire;
    DWORD           cbData;
    ULONG           cRef;
} CEd, ED, *PED;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CEm |
 *
 *          Emulation state information.
 *
 *  @field  VXDINSTANCE | vi |
 *
 *          Information shared with parent device.
 *
 *  @field  PEM | pemNext |
 *
 *          Next item in linked list of all active device instances.
 *
 *  @field  LPDWORD | rgdwDf |
 *
 *          Array of items (one for each byte in the device
 *          data format).  This maps each device data format byte
 *          into an application device data offset, or -1 if the
 *          application doesn't care about the corresponding object.
 *
 *  @field  ULONG_PTR  | dwExtra |
 *
 *          Extra information passed in the <t VXDDEVICEFORMAT>
 *          when the device was created.  This is used by each
 *          particular device to encode additional instance infomation.
 *
 *  @field  PED | ped |
 *
 *          The device that owns this instance.  Multiple instances
 *          of the same device share the same <e CEm.ped>.
 *
 *  @field  LONG | cRef |
 *
 *          Reference count.
 *
 *
 *  @field  LONG | cAcquire |
 *
 *          Number of times the device instance has been acquired (minus one). 
 *
 *
 *  @field  BOOL | fWorkerThread |
 *
 *          This is used by low-level hooks and HID devices, which
 *          require a worker thread to collect the data.
 *          This is not cheap, so
 *          instead, we spin up the thread on the first acquire, and
 *          on the unacquire, we keep the thread around so that the next
 *          acquire is fast.  When the last object is released, we finally
 *          kill the thread.
 *
 *****************************************************************************/

typedef struct CEm {

    VXDINSTANCE vi;             /* This must be first */
    struct CEm *pemNext;
    LPDWORD rgdwDf;
    ULONG_PTR   dwExtra;
    PED     ped;
    LONG    cAcquire;
    LONG    cRef;
#ifdef WORKER_THREAD
    BOOL    fWorkerThread;
#endif
#ifdef DEBUG
    DWORD   dwSignature;
#endif
    BOOL    fHidden;
} CEm, EM, *PEM;

#define CEM_SIGNATURE       0x4D4D4545      /* "EEMM" */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PEM | pemFromPvi |
 *
 *          Given an interior pointer to a <t VXDINSTANCE>, retrieve
 *          a pointer to the parent <t CEm>.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The pointer to convert.
 *
 *****************************************************************************/

PEM INLINE
pemFromPvi(PVXDINSTANCE pvi)
{
    return pvSubPvCb(pvi, FIELD_OFFSET(CEm, vi));
}

/*****************************************************************************
 *
 *          NT low-level hook support
 *
 *          Low-level hooks live on a separate thread which we spin
 *          up when first requested and take down when the last
 *          DirectInput device that used a thread has been destroyed.
 *
 *          If we wanted, we could destroy the thread when the
 *          device is unacquired (rather than when the device is
 *          destroyed), but we cache the thread instead, because
 *          a device that once has been acquired will probably be
 *          acquired again.
 *
 *          To prevent race conditions from crashing us, we addref
 *          our DLL when the thread exists and have the thread
 *          perform a FreeLibrary as its final act.
 *
 *          Note that this helper thread is also used by the HID data
 *          collector.
 *
 *****************************************************************************/

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct LLHOOKSTATE |
 *
 *          Low-level hook information about a single hook.
 *
 *  @field  int | cHook |
 *
 *          Number of times the hook has been requested.  If zero,
 *          then there should be no hook.  All modifications to
 *          this field must be interlocked to avoid race conditions
 *          when two threads try to hook or unhook simultaneously.
 *
 *  @field  int | cExcl |
 *
 *          Number of times the hook has been requested in an exclusive 
 *          mode.  This value should always be less than or equal to the 
 *          cHook value.  All modifications to this field must be 
 *          interlocked to avoid race conditions when two threads try to 
 *          hook or unhook simultaneously.
 *
 *  @field  HHOOK | hhk |
 *
 *          The actual hook, if it is installed.  Only the hook thread
 *          touches this field, so it does not need to be protected.
 *
 *  @field  BOOLEAN | fExcluded |
 *
 *          Flag to indicate whether or not exclusivity has been applied.  
 *          Only the hook thread touches this field, so it does not need to 
 *          be protected.
 *
 *****************************************************************************/

typedef struct LLHOOKSTATE {

    int     cHook;
    int     cExcl;
    HHOOK   hhk;
    BOOLEAN fExcluded;

} LLHOOKSTATE, *PLLHOOKSTATE;

LRESULT CALLBACK CEm_LL_KbdHook(int nCode, WPARAM wp, LPARAM lp);
LRESULT CALLBACK CEm_LL_MseHook(int nCode, WPARAM wp, LPARAM lp);

#endif  /* USE_SLOW_LL_HOOKS */

#ifdef WORKER_THREAD

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct LLTHREADSTATE |
 *
 *          Low-level hook state for a thread.  Note that this is
 *          a dynamically
 *          allocated structure instead of a static.  This avoids various
 *          race conditions where, for example, somebody terminates the
 *          worker thread and somebody else starts it up before the
 *          worker thread is completely gone.
 *
 *          A pointer to the hThread is passed as the pointer to an array 
 *          of two handles in calls to WaitForMultipleObject so hEvent must 
 *          follow it directly.
 *
 *  @field  DWORD | idThread |
 *
 *          The ID of the worker thread.
 *
 *  @field  LONG | cRef |
 *
 *          Thread reference count.  The thread kills itself when this
 *          drops to zero.
 *
 *  @field  LLHOOKSTATE | rglhs[2] |
 *
 *          Hook states, indexed by LLTS_* values.
 *
 *          These are used only if low-level hooks are enabled.
 *
 *  @field  HANDLE | hThread |
 *
 *          The handle (from the create) of the worker thread.
 *
 *          This is used only if HID support is enabled.
 *
 *  @field  HANDLE | hEvent |
 *
 *          The handle to the event used to synchronize with the worker thread.
 *
 *          This is used only if HID support is enabled.
 *
 *  @field  GPA | gpaHid |
 *
 *          Pointer array of HID devices which are acquired.
 *
 *          This is used only if HID support is enabled.
 *
 *  @field  PEM | pemCheck |
 *
 *          Pointer to Emulation state information.
 *
 *          This is used only if HID support is enabled.
 *
 *****************************************************************************/

#define LLTS_KBD    0
#define LLTS_MSE    1
#define LLTS_MAX    2

typedef struct LLTHREADSTATE {
    DWORD       idThread;
    LONG        cRef;
#ifdef USE_SLOW_LL_HOOKS
    LLHOOKSTATE rglhs[LLTS_MAX];
#endif
#ifdef HID_SUPPORT
    HANDLE      hThread;    /* MUST be followed by hEvent, see above */
    HANDLE      hEvent;     /* MUST follow hThread, see above */
    GPA         gpaHid;
    PEM         pemCheck;
#endif
} LLTHREADSTATE, *PLLTHREADSTATE;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @topic  Communicating with the worker thread |
 *
 *          Communication with the worker thread is performed via
 *          <c WM_NULL> messages.  Extra care must be taken to make
 *          sure that someone isn't randomly sending messages to us.
 *
 *          We use the <c WM_NULL> message because there are race
 *          windows where we might post a message to a thread after
 *          it is gone.  During this window, the thread ID might get
 *          recycled, and we end up posting the message to some random
 *          thread that isn't ours.  By using the <c WM_NULL> message,
 *          we are safe in knowing that the target thread won't barf
 *          on the unexpected message.
 *
 *          The <t WPARAM> of the <c WM_NULL> is the magic value
 *          <c WT_WPARAM>.
 *
 *          The <t LPARAM> of the <c WM_NULL> is either a pointer
 *          to the <t CEm> that needs to be refreshed or is
 *          zero if we merely want to check our bearings.
 *
 *****************************************************************************/

#define WT_WPARAM       0

#define PostWorkerMessage(thid, lp)                                     \
        PostThreadMessage(thid, WM_NULL, WT_WPARAM, (LPARAM)(lp))       \

#define NudgeWorkerThread(thid)                                         \
        PostThreadMessage(thid, WM_NULL, WT_WPARAM, (LPARAM)NULL)

HRESULT EXTERNAL NudgeWorkerThreadPem( PLLTHREADSTATE plts, PEM pem );

HRESULT EXTERNAL NotifyWorkerThreadPem(DWORD idThread, PEM pem);

STDMETHODIMP CEm_GetWorkerThread(PEM pem, PLLTHREADSTATE *pplts);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global PLLTHREADSTATE | g_plts |
 *
 *          The thread state of the currently-active thread.
 *
 *          This variable needs to be externally accessible
 *          because you can't pass instance data to a windows
 *          hook function.  (Whose idea was that?)
 *
 *****************************************************************************/

extern PLLTHREADSTATE g_plts;

void EXTERNAL CEm_Mouse_OnMouseChange(void);

#endif  /* WORKER_THREAD */

/*
 *  Private helper functions in diem.c
 */

#define FDUFL_NORMAL       0x0000           /* Nothing unusual */
#define FDUFL_UNPLUGGED    VIFL_UNPLUGGED   /* Device disconnected */

void  EXTERNAL CEm_ForceDeviceUnacquire(PED ped, UINT fdufl);
void  EXTERNAL CEm_AddState(PED ped, LPVOID pvData, DWORD tm);
DWORD EXTERNAL CEm_AddEvent(PED ped, DWORD dwData, DWORD dwOfs, DWORD tm);
BOOL  EXTERNAL CEm_ContinueEvent(PED ped, DWORD dwData, DWORD dwOfs, DWORD tm, DWORD dwSeq);

STDMETHODIMP CEm_LL_Acquire(PEM this, BOOL fAcquire, ULONG fl, UINT ilts);

HRESULT EXTERNAL
CEm_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut, PED ped);

void EXTERNAL CEm_FreeInstance(PEM this);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_AddRef |
 *
 *          Bump the reference count because we're doing something with it.
 *
 *  @parm   PEM | this |
 *
 *          The victim.
 *
 *****************************************************************************/

void INLINE
CEm_AddRef(PEM this)
{
    AssertF(this->dwSignature == CEM_SIGNATURE);
    InterlockedIncrement(&this->cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_Release |
 *
 *          Drop the reference count and blow it away if it's gone.
 *
 *  @parm   PEM | this |
 *
 *          The victim.
 *
 *****************************************************************************/

void INLINE
CEm_Release(PEM this)
{
    AssertF(this->dwSignature == CEM_SIGNATURE);
    if (InterlockedDecrement(&this->cRef) == 0) {
        CEm_FreeInstance(this);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dieffv.c ===
/*****************************************************************************
 *
 *  DIEffV.c
 *
 *  Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Effect driver for VJOYD devices.
 *
 *  Contents:
 *
 *      CEffVxd_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"
#ifndef WINNT

#if defined(IDirectInputDevice2Vtbl)

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflVxdEff

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CEffVxd_New!
 *
 *****************************************************************************/

Primary_Interface(CEffVxd, IDirectInputEffectDriver);

Interface_Template_Begin(CEffVxd)
    Primary_Interface_Template(CEffVxd, IDirectInputEffectDriver)
Interface_Template_End(CEffVxd)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CEffVxd |
 *
 *          An <i IDirectInputEffectDriver> wrapper for VJOYD
 *          joysticks.
 *
 *  @field  IDirectInputEffectDriver | didc |
 *
 *          The object (containing vtbl).
 *
 *****************************************************************************/

typedef struct CEffVxd {

    /* Supported interfaces */
    IDirectInputEffectDriver ded;

} CEffVxd, DVE, *PDVE;

typedef IDirectInputEffectDriver DED, *PDED;

#define ThisClass CEffVxd
#define ThisInterface IDirectInputEffectDriver
#define riidExpected &IID_IDirectInputEffectDriver

/*****************************************************************************
 *
 *      CEffVxd::QueryInterface   (from IUnknown)
 *      CEffVxd::AddRef           (from IUnknown)
 *      CEffVxd::Release          (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/
/*
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | Finalize |
 *
 *          We don't have any instance data, so we can just
 *          forward to <f Common_Finalize>.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CEffVxd)
Default_AddRef(CEffVxd)
Default_Release(CEffVxd)

#else

#define CEffVxd_QueryInterface      Common_QueryInterface
#define CEffVxd_AddRef              Common_AddRef
#define CEffVxd_Release             Common_Release

#endif

#define CEffVxd_QIHelper            Common_QIHelper
#define CEffVxd_AppFinalize         Common_AppFinalize
#define CEffVxd_Finalize            Common_Finalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | DeviceID |
 *
 *          Inform the driver of the identity of the device.
 *          See <mf IDirectInputEffectDriver::DeviceID>
 *          for more information.
 *
 *          Doesn't do anything because VJOYD will already
 *          have told the driver its identity.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwDirectInputVersion |
 *
 *          The version of DirectInput that loaded the
 *          effect driver.
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The joystick ID number being used.
 *          The Windows joystick subsystem allocates external IDs.
 *
 *  @parm   DWORD | fBegin |
 *
 *          Nonzero if access to the device is beginning.
 *          Zero if the access to the device is ending.
 *
 *  @parm   DWORD | dwInternalID |
 *
 *          Internal joystick id.  The device driver manages
 *          internal IDs.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Reserved for future use (HID).
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_DeviceID(PDED pded, DWORD dwDIVer, DWORD dwExternalID, DWORD fBegin,
                 DWORD dwInternalID, LPVOID pvReserved)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::DeviceID,
               (_ "pxuuu", pded, dwDIVer, dwExternalID, fBegin, dwInternalID));

    this = _thisPvNm(pded, ded);

    dwDIVer;
    dwExternalID;
    fBegin;
    dwInternalID;
    pvReserved;

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEffVxd_Ioctl |
 *
 *          Perform an IOCTL to VJOYD.
 *
 *  @parm   DWORD | dwIOCode |
 *
 *          The function to perform.
 *
 *  @parm   PV | pvIn |
 *
 *          Input arguments, the number of which depends on the
 *          function code.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_Ioctl(DWORD dwIOCode, PV pvIn)
{
    HRESULT hres;
    HRESULT hresFF;
    EnterProc(CEffVxD_Ioctl, (_ "u", dwIOCode));

    /*
     *  Once again, we rely on the fact that STDCALL passes
     *  parameters right to left, so our arguments are exactly
     *  in the form of a VXDFFIO structure.
     */
    CAssertF(cbX(VXDFFIO) == cbX(dwIOCode) + cbX(pvIn));
    CAssertF(FIELD_OFFSET(VXDFFIO, dwIOCode) == 0);
    CAssertF(FIELD_OFFSET(VXDFFIO, pvArgs) == cbX(dwIOCode));
    AssertF(cbSubPvPv(&pvIn, &dwIOCode) == cbX(dwIOCode));

    hres = IoctlHw(IOCTL_JOY_FFIO, &dwIOCode, cbX(VXDFFIO),
                   &hresFF, cbX(hresFF));
    if (SUCCEEDED(hres)) {
        hres = hresFF;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | Escape |
 *
 *          Escape to the driver.
 *          See <mf IDirectInputEffectDriver::Escape>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The joystick ID number being used.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect at which the command is directed.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Command block.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_Escape(PDED pded, DWORD dwId, DWORD dwEffect, LPDIEFFESCAPE pesc)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::Escape,
               (_ "puxx", pded, dwId, dwEffect, pesc->dwCommand));

    this = _thisPvNm(pded, ded);

    dwId;
    dwEffect;
    pesc;

    hres = CEffVxd_Ioctl(FFIO_ESCAPE, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | SetGain |
 *
 *          Set the overall device gain.
 *          See <mf IDirectInputEffectDriver::SetGain>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The joystick ID number being used.
 *
 *  @parm   DWORD | dwGain |
 *
 *          The new gain value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_SetGain(PDED pded, DWORD dwId, DWORD dwGain)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::SetGain,
               (_ "puu", pded, dwId, dwGain));

    this = _thisPvNm(pded, ded);

    dwId;
    hres = CEffVxd_Ioctl(FFIO_SETGAIN, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | SetForceFeedbackState |
 *
 *          Change the force feedback state for the device.
 *          See <mf IDirectInputEffectDriver::SetForceFeedbackState>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwState |
 *
 *          New state, one of the <c DEV_*> values.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_SetForceFeedbackState(PDED pded, DWORD dwId, DWORD dwState)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::SetForceFeedbackState,
               (_ "pux", pded, dwId, dwState));

    this = _thisPvNm(pded, ded);

    dwId;
    dwState;

    hres = CEffVxd_Ioctl(FFIO_SETFFSTATE, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | GetForceFeedbackState |
 *
 *          Retrieve the force feedback state for the device.
 *          See <mf IDirectInputEffectDriver::GetForceFeedbackState>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   LPDIDEVICESTATE | pds |
 *
 *          Receives device state.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_GetForceFeedbackState(PDED pded, DWORD dwId, LPDIDEVICESTATE pds)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::GetForceFeedbackState,
               (_ "pup", pded, dwId, pds));

    this = _thisPvNm(pded, ded);

    dwId;
    pds;

    hres = CEffVxd_Ioctl(FFIO_GETFFSTATE, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | DownloadEffect |
 *
 *          Send an effect to the device.
 *          See <mf IDirectInputEffectDriver::SetGain>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffectId |
 *
 *          Magic cookie dword that identifies the effect.
 *
 *  @parm   IN OUT LPDWORD | pdwEffect |
 *
 *          The effect being modified.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The new parameters for the effect.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIEP_*> flags.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_DownloadEffect(PDED pded, DWORD dwId, DWORD dwEffectId,
                       LPDWORD pdwEffect, LPCDIEFFECT peff, DWORD fl)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::DownloadEffect,
               (_ "puxxpx", pded, dwId, dwEffectId, *pdwEffect, peff, fl));

    this = _thisPvNm(pded, ded);

    dwEffectId;
    pdwEffect;
    peff;
    fl;

    hres = CEffVxd_Ioctl(FFIO_DOWNLOADEFFECT, &dwId);

    ExitOleProcPpv(pdwEffect);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | DestroyEffect |
 *
 *          Remove an effect from the device.
 *          See <mf IDirectInputEffectDriver::DestroyEffect>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be destroyed.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_DestroyEffect(PDED pded, DWORD dwId, DWORD dwEffect)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::DestroyEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    dwEffect;

    hres = CEffVxd_Ioctl(FFIO_DESTROYEFFECT, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | StartEffect |
 *
 *          Begin playback of an effect.
 *          See <mf IDirectInputEffectDriver::StartEffect>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be played.
 *
 *  @parm   DWORD | dwMode |
 *
 *          How the effect is to affect other effects.
 *
 *  @parm   DWORD | dwCount |
 *
 *          Number of times the effect is to be played.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_StartEffect(PDED pded, DWORD dwId, DWORD dwEffect,
                    DWORD dwMode, DWORD dwCount)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::StartEffect,
               (_ "puxxu", pded, dwId, dwEffect, dwMode, dwCount));

    this = _thisPvNm(pded, ded);

    dwEffect;
    dwMode;
    dwCount;
    hres = CEffVxd_Ioctl(FFIO_STARTEFFECT, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | StopEffect |
 *
 *          Halt playback of an effect.
 *          See <mf IDirectInputEffectDriver::StartEffect>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be stopped.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_StopEffect(PDED pded, DWORD dwId, DWORD dwEffect)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::StopEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    dwEffect;
    hres = CEffVxd_Ioctl(FFIO_STOPEFFECT, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | GetEffectStatus |
 *
 *          Obtain information about an effect.
 *          See <mf IDirectInputEffectDriver::StartEffect>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be queried.
 *
 *  @parm   LPDWORD | pdwStatus |
 *
 *          Receives the effect status.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_GetEffectStatus(PDED pded, DWORD dwId, DWORD dwEffect,
                        LPDWORD pdwStatus)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::StopEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    dwEffect;
    pdwStatus;
    hres = CEffVxd_Ioctl(FFIO_GETEFFECTSTATUS, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | CEffVxd | GetVersions |
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   LPDIDRIVERVERSIONS | pvers |
 *
 *          A structure which should be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *          DirectInput will set the <e DIDRIVERVERSIONS.dwSize> field
 *          to sizeof(DIDRIVERVERSIONS) before calling this method.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_GetVersions(PDED pded, LPDIDRIVERVERSIONS pvers)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::GetVersions, (_ "pux", pded));

    this = _thisPvNm(pded, ded);

    /*
     *  Returning E_NOTIMPL causes DirectInput to ask the VxD for the same
     *  information.
     */
    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *      CEffVxd_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::<constructor>,
               (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CEffVxd, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        PDVE this;
        if (Num_Interfaces(CEffVxd) == 1) {
            this = _thisPvNm(*ppvObj, ded);
        } else {
            this = _thisPv(*ppvObj);
        }

        /* No initialization needed */
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CEffVxd_Signature        0x46454556      /* "VEFF" */

Primary_Interface_Begin(CEffVxd, IDirectInputEffectDriver)
    CEffVxd_DeviceID,
    CEffVxd_GetVersions,
    CEffVxd_Escape,
    CEffVxd_SetGain,
    CEffVxd_SetForceFeedbackState,
    CEffVxd_GetForceFeedbackState,
    CEffVxd_DownloadEffect,
    CEffVxd_DestroyEffect,
    CEffVxd_StartEffect,
    CEffVxd_StopEffect,
    CEffVxd_GetEffectStatus,
Primary_Interface_End(CEffVxd, IDirectInputEffectDriver)

#endif // defined(IDirectInputDevice2Vtbl)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dieff.c ===
/*****************************************************************************
 *
 *  DIEff.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The standard implementation of IDirectInputEffect.
 *
 *      This is the device-independent part.  the device-dependent
 *      part is handled by the IDirectInputEffectShepherd.
 *
 *  Contents:
 *
 *      CDIEff_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef IDirectInputDevice2Vtbl

/*****************************************************************************
 *
 *      Note!
 *
 *      Out of laziness, all effects share the same critical section as
 *      their parent device.  This saves us from all sorts of race
 *      conditions.  Not all of them, but a big chunk of them.
 *
 *      A common race condition that this protects us against is
 *      where an application tries to download an effect at the same
 *      time another thread decides to unacquire the device.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      More laziness:  "TypeSpecificParams" is such a long thing.
 *
 *****************************************************************************/

#define cbTSP       cbTypeSpecificParams
#define lpvTSP      lpvTypeSpecificParams

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEff

/*****************************************************************************
 *
 *    The flags for dwMessage
 *
 *****************************************************************************/
#define EFF_DEFAULT 0
#define EFF_PLAY    1
#define EFF_STOP    2

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CDIEff, IDirectInputEffect);

Interface_Template_Begin(CDIEff)
    Primary_Interface_Template(CDIEff, IDirectInputEffect)
Interface_Template_End(CDIEff)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CDIEff |
 *
 *          The generic <i IDirectInputEffect> object.
 *
 *  @field  IDirectInputEffect | def |
 *
 *          <i DirectInputEffect> object (containing vtbl).
 *
 *  @field  struct CDIDev * | pdev |
 *
 *          Reference to parent device tracked via <f Common_Hold>.
 *
 *  @field  DICREATEEFFECTINFO | cei |
 *
 *          Parameters that tell us how to talk to the effect driver.
 *
 *  @field  BOOL | fInitialized:1 |
 *
 *          Do we know who we are?
 *
 *  @field  BOOL | fDadNotified:1 |
 *
 *          Does our parent know that we exist?
 *
 *  @field  BOOL | fDadDead:1 |
 *
 *          Has our parent been destroyed (from the app's point of view)?
 *
 *  @field  TSDPROC | hresValidTsd |
 *
 *          Callback function that validates the type-specific data.
 *
 *  @field  DIEFFECTATTRIBUTES | dEffAttributes |
 *
 *         Attributes of the effect (includes dwEffectType and dwEffectId, among others).
 *
 *  @field  HANDLE | hEventDelete |
 *
 *          Event to signal to the timer thread that the app performed final release on the effect.
 *
 *  @field  HANDLE | hEventThreadDead |
 *
 *          Event to signal AppFinalize to perform the final release on the effect.
 *
 *  @field  HANDLE | hEventGeneral |
 *
 *          Event to signal to the timer thread that the app called Start(...) or Stop() the effect.
 *
 *  @field  DWORD | dwMessage |
 *
 *			Message to the thread as to which event hEventGeneral is actually signaling.
 *			Can be EFF_DEFAULT, EFF_PLAY or EFF_STOP>
 *
 *  @field  DWORD | dwcLoop|
 *
 *			Loop count for playing the effect (passed in the call to Start(...))
 *
 *  @field  DWORD | dwFlags |
 *
 *          Flags for playing the effect (passed in the call to Start(...))
 *
 *  @field  DWORD | diepDirty |
 *
 *          The parts of the effect which are "dirty" and need to
 *          be updated by the next <mf IDirectInputEffect::Download>.
 *
 *  @field  DWORD | diepUnset |
 *
 *          The parts of the effect which have yet to be set by the
 *          application.  Items which we can set decent defaults for
 *          are not counted.
 *
 *  @field  DWORD | dwDirFlags |
 *
 *          Flags that record the direction format the application
 *          last set.
 *
 *  @field  DWORD | dwCoords |
 *
 *          Coordinate systems supported by device.
 *
 *  @field  LPVOID | lpvTSP |
 *
 *          Temporary buffer used to cache type-specific parameters
 *          during Try'ing of proposed effect parameters.
 *
 *  @field  SHEPHANDLE | sh |
 *
 *          Effect handle information.
 *
 *  @field  DIEFFECT | eff |
 *
 *          Cached effect parameters as they exist (or should exist)
 *          on the device.
 *          Direction parameters are in device-preferred coordinates.
 *
 *  @field  DIENVELOPE | env |
 *
 *          Cached envelope parameters as they exist (or should exist)
 *          on the device.
 *
 *  @field  LONG | rglDirApp[DIEFFECT_MAXAXES] |
 *
 *          Cached direction list, in application native format.
 *          The format of this array is kept in the
 *          <e CDIEff.dwDirFlags> field.
 *
 *  @field  DWORD | rgdwAxes[DIEFFECT_MAXAXES] |
 *
 *          Cached axis list, stored as item numbers.
 *
 *  @field  LONG | rglDirDev[DIEFFECT_MAXAXES] |
 *
 *          Cached direction list, in device native format.
 *          The format of this array is kept in the
 *          <e DIEFFECT.dwFlags> field of the
 *          <e CDIEff.eff>.
 *
 *  @field  GUID | guid |
 *
 *          Identity.
 *
 *****************************************************************************/

typedef STDMETHOD(TSDPROC)(LPCDIEFFECT peff, DWORD cAxes);

typedef struct CDIEff {

    /* Supported interfaces */
    IDirectInputEffect def;

    struct CDIDev *pdev;
    LPDIRECTINPUTEFFECTSHEPHERD pes;

    BOOL fDadNotified:1;
    BOOL fDadDead:1;
    BOOL fInitialized:1;

    TSDPROC hresValidTsd;

    /* WARNING!  EVERYTHING AFTER THIS LINE IS ZERO'd ON A RESET */

	DIEFFECTATTRIBUTES dEffAttributes;
	HANDLE hEventDelete;
	HANDLE hEventGeneral;
    HANDLE hEventThreadDead;
	DWORD dwMessage;

	DWORD dwcLoop;
	DWORD dwFlags;

    DWORD diepDirty;
    DWORD diepUnset;
    DWORD dwDirFlags;
    DWORD dwCoords;
    LPVOID lpvTSP;
    SHEPHANDLE sh;

    DIEFFECT effDev;
    DIEFFECT effTry;
    DIENVELOPE env;

    GUID guid;

    LONG rglDirApp[DIEFFECT_MAXAXES];
    DWORD rgdwAxes[DIEFFECT_MAXAXES];
    LONG rglDirDev[DIEFFECT_MAXAXES];
    LONG rglDirTry[DIEFFECT_MAXAXES];

    /* WARNING!  EVERYTHING ABOVE THIS LINE IS ZERO'd ON A RESET */

    /*
     *  The Reset() function assumes that the entire remainder
     *  of the structure is to be zero'd out, so if you add a field
     *  here, make sure to adjust Reset() accordingly.
     */

} CDIEff, DE, *PDE;

#define ThisClass CDIEff
#define ThisInterface IDirectInputEffect

/*****************************************************************************
 *
 *      Forward declarations
 *
 *      These are out of laziness, not out of necessity.
 *
 *****************************************************************************/

STDMETHODIMP CDIEff_IsValidUnknownTsd(LPCDIEFFECT peff, DWORD cAxes);

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CDIEff)
Default_AddRef(CDIEff)
Default_Release(CDIEff)

#else

#define CDIEff_QueryInterface           Common_QueryInterface
#define CDIEff_AddRef                   Common_AddRef
#define CDIEff_Release                  Common_Release
#endif

#define CDIEff_QIHelper                 Common_QIHelper

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIEff | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @cwrap  PDE | this
 *
 *****************************************************************************/

void INLINE  
CDIEff_EnterCrit(PDE this)
{
    AssertF(this->pdev);
    CDIDev_EnterCrit(this->pdev);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIEff | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *  @cwrap  PDE | this
 *
 *****************************************************************************/

void INLINE
CDIEff_LeaveCrit(PDE this)
{
    AssertF(this->pdev);
    CDIDev_LeaveCrit(this->pdev);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIEff | CanAccess |
 *
 *          Check if the effect can be accessed.  For this to succeeed,
 *          the effect must be initialized, and the parent device
 *          must be acquired in exclusive mode.
 *
 *  @cwrap  PDE | this
 *
 *  @returns
 *
 *          <c S_OK> if the device is exclusively acquired.
 *
 *          <c DIERR_INPUTLOST> if acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> the device is acquired,
 *          but not exclusively, or if the device is not acquired
 *          at all.
 *
 *          <c DIERR_NOTINITIALIZED> if the effect object has not
 *          yet been initialized.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_CanAccess_(this, z)                                  \
       _CDIEff_CanAccess_(this)                                     \

#endif

STDMETHODIMP
CDIEff_CanAccess_(PDE this, LPCSTR s_szProc)
{
    HRESULT hres;

    AssertF(this->pdev);
    AssertF(CDIDev_InCrit(this->pdev));

    if (this->fInitialized) {
        hres = CDIDev_IsExclAcquired(this->pdev);
    } else {
        if (s_szProc) {
            RPF("ERROR %s: Effect not initialized", s_szProc);
        }
        hres = DIERR_NOTINITIALIZED;
    }

    return hres;
}

#define CDIEff_CanAccess(this)                                      \
        CDIEff_CanAccess_(this, s_szProc)                           \

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_Reset |
 *
 *          Releases all the resources of a generic effect that
 *          are associated with a particular device effect instance.
 *
 *          This method is called in preparation for reinitialization.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being reset.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_Reset(PDE this)
{
	HRESULT hres;

    AssertF(this->pdev);
    CDIEff_EnterCrit(this);

    /*
     *  Destroying an effect implicitly stops it.
     *
     *  It's okay if this fails (and in fact it usually will).
     *  We're just playing it safe.
     */
    hres = IDirectInputEffectShepherd_DestroyEffect(this->pes, &this->sh);

    AssertF(this->lpvTSP == 0);
    FreePpv(&this->effDev.lpvTSP);

	//rezero the entire DIEFFECTATTRIBUTES!
	ZeroBuf(&this->dEffAttributes, 
                         cbX(DE) -
                         FIELD_OFFSET(DE, dEffAttributes));


	//rezero effect's event handles
	if (this->hEventDelete != NULL)
	{
		CloseHandle(this->hEventDelete);
		this->hEventDelete = NULL;
	}

	if (this->hEventGeneral != NULL)
	{
		CloseHandle(this->hEventGeneral);
		this->hEventGeneral = NULL;
	}
	
	if (this->hEventThreadDead != NULL)
	{
		CloseHandle(this->hEventThreadDead);
		this->hEventThreadDead = NULL;
	}

	this->dwMessage = EFF_DEFAULT;

    this->effDev.dwSize = cbX(this->effDev);
    this->env.dwSize = cbX(this->env);

    /*
     *  DIEP_DURATION               - Defaults to zero.
     *  DIEP_SAMPLEPERIOD           - Defaults to zero.
     *  DIEP_GAIN                   - Defaults to zero.
     *  DIEP_TRIGGERBUTTON          - Defaults to DIEB_NOTRIGGER.
     *  DIEP_TRIGGERREPEATINTERVAL  - Defaults to INFINITE (no autorepeat).
     *  DIEP_AXES                   - Must be set manually.
     *  DIEP_DIRECTION              - Must be set manually.
     *  DIEP_ENVELOPE               - No envelope.
     *  DIEP_TYPESPECIFICPARAMS     - Must be set manually.
#if DIRECTINPUT_VERSION >= 0x0600
     *  DIEP_STARTDELAY             - Defaults to zero.
#endif
     */

    this->effDev.dwTriggerButton = DIEB_NOTRIGGER;

    this->diepUnset = DIEP_AXES |
                      DIEP_DIRECTION |
                      DIEP_TYPESPECIFICPARAMS;

    this->effDev.rgdwAxes = this->rgdwAxes;
    this->effDev.rglDirection = this->rglDirDev;

    this->fInitialized = 0;

    CDIEff_LeaveCrit(this);

    hres = S_OK;

    return hres;


}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | UnloadWorker |
 *
 *          Remove the effect from the device.  All parameters have
 *          been validated.
 *
 *  @cwrap  PDE | this
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The effect was not previously downloaded,
 *          so there was nothing to unload.  Note that this is a
 *          success code.
 *
 *          <c DI_PROPNOEFFECT> = <c S_FALSE>: The effect was not
 *          previously downloaded.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not yet been <mf IDirectInputEffect::Initialize>d.
 *
 *          <c DIERR_INPUTLOST> if acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> the device is acquired,
 *          but not exclusively, or if the device is not acquired
 *          at all.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_UnloadWorker_(this, z)                               \
       _CDIEff_UnloadWorker_(this)                                  \

#endif

HRESULT INTERNAL
CDIEff_UnloadWorker_(PDE this, LPCSTR s_szProc)
{

	HRESULT hres;

    AssertF(CDIDev_InCrit(this->pdev));

    if (SUCCEEDED(hres = CDIEff_CanAccess(this))) {
        /*
         *  The effect driver will stop the effect (if it is playing)
         *  before destroying it.
         */
            hres = IDirectInputEffectShepherd_DestroyEffect(
                        this->pes, &this->sh);
    } else {
        /*
         *  The effect is dead.  Long live the effect.
         */
        this->sh.dwEffect = 0;
    }

    this->diepDirty = DIEP_ALLPARAMS;

    return hres;

}

#define CDIEff_UnloadWorker(this)                                   \
        CDIEff_UnloadWorker_(this, s_szProc)                        \

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIEff_AppFinalize |
 *
 *          The application has performed its final release.
 *
 *          Tell our parent that we are officially dead, so that
 *          dad will stop tracking us and release its hold on us.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CDIEff_AppFinalize(PV pvObj)
{
    PDE this = pvObj;
    DWORD dwRc = 0xFFFFFFFF;

    EnterProcR(CDIEff_AppFinalize, (_ "p", pvObj));

    if (this->fDadNotified) {
        this->fDadNotified = 0;

        CDIEff_EnterCrit(this);

		/*
		 * Kill the timer thread, if any.
		 * For this, fire off the effect's event.
		 */
		
		if (this->hEventDelete != NULL) {
            if( SetEvent(this->hEventDelete) && this->hEventThreadDead != NULL ) 
            {
                do
                {
                    dwRc = WaitForSingleObject(this->hEventThreadDead, INFINITE);
                } while( dwRc != WAIT_OBJECT_0 );
                
                CloseHandle(this->hEventThreadDead);
                this->hEventThreadDead = NULL;
            }
        }

        CDIEff_UnloadWorker_(this, 0);
        CDIEff_LeaveCrit(this);
        CDIDev_NotifyDestroyEffect(this->pdev, this);
    }

    ExitProcR();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIEff_Finalize |
 *
 *          Releases the resources of an effect.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CDIEff_Finalize(PV pvObj)
{
    HRESULT hres;
    PDE this = pvObj;

#if 0 // def XDEBUG
    if (this->cCrit) {
        RPF("IDirectInputEffect::Release: Another thread is using the object; crash soon!");
    }
#endif

    AssertF(this->sh.dwEffect == 0);

    if (this->pdev) {
        hres = CDIEff_Reset(this);
        AssertF(SUCCEEDED(hres));
    }

    Invoke_Release(&this->pes);
    Common_Unhold(this->pdev);

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | GetEffectGuid |
 *
 *          Retrieve the GUID for the effect represented by the
 *          <i IDirectInputEffect> object.  Additional information
 *          about the effect can be obtained by passing the
 *          <t GUID> to <mf IDirectInputDevice2::GetEffectInfo>.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   OUT LPGUID | pguid |
 *
 *          Points to a <t GUID> structure that is filled in
 *          by the function.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not yet been <mf IDirectInputEffect::Initialize>d.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpDirectInputEffect> or
 *          <p lpdc> parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_GetEffectGuid(PDIE pdie, LPGUID pguid)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::GetEffectGuid, (_ "p", pdie));

    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresFullValidWritePguid(pguid, 1))) {
        PDE this = _thisPvNm(pdie, def);

        /*
         *  Race condition:  If the caller reinitializes and
         *  does a GetEffectGuid simultaneously, the return value
         *  is random.  That's okay; it's the caller's problem.
         */
        if (this->fInitialized) {
            *pguid = this->guid;
            hres = S_OK;
        } else {
            hres = DIERR_NOTINITIALIZED;
        }

    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   __int64 | _ftol |
 *
 *          Convert a floating point number to an integer.
 *
 *          We do it ourselves because the C runtime has been known to do a 
 *          poor job of this.
 *
 *          It's the caller's job to worry about the rounding mode.
 *
 *  @parm   double | lf |
 *
 *          Floating point number to convert.
 *
 *****************************************************************************/

#if defined(WIN95)

#pragma warning(disable:4035)           /* no return value (duh) */

BYTE _fltused;

__declspec(naked) __int64 __cdecl
_ftol(double lf)
{
    lf;
    _asm {
        sub     esp, 8
        fistp   qword ptr [esp]
        pop     eax
        pop     edx
        ret
    }
}

#pragma warning(default:4035)

#endif

/*
 *  The floating point type we use for intermediates.
 */
typedef long double FPTYPE;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   FPTYPE | CDIEff_IntToAngle |
 *
 *          Convert an integer angle to a floating point angle.
 *
 *  @parm   LONG | l |
 *
 *          Integer angle to convert.
 *
 *****************************************************************************/

#ifndef M_PI
#define M_PI 3.1415926535897932384
#endif

FPTYPE INLINE
CDIEff_IntToAngle(LONG l)
{
    FPTYPE theta;

    /*
     *  2pi radians equals 360 degrees.
     */
    theta = l * (2 * M_PI) / (360 * DI_DEGREES);

    return theta;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | CDIEff_IntAtan2 |
 *
 *          Compute the floating point arctangent of y/x and
 *          convert the resulting angle to an integer in DI_DEGREES.
 *
 *  @parm   FPTYPE | y |
 *
 *          Vertical coordinate.
 *
 *  @parm   FPTYPE | x |
 *
 *          Horizontal coordinate.
 *
 *  @returns
 *
 *          A value in the range [ 0 .. 360 * DI_DEGREES ).
 *
 *****************************************************************************/

LONG INLINE
CDIEff_IntAtan2(FPTYPE y, FPTYPE x)
{
    FPTYPE theta;
    LONG l;

#if defined(_X86_)
    /*
     *  The Intel FPU doesn't care about (0, 0).
     */
    theta = atan2(y, x);
#else
    /*
     *  The Alpha gets really upset about (0, 0).
     */
    if (y != 0.0 || x != 0.0) {
        theta = atan2(y, x);
    } else {
        theta = 0.0;
    }
#endif

    /*
     *  atan2 returns a value in the range -M_PI to +M_PI.
     *  On the Intel x86, there are four rounding modes:
     *
     *      Round to nearest or even
     *      Round towards minus infinity
     *      Round towards plus infinity
     *      Round towards zero
     *
     *  By ensuring that the value being rounded is positive, we
     *  reduce to three cases:
     *
     *      Round to nearest or even
     *      Round down
     *      Round up
     *
     *  And as long as the app doesn't change its rounding mode
     *  (few do), the values will be consistent.  (Whereas if we
     *  let negative numbers through, you would get weird behavior
     *  as the angle neared M_PI aka -M_PI.)
     *
     *  Method 1:
     *
     *      if (theta < 0) theta += 2 * M_PI;
     *      l = convert(theta);
     *      return l;
     *
     *  This is bad because if theta starts out as -epsilon, then
     *  we end up converting 2 * M_PI - epsilon, which might get
     *  rounded up to 360 * DI_DEGREES.  But our return value
     *  must be in the range 0 <= l < 360 * DI_DEGREES.
     *
     *  So instead, we use method 2:
     *
     *  l = convert(theta + 2 * M_PI);
     *  if (l >= 360 * DI_DEGREES) l -= 360 * DI_DEGREES;
     *
     *  The value being converted ends up in the range M_PI .. 3 * M_PI,
     *  which after rounding becomes 180 * DI_DEGREES .. 540 * DI_DEGREES.
     *  The final check then pulls the value into range.
     */

    /*
     *  2pi radians equals 360 degrees.
     */
    l = (LONG)((theta + 2 * M_PI) * (360 * DI_DEGREES) / (2 * M_PI));
    if (l >= 360 * DI_DEGREES) {
        l -= 360 * DI_DEGREES;
    }

    return l;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   FPTYPE | atan2Z |
 *
 *          Just like <f atan2>, except it doesn't barf on
 *          (0, 0).
 *
 *  @parm   FPTYPE | y |
 *
 *          Vertical coordinate.
 *
 *  @parm   FPTYPE | x |
 *
 *          Horizontal coordinate.
 *
 *****************************************************************************/

FPTYPE INLINE
atan2Z(FPTYPE y, FPTYPE x)
{

#if defined(_X86_)
    /*
     *  The Intel FPU doesn't care about (0, 0).
     */
    return atan2(y, x);
#else
    /*
     *  The Alpha gets really upset about (0, 0).
     */
    if (y != 0.0 || x != 0.0) {
        return atan2(y, x);
    } else {
        return 0.0;
    }
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_CartToAngles |
 *
 *          Convert cartesian coordinates to angle-based coordinates
 *          (either polar or spherical).  Note that the resulting
 *          angles have not been normalized.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes involved, never zero.
 *
 *  @parm   LPLONG | rglAngles |
 *
 *          Buffer to receive angle-base coordinates.
 *          The final entry of the array contains nothing of interest.
 *
 *  @parm   LPCLONG | rglCart |
 *
 *          Buffer containing existing cartesian coordinates.
 *
 *  @parm   DWORD | dieff |
 *
 *          Flags specifying whether the target coordinates should
 *          be <c DIEFF_POLAR> or <c DIEFF_SPHERICAL>.
 *
 *          Polar and spherical coordinates differ only in their
 *          treatment of the first angle.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_CartToAngles(DWORD cAxes,
                    LPLONG rglAngles, const LONG *rglCart, DWORD dieff)
{
    HRESULT hres;
    FPTYPE r;
    DWORD iAxis;

    AssertF(cAxes);
    AssertF(dieff == DIEFF_POLAR || dieff == DIEFF_SPHERICAL);

	/*
	 * If we're converting a 1-axis cartesian effect
	 * the value of rglAngles[0] will not be overwritten;
	 * the value that is put there initially can be random, 
	 * since rglAngles is never initialized (Whistler bug 228280).
	 * but we can't change this behaviour without potentially
	 * breaking compatibility w/ some devices.
	 * The best we can do is to print out a warning in debug.
	 */
	if (cAxes == 1)
	{
		RPF("Warning: converting a 1-axis cartesian effect to polar or spherical coordinates: the results will be undefined.");
	}

    /*
     *  Prime the pump.
     */
    r = rglCart[0];

    /*
     *  Then walk the coordinates, converting to angles as we go.
     */
    for (iAxis = 1; iAxis < cAxes; iAxis++) {
        FPTYPE y = rglCart[iAxis];
        rglAngles[iAxis-1] = CDIEff_IntAtan2(y, r);
        r = sqrt(r * r + y * y);
    }

    /*
     *  The last coordinate is left garbage.
     *
     *  NOTE!  Mathematically, the last coordinate is r.
     */

    /*
     *  Adjust for DIEFF_POLAR.
     *
     *  theta(polar) = theta(spherical) + 90deg
     */

    if (dieff & DIEFF_POLAR) {
        rglAngles[0] += 90 * DI_DEGREES;
    }

    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_AnglesToCart |
 *
 *          Convert angle-based coordinates
 *          (either polar or spherical)
 *          to cartesian coordinates.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes involved, never zero.
 *
 *  @parm   LPLONG | rglCart |
 *
 *          Buffer to receive cartesian coordinates.
 *
 *  @parm   LPCLONG | rglAngles |
 *
 *          Buffer containing existing angle-base coordinates.
 *
 *  @parm   DWORD | dieff |
 *
 *          Flags specifying whether the source coordinates are
 *          <c DIEFF_POLAR> or <c DIEFF_SPHERICAL>.
 *
 *          Polar and spherical coordinates differ only in their
 *          treatment of the first angle.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_AnglesToCart(DWORD cAxes,
                    LPLONG rglCart, const LONG *rglAngles, DWORD dieff)
{
    HRESULT hres;
    FPTYPE x[DIEFFECT_MAXAXES];
    DWORD iAxis;
    DWORD lAngle;

    AssertF(cAxes);
    AssertF(cAxes <= DIEFFECT_MAXAXES);
    AssertF(dieff == DIEFF_POLAR || dieff == DIEFF_SPHERICAL);

    /*
     *  Prime the pump.
     */
    x[0] = 1.0;

    /*
     *  For each angle, rotate in that direction.
     *
     *  If polar, then the first angle is biased by 90deg,
     *  so unbias it.
     *
     *  theta(spherical) = theta(polar) - 90deg
     */
    lAngle = rglAngles[0];
    if (dieff & DIEFF_POLAR) {
        lAngle -= 90 * DI_DEGREES;
    }

    for (iAxis = 1; iAxis < cAxes; iAxis++) {
        DWORD iX;
        FPTYPE theta, costh;

        theta = CDIEff_IntToAngle(lAngle);

        x[iAxis] = sin(theta);

        /*
         *  Compiler wont hoist this expression.
         *
         *  It also wont use the FSINCOS instruction.
         */
        costh = cos(theta);
        for (iX = 0; iX < iAxis; iX++) {
            x[iX] *= costh;
        }

        /*
         *  Note that this is safe because the angle array
         *  always contains an extra zero.
         */
        lAngle = rglAngles[iAxis];
    }

    /*
     *  Now convert the floating point values to scaled integers.
     */
    for (iAxis = 0; iAxis < cAxes; iAxis++) {
        rglCart[iAxis] = (LONG)(x[iAxis] * DI_FFNOMINALMAX);
    }

    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CDIEff_ConvertDirection |
 *
 *          Given coordinates in a source system and a target system,
 *          convert them.
 *
 *          There are three possible source systems and three
 *          possible destination systems.
 *
 *          Yes, this is the most annoying thing you could imagine.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes involved, never zero.
 *
 *  @parm   LPLONG | rglDst |
 *
 *          Buffer to receive target coordinates.
 *
 *  @parm   DWORD | dieffDst |
 *
 *          Coordinate systems supported by target.  As many bits
 *          may be set as are supported by the target, but at least
 *          one must be set.
 *
 *  @parm   LPCLONG | rglSrc |
 *
 *          Buffer containing source coordinates.
 *
 *  @parm   DWORD | dieffSrc |
 *
 *          Coordinate system of source.  Exactly one bit should be set.
 *
 *  @returns
 *
 *          Returns the coordinate system stored into the target.
 *
 *****************************************************************************/

DWORD INTERNAL
CDIEff_ConvertDirection(DWORD cAxes,
                        LPLONG rglDst, DWORD dieffDst,
                        const LONG *rglSrc, DWORD dieffSrc)
{
    DWORD dieffRc;
    HRESULT hres;

    dieffSrc &= DIEFF_COORDMASK;
    dieffDst &= DIEFF_COORDMASK;

    AssertF(cAxes);
    AssertF(dieffDst);

    AssertF(dieffSrc == DIEFF_CARTESIAN ||
            dieffSrc == DIEFF_POLAR     ||
            dieffSrc == DIEFF_SPHERICAL);

    if (dieffSrc & dieffDst) {
        /*
         *  The easy case:  The two are directly compatible.
         *
         *  Just slam the bits across and copy the format.
         */
        CopyMemory(rglDst, rglSrc, cbCdw(cAxes));
        dieffRc = dieffSrc;

    } else

    /*
     *  If they two are not directly compatible, see if
     *  the source is cartesian.
     */

    if (dieffSrc & DIEFF_CARTESIAN) {
        /*
         *  Source is cartesian, dest is something angular.
         *  Choose DIEFF_SPHERICAL if possible.
         */
        AssertF(dieffDst & DIEFF_ANGULAR);

        dieffRc = dieffDst & DIEFF_SPHERICAL;
        if (dieffRc == 0) {
            AssertF(dieffDst & DIEFF_POLAR);
            dieffRc = DIEFF_POLAR;
        }

        hres = CDIEff_CartToAngles(cAxes, rglDst, rglSrc, dieffRc);
        AssertF(SUCCEEDED(hres));

    } else

    /*
     *  The two are not directly compatible, and the source is
     *  not cartesian.  This means that the source is one of the
     *  angular forms.  The destination is a combination of
     *  the other angular form or cartesian.
     */

    if (dieffDst & DIEFF_ANGULAR) {
        /*
         *  Source is angular, dest is the other angular.
         */

        AssertF(dieffSrc & DIEFF_ANGULAR);
        AssertF((dieffSrc & dieffDst) == 0);

        /*
         *  First copy everything over,
         */
        CopyMemory(rglDst, rglSrc, cbCdw(cAxes));

        /*
         *  Now rotate left or right, depending on which way
         *  we're going.
         */
        if (dieffSrc & DIEFF_POLAR) {
            /*
             *  Polar to spherical:  Subtract 90deg.
             */
            rglDst[0] -= 90 * DI_DEGREES;
        } else {
            /*
             *  Spherical to polar: Add 90deg.
             */
            rglDst[0] += 90 * DI_DEGREES;
        }

        dieffRc = dieffDst & DIEFF_ANGULAR;

    } else

    /*
     *  All that's left is the source is angular and the destination
     *  is cartesian.
     */
    {
        AssertF(dieffSrc & DIEFF_ANGULAR);
        AssertF(dieffDst & DIEFF_CARTESIAN);

        hres = CDIEff_AnglesToCart(cAxes, rglDst, rglSrc, dieffSrc);
        dieffRc = DIEFF_CARTESIAN;

    }

    /*
     *  If the resulting coordinate system is angular, then
     *  normalize all the angles.
     */
    if (dieffRc & DIEFF_ANGULAR) {
        DWORD iAxis;

        /*
         *  Remember, the last entry is not a direction.
         */
        for (iAxis = 0; iAxis < cAxes - 1; iAxis++) {

            /*
             *  An annoying artifact of the C language is that
             *  the sign of the result of a % operation when the
             *  numerator is negative and the denominator is
             *  positive is implementation-defined.  The standard
             *  does require that the absolute value of the result
             *  not exceed the denominator, so a quick final
             *  check brings things back into focus.
             */
            rglDst[iAxis] %= 360 * DI_DEGREES;
            if (rglDst[iAxis] < 0) {
                rglDst[iAxis] += 360 * DI_DEGREES;
            }
        }

        /*
         *  As always, the last coordinate is zero.
         */
        rglDst[cAxes - 1] = 0;
    }

    return dieffRc;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | SyncShepHandle |
 *
 *          Synchronize our private <t SHEPHANDLE> with the
 *          <t SHEPHANDLE> of the parent device.  If they were
 *          out of sync, then mark the efect as completely dirty
 *          so it will get re-downloaded in full.
 *
 *  @cwrap  PDE | this
 *
 *  @returns
 *
 *          <c DI_OK> = <c S_OK>: The two were already in sync.
 *
 *          <c S_FALSE>: The two were not in sync and are now in sync.
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIEff_SyncShepHandle(PDE this)
{
    HRESULT hres;

    hres = CDIDev_SyncShepHandle(this->pdev, &this->sh);

    if (hres == S_OK) {
    } else {
        /*
         *  We were out of sync with our dad.  CDIDev_SyncShepHandle
         *  already sync'd us with dad and wiped out the effect handle.
         *  All that's left is to dirty everything because there is
         *  nothing to update.
         */
        AssertF(hres == S_FALSE);
        this->diepDirty = DIEP_ALLPARAMS;
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | DownloadWorker |
 *
 *          Place the effect on the device.  All parameters have
 *          been validated and the critical section has already been
 *          taken.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Effect to send down to the device.
 *
 *          If we are downloading for real, then this is the
 *          <e CDIEff.effDev>.
 *
 *          If we are hoping to download, then this is the
 *          <e CDIEff.effTry>.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags which specify which parameters are to be sent down
 *          to the driver as changed since last time.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not yet been <mf IDirectInputEffect::Initialize>d.
 *
 *          <c DIERR_DEVICEFULL>: The device does not have enough
 *          available memory to download the effect.
 *
 *          <c DIERR_INPUTLOST> if acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> the device is acquired,
 *          but not exclusively, or if the device is not acquired
 *          at all.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_DownloadWorker_(this, peff, fl, z)                   \
       _CDIEff_DownloadWorker_(this, peff, fl)                      \

#endif

HRESULT INTERNAL
CDIEff_DownloadWorker_(PDE this, LPCDIEFFECT peff, DWORD fl, LPCSTR s_szProc)
{

	HRESULT hres;

    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  If we do not have acquisition, but we are coming from
     *  SetParameters, then turn it into a DIEP_NODOWNLOAD so
     *  the call will go through.
     */

    hres = CDIEff_CanAccess(this);
    if ((hres == DIERR_INPUTLOST || hres == DIERR_NOTEXCLUSIVEACQUIRED) &&
        peff == &this->effTry) {
        fl |= DIEP_NODOWNLOAD;
        hres = S_OK;
    }

    if (SUCCEEDED(hres)) {

        hres = CDIEff_SyncShepHandle(this);

        if (!(fl & DIEP_NODOWNLOAD)) {          /* If we are downloading */

            /*
             *  If there are still unset bits, then barf.
             */
            if (this->diepUnset & ~fl) {
                RPF("%s: Effect still incomplete; "
                    "DIEP flags %08x need to be set",
                    s_szProc, this->diepUnset);
                hres = DIERR_INCOMPLETEEFFECT;
                goto done;
            }

            /*
             *  Since we are downloading, pass down all dirty bits.
             */
            fl |= this->diepDirty;
        }

        /*
         *  Now call the driver to do the validation or
         *  the download (accordingly).
         *
         *  Note that if nothing is to be done, then there is no need
         *  to call the driver.
         */
		hres = IDirectInputEffectShepherd_DownloadEffect(
				this->pes, (this->dEffAttributes).dwEffectId, &this->sh, peff, fl);

        if (SUCCEEDED(hres)) {
            if (fl & DIEP_NODOWNLOAD) {
                hres = DI_DOWNLOADSKIPPED;
            } else {
                this->diepDirty = 0;
            }
        }

        AssertF(hres != DIERR_NOTDOWNLOADED);

    }

done:;
    return hres;


}

#define CDIEff_DownloadWorker(this, peff, fl)                       \
        CDIEff_DownloadWorker_(this, peff, fl, s_szProc)            \

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Download |
 *
 *          Place the effect on the device.  If the effect is already
 *          on the device, then the existing effect is updated to
 *          match the values set via <mf IDirectInputEffect::SetParameters>.
 *
 *          It is valid to update an effect while it is playing.
 *          The semantics of such an operation are explained in the
 *          documentation for <mf IDirectInputEffect::SetParameters>.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>:  The effect has already been downloaded to the
 *          device.  Note that this is a success code.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not yet been <mf IDirectInputEffect::Initialize>d.
 *
 *          <c DIERR_DEVICEFULL>: The device does not have enough
 *          available memory to download the effect.
 *
 *          <c DIERR_INPUTLOST> if acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> the device is acquired,
 *          but not exclusively, or if the device is not acquired
 *          at all.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *          <c DIERR_EFFECTPLAYING>: The parameters were updated in
 *          memory but were not downloaded to the device because
 *          the device does not support updating an effect while
 *          it is still playing.  In such case, you must stop the
 *          effect, change its parameters, and restart it.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_Download(PDIE pdie)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::Download, (_ "p", pdie));

    if (SUCCEEDED(hres = hresPv(pdie))) {
        PDE this = _thisPvNm(pdie, def);

        CDIEff_EnterCrit(this);

        hres = CDIEff_DownloadWorker(this, &this->effDev, 0);

        CDIEff_LeaveCrit(this);

    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Unload |
 *
 *          Remove the effect from the device.
 *
 *          If the effect is playing, it is automatically stopped before
 *          it is unloaded.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not yet been <mf IDirectInputEffect::Initialize>d.
 *
 *          <c DIERR_INPUTLOST> if acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> the device is acquired,
 *          but not exclusively, or if the device is not acquired
 *          at all.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_Unload(PDIE pdie)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::Unload, (_ "p", pdie));

    if (SUCCEEDED(hres = hresPv(pdie))) {
        PDE this = _thisPvNm(pdie, def);

        CDIEff_EnterCrit(this);

        hres = CDIEff_UnloadWorker(this);

        CDIEff_LeaveCrit(this);

    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWritePeff |
 *
 *          Verify that the recipient buffer is valid to receive
 *          effect information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   LPDIEFFECT | peff |
 *
 *          Structure that receives effect information.  It has
 *          already been validate in size and for general writeability.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIEP_*> flags specifying which
 *          portions of the effect information is to be retrieved.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define hresFullValidWritePeff_(this, peff, fl, z, i)               \
       _hresFullValidWritePeff_(this, peff, fl)                     \

#endif

#define hresFullValidWritePeff(this, peff, fl, iarg)                \
        hresFullValidWritePeff_(this, peff, fl, s_szProc, iarg)     \


HRESULT INTERNAL
hresFullValidWritePeff_(PDE this, LPDIEFFECT peff, DWORD fl,
                        LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  You can't get the parameters of a nonexistent effect.
     */
    if (!this->fInitialized) {
        hres = DIERR_NOTINITIALIZED;
        goto done;
    }

    /*
     *  Flags are always validated.
     */
    if (peff->dwFlags & ~DIEFF_VALID) {
        RPF("ERROR %s: arg %d: Invalid value 0x%08x in DIEFFECT.dwFlags",
            s_szProc, iarg, peff->dwFlags);
        hres = E_INVALIDARG;
        goto done;
    }

    /*
     *  If requesting something that requires object ids or offsets,
     *  make sure the caller picks one or the other.
     */
    if (fl & DIEP_USESOBJECTS) {
        switch (peff->dwFlags & DIEFF_OBJECTMASK) {
        case DIEFF_OBJECTIDS:
        case DIEFF_OBJECTOFFSETS:
            break;

        default:
            RPF("ERROR %s: arg %d: Must specify one of "
                "DIEFF_OBJECTIDS or DIEFF_OBJECTOFFSETS", s_szProc, iarg);
            hres = E_INVALIDARG;
            goto done;
        }

    }

    /*
     *  If requesting something that requires direction coordinates,
     *  make sure the caller picks something we can return.
     */
    if (fl & DIEP_USESCOORDS) {

        /*
         *  Polar coordinates require cAxes == 2.  If not, then
         *  turn off DIEFF_POLAR so we won't return it.
         *
         *  But the place where we check the number of axes is
         *  in the effect itself, not in the input buffer.
         *  The reason is that the caller might be passing cAxes=0
         *  intending to ping the number of axes, and I don't
         *  want to return an error or the app will get confused
         *  and panic.
         */
        if (this->effDev.cAxes != 2 && (peff->dwFlags & DIEFF_POLAR)) {
            RPF("WARNING %s: arg %d: DIEFF_POLAR requires DIEFFECT.cAxes=2",
                s_szProc, 1);
            peff->dwFlags &= ~DIEFF_POLAR;
        }

        /*
         *  There'd better be a coordinate system left.
         */
        if ((peff->dwFlags & DIEFF_COORDMASK) == 0) {
            RPF("ERROR %s: arg %d: No (valid) coordinate system "
                "in DIEFFECT.dwFlags", s_szProc, 1);
            hres = E_INVALIDARG;
            goto done;
        }

    }

    /*
     *  DIEP_DURATION
     *  DIEP_SAMPLEPERIOD
     *  DIEP_GAIN
     *  DIEP_TRIGGERBUTTON
     *  DIEP_TRIGGERREPEATINTERVAL
     *                - Simple dwords.  No extra validation needed.
     */

#if DIRECTINPUT_VERSION >= 0x0600
    /*
     *  DIEP_STARTDELAY
     *                - Although this is a simple DWORD, we do some
     *                  sanity warnings because vendors will probably
     *                  forget to initialize it.  Also, you can't pass
     *                  this flag if your structure isn't big enough.
     */
    if (fl & DIEP_STARTDELAY) {
        if (peff->dwSize < cbX(DIEFFECT_DX6)) {
            RPF("ERROR %s: arg %d: Can't use DIEP_STARTDELAY with "
                "DIEFFECT_DX5 structure", s_szProc, 1);
        }

        /*
         *  Sanity checks.  A delay that isn't a multiple of 50ms is
         *  probably a bug.
         */
        if (peff->dwStartDelay % 50000) {
            RPF("WARNING %s: DIEFFECT.dwStartDelay = %d seems odd",
                s_szProc, peff->dwStartDelay);
        }
    }
#endif

    /*
     *  DIEP_TYPESPECIFICPARAMS
     *                - Validate that the buffer is big enough.
     */

    AssertF(this->hresValidTsd);
    if ((fl & DIEP_TYPESPECIFICPARAMS) &&
        FAILED(hres = hresFullValidWritePvCb(peff->lpvTypeSpecificParams,
                                             peff->cbTypeSpecificParams,
                                             iarg))) {
        RPF("ERROR %s: arg %d: Invalid pointer in "
            "DIEFFECT.lpvTypeSpecificParams", s_szProc, iarg);
        goto done;
    }

    /*
     *  DIEP_AXES
     *  DIEP_DIRECTION
     *                - The buffers must be of necessary size.
     */
    if ((fl & DIEP_AXES) &&
        FAILED(hres = hresFullValidWritePvCb(peff->rgdwAxes,
                                             cbCdw(peff->cAxes), iarg))) {
        RPF("ERROR %s: arg %d: Invalid pointer in DIEFFECT.rgdwAxes",
            s_szProc, iarg);
        goto done;
    }

    if ((fl & DIEP_DIRECTION) &&
        FAILED(hres = hresFullValidWritePvCb(peff->rglDirection,
                                             cbCdw(peff->cAxes), iarg))) {
        RPF("ERROR %s: arg %d: Invalid pointer in DIEFFECT.rglDirection",
            s_szProc, iarg);
        goto done;
    }

    /*
     *  DIEP_ENVELOPE - The pointer must be valid to receive the envelope.
     */
    if ((fl & DIEP_ENVELOPE) &&
        FAILED(hres = hresFullValidWritePxCb(peff->lpEnvelope,
                                             DIENVELOPE, iarg))) {
        RPF("ERROR %s: arg %d: Invalid pointer in DIEFFECT.lpEnvelope",
            s_szProc, iarg);
        goto done;
    }

    hres = S_OK;

done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | MapDwords |
 *
 *          Map a few <t DWORD>s based on the desired mapping mode
 *          of the caller.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   DWORD | dwFlags |
 *
 *          The mapping mode desired by the caller.
 *
 *  @parm   UINT | cdw |
 *
 *          Number of items to convert.
 *
 *  @parm   LPDWORD | rgdwOut |
 *
 *          Destination buffer.
 *
 *  @parm   LPCDWORD | rgdwIn |
 *
 *          Source buffer.
 *
 *  @parm   UINT | devco |
 *
 *          Conversion code describing what we're converting.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The caller
 *          requested offsets but there is no data format selected.
 *
 *****************************************************************************/

#if 0

#ifndef XDEBUG

#define CDIEff_MapDwords_(this, fl, cdw, rgdwOut, rgdwIn, devco, z, i)  \
       _CDIEff_MapDwords_(this, fl, cdw, rgdwOut, rgdwIn, devco)        \

#endif

#define CDIEff_MapDwords(this, fl, cdw, rgdwOut, rgdwIn, devco, i)      \
        CDIEff_MapDwords_(this, fl, cdw, rgdwOut, rgdwIn, devco, s_szProc, i) \

#endif

HRESULT INTERNAL
CDIEff_MapDwords(PDE this, DWORD dwFlags,
                 UINT cdw, LPDWORD rgdwOut, const DWORD *rgdwIn, UINT devco)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this->pdev));

    if (cdw) {

        CopyMemory(rgdwOut, rgdwIn, cbCdw(cdw));

        /*
         *  Okay, now things get weird.  We internally keep the
         *  items as item IDs, because that's what drivers
         *  want.  So we need to convert them to whatever the
         *  caller really wants.
         */

        if (dwFlags & DIEFF_OBJECTOFFSETS) {
            if (devco & DEVCO_FROMID) {
                devco |= DEVCO_TOOFFSET;
            } else {
                AssertF(devco & DEVCO_TOID);
                devco |= DEVCO_FROMOFFSET;
            }
        } else {
            AssertF(dwFlags & DIEFF_OBJECTIDS);
            if (devco & DEVCO_FROMID) {
                devco |= DEVCO_TOID;
            } else {
                AssertF(devco & DEVCO_TOID);
                devco |= DEVCO_FROMID;
            }
        }
        hres = CDIDev_ConvertObjects(this->pdev, cdw, rgdwOut, devco);

    } else {
        /* Vacuous success */
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIEff | GetDirectionParameters |
 *
 *          Retrieve information about the direction of an effect.
 *
 *          If no direction has yet been set, then wipe out the
 *          direction pointer and erase the coordinate system.
 *
 *          Always convert from the cached application coordinate
 *          system instead of the device coordinate system, in
 *          order to maximize fidelity.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPDIEFFECT | peff |
 *
 *          Structure to receive effect information.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes to return.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_GetDirectionParameters_(this, peff, cAxes, z, iarg)  \
       _CDIEff_GetDirectionParameters_(this, peff, cAxes)           \

#endif

#define CDIEff_GetDirectionParameters(this, peff, cAxes, iarg)      \
        CDIEff_GetDirectionParameters_(this, peff, cAxes, s_szProc, iarg)  \

void INTERNAL
CDIEff_GetDirectionParameters_(PDE this, LPDIEFFECT peff, DWORD cAxes,
                               LPCSTR s_szProc, int iarg)
{
    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  Make sure there are no non-coordinate bits in dwDirFlags.
     *  And validation should've made sure the app is asking for *something*.
     */
    AssertF((this->dwDirFlags & ~DIEFF_COORDMASK) == 0);
    AssertF(peff->dwFlags & DIEFF_COORDMASK);
    AssertF(cAxes <= DIEFFECT_MAXAXES);

    if (this->dwDirFlags) {
        DWORD dieffRc;
        LONG rgl[DIEFFECT_MAXAXES];     /* Holding buffer */

        /*
         *  We must double-buffer in case the target is not big enough.
         */
		/*
         *  Prefix does not like the lack of initialization of rgl (Manbugs 34566, Whistler 228280 -- 
		 *  althought the bugs refer to dinput8.dll, the same problem is present in dinput.dll). 
         *  but unfortunately we can't fix it without potentially breaking compatibility
		 *  with some devices. See comment in CDIEff_CartToAngles() about this issue.
		 */
        dieffRc = CDIEff_ConvertDirection(
                        this->effDev.cAxes,
                        rgl, peff->dwFlags,
                        this->rglDirApp, this->dwDirFlags);

        peff->dwFlags = (peff->dwFlags & ~DIEFF_COORDMASK) | dieffRc;

        CopyMemory(peff->rglDirection, rgl, cbCdw(cAxes));

    } else {
        /*
         *  No direction set; vacuous success.
         */
        RPF("Warning: %s: arg %d: Effect has no direction", s_szProc, iarg);
        peff->rglDirection = 0;
        peff->dwFlags &= ~DIEFF_COORDMASK;
    }

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | GetParameters |
 *
 *          Retrieve information about an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   LPDIEFFECT | peff |
 *
 *          Structure that receives effect information.
 *          The <e DIEFFECT.dwSize> field must be filled in by
 *          the application before calling this function.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIEP_*> flags specifying which
 *          portions of the effect information is to be retrieved.
 *
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has never had any effect parameters set into it.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.  Common errors include
 *          not setting the <e DIEFFECT.dwSize> field of the
 *          <t DIEFFECT> structure, passing invalid flags,
 *          or not setting up the fields in the <t DIEFFECT> structure
 *          properly in preparation for receiving the effect information.
 *
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_GetParameters(PDIE pdie, LPDIEFFECT peff, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::GetParameters, (_ "ppx", pdie, peff, fl));

    /*
     *  Note that we cannot use hresFullValidWritePxCb() because
     *  that will scramble the buffer, but we still need the values
     *  in it.
     */
    if (SUCCEEDED(hres = hresPv(pdie)) &&
#if DIRECTINPUT_VERSION >= 0x0600
        SUCCEEDED( hres = ( IsBadReadPtr(&peff->dwSize, cbX(peff->dwSize)) ) ? E_POINTER : S_OK ) &&
        ( ( (peff->dwSize != cbX(DIEFFECT_DX5)) &&
            SUCCEEDED(hres = hresFullValidWriteNoScramblePxCb(peff, DIEFFECT_DX6, 1) ) &&
            SUCCEEDED(hres = hresFullValidFl(fl, DIEP_GETVALID, 2)) )
          ||
          ( SUCCEEDED(hres = hresFullValidWriteNoScramblePxCb(peff, DIEFFECT_DX5, 1)) &&
            SUCCEEDED(hres = hresFullValidFl(fl, DIEP_GETVALID_DX5, 2)) )
        ) ) {
#else
        SUCCEEDED(hres = hresFullValidWriteNoScramblePxCb(peff, DIEFFECT_DX5, 1)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, DIEP_GETVALID_DX5, 2))) {
#endif

        PDE this = _thisPvNm(pdie, def);

        CDIEff_EnterCrit(this);

        if (SUCCEEDED(hres = hresFullValidWritePeff(this, peff, fl, 1))) {

            if (fl == 0) {
                RPF("Warning: %s(dwFlags=0) is pretty useless",
                    s_szProc);
            }

            /*
             *  Assume everything is okay.
             */
            hres = S_OK;

            /*
             *  Pull out the effect parameters.
             */

            if (fl & DIEP_DURATION) {
                peff->dwDuration = this->effDev.dwDuration;
            }

            if (fl & DIEP_SAMPLEPERIOD) {
                peff->dwSamplePeriod = this->effDev.dwSamplePeriod;
            }

            if (fl & DIEP_GAIN) {
                peff->dwGain = this->effDev.dwGain;
            }

#if DIRECTINPUT_VERSION >= 0x0600
            if (fl & DIEP_STARTDELAY) {
                peff->dwStartDelay = this->effDev.dwStartDelay;
            }
#endif

            if (fl & DIEP_TRIGGERBUTTON) {
                peff->dwTriggerButton = this->effDev.dwTriggerButton;
                if (peff->dwTriggerButton != DIEB_NOTRIGGER) {
                    hres = CDIEff_MapDwords(this, peff->dwFlags, 1,
                                            &peff->dwTriggerButton,
                                            &peff->dwTriggerButton,
                                            DEVCO_BUTTON |
                                            DEVCO_FROMID);

                    /*
                     *  We should never allow a bad id to sneak in.
                     */
                    AssertF(SUCCEEDED(hres));

                    if (FAILED(hres)) {
                        goto done;
                    }
                }
            }

            if (fl & DIEP_TRIGGERREPEATINTERVAL) {
                peff->dwTriggerRepeatInterval =
                                    this->effDev.dwTriggerRepeatInterval;
            }

            if (fl & DIEP_TYPESPECIFICPARAMS) {
                DWORD cb = this->effDev.cbTSP;
                if (peff->cbTSP < this->effDev.cbTSP) {
                    cb = peff->cbTSP;
                    hres = DIERR_MOREDATA;
                }
                peff->cbTSP = this->effDev.cbTSP;

                CopyMemory(peff->lpvTSP, this->effDev.lpvTSP, cb);
            }

            if (fl & DIEP_ENVELOPE) {
                if (this->effDev.lpEnvelope) {
                    *peff->lpEnvelope = *this->effDev.lpEnvelope;
                } else {
                    /*
                     *  Zero out the envelope because apps won't
                     *  check whether peff->lpEnvelope == 0;
                     *  they're just going to peek at the envelope
                     *  even if the effect doesn't have one.
                     */
                    ZeroMemory(pvAddPvCb(peff->lpEnvelope,
                                         cbX(peff->lpEnvelope->dwSize)),
                               cbX(DIENVELOPE) -
                                         cbX(peff->lpEnvelope->dwSize));
                    peff->lpEnvelope = this->effDev.lpEnvelope;
                }
            }

            /*
             *  Do axes and direction last because weird error
             *  codes can come out of here.
             */
            if (fl & (DIEP_AXES | DIEP_DIRECTION)) {

                DWORD cAxes = this->effDev.cAxes;
                if (peff->cAxes < this->effDev.cAxes) {
                    cAxes = peff->cAxes;
                    peff->cAxes = this->effDev.cAxes;
                    hres = DIERR_MOREDATA;
                }
                peff->cAxes = this->effDev.cAxes;

                if (fl & DIEP_AXES) {
                    HRESULT hresT;
                    hresT = CDIEff_MapDwords(this, peff->dwFlags, cAxes,
                                             peff->rgdwAxes,
                                             this->effDev.rgdwAxes,
                                             DEVCO_AXIS |
                                             DEVCO_FROMID);
                    if (FAILED(hresT)) {
                        RPF("ERROR: %s: arg %d: Axes not in data format",
                             s_szProc, 1);
                        hres = hresT;
                        goto done;
                    }
                }

                if (fl & DIEP_DIRECTION) {
                    CDIEff_GetDirectionParameters(this, peff, cAxes, 1);
                }

            }
        }

    done:;
        CDIEff_LeaveCrit(this);
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidUnknownTsd |
 *
 *          Verify that the buffer is a valid buffer for unknown
 *          type-specific data.  Since we don't know what it is,
 *          the buffer is assumed valid because we can't validate it.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidUnknownTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    peff;
    cAxes;

    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidConstantTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DICONSTANTFORCE> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidConstantTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

        if (peff->cbTypeSpecificParams == cbX(DICONSTANTFORCE)) {
            hres = S_OK;
        } else {
            hres = E_INVALIDARG;
        }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidRampTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DIRAMPFORCE> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidRampTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

        if (peff->cbTypeSpecificParams == cbX(DIRAMPFORCE)) {
            hres = S_OK;
        } else {
            hres = E_INVALIDARG;
        }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidPeriodicTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DIPERIODIC> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidPeriodicTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

        if (peff->cbTypeSpecificParams == cbX(DIPERIODIC)) {
            hres = S_OK;
        } else {
            hres = E_INVALIDARG;
        }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidConditionTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DICONDITION> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidConditionTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    /*
     *  Conditions are weird.  The size of the type-specific data
     *  must be equal to cAxes * cbX(DICONDITION) or equal to
     *  exactly one cbX(DICONDITION), depending on whether you want
     *  multiple conditions on multiple axes or a single condition
     *  rotated across multiple axes.
     *
     *  Note that we do not enforce that the parameters are in range;
     *  this allows for "overgain"-type behaviors.
     */

    if (peff->cbTypeSpecificParams ==         cbX(DICONDITION) ||
        peff->cbTypeSpecificParams == cAxes * cbX(DICONDITION)) {
        hres = S_OK;
    } else {
        RPF("IDirectInputEffect::SetParameters: "
            "Size of type-specific data (%d) "
            "not compatible with number of axes (%d)",
            peff->cbTypeSpecificParams, cAxes);
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidCustomForceTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DICUSTOMFORCE> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidCustomForceTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

        if (peff->cbTypeSpecificParams == cbX(DICUSTOMFORCE)) {
            LPCDICUSTOMFORCE pcf = peff->lpvTypeSpecificParams;
            if (pcf->cChannels == 0) {
                RPF("ERROR: IDirectInputEffect::SetParameters: "
                    "DICUSTOMFORCE.cChannels == 0 is invalid");
                hres = E_INVALIDARG;
            } else if (pcf->cSamples % pcf->cChannels != 0) {
                RPF("ERROR: IDirectInputEffect::SetParameters: "
                    "DICUSTOMFORCE.cSamples must be multiple of "
                    "DICUSTOMFORCE.cChannels");
                hres = E_INVALIDARG;
            } else if (IsBadReadPtr(pcf->rglForceData,
                                    cbCxX((pcf->cSamples)*(pcf->cChannels), LONG))) {
                RPF("ERROR: IDirectInputEffect::SetParameters: "
                    "DICUSTOMFORCE.rglForceData invalid");
                hres = E_INVALIDARG;
            } else {
                hres = S_OK;
            }
        } else {
            hres = E_INVALIDARG;
        }

    return hres;
}

#if DIRECTINPUT_VERSION >= 0x0800
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidRandomTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DIRANDOM> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidRandomTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

    if (peff->cbTypeSpecificParams == cbX(DIRANDOM)) {
        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidAbsoluteTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DIABSOLUTE> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidAbsoluteTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

    /*
     *  Unlike other effects, "overgain" is not permitted for absolute effects.
     */
    if (peff->cbTypeSpecificParams == cbX(DIABSOLUTE)) 
    {
        LPCDIABSOLUTE pabs = peff->lpvTypeSpecificParams;
        if( fInOrder( -10000, pabs->lTarget, 10000 ) )
        {
            hres = S_OK;
        }
        else
        {
            RPF("ERROR: IDirectInputEffect::SetParameters: "
                "DIABSOLUTE.lTarget %d not in range -10000 to 100000", 
                pabs->lTarget );
            hres = E_INVALIDARG;
        }
    } else {
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidBumpForceTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DIBUMPFORCE> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidBumpForceTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    cAxes;

    if (peff->cbTypeSpecificParams == cbX(DIBUMPFORCE)) {
        LPCDIBUMPFORCE pbf = peff->lpvTypeSpecificParams;
        if (pbf->cChannels == 0) {
            RPF("ERROR: IDirectInputEffect::SetParameters: "
                "DIBUMPFORCE.cChannels == 0 is invalid");
            hres = E_INVALIDARG;
        } else if (pbf->cSamples % pbf->cChannels != 0) {
            RPF("ERROR: IDirectInputEffect::SetParameters: "
                "DIBUMPFORCE.cSamples must be multiple of "
                "DIBUMPFORCE.cChannels");
            hres = E_INVALIDARG;
        } else if (IsBadReadPtr(pbf->rglForceData,
                                cbCxX(pbf->cSamples, LONG))) {
            RPF("ERROR: IDirectInputEffect::SetParameters: "
                "DIBUMPFORCE.rglForceData invalid");
            hres = E_INVALIDARG;
        } else {
            hres = S_OK;
        }
    } else {
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIEff_IsValidConditionExTsd |
 *
 *          Verify that the buffer is a valid
 *          <t DICONDITIONEX> structure.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The type-specific parameters have already been validated
 *          for access.
 *
 *  @parm   DWORD | cAxes |
 *
 *          Number of axes associated with the type-specific parameters.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_IsValidConditionExTsd(LPCDIEFFECT peff, DWORD cAxes)
{
    HRESULT hres;

    /*
     *  Extended conditions, like conditions are weird.  
     *  The size of the type-specific data
     *  must be equal to cAxes * cbX(DICONDITIONEX) or equal to
     *  exactly one cbX(DICONDITIONEX), depending on whether you want
     *  multiple conditions on multiple axes or a single condition
     *  rotated across multiple axes.
     *
     *  Note that we do not enforce that the parameters are in range;
     *  this allows for "overgain"-type behaviors.
     */

    if (peff->cbTypeSpecificParams ==         cbX(DICONDITIONEX) ||
        peff->cbTypeSpecificParams == cAxes * cbX(DICONDITIONEX)) {
        hres = S_OK;
    } else {
        RPF("IDirectInputEffect::SetParameters: "
            "Size of type-specific data (%d) "
            "not compatible with number of axes (%d)",
            peff->cbTypeSpecificParams, cAxes);
        hres = E_INVALIDARG;
    }

    return hres;
}
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPeff |
 *
 *          Verify that the recipient buffer contains valid information.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.  It has
 *          already been validate in size and for general readability.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIEP_*> flags specifying which
 *          portions of the effect information should be validated.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define hresFullValidPeff_(this, peff, fl, z, i)                    \
       _hresFullValidPeff_(this, peff, fl)                          \

#endif

#define hresFullValidPeff(this, peff, fl, iarg)                     \
        hresFullValidPeff_(this, peff, fl, s_szProc, iarg)          \


HRESULT INTERNAL
hresFullValidPeff_(PDE this, LPCDIEFFECT peff, DWORD fl,
                   LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    DWORD cAxes;

    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  You can't set the parameters of a nonexistent effect.
     */
    if (!this->fInitialized) {
        hres = DIERR_NOTINITIALIZED;
        goto done;
    }

    /*
     *  Flags are always validated.
     */
    if (peff->dwFlags & ~DIEFF_VALID) {
        RPF("ERROR %s: arg %d: Invalid flags specific parms in DIEFFECT",
            s_szProc, iarg);
        hres = E_INVALIDARG;
        goto done;
    }

    /*
     *  If setting something that requires object ids or offsets,
     *  make sure the caller picks one or the other.
     */
    if (fl & DIEP_USESOBJECTS) {
        switch (peff->dwFlags & DIEFF_OBJECTMASK) {
        case DIEFF_OBJECTIDS:
        case DIEFF_OBJECTOFFSETS:
            break;

        default:
            RPF("ERROR %s: arg %d: Must specify one of "
                "DIEFF_OBJECTIDS or DIEFF_OBJECTOFFSETS", s_szProc, iarg);
            hres = E_INVALIDARG;
            goto done;
        }

    }

    /*
     *  If setting something that requires direction coordinates,
     *  make sure the caller picks exactly one.
     */
    if (fl & DIEP_USESCOORDS) {
        switch (peff->dwFlags & DIEFF_COORDMASK) {
        case DIEFF_CARTESIAN:
        case DIEFF_SPHERICAL:
            break;

        /*
         *  Polar coordinates mandate two (and only two) axes.
         */
        case DIEFF_POLAR:
            if (peff->cAxes != 2) {
                RPF("ERROR %s: arg %d: DIEFF_POLAR requires DIEFFECT.cAxes=2",
                    s_szProc, 1);
                hres = E_INVALIDARG;
                goto done;
            }
            break;

        default:
            RPF("ERROR %s: arg %d: Must specify one of "
                "DIEFF_CARTESIAN, DIEFF_POLAR, or DIEFF_SPHERICAL",
                s_szProc, iarg);
            hres = E_INVALIDARG;
            goto done;
        }

    }

    /*
     *  DIEP_DURATION
     *  DIEP_SAMPLEPERIOD
     *  DIEP_GAIN
     *  DIEP_TRIGGERBUTTON
     *                - Simple dwords.  No extra validation needed.
     */

    /*
     *  DIEP_AXES
     *  DIEP_DIRECTION
     *                - The buffers must be of necessary size.
     *
     *  We will validate the other goo later, because there
     *  are annoying interactions between them.
     */

    AssertF(fLeqvFF(this->effDev.cAxes == 0, this->diepUnset & DIEP_AXES));

    cAxes = this->effDev.cAxes;
    if (fl & (DIEP_AXES | DIEP_DIRECTION)) {

        /*
         *  The number of axes had better not be zero.
         */

        if (peff->cAxes == 0) {
            RPF("ERROR %s: arg %d: DIEFFECT.cAxes = 0 is invalid",
                s_szProc, iarg);
            hres = E_INVALIDARG;
            goto done;
        }

        /*
         *  And it better not be too big either.
         */

        if (peff->cAxes > DIEFFECT_MAXAXES) {
            RPF("ERROR %s: arg %d: DIEFFECT.cAxes = %d is too large (max %d)",
                s_szProc, iarg, peff->cAxes, DIEFFECT_MAXAXES);
            hres = E_INVALIDARG;
            goto done;
        }

        if (fl & DIEP_AXES) {

            /*
             *  If the axes have already been set (which we know because
             *  this->effDev.cAxes will be nonzero), then don't
             *  let the caller change them.
             */

            if (this->effDev.cAxes) {
                RPF("ERROR %s: arg %d: Cannot change axes once set",
                    s_szProc, iarg);
                hres = DIERR_ALREADYINITIALIZED;
                goto done;
            }

            cAxes = peff->cAxes;

            if (IsBadReadPtr(peff->rgdwAxes, cbCdw(peff->cAxes))) {
                RPF("ERROR %s: arg %d: Invalid rgdwAxes in DIEFFECT",
                    s_szProc, iarg);
                hres = E_INVALIDARG;
                goto done;
            }
        }

        if (fl & DIEP_DIRECTION) {

            /*
             *  We want to disallow cAxes == 0 as well,
             *  but we get that for free because
             *  peff->cAxes != cAxes, and peff->cAxes is already
             *  validated as nonzero.
             */
            if (peff->cAxes != cAxes) {
                if (cAxes) {
                    RPF("ERROR %s: arg %d: Wrong number of DIEFFECT.cAxes",
                        s_szProc, 1);
                } else {
                    RPF("ERROR %s: arg %d: "
                        "Must set number of axes before directions", s_szProc);
                }
                hres = E_INVALIDARG;
                goto done;
            }

            /*
             *  Direction validation should've already checked above.
             */
            AssertF(fLimpFF(peff->dwFlags & DIEFF_POLAR, peff->cAxes == 2));

            if (IsBadReadPtr(peff->rglDirection, cbCdw(peff->cAxes))) {
                RPF("ERROR %s: arg %d: Invalid rglDirection in DIEFFECT",
                    s_szProc, iarg);
                hres = E_INVALIDARG;
                goto done;

            }
        }
    }

    /*
     *  DIEP_TYPESPECIFICPARAMS
     *                - Validate that the buffer is valid
     *                  and passes type-specific tests.
     *
     *  This must be done after axes so we know how many
     *  axes there are.
     */

    AssertF(this->hresValidTsd);
    if (fl & DIEP_TYPESPECIFICPARAMS) {
        hres = hresFullValidReadPvCb(peff->lpvTypeSpecificParams,
                                     peff->cbTypeSpecificParams, iarg);
        if (FAILED(hres)) {
            RPF("ERROR %s: arg %d: Invalid pointer in "
                "DIEFFECT.lpvTypeSpecificParams",
                s_szProc, iarg);
            hres = E_INVALIDARG;
            goto done;
        }

        hres = this->hresValidTsd(peff, cAxes);
        if (FAILED(hres)) {
            RPF("ERROR %s: arg %d: Invalid type-specific data",
                s_szProc, iarg);
            goto done;
        }
    }

    /*
     *  DIEP_ENVELOPE - The pointer must be valid if present.
     */
    if ((fl & DIEP_ENVELOPE) &&
        peff->lpEnvelope &&
        FAILED(hres = hresFullValidReadPxCb(peff->lpEnvelope,
                                            DIENVELOPE, iarg))) {
        RPF("ERROR %s: arg %d: Invalid lpEnvelope in DIEFFECT",
            s_szProc, iarg);
        hres = E_INVALIDARG;
        goto done;
    }

    hres = S_OK;

done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | TryTriggerButton |
 *
 *          Set information about the trigger button for an effect into the
 *          temporary buffer.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_TryTriggerButton_(this, peff, z, iarg)               \
       _CDIEff_TryTriggerButton_(this, peff)                        \

#endif

#define CDIEff_TryTriggerButton(this, peff, iarg)                   \
        CDIEff_TryTriggerButton_(this, peff, s_szProc, iarg)        \


STDMETHODIMP
CDIEff_TryTriggerButton_(PDE this, LPCDIEFFECT peff, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  We can copy directly in, because if something goes wrong,
     *  we just throw away effTry without damaging effDev.
     */

    this->effTry.dwTriggerButton = peff->dwTriggerButton;

    if (fLimpFF(this->effTry.dwTriggerButton != DIEB_NOTRIGGER,
        SUCCEEDED(hres = CDIEff_MapDwords(this, peff->dwFlags, 1,
                                          &this->effTry.dwTriggerButton,
                                          &this->effTry.dwTriggerButton,
                                          DEVCO_BUTTON |
                                          DEVCO_FFEFFECTTRIGGER |
                                          DEVCO_TOID)))) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: Invalid button identifier/offset "
            "or button is not DIEB_NOTRIGGER",
            s_szProc);
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | TryAxis |
 *
 *          Set information about the axes of an effect into the
 *          temporary buffer.  Note that since you can't change the
 *          axes once they've been set, we can put our try directly
 *          into the final buffer.
 *
 *          The only tricky thing is making sure no axes are repeated
 *          in the array.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_TryAxis_(this, peff, z, iarg)                        \
       _CDIEff_TryAxis_(this, peff)                                 \

#endif

#define CDIEff_TryAxis(this, peff, iarg)                            \
        CDIEff_TryAxis_(this, peff, s_szProc, iarg)                 \


STDMETHODIMP
CDIEff_TryAxis_(PDE this, LPCDIEFFECT peff, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    UINT idw;

    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  You can change the axes only once.  Therefore, rgdwAxes
     *  always points to this->rgdwAxes.
     */
    AssertF(this->effDev.cAxes == 0);
    AssertF(this->effTry.cAxes == 0);
    AssertF(this->effDev.rgdwAxes == this->effTry.rgdwAxes);
    AssertF(this->effTry.rgdwAxes == this->rgdwAxes);

    hres = CDIEff_MapDwords(this, peff->dwFlags, peff->cAxes,
                            this->effTry.rgdwAxes, peff->rgdwAxes,
                            DEVCO_AXIS | DEVCO_FFACTUATOR | DEVCO_TOID);
    if (FAILED(hres)) {
        RPF("ERROR %s: Invalid axis identifiers/offsets"
            "or axes are not all DIDFT_FFACTUATOR", s_szProc);
        goto done;
    }

    /*
     *  Make sure there are no dups in the axis list.
     *
     *  The outer loop starts at 1 because the 0'th axis
     *  can't possibly conflict with any others.
     */
    for (idw = 1; idw < peff->cAxes; idw++) {
        DWORD idwT;
        for (idwT = 0; idwT < idw; idwT++) {
            if (this->effTry.rgdwAxes[idw] == this->effTry.rgdwAxes[idwT]) {
                RPF("ERROR %s: arg %d: Duplicate axes in axis array",
                    s_szProc, iarg);
                hres = E_INVALIDARG;
                goto done;
            }
        }
    }

    this->effTry.cAxes = peff->cAxes;

done:;
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIEff | TryDirection |
 *
 *          Set information about the direction of an effect into the
 *          temporary buffer.
 *
 *          This is particularly gruesome, because we need to keep
 *          two sets of books: The values passed by the app (which
 *          we regurgitate back when queried) and the values passed
 *          to the driver.
 *
 *          We must keep two sets of books, because I just know
 *          that some apps are going to act up if the
 *          parameters they read back do not <y exactly> match
 *          the values they set in.  For example, they might
 *          read the value, subtract five, and write it back.
 *          Due to rounding, <y n> and <y n>-5 have the same
 *          value in the driver, so if we translated down and
 *          back, the value wouldn't change, and the app would
 *          get stuck in an infinite loop.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define CDIEff_TryDirection_(this, peff, z, iarg)                   \
       _CDIEff_TryDirection_(this, peff)                            \

#endif

#define CDIEff_TryDirection(this, peff, iarg)                       \
        CDIEff_TryDirection_(this, peff, s_szProc, iarg)            \

STDMETHODIMP
CDIEff_TryDirection_(PDE this, LPCDIEFFECT peff, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    DWORD dieffRc;

    AssertF(CDIDev_InCrit(this->pdev));

    /*
     *  These should've been caught by validation.
     */
    AssertF(this->effTry.cAxes);
    AssertF(peff->cAxes == this->effTry.cAxes);
    AssertF(fLimpFF(peff->dwFlags & DIEFF_POLAR, peff->cAxes == 2));

    /*
     *  Translate the coordinates into device coordinates.
     */
    AssertF((this->dwCoords & ~DIEFF_COORDMASK) == 0);
    AssertF(this->dwCoords);

    this->effTry.rglDirection = this->rglDirTry;
    dieffRc = CDIEff_ConvertDirection(
                    this->effTry.cAxes,
                    this->rglDirTry, this->dwCoords,
                    peff->rglDirection, peff->dwFlags & DIEFF_COORDMASK);
    AssertF(dieffRc);

    this->effTry.dwFlags = (this->effTry.dwFlags & ~DIEFF_COORDMASK) | dieffRc;

    hres = S_OK;

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method void | CDIEff | TryParameters |
 *
 *          Build the Try structure based on the new parameters.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The original effect structure passed by the application.
 *
 *  @parm   DWORD | fl |
 *
 *          The <c DIEP_*> flags which specify what changed.
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIEff_TryParameters(PDE this, LPCDIEFFECT peff, DWORD fl)
{
    HRESULT hres = S_OK;  
    EnterProcR(IDirectInputEffect::SetParameters, (_ "ppx", this, peff, fl));

    AssertF(this->lpvTSP == 0);

    /*
     *  Copy the current device parameters so we
     *  can modify the copy without damaging the original.
     */
    this->effTry = this->effDev;

    /*
     *  Install the appropriate effect parameters.
     */

    if (fl & DIEP_DURATION) {
        this->effTry.dwDuration = peff->dwDuration;
    }

    if (fl & DIEP_SAMPLEPERIOD) {
        this->effTry.dwSamplePeriod = peff->dwSamplePeriod;
    }

    if (fl & DIEP_GAIN) {
        this->effTry.dwGain = peff->dwGain;
    }

#if DIRECTINPUT_VERSION >= 0x0600
    if (fl & DIEP_STARTDELAY) {
        this->effTry.dwStartDelay = peff->dwStartDelay;
    }
#endif

    if (fl & DIEP_TRIGGERBUTTON) {
        hres = CDIEff_TryTriggerButton(this, peff, 1);
        if (FAILED(hres)) {
            goto done;
        }
    }

    if (fl & DIEP_TRIGGERREPEATINTERVAL) {
        this->effTry.dwTriggerRepeatInterval =
                                    peff->dwTriggerRepeatInterval;
    }

    if (fl & DIEP_TYPESPECIFICPARAMS) {
        this->effTry.cbTSP = peff->cbTSP;
        this->effTry.lpvTSP = peff->lpvTSP;

        /*
         *  Preallocate memory to hold the type-specific parameters
         *  to make sure we can proceed on success.
         */
        if (this->effDev.cbTSP != this->effTry.cbTSP) {
            hres = AllocCbPpv(this->effTry.cbTSP, &this->lpvTSP);
            if (FAILED(hres)) {
                goto done;
            }
        }

    }

    /*
     *  Must do axes before directions because directions
     *  depends on the number of axes.
     */

    if (fl & DIEP_AXES) {
        hres = CDIEff_TryAxis(this, peff, 1);
        if (FAILED(hres)) {
            goto done;
        }
    }

    if (fl & DIEP_DIRECTION) {
        hres = CDIEff_TryDirection(this, peff, 1);
        if (FAILED(hres)) {
            goto done;
        }
    }

    if (fl & DIEP_ENVELOPE) {
        this->effTry.lpEnvelope = peff->lpEnvelope;
    }

done:;
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method void | CDIEff | SaveTry |
 *
 *          A Try'd effect worked.  Save its parameters in the
 *          driver parameter cache.
 *
 *  @cwrap  PDE | this
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The original effect structure passed by the application.
 *
 *  @parm   DWORD | fl |
 *
 *          The <c DIEP_*> flags which specify what changed.
 *
 *****************************************************************************/

void INTERNAL
CDIEff_SaveTry(PDE this, LPCDIEFFECT peff, DWORD fl)
{

    /*
     *  For the easy stuff, just copy them blindly.
     *  It doesn't hurt to copy something that didn't change.
     */
    this->effDev.dwDuration              = this->effTry.dwDuration;
    this->effDev.dwSamplePeriod          = this->effTry.dwSamplePeriod;
    this->effDev.dwGain                  = this->effTry.dwGain;
    this->effDev.dwTriggerButton         = this->effTry.dwTriggerButton;
    this->effDev.dwTriggerRepeatInterval = this->effTry.dwTriggerRepeatInterval;
#if DIRECTINPUT_VERSION >= 0x0600
	this->effDev.dwStartDelay            = this->effTry.dwStartDelay;
#endif

    /*
     *  Axes count as "easy" because CDIEff_TryAxes put the
     *  axis info directly into this->rgdwAxes.
     */
    this->effDev.cAxes                   = this->effTry.cAxes;

    /*
     *  Now the hard parts: The things that require
     *  memory allocation or block copying.
     */

    if (fl & DIEP_TYPESPECIFICPARAMS) {
        if (this->effDev.cbTSP == this->effTry.cbTSP) {
            AssertF(this->lpvTSP == 0);
        } else {
            AssertF(this->lpvTSP);
            this->effDev.cbTSP = this->effTry.cbTSP;
            FreePpv(&this->effDev.lpvTSP);
            this->effDev.lpvTSP = this->lpvTSP;
            this->lpvTSP = 0;
        }
        CopyMemory(this->effDev.lpvTSP, this->effTry.lpvTSP,
                   this->effTry.cbTSP);
    }

    if (fl & DIEP_DIRECTION) {
        /*
         *  Save the app coordinate and the coordinate system into our cache.
         */
        this->dwDirFlags = peff->dwFlags & DIEFF_COORDMASK;
        CopyMemory(this->rglDirApp, peff->rglDirection,
                   cbCdw(this->effDev.cAxes));

        /*
         *  And propagate the Try'd coordinates into the Drv coordinates.
         */
        this->effDev.dwFlags= this->effTry.dwFlags;
        CopyMemory(this->rglDirDev, this->rglDirTry, cbX(this->rglDirTry));
    }

    if (fl & DIEP_ENVELOPE) {
        if (this->effTry.lpEnvelope) {
            this->effDev.lpEnvelope = &this->env;
            this->env = *this->effTry.lpEnvelope;
        } else {
            this->effDev.lpEnvelope = 0;
        }
    }

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | SetParameters |
 *
 *          Set information about an effect.
 *
 *          It is valid to update the parameters of an effect while
 *          it is playing.  The new parameters take effect immediately
 *          upon download if the device supports dynamic updating of effect
 *          parameters.  The <mf IDirectInputEffect::SetParameters>
 *          method automatically downloads the effect, but this behavior
 *          can be suppressed by setting the <c DIEP_NODOWNLOAD> flag.
 *
 *          If automatic download has been suppressed, then you can
 *          manually download the effect by invoking the
 *          <mf IDirectInputEffect::Download> method.
 *
 *          If the effect is playing while the parameters are changed,
 *          then the new parameters take effect as if they were the
 *          parameters when the effect started.
 *
 *          For example, suppose a periodic effect with a duration
 *          of three seconds is started.
 *          After two seconds, the direction of the effect is changed.
 *          The effect will then continue for one additional second
 *          in the new direction.  The envelope, phase, amplitude,
 *          and other parameters of the effect continue smoothly
 *          as if the direction had not changed.
 *
 *          In the same scenario, if after two seconds, the duration
 *          of the effect were changed to 1.5 seconds, then the effect
 *          would stop, because two seconds have already elapsed from
 *          the beginning of effect playback.
 *
 *          Two additional flags control the download behavior.
 *          The <c DIEP_START> flag indicates that the effect should
 *          be started (or restarted if it is currently playing) after
 *          the parameters are updated.  By default, the play state
 *          of the effect is not altered.
 *
 *          Normally, if the driver cannot update the parameters
 *          of a playing effect, it is permitted to stop the effect,
 *          update the parameters, and then restart the effect.
 *          Passing the <c DIEP_NORESTART> flag suppresses this
 *          behavior.  If the driver cannot update the parameters
 *          of an effect while it is playing, the error code
 *          <c DIERR_EFFECTPLAYING> is returned and the parameters
 *          are not updated.
 *
 *          To summarize the behavior of the three flags that control
 *          download and playback behavior:
 *
 *          If <c DIEP_NODOWNLOAD> is set, then the effect parameters
 *          are updated but not downloaded to the device.
 *
 *          Otherwise, the <c DIEP_NODOWNLOAD> flag is clear.
 *
 *          If the <c DIEP_START> flag is set, then the effect
 *          parameters are updated and downloaded to the device,
 *          and the effect is started,
 *          as if the <mf IDirectInputEffect::Start> method were
 *          called.  Combining the update with <c DIEP_START> is
 *          slightly faster than calling
 *          <mf IDirectInputEffect::Start> separately, because
 *          it requires less information to be transmitted to the
 *          device.
 *
 *          Otherwise, both the <c DIEP_NODOWNLOAD> and
 *          <c DIEP_START> flags are clear.
 *
 *          If the effect is not playing, then the parameters
 *          are updated and downloaded to the device.
 *
 *          Otherwise, both the <c DIEP_NODOWNLOAD> and
 *          <c DIEP_START> flags are clear, and the effect is
 *          already playing.
 *
 *          If the parameters of the effect can be updated
 *          "on the fly", then the update is so performed.
 *
 *          Otherwise, both the <c DIEP_NODOWNLOAD> and
 *          <c DIEP_START> flags are clear, and the effect is
 *          already playing, and the parameters cannot be updated
 *          while the effect is playing.
 *
 *          If the <c DIEP_NORESTART> flag is set, then the
 *          error code <c DIERR_EFFECTPLAYING> is returned.
 *
 *          Otherwise, all three of the flags
 *          <c DIEP_NODOWNLOAD>, <c DIEP_START> and
 *          <c DIEP_NORESTART> are clear, and the effect is
 *          already playing, and the parameters cannot be
 *          updated while the effect is playing.
 *
 *          The effect is stopped, the parameters updated, and
 *          the effect is restarted.  The return code is
 *          <c DI_EFFECTRESTARTED>.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          Structure that contains effect information.
 *          The <e DIEFFECT.dwSize> field must be filled in by
 *          the application before calling this function, as well
 *          as any fields specified by corresponding bits in
 *          the <p dwFlags> parameter.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIEP_*> flags specifying which
 *          portions of the effect information is to be set
 *          and how the downloading of the effect parameters
 *          should be handled.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DI_NOTDOWNLOADED>: The parameters of the effect were
 *          successfully
 *          updated, but the effect could not be downloaded because
 *          the associated device is not acquired in exclusive mode.
 *          Note that this is a success code, because the
 *          parameters were successfully updated.
 *
 *          <c DI_TRUNCATED>: The parameters of the effect were
 *          successfully updated,
 *          but some of the effect parameters were
 *          beyond the capabilities of the device and were truncated
 *          to the nearest valid value.
 *          Note that this is a success code, because the
 *          parameters were successfully updated.
 *
 *          <c DI_EFFECTRESTARTED>: The parameters of the effect
 *          were successfully updated, and the effect was restarted.
 *          Note that this is a success code, because the
 *          parameters were successfully updated.
 *
 *          <c DI_TRUNCATEDANDRESTARTED>: The parameters of the effect
 *          were successfully updated, but some of the effect parameters
 *          were truncated, and the effect was restarted.  This code
 *          combines <c DI_TRUNCATED> and <c DI_EFFECTRESTARTED>.
 *          Note that this is a success code, because the
 *          parameters were successfully updated.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not been initialized.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *          <c DIERR_EFFECTPLAYING>: The parameters were not updated
 *          because
 *          the device does not support updating an effect while
 *          it is still playing, and the <c DIEP_NORESTART> flag was
 *          passed, prohibiting the driver from stopping the effect,
 *          updating its parameters, and restarting it.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_SetParameters(PDIE pdie, LPCDIEFFECT peff, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::SetParameters, (_ "ppx", pdie, peff, fl));

    if (SUCCEEDED(hres = hresPv(pdie)) &&
#if DIRECTINPUT_VERSION >= 0x0600
        SUCCEEDED(hres = hresFullValidReadPxCb2(peff,
                                                DIEFFECT_DX6,
                                                DIEFFECT_DX5, 1)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, ((peff->dwSize == cbX(DIEFFECT_DX6)) 
                                              ? DIEP_SETVALID : DIEP_SETVALID_DX5 ), 2))) {
#else
        SUCCEEDED(hres = hresFullValidReadPxCb(peff, DIEFFECT, 1)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, DIEP_SETVALID_DX5, 2))) {
#endif

        PDE this = _thisPvNm(pdie, def);

        CDIEff_EnterCrit(this);

        if (SUCCEEDED(hres = hresFullValidPeff(this, peff, fl, 1))) {

            BOOL fChangeEmulatedStartDelay = FALSE;
    
            /*
             *  Note that if fl == 0 (or nearly so),
             *  TryParameters doesn't do anything,
             *  albeit rather inefficiently.
             */
            hres = CDIEff_TryParameters(this, peff, fl);
            if (FAILED(hres)) {
                goto done;
            }

			/*
			 * Special case for DIEP_STARTDELAY.
			 */
			if (fl & DIEP_STARTDELAY)
			{
				if (this->dEffAttributes.dwStaticParams & DIEP_STARTDELAY)
				{
					/*
					 * Driver supports it, so don't worry.
					 */
					;
				}
				else
				{
					/*
					 * Driver doesn't support it.
					 * Take start delay out...
					 */
					fl &= ~(DIEP_STARTDELAY);
				    this->diepUnset &= ~(DIEP_STARTDELAY);

                    /*
                     * ...but remember that we may need to do something
                     */
                    fChangeEmulatedStartDelay = ( this->effDev.dwStartDelay != this->effTry.dwStartDelay );
					if (fl == 0)
					{
						hres = DI_OK;
						goto save;
					}

				}


			}

            /*
             *  Now pass the effTry to the device driver for
             *  final validation.
             *
             *  Passing fl=0 is a really slow way of downloading
             *  the effect, except that we return DI_DOWNLOADSKIPPED
             *  instead of an error code if the device is not exclusive
             *  acquired.
             *
             *  Passing fl=DIEP_NODOWNLOAD is a really slow NOP.
             *
             *  Note that inability to download due to lack of
             *  proper acquisition is not an error, merely a warning.
             */
            hres = CDIEff_DownloadWorker_(this, &this->effTry, fl, 0);
            AssertF(hres != DIERR_NOTDOWNLOADED);

            /*
             *  If the driver approves, then make the changes permanent.
             *  but first a check on the emulated driver
             */
			save:;

            if( SUCCEEDED(hres) ) 
            {
                if( fChangeEmulatedStartDelay )
                {
                    /*
                     * The start delay for parameter has been changed, so 
                     * any future iteration is OK also the driver has 
                     * SUCCEEDED any other changes.
                     */
                    if( this->dwMessage != EFF_PLAY )
                    {
                        /*
                         * We're not in the delay, so declare everything OK.
                         */
                    }
                    else
                    {
                        /*
                         * If the download was skipped don't bother.
                         */
                        if( hres != DI_DOWNLOADSKIPPED )
                        {
                            if( fl & DIEP_NORESTART )
                            {
                                /*
                                 * We don't support changing the delay during the 
                                 * delay.  Since the driver has already had its 
                                 * parameters changed, only fail this if the 
                                 * delay was the only change requested.
                                 */
                                if( fl == 0 )
                                {
                                    hres = DIERR_EFFECTPLAYING;
                                }
                            }
                            else
                            {
                                /*
                                 * Since we don't support modifying the delay 
                                 * whilst we're in it, restart with the new 
                                 * delay.
                                 * If we were being really smart, we could 
                                 * try to adjust the delay without restarting.
                                 */
                                if( this->hEventDelete && this->hEventGeneral )
                                {
                                    this->dwMessage = EFF_PLAY;
                                    ResetEvent(this->hEventGeneral);
                                    SetEvent(this->hEventGeneral);
                                    if( ( hres & ~DI_TRUNCATEDANDRESTARTED ) == 0 ) 
                                    {
                                        hres |= DI_EFFECTRESTARTED;
                                    }
                                    else if( hres == DI_NOEFFECT )
                                    {
                                        hres = DI_EFFECTRESTARTED;
                                    }
                                }
                                else
                                {
                                    AssertF( !"Effect synchronization event(s) NULL" );
                                }
                            }
                        }
                    }
                }
                else
                {
                    /*
                     *  If there was no change to an emulated start delay then 
                     *  the result we have is already what we need.
                     */
                }
            }

            if (SUCCEEDED(hres)) {
                this->diepUnset &= ~fl;             /* No longer unset */

                /*
                 *  If we didn't download, then the parameters are
                 *  dirty and need to be downloaded later.
                 */
                if (hres == DI_DOWNLOADSKIPPED) {
                    this->diepDirty |= (fl & DIEP_ALLPARAMS);
                }

                CDIEff_SaveTry(this, peff, fl);     /* Save permanently */

            }


        done:;
            FreePpv(&this->lpvTSP);

        }

        CDIEff_LeaveCrit(this);

    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | RealStart |
 *
 *          Actually begin playing an effect.  The parent device must
 *          be acquired.
 *
 *          If the effect is already playing, then it is restarted
 *          from the beginning.
 *
 *          If the effect has not been downloaded or has been
 *          modified since its last download, then it will be
 *          downloaded before being started.  This default
 *          behavior can be suppressed by passing the
 *          <c DIES_NODOWNLOAD> flag.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   DWORD | dwIterations |
 *
 *          Number of times to play the effect in sequence.
 *          The envelope is re-articulated with each iteration.
 *
 *          To play the effect exactly once, pass 1.
 *
 *          To play the effect repeatedly until explicitly stopped,
 *          pass <c INFINITE>.
 *
 *          To play the effect until explicitly stopped without
 *          re-articulating the envelope, modify the effect
 *          parameters via <mf IDirectInputEffect::SetParameters>
 *          and change its <e DIEFFECT.dwDuration> to <c INFINITE>.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags that describe how the effect should be played
 *          by the device.  It can be zero or more of the
 *          <c DIES_*> flags.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not been initialized or no effect parameters have been
 *          set.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_RealStart(PDIE pdie, DWORD dwcLoop, DWORD fl)
{
	HRESULT hres;
    EnterProcR(IDirectInputEffect::Start, (_ "ppx", pdie, dwcLoop, fl));

    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, DIES_VALID, 2))) {

        PDE this = _thisPvNm(pdie, def);
		
        if( SUCCEEDED( hres= (IsBadReadPtr(this, cbX(this))) ? E_POINTER : S_OK ) )
        {
            CDIEff_EnterCrit(this);
    
            if (SUCCEEDED(hres = CDIEff_CanAccess(this))) {
    
                if (fl & DIES_NODOWNLOAD) {
                    /*
                     *  App wants fine control.  Let him have it.
                     */
                    hres = IDirectInputEffectShepherd_StartEffect(
                              this->pes, &this->sh, fl & DIES_DRIVER, dwcLoop);
                } else {
                    /*
                     *  App wants us to do the work.  First thing to do
                     *  is see if the effect needs to be downloaded.
                     *
                     *  SyncShepHandle checks if the effect is downloaded.
                     */
                    hres = CDIEff_SyncShepHandle(this);
    
                    if (this->diepDirty == 0 && this->sh.dwEffect) {
                        /*
                         *  Effect is clean and downloaded.
                         *  Just start it normally.
                         */
                        hres = IDirectInputEffectShepherd_StartEffect(
                                    this->pes, &this->sh,
                                    fl & DIES_DRIVER, dwcLoop);
    
                    } else {
                        /*
                         *  Effect needs to be downloaded.  We can
                         *  optimize it if no special flags are set
                         *  and the loop count is exactly unity.
                         */
                        if (fl == 0 && dwcLoop == 1) {
                            hres = CDIEff_DownloadWorker(this, &this->effDev,
                                                         DIEP_START);
                        } else {
                            /*
                             *  Cannot optimize; must do separate download
                             *  followed by Start.
                             */
                            hres = CDIEff_DownloadWorker(this, &this->effDev, 0);
                            if (SUCCEEDED(hres)) {
                                hres = IDirectInputEffectShepherd_StartEffect(
                                            this->pes, &this->sh,
                                            fl & DIES_DRIVER, dwcLoop);
                            }
                        }
                    }
                }
            }
    
            CDIEff_LeaveCrit(this); 
        }
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | WINAPI | CDIEff_ThreadProc |
 *
 *			Used to simulate dwStartDelay for drivers that do not support it.
 *          Begin playing an effect that has already been downloaded.  The parent device must
 *          be acquired.
 *
 *          If the effect is already playing, then it is restarted
 *          from the beginning.
 *
 *          If the effect has not been downloaded or has been
 *          modified since its last download, then it will be
 *          downloaded before being started.  This default
 *          behavior can be suppressed by passing the
 *          <c DIES_NODOWNLOAD> flag.
 *	
 *			After starting the effect, kills the timer whose event activated CDIEff_TimerProc
 *
 *
 *  @parm   LPVOID | lpParameter |
 *
 *			LPDIRECTINPUTEFFECT pointer.
 *
 *  @returns
 *
 *         0 if succeeded in starting the effect, or if the effect has been deleted by the app.
 *         -1 otherwise
 *
 *****************************************************************************/

 DWORD WINAPI CDIEff_ThreadProc(LPVOID lpParameter)
 {

	LPDIRECTINPUTEFFECT pdie = (LPDIRECTINPUTEFFECT) lpParameter;

	HRESULT hres = E_FAIL;
	DWORD dwWait;
	HANDLE hArray[2];
	BOOL startCalled = FALSE;

    PDE this = _thisPvNm(pdie, def);
    
    if( SUCCEEDED( hres= (IsBadReadPtr(this, cbX(this))) ? E_POINTER : S_OK ) )
    {
        if( this->hEventDelete != NULL && this->hEventThreadDead != NULL ) 
        {
        	hArray[0] = this->hEventDelete;
        	hArray[1] = this->hEventGeneral;
        
            ResetEvent( this->hEventThreadDead );
    
        	/*
        	 * Wait till the timeout expires, or till one of the events happens -- 
        	 * the effect is deleted by the app (hEventDelete) or the effect is started (hEventStart),
        	 * or the effect is stopped (hEventStop).
        	 */
        
            dwWait = WAIT_TIMEOUT; 
            while (dwWait != WAIT_OBJECT_0 && dwWait != WAIT_FAILED)
            {
                if (dwWait == WAIT_TIMEOUT) 
                {
                    if (startCalled)
                    {
                        /* 
                         * Start have been called, and timeout has expired.
                         * Start the effect. And wait again.
                         */
                        hres = CDIEff_RealStart(pdie, this->dwcLoop, this->dwFlags);
                        startCalled = FALSE;
                        this->dwMessage = EFF_DEFAULT;
                    }
    
                }
    
                else
                {
                    if (dwWait == (WAIT_OBJECT_0 + 1))
                    {
                        /* 
                         * App called Start on the effect.
                         * Set flag  and start waiting anew.
                         */
                        if (this->dwMessage == EFF_PLAY)
                        {
                            if ((this->effDev).dwStartDelay/1000 == 0)
                            {
                                /*
                                 * If time delay is 0 ms, start immediately.
                                 */
                                hres = CDIEff_RealStart(pdie, this->dwcLoop, this->dwFlags);
                                startCalled = FALSE;
                                this->dwMessage = EFF_DEFAULT;
                            }
    
                            else
                            {
                                startCalled = TRUE;
                            }
                        }
                        else
                        {
                            if (this->dwMessage == EFF_STOP)
                            {
                                startCalled = FALSE;
                                this->dwMessage = EFF_DEFAULT;
                            }
                        }
                        
                        ResetEvent(this->hEventGeneral);
                    }
    
                }
    
    
                /*
                 * And wait again.
                 */
                    
                if (startCalled == TRUE) {
                    dwWait = WaitForMultipleObjects(2, hArray, FALSE, (this->effDev).dwStartDelay/1000);
                } else {
                    dwWait = WaitForMultipleObjects(2, hArray, FALSE, INFINITE);
                }
            }
            
            SetEvent( this->hEventThreadDead );
        }

        /* 
         * App has deleted the effect.
         * Exit.
         */

        hres = DI_OK;
    	
    }

	if (SUCCEEDED(hres))
		return 0;
	else
		return -1;
 }


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Start |
 *
 *          Begin playing an effect.  The parent device must
 *          be acquired.
 *
 *          If the effect is already playing, then it is restarted
 *          from the beginning.
 *
 *          If the effect has not been downloaded or has been
 *          modified since its last download, then it will be
 *          downloaded before being started.  This default
 *          behavior can be suppressed by passing the
 *          <c DIES_NODOWNLOAD> flag.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   DWORD | dwIterations |
 *
 *          Number of times to play the effect in sequence.
 *          The envelope is re-articulated with each iteration.
 *
 *          To play the effect exactly once, pass 1.
 *
 *          To play the effect repeatedly until explicitly stopped,
 *          pass <c INFINITE>.
 *
 *          To play the effect until explicitly stopped without
 *          re-articulating the envelope, modify the effect
 *          parameters via <mf IDirectInputEffect::SetParameters>
 *          and change its <e DIEFFECT.dwDuration> to <c INFINITE>.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags that describe how the effect should be played
 *          by the device.  It can be zero or more of the
 *          <c DIES_*> flags.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not been initialized or no effect parameters have been
 *          set.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_Start(PDIE pdie, DWORD dwcLoop, DWORD fl)
{

	HRESULT hres;
	EnterProcR(IDirectInputEffect::Start, (_ "ppx", pdie, dwcLoop, fl));

    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, DIES_VALID, 2))) {

        PDE this = _thisPvNm(pdie, def);

        if( SUCCEEDED( hres= (IsBadReadPtr(this, cbX(this))) ? E_POINTER : S_OK ) )
        {
            CDIEff_EnterCrit(this);
        
            if (SUCCEEDED(hres = CDIEff_CanAccess(this))) {
        
                this->dwcLoop = dwcLoop;
                this->dwFlags = fl;
        
                if (this->hEventDelete == NULL)
                    hres = CDIEff_RealStart(pdie, dwcLoop, fl);
                else 
                {
                    /* 
                     * Activate the thread's waiting period
                     */
                    hres = CDIEff_DownloadWorker(this, &this->effDev, 0);
                    if (this->hEventGeneral != NULL)
                    {
                        this->dwMessage = EFF_PLAY;
                        ResetEvent(this->hEventGeneral);
                        SetEvent(this->hEventGeneral);
                    }
                    
                }	
        
            }
        
            CDIEff_LeaveCrit(this);
        }
	}

	ExitOleProcR();
    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Stop |
 *
 *          Stop playing an effect.  The parent device must
 *          be acquired.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not been initialized or no effect parameters have been
 *          set.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_Stop(PDIE pdie)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::Stop, (_ "p", pdie));

    if (SUCCEEDED(hres = hresPv(pdie))) {

        PDE this = _thisPvNm(pdie, def);

        CDIEff_EnterCrit(this);

        if (SUCCEEDED(hres = CDIEff_CanAccess(this))) {
            hres = IDirectInputEffectShepherd_StopEffect(this->pes, &this->sh);
        }

		if (this->hEventGeneral != NULL)
		{
			this->dwMessage = EFF_STOP;
			ResetEvent(this->hEventGeneral);
			SetEvent(this->hEventGeneral);
		}

        CDIEff_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | GetEffectStatus |
 *
 *          Retrieves the status of an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   LPDWORD | pdwFlags |
 *
 *          Receives the status flags for the effect.  It may
 *          consist of zero or more <c DIEGES_*> flag values.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not been initialized or no effect parameters have been
 *          set.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  At least one
 *          of the parameters is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_GetEffectStatus(PDIE pdie, LPDWORD pdwOut)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::Stop, (_ "p", pdie));

    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresFullValidPcbOut(pdwOut, cbX(*pdwOut), 1))) {

        PDE this = _thisPvNm(pdie, def);

        CAssertF(DEV_STS_EFFECT_RUNNING == DIEGES_PLAYING);

        CDIEff_EnterCrit(this);

        if (SUCCEEDED(hres = CDIEff_CanAccess(this))) {

			/*
			 * Check the dwMessage first -- 
			 * if it says PLAYING, report DIEGES_PLAYING
			 */
			if (this->dwMessage == EFF_PLAY)
			{
				*pdwOut = DIEGES_PLAYING;
				hres = DI_OK;
			}
			else
			{
				hres = IDirectInputEffectShepherd_GetEffectStatus(
							this->pes, &this->sh, pdwOut);
			}
        }

        CDIEff_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Escape |
 *
 *          Send a hardware-specific command to the driver.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Pointer to a <t DIEFFESCAPE> structure which describes
 *          the command to be sent.  On success, the
 *          <e DIEFFESCAPE.cbOutBuffer> field contains the number
 *          of bytes of the output buffer actually used.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTDOWNLOADED>:  The effect is not downloaded.
 *
 *          <c DIERR_NOTINITIALIZED>: The <i IDirectInputEffect> object
 *          has not yet been <mf IDirectInputEffect::Initialize>d.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_Escape(PDIE pdie, LPDIEFFESCAPE pesc)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::Escape, (_ "p", pdie));

    /*
     *  The output buffer is NoScramble because some people like
     *  to pass overlapping in and out buffers.
     */
    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresFullValidPesc(pesc, 1))) {
        PDE this = _thisPvNm(pdie, def);

        CDIEff_EnterCrit(this);

        /*
         *  Download the effect if it isn't downloaded yet,
         *  so we have a valid effect to Escape on.
         */
        hres = CDIEff_DownloadWorker(this, &this->effDev, 0);
        if (SUCCEEDED(hres)) {
            hres = IDirectInputEffectShepherd_Escape(
                        this->pes, &this->sh, pesc);
        } else {
            hres = DIERR_NOTDOWNLOADED;
        }

        CDIEff_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Initialize |
 *
 *          Initialize a DirectInputEffect object.
 *
 *          Note that if this method fails, the underlying object should
 *          be considered to be an an indeterminate state and needs to
 *          be reinitialized before it can be subsequently used.
 *
 *          The <mf IDirectInputDevice::CreateEffect> method automatically
 *          initializes the device after creating it.  Applications
 *          normally do not need to call this function.
 *
 *  @cwrap  LPDIRECTINPUTEFFECT | lpDirectInputEffect
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInputEffect object.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   IN REFGUID | rguid |
 *
 *          Identifies the effect for which the interface
 *          should be associated.
 *          The <mf IDirectInputDevice::EnumEffects> method
 *          can be used to determine which effect GUIDs are supported by
 *          the device.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_DEVICENOTREG>: The effect GUID does not exist
 *          on the current device.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TSDPROC c_rgtsd[] = {
    CDIEff_IsValidConstantTsd,      /* DIEFT_CONSTANTFORCE  */
    CDIEff_IsValidRampTsd,          /* DIEFT_RAMPFORCE      */
    CDIEff_IsValidPeriodicTsd,      /* DIEFT_PERIODIC       */
    CDIEff_IsValidConditionTsd,     /* DIEFT_CONDITION      */
    CDIEff_IsValidCustomForceTsd,   /* DIEFT_CUSTOMFORCE    */
#if DIRECTINPUT_VERSION >= 0x0800
    CDIEff_IsValidRandomTsd,        /* DIEFT_RANDOM         */
    CDIEff_IsValidAbsoluteTsd,      /* DIEFT_ABSOLUTE       */
    CDIEff_IsValidBumpForceTsd,     /* DIEFT_BUMPFORCE      */
    CDIEff_IsValidConditionExTsd,   /* DIEFT_CONDITIONEX    */
#endif /* DIRECTINPUT_VERSION >= 0x0800 */
};

STDMETHODIMP
CDIEff_Initialize(PDIE pdie, HINSTANCE hinst, DWORD dwVersion, REFGUID rguid)
{

	HRESULT hres;
    EnterProcR(IDirectInputEffect::Initialize,
               (_ "pxxG", pdie, hinst, dwVersion, rguid));

    if (SUCCEEDED(hres = hresPv(pdie)) &&
        SUCCEEDED(hres = hresValidInstanceVer(hinst, dwVersion)) &&
        SUCCEEDED(hres = hresFullValidGuid(rguid, 1))) {
        PDE this = _thisPv(pdie);
        EFFECTMAPINFO emi;

        AssertF(this->pes);

        /*
         *  Don't let somebody mess with the effect while we're
         *  resetting it.
         */
        CDIEff_EnterCrit(this);

        if (SUCCEEDED(hres = CDIDev_FindEffectGUID(this->pdev, rguid,
                                                   &emi, 3)) &&
            SUCCEEDED(hres = CDIEff_Reset(this))) {

            /*
             *  ISSUE-2001/03/29-timgill Need to check for actual hardware FF effect support
             */

			/*
			 * Initialize dEffAttributes 
			 */
            this->fInitialized = 1;
            this->dEffAttributes = emi.attr;
            this->guid = *rguid;

		
			/* 
			 * Check if the app is using DX6 or above structure.
			 * If not, no dwStartDelay is being requested by the app.
			 * 
			 * Check if the driver supports dwStartDelay.
			 * If it does, no need for us to do anything in that respect.
			 */

			if ((dwVersion < 0x0600)  ||
				((this->dEffAttributes).dwStaticParams & DIEP_STARTDELAY))
			{
				/*
				 * No need to emulate dwStartDelay.
				 */
				;
			}

			else
			{
					/*
					 * Driver doesn't support start delay.
					 * Start a thread that will emulate dwStartDelay.
					 */
	
					DWORD dwThreadId;
					HANDLE hThread;

					this->hEventDelete = CreateEvent(NULL, TRUE, FALSE, NULL);
					this->hEventThreadDead = CreateEvent(NULL, TRUE, FALSE, NULL);

					hThread = CreateThread(NULL, 0, CDIEff_ThreadProc, (LPVOID)pdie, 0, &dwThreadId);
					if (hThread == NULL)
					{
						/* Failed to create the thread.
						 * Clean up all our preparations.
						 */
						CloseHandle(this->hEventDelete);
						this->hEventDelete = NULL;
						CloseHandle(this->hEventThreadDead);
						this->hEventThreadDead = NULL;
						hres = hresLe(GetLastError());		
					}

					else
					{
						/*
						 * Create an event to signal effect started or stopped
						 */
						this->hEventGeneral = CreateEvent(NULL, TRUE, FALSE, NULL);
					}
			}


            this->dwCoords = emi.attr.dwCoords & DIEFF_COORDMASK;
            AssertF(this->dwCoords);


            /*
             *  Note, we allow non-hardware specific types that are not 
             *  recognized to pass through untested.  This effects to be run 
             *  from a device which has newer effects than this version of 
             *  DInput can check.  However if this DInput recognizes the 
             *  effect type, it will be checked, even if the application was 
             *  written for a version that could not check it.
             */
            if (fInOrder(DIEFT_PREDEFMIN, DIEFT_GETTYPE(emi.attr.dwEffType),
                         DIEFT_PREDEFMAX)) {
                this->hresValidTsd = c_rgtsd[
                            DIEFT_GETTYPE(emi.attr.dwEffType) -
                                                        DIEFT_PREDEFMIN];
            } else {
                this->hresValidTsd = CDIEff_IsValidUnknownTsd;
            }

            hres = S_OK;

        }

        CDIEff_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;


}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | Init |
 *
 *          Initialize the internal parts of the DirectInputEffect object.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD | pes |
 *
 *          The shepherd that lets us talk to the driver.
 *
 *****************************************************************************/

HRESULT INLINE
CDIEff_Init(struct CDIDev *pdev, LPDIRECTINPUTEFFECTSHEPHERD pes, PDE this)
{
    HRESULT hres;

    /*
     *  The critical section must be the very first thing we do,
     *  because only Finalize checks for its existence.
     *
     *  (We might be finalized without being initialized if the user
     *  passed a bogus interface to CDIEff_New.)
     */
    this->pdev = pdev;
    Common_Hold(this->pdev);

    this->pes = pes;
    OLE_AddRef(this->pes);

    hres = CDIDev_NotifyCreateEffect(this->pdev, this);
    if (SUCCEEDED(hres)) {
        this->fDadNotified = 1;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffect | New |
 *
 *          Create a new DirectInputEffect object, uninitialized.
 *
 *  @parm   IN struct CDIDev * | pdd |
 *
 *          Parent device, which we keep a <f Common_Hold> on.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD | pes |
 *
 *          The shepherd that lets us talk to the driver.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *****************************************************************************/

STDMETHODIMP
CDIEff_New(struct CDIDev *pdev, LPDIRECTINPUTEFFECTSHEPHERD pes,
           PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffect::<constructor>,
               (_ "ppGp", pdev, pes, riid, punkOuter));

	if (SUCCEEDED(hres = hresFullValidPcbOut(ppvObj, cbX(*ppvObj), 5)))
	{
		LPVOID pvTry = NULL;
		hres = Common_NewRiid(CDIEff, punkOuter, riid, &pvTry);

		if (SUCCEEDED(hres)) {
			PDE this = _thisPv(pvTry);
			hres = CDIEff_Init(pdev, pes, this);
			if (SUCCEEDED(hres)) {
				*ppvObj = pvTry;
			} else {
				Invoke_Release(&pvTry);
				*ppvObj = NULL;
			}
		}
	}

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CDIEff_Signature        0x20464643      /* "EFF " */

Primary_Interface_Begin(CDIEff, IDirectInputEffect)
    CDIEff_Initialize,
    CDIEff_GetEffectGuid,
    CDIEff_GetParameters,
    CDIEff_SetParameters,
    CDIEff_Start,
    CDIEff_Stop,
    CDIEff_GetEffectStatus,
    CDIEff_Download,
    CDIEff_Unload,
    CDIEff_Escape,
Primary_Interface_End(CDIEff, IDirectInputEffect)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\diemk.c ===
/*****************************************************************************
 *
 *  DIEmK.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Emulation module for keyboard.
 *
 *  Contents:
 *
 *      CEm_Kbd_CreateInstance
 *      CEm_Kbd_InitKeys
 *      CEm_LL_KbdHook
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEm

/*****************************************************************************
 *
 *          Keyboard emulation
 *
 *****************************************************************************/

STDMETHODIMP CEm_Kbd_Acquire(PEM this, BOOL fAcquire);

static BYTE s_rgbKbd[DIKBD_CKEYS];
HHOOK g_hhkKbd;
LPBYTE g_pbKbdXlat;

ED s_edKbd = {
    &s_rgbKbd,
    0,
    CEm_Kbd_Acquire,
    -1,
    cbX(s_rgbKbd),
    0x0,
};

static BOOL s_fFarEastKbd;
static BOOL fKbdCaptured;
static BOOL fNoWinKey;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CEm_Kbd_KeyboardHook |
 *
 *          Thread-specific keyboard hook filter.
 *
 *          Note that we need only one of these, since only the foreground
 *          window will require a hook.
 *
 *  @parm   int | nCode |
 *
 *          Notification code.
 *
 *  @parm   WPARAM | wp |
 *
 *          VK_* code.
 *
 *  @parm   LPARAM | lp |
 *
 *          Key message information.
 *
 *  @returns
 *
 *          Always chains to the next hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
CEm_Kbd_KeyboardHook(int nCode, WPARAM wp, LPARAM lp)
{
    BYTE bScan = 0x0;
    BYTE bAction;
    LRESULT lr;
    
    if (nCode == HC_ACTION || nCode == HC_NOREMOVE) {
        bScan = LOBYTE(HIWORD(lp));
        
        if (HIWORD(lp) & KF_EXTENDED) {
            bScan |= 0x80;
        }
        if (HIWORD(lp) & KF_UP) {
            bAction = 0;
        } else {
            bAction = 0x80;
        }

        bScan = g_pbKbdXlat[bScan];

       CEm_AddEvent(&s_edKbd, bAction, bScan, GetMessageTime());
    }

    lr = CallNextHookEx(g_hhkKbd, nCode, wp, lp);

    if( fKbdCaptured ) {
        // test Alt+Tab
        if( ((HIWORD(lp) & KF_ALTDOWN) && (bScan == 0x0F))
            || ((bScan == 0x38 || bScan == 0xb8) && bAction == 0)
        ) {
            return lr;
        } else {
            return TRUE;
        }
    } else if (fNoWinKey) {
        //If left_Winkey or right_WinKey pressed. We really should use virtual keys
        // if we could, but unfortunately no virtual key info is available.
        if( bScan == 0xdb || bScan == 0xdc ) {
            return TRUE;
        } else {
            return lr;
        }
    } else {
        return lr;
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Kbd_Hook_Acquire |
 *
 *          Acquire/unacquire a keyboard via a thread hook.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *  @parm   BOOL | fAcquire |
 *
 *          Whether the device is being acquired or unacquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Kbd_Hook_Acquire(PEM this, BOOL fAcquire)
{
    HRESULT hres;
    EnterProc(CEm_Kbd_Hook_Acquire, (_ "pu", this, fAcquire));

    AssertF(this->dwSignature == CEM_SIGNATURE);

    DllEnterCrit();
    if (fAcquire) {                 /* Install the hook */
        if (this->vi.hwnd) {
            if (!g_hhkKbd) {
                g_hhkKbd = SetWindowsHookEx(WH_KEYBOARD,
                                CEm_Kbd_KeyboardHook, g_hinst,
                                GetWindowThreadProcessId(this->vi.hwnd, 0));
                hres = S_OK;
            }
			else
				hres = E_FAIL;  //already hooked
        } else {
            RPF("Kbd::Acquire: Background mode not supported");
            hres = E_FAIL;
        }
    } else {                        /* Remove the hook */
        UnhookWindowsHookEx(g_hhkKbd);
        g_hhkKbd = 0;
        hres = S_OK;
    }

    DllLeaveCrit();

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Kbd_Acquire |
 *
 *          Acquire/unacquire a keyboard in a manner consistent with the
 *          emulation level.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Kbd_Acquire(PEM this, BOOL fAcquire)
{
    HRESULT hres;
    EnterProc(CEm_Kbd_Acquire, (_ "pu", this, fAcquire));

    AssertF(this->dwSignature == CEM_SIGNATURE);

    fKbdCaptured = FALSE;
    fNoWinKey = FALSE;
    if( fAcquire ) {
       if( this->vi.fl & VIFL_CAPTURED ) {
           fKbdCaptured = TRUE;
       } else if( this->vi.fl & VIFL_NOWINKEY ) {
           fNoWinKey = TRUE;
       }
    }

#ifdef USE_SLOW_LL_HOOKS
    AssertF(DIGETEMFL(this->vi.fl) == DIEMFL_KBD ||
            DIGETEMFL(this->vi.fl) == DIEMFL_KBD2);

    if (this->vi.fl & DIMAKEEMFL(DIEMFL_KBD)) {
        AssertF(g_fUseLLHooks);
        hres = CEm_LL_Acquire(this, fAcquire, this->vi.fl, LLTS_KBD);
    } else {
        hres = CEm_Kbd_Hook_Acquire(this, fAcquire);
    }
#else
    AssertF(DIGETEMFL(this->vi.fl) == DIEMFL_KBD2);
    hres = CEm_Kbd_Hook_Acquire(this, fAcquire);
#endif

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Kbd_CreateInstance |
 *
 *          Create a keyboard thing.  Also record what emulation
 *          level we ended up with so the caller knows.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.  The
 *          <e VXDDEVICEFORMAT.dwEmulation> field is updated to specify
 *          exactly what emulation we ended up with.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_Kbd_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    LPBYTE pbKbdXlat;

#ifdef WINNT
    /* 
     * In Win2K/WinXP, for legacy free machine, GetKeyboardType will return
     * unreliable result for non-PS2 keyboard. We will use the first time result
     * from GetKeyboardType (for GUID_SysKeyboard) which is also used by Generic 
     * Input to do translation.
     * Related Windows bug: 363700.
     */
    if( !g_pbKbdXlat ) {
#endif        
        pbKbdXlat = (LPBYTE)pdevf->dwExtra;
        if (!pbKbdXlat) {
            pbKbdXlat = pvFindResource(g_hinst, IDDATA_KBD_PCENH, RT_RCDATA);
        }

        AssertF(pbKbdXlat);
        AssertF(fLimpFF(g_pbKbdXlat, g_pbKbdXlat == pbKbdXlat));
        g_pbKbdXlat = pbKbdXlat;
#ifdef WINNT
    }
#endif

#ifdef USE_SLOW_LL_HOOKS
    /*
     *  Note carefully the test.  It handles the cases where
     *
     *  0.  The app did not ask for emulation, so we give it the
     *      best we can.  (dwEmulation == 0)
     *  1.  The app explicitly asked for emulation 1.
     *      (dwEmulation == DIEMFL_KBD)
     *  2.  The app explicitly asked for emulation 2.
     *      (dwEmulation == DIEMFL_KBD2)
     *  3.  The registry explicitly asked for both emulation modes.
     *      (dwEmulation == DIEMFL_KBD | DIEMFL_KBD2)
     *      Give it the best we can.  (I.e., same as case 0.)
     *
     *  All platforms support emulation 2.  Not all platforms support
     *  emulation 1.  If we want emulation 1 but can't get it, then
     *  we fall back on emulation 2.
     */

    /*
     *  First, if we don't have support for emulation 1, then clearly
     *  we have to use emulation 2.
     */

    if (!g_fUseLLHooks 
#ifdef DEBUG    
        || (g_flEmulation & DIEMFL_KBD2)
#endif        
    ) {
        pdevf->dwEmulation = DIEMFL_KBD2;
    } else

    /*
     *  Otherwise, we have to choose between 1 and 2.  The only case
     *  where we choose 2 is if 2 is explicitly requested.
     */
    if (pdevf->dwEmulation == DIEMFL_KBD2) {
        /* Do nothing */
    } else

    /*
     *  All other cases get 1.
     */
    {
        pdevf->dwEmulation = DIEMFL_KBD;
    }

    /*
     *  Assert that we never give emulation 1 when it doesn't exist.
     */
    AssertF(fLimpFF(pdevf->dwEmulation & DIEMFL_KBD, g_fUseLLHooks));

    /*
     *  Assert that exactly one emulation flag is selected.
     */
    AssertF(pdevf->dwEmulation == DIEMFL_KBD ||
            pdevf->dwEmulation == DIEMFL_KBD2);
#else
    /*
     *  We are being compiled for "emulation 2 only", so that simplifies
     *  matters immensely.
     */
    pdevf->dwEmulation = DIEMFL_KBD2;
#endif

    return CEm_CreateInstance(pdevf, ppviOut, &s_edKbd);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Kbd_InitKeys |
 *
 *          Initialize pieces of the keyboard state in preparation for
 *          acquisition.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The states of the <c VK_KANA> and <c VK_CAPITAL> keys.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_Kbd_InitKeys(PVXDDWORDDATA pvdd)
{

    /* Do this only when not acquired */
    if (s_edKbd.cAcquire < 0) {
        ZeroX(s_rgbKbd);
        if (pvdd->dw & 1) {
            s_rgbKbd[DIK_KANA] = 0x80;
        }
        if (pvdd->dw & 2) {
            s_rgbKbd[DIK_CAPITAL] = 0x80;
        }
        if (pvdd->dw & 8) {
            s_rgbKbd[DIK_KANJI] = 0x80;
        }
        s_fFarEastKbd = ((pvdd->dw & 16)) != 0;
    }

    return S_OK;
}

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CEm_LL_KbdHook |
 *
 *          Low-level keyboard hook filter.
 *
 *  @parm   int | nCode |
 *
 *          Notification code.
 *
 *  @parm   WPARAM | wp |
 *
 *          WM_* keyboard message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Key message information.
 *
 *  @returns
 *
 *          Always chains to the next hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
CEm_LL_KbdHook(int nCode, WPARAM wp, LPARAM lp)
{
    PLLTHREADSTATE plts;
    PKBDLLHOOKSTRUCT pllhs = (PV)lp;

    if (nCode == HC_ACTION) {
        BYTE bScan;
        BYTE bAction;
      D(DWORD tmStart = GetTickCount());

        wp;                         /* We don't care what the msg is */

        bScan = (BYTE)pllhs->scanCode;

        if( !bScan )
        {
            /* 
             *  ISSUE-2001/03/29-timgill  Special case for non-standard VK codes
             *  The bonus keys on some USB keyboards have zero scan code and 
             *  the extended key flag is clear.
             *  Get the scan code by mapping the VK, then map the 
             *  scan code back, if it is the same as the original VK assume 
             *  the scan code is not extended otherwise assume it is.
             *  This is no where near full proof and only works at all 
             *  because non-extended scan codes are matched first so extended 
             *  scan codes normally fail to translate back.
             */
            bScan = (BYTE)MapVirtualKey( pllhs->vkCode, 0 );
            if( MapVirtualKey( bScan, 3 ) != pllhs->vkCode )
            {
                bScan |= 0x80;
            }
        }
        else if (pllhs->flags & LLKHF_EXTENDED) {
            bScan |= 0x80;
        }

        if (pllhs->flags & LLKHF_UP) {
            bAction = 0;
        } else {
            bAction = 0x80;
        }

        bScan = g_pbKbdXlat[bScan];
        if( s_fFarEastKbd )
        {
            /*
             *  Manually toggle these keys on make, ignore break
             */
            if( ( bScan == DIK_KANA ) 
              ||( bScan == DIK_KANJI ) 
              ||( bScan == DIK_CAPITAL ) )
            {
                if( bAction )
                {
                    bAction = s_rgbKbd[bScan] ^ 0x80;
                }
                else
                {
                  D(SquirtSqflPtszV(sqflTrace | sqfl,
                                    TEXT("KBD! vk=%02x, scan=%02x, fl=%08x, tm=%08x")
                                    TEXT(" being skipped"),
                                    pllhs->vkCode, pllhs->scanCode, pllhs->flags,
                                    pllhs->time );)
                    goto KbdHook_Skip;
                }
            }
        }

        CEm_AddEvent(&s_edKbd, bAction, bScan, GetTickCount());

      D(SquirtSqflPtszV(sqflTrace | sqfl,
                        TEXT("KBD! vk=%02x, scan=%02x, fl=%08x, tm=%08x, ")
                        TEXT("in=%08x, out=%08x"),
                        pllhs->vkCode, pllhs->scanCode, pllhs->flags,
                        pllhs->time, tmStart, GetTickCount()));
KbdHook_Skip:;

    }

    /*
     *  ISSUE-2001/03/29-timgill  Need method for detecting Ctrl-Alt-Del
     *  If Ctrl+Alt+Del, then force global unacquire!
     *  Need to re-sync Ctrl, Alt, and Del on next keypress.
     *  Unfortunately, there is no way to find out if Ctrl+Alt+Del
     *  has been pressed...
     */

    plts = g_plts;
    if (plts) {
        LRESULT lr;

        lr = CallNextHookEx(plts->rglhs[LLTS_KBD].hhk, nCode, wp, lp);

        if( fKbdCaptured ) {
            if( ((pllhs->flags & LLKHF_ALTDOWN) && (pllhs->vkCode == VK_TAB)) ||
                ((pllhs->flags & LLKHF_UP) && (pllhs->vkCode == VK_LMENU || pllhs->vkCode == VK_RMENU))
            ) {
                return lr;
            } else {
                return TRUE;
            }
        } else if (fNoWinKey) {
            if( pllhs->vkCode == VK_LWIN || pllhs->vkCode == VK_RWIN ) {
                return TRUE;
            } else {
                return lr;
            }
        } else {
            return lr;
        }
    } else {
        /*
         *  This can happen if a message gets posted to the hook after 
         *  releasing the last acquire but before we completely unhook.
         */
        RPF( "DINPUT: Keyboard hook not passed on to next hook" );
        return 1;
    }

}

#endif  /* USE_SLOW_LL_HOOKS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\diemh.c ===
/*****************************************************************************
 *
 *  DIEmH.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Emulation module for HID.  HID is always run at ring 3,
 *      so "emulation" is a bit of a misnomer.
 *
 *  Contents:
 *
 *      CEm_HID_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef HID_SUPPORT

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

    #define sqfl sqflEm


/*****************************************************************************
 *
 *      Forward declarations
 *
 *      CEm_HID_ReadComplete and CEm_HID_IssueRead schedule each other
 *      back and forth.
 *
 *****************************************************************************/

void CALLBACK
    CEm_HID_ReadComplete(DWORD dwError, DWORD cbRead, LPOVERLAPPED po);
/*****************************************************************************
 *
 *          HID "emulation"
 *
 *****************************************************************************/

STDMETHODIMP CEm_HID_Acquire(PEM this, BOOL fAcquire);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | FakeCancelIO |
 *
 *          Stub function which doesn't do anything but
 *          keeps us from crashing.
 *
 *  @parm   HANDLE | h |
 *
 *          The handle whose I/O is supposed to be cancelled.
 *
 *****************************************************************************/

BOOL WINAPI
    FakeCancelIO(HANDLE h)
{
    AssertF(0);
    return FALSE;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | FakeTryEnterCriticalSection |
 *
 *          We use TryEnterCriticalSection in DEBUG to detect deadlock
 *          If the function does not exist, just enter CritSection and report
 *          true. This compromises some debug functionality.           
 *
 *  @parm   LPCRITICAL_SECTION | lpCriticalSection |
 *
 *          Address of Critical Section to be entered. 
 *
 *****************************************************************************/
#ifdef XDEBUG
BOOL WINAPI
    FakeTryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
    EnterCriticalSection(lpCriticalSection);
    return TRUE;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_Hold |
 *
 *          Place a hold on both the parent device and the
 *          emulation structure, so neither will go away while
 *          we aren't paying attention.
 *
 *  @parm   PCHID | this |
 *
 *          The item to be held.
 *
 *****************************************************************************/

void INTERNAL
    CEm_Hid_Hold(PCHID this)
{
    CEm_AddRef(pemFromPvi(this->pvi));
    Common_Hold(this);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_Unhold |
 *
 *          Release the holds we placed via <f CEm_HID_Hold>.
 *
 *  @parm   PCHID | this |
 *
 *          The item to be unheld.
 *
 *****************************************************************************/

void INTERNAL
    CEm_Hid_Unhold(PCHID this)
{
    CEm_Release(pemFromPvi(this->pvi));
    Common_Unhold(this);
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   BOOL | CEm_HID_IssueRead |
 *
 *          Issue another read request.
 *
 *  @parm   PCHID | this |
 *
 *          The device on which the read is to be issued.
 *
 *  @returns
 *
 *          Returns nonzero if the read was successfully issued.
 *
 *****************************************************************************/

BOOL EXTERNAL
    CEm_HID_IssueRead(PCHID this)
{
    BOOL fRc;

    fRc = ReadFileEx(this->hdevEm, this->hriIn.pvReport,
                     this->hriIn.cbReport, &this->o,
                     CEm_HID_ReadComplete);

    if(!fRc)
    {
        /*
         *  Couldn't issue read; force an unacquire.
         *
         *  Unhold the device once, since the read loop is gone.
         */
        // 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflError,
            TEXT("IssueRead: Access to HID device(%p, handle=0x%p) lost le=0x%x!"), 
            this, this->hdevEm, GetLastError() );

        DllEnterCrit();
        ConfirmF(SUCCEEDED(GPA_DeletePtr(&g_plts->gpaHid, pemFromPvi(this->pvi))));
        DllLeaveCrit();

        CEm_ForceDeviceUnacquire(&this->ed,
            (!(this->pvi->fl & VIFL_ACQUIRED)) ? FDUFL_UNPLUGGED : 0);

        CEm_Hid_Unhold(this);

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("Removed HID device(%p) from GPA "), this);
    }
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_PrepareState |
 *
 *          Prepare the staging area for a new device state
 *          by assuming that nothing has changed.
 *
 *  @parm   PCHID | this |
 *
 *          The device on which a read has just completed.
 *
 *****************************************************************************/

void INLINE
    CEm_HID_PrepareState(PCHID this)
{
    /*
     *  Copy over everything...
     */
    CopyMemory(this->pvStage, this->pvPhys, this->cbPhys);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_ReadComplete |
 *
 *          APC function which is called when an I/O has completed.
 *
 *  @parm   DWORD | dwError |
 *
 *          Error code, or zero on success.
 *
 *  @parm   DWORD | cbRead |
 *
 *          Number of bytes actually read.
 *
 *  @parm   LPOVERLAPPED | po |
 *
 *          I/O packet that completed.
 *
 *****************************************************************************/

void CALLBACK
    CEm_HID_ReadComplete(DWORD dwError, DWORD cbRead, LPOVERLAPPED po)
{
    PCHID this = pchidFromPo(po);

    //EnterProc(Cem_HID_ReadComplete, (_"ddp", dwError, cbRead, po ));


    /*
     *  Cannot own any critical sections because CEm_ForceDeviceUnacquire
     *  assumes that no critical sections are taken.
     */
    AssertF(!CDIDev_InCrit(this->pvi->pdd));
    AssertF(!DllInCrit());

    /*
     *  Process the data.
     *
     *  Note: We can get error STATUS_DEVICE_NOT_CONNECTED
     *  or ERROR_READ_FAULT if the device is unplugged.
     */
    if(dwError == 0 &&
       this->o.InternalHigh == this->caps.InputReportByteLength)
    {

        NTSTATUS stat;

        CEm_HID_PrepareState(this);

        stat = CHid_ParseData(this, HidP_Input, &this->hriIn);

        if(SUCCEEDED(stat))
        {
            CEm_AddState(&this->ed, this->pvStage, GetTickCount());
        }

        CEm_HID_IssueRead(this);
    } else
    {

        if(!dwError)
        {
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqflError | sqfl,
                            TEXT("ReadComplete HID(%p) short read! Got %d wanted %d"),
                            this,
                            this->o.InternalHigh,
                            this->caps.InputReportByteLength);

        } else
        {
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqflError | sqfl,
                            TEXT("ReadComplete HID(%p) read failed! error=0x%08x "),
                            this, dwError);
        }

        DllEnterCrit();
        ConfirmF(SUCCEEDED(GPA_DeletePtr(&g_plts->gpaHid, pemFromPvi(this->pvi))));
        DllLeaveCrit();

        CEm_ForceDeviceUnacquire(&this->ed,
                                 (!(this->pvi->fl & VIFL_ACQUIRED)) ? FDUFL_UNPLUGGED : 0);
        CEm_Hid_Unhold(this);
    }

    /*
     *  And wait for more data.
     *  If the read failed, then CEm_HID_IssueRead() will its Reference 
     */
    //    CEm_HID_IssueRead(this);

    //ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_Sync |
 *
 *          Kick off a read or kill the existing one.
 *
 *  @parm   PLLTHREADSTATE | plts |
 *
 *          Thread hook state containing hook information to synchronize.
 *
 *  @parm   PEM | pem |
 *
 *          Who is the poor victim?
 *
 *****************************************************************************/

void EXTERNAL
    CEm_HID_Sync(PLLTHREADSTATE plts, PEM pem)
{
    PCHID this;

    EnterProc(CEm_HID_Sync, (_ "pp", plts, pem ));

    this = pchidFromPem(pem);

    AssertF(GPA_FindPtr(&plts->gpaHid, pem));
    AssertF(this->pvi == &pem->vi);
    AssertF(pem->ped == &this->ed);

    /*
     *  Cannot own any critical sections because CEm_HID_IssueRead
     *  may result in a call to CEm_ForceDeviceUnacquire, which
     *  in turn assumes that no critical sections are taken.
     */
    AssertF(!CDIDev_InCrit(this->pvi->pdd));
    AssertF(!DllInCrit());

    if( pem->vi.fl & VIFL_ACQUIRED )
    {
        AssertF(this->hdevEm == INVALID_HANDLE_VALUE);
        /*
         *  Start reading.
         *
         *  While underneath the device critical section, duplicate
         *  the handle so we can avoid race conditions with the
         *  main thread (when the main thread closes the handle,
         *  we need to keep our private version alive so we can
         *  clean it up nicely).
         */

        /*
         *  Need to look again, in case the device has already
         *  been unacquired before we get a chance to synchronize
         *  with the main thread.  This can happen, for example,
         *  if the app quickly does an Acquire/Unacquire without
         *  an intervening thread switch.
         */
        AssertF(!CDIDev_InCrit(this->pvi->pdd));
        //CDIDev_EnterCrit(this->pvi->pdd);
        if(this->hdev != INVALID_HANDLE_VALUE)
        {
            HANDLE hProcessMe = GetCurrentProcess();
            HANDLE hdevEm;

            if(DuplicateHandle(hProcessMe, this->hdev,
                               hProcessMe, &hdevEm, GENERIC_READ,
                               0, 0))
            {
                this->hdevEm = hdevEm;
            }
        }
        //CDIDev_LeaveCrit(this->pvi->pdd);

        if(this->hdevEm != INVALID_HANDLE_VALUE)
        {
            /*
             *  On Win98, HidD_FlushQueue will fail if the underlying
             *  device is dead.  Whereas on NT, it blindly succeeds.
             *  Therefore, we cannot trust the return value.
             */
            HidD_FlushQueue(this->hdevEm);
        }

        /*
         * Even if we have failed to duplicate the handle
         * we still want to issue the read. A error in read
         * will force the device to be unacquired
         */
        CEm_HID_IssueRead(this);

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT(" StartReading(%p) "),
                        this);
    } else 
    {
        HANDLE hdev;
        /*
         *  Stop reading. There is still another outstanding
         *  hold by the read loop, which will be cleaned up when
         *  the the I/O cancel is received.
         */
        AssertF(this->hdevEm != INVALID_HANDLE_VALUE);

        hdev = this->hdevEm;
        this->hdevEm = INVALID_HANDLE_VALUE;

        if(hdev != INVALID_HANDLE_VALUE)
        {
            /*
             *  We don't need to call CancelIo because we're closing
             *  the handle soon anyway.  Which is good, because Memphis
             *  B#55771 prevents CancelIo from working on read-only
             *  handles (which we are).
             *
             */
            /* Need CancelIo on NT otherwise HID devices appear only on every
             * consecutive plug in 
             */

            _CancelIO(hdev);
            CloseHandle(hdev);
        }

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT(" StopReading(%p) "),
                        this);
    }

    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_HID_Acquire |
 *
 *          Acquire/unacquire a HID device.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *  @parm   BOOL | fAcquire |
 *
 *          Whether the device is being acquired or unacquired.
 *
 *****************************************************************************/

STDMETHODIMP
    CEm_HID_Acquire(PEM pem, BOOL fAcquire)
{
    HRESULT hres;
    PLLTHREADSTATE plts;
    PCHID pchid;

    EnterProc(CEm_HID_Acquire, (_ "pu", pem, fAcquire));

    AssertF(pem->dwSignature == CEM_SIGNATURE);

    pchid = pchidFromPem(pem);

    if( fAcquire )
    {
        pchid->hdev = CHid_OpenDevicePath(pchid, FILE_FLAG_OVERLAPPED);

        if(pchid->hdev != INVALID_HANDLE_VALUE )
        {
            hres = S_OK;
        } else
        {
            hres = DIERR_UNPLUGGED;
        }

    } else
    {
        HANDLE hdev;        

        AssertF(pchid->hdev != INVALID_HANDLE_VALUE);

        hdev = pchid->hdev;
        pchid->hdev = INVALID_HANDLE_VALUE;
        _CancelIO(hdev);
        CloseHandle(hdev);

        hres = S_OK;
    }

    if( pchid->IsPolledInput )
    {
        hres = S_OK;
        AssertF(pchid->hdevEm == INVALID_HANDLE_VALUE);

    } else if( SUCCEEDED(hres) )
    {
      #ifdef USE_WM_INPUT
        ResetEvent( g_hEventHid );
      #endif
        
        hres = CEm_GetWorkerThread(pem, &plts);

        if(SUCCEEDED(hres)  )
        {
            if(fAcquire  )
            {  
                /* Begin the I/O */
                /*
                 *  Must apply the hold before adding to the list
                 *  to avoid a race condition where the worker thread
                 *  unholds the pchid before we can hold it.
                 *
                 *  The rule is that there is a hold to track each copy
                 *  of the device on the gpaHid.
                 */
                CEm_Hid_Hold(pchid);

                /*
                 *  Add ourselves to the busy list, and wake up
                 *  the worker thread to tell him to start paying attention.
                 */

                DllEnterCrit();
                hres = GPA_Append(&plts->gpaHid, pem);
                DllLeaveCrit();

                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("Added HID device(%p) to GPA "), pchid );

                if(FAILED(hres))
                {
                    CEm_Hid_Unhold(pchid);
                }

                NudgeWorkerThreadPem(plts, pem);

              #ifdef USE_WM_INPUT
                if( g_fRawInput) {
                    DWORD dwRc;
                    dwRc = WaitForSingleObject( g_hEventHid, INFINITE );
                }
              #endif

            } else
            {
                HANDLE hdev;

                hdev = pchid->hdevEm;
                pchid->hdevEm = INVALID_HANDLE_VALUE;
                
                if(hdev != INVALID_HANDLE_VALUE)
                {
                    _CancelIO(hdev);
                    CloseHandle(hdev);
                }
            }

        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_HID_CreateInstance |
 *
 *          Create a HID thing.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    CEm_HID_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    PCHID pchid = (PCHID)pdevf->dwExtra;
    PED ped = &pchid->ed;

    AssertF(ped->pState == 0);
    AssertF(ped->pDevType == 0);
    *(PPV)&ped->pState = pchid->pvPhys;      /* De-const */
    ped->Acquire = CEm_HID_Acquire;
    ped->cAcquire = -1;
    ped->cbData = pdevf->cbData;
    ped->cRef = 0x0;

    return CEm_CreateInstance(pdevf, ppviOut, &pchid->ed);
}

#endif /* HID_SUPPORT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\digendef.c ===
/*****************************************************************************
 *
 *  DIGenDef.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Default IDirectInputDevice callback.
 *
 *  Contents:
 *
 *      CDefDcb_Acquire
 *      CDefDcb_Unacquire
 *      CDefDcb_GetProperty
 *      CDefDcb_SetProperty
 *      CDefDcb_SetCooperativeLevel
 *      CDefDcb_CookDeviceData
 *      CDefDcb_CreateEffect
 *      CDefDcb_GetFFConfigKey
 *      CDefDcb_SendDeviceData
 *      CDefDcb_Poll
 *      CDefDcb_MapUsage
 *      CDefDcb_GetUsage
 *      CDefDcb_SetDIData
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflNil

/*****************************************************************************
 *
 *      Note!  These are generic default functions that all return
 *      E_NOTIMPL.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | Acquire |
 *
 *          Tell the device driver to begin data acquisition.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: The device could not be acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_Acquire(PDICB pdcb)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::Acquire, (_ "p", pdcb));

    hres = S_FALSE;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | Unacquire |
 *
 *          Tell the device driver to stop data acquisition.
 *
 *          It is the caller's responsibility to call this only
 *          when the device has been acquired.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: The device was not acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_Unacquire(PDICB pdcb)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::Unacquire, (_ "p", pdcb));

    hres = S_FALSE;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDefDcb | GetProperty |
 *
 *          Retrieve a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Where to put the property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDefDcb | SetProperty |
 *
 *          Set a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::SetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | SetEventNotification |
 *
 *          Called by DirectInput to inquire whether the device
 *          supports event notifications.
 *
 *  @parm   IN PDM | this |
 *
 *          The object in question.
 *
 *  @field  HANDLE | h |
 *
 *          The notification handle, if any.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SetEventNotification(PDICB pdcb, HANDLE h)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::DefDcb::SetEventNotification,
               (_ "px", pdcb, h));

    /*
     *  Yes, we support it.  Please do it for me.
     */
    hres = S_FALSE;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefdcb | SetCooperativeLevel |
 *
 *          Notify the device of the cooperative level.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | CookDeviceData |
 *
 *          Manipulate buffered device data.
 *
 *  @parm   UINT | cdod |
 *
 *          Number of objects to cook; zero is a valid value.
 *
 *  @parm   LPDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of object data to cook.
 *
 *  @returns
 *
 *          <c E_NOTIMPL>: Nothing happened.
 *
 ***************************************************************************/

STDMETHODIMP
CDefDcb_CookDeviceData(PDICB pdcb, UINT cdod, LPDIDEVICEOBJECTDATA rgdod)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::CookDeviceData,
               (_ "pxp", pdcb, cdod, rgdod));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | CreateEffect |
 *
 *          Create an <i IDirectInputEffectDriver> interface.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD * | ppes |
 *
 *          Receives the shepherd for the effect driver.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Kbd::CreateEffect, (_ "p", pdcb));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | GetFFConfigKey |
 *
 *          Open and return the registry key that contains
 *          force feedback configuration information.
 *
 *  @parm   DWORD | sam |
 *
 *          Security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the registry key.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::GetFFConfigKey,
               (_ "px", pdcb, sam));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | SendDeviceData |
 *
 *          Spew some data to the device.
 *
 *  @parm   IN LPCDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          Number of items actually sent.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we don't support output.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SendDeviceData(PDICB pdcb, LPCDIDEVICEOBJECTDATA rgdod,
                       LPDWORD pdwInOut, DWORD fl)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::SendDeviceData, (_ "p", pdcb));

    *pdwInOut = 0;
    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | Poll |
 *
 *          Ping down into the driver to get the latest data.
 *
 *  @returns
 *
 *          <c S_FALSE> because nothing is pollable.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_Poll(PDICB pdcb)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::Poll, (_ "p", pdcb));

    hres = S_FALSE;

    ExitOleProcR();
    return hres;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | GetVersions |
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: No version
 *          information is available.
 *
 ***************************************************************************/

STDMETHODIMP
CDefDcb_GetVersions(PDICB pdcb, LPDIDRIVERVERSIONS pvers)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::GetVersions, (_ "p", pdcb));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | MapUsage |
 *
 *          Given a usage and usage page (munged into a single
 *          <t DWORD>), find a device object that matches it.
 *
 *  @parm   DWORD | dwUsage |
 *
 *          The usage page and usage combined into a single <t DWORD>
 *          with the <f DIMAKEUSAGEDWORD> macro.
 *
 *  @parm   PINT | piOut |
 *
 *          Receives the object index of the found object, if successful.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we don't support usages.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_MapUsage(PDICB pdcb, DWORD dwUsage, PINT piOut)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::MapUsage, (_ "p", pdcb));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CDefDcb | GetUsage |
 *
 *          Given an object index, return the usage and usage page,
 *          packed into a single <t DWORD>.
 *
 *  @parm   int | iobj |
 *
 *          The object index to convert.
 *
 *  @returns
 *
 *          Zero because we don't support usages.
 *
 *****************************************************************************/

STDMETHODIMP_(DWORD)
CDefDcb_GetUsage(PDICB pdcb, int iobj)
{
    EnterProcI(IDirectInputDeviceCallback::Def::GetUsage, (_ "p", pdcb));

    return 0;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | SetDIData |
 *
 *          Set DirectInput version and AppHack data from CDIDev *.
 *
 *  @parm   DWORD | dwVer |
 *
 *          DirectInput version
 *
 *  @parm   LPVOID | lpdihacks |
 *
 *          AppHack data
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we don't support usages.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::SetDIData, (_ "pup", pdcb, dwVer, lpdihacks));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dieshep.c ===
/*****************************************************************************
 *
 *  DIEShep.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The IDirectInputEffectDriver shepherd.
 *
 *      The shepherd does the annoying work of babysitting the
 *      external IDirectInputDriver.
 *
 *      It makes sure nobody parties on bad handles.
 *
 *      It handles cross-process (or even intra-process) effect
 *      management.
 *
 *      It caches the joystick ID so you don't have to.
 *
 *  Contents:
 *
 *      CEShep_New
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEShep

#pragma BEGIN_CONST_DATA

#ifdef IDirectInputDevice2Vtbl

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

  Primary_Interface(CEShep, IDirectInputEffectShepherd);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CEShep |
 *
 *          The <i IDirectInputEffectShepherd> object, which
 *          babysits an <i IDirectInputEffectDriver>.
 *
 *  @field  IDirectInputEffectShepherd | des |
 *
 *          DirectInputEffectShepherd object (containing vtbl).
 *
 *  @field  IDirectInputEffectDriver * | pdrv |
 *
 *          Delegated effect driver interface.
 *
 *  @field  UINT | idJoy |
 *
 *          Joystick identification number.
 *
 *  @field  HINSTANCE | hinst |
 *
 *          The instance handle of the DLL that contains the effect
 *          driver.
 *
 *****************************************************************************/

typedef struct CEShep {

    /* Supported interfaces */
    IDirectInputEffectShepherd des;

    IDirectInputEffectDriver *pdrv;

    UINT        idJoy;
    HINSTANCE   hinst;

} CEShep, ES, *PES;

typedef IDirectInputEffectShepherd DES, *PDES;
#define ThisClass CEShep
#define ThisInterface IDirectInputEffectShepherd

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *//**************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *//**************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | QIHelper |
 *
 *          We don't have any dynamic interfaces and simply forward
 *          to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *//**************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CEShep)
Default_AddRef(CEShep)
Default_Release(CEShep)

#else

#define CEShep_QueryInterface   Common_QueryInterface
#define CEShep_AddRef           Common_AddRef
#define CEShep_Release          Common_Release

#endif

#define CEShep_QIHelper         Common_QIHelper
#define CEShep_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEShep_Finalize |
 *
 *          Clean up our instance data.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CEShep_Finalize(PV pvObj)
{
    PES this = pvObj;

    Invoke_Release(&this->pdrv);

    if (this->hinst) {
        FreeLibrary(this->hinst);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CEShep | UnlockDevice |
 *
 *          Unlock the joystick table after we are finished messing
 *          with the device.
 *
 *****************************************************************************/

void INLINE
CEShep_UnlockDevice(void)
{
    ReleaseMutex(g_hmtxJoy);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEShep | LockDevice |
 *
 *          Validate that the the device access token is still valid.
 *
 *          If so, then take the joystick mutex to prevent someone
 *          from dorking with the device while we're using it.
 *          Call <f CEShep_UnlockDevice> when done.
 *
 *          If not, then try to steal ownership if requested.
 *
 *          Else, fail.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Handle to lock.
 *
 *  @parm   DWORD | dwAccess |
 *
 *          If <c DISFFC_FORCERESET>, then force ownership of the device.
 *          This is done as part of device acquisition to kick out the
 *          previous owner.
 *
 *          Otherwise, if the device belongs to somebody else, then
 *          leave it alone.
 *
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> if the lock failed.
 *          Note that
 *          <mf IDirectInputEffectDevice2::SetForceFeedbackState>
 *          and
 *          <mf IDirectInputEffectDevice2::GetForceFeedbackState>
 *          are particularly keen on this error code.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_LockDevice(PES this, PSHEPHANDLE psh, DWORD dwAccess)
{
    HRESULT hres;
    EnterProc(CEShep_LockDevice, (_ "puu", this, psh->dwTag, dwAccess));

    WaitForSingleObject(g_hmtxJoy, INFINITE);

    /*
     *  Note that DISFFC_FORCERESET allows unconditional access.
     *  DISFFC_FORCERESET is used when we perform the initial reset
     *  after acquiring, so we can legitimately steal the device
     *  from the previous owner.
     */
    if (dwAccess & DISFFC_FORCERESET) {
        hres = S_OK;
    } else if (g_psoh->rggjs[this->idJoy].dwTag == psh->dwTag) {
        hres = S_OK;
    } else {
        ReleaseMutex(g_hmtxJoy);
        hres = DIERR_NOTEXCLUSIVEACQUIRED;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CEShep | UnlockEffect |
 *
 *          Unlock the joystick table after we are finished messing
 *          with an effect.
 *
 *****************************************************************************/

void INLINE
CEShep_UnlockEffect(void)
{
    ReleaseMutex(g_hmtxJoy);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEShep | LockEffect |
 *
 *          Validate that the the effect handle is still valid.
 *
 *          If so, then take the joystick mutex to prevent someone
 *          from dorking with the device while we're using the handle.
 *          Call <f CEShep_UnlockEffect> when done.
 *
 *          If not, then set the effect handle to zero to indicate
 *          that it's bogus.  The
 *          <mf IDirectInputEffectShepherd::DownloadEffect>
 *          method relies on the zero-ness.
 *          It is also asserted in <i IDirectInputEffect> to make
 *          sure we don't accidentally leave effects on the device
 *          when we leave.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Handle to lock.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c DIERR_NOTDOWNLOADED> if the lock failed.
 *          Note that
 *          <mf IDirectInputEffectShepherd::DownloadEffect> and
 *          <mf IDirectInputEffectShepherd::DestroyEffect> assume
 *          that this is the only possible error code.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_LockEffect(PES this, PSHEPHANDLE psh)
{
    HRESULT hres;
    EnterProc(CEShep_LockEffect, (_ "pux", this, psh->dwTag, psh->dwEffect));

    WaitForSingleObject(g_hmtxJoy, INFINITE);

    if (g_psoh->rggjs[this->idJoy].dwTag == psh->dwTag && psh->dwEffect) {
        hres = S_OK;
    } else {
        psh->dwEffect = 0;
        ReleaseMutex(g_hmtxJoy);
        hres = DIERR_NOTDOWNLOADED;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | DeviceID |
 *
 *          Inform the driver of the identity of the device.
 *
 *          For example, if a device driver is passed
 *          <p dwExternalID> = 2 and <p dwInteralID> = 1,
 *          then this means that unit 1 on the device
 *          corresponds to joystick ID number 2.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The joystick ID number being used.
 *          The Windows joystick subsystem allocates external IDs.
 *
 *  @parm   DWORD | fBegin |
 *
 *          Nonzero if access to the device is begining.
 *          Zero if the access to the device is ending.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Reserved for future use (HID).
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_DeviceID(PDES pdes, DWORD dwExternalID, DWORD fBegin, LPVOID pvReserved)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::DeviceID,
               (_ "puu", pdes, dwExternalID, fBegin));

    this = _thisPvNm(pdes, des);

    AssertF(dwExternalID < cJoyMax);

    if (dwExternalID < cJoyMax) {
        VXDINITPARMS vip;

        /*
         *  If this device has never been used before,
         *  go grab its global gain.
         */
        WaitForSingleObject(g_hmtxJoy, INFINITE);

        if (g_psoh->rggjs[dwExternalID].dwTag == 0) {
            DIJOYCONFIG cfg;
            JOYCAPS caps;

            g_psoh->rggjs[dwExternalID].dwTag = 1;

            hres = JoyReg_GetConfig(dwExternalID, &caps, &cfg, DIJC_GAIN);
            if (SUCCEEDED(hres)) {
                SquirtSqflPtszV(sqfl,
                                TEXT("Joystick %d global gain = %d"),
                                     dwExternalID, cfg.dwGain);
                g_psoh->rggjs[dwExternalID].dwCplGain = cfg.dwGain;
            } else {
                g_psoh->rggjs[dwExternalID].dwCplGain = DI_FFNOMINALMAX;
            }

            /*
             *  Set to DI_FFNOMINALMAX until we learn better.
             */
            g_psoh->rggjs[dwExternalID].dwDevGain = DI_FFNOMINALMAX;

        }

        ReleaseMutex(g_hmtxJoy);

        /*
         *  Ask the HEL for the internal ID.
         */
        hres = Hel_Joy_GetInitParms(dwExternalID, &vip);

        if (SUCCEEDED(hres)) {
            this->idJoy = dwExternalID;
            hres = this->pdrv->lpVtbl->DeviceID(this->pdrv,
                                                DIRECTINPUT_VERSION,
                                                dwExternalID,
                                                fBegin, vip.dwId,
                                                pvReserved);
        }
    } else {
        hres = E_FAIL;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | Escape |
 *
 *          Escape to the driver.  This method is called
 *          in response to an application invoking the
 *          <mf IDirectInputEffect::Escape> method.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect at which the command is directed.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Command block.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c DIERR_NOTDOWNLOADED> if the effect is not downloaded.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_Escape(PDES pdes, PSHEPHANDLE psh, LPDIEFFESCAPE pesc)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::Escape,
               (_ "puxx", pdes, psh->dwTag, psh->dwEffect, pesc->dwCommand));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        if (psh->dwEffect) {
            hres = this->pdrv->lpVtbl->Escape(this->pdrv, this->idJoy,
                                              psh->dwEffect, pesc);
        } else {
            hres = DIERR_NOTDOWNLOADED;
        }
        CEShep_UnlockEffect();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | DeviceEscape |
 *
 *          Escape to the driver.  This method is called
 *          in response to an application invoking the
 *          <mf IDirectInputDevice2::Escape> method.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the ownership of the device.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Command block.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_DeviceEscape(PDES pdes, PSHEPHANDLE psh, LPDIEFFESCAPE pesc)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::DeviceEscape,
               (_ "pux", pdes, psh->dwTag, pesc->dwCommand));

    this = _thisPvNm(pdes, des);

    AssertF(psh->dwEffect == 0);

    WaitForSingleObject(g_hmtxJoy, INFINITE);

    if (g_psoh->rggjs[this->idJoy].dwTag == psh->dwTag) {
        hres = this->pdrv->lpVtbl->Escape(this->pdrv, this->idJoy,
                                          0, pesc);
    } else {
        hres = DIERR_NOTEXCLUSIVEACQUIRED;
    }

    ReleaseMutex(g_hmtxJoy);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEShep | SetPhysGain |
 *
 *          Set the physical gain based on the global gain
 *          and the local gain.
 *
 *          The caller must already have the global joystick lock.
 *
 *
 *  @cwrap  PES | this
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_SetPhysGain(PES this)
{
    HRESULT hres;

    hres = this->pdrv->lpVtbl->SetGain(
                 this->pdrv, this->idJoy,
                 MulDiv(g_psoh->rggjs[this->idJoy].dwDevGain,
                        g_psoh->rggjs[this->idJoy].dwCplGain,
                        DI_FFNOMINALMAX));
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | SetGlobalGain |
 *
 *          Set the global gain.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwCplGain |
 *
 *          The new global gain value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_SetGlobalGain(PDES pdes, DWORD dwCplGain)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::SetGlobalGain,
               (_ "pu", pdes, dwCplGain));

    this = _thisPvNm(pdes, des);

    WaitForSingleObject(g_hmtxJoy, INFINITE);

    g_psoh->rggjs[this->idJoy].dwCplGain = dwCplGain;

    hres = CEShep_SetPhysGain(this);

    ReleaseMutex(g_hmtxJoy);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | SetGain |
 *
 *          Set the overall device gain.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about device ownership.
 *
 *  @parm   DWORD | dwDevGain |
 *
 *          The new local gain value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_SetGain(PDES pdes, PSHEPHANDLE psh, DWORD dwDevGain)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::SetGain,
               (_ "puu", pdes, psh->dwTag, dwDevGain));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockDevice(this, psh, DISFFC_NULL))) {
        g_psoh->rggjs[this->idJoy].dwDevGain = dwDevGain;

        hres = CEShep_SetPhysGain(this);
        CEShep_UnlockDevice();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | SendForceFeedbackCommand |
 *
 *          Send a command to the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about device ownership.
 *
 *  @parm   DWORD | dwCmd |
 *
 *          Command, one of the <c DISFFC_*> values.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_SetForceFeedbackState(PDES pdes, PSHEPHANDLE psh, DWORD dwCmd)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::SetForceFeedbackState,
               (_ "pux", pdes, psh->dwTag, dwCmd));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockDevice(this, psh, dwCmd))) {

        if (dwCmd & DISFFC_FORCERESET) {
            dwCmd &= ~DISFFC_FORCERESET;
            dwCmd |= DISFFC_RESET;
        }

        hres = this->pdrv->lpVtbl->SendForceFeedbackCommand(
                        this->pdrv, this->idJoy, dwCmd);

        if (SUCCEEDED(hres) && (dwCmd & DISFFC_RESET)) {
            psh->dwTag = ++g_psoh->rggjs[this->idJoy].dwTag;
        }
        CEShep_UnlockDevice();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | GetForceFeedbackState |
 *
 *          Retrieve the force feedback state for the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about device ownership.
 *
 *  @parm   LPDIDEVICESTATE | pds |
 *
 *          Receives device state.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_GetForceFeedbackState(PDES pdes, PSHEPHANDLE psh, LPDIDEVICESTATE pds)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::GetForceFeedbackState,
               (_ "pup", pdes, psh->dwTag, pds));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockDevice(this, psh, DISFFC_NULL))) {
        hres = this->pdrv->lpVtbl->GetForceFeedbackState(
                            this->pdrv, this->idJoy, pds);
        CEShep_UnlockDevice();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | DownloadEffect |
 *
 *          Send an effect to the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwEffectId |
 *
 *          Magic cookie dword that identifies the effect.
 *
 *  @parm   IN OUT PSHEPHANDLE | psh |
 *
 *          On entry, contains the handle of the effect being
 *          downloaded.  If the value is zero, then a new effect
 *          is downloaded.  If the value is nonzero, then an
 *          existing effect is modified.
 *
 *          On exit, contains the new effect handle.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The new parameters for the effect.  The axis and button
 *          values have been converted to axis/button indexes.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *          <c S_FALSE> if no change was made.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_DownloadEffect(PDES pdes, DWORD dwEffectId,
                       PSHEPHANDLE psh, LPCDIEFFECT peff, DWORD fl)
{
    PES this;
    HRESULT hres = S_OK;
    EnterProcI(IDirectInputEffectShepherd::DownloadEffect,
               (_ "pxuppx", pdes, dwEffectId, psh->dwTag,
                            psh->dwEffect, peff, fl));

    this = _thisPvNm(pdes, des);

    /*
     *  Downloading an effect is sufficiently different from all
     *  other methods that we do the locking manually.
     */
    WaitForSingleObject(g_hmtxJoy, INFINITE);

    /*
     *  If not downloading, then it doesn't matter whether or not
     *  the tag matches.  However, if the tag doesn't match, then
     *  we must wipe out the download handle because it's dead.
     */
    if (g_psoh->rggjs[this->idJoy].dwTag == psh->dwTag) {
    } else {
        psh->dwEffect = 0;
        if (fl & DIEP_NODOWNLOAD) {     /* It's okay if not downloading */
        } else {
            hres = DIERR_NOTEXCLUSIVEACQUIRED;
            goto done;
        }
    }

    /*
     *  If downloading and creating a new effect,
     *  then all parameters need to be downloaded.
     */
    if (!(fl & DIEP_NODOWNLOAD) && psh->dwEffect == 0) {
        fl |= DIEP_ALLPARAMS;
    }
    if (fl) {
        hres = this->pdrv->lpVtbl->DownloadEffect(
                    this->pdrv, this->idJoy, dwEffectId,
                    &psh->dwEffect, peff, fl);
    } else {
        hres = S_FALSE;
    }

done:;
    ReleaseMutex(g_hmtxJoy);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | DestroyEffect |
 *
 *          Remove an effect from the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect to be destroyed.  On exit,
 *          the <e SHEPHANDLE.dwEffect> is zero'd so nobody will use
 *          it any more.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *          <c S_FALSE> if the effect was already destroyed.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_DestroyEffect(PDES pdes, PSHEPHANDLE psh)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::DestroyEffect,
               (_ "pux", pdes, psh->dwTag, psh->dwEffect));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        DWORD dwEffect = psh->dwEffect;
        psh->dwEffect = 0;
        hres = this->pdrv->lpVtbl->DestroyEffect(
                    this->pdrv, this->idJoy, dwEffect);
        CEShep_UnlockEffect();
    } else {
        hres = S_FALSE;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | StartEffect |
 *
 *          Begin playback of an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect to be played.
 *
 *  @parm   DWORD | dwMode |
 *
 *          How the effect is to affect other effects.
 *
 *  @parm   DWORD | dwCount |
 *
 *          Number of times the effect is to be played.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_StartEffect(PDES pdes, PSHEPHANDLE psh, DWORD dwMode, DWORD dwCount)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::StartEffect,
               (_ "puxxu", pdes, psh->dwTag, psh->dwEffect, dwMode, dwCount));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        hres = this->pdrv->lpVtbl->StartEffect(this->pdrv, this->idJoy,
                                               psh->dwEffect, dwMode, dwCount);
        CEShep_UnlockEffect();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | StopEffect |
 *
 *          Halt playback of an effect.
 *
 *          ISSUE-2001/03/29-timgill There is no way to pause an effect
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect to be stopped.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_StopEffect(PDES pdes, PSHEPHANDLE psh)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::StopEffect,
               (_ "pux", pdes, psh->dwTag, psh->dwEffect));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        hres = this->pdrv->lpVtbl->StopEffect(this->pdrv, this->idJoy,
                                              psh->dwEffect);
        CEShep_UnlockEffect();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | GetEffectStatus |
 *
 *          Obtain information about an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect to be queried.
 *
 *  @parm   LPDWORD | pdwStatus |
 *
 *          Receives the effect status.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_GetEffectStatus(PDES pdes, PSHEPHANDLE psh, LPDWORD pdwStatus)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::GetEffectStatus,
               (_ "pux", pdes, psh->dwTag, psh->dwEffect));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        hres = this->pdrv->lpVtbl->GetEffectStatus(this->pdrv, this->idJoy,
                                                   psh->dwEffect, pdwStatus);
        CEShep_UnlockEffect();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | GetVersions |
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   LPDIDRIVERVERSIONS | pvers |
 *
 *          A structure which will be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_GetVersions(PDES pdes, LPDIDRIVERVERSIONS pvers)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::GetVersions, (_ "p", pdes));

    this = _thisPvNm(pdes, des);

    AssertF(pvers->dwSize == cbX(*pvers));

    hres = this->pdrv->lpVtbl->GetVersions(this->pdrv, pvers);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEShep | InitInstance |
 *
 *          Initialize a new instance of
 *          an IDirectInputEffectShepherd object.
 *
 *          If an in-proc OLE server is needed, then load it.
 *
 *          Otherwise, use our private interface that goes down
 *          to our helper driver.
 *
 *  @parm   IN HKEY | hkFF |
 *
 *          Force feedback registry key.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_InitInstance(PES this, HKEY hkFF)
{
    LONG lRc;
    HRESULT hres;
    TCHAR tszClsid[ctchGuid];

    EnterProcI(IDirectInputEffectShepherd::InitInstance, (_ "x", hkFF));

    if( hkFF == 0x0 )
    {
        TCHAR tszName[ctchNameGuid];
        NameFromGUID(tszName, &IID_IDirectInputPIDDriver );
        memcpy(tszClsid, &tszName[ctchNamePrefix], cbX(tszClsid) );
        lRc = ERROR_SUCCESS;
    }else
    {
        lRc = RegQueryString(hkFF, TEXT("CLSID"), tszClsid, cA(tszClsid));
    }

    if (lRc == ERROR_SUCCESS) {
        hres = DICoCreateInstance(tszClsid, 0,
                                  &IID_IDirectInputEffectDriver,
                                  &this->pdrv,
                                  &this->hinst);

        /*
         *  If anything went wrong, change the error to
         *  E_NOTIMPL so the app won't see a wacky CoCreateInstance
         *  error code.
         */
        if (FAILED(hres)) {
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("Substituting E_NOTIMPL for FF driver CoCreateInstance error 0x%08x"),
                hres );
            hres = E_NOTIMPL;
        }

    } else {
#ifdef WINNT
        hres = E_NOTIMPL;
#else
        DWORD cb = 0;
        lRc = RegQueryValueEx(hkFF, TEXT("VJoyD"), 0, 0, 0, &cb);
        if (lRc == ERROR_SUCCESS || lRc == ERROR_MORE_DATA) {
            hres = CEffVxd_New(0, &IID_IDirectInputEffectDriver, &this->pdrv);
        } else {
            hres = E_NOTIMPL;
        }
#endif
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | New |
 *
 *          Create a new instance of an IDirectInputEffectShepherd object.
 *
 *  @parm   IN HKEY | hkFF |
 *
 *          Force feedback registry key.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_New(HKEY hkFF, PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffectShepherd::<constructor>, (_ "G", riid));

    AssertF(g_hmtxJoy);

    hres = Common_NewRiid(CEShep, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv in case of aggregation */
        PES this = _thisPv(*ppvObj);
        if (SUCCEEDED(hres = CEShep_InitInstance(this, hkFF))) {
        } else {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CEShep_Signature        0x50454853      /* "SHEP" */

Interface_Template_Begin(CEShep)
    Primary_Interface_Template(CEShep, IDirectInputEffectShepherd)
Interface_Template_End(CEShep)

Primary_Interface_Begin(CEShep, IDirectInputEffectShepherd)
    CEShep_DeviceID,
    CEShep_GetVersions,
    CEShep_Escape,
    CEShep_DeviceEscape,
    CEShep_SetGain,
    CEShep_SetForceFeedbackState,
    CEShep_GetForceFeedbackState,
    CEShep_DownloadEffect,
    CEShep_DestroyEffect,
    CEShep_StartEffect,
    CEShep_StopEffect,
    CEShep_GetEffectStatus,
    CEShep_SetGlobalGain,
Primary_Interface_End(CEShep, IDirectInputEffectShepherd)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\diemm.c ===
/*****************************************************************************
 *
 *  DIEmM.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Emulation module for mouse.
 *
 *  Contents:
 *
 *      CEm_Mouse_CreateInstance
 *      CEm_Mouse_InitButtons
 *      CEm_LL_MseHook
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEm

/*****************************************************************************
 *
 *          Mouse globals
 *
 *****************************************************************************/

STDMETHODIMP CEm_Mouse_Acquire(PEM this, BOOL fAcquire);

DIMOUSESTATE_INT s_msEd;

ED s_edMouse = {
    &s_msEd,
    0,
    CEm_Mouse_Acquire,
    -1,
    cbX(DIMOUSESTATE_INT),
    0x0,
};

/*****************************************************************************
 *
 *      The algorithm for applying acceleration is:
 *
 *      dxC = dxR
 *      if A >= 1 and abs(dxR) > T1 then
 *          dxC = dxR * 2
 *          if A >= 2 and abs(dxR) > Thres2 then
 *              dxC = dxR * 4
 *          end if
 *      end if
 *
 *      where
 *          dxR is the raw mouse motion
 *          dxC is the cooked mouse motion
 *          A   is the acceleration
 *          T1  is the first threshold
 *          T2  is the second threshold
 *
 *      Repeat for dy instead of dx.
 *
 *      We can optimize this by simply setting the thresholds to MAXLONG
 *      if they are disabled; that way, abs(dx) will never exceed it.
 *
 *      The result is the following piecewise linear function:
 *
 *      if  0 < abs(dxR) <= T1:         dxC = dxR
 *      if T1 < abs(dxR) <= T2:         dxC = dxR * 2
 *      if T2 < abs(dxR):               dxC = dxR * 4
 *
 *      If you graph this function, you'll see that it's discontinuous!
 *
 *      The inverse mapping of this function is what concerns us.
 *      It looks like this:
 *
 *      if      0 < abs(dxC) <= T1:         dxR = dxC
 *      if T1 * 2 < abs(dxC) <= T2 * 2:     dxR = dxC / 2
 *      if T2 * 4 < abs(dxC):               dxR = dxC / 4
 *
 *      Notice that there are gaps in the graph, so we can fill them in
 *      any way we want, as long as it isn't blatantly unintelegent.  (In the
 *      case where we are using emulation, it is possible to get relative
 *      mouse motions that live in the "impossible" limbo zone due to
 *      clipping.)
 *
 *      if      0 < abs(dxC) <= T1:         dxR = dxC
 *      if T1     < abs(dxC) <= T2 * 2:     dxR = dxC / 2
 *      if T2 * 2 < abs(dxC):               dxR = dxC / 4
 *
 *      Therefore:          (you knew the punch line was coming)
 *
 *      s_rgiMouseThresh[0] = T1 (or MAXLONG)
 *      s_rgiMouseThresh[1] = T2 * 2 (or MAXLONG)
 *
 *
 *****************************************************************************/

static int s_rgiMouseThresh[2];

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_Mouse_OnMouseChange |
 *
 *          The mouse acceleration changed.  Go recompute the
 *          unacceleration variables.
 *
 *****************************************************************************/

void EXTERNAL
CEm_Mouse_OnMouseChange(void)
{
    int rgi[3];             /* Mouse acceleration information */

    /*
     *  See the huge comment block at the definition of
     *  s_rgiMouseThresh for an explanation of the math
     *  that is happening here.
     *
     *  If acceleration is enabled at all...
     */

    if (SystemParametersInfo(SPI_GETMOUSE, 0, &rgi, 0) && rgi[2]) {
        s_rgiMouseThresh[0] = rgi[0];

        if (rgi[2] >= 2) {
            s_rgiMouseThresh[1] = rgi[1] * 2;

        } else {        /* Disable level 2 acceleration */
            s_rgiMouseThresh[1] = MAXLONG;
        }

    } else {            /* Disable all acceleration */
        s_rgiMouseThresh[0] = MAXLONG;
    }

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_OnMouseChange: ")
                          TEXT("New accelerations %d / %d"),
                          s_rgiMouseThresh[0], s_rgiMouseThresh[1]);

}

/*****************************************************************************
 *
 *          Mouse emulation
 *
 *          Mouse emulation is done by subclassing the window that
 *          captured the mouse.  We then do the following things:
 *
 *          (1) Hide the cursor for the entire vwi.
 *
 *          (2) Capture the mouse.
 *
 *          (3) Clip the cursor to the window.  (If we let the cursor
 *              leave our window, then it screws up capture.)
 *
 *          (4) Keep re-centering the mouse whenever it moves.
 *
 *          (5) Release the capture on WM_SYSCOMMAND so we don't
 *              mess up menus, Alt+F4, etc.
 *
 *          If we are using NT low-level hooks then mouse emulation
 *          is done by spinning a thread to service ll hook
 *          notifications. The victim window is not subclassed.
 *
 *****************************************************************************/

#define dxMinMouse  10
#define dyMinMouse  10

typedef struct MOUSEEMULATIONINFO {
    POINT   ptCenter;               /* Center of client rectangle (screen coords) */
    POINT   ptCenterCli;            /* Center of client rectangle (client coords) */
    LPARAM  lpCenter;               /* ptCenter in the form of an LPARAM */

    BOOL    fInitialized:1;         /* Have we gotten started? */
    BOOL    fNeedExit:1;            /* Should we leave now? */
    BOOL    fExiting:1;             /* Are we trying to leave already? */
    BOOL    fCaptured:1;            /* Have we captured the mouse? */
    BOOL    fHidden:1;              /* Have we hidden the mouse? */
    BOOL    fClipped:1;             /* Have we clipped the mouse? */

    RECT    rcClip;                 /* ClipCursor rectangle */

} MOUSEEMULATIONINFO, *PMOUSEEMULATIONINFO;

LRESULT CALLBACK
CEm_Mouse_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                       UINT_PTR uid, ULONG_PTR dwRef);

/*****************************************************************************
 *
 *          CEm_Mouse_InitCoords
 *
 *
 *****************************************************************************/

BOOL INTERNAL
CEm_Mouse_InitCoords(HWND hwnd, PMOUSEEMULATIONINFO this)
{
    RECT rcClient;
    RECT rcDesk;

    GetClientRect(hwnd, &rcClient);
    MapWindowPoints(hwnd, 0, (LPPOINT)&rcClient, 2);

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_InitCoords: Client (%d,%d)-(%d,%d)"),
                    rcClient.left,
                    rcClient.top,
                    rcClient.right,
                    rcClient.bottom);

    /*
     *  Clip this with the screen, in case the window extends
     *  off-screen.
     *
     *  Someday: This will need to change when we get multiple monitors.
     */
    GetWindowRect(GetDesktopWindow(), &rcDesk);

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_InitCoords: Desk (%d,%d)-(%d,%d)"),
                    rcDesk.left,
                    rcDesk.top,
                    rcDesk.right,
                    rcDesk.bottom);

    IntersectRect(&this->rcClip, &rcDesk, &rcClient);

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_InitCoords: Clip (%d,%d)-(%d,%d)"),
                    this->rcClip.left,
                    this->rcClip.top,
                    this->rcClip.right,
                    this->rcClip.bottom);

    this->ptCenter.x = (this->rcClip.left + this->rcClip.right) >> 1;
    this->ptCenter.y = (this->rcClip.top + this->rcClip.bottom) >> 1;

    this->ptCenterCli.x = this->ptCenter.x - rcClient.left;
    this->ptCenterCli.y = this->ptCenter.y - rcClient.top;

    this->lpCenter = MAKELPARAM(this->ptCenterCli.x, this->ptCenterCli.y);

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_InitCoords: lpCenter (%d, %d)"),
                    MAKEPOINTS(this->lpCenter).x,
                    MAKEPOINTS(this->lpCenter).y);

    return this->rcClip.bottom - this->rcClip.top > dyMinMouse &&
           this->rcClip.right - this->rcClip.left > dxMinMouse;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_Mouse_OnSettingChange |
 *
 *          If the mouse acceleration changed, then update our globals
 *          so we can unaccelerate the mouse properly.
 *
 *  @parm   WPARAM | wp |
 *
 *          SystemParametersInfo value.
 *
 *  @parm   LPARAM | lp |
 *
 *          Name of section that changed.
 *
 *****************************************************************************/

void INTERNAL
CEm_Mouse_OnSettingChange(WPARAM wp, LPARAM lp)
{
    /*
     *  If wp is nonzero, then it is an SPI value.
     *
     *  If wp is zero, then be paranoid if lp == 0 or lp = "windows".
     */
    switch (wp) {

    case 0:                 /* wp == 0; must test lp */
        if (lp == 0) {
            CEm_Mouse_OnMouseChange();
        } else if (lstrcmpi((LPTSTR)lp, TEXT("windows")) == 0) {
            CEm_Mouse_OnMouseChange();
        }
        break;

    case SPI_SETMOUSE:
        CEm_Mouse_OnMouseChange();
        break;

    default:
        /* Some other SPI */
        break;
    }

}

/*****************************************************************************
 *
 *          CEm_Mouse_Subclass_OnNull
 *
 *          WM_NULL is a nudge message that makes us reconsider our
 *          place in the world.
 *
 *          We need this special signal because you cannot call
 *          SetCapture() or ReleaseCapture() from the wrong thread.
 *
 *****************************************************************************/

void INTERNAL
CEm_Mouse_Subclass_OnNull(HWND hwnd, PMOUSEEMULATIONINFO this)
{
    /*
     *  Initialize me if I haven't been already.
     */
    if (!this->fInitialized) {

        this->fInitialized = 1;

        if (!this->fCaptured) {
            this->fCaptured = 1;
            SetCapture(hwnd);
        }

        if (!this->fHidden) {
            this->fHidden = 1;
            SquirtSqflPtszV(sqflCursor,
                            TEXT("CEm_Mouse_Subclass: Hiding mouse"));
            ShowCursor(0);
        }

        /*
         *  Remove any clipping we performed so our math
         *  comes out right again.
         */
        if (this->fClipped) {
            this->fClipped = 0;
            ClipCursor(0);
        }

        /*
         *  (Re)compute mouse acceleration information.
         */
        CEm_Mouse_OnMouseChange();

        if (CEm_Mouse_InitCoords(hwnd, this)) {

            /*
             *  Force the LBUTTON up during the recentering move.
             *
             *  Otherwise, if the user activates the app by clicking
             *  the title bar, USER sees the cursor move while the
             *  left button is down on the title bar and moves the
             *  window.  Oops.
             *
             *  We don't bother forcing the mouse back down after we
             *  have recentered.  I can't figure out how, and it's
             *  not worth it.
             *
             */
            if (GetAsyncKeyState(VK_LBUTTON) < 0) {
                mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
            }

            SetCursorPos(this->ptCenter.x, this->ptCenter.y);

            this->fClipped = 1;
            ClipCursor(&this->rcClip);

        } else {                    /* Can't emulate; window too small */
            this->fNeedExit = 1;
        }

    }

    if (this->fNeedExit && !this->fExiting) {

        /*
         *  Must do this first!  ReleaseCapture() will re-enter us,
         *  and if we continued onward, we'd end up partying on freed
         *  memory.
         */
        this->fExiting = 1;

        if (this->fCaptured) {
            ReleaseCapture();
        }
        if (this->fHidden) {
            SquirtSqflPtszV(sqflCursor,
                            TEXT("CEm_Mouse_Subclass: Showing mouse"));
            ShowCursor(1);
        }

        if (this->fClipped) {
            ClipCursor(0);
        }

        CEm_ForceDeviceUnacquire(&s_edMouse, FDUFL_NORMAL);

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_Subclass %p unhook"), hwnd);
        ConfirmF(RemoveWindowSubclass(hwnd, CEm_Mouse_SubclassProc, 0));
        FreePv(this);

    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_Mouse_RemoveAccel |
 *
 *          Remove any acceleration from the mouse motion.
 *
 *          See the huge comment block at s_rgiMouseThresh
 *          for an explanation of what we are doing.
 *
 *  @parm   int | dx |
 *
 *          Change in coordinate, either dx or dy.
 *
 *****************************************************************************/

int INTERNAL
CEm_Mouse_RemoveAccel(int dx)
{
    int x = abs(dx);
    if (x > s_rgiMouseThresh[0]) {
        dx /= 2;
        if (x > s_rgiMouseThresh[1]) {
            dx /= 2;
        }
    }
    return dx;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | CEm_Mouse_AddState |
 *
 *          Add a mouse state change.
 *
 *          The mouse coordinates are relative, not absolute.
 *
 *  @parm   LPDIMOUSESTATE_INT | pms |
 *
 *          New mouse state, except that coordinates are relative.
 *
 *  @parm   DWORD | tm |
 *
 *          Time the state change was generated.
 *
 *****************************************************************************/

void EXTERNAL
CEm_Mouse_AddState(LPDIMOUSESTATE_INT pms, DWORD tm)
{

    /* Sanity check: Make sure the device has been initialized */
    if( s_edMouse.pDevType ) 
    {
        pms->lX = s_msEd.lX + pms->lX;
        pms->lY = s_msEd.lY + pms->lY;

        /*
         *  HACK!
         *
         *  Memphis and NT5 USER both mess up the case where the presence
         *  of a wheel mouse changes dynamically.  So if we do not have
         *  a wheel in our data format, then don't record it.
         *
         *  The consequence of this is that we will not see any more
         *  buttons or wheels than were present when we queried the number
         *  of buttons in the first place.
         */

         /* If we use Subclassing, the movement of wheel can't be accumulated. 
          * Otherwise, you will see the number keep increasing. Fix bug: 182774.
          * However, if we use low level hook, we need the code. Fix bug: 238987
          */

#ifdef USE_SLOW_LL_HOOKS
       if (s_edMouse.pDevType[DIMOFS_Z]) {
           pms->lZ = s_msEd.lZ + pms->lZ;
       }
#endif

        CEm_AddState(&s_edMouse, pms, tm);
    }
}

/*****************************************************************************
 *
 *          Mouse window subclass procedure
 *
 *****************************************************************************/

#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL   (WM_MOUSELAST + 1)
#endif

#define WM_SETACQUIRE   WM_USER
#define WM_QUITSELF     (WM_USER+1)

LRESULT CALLBACK
CEm_Mouse_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                       UINT_PTR uid, ULONG_PTR dwRef)
{
    PMOUSEEMULATIONINFO this = (PMOUSEEMULATIONINFO)dwRef;
    DIMOUSESTATE_INT ms;
	static BOOL  fWheelScrolling = FALSE;

    switch (wm) {

    case WM_NCDESTROY:
        SquirtSqflPtszV(sqfl, TEXT("CEm_Subclass: window destroyed while acquired"));
        goto unhook;

    case WM_CAPTURECHANGED:
        /*
         *  "An application should not attempt to set the mouse capture
         *   in response to [WM_CAPTURECHANGED]."
         *
         *  So we just unhook.
         */
        SquirtSqflPtszV(sqfl, TEXT("CEm_Subclass: %04x lost to %04x"),
                        hwnd, lp);
        goto unhook;

    case WM_SYSCOMMAND:
        /*
         *  We've got to unhook because WM_SYSCOMMAND will punt if
         *  the mouse is captured.  Otherwise, you couldn't type Alt+F4
         *  to exit the app, which is kind of a bummer.
         */

    unhook:;
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_Acquire: %p ")
                              TEXT("exiting because of %04x"), hwnd, wm);
        this->fNeedExit = 1;
        CEm_Mouse_Subclass_OnNull(hwnd, this);
        break;

    case WM_NULL:
        CEm_Mouse_Subclass_OnNull(hwnd, this);
        break;

    /*
     *  Note that we use WM_WINDOWPOSCHANGED and not WM_SIZE, because
     *  an application which doesn't send WM_WINDOWPOSCHANGED to
     *  DefWindowProc will will never receive a WM_SIZE message.
     *
     *  We need to start over to handle the new screen dimensions,
     *  recenter the mouse, and possibly abandon the operation if
     *  things don't look right.
     */
    case WM_WINDOWPOSCHANGED:
    case WM_DISPLAYCHANGE:
        this->fInitialized = 0;
        CEm_Mouse_Subclass_OnNull(hwnd, this);
        break;

    /*
     *  The mouse acceleration may have changed.
     */
    case WM_SETTINGCHANGE:
        CEm_Mouse_OnSettingChange(wp, lp);
        break;

    case WM_MOUSEWHEEL:
        SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_SubclassProc: (%d,%d,%d)"),
                        MAKEPOINTS(lp).x, MAKEPOINTS(lp).y, (short)HIWORD(wp));

        ms.lZ = (short)HIWORD(wp);
        fWheelScrolling = TRUE;

        goto lparam;

    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MBUTTONDBLCLK:
#if DIRECTINPUT_VERSION >= 0x0700
  #if defined(WINNT) && (_WIN32_WINNT >= 0x0500)
    case WM_XBUTTONDOWN:
    case WM_XBUTTONUP:
    case WM_XBUTTONDBLCLK:
  #endif
#endif

        SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_SubclassProc: (%d,%d)"),
                        MAKEPOINTS(lp).x, MAKEPOINTS(lp).y);

        ms.lZ = 0;
    lparam:;

        /*
         *  Don't move the cursor if it hasn't moved.
         *  Otherwise, we recurse ourselves to death.
         *
         *  In fact, if the cursor hasn't moved, ignore this
         *  motion and do only buttons.  Otherwise, you get
         *  into the situation where we end up reacting to
         *  our own recentering.  (D'oh!)
         */
        ms.lX = 0;
        ms.lY = 0;

        if (lp != this->lpCenter && !fWheelScrolling ) {
            SetCursorPos(this->ptCenter.x, this->ptCenter.y);
            ms.lX = MAKEPOINTS(lp).x - this->ptCenterCli.x;
            ms.lY = MAKEPOINTS(lp).y - this->ptCenterCli.y;
        }

        fWheelScrolling = FALSE;

        /*
         *  Note that these return unswapped mouse button data.
         *  Arguably a bug, but it's documented, so it's now a
         *  feature.
         */
        #define GetButton(n) ((GetAsyncKeyState(n) & 0x8000) >> 8)
        ms.rgbButtons[0] = GetButton(VK_LBUTTON);
        ms.rgbButtons[1] = GetButton(VK_RBUTTON);
        ms.rgbButtons[2] = GetButton(VK_MBUTTON);
#if DIRECTINPUT_VERSION >= 0x0700
    #if defined(WINNT) && (_WIN32_WINNT >= 0x0500)
        ms.rgbButtons[3] = GetButton(VK_XBUTTON1);
        ms.rgbButtons[4] = GetButton(VK_XBUTTON2);
    #else
        ms.rgbButtons[3] = 0;
        ms.rgbButtons[4] = 0;
    #endif        
        ms.rgbButtons[5] = 0;
        ms.rgbButtons[6] = 0;
        ms.rgbButtons[7] = 0;
#else
        ms.rgbButtons[3] = 0;
#endif

        #undef GetButton

        /*
         *  Note that we cannot unaccelerate the mouse when using
         *  mouse capture, because we don't know what sort of
         *  coalescing USER has done for us.
         */

        CEm_Mouse_AddState(&ms, GetMessageTime());

        return 0;

    }

    return DefSubclassProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Mouse_Subclass_Acquire |
 *
 *          Acquire/unacquire a mouse via subclassing.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *  @parm   BOOL | fAcquire |
 *
 *          Whether the device is being acquired or unacquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Mouse_Subclass_Acquire(PEM this, BOOL fAcquire)
{
    HRESULT hres;
    EnterProc(CEm_Mouse_Subclass_Acquire, (_ "pu", this, fAcquire));

    AssertF(this->dwSignature == CEM_SIGNATURE);

    if (fAcquire) {                 /* Install the hook */
        if (this->vi.hwnd && (this->vi.fl & VIFL_CAPTURED)) {
            PMOUSEEMULATIONINFO pmei;
            hres = AllocCbPpv(cbX(MOUSEEMULATIONINFO), &pmei);
            if (SUCCEEDED(hres)) {
                if (SetWindowSubclass(this->vi.hwnd,
                                      CEm_Mouse_SubclassProc, 0,
                                      (ULONG_PTR)pmei)) {
                    /* Nudge it */
                    SendNotifyMessage(this->vi.hwnd, WM_NULL, 0, 0L);
                    hres = S_OK;
                } else {
                    // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
					SquirtSqflPtszV(sqfl,
                                    TEXT("Mouse::Acquire: ")
                                    TEXT("Window %p is not valid"),
                                    this->vi.hwnd);
                    FreePv(pmei);
                    hres = E_INVALIDARG;
                }
            }

        } else {
            RPF("Mouse::Acquire: Non-exclusive mode not supported");
            hres = E_FAIL;
        }
    } else {                        /* Remove the hook */
        PMOUSEEMULATIONINFO pmei;
        if (GetWindowSubclass(this->vi.hwnd, CEm_Mouse_SubclassProc,
                              0, (PULONG_PTR)&pmei)) {
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_Acquire: ")
                                  TEXT("Telling %p to exit"), this->vi.hwnd);
            pmei->fNeedExit = 1;
            SendNotifyMessage(this->vi.hwnd, WM_NULL, 0, 0L);
        } else {                    /* Window was already unhooked */
        }
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Mouse_Acquire |
 *
 *          Acquire/unacquire a mouse.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *          Whether the device is being acquired or unacquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Mouse_Acquire(PEM this, BOOL fAcquire)
{
    HRESULT hres;
    EnterProc(CEm_Mouse_Acquire, (_ "pu", this, fAcquire));

    AssertF(this->dwSignature == CEM_SIGNATURE);

#ifdef USE_SLOW_LL_HOOKS
    AssertF(DIGETEMFL(this->vi.fl) == DIEMFL_MOUSE ||
            DIGETEMFL(this->vi.fl) == DIEMFL_MOUSE2);

    if (this->vi.fl & DIMAKEEMFL(DIEMFL_MOUSE)) {
        /* 
         *  This used to use the subclass technique for exclusive mode 
         *  even if low-level hooks were available because low-level 
         *  hooks turn out to be even slower that subclassing.  However, 
         *  subclassing is not transparent as it uses SetCapture which 
         *  causes Accellerator translation to be disabled for the app
         *  which would be a more serious regression from Win9x than 
         *  performance being even worse than we thought.
         */
        AssertF(g_fUseLLHooks);
        hres = CEm_LL_Acquire(this, fAcquire, this->vi.fl, LLTS_MSE);
        if( SUCCEEDED(hres) ) {
            if( fAcquire && this->vi.fl & VIFL_CAPTURED ) {
                if( !this->fHidden ) {
                    ShowCursor(0);
                    this->fHidden = TRUE;
                }
            } else {
                if( this->fHidden ) {
                    ShowCursor(1);
                    this->fHidden = FALSE;
                }
            }
        }
    } else {
        hres = CEm_Mouse_Subclass_Acquire(this, fAcquire);
    }
#else
    AssertF(DIGETEMFL(this->vi.fl) == DIEMFL_MOUSE2);
    hres = CEm_Mouse_Subclass_Acquire(this, fAcquire);
#endif

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Mouse_CreateInstance |
 *
 *          Create a mouse thing.  Also record what emulation
 *          level we ended up with so the caller knows.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_Mouse_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    HRESULT hres;

#ifdef USE_SLOW_LL_HOOKS
    /*
     *  Note carefully the test.  It handles the cases where
     *
     *  0.  The app did not ask for emulation, so we give it the
     *      best we can.  (dwEmulation == 0)
     *  1.  The app explicitly asked for emulation 1.
     *      (dwEmulation == DIEMFL_MOUSE)
     *  2.  The app explicitly asked for emulation 2.
     *      (dwEmulation == DIEMFL_MOUSE2)
     *  3.  The registry explicitly asked for both emulation modes.
     *      (dwEmulation == DIEMFL_MOUSE | DIEMFL_MOUSE2)
     *      Give it the best we can.  (I.e., same as case 0.)
     *
     *  All platforms support emulation 2.  Not all platforms support
     *  emulation 1.  If we want emulation 1 but can't get it, then
     *  we fall back on emulation 2.
     */

    /*
     *  First, if we don't have support for emulation 1, then clearly
     *  we have to use emulation 2.
     */
     
    if (!g_fUseLLHooks 
#ifdef DEBUG
        || (g_flEmulation & DIEMFL_MOUSE2)
#endif        
    ) {
        pdevf->dwEmulation = DIEMFL_MOUSE2;
    } else

    /*
     *  Otherwise, we have to choose between 1 and 2.  The only case
     *  where we choose 2 is if 2 is explicitly requested.
     */
    if (pdevf->dwEmulation == DIEMFL_MOUSE2) {
        /* Do nothing */
    } else

    /*
     *  All other cases get 1.
     */
    {
        pdevf->dwEmulation = DIEMFL_MOUSE;
    }

    /*
     *  Assert that we never give emulation 1 when it doesn't exist.
     */
    AssertF(fLimpFF(pdevf->dwEmulation & DIEMFL_MOUSE, g_fUseLLHooks));
#else
    /*
     *  We are being compiled for "emulation 2 only", so that simplifies
     *  matters immensely.
     */
    pdevf->dwEmulation = DIEMFL_MOUSE2;
#endif

    hres = CEm_CreateInstance(pdevf, ppviOut, &s_edMouse);

    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Mouse_InitButtons |
 *
 *          Initialize the mouse button state in preparation for
 *          acquisition.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The button states.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_Mouse_InitButtons(PVXDDWORDDATA pvdd)
{
    /* Do this only when nothing is yet acquired */
    if (s_edMouse.cAcquire < 0) {
       *(LPDWORD)&s_msEd.rgbButtons = pvdd->dw;

        /* randomly initializing axes as well as mouse buttons
           X and Y are not buttons 
           Randomize initial values of X and Y */
        while( !s_msEd.lX )
        {
            s_msEd.lX = GetTickCount();
            s_msEd.lY = (s_msEd.lX << 16) | (s_msEd.lX >> 16);
            s_msEd.lX = s_msEd.lY * (DWORD)((UINT_PTR)&pvdd);
        }
    }
    return S_OK;
}

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CEm_LL_MseHook |
 *
 *          Low-level mouse hook filter.
 *
 *  @parm   int | nCode |
 *
 *          Notification code.
 *
 *  @parm   WPARAM | wp |
 *
 *          WM_* mouse message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Mouse message information.
 *
 *  @returns
 *
 *          Always chains to the next hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
CEm_LL_MseHook(int nCode, WPARAM wp, LPARAM lp)
{
    PLLTHREADSTATE plts;
    
    if (nCode == HC_ACTION) {
        DIMOUSESTATE_INT ms;
        POINT pt;
        PMSLLHOOKSTRUCT pllhs = (PV)lp;

        /*
         *  We are called only on mouse messages, so we may as
         *  well prepare ourselves up front.
         *
         *  Note! that we *cannot* use GetAsyncKeyState on the
         *  buttons, because the buttons haven't been pressed yet!
         *  Instead, we must update the button state based on the
         *  received message.
         */

        ms.lX = 0;
        ms.lY = 0;
        ms.lZ = 0;

        memcpy(ms.rgbButtons, s_msEd.rgbButtons, cbX(ms.rgbButtons));

        /*
         *
         *  Annoying!  We receive swapped buttons, so we need to
         *  unswap them.  I mark this as `annoying' because
         *  GetAsyncKeyState returns unswapped buttons, so sometimes
         *  I do and sometimes I don't.  But it isn't unintelegent
         *  because it is the right thing.  Arguably, GetAsyncKeyState
         *  is the one that is broken.
         */

        if (GetSystemMetrics(SM_SWAPBUTTON)) {

            /*
             *  Assert that the left and right button messages
             *  run in parallel.
             */

            CAssertF(WM_RBUTTONDOWN - WM_LBUTTONDOWN     ==
                     WM_RBUTTONDBLCLK - WM_LBUTTONDBLCLK &&
                     WM_RBUTTONDBLCLK - WM_LBUTTONDBLCLK ==
                     WM_RBUTTONUP     - WM_LBUTTONUP);

            switch (wp) {

            case WM_LBUTTONDOWN:
            case WM_LBUTTONDBLCLK:
            case WM_LBUTTONUP:
                wp = (wp - WM_LBUTTONUP) + WM_RBUTTONUP;
                break;

            case WM_RBUTTONDOWN:
            case WM_RBUTTONDBLCLK:
            case WM_RBUTTONUP:
                wp = (wp - WM_RBUTTONUP) + WM_LBUTTONUP;
                break;

            }
        }

        switch (wp) {           /* wp = message number */

        case WM_MOUSEWHEEL:
            SquirtSqflPtszV(sqfl, TEXT("CEm_LL_MseHook: (%d,%d,%d)"),
                            pllhs->pt.x,
                            pllhs->pt.y,
                            pllhs->mouseData);

            ms.lZ = (short int)HIWORD(pllhs->mouseData);
            goto lparam;

        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
            ms.rgbButtons[0] = 0x80;
            goto move;

        case WM_LBUTTONUP:
            ms.rgbButtons[0] = 0x00;
            goto move;

        case WM_RBUTTONDOWN:
        case WM_RBUTTONDBLCLK:
            ms.rgbButtons[1] = 0x80;
            goto move;

        case WM_RBUTTONUP:
            ms.rgbButtons[1] = 0x00;
            goto move;

        case WM_MBUTTONDOWN:
        case WM_MBUTTONDBLCLK:
            ms.rgbButtons[2] = 0x80;
            goto move;

        case WM_MBUTTONUP:
            ms.rgbButtons[2] = 0x00;
            goto move;

#if DIRECTINPUT_VERSION >= 0x0700
    #if defined(WINNT) && (_WIN32_WINNT >= 0x0500)
        case WM_XBUTTONDOWN:
        case WM_XBUTTONDBLCLK:
            /*
             * Using switch can be easily extended to support more buttons.
             */
            switch ( HIWORD(pllhs->mouseData) ) {
            	case XBUTTON1:
            	    ms.rgbButtons[3] = 0x80;
            	    break;

            	case XBUTTON2:
            	    ms.rgbButtons[4] = 0x80;
            	    break;

                /*
                 * When we support more than 5 buttons, take care of them.
            	case XBUTTON3:
            	    ms.rgbButtons[5] = 0x80;
            	    break;

            	case XBUTTON4:
            	    ms.rgbButtons[6] = 0x80;
            	    break;

            	case XBUTTON5:
            	    ms.rgbButtons[7] = 0x80;
            	    break;
                 */
            }
            
            goto move;

        case WM_XBUTTONUP:
            /*
             * Using switch can be easily extended to support more buttons.
             */
            switch ( HIWORD(pllhs->mouseData) ) {
            	case XBUTTON1:
            	    ms.rgbButtons[3] = 0x00;
            	    break;

            	case XBUTTON2:
            	    ms.rgbButtons[4] = 0x00;
            	    break;
                /*
                 * When we support more than 5 buttons, take care of them.
            	case XBUTTON3:
            	    ms.rgbButtons[5] = 0x00;
            	    break;

            	case XBUTTON4:
            	    ms.rgbButtons[6] = 0x00;
            	    break;

            	case XBUTTON5:
            	    ms.rgbButtons[7] = 0x00;
            	    break;
                 */
            }
            goto move;
    #endif
#endif

        case WM_MOUSEMOVE:
            SquirtSqflPtszV(sqfl, TEXT("CEm_LL_MseHook: (%d,%d)"),
                            pllhs->pt.x, pllhs->pt.y);

        move:;

        lparam:;

            GetCursorPos(&pt);

            ms.lX = CEm_Mouse_RemoveAccel(pllhs->pt.x - pt.x);
            ms.lY = CEm_Mouse_RemoveAccel(pllhs->pt.y - pt.y);

            CEm_Mouse_AddState(&ms, GetTickCount());
        }

    }

    /*
     *  Eat the message by returning non-zero if at least one client 
     *  is exclusive.
     */
    
    plts = g_plts;
    if (plts) {
        LRESULT rc;

        rc = CallNextHookEx(plts->rglhs[LLTS_MSE].hhk, nCode, wp, lp);
        if (!plts->rglhs[LLTS_MSE].cExcl) {
            return rc;
        }
    } else {
        /*
         *  This can happen if a message gets posted to the hook after 
         *  releasing the last acquire but before we completely unhook.
         */
        RPF( "DINPUT: Mouse hook not passed on to next hook" );
    }

    return 1;
}


#endif  /* USE_SLOW_LL_HOOKS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\diexcl.c ===
/*****************************************************************************
 *
 *  DIExcl.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Management and negotiation of exclusive access.
 *
 *  Contents:
 *
 *      Excl_Acquire
 *      Excl_Unacquire
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflExcl

#pragma BEGIN_CONST_DATA

#ifndef WINNT
TCHAR c_tszVxd[] = TEXT("\\\\.\\DINPUT.VXD");
#endif

#if DIRECTINPUT_VERSION > 0x0300

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SHAREDOBJECT |
 *
 *          Each object that can be taken exclusively receives one of
 *          these structures.  This structure is shared across processes,
 *          so you must protect access with the global DLL mutex.
 *
 *          You would think that we could just use a named semaphore.
 *          Well, that won't work because if the app crashes, nobody
 *          will release the semaphore token and the device will be
 *          unavailable forever.
 *
 *          And we can't use a named mutex because mutexes are tracked
 *          on a per-thread basis, but device acquisition is maintained
 *          on a per-process basis.
 *
 *          So instead we have to roll our own "process-level mutex".
 *
 *          To conserve memory, we dump all our tiny <t SHAREDOBJECT>
 *          structures into a single page.  This means that we cannot
 *          support more than about 4000 / sizeof(SHAREDOBJECT) =
 *          140 devices simultaneously acquired exclusively.
 *
 *          Since USB maxes out at 64 devices, we've got plenty of room.
 *
 *          WARNING!  This structure may not change between DEBUG and
 *          RETAIL.  Otherwise, you have problems if one DirectInput
 *          app is using DEBUG and another is using RETAIL.
 *
 *  @field  GUID | guid |
 *
 *          The identifier for the device that is acquired exclusively.
 *
 *  @field  HWND | hwndOwner |
 *
 *          The window handle associated with the device that has
 *          obtained exclusive access.
 *
 *  @field  DWORD | pidOwner |
 *
 *          The process ID of the owner window.  This is used as a
 *          cross-check against <f hwndOwner> in case the application
 *          which is the owner suddenly crashes.
 *
 *  @field  DWORD | discl |
 *
 *          Cooperative level with which the device was acquired.
 *          We care about foreground-ness so that
 *          we can steal acquisition from a window that
 *          has stopped responding.
 *
 *****************************************************************************/

typedef struct SHAREDOBJECT
{
    GUID    guid;
    HWND    hwndOwner;
    DWORD   pidOwner;
    DWORD   discl;
} SHAREDOBJECT, *PSHAREDOBJECT;

typedef const SHAREDOBJECT *PCSHAREDOBJECT;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @define csoMax | (cbShared - cbX(SHAREDOBJECTHEADER)) / cbX(SHAREDOBJECT) |
 *
 *          The maximum number of simultaneously acquired devices.
 *
 *****************************************************************************/

    #define cbShared    4096
    #define csoMax ((cbShared - cbX(SHAREDOBJECTHEADER)) / cbX(SHAREDOBJECT))

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SHAREDOBJECTPAGE |
 *
 *          A header followed by an array of shared objects.
 *
 *          The header must be first.  <c g_soh> relies on it.
 *
 *  @field  SHAREDOBJECTHEADER | soh |
 *
 *          The header.
 *
 *  @field  SHAREDOBJECT | rgso[csoMax] |
 *
 *          Array of shared object structures.
 *
 *****************************************************************************/

typedef struct SHAREDOBJECTPAGE
{
    SHAREDOBJECTHEADER soh;
    SHAREDOBJECT rgso[csoMax];
} SHAREDOBJECTPAGE, *PSHAREDOBJECTPAGE;

void INLINE
    CheckSharedObjectPageSize(void)
{
    CAssertF(cbX(SHAREDOBJECTPAGE) <= cbShared);
    CAssertF(cbX(SHAREDOBJECTPAGE) + cbX(SHAREDOBJECT) > cbShared);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSHAREDOBJECT | Excl_FindGuid |
 *
 *          Locate a GUID in the shared object array.
 *
 *          The shared global mutex must already be taken.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to locate.
 *
 *  @returns
 *
 *          A pointer to the entry, or 0 if not found.
 *
 *
 *****************************************************************************/

PSHAREDOBJECT INTERNAL
    Excl_FindGuid(PCGUID pguid)
{
    PSHAREDOBJECTPAGE psop;
    PSHAREDOBJECT pso, psoMax;
    DWORD Data1;
    EnterProcI(Excl_FindGuid, (_ "G", pguid));

    psop = g_psop;
    Data1 = pguid->Data1;

    AssertF(g_psop);
    for(pso = &psop->rgso[0], psoMax = &psop->rgso[psop->soh.cso];
       pso < psoMax; pso++)
    {
        if(pso->guid.Data1 == Data1 && IsEqualGUID(pguid, &pso->guid))
        {
            goto done;
        }
    }

    pso = 0;

    done:;
    ExitProcX((UINT_PTR)pso);
    return pso;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Excl_CanStealPso |
 *
 *          Determine whether the <t SHAREDOBJECT> is self-consistent
 *          and represents an instance which validly holds the
 *          exclusive acquisition.  If so, then it cannot be stolen.
 *          Else, it is dead and can be stolen.
 *
 *  @parm   PCSHAREDOBJECT | pso |
 *
 *          The <t SHAREDOBJECT> structure to validate.
 *
 *  @returns
 *
 *          <c S_OK> if acquisition can be stolen, or
 *          <c DIERR_OTHERAPPHASPRIO> if acquisition is validly
 *          held by another instance.
 *
 *****************************************************************************/

STDMETHODIMP
    Excl_CanStealPso(PCSHAREDOBJECT pso)
{
    HRESULT hres = S_OK;

    /*
     *  The window handle should be valid and still refer to the pid.
     */
    if(GetWindowPid(pso->hwndOwner) == pso->pidOwner)
    {

        if( pso->discl & DISCL_FOREGROUND  )
        {
            if( GetForegroundWindow() != pso->hwndOwner)
            {
                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
				RPF("Acquire: can't steal Pso because it belongs to another app. (current hwnd=0x%p)",
                    pso->hwndOwner);
                hres = DIERR_OTHERAPPHASPRIO;
            } else
            {
				// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
                RPF("Acquire: Current owner hwnd=0x%p has priority; "
                    "stealing", pso->hwndOwner);
                hres = S_OK;
            }
        }
    } else
    {
        /*
         *  App died.  Can steal.
         */
		RPF("Acquire: Previous owner pid=0x%08x mysteriously died; "
            "stealing", pso->pidOwner);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Excl_Acquire |
 *
 *          Attempt to acquire the device exclusively.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to acquire.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle with which to associate the device.
 *
 *  @parm   DWORD | discl |
 *
 *          Flags describing cooperative level.
 *          We are interested only in devices acquired exclusively.
 *
 *  @returns
 *
 *          S_OK on success, or
 *
 *          DIERR_OTHERAPPHASPRIO
 *          hresLe(ERROR_INVALID_WINDOW_HANDLE)
 *
 *
 *****************************************************************************/

STDMETHODIMP
    Excl_Acquire(PCGUID pguid, HWND hwnd, DWORD discl)
{
    HRESULT hres;

    AssertF(g_psop);
    if(discl & DISCL_EXCLUSIVE)
    {

        /*
         *  Window must be owned by this process.
         */
        if(GetWindowPid(hwnd) == GetCurrentProcessId())
        {

            PSHAREDOBJECT pso;

            WaitForSingleObject(g_hmtxGlobal, INFINITE);

            pso = Excl_FindGuid(pguid);

            /*
             *  If we found a match, then it might be a sharing violation.
             */
            if(pso)
            {
                hres = Excl_CanStealPso(pso);
            } else
            {
                /*
                 *  Allocate a slot for it.
                 */
                if(g_psop->soh.cso < csoMax)
                {
                    pso = &g_psop->rgso[g_psop->soh.cso++];
                    pso->guid = *pguid;
                    hres = S_OK;
                } else
                {
                    //ISSUE-2001/03/29-timgill hard limit on number of exclusive devices
                    //Can be annoying
                    RPF("Too many devices acquired exclusively");
                    hres = E_FAIL;
                }
            }

            if(SUCCEEDED(hres))
            {

                pso->hwndOwner = hwnd;
                pso->pidOwner = GetCurrentProcessId();
                pso->discl = discl;

                hres = S_OK;
            }

            ReleaseMutex(g_hmtxGlobal);
        } else
        {
            hres = hresLe(ERROR_INVALID_WINDOW_HANDLE);
        }
    } else
    {
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Excl_Unacquire |
 *
 *          Undo the effects of an acquire.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to acquire.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle with which to associate the device.
 *
 *  @parm   DWORD | discl |
 *
 *          Flags describing cooperative level.
 *          We are interested only in devices acquired exclusively.
 *
 *****************************************************************************/

void EXTERNAL
    Excl_Unacquire(PCGUID pguid, HWND hwnd, DWORD discl)
{

    AssertF(g_psop);
    if(discl & DISCL_EXCLUSIVE)
    {

        PSHAREDOBJECT pso;

        WaitForSingleObject(g_hmtxGlobal, INFINITE);

        pso = Excl_FindGuid(pguid);

        /*
         *  Make sure it's really ours.
         */
        if(pso && pso->hwndOwner == hwnd &&
           pso->pidOwner == GetCurrentProcessId())
        {

            /*
             *  Delete the entry and close up the gap.
             */

            *pso = g_psop->rgso[--g_psop->soh.cso];

        }

        ReleaseMutex(g_hmtxGlobal);

    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Excl_Init |
 *
 *          Initialize the exclusive device manager.
 *
 *  @returns
 *
 *          <c S_OK> if all is well.
 *
 *          <c E_FAIL> if something is horribly wrong.
 *
 *****************************************************************************/

STDMETHODIMP
    Excl_Init(void)
{
    HRESULT hres;
    TCHAR tszName[ctchNameGuid];

    DllEnterCrit();

    /*
     *  Create the global mutex used to gate access to shared memory.
     */

    if(g_hmtxGlobal == 0)
    {

        NameFromGUID(tszName, &IID_IDirectInputW);
        g_hmtxGlobal = CreateMutex(0, TRUE, tszName);

        if(g_hmtxGlobal)
        {
            /*
			 * If we need to do smth only once, we can do:
			 * if ( GetLastError() != ERROR_ALREADY_EXISTS )
			 * {
			 *		do our stuff
			 *	}
			 */

            g_flEmulation = RegQueryDIDword(NULL, REGSTR_VAL_EMULATION, 0);

#ifndef WINNT
            /*
             *  We have to open the VxD while we own the global mutex in order 
             *  to avoid a race condition that occurs when two processes try 
             *  to open a VxD at the same time.  See DInput VxD for details.
             */
            if (_OpenVxDHandle)
            {
                /*
                 *  CreateFile on a \\.\ name does not check the dwCreationDisposition 
                 *  parameter but BoundsChecker does so use a valid value.
                 */
                g_hVxD = CreateFile(c_tszVxd, 0, 0, 0, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);

                if( g_hVxD != INVALID_HANDLE_VALUE )
                {
                    LONG lGranularity;

                    /*
                     *  If we can't get the sequence number (weird), then set it
                     *  back to NULL so it will point at the shared memory
                     *  block just like on NT.
                     */
                    if (FAILED(IoctlHw(IOCTL_GETSEQUENCEPTR, 0, 0,
                                       &g_pdwSequence, cbX(g_pdwSequence))))
                    {
                        g_pdwSequence = 0;
                    }

                    if (SUCCEEDED(IoctlHw(IOCTL_MOUSE_GETWHEEL, 0, 0,
                                          &lGranularity, cbX(lGranularity))))
                    {
                        g_lWheelGranularity = lGranularity;
                    }
                } 
                else
                {
                    RPF( "ERROR: Cannot load %s", &c_tszVxd[4] );
                }
            }
#endif
 
            /*
             *  We defer ExtDll work until now, because it is not safe to
             *  call LoadLibrary during PROCESS_ATTACH.
             *
             *  We also steal g_hmtxGlobal to protect us from doing it twice.
             */
            ExtDll_Init();


            ReleaseMutex(g_hmtxGlobal);

        } 
        else
        {
            RPF("Cannot create shared semaphore %s", tszName);
            hres = E_FAIL;
            goto fail;
        }

    }

    /*
     *  Create the shared memory.
     *
     *  Warning!  The file mapping handle must be kept alive
     *  so its name stays alive.  NT destroys the file mapping
     *  object when you close the handle; as a result, the
     *  name goes away with it and another instance of
     *  DirectInput fails to find it.
     */

    if(g_psop == 0)
    {

        NameFromGUID(tszName, &IID_IDirectInputDeviceW);

        g_hfm = CreateFileMapping(INVALID_HANDLE_VALUE, 0,
                                  PAGE_READWRITE, 0,
                                  cbShared, tszName);

        if(g_hfm)
        {
            g_psop = MapViewOfFile(g_hfm, FILE_MAP_WRITE | FILE_MAP_READ,
                                   0, 0, 0);
            if(g_psop)
            {

            } else
            {
                RPF("Cannot map shared memory block %s", tszName);
                hres = E_FAIL;
                goto fail;
            }
        } else
        {
            RPF("Cannot create shared memory block %s", tszName);
            hres = E_FAIL;
            goto fail;
        }
    }

    #ifdef IDirectInputDevice2Vtbl
    /*
     *  Create the global mutex used to gate access to joystick info.
     */

    if(g_hmtxJoy == 0)
    {
        NameFromGUID(tszName, &IID_IDirectInputDevice2A);
        g_hmtxJoy = CreateMutex(0, 0, tszName);

        if(g_hmtxJoy)
        {

        } else
        {
            RPF("Cannot create shared semaphore %s", tszName);
            hres = E_FAIL;
            goto fail;
        }
    
    
        /* 
         * We shall steal the joystick Mutex to build the Bus list
         * for the first time. 
         * It is very unlikely that the list will change. ( PCMCIA cards ! )
         * And when it does change we can expect the joyConfig interface will
         * be pinged.     
         */
        DIBus_BuildList(FALSE);
    }

    #endif

    /*
     *  If we don't have a global sequence number from the driver,
     *  then use the one in the shared memory block instead.
     */
    if(g_pdwSequence == 0)
    {
        g_pdwSequence = &g_psoh->dwSequence;
    }
    
    hres = S_OK;

fail:;
    DllLeaveCrit();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | Excl_UniqueGuidInteger |
 *
 *          Generate a unique number used by DICreateGuid to make sure
 *          that we don't generate two pseudoGUIDs with the same value.
 *
 *  @returns
 *
 *          An integer that has not been returned by this function
 *          yet.
 *
 *****************************************************************************/

LONG EXTERNAL
    Excl_UniqueGuidInteger(void)
{
    LONG lRc;

    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    lRc = ++g_psop->soh.cguid;

    ReleaseMutex(g_hmtxGlobal);

    return lRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | Excl_GetConfigChangedTime |
 *
 *          Retrieves tmConfigChanged in g_psop->soh. 
 *
 *  @returns
 *
 *          tmConfigChanged
 *****************************************************************************/

DWORD EXTERNAL
    Excl_GetConfigChangedTime()
{
    DWORD dwRc;

    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    dwRc = g_psop->soh.tmConfigChanged;

    ReleaseMutex(g_hmtxGlobal);

    return dwRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Excl_SetConfigChangedTime |
 *
 *          Sets tmConfigChanged in g_psop->soh. 
 *
 *  @returns
 *
 *          void
 *****************************************************************************/

void EXTERNAL
    Excl_SetConfigChangedTime(DWORD tm)
{
    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    g_psop->soh.tmConfigChanged = tm;

    ReleaseMutex(g_hmtxGlobal);

    return;
}


#if 0
/*
 * This is the code I wrote when I tired to fix WI321711.
 * It may be used in the future when we want to communicate between DInput7
 * DInput8. -qzheng  3/9/2001
 */
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Excl_SetFlag |
 *
 *          Sets dwFlags in g_psop->soh. 
 *
 *  @returns
 *
 *          void
 *****************************************************************************/

void EXTERNAL
    Excl_SetFlag(DWORD flag)
{
    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    g_psop->soh.dwFlags = flag;

    ReleaseMutex(g_hmtxGlobal);

    return;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | Excl_TestFlag |
 *
 *          Test whether a flag is set. 
 *          The flags are as dwFlags in g_psop->soh. 
 *
 *  @returns
 *
 *          TRUE: the flag is set
 *          FALSE: otherwise
 *
 *****************************************************************************/

BOOL EXTERNAL
    Excl_TestFlag(DWORD flag)
{
    BOOL fRc;

    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    if( g_psop->soh.dwFlags & flag ) {
        fRc = TRUE;
    }

    ReleaseMutex(g_hmtxGlobal);

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Excl_ClearFlag |
 *
 *          Clear a flag. 
 *          The flags are as dwFlags in g_psop->soh. 
 *
 *  @returns
 *
 *          void
 *****************************************************************************/

void EXTERNAL
    Excl_ClearFlag(DWORD flag)
{
    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    if( g_psop->soh.dwFlags &= ~flag;

    ReleaseMutex(g_hmtxGlobal);

    return;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | Excl_TestAndClearFlag |
 *
 *          Test whether a flag is set, if set, then clear it. 
 *          The flags are as dwFlags in g_psop->soh. 
 *
 *  @returns
 *
 *          TRUE: the flag is set
 *          FALSE: otherwise
 *
 *****************************************************************************/

BOOL EXTERNAL
    Excl_TestAndClearFlag(DWORD flag)
{
    BOOL fRc;

    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    if( g_psop->soh.dwFlags & flag ) {
        g_psop->soh.dwFlags &= ~flag;
        fRc = TRUE;
    }

    ReleaseMutex(g_hmtxGlobal);

    return fRc;
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\digenk.c ===
/*****************************************************************************
 *
 *  DIGenK.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Generic IDirectInputDevice callback for keyboard.
 *
 *  Contents:
 *
 *      CKbd_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      Some holes in windows.h on NT platforms.
 *
 *****************************************************************************/

#ifndef VK_KANA
#define VK_KANA         0x15
#endif

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflKbd

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CKbd_New!
 *
 *****************************************************************************/

Primary_Interface(CKbd, IDirectInputDeviceCallback);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct KBDSTAT |
 *
 *          Internal instantaneous keyboard status information.
 *
 *  @field  BYTE | rgb[DIKBD_CKEYS] |
 *
 *          Array of key states, one for each logical key.
 *
 *****************************************************************************/

typedef struct KBDSTAT {

    BYTE    rgb[DIKBD_CKEYS];

} KBDSTAT, *PKBDSTAT;

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @topic  Special remarks on keyboard scan codes |
 *
 *          There are several aspects of keyboards which applications should
 *          be aware of.  Applications are encouraged to allow users to
 *          reconfigure keyboard action keys to suit the physical keyboard
 *          layout.
 *
 *          For the purposes of this discussion, the baseline keyboard
 *          shall be the US PC Enhanced keyboard.  When a key is described
 *          as "missing", it means that the key is present on the US PC
 *          Enhanced keyboard but not on the keyboard under discussion.
 *          When a key is described as "added", it means that the key is
 *          absent on the US PC Enhanced keyboard but present on the
 *          keyboard under discussion.
 *
 *          Not all PC Enhanced keyboards support the new Windows keys
 *          (DIK_LWIN, DIK_RWIN, and DIK_APPS).  There is no way to
 *          determine whether the keys are physically available.
 *
 *          Note that there is no DIK_PAUSE key code.  The PC Enhanced
 *          keyboard does not generate a separate DIK_PAUSE scan code;
 *          rather, it synthesizes a "Pause" from the DIK_LCONTROL and
 *          DIK_NUMLOCK scan codes.
 *
 *          Keyboards for laptops or other reduced-footprint computers
 *          frequently do not implement a full set of keys.  Instead,
 *          some keys (typically numeric keypad keys) are multiplexed
 *          with other keys, selected by an auxiliary "mode" key which
 *          does not generate a separate scan code.
 *
 *          If the keyboard subtype indicates a PC XT or PC AT keyboard,
 *          then the following keys are not available:
 *          DIK_F11, DIK_F12, and all the extended keys (DIK_* values
 *          greater than or equal to 0x80).  Furthermore, the PC XT
 *          keyboard lacks DIK_SYSRQ.
 *
 *          Japanese keyboards contain a substantially different set of
 *          keys from US keyboards.  The following keyboard scan codes
 *          are not available on Japanese keyboards:
 *          DIK_EQUALS, DIK_APOSTROPHE, DIK_GRAVE, DIK_NUMPADENTER,
 *          DIK_RCONTROL, DIK_RMENU.  Furthermore, most Japanese
 *          keyboards do not support DIK_RSHIFT.  (It is customary
 *          to use DIK_NUMPADEQUAL in place of DIK_RSHIFT.)
 *
 *          Japanese keyboards contain the following additional keys:
 *          DIK_F14, DIK_NUMPADEQUAL, DIK_CIRCUMFLEX, DIK_AT, DIK_COLON,
 *          DIK_UNDERLINE, DIK_XFER, DIK_NFER, DIK_STOP, DIK_KANA, and
 *          DIK_NUMPADCOMMA.
 *
 *          Note that on Japanese keyboards, the DIK_CAPSLOCK and
 *          DIK_KANA keys are toggle buttons and not push buttons.
 *          They generate a down event
 *          when first pressed, then generate an up event when pressed a
 *          second time.
 *          Note that on Windows 2000, the DIK_KANJI key is also treated as a 
 *          toggle.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global KBDTYPE | c_rgktWhich[] |
 *
 *          Array that describes which keyboards support which keys.
 *
 *          The list is optimistic.  If any keyboard of the indicated
 *          type supports the key, then we list it.
 *
 *          Items marks "available for NEC" are keys which are extremely
 *          unlikely to be used in future versions of the Enhanced
 *          keyboard and therefore can be used as ersatz scan codes for
 *          NEC-only keys.
 *
 *          Note:  Kana and CAPSLOCK are toggle buttons on NEC keyboards.
 *          Note:  Kana, Kanji and CAPSLOCK are toggle buttons on all NT JPN 
 *                 keyboards.
 *
 *****************************************************************************/

typedef BYTE KBDTYPE;

#define KBDTYPE_XT       0x01       /* Key exists on XT class keyboard */
#define KBDTYPE_AT       0x02       /* Key exists on AT class keyboard */
#define KBDTYPE_ENH      0x04       /* Key exists on Enhanced keyboard */
#define KBDTYPE_NEC      0x08       /* Key exists on NEC keyboard */
#define KBDTYPE_ANYKBD   0x0F       /* Key exists somewhere in the world */

#define KBDTYPE_NECTGL   0x10       /* Is a toggle-key on NEC keyboard */
#define KBDTYPE_NTTGL    0x20       /* Is a toggle-key on an NT FE keyboard */

#pragma BEGIN_CONST_DATA

#define XT      KBDTYPE_XT  |
#define AT      KBDTYPE_XT  |
#define ENH     KBDTYPE_ENH |
#define NEC     KBDTYPE_NEC |
#define NECTGL  KBDTYPE_NECTGL |
#define NTTGL   KBDTYPE_NTTGL |

KBDTYPE c_rgktWhich[] = {

                               0,     /* 0x00 - <undef>  */
    XT AT ENH NEC              0,     /* 0x01 - Esc      */
    XT AT ENH NEC              0,     /* 0x02 - 1        */
    XT AT ENH NEC              0,     /* 0x03 - 2        */
    XT AT ENH NEC              0,     /* 0x04 - 3        */
    XT AT ENH NEC              0,     /* 0x05 - 4        */
    XT AT ENH NEC              0,     /* 0x06 - 5        */
    XT AT ENH NEC              0,     /* 0x07 - 6        */
    XT AT ENH NEC              0,     /* 0x08 - 7        */
    XT AT ENH NEC              0,     /* 0x09 - 8        */
    XT AT ENH NEC              0,     /* 0x0A - 9        */
    XT AT ENH NEC              0,     /* 0x0B - 0        */
    XT AT ENH NEC              0,     /* 0x0C - -        */
    XT AT ENH                  0,     /* 0x0D - =        */
    XT AT ENH NEC              0,     /* 0x0E - BkSp     */
    XT AT ENH NEC              0,     /* 0x0F - Tab      */

    XT AT ENH NEC              0,     /* 0x10 - Q        */
    XT AT ENH NEC              0,     /* 0x11 - W        */
    XT AT ENH NEC              0,     /* 0x12 - E        */
    XT AT ENH NEC              0,     /* 0x13 - R        */
    XT AT ENH NEC              0,     /* 0x14 - T        */
    XT AT ENH NEC              0,     /* 0x15 - Y        */
    XT AT ENH NEC              0,     /* 0x16 - U        */
    XT AT ENH NEC              0,     /* 0x17 - I        */
    XT AT ENH NEC              0,     /* 0x18 - O        */
    XT AT ENH NEC              0,     /* 0x19 - P        */
    XT AT ENH NEC              0,     /* 0x1A - [        */
    XT AT ENH NEC              0,     /* 0x1B - ]        */
    XT AT ENH NEC              0,     /* 0x1C - Enter    */
    XT AT ENH NEC              0,     /* 0x1D - LCtrl    */
    XT AT ENH NEC              0,     /* 0x1E - A        */
    XT AT ENH NEC              0,     /* 0x1F - S        */

    XT AT ENH NEC              0,     /* 0x20 - D        */
    XT AT ENH NEC              0,     /* 0x21 - F        */
    XT AT ENH NEC              0,     /* 0x22 - G        */
    XT AT ENH NEC              0,     /* 0x23 - H        */
    XT AT ENH NEC              0,     /* 0x24 - J        */
    XT AT ENH NEC              0,     /* 0x25 - K        */
    XT AT ENH NEC              0,     /* 0x26 - L        */
    XT AT ENH NEC              0,     /* 0x27 - ;        */
    XT AT ENH                  0,     /* 0x28 - '        */
    XT AT ENH                  0,     /* 0x29 - `        */
    XT AT ENH NEC              0,     /* 0x2A - LShift   */
    XT AT ENH NEC              0,     /* 0x2B - \        */
    XT AT ENH NEC              0,     /* 0x2C - Z        */
    XT AT ENH NEC              0,     /* 0x2D - X        */
    XT AT ENH NEC              0,     /* 0x2E - C        */
    XT AT ENH NEC              0,     /* 0x2F - V        */

    XT AT ENH NEC              0,     /* 0x30 - B        */
    XT AT ENH NEC              0,     /* 0x31 - N        */
    XT AT ENH NEC              0,     /* 0x32 - M        */
    XT AT ENH NEC              0,     /* 0x33 - ,        */
    XT AT ENH NEC              0,     /* 0x34 - .        */
    XT AT ENH NEC              0,     /* 0x35 - /        */
    XT AT ENH NEC              0,     /* 0x36 - RShift   */
    XT AT ENH NEC              0,     /* 0x37 - Num*     */
    XT AT ENH NEC              0,     /* 0x38 - LAlt     */
    XT AT ENH NEC              0,     /* 0x39 - Space    */
    XT AT ENH NEC NECTGL NTTGL 0,     /* 0x3A - CapsLock */
    XT AT ENH NEC              0,     /* 0x3B - F1       */
    XT AT ENH NEC              0,     /* 0x3C - F2       */
    XT AT ENH NEC              0,     /* 0x3D - F3       */
    XT AT ENH NEC              0,     /* 0x3E - F4       */
    XT AT ENH NEC              0,     /* 0x3F - F5       */

    XT AT ENH NEC              0,     /* 0x40 - F6       */
    XT AT ENH NEC              0,     /* 0x41 - F7       */
    XT AT ENH NEC              0,     /* 0x42 - F8       */
    XT AT ENH NEC              0,     /* 0x43 - F9       */
    XT AT ENH NEC              0,     /* 0x44 - F10      */
    XT AT ENH                  0,     /* 0x45 - NumLock  */
    XT AT ENH                  0,     /* 0x46 - ScrLock  */
    XT AT ENH NEC              0,     /* 0x47 - Numpad7  */
    XT AT ENH NEC              0,     /* 0x48 - Numpad8  */
    XT AT ENH NEC              0,     /* 0x49 - Numpad9  */
    XT AT ENH NEC              0,     /* 0x4A - Numpad-  */
    XT AT ENH NEC              0,     /* 0x4B - Numpad4  */
    XT AT ENH NEC              0,     /* 0x4C - Numpad5  */
    XT AT ENH NEC              0,     /* 0x4D - Numpad6  */
    XT AT ENH NEC              0,     /* 0x4E - Numpad+  */
    XT AT ENH NEC              0,     /* 0x4F - Numpad1  */

    XT AT ENH NEC              0,     /* 0x50 - Numpad2  */
    XT AT ENH NEC              0,     /* 0x51 - Numpad3  */
    XT AT ENH NEC              0,     /* 0x52 - Numpad0  */
    XT AT ENH NEC              0,     /* 0x53 - Numpad.  */

                               0,     /* 0x54 - <undef>  */
                               0,     /* 0x55 - <undef>  */
          ENH                  0,     /* 0x56 - <undef>. On UK/Germany keyboards, it is <, > and |. */
          ENH NEC              0,     /* 0x57 - F11      */
          ENH NEC              0,     /* 0x58 - F12      */
                               0,     /* 0x59 - <undef>  */
                               0,     /* 0x5A - <undef>  */
                               0,     /* 0x5B - <undef>  */
                               0,     /* 0x5C - <undef>  */
                               0,     /* 0x5D - <undef>  */
                               0,     /* 0x5E - <undef>  */
                               0,     /* 0x5F - <undef>  */

                               0,     /* 0x60 - <undef>  */
                               0,     /* 0x61 - <undef>  */
                               0,     /* 0x62 - <undef>  */
                               0,     /* 0x63 - <undef>  */
              NEC              0,     /* 0x64 - F13      */
              NEC              0,     /* 0x65 - F14      */
              NEC              0,     /* 0x66 - F15      */
                               0,     /* 0x67 - <undef>  */
                               0,     /* 0x68 - <undef>  */
                               0,     /* 0x69 - <undef>  */
                               0,     /* 0x6A - <undef>  */
                               0,     /* 0x6B - <undef>  */
                               0,     /* 0x6C - <undef>  */
                               0,     /* 0x6D - <undef>  */
                               0,     /* 0x6E - <undef>  */
                               0,     /* 0x6F - <undef>  */

              NEC NECTGL NTTGL 0,     /* 0x70 - Kana     */
                               0,     /* 0x71 - <undef>  */
                               0,     /* 0x72 - <undef>  */
          ENH                  0,     /* 0x73 - <undef>.  On Portugese (Brazilian) keyboard, it is /, ? */
                               0,     /* 0x74 - <undef>  */
                               0,     /* 0x75 - <undef>  */
                               0,     /* 0x76 - <undef>  */
                               0,     /* 0x77 - <undef>  */
                               0,     /* 0x78 - <undef>  */
              NEC              0,     /* 0x79 - Convert  */
                               0,     /* 0x7A - <undef>  */
              NEC              0,     /* 0x7B - Nfer     */
                               0,     /* 0x7C - <undef>  */
              NEC              0,     /* 0x7D - Yen      */
          ENH                  0,     /* 0x7E - <undef>.  On Portugese (Brazilian) keyboard, it is keypad . */
                               0,     /* 0x7F - <undef>  */

                                /* Extended keycodes go here */

                               0,     /* 0x80 - <undef>  */
                               0,     /* 0x81 - <undef>  */
                               0,     /* 0x82 - <undef>  */
                               0,     /* 0x83 - <undef>  */
                               0,     /* 0x84 - <undef>  */
                               0,     /* 0x85 - <undef>  */
                               0,     /* 0x86 - <undef>  */
                               0,     /* 0x87 - <undef>  */
                               0,     /* 0x88 - <undef>  */
                               0,     /* 0x89 - <undef>  */
                               0,     /* 0x8A - <undef>  */
                               0,     /* 0x8B - <undef>  */
                               0,     /* 0x8C - <undef>  */
              NEC              0,     /* 0x8D - Num=     */
                               0,     /* 0x8E - <undef>  */
                               0,     /* 0x8F - <undef>  */

          ENH NEC              0,     /* 0x90 - ^        */ ///Prev Track
              NEC              0,     /* 0x91 - @        */
              NEC              0,     /* 0x92 - :        */
              NEC              0,     /* 0x93 - _        */
              NEC        NTTGL 0,     /* 0x94 - Xfer - AKA Kanji */
              NEC              0,     /* 0x95 - Stop     */
              NEC              0,     /* 0x96 - AX       */
              NEC              0,     /* 0x97 - Unlabel'd*/
                               0,     /* 0x98 - <undef>  */ /* available for NEC */
          ENH                  0,     /* 0x99 - <undef>  */ /* available for NEC */ ///Next Track
                               0,     /* 0x9A - <undef>  */
                               0,     /* 0x9B - <undef>  */
          ENH                  0,     /* 0x9C - NumEnter */
          ENH                  0,     /* 0x9D - RCtrl    */
                               0,     /* 0x9E - <undef>  */ /* available for NEC */
                               0,     /* 0x9F - <undef>  */ /* available for NEC */

          ENH                  0,     /* 0xA0 - <undef>  */ /* available for NEC */ ///Mute
          ENH                  0,     /* 0xA1 - <undef>  */ /* available for NEC */ ///Calculator
          ENH                  0,     /* 0xA2 - <undef>  */ /* available for NEC */ ///Play/Pause
                               0,     /* 0xA3 - <undef>  */ /* available for NEC */
          ENH                  0,     /* 0xA4 - <undef>  */ /* available for NEC */ ///Stop
                               0,     /* 0xA5 - <undef>  */ /* available for NEC */
                               0,     /* 0xA6 - <undef>  */ /* available for NEC */
                               0,     /* 0xA7 - <undef>  */
                               0,     /* 0xA8 - <undef>  */
                               0,     /* 0xA9 - <undef>  */
                               0,     /* 0xAA - <undef>  */
                               0,     /* 0xAB - <undef>  */
                               0,     /* 0xAC - <undef>  */ /* available for NEC */
                               0,     /* 0xAD - <undef>  */ /* available for NEC */
          ENH                  0,     /* 0xAE - <undef>  */ /* available for NEC */ ///Volume -
                               0,     /* 0xAF - <undef>  */ /* available for NEC */

          ENH                  0,     /* 0xB0 - <undef>  */ /* available for NEC */ ///Volume +
                               0,     /* 0xB1 - <undef>  */ /* available for NEC */
          ENH                  0,     /* 0xB2 - <undef>  */ /* available for NEC */ ///Web/Home
              NEC              0,     /* 0xB3 - Num,     */
                               0,     /* 0xB4 - <undef>  */
          ENH NEC              0,     /* 0xB5 - Num/     */
                               0,     /* 0xB6 - <undef>  */
       AT ENH NEC              0,     /* 0xB7 - SysRq    */
          ENH                  0,     /* 0xB8 - RAlt     */
                               0,     /* 0xB9 - <undef>  */
                               0,     /* 0xBA - <undef>  */
                               0,     /* 0xBB - <undef>  */
                               0,     /* 0xBC - <undef>  */
                               0,     /* 0xBD - <undef>  */
                               0,     /* 0xBE - <undef>  */
                               0,     /* 0xBF - <undef>  */

                               0,     /* 0xC0 - <undef>  */
                               0,     /* 0xC1 - <undef>  */
                               0,     /* 0xC2 - <undef>  */
                               0,     /* 0xC3 - <undef>  */
                               0,     /* 0xC4 - <undef>  */
          ENH                  0,     /* 0xC5 - Pause    */
                               0,     /* 0xC6 - <undef>  */
          ENH NEC              0,     /* 0xC7 - Home     */
          ENH NEC              0,     /* 0xC8 - UpArrow  */
          ENH NEC              0,     /* 0xC9 - PgUp     */
                               0,     /* 0xCA - <undef>  */
          ENH NEC              0,     /* 0xCB - LtArrow  */
                               0,     /* 0xCC - <undef>  */
          ENH NEC              0,     /* 0xCD - RtArrow  */
                               0,     /* 0xCE - <undef>  */
          ENH NEC              0,     /* 0xCF - End      */

          ENH NEC              0,     /* 0xD0 - DnArrow  */
          ENH NEC              0,     /* 0xD1 - PgDn     */
          ENH NEC              0,     /* 0xD2 - Insert   */
          ENH NEC              0,     /* 0xD3 - Delete   */
                               0,     /* 0xD4 - <undef>  */
                               0,     /* 0xD5 - <undef>  */
                               0,     /* 0xD6 - <undef>  */
                               0,     /* 0xD7 - <undef>  */
                               0,     /* 0xD8 - <undef>  */
                               0,     /* 0xD9 - <undef>  */
                               0,     /* 0xDA - <undef>  */
          ENH NEC              0,     /* 0xDB - LWin     */
          ENH NEC              0,     /* 0xDC - RWin     */
          ENH NEC              0,     /* 0xDD - AppMenu  */
          ENH                  0,     /* 0xDE - Power    */
          ENH                  0,     /* 0xDF - Sleep    */

                               0,     /* 0xE0 - <undef>  */
                               0,     /* 0xE1 - <undef>  */
                               0,     /* 0xE2 - <undef>  */
          ENH                  0,     /* 0xE3 - Wake     */
                               0,     /* 0xE4 - <undef>  */
          ENH                  0,     /* 0xE5 - <undef>  */ ///Search
          ENH                  0,     /* 0xE6 - <undef>  */ ///Favorites
          ENH                  0,     /* 0xE7 - <undef>  */ ///Refresh
          ENH                  0,     /* 0xE8 - <undef>  */ ///Stop
          ENH                  0,     /* 0xE9 - <undef>  */ ///Forward
          ENH                  0,     /* 0xEA - <undef>  */ ///Back
          ENH                  0,     /* 0xEB - <undef>  */ ///My Computer
          ENH                  0,     /* 0xEC - <undef>  */ ///Mail
          ENH                  0,     /* 0xED - <undef>  */ ///Media
                               0,     /* 0xEE - <undef>  */
                               0,     /* 0xEF - <undef>  */

                               0,     /* 0xF0 - <undef>  */
                               0,     /* 0xF1 - <undef>  */
                               0,     /* 0xF2 - <undef>  */
                               0,     /* 0xF3 - <undef>  */
                               0,     /* 0xF4 - <undef>  */
                               0,     /* 0xF5 - <undef>  */
                               0,     /* 0xF6 - <undef>  */
                               0,     /* 0xF7 - <undef>  */
                               0,     /* 0xF8 - <undef>  */
                               0,     /* 0xF9 - <undef>  */
                               0,     /* 0xFA - <undef>  */
                               0,     /* 0xFB - <undef>  */
                               0,     /* 0xFC - <undef>  */
                               0,     /* 0xFD - <undef>  */
                               0,     /* 0xFE - <undef>  */
                               0,     /* 0xFF - <undef>  */

};

#undef  XT
#undef  AT
#undef  ENH
#undef  NEC

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CKbd |
 *
 *          The <i IDirectInputDeviceCallback> object for the
 *          generic keyboard.
 *
 *  @field  IDirectInputDeviceCalllback | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  PMKBDSTAT | pksPhys |
 *
 *          Pointer to physical keyboard status information kept down in the
 *          VxD.
 *
 *  @field  VXDINSTANCE * | pvi |
 *
 *          The DirectInput instance handle.
 *
 *  @field  DWORD | dwKbdType |
 *
 *          The device subtype for this keyboard.
 *
 *  @field  DWORD | flEmulation |
 *
 *          The emulation flags forced by the application.  If any of
 *          these flags is set (actually, at most one will be set), then
 *          we are an alias device.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          The dynamically-generated data format based on the
 *          keyboard type.
 *
 *  @field  DIOBJECTDATAFORMAT | rgodf[] |
 *
 *          Object data format table generated as part of the
 *          <e CKbd.df>.
 *
 *  @comm
 *
 *          It is the caller's responsibility to serialize access as
 *          necessary.
 *
 *****************************************************************************/

typedef struct CKbd {

    /* Supported interfaces */
    IDirectInputDeviceCallback dcb;

    PKBDSTAT pksPhys;

    VXDINSTANCE *pvi;

    DWORD dwKbdType;
    DWORD flEmulation;

    DIDATAFORMAT df;
    DIOBJECTDATAFORMAT rgodf[DIKBD_CKEYS];

} CKbd, DK, *PDK;

#define ThisClass CKbd
#define ThisInterface IDirectInputDeviceCallback
#define riidExpected &IID_IDirectInputDeviceCallback

/*****************************************************************************
 *
 *      CKbd::QueryInterface      (from IUnknown)
 *      CKbd::AddRef              (from IUnknown)
 *      CKbd::Release             (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CKbd)
Default_AddRef(CKbd)
Default_Release(CKbd)

#else

#define CKbd_QueryInterface   Common_QueryInterface
#define CKbd_AddRef           Common_AddRef
#define CKbd_Release          Common_Release

#endif

#define CKbd_QIHelper         Common_QIHelper
#define CKbd_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CKbd_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CKbd_Finalize(PV pvObj)
{
    PDK this = pvObj;

    if (this->pvi) {
        HRESULT hres;
        hres = Hel_DestroyInstance(this->pvi);
        AssertF(SUCCEEDED(hres));
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | WrappedGetKeyboardType |
 *
 *          GetKeyboardType but wrapped in DEBUG for registry overrides.
 *
 *  @parm   int  | nTypeFlag |
 *
 *          Which data to return.  Only 0, 1 and 2 are supported
 *
 *  @returns
 *
 *          int value requested
 *
 *****************************************************************************/

#ifndef DEBUG
  #ifdef USE_WM_INPUT
    #define WrappedGetKeyboardType(x) DIRaw_GetKeyboardType(x)
  #else
    #define WrappedGetKeyboardType(x) GetKeyboardType(x)
  #endif
#else
int INTERNAL WrappedGetKeyboardType
( 
    int nTypeFlag 
)
{
    TCHAR ValueName[2];
    int TypeRes;

  #ifdef USE_WM_INPUT
    TypeRes = DIRaw_GetKeyboardType( nTypeFlag );
  #else
    TypeRes = GetKeyboardType( nTypeFlag );
  #endif
  
    if( nTypeFlag < 10 )
    {
        ValueName[0] = TEXT( '0' ) + nTypeFlag;
        ValueName[1] = TEXT( '\0' );
        
        TypeRes = (int)RegQueryDIDword( REGSTR_KEY_KEYBTYPE, ValueName, (DWORD)TypeRes );

        SquirtSqflPtszV(sqfl | sqflTrace, 
            TEXT( "DINPUT: GetKeyboardType(%d) returning 0x%08x" ),
            nTypeFlag, TypeRes );
    }
    else
    {
        RPF( "Somebody is passing %d to WrappedGetKeyboardType", nTypeFlag );
    }

    return TypeRes;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | Acquire |
 *
 *          Tell the device driver to begin data acquisition.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_Acquire(PDICB pdcb)
{
    VXDDWORDDATA vdd;
    PDK this;
    HRESULT hres;

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  Propagate the state of the potential toggle keys down to
     *  the VxD.  This also alerts the VxD that acquisition is coming,
     *  so it can reset the state tables if necessary.
     */
    vdd.pvi = this->pvi;
    vdd.dw = 0;
    if( WrappedGetKeyboardType(0) == 7 )
    {
        /*
         *  Let the keyboard driver know that this is an FE keyboard
         */
        vdd.dw |= 16;

        if (GetAsyncKeyState(VK_KANA) < 0) {
            vdd.dw |= 1;
        }
        if (GetAsyncKeyState(VK_CAPITAL) < 0) {
            vdd.dw |= 2;
        }
        if (GetAsyncKeyState(VK_KANJI) < 0) {
            vdd.dw |= 8;
        }
    }

    if( this->pvi->fl & VIFL_CAPTURED )
    {
        vdd.dw |= 4;        // Tell the keyboard driver to pre-acquire hooks
    }

    hres = Hel_Kbd_InitKeys(&vdd);
    
    if( this->pvi->fl & VIFL_CAPTURED )
    {
        /*
         *  A bit of work needs to be done at ring 3 now.
         *  Try to clear any key that is set.  Start with VK_BACK as mouse 
         *  buttons and undefined things go before.
         *  This still covers a lot of undefined VKs but we're less likely 
         *  to do damage clearing something that was undefined than leaving 
         *  keys uncleared.
         */
        BYTE vk;
        for( vk=VK_BACK; vk<VK_OEM_CLEAR; vk++ )
        {
            if( ( vk == VK_KANA ) || ( vk == VK_KANJI ) || ( vk == VK_CAPITAL ) )
            {
                continue;
            }
            if(GetAsyncKeyState(vk) < 0)
            {
                keybd_event( vk, 0, KEYEVENTF_KEYUP, 0 );
            }
        }
    }

    return S_FALSE;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetInstance |
 *
 *          Obtains the DirectInput instance handle.
 *
 *  @parm   OUT PPV | ppvi |
 *
 *          Receives the instance handle.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetInstance(PDICB pdcb, PPV ppvi)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetInstance, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    *ppvi = (PV)this->pvi;
    hres = S_OK;

    ExitOleProcPpvR(ppvi);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetDataFormat |
 *
 *          Obtains the device's preferred data format.
 *
 *  @parm   OUT LPDIDEVICEFORMAT * | ppdf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdf)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetDataFormat,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppdf = &this->df;
    hres = S_OK;

    ExitOleProcPpvR(ppdf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetDeviceInfo |
 *
 *          Obtain general information about the device.
 *
 *  @parm   OUT LPDIDEVICEINSTANCEW | pdiW |
 *
 *          <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *          Secret convenience:  <e DEVICEINSTANCE.guidProduct> is equal
 *          to <e DEVICEINSTANCE.guidInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW pdiW)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetDeviceInfo,
               (_ "pp", pdcb, pdiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEINSTANCEW(pdiW->dwSize));

    AssertF(IsEqualGUID(&GUID_SysKeyboard   , &pdiW->guidInstance) ||
            IsEqualGUID(&GUID_SysKeyboardEm , &pdiW->guidInstance) ||
            IsEqualGUID(&GUID_SysKeyboardEm2, &pdiW->guidInstance));

    pdiW->guidProduct = GUID_SysKeyboard;

    pdiW->dwDevType = MAKE_DIDEVICE_TYPE(DIDEVTYPE_KEYBOARD,
                                         this->dwKbdType);


    LoadStringW(g_hinst, IDS_STDKEYBOARD, pdiW->tszProductName, cA(pdiW->tszProductName));
    LoadStringW(g_hinst, IDS_STDKEYBOARD, pdiW->tszInstanceName, cA(pdiW->tszInstanceName));

    hres = S_OK;

    ExitOleProcR();
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CKbd | GetCapabilities |
 *
 *          Get keyboard device capabilities.
 *
 *  @parm   LPDIDEVCAPS | pdc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdc)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetCapabilities,
               (_ "pp", pdcb, pdc));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    pdc->dwDevType = MAKE_DIDEVICE_TYPE(DIDEVTYPE_KEYBOARD,
                                        this->dwKbdType);
    pdc->dwFlags = DIDC_ATTACHED;
    if (this->flEmulation) {
        pdc->dwFlags |= DIDC_ALIAS;
    }

    //  Remove these assertions for 32650
    //  AssertF(pdc->dwAxes == 0);
    //  AssertF(pdc->dwPOVs == 0);
    pdc->dwButtons = this->df.dwNumObjs;
    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CKbd | GetPhysicalState |
 *
 *          Read the physical keyboard state into <p pksOut>.
 *
 *          Note that it doesn't matter if this is not atomic.
 *          If a key goes down or up while we are reading it,
 *          we will get a mix of old and new data.  No big deal.
 *
 *  @parm   PDK | this |
 *
 *          The object in question.
 *
 *  @parm   PKBDSTATE | pksOut |
 *
 *          Where to put the keyboard state.
 *  @returns
 *          None.
 *
 *****************************************************************************/

void INLINE
CKbd_GetPhysicalState(PDK this, PKBDSTAT pksOut)
{
    AssertF(this->pksPhys);
    *pksOut = *this->pksPhys;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetDeviceState |
 *
 *          Obtains the state of the keyboard device.
 *
 *          It is the caller's responsibility to have validated all the
 *          parameters and ensure that the device has been acquired.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Keyboard data in the preferred data format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetDeviceState(PDICB pdcb, LPVOID pvData)
{
    HRESULT hres;
    PDK this;
    PKBDSTAT pkstOut = pvData;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetDeviceState,
               (_ "pp", pdcb, pvData));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  ISSUE-2001/03/29-timgill older apps may need compat behaviour
     *  We never used to check whether or not the device was still 
     *  acquired since without exclusive mode there would be no reason for 
     *  the device not to be.  
     *  To keep behavior the same for older apps it might be better to 
     *  only fail if VIFL_CAPTURED is not set but just checking VIFL_ACQUIRED 
     *  is good enough for now, maybe for ever.
     */
//    if( !(this->pvi->fl & VIFL_CAPTURED) 
//      || (this->pvi->fl & VIFL_ACQUIRED) )
    if( this->pvi->fl & VIFL_ACQUIRED )
    {
        CKbd_GetPhysicalState(this, pkstOut);
        hres = S_OK;
    } else {
        RPF( "Keyboard VxD flags: 0x%08x", this->pvi->fl );
        hres = DIERR_INPUTLOST;
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetObjectInfo |
 *
 *          Obtain the friendly name of an object, passwed by index
 *          into the preferred data format.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          fields have already been filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                               LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetObjectInfo,
               (_ "pxp", pdcb, ppropi->iobj, pdidoiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

#ifdef HAVE_DIDEVICEOBJECTINSTANCE_DX5
    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEW(pdidoiW->dwSize));
#endif
    if (ppropi->iobj < this->df.dwNumObjs) {
        AssertF(this->rgodf == this->df.rgodf);
        AssertF(ppropi->dwDevType == this->rgodf[ppropi->iobj].dwType);
        AssertF(ppropi->dwDevType & DIDFT_BUTTON);

        LoadStringW(g_hinst,
                    IDS_KEYBOARDOBJECT +
                    DIDFT_GETINSTANCE(ppropi->dwDevType),
                    pdidoiW->tszName, cA(pdidoiW->tszName));

        /*
         *  We do not support force feedback on keyboards, so
         *  there are no FF flags to report.
         */
        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | SetCooperativeLevel |
 *
 *          Notify the device of the cooperative level.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.  We do not support exclusive access.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);

    AssertF(DIGETEMFL(this->pvi->fl) == 0 ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_KBD ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_KBD2);

    /*
     *  We don't allow background exclusive access.
     *  This is actually not a real problem to support; we just don't feel like it
     *  because it's too dangerous.
     */
    if (!(this->pvi->fl & DIMAKEEMFL(DIEMFL_KBD2))) {

        if (dwFlags & DISCL_EXCLUSIVE) {
            if (dwFlags & DISCL_FOREGROUND) {
                this->pvi->fl |= VIFL_CAPTURED;
                this->pvi->fl &= ~VIFL_NOWINKEY;
                hres = S_OK;
            } else {                /* Disallow exclusive background */
                hres = E_NOTIMPL;
            }
        } else {
            this->pvi->fl &= ~VIFL_CAPTURED;
            this->pvi->fl &= ~VIFL_NOWINKEY;
            hres = S_OK;

            if (dwFlags & DISCL_NOWINKEY) {
                if (dwFlags & DISCL_FOREGROUND) {
                    this->pvi->fl |= VIFL_NOWINKEY;
                } else {
                    RPF("Kbd::SetCooperativeLevel: NOWINKEY not supported in Backgroud mode.");
                    hres = E_NOTIMPL;
                }
            }
        }
    } else {

        /*
         *  Emulation level 2 does not support background access.
         */

        if ((this->pvi->fl & DIMAKEEMFL(DIEMFL_KBD2)) &&
            (dwFlags & DISCL_BACKGROUND)) {
            hres = E_NOTIMPL;
        } else {
            this->pvi->fl &= ~VIFL_NOWINKEY;
            hres = S_OK;

            if (dwFlags & DISCL_NOWINKEY) {
                if (dwFlags & DISCL_FOREGROUND) {
                    this->pvi->fl |= VIFL_NOWINKEY;
                } else {
                    RPF("Kbd::SetCooperativeLevel: NOWINKEY not supported in Backgroud mode.");
                    hres = E_NOTIMPL;
                }
            }
        }
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | RunControlPanel |
 *
 *          Run the keyboard control panel.
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          The owner window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszKeyboard[] = TEXT("keyboard");

#pragma END_CONST_DATA

STDMETHODIMP
CKbd_RunControlPanel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::RunControlPanel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = hresRunControlPanel(c_tszKeyboard);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CKbd | InitJapanese |
 *
 *          Initialize the Japanese keyboard goo.
 *
 *          Annoying quirk!  On Windows 95, Japanese keyboards generate
 *          their own scan codes.  But on Windows NT, they generate
 *          "nearly AT-compatible" scan codes.
 *
 *  @returns
 *
 *          KBDTYPE_ANYKBD or KBDTYPE_ANYKBD + KBDTYPE_NECTGL.
 *
 *****************************************************************************/

DWORD INTERNAL
CKbd_InitJapanese(PDK this, PVXDDEVICEFORMAT pdevf)
{
    DWORD dwSubType;
    UINT idKbd;
    DWORD dwRc;

    dwSubType = WrappedGetKeyboardType(1);
    if (HIBYTE(dwSubType) == 0x0D) {    /* NEC PC98 series */

        switch (LOBYTE(dwSubType)) {
        case 1:
        default:
            idKbd = IDDATA_KBD_NEC98;
            this->dwKbdType = DIDEVTYPEKEYBOARD_NEC98;
            dwRc = KBDTYPE_ANYKBD + KBDTYPE_NECTGL;
            break;

        case 4:
            idKbd = IDDATA_KBD_NEC98LAPTOP;
            this->dwKbdType = DIDEVTYPEKEYBOARD_NEC98LAPTOP;
            dwRc = KBDTYPE_ANYKBD + KBDTYPE_NECTGL;
            break;

        case 5:
            idKbd = IDDATA_KBD_NEC98_106;
            this->dwKbdType = DIDEVTYPEKEYBOARD_NEC98106;
            dwRc = KBDTYPE_ANYKBD + KBDTYPE_NECTGL;
            break;
        }

        /*
         *  If the scan code for ESC is 1, then we're on an
         *  NEC98 keyboard that acts AT-like.
         */

        CAssertF(IDDATA_KBD_NEC98_NT - IDDATA_KBD_NEC98 ==
                 IDDATA_KBD_NEC98LAPTOP_NT - IDDATA_KBD_NEC98LAPTOP);
        CAssertF(IDDATA_KBD_NEC98_NT - IDDATA_KBD_NEC98 ==
                 IDDATA_KBD_NEC98_106_NT - IDDATA_KBD_NEC98_106);

        if (MapVirtualKey(VK_ESCAPE, 0) == DIK_ESCAPE) {
            idKbd += IDDATA_KBD_NEC98_NT - IDDATA_KBD_NEC98;
        }

    } else {

        switch (dwSubType) {
        case 0:
            this->dwKbdType = DIDEVTYPEKEYBOARD_PCENH;
            dwRc = KBDTYPE_ENH;
            goto done;                      /* Yuck */

        case 1:
            idKbd = IDDATA_KBD_JAPANAX;
            this->dwKbdType = DIDEVTYPEKEYBOARD_JAPANAX;
            dwRc = KBDTYPE_ANYKBD;
            break;

        case 13:
        case 14:
        case 15:
            idKbd = IDDATA_KBD_J3100;
            this->dwKbdType = DIDEVTYPEKEYBOARD_J3100;
            dwRc = KBDTYPE_ANYKBD;
            break;

        case 4:             /* Rumored to be Epson */
        case 5:             /* Rumored to be Fujitsu */
        case 7:             /* Rumored to be IBMJ */
        case 10:            /* Rumored to be Matsushita */
        case 18:            /* Rumored to be Toshiba */
        default:
            idKbd = IDDATA_KBD_JAPAN106;
            this->dwKbdType = DIDEVTYPEKEYBOARD_JAPAN106;
            dwRc = KBDTYPE_ANYKBD;
            break;
        }
    }

    if( fWinnt )
    {
        /*
         *  ISSUE-2001/03/29-timgill Japanese keyboard assumption needs testing
         *  All Japanese keyboards on NT have toggle keys
         *  Except subtype zero? Needs test
         */
        dwRc = KBDTYPE_ANYKBD + KBDTYPE_NTTGL;
    }

    /*
     *  Now load up the translation table goo.
     */
    pdevf->dwExtra = (UINT_PTR)pvFindResource(g_hinst, idKbd, RT_RCDATA);
    if (pdevf->dwExtra == 0) {
        dwRc = 0;
    }

done:;
    return dwRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | Init |
 *
 *          Initialize the object by establishing the data format
 *          based on the keyboard type.  Anything we don't recognize,
 *          we treat as a PC Enhanced keyboard.
 *
 *  @parm   REFGUID | rguid |
 *
 *          The instance GUID we are being asked to create.
 *
 *****************************************************************************/

HRESULT INTERNAL
CKbd_Init(PDK this, REFGUID rguid)
{
    DWORD dwDevType;
    UINT ib;
    HRESULT hres;
    VXDDEVICEFORMAT devf;
    EnterProc(CKbd_Init, (_ "pG", this, rguid));

#ifdef DEBUG
    /*
     *  Check that the Japan tables aren't messed up.
     */
    {
        UINT idk;

        for (idk = IDDATA_KBD_NEC98; idk <= IDDATA_KBD_J3100; idk++) {
            BYTE rgb[DIKBD_CKEYS];
            HANDLE hrsrc;
            LPBYTE pb;
            ZeroX(rgb);

            /*
             *  Make sure the table exists.
             */
            hrsrc = FindResource(g_hinst, (LPTSTR)(LONG_PTR)idk, RT_RCDATA);
            AssertF(hrsrc);
            pb = LoadResource(g_hinst, hrsrc);

            /*
             *  Walk the table and make sure each thing that exists
             *  in the translation table also exists in our master table.
             *  Also make sure that it isn't a dup with something else
             *  in the same table.
             */

            /*
             *  Note, however, that the JAPAN106 keyboard contains
             *  dups so we can save having to write an entire
             *  translation table.  And then NEC98_NT tables contain
             *  lots of dups out of sheer laziness.
             */

            for (ib = 0; ib < DIKBD_CKEYS; ib++) {
                if (pb[ib]) {
                    AssertF(c_rgktWhich[pb[ib]] & KBDTYPE_ANYKBD);
                    AssertF(fLorFF(idk == IDDATA_KBD_JAPAN106 && ib == 0x73,
                                   rgb[pb[ib]] == 0));
                    rgb[pb[ib]] = 1;
                }
            }
        }
    }
#endif

    this->df.dwSize = cbX(DIDATAFORMAT);
    this->df.dwObjSize = cbX(DIOBJECTDATAFORMAT);
    this->df.dwDataSize = sizeof(KBDSTAT);
    this->df.rgodf = this->rgodf;

    this->dwKbdType = WrappedGetKeyboardType(0);

    /*
     *  Create the object with the most optimistic data format.
     *  This allows apps to access new keys without having to rev DINPUT.
     *
     *  However, leave out the following scan codes because some keyboards
     *  generate them spuriously:
     *
     *  0xB6
     *
     *      If you hold the right shift key and then press an
     *      extended arrow key, then release both, some keyboards
     *      generate the following:
     *
     *          0x36        - right shift down
     *          0xE0 0xB6   - extended right shift up (?)
     *          0xE0 0x4B   - extended left arrow down
     *          0xE0 0xCB   - extended left arrow up
     *          0xE0 0x36   - extended right shift down (?)
     *          0xE6        - right shift up
     *
     *      The stray 0xE0 0x36 needs to be ignored.
     *
     *  0xAA
     *
     *      Same as 0xB6, but with the left shift key.
     *
     *
     */
    for (ib = 0; ib < DIKBD_CKEYS; ib++) {
        if (ib != 0xAA && ib != 0xB6) {
            this->rgodf[ib].pguid = &GUID_Key;
            this->rgodf[ib].dwOfs = ib;
            this->rgodf[ib].dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE(ib);
            AssertF(this->rgodf[ib].dwFlags == 0);
        }
    }
    devf.cObj = DIKBD_CKEYS;

    devf.cbData = cbX(KBDSTAT);
    devf.rgodf = this->rgodf;

    /*
     *  But first a word from our sponsor:  Figure out if this keyboard
     *  needs a translation table.
     */

    devf.dwExtra = 0;               /* Assume no translation */
    if (this->dwKbdType != 7) {     /* Not a yucky Japanese keyboard */
        switch (this->dwKbdType) {
        case DIDEVTYPEKEYBOARD_PCXT:  dwDevType = KBDTYPE_XT;  break;
        case DIDEVTYPEKEYBOARD_PCAT:  dwDevType = KBDTYPE_AT;  break;
        default:
        case DIDEVTYPEKEYBOARD_PCENH: dwDevType = KBDTYPE_ENH; break;
        }
    } else {                        /* Yucky Japanese keyboard */
        dwDevType = CKbd_InitJapanese(this, &devf);
        if (!dwDevType) {
            goto justfail;
        }
    }

    /*
     *  And now a word from our other sponsor:  Figure out the
     *  emulation flags based on the GUID.
     */

    AssertF(GUID_SysKeyboard   .Data1 == 0x6F1D2B61);
    AssertF(GUID_SysKeyboardEm .Data1 == 0x6F1D2B82);
    AssertF(GUID_SysKeyboardEm2.Data1 == 0x6F1D2B83);

    switch (rguid->Data1) {

    default:
    case 0x6F1D2B61:
        AssertF(IsEqualGUID(rguid, &GUID_SysKeyboard));
        AssertF(this->flEmulation == 0);
        break;

    case 0x6F1D2B82:
        AssertF(IsEqualGUID(rguid, &GUID_SysKeyboardEm));
        this->flEmulation = DIEMFL_KBD;
        break;

    case 0x6F1D2B83:
        AssertF(IsEqualGUID(rguid, &GUID_SysKeyboardEm2));
        this->flEmulation = DIEMFL_KBD2;
        break;

    }

    devf.dwEmulation = this->flEmulation;

    //RPF("CKbd_Init: Kbd type: %d, subtype: %d, dwEmulation: %d", GetKeyboardType(0), GetKeyboardType(1), devf.dwEmulation);

    hres = Hel_Kbd_CreateInstance(&devf, &this->pvi);
    if (SUCCEEDED(hres)) {
        UINT cobj;
        BYTE rgbSeen[DIKBD_CKEYS];
        AssertF(this->pvi);
        AssertF(this->df.dwFlags == 0);
        AssertF(this->df.dwNumObjs == 0);

        /*
         *  Japanese keyboards have many-to-one mappings, so
         *  we need to filter out the dups or we end up in big
         *  trouble.
         */
        ZeroX(rgbSeen);

        /*
         *  Now create the real data format.
         *
         *  We shadow this->df.dwNumObjs in cobj so that the compiler
         *  can enregister it.
         *
         *  Note that we filter through the translation table if there
         *  is one.
         */

        cobj = 0;
        for (ib = 0; ib < DIKBD_CKEYS; ib++) {
            BYTE bScan = devf.dwExtra ? ((LPBYTE)devf.dwExtra)[ib] : ib;
            if ((c_rgktWhich[bScan] & dwDevType) && !rgbSeen[bScan]) {
                PODF podf = &this->rgodf[cobj];
                rgbSeen[bScan] = 1;
                podf->pguid = &GUID_Key;
                podf->dwOfs = bScan;
                if (c_rgktWhich[bScan] & dwDevType & (KBDTYPE_NECTGL|KBDTYPE_NTTGL) ) {
                    podf->dwType = DIDFT_TGLBUTTON | DIDFT_MAKEINSTANCE(bScan);
                } else {
                    podf->dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE(bScan);
                }
                AssertF(podf->dwFlags == 0);
                cobj++;
                this->df.dwNumObjs++;
            }
        }

        this->pksPhys = this->pvi->pState;

    } else {
    justfail:;
        hres = E_FAIL;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      CKbd_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Kbd::<constructor>,
               (_ "Gp", riid, ppvObj));

    AssertF(IsEqualGUID(rguid, &GUID_SysKeyboard) ||
            IsEqualGUID(rguid, &GUID_SysKeyboardEm) ||
            IsEqualGUID(rguid, &GUID_SysKeyboardEm2));

    hres = Common_NewRiid(CKbd, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv in case of aggregation */
        PDK this = _thisPv(*ppvObj);

        if (SUCCEEDED(hres = CKbd_Init(this, rguid))) {
        } else {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CKbd_Signature        0x2044424B      /* "KBD " */

Interface_Template_Begin(CKbd)
    Primary_Interface_Template(CKbd, IDirectInputDeviceCallback)
Interface_Template_End(CKbd)

Primary_Interface_Begin(CKbd, IDirectInputDeviceCallback)
    CKbd_GetInstance,
    CDefDcb_GetVersions,
    CKbd_GetDataFormat,
    CKbd_GetObjectInfo,
    CKbd_GetCapabilities,
    CKbd_Acquire,
    CDefDcb_Unacquire,
    CKbd_GetDeviceState,
    CKbd_GetDeviceInfo,
    CDefDcb_GetProperty,
    CDefDcb_SetProperty,
    CDefDcb_SetEventNotification,
    CKbd_SetCooperativeLevel,
    CKbd_RunControlPanel,
    CDefDcb_CookDeviceData,
    CDefDcb_CreateEffect,
    CDefDcb_GetFFConfigKey,
    CDefDcb_SendDeviceData,
    CDefDcb_Poll,
    CDefDcb_GetUsage,
    CDefDcb_MapUsage,
    CDefDcb_SetDIData,
Primary_Interface_End(CKbd, IDirectInputDeviceCallback)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\digenm.c ===
/*****************************************************************************
 *
 *  DIGenM.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Practice generic IDirectInputDevice callback for mouse.
 *
 *  Contents:
 *
 *      CMouse_New
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflMouse

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CMouse, IDirectInputDeviceCallback);

Interface_Template_Begin(CMouse)
    Primary_Interface_Template(CMouse, IDirectInputDeviceCallback)
Interface_Template_End(CMouse)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgodfMouse[] |
 *
 *          Device object data formats for the generic mouse device.
 *          The axes come first, then the buttons.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKEODF(guid, f, type, inst, aspect)                \
    { &GUID_##guid,                                         \
      FIELD_OFFSET(DIMOUSESTATE_INT, f),                        \
      DIDFT_##type | DIDFT_MAKEINSTANCE(inst),              \
      DIDOI_ASPECT##aspect,                                 \
    }                                                       \

/*
 * Warning!  If you change this table, you must adjust the IDS_MOUSEOBJECT
 * table in dinput.rc to match!
 */

DIOBJECTDATAFORMAT c_rgodfMouse[] = {
    MAKEODF( XAxis,            lX,   RELAXIS, 0, POSITION),
    MAKEODF( YAxis,            lY,   RELAXIS, 1, POSITION),
    MAKEODF( ZAxis,            lZ,   RELAXIS, 2, POSITION),
    MAKEODF(Button, rgbButtons[0], PSHBUTTON, 3,  UNKNOWN),
    MAKEODF(Button, rgbButtons[1], PSHBUTTON, 4,  UNKNOWN),
    MAKEODF(Button, rgbButtons[2], PSHBUTTON, 5,  UNKNOWN),
    MAKEODF(Button, rgbButtons[3], PSHBUTTON, 6,  UNKNOWN),
#if (DIRECTINPUT_VERSION == 0x0700)
    MAKEODF(Button, rgbButtons[4], PSHBUTTON, 7,  UNKNOWN),
    MAKEODF(Button, rgbButtons[5], PSHBUTTON, 8,  UNKNOWN),
    MAKEODF(Button, rgbButtons[6], PSHBUTTON, 9,  UNKNOWN),
    MAKEODF(Button, rgbButtons[7], PSHBUTTON,10,  UNKNOWN),
#endif
};

#define c_podfMouseAxes     (&c_rgodfMouse[0])
#define c_podfMouseButtons  (&c_rgodfMouse[3])

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CMouse |
 *
 *          The <i IDirectInputDeviceCallback> object for the generic mouse.
 *
 *  @field  IDirectInputDeviceCalllback | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  LPDIMOUSESTATE_INT | pdmsPhys |
 *
 *          Pointer to physical mouse status information kept down in the
 *          VxD.
 *
 *  @field  POINT | ptPrev |
 *
 *          Location of the mouse at the time we stole it exclusively.
 *
 *  @field  HWND | hwndCaptured |
 *
 *          The window that captured the mouse.
 *
 *  @field  VXDINSTANCE * | pvi |
 *
 *          The DirectInput instance handle.  Even though we manipulate
 *          the flags field, we do not need to mark it volatile because
 *          we modify the flags only when unacquired, whereas the device
 *          driver modifies the flags only when acquired.
 *
 *  @field  UINT | dwAxes |
 *
 *          Number of axes on the mouse.
 *
 *  @field  UINT | dwButtons |
 *
 *          Number of buttons on the mouse.
 *
 *  @field  DWORD | flEmulation |
 *
 *          The emulation flags forced by the application.  If any of
 *          these flags is set (actually, at most one will be set), then
 *          we are an alias device.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          The dynamically-generated data format based on the
 *          mouse type.
 *
 *  @field  DIOBJECTDATAFORMAT | rgodf[] |
 *
 *          Object data format table generated as part of the
 *          <e CMouse.df>.
 *
 *  @comm
 *
 *          It is the caller's responsibility to serialize access as
 *          necessary.
 *
 *****************************************************************************/

typedef struct CMouse {

    /* Supported interfaces */
    IDirectInputDeviceCallback dcb;

    LPDIMOUSESTATE_INT pdmsPhys;            /* Physical mouse state */

    POINT ptPrev;
    HWND hwndCapture;

    VXDINSTANCE *pvi;

    UINT dwAxes;
    UINT dwButtons;
    DWORD flEmulation;

    DIDATAFORMAT df;
    DIOBJECTDATAFORMAT rgodf[cA(c_rgodfMouse)];

} CMouse, DM, *PDM;

#define ThisClass CMouse
#define ThisInterface IDirectInputDeviceCallback
#define riidExpected &IID_IDirectInputDeviceCallback

/*****************************************************************************
 *
 *      CMouse::QueryInterface      (from IUnknown)
 *      CMouse::AddRef              (from IUnknown)
 *      CMouse::Release             (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CMouse)
Default_AddRef(CMouse)
Default_Release(CMouse)

#else

#define CMouse_QueryInterface   Common_QueryInterface
#define CMouse_AddRef           Common_AddRef
#define CMouse_Release          Common_Release

#endif

#define CMouse_QIHelper         Common_QIHelper
#define CMouse_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CMouse_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CMouse_Finalize(PV pvObj)
{
    PDM this = pvObj;

    if (this->pvi) {
        HRESULT hres;
        hres = Hel_DestroyInstance(this->pvi);
        AssertF(SUCCEEDED(hres));
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | GetPhysicalPosition |
 *
 *          Read the physical mouse position into <p pmstOut>.
 *
 *          Note that it doesn't matter if this is not atomic.
 *          If a mouse motion occurs while we are reading it,
 *          we will get a mix of old and new data.  No big deal.
 *
 *  @parm   PDM | this |
 *
 *          The object in question.
 *
 *  @parm   LPDIMOUSESTATE_INT | pdmsOut |
 *
 *          Where to put the mouse position.
 *  @returns
 *          None.
 *
 *****************************************************************************/

void INLINE
CMouse_GetPhysicalPosition(PDM this, LPDIMOUSESTATE_INT pdmsOut)
{
    AssertF(this->pdmsPhys);
    *pdmsOut = *this->pdmsPhys;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | Acquire |
 *
 *          Tell the device driver to begin data acquisition.
 *          Give the device driver the current mouse button states
 *          in case it needs them.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_Acquire(PDICB pdcb)
{
    HRESULT hres;
    PDM this;
    VXDDWORDDATA vdd;
    DWORD mef;
    EnterProcI(IDirectInputDeviceCallback::Mouse::Acquire,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);

    vdd.pvi = this->pvi;
    vdd.dw = 0;

    /*
     *  Collect information about which buttons are down.
     */
    mef = 0;
    if (GetAsyncKeyState(VK_LBUTTON) < 0) {
        mef |= MOUSEEVENTF_LEFTUP;
        vdd.dw |= 0x80;
    }
    if (GetAsyncKeyState(VK_RBUTTON) < 0) {
        mef |= MOUSEEVENTF_RIGHTUP;
        vdd.dw |= 0x8000;
    }
    if (GetAsyncKeyState(VK_MBUTTON) < 0) {
        mef |= MOUSEEVENTF_MIDDLEUP;
        vdd.dw |= 0x800000;
    }

    /*
     *  HACKHACK - This, strictly speaking, belongs in dihel.c,
     *  but we need to maintain some state, and it's easier to
     *  put the state in our own object.
     */

    /*
     *  A bit of work needs to be done at ring 3 now.
     */
    if (this->pvi->fl & VIFL_CAPTURED) {
        RECT rc;

        /*
         *  Hide the mouse cursor (for compatibility with NT emulation)
         */
        GetCursorPos(&this->ptPrev);
        GetWindowRect(this->hwndCapture, &rc);
        SetCursorPos((rc.left + rc.right) >> 1,
                     (rc.top + rc.bottom) >> 1);
        ShowCursor(0);

	    if (!(this->pvi->fl & VIFL_EMULATED)) {
			/*
			 *  Force all mouse buttons up from USER's point of view
			 *  to avoid "stuck mouse button" problems.  However, don't
			 *  force a button up unless it is actually down.
			 */
			if (mef) {
				mouse_event(mef, 0, 0, 0, 0);
			}
		}
    }

    if (!(this->pvi->fl & VIFL_EMULATED)) {
        hres = IoctlHw(IOCTL_MOUSE_INITBUTTONS, &vdd.dw, cbX(vdd.dw), 0, 0);
    } else {
      #ifdef USE_WM_INPUT
        if( g_fRawInput ) {
            hres = CDIRaw_Mouse_InitButtons();
        }
      #endif
        hres = CEm_Mouse_InitButtons(&vdd);
    }

    AssertF(SUCCEEDED(hres));

    hres = S_FALSE;                 /* Please finish for me */

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | Unacquire |
 *
 *          Tell the device driver to stop data acquisition.
 *
 *          It is the caller's responsibility to call this only
 *          when the device has been acquired.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_Unacquire(PDICB pdcb)
{
    HRESULT hres;
    PDM this;
  #ifdef WANT_TO_FIX_MANBUG43879
    DWORD mef;
  #endif
    
    EnterProcI(IDirectInputDeviceCallback::Mouse::Unacquire,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);

  #ifdef WANT_TO_FIX_MANBUG43879  
    /*
     *  Collect information about which buttons are down.
     */
    mef = 0;
    if (GetAsyncKeyState(VK_LBUTTON) < 0) {
        mef |= MOUSEEVENTF_LEFTUP;
    }
    if (GetAsyncKeyState(VK_RBUTTON) < 0) {
        mef |= MOUSEEVENTF_RIGHTUP;
    }
    if (GetAsyncKeyState(VK_MBUTTON) < 0) {
        mef |= MOUSEEVENTF_MIDDLEUP;
    }

    if (this->pvi->fl & VIFL_FOREGROUND) {
        /*
         *  Force all mouse buttons up from USER's point of view
         *  to avoid "stuck mouse button" problems.  However, don't
         *  force a button up unless it is actually down.
         *  This could happen if DInput loses UP events due to slow
         *  low-level hook. See bug: 43879.
         */
        if (mef) {
            mouse_event(mef, 0, 0, 0, 0);
        }
    }
  #endif

    /*
     *  HACKHACK - This is the corresponding half of the HACKHACK
     *  in CMouse_Acquire.
     */
  
    /*
     *  A bit of work needs to be done at ring 3 now.
     */
    if (this->pvi->fl & VIFL_CAPTURED) {
        RECT rcDesk;
        RECT rcApp;

        /*
         *  Reposition and restore the mouse cursor
         *  (for compatibility with NT emulation)
         *
         *  Do not reposition the mouse cursor if we lost to a
         *  window that covers the screen.  Otherwise, our
         *  repositioning will nuke the screen saver.
         */
        GetWindowRect(GetDesktopWindow(), &rcDesk);
        GetWindowRect(GetForegroundWindow(), &rcApp);
        SubtractRect(&rcDesk, &rcDesk, &rcApp);
        if (!IsRectEmpty(&rcDesk)) {
            SetCursorPos(this->ptPrev.x, this->ptPrev.y);
        }
        ShowCursor(1);
    }

    hres = S_FALSE;
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetInstance |
 *
 *          Obtains the DirectInput instance handle.
 *
 *  @parm   OUT PPV | ppvi |
 *
 *          Receives the instance handle.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetInstance(PDICB pdcb, PPV ppvi)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetInstance, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    *ppvi = (PV)this->pvi;
    hres = S_OK;

    ExitOleProcPpvR(ppvi);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetDataFormat |
 *
 *          Obtains the device's preferred data format.
 *
 *  @parm   OUT LPDIDEVICEFORMAT * | ppdf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdf)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetDataFormat,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppdf = &this->df;
    hres = S_OK;

    ExitOleProcPpvR(ppdf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetDeviceInfo |
 *
 *          Obtain general information about the device.
 *
 *  @parm   OUT LPDIDEVICEINSTANCEW | pdiW |
 *
 *          <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *          Secret convenience:  <e DEVICEINSTANCE.guidProduct> is equal
 *          to <e DEVICEINSTANCE.guidInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW pdiW)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetDeviceInfo,
               (_ "pp", pdcb, pdiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEINSTANCEW(pdiW->dwSize));

    AssertF(IsEqualGUID(&GUID_SysMouse   , &pdiW->guidInstance) ||
            IsEqualGUID(&GUID_SysMouseEm , &pdiW->guidInstance) ||
            IsEqualGUID(&GUID_SysMouseEm2, &pdiW->guidInstance));
    pdiW->guidProduct = GUID_SysMouse;

    pdiW->dwDevType = MAKE_DIDEVICE_TYPE(DIDEVTYPE_MOUSE,
                                         DIDEVTYPEMOUSE_UNKNOWN);

    LoadStringW(g_hinst, IDS_STDMOUSE, pdiW->tszProductName, cA(pdiW->tszProductName));
    LoadStringW(g_hinst, IDS_STDMOUSE, pdiW->tszInstanceName, cA(pdiW->tszInstanceName));

    hres = S_OK;

    ExitOleProcR();
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | GetProperty |
 *
 *          Get a mouse device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  Granularity is only supported for wheels and then only if the value 
     *  could be determined (if not g_lWheelGranularity is zero).
     */
    if( ppropi->pguid == DIPROP_GRANULARITY &&
        ppropi->dwDevType == (DIDFT_RELAXIS | DIDFT_MAKEINSTANCE(2)) )
    {
        LPDIPROPDWORD pdipdw = (PV)pdiph;
        pdipdw->dwData = g_lWheelGranularity? (DWORD)g_lWheelGranularity : 120;
        hres = S_OK;
    } else {
        hres = E_NOTIMPL;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | GetCapabilities |
 *
 *          Get mouse device capabilities.
 *
 *  @parm   LPDIDEVCAPS | pdc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdc)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetCapabilities,
               (_ "pp", pdcb, pdc));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    pdc->dwDevType = MAKE_DIDEVICE_TYPE(DIDEVTYPE_MOUSE,
                                        DIDEVTYPEMOUSE_UNKNOWN);
    pdc->dwFlags = DIDC_ATTACHED;
    if (this->flEmulation) {
        pdc->dwFlags |= DIDC_ALIAS;
    }

    pdc->dwAxes = this->dwAxes;
    pdc->dwButtons = this->dwButtons;
    //  Remove this assertion for 32650
    //  AssertF(pdc->dwPOVs == 0);

    hres = S_OK;
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetDeviceState |
 *
 *          Obtains the state of the mouse device.
 *
 *          It is the caller's responsibility to have validated all the
 *          parameters and ensure that the device has been acquired.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Mouse data in the preferred data format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetDeviceState(PDICB pdcb, LPVOID pvData)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetDeviceState,
               (_ "pp", pdcb, pvData));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pdmsPhys);

    if (this->pvi->fl & VIFL_ACQUIRED) {
        CMouse_GetPhysicalPosition(this, pvData);
        hres = S_OK;
    } else {
        hres = DIERR_INPUTLOST;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetObjectInfo |
 *
 *          Obtain the friendly name of an object, passwed by index
 *          into the preferred data format.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          fields have already been filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                                 LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetObjectInfo,
               (_ "pxp", pdcb, ppropi->iobj, pdidoiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

#ifdef HAVE_DIDEVICEOBJECTINSTANCE_DX5
    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEW(pdidoiW->dwSize));
#endif
    if (ppropi->iobj < this->df.dwNumObjs) {
        AssertF(this->rgodf == this->df.rgodf);
        AssertF(ppropi->dwDevType == this->rgodf[ppropi->iobj].dwType);

        AssertF(DIDFT_GETTYPE(ppropi->dwDevType) == DIDFT_RELAXIS ||
                DIDFT_GETTYPE(ppropi->dwDevType) == DIDFT_PSHBUTTON);


        LoadStringW(g_hinst, IDS_MOUSEOBJECT +
                             DIDFT_GETINSTANCE(ppropi->dwDevType),
                             pdidoiW->tszName, cA(pdidoiW->tszName));

        /*
         *  We do not support force feedback on mice, so
         *  there are no FF flags to report.
         */
        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | SetCooperativeLevel |
 *
 *          Notify the device of the cooperative level.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);

#ifdef USE_SLOW_LL_HOOKS
    AssertF(DIGETEMFL(this->pvi->fl) == 0 ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_MOUSE ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_MOUSE2);
#else
    AssertF(DIGETEMFL(this->pvi->fl) == 0 ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_MOUSE2);
#endif
    /*
     *  Even though we can do it, we don't let the app
     *  get background exclusive access.  As with the keyboard,
     *  there is nothing that technically prevents us from
     *  supporting it; we just don't feel like it because it's
     *  too dangerous.
     */

    /*
     *  VxD and LL (emulation 1) behave the same, so we check
     *  if it's "not emulation 2".
     */

    if (!(this->pvi->fl & DIMAKEEMFL(DIEMFL_MOUSE2))) {

        if (dwFlags & DISCL_EXCLUSIVE) {
            if (dwFlags & DISCL_FOREGROUND) {
              #ifdef WANT_TO_FIX_MANBUG43879
                this->pvi->fl |= VIFL_FOREGROUND;
              #endif
              
                this->pvi->fl |= VIFL_CAPTURED;
                hres = S_OK;
            } else {                /* Disallow exclusive background */
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("Exclusive background mouse access disallowed"));
                hres = E_NOTIMPL;
            }
        } else {
          #ifdef WANT_TO_FIX_MANBUG43879
            if (dwFlags & DISCL_FOREGROUND) {
                this->pvi->fl |= VIFL_FOREGROUND;
            }
          #endif
          
            this->pvi->fl &= ~VIFL_CAPTURED;
            hres = S_OK;
        }

    } else {
        /*
         *  Emulation 2 supports only exclusive foreground.
         */
        if ((dwFlags & (DISCL_EXCLUSIVE | DISCL_FOREGROUND)) ==
                       (DISCL_EXCLUSIVE | DISCL_FOREGROUND)) {
          #ifdef WANT_TO_FIX_MANBUG43879
            this->pvi->fl |= VIFL_FOREGROUND;
          #endif
            this->pvi->fl |= VIFL_CAPTURED;
            hres = S_OK;
        } else {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("Mouse access must be exclusive foreground in Emulation 2."));
            hres = E_NOTIMPL;
        }
    }

    if (SUCCEEDED(hres)) {
        this->hwndCapture = hwnd;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | RunControlPanel |
 *
 *          Run the mouse control panel.
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          The owner window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszMouse[] = TEXT("mouse");

#pragma END_CONST_DATA

STDMETHODIMP
CMouse_RunControlPanel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Mouse::RunControlPanel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    hres = hresRunControlPanel(c_tszMouse);

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method UINT | CMouse | NumAxes |
 *
 *          Determine the number of mouse axes.
 *
 *          On Windows NT, we can use the new <c SM_MOUSEWHEELPRESENT>
 *          system metric.  On Windows 95, we have to hunt for the
 *          Magellan window (using the mechanism documented in the
 *          Magellan SDK).
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszMouseZClass[] = TEXT("MouseZ");
TCHAR c_tszMouseZTitle[] = TEXT("Magellan MSWHEEL");
TCHAR c_tszMouseZActive[] = TEXT("MSH_WHEELSUPPORT_MSG");

#pragma END_CONST_DATA

BOOL INLINE
CMouse_IsMagellanWheel(void)
{
    if( fWinnt )
        return FALSE;
    else {
        HWND hwnd = FindWindow(c_tszMouseZClass, c_tszMouseZTitle);
        return hwnd && SendMessage(hwnd, RegisterWindowMessage(c_tszMouseZActive), 0, 0);
    }
}

#ifndef SM_MOUSEWHEELPRESENT
#define SM_MOUSEWHEELPRESENT            75
#endif

UINT INLINE
CMouse_NumAxes(void)
{
    UINT dwAxes;

    if (GetSystemMetrics(SM_MOUSEWHEELPRESENT) || CMouse_IsMagellanWheel()) {
        dwAxes = 3;
    } else {
        dwAxes = 2;
    }

    if (dwAxes == 2) {
        //Should avoid rebuilding too frequently.
        DIHid_BuildHidList(FALSE);

        DllEnterCrit();

        if (g_phdl) {
            int ihdi;
            for (ihdi = 0; ihdi < g_phdl->chdi; ihdi++) {
                if (dwAxes < g_phdl->rghdi[ihdi].osd.uiAxes) {
                    dwAxes = g_phdl->rghdi[ihdi].osd.uiAxes;
                }
            }
        }
        DllLeaveCrit();
    }

    return dwAxes;
}

UINT INLINE
CMouse_NumButtons(DWORD dwAxes)
{
    UINT dwButtons;

    dwButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);

#ifndef WINNT
  #ifdef HID_SUPPORT
    {
        /*
         *  ISSUE-2001/03/29-timgill Should try to avoid rebuilding Hid List too frequently.
         */
        DIHid_BuildHidList(FALSE);

        DllEnterCrit();

        if (g_phdl) {
            int ihdi;
            for (ihdi = 0; ihdi < g_phdl->chdi; ihdi++) {
                if (dwButtons < g_phdl->rghdi[ihdi].osd.uiButtons) {
                    dwButtons = g_phdl->rghdi[ihdi].osd.uiButtons;
                }
            }
        }
        DllLeaveCrit();
    }
  #endif
#endif

#if (DIRECTINPUT_VERSION >= 0x0700)
    if( dwButtons >= 8 ) {
        dwButtons = 8;
#else
    if( dwButtons >= 4 ) {
        dwButtons = 4;
#endif
    }
    else if (dwAxes == 3 && dwButtons < 3) {
        /*
         *  HACK FOR MAGELLAN!
         *
         *  They return 2 from GetSystemMetrics(SM_CMOUSEBUTTONS).
         *  So if we see a Z-axis, then assume that
         *  there is also a third button.
         */
        dwButtons = 3;
    }

    return dwButtons;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | AddObjects |
 *
 *          Add a number of objects to the device format.
 *
 *  @parm   LPCDIOBJECTDATAFORMAT | rgodf |
 *
 *          Array of objects to be added.
 *
 *  @parm   UINT | cObj |
 *
 *          Number of objects to add.
 *
 *****************************************************************************/

void INTERNAL
CMouse_AddObjects(PDM this, LPCDIOBJECTDATAFORMAT rgodf, UINT cObj)
{
    UINT iodf;
    EnterProc(CMouse_AddObjects, (_ "pxx", this, rgodf, cObj));

    for (iodf = 0; iodf < cObj; iodf++) {
        this->rgodf[this->df.dwNumObjs++] = rgodf[iodf];
    }
    AssertF(this->df.dwNumObjs <= cA(this->rgodf));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | Init |
 *
 *          Initialize the object by establishing the data format
 *          based on the mouse type.
 *
 *          Code for detecting the IntelliMouse (formerly known as
 *          Magellan) pointing device is swiped from zmouse.h.
 *
 *  @parm   REFGUID | rguid |
 *
 *          The instance GUID we are being asked to create.
 *
 *****************************************************************************/

HRESULT INTERNAL
CMouse_Init(PDM this, REFGUID rguid)
{
    HRESULT hres;
    VXDDEVICEFORMAT devf;
    EnterProc(CMouse_Init, (_ "pG", this, rguid));

    this->df.dwSize = cbX(DIDATAFORMAT);
    this->df.dwObjSize = cbX(DIOBJECTDATAFORMAT);
    this->df.dwDataSize = cbX(DIMOUSESTATE_INT);
    this->df.rgodf = this->rgodf;
    AssertF(this->df.dwFlags == 0);
    AssertF(this->df.dwNumObjs == 0);

    /*
     *  Need to know early if we have a Z-axis, so we can disable
     *  the Z-wheel if it doesn't exist.
     *
     *  Note that this disabling needs to be done only on Win95.
     *  Win98 and NT4 have native Z-axis support, so there is
     *  nothing bogus that needs to be hacked.
     */
    this->dwAxes = CMouse_NumAxes();
    devf.dwExtra = this->dwAxes;
    if (this->dwAxes < 3) {
        DWORD dwVer = GetVersion();
        if ((LONG)dwVer >= 0 ||
            MAKEWORD(HIBYTE(LOWORD(dwVer)), LOBYTE(dwVer)) >= 0x040A) {
            devf.dwExtra = 3;
        }
    }
    CMouse_AddObjects(this, c_podfMouseAxes, this->dwAxes);

    /*
     *  Create the object with the most optimistic data format.
     *  This is important, because DINPUT.VXD builds the
     *  data format only once, and we need to protect ourselves against
     *  the user going into Control Panel and enabling the Z-Wheel
     *  after DINPUT.VXD has already initialized.
     */

    devf.cbData = cbX(DIMOUSESTATE_INT);
    devf.cObj = cA(c_rgodfMouse);
    devf.rgodf = c_rgodfMouse;

    /*
     *  But first a word from our other sponsor:  Figure out the
     *  emulation flags based on the GUID.
     */

    AssertF(GUID_SysMouse   .Data1 == 0x6F1D2B60);
    AssertF(GUID_SysMouseEm .Data1 == 0x6F1D2B80);
    AssertF(GUID_SysMouseEm2.Data1 == 0x6F1D2B81);

    switch (rguid->Data1) {

    default:
    case 0x6F1D2B60:
        AssertF(IsEqualGUID(rguid, &GUID_SysMouse));
        AssertF(this->flEmulation == 0);
        break;

    case 0x6F1D2B80:
        AssertF(IsEqualGUID(rguid, &GUID_SysMouseEm));
        this->flEmulation = DIEMFL_MOUSE;
        break;

    case 0x6F1D2B81:
        AssertF(IsEqualGUID(rguid, &GUID_SysMouseEm2));
        this->flEmulation = DIEMFL_MOUSE2;
        break;

    }

    devf.dwEmulation = this->flEmulation;

    hres = Hel_Mouse_CreateInstance(&devf, &this->pvi);
    if (SUCCEEDED(hres)) {

        AssertF(this->pvi);
        this->pdmsPhys = this->pvi->pState;

        this->dwButtons = CMouse_NumButtons( this->dwAxes );

        CMouse_AddObjects(this, c_podfMouseButtons, this->dwButtons);

        hres = S_OK;

    } else {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("Mismatched version of dinput.vxd"));
        hres = E_FAIL;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      CMouse_New       (constructor)
 *
 *      Fail the create if the machine has no mouse.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Mouse::<constructor>,
               (_ "Gp", riid, ppvObj));

    AssertF(IsEqualGUID(rguid, &GUID_SysMouse) ||
            IsEqualGUID(rguid, &GUID_SysMouseEm) ||
            IsEqualGUID(rguid, &GUID_SysMouseEm2));

    if (GetSystemMetrics(SM_MOUSEPRESENT)) {
        hres = Common_NewRiid(CMouse, punkOuter, riid, ppvObj);

        if (SUCCEEDED(hres)) {
            /* Must use _thisPv in case of aggregation */
            PDM this = _thisPv(*ppvObj);

            if (SUCCEEDED(hres = CMouse_Init(this, rguid))) {
            } else {
                Invoke_Release(ppvObj);
            }

        }
    } else {
        RPF("Warning: System does not have a mouse");
        /*
         *  Since we by-passed the parameter checks and we failed to create 
         *  the new interface, try to zero the pointer now.
         */
        if (!IsBadWritePtr(ppvObj, sizeof(UINT_PTR) )) 
        {
            *(PUINT_PTR)ppvObj = 0;
        }
        hres = DIERR_DEVICENOTREG;
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CMouse_Signature        0x53554F4D      /* "MOUS" */

Primary_Interface_Begin(CMouse, IDirectInputDeviceCallback)
    CMouse_GetInstance,
    CDefDcb_GetVersions,
    CMouse_GetDataFormat,
    CMouse_GetObjectInfo,
    CMouse_GetCapabilities,
    CMouse_Acquire,
    CMouse_Unacquire,
    CMouse_GetDeviceState,
    CMouse_GetDeviceInfo,
    CMouse_GetProperty,
    CDefDcb_SetProperty,
    CDefDcb_SetEventNotification,
    CMouse_SetCooperativeLevel,
    CMouse_RunControlPanel,
    CDefDcb_CookDeviceData,
    CDefDcb_CreateEffect,
    CDefDcb_GetFFConfigKey,
    CDefDcb_SendDeviceData,
    CDefDcb_Poll,
    CDefDcb_GetUsage,
    CDefDcb_MapUsage,
    CDefDcb_SetDIData,
Primary_Interface_End(CMouse, IDirectInputDeviceCallback)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\digenj.c ===
/*****************************************************************************
 *
 *  DIGenJ.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Generic IDirectInputDevice callback for joystick.
 *
 *  Contents:
 *
 *      CJoy_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoy

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CJoy_New!
 *
 *****************************************************************************/

Primary_Interface(CJoy, IDirectInputDeviceCallback);

/*****************************************************************************
 *
 *      Macro "lookup tables".
 *
 *      iJoyStateAxis# converts an axis name to an axis number in the
 *      DIJOYSTATE structure.
 *
 *      ibJoyStateAxis# converts the name to an offset.
 *
 *      Note that the extra axes in DIJOYSTATE2 are arranged in relative
 *      positions just like a DIJOYSTATE.  We will exploit this
 *      arrangement frequently.
 *
 *****************************************************************************/

#define iJoyStateAxisX      0
#define iJoyStateAxisY      1
#define iJoyStateAxisZ      2
#define iJoyStateAxisRx     3
#define iJoyStateAxisRy     4
#define iJoyStateAxisRz     5
#define iJoyStateAxisS0     6
#define iJoyStateAxisS1     7
#define cJoyStateAxisMax    8

#define iJoyStateAxisSlider iJoyStateAxisS0     /* Hack for macros */

#define cJoyStateAxis       8

#define iobjPositions       (cJoyStateAxis * 0)
#define iobjVelocities      (cJoyStateAxis * 1)
#define iobjAccels          (cJoyStateAxis * 2)
#define iobjForces          (cJoyStateAxis * 3)

#define cJoyStateAxisTotal  (cJoyStateAxis * 4)

#define ibJoyStateAxisX      (iJoyStateAxisX  * cbX(LONG))
#define ibJoyStateAxisY      (iJoyStateAxisY  * cbX(LONG))
#define ibJoyStateAxisZ      (iJoyStateAxisZ  * cbX(LONG))
#define ibJoyStateAxisRx     (iJoyStateAxisRx * cbX(LONG))
#define ibJoyStateAxisRy     (iJoyStateAxisRy * cbX(LONG))
#define ibJoyStateAxisRz     (iJoyStateAxisRz * cbX(LONG))
#define ibJoyStateAxisS0     (iJoyStateAxisS0 * cbX(LONG))
#define ibJoyStateAxisS1     (iJoyStateAxisS1 * cbX(LONG))

#define ibJoyStateAxisSlider ibJoyStateAxisS0    /* Hack for macros */

#define cJoyStatePOVTotal   4
#define cJoyStateButtonTotal 128

#define cJoyStateObjTotal   (cJoyStateAxisTotal + \
                             cJoyStatePOVTotal + \
                             cJoyStateButtonTotal)

#if 0
#define c_podfJoyXY         (&c_rgodfJoy[iJoyStateAxisX])
#define c_podfJoyZ          (&c_rgodfJoy[iJoyStateAxisZ])
#define c_podfJoyR          (&c_rgodfJoy[iJoyStateAxisRz])
#define c_podfJoyU          (&c_rgodfJoy[iJoyStateAxisS0])
#define c_podfJoyV          (&c_rgodfJoy[iJoyStateAxisS1])
#define c_podfJoyButtons    (&c_rgodfJoy[cJoyStateAxisMax])
#define c_podfJoyPOV        (&c_rgodfJoy[cJoyStateAxisMax+32])
#endif

/*
 *  The worst-case data format for joysticks.  (Christmas-tree)
 */
VXDAXISCAPS c_vacMax = {
    JOYPF_ALLCAPS | JOYPF_POSITION,         /*  dwPos   */
    JOYPF_ALLCAPS | JOYPF_VELOCITY,         /*  dwVel   */
    JOYPF_ALLCAPS | JOYPF_ACCELERATION,     /*  dwAccel */
    JOYPF_ALLCAPS | JOYPF_FORCE,            /*  dwForce */
};

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | ibJoyStateAxisFromPosAxis |
 *
 *          Returns the offset of the <p iPosAxis>'th joystick axis
 *          in the <t DIJOYSTATE> structure.
 *
 *  @parm   UINT | uiStateAxis |
 *
 *          The index of the requested <t JOYPOS> axis.
 *          X, Y, Z, R, U and V are respectively zero through five.
 *
 *          Remember that we map R to Rz, U to Slider0 and V to Slider1.
 *
 *  @returns
 *
 *          The offset relative to the structure.
 *
 *****************************************************************************/

const int c_rgibJoyStateAxisFromPosAxis[6] = {
    FIELD_OFFSET(DIJOYSTATE, lX),           /* X */
    FIELD_OFFSET(DIJOYSTATE, lY),           /* Y */
    FIELD_OFFSET(DIJOYSTATE, lZ),           /* Z */
    FIELD_OFFSET(DIJOYSTATE, lRz),          /* R */
    FIELD_OFFSET(DIJOYSTATE, rglSlider[0]), /* U */
    FIELD_OFFSET(DIJOYSTATE, rglSlider[1]), /* V */
};

UINT INLINE
ibJoyStateAxisFromPosAxis(UINT uiPosAxis)
{
    AssertF(uiPosAxis < cA(c_rgibJoyStateAxisFromPosAxis));
    return c_rgibJoyStateAxisFromPosAxis[uiPosAxis];
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | iJoyStateAxisFromPosAxis |
 *
 *          Returns the index of the <p iPosAxis>'th joystick axis
 *          in the <t DIJOYSTATE> structure.
 *
 *  @parm   UINT | uiStateAxis |
 *
 *          The index of the requested <t JOYPOS> axis.
 *          X, Y, Z, R, U and V are respectively zero through five.
 *
 *          Remember that we map R to Rz, U to Slider0 and V to Slider1.
 *
 *  @returns
 *
 *          The offset relative to the structure.
 *
 *****************************************************************************/

const int c_rgiJoyStateAxisFromPosAxis[6] = {
    iJoyStateAxisX,             /* X */
    iJoyStateAxisY,             /* Y */
    iJoyStateAxisZ,             /* Z */
    iJoyStateAxisRz,            /* R */
    iJoyStateAxisS0,            /* U */
    iJoyStateAxisS1,            /* V */
};

UINT INLINE
iJoyStateAxisFromPosAxis(UINT uiPosAxis)
{
    AssertF(uiPosAxis < cA(c_rgiJoyStateAxisFromPosAxis));
    return c_rgiJoyStateAxisFromPosAxis[uiPosAxis];
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | ibJoyStateAxisFromStateAxis |
 *
 *          Returns the offset of the <p iStateAxis>'th joystick axis
 *          in the <t DIJOYSTATE> structure.
 *
 *  @parm   UINT | uiStateAxis |
 *
 *          The index of the requested <t JOYSTATE> axis.
 *          The first eight axes live at the top, and the
 *          later ones (corresponding to velocity, etc.)
 *          live down at the bottom.
 *
 *  @returns
 *
 *          The offset relative to the structure.
 *
 *****************************************************************************/

const int c_rgibJoyStateAxisFromStateAxis[cJoyStateAxisMax] = {
    FIELD_OFFSET(DIJOYSTATE, lX),           /* X  */
    FIELD_OFFSET(DIJOYSTATE, lY),           /* Y  */
    FIELD_OFFSET(DIJOYSTATE, lZ),           /* Z  */
    FIELD_OFFSET(DIJOYSTATE, lRx),          /* Rx */
    FIELD_OFFSET(DIJOYSTATE, lRy),          /* Ry */
    FIELD_OFFSET(DIJOYSTATE, lRz),          /* Rz */
    FIELD_OFFSET(DIJOYSTATE, rglSlider[0]), /* S0 */
    FIELD_OFFSET(DIJOYSTATE, rglSlider[1]), /* S1 */
};

UINT INLINE
ibJoyStateAxisFromStateAxis(UINT uiStateAxis)
{
    AssertF(uiStateAxis < cA(c_rgibJoyStateAxisFromStateAxis));
    return c_rgibJoyStateAxisFromStateAxis[uiStateAxis];
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | iJoyPosAxisFromStateAxis |
 *
 *          Convert a <t DIJOYSTATE> axis number back to
 *          a <t JOYPOS> axis number.
 *
 *  @parm   UINT | uiPosAxis |
 *
 *          The index of the requested <t JOYSTATE> axis.
 *
 *  @returns
 *
 *          The corresponding <t JOYPOS> axis number.
 *
 *****************************************************************************/

const int c_rgiJoyPosAxisFromStateAxis[8] = {
    iJoyPosAxisX,               /* X    */
    iJoyPosAxisY,               /* Y    */
    iJoyPosAxisZ,               /* Z    */
    -1,                         /* Rx   */
    -1,                         /* Ry   */
    iJoyPosAxisR,               /* Rz   */
    iJoyPosAxisU,               /* S0   */
    iJoyPosAxisV,               /* S1   */
};

UINT INLINE
iJoyPosAxisFromStateAxis(UINT uiStateAxis)
{
    AssertF(uiStateAxis < cA(c_rgiJoyPosAxisFromStateAxis));
    return c_rgiJoyPosAxisFromStateAxis[uiStateAxis];
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @topic  Cooking Joystick Data |
 *
 *          We always fetch joystick data raw, then cook it before
 *          returning it to the application.
 *
 *          If the app is in "raw" mode, then we don't cook anything.
 *
 *          If the app is in "cooked" mode, then things get interesting.
 *
 *          If there is `centered' cooking, then the center point of the
 *          joystick is reported in the center of the virtual range.
 *
 *
 *          Joystick properties work like this:
 *
 *          <c DIPROP_BUFFERSIZE> - No special semantics.
 *
 *          <c DIPROP_CALIBRATIONMODE> - Specifies whether
 *          cooked or raw data should be returned.  If raw data
 *          is requested, then most other properties have no effect.
 *
 *          The default is cooked.
 *
 *          <c DIPROP_GRANULARITY> - No special semantics.
 *
 *          <c DIPROP_RANGE> - This returns the range of values that
 *          can be returned by the axis.  For joysticks, this is a
 *          read/write property.  (For most devices, it is a read-only
 *          property.)  If you change the property, it affects only
 *          your device instance; it does not affect the ranges of other
 *          devices.
 *
 *          If the axis is in calibration mode, then setting this value
 *          has no immediate effect.
 *
 *          We also define a few new properties:
 *
 *          <c DIPROP_CENTER> - This returns the joystick center (neutral)
 *          position.  In other words, this is the position that
 *          DirectInput returns when the user has released the joystick
 *          and allowed it to self-center.
 *          When a joystick device is created, the center position is
 *          initially set to midway between the lower and
 *          upper bounds of the range.  An application may change the
 *          center position (although I don't see any reason why).
 *
 *          If the axis is in calibration mode, then setting this value
 *          has no immediate effect.
 *
 *          <c DIPROP_DEADZONE> - This returns the size of the joystick
 *          dead zone, as a percentage of total range.
 *
 *          If the axis is in calibration mode, then setting this value
 *          has no immediate effect.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CJoy |
 *
 *          The <i IDirectInputDeviceCallback> object for the
 *          generic joystick.
 *
 *  @field  IDirectInputDeviceCallback | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  PDIJOYSTATE2 | pjsPhys |
 *
 *          Pointer to physical joystick status information kept down in the
 *          VxD.
 *
 *  @field  UINT | idJoy |
 *
 *          Joystick identifier for <f joyGetPosEx> and friends.
 *
 *  @field  DWORD | dwPOVGranularity |
 *
 *          Granularity of the POV control.
 *
 *  @field  HWND | hwnd |
 *
 *          The window which we have subclassed in order to watch
 *          for joystick reconfiguration messages.
 *
 *  @field  HKEY | hkType |
 *
 *          The joystick type key opened with <c MAXIMUM_ALLOWED> access.
 *
 *  @field  VXDINSTANCE * | pvi |
 *
 *          The DirectInput instance handle.
 *
 *  @field  DIDEVCAPS | dc |
 *
 *          Device capability information.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          The dynamically-generated data format based on the
 *          joystick type.
 *
 *  @field  JOYRANGECONVERT | rgjrc |
 *
 *          Range conversion structures for each axis.
 *
 *  @field  DIJOYCONFIG | cfg |
 *
 *          Joystick configuration information.
 *
 *  @field  DIJOYTYPEINFO | typi |
 *
 *          Joystick type information.
 *
 *  @comm
 *
 *          It is the caller's responsibility to serialize access as
 *          necessary.
 *
 *****************************************************************************/

typedef struct CJoy {

    /* Supported interfaces */
    IDirectInputDeviceCallback dcb;

    LPDIJOYSTATE2 pjsPhys;

    UINT idJoy;
    DWORD dwPOVGranularity;

    HWND hwnd;
    HKEY hkType;
    VXDINSTANCE *pvi;
    DIDEVCAPS dc;

    DIDATAFORMAT df;
    JOYRANGECONVERT rgjrc[cJoyStateAxisMax];

    DIJOYCONFIG cfg;
    DIJOYTYPEINFO typi;

    DWORD dwVersion;  //DirectInput version

#if (DIRECTINPUT_VERSION > 0x061A)
    DIAPPHACKS  diHacks;
#endif

} CJoy, DJ, *PDJ;

#define ThisClass CJoy
#define ThisInterface IDirectInputDeviceCallback
#define riidExpected &IID_IDirectInputDeviceCallback

/*****************************************************************************
 *
 *      Forward declarations
 *
 *      These are out of laziness, not out of necessity.
 *
 *****************************************************************************/

STDMETHODIMP CJoy_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk);
void INTERNAL CJoy_InitPhysRanges(PDJ this, LPJOYREGHWCONFIG phwc);

LRESULT CALLBACK
CJoy_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                  UINT_PTR uid, ULONG_PTR dwRef);

/*****************************************************************************
 *
 *      CJoy::QueryInterface      (from IUnknown)
 *      CJoy::AddRef              (from IUnknown)
 *      CJoy::Release             (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CJoy)
Default_AddRef(CJoy)
Default_Release(CJoy)

#else

#define CJoy_QueryInterface   Common_QueryInterface
#define CJoy_AddRef           Common_AddRef
#define CJoy_Release          Common_Release

#endif

#define CJoy_QIHelper         Common_QIHelper

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | RemoveSubclass |
 *
 *          Remove our subclass hook on the window.
 *
 *          The parameter is intentionally misdeclared as a <t PV>
 *          so that this function can double as the <f CJoy_AppFinalize>.
 *
 *****************************************************************************/

void INTERNAL
CJoy_RemoveSubclass(PV pvObj)
{
    PDJ this = pvObj;

    /*
     *  If there was an old window, then un-subclass it
     *  and release the hold associated with it.
     *
     *  You might think that there's a race condition here, where
     *  we might unhold the device while the subclass procedure is
     *  still using it.
     *
     *  Ah, but that's not a problem, because the only message that
     *  the subclass procedure cares about is the joystick
     *  reconfiguration message, and when it is processing that message,
     *  it does its own artificial hold/unhold to keep the device alive
     *  while it dorks on the device.
     *
     *  Okay, so there *is* a really tiny race condition where we
     *  might nuke the device while the window procedure is studying
     *  the message to decide whether it cares or not.
     *
     *  Since that is so extremely rare, we close that window by
     *  hacking it:  We revalidate the device before partying on it.
     *  Note that the hack is not perfect, but the race window becomes
     *  only a few instructions long that I'm not going to worry about it.
     *
     *  By wiping out this->hwnd before removing the subclass, we
     *  can reduce the window to very small indeed.
     */
    if (this->hwnd) {
        HWND hwnd = this->hwnd;
        this->hwnd = 0;
        if (!RemoveWindowSubclass(hwnd, CJoy_SubclassProc, 0)) {
            /*
             *  The RemoveWindowSubclass can fail if the window
             *  was destroyed behind our back.
             */
//            AssertF(!IsWindow(hwnd));
        }
        Sleep(0);                   /* Let the worker thread drain */
        Common_Unhold(this);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CJoy_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CJoy_Finalize(PV pvObj)
{
    PDJ this = pvObj;

    if (this->pvi) {
        HRESULT hres;

        hres = Hel_DestroyInstance(this->pvi);
        AssertF(SUCCEEDED(hres));
        FreePpv(&this->df.rgodf);

        if (this->hkType) {
            RegCloseKey(this->hkType);
        }
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CJoy_AppFinalize |
 *
 *          The application has performed its final release.
 *          Remove our window subclass at this point.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

#define CJoy_AppFinalize      CJoy_RemoveSubclass

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CJoy_SubclassProc |
 *
 *          Window subclass procedure which watches for
 *          joystick configuration change notifications.
 *
 *  @parm   HWND | hwnd |
 *
 *          The victim window.
 *
 *  @parm   UINT | wm |
 *
 *          Window message.
 *
 *  @parm   WPARAM | wp |
 *
 *          Message-specific data.
 *
 *  @parm   LPARAM | lp |
 *
 *          Message-specific data.
 *
 *  @parm   UINT | uid |
 *
 *          Callback identification number, always zero.
 *
 *  @parm   DWORD | dwRef |
 *
 *          Reference data, a pointer to our joystick device callback.
 *
 *****************************************************************************/

LRESULT CALLBACK
CJoy_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                  UINT_PTR uid, ULONG_PTR dwRef)
{
#ifdef XDEBUG
    static CHAR s_szProc[] = "";
#endif
    AssertF(uid == 0);

    if (wm == g_wmJoyChanged) {
        PDJ this = (PDJ)dwRef;

        /*
         *  Wacky subtlety going on here to avoid race conditions.
         *  See the mondo comment block in CJoy_RemoveSubclass
         *  for details.
         *
         *  We can get faked out if the memory associated with the
         *  CJoy is still physically allocated, the vtbl is magically
         *  still there and the hwnd field somehow matches our hwnd.
         */
        if (SUCCEEDED(hresPv(this)) && this->hwnd == hwnd) {

            HRESULT hres;

            Common_Hold(this);
            /*
             *  We must ask for DIJC_CALLOUT even though we don't care,
             *  because that will trigger the Microsoft Gamepad hack-o-rama.
             */
            hres = JoyReg_GetConfig(this->idJoy, NULL, &this->cfg,
                                    DIJC_REGHWCONFIGTYPE | DIJC_CALLOUT);
            if (SUCCEEDED(hres)) {
                CJoy_InitPhysRanges(this, &this->cfg.hwc);
            }
            Common_Unhold(this);

        }
    }

    return DefSubclassProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetInstance |
 *
 *          Obtains the DirectInput instance handle.
 *
 *  @parm   OUT PPV | ppvi |
 *
 *          Receives the instance handle.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetInstance(PDICB pdcb, PPV ppvi)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetInstance, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppvi = (PV)this->pvi;
    hres = S_OK;

    ExitOleProcPpvR(ppvi);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetDataFormat |
 *
 *          Obtains the device's preferred data format.
 *
 *  @parm   OUT LPDIDEVICEFORMAT * | ppdf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdf)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetDataFormat,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppdf = &this->df;
    hres = S_OK;

    ExitOleProcPpvR(ppdf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetDeviceInfo |
 *
 *          Obtain general information about the device.
 *
 *  @parm   OUT LPDIDEVICEINSTANCEW | pdiW |
 *
 *          <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *          Secret convenience:  <e DEVICEINSTANCE.guidProduct> is equal
 *          to <e DEVICEINSTANCE.guidInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW pdiW)
{
    HRESULT hres;
    PDJ this;

    EnterProcI(IDirectInputDeviceCallback::Joy::GetDeviceInfo,
               (_ "pp", pdcb, pdiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

#if DIRECTINPUT_VERSION <= 0x0400
    AssertF(pdiW->dwSize == cbX(*pdiW));
#else
    AssertF(IsValidSizeDIDEVICEINSTANCEW(pdiW->dwSize));
#endif

    /*
     *  Unlike mouse and keyboard, there can be multiple instances of
     *  the same joystick product, so we can't just leave guidProduct
     *  equal to guidInstance.
     */

    pdiW->guidProduct = GUID_Joystick;
    AssertF(pdiW->guidInstance.Data1 ==
            (pdiW->guidProduct.Data1 | this->idJoy));

    pdiW->dwDevType = this->dc.dwDevType;

  #ifdef UNICODE
    lstrcpyn(pdiW->tszProductName, this->typi.wszDisplayName,
             cA(pdiW->tszProductName));
  #else
    CAssertF(cA(pdiW->tszProductName) >= cA(this->typi.wszDisplayName));
    CopyMemory(pdiW->tszProductName, this->typi.wszDisplayName,
               cbX(this->typi.wszDisplayName));
  #endif


/*
 * Since we use HID path, there is no meaning to distinguish
 * the devices by using "Joystick x" name.
 * We'd better use the same DisplayName for InstanceName.
 * Shall we do this?
 *
    LoadString(g_hinst, IDS_STDJOYSTICK, tszFormat, cA(tszFormat));

#ifdef UNICODE
    wsprintf(pdiW->tszInstanceName, tszFormat, this->idJoy + 1);
#else
    wsprintf(tszName, tszFormat, this->idJoy + 1);
    AToU(pdiW->tszInstanceName, cA(pdiW->tszInstanceName), tszName);
#endif
 */

#ifdef UNICODE
    lstrcpyn(pdiW->tszInstanceName, this->typi.wszDisplayName,
             cA(pdiW->tszInstanceName));
#else
    CAssertF(cA(pdiW->tszInstanceName) >= cA(this->typi.wszDisplayName));
    CopyMemory(pdiW->tszInstanceName, this->typi.wszDisplayName,
               cbX(this->typi.wszDisplayName));
//    lstrcatW( pdiW->tszInstanceName, L" (VJOYD)");
#endif

#ifdef IDirectInputDevice2Vtbl
    if (pdiW->dwSize >= cbX(DIDEVICEINSTANCE_DX5W)) {
        HKEY hkFF;

        /*
         *  If there is a force feedback driver, then fetch the driver CLSID
         *  as the FF GUID.
         */
        hres = CJoy_GetFFConfigKey(pdcb, KEY_QUERY_VALUE, &hkFF);
        if (SUCCEEDED(hres)) {
            LONG lRc;
            TCHAR tszClsid[ctchGuid];

            lRc = RegQueryString(hkFF, TEXT("CLSID"), tszClsid, cA(tszClsid));
            if (lRc == ERROR_SUCCESS &&
                ParseGUID(&pdiW->guidFFDriver, tszClsid)) {
            } else {
                ZeroX(pdiW->guidFFDriver);
            }
            RegCloseKey(hkFF);
        }
    }
#endif

    hres = S_OK;

    ExitOleProcR();
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | SetAxisProperty |
 *
 *          If the request is to set a property on the device,
 *          then convert it into separate requests, one for each
 *          axis.
 *
 *  @parm   PDJ | this |
 *
 *          The device object.
 *
 *  @parm   GETSETJOYPROP | GetSetJoyProp |
 *
 *          Callback function that gets or sets the property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @parm   int | ibField |
 *
 *          Offset to field being set.  (Really: Reference data to
 *          pass to callback.)
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_SetAxisProperty(PDJ this, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;

    /*
     *  Note that we never pass the type key to CCal_SetProperty
     *  because we keep our calibration data elsewhere.
     */

    if (ppropi->dwDevType == 0) {           /* For device */
        int iAxis;

        for (iAxis = 0; iAxis < cA(this->rgjrc); iAxis++) {

            PJOYRANGECONVERT pjrc = &this->rgjrc[iAxis];

            hres = CCal_SetProperty(pjrc, ppropi, pdiph, NULL, this->dwVersion);

            if (FAILED(hres)) {
                goto done;
            }
        }
        hres = S_OK;

    } else if ((ppropi->dwDevType & DIDFT_ABSAXIS) &&
               DIDFT_GETINSTANCE(ppropi->dwDevType) < cA(this->rgjrc)) {

        PJOYRANGECONVERT pjrc;
        pjrc = &this->rgjrc[DIDFT_GETINSTANCE(ppropi->dwDevType)];

        hres = CCal_SetProperty(pjrc, ppropi, pdiph, NULL, this->dwVersion);

    } else {
        hres = E_NOTIMPL;
    }

done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | UpdateAxisCalibration |
 *
 *          Take our cached calibration information and smash it into
 *          the configuration section of the registry.
 *
 *  @parm   PDJ | this |
 *
 *          The device object.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_UpdateAxisCalibration(PDJ this)
{
    HRESULT hres;
    DIJOYCONFIG cfg;

    hres = JoyReg_GetConfig(this->idJoy, NULL, &cfg, DIJC_REGHWCONFIGTYPE);
    if (SUCCEEDED(hres)) {
        UINT uiPosAxis;

#define JoyPosValue(phwc, f, i)                                         \
        *(LPDWORD)pvAddPvCb(&(phwc)->hwv.jrvHardware.f,                 \
                            ibJoyPosAxisFromPosAxis(i))                 \


        for (uiPosAxis = 0; uiPosAxis < cJoyPosAxisMax; uiPosAxis++) {
            PJOYRANGECONVERT pjrc;
            UINT uiStateAxis;

            uiStateAxis = iJoyStateAxisFromPosAxis(uiPosAxis);

            pjrc = &this->rgjrc[uiStateAxis];

            JoyPosValue(&cfg.hwc, jpMin,    uiPosAxis) = pjrc->dwPmin;
            JoyPosValue(&cfg.hwc, jpMax,    uiPosAxis) = pjrc->dwPmax;
            JoyPosValue(&cfg.hwc, jpCenter, uiPosAxis) = pjrc->dwPc;

#undef JoyPosValue
        }

        hres = JoyReg_SetConfig(this->idJoy, &cfg.hwc, &cfg,
                                DIJC_UPDATEALIAS | DIJC_REGHWCONFIGTYPE);

    }

    if (FAILED(hres)) {
        RPF("Joystick::SetProperty::Calibration: "
            "Unable to update calibration in registry");
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | SetProperty |
 *
 *          Set a device property.
 *
 *  @parm   PDJ | this |
 *
 *          The device object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> for something we didn't handle natively.
 *          The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::SetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    switch ((DWORD)(UINT_PTR)ppropi->pguid) {

    case (DWORD)(UINT_PTR)DIPROP_RANGE:
    case (DWORD)(UINT_PTR)DIPROP_DEADZONE:
    case (DWORD)(UINT_PTR)DIPROP_SATURATION:
    case (DWORD)(UINT_PTR)DIPROP_CALIBRATIONMODE:
    case (DWORD)(UINT_PTR)DIPROP_CALIBRATION:
        hres = CJoy_SetAxisProperty(this, ppropi, pdiph);
        if (SUCCEEDED(hres) && ppropi->pguid == DIPROP_CALIBRATION) {
            hres = CJoy_UpdateAxisCalibration(this);
        }
        break;

    case (DWORD)(UINT_PTR)DIPROP_INSTANCENAME:
    case (DWORD)(UINT_PTR)DIPROP_PRODUCTNAME:
        {
            USHORT uVid, uPid;
            
            /*
             *  Friendly names cause all manner of problems with devices that 
             *  use auto detection so only allow non-predefined analog devices 
             *  to use them.
             *
             *  Prefix warns (240487) that ParseVIDPID could leave uVid 
             *  uninitialized and succeed but it won't.  
             *  See the comment in _ParseHex for more details.
             */
            if( ParseVIDPID( &uVid, &uPid, this->cfg.wszType ) &&
                ( uVid == MSFT_SYSTEM_VID ) &&
                ( uPid >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) &&
                ( ( uPid & 0xff00 ) == MSFT_SYSTEM_PID ) )
            {
                AssertF(this->hkType);
                if( this->hkType )
                {
                    LPDIPROPSTRING pstr = (PV)pdiph;

                    hres = JoyReg_SetValue(this->hkType,
                                           REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                           pstr->wsz,
                                           cbX(pstr->wsz));
                                              
                    if( SUCCEEDED(hres ) )
                    {
                        hres = S_OK;
                    } else {
                        hres = E_FAIL;
                    }
                }
            }
            else
            {
                hres = E_NOTIMPL;
            }
            break;
        }
        
    default:
        SquirtSqflPtszV(sqflJoy,
                        TEXT("CJoy_SetProperty: E_NOTIMPL on guid: %08x"),
                        ppropi->pguid);

        hres = E_NOTIMPL;
        break;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetAxisProperty |
 *
 *          Handle an axis property.
 *
 *  @cwrap  PDJ | this
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   OUT LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetAxisProperty(PDJ this, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    LPDIPROPRANGE pdiprg = (PV)pdiph;
    HRESULT hres;

    if ((ppropi->dwDevType & DIDFT_ABSAXIS) &&
        DIDFT_GETINSTANCE(ppropi->dwDevType) < cA(this->rgjrc)) {

        PJOYRANGECONVERT pjrc;
        pjrc = &this->rgjrc[DIDFT_GETINSTANCE(ppropi->dwDevType)];

        hres = CCal_GetProperty(pjrc, ppropi->pguid, pdiph, this->dwVersion);

    } else {
        SquirtSqflPtszV(sqflJoy,
                        TEXT("CJoy_GetProperty: E_NOTIMPL on guid: %08x"),
                        ppropi->pguid);

        hres = E_NOTIMPL;
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | GetGuidAndPath |
 *
 *          Get a Joy device's class GUID (namely, the MEDIA guid)
 *          and device interface (path).  The path is for the equivalent
 *          HID device if possible, otherwise a NULL string.
 *
 *  @parm   PCHID | this |
 *
 *          The Joy object.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *****************************************************************************/

VOID INTERNAL
    CJoy_GetGuidAndPath(PDJ this, LPDIPROPHEADER pdiph)
{

/*
 *  This should never happen on Win2k because all devices are HID
 *  but just in case we build an NT4 SP5 version or something...
 */
#ifdef WINNT
    LPDIPROPGUIDANDPATH pgp = (PV)pdiph;

    UNREFERENCED_PARAMETER( this );

    pgp->guidClass = GUID_MediaClass;
    pgp->wszPath[0] = TEXT( '\0' );
#else

    LPDIPROPGUIDANDPATH pgp = (PV)pdiph;
    VXDINITPARMS    vip;
    TCHAR           szPath[MAX_PATH];
    PTCHAR          pszPath;

    pgp->guidClass = GUID_MediaClass;

    pszPath = JoyReg_JoyIdToDeviceInterface_95( this->idJoy, &vip, szPath );
    if( pszPath )
    {
        TToU( pgp->wszPath, cA(pgp->wszPath), pszPath );
    }
    else
    {
        pgp->wszPath[0] = TEXT( '\0' );
    }
#endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetProperty |
 *
 *          Retrieve a device property.
 *
 *  @parm   PDJ | this |
 *
 *          The device object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres = E_NOTIMPL;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    switch ((DWORD)(UINT_PTR)ppropi->pguid) {
        case (DWORD)(UINT_PTR)DIPROP_GRANULARITY:
            /*
             *  ISSUE-2001/03/29-timgill All POVs have the same granularity
             */
            if (ppropi->dwDevType & DIDFT_POV) {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                pdipdw->dwData = this->dwPOVGranularity;
                hres = S_OK;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_GUIDANDPATH:
            if(ppropi->iobj == 0xFFFFFFFF)
            {
                CJoy_GetGuidAndPath(this, pdiph);
                hres = S_OK;
            }
            break;

        /*
         * ISSUE-2001/03/29-timgill DX7 VJOYD devices have same INSTANCENAME and PRODUCTNAME
         * In DX7, INSTANCENAME and PRODUCTNAME are the same for VJOYD devices.
         * It is different before DX7. Probably we need make them different again
         * after DX7.
         */
        case (DWORD)(UINT_PTR)DIPROP_INSTANCENAME:
        case (DWORD)(UINT_PTR)DIPROP_PRODUCTNAME:
            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;

                if( cbX(pdipstr->wsz) > cbX(this->typi.wszDisplayName) )
                {
                    memset( &pdipstr->wsz[cA(this->typi.wszDisplayName)], 0, cbX(pdipstr->wsz) - cbX(this->typi.wszDisplayName) );
                }

                CAssertF( cbX(pdipstr->wsz) >= cbX(this->typi.wszDisplayName) );
                memcpy( pdipstr->wsz, this->typi.wszDisplayName, cbX(this->typi.wszDisplayName));
              #if (DIRECTINPUT_VERSION > 0x061A)
                if( this->diHacks.nMaxDeviceNameLength < lstrlenW(pdipstr->wsz) ) {
                    pdipstr->wsz[this->diHacks.nMaxDeviceNameLength] = L'\0';
                }
              #endif
                hres = S_OK;
                break;
            }


        case (DWORD)(UINT_PTR)DIPROP_JOYSTICKID:
            if(ppropi->iobj == 0xFFFFFFFF)
            {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                pdipdw->dwData =  this->idJoy;
                hres = S_OK;
            }
            break;


    /*
     *  Else, it might be something axis-specific.
     */
    default:
        hres = CJoy_GetAxisProperty(this, ppropi, pdiph);
        break;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | GetCapabilities |
 *
 *          Get joystick device capabilities.
 *
 *  @parm   PDJ | this |
 *
 *          The joystick object.
 *
 *  @parm   LPDIDEVCAPS | pdc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdc)
{
    HRESULT hres;
    PDJ this;
    JOYINFOEX jix;
    MMRESULT mmrc = MMSYSERR_ERROR;

    EnterProcI(IDirectInputDeviceCallback::Joy::GetCapabilities,
               (_ "pp", pdcb, pdc));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVCAPS(pdc->dwSize));
    CopyMemory(pvAddPvCb(pdc, cbX(DWORD)),
               pvAddPvCb(&this->dc, cbX(DWORD)),
               pdc->dwSize - cbX(DWORD));

    /*
     *  Joysticks can come and go.  Re-query each time.
     */

    /*
     *  Determine if joystick is physically attached
     *  or is possibly even phantom.
     *
     *  JOYERR_ATTACHED  - Is attached
     *  JOYERR_UNPLUGGED - Is not attached
     *  Anything else    - Is phantom
     */
    jix.dwSize = sizeof(JOYINFOEX);
    jix.dwFlags = JOY_CAL_READALWAYS | JOY_RETURNALL;
    mmrc = joyGetPosEx(this->idJoy, &jix);

    pdc->dwFlags &= ~DIDC_ATTACHED;
    if (mmrc == JOYERR_NOERROR) {
        pdc->dwFlags |= DIDC_ATTACHED;
    } else if (mmrc == JOYERR_UNPLUGGED) {
    } else {
        pdc->dwFlags |= DIDC_PHANTOM;
    }

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | GetPhysicalState |
 *
 *          Read the physical joystick state into <p pjsOut>.
 *
 *          After getting the physical data,
 *          we cook the axes as necessary.
 *
 *  @parm   LPDIJOYSTATE2 | pjsOut |
 *
 *          Where to put the joystick state.
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/

void INLINE
CJoy_GetPhysicalState(PDJ this, LPDIJOYSTATE2 pjsOut)
{
    UINT uiStateAxis;

    AssertF(this->pjsPhys);

    *pjsOut = *this->pjsPhys;

    /*
     *  Note only absolute positional data gets calibrated 
     */
    if( ( this->pvi->fl & VIFL_RELATIVE ) == 0 )
    {
        for (uiStateAxis = 0; uiStateAxis < cA(this->rgjrc); uiStateAxis++) {
            PLONG pl = pvAddPvCb(pjsOut,
                                 ibJoyStateAxisFromStateAxis(uiStateAxis));
            CCal_CookRange(&this->rgjrc[uiStateAxis], pl);
        }
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | Poll |
 *
 *          Ping down into the driver to get the latest data.
 *
 *  @returns
 *
 *          <c S_OK> if we pinged okay.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_Poll(PDICB pdcb)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::Poll, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    if( this->diHacks.fNoPollUnacquire )
    {
        hres = Hel_Joy_Ping8(this->pvi);
    }
    else
    {
        hres = Hel_Joy_Ping(this->pvi);
    }
    if (FAILED(hres)) {
        if( this->dwVersion < 0x05B2 ) {
            /*
             *  Some Win9x games will break if Poll fails.
             *  See OSR 4.1 Bug 62999. So we make it always succeeded.
             */
            hres = S_OK;
        } else {
            /*
             *  The NT and onwards CPL requires poll to return true status
             */
            AssertF(hres ==
                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,
                                             ERROR_DEV_NOT_EXIST));
            hres = DIERR_UNPLUGGED;
        }
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetDeviceState |
 *
 *          Obtains the state of the joystick device.
 *
 *          It is the caller's responsibility to have validated all the
 *          parameters and ensure that the device has been acquired.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          joystick data in the preferred data format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetDeviceState(PDICB pdcb, LPVOID pvData)
{
    HRESULT hres;
    PDJ this;
    LPDIJOYSTATE2 pjsOut = pvData;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetDeviceState,
               (_ "pp", pdcb, pvData));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pjsPhys);

    if (this->pvi->fl & VIFL_ACQUIRED) {
        CJoy_GetPhysicalState(this, pjsOut);
        hres = S_OK;
    } else {
        hres = DIERR_INPUTLOST;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | CookDeviceData |
 *
 *          Manipulate buffered device data.
 *
 *          If the item describe an axis, we need to cook it.
 *
 *  @parm   UINT | cdod |
 *
 *          Number of objects to cook; zero is a valid value.
 *
 *  @parm   LPDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of object data to cook.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The callback does
 *          not cook device data.
 *
 *          <c DIERR_NOTACQUIRED>: The device could not be acquired.
 *
 ***************************************************************************/

STDMETHODIMP
CJoy_CookDeviceData(PDICB pdcb, UINT cdod, LPDIDEVICEOBJECTDATA rgdod)
{
    HRESULT hres;
    PDJ this;
    UINT idod;
    EnterProcI(IDirectInputDeviceCallback::Joy::CookDeviceData,
               (_ "pxp", pdcb, cdod, rgdod));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    for (idod = 0; idod < cdod; idod++) {
        DWORD dwDevType = DICOOK_IDFROMDFOFS(rgdod[idod].dwOfs);
        if ((dwDevType & DIDFT_ABSAXIS) &&
            DIDFT_GETINSTANCE(dwDevType) < cA(this->rgjrc)) {

            PJOYRANGECONVERT pjrc;
            pjrc = &this->rgjrc[DIDFT_GETINSTANCE(dwDevType)];
            CCal_CookRange(pjrc, (PV)&rgdod[idod].dwData);
        }
    }

    hres = S_OK;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | OpenIdSubkey |
 *
 *          Given an object ID, attempt to open the subkey that
 *          corresponds to it.
 *
 *  @cwrap  PDJ | this
 *
 *  @parm   DWORD | dwId |
 *
 *          Object id.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

HRESULT INLINE
CJoy_OpenIdSubkey(PDJ this, DWORD dwId, PHKEY phk)
{
    return CType_OpenIdSubkey(this->hkType, dwId, KEY_QUERY_VALUE, phk);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetObjectInfo |
 *
 *          Obtain the friendly name and FF/HID information
 *          of an object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          <e DIDEVICEOBJECTINSTANCE.dwFlags>
 *          fields have already been filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                               LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetObjectInfo,
               (_ "pxp", pdcb, ppropi->iobj, pdidoiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEW(pdidoiW->dwSize));
    if (ppropi->iobj < this->df.dwNumObjs) {

        AssertF(ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType);

        CType_RegGetObjectInfo(this->hkType, ppropi->dwDevType, pdidoiW);

        /*
         *  If we couldn't get a name from the registry,
         *  then grab one of the standard names.
         */
        if (pdidoiW->tszName[0] == L'\0') {
            UINT dids;

            if (ppropi->dwDevType & DIDFT_AXIS) {
                dids = 0;
                LoadStringW(g_hinst, IDS_JOYSTICKOBJECT + dids +
                                     DIDFT_GETINSTANCE(ppropi->dwDevType),
                                     pdidoiW->tszName, cA(pdidoiW->tszName));
            } else if (ppropi->dwDevType & DIDFT_BUTTON) {
                GetNthButtonString(pdidoiW->tszName,
                                   DIDFT_GETINSTANCE(ppropi->dwDevType));
            } else {
                AssertF(ppropi->dwDevType & DIDFT_POV);
                GetNthPOVString(pdidoiW->tszName,
                                DIDFT_GETINSTANCE(ppropi->dwDevType));
            }

        }

        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | SetCooperativeLevel |
 *
 *          The app changed the cooperative level.
 *          Un-subclass the old window and en-subclass the new window.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  First get out of the old window.
     */
    CJoy_RemoveSubclass(this);

    /*
     *  If a new window is passed, then subclass it so we can
     *  watch for joystick configuration change messages.
     *
     *  If we can't, don't worry.  All it means that we won't
     *  be able to catch when the user recalibrates the joystick,
     *  which isn't very often.
     */
    if (hwnd) {
        if (SetWindowSubclass(hwnd, CJoy_SubclassProc, 0, (ULONG_PTR)this)) {
            this->hwnd = hwnd;
            Common_Hold(this);
        }

    } else {
        RPF("SetCooperativeLevel: You really shouldn't pass hwnd = 0; "
            "joystick calibration may be dodgy");
    }

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | RunControlPanel |
 *
 *          Run the joystick control panel.
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          The owner window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags.
 *
 *****************************************************************************/

TCHAR c_tszJoyCpl[] = TEXT("joy.cpl");

STDMETHODIMP
CJoy_RunControlPanel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::RunControlPanel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = hresRunControlPanel(c_tszJoyCpl);

    ExitOleProcR();
    return hres;
}

#ifdef IDirectInputDevice2Vtbl

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetFFConfigKey |
 *
 *          Open and return the registry key that contains
 *          force feedback configuration information.
 *
 *  @parm   DWORD | sam |
 *
 *          Security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the registry key.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetFFConfigKey,
               (_ "px", pdcb, sam));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = JoyReg_OpenFFKey(this->hkType, sam, phk);

    AssertF(fLeqvFF(SUCCEEDED(hres), *phk));

    ExitBenignOleProcPpvR(phk);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | CreateEffect |
 *
 *          Create an <i IDirectInputEffectDriver> interface.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD * | ppes |
 *
 *          Receives the shepherd for the effect driver.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes)
{
    HRESULT hres;
    PDJ this;
    HKEY hk;
    EnterProcI(IDirectInputDeviceCallback::Joy::CreateEffect, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = CJoy_GetFFConfigKey(pdcb, KEY_QUERY_VALUE, &hk);
    if (SUCCEEDED(hres)) {
        hres = CEShep_New(hk, 0, &IID_IDirectInputEffectShepherd, ppes);
        if (SUCCEEDED(hres)) {
#ifndef WINNT
            VXDINITPARMS    vip;
            CHAR           szPath[MAX_PATH];
            PCHAR          pszPath;

            pszPath = JoyReg_JoyIdToDeviceInterface_95( this->idJoy, &vip, szPath );
            if( pszPath )
            {
                DIHIDFFINITINFO init;
                WCHAR           wszPath[MAX_PATH];

                ZeroX(init);
                init.dwSize = cbX(init);

                TToU( wszPath, cA(wszPath), pszPath );
                init.pwszDeviceInterface = wszPath;
                hresFindHIDDeviceInterface(pszPath, &init.GuidInstance);

                hres = (*ppes)->lpVtbl->DeviceID((*ppes), this->idJoy, TRUE, &init);
            }
            else
#endif
            {
                hres = (*ppes)->lpVtbl->DeviceID((*ppes), this->idJoy, TRUE, 0);
            }
         }
        if (SUCCEEDED(hres)) {
        } else {
            Invoke_Release(ppes);
        }
        RegCloseKey(hk);
    } else {
        hres = E_NOTIMPL;
        *ppes = 0;
    }

    ExitOleProcPpvR(ppes);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetVersions |
 *
 *          Ping down into the driver to get the driver version info.
 *
 *  @parm   LPDIDRIVERVERSIONS | pvers |
 *
 *          A structure which should be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *          DirectInput will set the <e DIDRIVERVERSIONS.dwSize> field
 *          to sizeof(DIDRIVERVERSIONS) before calling this method.
 *
 *  @returns
 *
 *          <c S_OK> if we succeeded.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetVersions(PDICB pdcb, LPDIDRIVERVERSIONS pvers)
{
    HRESULT hres;
    PDJ this;
    VXDINITPARMS vip;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetVersions, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(pvers->dwSize == cbX(*pvers));

    hres = Hel_Joy_GetInitParms(this->idJoy, &vip);

    if (SUCCEEDED(hres)) {
        pvers->dwFirmwareRevision = vip.dwFirmwareRevision;
        pvers->dwHardwareRevision = vip.dwHardwareRevision;
        pvers->dwFFDriverVersion  = vip.dwFFDriverVersion;
    }

    return hres;
}

#endif

/*****************************************************************************
 *
 *  Joystick registry usage
 *
 *****************************************************************************
 *
 *  Global joystick information is kept under
 *
 *  HKEY_LOCAL_MACHINE\
 *      System\
 *          CurrentControlSet\
 *              Control\
 *                  MediaProperties\
 *                      Joystick\
 *                          OEM
 *
 *  Under this key is a number of subkeys, each corresponding to a brand
 *  of joystick.
 *
 *  Under each OEM\<name> key, you can find the following values:
 *
 *      OEMData
 *
 *          This is a binary value containing a structure of two dwords.
 *          The first is the JOYREGHWCONFIG.hws.dwFlags and the second
 *          is the JOYREGHWCONFIG.hws.dwNumButtons.
 *
 *      OEMName
 *
 *          This is a string which gives a friendly name for the unit.
 *
 *
 *****************************************************************************
 *
 *  Under the driver key is kept information about the particular joystick.
 *
 *  HKEY_LOCAL_MACHINE\
 *      System\
 *          CurrentControlSet\
 *              Control\
 *                  MediaResources\
 *                      Joystick\
 *                          <driver key name>\
 *                              CurrentJoystickSettings
 *
 *  Under this key, there are a bunch of values named
 *  Joystick##Configuration, where ## is the joystick number
 *  (1 through 16).  Each value contains binary data in the form
 *  of a JOYREGHWCONFIG, which looks like this:
 *
 *      DWORD hws.dwFlags;    // JOY_HWS_*    \
 *      DWORD hws.dwNumButtons;               _\ JOYREGHWSETTINGS
 *      DWORD dwUsageSettings;// JOY_US_*    _____
 *      DWORD hwv.jrvHardware.jpMin.dwX;    \     |
 *      DWORD hwv.jrvHardware.jpMin.dwY;     \    |
 *      DWORD hwv.jrvHardware.jpMin.dwZ;      \
 *      DWORD hwv.jrvHardware.jpMin.dwR;      |
 *      DWORD hwv.jrvHardware.jpMin.dwU;       > JOYREGHWVALUES.JOYRANGE
 *      DWORD hwv.jrvHardware.jpMin.dwV;      |
 *      DWORD hwv.jrvHardware.jpMax.dwX;      |   |
 *      DWORD hwv.jrvHardware.jpMax.dwY;      |   |
 *      DWORD hwv.jrvHardware.jpMax.dwZ;      |   \
 *      DWORD hwv.jrvHardware.jpMax.dwR;      |    > JOYREGHWVALUES
 *      DWORD hwv.jrvHardware.jpMax.dwU;      |   /
 *      DWORD hwv.jrvHardware.jpMax.dwV;      |   |
 *      DWORD hwv.jrvHardware.jpCenter.dwX;   |   |
 *      DWORD hwv.jrvHardware.jpCenter.dwY;   |   |
 *      DWORD hwv.jrvHardware.jpCenter.dwZ;   |   |
 *      DWORD hwv.jrvHardware.jpCenter.dwR;   /   |
 *      DWORD hwv.jrvHardware.jpCenter.dwU;  /    |
 *      DWORD hwv.jrvHardware.jpCenter.dwV; /     |
 *      DWORD hwv.dwPOVValues[4];                 |
 *      DWORD hwv.dwCalFlags;               ______|
 *      DWORD dwType;         // JOY_HW_*
 *      DWORD dwReserved;
 *
 *
 *  Also under this key are optional values named Joystick##OEMName.
 *  If present, it is a string-data key whose contents are the name
 *  of another key that describes the joystick, stored in the global
 *  section described above.
 *
 *  Meanwhile, under the key
 *
 *  HKEY_LOCAL_MACHINE\
 *      System\
 *          CurrentControlSet\
 *              Control\
 *                  MediaResources\
 *                      Joystick\
 *                          <driver key name>
 *
 *  is a value called "JoystickUserValues".  This is a binary key
 *  that contains a JOYREGUSERVALUES structure:
 *
 *      DWORD   dwTimeOut;
 *      DWORD   jrvRanges.jpMin.dwX;    \
 *      DWORD   jrvRanges.jpMin.dwY;     \
 *      DWORD   jrvRanges.jpMin.dwZ;      \
 *      DWORD   jrvRanges.jpMin.dwR;      |
 *      DWORD   jrvRanges.jpMin.dwU;       > JOYRANGE
 *      DWORD   jrvRanges.jpMin.dwV;      |
 *      DWORD   jrvRanges.jpMax.dwX;      |
 *      DWORD   jrvRanges.jpMax.dwY;      |
 *      DWORD   jrvRanges.jpMax.dwZ;      |
 *      DWORD   jrvRanges.jpMax.dwR;      |
 *      DWORD   jrvRanges.jpMax.dwU;      |
 *      DWORD   jrvRanges.jpMax.dwV;      |
 *      DWORD   jrvRanges.jpCenter.dwX;   | (ignored)
 *      DWORD   jrvRanges.jpCenter.dwY;   | (ignored)
 *      DWORD   jrvRanges.jpCenter.dwZ;   | (ignored)
 *      DWORD   jrvRanges.jpCenter.dwR;   / (ignored)
 *      DWORD   jrvRanges.jpCenter.dwU;  /  (ignored)
 *      DWORD   jrvRanges.jpCenter.dwV; /   (ignored)
 *      DWORD   jpDeadZone.dwX;         \
 *      DWORD   jpDeadZone.dwY;          \
 *      DWORD   jpDeadZone.dwZ;           \ JOYPOS
 *      DWORD   jpDeadZone.dwR;           / Dead zone is recorded as a
 *      DWORD   jpDeadZone.dwU;          /  percentage of total range
 *      DWORD   jpDeadZone.dwV;         /
 *
 *  If there is no JoystickUserValues, then the following defaults
 *  are used:
 *
 *      jpMin.dw# = 0;
 *      jpMax.dw# = 65535;
 *      jpCenter.dw# = jpMax.dw# / 2;
 *      jrvDeadZone.dw# = 5;
 *
 *  (See ibmjoy\msjstick.c, function jsReadRegistry for the code that
 *  sets the defaults.)
 *
 *  We will also use the defaults if Min > Max or if Max >= 0x80000000
 *  or if DeadZone > 100.
 *
 *****************************************************************************/

#if DIRECTINPUT_VERSION > 0x0300

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | InitPhysRanges |
 *
 *          Initialize (or re-initialize)
 *          the physical min/max/center values.  This is
 *          done as part of device initialization as well as in response
 *          to a notification that the Joystick control panel has been
 *          dinked with.
 *
 *          It is assumed that the <e DJ.hwc> already contains the
 *          registry hardware settings.
 *
 *          After the phys ranges are set, the ramps are recalculated.
 *
 *
 *****************************************************************************/

void INTERNAL
CJoy_InitPhysRanges(PDJ this, LPJOYREGHWCONFIG phwc)
{
    UINT uiPosAxis;
    UINT uiStateAxis;

#define GetJoyPosValue(phwc, f, i)                                      \
        *(LPDWORD)pvAddPvCb(&phwc->hwv.jrvHardware.f,                   \
                            ibJoyPosAxisFromPosAxis(i))                 \


    for (uiPosAxis = 0; uiPosAxis < cJoyPosAxisMax; uiPosAxis++) {
        DWORD dwMax, dwC;
        PJOYRANGECONVERT pjrc;

        uiStateAxis = iJoyStateAxisFromPosAxis(uiPosAxis);

        pjrc = &this->rgjrc[uiStateAxis];

        pjrc->dwPmin = GetJoyPosValue(phwc, jpMin, uiPosAxis);

        /*
         *  HACKHACK - Uncalibrated joysticks will have max == 0, in which
         *  case we use a fake max of 655, just like VJOYD.
         */
        dwMax = GetJoyPosValue(phwc, jpMax, uiPosAxis);
        if (dwMax == 0) {
            dwMax = 655;
        }

        pjrc->dwPmax = dwMax;

        /*
         *  HACKHACK - Uncalibrated joysticks will have center == 0,
         *  in which case we use a fake center of midway between min and
         *  max, just like VJOYD.
         *
         *  Quirk - Z, R, U, and V typically are not center-calibrated,
         *  so if the jpCenter value is not strictly between min and
         *  max, then assume it's one of the bogus cases and slam it
         *  into the middle of the range.
         */

        dwC = GetJoyPosValue(phwc, jpCenter, uiPosAxis);
        if (dwC <= pjrc->dwPmin || dwC >= pjrc->dwPmax) {
            dwC = (pjrc->dwPmin + pjrc->dwPmax) / 2;
        }

        pjrc->dwPc = dwC;

        SquirtSqflPtszV(sqfl,
                        TEXT("CJoy_PhysRange %d -> %d: %08x / %08x / %08x"),
                        uiPosAxis,
                        uiStateAxis,
                        pjrc->dwPmin,
                        pjrc->dwPc,
                        pjrc->dwPmax);

    }

#undef GetJoyValue

    /*
     *  These two phantom axes are always raw because they don't exist.
     */
    this->rgjrc[iJoyStateAxisRx].fRaw = TRUE;
    this->rgjrc[iJoyStateAxisRy].fRaw = TRUE;

    /*
     *  Now compute all the dependent variables.
     */
    for (uiStateAxis = 0; uiStateAxis < cA(this->rgjrc); uiStateAxis++) {
        CCal_RecalcRange(&this->rgjrc[uiStateAxis]);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | InitLogRanges |
 *
 *          Initialize the logical ranges from the user values.
 *
 *****************************************************************************/

void INLINE
CJoy_InitLogRanges(PDJ this)
{
    HRESULT hres;
    UINT uiPosAxis;
    UINT uiStateAxis;
    DIJOYUSERVALUES juv;

    hres = JoyReg_GetUserValues(&juv, DIJU_USERVALUES);
    AssertF(SUCCEEDED(hres));

#define pJoyValue(jp, i)                                            \
        (LPDWORD)pvAddPvCb(&(jp), ibJoyPosAxisFromPosAxis(i))       \


    for (uiPosAxis = 0; uiPosAxis < cJoyPosAxisMax; uiPosAxis++) {

        PJOYRANGECONVERT pjrc;

        AssertF((int)*pJoyValue(juv.ruv.jrvRanges.jpMax, uiPosAxis) >= 0);
        AssertF(*pJoyValue(juv.ruv.jrvRanges.jpMin, uiPosAxis) <
                *pJoyValue(juv.ruv.jrvRanges.jpMax, uiPosAxis));

        uiStateAxis = iJoyStateAxisFromPosAxis(uiPosAxis);

        pjrc = &this->rgjrc[uiStateAxis];

        pjrc->lMin = *pJoyValue(juv.ruv.jrvRanges.jpMin, uiPosAxis);
        pjrc->lMax = *pJoyValue(juv.ruv.jrvRanges.jpMax, uiPosAxis);

        /*
         *  Note that we do *not* use the jpCenter value.  Strange
         *  but true.
         *
         *  The sum cannot overflow due to the sanity checks we did above.
         */

        pjrc->lC = CCal_Midpoint(pjrc->lMin, pjrc->lMax);

        /*
         *  Now do the dead zone.  Convert from percent to range units.
         */
        pjrc->dwDz = *pJoyValue(juv.ruv.jpDeadZone, uiPosAxis) *
                                    (RANGEDIVISIONS / 100);

        if (pjrc->dwDz > RANGEDIVISIONS) {
            pjrc->dwDz = 5 * (RANGEDIVISIONS / 100);
        }

        /*
         *  Now do the saturation level.  It always defaults to 100%.
         */
        pjrc->dwSat = RANGEDIVISIONS;

    }

}

#undef pJoyValue

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitFromHwc |
 *
 *          Initialize the information that is kept in the
 *          <t JOYREGHWCONFIG>.
 *
 *          Broken out from CJoy_InitRing3 to make things less monolithic.
 *
 *          The <e CJoy.cfg> structure already contains joystick
 *          configuration information.
 *
 *****************************************************************************/

HRESULT INLINE
CJoy_InitFromHwc(PDJ this)
{
    HRESULT hres;

    #define hwc this->cfg.hwc

    if (hwc.hws.dwFlags & JOY_HWS_ISYOKE) {
        this->dc.dwDevType =
                    MAKE_DIDEVICE_TYPE(DIDEVTYPE_JOYSTICK,
                                       DIDEVTYPEJOYSTICK_FLIGHTSTICK);
    } else if (hwc.hws.dwFlags & JOY_HWS_ISGAMEPAD) {
        this->dc.dwDevType =
                    MAKE_DIDEVICE_TYPE(DIDEVTYPE_JOYSTICK,
                                       DIDEVTYPEJOYSTICK_GAMEPAD);
    } else if (hwc.hws.dwFlags & JOY_HWS_ISCARCTRL) {
        this->dc.dwDevType =
                    MAKE_DIDEVICE_TYPE(DIDEVTYPE_JOYSTICK,
                                       DIDEVTYPEJOYSTICK_WHEEL);
    } else if (hwc.hws.dwFlags & JOY_HWS_ISHEADTRACKER) {
        this->dc.dwDevType =
                    MAKE_DIDEVICE_TYPE(DIDEVTYPE_JOYSTICK,
                                       DIDEVTYPEJOYSTICK_HEADTRACKER);
    } else if (hwc.dwUsageSettings & JOY_US_HASRUDDER) {
        this->dc.dwDevType =
                    MAKE_DIDEVICE_TYPE(DIDEVTYPE_JOYSTICK,
                                       DIDEVTYPEJOYSTICK_RUDDER);
    } else if (hwc.dwType < JOY_HW_PREDEFMAX &&
               hwc.dwType != JOY_HW_NONE) {
        this->dc.dwDevType =
                    MAKE_DIDEVICE_TYPE(DIDEVTYPE_JOYSTICK,
                                       DIDEVTYPEJOYSTICK_TRADITIONAL);
    } else {
        this->dc.dwDevType =
                    MAKE_DIDEVICE_TYPE(DIDEVTYPE_JOYSTICK,
                                       DIDEVTYPEJOYSTICK_UNKNOWN);
    }

    #undef hwc

    if( this->cfg.hwc.dwType >= JOY_HW_PREDEFMIN && this->cfg.hwc.dwType < JOY_HW_PREDEFMAX ) {
        WCHAR wszType[4];

        wszType[0] = L'#';
        wszType[1] = L'0' + (WCHAR)this->cfg.hwc.dwType;
        wszType[2] = L'\0';

        hres = JoyReg_GetPredefTypeInfo( wszType, &this->typi, DITC_DISPLAYNAME);
    } else if (this->cfg.wszType[0] != TEXT('\0')) {
        hres = JoyReg_GetTypeInfo(this->cfg.wszType, &this->typi, DITC_DISPLAYNAME);

        if (SUCCEEDED(hres)) {
        } else {
            if( fWinnt ) {
                ZeroMemory(&this->typi, cbX(this->typi));
            } else {
                //lstrcpyW( this->typi.wszDisplayName, this->cfg.wszType );
                memset( &this->typi.wszDisplayName[0], 0, sizeof(this->typi.wszDisplayName) );
                memcpy( &this->typi.wszDisplayName[0], &this->cfg.wszType[0], sizeof(this->cfg.wszType));
            }
        }
    } else {
        ZeroMemory(&this->typi, cbX(this->typi));
    }


    /*
     *  If that was unsuccessful, then make one up ourselves.
     */
    if (this->typi.wszDisplayName[0] == TEXT('\0'))
    {
        CType_MakeGameCtrlName( this->typi.wszDisplayName, 
            this->dc.dwDevType, this->dc.dwAxes, this->dc.dwButtons, this->dc.dwPOVs );
    }

    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | AddObject |
 *
 *          Add one object to the device format.
 *
 *          If the device is polled, then the object is polled, too.
 *
 *  @cwrap  PDJ | this
 *
 *  @parm   PCGUID | pguid |
 *
 *          The <t GUID> that classifies the device.
 *
 *  @parm   DWORD | dwOfs |
 *
 *          Data offset.
 *
 *  @parm   DWORD | dwDevType |
 *
 *          Device type flags to apply to the object.
 *
 *  @parm   UINT | uiObj |
 *
 *          Object instance number.
 *
 *  @parm   DWORD | dwAspect |
 *
 *          Optional <c DIDOI_ASPECT*> flag.
 *
 *****************************************************************************/

void INTERNAL
CJoy_AddObject(PDJ this, PCGUID pguid, DWORD dwOfs,
               DWORD dwDevType, UINT uiObj, DWORD dwAspect)
{
    LPDIOBJECTDATAFORMAT podf;
    EnterProc(CJoy_AddObject,
              (_ "pGxxx", this, pguid, dwDevType, uiObj, dwAspect));

    podf = &this->df.rgodf[this->df.dwNumObjs++];
    podf->pguid = pguid;
    podf->dwOfs = dwOfs;
    podf->dwType = dwDevType | DIDFT_MAKEINSTANCE(uiObj);
    podf->dwFlags = dwAspect;

    if (this->dc.dwFlags & DIDC_POLLEDDEVICE) {
        podf->dwFlags |= DIDOI_POLLED;
    }

    CType_RegGetTypeInfo(this->hkType, podf, FALSE);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | BuildAxes |
 *
 *          Study a single capabilities flag and add axis items to the data
 *          format accordingly.
 *
 *  @parm   DWORD | dwCaps |
 *
 *          Collection of <c JOYPF_*> flags describing the axes supported.
 *
 *  @parm   UINT | ib |
 *
 *          Data format offset at which this data is provided.
 *
 *  @parm   UINT | uiObj |
 *
 *          Instance index for the first item.
 *
 *  @parm   DWORD | dwAspect |
 *
 *          <c DIDOI_ASPECT*> for these axes.
 *
 *****************************************************************************/

typedef struct AXISATTRIBUTES {
    DWORD dwMask;                   /* Mask that identifies the axis */
    PCGUID pguid;                   /* GUID for the object */
    UINT dib;                       /* Delta for the data offset */
    UINT diObj;                     /* Delta for object index */
} AXISATTRIBUTES, *PAXISATTRIBUTES;
typedef const AXISATTRIBUTES *PCAXISATTRIBUTES;

const AXISATTRIBUTES c_rgaattrJoy[] = {
    {   JOYPF_X,    &GUID_XAxis,        ibJoyStateAxisX,    iJoyStateAxisX,  },
    {   JOYPF_Y,    &GUID_YAxis,        ibJoyStateAxisY,    iJoyStateAxisY,  },
    {   JOYPF_Z,    &GUID_ZAxis,        ibJoyStateAxisZ,    iJoyStateAxisZ,  },
    {   JOYPF_R,    &GUID_RzAxis,       ibJoyStateAxisRz,   iJoyStateAxisRz, },
    {   JOYPF_U,    &GUID_Slider,       ibJoyStateAxisS0,   iJoyStateAxisS0, },
    {   JOYPF_V,    &GUID_Slider,       ibJoyStateAxisS1,   iJoyStateAxisS1, },
};

void INTERNAL
CJoy_BuildAxes(PDJ this, DWORD dwCaps, UINT ib, UINT uiObj, DWORD dwAspect)
{
    int iaattr;

    for (iaattr = 0; iaattr < cA(c_rgaattrJoy); iaattr++) {
        PCAXISATTRIBUTES paattr = &c_rgaattrJoy[iaattr];
        if (dwCaps & paattr->dwMask) {
            CJoy_AddObject(this, paattr->pguid, paattr->dib + ib,
                           DIDFT_ABSAXIS, uiObj + paattr->diObj, dwAspect);
        }
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | BuildDataFormat |
 *
 *          Study the device capabilities and build the device
 *          data format.
 *
 *****************************************************************************/

void INTERNAL
CJoy_BuildDataFormat(PDJ this, PVXDAXISCAPS pvac, DWORD dwButtons)
{
    DWORD dw;

    this->dc.dwAxes = 0;
    this->dc.dwButtons = 0;
    this->dc.dwPOVs = 0;

    this->df.dwSize = cbX(DIDATAFORMAT);
    this->df.dwObjSize = cbX(DIOBJECTDATAFORMAT);
    this->df.dwDataSize = sizeof(DIJOYSTATE2);
    AssertF(this->df.dwFlags == 0);
    this->df.dwNumObjs = 0;

    /*
     *  Repeat for each set of axes.
     */

    #define CheckAxisOrder(fStart, p, f)                                    \
            CAssertF(FIELD_OFFSET(DIJOYSTATE2, p##f) ==                     \
                     FIELD_OFFSET(DIJOYSTATE2, fStart) + ibJoyStateAxis##f) \

    CheckAxisOrder(lX, l, X);
    CheckAxisOrder(lX, l, Y);
    CheckAxisOrder(lX, l, Z);
    CheckAxisOrder(lX, l, Rx);
    CheckAxisOrder(lX, l, Ry);
    CheckAxisOrder(lX, l, Rz);
    CheckAxisOrder(lX, rgl, Slider);

    if (pvac->dwPos & JOYPF_POSITION) {
        CJoy_BuildAxes(this, pvac->dwPos, FIELD_OFFSET(DIJOYSTATE2, lX),
                       iobjPositions, DIDOI_ASPECTPOSITION);
    }

    CheckAxisOrder(lVX, lV, X);
    CheckAxisOrder(lVX, lV, Y);
    CheckAxisOrder(lVX, lV, Z);
    CheckAxisOrder(lVX, lV, Rx);
    CheckAxisOrder(lVX, lV, Ry);
    CheckAxisOrder(lVX, lV, Rz);
    CheckAxisOrder(lVX, rglV, Slider);

    if (pvac->dwPos & JOYPF_VELOCITY) {
        CJoy_BuildAxes(this, pvac->dwVel, FIELD_OFFSET(DIJOYSTATE2, lVX),
                       iobjVelocities, DIDOI_ASPECTVELOCITY);
    }

    CheckAxisOrder(lAX, lA, X);
    CheckAxisOrder(lAX, lA, Y);
    CheckAxisOrder(lAX, lA, Z);
    CheckAxisOrder(lAX, lA, Rx);
    CheckAxisOrder(lAX, lA, Ry);
    CheckAxisOrder(lAX, lA, Rz);
    CheckAxisOrder(lAX, rglA, Slider);

    if (pvac->dwPos & JOYPF_ACCELERATION) {
        CJoy_BuildAxes(this, pvac->dwAccel, FIELD_OFFSET(DIJOYSTATE2, lAX),
                       iobjAccels, DIDOI_ASPECTACCEL);
    }

    CheckAxisOrder(lFX, lF, X);
    CheckAxisOrder(lFX, lF, Y);
    CheckAxisOrder(lFX, lF, Z);
    CheckAxisOrder(lFX, lF, Rx);
    CheckAxisOrder(lFX, lF, Ry);
    CheckAxisOrder(lFX, lF, Rz);
    CheckAxisOrder(lFX, rglF, Slider);

    if (pvac->dwPos & JOYPF_FORCE) {
        CJoy_BuildAxes(this, pvac->dwForce, FIELD_OFFSET(DIJOYSTATE2, lFX),
                       iobjForces, DIDOI_ASPECTFORCE);
    }

    #undef CheckAxisOrder

    this->dc.dwAxes = this->df.dwNumObjs;

    /*
     *  Doing the buttons is easy since they don't have
     *  any interesting attributes.
     */
    this->dc.dwButtons = min(dwButtons, cJoyStateButtonTotal);

    for (dw = 0; dw < this->dc.dwButtons; dw++) {
        CJoy_AddObject(this, &GUID_Button,
                       FIELD_OFFSET(DIJOYSTATE2, rgbButtons[dw]),
                       DIDFT_PSHBUTTON, dw, DIDOI_ASPECTUNKNOWN);
    }

    /*
     *  Doing the POVs is a bit trickier but not that bad.
     */
    for (dw = 0; dw < cJoyStatePOVTotal; dw++) {
        if (pvac->dwPos & JOYPF_POV(dw)) {
            CJoy_AddObject(this, &GUID_POV,
                           FIELD_OFFSET(DIJOYSTATE2, rgdwPOV[dw]),
                           DIDFT_POV, dw, DIDOI_ASPECTUNKNOWN);
            this->dc.dwPOVs++;
        }
    }

    AssertF(this->df.dwNumObjs <= cJoyStateObjTotal);

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | PreInit |
 *
 *          Preallocate all the memory we will need up front, so we
 *          don't waste time reallocating later.
 *
 *****************************************************************************/

HRESULT INLINE
CJoy_PreInit(PDJ this)
{
    HRESULT hres;

    hres = ReallocCbPpv(cbCxX(cJoyStateObjTotal, DIOBJECTDATAFORMAT),
                        &this->df.rgodf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitRing0 |
 *
 *          Initialize the ring 0 information maintained about the object.
 *
 *          Broken out from CJoy_Init to make things less monolithic.
 *
 *****************************************************************************/

HRESULT INTERNAL
CJoy_InitRing0(PDJ this)
{
    HRESULT hres;
    VXDDEVICEFORMAT devf;

    /*
     *  Note that we now allow the device to be created even if
     *  the joystick doesn't physically exist.  This is necessary
     *  so that IDirectInputJoyConfig can calibrate the joystick
     *  that doesn't exist yet.
     *
     *  This won't confuse applications, however, because
     *  IDirectInput::EnumDevices will not return phantom devices
     *  unless the application explicitly asks for phantom devices
     *  to be included.
     */

    /*
     *  This code is indented an extra level for historical reasons.
     */

        this->dc.dwSize = cbX(DIDEVCAPS);
        /* this->dc.dwDevType will be initialized later */

    /*
     *  See if this joystick supports fancy notifications.
     *  The default is "no".
     *
     *  Also see if this is really a HID device (and hence our
     *  interface is an alias).
     *
     *  These things are all 9x-specific.
     */
    this->dc.dwFlags |= DIDC_POLLEDDEVICE;

     /* This never happens on NT */
    if( !fWinnt )
    {
        VXDINITPARMS vip;

        hres = Hel_Joy_GetInitParms(this->idJoy, &vip);
        if (SUCCEEDED(hres)) {
            if (vip.dwFlags & VIP_SENDSNOTIFY) {
                this->dc.dwFlags &= ~DIDC_POLLEDDEVICE;
            }

            if (vip.dwFlags & VIP_ISHID)
            {
              #ifdef DEBUG
                TCHAR        szJoyProp[] = REGSTR_PATH_PRIVATEPROPERTIES TEXT("\\Joystick");
                HKEY         hkJoyProp;
                TCHAR        szUseHid[] = TEXT("UseHidPath");
                DWORD        dwUseHid = 0;

                hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE,
                                       szJoyProp,
                                       DI_KEY_ALL_ACCESS,
                                       REG_OPTION_NON_VOLATILE,
                                       &hkJoyProp);

                if ( SUCCEEDED(hres) )
                {
                    DWORD cb = sizeof(dwUseHid);
                    LONG  lRc;

                    lRc = RegQueryValueEx(hkJoyProp, szUseHid, 0, 0, (LPBYTE)&dwUseHid, &cb);

                    if ( lRc != ERROR_SUCCESS )
                    {
                        DWORD dwDefault = 1;

                        dwUseHid = dwDefault;
                        lRc = RegSetValueEx(hkJoyProp, szUseHid, 0, REG_DWORD, (LPBYTE)&dwDefault, cb);
                    }

                    RegCloseKey(hkJoyProp);
                }

                if( dwUseHid )
                {
                    this->dc.dwFlags |= DIDC_ALIAS;
                }
              #endif

                /*
                 * Always use VJOYD as Alias if the device is HID.
                 */
                this->dc.dwFlags |= DIDC_ALIAS;

            }

        }
    }

    /*
     *  Build the worst-case data format for the VxD.
     *
     *  We must always build worst-case because sometime
     *  later, a newer more capable joystick might show up,
     *  with more objects than the one we imprinted on.
     */

    CJoy_BuildDataFormat(this, &c_vacMax, cJoyStateButtonTotal);

    /*
     *  It won't actually get that high because of the
     *  nonexistent Rx and Ry axes.
     */
    AssertF(this->df.dwNumObjs <= cJoyStateObjTotal);

    devf.cbData = cbX(DIJOYSTATE2);
    devf.dwExtra = this->idJoy;
    devf.cObj = this->df.dwNumObjs;
    devf.rgodf = this->df.rgodf;
    devf.dwEmulation = 0;

    hres = Hel_Joy_CreateInstance(&devf, &this->pvi);
    if (SUCCEEDED(hres)) {
        AssertF(this->pvi);
        this->pjsPhys = this->pvi->pState;
    } else {                /* IOCTL failed; hres already set */
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitRing3 |
 *
 *          Initialize the ring 3 information maintained about the object.
 *
 *          Broken out from CJoy_Init to make things less monolithic.
 *
 *****************************************************************************/

HRESULT INTERNAL
CJoy_InitRing3(PDJ this)
{
    HRESULT hres;
    VXDAXISCAPS vac;
    JOYCAPS jc;

    /*
     *  We must ask for DIJC_CALLOUT even though we don't care,
     *  because that will trigger the Microsoft Gamepad hack-o-rama.
     */
    hres = JoyReg_GetConfig(this->idJoy, &jc, &this->cfg,
                            DIJC_REGHWCONFIGTYPE | DIJC_CALLOUT );
    if (SUCCEEDED(hres)) {
        /*
         * Fix phantom devices bug. See manbug: 23186
         */
        if( this->cfg.hwc.dwType == JOY_HW_NONE ) {
            hres = E_FAIL;
            goto done;
        }

        /*
         *  Open the type key so we can grovel into the type info.
         *  If the RegOpenKeyEx fails, the value of this->hkType
         *  will stay zero so we won't run with garbage.
         *
         *  Note that failure to open the type key is not an error.
         *
         *  We need to do this before building the data format, because
         *  BuildDataFormat needs the hkType to get the attributes.
         */
        AssertF(this->hkType == 0);

        /*
         *  Only open the key if it is intended to exist
         */
        if( this->cfg.hwc.dwUsageSettings & JOY_US_ISOEM )
        {
            JoyReg_OpenTypeKey(this->cfg.wszType, MAXIMUM_ALLOWED,
                               REG_OPTION_NON_VOLATILE, &this->hkType);
        }

        hres = Hel_Joy_GetAxisCaps(this->idJoy, &vac, &jc);
        /*
         *  HACKHACK
         *  In the case of a DX5 VJoyD, the POV0 flag can be stripped out of 
         *  the vac if the poll returns a POV0 value other than (DWORD)-1.
         *  So add it back if the registry says we have it.
         */
        if( this->cfg.hwc.hws.dwFlags & JOY_HWS_HASPOV )
        {
            DWORD dwVersion = GetVersion();

            /*
             *  Check for any Win95 version
             */
            if( ( LOBYTE( dwVersion ) == 4 )
             && ( HIBYTE( LOWORD( dwVersion ) ) < 10 ) )
            {
                vac.dwPos |= JOYPF_POV0;
            }

        }
        jc.wNumButtons = this->cfg.hwc.hws.dwNumButtons;

        AssertF(SUCCEEDED(hres));

        CJoy_BuildDataFormat(this, &vac, jc.wNumButtons);

        if (jc.wCaps & JOYCAPS_POV4DIR) {
            this->dwPOVGranularity = 9000;
        } else {
            this->dwPOVGranularity = 1;
        }

        /*
         *  Logical ranges must be done before physical ranges,
         *  because initializing the physical ranges will also
         *  recompute the ramp conversion parameters.
         */
        CJoy_InitLogRanges(this);

        CJoy_InitPhysRanges(this, &this->cfg.hwc);

        hres = CJoy_InitFromHwc(this);

#if !defined(WINNT) && DIRECTINPUT_VERSION > 0x050A
        if( this->hkType )
        {
            DWORD dwFlags1;
            if( SUCCEEDED( JoyReg_GetValue( this->hkType,
                    REGSTR_VAL_FLAGS1, REG_BINARY,
                    &dwFlags1,
                    cbX(dwFlags1) ) ) )
            {
                if( dwFlags1 & JOYTYPE_NOHIDDIRECT )
                {
                    this->dc.dwFlags &= ~DIDC_ALIAS;
                }
            }
        }
#endif

#if (DIRECTINPUT_VERSION > 0x061A)
        this->diHacks.nMaxDeviceNameLength = MAX_PATH;
#endif

    } else {
        RPF("Unexpected error obtaining joystick capabilities");
        hres = E_FAIL;
    }

done:
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | Init |
 *
 *          Initialize the object by establishing the data format
 *          based on the joystick capabilities.
 *
 *****************************************************************************/

HRESULT INTERNAL
CJoy_Init(PDJ this, REFGUID rguid)
{
    HRESULT hres;
    EnterProc(CJoy_Init, (_ "pG", this, rguid));

    this->idJoy = rguid->Data1 & 0xF;

    /* If joystick number is vaguely valid */
    if (this->idJoy < cJoyMax) {

        if (SUCCEEDED(hres = CJoy_PreInit(this)) &&
            SUCCEEDED(hres = CJoy_InitRing0(this)) &&
            SUCCEEDED(hres = CJoy_InitRing3(this))) {
        }
    } else {
        hres = DIERR_DEVICENOTREG;
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      CJoy_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Joy::<constructor>,
               (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CJoy, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv in case of aggregation */
        PDJ this = _thisPv(*ppvObj);

        if (SUCCEEDED(hres = CJoy_Init(this, rguid))) {
        } else {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | SetDIData |
 *
 *          Set DirectInput version and apphack data from CDIDev *.
 *
 *  @parm   DWORD | dwVer |
 *
 *          DirectInput version
 *
 *  @parm   LPVOID | lpdihacks |
 *
 *          AppHack data
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we don't support usages.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::SetDIData,
               (_ "pup", pdcb, dwVer, lpdihacks));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    this->dwVersion = dwVer;

    if( ( this->dwVersion < 0x0700 ) && ( this->dwVersion != 0x05B2 ) )
    {
        /*
         *  Post DX7 Gold Fix
         *  Keep this as the default interface for older apps
         *  unless it's the CPL
         */
        this->dc.dwFlags &= ~DIDC_ALIAS;
    }

    ((LPDIAPPHACKS)lpdihacks)->dwDevType = this->dc.dwDevType;

    CopyMemory(&this->diHacks, (LPDIAPPHACKS)lpdihacks, sizeof(this->diHacks));

    hres = S_OK;

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#define CJoy_Signature        0x2044424B      /* "Joy " */

Interface_Template_Begin(CJoy)
    Primary_Interface_Template(CJoy, IDirectInputDeviceCallback)
Interface_Template_End(CJoy)

Primary_Interface_Begin(CJoy, IDirectInputDeviceCallback)
    CJoy_GetInstance,
    CJoy_GetVersions,
    CJoy_GetDataFormat,
    CJoy_GetObjectInfo,
    CJoy_GetCapabilities,
    CDefDcb_Acquire,
    CDefDcb_Unacquire,
    CJoy_GetDeviceState,
    CJoy_GetDeviceInfo,
    CJoy_GetProperty,
    CJoy_SetProperty,
    CDefDcb_SetEventNotification,
    CJoy_SetCooperativeLevel,
    CJoy_RunControlPanel,
    CJoy_CookDeviceData,
    CJoy_CreateEffect,
    CJoy_GetFFConfigKey,
    CDefDcb_SendDeviceData,
    CJoy_Poll,
    CDefDcb_GetUsage,
    CDefDcb_MapUsage,
    CJoy_SetDIData,
Primary_Interface_End(CJoy, IDirectInputDeviceCallback)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\diextdll.c ===
/*****************************************************************************
 *
 *  DIExtDll.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Dynamic loading of optional external DLLs.
 *
 *  Contents:
 *
 *      ExtDll_Init
 *      ExtDll_Term
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflExtDll

#ifdef HID_SUPPORT

/*****************************************************************************
 *
 *  @define T | TEXT(ch) |
 *
 *          Either "A" or "W", depending on whether we are building
 *          the ANSI or UNICODE version.
 *
 *****************************************************************************/

    #ifdef UNICODE
        #define T       "W"
    #else
        #define T       "A"
    #endif

/*****************************************************************************
 *
 *  @define MAKEAPINAME | nm |
 *
 *          Emit a c_sz that records the name of the API.
 *
 *****************************************************************************/

    #define MAKEAPINAME(nm)     CHAR c_sz##nm[] = #nm

#ifndef STATIC_DLLUSAGE

/*****************************************************************************
 *
 *  CFGMGR32
 *
 *  Note that this must match the CFGMGR32 structure in dihid.h
 *
 *****************************************************************************/

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(CM_Get_Child);
MAKEAPINAME(CM_Get_Sibling);
MAKEAPINAME(CM_Get_Parent);
MAKEAPINAME(CM_Get_DevNode_Registry_Property) T;
MAKEAPINAME(CM_Set_DevNode_Registry_Property) T;
MAKEAPINAME(CM_Get_Device_ID) T;
        #pragma END_CONST_DATA
        
#ifndef WINNT
LPSTR g_cfgmgr32_fn[] = {
    c_szCM_Get_Child,
    c_szCM_Get_Sibling,
    c_szCM_Get_Parent,
    c_szCM_Get_DevNode_Registry_Property,
    c_szCM_Set_DevNode_Registry_Property,
    c_szCM_Get_Device_ID
};

HINSTANCE g_hinstcfgmgr32;

CFGMGR32 g_cfgmgr32 = {
    (FARPROC)DIDummy_CM_Get_Child,
    (FARPROC)DIDummy_CM_Get_Sibling,
    (FARPROC)DIDummy_CM_Get_Parent,
    (FARPROC)DIDummy_CM_Get_DevNode_Registry_Property,
    (FARPROC)DIDummy_CM_Set_DevNode_Registry_Property,
    (FARPROC)DIDummy_CM_Get_Device_ID
};
#endif //WINNT

/*****************************************************************************
 *
 *  SETUPAPI
 *
 *  Note that this must match the SETUPAPI structure in dihid.h
 *
 *****************************************************************************/

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(SetupDiGetClassDevs) T;
MAKEAPINAME(SetupDiDestroyDeviceInfoList);
MAKEAPINAME(SetupDiGetDeviceInterfaceDetail) T;
MAKEAPINAME(SetupDiEnumDeviceInterfaces);
MAKEAPINAME(SetupDiCreateDeviceInterfaceRegKey) T;
MAKEAPINAME(SetupDiCallClassInstaller);
MAKEAPINAME(SetupDiGetDeviceRegistryProperty) T;
MAKEAPINAME(SetupDiSetDeviceRegistryProperty) T;
MAKEAPINAME(SetupDiGetDeviceInstanceId) T;
MAKEAPINAME(SetupDiOpenDeviceInfo) T;
MAKEAPINAME(SetupDiCreateDeviceInfoList);
MAKEAPINAME(SetupDiOpenDevRegKey);
        #pragma END_CONST_DATA

LPSTR g_setupapi_fn[] = {
    c_szSetupDiGetClassDevs,
    c_szSetupDiDestroyDeviceInfoList,
    c_szSetupDiGetDeviceInterfaceDetail,
    c_szSetupDiEnumDeviceInterfaces,
    c_szSetupDiCreateDeviceInterfaceRegKey,
    c_szSetupDiCallClassInstaller,
    c_szSetupDiGetDeviceRegistryProperty,
    c_szSetupDiSetDeviceRegistryProperty,
    c_szSetupDiGetDeviceInstanceId,
    c_szSetupDiOpenDeviceInfo,
    c_szSetupDiCreateDeviceInfoList,
    c_szSetupDiOpenDevRegKey,
  #ifdef WINNT
    c_szCM_Get_Child,
    c_szCM_Get_Sibling,
    c_szCM_Get_Parent,
    c_szCM_Get_DevNode_Registry_Property,
    c_szCM_Set_DevNode_Registry_Property,
    c_szCM_Get_Device_ID
  #endif
};

HINSTANCE g_hinstSetupapi;

SETUPAPI g_setupapi = {
    (FARPROC)DIDummy_SetupDiGetClassDevs,
    (FARPROC)DIDummy_SetupDiDestroyDeviceInfoList,
    (FARPROC)DIDummy_SetupDiGetDeviceInterfaceDetail,
    (FARPROC)DIDummy_SetupDiEnumDeviceInterfaces,
    (FARPROC)DIDummy_SetupDiCreateDeviceInterfaceRegKey,
    (FARPROC)DIDummy_SetupDiCallClassInstaller,
    (FARPROC)DIDummy_SetupDiGetDeviceRegistryProperty,
    (FARPROC)DIDummy_SetupDiSetDeviceRegistryProperty,
    (FARPROC)DIDummy_SetupDiGetDeviceInstanceId,
    (FARPROC)DIDummy_SetupDiOpenDeviceInfo,
    (FARPROC)DIDummy_SetupDiCreateDeviceInfoList,
    (FARPROC)DIDummy_SetupDiOpenDevRegKey,
  #ifdef WINNT
    (FARPROC)DIDummy_CM_Get_Child,
    (FARPROC)DIDummy_CM_Get_Sibling,
    (FARPROC)DIDummy_CM_Get_Parent,
    (FARPROC)DIDummy_CM_Get_DevNode_Registry_Property,
    (FARPROC)DIDummy_CM_Set_DevNode_Registry_Property,
    (FARPROC)DIDummy_CM_Get_Device_ID
  #endif    
};

/*****************************************************************************
 *
 *  HIDDLL
 *
 *  Note that this must match the HIDDLL structure in dihid.h
 *
 *****************************************************************************/

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(HidD_GetHidGuid);
MAKEAPINAME(HidD_GetPreparsedData);
MAKEAPINAME(HidD_FreePreparsedData);
MAKEAPINAME(HidD_FlushQueue);
MAKEAPINAME(HidD_GetAttributes);
MAKEAPINAME(HidD_GetFeature);
MAKEAPINAME(HidD_SetFeature);
MAKEAPINAME(HidD_GetProductString);
MAKEAPINAME(HidD_GetInputReport);
MAKEAPINAME(HidP_GetCaps);
MAKEAPINAME(HidP_GetButtonCaps);
MAKEAPINAME(HidP_GetValueCaps);
MAKEAPINAME(HidP_GetLinkCollectionNodes);
MAKEAPINAME(HidP_MaxDataListLength);
MAKEAPINAME(HidP_GetUsagesEx);
MAKEAPINAME(HidP_GetScaledUsageValue);
MAKEAPINAME(HidP_GetData);
MAKEAPINAME(HidP_SetData);
MAKEAPINAME(HidP_GetUsageValue);
MAKEAPINAME(HidP_MaxUsageListLength);
MAKEAPINAME(HidP_GetSpecificButtonCaps);
        #pragma END_CONST_DATA

LPSTR g_hiddll_fn[] = {
    c_szHidD_GetHidGuid,
    c_szHidD_GetPreparsedData,
    c_szHidD_FreePreparsedData,
    c_szHidD_FlushQueue,
    c_szHidD_GetAttributes,
    c_szHidD_GetFeature,
    c_szHidD_SetFeature,
    c_szHidD_GetProductString,
    c_szHidD_GetInputReport,
    c_szHidP_GetCaps,
    c_szHidP_GetButtonCaps,
    c_szHidP_GetValueCaps,
    c_szHidP_GetLinkCollectionNodes,
    c_szHidP_MaxDataListLength,
    c_szHidP_GetUsagesEx,
    c_szHidP_GetScaledUsageValue,
    c_szHidP_GetData,
    c_szHidP_SetData,
    c_szHidP_GetUsageValue,
    c_szHidP_MaxUsageListLength,
    c_szHidP_GetSpecificButtonCaps,
};

HINSTANCE g_hinstHid;

HIDDLL g_hiddll = {
    (FARPROC)DIDummy_HidD_GetHidGuid,
    (FARPROC)DIDummy_HidD_GetPreparsedData,
    (FARPROC)DIDummy_HidD_FreePreparsedData,
    (FARPROC)DIDummy_HidD_FlushQueue,
    (FARPROC)DIDummy_HidD_GetAttributes,
    (FARPROC)DIDummy_HidD_GetFeature,
    (FARPROC)DIDummy_HidD_SetFeature,
    (FARPROC)DIDummy_HidD_GetProductString,
    (FARPROC)DIDummy_HidD_GetInputReport,
    (FARPROC)DIDummy_HidP_GetCaps,
    (FARPROC)DIDummy_HidP_GetButtonCaps,
    (FARPROC)DIDummy_HidP_GetValueCaps,
    (FARPROC)DIDummy_HidP_GetLinkCollectionNodes,
    (FARPROC)DIDummy_HidP_MaxDataListLength,
    (FARPROC)DIDummy_HidP_GetUsagesEx,
    (FARPROC)DIDummy_HidP_GetScaledUsageValue,
    (FARPROC)DIDummy_HidP_GetData,
    (FARPROC)DIDummy_HidP_SetData,
    (FARPROC)DIDummy_HidP_GetUsageValue,
    (FARPROC)DIDummy_HidP_MaxUsageListLength,
    (FARPROC)DIDummy_HidP_GetSpecificButtonCaps,
};

/*****************************************************************************
 *
 *  Winmm
 *
 *  Note that this must match the Winmm structure in dihid.h
 *
 *****************************************************************************/

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(joyGetDevCaps) T;
MAKEAPINAME(joyGetPosEx);
MAKEAPINAME(joyGetPos);
MAKEAPINAME(joyConfigChanged);
        #pragma END_CONST_DATA

LPSTR g_winmmdll_fn[] = {
    c_szjoyGetDevCaps,
    c_szjoyGetPosEx,
    c_szjoyGetPos,
    c_szjoyConfigChanged,
};

HINSTANCE g_hinstwinmmdll;

WINMMDLL g_winmmdll = {
    (FARPROC)DIDummy_joyGetDevCaps,
    (FARPROC)DIDummy_joyGetPosEx,
    (FARPROC)DIDummy_joyGetPos,
    (FARPROC)DIDummy_joyConfigChanged,
};


/*****************************************************************************
 *
 *  User32
 *
 *  Note that this must match the User32 structure in dihid.h
 *
 *****************************************************************************/

#ifdef USE_WM_INPUT

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(RegisterRawInputDevices);
MAKEAPINAME(GetRawInputData);
        #pragma END_CONST_DATA

LPSTR g_user32_fn[] = {
    c_szRegisterRawInputDevices,
    c_szGetRawInputData,
};

HINSTANCE g_hinstuser32;

USER32 g_user32 = {
    (FARPROC)DIDummy_RegisterRawInputDevices,
    (FARPROC)DIDummy_GetRawInputData,
};

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HINSTANCE | ExtDll_LoadDll |
 *
 *          Loads a DLL and resolves all the imports.
 *
 *  @parm   LPCTSTR | ptszName |
 *
 *          The name of the DLL to load.
 *
 *  @parm   PMANUALIMPORT | rgmi |
 *
 *          Array of <t MANUALIMPORT> structures to resolve.
 *
 *  @parm   int | cmi |
 *
 *          Number of <t MANUALIMPORT> structures to resolve.
 *
 *  @parm   LPSTR * | ppszProcName |
 * 
 *          Function names.
 *
 *  @returns
 *
 *          Returns the instance handle of the DLL if one or more of the imports
 *          were resolved successfully; otherwise, unloads the DLL
 *          and returns 0.
 *
 *          If none of the imports was resolved successfully, the value
 *          of the entries of <p rgmi> are not changed.
 *
 *****************************************************************************/

HINSTANCE INTERNAL
    ExtDll_LoadDll(LPCTSTR ptszName, PMANUALIMPORT rgmi, int cmi, LPSTR *ppszProcName)
{
    HINSTANCE hinst = 0;
    BOOL      fNeedFreeLib = TRUE;

    EnterProcR(ExtDll_LoadDll, (_ "spuup", ptszName, rgmi, cmi, ppszProcName));

    hinst = LoadLibrary(ptszName);
    if(hinst)
    {
        int     imi;
        FARPROC fp;

        for(imi = 0; imi < cmi; imi++)
        {
            fp = GetProcAddress(hinst, ppszProcName[imi]);
            if( fp ) {
                rgmi[imi].pfn = fp;
                fNeedFreeLib = FALSE;
            }
        }
    }

    if( fNeedFreeLib ) {
        FreeLibrary(hinst);
        hinst = 0;
    }
        
    ExitProcX((UINT_PTR)hinst);
    
    return hinst;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ExtDll_Init |
 *
 *          Try to load our optional DLLs.  Don't get upset if they
 *          don't load.
 *
 *****************************************************************************/

void EXTERNAL
    ExtDll_Init(void)
{
    g_hinstHid =      ExtDll_LoadDll(TEXT("HID.DLL"),
                                g_hiddll.rgmi,
                                cA(g_hiddll.rgmi),
                                g_hiddll_fn ); 
    
    g_hinstSetupapi = ExtDll_LoadDll(TEXT("SETUPAPI.DLL"),
                                g_setupapi.rgmi,
                                cA(g_setupapi.rgmi),
                                g_setupapi_fn );
    
  #ifndef WINNT
    g_hinstcfgmgr32 = ExtDll_LoadDll( TEXT("CFGMGR32.DLL" ),
                                g_cfgmgr32.rgmi,
                                cA(g_cfgmgr32.rgmi),
                                g_cfgmgr32_fn );
    
    g_hinstwinmmdll = ExtDll_LoadDll( TEXT("WINMM.DLL" ),
                                g_winmmdll.rgmi,
                                cA(g_winmmdll.rgmi),
                                g_winmmdll_fn );
  #endif
                                

  #ifdef USE_WM_INPUT
    g_hinstuser32   = ExtDll_LoadDll( TEXT("USER32.DLL" ),
                                g_user32.rgmi,
                                cA(g_user32.rgmi),
                                g_user32_fn );
  #endif

}

#endif /* STATIC_DLLUSAGE */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ExtDll_Term |
 *
 *          Unload any optional DLLs that we loaded.
 *
 *****************************************************************************/

void EXTERNAL
    ExtDll_Term(void)
{

  #ifndef STATIC_DLLUSAGE
    if(g_hinstSetupapi)
    {
  #endif /* STATIC_DLLUSAGE */

        DllEnterCrit();
        if(g_phdl)
        {
            DIHid_EmptyHidList();
            FreePpv(&g_phdl);
        }

        DIBus_FreeMemory();

        DllLeaveCrit();

#ifndef STATIC_DLLUSAGE
        FreeLibrary(g_hinstSetupapi);
        g_hinstSetupapi = NULL;
    }

  #ifndef WINNT
    if(g_hinstcfgmgr32)
    {
        FreeLibrary(g_hinstcfgmgr32);
        g_hinstcfgmgr32 = NULL;
    }
  #endif

    if(g_hinstHid)
    {
        FreeLibrary(g_hinstHid);
        g_hinstHid = NULL;
    }

    if( g_hinstwinmmdll)
    {
        FreeLibrary(g_hinstwinmmdll);
        g_hinstwinmmdll = NULL;
    }

  #ifdef USE_WM_INPUT    
    if( g_hinstuser32)
    {
        FreeLibrary(g_hinstuser32);
        g_hinstuser32 = NULL;
    }
  #endif
    
#endif /* STATIC_DLLUSAGE */

}

#ifndef STATIC_DLLUSAGE

////////////////////////////////////////
// cfgmgr32.dll dummy functions
////////////////////////////////////////

CONFIGRET WINAPI DIDummy_CM_Get_Child
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  dnDevInst,
IN  ULONG    ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_Child( %08x, %08x, %u )"),
                     pdnDevInst, dnDevInst, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Get_Sibling
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  DevInst,
IN  ULONG    ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_Sibling( %08x, %08x, %u )"),
                     pdnDevInst, DevInst, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Get_Parent
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  dnDevInst,
IN  ULONG    ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_Parent( %08x, %08x, %u )"),
                     pdnDevInst, dnDevInst, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Get_DevNode_Registry_Property
(
IN  DEVINST     dnDevInst,
IN  ULONG       ulProperty,
OUT PULONG      pulRegDataType,   OPTIONAL
OUT PVOID       Buffer,           OPTIONAL
IN  OUT PULONG  pulLength,
IN  ULONG       ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_DevNode_Registry_Property( %08x, %u, %08x, %08x, %08x, %u )"),
                     dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Set_DevNode_Registry_Property
(
IN  DEVINST     dnDevInst,
IN  ULONG       ulProperty,
IN  PVOID       Buffer,           OPTIONAL
IN  ULONG       ulLength,
IN  ULONG       ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Set_DevNode_Registry_Property( %08x, %u, %08x, %u, %u )"),
                     dnDevInst, ulProperty, Buffer, ulLength, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Get_Device_ID
(
 IN  DEVINST  dnDevInst,
 OUT PTCHAR   Buffer,
 IN  ULONG    BufferLen,
 IN  ULONG    ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_Device_ID( %08x, %08x, %u, %u )"),
                     dnDevInst, Buffer, BufferLen, ulFlags );

    return CR_FAILURE;
}

////////////////////////////////////////
//Setupapi.dll dummy functions
////////////////////////////////////////

HDEVINFO WINAPI DIDummy_SetupDiGetClassDevs
(
IN LPGUID ClassGuid,  OPTIONAL
IN LPCTSTR Enumerator, OPTIONAL
IN HWND   hwndParent, OPTIONAL
IN DWORD  Flags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetClassDevs( %08x, %08x, %08x, %u )"),
                     ClassGuid, Enumerator, hwndParent, Flags );

    return INVALID_HANDLE_VALUE;    
}

BOOL WINAPI DIDummy_SetupDiDestroyDeviceInfoList
(
IN HDEVINFO DeviceInfoSet
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiDestroyDeviceInfoList( %08x )"),
                     DeviceInfoSet );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiGetDeviceInterfaceDetail
(
IN  HDEVINFO                         DeviceInfoSet,
IN  PSP_DEVICE_INTERFACE_DATA        pdid,
OUT PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd,         OPTIONAL
IN  DWORD                            cbDidd,
OUT PDWORD                           RequiredSize,  OPTIONAL
OUT PSP_DEVINFO_DATA                 DeviceInfoData OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetDeviceInterfaceDetail( %08x, %08x, %08x, %u, %08x, %08x )"),
                     DeviceInfoSet, pdid, pdidd, cbDidd, RequiredSize, DeviceInfoData );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiEnumDeviceInterfaces
(
IN  HDEVINFO                  DeviceInfoSet,
IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
IN  LPGUID                    InterfaceClassGuid,
IN  DWORD                     MemberIndex,
OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiEnumDeviceInterfaces( %08x, %08x, %08x, %u, %08x )"),
                     DeviceInfoSet, DeviceInfoData, InterfaceClassGuid, MemberIndex, DeviceInterfaceData );

    return FALSE;
}

HKEY WINAPI DIDummy_SetupDiCreateDeviceInterfaceRegKey
(
IN HDEVINFO                  hdev,
IN PSP_DEVICE_INTERFACE_DATA pdid,
IN DWORD                     Reserved,
IN REGSAM                    samDesired,
IN HINF                      InfHandle,           OPTIONAL
IN PCSTR                     InfSectionName       OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiCreateDeviceInterfaceRegKey( %08x, %08x, %u, %u, %08x, %s )"),
                     hdev, pdid, Reserved, samDesired, InfHandle, InfSectionName );

    return INVALID_HANDLE_VALUE;
}

BOOL WINAPI DIDummy_SetupDiCallClassInstaller
(
IN DI_FUNCTION      InstallFunction,
IN HDEVINFO         DeviceInfoSet,
IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiCallClassInstaller( %08x, %08x, %08x )"),
                     InstallFunction, DeviceInfoSet, DeviceInfoData );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiGetDeviceRegistryProperty
(
IN  HDEVINFO         DeviceInfoSet,
IN  PSP_DEVINFO_DATA DeviceInfoData,
IN  DWORD            Property,
OUT PDWORD           PropertyRegDataType, OPTIONAL
OUT PBYTE            PropertyBuffer,
IN  DWORD            PropertyBufferSize,
OUT PDWORD           RequiredSize         OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetDeviceRegistryProperty( %08x, %08x, %u, %08x, %08x, %u, %08x )"),
                     DeviceInfoSet, DeviceInfoData, Property, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiSetDeviceRegistryProperty
(
IN     HDEVINFO         DeviceInfoSet,
IN OUT PSP_DEVINFO_DATA DeviceInfoData,
IN     DWORD            Property,
IN     CONST BYTE*      PropertyBuffer,
IN     DWORD            PropertyBufferSize
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetDeviceInstanceId( %08x, %08x, %u, %08x, %u )"),
                     DeviceInfoSet, DeviceInfoData, Property, PropertyBuffer, PropertyBufferSize );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiGetDeviceInstanceId
(
IN  HDEVINFO         DeviceInfoSet,
IN  PSP_DEVINFO_DATA DeviceInfoData,
OUT PTSTR            DeviceInstanceId,
IN  DWORD            DeviceInstanceIdSize,
OUT PDWORD           RequiredSize          OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetDeviceInstanceId( %08x, %08x, %08x, %u, %08x )"),
                     DeviceInfoSet, DeviceInfoData, DeviceInstanceId, DeviceInstanceIdSize, RequiredSize );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiOpenDeviceInfo
(
IN  HDEVINFO         DeviceInfoSet,
IN  LPCTSTR          DeviceInstanceId,
IN  HWND             hwndParent,       OPTIONAL
IN  DWORD            OpenFlags,
OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiOpenDeviceInfo( %08x, %08x, %08x, %u, %08x )"),
                     DeviceInfoSet, DeviceInstanceId, hwndParent, OpenFlags, DeviceInfoData );

    return FALSE;
}

HDEVINFO WINAPI DIDummy_SetupDiCreateDeviceInfoList
(
IN LPGUID ClassGuid, OPTIONAL
IN HWND   hwndParent OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiCreateDeviceInfoList( %08x, %08x )"),
                     ClassGuid, hwndParent );

    return INVALID_HANDLE_VALUE;
}

HKEY WINAPI DIDummy_SetupDiOpenDevRegKey
(
IN HDEVINFO         DeviceInfoSet,
IN PSP_DEVINFO_DATA DeviceInfoData,
IN DWORD            Scope,
IN DWORD            HwProfile,
IN DWORD            KeyType,
IN REGSAM           samDesired
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiOpenDevRegKey( %08x, %08x, %u, %u, %u, %u )"),
                     DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType, samDesired );

    return INVALID_HANDLE_VALUE;
}

////////////////////////////////////////
// hid.dll dummy functions
////////////////////////////////////////

void __stdcall DIDummy_HidD_GetHidGuid
(
OUT   LPGUID   HidGuid
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetHidGuid( %08x )"),
                     HidGuid );

    return;
}

BOOLEAN __stdcall DIDummy_HidD_GetPreparsedData
(
IN    HANDLE                  HidDeviceObject,
OUT   PHIDP_PREPARSED_DATA  * PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetPreparsedData( %08x, %08x )"),
                     HidDeviceObject, PreparsedData );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_FreePreparsedData
(
IN    PHIDP_PREPARSED_DATA PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_FreePreparsedData( %08x )"),
                     PreparsedData );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_FlushQueue  //unused
(
IN    HANDLE                HidDeviceObject
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_FlushQueue( %08x )"),
                     HidDeviceObject );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_GetAttributes
(
IN  HANDLE              HidDeviceObject,
OUT PHIDD_ATTRIBUTES    Attributes
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetAttributes( %08x, %08x )"),
                     HidDeviceObject, Attributes );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_GetFeature
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetFeature( %08x, %08x, %u )"),
                     HidDeviceObject, ReportBuffer, ReportBufferLength );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_SetFeature
(
IN    HANDLE   HidDeviceObject,
IN    PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_SetFeature( %08x, %08x, %u )"),
                     HidDeviceObject, ReportBuffer, ReportBufferLength );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_GetProductString
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    Buffer,
IN    ULONG    BufferLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetProductString( %08x, %08x, %u )"),
                     HidDeviceObject, Buffer, BufferLength );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_GetInputReport
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetProductString( %08x, %08x, %u )"),
                     HidDeviceObject, ReportBuffer, ReportBufferLength );

    return FALSE;
}

NTSTATUS __stdcall DIDummy_HidP_GetCaps
(
IN      PHIDP_PREPARSED_DATA      PreparsedData,
OUT     PHIDP_CAPS                Capabilities
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetCaps( %08x, %08x )"),
                     PreparsedData, Capabilities );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetButtonCaps
(
IN       HIDP_REPORT_TYPE     ReportType,
OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
IN OUT   PUSHORT              ButtonCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetButtonCaps( %08x, %08x, %08x, %08x )"),
                     ReportType, ButtonCaps, ButtonCapsLength, PreparsedData );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetValueCaps
(
IN       HIDP_REPORT_TYPE     ReportType,
OUT      PHIDP_VALUE_CAPS     ValueCaps,
IN OUT   PUSHORT              ValueCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetValueCaps( %08x, %08x, %08x, %08x )"),
                     ReportType, ValueCaps, ValueCapsLength, PreparsedData );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetLinkCollectionNodes
(
OUT      PHIDP_LINK_COLLECTION_NODE LinkCollectionNodes,
IN OUT   PULONG                     LinkCollectionNodesLength,
IN       PHIDP_PREPARSED_DATA       PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetLinkCollectionNodes( %08x, %08x, %08x )"),
                     LinkCollectionNodes, LinkCollectionNodesLength, PreparsedData );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

ULONG __stdcall DIDummy_HidP_MaxDataListLength
(
IN HIDP_REPORT_TYPE      ReportType,
IN PHIDP_PREPARSED_DATA  PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_MaxDataListLength( %08x, %08x )"),
                     ReportType, PreparsedData );

    return 0;
}

NTSTATUS __stdcall DIDummy_HidP_GetUsagesEx   //unused
(
IN       HIDP_REPORT_TYPE     ReportType,
IN       USHORT               LinkCollection,
OUT      PUSAGE_AND_PAGE      ButtonList,
IN OUT   ULONG *              UsageLength,
IN       PHIDP_PREPARSED_DATA PreparsedData,
IN       PCHAR                Report,
IN       ULONG                ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetUsagesEx( %08x, %u, %08x, %08x, %08x, %08x, %u )"),
                     ReportType, LinkCollection, ButtonList, UsageLength, PreparsedData, Report, ReportLength );
	
    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetScaledUsageValue  //unused
(
IN    HIDP_REPORT_TYPE     ReportType,
IN    USAGE                UsagePage,
IN    USHORT               LinkCollection,
IN    USAGE                Usage,
OUT   PLONG                UsageValue,
IN    PHIDP_PREPARSED_DATA PreparsedData,
IN    PCHAR                Report,
IN    ULONG                ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetScaledUsageValue( %08x, %u, %u, %u, %08x, %08x, %08x, %u )"),
                     ReportType, UsagePage, LinkCollection, Usage, UsageValue, PreparsedData, Report, ReportLength );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetData
(
IN       HIDP_REPORT_TYPE      ReportType,
OUT      PHIDP_DATA            DataList,
IN OUT   PULONG                DataLength,
IN       PHIDP_PREPARSED_DATA  PreparsedData,
IN       PCHAR                 Report,
IN       ULONG                 ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetData( %08x, %08x, $08x, %08x, %08x, %u )"),
                     ReportType, DataList, DataLength, PreparsedData, Report, ReportLength );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_SetData
(
IN       HIDP_REPORT_TYPE      ReportType,
IN       PHIDP_DATA            DataList,
IN OUT   PULONG                DataLength,
IN       PHIDP_PREPARSED_DATA  PreparsedData,
IN OUT   PCHAR                 Report,
IN       ULONG                 ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_SetData( %08x, %08x, $08x, %08x, %08x, %u )"),
                     ReportType, DataList, DataLength, PreparsedData, Report, ReportLength );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetUsageValue
(
IN    HIDP_REPORT_TYPE     ReportType,
IN    USAGE                UsagePage,
IN    USHORT               LinkCollection,
IN    USAGE                Usage,
OUT   PULONG               UsageValue,
IN    PHIDP_PREPARSED_DATA PreparsedData,
IN    PCHAR                Report,
IN    ULONG                ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetUsageValue( %08x, %u, %u, %u, %08x, %08x, %08x, %u )"),
                     ReportType, UsagePage, LinkCollection, Usage, UsageValue, PreparsedData, Report, ReportLength );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

ULONG __stdcall DIDummy_HidP_MaxUsageListLength
(
IN HIDP_REPORT_TYPE      ReportType,
IN USAGE                 UsagePage,
IN PHIDP_PREPARSED_DATA  PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_MaxUsageListLength( %08x, %u, %08x )"),
                     ReportType, UsagePage, PreparsedData );

    return 0;
}

NTSTATUS __stdcall DIDummy_HidP_GetSpecificButtonCaps 
(
IN       HIDP_REPORT_TYPE     ReportType,
IN       USAGE                UsagePage,      
IN       USHORT               LinkCollection, 
IN       USAGE                Usage,          
OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
IN OUT   PUSHORT              ButtonCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetSpecificButtonCaps( %08x, %u, %u, %u, %08x, %08x, %08x )"),
                     ReportType, UsagePage, LinkCollection, Usage, ButtonCaps, ButtonCapsLength, PreparsedData );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_TranslateUsagesToI8042ScanCodes
(
IN       PUSAGE               ChangedUsageList, // Those usages that changed
IN       ULONG                UsageListLength,
IN       HIDP_KEYBOARD_DIRECTION KeyAction,
IN OUT   PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
IN       PHIDP_INSERT_SCANCODES  InsertCodesProcedure,
IN       PVOID                InsertCodesContext
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_TranslateUsagesToI8042ScanCodes( %08x, %u, %08x, %08x, %08x, %08x )"),
                     ChangedUsageList, UsageListLength, KeyAction, ModifierState, InsertCodesProcedure, InsertCodesContext );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

////////////////////////////////////////
// winmm.dll dummy functions
////////////////////////////////////////

MMRESULT WINAPI DIDummy_joyGetDevCaps
(
IN  UINT uJoyID,
OUT LPJOYCAPS pjc,
IN  UINT cbjc
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_joyGetDevCaps( %u, %08x, %u )"),
                     uJoyID, pjc, cbjc );

    return MMSYSERR_ERROR;
}

MMRESULT WINAPI DIDummy_joyGetPosEx
(
IN  UINT        uJoyID,
OUT LPJOYINFOEX pji
)
{   
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_joyGetPosEx( %u, %08x )"),
                     uJoyID, pji );

    return MMSYSERR_ERROR;
}

MMRESULT WINAPI DIDummy_joyGetPos
(
IN  UINT        uJoyID,
OUT LPJOYINFO   pji
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_joyGetPos( %u, %08x )"),
                     uJoyID, pji );

    return MMSYSERR_ERROR;
}

UINT WINAPI DIDummy_joyConfigChanged
(
IN DWORD dwFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_joyConfigChanged( %u )"),
                     dwFlags );

    return MMSYSERR_ERROR;
}

MMRESULT WINAPI DIDummy_mmioClose
( 
IN HMMIO hmmio, 
IN UINT fuClose
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioClose( %08x, %u )"),
                     hmmio, fuClose );
	
    return MMSYSERR_ERROR;
}

HMMIO WINAPI DIDummy_mmioOpenA
( 
IN OUT LPSTR pszFileName, 
IN OUT LPMMIOINFO pmmioinfo, 
IN DWORD fdwOpen
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioOpenA( %s, %08x, %u )"),
                     pszFileName, pmmioinfo, fdwOpen );

    return NULL;
}

MMRESULT WINAPI DIDummy_mmioDescend
( 
IN HMMIO hmmio, 
IN OUT LPMMCKINFO pmmcki, 
IN const MMCKINFO FAR* pmmckiParent, 
IN UINT fuDescend
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioDescend( %08x, %08x, %08x, %u )"),
                     hmmio, pmmcki, pmmckiParent, fuDescend );

    return MMSYSERR_ERROR;
}

MMRESULT WINAPI DIDummy_mmioCreateChunk
(
IN HMMIO hmmio, 
IN LPMMCKINFO pmmcki, 
IN UINT fuCreate
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioCreateChunk( %08x, %08x, %u )"),
                     hmmio, pmmcki, fuCreate );

    return MMSYSERR_ERROR;
}

LONG WINAPI DIDummy_mmioRead
( 
IN HMMIO hmmio, 
OUT HPSTR pch, 
IN LONG cch
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioRead( %08x, %08x, %u )"),
                     hmmio, pch, cch );
	
    return 0;
}

LONG WINAPI DIDummy_mmioWrite
( 
IN HMMIO hmmio, 
IN const char _huge* pch, 
IN LONG cch
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioWrite( %08x, %08x, %u )"),
                     hmmio, pch, cch );

    return 0;
}

MMRESULT WINAPI DIDummy_mmioAscend
( 
IN HMMIO hmmio, 
IN LPMMCKINFO pmmcki, 
IN UINT fuAscend
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioAscend( %08x, %08x, %u )"),
                     hmmio, pmmcki, fuAscend );
                           
    return MMSYSERR_ERROR;
}

////////////////////////////////////////
// user32.dll dummy functions
////////////////////////////////////////

#ifdef USE_WM_INPUT

BOOL WINAPI DIDummy_RegisterRawInputDevices
(
PCRAWINPUTDEVICE pRawInputDevices,
UINT uiNumDevices,
UINT cbSize
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_RegisterRawInputDevices( %08x, %u, %u )"),
                     pRawInputDevices, uiNumDevices, cbSize );
                           
    return FALSE;
}

UINT WINAPI DIDummy_GetRawInputData
(
HRAWINPUT   hRawInput,
UINT        uiCommand,
LPVOID      pData,
PUINT       pcbSize,
UINT        cbSizeHeader
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_GetRawInputData( %08x, %u, %08x, %08x, %u )"),
                     hRawInput, uiCommand, pData, pcbSize, cbSizeHeader );
                           
    return -1;
}

#endif //#ifdef USE_WM_INPUT

#endif /* STATIC_DLLUSAGE */

#endif  //HID_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\diguid.c ===
/*****************************************************************************
 *
 *  DIGuid.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Misc GUID-related helper functions.
 *
 *  Contents:
 *
 *      DICreateGuid
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflUtil

#ifdef HID_SUPPORT

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

typedef void (__stdcall *UUIDCREATE)(OUT LPGUID pguid);

UUIDCREATE g_UuidCreate;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | FakeUuidCreate |
 *
 *          Create a GUID using a fake algorithm that is close enough.
 *          Since we don't let our GUIDs leave the DirectInput world,
 *          the uniqueness policy can be relaxed.
 *
 *          OLE generates a GUID as follows:
 *
 *          Get the current local time in FILETIME format.
 *
 *          Add the magic number 0x00146bf33e42c000 = 580819200 seconds =
 *          9580320 minutes = 159672 hours = 6653 days, approximately
 *          18 years.  Who knows why.
 *
 *          Subtract 0x00989680 (approximately 256 seconds).  Who
 *          knows why.
 *
 *          If you combine the above two steps, the net result is to
 *          add 0x00146bf33daa2980.
 *
 *          The dwLowDateTime of the resulting FILETIME becomes Data1.
 *
 *          The dwHighDateTime of the resulting FILETIME becomes
 *          Data2 and Data3, except that the high nibble of Data3
 *          is forced to 1.
 *
 *          The first two bytes of Data4 are a big-endian 10-bit
 *          sequence counter, with the top bit set and the other
 *          bits zero.
 *
 *          The last six bytes are the network card identifier.
 *
 *  @parm   LPGUID | pguid |
 *
 *          Receives the GUID to create.
 *
 *****************************************************************************/

void INTERNAL
FakeUuidCreate(LPGUID pguid)
{
    LONG lRc;
    SYSTEMTIME st;
    union {
        FILETIME ft;
        DWORDLONG ldw;
    } u;

    GetLocalTime(&st);
    SystemTimeToFileTime(&st, &u.ft);
    u.ldw += 0x00146BF33DAA2980;

    /*
     *  Note: The wacky pun is actually safe on a RISC because
     *  Data2 is already dword-aligned.
     */

    pguid->Data1 = u.ft.dwLowDateTime;
    *(LPDWORD)&pguid->Data2 = (u.ft.dwHighDateTime & 0x0FFFFFFF) | 0x10000000;

    lRc = Excl_UniqueGuidInteger();
    lRc = lRc & 0x3FFF;

    pguid->Data4[0] = 0x80 | HIBYTE(lRc);
    pguid->Data4[1] =        LOBYTE(lRc);


    /*
     *  We use the network adapter ID of the dial-up adapter as our
     *  network ID.  No real network adapter will have this ID.
     */
    pguid->Data4[2] = 'D';
    pguid->Data4[3] = 'E';
    pguid->Data4[4] = 'S';
    pguid->Data4[5] = 'T';
    pguid->Data4[6] = 0x00;
    pguid->Data4[7] = 0x00;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DICreateGuid |
 *
 *          Create a GUID.  Because we don't want to pull in all of OLE,
 *          we don't actually use RPCRT4.
 *
 *  @parm   LPGUID | pguid |
 *
 *          Receives the GUID to create.
 *
 *****************************************************************************/

void EXTERNAL
DICreateGuid(LPGUID pguid)
{
    AssertF(g_hmtxGlobal);

    FakeUuidCreate(pguid);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DICreateStaticGuid |
 *
 *          Create a "static" <t GUID>, which is a <t GUID> that can be
 *          deterministically regenerated from its parameters.
 *
 *          This is used to invent <t GUID>s for HID devices
 *          and vendors.
 *
 *          The entire <t GUID> is zero, except for the pid and vid
 *          which go into Data1, and the network adapter
 *          ID is the dial-up adapter.
 *
 *          We put the variable bits into the Data1 because that's
 *          how GUIDs work.
 *
 *          The resulting GUID is {pidvid-0000-0000-0000-504944564944}
 *
 *  @parm   LPGUID | pguid |
 *
 *          Receives the created <t GUID>.
 *
 *****************************************************************************/

void EXTERNAL
DICreateStaticGuid(LPGUID pguid, WORD pid, WORD vid)
{
    pguid->Data1 = MAKELONG(vid, pid);

    pguid->Data2 = 0;
    pguid->Data3 = 0;

    /*
     *  We use the string "PIDVID" as our network adapter ID.
     *  No real network adapter will have this ID.
     */
    pguid->Data4[0] = 0x00;
    pguid->Data4[1] = 0x00;
    pguid->Data4[2] = 'P';
    pguid->Data4[3] = 'I';
    pguid->Data4[4] = 'D';
    pguid->Data4[5] = 'V';
    pguid->Data4[6] = 'I';
    pguid->Data4[7] = 'D';

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\digenx.c ===
/*****************************************************************************
 *
 *  DIGenX.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Generic IDirectInputDevice callback for uninitialized devices.
 *
 *  Contents:
 *
 *      CNil_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflNil

/*****************************************************************************
 *
 *      Note!  This is not a normal refcounted interface.  It is
 *      a static object whose sole purpose is to keep the seat warm
 *      until the IDirectInputDevice gets Initialize()d.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *          We're not a real object, so we don't have any interfaces.
 *
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_QueryInterface(PDICB pdcb, REFIID riid, PPV ppvObj)
{
    return E_NOTIMPL;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *          We are always here, so the refcount is meaningless.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | Release |
 *
 *          Increments the reference count for the interface.
 *
 *          We are always here, so the refcount is meaningless.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
CNil_AddRefRelease(PDICB pdcb)
{
    return 0;
}

#define CNil_AddRef                 CNil_AddRefRelease
#define CNil_Release                CNil_AddRefRelease

/*****************************************************************************
 *
 *      You might think we could just write a bunch of stubs,
 *      <f CNil_NotInit0>,
 *      <f CNil_NotInit4>,
 *      <f CNil_NotInit8>, and so on, one for each arity, and
 *      point all of the methods at the appropriate stub.
 *
 *      However, you would be wrong.  Some processors (especially
 *      the 68k series) have weird calling conventions which depend
 *      on things other than just the number of bytes of parameters.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetInstance |
 *
 *          Called by DirectInput to obtain the DirectInput instance
 *          handle that was created by the DirectInput device driver.
 *
 *  @parm   LPVOID * | ppvInst |
 *
 *          Receives the DirectInput instance handle created by the
 *          DirectInput device driver.  This instance handle is returned
 *          to the device-specific driver, which in turn is given to
 *          the device callback via a private mechanism.
 *
 *          If the device callback does not use a device driver, then
 *          0 is returned in this variable.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_GetInstance(PDICB pdcb, LPVOID *ppvInst)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetDataFormat |
 *
 *          Called by DirectInput to obtain the device's preferred
 *          data format.
 *
 *  @parm   OUT LPDIDATAFORMAT * | ppdidf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ****************************************************************************/

STDMETHODIMP
CNil_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdidf)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetObjectInfo |
 *
 *          Obtain the friendly name of an object, passwed by index
 *          into the preferred data format.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          fields have already been filled in.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ****************************************************************************/

STDMETHODIMP
CNil_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                               LPDIDEVICEOBJECTINSTANCEW pdidioiW)
{
    /*
     *  This should never happen; didev.c validates the device
     *  before calling us.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetCapabilities |
 *
 *          Obtain device capabilities.
 *
 *  @parm   LPDIDEVCAPS | pdidc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ****************************************************************************/

STDMETHODIMP
CNil_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdidc)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::GetCapabilities.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | Acquire |
 *
 *          Begin data acquisition.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ****************************************************************************/

STDMETHODIMP
CNil_Acquire(PDICB pdcb)
{
    /*
     *  This should never happen; we don't get called until
     *  after the data format is set.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | Unacquire |
 *
 *          End data acquisition.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_Unacquire(PDICB pdcb)
{
    /*
     *  This should never happen; we don't get called until
     *  we've acquired, which never works.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetDeviceState |
 *
 *          Obtain instantaneous device state.
 *
 *  @parm   OUT LPVOID | lpvBuf |
 *
 *          Buffer to receive device state.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_GetDeviceState(PDICB pdcb, LPVOID lpvBuf)
{
    /*
     *  This may legitimately be called, because it happens only
     *  when the device is already acquired, which never happens.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetDeviceInfo |
 *
 *          Obtain the product id.
 *
 *  @parm   LPDIDEVICEINSTANCEW | lpdidiW |
 *
 *          (out) <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW lpdidiW)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::GetDeviceInfo.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetProperty |
 *
 *          Retrieve a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   OUT LPDIPROPHEADER | pdiph |
 *
 *          Where to put the property value.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER lpdiph)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::GetProperty.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | SetProperty |
 *
 *          Set a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   IN LPCDIPROPHEADER | pdiph |
 *
 *          Value of property.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER lpdiph)
{
    /*
     *  This should never happen; didev.c validates the device
     *  before calling us.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | SetEventNotification |
 *
 *          Set the handle associated with the device.
 *
 *  @parm   HANDLE | h |
 *
 *          Handle to be signalled when new data arrives.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_SetEventNotification(PDICB pdcb, HANDLE h)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::SetEventNotification.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | SetCooperativeLevel |
 *
 *          Set the device cooperativity level.  Device callbacks
 *          typically need only respond to the <c DISCL_EXCLUSIVE> bit.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::SetCooperativeLevel.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | RunControlPanel |
 *
 *          Run the control panel for the device.
 *
 *  @parm   HWND | hwndOwner |
 *
 *          Owner window (if modal).
 *
 *  @parm   DWORD | fl |
 *
 *          Flags.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_RunControlPanel(PDICB pdcb, HWND hwndOwner, DWORD fl)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::RunControlPanel.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}


/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | CookDeviceData |
 *
 *          Cook a piece of device data that was obtained from the
 *          data buffer.  This data does not pass through the device
 *          callback, so it needs to be cooked externally.  In
 *          comparison, device state information is obtained via
 *          DIDM_GETDEVICESTATE, which the callback can cook before
 *          returning.
 *
 *          If the callback returns E_NOTIMPL, then the caller is
 *          permitted to cache the result <y for the entire device>
 *          (not merely for the device object) until the next DIDM_ACQUIRE.
 *
 *  @parm   UINT | cdod |
 *
 *          Number of objects to cook.  This can be zero, in which case
 *          the caller is checking whether the device requires cooking.
 *
 *  @parm   LPDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of object data to cook.
 *
 *          Note, however, that the <e DIDEVICEOBJETCDATA.dwOfs> fields
 *          are not what you think.  The low word contains the application
 *          data offset (which is not important to the callback); the
 *          high word contains the object ID (traditionally called the
 *          "device type" code).
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_CookDeviceData(PDICB pdcb, UINT cdod, LPDIDEVICEOBJECTDATA rgdod)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | CreateEffect |
 *
 *          Create an <i IDirectInputEffectDriver> callback.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD * | ppes |
 *
 *          Receives the shepherd for the effect driver.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling a force feedback method.
     */
    *ppes = 0;
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetFFConfigKey |
 *
 *          Returns a handle to the registry key which contains
 *          force feedback configuration information.
 *
 *  @parm   DWORD | sam |
 *
 *          Security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives key handle on success.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | SendDeviceData |
 *
 *          Spew some data to the device.
 *
 *  @parm   IN LPCDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          Number of items actually sent.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_SendDeviceData(PDICB pdcb, LPCDIDEVICEOBJECTDATA rgdod,
                       LPDWORD pdwInOut, DWORD fl)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | Poll |
 *
 *          Poll the device as necessary.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_Poll(PDICB pdcb)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | MapUsage |
 *
 *          Given a usage and usage page (munged into a single
 *          <t DWORD>), find a device object that matches it.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_MapUsage(PDICB pdcb, DWORD dwUsage, PINT piOut)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CNil | GetUsage |
 *
 *          Given an object index, return the usage and usage page,
 *          packed into a single <t DWORD>.
 *
 *  @parm   int | iobj |
 *
 *          Object index to be converted.
 *
 *  @returns
 *
 *          Zero because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP_(DWORD)
CNil_GetUsage(PDICB pdcb, int iobj)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return 0;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CNil | SetDIData |
 *
 *          Set DirectInput version from CDIDev *.
 *
 *  @parm   DWORD | dwVer |
 *
 *          DirectInput version
 *
 *  @parm   LPVOID | lpdihacks |
 *
 *          AppHack data
 *
 *  @returns
 *
 *          Zero because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return 0;
}

/****************************************************************************
 *
 *      Our VTBL for our static object
 *
 ***************************************************************************/

#pragma BEGIN_CONST_DATA

IDirectInputDeviceCallbackVtbl c_vtblNil = {
    CNil_QueryInterface,
    CNil_AddRef,
    CNil_Release,
    CNil_GetInstance,
    CDefDcb_GetVersions,
    CNil_GetDataFormat,
    CNil_GetObjectInfo,
    CNil_GetCapabilities,
    CNil_Acquire,
    CNil_Unacquire,
    CNil_GetDeviceState,
    CNil_GetDeviceInfo,
    CNil_GetProperty,
    CNil_SetProperty,
    CNil_SetEventNotification,
    CNil_SetCooperativeLevel,
    CNil_RunControlPanel,
    CNil_CookDeviceData,
    CNil_CreateEffect,
    CNil_GetFFConfigKey,
    CNil_SendDeviceData,
    CNil_Poll,
    CNil_GetUsage,
    CNil_MapUsage,
    CNil_SetDIData,
};

IDirectInputDeviceCallback c_dcbNil = {
    &c_vtblNil,
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dihel.c ===
/*****************************************************************************
 *
 *  DIHel.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Hardware emulation layer for DirectInput.
 *
 *  Contents:
 *
 *      Hel_AcquireInstance
 *      Hel_UnacquireInstance
 *      Hel_SetBufferSize
 *      Hel_DestroyInstance
 *
 *      Hel_SetDataFormat
 *      Hel_SetNotifyHandle
 *
 *      Hel_Mouse_CreateInstance
 *      Hel_Kbd_CreateInstance
 *      Hel_Kbd_InitKeys
 *      Hel_Joy_CreateInstance
 *      Hel_Joy_Ping
 *      Hel_Joy_GetInitParms
 *
 *      IoctlHw
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHel

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | IoctlHw |
 *
 *          Send the IOCtl to the hardware device.
 *
 *  @parm   DWORD | ioctl |
 *
 *          I/O control code.
 *
 *  @parm   IN LPVOID | pvIn |
 *
 *          Optional input parameter.
 *
 *  @parm   DWORD | cbIn |
 *
 *          Size of input buffer in bytes.
 *
 *  @parm   IN LPVOID | pvOut |
 *
 *          Optional output parameter.
 *
 *  @parm   DWORD | cbOut |
 *
 *          Size of output buffer in bytes.
 *
 *  @returns
 *
 *          <c S_OK> if the ioctl succeeded and returned the correct
 *          number of bytes, else something based on the Win32 error code.
 *
 *****************************************************************************/

#ifndef WINNT
HRESULT EXTERNAL
IoctlHw(DWORD ioctl, LPVOID pvIn, DWORD cbIn, LPVOID pvOut, DWORD cbOut)
{
    HRESULT hres;
    DWORD cbRc;

    if (g_hVxD != INVALID_HANDLE_VALUE) {
        if (DeviceIoControl(g_hVxD, ioctl, pvIn, cbIn,
                            pvOut, cbOut, &cbRc, 0)) {
            if (cbRc == cbOut) {
                hres = S_OK;
            } else {
                SquirtSqflPtszV(sqfl, TEXT("Ioctl(%08x) returned wrong cbOut"),
                                ioctl);
                hres = DIERR_BADDRIVERVER;
            }
        } else {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("Ioctl(%08x) failed, error %d"),
                            ioctl, GetLastError());
            hres = hresLe(GetLastError());
        }
    } else {
        hres = DIERR_BADDRIVERVER;
    }
    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_IoctlChoose |
 *
 *          Send the IOCtl to the hardware device if it is native,
 *          or perform the operation through emulation if it is emulated.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The device in question.
 *
 *  @parm   PFNHANDLER | pfn |
 *
 *          The emulation function to call to carry out the operation.
 *
 *  @parm   DWORD | ioctl |
 *
 *          I/O control code.
 *
 *  @parm   IN LPVOID | pvIn |
 *
 *          Optional input parameter.
 *
 *  @parm   DWORD | cbIn |
 *
 *          Size of input buffer in bytes.
 *
 *****************************************************************************/

typedef HRESULT (EXTERNAL *PFNHANDLER)(PV pv);

HRESULT INTERNAL
Hel_IoctlChoose(PVXDINSTANCE pvi, PFNHANDLER pfn,
                DWORD ioctl, LPVOID pvIn, DWORD cbIn)
{
    HRESULT hres;
    if (!(pvi->fl & VIFL_EMULATED)) {
        hres = IoctlHw(ioctl, pvIn, cbIn, 0, 0);
    } else {
        hres = pfn(pvIn);
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_AcquireInstance |
 *
 *          Attempt to acquire the device instance, using either the
 *          device driver or emulation, whichever is appropriate.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The instance to acquire.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_AcquireInstance(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_AcquireInstance,
                           IOCTL_ACQUIREINSTANCE, &pvi, cbX(pvi));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_UnacquireInstance |
 *
 *          Attempt to unacquire the device instance.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The instance to unacquire.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_UnacquireInstance(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_UnacquireInstance,
                           IOCTL_UNACQUIREINSTANCE, &pvi, cbX(pvi));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_DestroyInstance |
 *
 *          Destroy the device instance in the appropriate way.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_DestroyInstance(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_DestroyInstance,
                           IOCTL_DESTROYINSTANCE, &pvi, cbX(pvi));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_SetDataFormat |
 *
 *          Set the data format.
 *
 *  @parm   PVXDDATAFORMAT | pvdf |
 *
 *          Information about the data format.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_SetDataFormat(PVXDDATAFORMAT pvdf)
{
    return Hel_IoctlChoose(pvdf->pvi, CEm_SetDataFormat,
                           IOCTL_SETDATAFORMAT, pvdf, cbX(*pvdf));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_SetNotifyHandle |
 *
 *          Set the data format.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          Information about the data format.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_SetNotifyHandle(PVXDDWORDDATA pvdd)
{
    HRESULT hres = S_OK;
    
#ifndef WINNT
    if (!(pvdd->pvi->fl & VIFL_EMULATED)) {
        AssertF(_OpenVxDHandle);
        if (pvdd->dw) {
            pvdd->dw = _OpenVxDHandle((HANDLE)pvdd->dw);
        }
    
        hres = IoctlHw(IOCTL_SETNOTIFYHANDLE, pvdd, cbX(*pvdd), 0, 0);
    }  
#endif
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_SetBufferSize |
 *
 *          Set the buffer size.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          Information about the buffer size.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_SetBufferSize(PVXDDWORDDATA pvdd)
{
    HRESULT hres;
    EnterProc(Hel_SetBufferSize, (_ "pxx", pvdd->pvi, pvdd->dw, pvdd->pvi->fl));

    hres = Hel_IoctlChoose(pvdd->pvi, CEm_SetBufferSize,
                           IOCTL_SETBUFFERSIZE, pvdd, cbX(*pvdd));

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CREATEDEVICEINFO |
 *
 *          Describes how to create the device either via the driver or
 *          via emulation.
 *
 *  @parm   DWORD | dwIoctl |
 *
 *          IOCtl code to try.
 *
 *  @parm   DWORD | flEmulation |
 *
 *          Flag in registry that forces emulation.
 *
 *  @parm   EMULATIONCREATEPROC | pfnCreate |
 *
 *          Function that creates emulation object.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

typedef HRESULT (EXTERNAL *EMULATIONCREATEPROC)
                (PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut);


typedef struct CREATEDEVICEINFO {
    DWORD dwIoctl;
    DWORD flEmulation;
    EMULATIONCREATEPROC pfnCreate;
} CREATEDEVICEINFO, *PCREATEDEVICEINFO;

CREATEDEVICEINFO c_cdiMouse = {
    IOCTL_MOUSE_CREATEINSTANCE,
    DIEMFL_MOUSE,
    CEm_Mouse_CreateInstance,
};

CREATEDEVICEINFO c_cdiKbd = {
    IOCTL_KBD_CREATEINSTANCE,
    DIEMFL_KBD | DIEMFL_KBD2,
    CEm_Kbd_CreateInstance,
};

CREATEDEVICEINFO c_cdiJoy = {
    IOCTL_JOY_CREATEINSTANCE,
    DIEMFL_JOYSTICK,
    CEm_Joy_CreateInstance,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_CreateInstance |
 *
 *          Attempt to create the device instance through the driver
 *          with the specified IOCtl.
 *
 *          If that is not possible, then use the emulation callback.
 *
 *  @parm   PCREATEDEVICEINFO | pcdi |
 *
 *          Describes how to create the device.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          Describes the device being created.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          Receives created instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_CreateInstance(PCREATEDEVICEINFO pcdi,
                   PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    HRESULT hres;

    pdevf->dwEmulation |= g_flEmulation;
    pdevf->dwEmulation &= pcdi->flEmulation;

    if (pdevf->dwEmulation ||
        (FAILED(hres = IoctlHw(pcdi->dwIoctl, pdevf, cbX(*pdevf),
                        ppviOut, cbX(*ppviOut))))) {
        hres = pcdi->pfnCreate(pdevf, ppviOut);
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Mouse_CreateInstance |
 *
 *          Attempt to create the device instance through the driver.
 *          If that is not possible, then use the emulation layer.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          Describes the device being created.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          Receives created instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Mouse_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    return Hel_CreateInstance(&c_cdiMouse, pdevf, ppviOut);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Kbd_CreateInstance |
 *
 *          Attempt to create the device instance through the driver.
 *          If that is not possible, then use the emulation layer.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          Describes the device being created.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          Receives created instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Kbd_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    return Hel_CreateInstance(&c_cdiKbd, pdevf, ppviOut);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Kbd_InitKeys |
 *
 *          Tell the device driver (or emulation) about the key state.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The instance and the key state.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Kbd_InitKeys(PVXDDWORDDATA pvdd)
{
    return Hel_IoctlChoose(pvdd->pvi, CEm_Kbd_InitKeys,
                           IOCTL_KBD_INITKEYS, pvdd, cbX(*pvdd));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_CreateInstance |
 *
 *          Attempt to create the device instance through the driver.
 *          If that is not possible, then use the emulation layer.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          Describes the device being created.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          Receives created instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    return Hel_CreateInstance(&c_cdiJoy, pdevf, ppviOut);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_Ping |
 *
 *          Ask the device driver (or emulation) to get the joystick info.
 *          If the poll fails, the device will be forced unacquired.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The instance and the key state.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_Ping(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_Joy_Ping,
                           IOCTL_JOY_PING, &pvi, cbX(pvi));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_Ping8 |
 *
 *          Ask the device driver (or emulation) to get the joystick info.
 *          If the poll fails, the device will NOT be forced unacquired.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The instance and the key state.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_Ping8(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_Joy_Ping,
                           IOCTL_JOY_PING8, &pvi, cbX(pvi));
}

#ifdef IDirectInputDevice2Vtbl

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_GetInitParms |
 *
 *          Ask the device driver (or emulation) for
 *          VJOYD initialization parameters.
 *
 *          In emulation, we assume the internal and external
 *          IDs are equal (because they may as well be),
 *          that no flags are set, and there are no versions.
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The external joystick number.
 *
 *  @parm   PVXDINITPARMS | pvip |
 *
 *          Receives assorted information.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_GetInitParms(DWORD dwExternalID, PVXDINITPARMS pvip)
{
    HRESULT hres;

    if ((g_flEmulation & DIEMFL_JOYSTICK) ||
         FAILED(hres = IoctlHw(IOCTL_JOY_GETINITPARMS,
                               &dwExternalID, cbX(dwExternalID),
                               pvip, cbX(*pvip))) ||
         FAILED(hres = pvip->hres)) {

        /*
         *  Do it the emulation way.
         */

         ZeroX(*pvip);
         pvip->dwId = dwExternalID;
         hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_GetAxisCaps |
 *
 *          Obtain a bitmask of the axes supported by the joystick.
 *          If VJOYD won't tell us, then we figure it out from the
 *          registry structure passed in.
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The external joystick number.
 *
 *  @parm   PVXDAXISCAPS | pvac |
 *
 *          Structure to receive the axis capabilities.
 *
 *  @parm   PJOYCAPS | pjc |
 *
 *          The joystick capabilities as reported by the registry.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_GetAxisCaps(DWORD dwExternalID, PVXDAXISCAPS pvac, PJOYCAPS pjc)
{
    HRESULT hres;

    if ((g_flEmulation & DIEMFL_JOYSTICK) ||
        FAILED(hres = IoctlHw(IOCTL_JOY_GETAXES,
                        &dwExternalID, cbX(dwExternalID),
                        pvac, cbX(*pvac)))) {

        /*
         *  If that didn't work, then get the axis information
         *  from the registry.
         */

        /*
         *  Every joystick has an X and Y (no way to tell)
         */
        pvac->dwPos = JOYPF_X | JOYPF_Y;

        if (pjc->wCaps & JOYCAPS_HASZ) {
            pvac->dwPos |= JOYPF_Z;
        }

        if (pjc->wCaps & JOYCAPS_HASR) {
            pvac->dwPos |= JOYPF_R;
        }

        if (pjc->wCaps & JOYCAPS_HASU) {
            pvac->dwPos |= JOYPF_U;
        }

        if (pjc->wCaps & JOYCAPS_HASV) {
            pvac->dwPos |= JOYPF_V;
        }

        if (pjc->wCaps & JOYCAPS_HASPOV) {
            pvac->dwPos |= JOYPF_POV0;
        }

        /*
         *  Old VJOYD clients do not support velocity or any of the
         *  other stuff.
         */
        pvac->dwVel = 0;
        pvac->dwAccel = 0;
        pvac->dwForce = 0;

        hres = S_OK;
    }

    /*
     *  CJoy_InitRing3 assumes that this never fails.
     */
    AssertF(SUCCEEDED(hres));

    return hres;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dihel.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dihel.h
 *  Content:    DirectInput internal include file for the
 *              hardware emulation layer
 *
 ***************************************************************************/

HRESULT EXTERNAL Hel_AcquireInstance(PVXDINSTANCE pvi);
HRESULT EXTERNAL Hel_UnacquireInstance(PVXDINSTANCE pvi);
HRESULT EXTERNAL Hel_SetBufferSize(PVXDDWORDDATA pvdd);
HRESULT EXTERNAL Hel_DestroyInstance(PVXDINSTANCE pvi);

HRESULT EXTERNAL Hel_SetDataFormat(PVXDDATAFORMAT pvdf);
HRESULT EXTERNAL Hel_SetNotifyHandle(PVXDDWORDDATA pvdd);

HRESULT EXTERNAL
Hel_Mouse_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut);

HRESULT EXTERNAL
Hel_Kbd_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut);

HRESULT EXTERNAL Hel_Kbd_InitKeys(PVXDDWORDDATA pvdd);

HRESULT EXTERNAL
Hel_Joy_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut);

HRESULT EXTERNAL Hel_Joy_Ping(PVXDINSTANCE pvi);
HRESULT EXTERNAL Hel_Joy_Ping8(PVXDINSTANCE pvi);

HRESULT EXTERNAL
Hel_Joy_GetInitParms(DWORD dwExternalID, PVXDINITPARMS pvip);

HRESULT EXTERNAL
Hel_Joy_GetAxisCaps(DWORD dwExternalID, PVXDAXISCAPS pvac, PJOYCAPS pjc);

/*
 *  HID always runs via ring 3.
 */
#define Hel_HID_CreateInstance          CEm_HID_CreateInstance

#ifdef WINNT
#define IoctlHw( ioctl, pvIn, cbIn, pvOut, cbOut ) ( (HRESULT)DIERR_BADDRIVERVER )
#else
HRESULT EXTERNAL
IoctlHw(DWORD ioctl, LPVOID pvIn, DWORD cbIn, LPVOID pvOut, DWORD cbOut);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dihiddat.c ===
/*****************************************************************************
 *
 *  DIHidDat.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      HID data management.
 *
 *  Contents:
 *
 *      CHid_AddDeviceData
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHidDev

#ifdef HID_SUPPORT

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | DelDeviceData |
 *
 *          Remove an item of device data from the list.
 *
 *          We grab the last item and slide it into place, updating
 *          the various pointers as we go.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The HID report from which the item is being deleted.
 *
 *  @parm   int | idataDel |
 *
 *          The data value being deleted.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          The report type we are mangling with.
 *
 *****************************************************************************/

void INTERNAL
CHid_DelDeviceData(PCHID this, PHIDREPORTINFO phri, int idataDel,
                   HIDP_REPORT_TYPE type)
{
    DWORD dwBase = this->rgdwBase[type];
    int iobjDel = phri->rgdata[idataDel].DataIndex + dwBase;
    PHIDOBJCAPS phocDel = &this->rghoc[iobjDel];
    int idataSrc;

    SquirtSqflPtszV(sqflHidOutput,
                    TEXT("DelDeviceData(%d) - cdataUsed = %d, obj=%d"),
                    idataDel, phri->cdataUsed, iobjDel);

    AssertF(idataDel >= 0);
    AssertF(idataDel < phri->cdataUsed);
    AssertF(phri->cdataUsed > 0);

    /*
     *  Wipe out the item being deleted.
     *  Remember that the report needs to be rebuilt.
     */
    AssertF(phocDel->idata == idataDel);
    phocDel->idata = -1;
    phri->fNeedClear = TRUE;

    /*
     *  Slide the top item into its place.
     */
    idataSrc = (int)--(phri->cdataUsed);
    if (idataSrc > idataDel) {
        int iobjSrc;
        PHIDOBJCAPS phocSrc;

        AssertF(idataSrc > 0 && idataSrc < phri->cdataMax);

        iobjSrc = phri->rgdata[idataSrc].DataIndex + dwBase;
        phocSrc = &this->rghoc[iobjSrc];

        AssertF(phocSrc->idata == idataSrc);

        phocSrc->idata = idataDel;
        phri->rgdata[idataDel] = phri->rgdata[idataSrc];

    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | ResetDeviceData |
 *
 *          Clean out all old device data from the list.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The HID report which should be reset.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          The report type we are mangling with.
 *
 *****************************************************************************/

void EXTERNAL
CHid_ResetDeviceData(PCHID this, PHIDREPORTINFO phri, HIDP_REPORT_TYPE type)
{
    SquirtSqflPtszV(sqflHidOutput,
                    TEXT("ResetDeviceData(%d) - cdataUsed = %d"),
                    type, phri->cdataUsed);

    if (phri->cdataUsed) {
        int idata;
        DWORD dwBase = this->rgdwBase[type];

        phri->fNeedClear = TRUE;
        for (idata = 0; idata < phri->cdataUsed; idata++) {
            int iobj = phri->rgdata[idata].DataIndex + dwBase;
            PHIDOBJCAPS phoc = &this->rghoc[iobj];

            AssertF(phoc->idata == idata);
            phoc->idata = -1;
        }

        phri->cdataUsed = 0;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | AddDeviceData |
 *
 *          Add (or replace) a piece of device data to the array.
 *
 *          If we are removing a button, then we delete it, because
 *          the HID way of talking about a button is "If you don't
 *          talk about it, then it isn't set."
 *
 *  @parm   UINT | uiObj |
 *
 *          The object being added.
 *
 *  @parm   DWORD | dwData |
 *
 *          The data value to add.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_REPORTFULL>: Too many items are set in the report.
 *          ISSUE-2001/03/29-timgill Need more document clarification
 *
 *****************************************************************************/

HRESULT EXTERNAL
CHid_AddDeviceData(PCHID this, UINT uiObj, DWORD dwData)
{
    HRESULT hres;
    LPDIOBJECTDATAFORMAT podf;

    AssertF(uiObj < this->df.dwNumObjs);

    podf = &this->df.rgodf[uiObj];

    if (podf->dwType & DIDFT_OUTPUT) {
        PHIDOBJCAPS phoc = &this->rghoc[uiObj];
        PHIDGROUPCAPS pcaps = phoc->pcaps;
        PHIDREPORTINFO phri;

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqflHidOutput,
                        TEXT("CHid_AddDeviceData(%p, %d, %d) - type %d"),
                        this, uiObj, dwData, pcaps->type);

        /*
         *  Decide if it's HidP_Output or HidP_Feature.
         */
        AssertF(HidP_IsOutputLike(pcaps->type));

        switch (pcaps->type) {
        case HidP_Output:  phri = &this->hriOut; break;
        case HidP_Feature: phri = &this->hriFea; break;
        default:           AssertF(0); hres = E_FAIL; goto done;
        }

        AssertF(phri->cdataUsed <= phri->cdataMax);
        if (phoc->idata == -1) {
            SquirtSqflPtszV(sqflHidOutput,
                            TEXT("CHid_AddDeviceData - no iData"));

        } else {
            AssertF(phoc->idata < phri->cdataUsed);
            AssertF(uiObj == phri->rgdata[phoc->idata].DataIndex +
                                         this->rgdwBase[pcaps->type]);
            SquirtSqflPtszV(sqflHidOutput,
                            TEXT("CHid_AddDeviceData - iData = %d ")
                            TEXT("DataIndex = %d"),
                            phoc->idata,
                            phri->rgdata[phoc->idata].DataIndex);
        }

        phri->fChanged = TRUE;

        if (pcaps->IsValue) {
            /*
             *  Just swipe the value.
             *  The fallthrough code will handle this.
             */
        } else {
            /*
             *  If the button is being deleted, then delete it
             *  and that's all.
             */
            if (dwData == 0) {
                if (phoc->idata >= 0) {
                    CHid_DelDeviceData(this, phri, phoc->idata, pcaps->type);
                    AssertF(phoc->idata == -1);
                } else {
                    SquirtSqflPtszV(sqflHidOutput,
                                    TEXT("CHid_AddDeviceData - nop"));
                }
                hres = S_OK;
                goto done;
            } else {
                dwData = TRUE;  /* HidP_SetData requires this for buttons */
            }
        }

        /*
         *  If there is not already a slot for this item, then
         *  find one.
         */
        if (phoc->idata < 0) {
            if (phri->cdataUsed < phri->cdataMax) {
                USHORT DataIndex;

                phoc->idata = phri->cdataUsed++;

                DataIndex = (USHORT)(uiObj - this->rgdwBase[pcaps->type]);
                phri->rgdata[phoc->idata].DataIndex = DataIndex;

                SquirtSqflPtszV(sqflHidOutput,
                                TEXT("CHid_AddDeviceData - create iData = %d ")
                                TEXT("DataIndex = %d"),
                                phoc->idata,
                                DataIndex);
            } else {
                RPF("SendDeviceData: No room for more data");
                hres = DIERR_REPORTFULL;
                goto done;
            }
        }

        AssertF(phri->cdataUsed <= phri->cdataMax);
        AssertF(phoc->idata >= 0 && phoc->idata < phri->cdataUsed);
        AssertF(uiObj == phri->rgdata[phoc->idata].DataIndex +
                                     this->rgdwBase[pcaps->type]);

        /*
         *  Here it comes... The entire purpose of this function
         *  is the following line of code...  (Well, not the
         *  *entire* purpose, but 90% of it...)
         */
        phri->rgdata[phoc->idata].RawValue = dwData;

        SquirtSqflPtszV(sqflHidOutput,
                        TEXT("CHid_AddDeviceData - iData(%d) dwData = %d"),
                        phoc->idata, dwData);

        hres = S_OK;
    done:;

    } else {
        RPF("SendDeviceData: Object %08x is not DIDFT_OUTPUT",
            podf->dwType);
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SendHIDReport |
 *
 *          Build up an output or feature report and send it.
 *          If the report has not changed, then do nothing.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          Describes the HID report we should build.
 *
 *  @parm   OUTPUTHIDREPORT | OutputHIDReport |
 *
 *          Output a HID report to wherever it's supposed to go.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          The report type being sent.
 *          <c HidP_Output> or <c HidP_Feature>.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully
 *          and the report is ready to be sent to the device.
 *
 *          <c DIERR_REPORTFULL>: Too many items are set in the report.
 *
 *  @cb     HRESULT CALLBACK | SendHIDReportProc |
 *
 *          An internal callback which takes a composed HID report
 *          and sends it in the appropriate manner to the device.
 *
 *  @parm   PCHID | this |
 *
 *          The device in question.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The report being sent.
 *
 *****************************************************************************/

STDMETHODIMP
CHid_SendHIDReport(PCHID this, PHIDREPORTINFO phri, HIDP_REPORT_TYPE type,
                   SENDHIDREPORT SendHIDReport)
{
    HRESULT hres = S_OK;
    DWORD cdata;
    NTSTATUS stat;

    if (phri->fChanged) {

        if (phri->fNeedClear) {
            ZeroMemory(phri->pvReport, phri->cbReport);
            phri->fNeedClear = FALSE;
        }

        cdata = phri->cdataUsed;
        stat = HidP_SetData(type, phri->rgdata, &cdata, this->ppd,
                            phri->pvReport, phri->cbReport);
        if (SUCCEEDED(stat) && (int)cdata == phri->cdataUsed) {
            if ( SUCCEEDED( hres = SendHIDReport(this, phri) ) ) {
                phri->fChanged = FALSE;
            }
        } else if (stat == HIDP_STATUS_BUFFER_TOO_SMALL) {
            hres = DIERR_REPORTFULL;
        } else {
            RPF("SendDeviceData: Unexpected HID failure");
            hres = E_FAIL;
        }

    } else {
        /* Vacuous success */
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method NTSTATUS | CHid | ParseData |
 *
 *          Parse a single input report and set up the
 *          <e CHid.pvStage> buffer to contain the new device state.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          HID report type being parsed.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          Information that tells us how to parse the report.
 *
 *****************************************************************************/

NTSTATUS INTERNAL
CHid_ParseData(PCHID this, HIDP_REPORT_TYPE type, PHIDREPORTINFO phri)
{
    NTSTATUS stat = E_FAIL;

    /*
     *  Do this only if there are inputs at all.  This avoids
     *  annoying boundary conditions.
     */
    UCHAR uReportId;
    ULONG cdataMax = phri->cdataMax;

    if (cdataMax && phri->cbReport) {
        
        uReportId = *(UCHAR*)phri->pvReport;
        
        if( uReportId <  this->wMaxReportId[type] &&
            *(this->pEnableReportId[type]  + uReportId) )
        {

            stat = HidP_GetData(type, phri->rgdata, &cdataMax,
                                this->ppd, phri->pvReport, phri->cbReport);

            if (SUCCEEDED(stat)) {
                ULONG idata;

                /*
                 *  If we successfully got stuff, then wipe out the old
                 *  buttons and start with new ones.
                 *
                 *  HID data parsing rules differ from buttons to axes.
                 *  For buttons, the rule is that if it isn't in the
                 *  report, then the button isn't presed.
                 *
                 *  Compare axes, where the rule is that if it isn't
                 *  in the report, then the value is unchanged.
                 *  
                 *  To avoid deleting buttons that are reported in reports 
                 *  other than the one just received we check for multiple 
                 *  reports during initialization and if necessary set up mask 
                 *  arrays for the buttons.  The mask is an arrays of bytes of 
                 *  the same length as the button data, one for each report 
                 *  that contains any buttons.  If the device only has one 
                 *  report there are no mask arrays so we can optimize by just 
                 *  zeroing all the buttons.  If the device has multiple 
                 *  reports there is an array of pointers to the mask arrays, 
                 *  if a report has no buttons, the pointer is NULL so no 
                 *  further processing is required.  For reports that do have 
                 *  buttons, each byte in the button data is ANDed with the 
                 *  corresponding byte in the mask so that only buttons in 
                 *  the received report are zeroed.
                 */
                if( this->rgpbButtonMasks == NULL )
                {
                    /*
                     *  Only one report so just zero all buttons
                     *  This is the normal case so it is important that this 
                     *  be done as quickly as possible.
                     */
                    ZeroMemory(pvAddPvCb(this->pvStage, this->ibButtonData),
                               this->cbButtonData);
                }
                else
                {
                    if( this->rgpbButtonMasks[uReportId-1] != NULL )
                    {
                        /*
                         *  ISSUE-2001/05/12-MarcAnd  Could mask buttons faster
                         *  If we do this often, we could consider doing masks 
                         *  with multiple bytes in each opperation.
                         */

                        PBYTE pbMask;
                        PBYTE pbButtons;
                        PBYTE pbButtonEnd = pvAddPvCb(this->pvStage, this->ibButtonData + this->cbButtonData);
                        for( pbMask = this->rgpbButtonMasks[uReportId-1],
                             pbButtons = pvAddPvCb(this->pvStage, this->ibButtonData);
                             pbButtons < pbButtonEnd;
                             pbMask++, pbButtons++ )
                        {
                            *pbButtons &= *pbMask;
                        }
                    }
                    else
                    {
                        /*
                         *  No buttons in this report
                         */
                    }
                }

                for (idata = 0; idata < cdataMax; idata++) {

                    UINT uiObj;
                    PHIDGROUPCAPS pcaps;

                    /*
                     *  Be careful and make sure that HID didn't
                     *  give us anything with a bogus item index.
                     *
                     *  ISSUE-2001/03/29-timgill Not Feature-friendly.
                     */
                    AssertF(this->rgdwBase[HidP_Input] == 0);

                    SquirtSqflPtszV(sqfl | sqflTrace,
                            TEXT("HidP_GetData: %2d -> %d"),
                            phri->rgdata[idata].DataIndex,
                            phri->rgdata[idata].RawValue);

                    uiObj = this->rgdwBase[type] + phri->rgdata[idata].DataIndex;

                    if (uiObj < this->df.dwNumObjs &&
                        (pcaps = this->rghoc[uiObj].pcaps) &&
                        pcaps->type == type) {
                        LPDIOBJECTDATAFORMAT podf;
                        LONG lValue = (LONG)phri->rgdata[idata].RawValue;

                        /*
                         *  Sign-extend the raw value if necessary.
                         */
                        if (lValue & pcaps->lMask ) {
                            if( pcaps->IsSigned) 
                                lValue |= pcaps->lMask;
                            else
                                lValue &= pcaps->lMask;
                        }

                        if (HidP_IsOutputLike(pcaps->type)) {
                            HRESULT hres;
                            hres = CHid_AddDeviceData(this, uiObj, lValue);
                            AssertF(SUCCEEDED(hres));
                        }

                        podf = &this->df.rgodf[uiObj];

                        if (!pcaps->IsValue) {
                            LPBYTE pb = pvAddPvCb(this->pvStage, podf->dwOfs);
                            AssertF(lValue);
                            *pb = 0x80;

                        } else {

                            LONG UNALIGNED *pl = pvAddPvCb(this->pvStage, podf->dwOfs);

                            // ISSUE-2001/03/29-timgill need to consider how logical/physical mapping can alter scaling

                            if (podf->dwType & DIDFT_RELAXIS) {
                                if (pcaps->usGranularity) {
                                    lValue = -lValue * pcaps->usGranularity;
                                }

                                *pl += lValue;
                            } else if ( (podf->dwType & DIDFT_ABSAXIS) 
                                      #ifdef WINNT
                                        || ((podf->dwType & DIDFT_POV) && pcaps->IsPolledPOV) 
                                      #endif
                            ) {
                                PJOYRANGECONVERT pjrc;
                                *pl = lValue;

                                /*
                                 *  Apply the ramp if any.
                                 */
                                pjrc = this->rghoc[uiObj].pjrc;
                                if( pjrc 
                                 && !( this->pvi->fl & VIFL_RELATIVE ) ) 
                                {
                                    CCal_CookRange(pjrc, pl);
                                }
                            } else if (podf->dwType & DIDFT_BUTTON) {

                                /*
                                 *  Current applications do not expect any values 
                                 *  other than zero and 0x80.  Just in case 
                                 *  someone has implemented an analog button the 
                                 *  way we had suggested, make sure we any value 
                                 *  greater than or equal to half pressed reports 
                                 *  0x80 and anything else reports as zero.
                                 *  Note, out of range values default to zero.
                                 */
                                if( ( lValue <= pcaps->Logical.Max )
                                 && ( ( lValue - pcaps->Logical.Min ) >= 
                                      ( ( ( pcaps->Logical.Max - pcaps->Logical.Min ) + 1 ) / 2 ) ) )
                                {
                                    *((PBYTE)pl) = 0x80;
                                }
                                else
                                {
                                    *((PBYTE)pl) = 0;
                                }

                            } else if (podf->dwType & DIDFT_POV) {
                                /*
                                 *  For (non-polled) POVs, an out of range value 
                                 *  is a NULL aka centered.  Otherwise work out 
                                 *  the angle from the fraction of the circle.
                                 */
                                if (lValue < pcaps->Logical.Min ||
                                    lValue > pcaps->Logical.Max) {
                                    *pl = JOY_POVCENTERED;
                                } else {
                                    lValue -= pcaps->Logical.Min;
                                    *pl = lValue * pcaps->usGranularity;
                                }
                            }

                        }
                    } else {
                        SquirtSqflPtszV(sqfl | sqflTrace,
                                TEXT("HidP_GetData: Unable to use data element"));
                    }
                }
                stat = S_OK;
            }
            stat = S_OK;
        }
    } else {
            stat = E_FAIL;
    }
    return stat;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dihid.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dihid.h
 *  Content:    DirectInput internal include file for HID
 *
 ***************************************************************************/

#ifdef HID_SUPPORT
#ifndef _DIHID_H
#define _DIHID_H

#ifndef HID_USAGE_PAGE_PID
#define HID_USAGE_PAGE_PID      ( (USAGE) 0x0000f )
#endif

#ifndef HID_USAGE_PAGE_VENDOR
#define HID_USAGE_PAGE_VENDOR   ( (USAGE) 0xff00 )
#endif  
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDDEVICEINFO |
 *
 *          Records information about a single hid device.
 *
 *  @field  DIOBJECTSTATICDATA | osd |
 *
 *          Standard information that identifies the device crudely.
 *
 *          The <e DIOBJECTSTATICDATA.dwDevType> field contains the
 *          device type code, used by
 *          <f CDIDEnum_Next>.
 *
 *          If the device is a HID mouse, then the remaining fields
 *          are commandeered as follows:
 *
 *          The <e DIOBJECTSTATICDATA.pcguid> field is the number
 *          of buttons on the mouse.
 *
 *          The <e DIOBJECTSTATICDATA.CreateDcb> field is the number
 *          of axes on the mouse.
 *
 *          See <f DIHid_ProbeMouse> for an explanation of why we
 *          need to do this.
 *
 *  @field  PSP_DEVICE_INTERFACE_DETAIL_DATA | pdidd |
 *
 *          Pointer to name for device to be used in <f CreateFile>.
 *
 *  @field  HKEY | hk |
 *
 *          Registry key that contains configuration information.
 *          Sadly, we must keep it open because there is no way to
 *          obtain the name of the key, and the only way to open the
 *          key is inside an enumeration.
 *
 *  @field  HKEY | hkOld |
 *
 *          Registry key that contains configuration information.
 *          This key was originally used in Win2k Gold. It is to
 *          maintain compatibiltiy with Win2k Gold.
 *
 *  @field  LPTSTR | ptszId |
 *
 *          Cached device ID that allows us to access other information
 *          about the device.
 *
 *  @field  GUID | guid |
 *
 *          The instance GUID for the device.
 *
 *  @field  GUID | guidProduct | 
 *
 *          The product GUID for the device. 
 *
 *	@field	WORD | ProductID |
 *
 *			The PID for the device
 *
 *	@field	WORD | VendorID |
 *
 *			The VID for the device
 *
 *****************************************************************************/

typedef struct HIDDEVICEINFO
{
    DIOBJECTSTATICDATA osd;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;
    HKEY hk;
    HKEY hkOld;
    LPTSTR ptszId;
    GUID guid;
    GUID guidProduct;
    int  idJoy;
    WORD ProductID;
    WORD VendorID;
    BOOL fAttached;
} HIDDEVICEINFO, *PHIDDEVICEINFO;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDDEVICELIST |
 *
 *          Records information about all the HID devices.
 *
 *  @field  int | chdi |
 *
 *          Number of items in the list that are in use.
 *
 *  @field  int | chdiAlloc |
 *
 *          Number of items allocated in the list.
 *
 *  @field  HIDDEVICEINFO | rghdi[0] |
 *
 *          Variable-size array of device information structures.
 *
 *****************************************************************************/

typedef struct HIDDEVICELIST
{

    int chdi;
    int chdiAlloc;
    int idMaxJoy;
    HIDDEVICEINFO rghdi[0];

} HIDDEVICELIST, *PHIDDEVICELIST;

extern PHIDDEVICELIST g_phdl;

    #define cbHdlChdi(chdi)         FIELD_OFFSET(HIDDEVICELIST, rghdi[chdi])

/*
 *  We choose our starting point at 64 devices, since
 *  that's the maximum number of USB devices supported.  This
 *  avoids needless reallocs.
 */

    #define chdiMax                 64
    #define chdiInit                16

/*
 *  Tag for unused translation of object instance
 */
    #define NOREGTRANSLATION        (0x80000000)

/*
 *  VID/PID definitions used to handle analog devices
 */
    #define MSFT_SYSTEM_VID         (0x45E)
    #define MSFT_SYSTEM_PID         (0x100)
    #define ANALOG_ID_ROOT          TEXT("VID_045E&PID_01")

/*
 *  VID/PID template so that upper case hex is always used
 */
    #define VID_PID_TEMPLATE        TEXT("VID_%04X&PID_%04X")

/*
 *  Size of string in characters generated using VID_PID_TEMPLATE
 */
    #define cbszVIDPID              cA( VID_PID_TEMPLATE )


/*****************************************************************************
 *
 *      diextdll.c - Imports from optional external DLLs
 *
 *      It is very important that HidD_GetHidGuid be the very last one.
 *
 *****************************************************************************/

    #ifdef STATIC_DLLUSAGE
        #define ExtDll_Init()
    #else
void EXTERNAL ExtDll_Init(void);
    #endif
void EXTERNAL ExtDll_Term(void);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct MANUALIMPORT |
 *
 *          Records a single manual import.  If it hasn't
 *          yet been resolved, then the <e MANUALIMPORT.ptsz>
 *          points to the procedure name.  If it has been resolved
 *          successfully, then <e MANUALIMPORT.pfn> points to
 *          the resolved address.  If it has not been resolved
 *          successfully, then <e MANUALIMPORT.pfn> is garbage.
 *
 *  @field  LPCSTR | psz |
 *
 *          Procdure name.  Note that this is always an ANSI string.
 *
 *  @field  FARPROC | pfn |
 *
 *          Procedure address.
 *
 *****************************************************************************/

typedef union MANUALIMPORT
{
    FARPROC pfn;                    /* Procedure address */
} MANUALIMPORT, *PMANUALIMPORT;

#ifndef STATIC_DLLUSAGE

    #ifndef WINNT
/*****************************************************************************
 *
 * CFGMGR32
 *
 *  Note that this must match the CFGMGR32 section in diextdll.c
 *
 *****************************************************************************/

typedef union CFGMGR32
{

    MANUALIMPORT rgmi[6];              /* number of functions we import */

    struct
    {
        CONFIGRET ( WINAPI * _CM_Get_Child)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_Sibling)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  DevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_Parent)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_DevNode_Registry_Property)
        (
        IN  DEVINST     dnDevInst,
        IN  ULONG       ulProperty,
        OUT PULONG      pulRegDataType,   OPTIONAL
        OUT PVOID       Buffer,           OPTIONAL
        IN  OUT PULONG  pulLength,
        IN  ULONG       ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Set_DevNode_Registry_Property)
        (
        IN  DEVINST     dnDevInst,
        IN  ULONG       ulProperty,
        IN  PVOID       Buffer,           OPTIONAL
        IN  ULONG       ulLength,
        IN  ULONG       ulFlags
        );

        CONFIGRET( WINAPI * _CM_Get_Device_ID)
        (
         IN  DEVINST  dnDevInst,
         OUT PTCHAR   Buffer,
         IN  ULONG    BufferLen,
         IN  ULONG    ulFlags
        );    
    };

} CFGMGR32, *PFGMGR32;

extern CFGMGR32 g_cfgmgr32;

        #undef CM_Get_Child
        #undef CM_Get_Sibling
        #undef CM_Get_Parent
        #undef CM_Get_DevNode_Registry_Property
        #undef CM_Set_DevNode_Registry_Property
        #undef CM_Get_Device_ID

        #define             CM_Get_Child                       \
        g_cfgmgr32._CM_Get_Child

        #define             CM_Get_Sibling                     \
        g_cfgmgr32._CM_Get_Sibling

        #define             CM_Get_Parent                      \
        g_cfgmgr32._CM_Get_Parent

        #define             CM_Get_DevNode_Registry_Property   \
        g_cfgmgr32._CM_Get_DevNode_Registry_Property

        #define             CM_Set_DevNode_Registry_Property    \
        g_cfgmgr32._CM_Set_DevNode_Registry_Property

        #define             CM_Get_Device_ID                    \
        g_cfgmgr32._CM_Get_Device_ID
    #endif  //#ifndef WINNT

/*****************************************************************************
 *
 *  SETUPAPI
 *
 *  Note that this must match the SETUPAPI section in diextdll.c
 *
 *****************************************************************************/

typedef union SETUPAPI
{

  #ifdef WINNT
    MANUALIMPORT rgmi[18];              /* number of functions we import */
  #else
    MANUALIMPORT rgmi[12];              /* number of functions we import */
  #endif

    struct
    {

        HDEVINFO (WINAPI *_SetupDiGetClassDevs)
        (
        IN LPGUID ClassGuid,  OPTIONAL
        IN LPCTSTR Enumerator, OPTIONAL
        IN HWND   hwndParent, OPTIONAL
        IN DWORD  Flags
        );

        BOOL (WINAPI *_SetupDiDestroyDeviceInfoList)
        (
        IN HDEVINFO DeviceInfoSet
        );

        BOOL (WINAPI *_SetupDiGetDeviceInterfaceDetail)
        (
        IN  HDEVINFO                         DeviceInfoSet,
        IN  PSP_DEVICE_INTERFACE_DATA        pdid,
        OUT PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd,         OPTIONAL
        IN  DWORD                            cbDidd,
        OUT PDWORD                           RequiredSize,  OPTIONAL
        OUT PSP_DEVINFO_DATA                 DeviceInfoData OPTIONAL
        );

        BOOL (WINAPI *_SetupDiEnumDeviceInterfaces)
        (
        IN  HDEVINFO                  DeviceInfoSet,
        IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
        IN  LPGUID                    InterfaceClassGuid,
        IN  DWORD                     MemberIndex,
        OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
        );

        HKEY (WINAPI *_SetupDiCreateDeviceInterfaceRegKey)
        (
        IN HDEVINFO                  hdev,
        IN PSP_DEVICE_INTERFACE_DATA pdid,
        IN DWORD                     Reserved,
        IN REGSAM                    samDesired,
        IN HINF                      InfHandle,           OPTIONAL
        IN PCSTR                     InfSectionName       OPTIONAL
        );

        BOOL (WINAPI *_SetupDiCallClassInstaller)
        (
        IN DI_FUNCTION      InstallFunction,
        IN HDEVINFO         DeviceInfoSet,
        IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
        );

        BOOL (WINAPI *_SetupDiGetDeviceRegistryProperty)
        (
        IN  HDEVINFO         DeviceInfoSet,
        IN  PSP_DEVINFO_DATA DeviceInfoData,
        IN  DWORD            Property,
        OUT PDWORD           PropertyRegDataType, OPTIONAL
        OUT PBYTE            PropertyBuffer,
        IN  DWORD            PropertyBufferSize,
        OUT PDWORD           RequiredSize         OPTIONAL
        );

        BOOL (WINAPI *_SetupDiSetDeviceRegistryProperty)
        (
        IN     HDEVINFO         DeviceInfoSet,
        IN OUT PSP_DEVINFO_DATA DeviceInfoData,
        IN     DWORD            Property,
        IN     CONST BYTE*      PropertyBuffer,
        IN     DWORD            PropertyBufferSize
        );

        BOOL (WINAPI *_SetupDiGetDeviceInstanceId)
        (
        IN  HDEVINFO         DeviceInfoSet,
        IN  PSP_DEVINFO_DATA DeviceInfoData,
        OUT PTSTR            DeviceInstanceId,
        IN  DWORD            DeviceInstanceIdSize,
        OUT PDWORD           RequiredSize          OPTIONAL
        );

        BOOL (WINAPI *_SetupDiOpenDeviceInfo)
        (
        IN  HDEVINFO         DeviceInfoSet,
        IN  LPCTSTR          DeviceInstanceId,
        IN  HWND             hwndParent,       OPTIONAL
        IN  DWORD            OpenFlags,
        OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
        );

        HDEVINFO (WINAPI *_SetupDiCreateDeviceInfoList)
        (
        IN LPGUID ClassGuid, OPTIONAL
        IN HWND   hwndParent OPTIONAL
        );

        HKEY (WINAPI *_SetupDiOpenDevRegKey)
        (
        IN HDEVINFO         DeviceInfoSet,
        IN PSP_DEVINFO_DATA DeviceInfoData,
        IN DWORD            Scope,
        IN DWORD            HwProfile,
        IN DWORD            KeyType,
        IN REGSAM           samDesired
        );

    #ifdef WINNT
        CONFIGRET ( WINAPI * _CM_Get_Child)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_Sibling)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  DevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_Parent)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_DevNode_Registry_Property)
        (
        IN  DEVINST     dnDevInst,
        IN  ULONG       ulProperty,
        OUT PULONG      pulRegDataType,   OPTIONAL
        OUT PVOID       Buffer,           OPTIONAL
        IN  OUT PULONG  pulLength,
        IN  ULONG       ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Set_DevNode_Registry_Property)
        (
        IN  DEVINST     dnDevInst,
        IN  ULONG       ulProperty,
        IN  PVOID       Buffer,           OPTIONAL
        IN  ULONG       ulLength,
        IN  ULONG       ulFlags
        );

        CONFIGRET( WINAPI * _CM_Get_Device_ID)
        (
         IN  DEVINST  dnDevInst,
         OUT PTCHAR   Buffer,
         IN  ULONG    BufferLen,
         IN  ULONG    ulFlags
        );    
    #endif  //#ifdef WINNT        
    };

} SETUPAPI, *PSETUPAPI;

extern SETUPAPI g_setupapi;

        #undef SetupDiGetClassDevs
        #undef SetupDiDestroyDeviceInfoList
        #undef SetupDiGetDeviceInterfaceDetail
        #undef SetupDiEnumDeviceInterfaces
        #undef SetupDiCreateDeviceInterfaceRegKey
        #undef SetupDiCallClassInstaller
        #undef SetupDiGetDeviceRegistryProperty
        #undef SetupDiSetDeviceRegistryProperty
        #undef SetupDiGetDeviceInstanceId
        #undef SetupDiOpenDeviceInfo
        #undef SetupDiCreateDeviceInfoList
        #undef SetupDiOpenDevRegKey

        #define             SetupDiGetClassDevs                 \
        g_setupapi._SetupDiGetClassDevs

        #define             SetupDiDestroyDeviceInfoList        \
        g_setupapi._SetupDiDestroyDeviceInfoList

        #define             SetupDiGetDeviceInterfaceDetail     \
        g_setupapi._SetupDiGetDeviceInterfaceDetail

        #define             SetupDiEnumDeviceInterfaces         \
        g_setupapi._SetupDiEnumDeviceInterfaces

        #define             SetupDiCreateDeviceInterfaceRegKey  \
        g_setupapi._SetupDiCreateDeviceInterfaceRegKey

        #define             SetupDiCallClassInstaller           \
        g_setupapi._SetupDiCallClassInstaller

        #define             SetupDiGetDeviceRegistryProperty    \
        g_setupapi._SetupDiGetDeviceRegistryProperty

        #define             SetupDiSetDeviceRegistryProperty    \
        g_setupapi._SetupDiSetDeviceRegistryProperty

        #define             SetupDiGetDeviceInstanceId          \
        g_setupapi._SetupDiGetDeviceInstanceId

        #define             SetupDiOpenDeviceInfo               \
        g_setupapi._SetupDiOpenDeviceInfo

        #define             SetupDiCreateDeviceInfoList         \
        g_setupapi._SetupDiCreateDeviceInfoList

        #define             SetupDiOpenDevRegKey                \
        g_setupapi._SetupDiOpenDevRegKey

    #ifdef WINNT
        #undef CM_Get_Child
        #undef CM_Get_Sibling
        #undef CM_Get_Parent
        #undef CM_Get_DevNode_Registry_Property
        #undef CM_Set_DevNode_Registry_Property
        #undef CM_Get_Device_ID

        #define             CM_Get_Child                        \
        g_setupapi._CM_Get_Child

        #define             CM_Get_Sibling                      \
        g_setupapi._CM_Get_Sibling

        #define             CM_Get_Parent                       \
        g_setupapi._CM_Get_Parent

        #define             CM_Get_DevNode_Registry_Property    \
        g_setupapi._CM_Get_DevNode_Registry_Property

        #define             CM_Set_DevNode_Registry_Property    \
        g_setupapi._CM_Set_DevNode_Registry_Property

        #define             CM_Get_Device_ID                    \
        g_setupapi._CM_Get_Device_ID
    #endif  //#ifdef WINNT

/*****************************************************************************
 *
 *  HIDDLL
 *
 *  Note that this must match the HID section in diextdll.c
 *
 *****************************************************************************/

typedef union HIDDLL
{

    MANUALIMPORT rgmi[21];              /* number of functions we import */

    struct
    {
        void (__stdcall *_HidD_GetHidGuid)
        (
        OUT   LPGUID   HidGuid
        );

        BOOLEAN (__stdcall *_HidD_GetPreparsedData)
        (
        IN    HANDLE                  HidDeviceObject,
        OUT   PHIDP_PREPARSED_DATA  * PreparsedData
        );

        BOOLEAN (__stdcall *_HidD_FreePreparsedData)
        (
        IN    PHIDP_PREPARSED_DATA PreparsedData
        );

        BOOLEAN (__stdcall *_HidD_FlushQueue)
        (
        IN    HANDLE                HidDeviceObject
        );

        BOOLEAN (__stdcall *_HidD_GetAttributes)
        (
        IN  HANDLE              HidDeviceObject,
        OUT PHIDD_ATTRIBUTES    Attributes
        );

        BOOLEAN (__stdcall *_HidD_GetFeature)
        (
        IN    HANDLE   HidDeviceObject,
        OUT   PVOID    ReportBuffer,
        IN    ULONG    ReportBufferLength
        );

        BOOLEAN (__stdcall *_HidD_SetFeature)
        (
        IN    HANDLE   HidDeviceObject,
        IN    PVOID    ReportBuffer,
        IN    ULONG    ReportBufferLength
        );

        BOOLEAN (__stdcall *_HidD_GetProductString)
        (
        IN    HANDLE   HidDeviceObject,
        OUT   PVOID    Buffer,
        IN    ULONG    BufferLength
        );

        BOOLEAN (__stdcall *_HidD_GetInputReport)
        (
        IN    HANDLE   HidDeviceObject,
        OUT   PVOID    ReportBuffer,
        IN    ULONG    ReportBufferLength
        );

        NTSTATUS (__stdcall *_HidP_GetCaps)
        (
        IN      PHIDP_PREPARSED_DATA      PreparsedData,
        OUT     PHIDP_CAPS                Capabilities
        );

        NTSTATUS (__stdcall *_HidP_GetButtonCaps)
        (
        IN       HIDP_REPORT_TYPE     ReportType,
        OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
        IN OUT   PUSHORT              ButtonCapsLength,
        IN       PHIDP_PREPARSED_DATA PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_GetValueCaps)
        (
        IN       HIDP_REPORT_TYPE     ReportType,
        OUT      PHIDP_VALUE_CAPS     ValueCaps,
        IN OUT   PUSHORT              ValueCapsLength,
        IN       PHIDP_PREPARSED_DATA PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_GetLinkCollectionNodes)
        (
        OUT      PHIDP_LINK_COLLECTION_NODE LinkCollectionNodes,
        IN OUT   PULONG                     LinkCollectionNodesLength,
        IN       PHIDP_PREPARSED_DATA       PreparsedData
        );

        ULONG (__stdcall *_HidP_MaxDataListLength)
        (
        IN HIDP_REPORT_TYPE      ReportType,
        IN PHIDP_PREPARSED_DATA  PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_GetUsagesEx)
        (
        IN       HIDP_REPORT_TYPE     ReportType,
        IN       USHORT               LinkCollection,
        OUT      PUSAGE_AND_PAGE      ButtonList,
        IN OUT   ULONG *              UsageLength,
        IN       PHIDP_PREPARSED_DATA PreparsedData,
        IN       PCHAR                Report,
        IN       ULONG                ReportLength
        );

        NTSTATUS (__stdcall *_HidP_GetScaledUsageValue)
        (
        IN    HIDP_REPORT_TYPE     ReportType,
        IN    USAGE                UsagePage,
        IN    USHORT               LinkCollection,
        IN    USAGE                Usage,
        OUT   PLONG                UsageValue,
        IN    PHIDP_PREPARSED_DATA PreparsedData,
        IN    PCHAR                Report,
        IN    ULONG                ReportLength
        );

        NTSTATUS (__stdcall *_HidP_GetData)
        (
        IN       HIDP_REPORT_TYPE      ReportType,
        OUT      PHIDP_DATA            DataList,
        IN OUT   PULONG                DataLength,
        IN       PHIDP_PREPARSED_DATA  PreparsedData,
        IN       PCHAR                 Report,
        IN       ULONG                 ReportLength
        );

        NTSTATUS (__stdcall *_HidP_SetData)
        (
        IN       HIDP_REPORT_TYPE      ReportType,
        IN       PHIDP_DATA            DataList,
        IN OUT   PULONG                DataLength,
        IN       PHIDP_PREPARSED_DATA  PreparsedData,
        IN OUT   PCHAR                 Report,
        IN       ULONG                 ReportLength
        );

        NTSTATUS (__stdcall *_HidP_GetUsageValue)
        (
        IN    HIDP_REPORT_TYPE     ReportType,
        IN    USAGE                UsagePage,
        IN    USHORT               LinkCollection,
        IN    USAGE                Usage,
        OUT   PULONG               UsageValue,
        IN    PHIDP_PREPARSED_DATA PreparsedData,
        IN    PCHAR                Report,
        IN    ULONG                ReportLength
        );

        ULONG (__stdcall *_HidP_MaxUsageListLength)
        (
        IN HIDP_REPORT_TYPE      ReportType,
        IN USAGE                 UsagePage,
        IN PHIDP_PREPARSED_DATA  PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_GetSpecificButtonCaps) 
        (
        IN       HIDP_REPORT_TYPE     ReportType,
        IN       USAGE                UsagePage,      // Optional (0 => ignore)
        IN       USHORT               LinkCollection, // Optional (0 => ignore)
        IN       USAGE                Usage,          // Optional (0 => ignore)
        OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
        IN OUT   PUSHORT              ButtonCapsLength,
        IN       PHIDP_PREPARSED_DATA PreparsedData
        );

    };

} HIDDLL, *PHIDDLL;

extern HIDDLL g_hiddll;

        #undef HidD_GetHidGuid
        #undef HidD_GetPreparsedData
        #undef HidD_FreePreparsedData
        #undef HidD_FlushQueue
        #undef HidD_GetAttributes
        #undef HidD_GetFeature
        #undef HidD_SetFeature
        #undef HidD_GetProductString
        #undef HidD_GetInputReport
        #undef HidP_GetCaps
        #undef HidP_GetButtonCaps
        #undef HidP_GetValueCaps
        #undef HidP_GetLinkCollectionNodes
        #undef HidP_MaxDataListLength
        #undef HidP_GetUsagesEx
        #undef HidP_GetScaledUsageValue
        #undef HidP_GetData
        #undef HidP_SetData
        #undef HidP_GetUsageValue
        #undef HidP_MaxUsageListLength
        #undef HidP_GetSpecificButtonCaps

        #define           HidD_GetHidGuid                       \
        g_hiddll._HidD_GetHidGuid

        #define           HidD_GetPreparsedData                 \
        g_hiddll._HidD_GetPreparsedData

        #define           HidD_FreePreparsedData                \
        g_hiddll._HidD_FreePreparsedData

        #define           HidD_FlushQueue                       \
        g_hiddll._HidD_FlushQueue

        #define           HidD_GetAttributes                    \
        g_hiddll._HidD_GetAttributes                    \

        #define           HidD_GetFeature                       \
        g_hiddll._HidD_GetFeature                       \

        #define           HidD_SetFeature                       \
        g_hiddll._HidD_SetFeature                       \

        #define           HidD_GetProductString                 \
        g_hiddll._HidD_GetProductString                 \

        #define           HidD_GetInputReport                   \
        g_hiddll._HidD_GetInputReport                   \

        #define           HidP_GetCaps                          \
        g_hiddll._HidP_GetCaps

        #define           HidP_GetButtonCaps                    \
        g_hiddll._HidP_GetButtonCaps

        #define           HidP_GetValueCaps                     \
        g_hiddll._HidP_GetValueCaps

        #define           HidP_GetLinkCollectionNodes           \
        g_hiddll._HidP_GetLinkCollectionNodes

        #define           HidP_MaxDataListLength                \
        g_hiddll._HidP_MaxDataListLength                \

        #define           HidP_GetUsagesEx                      \
        g_hiddll._HidP_GetUsagesEx                      \

        #define           HidP_GetScaledUsageValue              \
        g_hiddll._HidP_GetScaledUsageValue              \

        #define           HidP_GetData                          \
        g_hiddll._HidP_GetData                          \

        #define           HidP_SetData                          \
        g_hiddll._HidP_SetData                          \

        #define           HidP_GetUsageValue                    \
        g_hiddll._HidP_GetUsageValue                    \

        #define           HidP_MaxUsageListLength               \
        g_hiddll._HidP_MaxUsageListLength               \

        #define           HidP_GetSpecificButtonCaps            \
        g_hiddll._HidP_GetSpecificButtonCaps            \

/*****************************************************************************
 *
 * WINMMDLL
 *
 *  Note that this must match the WINMM section in diextdll.c
 *
 *****************************************************************************/

typedef union WINMMDLL
{

    MANUALIMPORT rgmi[4];              /* number of functions we import */

    struct
    {
        MMRESULT ( WINAPI * _joyGetDevCaps)
        (
        IN	UINT uJoyID,
        OUT LPJOYCAPS pjc,
        IN  UINT cbjc
        );

        MMRESULT ( WINAPI * _joyGetPosEx)
        (
		IN  UINT        uJoyID,
        OUT LPJOYINFOEX pji
        );

        MMRESULT ( WINAPI * _joyGetPos)
        (
        IN  UINT        uJoyID,
        OUT LPJOYINFO	pji
        );

        UINT ( WINAPI * _joyConfigChanged)
        (
        IN DWORD dwFlags
        );

    };

} WINMMDLL, *PWINMMDLL;

extern WINMMDLL g_winmmdll;

        #undef joyGetDevCaps
        #undef joyGetPosEx
        #undef joyGetPos
        #undef joyConfigChanged

        #define             joyGetDevCaps                  \
        g_winmmdll._joyGetDevCaps

        #define             joyGetPosEx                    \
        g_winmmdll._joyGetPosEx

        #define             joyGetPos                      \
        g_winmmdll._joyGetPos

        #define             joyConfigChanged               \
        g_winmmdll._joyConfigChanged

/*****************************************************************************
 *
 * USER32
 *
 *  Note that this must match the USER32 section in diextdll.c
 *
 *****************************************************************************/

#ifdef USE_WM_INPUT

typedef union USER32
{

    MANUALIMPORT rgmi[2];              /* number of functions we import */

    struct
    {
        BOOL ( WINAPI * _RegisterRawInputDevices)
        (
        PCRAWINPUTDEVICE pRawInputDevices,
        UINT             uiNumDevices,
        UINT             cbSize
        );

        UINT ( WINAPI * _GetRawInputData)
        (
        HRAWINPUT   hRawInput,
        UINT        uiCommand,
        LPVOID      pData,
        PUINT       pcbSize,
        UINT        cbSizeHeader
        );
    };

} USER32, *PUSER32;

extern USER32 g_user32;

        #undef RegisterRawInputDevices
        #undef GetRawInputData

        #define             RegisterRawInputDevices        \
        g_user32._RegisterRawInputDevices

        #define             GetRawInputData                \
        g_user32._GetRawInputData

#endif

/*****************************************************************************
 *
 * Dummy functions
 *
 *   These functions are used only when some DLLs can't be loaded.
 *
 *****************************************************************************/

//cfgmgr32.dll 

CONFIGRET WINAPI DIDummy_CM_Get_Child
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  dnDevInst,
IN  ULONG    ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Get_Sibling
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  DevInst,
IN  ULONG    ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Get_Parent
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  dnDevInst,
IN  ULONG    ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Get_DevNode_Registry_Property
(
IN  DEVINST     dnDevInst,
IN  ULONG       ulProperty,
OUT PULONG      pulRegDataType,   OPTIONAL
OUT PVOID       Buffer,           OPTIONAL
IN  OUT PULONG  pulLength,
IN  ULONG       ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Set_DevNode_Registry_Property
(
IN  DEVINST     dnDevInst,
IN  ULONG       ulProperty,
IN  PVOID       Buffer,           OPTIONAL
IN  ULONG       ulLength,
IN  ULONG       ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Get_Device_ID
(
 IN  DEVINST  dnDevInst,
 OUT PTCHAR   Buffer,
 IN  ULONG    BufferLen,
 IN  ULONG    ulFlags
);

//Setupapi.dll

HDEVINFO WINAPI DIDummy_SetupDiGetClassDevs
(
IN LPGUID ClassGuid,  OPTIONAL
IN LPCTSTR Enumerator, OPTIONAL
IN HWND   hwndParent, OPTIONAL
IN DWORD  Flags
);

BOOL WINAPI DIDummy_SetupDiDestroyDeviceInfoList
(
IN HDEVINFO DeviceInfoSet
);

BOOL WINAPI DIDummy_SetupDiGetDeviceInterfaceDetail
(
IN  HDEVINFO                         DeviceInfoSet,
IN  PSP_DEVICE_INTERFACE_DATA        pdid,
OUT PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd,         OPTIONAL
IN  DWORD                            cbDidd,
OUT PDWORD                           RequiredSize,  OPTIONAL
OUT PSP_DEVINFO_DATA                 DeviceInfoData OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiEnumDeviceInterfaces
(
IN  HDEVINFO                  DeviceInfoSet,
IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
IN  LPGUID                    InterfaceClassGuid,
IN  DWORD                     MemberIndex,
OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
);

HKEY WINAPI DIDummy_SetupDiCreateDeviceInterfaceRegKey
(
IN HDEVINFO                  hdev,
IN PSP_DEVICE_INTERFACE_DATA pdid,
IN DWORD                     Reserved,
IN REGSAM                    samDesired,
IN HINF                      InfHandle,           OPTIONAL
IN PCSTR                     InfSectionName       OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiCallClassInstaller
(
IN DI_FUNCTION      InstallFunction,
IN HDEVINFO         DeviceInfoSet,
IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiGetDeviceRegistryProperty
(
IN  HDEVINFO         DeviceInfoSet,
IN  PSP_DEVINFO_DATA DeviceInfoData,
IN  DWORD            Property,
OUT PDWORD           PropertyRegDataType, OPTIONAL
OUT PBYTE            PropertyBuffer,
IN  DWORD            PropertyBufferSize,
OUT PDWORD           RequiredSize         OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiSetDeviceRegistryProperty
(
IN     HDEVINFO         DeviceInfoSet,
IN OUT PSP_DEVINFO_DATA DeviceInfoData,
IN     DWORD            Property,
IN     CONST BYTE*      PropertyBuffer,
IN     DWORD            PropertyBufferSize
);

BOOL WINAPI DIDummy_SetupDiGetDeviceInstanceId
(
IN  HDEVINFO         DeviceInfoSet,
IN  PSP_DEVINFO_DATA DeviceInfoData,
OUT PTSTR            DeviceInstanceId,
IN  DWORD            DeviceInstanceIdSize,
OUT PDWORD           RequiredSize          OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiOpenDeviceInfo
(
IN  HDEVINFO         DeviceInfoSet,
IN  LPCTSTR          DeviceInstanceId,
IN  HWND             hwndParent,       OPTIONAL
IN  DWORD            OpenFlags,
OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
);

HDEVINFO WINAPI DIDummy_SetupDiCreateDeviceInfoList
(
IN LPGUID ClassGuid, OPTIONAL
IN HWND   hwndParent OPTIONAL
);

HKEY WINAPI DIDummy_SetupDiOpenDevRegKey
(
IN HDEVINFO         DeviceInfoSet,
IN PSP_DEVINFO_DATA DeviceInfoData,
IN DWORD            Scope,
IN DWORD            HwProfile,
IN DWORD            KeyType,
IN REGSAM           samDesired
);

// hid.dll

void __stdcall DIDummy_HidD_GetHidGuid
(
OUT   LPGUID   HidGuid
);

BOOLEAN __stdcall DIDummy_HidD_GetPreparsedData
(
IN    HANDLE                  HidDeviceObject,
OUT   PHIDP_PREPARSED_DATA  * PreparsedData
);

BOOLEAN __stdcall DIDummy_HidD_FreePreparsedData
(
IN    PHIDP_PREPARSED_DATA PreparsedData
);

BOOLEAN __stdcall DIDummy_HidD_FlushQueue
(
IN    HANDLE                HidDeviceObject
);

BOOLEAN __stdcall DIDummy_HidD_GetAttributes
(
IN  HANDLE              HidDeviceObject,
OUT PHIDD_ATTRIBUTES    Attributes
);

BOOLEAN __stdcall DIDummy_HidD_GetFeature
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
);

BOOLEAN __stdcall DIDummy_HidD_SetFeature
(
IN    HANDLE   HidDeviceObject,
IN    PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
);

BOOLEAN __stdcall DIDummy_HidD_GetProductString
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    Buffer,
IN    ULONG    BufferLength
);

BOOLEAN __stdcall DIDummy_HidD_GetInputReport
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
);

NTSTATUS __stdcall DIDummy_HidP_GetCaps
(
IN      PHIDP_PREPARSED_DATA      PreparsedData,
OUT     PHIDP_CAPS                Capabilities
);

NTSTATUS __stdcall DIDummy_HidP_GetButtonCaps
(
IN       HIDP_REPORT_TYPE     ReportType,
OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
IN OUT   PUSHORT              ButtonCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_GetValueCaps
(
IN       HIDP_REPORT_TYPE     ReportType,
OUT      PHIDP_VALUE_CAPS     ValueCaps,
IN OUT   PUSHORT              ValueCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_GetLinkCollectionNodes
(
OUT      PHIDP_LINK_COLLECTION_NODE LinkCollectionNodes,
IN OUT   PULONG                     LinkCollectionNodesLength,
IN       PHIDP_PREPARSED_DATA       PreparsedData
);

ULONG __stdcall DIDummy_HidP_MaxDataListLength
(
IN HIDP_REPORT_TYPE      ReportType,
IN PHIDP_PREPARSED_DATA  PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_GetUsagesEx   //unused
(
IN       HIDP_REPORT_TYPE     ReportType,
IN       USHORT               LinkCollection,
OUT      PUSAGE_AND_PAGE      ButtonList,
IN OUT   ULONG *              UsageLength,
IN       PHIDP_PREPARSED_DATA PreparsedData,
IN       PCHAR                Report,
IN       ULONG                ReportLength
);

NTSTATUS __stdcall DIDummy_HidP_GetScaledUsageValue  //unused
(
IN    HIDP_REPORT_TYPE     ReportType,
IN    USAGE                UsagePage,
IN    USHORT               LinkCollection,
IN    USAGE                Usage,
OUT   PLONG                UsageValue,
IN    PHIDP_PREPARSED_DATA PreparsedData,
IN    PCHAR                Report,
IN    ULONG                ReportLength
);

NTSTATUS __stdcall DIDummy_HidP_GetData
(
IN       HIDP_REPORT_TYPE      ReportType,
OUT      PHIDP_DATA            DataList,
IN OUT   PULONG                DataLength,
IN       PHIDP_PREPARSED_DATA  PreparsedData,
IN       PCHAR                 Report,
IN       ULONG                 ReportLength
);

NTSTATUS __stdcall DIDummy_HidP_SetData
(
IN       HIDP_REPORT_TYPE      ReportType,
IN       PHIDP_DATA            DataList,
IN OUT   PULONG                DataLength,
IN       PHIDP_PREPARSED_DATA  PreparsedData,
IN OUT   PCHAR                 Report,
IN       ULONG                 ReportLength
);

NTSTATUS __stdcall DIDummy_HidP_GetUsageValue
(
IN    HIDP_REPORT_TYPE     ReportType,
IN    USAGE                UsagePage,
IN    USHORT               LinkCollection,
IN    USAGE                Usage,
OUT   PULONG               UsageValue,
IN    PHIDP_PREPARSED_DATA PreparsedData,
IN    PCHAR                Report,
IN    ULONG                ReportLength
);

ULONG __stdcall DIDummy_HidP_MaxUsageListLength
(
IN HIDP_REPORT_TYPE      ReportType,
IN USAGE                 UsagePage,
IN PHIDP_PREPARSED_DATA  PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_GetSpecificButtonCaps 
(
IN       HIDP_REPORT_TYPE     ReportType,
IN       USAGE                UsagePage,      
IN       USHORT               LinkCollection, 
IN       USAGE                Usage,          
OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
IN OUT   PUSHORT              ButtonCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_TranslateUsagesToI8042ScanCodes
(
IN       PUSAGE               ChangedUsageList, // Those usages that changed
IN       ULONG                UsageListLength,
IN       HIDP_KEYBOARD_DIRECTION KeyAction,
IN OUT   PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
IN       PHIDP_INSERT_SCANCODES  InsertCodesProcedure,
IN       PVOID                InsertCodesContext
);

// winmm.dll

MMRESULT WINAPI DIDummy_joyGetDevCaps
(
IN  UINT uJoyID,
OUT LPJOYCAPS pjc,
IN  UINT cbjc
);

MMRESULT WINAPI DIDummy_joyGetPosEx
(
IN  UINT        uJoyID,
OUT LPJOYINFOEX pji
);

MMRESULT WINAPI DIDummy_joyGetPos
(
IN  UINT        uJoyID,
OUT LPJOYINFO   pji
);

UINT WINAPI DIDummy_joyConfigChanged
(
IN DWORD dwFlags
);

MMRESULT WINAPI DIDummy_mmioClose 
( 
IN HMMIO hmmio, 
IN UINT fuClose
);

HMMIO WINAPI DIDummy_mmioOpenA 
( 
IN OUT LPSTR pszFileName, 
IN OUT LPMMIOINFO pmmioinfo, 
IN DWORD fdwOpen
);

MMRESULT WINAPI DIDummy_mmioDescend 
( 
IN HMMIO hmmio, 
IN OUT LPMMCKINFO pmmcki, 
IN const MMCKINFO FAR* pmmckiParent, 
IN UINT fuDescend
);

MMRESULT WINAPI DIDummy_mmioCreateChunk 
(
IN HMMIO hmmio, 
IN LPMMCKINFO pmmcki, 
IN UINT fuCreate
);

LONG WINAPI DIDummy_mmioRead 
( 
IN HMMIO hmmio, 
OUT HPSTR pch, 
IN LONG cch
);

LONG WINAPI DIDummy_mmioWrite 
( 
IN HMMIO hmmio, 
IN const char _huge* pch, 
IN LONG cch
);

MMRESULT WINAPI DIDummy_mmioAscend 
( 
IN HMMIO hmmio, 
IN LPMMCKINFO pmmcki, 
IN UINT fuAscend
);

// user32.dll

#ifdef USE_WM_INPUT

BOOL WINAPI DIDummy_RegisterRawInputDevices
(
PCRAWINPUTDEVICE pRawInputDevices,
UINT uiNumDevices,
UINT cbSize
);

UINT WINAPI DIDummy_GetRawInputData
(
HRAWINPUT   hRawInput,
UINT        uiCommand,
LPVOID      pData,
PUINT       pcbSize,
UINT        cbSizeHeader
);

#endif // #ifdef USE_WM_INPUT

#endif /* STATIC_DLLUSAGE */

/*****************************************************************************
 *
 *      dihidenm.c - HID enumeration functions.
 *
 *****************************************************************************/

extern TCHAR g_tszIdLastRemoved[MAX_PATH]; //in dihidenm.c
extern DWORD g_tmLastRemoved;   //in dihinenm.c

STDMETHODIMP hresFindHIDInstanceGUID(PCGUID pguid, CREATEDCB *pcdcb);
STDMETHODIMP hresFindHIDDeviceInterface(LPCTSTR ptszPath, LPGUID pguidOut);

PHIDDEVICEINFO EXTERNAL phdiFindHIDInstanceGUID(PCGUID pguid);
PHIDDEVICEINFO EXTERNAL phdiFindHIDDeviceInterface(LPCTSTR ptszPath);

void EXTERNAL DIHid_BuildHidList(BOOL fForce);
void EXTERNAL DIHid_EmptyHidList(void);

BOOL EXTERNAL
    DIHid_GetDevicePath(HDEVINFO hdev,
                        PSP_DEVICE_INTERFACE_DATA pdid,
                        PSP_DEVICE_INTERFACE_DETAIL_DATA *ppdidd,
                        PSP_DEVINFO_DATA pdinf);


BOOL EXTERNAL
    DIHid_GetDeviceInstanceId(HDEVINFO hdev,
                              PSP_DEVINFO_DATA pdinf, 
                              LPTSTR *pptszId);

BOOL EXTERNAL
    DIHid_GetInstanceGUID(HKEY hk, LPGUID pguid);

    
/*****************************************************************************
 *
 *      diguid.c - GUID generation
 *
 *****************************************************************************/

void EXTERNAL DICreateGuid(LPGUID pguid);
void EXTERNAL DICreateStaticGuid(LPGUID pguid, WORD pid, WORD vid);

/*****************************************************************************
 *
 *      dihid.c
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *          We will just use the HID item index as our DirectInput
 *          internal ID number, which is in turn an index into the
 *          <t DIOBJECTDATAFORMAT> array.
 *
 *          Keyboard support requires a translation table.
 *          Other devices also a translation table so that the external 
 *          instance numbers can be made compatible with legacy ones and 
 *          so that secondary aliases can be separated from primary ones.
 *
 *          Since HID restarts the item index counter at zero for
 *          each of input, feature, and output, we need to do some
 *          adjustment so there aren't any collisions.  So we
 *          shift the features to start after the inputs, and the
 *          outputs to start after the features.
 *
 *          The <e CHid.rgdwBase> array contains the amount by which
 *          each group of HID item indexes has been shifted.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | HidP_IsValidReportType |
 *
 *          For debugging only.  Check if a value is a valid
 *          <t HIDP_REPORT_TYPE>.
 *
 *          Note that we also create a "fake" report type in which
 *          to record our collections.
 *
 *  @field  HIDP_REPORT_TYPE | type |
 *
 *          One of the values
 *          <c HidP_Input>,
 *          <c HidP_Output>,
 *          or
 *          <c HidP_Feature>.  Hopefully.
 *
 *****************************************************************************/

    #define HidP_Max            (HidP_Feature + 1)
    #define HidP_Coll           HidP_Max
    #define HidP_MaxColl        (HidP_Coll + 1)

BOOL INLINE
    HidP_IsValidReportType(HIDP_REPORT_TYPE type)
{
    CAssertF(HidP_Input == 0);
    CAssertF(HidP_Output == 1);
    CAssertF(HidP_Feature == 2);
    return type < HidP_Max;
}

/*****************************************************************************
 *
 *          There are three (overlapping) classes of HID reports.
 *
 *          InputLike - HidP_Input and HidP_Feature
 *          OutputLike - HidP_Output and HidP_Feature
 *          NothingLike - HidP_Coll
 *
 *****************************************************************************/

BOOL INLINE
    HidP_IsInputLike(HIDP_REPORT_TYPE type)
{
    return type == HidP_Input || type == HidP_Feature;
}

BOOL INLINE
    HidP_IsOutputLike(HIDP_REPORT_TYPE type)
{
    return type == HidP_Output || type == HidP_Feature;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct LMINMAX |
 *
 *          Min and max, that's all.  These are kept in structures
 *          to make logical-to-physical and physical-to-logical
 *          translations less gross.
 *
 *  @field  LONG | Min |
 *
 *          The minimum value.
 *
 *  @field  LONG | Max |
 *
 *          The maximum value.
 *
 *****************************************************************************/

typedef struct LMINMAX
{
    LONG Min;
    LONG Max;
} LMINMAX, *PLMINMAX;

typedef const LMINMAX *PCLMINMAX;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDGROUPCAPS |
 *
 *          This structure unifies the various HID caps structures
 *          <t HIDP_BUTTON_CAPS> and
 *          <t HIDP_VALUE_CAPS>.
 *
 *  @field  HIDP_REPORT_TYPE | type |
 *
 *          One of the values
 *          <c HidP_Input>,
 *          <c HidP_Output>,
 *          or
 *          <c HidP_Feature>.
 *
 *  @field  UINT | cObj |
 *
 *          Number of objects in this group.
 *
 *  @field  USAGE | UsagePage |
 *
 *          Usage page for all usages in the group.
 *
 *  @field  USAGE | UsageMin |
 *
 *          First usage described by this group.  The remaining
 *          items are numbered consecutively starting from
 *          this value.
 *
 *  @field  USHORT | StringMin |
 *
 *          String for first usage described by this group.
 *          The remaining strings are numbered consecutively
 *          starting from this value, unless the string maximum
 *          is reached, in which case all subsequent objects
 *          share that last string.
 *
 *  @field  USHORT | StringMax |
 *
 *          Last string.
 *
 *  @field  USHORT | DesignatorMin |
 *
 *          Designator for first usage described by this group.
 *          The remaining designators are numbered consecutively
 *          starting from this value, unless the designator maximum
 *          is reached, in which case all subsequent objects
 *          share that last designator.
 *
 *  @field  USHORT | DesignatorMax |
 *
 *          Last designator.
 *
 *  @field  USHORT | DataIndexMin |
 *
 *          Data index for the first usage described by this group.
 *          The remaining data index values are numbered consecutively
 *          starting from this value.
 *
 *  @field  USHORT | usGranularity |
 *
 *          If object is a POV or wheel, then contains device granularity.
 *
 *  @field  LONG | lMask |
 *
 *          Mask bits used for sign extension.  For example, if the
 *          value is 8-bits, the mask will be 0xFFFFFF80, indicating
 *          that bit 7 (0x00000080) is extended to fill the remainder
 *          of the value.
 *
 *          This field is used only by values.
 *
 *  @field  USHORT | BitSize |
 *
 *          Number of bits devoted to this value, including the sign bit.
 *
 *          ISSUE-2001/03/29-timgill structure field probably not used anywhere.
 *
 *  @field  USHORT | LinkCollection |
 *
 *          HID link collection number.
 *
 *  @field  LMINMAX | Logical |
 *
 *          Logical minimum and maximum values.
 *          These are the extremes of raw values
 *          that can validly be received from the device.
 *
 *          This field is used only by values.
 *
 *  @field  LMINMAX | Physical |
 *
 *          Physical minimum and maximum values.
 *          This is the "actual" value
 *          that the logical minimum and maximum value corresponds to.
 *
 *          This field is used only by values, and is consulted
 *          only when converting between DirectInput calibration
 *          (which uses logical values) and VJOYD calibration
 *          (which uses physical values).
 *
 *  @field  LONG | Null |
 *
 *          The null value to be used for output.
 *
 *          This field is used only by values.
 *
 *  @field  ULONG | Units |
 *
 *          The HID units descriptor, if any.
 *
 *  @field  WORD | Exponent |
 *
 *          The HID unit exponent, if any.
 *
 *  @field  WORD | wReportId |
 *
 *          HID report Id
 *
 *  @field  BOOL | IsAbsolute |
 *
 *          Nonzero if the group describes absolute axes.
 *
 *          This field is used only by values.
 *
 *  @field  BOOL | IsValue |
 *
 *          Nonzero if the group describes a HID value.
 *
 *          Note that an analog pushbutton is reported by
 *          DirectInput as a <c DIDFT_BUTTON>, but is
 *          handled internally as a HID value.
 *
 *  @field  BOOL | IsAlias |
 *
 *          Nonzero if the group describes an alias.
 *
 *  @field  BOOL | IsSigned |
 *          
 *          The return data is signed. 
 *
 *  @field  BOOL | IsPolledPOV |
 *          
 *          Nonzero if the axis is a polled POV. 
 *
 *  @devnote New for DX6.1a
 *
 *****************************************************************************/

    #define HIDGROUPCAPS_SIGNATURE      0x47444948  /* HIDG */

typedef struct HIDGROUPCAPS
{

    D(DWORD dwSignature;)
    HIDP_REPORT_TYPE type;
    UINT    cObj;

    USAGE   UsagePage;
    USAGE   UsageMin;

    USHORT  StringMin,        StringMax;
    USHORT  DesignatorMin,    DesignatorMax;
    USHORT  DataIndexMin;

    USHORT  usGranularity;

    LONG    lMask;

    USHORT  BitSize;

    USHORT  LinkCollection;

    LMINMAX Logical;
    LMINMAX Physical;

    LONG    Null;

    ULONG   Units;
    WORD    Exponent;

    WORD    wReportId;
    BOOL    fReportDisabled;
    BOOL    Reserved;

    BOOL    IsAbsolute;
    BOOL    IsValue;
    BOOL    IsAlias;
    BOOL    IsSigned;

  #ifdef WINNT
    BOOL    IsPolledPOV;
  #endif
    
} HIDGROUPCAPS, *PHIDGROUPCAPS;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDOBJCAPS |
 *
 *          This structure contains various cached pointers for each
 *          object on the device, allowing us to get at things like
 *          the group caps and the calibration information.
 *
 *  @field  PHIDGROUPCAPS | pcaps |
 *
 *          The <t PHIDGROUPCAPS> for the group the object belongs to.
 *
 *  @field  PJOYRANGECONVERT | pjrc |
 *
 *          If non-NULL, then points to the range conversion information
 *          for the object.
 *
 *  @field  int | idata |
 *
 *          Index into the <t HIDP_DATA> array for the corresponding
 *          output/feature report,
 *          or <c -1> if the item is not in the output/feature report.
 *
 *****************************************************************************/

typedef struct HIDOBJCAPS
{
    PHIDGROUPCAPS pcaps;
    PJOYRANGECONVERT pjrc;
    int idata;
} HIDOBJCAPS, *PHIDOBJCAPS;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDREPORTINFO |
 *
 *          This structure contains information that is used for
 *          parsing HID reports.
 *
 *  @field  PHIDP_DATA | rgdata |
 *
 *          Array used when parsing reports via
 *          <f HidP_GetData> or <f HidP_SetData>.  This MUST be aligned 
 *          correctly on some architechtures.
 *
 *  @field  PV | pvReport |
 *
 *          The report itself.
 *
 *  @field  int | cdataMax |
 *
 *          Number of elements in the <e HIDREPORTINFO.rgdata> array.
 *
 *  @field  int | cdataUsed |
 *
 *          Number of elements in the <e HIDREPORTINFO.rgdata> array
 *          that are actually in use.
 *
 *  @field  ULONG | cbReport |
 *
 *          Number of bytes in the report.
 *
 *  @field  BOOL | fNeedClear |
 *
 *          Nonzero if the report needs to be zero'd out because we
 *          deleted something (most likely a button) from it.
 *          The only way to delete an item from a report is to zero
 *          out the entire report and then re-add everything back in.
 *
 *  @field  BOOL | fChanged |
 *
 *          Nonzero if an element in the report has changed.
 *
 *****************************************************************************/

typedef struct HIDREPORTINFO
{
    PHIDP_DATA rgdata;
    PV pvReport;
    int cdataMax;
    int cdataUsed;
    ULONG cbReport;
    BOOL fNeedClear;
    BOOL fChanged;
} HIDREPORTINFO, *PHIDREPORTINFO;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CHid |
 *
 *          The <i IDirectInputDeviceCallback> object for HID devices.
 *
 *  @field  IDirectInputDeviceCalllback | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  PV | pvGroup2 |
 *
 *          Pointer to group 2 memory.  This field is a union with the 
 *          pointer to the first chunk of memory in the second memory group.
 *
 *  @field  HIDREPORTINFO | hriIn |
 *
 *          HID input report parsing and state.
 *
 *          This memory is the first chunk of group 2.
 *
 *  @field  HIDREPORTINFO | hriOut |
 *
 *          HID output report parsing and state.
 *
 *  @field  HIDREPORTINFO | hriFea |
 *
 *          HID feature report parsing and state.
 *
 *  @field  PV | pvPhys |
 *
 *          Pointer to physical device status information updated
 *          asynchronously by the data collection thread.
 *
 *  @field  PV | pvStage |
 *
 *          Staging area used when the HID report is parsed.
 *
 *          This memory is the last chunk of group 2.
 *
 *  @field  DWORD | cbPhys |
 *
 *          Size of the physical device state.
 *
 *  @field  VXDINSTANCE * | pvi |
 *
 *          The DirectInput instance handle.
 *
 *          HID devices always run through ring 3, which is misleadingly
 *          called "emulation".
 *
 *  @field  DWORD | dwDevType |
 *
 *          Device type code.
 *
 *  @field  LPTSTR | ptszId |
 *
 *          Setupapi device instance ID.  Used to obtain things
 *          like manufacturer name.
 *
 *  @field  LPTSTR | ptszPath |
 *
 *          Path to the device, for <f CreateFile>.
 *
 *  @field  UINT | dwAxes |
 *
 *          Number of axes on the device.
 *
 *  @field  UINT | dwButtons |
 *
 *          Number of buttons on the device.
 *
 *  @field  UINT | dwPOVs |
 *
 *          Number of POV controllers on the device.
 *
 *  @field  HANDLE | hdev |
 *
 *          Handle to the device itself.  This field is valid only
 *          while the device is acquired.
 *
 *  @field  HANDLE | hdevEm |
 *
 *          <f DuplicateHandle> of the <e CHid.hdev> which is used
 *          by the worker thread.  We need to keep this separate from
 *          the main copy to avoid race conditions between the main
 *          thread and the worker thread.
 *
 *  @field  HKEY | hkInstType |
 *
 *          Per-instance registry key that contains additional configuration
 *          information, equivalent to the joystick Type key.
 *
 *  @field  DWORD | rgdwBase[HidP_MaxColl] |
 *
 *          Array of base indices for the three HID usage classes:
 *          <c HidP_Input>, <c HidP_Output>, and <c HidP_Feature>.
 *          We hide the <c HidP_Collection> base index here, too.
 *
 *  @field  PHIDOBJCAPS | rghoc |
 *
 *          Pointer to array of
 *          <t PHIDOBJCAPS>, one for each object on the device,
 *          each of which in turn contains info about a single object.
 *
 *          This memory is allocated as part of the
 *          df.rgodf in the <t DIDATAFORMAT> structure
 *          hence should not be freed separately.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          The dynamically-generated data format based on the
 *          usages on the HID device.
 *
 *  @field  DWORD | ibButtonData |
 *
 *          The location of the button data inside the data format.
 *
 *  @field  DWORD | cbButtonData |
 *
 *          The number of bytes of button data inside the data format.
 *
 *  @field  PBYTE * | rgpbButtonMasks |
 *
 *          Pointer to a an array of pointers to byte strings to mask 
 *          the buttons relevant to a report.
 *
 *  @field  PHIDP_PREPARSED_DATA | ppd |
 *
 *          Preparsed data generated by the HID subsystem.
 *
 *  @field  PHIDGROUPCAPS | rgcaps |
 *
 *          Array of <t HIDGROUPCAPS> structures used to keep
 *          track of the various buttons, groups, and collections.
 *
 *  @field  UINT | ccaps |
 *
 *          Number of caps structures in the <e CHid.rgcaps> array.
 *
 *  @field  HIDP_CAPS | caps |
 *
 *          Cached HID caps.
 *
 *  @field  OVERLAPPED | o |
 *
 *          Overlapped I/O structure used by worker thread
 *          for reading.
 *
 *  @field  PJOYRANGECONVERT | pjrcNext |
 *
 *          Pointer to the first <t JOYRANGECONVERT> structure
 *          (in a preallocated array) which has
 *          yet to be used.
 *          This structure is used for logical-to-physical
 *          range conversion (a.k.a. calibration).
 *
 *          This memory is allocated as part of the
 *          df.rgodf in the <t DIDATAFORMAT> structure
 *          hence should not be freed separately.
 *
 *          This field is used during device initialization to
 *          parcel out the <t JOYRANGECONVERT>s.  Afterwards,
 *          the field is <c NULL> if we did not create any
 *          conversion structures (hence do not need to subclass
 *          the cooperative window to catch recalibrations).
 *
 *  @field  PINT | rgiobj |
 *
 *          This points to an array which maps DirectInput instance 
 *          values (DIDFT_GETINSTANCE) into object indices.
 *
 *  @field  PINT | rgipov |
 *
 *          If we are not a keyboard, then this is the first element in 
 *          the above array which maps povs.
 *
 *  @field  PINT | rgiaxis |
 *
 *          If we are not a keyboard, then this is the first element in 
 *          the above array which maps axes.
 *
 *  @field  PINT | rgicoll |
 *
 *          If we are not a keyboard, then this is the first element in 
 *          the above array which maps collections.
 *          //ISSUE-2001/03/29-timgill need to document keyboard case behaviour
 *
 *  @field  UINT | uiInstanceMax |
 *
 *          The number of elements in the above
 *          <f rgiobj> array.
 *
 *  @field  int | idJoy |
 *
 *          Joystick identifier for <f joyGetPosEx> and friends for
 *          legacy access.
 *
 *          This value starts out as -1, to meant that
 *          the corresponding legacy joystick is unknown.
 *          If we do something that requires the matched legacy
 *          joystick to be found, we check if the current value
 *          is still valid.  If not (either it is -1 or the cached
 *          value is stale), then we go hunt for the correct value.
 *
 *  @field  HKEY | hkType |
 *
 *          The joystick type key opened with <c MAXIMUM_ALLOWED> access.
 *          This is not per-instance; multiple instances of the same
 *          hardware share this key.
 *
 *  @field  USHORT | VendorID |
 *
 *          HID vendor ID for this device.
 *
 *  @field  USHORT | ProductID |
 *
 *          HID product ID for this device.
 *
 *  @field  HWND | hwnd |
 *
 *          The window which we have subclassed in order to watch
 *          for recalibration messages.
 *
 *  @field  BOOL | IsPolledInput |
 *
 *          Nonzero if the device has to be polled for Input data.
 *
 *  @field  BOOL | fPIDdevice |
 *
 *          Set to true if the device is found to support PID. 
 *
 *  @field  WORD | wMaxReportId | 
 *          
 *          The maximum (number) of ReportId used by the HID device.   
 *      
 *  @field  PUCHAR | pEnableReportId |
 *          
 *          Pointer to (wMaxReportId) bytes. If a reportID needs to be
 *          polled in order to get features / set Output, then that element
 *          of this array is set to 0x1.
 *
 *  @field  BOOL | fEnableInputReport |
 *
 *          True if Input report should be enabled for this device.
 *  
 *  @field  BOOL | fFlags2Checked |
 *
 *          True after we check the registry for Flags2 for disabling
 *          input reports.
 *
 *  @comm
 *
 *          It is the caller's responsibility to serialize access as
 *          necessary.
 *
 *****************************************************************************/

typedef struct CHid
{

    /* Supported interfaces */
    IDirectInputDeviceCallback dcb;

    union
    {
        PV            pvGroup2;
        HIDREPORTINFO hriIn;
    };

    HIDREPORTINFO hriOut;
    HIDREPORTINFO hriFea;

    PV       pvPhys;
    PV       pvStage;
    DWORD    cbPhys;

    VXDINSTANCE *pvi;

    DWORD    dwDevType;

    UINT     dwAxes;
    UINT     dwButtons;
    UINT     dwPOVs;
    UINT     dwCollections;

    HANDLE   hdev;
    HANDLE   hdevEm;

    DWORD    rgdwBase[HidP_MaxColl];
    PHIDOBJCAPS rghoc;
    DIDATAFORMAT df;

    DWORD    ibButtonData;
    DWORD    cbButtonData;
    PBYTE   *rgpbButtonMasks;
    
    PHIDP_PREPARSED_DATA ppd;
    PHIDGROUPCAPS rgcaps;

    PJOYRANGECONVERT pjrcNext;

    HIDP_CAPS caps;

    ED       ed;
    OVERLAPPED o;
    DWORD    dwStartRead;
    DWORD    dwStopRead;

    PINT     rgiobj;
    PINT     rgipov;
    PINT     rgiaxis;
    PINT     rgicoll;
    UINT     uiInstanceMax;

    LPTSTR   ptszId;
    LPTSTR   ptszPath;
    HKEY     hkInstType;
    UINT     ccaps;
    int      idJoy;

    HKEY     hkType;
    USHORT   VendorID;
    USHORT   ProductID;
    
    #define  FAILED_POLL_THRESHOLD   (0x4)
        
    HWND     hwnd;    
    
    BOOL     IsPolledInput;
    BOOL     fPIDdevice;  
    WORD     wMaxReportId[HidP_Max];
    PUCHAR   pEnableReportId[HidP_Max];

    DWORD    dwVersion;

#if (DIRECTINPUT_VERSION > 0x061A)
    DIAPPHACKS  diHacks;
#endif

    BOOL     fEnableInputReport;
    BOOL     fFlags2Checked;

} CHid, CHID, *PCHID;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCHID | pchidFromPo |
 *
 *          Given an interior pointer to an <t OVERLAPPED>, retrieve
 *          a pointer to the parent <t CHid>.
 *
 *  @parm   LPOVERLAPPED | po |
 *
 *          The pointer to convert.
 *
 *****************************************************************************/

PCHID INLINE
    pchidFromPo(LPOVERLAPPED po)
{
    return pvSubPvCb(po, FIELD_OFFSET(CHid, o));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCHID | pchidFromPed |
 *
 *          Given an interior pointer to a <t CEd>, retrieve
 *          a pointer to the parent <t CHid>.
 *
 *  @parm   PED | ped |
 *
 *          The pointer to convert.
 *
 *****************************************************************************/

PCHID INLINE
    pchidFromPed(PED ped)
{
    return pvSubPvCb(ped, FIELD_OFFSET(CHid, ed));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCHID | pchidFromPem |
 *
 *          Given a <t CEm>, wander back to the
 *          <t CHid> that spawned it.
 *
 *  @parm   PEM | pem |
 *
 *          The pointer at which to start.
 *
 *****************************************************************************/

PCHID INLINE
    pchidFromPem(PEM pem)
{
    PCHID pchid = pchidFromPed(pem->ped);
    AssertF(pemFromPvi(pchid->pvi) == pem);
    return pchid;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method UINT | CHid | ObjFromType |
 *
 *          Given a <p dwType>, extract the instance number
 *          and (if necessary) convert it to an object index.
 *          Note, the instance number will always be of the primary instance
 *          not an alias.
 *
 *  @parm   PCHID | this |
 *
 *          HID device object.
 *
 *  @parm   DWORD | dwType |
 *
 *          The type code to convert.
 *
 *  @returns
 *
 *          The object index, or an out-of-range value.
 *
 *****************************************************************************/

UINT INLINE
    CHid_ObjFromType(PCHID this, DWORD dwType)
{
    UINT uiObj = DIDFT_GETINSTANCE(dwType);

    // ISSUE-2001/03/29-timgill Range checks may be unnecessary
    // MarcAnd can we ever get the out of range value?
    //          if so, can we really run with it?
    //          if not, can these range checks be converted into Asserts?

    /*
     *  The range checking makes use of the fact that the translation 
     *  tables are taken from a contiguous memory allocation and that
     *  aliased collections are not distinguished.
     */
    if(this->rgiobj)
    {
        switch( DIDFT_GETTYPE(dwType) )
        {
        case DIDFT_RELAXIS:
        case DIDFT_ABSAXIS:
            if( &this->rgiaxis[uiObj] < this->rgicoll )
            {
                uiObj = this->rgiaxis[uiObj];
            } else
            {
                uiObj = 0xFFFFFFFF;
            }
            break;

        case DIDFT_PSHBUTTON:
        case DIDFT_TGLBUTTON:
            /*
             * If it is keyboard, this->rgiobj == this->rgipov (see CHid_MungeKeyboard).
             * So, we can't test &this->rgiobj[uiObj] < this->rgipov.
             */
            if( (GET_DIDEVICE_TYPE(this->dwDevType) == DIDEVTYPE_KEYBOARD &&
                 uiObj < this->uiInstanceMax ) ||
                &this->rgiobj[uiObj] < this->rgipov )
            {
                uiObj = this->rgiobj[uiObj];
            } else
            {
                uiObj = 0xFFFFFFFF;
            }
            break;

        case DIDFT_POV:
            if( &this->rgipov[uiObj] < this->rgiaxis )
            {
                uiObj = this->rgipov[uiObj];
            } else
            {
                uiObj = 0xFFFFFFFF;
            }
            break;
        case (DIDFT_COLLECTION | DIDFT_NODATA):
            if( &this->rgicoll[uiObj] <= &this->rgiobj[this->uiInstanceMax] )
            {
                uiObj = this->rgicoll[uiObj];
            } else
            {
                uiObj = 0xFFFFFFFF;
            }
            break;
        case DIDFT_NODATA:
            /*
             * So far, this TYPE only shows up on Keyboard (HID_USAGE_PAGE_LED).
             */
            if( GET_DIDEVICE_TYPE(this->dwDevType) == DIDEVTYPE_KEYBOARD &&
                 uiObj < this->uiInstanceMax )
            {
                uiObj = this->rgiobj[uiObj];
            }
            break;
        
        default:
            /*
             *  Hopefully this is just a vendor defined object but squirt
             *  in debug as these may cause problems.
             */
            SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                            TEXT("CHid_ObjFromType: dwType 0x%08x not converted"),
                            dwType );                
            break;
        }
    }
    else
    {
        SquirtSqflPtszV(sqflHidParse | sqflError,
                        TEXT("CHid_ObjFromType: Translation array missing") );
    }

    return uiObj;
}

LONG EXTERNAL
    CHid_CoordinateTransform(PLMINMAX Dst, PLMINMAX Src, LONG lVal);

void EXTERNAL
    CHid_UpdateVjoydCalibration(PCHID this, UINT iobj);

void EXTERNAL
    CHid_UpdateCalibrationFromVjoyd(PCHID this, UINT iobj, LPDIOBJECTCALIBRATION pCal);

/*****************************************************************************
 *
 *      dihidini.c - Device callback initialization stuff
 *
 *****************************************************************************/

#define INITBUTTONFLAG     0x10000000

HRESULT EXTERNAL CHid_InitParseData(PCHID this);

HRESULT EXTERNAL CHid_Init(PCHID this, REFGUID rguid);

HANDLE EXTERNAL CHid_OpenDevicePath(PCHID this, DWORD dwAttributes );

UINT EXTERNAL CHid_LoadCalibrations(PCHID this);

BOOL EXTERNAL CHid_IsPolledDevice( HANDLE hdev );

/*****************************************************************************
 *
 *      dihiddat.c - HID data parsing/management
 *
 *****************************************************************************/

typedef HRESULT (FAR PASCAL * SENDHIDREPORT)(PCHID this, PHIDREPORTINFO phri);

void EXTERNAL CHid_ResetDeviceData(PCHID this, PHIDREPORTINFO phri,
                                   HIDP_REPORT_TYPE type);
HRESULT EXTERNAL CHid_AddDeviceData(PCHID this, UINT uiObj, DWORD dwData);
STDMETHODIMP CHid_PrepareDeviceData(PCHID this, PHIDREPORTINFO phri);
STDMETHODIMP CHid_SendHIDReport(PCHID this, PHIDREPORTINFO phri,
                                HIDP_REPORT_TYPE type, SENDHIDREPORT SendHIDReport);

NTSTATUS EXTERNAL
    CHid_ParseData(PCHID this, HIDP_REPORT_TYPE type, PHIDREPORTINFO phri);


HRESULT EXTERNAL
    DIHid_GetRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPDIPROPHEADER pdiph);

/*****************************************************************************
 *
 *      diemh.c - HID "emulation"
 *
 *****************************************************************************/

void EXTERNAL CEm_HID_Sync(PLLTHREADSTATE plts, PEM pem);

BOOL EXTERNAL CEm_HID_IssueRead( PCHID pchid );

#else //No HID Support

    #define DIHid_BuildHidList(fForce)
    #define hresFindHIDDeviceInterface(ptszPath, pguidOut)  ( E_FAIL )

#endif /* _DIHID_H */
#endif /* HID_SUPPORT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dihid.c ===
/*****************************************************************************
*
*  DIHid.c
*
*  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
*
*  Abstract:
*
*      The HID device callback.
*
*  Contents:
*
*      CHid_New
*
*****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHidDev

#ifdef HID_SUPPORT

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CHid, IDirectInputDeviceCallback);

Interface_Template_Begin(CHid)
Primary_Interface_Template(CHid, IDirectInputDeviceCallback)
Interface_Template_End(CHid)

/*****************************************************************************
 *
 *      Forward declarations
 *
 *      These are out of laziness, not out of necessity.
 *
 *****************************************************************************/

LRESULT CALLBACK
    CHid_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                      UINT_PTR uid, ULONG_PTR dwRef);
STDMETHODIMP_(DWORD) CHid_GetUsage(PDICB pdcb, int iobj);

/*****************************************************************************
 *
 *      Hid devices are totally arbitrary, so there is nothing static we
 *      can cook up to describe them.  We generate all the information on
 *      the fly.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      Auxiliary helper definitions for CHid.
 *
 *****************************************************************************/

    #define ThisClass CHid
    #define ThisInterface IDirectInputDeviceCallback
    #define riidExpected &IID_IDirectInputDeviceCallback

/*****************************************************************************
 *
 *      CHid::QueryInterface      (from IUnknown)
 *      CHid::AddRef              (from IUnknown)
 *      CHid::Release             (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************/

    #ifdef DEBUG

Default_QueryInterface(CHid)
Default_AddRef(CHid)
Default_Release(CHid)

    #else

        #define CHid_QueryInterface   Common_QueryInterface
        #define CHid_AddRef           Common_AddRef
        #define CHid_Release          Common_Release

    #endif

    #define CHid_QIHelper         Common_QIHelper

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | RemoveSubclass |
 *
 *          Remove our subclass hook on the window.
 *
 *****************************************************************************/

void INTERNAL
    CHid_RemoveSubclass(PCHID this)
{

    /*
     *  !! All the comments in CJoy_RemoveSubclass apply here !!
     */
    if(this->hwnd)
    {
        HWND hwnd = this->hwnd;
        this->hwnd = 0;
        if(!RemoveWindowSubclass(hwnd, CHid_SubclassProc, 0))
        {
            /*
             *  The RemoveWindowSubclass can fail if the window
             *  was destroyed behind our back.
             */
            // AssertF(!IsWindow(hwnd));
        }
        Sleep(0);                   /* Let the worker thread drain */
        Common_Unhold(this);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Unacquire |
 *
 *          Tell the device driver to stop data acquisition.
 *
 *          It is the caller's responsibility to call this only
 *          when the device has been acquired.
 *
 *          Warning!  We require that the device critical section be
 *          held so we don't race against our worker thread.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_Unacquire(PDICB pdcb)
{
    HRESULT hres;
    PCHID this;

    EnterProcI(IDirectInputDeviceCallback::HID::Unacquire,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pvi->pdd);
    AssertF(CDIDev_InCrit(this->pvi->pdd));    

    hres = S_FALSE;     /* Please finish for me */

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CHid_Finalize |
 *
 *          Releases the resources of the device after all references
 *          (both strong and weak) are gone.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
    CHid_Finalize(PV pvObj)
{
    UINT  iType;
    PCHID this = pvObj;

    if(this->hkInstType)
    {
        RegCloseKey(this->hkInstType);
    }

    if(this->hkType)
    {
        RegCloseKey(this->hkType);
    }

    AssertF(this->hdev == INVALID_HANDLE_VALUE);
    AssertF(this->hdevEm == INVALID_HANDLE_VALUE);

    if(this->ppd)
    {
        HidD_FreePreparsedData(this->ppd);
    }

    /*
     *
     *  Free group 2 memory:
     *
     *      hriIn.rgdata        Input data
     *      hriOut.rgdata       Output data
     *      hriFea.rgdata       Feature data (both in and out)
     *
     *      hriIn.pvReport      Raw input report
     *      hriOut.pvReport     Raw output report
     *      hriFea.pvReport     Raw feature report
     *
     *      pvPhys              Used by ED
     *      pvStage
     */
    FreePpv(&this->pvGroup2);

    /*
     *  Freeing df.rgodf also frees rgpvCaps, rgvcaps, rgbcaps, rgcoll.
     */
    FreePpv(&this->df.rgodf);

    FreePpv(&this->rgiobj);
    FreePpv(&this->ptszPath);
    FreePpv(&this->ptszId);
    FreePpv(&this->rgpbButtonMasks);

    for(iType = 0x0; iType < HidP_Max; iType++)
    {
        FreePpv(&this->pEnableReportId[iType]);  
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | AppFinalize |
 *
 *          The client <t VXDINSTANCE> contains a weak pointer back
 *          to us so that that it can party on the data format we
 *          collected.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

void INTERNAL
    CHid_AppFinalize(PV pvObj)
{
    PCHID this = pvObj;

    if(this->pvi)
    {
        HRESULT hres;
        CHid_RemoveSubclass(this);
        hres = Hel_DestroyInstance(this->pvi);
        AssertF(SUCCEEDED(hres));
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CHid_SubclassProc |
 *
 *          Window subclass procedure which watches for
 *          joystick configuration change notifications.
 *
 *          Even if we are not a joystick, we still listen to
 *          this, in case somebody recalibrated a remote control
 *          or some other wacky thing like that.
 *
 *          However, if our device has no calibratable controls,
 *          then there's no point in watching for recalibration
 *          notifications.
 *
 *  @parm   HWND | hwnd |
 *
 *          The victim window.
 *
 *  @parm   UINT | wm |
 *
 *          Window message.
 *
 *  @parm   WPARAM | wp |
 *
 *          Message-specific data.
 *
 *  @parm   LPARAM | lp |
 *
 *          Message-specific data.
 *
 *  @parm   UINT | uid |
 *
 *          Callback identification number, always zero.
 *
 *  @parm   DWORD | dwRef |
 *
 *          Reference data, a pointer to our joystick device callback.
 *
 *****************************************************************************/

LRESULT CALLBACK
    CHid_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                      UINT_PTR uid, ULONG_PTR dwRef)
{
    #ifdef XDEBUG
    static CHAR s_szProc[] = "";
    #endif

    PCHID this = (PCHID)dwRef;
    AssertF(uid == 0);
    /*
     *  Wacky subtlety going on here to avoid race conditions.
     *  See the mondo comment block in CJoy_RemoveSubclass [sic]
     *  for details.
     *
     *  We can get faked out if the memory associated with the
     *  CHid is still physically allocated, the vtbl is magically
     *  still there and the hwnd field somehow matches our hwnd.
     */
    if(SUCCEEDED(hresPv(this)) && this->hwnd == hwnd)
    {
        switch(wm)
        {
        case WM_POWERBROADCAST :
            // 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV( sqfl | sqflError,
                             TEXT("WM_POWERBROADCAST(0x%x) for 0x%p"), wp, this);

            if(wp == PBT_APMSUSPEND )
            {
                CEm_ForceDeviceUnacquire(pemFromPvi(this->pvi)->ped, 0x0 );
            }
            else if(wp == PBT_APMRESUMESUSPEND )
            {
                CEm_ForceDeviceUnacquire(pemFromPvi(this->pvi)->ped, 0x0 );
                
                DIBus_BuildList(TRUE);
            }
            break;

        default:
            if( wm == g_wmJoyChanged )
            {
                /*
                 * Once we receive this notification message, we need to rebuild
                 * our list, because sometimes the user has just changed the device's ID.
                 * See manbug: 35445
                 */
                DIHid_BuildHidList(TRUE);

                Common_Hold(this);

                CHid_LoadCalibrations(this);

                Common_Unhold(this);
            }
            // 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV( sqfl | sqflVerbose,
                             TEXT("wp(0x%x) wm(0x%x) for 0x%p"), wm, wp, this);
            break;
        }
    }
    return DefSubclassProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | GetPhysicalState |
 *
 *          Read the physical device state into <p pmstOut>.
 *
 *          Note that it doesn't matter if this is not atomic.
 *          If a device report arrives while we are reading it,
 *          we will get a mix of old and new data.  No big deal.
 *
 *  @parm   PCHID | this |
 *
 *          The object in question.
 *
 *  @parm   PV | pvOut |
 *
 *          Where to put the device state.
 *
 *  @returns
 *          None.
 *
 *****************************************************************************/

void INLINE
    CHid_GetPhysicalState(PCHID this, PV pvOut)
{
    AssertF(this->pvPhys);
    AssertF(this->cbPhys);

    CopyMemory(pvOut, this->pvPhys, this->cbPhys);


}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Acquire |
 *
 *          Tell the device driver to begin data acquisition.
 *          We create a handle to the device so we can talk to it again.
 *          We must create each time so we can survive in the
 *          "unplug/replug" case.  When a device is unplugged,
 *          its <t HANDLE> becomes permanently invalid and must be
 *          re-opened for it to work again.
 *
 *          Warning!  We require that the device critical section be
 *          held so we don't race against our worker thread.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_Acquire(PDICB pdcb)
{
    HRESULT hres;
    HANDLE h;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::HID::Acquire,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pvi->pdd);
    AssertF(CDIDev_InCrit(this->pvi->pdd));
    AssertF(this->hdev == INVALID_HANDLE_VALUE);


    /*
     *  We must check connectivity by opening the device, because NT
     *  leaves the device in the info list even though it has
     *  been unplugged.
     */
    h = CHid_OpenDevicePath(this, FILE_FLAG_OVERLAPPED);
    if(h != INVALID_HANDLE_VALUE)
    {
        NTSTATUS stat;
        DIJOYTYPEINFO dijti;
        DWORD dwFlags2 = 0;
        WCHAR wszType[cbszVIDPID];
        HKEY hkProp;

        /*
         * Obtain Flags2 to find out if input report is disabled for this device,
         * if we haven't done so.
         */
        if (!this->fFlags2Checked)
        {
            /* Check the type key or get predefined name */
            ZeroX(dijti);
            dijti.dwSize = cbX(dijti);

            if( ( this->VendorID == MSFT_SYSTEM_VID )
                &&( ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN )
                    &&( this->ProductID < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
            {
                wszType[0] = L'#';
                wszType[1] = L'0' + (WCHAR)(this->ProductID-MSFT_SYSTEM_PID);
                wszType[2] = L'\0';
            } 
            else
            {
                #ifndef WINNT
                static WCHAR wszDefHIDName[] = L"HID Game Controller";
                #endif

                #ifndef UNICODE
                TCHAR tszType[cbszVIDPID];

                wsprintf(tszType, VID_PID_TEMPLATE, this->VendorID, this->ProductID);
                TToU( wszType, cA(wszType), tszType );
                #else
                wsprintf(wszType, VID_PID_TEMPLATE, this->VendorID, this->ProductID);
                #endif
            }

            /* Got key name. Now open the key. */
            hres = JoyReg_OpenPropKey( wszType, KEY_QUERY_VALUE, REG_OPTION_NON_VOLATILE, &hkProp );
            if (SUCCEEDED(hres))
            {
                JoyReg_GetValue( hkProp, REGSTR_VAL_FLAGS2, REG_BINARY,
                                 &dwFlags2, cbX(dwFlags2) );
                this->fEnableInputReport = ( (dwFlags2 & JOYTYPE_ENABLEINPUTREPORT) != 0 );
                RegCloseKey(hkProp);
            }
            this->fFlags2Checked = TRUE;
        }

        if ( this->fEnableInputReport )
        {
            BYTE id;
            for (id = 0; id < this->wMaxReportId[HidP_Input]; ++id)
                if (this->pEnableReportId[HidP_Input][id])
                {
                    BOOL bRet;

                    *(BYTE*)this->hriIn.pvReport = id;
                    bRet = HidD_GetInputReport(h, this->hriIn.pvReport, this->hriIn.cbReport);

                    if (bRet)
                    {
                        stat = CHid_ParseData(this, HidP_Input, &this->hriIn);
                        if (SUCCEEDED(stat))
                        {
                            this->pvi->fl |= VIFL_INITIALIZE;  /* Set the flag so the event can be buffered.
                                                                  since VIFL_ACQUIRED isn't set yet. */
                            CEm_AddState(&this->ed, this->pvStage, GetTickCount());
                            this->pvi->fl &= ~VIFL_INITIALIZE;  /* Clear the flag when done. */
                        }
                    } else
                    {
                        DWORD dwError = GetLastError();

                        // ERROR_SEM_TIMEOUT means the device has timed out.
                        if (dwError == ERROR_SEM_TIMEOUT)
                        {
                            /*
                             * Timed out. The device does not support input report. We need to record
                             * the fact in registry so that GetInputReport() does not ever get called
                             * again for this device, since each failed call takes five seconds to
                             * complete.
                             */
                            HKEY hkProp;

                            this->fEnableInputReport = FALSE;
                            dwFlags2 &= ~JOYTYPE_ENABLEINPUTREPORT;
                            hres = JoyReg_OpenPropKey(wszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &hkProp);
                            if (SUCCEEDED(hres))
                            {
                                hres = JoyReg_SetValue( hkProp, REGSTR_VAL_FLAGS2, 
                                                        REG_BINARY, (PV)&dwFlags2, cbX( dwFlags2 ) );
                                RegCloseKey(hkProp);
                            }
                            break;
                        }

                        RPF("CHid_InitParse: Unable to read HID input report LastError(0x%x)", GetLastError() );
                    }
                }
        }

        CloseHandle(h);
        /* Please finish for me */
        hres = S_FALSE;
    } else
    {
        hres = DIERR_UNPLUGGED;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetInstance |
 *
 *          Obtains the DirectInput instance handle.
 *
 *  @parm   OUT PPV | ppvi |
 *
 *          Receives the instance handle.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetInstance(PDICB pdcb, PPV ppvi)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetInstance, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    *ppvi = (PV)this->pvi;
    hres = S_OK;

    ExitOleProcPpvR(ppvi);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetDataFormat |
 *
 *          Obtains the device's preferred data format.
 *
 *  @parm   OUT LPDIDEVICEFORMAT * | ppdf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdf)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetDataFormat,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppdf = &this->df;
    hres = S_OK;

    ExitOleProcPpvR(ppdf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIHid_GetRegistryProperty |
 *
 *  @parm   LPTSTR | ptszId |
 *
 *          Device Instance ID.           
 *
 *  @parm   DWORD | dwProperty |
 *
 *          The property being queried.
 *
 *  @parm   LPDIPROPHEADER | diph |
 *
 *          Property data to be set.
 *
 *****************************************************************************/

HRESULT INTERNAL
    DIHid_GetParentRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPDIPROPHEADER pdiph, BOOL bGrandParent)
{

    HDEVINFO hdev;
    LPDIPROPSTRING pstr = (PV)pdiph;
    TCHAR   tsz[MAX_PATH];
    HRESULT hres;

    ZeroX(tsz);
    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;

        /*
         *  For the instance name, use the friendly name if possible.
         *  Else, use the device description.
         */
        dinf.cbSize = cbX(SP_DEVINFO_DATA);
        if(SetupDiOpenDeviceInfo(hdev, ptszId, NULL, 0, &dinf))
        {
            DEVINST DevInst;
            CONFIGRET cr;
            if( ( cr = CM_Get_Parent(&DevInst, dinf.DevInst, 0x0)) == CR_SUCCESS )
            {
                ULONG   ulLength;

                CAssertF( SPDRP_DEVICEDESC   +1  == CM_DRP_DEVICEDESC  );
                CAssertF( SPDRP_FRIENDLYNAME +1  ==  CM_DRP_FRIENDLYNAME );

                if(bGrandParent)
                {
                    cr = CM_Get_Parent(&DevInst, DevInst, 0x0);
                    if( cr != CR_SUCCESS )
                    {
                        // No GrandParent ?? 
                    }
                }

                ulLength = MAX_PATH * cbX(TCHAR);

                if( cr == CR_SUCCESS && 
                    ( cr = CM_Get_DevNode_Registry_Property(
                                                           DevInst,
                                                           dwProperty+1,
                                                           NULL,
                                                           tsz,
                                                           &ulLength,
                                                           0x0 ) ) == CR_SUCCESS )
                {
                    // Success
                    hres = S_OK;
    #ifdef UNICODE
                    lstrcpyW(pstr->wsz, tsz);
    #else
                    TToU(pstr->wsz, MAX_PATH, tsz);
    #endif
                } else
                {
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("CM_Get_DevNode_Registry_Property FAILED") );

                    hres = E_FAIL;
                }
            } else
            {

                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("CM_Get_Parent FAILED") );
                hres = E_FAIL;
            }
        }

        SetupDiDestroyDeviceInfoList(hdev);
    } else
    {
        hres = E_FAIL;
    }

    return hres;
}

HRESULT EXTERNAL
    DIHid_GetRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPDIPROPHEADER pdiph)
{

    HDEVINFO hdev;
    LPDIPROPSTRING pstr = (PV)pdiph;
    TCHAR   tsz[MAX_PATH];
    HRESULT hres;

    ZeroX(tsz);
    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;

        /*
         *  For the instance name, use the friendly name if possible.
         *  Else, use the device description.
         */
        dinf.cbSize = cbX(SP_DEVINFO_DATA);
        if(SetupDiOpenDeviceInfo(hdev, ptszId, NULL, 0, &dinf))
        {
            if(SetupDiGetDeviceRegistryProperty(hdev, &dinf, dwProperty, NULL, 
                                                (LPBYTE)tsz, MAX_PATH, NULL) )
            {
                hres = S_OK;
    #ifdef UNICODE
                lstrcpyW(pstr->wsz, tsz);
    #else
                TToU(pstr->wsz, MAX_PATH, tsz);
    #endif
            } else
            {
                hres = E_FAIL;
            }
        } else
        {
            hres = E_FAIL;
        }

        SetupDiDestroyDeviceInfoList(hdev);
    } else
    {
        hres = E_FAIL;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | GetGuidAndPath |
 *
 *          Get a Hid device's class GUID (namely, the HID guid)
 *          and device interface (path).
 *
 *  @parm   PCHID | this |
 *
 *          The Hid object.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_GetGuidAndPath(PCHID this, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    LPDIPROPGUIDANDPATH pgp = (PV)pdiph;

    pgp->guidClass = GUID_HIDClass;
    TToU(pgp->wszPath, cA(pgp->wszPath), this->ptszPath);

    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL |  fHasSpecificHardwareMatch |
 *
 *          Find out from SetupAPI whether the device was matched with a 
 *          specific hardware ID match or generic match.
 *          A specific match should have caused a device description to be 
 *          installed which is likely to be at least as good as what HID could 
 *          get from a product string in firmware.  (a. because it's easier to 
 *          update an INF after release than firmware; b. because HID can only 
 *          get us an English string.)  Generic matches on the other hand are,
 *          by definition, all the same so cannot be used to tell two devices 
 *          apart.
 *
 *  @parm   LPTSTR ptszId
 *          
 *          Device Instance ID.
 *  
 *  @returns 
 *          <c TRUE> if the device was installed using a specific match.
 *          <c FALSE> if it was not or if installation info was unobtainable.
 *
 *  @comm
 *          This is used on Win2k for game controllers and Win9x for mice and 
 *          keyboards.  Win2k we can't read HID mice and keyboards and on 
 *          Win9x VJoyD should always create device names before DInput.dll.  
 *          On Win9x this is less of a big deal for game controllers because 
 *          IHVs are accoustomed to adding their display name to 
 *          MediaProperties.
 *
 *****************************************************************************/
BOOL fHasSpecificHardwareMatch( LPTSTR ptszId )
{
    HDEVINFO    hInfo;
    BOOL        fRc = FALSE;

    EnterProcI(fHasSpecificHardwareMatch,(_ "s", ptszId));

    hInfo = SetupDiCreateDeviceInfoList(NULL, NULL);
    if( hInfo != INVALID_HANDLE_VALUE )
    {
        SP_DEVINFO_DATA dinf;

        dinf.cbSize = cbX(SP_DEVINFO_DATA);
        if( SetupDiOpenDeviceInfo(hInfo, ptszId, NULL, 0, &dinf) )
        {
            CONFIGRET   cr;
            DEVINST     DevInst;

            cr = CM_Get_Parent( &DevInst, dinf.DevInst, 0x0 );
            if( cr == CR_SUCCESS )
            {
                TCHAR       tszDevInst[MAX_PATH];
                cr = CM_Get_Device_ID( DevInst, (DEVINSTID)tszDevInst, MAX_PATH, 0 );
                if( cr == CR_SUCCESS )
                {
                    if( SetupDiOpenDeviceInfo(hInfo, tszDevInst, NULL, 0, &dinf) )
                    {
                        HKEY hkDrv;

                        hkDrv = SetupDiOpenDevRegKey( hInfo, &dinf, DICS_FLAG_GLOBAL, 0, 
                            DIREG_DRV, MAXIMUM_ALLOWED );

                        if( hkDrv != INVALID_HANDLE_VALUE )
                        {
                            PTCHAR      tszHardwareID = NULL;
                            PTCHAR      tszMatchingID = NULL;
                            ULONG       ulLength = 0;
                    
                            cr = CM_Get_DevNode_Registry_Property(DevInst,
                                                                  CM_DRP_HARDWAREID,
                                                                  NULL,
                                                                  NULL,
                                                                  &ulLength,
                                                                  0x0 );
                            /*
                             *  Win2k returns CR_BUFFER_SMALL but 
                             *  Win9x returns CR_SUCCESS so allow both.
                             */
                            if( ( ( cr == CR_BUFFER_SMALL ) || ( cr == CR_SUCCESS ) )
                             && ulLength )
                            {
                              #ifndef WINNT
                                /*
                                 *  Need to allocate extra for terminator on Win9x
                                 */
                                ulLength++;
                              #endif
                                if( SUCCEEDED( AllocCbPpv( ulLength + ( MAX_PATH * cbX(tszMatchingID[0]) ), &tszMatchingID ) ) )
                                {
                                    cr = CM_Get_DevNode_Registry_Property(DevInst,
                                                                          CM_DRP_HARDWAREID,
                                                                          NULL,
                                                                          (PBYTE)&tszMatchingID[MAX_PATH],
                                                                          &ulLength,
                                                                          0x0 );
                                    if( cr == CR_SUCCESS )
                                    {
                                        tszHardwareID = &tszMatchingID[MAX_PATH];
                                    }
                                    else
                                    {
                                        SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("CR error %d getting HW ID"), cr );
                                    }
                                }
                                else
                                {
                                    SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("No memory requesting %d bytes for HW ID"), ulLength );
                                }
                            }
                            else
                            {
                                SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("Unexpected CR error %d getting HW ID size"), cr );
                            }

                            if( tszHardwareID )
                            {
                                ulLength = MAX_PATH * cbX(tszMatchingID[0]);
                                cr = RegQueryValueEx( hkDrv, REGSTR_VAL_MATCHINGDEVID, 0, 0, (PBYTE)tszMatchingID, &ulLength );
                                if( CR_SUCCESS == cr )
                                {
                                    while( ulLength = lstrlen( tszHardwareID ) )
                                    {
                                        if( !lstrcmpi( tszHardwareID, tszMatchingID ) )
                                        {
                                            fRc = TRUE;
                                            break;
                                        }
                                        tszHardwareID += ulLength + 1;
                                    }
                                }
                                else
                                {
                                    SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("No matching ID!, cr = %d"), cr );
                                }
                            }

                            if( tszMatchingID )
                            {
                                FreePv( tszMatchingID );
                            }

                            RegCloseKey( hkDrv );
                        }
                        else
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("SetupDiOpenDevRegKey failed, le = %d"), GetLastError() );
                        }
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("SetupDiOpenDeviceInfo failed for %S (parent), le = %d"), 
                            tszDevInst, GetLastError() );
                    }
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("CM_Get_Device_ID FAILED %d"), cr );
                }
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("CM_Get_Parent FAILED %d"), cr );
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                TEXT("SetupDiOpenDeviceInfo failed for %S (child), le = %d"), 
                ptszId, GetLastError() );
        }

        SetupDiDestroyDeviceInfoList(hInfo);
    } 
    else
    {
        SquirtSqflPtszV(sqfl | sqflError,
            TEXT("SetupDiCreateDeviceInfoList failed, le = %d"), GetLastError() );
    }

    ExitProc();

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL |  fGetProductStringFromDevice |
 *
 *          Try getting the product name from HID.
 *          If the device has one of these, this is what is displayed 
 *          when the device is initially recognized.  Unfortunately 
 *          this name does not land up in the friendly name registry 
 *          entry so in case this gets fixed we go directly to HID.
 *
 *  @parm   PCHID | this |
 *
 *          The Hid object.
 *
 *  @parm   PWCHAR | wszBuffer |
 *          
 *          Where to put the product string if found.
 *  
 *  @parm   ULONG | ulBufferLen |
 *          
 *          How big the string buffer is in bytes
 *  
 *  @returns 
 *          <c TRUE> if a string has been placed in the buffer
 *          <c FALSE> if no string was retrieved
 *
 *****************************************************************************/
BOOL fGetProductStringFromDevice
( 
    PCHID   this,
    PWCHAR  wszBuffer,
    ULONG   ulBufferLen
)
{
    BOOL fRc;

    /*
     *  If we already have a handle open (device is acquired), use 
     *  it, otherwise open one just for now.
     */
    if( this->hdev != INVALID_HANDLE_VALUE )
    {
        fRc = HidD_GetProductString( this->hdev, wszBuffer, ulBufferLen );
    }
    else
    {
        HANDLE hdev;

        hdev = CHid_OpenDevicePath(this, FILE_FLAG_OVERLAPPED);
        if(hdev != INVALID_HANDLE_VALUE)
        {
            wszBuffer[0] = 0;
            fRc = HidD_GetProductString( hdev, wszBuffer, ulBufferLen );
            fRc = (fRc)?(wszBuffer[0] != 0):FALSE;
            CloseHandle(hdev);
        } 
        else
        {
            fRc = FALSE;
        }
    }

    return fRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetProperty |
 *
 *          Get a Hid device property.
 *
 *  @parm   PCHID | this |
 *
 *          The Hid object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/
#ifdef WINNT
TCHAR   g_wszDefaultHIDName[80];
UINT    g_uLenDefaultHIDSize;
#endif

STDMETHODIMP
    CHid_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    if(ppropi->iobj < this->df.dwNumObjs)
    {    /* Object property */
        AssertF(ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType);
        switch((DWORD)(UINT_PTR)(ppropi->pguid))
        {
        case (DWORD)(UINT_PTR)(DIPROP_ENABLEREPORTID):
            {        
                LPDIPROPDWORD ppropdw = CONTAINING_RECORD(pdiph, DIPROPDWORD, diph);

                PHIDGROUPCAPS pcaps = this->rghoc[ppropi->iobj].pcaps;

                AssertF(fLimpFF(pcaps,
                                pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE));

                ppropdw->dwData = 0x0;
                AssertF(pcaps->wReportId < this->wMaxReportId[pcaps->type]);
                AssertF(this->pEnableReportId[pcaps->type]);
                (UCHAR)ppropdw->dwData = *(this->pEnableReportId[pcaps->type] + pcaps->wReportId);
                hres = S_OK;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_PHYSICALRANGE):
            {        
                LPDIPROPRANGE pdiprg  = CONTAINING_RECORD(pdiph, DIPROPRANGE, diph);
                PHIDGROUPCAPS pcaps = this->rghoc[ppropi->iobj].pcaps;

                pdiprg->lMin = pcaps->Physical.Min;
                pdiprg->lMax = pcaps->Physical.Max;
                hres = S_OK;
                break;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_LOGICALRANGE):
            {        
                LPDIPROPRANGE pdiprg  = CONTAINING_RECORD(pdiph, DIPROPRANGE, diph);
                PHIDGROUPCAPS pcaps = this->rghoc[ppropi->iobj].pcaps;

                pdiprg->lMin = pcaps->Logical.Min;
                pdiprg->lMax = pcaps->Logical.Max;
                hres = S_OK;
                break;
            }
            break;

        default:
            if(ppropi->dwDevType & DIDFT_POV)
            {
                PHIDGROUPCAPS pcaps = this->rghoc[ppropi->iobj].pcaps;

                AssertF(fLimpFF(pcaps,
                                pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE));

              #ifdef WINNT
                if( pcaps && pcaps->IsPolledPOV && ppropi->pguid == DIPROP_CALIBRATIONMODE ) {
                    PJOYRANGECONVERT pjrc = this->rghoc[ppropi->iobj].pjrc;

                    if(pjrc)
                    {
                        hres = CCal_GetProperty(pjrc, ppropi->pguid, pdiph, this->dwVersion);
                    } else
                    {
                        hres = E_NOTIMPL;
                    }
                } else
              #endif
                if(pcaps && ppropi->pguid == DIPROP_GRANULARITY)
                {
                    LPDIPROPDWORD pdipdw = (PV)pdiph;
                    pdipdw->dwData = pcaps->usGranularity;
                    hres = S_OK;
                } else
                {
                    hres = E_NOTIMPL;
                }

            } else if(ppropi->dwDevType & DIDFT_RELAXIS)
            {

                /*
                 *  All relative axes have a full range by default,
                 *  so we don't need to do anything.
                 */
                hres = E_NOTIMPL;

            } else if(ppropi->dwDevType & DIDFT_ABSAXIS)
            {
                PJOYRANGECONVERT pjrc = this->rghoc[ppropi->iobj].pjrc;

                /*
                 *  Theoretically, every absolute axis will have
                 *  calibration info.  But test just in case something
                 *  impossible happens.
                 */
                if(pjrc)
                {
                    hres = CCal_GetProperty(pjrc, ppropi->pguid, pdiph, this->dwVersion);
                } else
                {
                    hres = E_NOTIMPL;
                }

            } else
            {
                SquirtSqflPtszV(sqflHidDev | sqflError,
                                TEXT("CHid_GetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                                ppropi->iobj, ppropi->pguid);

                hres = E_NOTIMPL;
            }
        }
    } else if(ppropi->iobj == 0xFFFFFFFF)
    {        /* Device property */

        switch((DWORD)(UINT_PTR)ppropi->pguid)
        {

        case (DWORD)(UINT_PTR)DIPROP_GUIDANDPATH:
            hres = CHid_GetGuidAndPath(this, pdiph);
            break;

        case (DWORD)(UINT_PTR)DIPROP_INSTANCENAME:
        {
            /*
             *  DX8 CHANGE !
             *
             *  Friendly names cause all manner of problems with devices that 
             *  use auto detection so only allow non-predefined analog devices 
             *  to use them.
             */
            if( ( this->VendorID == MSFT_SYSTEM_VID )
             && ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX )
             && ( ( this->ProductID & 0xff00 ) == MSFT_SYSTEM_PID ) )
            {
                AssertF(this->hkType);
                
                if( this->hkType )
                {
                    LPDIPROPSTRING pstr = (PV)pdiph;

                    hres = JoyReg_GetValue(this->hkType,
                                           REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                           pstr->wsz,
                                           cbX(pstr->wsz));
                                              
                    if( SUCCEEDED(hres ) )
                    {
                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT( "Got instance name %s"), pstr->wsz );

#if (DIRECTINPUT_VERSION > 0x061A)
                    if( ( this->diHacks.nMaxDeviceNameLength < MAX_PATH )
                     && ( this->diHacks.nMaxDeviceNameLength < lstrlenW(pstr->wsz) ) )
                    {
                        pstr->wsz[this->diHacks.nMaxDeviceNameLength] = L'\0';
                    }
#endif
                        hres = S_OK;
                        break;
                    }
                }
            }
            /*
             *  Fall through to catch the product name
             */
        }

        /*
         *  DX8 CHANGE !
         *
         *  In Win2k, this is the way devices get named.  The original DX7 
         *  used SetupAPI to get a friendly name (which only ever seems to be 
         *  written by DInput) and if that failed, device description.  
         *  Unfortunately Setup gives all devices matched with a generic match 
         *  the same "USB Human Input Device" name, which is useless to game 
         *  players.  Devices listed specifically in input.inf have much 
         *  better names but all new devices are hosed.
         *  See bug 32586 for more links.
         */
        case (DWORD)(UINT_PTR)DIPROP_PRODUCTNAME:
        {

            LPDIPROPSTRING pdipstr = (PV)pdiph;

            /*
             *  For now, don't deal with mice and keyboard names on NT
             */
#ifdef WINNT
            AssertF( ( GET_DIDEVICE_TYPE( this->dwDevType ) != DIDEVTYPE_KEYBOARD )
                  && ( GET_DIDEVICE_TYPE( this->dwDevType ) != DIDEVTYPE_MOUSE ) );
#endif
            if( GET_DIDEVICE_TYPE( this->dwDevType ) < DIDEVTYPE_JOYSTICK ) 
            {
                if( fHasSpecificHardwareMatch( this->ptszId )
                      && SUCCEEDED( hres = DIHid_GetParentRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph, 0x0 ) ) )
                {
                    SquirtSqflPtszV(sqflHid | sqflVerbose,
                        TEXT("Got sys dev description %S"), pdipstr->wsz );
                }
                else if( fGetProductStringFromDevice( this, pdipstr->wsz, cbX( pdipstr->wsz ) ) )
                {
                    SquirtSqflPtszV(sqflHid | sqflVerbose,
                        TEXT( "Got sys dev name from device %S"), pdipstr->wsz );
                    hres = S_OK;
                }
                else
                {
                    if( SUCCEEDED( hres = DIHid_GetRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph ) ) )
                    {
                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT( "Got sys dev name from devnode registry %S"), pdipstr->wsz );
                    }
                    else
                    {
                        UINT uDefName;

                        switch( GET_DIDEVICE_TYPE( this->dwDevType ) )
                        {
                        case DIDEVTYPE_MOUSE:
                            uDefName = IDS_STDMOUSE;
                            break;
                        case DIDEVTYPE_KEYBOARD:
                            uDefName = IDS_STDKEYBOARD;
                            break;
                        default:
                            uDefName = IDS_DEVICE_NAME;
                            break;
                        }
                        if( LoadStringW(g_hinst, uDefName, pdipstr->wsz, cbX( pdipstr->wsz ) ) )
                        {
                            SquirtSqflPtszV(sqflHid | sqflVerbose,
                                TEXT( "Loaded default sys dev name %S"), pdipstr->wsz );
                            hres = S_OK;
                        }
                        else
                        {
                            /*
                             *  Give up, this machine is toast if we can't 
                             *  even load a string from our own resources.
                             */
                            SquirtSqflPtszV(sqflHidDev | sqflError,
                                            TEXT("CHid_GetProperty(guid:%08x) failed to get name"),
                                            ppropi->pguid);
                            hres = E_FAIL;
                        }
                    }
                }
            }
            else
            {

                /*
                 *  For game controllers, first look in MediaProperties.
                 *  This is the most likely place to find a localized string 
                 *  free from corruption by the setup process.
                 *  This should only fail before the type key is created when 
                 *  it first used so other paths are rare.
                 */

                DIJOYTYPEINFO dijti;
                WCHAR wszType[cbszVIDPID];            

                /* Check the type key or get predefined name */
                ZeroX(dijti);
                dijti.dwSize = cbX(dijti);

                if( ( this->VendorID == MSFT_SYSTEM_VID )
                    &&( ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN )
                        &&( this->ProductID < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
                {
                    wszType[0] = L'#';
                    wszType[1] = L'0' + (WCHAR)(this->ProductID-MSFT_SYSTEM_PID);
                    wszType[2] = L'\0';

                    hres = JoyReg_GetPredefTypeInfo( wszType, &dijti, DITC_DISPLAYNAME);
                    AssertF( SUCCEEDED( hres ) );
                    AssertF( dijti.wszDisplayName[0] != L'\0' );
                    lstrcpyW(pdipstr->wsz, dijti.wszDisplayName);
                    SquirtSqflPtszV(sqflHid | sqflVerbose,
                        TEXT( "Got name as predefined %s"), pdipstr->wsz );
                } 
                else 
                {
                  #ifndef WINNT
                    static WCHAR wszDefHIDName[] = L"HID Game Controller";
                  #endif
                    BOOL   fOverwriteDeviceName = FALSE;
  
                  #ifndef UNICODE
                    TCHAR tszType[cbszVIDPID];

                    wsprintf(tszType, VID_PID_TEMPLATE, this->VendorID, this->ProductID);
                    TToU( wszType, cA(wszType), tszType );
                  #else
                    wsprintf(wszType, VID_PID_TEMPLATE, this->VendorID, this->ProductID);
                  #endif

                  #ifdef WINNT
                    #define INPUT_INF_FILENAME L"\\INF\\INPUT.INF"
                    if( g_wszDefaultHIDName[0] == L'\0' )
                    {
                        WCHAR   wszInputINF[MAX_PATH];
                        UINT    uLen;
                        uLen = GetWindowsDirectoryW( wszInputINF, cA( wszInputINF ) );

                        /*
                         *  If the path is too long, don't set the filename 
                         *  so the the default string gets used when the 
                         *  GetPrivateProfileString fails.
                         */
                        if( uLen < cA( wszInputINF ) - cA( INPUT_INF_FILENAME ) )
                        {
                            memcpy( (PBYTE)&wszInputINF[uLen], (PBYTE)INPUT_INF_FILENAME, cbX( INPUT_INF_FILENAME ) );
                        }

                        /*
                         *  Remember the length, if the string was too long to 
                         *  fit in the buffer there will be plenty to make a 
                         *  reasonable comparison.
                         */
                        g_uLenDefaultHIDSize = 2 * GetPrivateProfileStringW( 
                            L"strings", L"HID.DeviceDesc", L"USB Human Interface Device",
                            g_wszDefaultHIDName, cA( g_wszDefaultHIDName ) - 1, wszInputINF );
                    }
                    #undef INPUT_INF_FILENAME
                  #endif //#ifdef WINNT
                  
                    if( SUCCEEDED(hres = JoyReg_GetTypeInfo(wszType, &dijti, DITC_DISPLAYNAME))
                        && (dijti.wszDisplayName[0] != L'\0')
                      #ifdef WINNT
                        && ( (g_uLenDefaultHIDSize == 0)
                            || memcmp(dijti.wszDisplayName, g_wszDefaultHIDName, g_uLenDefaultHIDSize) )// not equal
                      #else
                        && memcmp(dijti.wszDisplayName, wszDefHIDName, cbX(wszDefHIDName)-2)  //not equal
                      #endif
                    )
                    {
                        LPDIPROPSTRING pdipstr = (PV)pdiph;
                        lstrcpyW(pdipstr->wsz, dijti.wszDisplayName);

                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT("Got name from type info %s"), pdipstr->wsz );
                    }
                  #ifdef WINNT
                    else if( fHasSpecificHardwareMatch( this->ptszId )
                          && SUCCEEDED( hres = DIHid_GetParentRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph, 0x0 ) ) )
                    {
                      	fOverwriteDeviceName = TRUE;
                      	
                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT("Got specific description %s"), pdipstr->wsz );
                    }
                  #endif
                    else
                    {
                        if( fGetProductStringFromDevice( this, pdipstr->wsz, cbX( pdipstr->wsz ) ) )
                        {
                        	fOverwriteDeviceName = TRUE;
                        	
                            SquirtSqflPtszV(sqflHid | sqflVerbose,
                                TEXT("Got description %s from device"), pdipstr->wsz );
                        }
                        else
                        {
                            /*
                             *  Just make up a name from the caps
                             */
                            CType_MakeGameCtrlName( pdipstr->wsz, 
                                this->dwDevType, this->dwAxes, this->dwButtons, this->dwPOVs );

							fOverwriteDeviceName = TRUE;

                            SquirtSqflPtszV(sqflHid | sqflVerbose,
                                TEXT("Made up name %s"), pdipstr->wsz );

                        }
                        hres = S_OK;
                    }

                    if( fOverwriteDeviceName ) {
                        /*
                         * If we have a better name, overwrite the old one with this better one.
                         * See manbug 46438.
                         */
                        AssertF(this->hkType);
                        AssertF(pdipstr->wsz[0]);
                        hres = JoyReg_SetValue(this->hkType,
                                               REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                               pdipstr->wsz,
                                               cbX(pdipstr->wsz));
                        if( FAILED(hres) ){
                            SquirtSqflPtszV(sqflHid | sqflVerbose,
                                TEXT("Unable to overwrite generic device name with %s"), pdipstr->wsz );
    
                            // This failure (unlikely) doesn't matter.
                            hres = S_OK;
                        }
                    }
                    
                }
            }
            
          #if (DIRECTINPUT_VERSION > 0x061A)
            if( SUCCEEDED(hres) 
             && ( this->diHacks.nMaxDeviceNameLength < MAX_PATH )
             && ( this->diHacks.nMaxDeviceNameLength < lstrlenW(pdipstr->wsz) ) )
            {
                pdipstr->wsz[this->diHacks.nMaxDeviceNameLength] = L'\0';
            }
          #endif
          
            break;
        }

        case (DWORD)(UINT_PTR)DIPROP_JOYSTICKID:
            if( fHasAllBitsFlFl( this->dwDevType, DIDEVTYPE_JOYSTICK | DIDEVTYPE_HID ) )
            {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                pdipdw->dwData =  this->idJoy;
                hres = S_OK;

            } else
            {
                hres = E_NOTIMPL;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_GETPORTDISPLAYNAME:

            if( fWinnt )
            {
                /* For HID devices Port Display Name is the grand parent name */
                hres = DIHid_GetParentRegistryProperty(this->ptszId, SPDRP_FRIENDLYNAME, pdiph, TRUE);
                if( FAILED(hres) )
                {
                    /* Maybe we can use the Product Name */
                    hres = DIHid_GetParentRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph, TRUE);
                    if( SUCCEEDED(hres) )
                    {
                        /* We only sort of succeeded */
                        hres = S_FALSE;
                    }
                }
#if (DIRECTINPUT_VERSION > 0x061A)
                if( SUCCEEDED(hres) )
                {
                    LPDIPROPSTRING pdipstr = (PV)pdiph;
                    if( this->diHacks.nMaxDeviceNameLength < lstrlenW(pdipstr->wsz) ) {
                        pdipstr->wsz[this->diHacks.nMaxDeviceNameLength] = L'\0';
                    }
                }
#endif
            } else
            {
                // Not sure how this works on Win9x
                hres = E_NOTIMPL;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_ENABLEREPORTID):
            hres = E_NOTIMPL;
            break;

        default:
            SquirtSqflPtszV(sqflHid | sqflBenign ,
                            TEXT("CHid_GetProperty(iobj=0xFFFFFFFF): E_NOTIMPL on guid: %08x"),
                            ppropi->pguid);

            hres = E_NOTIMPL;
            break;
        }

    } else
    {
        SquirtSqflPtszV(sqflHidDev | sqflError,
                        TEXT("CHid_GetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                        ppropi->iobj, ppropi->pguid);

        hres = E_NOTIMPL;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | CHid_CoordinateTransform |
 *
 *          Convert numbers from logical to physical or vice versa.
 *
 *          If either the To or From values look suspicious, then
 *          ignore them and leave the values alone.
 *
 *  @parm   PLMINMAX | Dst |
 *
 *          Destination min/max information.
 *
 *  @parm   PLMINMAX | Src |
 *
 *          Source min/max information.
 *
 *  @parm   LONG | lVal |
 *
 *          Source value to be converted.
 *
 *  @returns
 *
 *          The destination value after conversion.
 *
 *****************************************************************************/

LONG EXTERNAL
    CHid_CoordinateTransform(PLMINMAX Dst, PLMINMAX Src, LONG lVal)
{
    /*
     *  Note that the sanity check is symmetric in Src and Dst.
     *  This is important, so that we never get into a weird
     *  case where we can convert one way but can't convert back.
     */
    if(Dst->Min < Dst->Max && Src->Min < Src->Max)
    {

        /*
         *  We need to perform a straight linear interpolation.
         *  The math comes out like this:
         *
         *  x  - x0   y  - y0
         *  ------- = -------
         *  x1 - x0   y1 - y0
         *
         *  If you now do a "solve for y", you get
         *
         *
         *               y1 - y0
         *  y = (x - x0) ------- + y0
         *               x1 - x0
         *
         *  where "x" is Src, "y" is Dst, 0 is Min, and 1 is Max.
         *
         *
         */

        lVal = MulDiv(lVal - Src->Min, Dst->Max - Dst->Min,
                      Src->Max - Src->Min) + Dst->Min;
    }

    return lVal;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CHid | IsMatchingJoyDevice |
 *
 *          Does the cached joystick ID match us?
 *
 *  @parm   OUT PVXDINITPARMS | pvip |
 *
 *          On success, contains parameter values.
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

BOOL INTERNAL
    CHid_IsMatchingJoyDevice(PCHID this, PVXDINITPARMS pvip)
{
    CHAR sz[MAX_PATH];
    LPSTR pszPath;
    BOOL fRc;

    pszPath = JoyReg_JoyIdToDeviceInterface_95(this->idJoy, pvip, sz);
    if(pszPath)
    {
        SquirtSqflPtszV(sqfl | sqflTrace,
                        TEXT("CHid_IsMatchingJoyDevice: %d -> %s"),
                        this->idJoy, pszPath);
    #ifdef UNICODE
        {
            CHAR szpath[MAX_PATH];
            UToA( szpath, cA(szpath), (LPWSTR)this->ptszPath);
            fRc = ( lstrcmpiA(pszPath, szpath) == 0x0 );
        }
    #else
        fRc = ( lstrcmpiA(pszPath, (PCHAR)this->ptszPath) == 0x0 );
    #endif
    } else
    {
        fRc = FALSE;
    }

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | FindJoyDevice |
 *
 *          Look for the VJOYD device that matches us, if any.
 *
 *          On return, the <e CHID.idJoy> field contains the
 *          matching joystick number, or -1 if not found.
 *
 *  @parm   OUT PVXDINITPARMS | pvip |
 *
 *          On success, contains parameter values.
 *
 *****************************************************************************/

void INTERNAL
    CHid_FindJoyDevice(PCHID this, PVXDINITPARMS pvip)
{

    /*
     *  If we have a cached value, and it still works, then
     *  our job is done.
     */
    if(this->idJoy >= 0 &&
       CHid_IsMatchingJoyDevice(this, pvip))
    {
    } else
    {
        /*
         *  Need to keep looking.  (Or start looking.)
         *
         *  A countdown loop is nicer, but for efficiency, we count
         *  upwards, since the joystick we want tends to be near the
         *  beginning.
         */
        for(this->idJoy = 0; this->idJoy < cJoyMax; this->idJoy++)
        {
            if(CHid_IsMatchingJoyDevice(this, pvip))
            {
                goto done;
            }
        }
        this->idJoy = -1;
    }

    done:;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CHid | MapAxis |
 *
 *          Find VJOYD axis from HID axis, if one.
 *
 *  @parm   PVXDINITPARMS | pvip |
 *
 *          Parameter values that let us known which axes VJOYD
 *          has mapped to which HID Axes.
 *
 *  @parm   UINT | iobj |
 *
 *          Object index of the object whose axis value changed.
 *
 *  @returns
 *
 *          The VJOYD axis number that changed (0 to 5), or -1
 *          if there is no matching axis.  There will be no matching
 *          axis if, for example, the device has something that is
 *          not expressible via VJOYD (e.g., a temperature sensor).
 *
 *****************************************************************************/

int INTERNAL
    CHid_MapAxis(PCHID this, PVXDINITPARMS pvip, UINT iobj)
{
    int iAxis;
    DWORD dwUsage;

    AssertF(this->dcb.lpVtbl->GetUsage == CHid_GetUsage);

    dwUsage = CHid_GetUsage(&this->dcb, (int)iobj);

    if(dwUsage)
    {

        /*
         *  A countdown loop lets us fall out with the correct failure
         *  code (namely, -1).
         */
        iAxis = cJoyPosAxisMax;
        while(--iAxis >= 0)
        {
            if(pvip->Usages[iAxis] == dwUsage)
            {
                break;
            }
        }
    } else
    {
        /*
         *  Eek!  No usage information for the axis.  Then it certainly
         *  isn't a VJOYD axis.
         */
        iAxis = -1;
    }

    return iAxis;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | UpdateVjoydCalibration |
 *
 *          Somebody changed the calibration on a single axis.  If we
 *          are shadowing a joystick, then look for the VJOYD alias of
 *          our device and update its registry settings, too.
 *
 *
 *  @parm   UINT | iobj |
 *
 *          Object index of the object whose calibration changed.
 *
 *****************************************************************************/

void EXTERNAL
    CHid_UpdateVjoydCalibration(PCHID this, UINT iobj)
{
    HRESULT hres;
    int iAxis;
    VXDINITPARMS vip;
    DIJOYCONFIG cfg;
    PHIDGROUPCAPS pcaps;
    PJOYRANGECONVERT pjrc;

    AssertF(iobj < this->df.dwNumObjs);

    /*
     *  Proceed if...
     *
     *  -   We can find the VJOYD device we correspond to.
     *  -   We can find the axis that got updated.
     *  -   The indicated axis has capability information.
     *  -   The indicated axis has calibration information.
     *  -   We can read the old calibration information.
     */

    CHid_FindJoyDevice(this, &vip);
    if(this->idJoy >= 0 &&
       (iAxis = CHid_MapAxis(this, &vip, iobj)) >= 0 &&
       (pcaps = this->rghoc[iobj].pcaps) != NULL &&
       (pjrc = this->rghoc[iobj].pjrc) != NULL &&
       SUCCEEDED(hres = JoyReg_GetConfig(this->idJoy, NULL, &cfg,
                                         DIJC_REGHWCONFIGTYPE)))
    {

        PLMINMAX Dst = &pcaps->Physical;
        PLMINMAX Src = &pcaps->Logical;

        AssertF(iAxis < cJoyPosAxisMax);

    #define JoyPosValue(phwc, f, i)                                 \
            *(LPDWORD)pvAddPvCb(&(phwc)->hwv.jrvHardware.f,             \
                            ibJoyPosAxisFromPosAxis(i))

        /*
         *  We use logical coordinates, but VJOYD wants physical
         *  coordinates, so do the conversion while we copy the
         *  values.
         */
    #define ConvertValue(f1, f2)                                    \
            JoyPosValue(&cfg.hwc, f1, iAxis) =                          \
                    CHid_CoordinateTransform(Dst, Src, pjrc->f2)        \

        ConvertValue(jpMin   , dwPmin);
        ConvertValue(jpMax   , dwPmax);
        ConvertValue(jpCenter, dwPc  );

    #undef ConvertValue
    #undef JoyPosValue

        /*
         *  Notice that we do *not* pass the DIJC_UPDATEALIAS flag
         *  because WE ARE THE ALIAS!  If we had passed the flag,
         *  then JoyReg would create us and attempt to update our
         *  calibration which we don't want it to do because the
         *  whole thing was our idea in the first place.
         */
        hres = JoyReg_SetConfig(this->idJoy, &cfg.hwc, &cfg,
                                DIJC_REGHWCONFIGTYPE);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | UpdateCalibrationFromVjoyd |
 *
 *          This function is only for Win9x. Joy.cpl uses winmm (through vjoyd)
 *          to calibrate the device, and save calibration information directly into
 *          registry without notifying HID. ANother issue is: vjoyd only use unsigned
 *          data (physical data), while HID also use signed data. When we read
 *          calibration information from VJOYD, we need do conversion.
 *
 *  @parm   UINT | iobj |
 *
 *          Object index of the object whose calibration changed.
 *
 *****************************************************************************/

void EXTERNAL
    CHid_UpdateCalibrationFromVjoyd(PCHID this, UINT iobj, LPDIOBJECTCALIBRATION pCal)
{
    HRESULT hres;
    int iAxis;
    VXDINITPARMS vip;
    DIJOYCONFIG cfg;
    PHIDGROUPCAPS pcaps;
    PJOYRANGECONVERT pjrc;

    AssertF(iobj < this->df.dwNumObjs);

    /*
     *  Proceed if...
     *
     *  -   We can find the VJOYD device we correspond to.
     *  -   We can find the axis that got updated.
     *  -   The indicated axis has capability information.
     *  -   The indicated axis has calibration information.
     *  -   We can read the calibration information.
     */

    CHid_FindJoyDevice(this, &vip);
    if(this->idJoy >= 0 &&
       (iAxis = CHid_MapAxis(this, &vip, iobj)) >= 0 &&
       (pcaps = this->rghoc[iobj].pcaps) != NULL &&
       (pjrc = this->rghoc[iobj].pjrc) != NULL &&
       SUCCEEDED(hres = JoyReg_GetConfig(this->idJoy, NULL, &cfg,
                                         DIJC_REGHWCONFIGTYPE)))
    {

        PLMINMAX Src = &pcaps->Physical;
        PLMINMAX Dst = &pcaps->Logical;

        AssertF(iAxis < cJoyPosAxisMax);

        #define JoyPosValue(phwc, f, i)                                 \
            *(LPDWORD)pvAddPvCb(&(phwc)->hwv.jrvHardware.f,             \
                            ibJoyPosAxisFromPosAxis(i))

        /*
         *  We use logical coordinates, but VJOYD wants physical
         *  coordinates, so do the conversion while we copy the
         *  values.
         */
        #define ConvertValue(f1, f2)                           \
            pCal->f2 = CHid_CoordinateTransform(Dst, Src,     \
                                             JoyPosValue(&cfg.hwc, f1, iAxis) ) 
        ConvertValue(jpMin   , lMin);
        ConvertValue(jpMax   , lMax);
        ConvertValue(jpCenter, lCenter);

        #undef ConvertValue
        #undef JoyPosValue

    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func HRESULT |  DIHid_SetRegistryProperty |
 *
 *          Wrapper around <f SetupDiSetDeviceRegistryProperty>
 *          that handles character set issues.
 *
 *  @parm   LPTSTR ptszId
 *          
 *          Device Instance ID.
 *  
 *  @parm   DWORD | dwProperty |
 *
 *          The property being queried.
 *
 *  @parm   LPCDIPROPHEADER | diph |
 *
 *          Property data to be set.
 *
 *****************************************************************************/
HRESULT INTERNAL
    DIHid_SetParentRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPCDIPROPHEADER pdiph, BOOL bGrandParent)
{
    HDEVINFO hdev;
    TCHAR   tsz[MAX_PATH];
    LPDIPROPSTRING pstr = (PV)pdiph;
    HRESULT hres = E_FAIL;

    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;

        ZeroX(tsz);
    #ifdef UNICODE
        lstrcpyW(tsz, pstr->wsz);
    #else 
        UToA(tsz, cA(tsz), pstr->wsz);
    #endif
        dinf.cbSize = cbX(SP_DEVINFO_DATA);

        if(SetupDiOpenDeviceInfo(hdev, ptszId, NULL, 0, &dinf))
        {
            CONFIGRET cr;
            DEVINST DevInst;
            if( (cr = CM_Get_Parent(&DevInst, dinf.DevInst, 0x0) ) == CR_SUCCESS )
            {
                CAssertF( SPDRP_DEVICEDESC   +1  == CM_DRP_DEVICEDESC  );
                CAssertF( SPDRP_FRIENDLYNAME +1  ==  CM_DRP_FRIENDLYNAME );

                if(bGrandParent)
                {
                    cr = CM_Get_Parent(&DevInst, DevInst, 0x0);
                    if( cr != CR_SUCCESS )
                    {
                        // No GrandParent ?? 
                    }
                }

                if( ( cr = CM_Set_DevNode_Registry_Property(
                                                           DevInst,
                                                           dwProperty+1,
                                                           (LPBYTE)tsz,
                                                           MAX_PATH *cbX(TCHAR),
                                                           0x0 ) ) == CR_SUCCESS )
                {
                    hres = S_OK;
                } else
                {
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("CM_Get_DevNode_Registry_Property FAILED") );
                }
            } else
            {
                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("CM_Get_Parent FAILED") );
            }
        } else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("SetupDiOpenDeviceInfo FAILED, le = %d"), GetLastError() );
        }

        SetupDiDestroyDeviceInfoList(hdev);
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("SetupDiCreateDeviceInfoList FAILED, le = %d"), GetLastError() );
    }

    return hres;
}

HRESULT INTERNAL
    DIHid_SetRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPCDIPROPHEADER pdiph)
{
    HDEVINFO hdev;
    TCHAR   tsz[MAX_PATH];
    LPDIPROPSTRING pstr = (PV)pdiph;
    HRESULT hres;

    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;

        ZeroX(tsz);
    #ifdef UNICODE
        lstrcpyW(tsz, pstr->wsz);
    #else 
        UToA(tsz, cA(tsz), pstr->wsz);
    #endif
        dinf.cbSize = cbX(SP_DEVINFO_DATA);

        if(SetupDiOpenDeviceInfo(hdev, ptszId, NULL, 0, &dinf))
        {
            if(SetupDiSetDeviceRegistryProperty(hdev, &dinf, dwProperty,
                                                (LPBYTE)tsz, MAX_PATH*cbX(TCHAR)) )
            {
                hres = S_OK;

            } else
            {
                hres = E_FAIL;
            }
        } else
        {
            hres = E_FAIL;
        }

        SetupDiDestroyDeviceInfoList(hdev);
    } else
    {
        hres = E_FAIL;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SetProperty |
 *
 *          Set a hid device property.
 *
 *  @parm   PCHID | this |
 *
 *          The hid object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::SetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    if(ppropi->iobj < this->df.dwNumObjs)
    {
        /* 
         * Object Property
         */
        PHIDGROUPCAPS pcaps;
        AssertF(ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType);
        AssertF(ppropi->iobj == CHid_ObjFromType(this, ppropi->dwDevType));

        if( pcaps = this->rghoc[ppropi->iobj].pcaps )
        {
            switch((DWORD)(UINT_PTR)ppropi->pguid)
            {
            case (DWORD)(UINT_PTR)(DIPROP_ENABLEREPORTID):
                {
                    LPDIPROPDWORD ppropdw = CONTAINING_RECORD(pdiph, DIPROPDWORD, diph);

                    AssertF(pcaps->wReportId < this->wMaxReportId[pcaps->type]);
                    AssertF(this->pEnableReportId[pcaps->type]);

                    hres = S_OK;
                    if( ppropdw->dwData == 0x1 )
                    {
                        *(this->pEnableReportId[pcaps->type] + pcaps->wReportId) = 0x1;
                        pcaps->fReportDisabled = FALSE;
                    } else
                    {
                        *(this->pEnableReportId[pcaps->type] + pcaps->wReportId) = 0x0;
                        pcaps->fReportDisabled = TRUE;
                    }
                }
                break;

            default:
                {        /* Object property */
                    PJOYRANGECONVERT pjrc;
                    PHIDGROUPCAPS pcaps;

                    AssertF(ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType);
                    AssertF(ppropi->iobj == CHid_ObjFromType(this, ppropi->dwDevType));

                    if((pjrc = this->rghoc[ppropi->iobj].pjrc) &&
                       (pcaps = this->rghoc[ppropi->iobj].pcaps))
                    {
                        if( ppropi->dwDevType == DIDFT_POV )
                        {
                          #ifdef WINNT
                            /*
                             *  Only allow POV calibration for the private 
                             *  DX5 version used by GCDEF.  This stops WinMM 
                             *  and Nascar 4 from getting unexpected raw 
                             *  data for POVs when polling for raw axes.
                             */
                            if( ( this->dwVersion == 0x5B2 )
                             && ( pcaps->IsPolledPOV ) )
                            {
                                hres = CCal_SetProperty(pjrc, ppropi, pdiph, this->hkInstType, this->dwVersion);
                            
                                if( SUCCEEDED(hres) ) {
                                    CHid_LoadCalibrations(this);
                                
                                    /*
                                     * If this doesn't succeed, no big deal. So, we needn't check hres.
                                     */
                                    hres = CHid_InitParseData( this );
                                }
                            } else 
                          #endif
                            {
                            	hres = E_NOTIMPL;
                            }
                        } else if (ppropi->dwDevType & DIDFT_RELAXIS)
                        {

                            /*
                             *  All relative axes have a full range by default,
                             *  so we don't need to do anything.
                             */
                            hres = E_NOTIMPL;
    
                        } else if(ppropi->dwDevType & DIDFT_ABSAXIS)
                        {
                            /*
                             *  Specific calibrations arrive in VJOYD coordinates.
                             *  We need to convert them to DirectInput (logical)
                             *  coordinates if so.
                             */
                            DIPROPCAL cal;

                            if(ppropi->pguid == DIPROP_SPECIFICCALIBRATION)
                            {
                                PLMINMAX Dst = &pcaps->Logical;
                                PLMINMAX Src = &pcaps->Physical;
                                LPDIPROPCAL pcal = CONTAINING_RECORD(pdiph, DIPROPCAL, diph);

                                cal.lMin    = CHid_CoordinateTransform(Dst, Src, pcal->lMin);
                                cal.lCenter = CHid_CoordinateTransform(Dst, Src, pcal->lCenter);
                                cal.lMax    = CHid_CoordinateTransform(Dst, Src, pcal->lMax);

                                pdiph = &cal.diph;
                            }

                            hres = CCal_SetProperty(pjrc, ppropi, pdiph, this->hkInstType, this->dwVersion);

                            /*
                             *  If we successfully changed the calibration of a joystick
                             *  device, then see if it's a VJOYD device.
                             */
                            if(SUCCEEDED(hres) &&
                               ppropi->pguid == DIPROP_CALIBRATION &&
                               GET_DIDEVICE_TYPE(this->dwDevType) == DIDEVTYPE_JOYSTICK)
                            {
                                CHid_UpdateVjoydCalibration(this, ppropi->iobj);
                            }

                            /*
                             *  We've been call by an app so there's no point in calling 
                             *  Common_Hold/Unhold around this.  
                             */
                            CHid_LoadCalibrations(this);

                            if( SUCCEEDED(hres) )
                            {
                                /*
                                 * If this doesn't succeed, no big deal. So, we needn't check hres.
                                 */
                                hres = CHid_InitParseData( this );
                            }
                        } else {
                            hres = E_NOTIMPL;
                        }
                    } else
                    {
                        hres = E_NOTIMPL;
                    }
                }
            }
        } else
        {
            SquirtSqflPtszV(sqflHidDev | sqflError,
                            TEXT("CHid_SetProperty FAILED due to missing caps for type 0x%08x, obj %d"),
                            ppropi->dwDevType, ppropi->iobj  );

            hres = E_NOTIMPL;
        }
    } else if(ppropi->iobj == 0xFFFFFFFF)
    {        /* Device property */

        switch((DWORD)(UINT_PTR)ppropi->pguid)
        {
        case (DWORD)(UINT_PTR)DIPROP_GUIDANDPATH:
            SquirtSqflPtszV(sqflHidDev | sqflError,
                            TEXT("CHid_SetProperty(iobj=%08x): PROP_GUIDANDPATH is read only.") );
            hres = E_NOTIMPL;
            break;


        case (DWORD)(UINT_PTR)DIPROP_INSTANCENAME:
            /*
             *  DX8 CHANGE !
             *
             *  Friendly names cause all manner of problems with devices that 
             *  use auto detection so only allow non-predefined analog devices 
             *  to use them.
             */
            if( ( this->VendorID == MSFT_SYSTEM_VID )
             && ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX )
             && ( ( this->ProductID & 0xff00 ) == MSFT_SYSTEM_PID ) )
            {
                AssertF(this->hkType);
                
                if( this->hkType )
                {
                    LPDIPROPSTRING pstr = (PV)pdiph;

                    hres = JoyReg_SetValue(this->hkType,
                                           REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                           pstr->wsz,
                                           cbX(pstr->wsz));
                                              
                    if( SUCCEEDED(hres ) )
                    {
                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT( "Set instance name %s"), pstr->wsz );
                        hres = S_OK;
                    } else {
                        hres = E_FAIL;
                    }
                } else {
                    hres = E_FAIL;
                }
            }
            else
            {
                /*
                 *  GenJ returns E_NOTIMPL for this property so do the same
                 */
                hres = E_NOTIMPL;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_PRODUCTNAME:
            if(fWinnt)
            {
                hres = DIHid_SetParentRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph, 0x0 );
            } else
            {
                hres = DIHid_SetRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph);
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_ENABLEREPORTID):
            {            
                LPDIPROPDWORD ppropdw = CONTAINING_RECORD(pdiph, DIPROPDWORD, diph);

                UINT iType;

                if( ppropdw->dwData == 0x0  )
                {
                    for( iType = 0x0; iType < HidP_Max; iType++)
                    {
                        ZeroBuf(this->pEnableReportId[iType], this->wMaxReportId[iType]);
                    }

                } else
                {
                    for( iType = 0x0; iType < HidP_Max; iType++)
                    {
                        memset(this->pEnableReportId[iType], 0x1, this->wMaxReportId[iType]);
                    }
                }
                hres = S_OK;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_RANGE:
        case (DWORD)(UINT_PTR)DIPROP_DEADZONE:
        case (DWORD)(UINT_PTR)DIPROP_SATURATION:
        case (DWORD)(UINT_PTR)DIPROP_CALIBRATIONMODE:
        case (DWORD)(UINT_PTR)DIPROP_CALIBRATION:
            {
                /*
                 *  Post DX7 Gold fix
                 *  For axis properties, iterate through all objects on the 
                 *  device, setting the property on each absolute axis.
                 */

                /*
                 *  ISSUE-2001/03/29-timgill DX7 compat fix should be fixed for ME
                 *  For minimum delta, go through a whole callback set 
                 *  property for each axis.  For Millennium this should 
                 *  be fixed to use a common subroutine.
                 */
                DIPROPCAL       axisprop;
                DIPROPINFO      axispropinfo;
                INT             iObj;
                HRESULT         hresAxis;

                axispropinfo.pguid = ppropi->pguid;

                /*
                 *  The largest property data we handle here is for the 
                 *  DIPROP_CALIBRATION.
                 */
                AssertF( pdiph->dwSize <= cbX( axisprop ) );
                /*
                 *  Copy whatever we have and modify it for each axis
                 */
                memcpy( &axisprop, pdiph, pdiph->dwSize );
                axisprop.diph.dwHow = DIPH_BYID;

                /*
                 *  Make sure we only report real failures.
                 */
                hres = S_OK;

                for( iObj = this->df.dwNumObjs; iObj >= 0; iObj-- )
                {
                    if( ( ( this->df.rgodf[iObj].dwType 
                          & ( DIDFT_ALIAS | DIDFT_VENDORDEFINED | DIDFT_OUTPUT | DIDFT_ABSAXIS ) ) 
                        == DIDFT_ABSAXIS )
                      #ifdef WINNT
                     || ( ( this->df.rgodf[iObj].dwType 
                          & ( DIDFT_ALIAS | DIDFT_VENDORDEFINED | DIDFT_OUTPUT | DIDFT_POV ) ) 
                        == DIDFT_POV )
                      #endif
                    )
                    {
                        axisprop.diph.dwObj = axispropinfo.dwDevType = this->df.rgodf[iObj].dwType;
                        axispropinfo.iobj = (UINT)iObj;

                        hresAxis = CHid_SetProperty(pdcb, (LPCDIPROPINFO)&axispropinfo, &axisprop.diph );
                        if( FAILED( hresAxis ) && ( hresAxis != E_NOTIMPL ) )
                        {
                            hres = hresAxis;
                            break;
                        }
                    }
                }
            }
            break;

        default:
            SquirtSqflPtszV(sqflHidDev| sqflBenign,
                            TEXT("CHid_SetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                            ppropi->iobj, ppropi->pguid);

            hres = E_NOTIMPL;
            break;
        }

    } else
    {
        SquirtSqflPtszV(sqflHidDev | sqflError,
                        TEXT("CHid_SetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                        ppropi->iobj, ppropi->pguid);

        hres = E_NOTIMPL;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | GetCapabilities |
 *
 *          Get Hid device capabilities.
 *
 *  @parm   LPDIDEVCAPS | pdc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdc)
{
    HRESULT hres;
    PCHID this;
    HANDLE h;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetCapabilities,
               (_ "pp", pdcb, pdc));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  We must check connectivity by opening the device, because NT
     *  leaves the device in the info list even though it has
     *  been unplugged.
     */
    h = CHid_OpenDevicePath(this, FILE_FLAG_OVERLAPPED);
    if(h != INVALID_HANDLE_VALUE)
    {
        CloseHandle(h);

        if( !fWinnt )
        {
            VXDINITPARMS vip;

            CHid_FindJoyDevice(this, &vip);

            if( TRUE == CHid_IsMatchingJoyDevice(this, &vip)  )
            {
#ifdef DEBUG  //always use HID path
                TCHAR        szJoyProp[] = REGSTR_PATH_PRIVATEPROPERTIES TEXT("\\Joystick");
                HKEY         hkJoyProp;
                TCHAR        szUseHid[] = TEXT("UseHidPath");
                DWORD        dwUseHid;

                hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                                       szJoyProp, 
                                       DI_KEY_ALL_ACCESS, 
                                       REG_OPTION_NON_VOLATILE, 
                                       &hkJoyProp);

                if( SUCCEEDED(hres) )
                {
                    DWORD cb = sizeof(dwUseHid);
                    LONG  lRc;

                    lRc = RegQueryValueEx(hkJoyProp, szUseHid, 0, 0, (LPBYTE)&dwUseHid, &cb);

                    if( lRc != ERROR_SUCCESS )
                    {
                        DWORD dwDefault = 1;

                        dwUseHid = dwDefault;
                        lRc = RegSetValueEx(hkJoyProp, szUseHid, 0, REG_DWORD, (LPBYTE)&dwDefault, cb);
                    }

                    RegCloseKey(hkJoyProp);
                }

                if( !dwUseHid )
                {
                    pdc->dwFlags |= DIDC_ALIAS ;
                }
#endif

            }
        }

    #if !defined(WINNT) && DIRECTINPUT_VERSION > 0x050A
        if( ( this->dwVersion < 0x0700 ) && ( this->dwVersion != 0x05B2 ) )
        {
            /* 
             *  Post DX7 Gold Fix 
             *  Keep this an alias for older apps.
             */
            pdc->dwFlags |= DIDC_ALIAS;
        }
        else if( this->hkType )
        {
            DWORD dwFlags1;
            if( SUCCEEDED( JoyReg_GetValue( this->hkType,
                                            REGSTR_VAL_FLAGS1, REG_BINARY, 
                                            &dwFlags1, 
                                            cbX(dwFlags1) ) ) )
            {
                if( dwFlags1 & JOYTYPE_NOHIDDIRECT )
                {
                    pdc->dwFlags |= DIDC_ALIAS;
                }
            }
        }
    #endif

        if( this->pvi->fl &  VIFL_UNPLUGGED )
        {
            pdc->dwFlags &= ~DIDC_ATTACHED;
        } else
        {
            pdc->dwFlags |= DIDC_ATTACHED;
        }

    } else
    {
        pdc->dwFlags &= ~DIDC_ATTACHED;
    }

    if( this->IsPolledInput )
    {
        pdc->dwFlags |= DIDC_POLLEDDEVICE;
    }

    pdc->dwDevType = this->dwDevType;
    pdc->dwAxes = this->dwAxes;
    pdc->dwButtons = this->dwButtons;
    pdc->dwPOVs = this->dwPOVs;

    hres = S_OK;
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetDeviceState |
 *
 *          Obtains the state of the Hid device.
 *
 *          It is the caller's responsibility to have validated all the
 *          parameters and ensure that the device has been acquired.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Hid data in the preferred data format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetDeviceState(PDICB pdcb, LPVOID pvData)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetDeviceState,
               (_ "pp", pdcb, pvData));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pvPhys);
    AssertF(this->cbPhys);

    if(this->pvi->fl & VIFL_ACQUIRED)
    {
        CHid_GetPhysicalState(this, pvData);
        hres = S_OK;
    } else
    {
        hres = DIERR_INPUTLOST;
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetObjectInfo |
 *
 *          Obtain the friendly name and FF/HID information
 *          of an object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  All fields have been
 *          filled in up to the <e DIDEVICEOBJECTINSTANCE.tszObjName>.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                       LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetObjectInfo,
               (_ "pxp", pdcb, ppropi->iobj, pdidoiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF((int)ppropi->iobj >= 0);

    if(ppropi->iobj < this->df.dwNumObjs)
    {
        UINT uiInstance = ppropi->iobj;
        PHIDGROUPCAPS pcaps;

        AssertF(ppropi->dwDevType == this->df.rgodf[uiInstance].dwType);
        AssertF(uiInstance == CHid_ObjFromType(this, ppropi->dwDevType));

        pcaps = this->rghoc[uiInstance].pcaps;

        /*
         *  pcaps might be NULL if HID messed up and left gaps
         *  in the index lists.
         */
        if(pcaps)
        {
            UINT ids, duiInstance;

            AssertF(pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE);

            /*
             *  See if there's anything in the registry that will help.
             */
            CType_RegGetObjectInfo(this->hkType, ppropi->dwDevType, pdidoiW);


            if(ppropi->dwDevType & DIDFT_COLLECTION)
            {

                ids = IDS_COLLECTIONTEMPLATE;

                duiInstance = 0;

            } else
            {
                if(ppropi->dwDevType & DIDFT_BUTTON)
                {

                    ids = IDS_BUTTONTEMPLATE;

                } else if(ppropi->dwDevType & DIDFT_AXIS)
                {

                    ids = IDS_AXISTEMPLATE;

                } else if(ppropi->dwDevType & DIDFT_POV)
                {

                    ids = IDS_POVTEMPLATE;

                } else
                {
                    ids = IDS_UNKNOWNTEMPLATE;
                }

                /*
                 *  Now convert the uiInstance to a duiInstance,
                 *  giving the index of this object into the group.
                 */
                AssertF(HidP_IsValidReportType(pcaps->type));
                duiInstance = uiInstance -
                              (this->rgdwBase[pcaps->type] +
                               pcaps->DataIndexMin);
            }

            /*
             *  Okay, now we have all the info we need to proceed.
             */

            /*
             *  If there was no overriding name in the registry, then
             *  try to get a custom name from the usage page/usage.
             *  If even that fails, then use the generic name.
             *  Note, generic names will contain zero based numbers
             *  which can look wrong if some objects have names and 
             *  others take defaults.
             */
            if(pdidoiW->tszName[0])
            {
            } else
                if(GetHIDString(pcaps->UsageMin + duiInstance,
                                pcaps->UsagePage,
                                pdidoiW->tszName, cA(pdidoiW->tszName)))
            {
                if(ppropi->dwDevType & DIDFT_COLLECTION)
                {
                    InsertCollectionNumber(DIDFT_GETINSTANCE( ppropi->dwDevType ), 
                                           pdidoiW->tszName);
                }
            } else
            {
                GetNthString(pdidoiW->tszName, ids, 
                             DIDFT_GETINSTANCE( ppropi->dwDevType ));
            }
            if(pdidoiW->dwSize >= cbX(DIDEVICEOBJECTINSTANCE_DX5W))
            {

                pdidoiW->wCollectionNumber = pcaps->LinkCollection;

                pdidoiW->wDesignatorIndex = pcaps->DesignatorMin + duiInstance;
                if(pdidoiW->wDesignatorIndex > pcaps->DesignatorMax)
                {
                    pdidoiW->wDesignatorIndex = pcaps->DesignatorMax;
                }

                /*
                 *  Much as you may try, you cannot override the usage
                 *  page and usage.  Doing so would mess up the GUID
                 *  selection code that happens in DIHIDINI.C.
                 *
                 *  If you change your mind and allow overridden usage
                 *  pages and usages, then you'll also have to change
                 *  CHid_GetUsage.
                 *
                 *  At this point, the registry overrides have already 
                 *  been read so defeat the override here.
                 */
                pdidoiW->wUsagePage = pcaps->UsagePage;
                pdidoiW->wUsage = pcaps->UsageMin + duiInstance;
                pdidoiW->dwDimension  = pcaps->Units;
                pdidoiW->wExponent  = pcaps->Exponent;
                pdidoiW->wReportId  = pcaps->wReportId;
            }

            hres = S_OK;
        } else
        {
            hres = E_INVALIDARG;
        }
    } else
    {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CHid | GetUsage |
 *
 *          Given an object index, return the usage and usage page,
 *          packed into a single <t DWORD>.
 *
 *  @parm   int | iobj |
 *
 *          The object index to convert.
 *
 *  @returns
 *
 *          Returns a <c DIMAKEUSAGEDWORD> of the resulting usage and
 *          usage page, or zero on error.
 *
 *****************************************************************************/

STDMETHODIMP_(DWORD)
CHid_GetUsage(PDICB pdcb, int iobj)
{
    PCHID this;
    PHIDGROUPCAPS pcaps;
    DWORD dwRc;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetUsage,
               (_ "pu", pdcb, iobj));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(iobj >= 0);
    AssertF((UINT)iobj < this->df.dwNumObjs);

    pcaps = this->rghoc[iobj].pcaps;

    /*
     *  pcaps might be NULL if HID messed up and left gaps
     *  in the index lists.
     */
    if(pcaps)
    {
        UINT duiInstance;

        AssertF(pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE);

        if(this->df.rgodf[iobj].dwType & DIDFT_COLLECTION)
        {

            duiInstance = 0;

        } else
        {

            /*
             *  Now convert the iobj to a duiInstance,
             *  giving the index of this object into the group.
             */
            AssertF(HidP_IsValidReportType(pcaps->type));
            duiInstance = iobj -
                          (this->rgdwBase[pcaps->type] +
                           pcaps->DataIndexMin);
        }

        /*
         *  CHid_GetObjectInfo also assumes that there is no way
         *  to override the usage page and usage values in the
         *  registry.
         */
        dwRc = DIMAKEUSAGEDWORD(pcaps->UsagePage,
                                pcaps->UsageMin + duiInstance);

    } else
    {
        dwRc = 0;
    }

    ExitProcX(dwRc);
    return dwRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | MapUsage |
 *
 *
 *          Given a usage and usage page (munged into a single
 *          <t DWORD>), find a device object that matches it.
 *
 *  @parm   DWORD | dwUsage |
 *
 *          The usage page and usage combined into a single <t DWORD>
 *          with the <f DIMAKEUSAGEDWORD> macro.
 *
 *  @parm   PINT | piOut |
 *
 *          Receives the object index of the found object, if successful.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c S_OK> if an object was found.
 *
 *          <c DIERR_NOTFOUND> if no matching object was found.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_MapUsage(PDICB pdcb, DWORD dwUsage, PINT piOut)
{
    HRESULT hres;
    PCHID this;
    UINT icaps;
    UINT uiObj;
    UINT duiObj;

    EnterProcI(IDirectInputDeviceCallback::Hid::MapUsage,
               (_ "px", pdcb, dwUsage));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    for(icaps = 0; icaps < this->ccaps; icaps++)
    {
        PHIDGROUPCAPS pcaps = &this->rgcaps[icaps];
        LPDIOBJECTDATAFORMAT podf;

        /*
         * Shall we support mapping HidP_Output usage? 
         * If we should, it is easy to add it later.
         */
        uiObj = this->rgdwBase[HidP_Input] + pcaps->DataIndexMin;

        for(duiObj = 0; duiObj < pcaps->cObj; duiObj++)
        {
            podf = &this->df.rgodf[uiObj + duiObj];

            if( dwUsage == GuidToUsage(podf->pguid) )
            {
                *piOut = uiObj+duiObj; 
                AssertF(*piOut < (INT)this->df.dwNumObjs);
                hres = S_OK;
                goto done;
            }

        }
    }

    hres = DIERR_NOTFOUND;

    done:;
    ExitBenignOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SetCooperativeLevel |
 *
 *          Notify the device of the cooperative level.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/


STDMETHODIMP
    CHid_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PCHID this;

    EnterProcI(IDirectInputDeviceCallback::Hid::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  We won't subclass Motocross Madness. See NT bug 262280.
     *  Use the app hacks for MCM and any app like it.
     */
#if (DIRECTINPUT_VERSION > 0x061A)
    if( !this->diHacks.fNoSubClass )
#endif
    {

        AssertF(this->pvi);

        /*
         *  First get out of the old window.
         */
        CHid_RemoveSubclass(this);

        /*
         *  If a new window is passed, then subclass it so we can
         *  watch for joystick configuration change messages.
         *
         *  If we can't, don't worry.  All it means that we won't
         *  be able to catch when the user recalibrates a device,
         *  which isn't very often.
         */
        if(hwnd)
        {
            if(SetWindowSubclass(hwnd, CHid_SubclassProc, 0x0, (ULONG_PTR)this))
            {
                this->hwnd = hwnd;
                Common_Hold(this);
            }

        } else
        {
            RPF("SetCooperativeLevel: You really shouldn't pass hwnd = 0; "
                "device calibration may be dodgy");
        }

    }

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | RunControlPanel |
 *
 *          Run the Hid control panel.
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          The owner window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_RunControlPanel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::RunControlPanel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     * How to invoke HID cpl?
     *
     * hres = (fWinnt) ? hresRunControlPanel(TEXT("srcmgr.cpl,@2")) :
     *                   hresRunControlPanel(TEXT("sysdm.cpl,@0,1"));
     *
     * Currently, we just launch joy.cpl. If more HID devices show up
     * which don't belong to game control panel, we may change it to
     * proper cpl.
     */
    hres = hresRunControlPanel(TEXT("joy.cpl"));

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetFFConfigKey |
 *
 *          Open and return the registry key that contains
 *          force feedback configuration information.
 *
 *  @parm   DWORD | sam |
 *
 *          Security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the registry key.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::HID::GetFFConfigKey,
               (_ "px", pdcb, sam));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = JoyReg_OpenFFKey(this->hkType, sam, phk);

    AssertF(fLeqvFF(SUCCEEDED(hres), *phk));

    if(FAILED(hres) && this->fPIDdevice )
    {
        *phk = NULL;
        hres = S_FALSE;
    }

    ExitBenignOleProcPpvR(phk);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetDeviceInfo |
 *
 *          Obtain general information about the device.
 *
 *  @parm   OUT LPDIDEVICEINSTANCEW | pdiW |
 *
 *          <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *          Secret convenience:  <e DEVICEINSTANCE.guidProduct> is equal
 *          to <e DEVICEINSTANCE.guidInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW pdiW)
{
    HRESULT hres;
    PCHID this;

    DIPROPINFO      propi;                            
    DIPROPSTRING    dips;

    EnterProcI(IDirectInputDeviceCallback::Hid::GetDeviceInfo,
               (_ "pp", pdcb, pdiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);
    AssertF(IsValidSizeDIDEVICEINSTANCEW(pdiW->dwSize));

    DICreateStaticGuid(&pdiW->guidProduct, this->ProductID, this->VendorID);

    pdiW->dwDevType = this->dwDevType;

    if(pdiW->dwSize >= cbX(DIDEVICEINSTANCE_DX5W))
    {
        pdiW->wUsagePage = this->caps.UsagePage;
        pdiW->wUsage     = this->caps.Usage;
    }

    propi.dwDevType = DIPH_DEVICE;
    propi.iobj      = 0xFFFFFFFF;
    propi.pguid = DIPROP_PRODUCTNAME;

    if(SUCCEEDED(hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dips.diph)) )
    {
        lstrcpyW(pdiW->tszProductName, dips.wsz);
    }

    propi.pguid = DIPROP_INSTANCENAME;
    if( FAILED(pdcb->lpVtbl->GetProperty(pdcb, &propi, &dips.diph)))
    {
        // Use Product Name
    }

    lstrcpyW(pdiW->tszInstanceName, dips.wsz); 


    #ifdef IDirectInputDevice2Vtbl
    if(pdiW->dwSize >= cbX(DIDEVICEINSTANCE_DX5W))
    {
        HKEY hkFF;
        HRESULT hresFF;

        /*
         *  If there is a force feedback driver, then fetch the driver CLSID
         *  as the FF GUID.
         */
        hresFF = CHid_GetFFConfigKey(pdcb, KEY_QUERY_VALUE, &hkFF);
        if(SUCCEEDED(hresFF))
        {
            LONG lRc;
            TCHAR tszClsid[ctchGuid];

            lRc = RegQueryString(hkFF, TEXT("CLSID"), tszClsid, cA(tszClsid));
            if(lRc == ERROR_SUCCESS &&
               ParseGUID(&pdiW->guidFFDriver, tszClsid))
            {
            } else
            {
                ZeroX(pdiW->guidFFDriver);
            }
            RegCloseKey(hkFF);
        }
    }
    #endif

    ExitOleProcR();
    return hres;

}
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | CreateEffect |
 *
 *
 *          Create an <i IDirectInputEffectDriver> interface.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD * | ppes |
 *
 *          Receives the shepherd for the effect driver.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes)
{
    HRESULT hres;
    PCHID this;
    HKEY hk;
    EnterProcI(IDirectInputDeviceCallback::HID::CreateEffect, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = CHid_GetFFConfigKey(pdcb, KEY_QUERY_VALUE, &hk);
    if(SUCCEEDED(hres))
    {
        DIHIDFFINITINFO init;
        PHIDDEVICEINFO phdi;

        hres = CEShep_New(hk, 0, &IID_IDirectInputEffectShepherd, ppes);
        if(SUCCEEDED(hres))
        {
    #ifndef UNICODE
            WCHAR wszPath[MAX_PATH];
    #endif

            init.dwSize = cbX(init);
    #ifdef UNICODE
            init.pwszDeviceInterface = this->ptszPath;
    #else
            init.pwszDeviceInterface = wszPath;
            TToU(wszPath, cA(wszPath), this->ptszPath);
    #endif

            DllEnterCrit();
            phdi = phdiFindHIDDeviceInterface(this->ptszPath);

            if( phdi )
            {
                init.GuidInstance = phdi->guid;
            } else
            {
                ZeroX(init.GuidInstance);
            }
            DllLeaveCrit();

            hres = (*ppes)->lpVtbl->DeviceID((*ppes), this->idJoy, TRUE, &init);
            if(SUCCEEDED(hres))
            {
            } else
            {
                Invoke_Release(ppes);
            }
        }
        RegCloseKey(hk);
    } else
    {
        hres = E_NOTIMPL;
        *ppes = 0;
    }

    ExitOleProcPpvR(ppes);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SendOutputReport |
 *
 *          Actually send the report as an output report.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The report being sent.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

void CALLBACK
    CHid_DummyCompletion(DWORD dwError, DWORD cbRead, LPOVERLAPPED po)
{
}

STDMETHODIMP
    CHid_SendOutputReport(PCHID this, PHIDREPORTINFO phri)
{
    HRESULT hres;
    OVERLAPPED o;

    AssertF(phri == &this->hriOut);
    ZeroX(o);

    /*
     *  Annoying API:  Since this->hdev was opened
     *  as FILE_FLAG_OVERLAPPED, *all* I/O must be overlapped.
     *  So we simulate a synchronous I/O by issuing an
     *  overlapped I/O and waiting for the completion.
     */

    if(WriteFileEx(this->hdev, phri->pvReport,
                   phri->cbReport, &o, CHid_DummyCompletion))
    {
        do
        {
            SleepEx(INFINITE, TRUE);
        } while(!HasOverlappedIoCompleted(&o));

        if(phri->cbReport == o.InternalHigh)
        {
            hres = S_OK;
        } else
        {
            RPF("SendDeviceData: Wrong HID output report size?");
            hres = E_FAIL;      /* Aigh!  HID lied to me! */
        }
    } else
    {
        hres = hresLe(GetLastError());

        CEm_ForceDeviceUnacquire(pemFromPvi(this->pvi)->ped, 0x0);
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SendFeatureReport |
 *
 *          Actually send the report as an feature report.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The report being sent.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_SendFeatureReport(PCHID this, PHIDREPORTINFO phri)
{
    HRESULT hres;

    AssertF(phri == &this->hriFea);

    if(HidD_SetFeature(this->hdev, phri->pvReport, phri->cbReport))
    {
        hres = S_OK;
    } else
    {
        RPF("SendDeviceData: Unable to set HID feature");
        hres = hresLe(GetLastError());
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SendDeviceData |
 *
 *          Spew some data to the device.
 *
 *  @parm   IN LPCDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          On entry, number of items to send;
 *          on exit, number of items actually sent.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_REPORTFULL>: Too many items are set in the report.
 *                                (More than can be sent to the device)
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_SendDeviceData(PDICB pdcb, LPCDIDEVICEOBJECTDATA rgdod,
                        LPDWORD pdwInOut, DWORD fl)
{
    HRESULT hres;
    PCHID this;
    DWORD dwIn, dw;
    EnterProcI(IDirectInputDeviceCallback::Hid::SendDeviceData,
               (_ "pux", pdcb, *pdwInOut, fl));


    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    dwIn = *pdwInOut;
    *pdwInOut = 0;

    if(fl & DISDD_CONTINUE)
    {
    } else
    {
        CHid_ResetDeviceData(this, &this->hriOut, HidP_Output);
        CHid_ResetDeviceData(this, &this->hriFea, HidP_Feature);
    }

    for(dw = 0; dw < dwIn; dw++)
    {
        DWORD dwType = rgdod[dw].dwOfs;
        UINT uiObj = CHid_ObjFromType(this, dwType);

        if(uiObj < this->df.dwNumObjs &&
           DIDFT_FINDMATCH(this->df.rgodf[uiObj].dwType, dwType))
        {
            hres = CHid_AddDeviceData(this, uiObj, rgdod[dw].dwData);
            if(FAILED(hres))
            {
                *pdwInOut = dw;
                goto done;
            }
        } else
        {
            hres = E_INVALIDARG;
            goto done;
        }
    }

    /*
     *  All the items made it into the buffer.
     */
    *pdwInOut = dw;

    /*
     *  Now send it all out.
     */
    if(SUCCEEDED(hres = CHid_SendHIDReport(this, &this->hriOut, HidP_Output,
                                           CHid_SendOutputReport)) &&
       SUCCEEDED(hres = CHid_SendHIDReport(this, &this->hriFea, HidP_Feature,
                                           CHid_SendFeatureReport)))
    {
    }

    done:;
    ExitOleProcR();
    return hres;
}
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Poll |
 *
 *          Read the features to see what's there.
 *
 *  @returns
 *
 *          <c S_OK> if we pinged okay.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_Poll(PDICB pdcb)
{
    // Prefix: 45082
    HRESULT hres = S_FALSE;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::Poll, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    //ISSUE-2001/03/29-timgill NT5 Beta1 compat fix
    if( this->IsPolledInput )
    {
        hres = DIERR_UNPLUGGED;
        if(ReadFileEx(this->hdev, this->hriIn.pvReport,
                      this->hriIn.cbReport, &this->o, CHid_DummyCompletion))
        {
            do
            {
                SleepEx( INFINITE, TRUE);
            } while(!HasOverlappedIoCompleted(&this->o));

            if(this->hriIn.cbReport == this->o.InternalHigh)
            {
                NTSTATUS stat;

                //CEm_HID_PrepareState(this);
                CopyMemory(this->pvStage, this->pvPhys, this->cbPhys);

                stat = CHid_ParseData(this, HidP_Input, &this->hriIn);

                if(SUCCEEDED(stat))
                {
                    CEm_AddState(&this->ed, this->pvStage, GetTickCount());                
                    this->pvi->fl &=  ~VIFL_UNPLUGGED;
                    hres = S_OK;
                } else
                {
                    hres = stat;
                }
            }
        }

        if( FAILED(hres) )
        {
            hres = DIERR_UNPLUGGED;
            this->pvi->fl |= VIFL_UNPLUGGED;
            if( !this->diHacks.fNoPollUnacquire )
            {
                CEm_ForceDeviceUnacquire(pemFromPvi(this->pvi)->ped, 0x0);
            }
        }
    }


    if( this->hriFea.cbReport )
    {
        UINT uReport;
        /*
         *  We should never get here unless there really are any
         *  features that need to be polled.
         */
        AssertF(this->hriFea.cbReport);
        AssertF(this->hriFea.pvReport);

        /*
         *  Read the new features and parse/process them.
         *
         *  Notice that we read the features into the same buffer
         *  that we log them into.  That's okay; the "live" parts
         *  of the two buffers never actually overlap.
         */
        for( uReport = 0x0; uReport < this->wMaxReportId[HidP_Feature]; uReport++ )
        {
            if( *(this->pEnableReportId[HidP_Feature] + uReport ) == TRUE )
            {
                *((UCHAR*)(this->hriFea.pvReport)) = (UCHAR)uReport;

                /*
                 *  Wipe out all the old goo because we're taking over.
                 */
                CHid_ResetDeviceData(this, &this->hriFea, HidP_Feature);

                if(HidD_GetFeature(this->hdev, this->hriFea.pvReport,
                                   this->hriFea.cbReport))
                {
                    NTSTATUS stat;

                    stat = CHid_ParseData(this, HidP_Feature, &this->hriFea);

                    AssertF(SUCCEEDED(stat));
                    if(SUCCEEDED(stat))
                    {
                        CEm_AddState(&this->ed, this->pvStage, GetTickCount());                
                    }

                    hres = stat;

                } else
                {
                    RPF("CHid_Poll: Unable to read HID features (ReportID%d) LastError(0x%x)", uReport, GetLastError() );
                    hres = hresLe(GetLastError());

                }
            }
        }
    }

    if( this->dwVersion < 0x05B2 )
    {
        /*
         * In Win9x, we need hard code it to be S_OK, otherwise, some games:
         * such as Carmegeddon 2, will fails.
         * The NT and onwards CPL requires poll to return true status
         */
        hres = S_OK;
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *      CHid_New       (constructor)
 *
 *      Fail the create if we can't open the device.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Hid::<constructor>,
               (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CHid, punkOuter, riid, ppvObj);

    if(SUCCEEDED(hres))
    {
        /* Must use _thisPv in case of aggregation */
        PCHID this = _thisPv(*ppvObj);

        if(SUCCEEDED(hres = CHid_Init(this, rguid)))
        {
        } else
        {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SetDIData |
 *
 *          Set DirectInput version and apphack data from CDIDev *.
 *
 *  @parm   DWORD | dwVer |
 *
 *          DirectInput version
 *
 *  @parm   LPVOID | lpdihacks |
 *
 *          AppHack data
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we don't support usages.
 *
 *****************************************************************************/

STDMETHODIMP
CHid_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::SetDIData,
               (_ "pup", pdcb, dwVer, lpdihacks));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    this->dwVersion = dwVer;
    ((LPDIAPPHACKS)lpdihacks)->dwDevType = this->dwDevType;
    
    CopyMemory(&this->diHacks, (LPDIAPPHACKS)lpdihacks, sizeof(this->diHacks));
    
    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

    #pragma BEGIN_CONST_DATA

    #define CHid_Signature          0x20444948      /* "HID " */

Primary_Interface_Begin(CHid, IDirectInputDeviceCallback)
CHid_GetInstance,
CDefDcb_GetVersions,
CHid_GetDataFormat,
CHid_GetObjectInfo,
CHid_GetCapabilities,
CHid_Acquire,
CHid_Unacquire,
CHid_GetDeviceState,
CHid_GetDeviceInfo,
CHid_GetProperty,
CHid_SetProperty,
CDefDcb_SetEventNotification,
    #ifdef WINNT
    CHid_SetCooperativeLevel,
    #else
    CDefDcb_SetCooperativeLevel,
    #endif
CHid_RunControlPanel,
CDefDcb_CookDeviceData,
CHid_CreateEffect,
CHid_GetFFConfigKey,
CHid_SendDeviceData,
CHid_Poll,
CHid_GetUsage,
CHid_MapUsage,
CHid_SetDIData,
Primary_Interface_End(CHid, IDirectInputDeviceCallback)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dihidenm.c ===
/*****************************************************************************
 *
 *  DIHidEnm.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Support functions for HID enumeration.
 *
 *  Contents:
 *
 *      DIHid_BuildHidList
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHid

#ifdef HID_SUPPORT

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global PHIDDEVICELIST | g_hdl |
 *
 *          List of known HID devices.
 *
 *  @global DWORD | g_tmLastHIDRebuild |
 *
 *          The time we last rebuilt the HID list.  Zero means that the
 *          HID list has never been rebuilt.  Watch out for wraparound;
 *          a 32-bit value rolls over after about 30 days.
 *
 *****************************************************************************/

#define MSREBUILDRATE       20000                /* Twenty seconds */
#define MSREBUILDRATE_FIFTH  5000                /* Two seconds */

PHIDDEVICELIST g_phdl;
DWORD g_tmLastHIDRebuild;

TCHAR g_tszIdLastRemoved[MAX_PATH];
DWORD g_tmLastRemoved = 0;
TCHAR g_tszIdLastUnknown[MAX_PATH];
DWORD g_tmLastUnknown = 0;


    #pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFindHIDInstanceGUID |
 *
 *          Locates information given an instance GUID for a HID device.
 *
 *          The parameters have already been validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          The instance GUID to be located.
 *
 *  @returns
 *
 *          Pointer to the <t HIDDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PHIDDEVICEINFO EXTERNAL
    phdiFindHIDInstanceGUID(PCGUID pguid)
{
    PHIDDEVICEINFO phdi;

    AssertF(InCrit());

    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0, phdi = g_phdl->rghdi; 
           ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            if(IsEqualGUID(pguid, &phdi->guid)  )
            {
                goto done;
            }
        }
        /* 
         * Memphis Bug#68994. App does not detect USB device. 
         * App was using product guid. 
         * Fix: We allow match to HID guid, if product guid is specfied
         */
        for(ihdi = 0, phdi = g_phdl->rghdi;
           ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            if(IsEqualGUID(pguid, &phdi->guidProduct)  )
            {
                RPF("Warning: Use instance GUID (NOT product GUID) to refer to a device.");
                goto done;
            }
        }

        #ifdef WINNT
        /*
         *  NT Bug#351951.
         *  If they are directly asking for one of the predefined joystick 
         *  IDs then see if we have a device mapped to that ID.  If so,
         *  pretend they asked for that GUID instead.
         */

        /*
         *  Weakly Assert the range of predefined static joystick instance GUIDs
         */
        AssertF( ( rgGUID_Joystick[0].Data1 & 0x0f ) == 0 );
        AssertF( ( rgGUID_Joystick[0x0f].Data1 & 0x0f ) == 0x0f );

        /*
         *  Check the GUID is the same as the first static one ignoring LS 4 bits
         */
        if( ( (pguid->Data1 & 0xf0) == (rgGUID_Joystick[0].Data1 & 0xf0) )
          && !memcmp( ((PBYTE)&rgGUID_Joystick)+1, ((PBYTE)pguid)+1, sizeof(*pguid) - 1 ) )
        {
            RPF("Using predefined instance GUIDs is bad and should not work!");
            phdi = phdiFindJoyId( pguid->Data1 & 0x0f );
            goto done;
        }
        #endif
    }
    phdi = 0;

    done:;

    return phdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFindHIDInstanceGUID |
 *
 *          Locates information given an instance GUID for a HID device.
 *
 *          The parameters have already been validated.
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          The instance GUID to be located.
 *
 *  @parm   OUT CREATEDCB * | pcdcb |
 *
 *          Receives pointer to the <f CreateDcb> function for the object.
 *
 *****************************************************************************/

STDMETHODIMP
    hresFindHIDInstanceGUID(PCGUID pguid, CREATEDCB *pcdcb)
{
    HRESULT hres;
    PHIDDEVICEINFO phdi;
    EnterProc(hresFindHIDInstanceGUID, (_ "G", pguid));

    AssertF(SUCCEEDED(hresFullValidGuid(pguid, 0)));

    DllEnterCrit();

    phdi = phdiFindHIDInstanceGUID(pguid);
    if(phdi)
    {
        *pcdcb = CHid_New;
        hres = S_OK;
    } else
    {
        hres = DIERR_DEVICENOTREG;
    }

    DllLeaveCrit();

    /*
     *  Don't use ExitOleProcPpv because that will validate that
     *  *pcdcb == 0 if FAILED(hres), but that's not our job.
     */
    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFindHIDDeviceInterface |
 *
 *          Locates information given a device interface
 *          (in other words, a \\.\... thing) for a HID device.
 *
 *          The parameters have already been validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN LPCTSTR | ptszPath |
 *
 *          The interface device to be located.
 *
 *  @returns
 *
 *          Pointer to the <t HIDDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PHIDDEVICEINFO EXTERNAL
    phdiFindHIDDeviceInterface(LPCTSTR ptszPath)
{
    PHIDDEVICEINFO phdi;

    AssertF(InCrit());

    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0, phdi = g_phdl->rghdi; ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            if(phdi->pdidd &&
               lstrcmpi(phdi->pdidd->DevicePath, ptszPath) == 0)
            {
                goto done;
            }
        }
    }
    phdi = 0;

    done:;

    return phdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFindHIDDeviceInterface |
 *
 *          Locates information given a device interface
 *          (in other words, a \\.\... thing) for a HID device.
 *
 *          The parameters have already been validated.
 *
 *  @parm   IN LPCTSTR | ptszPath |
 *
 *          The interface device to be located.
 *
 *  @parm   OUT LPGUID | pguidOut |
 *
 *          Receives the instance GUID of the device found.
 *
 *****************************************************************************/

STDMETHODIMP
    hresFindHIDDeviceInterface(LPCTSTR ptszPath, LPGUID pguidOut)
{
    HRESULT hres;
    PHIDDEVICEINFO phdi;
    EnterProc(hresFindHIDDeviceInterface, (_ "s", ptszPath));

    DllEnterCrit();

    phdi = phdiFindHIDDeviceInterface(ptszPath);

    if(phdi)
    {
        *pguidOut = phdi->guid;
        hres = S_OK;
    } else
    {
        hres = DIERR_DEVICENOTREG;
    }

    DllLeaveCrit();

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_ProbeMouse |
 *
 *          That this function exists at all is a total hack to work
 *          around bugs in Memphis and NT5.
 *
 *          If you call GetSystemMetrics(SM_WHEELPRESENT) or
 *          GetSystemMetrics(SM_MOUSEBUTTONS), USER32 does not
 *          return the correct values if your HID mouse is
 *          not the same as your PS/2 mouse (if any).
 *
 *          For example, if your PS/2 mouse is a regular two-button
 *          mouse but your HID mouse is a wheel mouse, GetSystemMetrics
 *          will still say "No wheel, 2 buttons" even though it's wrong.
 *
 *          So what we have to do is wander through all the HID mice in
 *          the system and record the number of buttons they have,
 *          and whether they have a wheel.
 *
 *          That way, when we create a system mouse, we can take the
 *          maximum of every supported device.
 *
 *****************************************************************************/

void INTERNAL
    DIHid_ProbeMouse(PHIDDEVICEINFO phdi, PHIDP_CAPS pcaps,
                     PHIDP_PREPARSED_DATA ppd)
{
    LPVOID pvReport;
    HRESULT hres;

    /*
     *  Get the number of buttons in the generic button page.
     *  This is the only page the MOUHID uses.
     */
    phdi->osd.uiButtons =
        HidP_MaxUsageListLength(HidP_Input, HID_USAGE_PAGE_BUTTON, ppd);

    /*
     *  See if there is a HID_USAGE_GENERIC_WHEEL.
     *  This is the way that MOUHID detects a wheel.
     */
    hres = AllocCbPpv(pcaps->InputReportByteLength, &pvReport);
    if(SUCCEEDED(hres))
    {
        ULONG ul;
        NTSTATUS stat;

        stat = HidP_GetUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0,
                                  HID_USAGE_GENERIC_WHEEL, &ul, ppd,
                                  pvReport,
                                  pcaps->InputReportByteLength);
        if(SUCCEEDED(stat))
        {
            phdi->osd.uiAxes = 3;
        }

        FreePv(pvReport);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_ParseUsagePage |
 *
 *          Parse the usage page information and create fake type
 *          information in the old DirectX3-compatible way.
 *
 *****************************************************************************/

void INTERNAL
    DIHid_ParseUsagePage(PHIDDEVICEINFO phdi, PHIDP_CAPS pcaps,
                         PHIDP_PREPARSED_DATA ppd)

{
    switch(pcaps->UsagePage)
    {

        case HID_USAGE_PAGE_GENERIC:
            switch(pcaps->Usage)
            {

                /*
                 *  MouHID accepts either HID_USAGE_GENERIC_MOUSE or
                 *  HID_USAGE_GENERIC_POINTER, so we will do the same.
                 */
                case HID_USAGE_GENERIC_MOUSE:
                case HID_USAGE_GENERIC_POINTER:
                    DIHid_ProbeMouse(phdi, pcaps, ppd);
                    phdi->osd.dwDevType =
                        MAKE_DIDEVICE_TYPE(DIDEVTYPE_MOUSE,
                                           DIDEVTYPEMOUSE_UNKNOWN) |
                        DIDEVTYPE_HID;
                    break;

                case HID_USAGE_GENERIC_JOYSTICK:
                    phdi->osd.dwDevType =
                        MAKE_DIDEVICE_TYPE(DIDEVTYPE_JOYSTICK,
                                           DIDEVTYPEJOYSTICK_UNKNOWN) |
                        DIDEVTYPE_HID;
                    break;

                case HID_USAGE_GENERIC_GAMEPAD:
                    phdi->osd.dwDevType =
                        MAKE_DIDEVICE_TYPE(DIDEVTYPE_JOYSTICK,
                                           DIDEVTYPEJOYSTICK_GAMEPAD) |
                        DIDEVTYPE_HID;
                    break;

                case HID_USAGE_GENERIC_KEYBOARD:
                    phdi->osd.dwDevType =
                        MAKE_DIDEVICE_TYPE(DIDEVTYPE_KEYBOARD,
                                           DIDEVTYPEKEYBOARD_UNKNOWN) |
                        DIDEVTYPE_HID;
                    break;

                default:
                    phdi->osd.dwDevType = DIDEVTYPE_DEVICE | DIDEVTYPE_HID;
                    break;
            }
            break;

        default:
            phdi->osd.dwDevType = DIDEVTYPE_DEVICE | DIDEVTYPE_HID;
            break;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIHid_GetDevicePath |
 *
 *          Obtain the path for the device.  This is a simple wrapper
 *          function to keep DIHid_BuildHidListEntry from getting too
 *          annoying.
 *
 *          This also gets the devinfo so we can get the
 *          instance ID string for subsequent use to get the
 *          friendly name, etc.
 *
 *****************************************************************************/

BOOL EXTERNAL
    DIHid_GetDevicePath(HDEVINFO hdev,
                        PSP_DEVICE_INTERFACE_DATA pdid,
                        PSP_DEVICE_INTERFACE_DETAIL_DATA *ppdidd,
                        OPTIONAL PSP_DEVINFO_DATA pdinf)
{
    HRESULT hres;
    BOOL fRc;
    DWORD cbRequired;
    EnterProcI(DIHid_GetDevicePath, (_ "xp", hdev, pdid));

    AssertF(*ppdidd == 0);

    /*
     *  Ask for the required size then allocate it then fill it.
     *
     *  Note that we don't need to free the memory on the failure
     *  path; our caller will do the necessary memory freeing.
     *
     *  Sigh.  Windows NT and Windows 98 implement
     *  SetupDiGetDeviceInterfaceDetail differently if you are
     *  querying for the buffer size.
     *
     *  Windows 98 returns FALSE, and GetLastError() returns
     *  ERROR_INSUFFICIENT_BUFFER.
     *
     *  Windows NT returns TRUE.
     *
     *  So we allow the cases either where the call succeeds or
     *  the call fails with ERROR_INSUFFICIENT_BUFFER.
     */
    if(SetupDiGetDeviceInterfaceDetail(hdev, pdid, 0, 0,
                                       &cbRequired, 0) ||
       GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {

        hres = AllocCbPpv(cbRequired, ppdidd);

        // Keep prefix happy, manbug 29341
        if(SUCCEEDED(hres) && ( *ppdidd != NULL) )
        {
            PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd = *ppdidd;

            /* 
             *  Note, The cbSize field always contains the size of the fixed 
             *  part of the data structure, not a size reflecting the 
             *  variable-length string at the end. 
             */

            pdidd->cbSize = cbX(SP_DEVICE_INTERFACE_DETAIL_DATA);

            fRc = SetupDiGetDeviceInterfaceDetail(hdev, pdid, pdidd,
                                                  cbRequired, &cbRequired, pdinf);

            if(!fRc)
            {
                FreePpv(ppdidd);

                /*
                 * Set fRc = FALSE again, so the compiler doesn't need
                 * to blow a register to cache the value zero.
                 */
                fRc = FALSE;
            }
        } else
        {
            fRc = FALSE;
        }
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%hs: SetupDiGetDeviceInterfaceDetail failed 1, ")
                        TEXT("Error = %d"),
                        s_szProc, GetLastError());
        fRc = FALSE;
    }

    ExitProcF(fRc);
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIHid_GetDeviceInstanceId |
 *
 *          Obtain the instance ID for the device.
 *
 *          The instance ID allows us to get access to device
 *          properties later.
 *
 *****************************************************************************/

BOOL EXTERNAL
    DIHid_GetDeviceInstanceId(HDEVINFO hdev,
                              PSP_DEVINFO_DATA pdinf, LPTSTR *pptszId)
{
    HRESULT hres;
    BOOL fRc;
    DWORD ctchRequired;

    AssertF(*pptszId == 0);

    /*
     *  Ask for the required size then allocate it then fill it.
     *
     *  Note that we don't need to free the memory on the failure
     *  path; our caller will do the necessary memory freeing.
     */
    if(SetupDiGetDeviceInstanceId(hdev, pdinf, NULL, 0,
                                  &ctchRequired) == 0 &&
       GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {

        hres = AllocCbPpv(cbCtch(ctchRequired), pptszId);

        if(SUCCEEDED(hres))
        {
            fRc = SetupDiGetDeviceInstanceId(hdev, pdinf, *pptszId,
                                             ctchRequired, NULL);
        } else
        {
            fRc = FALSE;
        }
    } else
    {
        fRc = FALSE;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIHid_GetInstanceGUID |
 *
 *          Read the instance GUID from the registry, or create one if
 *          necessary.
 *
 *****************************************************************************/

BOOL INTERNAL
    DIHid_GetInstanceGUID(HKEY hk, LPGUID pguid)
{
    LONG lRc;
    DWORD cb;

    cb = cbX(GUID);
    lRc = RegQueryValueEx(hk, TEXT("GUID"), 0, 0, (PV)pguid, &cb);

    if(lRc != ERROR_SUCCESS)
    {
        DICreateGuid(pguid);
        lRc = RegSetValueEx(hk, TEXT("GUID"), 0, REG_BINARY,
                            (PV)pguid, cbX(GUID));
    }

    return lRc == ERROR_SUCCESS;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_EmptyHidList |
 *
 *          Empty the list of HID devices.
 *
 *          This function must be called under the DLL critical section.
 *
 *****************************************************************************/

void EXTERNAL
    DIHid_EmptyHidList(void)
{
    AssertF(InCrit());

    /*
     *  Free all the old strings and things in the HIDDEVICEINFO's.
     */
    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0; ihdi < g_phdl->chdi; ihdi++)
        {
            FreePpv(&g_phdl->rghdi[ihdi].pdidd);
            FreePpv(&g_phdl->rghdi[ihdi].ptszId);
            if(g_phdl->rghdi[ihdi].hk)
            {
                RegCloseKey(g_phdl->rghdi[ihdi].hk);
            }
        }

        /*
         *  We invalidated all the pointers, so make sure
         *  nobody looks at them.
         */
        g_phdl->chdi = 0;
    }

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_CheckHidList |
 *
 *          Check the list of HID devices, and free whose what can not be opened
 *
 *          This function must be called under the DLL critical section.
 *
 *****************************************************************************/

void INTERNAL
    DIHid_CheckHidList(void)
{
    HANDLE hf;

    EnterProcI(DIHid_CheckList, (_ "x", 0x0) );

    AssertF(InCrit());

    /*
     *  Free all the information of the device cannot be opened
     */
    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0, g_phdl->chdi = 0; ihdi < g_phdl->chdiAlloc; ihdi++)
        {

            if( g_phdl->rghdi[ihdi].pdidd )
            {

                /*
                 *  Open the device
                 */
                hf = CreateFile(g_phdl->rghdi[ihdi].pdidd->DevicePath,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                0,                /* no SECURITY_ATTRIBUTES */
                                OPEN_EXISTING,
                                0,                /* attributes */
                                0);               /* template */

                if(hf == INVALID_HANDLE_VALUE)
                {                                        
#if 0
                    PHIDDEVICEINFO phdi;
                    PBUSDEVICEINFO pbdi;

                    CloseHandle(hf);
                    
                    phdi = &g_phdl->rghdi[ihdi];
                    
                    DllEnterCrit();

                    phdi = phdiFindHIDDeviceInterface(g_phdl->rghdi[ihdi].pdidd->DevicePath);
                    AssertF(phdi != NULL);
                    pbdi = pbdiFromphdi(phdi);

                    DllLeaveCrit();

                    if( pbdi != NULL )
                    {
                        if( pbdi->fDeleteIfNotConnected == TRUE )
                        {
                            lstrcpy( g_tszIdLastRemoved, pbdi->ptszId );
                            g_tmLastRemoved = GetTickCount();

                            DIBusDevice_Remove(pbdi);
                            
                            pbdi->fDeleteIfNotConnected = FALSE;
                        }
                    }
#endif                    

                    FreePpv(&g_phdl->rghdi[ihdi].pdidd);
                    FreePpv(&g_phdl->rghdi[ihdi].ptszId);

                    if(g_phdl->rghdi[ihdi].hk)
                    {
                        RegCloseKey(g_phdl->rghdi[ihdi].hk);
                    }
                    
                    ZeroX( g_phdl->rghdi[ihdi] );

                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: CreateFile(%s) failed? le=%d"),
                                    s_szProc, g_phdl->rghdi[ihdi].pdidd->DevicePath, GetLastError());
                    
                    /* Skip erroneous items */

                } else
                {
                    CloseHandle(hf);
                    g_phdl->chdi++;
                }
            }
        }

        //re-order the existing devices, put them at the front of the hid list.
        for(ihdi = 0; ihdi < g_phdl->chdi; ihdi++)
        {
            if( !g_phdl->rghdi[ihdi].pdidd )
            {
                int ihdi2;

                //find the existing device from the biggest index in the hid list.
                for( ihdi2 = g_phdl->chdiAlloc; ihdi2 >= ihdi+1; ihdi2-- )
                {
                    if( g_phdl->rghdi[ihdi2].pdidd )
                    {
                        memcpy( &g_phdl->rghdi[ihdi], &g_phdl->rghdi[ihdi2], sizeof(HIDDEVICEINFO) );
                        ZeroX( g_phdl->rghdi[ihdi2] );
                    }
                }
            }
        }

    }

    ExitProc();
    return;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIHid_CreateDeviceInstanceKeys |
 *
 *          Create the keys associaciated with a particular device.
 *
 *  @parm   IN OUT PHIDDEVICEINFO | phdi |
 *
 *          HIDDEVICEINFO we to use/update.
 *
 *  @returns
 *
 *          S_OK for a success
 *          A COM error for a failure
 *
 *****************************************************************************/

#define DIHES_UNDEFINED 0
#define DIHES_UNKNOWN   1
#define DIHES_KNOWN     2


HRESULT INTERNAL
    DIHid_CreateDeviceInstanceKeys( PHIDDEVICEINFO phdi, PBYTE pState )
{
    HRESULT hres;
    HKEY hkDin;

    USHORT uVid, uPid;

    TCHAR tszName[MAX_PATH];
    PTCHAR ptszInstance = NULL;

    EnterProcI(DIHid_CreateDeviceInstanceKeys, (_ "p", phdi));

    /*
     *  Unfortunately, we need to open our registry keys before we can open 
     *  the device so rather than ask the device for its VID and PID, we 
     *  parse it from the 
     */

    /*
     *  ISSUE-2001/01/27-MarcAnd Should avoid parsing device ID ourselves
     *  Need to find some documented way to parse out the three parts of the 
     *  device ID: class, device and instance in case the form changes.
     */

    /*
     *  The format of the device ID is a set of strings in the form 
     *  "<class>\<device>\<instance>" with variable case.
     *  For HID devices, the class should be "hid" and the instance is a set 
     *  of hex values separated by ampersands.  The device string should be 
     *  of the form vid_9999&pid_9999 but devices exposed via a gameport can 
     *  use any string that PnP accepts.
     */

    AssertF( ( phdi->ptszId[0]  == TEXT('H') ) || ( phdi->ptszId[0] == TEXT('h') ) );
    AssertF( ( phdi->ptszId[1]  == TEXT('I') ) || ( phdi->ptszId[1] == TEXT('i') ) );
    AssertF( ( phdi->ptszId[2]  == TEXT('D') ) || ( phdi->ptszId[2] == TEXT('d') ) );


    /*
     *  Assert that a defined state and a valid VID/PID on entry must both be 
     *  true or both false (so we can use the state after getting VID/PID).
     */        
    if( ( phdi->ProductID != 0 ) && ( phdi->VendorID !=0 ) )
    {
        AssertF( *pState != DIHES_UNDEFINED );
    }
    else
    {
        AssertF( *pState == DIHES_UNDEFINED );
    }

    if( phdi->ptszId[3] == TEXT('\\') )
    {
        PTCHAR ptcSrc;
        PTCHAR ptDevId;

        ptcSrc = ptDevId = &phdi->ptszId[4];

        if( ( phdi->ProductID != 0 ) && ( phdi->VendorID !=0 ) )
        {
            int iLen;
            /*
             *  Create the key name from VID / PID (because it may be 
             *  different from the value derived from the device ID).
             */
            iLen = wsprintf(tszName, VID_PID_TEMPLATE, phdi->VendorID, phdi->ProductID);

            while( *ptcSrc != TEXT('\\') )
            {
                if( *ptcSrc == TEXT('\0') )
                {
                    break;
                }
                ptcSrc++;
            }

            if( ( *ptcSrc != TEXT('\0') )
             && ( ptcSrc != ptDevId ) )
            {
                ptszInstance = &tszName[iLen+2];
                lstrcpy( ptszInstance, ptcSrc+1 );
            }
        }
        else 
        {
            PTCHAR ptcDest;
            BOOL   fFirstAmpersand = FALSE;

            /*
             *  Copy the device ID (minus "HID\") so we can corrupt the copy.
             *  Convert to upper case and find the other slash on the way.
             *  Terminate the string at either the separator slash or a second 
             *  ampersand if one is found (VID_1234&PID_1234&COL_12 or REV_12).
             *  These are device IDs so we're only really interested in keeping 
             *  real VID\PID style IDs in upper case so we don't care if this 
             *  is imperfect for other cases as long as it is reproducable.
             */

            for( ptcDest = tszName; *ptcSrc != TEXT('\0'); ptcSrc++, ptcDest++ )
            {
                if( ( *ptcSrc >= TEXT('a') ) && ( *ptcSrc <= TEXT('z') ) )
                {
                    *ptcDest = *ptcSrc - ( TEXT('a') - TEXT('A') );
                }
                else if( *ptcSrc == TEXT('&') )
                {
                    if( ( ptszInstance != NULL )
                     || !fFirstAmpersand )
                    {
                        fFirstAmpersand = TRUE;
                        *ptcDest = TEXT('&');
                    }
                    else
                    {
                        *ptcDest = TEXT('\0');
                    }
                }
                else if( *ptcSrc != TEXT('\\' ) )
                {
                    *ptcDest = *ptcSrc;
                }
                else
                {
                    /*
                     *  Only one slash and not the first char
                     */
                    if( ( ptszInstance != NULL ) 
                     || ( ptcDest == tszName ) )
                    {
                        ptszInstance = NULL;
                        break;
                    }

                    /*
                     *  Separate the device ID and the instance
                     */
                    *ptcDest = TEXT('\0');
                    ptszInstance = ptcDest + 1;
                }
            }

            if( ptszInstance != NULL )
            {
#ifndef UNICODE
/*
 *  ISSUE-2001/02/06-MarcAnd  Should have a ParseVIDPIDA
 *  ParseVIDPID is going to convert this string back to ANSI ifndef UNICODE
 */
                WCHAR wszName[cbszVIDPID];
                AToU( wszName, cA(wszName), ptDevId );

                if( ( ptszInstance - tszName == cbszVIDPID )
                 && ( ParseVIDPID( &uVid, &uPid, wszName ) ) )
#else
                if( ( ptszInstance - tszName == cbszVIDPID )
                 && ( ParseVIDPID( &uVid, &uPid, ptDevId ) ) )
#endif
                {
                    phdi->VendorID  = uVid;
                    phdi->ProductID = uPid;
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%hs: ID %s, len %d not VID PID"), 
                                s_szProc, ptDevId, ptszInstance - tszName );
                }

                /*
                 *  Terminate the instance string
                 */
                *ptcDest = TEXT('\0');
            }
        }
    }
            
    if( ptszInstance == NULL )
    {
        hres = E_INVALIDARG;
        RPF( "Ignoring invalid device ID handle \"%s\" enumerated by system" );
    }
    else
    {
        //Open our own reg key under MediaProperties\DirectInput,
        //creating it if necessary.
        hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                               REGSTR_PATH_DITYPEPROP, 
                               DI_KEY_ALL_ACCESS, 
                               REG_OPTION_NON_VOLATILE, 
                               &hkDin);

        if( SUCCEEDED(hres) )
        {
            HKEY hkVidPid;
            hres = hresMumbleKeyEx(hkDin, 
                                   (LPTSTR)tszName, 
                                   DI_KEY_ALL_ACCESS, 
                                   REG_OPTION_NON_VOLATILE, 
                                   &hkVidPid);
        
            if( SUCCEEDED(hres) )
            {
                HKEY hkDevInsts;

                /*
                 *  Need to create user subkeys even if the device ID is not 
                 *  VID/PID as an auto-detect device could use the auto-detect 
                 *  HW ID for whatever device it detects.  
                 */

                //Create the key for Calibration
                HKEY hkCal;

                hres = hresMumbleKeyEx(hkVidPid, 
                                   TEXT("Calibration"), 
                                   DI_KEY_ALL_ACCESS, 
                                   REG_OPTION_NON_VOLATILE, 
                                   &hkCal);

                if (SUCCEEDED(hres))
                {
                    //Create the key for the instance (as the user sees it).
                    //For this, need to find out how many instances of the particular device
                    //we have already enumerated.
                    int ihdi;
                    int iNum = 0;
                    TCHAR tszInst[3];

                    for( ihdi = 0; ihdi < g_phdl->chdi; ihdi++)
                    {
                        if ((g_phdl->rghdi[ihdi].VendorID == phdi->VendorID) && (g_phdl->rghdi[ihdi].ProductID == phdi->ProductID))
                        {
                            iNum++;
                        }
                    }

                    wsprintf(tszInst, TEXT("%u"), iNum);

                    hres = hresMumbleKeyEx(hkCal, 
                                       tszInst, 
                                       DI_KEY_ALL_ACCESS, 
                                       REG_OPTION_NON_VOLATILE, 
                                       &phdi->hk);
                    if (SUCCEEDED(hres))
                    {
                        DIHid_GetInstanceGUID(phdi->hk, &phdi->guid);
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: RegCreateKeyEx failed on Instance reg key"),
                                    s_szProc);
                    }

                    RegCloseKey(hkCal);
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%hs: RegCreateKeyEx failed on Calibration reg key"),
                                s_szProc);
                }

                /*
                 *  Try to open the device (plug) instances to find out or 
                 *  update the staus of processing on this device but don't 
                 *  return any failures.
                 */
                if( SUCCEEDED( hresMumbleKeyEx(hkVidPid, 
                                       TEXT("DeviceInstances"), 
                                       DI_KEY_ALL_ACCESS, 
                                       REG_OPTION_NON_VOLATILE, 
                                       &hkDevInsts) ) )
                {
                    LONG lRc;

                    if( *pState == DIHES_UNDEFINED )
                    {
                        DWORD cb = cbX( *pState );

                        lRc = RegQueryValueEx( hkDevInsts,
                                    ptszInstance, 0, 0, pState, &cb );

                        if( lRc != ERROR_SUCCESS )
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: RegQueryValueEx failed (%d) to get state for instance %s"),
                                        s_szProc, lRc, ptszInstance );
                            /*
                             *  Make sure it was not trashed in the failure
                             */
                            *pState = DIHES_UNDEFINED;
                        }
                    }
                    else
                    {
                        lRc = RegSetValueEx( hkDevInsts,
                                    ptszInstance, 0, REG_BINARY, pState, cbX( *pState ) );

                        if( lRc != ERROR_SUCCESS)
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: RegSetValueEx failed (%d) to update state for instance %s"),
                                        s_szProc, lRc, ptszInstance );
                        }
                    }

                    RegCloseKey(hkDevInsts);
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%hs: Failed to open DeviceInstances key"),
                                s_szProc );
                }

                RegCloseKey(hkVidPid);
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%hs: RegCreateKeyEx failed on Device reg key"),
                                s_szProc);
            }

            RegCloseKey(hkDin);
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%hs: RegOpenKeyEx failed on DirectInput reg key"),
                                s_szProc);
        }
    }

    ExitOleProc();

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_GetDevInfo |
 *
 *          Get the HIDDEVICEINFO info from the device
 *
 *  @parm   HDEVINFO | hdev |
 *
 *          Device to get information
 *
 *  @parm   PSP_DEVICE_INTERFACE_DATA | pdid |
 *
 *          Describes the device
 *
 *  @parm   OUT PHIDDEVICEINFO | phdi |
 *
 *          HIDDEVICEINFO we need to collect
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

BOOL INTERNAL
    DIHid_GetDevInfo( HDEVINFO hdev, PSP_DEVICE_INTERFACE_DATA pdid, PHIDDEVICEINFO phdi )
{
    BOOL fRc = FALSE;
    SP_DEVINFO_DATA dinf;

    EnterProcI(DIHid_GetDevInfo, (_ "xpp", hdev, pdid, phdi));

    /*
     *  Open the registry key for the device so we can obtain
     *  auxiliary information.
     */

    dinf.cbSize = cbX(SP_DEVINFO_DATA);

    /*
     *  Get the instance GUID and the path to
     *  the HID device so we can talk to it.
     */
    if (DIHid_GetDevicePath(hdev, pdid, &phdi->pdidd, &dinf) &&
        DIHid_GetDeviceInstanceId(hdev, &dinf, &phdi->ptszId))
    {
        HANDLE  hf;
        TCHAR   tszName[MAX_PATH];
        ULONG   len = sizeof(tszName);
        BOOL    fCreateOK = FALSE;
        BYTE    bNewState = DIHES_UNDEFINED;
        BYTE    bPreviousState = DIHES_UNDEFINED;

        DIHid_CreateDeviceInstanceKeys( phdi, &bPreviousState );

        //////////////////// BEGIN OF PATCH ////////////////////////
        /*
         * This part is to keep the compatibility with Win2k Gold. 
         * Some driver, like Thrustmaster driver, tries to get Joystick ID
         * from old registry key: 
         *   HKLM\SYSTEM\CurrentControlSet\Control\DeviceClasses\{4d1e55b2-f16f-11cf-88cb-001111000030}\<?????????>\#\Device Parameters\DirectX
         * See Windows bug 395416 for detail.
         */
        {
            HKEY    hkDev;
            HRESULT hres;
    
            /*
             *  Open the registry key for the device so we can obtain
             *  auxiliary information, creating it if necessary.
             */
            hkDev = SetupDiCreateDeviceInterfaceRegKey(hdev, pdid, 0,
                                                   MAXIMUM_ALLOWED, NULL, NULL);
                                                   
            if(hkDev && hkDev != INVALID_HANDLE_VALUE)
            {
                hres = hresMumbleKeyEx(hkDev, 
                                   TEXT("DirectX"), 
                                   KEY_ALL_ACCESS, 
                                   REG_OPTION_NON_VOLATILE, 
                                   &phdi->hkOld);
                if(SUCCEEDED(hres) )
                {
                    LONG lRc;
                    
                    lRc = RegSetValueEx(phdi->hkOld, TEXT("GUID"), 0, REG_BINARY,
                            (PV)&phdi->guid, cbX(GUID));
                }
            }
        }
        /////////////////// END OF PATCH /////////////////////

        /*
         *  Before we CreateFile on the device, we need to make sure the 
         *  device is not in the middle of the setup process. If a device has 
         *  no device description it is probably still being setup (plugged 
         *  in) so delay opening it to avoid having an open handle on a device 
         *  that setup is trying to update.  If that happens, setup will prompt 
         *  the user to reboot to use the device.
         *  Since HIDs are "RAW" devices (don't need drivers) don't ignore 
         *  such a device forever.
         */
        if( CM_Get_DevNode_Registry_Property(dinf.DevInst,
                                             CM_DRP_DEVICEDESC,
                                             NULL,
                                             tszName,
                                             &len,
                                             0) == CR_SUCCESS) 
        {
            /*
             * Known device.
             */
            fCreateOK = TRUE;
            bNewState = DIHES_KNOWN;
        } 
        else 
        {
            /*
             *  Unknown device.  This either means that setup has not yet 
             *  completed processing the HID or that no device description 
             *  was set for the device where it matched.
             *
             *  For now, see if we've seen this device instance before.  
             *  If we have, then if it was previously unknown assume it's 
             *  going to stay that way and start using the device.  If it 
             *  was previously known or we've never seen it before wait for 
             *  a while in case setup is just taking it's time.
             *
             *  If the device was the last one we tried to remove, then it's 
             *  OK to open it while it's still showing up.  
             *  ISSUE-2001/02/06-MarcAnd  Opening removed devices
             *  I assume this is so we get a read failure when it really goes 
             *  away but I don't know how that's better than ignoring it.
             */
            /*
             *  ISSUE-2001/01/27-MarcAnd Should keep real list with status 
             *  We should keep a complete list of all the devices we know 
             *  about with status indicating things like "pending on 
             *  setup since X" or "removed" not these globals.
             */
            if( lstrcmpi(phdi->ptszId, g_tszIdLastRemoved) == 0 ) 
            {
                fCreateOK = TRUE;
                bNewState = bPreviousState;
            } 
            else 
            {
                if( bPreviousState == DIHES_UNKNOWN )
                {
                    /*
                     *  We've seen this device before and it was Unknown so 
                     *  don't expect that to change (as Setup does not retry 
                     *  the ID search through the INFs) so just use it.
                     */
                    fCreateOK = TRUE;
                    bNewState = DIHES_UNKNOWN;
                }
                else
                {
                    if( lstrcmpi(phdi->ptszId, g_tszIdLastUnknown) == 0 ) 
                    {
                        if( GetTickCount() - g_tmLastUnknown < MSREBUILDRATE ) 
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: DIHid_BuildHidListEntry: %s pending on setup."), 
                                        s_szProc, phdi->ptszId );
                            fRc = FALSE;
                        } 
                        else 
                        {
                            /*
                             *  Don't wait any longer but we'll need to update 
                             *  the state to "Unknown".
                             */
                            fCreateOK = TRUE;
                            bNewState = DIHES_UNKNOWN;
                            g_tszIdLastUnknown[0] = TEXT('0');
#ifdef XDEBUG
                            if( bPreviousState == DIHES_KNOWN )
                            {
                                SquirtSqflPtszV(sqfl | sqflBenign,
                                    TEXT("%hs: %s was known but is now unknown!"), 
                                    s_szProc, phdi->ptszId );
                            }
#endif
                        }
                    } 
                    else 
                    {
                        lstrcpy( g_tszIdLastUnknown, phdi->ptszId );
                        g_tmLastUnknown = GetTickCount();
                        fRc = FALSE;
                    }
                }
            }
        }

        if( fCreateOK ) 
        {
            /*
             *  bNewState should always have been set if OK to create
             */

            AssertF( bNewState != DIHES_UNDEFINED );
            /*
             *  Open the device so we can get its (real) usage page / usage.
             */
            hf = CreateFile(phdi->pdidd->DevicePath,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0,                /* no SECURITY_ATTRIBUTES */
                            OPEN_EXISTING,
                            0,                /* attributes */
                            0);               /* template */

            if(hf != INVALID_HANDLE_VALUE)
            {
                PHIDP_PREPARSED_DATA ppd;
                HIDD_ATTRIBUTES attr;

                if(HidD_GetPreparsedData(hf, &ppd))
                {
                    HIDP_CAPS caps;

                    if( SUCCEEDED(HidP_GetCaps(ppd, &caps)) )
                    {
                        DIHid_ParseUsagePage(phdi, &caps, ppd);
                        SquirtSqflPtszV(sqfl,
                                        TEXT("%hs: Have %s"),
                                        s_szProc, phdi->pdidd->DevicePath);
                        /*
                         *  ISSUE-2001/02/06-MarcAnd  Incorrect return possible
                         *  There's nothing to reset this to false if any of 
                         *  the following code fails.
                         */
                        fRc = TRUE;
                    }

                    HidD_FreePreparsedData(ppd);

                } 
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: GetPreparsedData(%s) failed"),
                                    s_szProc, phdi->pdidd->DevicePath);
                }

                attr.Size = cbX(attr);
                if( HidD_GetAttributes(hf, &attr) )
                {
                    if( ( phdi->ProductID != attr.ProductID )
                     || ( phdi->VendorID != attr.VendorID ) )
                    {
                        SquirtSqflPtszV(sqfl | sqflBenign,
                            TEXT("%hs: Device changed from VID_%04X&PID_%04X to VID_%04X&PID_%04X"),
                            s_szProc, phdi->ProductID, phdi->VendorID, attr.ProductID, attr.VendorID);

                        phdi->ProductID = attr.ProductID;
                        phdi->VendorID = attr.VendorID;

                        /*
                         *  Make sure we update the registry.
                         */
                        bPreviousState = DIHES_UNDEFINED;
                    }

                    if( bPreviousState != bNewState )
                    {
                        DIHid_CreateDeviceInstanceKeys( phdi, &bNewState );
                    }
                } 
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: HidD_GetAttributes(%s) failed"),
                                    s_szProc, phdi->pdidd->DevicePath);
                }

                DICreateStaticGuid(&phdi->guidProduct, attr.ProductID, attr.VendorID); 

                CloseHandle(hf);

            } 
            else
            {
    
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%hs: CreateFile(%s) failed? le=%d"),
                                 s_szProc, phdi->pdidd->DevicePath, GetLastError());
            }
        }


#ifndef WINNT
            /*
             * The following part is to resolve the swap id probleom in OSR.
             * If a USB joystick is not in the lowest available id, after unplug and replug,
             * VJOYD will sign the same joystick at the lowest available id, but DINPUT still
             * remember its last id. To resolve this confliction, we need this code.
             */
             
            {
                VXDINITPARMS vip;
                CHAR sz[MAX_PATH];
                LPSTR pszPath;
                BOOL fFindIt = FALSE;

                for( phdi->idJoy = 0; phdi->idJoy < cJoyMax; phdi->idJoy++ )
                {
                    pszPath = JoyReg_JoyIdToDeviceInterface_95(phdi->idJoy, &vip, sz);
                    if(pszPath)
                    {
                        if( lstrcmpiA(pszPath, (PCHAR)phdi->pdidd->DevicePath) == 0x0 ) {
                            fFindIt = TRUE;
                            break;
                        }
                    }
                }

                if( fFindIt ) {
                    
                    if( phdi->hk != 0x0 )
                    {
                        DWORD cb;
                        BOOL  fRtn;

                        cb =  cbX(phdi->idJoy);

                        fRtn = RegSetValueEx(phdi->hk, TEXT("Joystick Id"), 0, 0, (PV)&phdi->idJoy, cb );

                        if( !fRtn ) 
                        {
                            // don't worry
                        }
                    }
                } else 
                {
                    //  Post Dx7 Patch. Win9x only
                    // Gravis has gone and created a vjoyd mini driver for their
                    // USB gamepad. Their driver replaces joyhid, but does not inform
                    // vjoyd about the HID path. So 2 instances of the same device show
                    // up in the CPL.
                    // This fix is to make a HID device that does not have a matching
                    // joyhid entry as being non Joystick.

                    /*
                     *  Post DX7a!  Only do this for game controllers
                     *  Assert the device types in case they get changed
                     *  Note they are changed in DX8 but the new types are 
                     *  only to be used by DX8 so these assertions should
                     *  be sufficient.
                     */
                    CAssertF( DIDEVTYPE_DEVICE == 1 );
                    CAssertF( DIDEVTYPE_JOYSTICK == 4 );
                    if( GET_DIDEVICE_TYPE( phdi->osd.dwDevType ) == DIDEVTYPE_JOYSTICK )
                    {
                        /*
                         *  Change type from joystick to device
                         */
                        phdi->osd.dwDevType ^= DIDEVTYPE_JOYSTICK | DIDEVTYPE_DEVICE;
                    }
                    /*
                     *  Set to the invalid id anyway
                     */
                    phdi->idJoy = -1;
                }
            }
#else
        // Executed only on WINNT
        if( phdi->hk != 0x0 )
        {
            DWORD cb;

            cb =  cbX(phdi->idJoy);

            if( RegQueryValueEx(phdi->hk, TEXT("Joystick Id"),
                   0, 0, (PV)&phdi->idJoy, &cb ) != ERROR_SUCCESS )
            {
                phdi->idJoy = JOY_BOGUSID;
            }
        }
#endif // WINNT
    } 
    else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%hs: Unable to get GUID or device path"),
                        s_szProc);
    }


    /*
     *  If we failed, then free the goo we already got.
     */
    if(!fRc)
    {
        if( phdi->hk ) 
        {
            RegCloseKey(phdi->hk);
        }
        phdi->hk = 0;
        FreePpv(&phdi->pdidd);
        FreePpv(&phdi->ptszId);
    }

    ExitProcF(fRc);

    return fRc;
}

#undef DIHES_UNDEFINED
#undef DIHES_UNKNOWN
#undef DIHES_KNOWN


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_BuildHidListEntry |
 *
 *          Builds a single entry in the list of HID devices.
 *
 *  @parm   HDEVINFO | hdev |
 *
 *          Device list being enumerated.
 *
 *  @parm   PSP_DEVICE_INTERFACE_DATA | pdid |
 *
 *          Describes the device that was enumerated.
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

BOOL INTERNAL
    DIHid_BuildHidListEntry(HDEVINFO hdev, PSP_DEVICE_INTERFACE_DATA pdid)
{
    BOOL            fRc = TRUE;
    BOOL            fAlreadyExist = FALSE;
    PHIDDEVICEINFO  phdi;
    HIDDEVICEINFO   hdi;

    EnterProcI(DIHid_BuildHidListEntry, (_ "xp", hdev, pdid));


    if(g_phdl)
    {
        PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;

        /* GetDevicePath is expecting a NULL */
        pdidd = NULL;
        if( DIHid_GetDevicePath(hdev, pdid, &pdidd, NULL) )
        {
            PHIDDEVICEINFO  phdi;
            int ihdi;
            
            //Check whether the device has been in the list
            for(ihdi = 0, phdi = g_phdl->rghdi; 
                ihdi < g_phdl->chdi;
                ihdi++, phdi++)
            {
                if( phdi->pdidd )
                {
                    if( lstrcmp( pdidd->DevicePath, phdi->pdidd->DevicePath ) == 0 )
                    {
                        //already in the list
                        fAlreadyExist = TRUE;

                      #ifdef WINNT
                        // id may be changed, so refresh here. 
                        // See Windows bug 321711. -qzheng
                        if( phdi->hk != 0x0 )
                        {
                            DWORD cb;
                            cb =  cbX(phdi->idJoy);

                            if( RegQueryValueEx(phdi->hk, TEXT("Joystick Id"),
                                                0, 0, (PV)&phdi->idJoy, &cb ) != ERROR_SUCCESS )
                            {
                                phdi->idJoy = JOY_BOGUSID;
                            }
                        }
                      #endif

                        SquirtSqflPtszV(sqfl | sqflTrace,
                                        TEXT("%hs: Device %s Already Exists in HID List "), s_szProc, pdidd->DevicePath);
                        break;      
                    }
                }
            }
            FreePpv(&pdidd);
        }

        if( fAlreadyExist )
        {
            //device is already there, needn't do anything, just leave
        } else 
        {
            PBUSDEVICEINFO pbdi;

            // prefix 29343
            if( g_phdl!= NULL  && g_phdl->chdi >= g_phdl->chdiAlloc )
            {
                /*
                 *  Make sure there is room for this device in the list.
                 *  Grow by doubling. 
                 */

                HRESULT hres;
                hres = ReallocCbPpv(cbHdlChdi(g_phdl->chdiAlloc * 2), &g_phdl);

                if(FAILED(hres))
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: Realloc failed"), s_szProc);

                    fRc = FALSE;
                    goto done;
                }

                g_phdl->chdiAlloc *= 2;
            }

            phdi = &g_phdl->rghdi[g_phdl->chdi];

            memset( &hdi, 0, sizeof(hdi) );

            if( DIHid_GetDevInfo(hdev, pdid, &hdi) )
            {
                hdi.fAttached = TRUE;
            
                pbdi = pbdiFromphdi(&hdi);
                if( pbdi != NULL )
                {

                    /*
                     * If the devices is just being removed, and PnP is working on the
                     * removing, then we won't include it in our list.
                     */
                    if( lstrcmpi(pbdi->ptszId, g_tszIdLastRemoved) == 0 &&
                        GetTickCount() - g_tmLastRemoved < MSREBUILDRATE_FIFTH ) 
                    {
                        SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: DIHid_BuildHidListEntry: %s pending on removal."), 
                                        s_szProc, pbdi->ptszId );
                        
                        fRc = FALSE;
                    } else {
                        BUS_REGDATA RegData;
                        
                        memcpy( phdi, &hdi, sizeof(hdi) );
                        g_phdl->chdi++;

                        if( SUCCEEDED(DIBusDevice_GetRegData(pbdi->hk, &RegData)) )
                        {
                            RegData.fAttachOnReboot = TRUE;
                            DIBusDevice_SetRegData(pbdi->hk, &RegData);
                        }
                    }
                } else {
                    memcpy( phdi, &hdi, sizeof(hdi) );
                    g_phdl->chdi++;
                }
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%hs: DIHid_GetDevInfo failed error %d, ignoring device"), 
                                s_szProc, GetLastError() );
                fRc = FALSE;
            }
        }
    }    // end of if(g_phdl)

done:

    ExitProcF(fRc);

    return fRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_BuildHidList |
 *
 *          Builds the list of HID devices.
 *
 *  @parm   BOOL | fForce |
 *
 *          If nonzero, we force a rebuild of the HID list.
 *          Otherwise, we rebuild only if the list hasn't
 *          been rebuilt recently.
 *
 *****************************************************************************/

void EXTERNAL
    DIHid_BuildHidList(BOOL fForce)
{
    HRESULT hres;
    DWORD   dwTick;
    
    EnterProcI(DIHid_BuildHidList, (_ "u", fForce));

    DllEnterCrit();

    // Force implies a complete rebuild of the list
    // No hanging onto old entries. 
    if( fForce )
    {
        DIHid_EmptyHidList();
    }

    //ISSUE-2001/03/29-timgill Meltdown code change may be unnecessary
    dwTick = GetTickCount();
    
    if(!(g_flEmulation & 0x80000000) &&        /* Not disabled by emulation */
       HidD_GetHidGuid &&                      /* HID actually exists */
       (fForce ||                              /* Forcing rebuild, or */
        g_tmLastHIDRebuild == 0 ||             /* Never built before, or */
        dwTick - g_tmLastHIDRebuild > MSREBUILDRATE  /* Haven't rebuilt in a while */
      #ifdef WINNT
        || dwTick - Excl_GetConfigChangedTime() < MSREBUILDRATE  /* joyConfig is just changed. */
      #endif
       ))
    {
        GUID guidHid;
        HDEVINFO hdev;

        HidD_GetHidGuid(&guidHid);

        hdev = SetupDiGetClassDevs(&guidHid, 0, 0,
                                   DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
        if(hdev != INVALID_HANDLE_VALUE)
        {
            DIHid_CheckHidList();

            /*
             *  There is no way to query the number of devices.
             *  You just have to keep incrementing until you run out.
             *
             *  If we already have a g_phdl, then re-use it.  Else, create
             *  a new one.  But always realloc up to the minimum starting
             *  point.  (This upward realloc is important in case there
             *  were no HID devices the last time we checked.)
             */

            if( !g_phdl )
            {
                hres = AllocCbPpv(cbHdlChdi(chdiInit), &g_phdl);

                if(SUCCEEDED(hres))
                {
                    g_phdl->chdi = 0;
                    g_phdl->chdiAlloc = chdiInit;
                } else
                {
                    /* Skip erroneous items */
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("DIHid_BuildHidListEntry ")
                                    TEXT("Realloc g_phdl fails."));
                }
            } else
                hres = S_OK;


            if(SUCCEEDED(hres))
            {
                int idev;

                /*
                 *  To avoid infinite looping on
                 *  internal error, break on any
                 *  error once we have tried more than
                 *  chdiMax devices, since that's the most
                 *  HID will ever give us.
                 */
                for(idev = 0; idev < chdiMax; idev++)
                {
                    SP_DEVICE_INTERFACE_DATA did;

                    AssertF(g_phdl->chdi <= g_phdl->chdiAlloc);

                    /* 
                     *  SetupDI requires that the caller initialize cbSize.
                     */
                    did.cbSize = cbX(did);
                    if(SetupDiEnumDeviceInterfaces(hdev, 0, &guidHid,
                                                   idev, &did))
                    {
                        if(DIHid_BuildHidListEntry(hdev, &did))
                        {
                        } else
                        {
                            /* Skip erroneous items */
                            SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("DIHid_BuildHidListEntry ")
                                            TEXT("failed?"));
                        }

                    } else

                        if(GetLastError() == ERROR_NO_MORE_ITEMS)
                    {
                        break;

                    } else
                    {
                        /* Skip erroneous items */
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("SetupDiEnumDeviceInterface ")
                                        TEXT("failed? le=%d"), GetLastError());
                    }

                }

            }

            SetupDiDestroyDeviceInfoList(hdev);
        
        }

      #ifdef WINNT
        if( g_phdl && g_phdl->chdi )
        {
            DIWdm_InitJoyId();
        }
      #endif
      
        g_tmLastHIDRebuild = GetTickCount();

    }

    DllLeaveCrit();

    ExitProc();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx7\dll\dihidini.c ===
/*****************************************************************************
 *
 *  DIHidIni.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The initialization-related functions of the HID device callback.
 *
 *      All the HID support is getting kind of bulky, so I've broken
 *      it out into submodules.
 *
 *  Contents:
 *
 *      CHid_Init
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHidIni

#ifdef HID_SUPPORT

/*****************************************************************************
 *
 *      Hid devices are totally arbitrary, so there is nothing static we
 *      can cook up to describe them.  We generate all the information on
 *      the fly.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | CHid_LoadCalibrations |
 *
 *          Load calibration information from the registry (or wherever).
 *          This is done when the device is created, and whenever we
 *          receive a recalibration message.
 *
 *  @returns
 *
 *          Returns the number of axes we calibrated.  This information
 *          is used during device initialization to see if we need to
 *          worry about calibration in the future.
 *
 *****************************************************************************/

UINT EXTERNAL
    CHid_LoadCalibrations(PCHID this)
{
    UINT uiObj;
    UINT uiRc = 0;

    /*
     *  Preinitialize the HIDP_DATA indices to -1 to indicate
     *  that they aren't there.  We must do this before we
     *  mess with AddDeviceData, which assumes that all the
     *  indices are properly set up.
     */
    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        PJOYRANGECONVERT pjrc = this->rghoc[uiObj].pjrc;
        PHIDGROUPCAPS pcaps = this->rghoc[uiObj].pcaps;
        if(pjrc && pcaps)
        {
            LPDIOBJECTDATAFORMAT podf = &this->df.rgodf[uiObj];
            DIOBJECTCALIBRATION cal;
          #ifdef WINNT
            DIPOVCALIBRATION pov;
          #endif
            D(LPCTSTR ptszWhence;)
            HRESULT hres;
            HKEY hk;

            D( ptszWhence = TEXT("unknown") );
            
            if( fWinnt
                || ( this->idJoy < 0 ) //See manbug 50591

                /*
                 * Whenever we use winmm calibraion page in Win9x,
                 * we should comment out this line.
                 *
                 * || SUCCEEDED( JoyReg_IsWdmGameport(this->hkType) )
                 */
            ) 
            {
              #ifdef WINNT
                if( podf->dwType & DIDFT_POV )
                {
                    if( pcaps->IsPolledPOV )  {
                        ZeroX( pov );
                        hres = CType_OpenIdSubkey(this->hkInstType, podf->dwType,
                                              KEY_QUERY_VALUE, &hk);
                        if(SUCCEEDED(hres))
                        {
                             hres = JoyReg_GetValue(hk, TEXT("Calibration"),
                                                   REG_BINARY, &pov,
                                                   cbX(DIPOVCALIBRATION));
                            RegCloseKey(hk);
                        }
                    }
                } else
              #endif
                {
                    ZeroX( cal );

                    hres = CType_OpenIdSubkey(this->hkInstType, podf->dwType,
                                              KEY_QUERY_VALUE, &hk);

                    if(SUCCEEDED(hres))
                    {
                        hres = JoyReg_GetValue(hk, TEXT("Calibration"),
                                               REG_BINARY, &cal,
                                               cbX(DIOBJECTCALIBRATION));
                        RegCloseKey(hk);
                    }

                    /*
                     *  If there is no calibration data, then create
                     *  some defaults based on the logical min/max.
                     */
                    if(FAILED(hres))
                    {
                        /*
                         *  But only if the logical min/max is sane!
                         */
                        if(pcaps->Logical.Min < pcaps->Logical.Max)
                        {
                            cal.lMin = pcaps->Logical.Min;
                            /*
                             *  HACKHACK
                             *  The analog joystick driver cannot report the true
                             *  range of the device, so to keep the sample driver
                             *  pure, it reports a range of zero to the point at
                             *  which it would consider the axis absent.  This is
                             *  good in terms of reporting healthy HID data but
                             *  it means that any normal joystick will only return
                             *  values in a fraction of this range.  So if this
                             *  device is an analog device default the calibration
                             *  to the typical range.
                             */
                            if( ( this->VendorID == MSFT_SYSTEM_VID )
                              &&( ( this->ProductID & 0xff00 ) == MSFT_SYSTEM_PID ) )
                            {
                                /*
                                 *  To be extra safe, compute the max from the
                                 *  reported range.  The divisor is a fudge factor
                                 *  derived by what looked about right to MarcAnd.
                                 */
                                cal.lMax = pcaps->Logical.Min +
                                    ( ( pcaps->Logical.Max - pcaps->Logical.Min ) / 11 );
                                D(ptszWhence = TEXT("log (adj)"));
                            }
                            else
                            {
                                cal.lMax = pcaps->Logical.Max;
                                D(ptszWhence = TEXT("log"));
                            }
                        } else
                        {
                            D(ptszWhence = TEXT("def"));
                            cal.lMin = 0;
                            cal.lMax = 655;
                        }
                        cal.lCenter = CCal_Midpoint(cal.lMin, cal.lMax);
                    } else
                    {
                        D(ptszWhence = TEXT("reg"));
                    }
                }
            }
            else {
                ZeroX( cal );

                /*
                 * For Win9x OSR update only.
                 * Because the CPL on Win9x only updates calibration in MediaResources,
                 * We need read that calibration information and update for HID.
                 */
                CHid_UpdateCalibrationFromVjoyd(this, uiObj, &cal);

                D(ptszWhence = TEXT("WinMM Reg"));
            }

          #ifdef WINNT
            if( podf->dwType & DIDFT_POV )
            {
                if( pcaps->IsPolledPOV )  {
                    memcpy( pjrc->lMinPOV, pov.lMin, cbX(pjrc->lMinPOV) );
                    memcpy( pjrc->lMaxPOV, pov.lMax, cbX(pjrc->lMaxPOV) );
                }
            } else 
          #endif
            {
                D(SquirtSqflPtszV(sqflHidParse,
                                  TEXT(" Calibration(%d) %s %d..%d..%d"),
                                  CHid_ObjFromType(this, podf->dwType), ptszWhence,
                                  cal.lMin, cal.lCenter, cal.lMax));
    
                /*
                 *  Saturation always defaults to 100%.
                 */
                pjrc->dwPmin = cal.lMin;
                pjrc->dwPmax = cal.lMax;
                pjrc->dwPc   = cal.lCenter;
    
                CCal_RecalcRange(pjrc);
    
                uiRc++;
            }
        }
    }

    return uiRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CHid_SortCaps |
 *
 *          Sort the capabilities by Data Index.  This is important
 *          so that the items are assigned numbers in the same order
 *          by both DirectInput and HID.
 *
 *          Note that we exploit the not-exactly-a-coincidence
 *          that a <t HIDP_VALUE_CAPS> and a
 *          <t HIDP_BUTTON_CAPS> are identical wherever they overlap.
 *
 *  @parm   PV | rgv |
 *
 *          Array of either <t HIDP_VALUE_CAPS> or <t HIDP_BUTTON_CAPS>
 *          structures.
 *
 *  @parm   UINT | cv |
 *
 *          Number of structures that need to be sorted.
 *
 *****************************************************************************/

void INTERNAL
    CHid_SortCaps(PV rgv, UINT cv)
{
    /*
     *  For concreteness, we use HIDP_VALUE_CAPS.
     */
    PHIDP_VALUE_CAPS rgvcaps = rgv;
    UINT ivcaps;

    /*
     *  There are several non-coincidences which we exploit.
     *
     *  HIDP_VALUE_CAPS and HIDP_BUTTON_CAPS are the same size.
     *
     *  HIDP_VALUE_CAPS.Range.DataIndexMin,
     *  HIDP_VALUE_CAPS.NotRange.DataIndex,
     *  HIDP_BUTTON_CAPS.Range.DataIndexMin, and
     *  HIDP_BUTTON_CAPS.NotRange.DataIndex are all at the same offset.
     */
    CAssertF(cbX(HIDP_VALUE_CAPS) == cbX(HIDP_BUTTON_CAPS));

    /*
     *  For some reason, the compiler doesn't think that these
     *  expressions are constant so I can't use CAssertF.
     */
    AssertF(FIELD_OFFSET(HIDP_VALUE_CAPS,  NotRange.DataIndex) ==
            FIELD_OFFSET(HIDP_VALUE_CAPS,     Range.DataIndexMin));
    AssertF(FIELD_OFFSET(HIDP_VALUE_CAPS,     Range.DataIndexMin) ==
            FIELD_OFFSET(HIDP_BUTTON_CAPS,    Range.DataIndexMin));
    AssertF(FIELD_OFFSET(HIDP_BUTTON_CAPS,    Range.DataIndexMin) ==
            FIELD_OFFSET(HIDP_BUTTON_CAPS, NotRange.DataIndex));

    #ifdef REALLY_ANNOYING
    /*
     *  Dump the Before list.
     */
    for(ivcaps = 0; ivcaps < cv; ivcaps++)
    {
        SquirtSqflPtszV(sqflHidParse,
                        TEXT("HidP_SortCaps:%2d = %04x"),
                        ivcaps, rgvcaps[ivcaps].Range.DataIndexMin);
    }
    #endif

    /*
     *  Since there are typically not very many caps, we will use
     *  a simple insertion sort.
     *
     *  Note if caps entries have the same data index they are
     *  aliases.  Make sure the primary alias will be the first
     *  in the sorted list.
     */

    for(ivcaps = 1; ivcaps < cv; ivcaps++)
    {
        int ivcapsT;
        HIDP_VALUE_CAPS vcaps = rgvcaps[ivcaps];

        ivcapsT = ivcaps;
        while( ( --ivcapsT >= 0 )
             &&( ( rgvcaps[ivcapsT].Range.DataIndexMin >
                   vcaps.Range.DataIndexMin )
               ||( ( rgvcaps[ivcapsT].Range.DataIndexMin ==
                     vcaps.Range.DataIndexMin )
                 &&( rgvcaps[ivcapsT].IsAlias ) ) ) )
        {
            rgvcaps[ivcapsT+1] = rgvcaps[ivcapsT];
        }
        rgvcaps[ivcapsT+1] = vcaps;
    }

    #ifdef REALLY_ANNOYING
    /*
     *  Dump the After list.
     */
    for(ivcaps = 0; ivcaps < cv; ivcaps++)
    {
        SquirtSqflPtszV(sqflHidParse,
                        TEXT("HidP_SortCaps:%2d = %04x"),
                        ivcaps, rgvcaps[ivcaps].Range.DataIndexMin);
    }
    #endif

    /*
     *  Assert that everything is weakly monotonically sorted.
     *
     *  If two items are equal, then it means that HID messed up
     *  or the values are aliases.
     *  We don't complain about it here; we will notice later.
     */
    for(ivcaps = 1; ivcaps < cv; ivcaps++)
    {
        AssertF(rgvcaps[ivcaps-1].Range.DataIndexMin <=
                rgvcaps[ivcaps  ].Range.DataIndexMin);
    }
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CHid_FindAspect |
 *
 *          Try to determine the aspect flags for this value.
 *
 *  @parm   PHIDP_VALUE_CAPS | pvcaps |
 *
 *          Pointer to HID value caps to search through
 *          structures.
 *
 *  @returns
 *
 *          Flags set for the aspect if found
 *
 *  @comm
 *          Currently (08-Dec-98) most devices and drivers do not
 *          declare units but since drivers must use the generic
 *          position usages in order to be recognized assume that
 *          these imply that position data is being returned.
 *
 *****************************************************************************/
DWORD CHID_FindAspect
(
    PHIDP_VALUE_CAPS    pvcaps
)
{
    DWORD               dwAspect = 0;

    if( pvcaps->Units )
    {
#define HID_UNIT_SYSTEM_MASK        0x0000000fL
#define HID_UNIT_LENGTH_MASK        0x000000f0L
#define HID_UNIT_MASS_MASK          0x00000f00L
#define HID_UNIT_TIME_MASK          0x0000f000L
        /*
         *  If available, use the units to derive the DI aspect
         *  flags for input objects.
         */

        if( pvcaps->Units & ~( HID_UNIT_SYSTEM_MASK
                             | HID_UNIT_LENGTH_MASK
                             | HID_UNIT_MASS_MASK
                             | HID_UNIT_TIME_MASK ) )
        {
            SquirtSqflPtszV(sqflTrace | sqflHidParse,
                            TEXT("Unit 0x%08x contains basic units that cannot be translated to aspects"),
                            pvcaps->Units );
        }
        else
        {
            /*
             *  The system of measurement should be one of the
             *  four defined systems and the length must be one
             *  dimensional.
             */
            if( ( ( pvcaps->Units & ( HID_UNIT_SYSTEM_MASK | HID_UNIT_LENGTH_MASK ) ) >= 0x11 )
              &&( ( pvcaps->Units & ( HID_UNIT_SYSTEM_MASK | HID_UNIT_LENGTH_MASK ) ) <= 0x14 ) )
            {
                switch( pvcaps->Units & ( HID_UNIT_TIME_MASK | HID_UNIT_MASS_MASK ) )
                {
                case 0x0000:
                    dwAspect = DIDOI_ASPECTPOSITION;
                    break;
                case 0xf000:
                    dwAspect = DIDOI_ASPECTVELOCITY;
                    break;
                case 0xe000:
                    dwAspect = DIDOI_ASPECTACCEL;
                    break;
                case 0xe100:
                    dwAspect = DIDOI_ASPECTFORCE;
                    break;
                default:
                    if( 0x0004 == ( pvcaps->Units & ( HID_UNIT_TIME_MASK | HID_UNIT_MASS_MASK | HID_UNIT_SYSTEM_MASK ) ) )
                    {
                        SquirtSqflPtszV(sqflTrace | sqflHidParse,
                            TEXT("Unit \"degrees\" will not be mapped to a DI aspect (probably a POV)") );
                    }
                    else
                    {
                        SquirtSqflPtszV(sqflTrace | sqflHidParse,
                                        TEXT("Unit 0x%04x represents a mass/time unit that cannot be translated to aspects"),
                                        pvcaps->Units );
                    }
                }
            }
            else
            {
                SquirtSqflPtszV(sqflTrace | sqflHidParse,
                                TEXT("Unit 0x%04x contains represents a length/system unit that cannot be translated to aspects"),
                                pvcaps->Units );
            }
        }

#ifdef DEBUG
        if( dwAspect )
        {
            SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                            TEXT("Unit 0x%04x translated to aspect 0x%04x"),
                            pvcaps->Units, dwAspect );
        }
#endif

#undef HID_UNIT_SYSTEM_MASK
#undef HID_UNIT_LENGTH_MASK
#undef HID_UNIT_MASS_MASK
#undef HID_UNIT_TIME_MASK

    }
    else
    {
        PHIDUSAGEMAP phum;

        phum = UsageToUsageMap( DIMAKEUSAGEDWORD( pvcaps->UsagePage,
                                                     pvcaps->Range.UsageMin ) );

        if( phum && phum->uiPosAxis <= 6 )
        {
            phum = UsageToUsageMap( DIMAKEUSAGEDWORD( pvcaps->UsagePage,
                                                         pvcaps->Range.UsageMax ) );

            if( phum && phum->uiPosAxis <= 6 )
            {
                dwAspect = DIDOI_ASPECTPOSITION;
            }
        }
        else
        {
            SquirtSqflPtszV(sqflTrace | sqflHidParse,
                            TEXT("No aspect found for 0x%04x page usage 0x%04x-0x%04x"),
                            pvcaps->UsagePage, pvcaps->Range.UsageMin, pvcaps->Range.UsageMax );
        }

#ifdef DEBUG
        if( dwAspect )
        {
            SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                            TEXT("Usage (page:min-max) 0x%04x:0x%04x-0x%04x translated to aspect 0x%04x"),
                            pvcaps->UsagePage, pvcaps->Range.UsageMin, pvcaps->Range.UsageMax, dwAspect );
        }
#endif

    }

    return dwAspect;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitAxisClass |
 *
 *          Initialize one class (input, feature, output) of axes.
 *
 *  @parm   PHIDGROUPCAPS | rgcaps |
 *
 *          Array of <t HIDGROUPCAPS> structures to receive the caps
 *          of the axes in the class.
 *
 *  @parm   USHORT | ccaps |
 *
 *          Number of <t HIDGROUPCAPS> structures we expect to find.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          One of the values
 *          <c HidP_Input>,
 *          <c HidP_Feature> or
 *          <c HidP_Output>.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitAxisClass(PCHID this, PHIDGROUPCAPS rgcaps, USHORT ccaps,
                       HIDP_REPORT_TYPE type)
{
    USHORT cvcaps;
    NTSTATUS stat;
    HRESULT hres;
    DWORD ivcaps;
    LONG lSignedMask;
    PHIDP_VALUE_CAPS rgvcaps;

    AssertF(rgcaps >= this->rgcaps);
    AssertF(rgcaps + ccaps <= &this->rgcaps[this->ccaps]);

    /*
     *  Annoying quirk:
     *
     *  HID doesn't like it when you pass 0 to HidP_GetValueCaps,
     *  so we need to special-case the "no axes" scenario.
     */
    if(ccaps == 0)
    {
        hres = S_OK;
        goto done;
    }

    hres = AllocCbPpv(cbCxX(ccaps, HIDP_VALUE_CAPS), &rgvcaps);
    if(FAILED(hres))
    {
        goto done;
    }

    cvcaps = ccaps;
    stat = HidP_GetValueCaps(type, rgvcaps, &cvcaps, this->ppd);
    if(FAILED(stat))
    {
        RPF("HidP_GetValueCaps failed - can't use device");
        hres = E_FAIL;
        goto freedone;
    }

    if(cvcaps != ccaps)
    {
        RPF("HidP_GetValueCaps inconsistent with HidP_GetCaps - "
            "can't use device");
        hres = E_FAIL;
        goto freedone;
    }

    CHid_SortCaps(rgvcaps, cvcaps);


    for(ivcaps = 0; ivcaps < cvcaps; ivcaps++)
    {
        PHIDP_VALUE_CAPS pvcaps = &rgvcaps[ivcaps];
        PHIDGROUPCAPS pcaps = &rgcaps[ivcaps];
        BOOL fPOV;
        UINT uiObj;
        UINT duiObj;
        DWORD dwAspect;

        /*
         *  ISSUE-2001/03/06-MarcAnd Ignoring report count
         *  We ignore the report count which may be bad, need 
         *  to test device with values declared in a range to see what HID 
         *  really gives us.
         *  At the descriptor level, values can be delared in a range with 
         *  usages and the last usage is repeated for any excess values.  
         */
        if(pvcaps->IsRange)
        {
            if(pvcaps->Range.DataIndexMax - pvcaps->Range.DataIndexMin !=
               pvcaps->Range.UsageMax - pvcaps->Range.UsageMin)
            {
                RPF("HidP_GetValueCaps corrupted VALUE_CAPS - "
                    "can't use device");
                hres = E_FAIL;
                goto freedone;
            }

        } else
        {
            pvcaps->Range.UsageMax = pvcaps->Range.UsageMin;
        }

        if( ( type == HidP_Input ) && !pvcaps->IsAlias )
        {
            /*
             *  The values are sorted by data index with the primary alias
             *  before any other.  So find out the aspect of the axis each
             *  time we get a new primary and use it for any alias that follow.
             */
            dwAspect = CHID_FindAspect( pvcaps );
        }

        pcaps->wReportId          = pvcaps->ReportID;
        this->wMaxReportId[type]  = max(pcaps->wReportId, this->wMaxReportId[type]);

        pcaps->UsagePage          = pvcaps->UsagePage;
        pcaps->UsageMin           = pvcaps->Range.UsageMin;
        pcaps->DataIndexMin       = pvcaps->Range.DataIndexMin;

        pcaps->cObj               = pvcaps->Range.UsageMax -
                                    pvcaps->Range.UsageMin + 1;

        /*
         *  The mask consists of the top bit of the BitSize and
         *  all bits above it.  Examples:
         *
         *           BitSize                     8              32
         *           BitSize - 1                 7              31
         *     1 << (BitSize - 1)       0x00000080      0x80000000
         *    (1 << (BitSize - 1)) - 1  0x0000007F      0x7FFFFFFF
         *  ~((1 << (BitSize - 1)) - 1) 0xFFFFFF80      0x80000000
         *
         */

        pcaps->BitSize            = pvcaps->BitSize;
        pcaps->lMask              = ~((1 << (pcaps->BitSize - 1)) - 1);
        lSignedMask               =  max( 1, ( 1 << pcaps->BitSize) -1 );


        pcaps->LinkCollection     = pvcaps->LinkCollection;
        pcaps->Units              = pvcaps->Units;
        pcaps->Exponent           = LOWORD(pvcaps->UnitsExp);

        pcaps->Logical.Min        = pvcaps->LogicalMin;
        pcaps->Logical.Max        = pvcaps->LogicalMax;

        pcaps->Physical.Min       = pvcaps->PhysicalMin;
        pcaps->Physical.Max       = pvcaps->PhysicalMax;

        if(pcaps->Logical.Min >= pcaps->Logical.Max)
        {
            RPF("HidP_GetValueCaps Logical Min >= Logical Max - ");

            if( pcaps->Physical.Min < pcaps->Physical.Max )
            {
                pcaps->Logical = pcaps->Physical;
            } else
            {
                pcaps->Logical.Min = pcaps->lMask;
                pcaps->Logical.Max = ~pcaps->lMask;
            }

            SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                            TEXT("HidP_GetValueCaps:")
                            TEXT("Logical Min(was:%d now:%d)")
                            TEXT("Logical Max(was:%d now:%d)"),
                            pvcaps->LogicalMin, pcaps->Logical.Min,
                            pvcaps->LogicalMax, pcaps->Logical.Max);

        }

        /*
         *  the range for LogicalMin / LogicalMax had better fall
         *  within the range of values the device can possibly
         *  report.
         *
         *  The lMask value happens also to be the smallest possible
         *  negative value, and the bitwise negation of it happens
         *  to be the largest possible positive value.  The wonders
         *  of two-s complement arithmetic.
         */

        /*
         *  Extra case is fix for 268519
         */
        if(pcaps->Physical.Min > pcaps->Physical.Max)
        {
            RPF("HidP_GetValueCaps Physical Min/Max(%d/%d) is bad setting all to zero to %d"
                "device may have bad firmware", pcaps->Physical.Min, pcaps->Physical.Max, lSignedMask);

            pcaps->Logical.Min = 0;
            pcaps->Physical.Min = 0;
            pcaps->Logical.Max = lSignedMask;
            pcaps->Physical.Max = lSignedMask;
            pcaps->lMask = lSignedMask;
            pcaps->IsSigned = FALSE;
        }
        else
        {
            if(pcaps->Physical.Min == pcaps->Physical.Max)
            {
                pcaps->Physical = pcaps->Logical;
            }

            if(pcaps->Logical.Min >=  pcaps->lMask &&     // Logical Min / Max are signed
               pcaps->Logical.Max <= ~pcaps->lMask)
            {
                pcaps->IsSigned = TRUE;

            } else if(pcaps->Logical.Min >= 0 &&
                      pcaps->Logical.Max <= lSignedMask  )
            {                                              // Logical Min / Max are unsigned
                pcaps->lMask = lSignedMask;
                pcaps->IsSigned = FALSE;

            } else if (pcaps->UsagePage >= HID_USAGE_PAGE_VENDOR )
            {
                // Let this one pass, hopefully the broken descriptors are for
                // usages that are vendor specific and will not effect too many folks
                RPF("HidP_GetValueCaps Logical Min/Max(%d/%d) don't fit in BitSize(%d) - "
                    "device may have bad firmware", pcaps->Logical.Min, pcaps->Logical.Max, pcaps->BitSize);

                pcaps->Logical.Min = pcaps->lMask;
                pcaps->Logical.Max = ~pcaps->lMask;
                pcaps->IsSigned = TRUE;

            }else
            {
                RPF("HidP_GetValueCaps UsagePage(0x%x)Usage(0x%x) Logical Min/Max(%d/%d) don't fit in BitSize(%d) - "
                    "can't use device", pcaps->UsagePage, pcaps->UsageMin, pcaps->Logical.Min, pcaps->Logical.Max, pcaps->BitSize);
                hres = E_FAIL;
                goto freedone;
            }
        }

        AssertF(pcaps->Physical.Min < pcaps->Physical.Max);

        pcaps->StringMin          = pvcaps->Range.StringMin;
        pcaps->StringMax          = pvcaps->IsStringRange ?
                                    pvcaps->Range.StringMax :
                                    pvcaps->Range.StringMin;

        pcaps->DesignatorMin      = pvcaps->Range.DesignatorMin;
        pcaps->DesignatorMax      = pvcaps->IsDesignatorRange ?
                                    pvcaps->Range.DesignatorMax :
                                    pvcaps->Range.DesignatorMin;

        pcaps->IsAbsolute         = pvcaps->IsAbsolute;
        pcaps->IsValue            = TRUE;
        pcaps->IsAlias            = pvcaps->IsAlias;
        pcaps->type               = type;

        /*
         *  HID reports axes and POVs as the same thing, and the two
         *  POV usages we recognize are in different pages, so you
         *  will never get multiple POVs coming through in a single
         *  value-caps.
         *
         *  ISSUE-2001/03/06-MarcAnd POVs within caps are treated as axes
         *  There is, however, the problem of a POV buried inside
         *  a larger value-cap that describes axes.  Tough.  Those
         *  POVs are in trouble.
         */

#ifndef HID_USAGE_SIMULATION
#define HID_USAGE_SIMULATION_STEERING       ((USAGE) 0xC8)
#endif
        if( pcaps->UsagePage == HID_USAGE_PAGE_SIMULATION )
        {
            /*
             *  Check for specific axes that allow us to better clasify
             *  the device sub type.
             */

            if( pcaps->UsageMin == HID_USAGE_SIMULATION_STEERING )
            {
                this->dwDevType = MAKE_DIDEVICE_TYPE(DIDEVTYPE_JOYSTICK,
                                                     DIDEVTYPEJOYSTICK_WHEEL) |
                                                     DIDEVTYPE_HID;
            } else if( pcaps->UsageMin == HID_USAGE_SIMULATION_RUDDER ) {
                this->dwDevType = MAKE_DIDEVICE_TYPE(DIDEVTYPE_JOYSTICK,
                                                     DIDEVTYPEJOYSTICK_RUDDER) |
                                                     DIDEVTYPE_HID;
            }
        }

#define HID_USAGE_GAME_POV                          ((USAGE) 0x20)

        fPOV = pcaps->cObj == 1
                           && ( ( pcaps->UsagePage == HID_USAGE_PAGE_GENERIC
                                &&pcaps->UsageMin == HID_USAGE_GENERIC_HATSWITCH )
                              ||( pcaps->UsagePage == HID_USAGE_PAGE_GAME
                                &&pcaps->UsageMin == HID_USAGE_GAME_POV ) );


        if(fPOV)
        {
            LONG lUnits;

            /*
             *  POVs are assumed to start at north and increase
             *  clockwise through the logical maximum.
             */
            lUnits = pcaps->Logical.Max - pcaps->Logical.Min + 1;
            if(lUnits)
            {
                pcaps->usGranularity = (USHORT)(36000U / lUnits);
            }
        } else
        {
            if( ( pcaps->UsagePage == HID_USAGE_PAGE_GENERIC &&
                  pcaps->UsageMin <= HID_USAGE_GENERIC_HATSWITCH &&
                  pvcaps->Range.UsageMax >= HID_USAGE_GENERIC_HATSWITCH )
              ||( pcaps->UsagePage == HID_USAGE_PAGE_GAME &&
                  pcaps->UsageMin <= HID_USAGE_GAME_POV &&
                  pvcaps->Range.UsageMax >= HID_USAGE_GAME_POV ) )
            {
                SquirtSqflPtszV(sqflHidParse | sqflError,
                                TEXT("HidP_GetValueCaps - multi-usage cap ")
                                TEXT("includes hatswitch or POV - will be treated")
                                TEXT("as axis"));
            }
        }

#undef HID_USAGE_GAME_POV

        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Objs = %d"),
                        type, ivcaps, pcaps->cObj);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Index %d ..."),
                        type, ivcaps,
                        pcaps->DataIndexMin);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Logical = %d..%d"),
                        type, ivcaps,
                        pcaps->Logical.Min, pcaps->Logical.Max);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Physical = %d..%d"),
                        type, ivcaps,
                        pcaps->Physical.Min, pcaps->Physical.Max);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Units = 0x%08x"),
                        type, ivcaps,
                        pcaps->Units);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: IsAbs = %d"),
                        type, ivcaps,
                        pcaps->IsAbsolute);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: BitSize = %d"),
                        type, ivcaps,
                        pcaps->BitSize);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: IsAlias = %d"),
                        type, ivcaps,
                        pcaps->IsAlias);
        if(pcaps->LinkCollection)
        {
            SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                            TEXT("HidP_GetValueCaps(%d)[%d]: ")
                            TEXT("LinkCollection %d"),
                            type, ivcaps,
                            pcaps->LinkCollection);
        }

        /*
         *  Come up with a decent Null value if possible.
         *  The traditional Null value is the arithmetically
         *  smallest value which lies outside the
         *  LogicalMin/LogicalMax range.  Conveniently, the
         *  pcaps->lMask is the most negative value that is
         *  in range.
         */
        AssertF(pcaps->Null == 0);
        if(pvcaps->HasNull)
        {
          #ifdef WINNT
            pcaps->IsPolledPOV = FALSE;
          #endif

            if(pcaps->lMask < pcaps->Logical.Min)
            {
                pcaps->Null = pcaps->lMask;
            } else if(!(pcaps->lMask & (pcaps->Logical.Max + 1)))
            {
                pcaps->Null = pcaps->Logical.Max + 1;
            } else if( ! pcaps->IsSigned )
            {
                pcaps->Null = 0x0;
            } else
            {
                SquirtSqflPtszV(sqflTrace,
                                TEXT("VALUE_CAPS claims Null but no room!"));
            }
            SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                            TEXT("HidP_GetValueCaps(%d)[%d]: Null = %d"),
                            type, ivcaps,
                            pcaps->Null);
        } else {
          #ifdef WINNT
            if( fPOV &&
                (this->VendorID == MSFT_SYSTEM_VID ) &&
                ( (this->ProductID & 0xff00) == MSFT_SYSTEM_PID) )
            {
                LONG lUnits;

                lUnits = pcaps->Logical.Max - pcaps->Logical.Min + 1;
                if(lUnits)
                {
                    pcaps->usGranularity = (USHORT)9000;
                }

                pcaps->IsPolledPOV = TRUE;

                SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                                TEXT("HidP_GetValueCaps(%d)[%d]: Null = %d (Polled POV)."),
                                type, ivcaps,
                                pcaps->Null);
            }
          #endif
        }

        uiObj = this->rgdwBase[type] + pcaps->DataIndexMin;
        for(duiObj = 0; duiObj < pcaps->cObj; duiObj++)
        {
            DWORD dwDevType;
            LPDIOBJECTDATAFORMAT podf;

            /*
             *  If HID messed up and gave us something out of range,
             *  then give up on this value caps (since the rest are
             *  also out of range) and move on to the next one.
             */
            if(uiObj + duiObj >= this->df.dwNumObjs)
            {
                RPF("HidP_GetValueCaps inconsistent with NumberDataIndices - "
                    "skipping object (sorry)");
                break;
            }

            AssertF(uiObj + duiObj < this->df.dwNumObjs);

            if(this->rghoc[uiObj + duiObj].pcaps)
            {
                RPF("HidP_GetValueCaps inconsistent - "
                    "can't use device");
                hres = E_FAIL;
                goto freedone;
            }

            this->rghoc[uiObj + duiObj].pcaps = pcaps;
            podf = &this->df.rgodf[uiObj + duiObj];

            /*
             *  HACKHACK!  Wheels are identified by
             *  UsageToUsageMap as GUID_Slider, but we
             *  want them to be GUID_ZAxis if we are a mouse.
             *
             *  We also set the granularity here.
             */
            if(GET_DIDEVICE_TYPE(this->dwDevType) == DIDEVTYPE_MOUSE &&
               pcaps->UsageMin + duiObj == HID_USAGE_GENERIC_WHEEL &&
               pcaps->UsagePage == HID_USAGE_PAGE_GENERIC)
            {
                podf->pguid = &GUID_ZAxis;
                pcaps->usGranularity = (USHORT)g_lWheelGranularity;
            } else if( type == HidP_Input )
            {
                PHIDUSAGEMAP phum;

                phum = UsageToUsageMap( DIMAKEUSAGEDWORD( pcaps->UsagePage,
                                                          pcaps->UsageMin + duiObj ) );
                if(phum)
                {
                    podf->pguid = phum->pguid;
                } else
                {
                    podf->pguid = &GUID_Unknown;
                }
            } else
            {
                podf->pguid = &GUID_Unknown;
            }

            /*
             *  Set a default instance.  This will be overwritten later
             *  if this object is of a type we fully understand.
             */
            dwDevType = DIDFT_MAKEINSTANCE(uiObj + duiObj);

            if( pcaps->IsAlias )
            {
                dwDevType |= DIDFT_ALIAS;
            }

            if(pcaps->UsagePage >= HID_USAGE_PAGE_VENDOR )
            {
                dwDevType |= DIDFT_VENDORDEFINED;
            }
            else if(podf->pguid == &GUID_POV)
            {
                /* Note, this must be an input to have been mapped */
                dwDevType |= DIDFT_POV;
                if( !pcaps->IsAlias )
                {
                    this->dwPOVs++;
                }
            }
            else if( type == HidP_Input )
            {
                /*
                 *  In order to reduce the likelyhood of an app picking up an
                 *  input value that is not a user controlled axis, only mark
                 *  values as axes if they are inputs on a usage page that
                 *  contains such usages.
                 *  ISSUE-2000/11/07-MarcAnd ideally we should be looking at 
                 *  not only the usage of the object but at the collections 
                 *  that contain it.
                 */
                switch( pcaps->UsagePage )
                {
                case HID_USAGE_PAGE_BUTTON:
                    /*
                     *  An absolute input axis on the button page
                     *  is an analog button.
                     */
                    if( pcaps->IsAbsolute)
                    {
                        dwDevType |= DIDFT_PSHBUTTON;
                        if( !pcaps->IsAlias )
                        {
                            this->dwButtons++;
                        }
               