       pDisti = m_listDistributors.GetNext(pos);
        if (pDisti->m_Clsid == clsid) {

            // found it - query for interface and return
            return ReturnInterface(pDisti, iid, ppv);
        }
    }

    // need to create new object
    hr = S_OK;
    pDisti = new CDistributor(m_pUnkOuter, &clsid, &hr, m_pFilterGraphCritSec);
    if (!pDisti) {
        return E_OUTOFMEMORY;
    } else if (FAILED(hr)) {
        delete pDisti;
        return hr;
    }

    // give it the current state and clock before adding it to our list
    if (m_pClock) {
        pDisti->SetSyncSource(m_pClock);
    }

    if (m_State == State_Stopped) {
        pDisti->Stop();
    } else if (m_State == State_Paused) {
        pDisti->Pause();
    } else {
        pDisti->Run(m_tOffset);
    }
    m_listDistributors.AddTail(pDisti);

    return ReturnInterface(pDisti, iid, ppv);

}

// look in the registry to find the Clsid for the object that will
// act as a distributor for the interface iid.
HRESULT
CDistributorManager::GetDistributorClsid(REFIID riid, CLSID *pClsid)
{
    // look in Interface\<iid>\Distributor for the clsid

    TCHAR chSubKey[128];
    WCHAR chIID[48];
    if (QzStringFromGUID2(riid, chIID, 48) == 0) {
        return E_NOINTERFACE;
    }
    wsprintf(chSubKey, TEXT("Interface\\%ls\\Distributor"), chIID);

    HKEY hk;
    LONG lRet = RegOpenKeyEx(
                    HKEY_CLASSES_ROOT,
                    chSubKey,
                    NULL,
                    KEY_READ,
                    &hk);
    if (lRet != ERROR_SUCCESS) {
        return E_NOINTERFACE;
    }

    LONG lLength;
    lRet = RegQueryValue(hk, NULL, NULL, &lLength);
    if (lRet != ERROR_SUCCESS) {
        RegCloseKey(hk);
        return E_NOINTERFACE;
    }


    TCHAR* pchClsid = new TCHAR[lLength / sizeof(TCHAR)];
    if (NULL == pchClsid) {
        RegCloseKey(hk);
        return E_OUTOFMEMORY;
    }
    lRet = RegQueryValue(hk, NULL, pchClsid, &lLength);
    RegCloseKey(hk);
    if (lRet != ERROR_SUCCESS) {
        delete [] pchClsid;
        return E_NOINTERFACE;
    }

#ifndef UNICODE
    WCHAR* pwch = new WCHAR[lLength];
    if (NULL == pwch) {
        delete [] pchClsid;
        return E_OUTOFMEMORY;
    }
    MultiByteToWideChar(
        CP_ACP,
        0,
        pchClsid,
        lLength,
        pwch,
        lLength
    );
    HRESULT hr = QzCLSIDFromString(pwch, pClsid);
    delete [] pwch;
#else
    HRESULT hr = QzCLSIDFromString(pchClsid, pClsid);
#endif
    delete [] pchClsid;
    if (FAILED(hr)) {
        return hr;
    }

    return S_OK;
}


// Query for a new interface and return it, caching it in our list
HRESULT
CDistributorManager::ReturnInterface(
    CDistributor* pDisti,
    REFIID riid,
    void** ppv)
{
    // Query for the new interface
    IUnknown* pInterface;
    HRESULT hr = pDisti->QueryInterface(riid, (void**)&pInterface);
    if (FAILED(hr)) {
        return hr;
    }

    // cache it on our list
    CDistributedInterface* pDI = new CDistributedInterface(riid, pInterface);
    m_listInterfaces.AddTail(pDI);

    // return it
    *ppv = pInterface;
    return S_OK;
}


// pass on IMediaFilter::Run method to distributors that need to
// know state
HRESULT
CDistributorManager::Run(REFERENCE_TIME tOffset)
{
    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;
    POSITION pos = m_listDistributors.GetHeadPosition();
    while(pos) {
        CDistributor* pDisti = m_listDistributors.GetNext(pos);
        HRESULT hrTmp = pDisti->Run(tOffset);
        if (FAILED(hrTmp) && SUCCEEDED(hr)) {
            hr = hrTmp;
        }
    }

    // remember this for any objects added later
    m_State = State_Running;
    m_tOffset = tOffset;

    return hr;
}

HRESULT
CDistributorManager::Pause()
{
    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;
    POSITION pos = m_listDistributors.GetHeadPosition();
    while(pos) {
        CDistributor* pDisti = m_listDistributors.GetNext(pos);
        HRESULT hrTmp = pDisti->Pause();
        if (FAILED(hrTmp) && SUCCEEDED(hr)) {
            hr = hrTmp;
        }
    }
    m_State = State_Paused;
    return hr;
}

HRESULT
CDistributorManager::Stop()
{
    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;
    POSITION pos = m_listDistributors.GetHeadPosition();
    while(pos) {
        CDistributor* pDisti = m_listDistributors.GetNext(pos);
        HRESULT hrTmp = pDisti->Stop();
        if (FAILED(hrTmp) && SUCCEEDED(hr)) {
            hr = hrTmp;
        }
    }
    m_State = State_Stopped;
    return hr;
}

HRESULT
CDistributorManager::NotifyGraphChange()
{
    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;
    POSITION pos = m_listDistributors.GetHeadPosition();
    while(pos) {
        CDistributor* pDisti = m_listDistributors.GetNext(pos);
        HRESULT hrTmp = pDisti->NotifyGraphChange();
        if (FAILED(hrTmp) && SUCCEEDED(hr)) {
            hr = hrTmp;
        }
    }
    return hr;
}

HRESULT CDistributorManager::SetSyncSource(IReferenceClock* pClock)
{
    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    // replace our clock - remember to addref before release in case same
    if (pClock) {
        pClock->AddRef();
    }
    if (m_pClock) {
        m_pClock->Release();
    }
    m_pClock = pClock;

    HRESULT hr = S_OK;
    POSITION pos = m_listDistributors.GetHeadPosition();
    while(pos) {
        CDistributor* pDisti = m_listDistributors.GetNext(pos);
        HRESULT hrTmp = pDisti->SetSyncSource(pClock);
        if (FAILED(hrTmp) && SUCCEEDED(hr)) {
            hr = hrTmp;
        }
    }
    return hr;
}

// the filter graph has entered its destructor.
// Pass on EC_SHUTTING_DOWN to the IMediaEventSink handler if
// we have it loaded. this will stop async event notifications such as
// EC_REPAINT from happening after shutdown.
HRESULT CDistributorManager::Shutdown(void)
{
    if (m_bDestroying) {
        return E_UNEXPECTED;
    }

    // first see if we have the interface already
    POSITION pos = m_listInterfaces.GetHeadPosition();
    while (pos) {
        CDistributedInterface* pDisti;
        pDisti = m_listInterfaces.GetNext(pos);
        if (pDisti->m_iid == IID_IMediaEventSink) {

            IMediaEventSink* pSink = (IMediaEventSink*) pDisti->m_pInterface;
            return pSink->Notify(EC_SHUTTING_DOWN, 0, 0);

        }
    }

    // didn't find IMediaEventSink, so no-one was notified. not an error.
    return S_FALSE;
}


// --- CDistributor object implementation ---------------

// this object represents one instantiated distributor.
// The constructor attempts to instantiate it given the clsid.
CDistributor::CDistributor(LPUNKNOWN pUnk, CLSID *pClsid, HRESULT * phr, CMsgMutex * pCritSec )
 : m_pUnkOuter(pUnk), m_pMF(NULL), m_pNotify(NULL)
{
    m_Clsid = *pClsid;

    HRESULT hr = QzCreateFilterObject(
                    m_Clsid,
                    pUnk,
                    CLSCTX_INPROC,
                    IID_IUnknown,
                    (void**) &m_pUnk);

    if (FAILED(hr)) {
        *phr = hr;
        return;
    }

    // get the notify interface if exposed
    hr = m_pUnk->QueryInterface(IID_IDistributorNotify, (void**)&m_pNotify);
    if (SUCCEEDED(hr)) {
        // COM aggregation rules - this QI has addrefed the outer
        // object, and I must release that AddRef.
        m_pUnkOuter->Release();
    }

    // if no IDistributorNotify, then see if it understands IMediaFilter
    // instead (for backwards compatibility only)
    if (!m_pNotify) {
        hr = m_pUnk->QueryInterface(IID_IMediaFilter, (void**)&m_pMF);
        if (SUCCEEDED(hr)) {
            // COM aggregation rules - this QI has addrefed the outer
            // object, and I must release that AddRef.
            m_pUnkOuter->Release();
        }
    }
}


CDistributor::~CDistributor()
{
    // release our ref counts on the object
    if (m_pNotify) {
        // COM aggregation rules - since I released the refcount on
        // myself after the QI for this interface, I need to addref
        // myself before releasing it
        m_pUnkOuter->AddRef();

        m_pNotify->Release();
    }

    if (m_pMF) {
        // COM aggregation rules - since I released the refcount on
        // myself after the QI for this interface, I need to addref
        // myself before releasing it
        m_pUnkOuter->AddRef();

        m_pMF->Release();
    }

    // this is the non-delegating unknown of the aggregated object
    if (m_pUnk) {
        m_pUnk->Release();
    }
}

// ask for an interface that this object is supposed to distribute
HRESULT
CDistributor::QueryInterface(REFIID riid, void**ppv)
{
    if (m_pUnk) {
        return m_pUnk->QueryInterface(riid, ppv);
    }
    return E_NOINTERFACE;
}

// distribute IMediaFilter info if the object supports it
HRESULT
CDistributor::Run(REFERENCE_TIME t)
{
    if (m_pNotify) {
        return m_pNotify->Run(t);
    } else if (m_pMF) {
        return m_pMF->Run(t);
    } else {
        // not an error - notify support is optional
        return S_OK;
    }
}

HRESULT
CDistributor::Pause()
{
    if (m_pNotify) {
        return m_pNotify->Pause();
    } else if (m_pMF) {
        return m_pMF->Pause();
    } else {
        // not an error - notify support is optional
        return S_OK;
    }
}

HRESULT
CDistributor::Stop()
{
    if (m_pNotify) {
        return m_pNotify->Stop();
    } else if (m_pMF) {
        return m_pMF->Stop();
    } else {
        // not an error - notify support is optional
        return S_OK;
    }
}

HRESULT
CDistributor::SetSyncSource(IReferenceClock * pClock)
{
    if (m_pNotify) {
        return m_pNotify->SetSyncSource(pClock);
    } else if (m_pMF) {
        return m_pMF->SetSyncSource(pClock);
    } else {
        // not an error - notify support is optional
        return S_OK;
    }
}

HRESULT
CDistributor::NotifyGraphChange()
{
    if (m_pNotify) {
        return m_pNotify->NotifyGraphChange();
    } else {
        // not an error - and not on IMediaFilter
        return S_OK;
    }
}

CDistributedInterface::CDistributedInterface(
    REFIID riid,
    IUnknown* pInterface)
    : m_pInterface(pInterface)
{
    m_iid = riid;

    // actually we don't addref or release the interface pointer.
    // Since we aggregate this object, it's lifetime is maintained
    // by the CDistributor object. This interface pointer is delegated,
    // and an addref call would simply increase the refcount of the
    // outer object of which we are part.

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\efcache.h ===
// Copyright (c) Microsoft Corporation 1999. All Rights Reserved

//
//
//   efcache.h
//       Definition of CEnumCacheFilter which implementents
//       the filter enumerator for the filter cache
//
#ifndef EnumCachedFilter_h
#define EnumCachedFilter_h

class CMsgMutex;
class CFilterCache;

class CEnumCachedFilter : public IEnumFilters, public CUnknown
{
public:
    CEnumCachedFilter( CFilterCache* pEnumeratedFilterCache, CMsgMutex* pcsFilterCache );
    ~CEnumCachedFilter();

    // IUnknown Interface
    DECLARE_IUNKNOWN

    // INonDelegatingUnknown Interface
    STDMETHODIMP NonDelegatingQueryInterface( REFIID riid, void** ppv );

    // IEnumFilters Interface
    STDMETHODIMP Next( ULONG cFilters, IBaseFilter** ppFilter, ULONG* pcFetched );
    STDMETHODIMP Skip( ULONG cFilters );
    STDMETHODIMP Reset( void );
    STDMETHODIMP Clone( IEnumFilters** ppCloanedEnum );

private:
    CEnumCachedFilter::CEnumCachedFilter
        (
        CFilterCache* pEnumeratedFilterCache,
        CMsgMutex* pcsFilterCache,
        POSITION posCurrentFilter,
        DWORD dwCurrentCacheVersion
        );
    void Init
        (
        CFilterCache* pEnumeratedFilterCache,
        CMsgMutex* pcsFilterCache,
        POSITION posCurrentFilter,
        DWORD dwCurrentCacheVersion
        );

    bool IsEnumOutOfSync( void );
    bool GetNextFilter( IBaseFilter** ppNextFilter );
    bool AdvanceCurrentPosition( void );

    CFilterCache* m_pEnumeratedFilterCache;
    DWORD m_dwEnumCacheVersion;
    POSITION m_posCurrentFilter;

    CMsgMutex* m_pcsFilterCache;
};

#endif // EnumCachedFilter_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\dyngraph.cpp ===
// Copyright (c) Microsoft Corporation 1999. All Rights Reserved
//
//
//   dyngraph.cpp
//
//   Contains code to implement IGraphConfig in the DirectShow filter
//   graph
//
#include <streams.h>
#include <atlbase.h>
#include "fgenum.h"
#include "distrib.h"
#include "rlist.h"
#include "filgraph.h"
#include "FilCache.h"
#include "Util.h"

extern HRESULT GetFilterMiscFlags(IUnknown *pFilter, DWORD *pdwFlags);

HRESULT DisconnectPeer(IGraphBuilder *pGraph, IPin *pPin)
{
    CComPtr<IPin> pConnectedTo;
    HRESULT hr = pPin->ConnectedTo(&pConnectedTo);
    if (SUCCEEDED(hr)) {
        hr = pGraph->Disconnect(pConnectedTo);
    }
    return hr;
}

//  Helpers
HRESULT GetPinListHelper(
    IPin *pOut,
    IPin *pIn,
    CPinList *pList,
    int *nAdded
);

HRESULT GetPinList(IPin *pOut, IPin *pIn, CPinList *pList)
{
    int nAdded = 0;
    HRESULT hr = GetPinListHelper(pOut, pIn, pList, &nAdded);
    if (FAILED(hr)) {
        while (nAdded--) {
            EXECUTE_ASSERT(NULL != pList->RemoveTail());
        }
    }
    return hr;
}

HRESULT GetPinListHelper(
    IPin *pOut,
    IPin *pIn,
    CPinList *pList,
    int *pnAdded
)
{
    *pnAdded = 0;

    for (; ; ) {
        IPin *pConnected;
        HRESULT hr = pOut->ConnectedTo(&pConnected);

        if (FAILED(hr)) {
            return hr;
        }

        if (IsEqualObject(pIn, pConnected)) {
            pConnected->Release();
            return S_OK;
        }

        //  This call transfers the ref count on pConnected to
        //  the pin list

        if (!pList->AddTail(pConnected)) {
            pConnected->Release();
            return E_OUTOFMEMORY;
        }

        (*pnAdded)++;

        //  Find a pin related to the pin we found - also look at
        //  all of them in case one of them is our target
        CEnumConnectedPins EnumPins(pConnected, &hr);
        if (SUCCEEDED(hr)) {
            IPin *pPin;
            for (; ; ) {
                pPin = EnumPins();
                if (NULL == pPin) {
                    return VFW_E_NOT_CONNECTED;
                }
                hr = GetPinList(pPin, pIn, pList);
                pPin->Release();
                if (SUCCEEDED(hr)) {
                    return hr;
                }
            }
        }
        return VFW_E_NOT_CONNECTED;
    }
}


//
//  This is problematical if the filters have extra pins and
//  we don't stop the filters connected to those pins
//
HRESULT StopAndRemoveFilters(
    CFilterGraph *pGraph,
    const CPinList *pPins,
    IPin *pInput,
    DWORD dwFlags,
    FILTER_STATE fs )
{
    // The FILTER_STATE enumeration has three possible values: State_Stopped,
    // State_Paused and State_Running.
    ASSERT( (State_Stopped == fs) || (fs == State_Running) || (fs == State_Paused) );

    POSITION Pos;

    if( (fs == State_Running) || (fs == State_Paused) ) {

        //  Step the list stopping the filters then
        Pos = pPins->GetTailPosition();
        while (Pos) {
            IPin *pPin = pPins->GetPrev(Pos);
            CComPtr<IBaseFilter> pFilter;
            GetFilter(pPin, &pFilter);
            if (pFilter) {
                HRESULT hr = pFilter->Stop();
                if (FAILED(hr)) {
                    return hr;
                }

                if( fs == State_Running ) {

                    DWORD dwMiscFilterFlags;

                    hr = GetFilterMiscFlags( pFilter, &dwMiscFilterFlags );
                    if (SUCCEEDED(hr) && (dwMiscFilterFlags & AM_FILTER_MISC_FLAGS_IS_RENDERER) ) {
                        hr = pGraph->UpdateEC_COMPLETEState( pFilter, State_Stopped );
                        if (FAILED(hr)) {
                            return hr;
                        }
                    }
                }
            }
        }
    }

    //  step it again removing them
    //  Note that because we disconnect each pin and its partner
    //  we effectively disconnect all the output pins too here
    //
    //  pOut==>pIn1 Filter1 pOut1==>pIn2 .. Filtern pOutn==>pIn
    // disconnect its peer
    HRESULT hr = DisconnectPeer(pGraph, pInput);
    if (FAILED(hr))
    {
        // bug in app or filter if disconnect fails. we can't always
        // handle this gracefully.
        DbgBreak("StopAndRemoveFilters: failed to disconnect pin");
        return hr;
    }

    IPinConnection *ppc;
    hr = pInput->QueryInterface(IID_IPinConnection, (void **)&ppc);
    // caller (CGraphConfig::Reconnect) validates
    ASSERT(hr == S_OK);
    
    if(SUCCEEDED(hr))           // !!!
    {
        hr = ppc->DynamicDisconnect();
        ppc->Release();
    }
    if (FAILED(hr)) {
        // bug in app or filter if disconnect fails. we can't always
        // handle this gracefully.
        DbgBreak("StopAndRemoveFilters: failed to disconnect pin");
        return hr;
    }

    Pos = pPins->GetTailPosition();
    while (Pos) {
        IPin *pPin = pPins->GetPrev(Pos);
        HRESULT hr;
        hr = DisconnectPeer(pGraph, pPin);
        if (FAILED(hr)) {
            return hr;
        }
        hr = pGraph->Disconnect(pPin);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Place removed filters in the filter cache.
    if( dwFlags & AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS ) {
        IPin *pCurrentPin;
        IGraphConfig* pGraphConfig;
        IBaseFilter* pCurrentFilter;

        hr = pGraph->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
        if( FAILED( hr ) ) {
            return hr;
        }

        Pos = pPins->GetTailPosition();
        while (Pos) {
            pCurrentPin = pPins->GetPrev( Pos );

            GetFilter( pCurrentPin, &pCurrentFilter );
            if( NULL == pCurrentFilter ) {
                pGraphConfig->Release();
                return E_FAIL;
            }

            hr = pGraphConfig->AddFilterToCache( pCurrentFilter );

            pCurrentFilter->Release();

            if( FAILED( hr ) ) {
                pGraphConfig->Release();
                return hr;
            }
        }

        pGraphConfig->Release();
    }

    return hr;
}

//  Flags from the reconnect call
HRESULT ReconnectPins(
    CFilterGraph *pGraph,
    IPin *pOut,
    IPin *pIn,
    const AM_MEDIA_TYPE *pmtFirstConnection,
    DWORD dwFlags)
{
    if (dwFlags & AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT) {
        return pGraph->ConnectDirect(pOut, pIn, pmtFirstConnection);
    } else {
        DWORD dwConnectFlags = 0;  // No flags.

        if( dwFlags & AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS ) {
            dwConnectFlags |= AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS;
        }

        return pGraph->ConnectInternal(pOut, pIn, pmtFirstConnection, dwConnectFlags);
    }
}


//  Restart filters
HRESULT RestartFilters(
    IPin *pOut,
    IPin *pIn,
    REFERENCE_TIME tStart,
    FILTER_STATE fs,
    CFilterGraph* pGraph )
{
    // This function should only be called when the filter graph is running or pasued.
    ASSERT( (State_Paused == fs) || (State_Running == fs) );

    //  Find which filters we're dealing with
    CPinList PinList;
    HRESULT hr = GetPinList(pOut, pIn, &PinList);

    POSITION pos = PinList.GetHeadPosition();
    while (pos) {
        IPin *pPin = PinList.GetNext(pos);
        CComPtr<IBaseFilter> pFilter;
        GetFilter(pPin, &pFilter);
        if (pFilter != NULL) {
            if (fs == State_Paused) {
                hr = pFilter->Pause();
                if (FAILED(hr)) {
                    return hr;
                }
            } else {
                if (fs == State_Running) {
                    hr = pFilter->Run(tStart);
                    if (FAILED(hr)) {
                        return hr;
                    }

                    DWORD dwMiscFilterFlags;

                    hr = GetFilterMiscFlags( pFilter, &dwMiscFilterFlags );
                    if (SUCCEEDED(hr) && (dwMiscFilterFlags & AM_FILTER_MISC_FLAGS_IS_RENDERER) ) {
                        hr = pGraph->UpdateEC_COMPLETEState( pFilter, State_Running );
                        if (FAILED(hr)) {
                            return hr;
                        }
                    }
                }
            }
        }
    }
    return S_OK;
}

//  Now do our thing - note this code is not a method it's
//  perfectly generic
HRESULT DoReconnectInternal(
                    CFilterGraph *pGraph,
                    IPin *pOutputPin,
                    IPin *pInputPin,
                    const AM_MEDIA_TYPE *pmtFirstConnection,
                    IBaseFilter *pUsingFilter, // can be NULL
                    HANDLE hAbortEvent,
                    DWORD dwFlags,
                    const CPinList *pList,
                    REFERENCE_TIME tStart,
                    FILTER_STATE fs
)
{
    CComPtr<IPin> pUsingOutput, pUsingInput;

    //  If we're using a filter find an input pin and an output pin
    //  to connect to
    //  BUGBUG - should we support filters that are not just
    //  transforms?

    if (pUsingFilter) {
        CEnumPin EnumPins(pUsingFilter);
        for (;;) {
            IPin *pPin = EnumPins();
            if (NULL == pPin) {
                break;
            }
            int dir = Direction(pPin);
            if (pUsingOutput == NULL && dir == PINDIR_OUTPUT) {
                pUsingOutput = pPin;
            }
            else if (pUsingInput == NULL && dir == PINDIR_INPUT) {
                pUsingInput = pPin;
            }

            pPin->Release();
        }
        if (pUsingInput == NULL || pUsingOutput == NULL) {
            return VFW_E_CANNOT_CONNECT;
        }
    }

    //  Stop all the intermediate filters
    HRESULT hr = StopAndRemoveFilters(pGraph, pList, pInputPin, dwFlags, fs);
    if (FAILED(hr)) {
        return hr;
    }

    //  Need some way of knowing what filters got added to the graph!

    //  Do 1 or 2 connects
    if (NULL != pUsingFilter) {

        // If the new filter is a legacy one (how to tell) it
        // May need stopping before we can connect it
        hr = pUsingFilter->Stop();

        // Find some pins
        if (SUCCEEDED(hr)) {
            hr = ReconnectPins(pGraph, pOutputPin, pUsingInput, pmtFirstConnection, dwFlags);
        }
        if (SUCCEEDED(hr)) {
            hr = ReconnectPins(pGraph, pUsingOutput, pInputPin, NULL, dwFlags);
        }
    } else {
        hr = ReconnectPins(pGraph, pOutputPin, pInputPin, pmtFirstConnection, dwFlags);
    }

    //  BUGBUG - what backout logic do we need?
    //
    //  Now start the filters
    //  Because we should not have added any filters actually connecting
    //  the 2 we've just connected we should just be able to restart
    //  the path between them.

    //  BUGBUG
    //  However - there could be a stream split or merge or just more
    //  filters in the graph so just start everyone?

    if( State_Stopped != fs ) {
        if (SUCCEEDED(hr)) {
            hr = RestartFilters(pOutputPin, pInputPin, tStart, fs, pGraph);
        }
    }

    return hr;
}

//  Now do our thing - note this code is not a method it's
//  perfectly generic
HRESULT DoReconnect(CFilterGraph *pGraph,
                    IPin *pOutputPin,
                    IPin *pInputPin,
                    const AM_MEDIA_TYPE *pmtFirstConnection,
                    IBaseFilter *pUsingFilter, // can be NULL
                    HANDLE hAbortEvent,
                    DWORD dwFlags,
                    REFERENCE_TIME tStart,
                    FILTER_STATE fs
)
{
    //  Find the set of pins - for now we'll fail if we find a
    //  terminal filter before we find the pin we're looking for
    int  nPins    = 0;
    CPinList PinList;

    HRESULT hr = GetPinList(pOutputPin, pInputPin, &PinList);

    if (FAILED(hr)) {
        return hr;
    }

    return DoReconnectInternal(
               pGraph,
               pOutputPin,
               pInputPin,
               pmtFirstConnection,
               pUsingFilter,
               hAbortEvent,
               dwFlags,
               &PinList,
               tStart,
               fs);
}

//  CGraphConfig

CGraphConfig::CGraphConfig(CFilterGraph *pGraph, HRESULT *phr) :
    m_pFilterCache(NULL),
    m_pGraph(pGraph),
    CUnknown(NAME("CGraphConfig"), (IFilterGraph *)pGraph)
{
    m_pFilterCache = new CFilterCache( m_pGraph->GetCritSec(), phr );
    if( NULL == m_pFilterCache )
    {
        *phr = E_OUTOFMEMORY;
        return;
    }

    if( FAILED( *phr ) )
    {
        delete m_pFilterCache;
        m_pFilterCache = NULL;
        return;
    }
}

CGraphConfig::~CGraphConfig()
{
    delete m_pFilterCache;

    // This object should never be destroyed if someone holds a
    // valid IGraphConfig interface pointer.
    ASSERT( 0 == m_cRef );
}

STDMETHODIMP CGraphConfig::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IGraphConfig) {
        return GetInterface((IGraphConfig *)this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

//  IGraphConfig

STDMETHODIMP CGraphConfig::Reconnect(IPin *pOutputPin,
                                     IPin *pInputPin,
                                     const AM_MEDIA_TYPE *pmtFirstConnection,
                                     IBaseFilter *pUsingFilter, // can be NULL
                                     HANDLE hAbortEvent,
                                     DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if(pOutputPin == 0 && pInputPin == 0) {
        return E_INVALIDARG;
    }

    // It makes no sense to specify both of these flags because if the user
    // specifies the AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT flag, then the
    // filter graph manager never uses any filters from the filter cache.
    if( (AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT & dwFlags) &&
        (AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS & dwFlags) )
    {
        return E_INVALIDARG;
    }

    // smart pointer to hold refcount for pInputPin or pOutputPin --
    // which ever we set.
    QzCComPtr<IPin> pPinComputed;

    if(pOutputPin && !pInputPin) {
        hr = GetSinkOrSource(pOutputPin, &pPinComputed, hAbortEvent);
        pInputPin = pPinComputed; // no refcount
    }
    else if(!pOutputPin && pInputPin) {
        hr = GetSinkOrSource(pInputPin, &pPinComputed, hAbortEvent);
        pOutputPin = pPinComputed; // no refcount
    }

    if(FAILED(hr)) {
        return hr;
    }

    CComQIPtr<IPinConnection, &IID_IPinConnection>
        pConnection(pInputPin);

    if (pConnection == NULL) {
        return E_NOINTERFACE;
    }

    // Filters do not process data if the filter graph is in the stopped state.
    if( State_Stopped != m_pGraph->GetStateInternal() ) { 
        hr = PushThroughData(pOutputPin, pConnection, hAbortEvent);
        if (FAILED(hr)) {
            return hr;
        }
    }

    //  Lock the graph with the special lock then call back
    if (!m_pGraph->GetCritSec()->Lock(hAbortEvent)) {
        return VFW_E_STATE_CHANGED;
    }

    hr = DoReconnect(
        m_pGraph,
        pOutputPin,
        pInputPin,
        pmtFirstConnection,
        pUsingFilter,
        hAbortEvent,
        dwFlags,
        m_pGraph->m_tStart,
        m_pGraph->GetStateInternal());

    m_pGraph->GetCritSec()->Unlock();

    {
        IMediaEventSink *psink;
        HRESULT hrTmp = m_pGraph->QueryInterface(IID_IMediaEventSink, (void **)&psink);
        ASSERT(hrTmp == S_OK);
        hrTmp = psink->Notify(EC_GRAPH_CHANGED, 0, 0);
        psink->Release();
    }
        
    return hr;
}

STDMETHODIMP CGraphConfig::Reconfigure(
                         IGraphConfigCallback *pCallback,
                         PVOID pvContext,
                         DWORD dwFlags,
                         HANDLE hAbortEvent)
{
    //  Lock the graph with the special lock then call back
    if (!m_pGraph->GetCritSec()->Lock(hAbortEvent)) {
        return VFW_E_WRONG_STATE;
    }

    HRESULT hr = pCallback->Reconfigure(pvContext, dwFlags);

    m_pGraph->GetCritSec()->Unlock();

    return hr;
}

STDMETHODIMP CGraphConfig::AddFilterToCache(IBaseFilter *pFilter)
{
    return m_pFilterCache->AddFilterToCache( pFilter );
}

STDMETHODIMP CGraphConfig::EnumCacheFilter(IEnumFilters **pEnum)
{
    return m_pFilterCache->EnumCacheFilters( pEnum );
}

STDMETHODIMP CGraphConfig::RemoveFilterFromCache(IBaseFilter *pFilter)
{
    return m_pFilterCache->RemoveFilterFromCache( pFilter );
}

STDMETHODIMP CGraphConfig::GetStartTime(REFERENCE_TIME *prtStart)
{
    CAutoMsgMutex alFilterGraphLock( m_pGraph->GetCritSec() );
    CheckPointer( prtStart, E_POINTER );

    if (m_pGraph->GetStateInternal() != State_Running) {
        *prtStart = 0;
        return VFW_E_WRONG_STATE;
    } else {
        *prtStart = m_pGraph->m_tStart;
        return S_OK;
    }
}

STDMETHODIMP CGraphConfig::PushThroughData(
    IPin *pOutputPin,
    IPinConnection *pConnection,
    HANDLE hEventAbort)
{
    HRESULT hr = S_OK;

    CAMEvent evDone;
    if (NULL == HANDLE(evDone)) {
        return E_OUTOFMEMORY;
    }

    CComPtr<IPinConnection> pConnectionTmp;
    if(pConnection == 0)
    {
        IPin *pPin;
        hr = GetSinkOrSource(pOutputPin, &pPin, hEventAbort);
        if(SUCCEEDED(hr))
        {
            pPin->QueryInterface(IID_IPinConnection, (void **)&pConnectionTmp);
            pConnection = pConnectionTmp;
            pPin->Release();
        }
    }

    if(!pConnection) {
        return VFW_E_NOT_FOUND;
    }

    hr = pConnection->NotifyEndOfStream(evDone);
    if (FAILED(hr)) {
        return hr;
    }
    QzCComPtr<IPin> pConnected;
    hr = pOutputPin->ConnectedTo(&pConnected);
    if (FAILED(hr)) {
        return hr;
    }
    hr = pConnected->EndOfStream();
    if (FAILED(hr)) {
        return hr;
    }

    //  They'd better set their event now!  (in the synchronous case
    //  it will have happened inside the call to EndOfStream).
    DWORD dwRet;
    DWORD dwNumEvents;
    HANDLE Events[2] = { evDone, hEventAbort };
    
    if( NULL == hEventAbort ) {
        dwNumEvents = NUMELMS(Events) - 1;
    } else {
        dwNumEvents = NUMELMS(Events);
    }

    if (WAIT_OBJECT_0 != 
        (dwRet = WaitForMultipleObjects(dwNumEvents, Events, FALSE, INFINITE))) {
        ASSERT(dwRet == WAIT_OBJECT_0 + 1);
        hr = VFW_E_STATE_CHANGED;
    }

    // ??? should all paths do this? worrying that the downstream
    // filter has a handle that may or may not be valid.
    pConnection->NotifyEndOfStream(NULL);

    return hr;
}

// report whether pPinStart is a candidate and the pin connected to
// the other side of this filter. *ppPinEnd is null if we cannot
// traverse this filter.

HRESULT CGraphConfig::TraverseHelper(
    IPin *pPinStart,
    IPin **ppPinNext,
    bool *pfIsCandidate)
{
    // A race condition could occur if the caller does not hold
    // the filter graph lock.
    ASSERT( CritCheckIn( m_pGraph->GetCritSec() ) );

    // Make sure the pin is in the filter graph.
    ASSERT( SUCCEEDED( m_pGraph->CheckPinInGraph(pPinStart) ) );

    HRESULT hr = S_OK;
    PIN_INFO pi;

    bool fCanTraverse = true;
    *pfIsCandidate = true;
    *ppPinNext = 0;

    hr = pPinStart->QueryPinInfo(&pi);
    if(SUCCEEDED(hr))
    {
        if(pi.dir == PINDIR_INPUT)
        {
            IPinConnection *ppc;
            if(SUCCEEDED(pPinStart->QueryInterface(IID_IPinConnection, (void **)&ppc))) {
                ppc->Release();
            } else {
                *pfIsCandidate = false;
            }
        }
        else
        {
            ASSERT(pi.dir == PINDIR_OUTPUT);
            IPinFlowControl *ppfc;
            hr = pPinStart->QueryInterface(IID_IPinFlowControl, (void **)&ppfc);
            if(SUCCEEDED(hr)) {
                ppfc->Release();
            } else {
                *pfIsCandidate = false;
            }
        }

        DWORD dwInternalFilterFlags = m_pGraph->GetInternalFilterFlags( pi.pFilter );

        bool fCanTraverse = !(FILGEN_ADDED_MANUALLY & dwInternalFilterFlags) ||
                            (FILGEN_FILTER_REMOVEABLE & dwInternalFilterFlags);

        // traverse to the next pin.
        if( fCanTraverse )
        {
            IEnumPins *pep;
            hr = pi.pFilter->EnumPins(&pep);
            if(SUCCEEDED(hr))
            {
                // we want there to be exactly 1 input pin and 1
                // output pin.
                IPin *rgp[3];
                ULONG cp;
                hr = pep->Next(3, rgp, &cp);
                if(SUCCEEDED(hr))
                {
                    ASSERT(hr == S_OK && cp == 3 ||
                           hr == S_FALSE && cp < 3);

                    if(cp == 2)
                    {
                        // need to make sure the pins are connected to
                        // avoid looping on circular graphs.
                        bool f_QIC_ok = false;

                        {
                            IPin *rgPinIC[1];
                            ULONG cPins = NUMELMS(rgPinIC);
                            HRESULT hrTmp = pPinStart->QueryInternalConnections(rgPinIC, &cPins);
                            if(hrTmp == E_NOTIMPL)
                            {
                                // all pins connect through
                                f_QIC_ok = true;
                            }
                            else if(SUCCEEDED(hr))
                            {
                                // can't return S_FALSE since there
                                // are only two pins
                                ASSERT(hr == S_OK);

                                if(cPins == 1)
                                {
                                    // this pin is connected to the other one
                                    f_QIC_ok = true;
                                    rgPinIC[0]->Release();
                                }
                                else
                                {
                                    ASSERT(cPins == 0);
                                }
                            }
                        }

                        IPin *pPinOtherSide = 0;

                        if(f_QIC_ok)
                        {
                            PIN_DIRECTION dir0, dir1;
                            hr = rgp[0]->QueryDirection(&dir0);
                            ASSERT(SUCCEEDED(hr));
                            hr = rgp[1]->QueryDirection(&dir1);
                            ASSERT(SUCCEEDED(hr));


                            if(dir0 != dir1 && dir0 == pi.dir)
                            {
                                pPinOtherSide = rgp[1];
                            }
                            else if(dir0 != dir1 && dir1 == pi.dir)
                            {
                                pPinOtherSide = rgp[0];
                            }

                            if(pPinOtherSide)
                            {
                                hr = pPinOtherSide->ConnectedTo(ppPinNext);
                                ASSERT(SUCCEEDED(hr) && *ppPinNext ||
                                       FAILED(hr) && !*ppPinNext);
                                
                                hr = S_OK; // supress this error
                            }
                        }
                    }

                    for(UINT i = 0; i < cp; i++) {
                        rgp[i]->Release();
                    }
                }

                pep->Release();
            }
        }

        pi.pFilter->Release();
    }

    if(FAILED(hr)) {
        ASSERT(!*ppPinNext);
    }

    return hr;
}

// go upstream or downstream until a filter added manually is found or
// until the furthest filter supporting dynamic reconnection
// (IPinConnection or IPinFlowControl) is found. stop if mux/demux
// found.
//

HRESULT CGraphConfig::GetSinkOrSource(IPin *pPin, IPin **ppPinOut, HANDLE hAbortEvent)
{
    //  Lock the graph with the special lock then call back
    if (!m_pGraph->GetCritSec()->Lock(hAbortEvent)) {
        return VFW_E_STATE_CHANGED;
    }

    HRESULT hr = GetSinkOrSourceHelper(pPin, ppPinOut);

    m_pGraph->GetCritSec()->Unlock();

    return hr;
}

HRESULT CGraphConfig::GetSinkOrSourceHelper(IPin *pPin, IPin **ppPinOut)
{
    // A race condition could occur if the caller does not hold
    // the filter graph lock.
    ASSERT( CritCheckIn( m_pGraph->GetCritSec() ) );

    *ppPinOut = 0;

    HRESULT hr = S_OK;
    QzCComPtr<IPin> pPinLastCandidate, pPinIter;
    hr = pPin->ConnectedTo(&pPinIter);
    if(SUCCEEDED(hr))
    {
        for(;;)
        {
            IPin *pPinEnd;
            bool fIsCandidate;

            hr = TraverseHelper(pPinIter, &pPinEnd, &fIsCandidate);
            if(SUCCEEDED(hr))
            {
                if(fIsCandidate) {
                    pPinLastCandidate = pPinIter; // auto-addref;
                }

                pPinIter = pPinEnd; // auto-release, addref
                if(pPinEnd) {
                    pPinEnd->Release();
                }
            }

            if(!pPinEnd || FAILED(hr)) {
                break;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        if(pPinLastCandidate) {
            *ppPinOut = pPinLastCandidate;
            pPinLastCandidate->AddRef();
        } else {
            hr = VFW_E_NOT_FOUND;
        }
    }

    return hr;
}

// todo -
//
// GetSink graph traversal will hang on dexter circular graphs.

STDMETHODIMP CGraphConfig::SetFilterFlags(IBaseFilter *pFilter, DWORD dwFlags)
{
    CheckPointer( pFilter, E_POINTER );

    CAutoMsgMutex alFilterGraphLock( m_pGraph->GetCritSec() );

    if( !IsValidFilterFlags( dwFlags ) ) {
        return E_INVALIDARG;
    }

    HRESULT hr = m_pGraph->CheckFilterInGraph( pFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    DWORD dwInternalFilterFlags = m_pGraph->GetInternalFilterFlags( pFilter );

    if( AM_FILTER_FLAGS_REMOVABLE & dwFlags ) {
        dwInternalFilterFlags |= FILGEN_FILTER_REMOVEABLE;
    } else {
        dwInternalFilterFlags &= ~FILGEN_FILTER_REMOVEABLE;
    }

    m_pGraph->SetInternalFilterFlags( pFilter, dwInternalFilterFlags );

    return S_OK;
}

STDMETHODIMP CGraphConfig::GetFilterFlags(IBaseFilter *pFilter, DWORD *pdwFlags)
{
    CheckPointer( pFilter, E_POINTER );
    CheckPointer( pdwFlags, E_POINTER );

    ValidateWritePtr( pdwFlags, sizeof(DWORD*) );

    CAutoMsgMutex alFilterGraphLock( m_pGraph->GetCritSec() );

    HRESULT hr = m_pGraph->CheckFilterInGraph( pFilter );
    if( FAILED( hr ) ) {
        return hr;
    }

    DWORD dwInternalFilterFlags = m_pGraph->GetInternalFilterFlags( pFilter );

    *pdwFlags = 0;

    if( FILGEN_FILTER_REMOVEABLE & dwInternalFilterFlags ) {
        (*pdwFlags) |= AM_FILTER_FLAGS_REMOVABLE;
    }

    //Make sure the function only returns valid information.
    ASSERT( IsValidFilterFlags( *pdwFlags ) );

    return S_OK;
}

STDMETHODIMP CGraphConfig::RemoveFilterEx(IBaseFilter *pFilter, DWORD Flags)
{
    return m_pGraph->RemoveFilterEx( pFilter, Flags );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\distrib.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.

#ifndef __DISTRIB_H__
#define __DISTRIB_H__

// This class supports plug-in distributors into the filtergraph.
//
// The filtergraph is a COM object that provides a single point of control
// for applications. It may contain several filters. The application will want to
// control those filters by talking to an interface on the filtergraph. For
// example, the app controls volume by asking the filtergraph for IBasicAudio
// and setting the volume property. The filtergraph has no knowledge of
// IBasicAudio itself, so it finds a plug-in distributor. This is an object
// that implements (eg) IBasicAudio by enumerating the filters in the graph
// and talking to those that support audio output. For any given interface we
// are asked for, we look for a clsid in the registry of an object that can
// implement that interface by distributing its methods to relevant filters
// in the graph.
//
// A distributor is instantiated as an aggregated object. It is created with
// an outer IUnknown* to which it defers all QueryInterface, AddRef and
// Release calls. It can also Query that outer unknown to obtain interfaces
// such as IFilterGraph which it uses to talk to the filters within the graph.
// This outer unknown is the filtergraph itself. Distributors must not
// hold refcounts on interfaces obtained from the filtergraph or circular
// refcounts will prevent anything from being released.
//
// The CDistributorManager class defined here manages a list of distributors.
// It will search the registry for a distributor for any given interface,
// and instantiate it aggregated by the outer unknown given on construction.
// It will make only one instance of a given class id. It also caches
// interfaces to reduce accesses to the registry.
//
// It will pass on Run, Pause, Stop and SetSyncSource calls to those
// loaded distributors that support IDistributorNotify. For backwards
// compatibility, we pass state changes to distributors that support
// IMediaFilter instead.


// This object represents one loaded distributor.
//
// for each loaded distributor, we remember
// its clsid (to avoid loading multiple instances of the
// same clsid), its non-delegating IUnknown to make new
// interfaces from, and its IMediaFilter (optional) to pass
// messages on to.
class CMsgMutex;  // predeclare
class CDistributor {
public:
    CLSID m_Clsid;

    // instantiate it from a clsid
    CDistributor(LPUNKNOWN pUnk, CLSID *clsid, HRESULT * phr, CMsgMutex * pFilterGraphCritSec );
    ~CDistributor();

    HRESULT QueryInterface(REFIID, void**);

    HRESULT Run(REFERENCE_TIME t);
    HRESULT Pause();
    HRESULT Stop();
    HRESULT SetSyncSource(IReferenceClock* pClock);
    HRESULT NotifyGraphChange();

private:
    IUnknown* m_pUnk;           // non-del unknown for plug-in object
    IUnknown* m_pUnkOuter;      // pUnk for aggregator
    IDistributorNotify *m_pNotify;
    IMediaFilter * m_pMF;
};

// this class represents one interface supported by a loaded
// distributor. We maintain a list of these
// simply as a cache to reduce registy accesses.
class CDistributedInterface {
public:
    GUID m_iid;
    IUnknown* m_pInterface;
    CDistributedInterface(REFIID, IUnknown*);
};

class CDistributorManager
{
public:

    // outer unknown passed to constructor is used as the aggregator for
    // all instantiations
    CDistributorManager(LPUNKNOWN pUnk, CMsgMutex * pFilterGraphCritSec );
    ~CDistributorManager();

// call this to find an interface distributor. If one is not already loaded
// it will search HKCR\Interface\<iid>\Distributor for a clsid and then
// instantiate that object.

    HRESULT QueryInterface(REFIID iid, void ** ppv);

// we pass on the basic IMediaFilter methods
    HRESULT Run(REFERENCE_TIME tOffset);
    HRESULT Pause();
    HRESULT Stop();
    HRESULT SetSyncSource(IReferenceClock* pClock);
    HRESULT NotifyGraphChange();

// notify shutdown to the IMediaEventSink handler if loaded
    HRESULT Shutdown(void);

protected:

    // protect against re-entry during destructor - destroying the list
    // of PIDs can lead to events eg NotifyGraphChange being called when the
    // lists are partly destroyed - if this member is TRUE then the
    // lists are not valid
    BOOL m_bDestroying;

    HRESULT GetDistributorClsid(REFIID riid, CLSID *pClsid);
    HRESULT ReturnInterface(CDistributor*, REFIID, void**);

    // this is the aggregator object
    LPUNKNOWN m_pUnkOuter;

    // pass on sync source and state to new objects
    FILTER_STATE m_State;
    REFERENCE_TIME m_tOffset;
    IReferenceClock * m_pClock;
    CMsgMutex * m_pFilterGraphCritSec;

    // list of loaded distributors
    CGenericList<CDistributor> m_listDistributors;

    // list of supported interfaces that we have returned already
    CGenericList<CDistributedInterface> m_listInterfaces;
};



#endif // __DISTRIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\efcache.cpp ===
// Copyright (c) Microsoft Corporation 1999. All Rights Reserved

//
//   efcache.cpp
//
//       Implementation of filter enumerator for filter graph's
//       filter cache
//

#include <streams.h>
#include "FilCache.h"
#include "EFCache.h"
#include "MsgMutex.h"

/******************************************************************************
    CEnumCachedFilter Interface
******************************************************************************/
CEnumCachedFilter::CEnumCachedFilter( CFilterCache* pEnumeratedFilterCache, CMsgMutex* pcsFilterCache ) :
    CUnknown( NAME("Enum Cached Filters"), NULL )
{
    Init( pEnumeratedFilterCache,
          pcsFilterCache,
          pEnumeratedFilterCache->GetFirstPosition(),
          pEnumeratedFilterCache->GetCurrentVersion() );
}

CEnumCachedFilter::CEnumCachedFilter
    (
    CFilterCache* pEnumeratedFilterCache,
    CMsgMutex* pcsFilterCache,
    POSITION posCurrentFilter,
    DWORD dwCurrentCacheVersion
    ) :
    CUnknown( NAME("Enum Cached Filters"), NULL )
{
    Init( pEnumeratedFilterCache, pcsFilterCache, posCurrentFilter, dwCurrentCacheVersion );
}

CEnumCachedFilter::~CEnumCachedFilter()
{
}

void CEnumCachedFilter::Init
    (
    CFilterCache* pEnumeratedFilterCache,
    CMsgMutex* pcsFilterCache,
    POSITION posCurrentFilter,
    DWORD dwCurrentCacheVersion
    )
{
    // This class can not function if pEnumeratedFilterCache is not a
    // pointer to a valid CFilterCache object.
    ASSERT( NULL != pEnumeratedFilterCache );

    m_pcsFilterCache = pcsFilterCache;
    m_posCurrentFilter = posCurrentFilter;
    m_dwEnumCacheVersion = dwCurrentCacheVersion;
    m_pEnumeratedFilterCache = pEnumeratedFilterCache;
}

/******************************************************************************
    INonDelegatingUnknown Interface
******************************************************************************/
STDMETHODIMP CEnumCachedFilter::NonDelegatingQueryInterface( REFIID riid, void** ppv )
{
    CheckPointer( ppv, E_POINTER );
    ValidateWritePtr( ppv, sizeof(void*) );

    if( IID_IEnumFilters == riid )
    {
        return GetInterface( (IEnumFilters*)this, ppv );
    }
    else
    {
        return CUnknown::NonDelegatingQueryInterface( riid, ppv );
    }
}

/******************************************************************************
    IEnumFilters Interface
******************************************************************************/
STDMETHODIMP CEnumCachedFilter::Next( ULONG cFilters, IBaseFilter** ppFilter, ULONG* pcFetched )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    ValidateWritePtr( ppFilter, sizeof(IBaseFilter*)*cFilters );

    if( NULL != pcFetched )
    {
        ValidateReadWritePtr( pcFetched, sizeof(ULONG) );
        *pcFetched = 0;
    }

    // Validate Arguments
    if( 0 == cFilters )
    {
        // While cFilters can equal 0 (see the IEnumXXXX::Next() documentation in the Platform SDK),
        // this is probably an error
        ASSERT( false );
        return E_INVALIDARG;
    }

    if( NULL == ppFilter )
    {
        // ppFilter should never be NULL.
        ASSERT( false );
        return E_POINTER;
    }

    if( (NULL == pcFetched) && (1 != cFilters) )
    {
        // pcFetched can only equal NULL if cFilters equals 1.  See
        // the IEnumXXXX::Next() documentation in the Platform SDK for
        // more information.
        ASSERT( false );
        return E_POINTER;
    }

    if( IsEnumOutOfSync() )
    {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    IBaseFilter* pNextFilter;
    ULONG ulNumFiltersCoppied = 0;

    while( (ulNumFiltersCoppied < cFilters) && GetNextFilter( &pNextFilter ) )
    {
        pNextFilter->AddRef();
        ppFilter[ulNumFiltersCoppied] = pNextFilter;
        ulNumFiltersCoppied++;
    }

    if( NULL != pcFetched )
    {
        *pcFetched = ulNumFiltersCoppied;
    }

    if( ulNumFiltersCoppied != cFilters )
    {
        return S_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CEnumCachedFilter::Skip( ULONG cFilters )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    // The caller probably wants to skip atleast one filter.
    // Skipping 0 filters is a no-op (it's also probably a
    // bug in the calling code).
    ASSERT( 0 != cFilters );

    if( IsEnumOutOfSync() )
    {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    ULONG ulNumFiltersSkipped = 0;

    while( (ulNumFiltersSkipped < cFilters) && AdvanceCurrentPosition() )
    {
        ulNumFiltersSkipped++;
    }

    if( cFilters != ulNumFiltersSkipped )
    {
        return S_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CEnumCachedFilter::Reset( void )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    m_posCurrentFilter = m_pEnumeratedFilterCache->GetFirstPosition();
    m_dwEnumCacheVersion = m_pEnumeratedFilterCache->GetCurrentVersion();

    return S_OK;
}

STDMETHODIMP CEnumCachedFilter::Clone( IEnumFilters** ppCloanedEnum )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    ValidateReadWritePtr( ppCloanedEnum, sizeof(IEnumFilters*) );

    if( NULL == ppCloanedEnum )
    {
        return E_POINTER;
    }

    IEnumFilters* pNewFilterCacheEnum;

    pNewFilterCacheEnum = new CEnumCachedFilter( m_pEnumeratedFilterCache,
                                                 m_pcsFilterCache,
                                                 m_posCurrentFilter,
                                                 m_dwEnumCacheVersion );
    if( NULL == pNewFilterCacheEnum )
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = ::GetInterface( pNewFilterCacheEnum, (void**)ppCloanedEnum );
    if( FAILED( hr ) )
    {
        delete pNewFilterCacheEnum;
        return hr;
    }

    return S_OK;
}

bool CEnumCachedFilter::IsEnumOutOfSync( void )
{
    return !(m_pEnumeratedFilterCache->GetCurrentVersion() == m_dwEnumCacheVersion);
}

bool CEnumCachedFilter::GetNextFilter( IBaseFilter** ppNextFilter )
{
    // This code may malfunction if it's called when the enum is out of sync.
    ASSERT( !IsEnumOutOfSync() );

    return m_pEnumeratedFilterCache->GetNextFilterAndFilterPosition( ppNextFilter,
                                                                     m_posCurrentFilter,
                                                                     &m_posCurrentFilter );
}

bool CEnumCachedFilter::AdvanceCurrentPosition( void )
{
    // This code may malfunction if it's called when the enum is out of sync.
    ASSERT( !IsEnumOutOfSync() );

    return m_pEnumeratedFilterCache->GetNextFilterPosition( m_posCurrentFilter, &m_posCurrentFilter );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\dyngraph.h ===
// Copyright (c) Microsoft Corporation 1996-1999. All Rights Reserved

class CFilterGraph;
class CFilterCache;

#include "util.h"

//  Dynamic graph object - just forwards stuff to the filter graph
class CGraphConfig :
    public IGraphConfig,
    public CUnknown
{
public:
    CGraphConfig(CFilterGraph *pGraph, HRESULT *phr);
    ~CGraphConfig();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);    

    //  IGraphConfig
    
    STDMETHODIMP Reconnect(IPin *pOutputPin, 
                           IPin *pInputPin,
                           const AM_MEDIA_TYPE *pmtFirstConnection,
                           IBaseFilter *pUsingFilter, // can be NULL
                           HANDLE hAbortEvent,
                           DWORD dwFlags);

    STDMETHODIMP Reconfigure(IGraphConfigCallback *pCallback,
                             PVOID pvContext,
                             DWORD dwFlags,
                             HANDLE hAbortEvent);

     
    STDMETHODIMP AddFilterToCache(IBaseFilter *pFilter);
    STDMETHODIMP EnumCacheFilter(IEnumFilters **pEnum);
    STDMETHODIMP RemoveFilterFromCache(IBaseFilter *pFilter);

    STDMETHODIMP GetStartTime(REFERENCE_TIME *prtStart);

    STDMETHODIMP PushThroughData(
        IPin *pOutputPin,
        IPinConnection *pConnection,
        HANDLE hEventAbort );

    STDMETHODIMP SetFilterFlags(IBaseFilter *pFilter, DWORD dwFlags);
    STDMETHODIMP GetFilterFlags(IBaseFilter *pFilter, DWORD *pdwFlags);

    STDMETHODIMP RemoveFilterEx( IBaseFilter *pFilter, DWORD Flags );
    

private:    
    HRESULT GetSinkOrSource(IPin *pPin, IPin **ppPinOut, HANDLE hAbortEvent);
    HRESULT GetSinkOrSourceHelper(IPin *pPin, IPin **ppPinOut);
    HRESULT TraverseHelper(IPin *pPinStart, IPin **ppPinNext, bool *pfIsCandidate);
    
    bool IsValidFilterFlags( DWORD dwFlags );

    CFilterGraph *m_pGraph;
    CFilterCache* m_pFilterCache;
};

inline bool CGraphConfig::IsValidFilterFlags( DWORD dwFlags )
{
    const DWORD VALID_FLAGS_MASK = AM_FILTER_FLAGS_REMOVABLE;

    return ValidateFlags( VALID_FLAGS_MASK, dwFlags );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\filgatl.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\filcache.h ===
// Copyright (c) Microsoft Corporation 1996-1999. All Rights Reserved

//
//
//   filcache.h
//
//   Definitions for filter graph cache
//
#ifndef FilterCache_h
#define FilterCache_h

class CMsgMutex;

class CFilterCache
{
public:
    CFilterCache( CMsgMutex* pcsFilterCache, HRESULT* phr );
    ~CFilterCache();

    HRESULT AddFilterToCache( IBaseFilter* pFilter );
    HRESULT EnumCacheFilters( IEnumFilters** ppCurrentCachedFilters );
    HRESULT RemoveFilterFromCache( IBaseFilter* pFilter );

    ULONG GetCurrentVersion( void ) const;
    POSITION GetFirstPosition( void );
    bool GetNextFilterAndFilterPosition
        (
        IBaseFilter** ppNextFilter,
        POSITION posCurrent,
        POSITION* pposNext
        );
    bool GetNextFilterPosition( POSITION posCurrent, POSITION* pposNext );

private:
    HRESULT AddFilterToCacheInternal( IBaseFilter* pFilter );
    HRESULT EnumCacheFiltersInternal( IEnumFilters** ppCurrentCachedFilters );
    HRESULT RemoveFilterFromCacheInternal( IBaseFilter* pFilter );
    bool IsFilterInCache( IBaseFilter* pFilter );

    static HRESULT AreAllPinsUnconnected( IBaseFilter* pFilter );
    bool FindCachedFilter( IBaseFilter* pFilter, POSITION* pPosOfFilter );

    #ifdef DEBUG
    void CFilterCache::AssertValid( void );
    #endif // DEBUG

    // The cached filters are stored in this list.
    CGenericList<IBaseFilter>* m_pCachedFilterList;

    CMsgMutex* m_pcsFilterCache;

    ULONG m_ulFilterCacheVersion;
};

#endif // FilterCache_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\fgenum.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

//
// fgenum.cpp
//

// Wrappers for IEnumXXX
// see fgenum.h for more information

// #include <windows.h> already included in streams.h
#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <hrExcept.h>

#include <atlbase.h>
#include "fgenum.h"

// Should a pin be default rendered
bool RenderPinByDefault(IPin *pPin)
{
    PIN_INFO pinInfo;
    HRESULT hr = pPin->QueryPinInfo(&pinInfo);
    if (SUCCEEDED(hr)) {
        if (pinInfo.pFilter) {
            pinInfo.pFilter->Release();
        }
        if (pinInfo.achName[0] == L'~') {
            return false;
        }
    }
    return true;
}

// *
// * CEnumPin
// *

// Enumerates a filter's pins.

//
// Constructor
//
// Set the type of pins to provide - PINDIR_INPUT, PINDIR_OUTPUT or all
CEnumPin::CEnumPin(
    IBaseFilter *pFilter,
    DirType Type,
    BOOL bDefaultRenderOnly
)
    : m_Type(Type),
      m_bDefaultRenderOnly(bDefaultRenderOnly)
{

    if (m_Type == PINDIR_INPUT) {

        m_EnumDir = ::PINDIR_INPUT;
    }
    else if (m_Type == PINDIR_OUTPUT) {

        m_EnumDir = ::PINDIR_OUTPUT;
    }

    ASSERT(pFilter);

    HRESULT hr = pFilter->EnumPins(&m_pEnum);
    if (FAILED(hr)) {
        // we just fail to return any pins now.
        DbgLog((LOG_ERROR, 0, TEXT("EnumPins constructor failed")));
        ASSERT(m_pEnum == 0);
    }
}


//
// CPinEnum::Destructor
//
CEnumPin::~CEnumPin(void) {

    if(m_pEnum) {
        m_pEnum->Release();
    }
}


//
// operator()
//
// return the next pin, of the requested type. return NULL if no more pins.
// NB it is addref'd
IPin *CEnumPin::operator() (void) {


    if(m_pEnum)
    {
        ULONG	ulActual;
        IPin	*aPin[1];

        for (;;) {

            HRESULT hr = m_pEnum->Next(1, aPin, &ulActual);
            if (SUCCEEDED(hr) && (ulActual == 0) ) {	// no more filters
                return NULL;
            }
            else if (hr == VFW_E_ENUM_OUT_OF_SYNC)
            {
                m_pEnum->Reset();

                continue;
            }
            else if (ulActual==0)
                return NULL;

            else if (FAILED(hr) || (ulActual != 1) ) {	// some unexpected problem occured
                ASSERT(!"Pin enumerator broken - Continuation is possible");
                return NULL;
            }

            // if m_Type == All return the first pin we find
            // otherwise return the first of the correct sense

            PIN_DIRECTION pd;
            if (m_Type != All) {

                /*  Check if we need to only return default rendered
                    pins
                    */
                hr = aPin[0]->QueryDirection(&pd);

                if (FAILED(hr)) {
                    aPin[0]->Release();
                    ASSERT(!"Query pin broken - continuation is possible");
                    return NULL;
                }
            }

            if (m_Type == All || pd == m_EnumDir) {	// its the direction we want

                //  Screen out pins not required by default
                if (m_bDefaultRenderOnly) {
                    if (!RenderPinByDefault(aPin[0])) {
                        aPin[0]->Release();
                        continue;
                    }
                }
                return aPin[0];
            }
            else {			// its not the dir we want, so release & try again
                aPin[0]->Release();
            }
        }
    }
    else                        // m_pEnum == 0
    {
        return 0;
    }
}




// *
// * CEnumElements - enumerates elements in a Storage
// *


//
// Constructor
//
CEnumElements::CEnumElements(IStorage *pStorage) {

    HRESULT hr = pStorage->EnumElements(0, NULL, 0, &m_pEnum);
    if (FAILED(hr)) {
        ASSERT(!"EnumElements constructor failed");
        m_pEnum = NULL;
    }
}


//
// operator ()
//
// return the next element, or NULL if no more
STATSTG *CEnumElements::operator() (void) {

    ULONG ulActual;


    HRESULT hr;

    STATSTG *pStatStg = new STATSTG;
    if (pStatStg == NULL) {
        ASSERT(!"Out of memory");
        return NULL;
    }

    hr = m_pEnum->Next(1, pStatStg, &ulActual);
    if (SUCCEEDED(hr) && (ulActual == 0)) {
        return NULL;
    }
    else if (FAILED(hr) || (ulActual != 1)) {
        ASSERT(!"Broken enumerator");
        return NULL;
    }

    return pStatStg;
}

//  Enumerate pins connected to another pin through a filter
CEnumConnectedPins::CEnumConnectedPins(IPin *pPin, HRESULT *phr) :
    m_ppPins(NULL), m_dwPins(0), m_dwCurrent(0)
{
    *phr = pPin->QueryInternalConnections(NULL, &m_dwPins);
    if (SUCCEEDED(*phr)) {
        m_ppPins = new PPIN[m_dwPins];
        if( NULL == m_ppPins ) {
            *phr = E_OUTOFMEMORY;
            return;
        }
        *phr = pPin->QueryInternalConnections(m_ppPins, &m_dwPins);
    } else {
        PIN_INFO pi;
        *phr = pPin->QueryPinInfo(&pi);
        if (SUCCEEDED(*phr) && pi.pFilter != NULL) {
            m_pindir = (PINDIR_INPUT + PINDIR_OUTPUT) - pi.dir;
            *phr = pi.pFilter->EnumPins(&m_pEnum);
            pi.pFilter->Release();
        }
    }
}


CEnumConnectedPins::~CEnumConnectedPins()
{
    if (m_ppPins) {
        for (DWORD i = 0; i < m_dwPins; i++) {
            m_ppPins[i]->Release();
        }
        delete [] m_ppPins;
    }
}

IPin *CEnumConnectedPins::operator() (void) {
    if (m_ppPins) {
        if (m_dwCurrent++ < m_dwPins) {
            IPin *pPin = m_ppPins[m_dwCurrent - 1];
            pPin->AddRef();
            return pPin;
        } else {
            return NULL;
        }
    } else {
        IPin *pPin;
        DWORD dwGot;
        while (S_OK == m_pEnum->Next(1, &pPin, &dwGot)) {
            PIN_DIRECTION dir;
            if (SUCCEEDED(pPin->QueryDirection(&dir)) && 
                dir == m_pindir) {
                return pPin;
            } else {
                pPin->Release();
            }
        }
        return NULL;
    }
}

/******************************************************************************
    CEnumCachedFilters's Public Functions
******************************************************************************/

CEnumCachedFilters::CEnumCachedFilters( IGraphConfig* pFilterCache, HRESULT* phr ) :
    m_pCachedFiltersList(NULL),
    m_posCurrentFilter(NULL)
{
    HRESULT hr = TakeFilterCacheStateSnapShot( pFilterCache );
    if( FAILED( hr ) ) {
        DestoryCachedFiltersEnum();
        *phr = hr;
        return;
    }
}

CEnumCachedFilters::~CEnumCachedFilters()
{
    DestoryCachedFiltersEnum();
}

IBaseFilter* CEnumCachedFilters::operator()( void )
{
    // m_posCurrentFilter position is moved to the next filter as part of this operation.
    IBaseFilter* pCurrentFilter = m_pCachedFiltersList->GetNext( m_posCurrentFilter /* IN and OUT */ );

    // CGenericList::GetNext() returns NULL if the next filter does not exist.    
    if( NULL != pCurrentFilter ) {
        pCurrentFilter->AddRef();
    }

    return pCurrentFilter;
}

/******************************************************************************
    CEnumCachedFilters's Private Functions
******************************************************************************/
HRESULT CEnumCachedFilters::TakeFilterCacheStateSnapShot( IGraphConfig* pFilterCache )
{
    // CGenericList allocates space for 10 filters.  The list may expand 
    // if more filters are added.
    const DWORD DEFAULT_CACHED_FILTERS_LIST_SIZE = 10;

    m_pCachedFiltersList = new CGenericList<IBaseFilter>( NAME("Enum Cached Filters"), DEFAULT_CACHED_FILTERS_LIST_SIZE );
    if( NULL == m_pCachedFiltersList ) {
        return E_OUTOFMEMORY;
    }

    IEnumFilters* pCachedFiltersEnum;

    HRESULT hr = pFilterCache->EnumCacheFilter( &pCachedFiltersEnum );
    if( FAILED( hr ) ) {
        return hr;
    }

    POSITION posNewFilter;
    IBaseFilter* aNextCachedFilter[1];

    do
    {
        hr = pCachedFiltersEnum->Next( 1, aNextCachedFilter, NULL );
        if( FAILED( hr ) ) {
            pCachedFiltersEnum->Release();
            return hr;
        }

        // IEnumFilters::Next() only returns two success values: S_OK and S_FALSE.
        ASSERT( (S_OK == hr) || (S_FALSE == hr) );

        if( S_OK == hr ) {
            posNewFilter = m_pCachedFiltersList->AddTail( aNextCachedFilter[0] );
            if( NULL == posNewFilter ) {
                aNextCachedFilter[0]->Release();
                pCachedFiltersEnum->Release();
                return E_FAIL;
            }
        }
    }
    while( S_OK == hr );

    pCachedFiltersEnum->Release();

    m_posCurrentFilter = m_pCachedFiltersList->GetHeadPosition();

    return S_OK;    
}

void CEnumCachedFilters::DestoryCachedFiltersEnum( void )
{
    IBaseFilter* pCurrentFilter;

    if( NULL != m_pCachedFiltersList ) {

        do {

            pCurrentFilter = m_pCachedFiltersList->RemoveHead();

            // CGenericList::RemoveHead() returns NULL if an error occurs.
            if( NULL != pCurrentFilter ) {
                pCurrentFilter->Release();
            }

        } while( NULL != pCurrentFilter );

        delete m_pCachedFiltersList;
        m_pCachedFiltersList = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\filgraph.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

/**************************************************************
The main file for implementation of the filter graph component.
Other files are
Filter graph sorting        sort.cpp
Intelligent render/connect  intel.cpp
******************************************************************/

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

/*********************************************************************
From Geraint's code review:

-- RenderByFindingPin and RenderUsingFilter need to document their assumptions
about the state of the lists on entry and exit. RenderUsingFilter appears to
do one unnecessary Backout(NewActs) on a list that should always be empty. If
it's needed here, then its also needed in RenderByFindingPin.

-- we need a policy on selecting the default clock. If more than one
filter exposes a clock, we may find that one of them will not accept
sync to another clock.

-- Use CAMThread for the Reconnect stuff.
***********************************************************/

/*********************** TO DO *********************************************
1.  No MRIDs (registering, unregistering or using)
16. No IDispatch
****************************************************************************/

#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <string.h>
#ifdef FILTER_DLL
#include <initguid.h>
#include <olectlid.h>
#include <rsrcmgr.h>
#include <fgctl.h>
#endif // FILTER_DLL

#include <ftype.h>        // GetMediaTypeFile
#include <comlite.h>
#include "MsgMutex.h"
#include "fgenum.h"
#include "rlist.h"
#include "distrib.h"
#include "filgraph.h"
#include "mapper.h"
#include "mtutil.h"
#include "resource.h"
#include <fgctl.h>
#include <stddef.h>
#include "FilChain.h"

const int METHOD_TRACE_LOGGING_LEVEL = 7;

// null security descriptor cached on dll attach.
SECURITY_ATTRIBUTES *g_psaNullDescriptor;

// Stats logging
CStats g_Stats;

extern HRESULT GetFilterMiscFlags(IUnknown *pFilter, DWORD *pdwFlags);

const REFERENCE_TIME MAX_GRAPH_LATENCY = 500 * (UNITS / MILLISECONDS );

// reg key to enable/disable setting of graph latency
const TCHAR g_szhkPushClock[] = TEXT( "Software\\Microsoft\\DirectShow\\PushClock");
const TCHAR g_szhkPushClock_SyncUsingOffset[] = TEXT( "SyncUsingOffset" );
const TCHAR g_szhkPushClock_MaxGraphLatencyMS[] = TEXT( "MaxGraphLatencyMS" );

const TCHAR chRegistryKey[] = TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie Filters\\FilterGraph");
//  Registry values
DWORD
GetRegistryDWORD(
    const TCHAR *pKey,
    DWORD dwDefault
    )
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(
               HKEY_CURRENT_USER,
               chRegistryKey,
               0,
               KEY_QUERY_VALUE,
               &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;

        dwLen = sizeof(DWORD);
        RegQueryValueEx(hKey, pKey, 0L, &dwType,
                        (LPBYTE)&dwDefault, &dwLen);
        RegCloseKey(hKey);
    }
    return dwDefault;
}

//  Helper to get a filter's name
void GetFilterName(IPin *pPin, WCHAR *psz)
{
    PIN_INFO pi;
    if (SUCCEEDED(pPin->QueryPinInfo(&pi))) {
        if (pi.pFilter) {
            FILTER_INFO fi;
            if (SUCCEEDED(pi.pFilter->QueryFilterInfo(&fi))) {
                if (fi.pGraph != NULL) {
                    fi.pGraph->Release();
                }
                lstrcpyWInternal(psz, fi.achName);
            }
            pi.pFilter->Release();
        }
    }
}

// -- Stuff to create a graph on another thread so it stays around and
//    has access to a message loop.  We can create as many graphs
//    as we like on the thread

CRITICAL_SECTION g_csObjectThread;
DWORD            g_cFGObjects;
DWORD            g_dwObjectThreadId;

//=====================================================================
//=====================================================================
// Auxiliary functions etc.
//=====================================================================
//=====================================================================

//=====================================================================
//  Instantiate a filter
//=====================================================================
STDAPI CoCreateFilter(const CLSID *pclsid, IBaseFilter **ppFilter)
{
    DbgLog((LOG_TRACE, 3, TEXT("Creating filter")));
    HRESULT hr =
           CoCreateInstance( *pclsid        // source filter
                           , NULL           // outer unknown
                           , CLSCTX_INPROC
                           , IID_IBaseFilter
                           , (void **) ppFilter // returned value
                           );
    DbgLog((LOG_TRACE, 3, TEXT("Created filter")));
    return hr;
}

//  Called from the message proc for AWM_CREATFILTER
void CFilterGraph::OnCreateFilter(
    const AwmCreateFilterArg *pArg,
    IBaseFilter **ppFilter
)
{
    ReplyMessage(0);

    if(pArg->creationType ==  AwmCreateFilterArg::BIND_MONIKER)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Binding to filter")));
        m_CreateReturn = pArg->pMoniker->BindToObject(
            m_lpBC, 0, IID_IBaseFilter, (void **)ppFilter);
        DbgLog((LOG_TRACE, 3, TEXT("Bound to filter")));
    }
    else
    {
        ASSERT(pArg->creationType == AwmCreateFilterArg::COCREATE_FILTER);
        m_CreateReturn = CoCreateFilter(pArg->pclsid, ppFilter);
    }


    if (FAILED(m_CreateReturn)) {
        DbgLog((LOG_ERROR, 1, TEXT("Failed to create filter code %8.8X"), m_CreateReturn));
    }

    m_evDone.Set();
}

//  Called in response to AWM_DELETESPARELIST
void CFilterGraph::OnDeleteSpareList(WPARAM wParam)
{
    DeleteSpareList(*(CSpareList *)wParam);
}

//=====================================================================
// Create a filter object on the filter graph's thread
//=====================================================================
HRESULT CFilterGraph::CreateFilter(
    const CLSID *pclsid,
    IBaseFilter **ppFilter
)
{
    CAutoTimer Timer(L"Create Filter");
    if (S_OK == CFilterGraph::IsMainThread()) {
        return CoCreateFilter(pclsid, ppFilter);
    } else {
        AwmCreateFilterArg acfa;
        acfa.pclsid = pclsid;
        acfa.creationType = AwmCreateFilterArg::COCREATE_FILTER;
        return CreateFilterHelper(&acfa, ppFilter);
    }
}

HRESULT CFilterGraph::CreateFilter(
    IMoniker *pMoniker,
    IBaseFilter **ppFilter
)
{
    CAutoTimer Timer(L"Create Filter");
    if (S_OK == CFilterGraph::IsMainThread()) {
        return pMoniker->BindToObject(
            m_lpBC, 0, IID_IBaseFilter, (void **)ppFilter);
    } else {
        AwmCreateFilterArg acfa;
        acfa.pMoniker = pMoniker;;
        acfa.creationType = AwmCreateFilterArg::BIND_MONIKER;
        return CreateFilterHelper(&acfa, ppFilter);
    }
}

HRESULT CFilterGraph::CreateFilterHelper(
    const AwmCreateFilterArg *pArg,
    IBaseFilter **ppFilter)
{
    m_CreateReturn = 0xFFFFFFFF;

    DbgLog((LOG_TRACE, 3, TEXT("CreateFilterHelper enter")));
    //  We would have liked to use SendMessage but win95 complained
    //  when we called ce inside SendMessage with
    //  RPC_E_CANTCALLOUT_ININPUTSYNCCALL
    //  So instead call PostMessage and wait for the event
    if (!PostMessage(m_hwnd,
                     AWM_CREATEFILTER,
                     (WPARAM)pArg,
                     (LPARAM)ppFilter)
       ) {
        return E_OUTOFMEMORY;
    }

    //  Even at this point we can be sent a message from
    //  a window on the filter graph thread.  What happens is:
    //  -- The video renderer window gets activated
    //  -- In processing the activation a message gets sent to
    //     a window owned by this thread to deactivate itself
    //
    WaitDispatchingMessages(m_evDone, INFINITE);
    ASSERT(m_CreateReturn != 0xFFFFFFFF);
    DbgLog((LOG_TRACE, 3, TEXT("CreateFilterHelper leave")));
    return m_CreateReturn;
}

//=====================================================================
// Return the length in bytes of str, including the terminating null
//=====================================================================
int BytesLen(LPTSTR str)
{
    if (str==NULL) {
        return 0;
    }
#ifdef UNICODE
    return (sizeof(TCHAR))*(1+wcslen(str));
#else
    return (sizeof(TCHAR))*(1+strlen(str));
#endif
} // BytesLen


//==============================================================================
// List traversal macros.
// NOTE Each of these has three unmatched open braces
// that are matched by the corresponding ENDTRAVERSExxx macro
// It's a single loop in each case so continue and break wil work
// All the names given in the macro call are available inside the loop
// They are all declared in the macro
//
// NB these could be replaced with C++ classes, see fgenum.h CEnumPin
//    TRAVERSEFILTERS may be an especially good candidate.
//==============================================================================

// Interate through every filter in the mFG_FilGenList list.  pCurrentFilter stores
// the IBaseFilter interface pointer for the current filter in the mFG_FilGenList.
#define TRAVERSEFILTERS( pCurrentFilter )                                                   \
        for (POSITION Pos = mFG_FilGenList.GetHeadPosition(); Pos; )                        \
        {   /* Retrieve the current IBaseFilter, side-effect Pos on to the next */          \
            /* IBaseFilter is decended from IMediaFilter, don't need to QI.     */          \
            IBaseFilter * const pCurrentFilter = mFG_FilGenList.Get(Pos)->pFilter;      \
            {

// dynamic reconnections can make the filgenlist change in between
// TRAVERSEFILTERS and ENDTRAVERSEFILTERS, so don't get the next Pos until now
//
#define ENDTRAVERSEFILTERS()                                                                \
            }                                                                               \
        Pos = mFG_FilGenList.Next(Pos);     \
        }                                                                                   \


// set *pfg to each FilGen in mFG_FilGenList in turn
// use Pos as a name of a temp
#define TRAVERSEFILGENS(Pos, pfg)                                              \
    {   POSITION Pos = mFG_FilGenList.GetHeadPosition();                       \
        while(Pos!=NULL) {                                                     \
            /* Retrieve the current IBaseFilter, side-effect Pos on to the next */ \
            FilGen * pfg = mFG_FilGenList.GetNext(Pos);                        \
            {


#define ENDTRAVERSEFILGENS \
            }              \
        }                  \
    }

//==============================================================================


// CumulativeHRESULT - this function can be used to aggregate the return
// codes that are received from the filters when a method is distributed.
// After a series of Accumulate()s m_hr will be:
// a) the first non-E_NOTIMPL failure code, if any;
// b) else the first non-S_OK success code, if any;
// c) E_NOINTERFACE if no Accumulates were made;
// d) E_NOTIMPL iff all Accumulated HRs are E_NOTIMPL
// e) else the first return code (S_OK by implication).

void __fastcall CumulativeHRESULT::Accumulate( HRESULT hrThisHR )
{
    if ( ( m_hr == S_OK || FAILED(hrThisHR) && SUCCEEDED(m_hr) ) && hrThisHR != E_NOTIMPL && hrThisHR != E_NOINTERFACE
         || m_hr == E_NOTIMPL
     || m_hr == E_NOINTERFACE
       )
    {
        m_hr = hrThisHR;
    }
}

#ifdef DEBUG
//===========================================================
//
// DbgDump
//
// Dump all the filter and pin addresses in the filter graph to DbgLog
//===========================================================
void CFilterGraph::DbgDump()
{

    HRESULT hr;
    DbgLog((LOG_TRACE, 2, TEXT("Filter graph dump")));

    CFilGenList::CEnumFilters NextOne(mFG_FilGenList);
    IBaseFilter *pf;

    while ((PVOID) (pf = ++NextOne)) {

        IUnknown * punk;
        pf->QueryInterface( IID_IUnknown, (void**)(&punk) );
        punk->Release();

        // note - name is a WSTR whether we are unicode or not.
        DbgLog((LOG_TRACE, 2
              , TEXT("Filter %x '%ls' Iunknown %x")
              , pf
              , (mFG_FilGenList.GetByFilter(pf))->pName
              , punk
              ));

        CEnumPin NextPin(pf);
        IPin *pPin;

        while ((PVOID) (pPin = NextPin())) {

            PIN_INFO pi;
            pPin->QueryPinInfo(&pi);
            QueryPinInfoReleaseFilter(pi);
            IPin *pConnected;
            hr = pPin->ConnectedTo(&pConnected);
            if (FAILED(hr)) {
                pConnected = NULL;
            }
            DbgLog(( LOG_TRACE, 2, TEXT("    Pin %x %ls (%s) connected to %x")
                   , pPin, pi.achName
                   , ( pi.dir==PINDIR_INPUT ? TEXT("Input") : TEXT("PINDIR_OUTPUT") )
                   , pConnected
                  ));

            if (pConnected != NULL) {
                pConnected->Release();
            }
            pPin->Release();
        }
    }
    DbgLog((LOG_TRACE, 2, TEXT("End of filter graph dump")));
} // DbgDump

//============================================================
//  TestConnection
//
//  Test that 2 pins that say they are connected do roughtly the right
//  things
//
void TestConnection(IPin *ppinIn, IPin *ppinOut)
{
    /*  Check they think they're connected to each other */
    IPin *ppinInTo;
    IPin *ppinOutTo;
    CMediaType mtIn;
    CMediaType mtOut;
    EXECUTE_ASSERT(S_OK == ppinIn->ConnectedTo(&ppinInTo));
    EXECUTE_ASSERT(S_OK == ppinOut->ConnectedTo(&ppinOutTo));
    ASSERT(IsEqualObject(ppinInTo, ppinOut));
    ASSERT(IsEqualObject(ppinOutTo, ppinIn));
    ppinInTo->Release();
    ppinOutTo->Release();
    EXECUTE_ASSERT(S_OK == ppinIn->ConnectionMediaType(&mtIn));
    EXECUTE_ASSERT(S_OK == ppinOut->ConnectionMediaType(&mtOut));
    //  Either the types match or one or other is partially specified
    ASSERT(mtIn == mtOut ||
           (mtIn.majortype == mtOut.majortype &&
            (mtIn.subtype == GUID_NULL && mtIn.formattype == GUID_NULL ||
             mtOut.subtype == GUID_NULL && mtOut.formattype == GUID_NULL)));
    FreeMediaType(mtIn);
    FreeMediaType(mtOut);
}

#endif // DEBUG

#ifdef CHECK_REGISTRY
typedef struct _CLSIDTAB {
    const CLSID * pclsid;
    LPCTSTR  szFileName;
} CLSIDTAB;

const CLSIDTAB clsidCheck[2] =
{
    {    &CLSID_DvdGraphBuilder, TEXT("qdvd.dll")
    },
    {    &CLSID_DVDNavigator, TEXT("qdvd.dll")
    }
};

extern HRESULT TextFromGUID2(REFGUID refguid, LPTSTR lpsz, int cbMax);
BOOL CheckValidClsids()
{
    for (int i = 0; i < NUMELMS(clsidCheck); i++) {
        TCHAR KeyName[100];
        lstrcpy(KeyName, TEXT("CLSID\\"));
        TextFromGUID2(*clsidCheck[i].pclsid, KeyName + lstrlen(KeyName), 100);
        lstrcat(KeyName, TEXT("\\InprocServer32"));
        TCHAR szFileName[MAX_PATH];
        LONG cbValue = sizeof(szFileName);
        if (NOERROR == RegQueryValue(HKEY_CLASSES_ROOT,
                               KeyName,
                               szFileName,
                               &cbValue)) {
            //  Check the file name
            LONG szLen = lstrlen(clsidCheck[i].szFileName);

            //  cbValue includes trailing 0
            ASSERT(cbValue > 0);
            cbValue--;
            if (cbValue < szLen ||
                lstrcmpi(clsidCheck[i].szFileName, szFileName + cbValue - szLen)) {
                return FALSE;
            }
            //  Check for derived names
            if (cbValue > szLen && szFileName[cbValue - szLen - 1] != TEXT('\\')) {
                return FALSE;
            }
        }
    }
    return TRUE;
}
#endif // CHECK_REGISTRY

#ifdef FILTER_DLL
//===========================================================
// List of class IDs and creator functions for class factory
//===========================================================

CFactoryTemplate g_Templates[3] =
{
    {L"", &CLSID_FilterGraph, CFilterGraph::CreateInstance},
    {L"", &CLSID_FilterMapper, CFilterMapper::CreateInstance
                             , CFilterMapper::MapperInit},
    {L"", &CLSID_FilterMapper2, CFilterMapper2::CreateInstance
                             , CFilterMapper2::MapperInit},
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif // FILTER_DLL


//==================================================================
//==================================================================
// Members of CFilterGraph
//==================================================================
//==================================================================


//==================================================================
//
// CreateInstance
//
// This goes in the factory template table to create new instances
//==================================================================

CUnknown *CFilterGraph::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CFilterGraph(NAME("Core filter graph"),pUnk, phr);
} // CFilterGraph::Createinstance

#pragma warning(disable:4355)

//==================================================================
//
// CFilterGraph constructor
//
//==================================================================

CFilterGraph::CFilterGraph( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr )
    : CBaseFilter(pName, pUnk, (CCritSec*) this, CLSID_FilterGraph)
    , mFG_hfLog(INVALID_HANDLE_VALUE)
    , mFG_FilGenList(NAME("List of filters in graph"), this)
    , mFG_ConGenList(NAME("List of outstanding connections for graph"))
    , mFG_iVersion(0)
    , mFG_iSortVersion(0)
    , mFG_bDirty(FALSE)
    , mFG_bNoSync(FALSE)
    , mFG_bSyncUsingStreamOffset(FALSE)
    , mFG_rtMaxGraphLatency(MAX_GRAPH_LATENCY)
    , mFG_dwFilterNameCount(0)
#ifdef THROTTLE
    , mFG_AudioRenderers(NAME("List of audio renderers"))
    , mFG_VideoRenderers(NAME("List of video renderers"))
#endif // THROTTLE
    , mFG_punkSite(NULL)
    , mFG_RecursionLevel(0)
    , mFG_ppinRender(NULL)
    , mFG_bAborting(FALSE)
    , m_hwnd(NULL)
    , m_MainThreadId(NULL)
    , mFG_listOpenProgress(NAME("List of filters supporting IAMOpenProgress"))
    , mFG_pDistributor(NULL)
    , mFG_pFGC(NULL)
    , mFG_pMapperUnk(NULL)
    , m_CritSec(phr)
    , m_lpBC(NULL)
    , mFG_bNoNewRenderers(false)
    , mFG_Stats(NULL)
    , m_Config( this, phr )
    , m_pFilterChain(NULL)
    , m_fstCurrentOperation(FST_NOT_STEPPING_THROUGH_FRAMES)
#ifdef DO_RUNNINGOBJECTTABLE
    , m_dwObjectRegistration(0)
#endif
{
#ifdef DEBUG
    mFG_Test = NULL;
#endif // DEBUG

    // Store the application thread ID
    m_MainThreadId = GetCurrentThreadId();

    m_pFilterChain = new CFilterChain( this );
    if( NULL == m_pFilterChain ) {
        *phr = E_OUTOFMEMORY;
        return;
    }

    // Create free threaded marshaler
    IUnknown *pMarshaler;
    HRESULT hr = CoCreateFreeThreadedMarshaler(GetOwner(), &m_pMarshaler);
    if (FAILED(hr)) {
        *phr = hr;
        return;
    }

    // Add stats object
    mFG_Stats = new CComAggObject<CStatContainer>(GetOwner());
    if (mFG_Stats == NULL) {
        *phr = E_OUTOFMEMORY;
        return;
    }
    mFG_Stats->AddRef();

#ifdef CHECK_REGISTRY
    if (!CheckValidClsids()) {
        *phr = HRESULT_FROM_WIN32(ERROR_REGISTRY_CORRUPT);
        return;
    }
#endif // CHECK_REGISTRY
    if (SUCCEEDED(*phr)) {
        // get the unknown for aggregation. can't addref
        // IFilterMapper2 because it'll addref us.
        HRESULT hr = QzCreateFilterObject( CLSID_FilterMapper2, GetOwner(), CLSCTX_INPROC
                                   , IID_IUnknown, (void **) &mFG_pMapperUnk
                                   );
        if (FAILED(hr)) {
            *phr = hr;
        }
        if (SUCCEEDED(*phr)) {

#ifdef PERF
            mFG_PerfConnect       = Msr_Register("FilterGraph Intelligent connect");
            mFG_PerfConnectDirect = Msr_Register("FilterGraph ConnectDirectInternal");
            mFG_NextFilter        = Msr_Register("FilterGraph Next filter");
            mFG_idIntel           = Msr_Register("Intel FG stuff");
            mFG_idConnectFail     = Msr_Register("ConnectDirect Failed");
#ifdef THROTTLE
            mFG_idAudioVideoThrottle = Msr_Register("Audio-Video Throttle");
#endif // THROTTLE
#endif //PERF
       }
    }

    // check whether the default state of mFG_bSyncUsingStreamOffset or
    // mFG_rtMaxGraphLatency has been overridden
    HKEY hkPushClockParams;
    LONG lResult = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        g_szhkPushClock,
        0,
        KEY_READ,
        &hkPushClockParams);
    if(lResult == ERROR_SUCCESS)
    {
        DWORD dwType, dwVal, dwcb;

        // Graph Latency set/unset flag
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkPushClockParams,
            g_szhkPushClock_SyncUsingOffset,
            0,
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            mFG_bSyncUsingStreamOffset = (0 == dwVal ) ? FALSE : TRUE;
        }
        // Max Graph Latency
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkPushClockParams,
            g_szhkPushClock_MaxGraphLatencyMS,
            0,
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            mFG_rtMaxGraphLatency = dwVal * ( UNITS / MILLISECONDS );
        }

        EXECUTE_ASSERT(RegCloseKey(hkPushClockParams) == ERROR_SUCCESS);
    }
#if DEBUG
    if( mFG_bSyncUsingStreamOffset )
        DbgLog((LOG_TRACE, 3, TEXT("Using Graph Latency of %dms"),
              (LONG) (mFG_rtMaxGraphLatency/10000)));
#endif

    // Now build the CFGControl
    if (SUCCEEDED(*phr))
    {
        mFG_pFGC = new CFGControl( this, phr );
        if (NULL == mFG_pFGC) {
            *phr = E_OUTOFMEMORY;
        } else if (SUCCEEDED(*phr)) {
            m_hwnd = mFG_pFGC->GetWorkerHWND();
        }
    }

    if(SUCCEEDED(*phr))
    {
        *phr = CreateBindCtx(0, &m_lpBC);
#ifdef DO_RUNNINGOBJECTTABLE
        if (GetRegistryDWORD(TEXT("Add To ROT on Create"), FALSE)) {
            AddToROT();
        }
#endif // DO_RUNNINGOBJECTTABLE
    }

} // CFilterGraph::CFilterGraph



//==================================================================
//
// RemoveAllConnections
//
// Disconnect all the direct connections of *pFilter, both ends.
// Each connection is removed in upstream order.
//
// Return S_OK disconnect successful or nothing to do. Returns an
// error if Disconnect() returns an error
//==================================================================

HRESULT CFilterGraph::RemoveAllConnections2( IBaseFilter * pFilter)
{
    HRESULT hrDisc = S_OK;

    // Enumerate all the pins and fully disconnect each
    CEnumPin Next(pFilter);
    IPin *pPin;
    while (SUCCEEDED(hrDisc) && (PVOID) (pPin = Next()))
    {
        HRESULT hr;  // return code from things we call

        //-------------------------------------------------
        // Find out direction and any peer connected to
        //-------------------------------------------------
        PIN_DIRECTION pd;
        hr = pPin->QueryDirection(&pd);
        ASSERT(SUCCEEDED(hr));

        IPin *pConnected;
        hr = pPin->ConnectedTo(&pConnected);
        ASSERT(SUCCEEDED(hr) && pConnected  || FAILED(hr) && !pConnected);
        if (SUCCEEDED(hr) && pConnected!=NULL) {

            //-------------------------------------------------
            // Disconnect any downstream peer
            //-------------------------------------------------
            if (pd == PINDIR_OUTPUT) {
                hrDisc = pConnected->Disconnect();
            }

            //-------------------------------------------------
            // Disconnect the pin itself - if it's connected
            //-------------------------------------------------
            if(SUCCEEDED(hrDisc)) {
                hrDisc = pPin->Disconnect();
            }

            //-------------------------------------------------
            // Disconnect any upstream peer
            //-------------------------------------------------
            if (SUCCEEDED(hrDisc) && pd == PINDIR_INPUT) {
                hrDisc = pConnected->Disconnect();
            }

            #ifdef DEBUG
            {
                // Make sure both pins are connected or both pins are disconnected.
                // If one pin is connected and the other pin is disconnected, the
                // filter graph is in an inconsistent state.  
                IPin* pOtherPin;
                bool fPinConnected = false;
                bool fConnectedPinConnected = false;

                HRESULT hrPin = pPin->ConnectedTo(&pOtherPin);
                if (SUCCEEDED(hrPin) && (NULL != pOtherPin)) {
                    fPinConnected = true;
                    pOtherPin->Release();
                }

                HRESULT hrConnected = pConnected->ConnectedTo(&pOtherPin);
                if (SUCCEEDED(hrConnected) && (NULL != pOtherPin)) {
                    fConnectedPinConnected = true;
                    pOtherPin->Release();
                }

                // Either both pins are connected or both pins are not connected.
                // If one pin is connected and the other pin is not connected,
                // the filter graph is in an inconsistent state.  This should be
                // avoided.  There are two possible solutions to this problem.
                //
                // 1) Modify the filter which failed to disconnect.  Change
                //    the code so IPin::Disconnect() cannot fail.
                //    
                // 2) Change the application to prevent it from disconnecting
                //    the pin when the pin does not want to be disconnected.
                // 
                ASSERT((fPinConnected && fConnectedPinConnected) ||
                       (!fPinConnected && !fConnectedPinConnected));
            }
            #endif // DEBUG

            pConnected->Release();
        }

        pPin->Release();
    } // while loop

    // Breaking connections do NOT require re-sorting!
    // They only add even more slack to the partial ordering.

    if(FAILED(hrDisc)) {
        DbgLog((LOG_ERROR, 0, TEXT("RemoveAllConnections2 failed %08x"), hrDisc));
    }

    return hrDisc;
} // RemoveAllConnections



//===================================================================
// RemoveDeferredList
//
// Remove mFG_ConGenList.
// Do NOT update the version number.  This is part of graph destruction.
//===================================================================
HRESULT CFilterGraph::RemoveDeferredList(void)
{
    ConGen * pcg;
    while ((PVOID)(pcg=mFG_ConGenList.RemoveHead())){
        delete pcg;
    }
    return NOERROR;
} // RemoveDeferredList



//==================================================================
//
// CFilterGraph destructor
//
//==================================================================

CFilterGraph::~CFilterGraph()
{
#ifdef DO_RUNNINGOBJECTTABLE
    //  Unregister ourselves if necessary
    if (0 != m_dwObjectRegistration) {
        // keep us from re-entering our destructor when the ROT releases
        // its refcount on us.
        m_cRef++;
        m_cRef++;

        if (m_MainThreadId == g_dwObjectThreadId) {
            // go to the object thread to unregister ourselves
            CAMEvent evDone;
            BOOL bOK = PostThreadMessage(g_dwObjectThreadId, WM_USER + 1,
                                    (WPARAM)this, (LPARAM) &evDone);
            if (bOK)
                WaitDispatchingMessages(HANDLE(evDone), INFINITE);
        } else {
            // unregister ourselves now
            IRunningObjectTable *pirot;
            if (SUCCEEDED(GetRunningObjectTable(0, &pirot))) {
                pirot->Revoke(m_dwObjectRegistration);
                pirot->Release();
            }
        }

        //EXECUTE_ASSERT(SUCCEEDED(CoDisconnectObject(GetOwner(), NULL)));
        m_dwObjectRegistration = 0;
    }
#endif

    delete m_pFilterChain;
    m_pFilterChain = NULL;

    // We need to tell the control object that we are shutting down
    // otherwise it can find itself processing a PAUSE after we have
    // done the Stop, and then the pins don't like to disconnect and
    // then the filters won't delete themselves.
    if (mFG_pFGC) mFG_pFGC->Shutdown();
    if (mFG_pDistributor) mFG_pDistributor->Shutdown();

    // Set all filters to stopped
    // again here in case the worker thread started anything before it was
    // shutdown
    Stop();

    RemoveAllFilters();
    RemoveDeferredList();

#ifdef THROTTLE
    ASSERT(mFG_VideoRenderers.GetCount()==0);
    ASSERT(mFG_AudioRenderers.GetCount()==0);
#endif // THROTTLE

    // clock should be gone by now.
    // what if it's an external clock???
    // ---as the comment above says, this is an invalid assert - the clock
    // will only be gone now if it came from a filter. The system clock
    // won't have gone away yet if we're using it.
    //    ASSERT(m_pClock == NULL);

    if (m_pClock) {
        m_pClock->Release();

        // must set it to null as this variable is owned by a base class
        m_pClock = NULL;
    }

    if (mFG_pMapperUnk) {
        mFG_pMapperUnk->Release();
    }

#ifdef DEBUG
    delete mFG_Test;
#endif // DEBUG

#ifdef DUMPPERFLOGATEND
#ifdef PERF
    HANDLE hFile = CreateFile( "c:\\filgraph.plog" // file name
                             , GENERIC_WRITE       // access
                             , 0                   // sharemode
                             , NULL                // security
                             , OPEN_ALWAYS
                             , 0                   // flags and attrs
                             , NULL                // hTemplateFile
                             );
    if (hFile==INVALID_HANDLE_VALUE) {
        volatile int i = GetLastError();
        // DbgBreak("Failed to create default perf log ");
        // If you tried to run several graphs at once - e.g. stress then you would hit this
        GetLastError(); // Bogus - hacking round a debugger quirk!
    } else {
        SetFilePointer(hFile, 0, NULL, FILE_END);
        MSR_DUMP(hFile);
        CloseHandle(hFile);
    }

#endif
#endif

    // Harmless on a NULL pointer, so don't test.
    delete mFG_pDistributor;
    delete mFG_pFGC;

    // OK - now tell the object creator thread to go away if necessary
    EnterCriticalSection(&g_csObjectThread);
    if (m_MainThreadId == g_dwObjectThreadId) {
        ASSERT(g_cFGObjects > 0);
        g_cFGObjects--;
        // Give the thread a nudge
        if (g_cFGObjects == 0) {
            PostThreadMessage(g_dwObjectThreadId, WM_NULL, 0, 0);
        }
    }
    LeaveCriticalSection(&g_csObjectThread);

    if(m_lpBC) {
        m_lpBC->Release();
    }

    // this list should be empty by now....
    ASSERT(mFG_listOpenProgress.GetCount() == 0);

    // Release our stats interface
    if (mFG_Stats) {
        mFG_Stats->Release();
    }
    mFG_Stats = NULL;

} // CFilterGraph::~CFilterGraph

//===================================================================
// RemoveAllFilters
//
// Utility function to remove all the filters in the graph.
// Also removes all the connections.
// Does not update the version number.
// This in turn means that it does NOT attempt to rebuild the
// connections list - which makes it OK to delete that stuff first.
//===================================================================
HRESULT CFilterGraph::RemoveAllFilters(void)
{
    HRESULT hr;
    HRESULT hrOverall = NOERROR;

    //-------------------------------------------------------------
    // while (any left in mFG_FilGenList)
    //     Remove the first FilGen from the list
    //     Disconnect all the pins of its filter
    //         // This will often fail because we have already disconnected
    //         // the pin from the other end.  These are harmless no-ops.
    //     Release its filter
    //     Free its storage
    //-------------------------------------------------------------
    while (  mFG_FilGenList.GetCount() > 0 ) {

        FilGen * pfg = mFG_FilGenList.Get( mFG_FilGenList.GetHeadPosition() );
                  ASSERT(pfg);
                  ASSERT(pfg->pFilter);
        hr = RemoveFilterInternal(pfg->pFilter);
        if (FAILED(hr) && SUCCEEDED(hrOverall)) hrOverall = hr;
    }
    return hrOverall;
} // RemoveAllFilters


//===================================================================
//
// RemovePointer
//
// Remove from a list (the first instance of) a given pointer
// return the pointer or NULL if it's not there.
// ??? This should be a generic method on the list
//===================================================================

CFilterGraph::FilGen * CFilterGraph::RemovePointer(CFilGenList &cfgl, IBaseFilter * pFilter)
{
    POSITION Pos;
    Pos = cfgl.GetHeadPosition();
    while(Pos!=NULL) {
        FilGen * pfg;
        POSITION OldPos = Pos;
        pfg = cfgl.GetNext(Pos);    // side-efects Pos onto next
        if (pfg->pFilter == pFilter) {
            cfgl.Remove(OldPos);
            return pfg;
        }
    }
    return NULL;
} // RemovePointer



//========================================================================
//
// AddFilter
//
// Add a filter to the graph and name it with *pName.
// The name is allowed to be NULL,
// If the name is not NULL and not unique, The request will fail.
// The Filter graph will call the JoinFilterGraph
// member function of the filter to inform it.
// This must be called before attempting Connect, ConnectDirect etc
// for pins of the filter.
// The filter is AddReffed iff AddFilter SUCCEEDED
//========================================================================
STDMETHODIMP CFilterGraph::AddFilter( IBaseFilter * pFilter, LPCWSTR pName )
{
    CheckPointer(pFilter, E_POINTER);

    HRESULT hr;
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);
        ++mFG_RecursionLevel;

        hr = AddFilterInternal( pFilter, pName, false );
        if (SUCCEEDED(hr)) {
            IncVersion();
            mFG_RList.Active();
            AttemptDeferredConnections();
            mFG_RList.Passive();
        }
        --mFG_RecursionLevel;
    }

    // notify graph change (self-inhibits if recursive)
    if (SUCCEEDED(hr)) NotifyChange();

    if (FAILED(hr)) {
        Log( IDS_ADDFILTERFAIL, hr );
    } else {
        Log( IDS_ADDFILTEROK );
        mFG_bDirty = TRUE;
    }
    return hr;
} // AddFilter

//========================================================================
// InstallName
//
// Take the name, mangle it if necessary, allocate space, point
// pNewName at it.  If it doesn't work, pName should be NULL.
//========================================================================

HRESULT CFilterGraph::InstallName(LPCWSTR pName, LPWSTR &pNewName)
{
    pNewName = 0;                   // Initialize to null

// leading space not used if empty name passed in
#define SZ_FORMAT_NUMBER (L" %04u")

    const size_t MaxNameWidth
             = NUMELMS( ((FILTER_INFO *)NULL)->achName );
             // Name width is constricted by the achName.  If we name mangle,
             // we ensure that the mangled name will fit in this field.

    HRESULT hr;
    enum _NameState { Used, Created, Mangled } eNameState;

    const WCHAR * pcwstrNameToUse;              // Ptr to name we'll really use
    WCHAR wcsNameBuffer[ MaxNameWidth  ];       // local buffer in case needed

    WCHAR * pwstrNumber = 0;                    // Place where num will be added
                                                // If null => no num needed

    int cchBase = 0;

    if ( pName == 0 || *pName == L'\0' )
    {   // Create
        eNameState = Created;
        *wcsNameBuffer = 0;
        pcwstrNameToUse = wcsNameBuffer;
        cchBase = 1;
    }
    else
    {
        IBaseFilter * pf;
        hr = FindFilterByName( pName, &pf);
        if ( FAILED(hr) )
        {   // Use
            eNameState = Used;
            pcwstrNameToUse = pName;
        }
        else
        {   // Mangle
            eNameState = Mangled;
            cchBase = lstrlenW(pName) + 1;
            cchBase = min(cchBase, MaxNameWidth);
            lstrcpynW(wcsNameBuffer, pName, cchBase);
            pcwstrNameToUse = wcsNameBuffer;
            pf->Release();
        }
    }

    ASSERT( pcwstrNameToUse );

    if (eNameState != Used)
    {
        while(++mFG_dwFilterNameCount)
        {
            UINT iPosSuffix = cchBase - 1;
            
            WCHAR wszNum[20];
            WCHAR *szFormat = eNameState == Created ? SZ_FORMAT_NUMBER + 1 : 
                              SZ_FORMAT_NUMBER;
            wsprintfW(wszNum, szFormat, mFG_dwFilterNameCount);
            const cchNum = lstrlenW(wszNum) + 1; // take log?
            iPosSuffix = min(iPosSuffix, MaxNameWidth - cchNum);

            CopyMemory(wcsNameBuffer + iPosSuffix, wszNum, cchNum * sizeof(WCHAR));
            
            IBaseFilter * pf;
            hr = FindFilterByName( wcsNameBuffer, &pf);
            if ( SUCCEEDED(hr) ) {
                pf->Release();
                continue;
            }

            break;
        }

        if(mFG_dwFilterNameCount == 0) {
            DbgBreak("Duplicate Name!");
            return VFW_E_DUPLICATE_NAME;
        }
    }

    const int ActualLen = 1+lstrlenW(pcwstrNameToUse);
    pNewName = new WCHAR[ActualLen];
    if (pNewName==NULL) {
        return E_OUTOFMEMORY;
    }
    memcpy( pNewName, pcwstrNameToUse, 2*ActualLen );

    return eNameState == Mangled ? VFW_S_DUPLICATE_NAME : NOERROR;
}

//========================================================================
//
// AddFilterInternal
//
// Check for IMediaFilter, check Name is OK, convert null pName to empty Name
// Copy Name into FilGen, JoinFilterGraph and SetSyncSource
// Don't increment the graph version count.
// (Incrementing the version count breaks the filter enumerator).
// Iff it succeeds then AddRef the filter (once!)

// ??? What are the rules if it fails - transactional semantics???
// ??? It certainly doesn't have them at the moment!

//========================================================================

HRESULT CFilterGraph::AddFilterInternal( IBaseFilter * pFilter, LPCWSTR pName, bool fIntelligent )
{
    HRESULT hr, hr2;

    //----------------------------------------------------------------
    // Add the filter to the FilGen list and Addref it
    //----------------------------------------------------------------
    hr = S_OK;

    DWORD dwAddFlag = 0;

    if(m_State != State_Stopped) {
        dwAddFlag |= FILGEN_ADDED_RUNNING;
    }

    if( !fIntelligent ) {
        dwAddFlag |= FILGEN_ADDED_MANUALLY;
    }

    FilGen * pFilGen = new FilGen(pFilter, dwAddFlag);
    if ( pFilGen==NULL ) {
        return E_OUTOFMEMORY;
    }

    //----------------------------------------------------------------
    // Put the name into the FilGen.
    // Convert NULL or duplicate name into something more sensible.
    // (Leaving NULL could even make JoinFilterGraph trap).
    //----------------------------------------------------------------
    hr2 = InstallName(pName, pFilGen->pName);
    if (FAILED(hr2)) {
        delete pFilGen;
        return hr2;
    }

    // We are usually working downstream.  By adding it to the head  we are
    // probably putting it in upstream order.  May save time on the sorting.
    POSITION pos;
    pos = mFG_FilGenList.AddHead( pFilGen );
    if (pos==NULL) {
        delete pFilGen;

        return E_OUTOFMEMORY;
    }

    //----------------------------------------------------------------
    // Tell the filter it's joining the filter graph
    // WARNING - the Image Renderer may call AddFilter INSIDE here
    // Another reason to be a state machine
    //----------------------------------------------------------------
    hr = pFilter->JoinFilterGraph( this, pFilGen->pName);
    if (FAILED(hr) || hr==S_FALSE) {
        mFG_FilGenList.RemoveHead();
        delete pFilGen;                      // also Releases the filter
        return hr;
    }


    //---------------------------------------------------------------------
    // If the FilterGraph has a syncsource defined then tell the new filter
    //---------------------------------------------------------------------
    if (NULL != m_pClock) {
        hr = pFilter->SetSyncSource( m_pClock );
        if (FAILED(hr)) {
            // Clean up - including calling JoinFilterGraph(NULL, NULL)
            RemoveFilterInternal(pFilter);
            return hr;
        }
    }

    if( mFG_bSyncUsingStreamOffset )
    {
        // if we're going to be setting a graph latency check whether this filter
        // has any IAMPushSource pins

        // First check that filter supports IAMFilterMiscFlags and is an
        // AM_FILTER_MISC_FLAGS_IS_SOURCE filter
        ULONG ulFlags;
        GetFilterMiscFlags(pFilter, &ulFlags);
        if( AM_FILTER_MISC_FLAGS_IS_SOURCE & ulFlags )
        {
            //
            // now find any IAMPushSource output pins and prepare them for the maximum latency
            // which we'll allow on the graph (the video preview pin, especially,
            // would like to know this before it connects, to adjust its buffering)
            //
            CEnumPin NextPin(pFilter);
            IPin *pPin;
            while ((PVOID) (pPin = NextPin()))
            {
                PIN_DIRECTION pd;
                hr = pPin->QueryDirection(&pd);
                ASSERT(SUCCEEDED(hr));
                if( PINDIR_OUTPUT == pd )
                {
                    IAMPushSource * pips;
                    hr = pPin->QueryInterface( IID_IAMPushSource, (void**)(&pips) );
                    if( SUCCEEDED( hr ) )
                    {
                        DbgLog((LOG_TRACE, 5, TEXT("AddFilterInternal::Found IAMPushSource pin...Setting maximum latency ( filter %x, %ls)")
                          , pFilter, (mFG_FilGenList.GetByFilter(pFilter))->pName));

                        pips->SetMaxStreamOffset( mFG_rtMaxGraphLatency );
                        pips->Release();
                    }
                }
                pPin->Release();
            }
        }
    }

    // IAMOpenProgress -- if we haven't already got an interface
    // that implements this, then get it now
    {
        CAutoLock lock(&mFG_csOpenProgress);
        IAMOpenProgress *pOp;

        HRESULT hr2 = pFilter->QueryInterface(IID_IAMOpenProgress, (void**) &pOp);

        if (SUCCEEDED(hr2)) {
            mFG_listOpenProgress.AddTail(pOp);
        }
    }

#ifdef FG_DEVICE_REMOVAL
    IAMDeviceRemoval *pdr;
    if(pFilter->QueryInterface(IID_IAMDeviceRemoval, (void **)&pdr) == S_OK)
    {
        mFG_pFGC->AddDeviceRemovalReg(pdr);
        pdr->Release();
    }
#endif // FG_DEVICE_REMOVAL

#ifdef DEBUG
    IUnknown * punk;
    pFilter->QueryInterface( IID_IUnknown, (void**)(&punk) );
    punk->Release();

    // Get something into the trace that will allow decode of numbers
    // note - name is a WSTR whether we are unicode or not.
    DbgLog((LOG_TRACE, 2
          , TEXT("Filter %x '%ls' Iunknown %x")
          , pFilter
          , (mFG_FilGenList.GetByFilter(pFilter))->pName
          , punk
          ));
#endif // DEBUG

    return hr2;

} // AddFilterInternal


//========================================================================
//
// RemoveFilter
//
// Remove a filter from the graph.  The filter graph implementation
// will inform the filter that it is being removed.
// It also removes all connections
//========================================================================

STDMETHODIMP CFilterGraph::RemoveFilter( IBaseFilter * pFilter )
{
    // defer to the newer version which takes a flag (defaulted to normal case)
    //
    return RemoveFilterEx( pFilter );

} // RemoveFilter

HRESULT CFilterGraph::RemoveFilterEx( IBaseFilter * pFilter, DWORD Flags )
{
    CheckPointer(pFilter, E_POINTER);
    HRESULT hr;
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);

        IncVersion();
        // Removing a filter does demand re-sorting, but it does require a
        // version change to ensure that we break the enumerators.  Distributors
        // depend on this to find the renderers etc.

        // pass Flags to RemoveFilterInternal
        hr = RemoveFilterInternal(pFilter, Flags );

        // Empty lists so all our pointers get released
        mFG_pFGC->EmptyLists();

        // It's weird, but just about possible that removing a filter, and thereby
        // removing a connection that it has could make some other connection possible.
        mFG_RList.Active();
        AttemptDeferredConnections();
        mFG_RList.Passive();
    }

    // outside lock, notify change in graph
    // notify change regardless of whether the filter was removed
    // successfully or not.  (We have changed the version.)
    NotifyChange();

    if (SUCCEEDED(hr)) {
        mFG_bDirty = TRUE;
    }

    return hr;
}


//========================================================================
//
// RemoveFilterInternal
//
// RemoveFilter, but do NOT increase the version count and so do not
// break the filter enumerator.  Release the refcount on the filter.
//========================================================================

HRESULT CFilterGraph::RemoveFilterInternal( IBaseFilter * pFilter, DWORD fRemoveFlags )
{
#ifdef FG_DEVICE_REMOVAL
    IAMDeviceRemoval *pdr;
    if(pFilter->QueryInterface(IID_IAMDeviceRemoval, (void **)&pdr) == S_OK) {
        mFG_pFGC->RemoveDeviceRemovalRegistration((IUnknown *)pFilter);
        pdr->Release();
    }
#endif

    FilGen * pfg = mFG_FilGenList.GetByFilter(pFilter);

    ASSERT (pFilter!=NULL);

    // Some filters don't like to join or leave filter graphs when they
    // have connections (reasonable, I guess) so remove them first, if
    // we're in normal mode
    //

    HRESULT hrRemove = NOERROR;
    if( !( fRemoveFlags & REMFILTERF_LEAVECONNECTED ) )
    {
        hrRemove = RemoveAllConnections2(pFilter);
        if( FAILED( hrRemove ) )
        {
            return hrRemove;
        }
    }

#ifdef THROTTLE
    // If this filter was on the audio renderers list, then release its Peer
    // and take it off the list.  Call IQualityControl::SetSink(NULL)
    // to ensure that it doesn't retain a pointer to us.

    POSITION Pos = mFG_AudioRenderers.GetHeadPosition();
    while(Pos!=NULL) {
        // Retrieve the current IBaseFilter, side-effect Pos on to the next
        // but remember where we were in case we need to delete it
        POSITION posDel = Pos;
        AudioRenderer * pAR = mFG_AudioRenderers.GetNext(Pos);

        if (IsEqualObject(pAR->pf, pFilter)) {

            // Undo the SetSink
            pAR->piqc->SetSink(NULL);
            pAR->piqc->Release();
            pAR->piqc = NULL;

            mFG_AudioRenderers.Remove(posDel);
            delete pAR;
            break;   // ASSERT no filter can be on the list more than once
        }
    }
#endif // THROTTLE


    // A filter has a JoinFilterGraph method, but no corresponding
    // LeaveFilterGraph method.  Call Join with NULLs.
    pFilter->SetSyncSource(NULL);
    pFilter->JoinFilterGraph(NULL, NULL);

    // If removing this filter also removes the clock then
    // set the sync source of the graph to NULL.
    if (m_pClock!=NULL) {
        if (IsEqualObject(pFilter,m_pClock)) {

            // this clears the current clock, but it leaves the filtergraph
            // thinking that we explicitly want to run with no clock
            SetSyncSource(NULL);

            // say that actually we do want a clock, and it will be chosen
            // on the next pause
            mFG_bNoSync = FALSE;
        }
    }

#ifdef THROTTLE
    // If this filter was on the video renderers list, then release its piqc
    // and take it off the list

    Pos = mFG_VideoRenderers.GetHeadPosition();
    while(Pos!=NULL) {
        // Retrieve the current IBaseFilter, side-effect Pos on to the next
        // but remember where we were in case we need to delete it
        POSITION posDel = Pos;
        IQualityControl * piqc = mFG_VideoRenderers.GetNext(Pos);

        if (IsEqualObject(piqc, pFilter)) {
            piqc->Release();
            mFG_VideoRenderers.Remove(posDel);
            break;   // ASSERT no filter can be on the list more than once
        }
    }
#endif // THROTTLE

    // if this filter was currently supplying IAMOpenProgress then release it
    {
        CAutoLock lock(&mFG_csOpenProgress);

        IAMOpenProgress *pOp;
        HRESULT hr = pFilter->QueryInterface(IID_IAMOpenProgress, (void**)&pOp);
        if (SUCCEEDED(hr)) {
            POSITION Pos = mFG_listOpenProgress.GetHeadPosition();
            while (Pos!=NULL) {
                IAMOpenProgress *p;
                POSITION OldPos = Pos;
                p = mFG_listOpenProgress.GetNext(Pos);    // side-efects Pos onto next
                if (p == pOp) {
                    mFG_listOpenProgress.Remove(OldPos);
                    p->Release();
                    break;
                }
            }
            pOp->Release();
        }
    }

    {
        FILTER_STATE fsCurrent;

        HRESULT hr = pFilter->GetState( 0, &fsCurrent );
        if (SUCCEEDED(hr)) {
            if ((State_Running == fsCurrent) && (State_Running == GetStateInternal())) {
                hr = IsRenderer( pFilter );

                // IsRenderer() returns S_OK if a renderer sends an EC_COMPLETE event.
                if (SUCCEEDED(hr) && (S_OK == hr)) {
                    hr = mFG_pFGC->UpdateEC_COMPLETEState( pFilter, CFGControl::ECS_FILTER_STOPS_SENDING );
                    if (FAILED(hr)) {
                        DbgLog(( LOG_ERROR, 3, TEXT("WARNING in CFilterGraph::RemoveFilterInternal(): UpdateEC_COMPLETEState() failed and returned %#08x."), hr ));
                    }
                }
            }
        }
    }

    RemovePointer(mFG_FilGenList, pFilter);
    delete pfg;                   // This Releases the filter!

    return hrRemove;

} // RemoveFilterInternal



//========================================================================
//
// EnumFilters
//
// Get an enumerator to list all filters in the graph.
//========================================================================

STDMETHODIMP CFilterGraph::EnumFilters( IEnumFilters **ppEnum )
{
    CheckPointer(ppEnum, E_POINTER);
    CAutoMsgMutex cObjectLock(&m_CritSec);
    CEnumFilters *pEnumFilters;

    // Create a new enumerator

    // If the list hasn't been sorted since the group was last furkled with
    // sort it now so as to always enumerate it in upstream order
    // UpstreamOrder checks before resorting

    HRESULT hr = UpstreamOrder();
    if( FAILED( hr ) ) {
        return hr;
    }

    pEnumFilters = new CEnumFilters(this);
    if (pEnumFilters == NULL) {
        *ppEnum = NULL;
        return E_OUTOFMEMORY;
    }

    // Get a reference counted IID_IEnumFilters interface

    return pEnumFilters->QueryInterface(IID_IEnumFilters, (void **)ppEnum);
} // EnumFilters



//========================================================================
//
// FindFilterByName
//
// Find the filter with a given name, returns an AddRef'ed pointer
// to the filters IBaseFilter interface, or will fail if the named filter does
// not exist in this graph in which the case a NULL interface pointer is
// returned in ppFilter.
//========================================================================

STDMETHODIMP CFilterGraph::FindFilterByName
    ( LPCWSTR pName, IBaseFilter ** ppFilter )
{
    CheckPointer(pName, E_POINTER);   // You may NOT search for a null name
    CheckPointer(ppFilter, E_POINTER);
    CAutoMsgMutex cObjectLock(&m_CritSec);

    TRAVERSEFILGENS(pos, pfg)
        if (0==lstrcmpW(pfg->pName, pName)) {
            *ppFilter = pfg->pFilter;
            (*ppFilter)->AddRef();
            return NOERROR;
        }

    ENDTRAVERSEFILGENS
    *ppFilter = NULL;
    return VFW_E_NOT_FOUND;

} // FindFilterByName



//========================================================================
//
// ConnectDirect
//
// Connect these two pins directly (i.e. without intervening filters)
// The filter which owns the pins
//========================================================================

STDMETHODIMP CFilterGraph::ConnectDirect
    ( IPin * ppinOut,    // the output pin
      IPin * ppinIn,      // the input pin
      const AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr;
    mFG_bAborting = FALSE;                // Possible race. Doesn't matter.
    CheckPointer(ppinOut, E_POINTER);
    CheckPointer(ppinIn, E_POINTER);
    if (FAILED(hr=CheckPinInGraph(ppinOut)) || FAILED(hr=CheckPinInGraph(ppinIn))) {
        return hr;
    }
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);

    #ifdef DEBUG
        // See if the filters have been added to the graph.  Forestall AVs later.
        PIN_INFO pi;
        ppinOut->QueryPinInfo(&pi);
        ASSERT(mFG_FilGenList.GetByFilter(pi.pFilter));
        QueryPinInfoReleaseFilter(pi);

        ppinIn->QueryPinInfo(&pi);
        ASSERT(mFG_FilGenList.GetByFilter(pi.pFilter));
        QueryPinInfoReleaseFilter(pi);
    #endif

        mFG_RList.Active();
        hr = ConnectDirectInternal(ppinOut, ppinIn, pmt);
        IncVersion();
        AttemptDeferredConnections();
        mFG_RList.Passive();
    }

    // outside lock, notify change
    NotifyChange();

    if (SUCCEEDED(hr)) {
        mFG_bDirty = TRUE;
    }
    return hr;
} // ConnectDirect



//========================================================================
//
// ConnectDirectInternal
//
// ConnectDirect without increasing the version count and hence
// without breaking the filter enumerator (also without any more locking)
//========================================================================

HRESULT CFilterGraph::ConnectDirectInternal
    ( IPin * ppinOut,    // the output pin
      IPin * ppinIn,     // the input pin
      const AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr;
    DbgLog(( LOG_TRACE, 3, TEXT("ConnectDirectInternal pins %x-->%x")
           , ppinOut,ppinIn ));
#ifdef TIME_CONNECTS
    DWORD dwTime = timeGetTime();
#endif
#if 0
    PIN_INFO piIn, piOut;
    WCHAR sz[257];
    sz[0] = L'0';

    GetFilterName(ppinOut, sz);
    int i = lstrlenWInternal(sz);
    lstrcpyWInternal(sz + i, L" to ");
    GetFilterName(ppinIn, sz + i + 4);

    CAutoTimer Timer(L"ConnectDirectInternal ", sz);
#else
    CAutoTimer Timer(L"ConnectDirectInternal ", NULL);
#endif
    MSR_START(mFG_PerfConnectDirect);
    if (IsUpstreamOf(ppinIn, ppinOut)) {
        hr = VFW_E_CIRCULAR_GRAPH;
    } else {
        hr = ppinOut->Connect(ppinIn, pmt);
    }
    MSR_STOP(mFG_PerfConnectDirect);
#ifdef TIME_CONNECTS
    dwTime = timeGetTime() - dwTime;
    TCHAR szOutput[500];
    wsprintf(szOutput, TEXT("Time to connect %s to %s was %d ms\r\n"),
           (LPCTSTR)CDisp(ppinOut), (LPCTSTR)CDisp(ppinIn), dwTime);
    OutputDebugString(szOutput);
#endif

    if (SUCCEEDED(hr)) {
#ifdef DEBUG
        /*  Check out the connection */
        TestConnection(ppinIn, ppinOut);
#endif
        DbgLog(( LOG_TRACE, 2, TEXT("ConnectDirectInternal succeeded pins %x==>%x")
               , ppinOut,ppinIn ));
    }

#ifdef PERF
    if (FAILED(hr)) {
        MSR_NOTE(mFG_idConnectFail);
    }

    {   // bung out something of the clsid of the two filters so that
        // we can see what went on in the log
        PIN_INFO pi;
        ppinIn->QueryPinInfo(&pi);
        IPersist * piper;

        pi.pFilter->QueryInterface(IID_IPersist,(void**)&piper);
        QueryPinInfoReleaseFilter(pi);

        if (piper) {
            CLSID clsidFilter;
            piper->GetClassID(&clsidFilter);
            piper->Release();
            MSR_INTEGER(mFG_idIntel, clsidFilter.Data1);

            ppinOut->QueryPinInfo(&pi);

            pi.pFilter->QueryInterface(IID_IPersist,(void**)&piper);
            QueryPinInfoReleaseFilter(pi);

            piper->GetClassID(&clsidFilter);
            piper->Release();
            MSR_INTEGER(mFG_idIntel, clsidFilter.Data1);
        }
    }
#endif PERF
    return hr;
} // ConnectDirectInternal



//========================================================================
//
// Disconnect
//
// Disconnect this pin, if connected.  Successful no-op if not connected.
// Does not hit the version.  No change in sort order, enumerator not broken.
//========================================================================

STDMETHODIMP CFilterGraph::Disconnect( IPin * ppin )
{
    CheckPointer(ppin, E_POINTER);
    CAutoMsgMutex cObjectLock(&m_CritSec);

    HRESULT hr = ppin->Disconnect();
    if (SUCCEEDED(hr)) {
        mFG_bDirty = TRUE;
    } else {
        #ifdef DEBUG
        {
            IPin* pConnectedPin;

            HRESULT hrDebug = ppin->ConnectedTo(&pConnectedPin);
            if (SUCCEEDED(hrDebug) && (NULL != pConnectedPin)) {
                // Make sure the filter graph's state is consistent if
                // a disconnect fails.  In particular, we want to detect
                // the situation were one pin 1 thinks it's connected to 
                // pin 2 but pin 2 thinks it is not connected.  This case
                // can occur if pin 2 is successfully disconnected but 
                // pin 1 refuses to disconnect.
                TestConnection(ppin, pConnectedPin);
            }
        }
        #endif DEBUG
    }
    return hr;
} // Disconnect



//========================================================================
//
// Reconnect
//
// Break the connection that this pin has and reconnect it to the
// same other pin.
// Dogma:
//     A filter must not request a Reconnect unless it knows it will succeed.
//========================================================================

STDMETHODIMP CFilterGraph::Reconnect( IPin * pPin )
{

    return CFilterGraph::ReconnectEx(pPin, NULL);

} // Reconnect

//========================================================================
//
// ReconnectEx
//
// Break the connection that this pin has and reconnect it to the
// same other pin.
// Dogma:
//     A filter must not request a Reconnect unless it knows it will succeed.
//========================================================================

STDMETHODIMP CFilterGraph::ReconnectEx( IPin * pPin, AM_MEDIA_TYPE const *pmt )
{
    CheckPointer(pPin, E_POINTER);
    CAutoMsgMutex cObjectLock(&m_CritSec);

    HRESULT hr = S_OK;

    // Legacy filters may have called Reconnect() when running and
    // failed previously. Now that some filters may disconnect while
    // running, one pin may disconnect but another may fail leaving
    // things in an unrecoverable inconsistent state. So restrict
    // Reconnect() to filters that are stopped.
    if(m_State != State_Stopped)
    {
        PIN_INFO pi;
        FILTER_STATE fs;

        hr = pPin->QueryPinInfo(&pi);
        if(SUCCEEDED(hr))
        {
            // bug to call Reconnect with pin not in graph.
            ASSERT(pi.pFilter);

            hr = pi.pFilter->GetState(0, &fs);
            pi.pFilter->Release();
        }
        if(hr == S_OK && fs != State_Stopped ||
           hr == VFW_S_STATE_INTERMEDIATE)
        {
            hr = VFW_E_WRONG_STATE;
        }

        if(FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("CFilterGraph::ReconnectEx: graph state %d, filter state %d"),
                    m_State, fs));
        }
    }
    if(SUCCEEDED(hr)) {
        hr = mFG_RList.Schedule(pPin, pmt);
    }

    return hr;

} // Reconnect



//========================================================================
//
// AddSourceFilter
//
// Add to the filter graph a source filter for this file.  This would
// be the same source filter that would be added by calling Render.
// This call permits you to get then have more control over building
// the rest of the graph, e.g. AddFilter(<a renderer of your choice>)
// and then Connect the two.
// It returns a RefCounted filter iff it succeeds.
//========================================================================

STDMETHODIMP CFilterGraph::AddSourceFilter
    ( LPCWSTR lpcwstrFileName,
      LPCWSTR lpcwstrFilterName,
      IBaseFilter **ppFilter
    )
{
    CheckPointer(ppFilter, E_POINTER);

    HRESULT hr;
    mFG_bAborting = FALSE;             // possible race.  Doesn't matter
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);
        ++mFG_RecursionLevel;
        BOOL bGuess;
        hr = AddSourceFilterInternal( lpcwstrFileName
                                    , lpcwstrFilterName
                                    , ppFilter
                                    , bGuess
                                    );
        --mFG_RecursionLevel;
    }

    if (SUCCEEDED(hr)) {
        NotifyChange();
    }
    return hr;
} // AddSourceFilter


// Add a source filter for the given moniker to the graph
// We first try BindToStorage and if this fails we try
// BindToObject
STDMETHODIMP CFilterGraph::AddSourceFilterForMoniker(
      IMoniker *pMoniker,          // Moniker to load
      IBindCtx *pCtx,              // Bind context
      LPCWSTR lpcwstrFilterName,   // Add the filter as this name
      IBaseFilter **ppFilter       // resulting IBaseFilter* "handle"
                                   // of the filter added.
)
{
    mFG_bAborting = FALSE;             // possible race.  Doesn't matter
    HRESULT hr = S_OK;
    IBaseFilter *pFilter = NULL;
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);
        ++mFG_RecursionLevel;

        //  Try BindToStorage via our URL reader filter (should do
        //  regular IStream too)
        hr = CreateFilter(&CLSID_URLReader, &pFilter);

        if (SUCCEEDED(hr)) {
            IPersistMoniker *pPersistMoniker;
            //  Try the Load method on it's IPersistMoniker
            hr = pFilter->QueryInterface(
                     IID_IPersistMoniker,
                     (void **)&pPersistMoniker);

            if (SUCCEEDED(hr)) {
                hr = AddFilter(pFilter, lpcwstrFilterName);
            }

            if (SUCCEEDED(hr)) {
                hr = pPersistMoniker->Load(
                                FALSE,    //  Always want async open
                                pMoniker, //  Our Moniker
                                pCtx,     //  Can the bind context be NULL?
                                0);       //  What should it be?
                pPersistMoniker->Release();
                if (FAILED(hr)) {
                    RemoveFilterInternal(pFilter);
                }
            }
            if (FAILED(hr)) {
                pFilter->Release();
                pFilter = NULL;
            }
        }

        //  If the URL reader can't open it try to create a filter object
        if (FAILED(hr)) {
            IBindCtx *pSavedCtx = m_lpBC;
            m_lpBC = pCtx;
            hr = CreateFilter(pMoniker, &pFilter);
            m_lpBC = pSavedCtx;
            if (SUCCEEDED(hr)) {
                hr = AddFilter(pFilter, lpcwstrFilterName);
            }
        }

        if (SUCCEEDED(hr)) {
            ASSERT(pFilter != NULL);
            NotifyChange();
            *ppFilter = pFilter;
        } else {
            if (pFilter != NULL) {
                pFilter->Release();
            }
        }

        --mFG_RecursionLevel;
    }

    return hr;
}

//====================================================================
//
//   RenderEx
//
//   Render extended
//
//    AM_RENDEREX_RENDERTOEXISTINGRENDERERS :
//       Try to pPinOut this pin without adding any renderers
//
//====================================================================

STDMETHODIMP CFilterGraph::RenderEx(
    IPin *pPinOut,
    DWORD dwFlags,
    DWORD * pvContext
)
{
    if (pvContext != NULL ||
        (dwFlags & ~AM_RENDEREX_RENDERTOEXISTINGRENDERERS)) {
        return E_INVALIDARG;
    }
    CAutoMsgMutex cObjectLock(&m_CritSec);
    ASSERT(!mFG_bNoNewRenderers);
    if (dwFlags & AM_RENDEREX_RENDERTOEXISTINGRENDERERS) {
        mFG_bNoNewRenderers = true;
    }
    HRESULT hr = Render(pPinOut);
    mFG_bNoNewRenderers = false;
    return hr;
}



//========================================================================
//
// AddSourceFilterInternal
//
// Does the work for AddSourceFilter (see above)
// Does NOT call NotifyChange either directly or indirectly.
// Does not claim its own lock (expects to be locked already)
//========================================================================

HRESULT CFilterGraph::AddSourceFilterInternal
    ( LPCWSTR lpcwstrFileName,
      LPCWSTR lpcwstrFilterName,
      IBaseFilter **ppFilter,
      BOOL    &bGuessingSource
    )
{
    HRESULT hr;                     // return code from stuff we call
    bGuessingSource = FALSE;

    IBaseFilter * pf;                   // We return this (with luck)

    ASSERT(CritCheckIn(&m_CritSec));      // we expect to have already been locked.

    // At this point, it could be a filename or it could be a URL.
    // if it's a URL, and it begins with "file://" or "file:", strip that off.
    // yes, this is ugly, but it's better than implementing a general routine
    // just for here.
    LPCWSTR lpcwstr = lpcwstrFileName;
    if (  (lpcwstrFileName[0] == L'F' || lpcwstrFileName[0] == L'f')
       && (lpcwstrFileName[1] == L'I' || lpcwstrFileName[1] == L'i')
       && (lpcwstrFileName[2] == L'L' || lpcwstrFileName[2] == L'l')
       && (lpcwstrFileName[3] == L'E' || lpcwstrFileName[3] == L'e')
       && (lpcwstrFileName[4] == L':')
       ) {
    // HACK: skip 'file://' at beginning of URL

    lpcwstr += 5;
    while (lpcwstr[0] == L'/')
        lpcwstr++;  // skip however many slashes are present next
    }

    //-----------------------------------------------------------------------
    //  See if we can find out what type of file it is
    //-----------------------------------------------------------------------
    GUID Type, Subtype;
    CLSID  clsidSource;
    CMediaType mt;
#ifdef UNICODE
    hr = GetMediaTypeFile(lpcwstr, &Type, &Subtype, &clsidSource);
#else
    {
        int iLen = lstrlenW(lpcwstr) * 2 + 1;
        char *psz = new char[iLen];
        if (psz == NULL) {
            return E_OUTOFMEMORY;
        }
        if (0 == WideCharToMultiByte(CP_ACP, 0, lpcwstr, -1,
                                     psz, iLen, NULL, NULL)) {
            delete [] psz;
            return E_INVALIDARG;
        }
        hr = GetMediaTypeFile(psz, &Type, &Subtype, &clsidSource);
        delete [] psz;
    }
#endif

    // if we guess at the file source, remember this for error-reporting later

    if (hr==VFW_E_UNKNOWN_FILE_TYPE) {
        Log( IDS_UNKNOWNFILETYPE );
        clsidSource = CLSID_AVIDoc;
        bGuessingSource = TRUE;
    } else if (FAILED(hr)) {
        //  If we couldn't open as a file and it wasn't 'file:'
        //  then try creating a moniker and using that
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr ||
            HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr ||
            HRESULT_FROM_WIN32(ERROR_INVALID_NAME) == hr) {

            // !!!Hack: AMGetError does not know file-not-found so give it an
            // error it does know
            hr = VFW_E_NOT_FOUND;
        }
        Log ( IDS_GETMEDIATYPEFAIL, hr);

        return hr;
    } else {
        if (Type==MEDIATYPE_Stream && Subtype==CLSID_NULL) {
            // This seems to be how Robin's stuff now reports a guess.
            bGuessingSource = TRUE;
        }

        mt.SetType(&Type);
        mt.SetSubtype(&Subtype);
        Log ( IDS_MEDIATYPEFILE, Type.Data1, Subtype.Data1);
    }

    Log( IDS_SOURCEFILTERCLSID, clsidSource.Data1);

    //-----------------------------------------------------------------------
    // Load the source filter (it will have 1 RefCount)
    //-----------------------------------------------------------------------
    hr = CreateFilter( &clsidSource, &pf );
    if (FAILED(hr)) {
        Log( IDS_SOURCECREATEFAIL, hr);
        if (bGuessingSource) {
            hr = VFW_E_UNKNOWN_FILE_TYPE;
        } else if (hr!=CO_E_NOTINITIALIZED) {
            hr = VFW_E_CANNOT_LOAD_SOURCE_FILTER;
        }
        return hr;
    }


    //-----------------------------------------------------------------------
    // If it has an IFileSourceFilter then load the file
    //-----------------------------------------------------------------------
    IFileSourceFilter * pFileSource;
    hr = pf->QueryInterface(IID_IFileSourceFilter, (void**) &pFileSource);
    if (FAILED(hr)){
        // we need this to open the file - give up
        Log( IDS_NOSOURCEINTFCE, hr);
        pf->Release();
        return hr;
    }

    // Add filter to our graph lists.  This also adds a ref-count
    // and increments the version count.
    // Note - we used to erroneously set the filter name to the file
    // name - now only do this if a filter name wasn't supplied

    hr = AddFilterInternal( pf,
                            lpcwstrFilterName == NULL ? lpcwstr : lpcwstrFilterName,
                            false );
    if (FAILED(hr)) {
        // If AddRef failed this will reduce it to zero and it will go away.
        Log( IDS_ADDFILTERFAIL, hr );
        pFileSource->Release();
        pf->Release();
        return hr;
    }

    //-----------------------------------------------------------------------
    // Ask the source to load the file
    //-----------------------------------------------------------------------

    // if we don't know the media type (either we guessed at avi above,
    // or the registry had a clsid but not the media type), then pass null
    // pointers, *not* a pointer to GUID_NULL
    if (*mt.Type() == GUID_NULL) {
        hr = pFileSource->Load(lpcwstr, NULL);
    } else {
        hr = pFileSource->Load(lpcwstr, &mt);
    }
    pFileSource->Release();
    if (FAILED(hr)) {
        // load failed, remove filter from graph.
        RemoveFilterInternal(pf);

        pf->Release();

        //  If the URL reader was trying to load it try binding the
        //  our object instead
        if (clsidSource == CLSID_URLReader) {

            //  Try and open it as a moniker
            HRESULT hr1 = S_OK;

            if (SUCCEEDED(hr1)) {
                IMoniker *pMoniker = NULL;

                //  MkParseDisplayNameEx is in urlmon.dll but if we FreeLibrary
                //  on urlmon.dll any Monikers it gives us become invalid.
                //  So for now use this version
                DWORD chEaten;
                hr1 = MkParseDisplayName(m_lpBC,
                                         lpcwstrFileName,
                                         &chEaten,
                                         &pMoniker);

                if (SUCCEEDED(hr1)) {
                    hr1 = CreateFilter(pMoniker, &pf);
                }
                if (SUCCEEDED(hr1)) {

                    //  This will be our real return code now since
                    //  we got this far
                    hr = AddFilterInternal( pf,
                                            lpcwstrFilterName == NULL ? lpcwstr : lpcwstrFilterName,
                                            true );
                    if (FAILED(hr)) {
                        pf->Release();
                    }
                }
                if (pMoniker) {
                    pMoniker->Release();
                }
            }
        }
        if (FAILED(hr)) {
            Log( IDS_LOADFAIL, hr);

            // try to preserve interesting errors (eg. ACCESS_DENIED)
            if (bGuessingSource && (HRESULT_FACILITY(hr) == FACILITY_ITF)) {
                hr = VFW_E_UNKNOWN_FILE_TYPE;
            }
            return hr;
        }
    }
    Log (IDS_LOADED );

    IncVersion();
    mFG_RList.Active();
    AttemptDeferredConnections();
    mFG_RList.Passive();


    // If AddRef succeeded, AddRef will have added its own count, making two.
    // That's one for the caller and one for us.
    *ppFilter = pf;

    Log( IDS_ADDSOURCEOK );
    mFG_bDirty = TRUE;
    return NOERROR;
} // AddSourceFilterInternal



//========================================================================
//
// SetSyncSource
//
// Override the IMediaFilter SetSyncSource
// Set this as the reference clock for all filters that are,
// or ever will be, in the graph.
// return NOERROR if it worked, or the result from the first IMediaFilter
// that went wrong if it didn't
//
// You are not allowed to add or remove clocks unless the graph is STOPPED
// Attempts to do so return E_VFW_NOT_STOPPED and have no effect.
// Otherwise AddReffing and Releasing is done as follows:
// The old clock (unless null) is Released
// The new clock (unless null) is AddRefed.
//
// DO NOT call with m_pClock as its parameter!!
//========================================================================

STDMETHODIMP CFilterGraph::SetSyncSource( IReferenceClock * pirc )
{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    HRESULT hr = NOERROR;

#if 0
    if ((m_pClock==NULL || pirc==NULL) && m_State!=State_Stopped) {
        // ASSERT(!"Clocks can only be added or removed when stopped");
        return VFW_E_NOT_STOPPED;
        // can we not do this while paused?  i.e. m_State!=State_Running ???
    }
#endif

    if (m_State!=State_Stopped && m_pClock != pirc ) 
    {
        //
        // In order to support dynamic clock changes we need a more complete solution,
        // especially a way to query filters up front whether they support switching the
        // clock while running, otherwise we get into all kinds of problems with filters
        // being in inconsistent clock states. 
        //
        // So we'll only allow clock changes while stopped.
        //
        return VFW_E_NOT_STOPPED;
    }



    //-----------------------------------------------------------------
    // If the list was not in upstream order already, make it so now.
    // ??? Do we need to do this?
    //-----------------------------------------------------------------

    hr = UpstreamOrder();
    if( FAILED( hr ) ) {
        return hr;
    }

    if (pirc!=NULL) {
        pirc->AddRef();
        mFG_bNoSync = FALSE;
    } else {
        mFG_bNoSync = TRUE;
    }

    // tell the distributor about the new clock
    mFG_pFGC->SetSyncSource(pirc);
    if (mFG_pDistributor) mFG_pDistributor->SetSyncSource(pirc);


    //-----------------------------------------------------------------
    // If somebody is switching the clocks on the fly then we need to
    // change the base times.  If the thing is running, then I think
    // the two clocks had pretty much better be in sync already???
    //-----------------------------------------------------------------

    if (m_State!=State_Stopped) {
       ASSERT (m_pClock !=NULL);
       CRefTime tOld;
       m_pClock->GetTime((REFERENCE_TIME*)&tOld);
       CRefTime tNew;
       pirc->GetTime((REFERENCE_TIME*)&tNew);

       mFG_tBase += (tNew-tOld);
       if (m_State==State_Paused) {
           mFG_tPausedAt += (tNew-tOld);
       }
       else // ??? I have no idea!!
          ;

    }

    // We've now finished with the old clock
    if (m_pClock!=NULL) {
        m_pClock->Release();
        m_pClock = NULL;
    }

    //-----------------------------------------------------------------
    // Record the sync source for all future filters
    //-----------------------------------------------------------------
    m_pClock = pirc;        // Set our clock (the one we inherited from IMediaFilter)
                            // This could set it to NULL

    //-----------------------------------------------------------------
    // Set the sync source for all filters already in the graph
    //-----------------------------------------------------------------

    TRAVERSEFILTERS( pCurrentFilter )

        HRESULT hr1;

        hr1 = pCurrentFilter->SetSyncSource(m_pClock);

        if (FAILED(hr1) && hr==NOERROR) {
            hr = hr1;
            // note: for these loop operations whereby each error
            // overwrites the next it might be good to write to the
            // event log so that we can see all the errors that
            // occurred.
        }

    ENDTRAVERSEFILTERS()

    // Tell the app that we're doing it
    IMediaEventSink * pimes;
    QueryInterface(IID_IMediaEventSink, (void**)&pimes);
    if (pimes) {
        pimes->Notify(EC_CLOCK_CHANGED, 0, 0);
        pimes->Release();
    }

    if (SUCCEEDED(hr)) {
        mFG_bDirty = TRUE;
    }

    return hr;

} // SetSyncSource


STDMETHODIMP CFilterGraph::GetSyncSource( IReferenceClock ** pirc )
{
    if (mFG_bNoSync) {
        *pirc = NULL;
        return S_FALSE;
    } else {
        *pirc = m_pClock;

        // Returning an interface. Need to AddRef it.
        if( m_pClock )
            m_pClock->AddRef();
        return S_OK;
    }
}

//=====================================================================
//
// Stop
//
// Set all the filters in the graph to Stopped
//=====================================================================

STDMETHODIMP CFilterGraph::Stop(void)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    // Don't stop if we're already stopped
    if (m_State == State_Stopped) {
        return S_OK;
    }

    // tell the distributor that we are stopping
    mFG_pFGC->Stop();
    if (mFG_pDistributor) mFG_pDistributor->Stop();

    CumulativeHRESULT chr(S_OK);

    // Call Stop on each filter in the list, in upstream order.

    // If the list was not in upstream order already, make it so now.
    chr.Accumulate( UpstreamOrder() );


    // Since reconnections only take place when stopped many filters defer
    // sending them until stopped. So we should queue them all up and then
    // when everyone is stopped process all entries on the queue. Otherwise
    // a thread may be spun off which by the time it gets in to do anything
    // has found that that application decided to rewind and pause us again

    mFG_RList.Active();

    TRAVERSEFILTERS( pCurrentFilter )

        chr.Accumulate( pCurrentFilter->Stop() );

    ENDTRAVERSEFILTERS()

    mFG_tPausedAt = CRefTime((LONGLONG)0);
    mFG_tBase = CRefTime((LONGLONG)0);

    // only S_OK indicates a completed transition,
    // but we can say what state we are transitioning into
    m_State = State_Stopped;
    mFG_RList.Passive();

    return chr;

} // Stop



//=====================================================================
//
// Pause
//
// Set all the filters in the graph to Pause
//=====================================================================

STDMETHODIMP CFilterGraph::Pause(void)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);
    HRESULT hr;

    if (m_State==State_Stopped) {
        // Last ditch go to make the graph complete.
        mFG_RList.Active();
        AttemptDeferredConnections();
        mFG_RList.Passive();
    } else if (m_State == State_Paused) {
        return S_OK;
    }


    // If the list was not in upstream order already, make it so now.
    hr = UpstreamOrder();
    if (FAILED(hr)) {
        return hr;    // e.g. VFW_E_CIRCULAR_GRAPH
    }

    // Pause can be a way to become active from stopped.
    // mustn't do this without a clock.
    if (m_pClock==NULL && !mFG_bNoSync) {
        hr = SetDefaultSyncSource();
        if (FAILED(hr)) return hr;
    }

    if( mFG_bSyncUsingStreamOffset && m_State != State_Running )
        hr = SetStreamOffset(); // continue even on error?

    // tell the distributor that we are pausing
    mFG_pFGC->Pause();
    if (mFG_pDistributor) mFG_pDistributor->Pause();

    // Now that we have a clock we can ask it the time.
    // we only really need this if we are paused from running?
    if (m_pClock!=NULL) {
        // Does PAUSE even really mean much when not synched?

        // tPausedAt is only nonzero when we are paused. We should
        // set it to the time we first paused. If we pause again, then
        // we should leave it alone. We can't check state to see if we
        // are paused since it might be intermediate
        if (mFG_tPausedAt == TimeZero) {
            hr = m_pClock->GetTime((REFERENCE_TIME*)&mFG_tPausedAt);
            ASSERT (SUCCEEDED(hr) );
        }

        // if pausing from stopped, set base time to pausedat time to
        // show that we have paused at stream time 0
        if (m_State==State_Stopped) {
           mFG_tBase = mFG_tPausedAt;
        }
    }

    // Tell all the lower level filters to Pause.

    CumulativeHRESULT chr(S_OK);
    BOOL bAsync = FALSE;
    TRAVERSEFILTERS( pCurrentFilter )

        hr = pCurrentFilter->Pause();
        chr.Accumulate( hr );
        // If Pause was Async, record the fact
        if (hr == S_FALSE) bAsync = TRUE;
        if (FAILED(hr)) {
#ifdef DEBUG
            CLSID clsid;
            pCurrentFilter->GetClassID(&clsid);

            FILTER_INFO finfo;
            finfo.achName[0] = 0;
            IBaseFilter *pbf;
            if (pCurrentFilter->QueryInterface(IID_IBaseFilter, (void **)&pbf) == S_OK)
            {
                if (SUCCEEDED(pbf->QueryFilterInfo(&finfo)))
                {
                    finfo.pGraph->Release();
                }
                pbf->Release();
            }

            WCHAR wszCLSID[128];
            QzStringFromGUID2(clsid,wszCLSID,128);

            DbgLog((LOG_ERROR, 0, TEXT("filter %8.8X '%ls' CLSID %ls failed pause, hr=%8.8X"),
                   pCurrentFilter, finfo.achName, wszCLSID, hr));

#endif
            break;
        }

    ENDTRAVERSEFILTERS()
    hr = chr;


    // If the pause is async, return S_FALSE in preference
    // to any other non-failure return code.
    if (bAsync && SUCCEEDED(hr)) hr = S_FALSE;

    m_State = State_Paused;
    // only S_OK means a completed transition

    // Go back to stopped state if we failed
    // (but set the state otherwise Stop will NOOP)
    if (FAILED(hr)) {
        Stop();
    }

    return hr;

} // Pause



//===============================================================
//
// SetDefaultSyncSource
//
// Instantiate the default clock and tell all filters.
//
// The default clock is the first connected filter that we see
// doing the standard enumeration of filters.  If no connected
// filters are found we will use a clock from an unconnected
// filter.  If none of those, then we create a system clock.
//===============================================================


// First, two utility routines...

// Get the first (in the standard enumeration sequence) input pin
// from a filter
IPin* GetFirstInputPin (IBaseFilter *pFilter);

// returns TRUE if filter is connected
//         FALSE if filter is not connected
//
// "connected" is defined to be "The first input pin IsConnected()".
//
BOOL IsFilterConnected(IBaseFilter *pInFilter);

// TRUE: this filter is connected
// FALSE: no its not
//
// "connected" means that it has an input pin that is
// connected to another pin. We only check one level.

BOOL IsFilterConnected(IBaseFilter *pInFilter)
{

    HRESULT hr ;
    IPin *pPin1, *pPin2 ;

    // get the input pin.
    pPin1 = GetFirstInputPin (pInFilter) ;
    if (pPin1 == NULL)
    {
        return FALSE; // not going anywhere
    }

    // get the connected to pin for this pin
    hr = pPin1->ConnectedTo (&pPin2) ;

    pPin1->Release();

    if (pPin2) {
        /*  Connected - return TRUE */
        pPin2->Release () ;
        return TRUE;
    } else {
        return FALSE;
    }
}

// return the first input pin on this filter
// NULL if no input pin.
IPin* GetFirstInputPin (IBaseFilter *pFilter)
{
    return CEnumPin(pFilter, CEnumPin::PINDIR_INPUT)();
}

//
// Determine the timestamp offset to use for all filters that support
// IAMPushSource.
//
HRESULT CFilterGraph::SetStreamOffset(void)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);
    HRESULT hr;

    // for now don't allow changes while running
    if (m_State==State_Running) {
        ASSERT("FALSE");
        return VFW_E_NOT_STOPPED;
    }
    REFERENCE_TIME rtMaxLatency = 0;
    PushSourceList lstPushSource( TEXT( "IAMPushSource filter list" ) );
    hr = BuildPushSourceList( lstPushSource, TRUE, FALSE ); // only include connected filters!
    //
    // now go through the push source list and find the max offset time
    // (we really need to do this per filter chain and accumulate the
    // latency via IAMLatency for each chain). Note that at this
    // time we do this independent of filter connections.
    //
    if( SUCCEEDED( hr ) )
    {
        rtMaxLatency = GetMaxStreamLatency( lstPushSource );

        // now go through the list we built and set the offset times based on
        // the max stream latency value
        for ( POSITION Pos = lstPushSource.GetHeadPosition(); Pos; )
        {
            PushSourceElem *pElem = lstPushSource.GetNext(Pos);
            if( pElem->pips )
                hr = pElem->pips->SetStreamOffset( rtMaxLatency );

            ASSERT( SUCCEEDED( hr ) );
        }
    }
    DeletePushSourceList( lstPushSource );
    return hr;

} // SetStreamOffset


//
// Find and set a default sync source for this filter graph
//

STDMETHODIMP CFilterGraph::SetDefaultSyncSource(void)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);
    HRESULT hr;

    // Get rid of this case before we change any flags or anything.
    if (m_State==State_Running) {
        DbgBreak("Clocks can only be added or removed when stopped");
        return VFW_E_NOT_STOPPED;
        // can we not do this while paused?  i.e. m_State!=State_Running
        // ??? Trying this out!
    }

    IReferenceClock * pClock;

    // check for IAMPushSources
    PushSourceList lstPushSource( TEXT( "IAMPushSource filter list" ) );
    hr = BuildPushSourceList( lstPushSource, TRUE, TRUE ); // only include connected filters!
                                                           // check for push clocks
    IReferenceClock * pPushClock = NULL;
    BOOL bLiveSource = FALSE;
    for ( POSITION Pos = lstPushSource.GetHeadPosition(); Pos; )
    {
        PushSourceElem *pElem = lstPushSource.GetNext(Pos);
        if( pElem->pClock && !pPushClock )
        {
            pPushClock = pElem->pClock;
            pPushClock->AddRef(); // keep a hold on this clock
        }
        else if( 0 == ( pElem->ulFlags & AM_PUSHSOURCECAPS_NOT_LIVE ) )
        {
            // if the source mode is any other mode then it must be live
            bLiveSource = TRUE;
        }
    }
    DeletePushSourceList( lstPushSource );

    IReferenceClock * pirc = NULL;
    IReferenceClock * pircUnconnected = NULL;

    if( pPushClock )
    {
        // there's an IAMPushSource filter that supports a clock, use the 1st one
        // of those that we find
        pirc = pPushClock;
    }
    else if ( !bLiveSource )
    {
        CFilGenList::CEnumFilters Next(mFG_FilGenList);
        IBaseFilter *pf;
        while ((PVOID) (pf = ++Next)) {
            hr = pf->QueryInterface( IID_IReferenceClock, (void**)(&pirc) );

            if (SUCCEEDED(hr)) {
                if (IsFilterConnected(pf)) {
                    DbgLog((LOG_TRACE, 1, TEXT("Got clock from filter %x %ls")
                      , pf, (mFG_FilGenList.GetByFilter(pf))->pName));
                    break;
                }
                if (!pircUnconnected) {
                    // this is the first unconnected filter that is
                    // willing to provide a reference clock
                    pircUnconnected = pirc;
                } else {
                    // This filter is not connected, and we already have a
                    // clock from an unconnected filter.  Throw this one away.
                    pirc->Release();
                }

                pirc = NULL;

                // do not exit the loop with pircUnconnected==pirc.  We have
                // either stored pirc into pircUnconnected and will release
                // the reference count on it later, or we have already released
                // pirc.  Either way we must set pirc to null in case we exit
                // the loop now.
            }
        }
    }
    // else there's a live IAMPushSource filter in the graph, but no source clock
    // so we'll default to the system clock

    // This gets the clock from the first filter that responds with the interface.
    // We should probably do something to check if there is more than one clock
    // present in the system.  (Like construct a list of all the clocks, pass that
    // list to all the clocks, and get each to give themselves a priority number.  At
    // the end the first highest priority wins.  This would also allow something like
    // the audio renderer which has to be the system clock (or so it thinks) to use
    // an external system clock and not system time in those periods when wave data
    // is not being played.)

    // if we found a clock on an unconnected filter, and it was the only
    // clock, we will use that one.  If it was not the only clock we need
    // to release the clock on the unconnected filter.
    if (pircUnconnected) {
        if (!pirc) {
            pirc = pircUnconnected;
        } else {
            pircUnconnected->Release();
        }
    }

    if (pirc == NULL) {
        // alternatively, get a system clock
        hr = QzCreateFilterObject( CLSID_SystemClock, NULL, CLSCTX_INPROC
                                 , IID_IReferenceClock, (void **)&pirc);
        if (FAILED(hr))
            return hr;
        DbgLog((LOG_TRACE, 1, TEXT("Created system clock")));
    }

    // This has a side effect on m_pClock.  Do NOT have m_pClock as its parameter
    // it causes bugs
    hr = SetSyncSource(pirc);

    // SetSync source will have either failed (in which case it doesn't
    // need to keep the new clock around any more) or AdReffed the new clock.
    // Either way we can now get rid of the RefCount that we got from either
    // QueryInterface or CoCreateInstance

    pirc->Release();

    if (SUCCEEDED(hr)) {
        mFG_bDirty = TRUE;
    }
    return hr;

} // SetDefaultSyncSource



//=====================================================================
//
// Run
//
// Set all the filters in the graph to Run from their current position.
//
// tStart is the base time i.e. (presentation time - stream time) which is
// the reference time for the zeroth sample to be rendered.
//
// The filter graph remembers the base time.  Supplying a base time of
// zero means "continue with the one you knew".
//
// e.g. at reference ("wall clock") time Tr we wish to start running
// from a point in the Ts after the start.  In that case we should
// seek to the point Ts and Pause then Run(Ts-Ts).
//=====================================================================

STDMETHODIMP CFilterGraph::Run(REFERENCE_TIME tStart)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    if (m_State == State_Running) {
        return S_OK;
    }

    HRESULT hr = NOERROR;
    // If the list was not in upstream order already, make it so now.
    hr = UpstreamOrder();
    if (FAILED(hr)) {
        return hr;    // e.g. VFW_E_CIRCULAR_GRAPH
    }


    // mustn't become active without a clock.
    if (m_pClock==NULL && !mFG_bNoSync) {
        hr = SetDefaultSyncSource();
        if (FAILED(hr))
        {
            return hr;
        }
    }


    // If we are restarting from paused then we set the time base on by
    // the length of time we were paused for.  Starting from paused is
    // assumed to be very quick, so we do not add any extra.  If we are
    // starting from cold then we add an extra 100mSec.  Since a stopped
    // system has a PausedAt and Base time of zero, the calculation is
    // otherwise the same.

    if (CRefTime(tStart) == CRefTime((LONGLONG)0) ) {
        CRefTime tNow;
        if (m_pClock!=NULL) {
            hr = m_pClock->GetTime((REFERENCE_TIME*)&tNow);
        } else {
            tNow = CRefTime((LONGLONG)0);
        }

        ASSERT (SUCCEEDED(hr));

        mFG_tBase += (tNow - mFG_tPausedAt);

        // if we are stopped, allow a little time for warm-up.  100mSec?
        if (m_State==State_Stopped)
            mFG_tBase += CRefTime(MILLISECONDS_TO_100NS_UNITS(100));

        // even starting from paused takes a little while - another 100mSec?
        mFG_tBase += CRefTime(MILLISECONDS_TO_100NS_UNITS(100));
    }
    else mFG_tBase = CRefTime(tStart);

    mFG_tPausedAt = CRefTime((LONGLONG)0);  // we are no longer paused

    // set the start time in the base class so that StreamTime (and hence
    // get_CurrentPosition) works correctly
    m_tStart = mFG_tBase;

    // tell the distributor that we are running
    mFG_pFGC->Run(mFG_tBase);
    if (mFG_pDistributor) mFG_pDistributor->Run(mFG_tBase);

#ifdef DEBUG
    BOOL fDisplayTime=FALSE;
    DbgLog((LOG_TIMING,1,TEXT("Time for RUN: %d ms"), m_tStart.Millisecs()));
    CRefTime CurrentTime;
    // Display the current time from the clock - if we have one and if
    // we are logging timing calls.
    if (m_pClock && DbgCheckModuleLevel(LOG_TIMING,1)) {
        fDisplayTime=TRUE;
        m_pClock->GetTime((REFERENCE_TIME*)&CurrentTime);
        DbgLog((LOG_TIMING,1,TEXT("time before distribution %d ms"),CurrentTime.Millisecs()));
    }
#endif

    // Distribute Run at high priority so filters that start processing
    // don't delay others getting started
    HANDLE hCurrentThread = GetCurrentThread();
    DWORD dwPriority = GetThreadPriority(hCurrentThread);
    SetThreadPriority(hCurrentThread, THREAD_PRIORITY_TIME_CRITICAL);

    // Tell all the filters about the change in upstream order
    // Note that this means that we start the renderers first.
    // ??? should we actually add a bit of time.

    CumulativeHRESULT chr(S_OK);
    TRAVERSEFILTERS( pCurrentFilter )

        chr.Accumulate( pCurrentFilter->Run(mFG_tBase) );

    ENDTRAVERSEFILTERS()
    hr = chr;

    SetThreadPriority(hCurrentThread, dwPriority);

#ifdef DEBUG
    // Display the current time from the clock - if we have one
    if (fDisplayTime) {
        CRefTime TimeNow;
        m_pClock->GetTime((REFERENCE_TIME*)&TimeNow);
        CurrentTime = TimeNow - CurrentTime;
        DbgLog((LOG_TIMING,1,TEXT("time after distribution %d ms (diff %d ms)"),TimeNow.Millisecs(), CurrentTime.Millisecs()));
    }
#endif

    // only S_OK means a completed transition
    m_State = State_Running;

    return hr;

} // Run

// override this to handle async state change completion
// we need to allow state changes during this - we can't hold the
// fg critsec. (eg if blocked waiting for a state transition to complete
// and an error occurs, the app has to be able to stop the graph.
//
// So we hold the critsec while traversing the list of filters, calling
// GetState with no timeout. If we find one that we need to block for, we
// hold that IMediaFilter*, but exit the traversal and exit the critsec, then
// block on the GetState. Then we start from the beginning of the list again.
//
// Many filters will transition through paused on their way between stopped
// and running.  We try to regard this as an "intermediate" condition and re-query
// the filters (after a small delay) in the hope of retrieveing a consistant
// state.
//
// !!! note that if a filter completes in a non-zero time, we should knock
// this amount off the total for the next timeout. It's a small point though
// since the scheduling of the thread could easily account for the difference.
STDMETHODIMP
CFilterGraph::GetState(DWORD dwTimeout, FILTER_STATE * pState)
{
    DbgLog(( LOG_TRACE, METHOD_TRACE_LOGGING_LEVEL, "CFilterGraph::GetState()" ));
    CheckPointer(pState, E_POINTER);

    HRESULT hr;

    for( ;; )
    {
        FILTER_STATE state;
        IBaseFilter * pmf;

        // ensure that this is S_OK not just any success code
        hr = S_OK;
        IMediaFilter * pIntermediateFilter = NULL;
        {
            CAutoMsgMutex cObjectLock(&m_CritSec);

            // If the list was not in upstream order already, make it so now.
            hr = UpstreamOrder();
            if( FAILED( hr ) ) {
                return hr;
            }

            // we know what state we're supposed to be in, since a
            // requirement for using this GetState is that you do all
            // state changes through us. However, we don't know whether
            // the state is intermediate or not, since other activity
            // (for example seeks) could make it intermediate after
            // a successful transition.
            *pState = m_State;

            // always need to traverse to look for intermediate state anywhere.

            for ( POSITION Pos = mFG_FilGenList.GetTailPosition(); Pos; Pos = mFG_FilGenList.Prev(Pos) )
            {
                pmf = mFG_FilGenList.Get(Pos)->pFilter;

                // just look and see if it will block
                hr = pmf->GetState(0, &state);
                if (FAILED(hr)) return hr;

                // compare against the state we think we're in to check
                // that all filters are in the same state
                if (state != *pState)
                {
                    // !!!flag this so we understand why it is happening
                    #ifdef DEBUG
                    {
                        FILTER_INFO info;
                        EXECUTE_ASSERT(SUCCEEDED(
                            pmf->QueryFilterInfo(&info)
                        ));
                        if (info.pGraph) info.pGraph->Release();
                        DbgLog(( LOG_ERROR, 0
                               , "Graph should be in state %d, but filter '%ls' (0x%08X) reported state %d"
                               , int(*pState), info.achName, pmf, int(state)
                              ));
                    }
                    #endif

                    // This case should only happen if filters transition through paused
                    // on the way into or out of run.  Any other time, E_FAIL it.
                    if (state != State_Paused) return E_FAIL;

                    pIntermediateFilter = pmf;
                    continue;
                } // end if (state != *pState)

                // only S_OK indicates a completed transition
                if ( S_OK == hr ) continue;
                if ( hr == VFW_S_STATE_INTERMEDIATE )
                {
                    pIntermediateFilter = pmf;
                    continue;
                }
                ASSERT( hr == VFW_S_CANT_CUE && state == State_Paused && m_State == State_Paused );
                return hr;
            }  // end for( Pos )
        }  // end scope CAutoLock lck(this)

        ASSERT( SUCCEEDED(hr) );

        if ( !pIntermediateFilter )
        {
            ASSERT( hr == S_OK );
            return hr;
        }
        if ( dwTimeout == 0 ) return VFW_S_STATE_INTERMEDIATE;

        const DWORD dwStartTime = timeGetTime();
        m_CritSec.Lock();
            *pState = m_State;
            hr = pIntermediateFilter->GetState(10, &state);
        m_CritSec.Unlock();
        if (FAILED(hr) || hr == VFW_S_CANT_CUE) return hr;
        if ( state != *pState )
        {
            if ( state != State_Paused ) return E_FAIL;
            Sleep(10);
        }
        ASSERT( hr == S_OK || hr == VFW_S_STATE_INTERMEDIATE );
        const DWORD dwWait = timeGetTime() - dwStartTime;
        if (dwTimeout != INFINITE) dwTimeout = dwTimeout > dwWait ? dwTimeout - dwWait : 0;
    } // end-for(;;)
}  // GetState


#ifdef THROTTLE
// avoid compiler bug passing in q; wrong value passed in
#if defined _MIPS_
#pragma optimize ("", off)
#endif // _MIPS_

HRESULT CFilterGraph::TellVideoRenderers(Quality q)
{
    // MSR_INTEGER(mFG_idAudioVideoThrottle, (int)q.Late);   // log low order bits
    MSR_INTEGER(mFG_idAudioVideoThrottle, q.Proportion);
    // for piqc = the IQualityControl on each video renderer filter
    POSITION Pos = mFG_VideoRenderers.GetHeadPosition();
    while(Pos!=NULL) {
        /* Retrieve the current IBaseFilter, side-effect Pos on to the next */
        IQualityControl * piqc = mFG_VideoRenderers.GetNext(Pos);
        piqc->Notify(this, q);
    }
    return NOERROR;
} // TellVideoRenderers

#if defined _MIPS_
#pragma optimize ("", on)
#endif // _MIPS_


// Receive Quality notifications.  The only interesting ones are from
// Audio renderers.  Pass screams for help to video renderers.
STDMETHODIMP CFilterGraph::Notify(IBaseFilter * pSender, Quality q)
{
    // See if this is really from an Audio Renderer

    // NOTE!  We are NOT getting any locks here as this could be called
    // asynchronously and even from a time critical thread.
    // we do not alter any of the state variables, we only expect
    // to be called while running, and nobody else should be changing
    // any of these while we are running either!

    // for pf = each audio renderer filter
    BOOL bFound = FALSE;
    POSITION Pos = mFG_AudioRenderers.GetHeadPosition();
    while(Pos!=NULL) {
        /* Retrieve the current IBaseFilter, side-effect Pos on to the next */
        AudioRenderer * pAR = mFG_AudioRenderers.GetNext(Pos);
        // IsEqualObject is expensive (1mSec or more) unless the == succeeds.
        // Rather than hit the frame rate always, we'll just not do AV throttling
        // if we are getting a dumb interface.
        if (pAR->pf == pSender) {
            bFound = TRUE;
            break;
        }
    }
    if (bFound) {
        TellVideoRenderers(q);
    } else {
        DbgBreak("Notify to filter graph but not from AudioRenderer IBaseFilter *");
    }
    return NOERROR;
} // Notify

#endif // THROTTLE

//=====================================================================
//
// CFilterGraph::NonDelegatingQueryInterface
//
//=====================================================================

// new version of url reader filter knows to look for
// DISPID_AMBIENT_CODEPAGE from the container. interface looks like
// IUnknown.
static const GUID IID_IUrlReaderCodePageAware = { /* 611dff56-29c3-11d3-ae5d-0000f8754b99 */
    0x611dff56, 0x29c3, 0x11d3, {0xae, 0x5d, 0x00, 0x00, 0xf8, 0x75, 0x4b, 0x99}
  };


STDMETHODIMP CFilterGraph::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv, E_POINTER);
    IUnknown * pInterface;
#ifdef DEBUG
    pInterface = NULL;
#endif

    if (riid == IID_IMediaEventSink)  {
        pInterface = static_cast<IMediaEventSink*>(&mFG_pFGC->m_implMediaEvent);
    } else if (riid == IID_IUnknown) {
        goto CUnknownNDQI;
    } else if (riid == IID_IGraphBuilder || riid == IID_IFilterGraph2) {
        pInterface = static_cast<IFilterGraph2*>(this);
    } else if (riid == IID_IMediaControl) {
        pInterface = static_cast<IMediaControl*>(&mFG_pFGC->m_implMediaControl);
    } else if (riid == IID_IResourceManager) {
        pInterface = static_cast<IResourceManager*>(&mFG_pFGC->m_ResourceManager);
    } else if (riid == IID_IMediaSeeking) {
        pInterface = static_cast<IMediaSeeking*>(&mFG_pFGC->m_implMediaSeeking);
    } else if (riid == IID_IMediaEvent || riid == IID_IMediaEventEx) {
        return mFG_pFGC->m_implMediaEvent.NonDelegatingQueryInterface(riid, ppv);
    } else if (riid == IID_IBasicAudio) {
        pInterface = static_cast<IBasicAudio*>(&mFG_pFGC->m_implBasicAudio);
    } else if (riid == IID_IBasicVideo || riid == IID_IBasicVideo2) {
        pInterface = static_cast<IBasicVideo2*>(&mFG_pFGC->m_implBasicVideo);
    } else if (riid == IID_IVideoWindow) {
        pInterface = static_cast<IVideoWindow*>(&mFG_pFGC->m_implVideoWindow);
    } else if (riid == IID_IFilterGraph) {
        pInterface = static_cast<IFilterGraph*>(this);
    } else if (riid == IID_IFilterMapper || riid == IID_IFilterMapper2 || riid == IID_IFilterMapper3) {
        return mFG_pMapperUnk->QueryInterface(riid, ppv);
    } else if (riid == IID_IPersistStream) {
        pInterface = static_cast<IPersistStream*>(this);
    } else if (riid == IID_IObjectWithSite) {
        pInterface = static_cast<IObjectWithSite*>(this);
#ifdef DEBUG
    } else if (riid == IID_ITestFilterGraph) {
        HRESULT hr = S_OK;
        mFG_Test = new CTestFilterGraph( NAME("GraphTester"), this, &hr);
        if (mFG_Test==NULL) {
           return E_OUTOFMEMORY;
        } else if (FAILED(hr)) {
            delete mFG_Test;
            return hr;
        }
        return mFG_Test->NonDelegatingQueryInterface(riid, ppv);
#endif //DEBUG

    } else if ((riid == IID_IMediaFilter) || (riid == IID_IPersist)) {
        pInterface = static_cast<IMediaFilter *>(&mFG_pFGC->m_implMediaFilter);
    } else if (riid == IID_IGraphVersion) {
        // has a single method QueryVersion in filgraph.h
        pInterface = static_cast<IGraphVersion*>(this);
    } else if (riid == IID_IAMMainThread) {
        pInterface = static_cast<IAMMainThread*>(this);
    } else if (riid == IID_IAMOpenProgress) {
        pInterface = static_cast<IAMOpenProgress*>(this);
    } else if (riid == IID_IGraphConfig) {
        pInterface = static_cast<IGraphConfig*>(&m_Config);
    } else if (riid == IID_IAMGraphStreams) {
        pInterface = static_cast<IAMGraphStreams*>(this);
    } else if (riid == IID_IMediaPosition) {
        pInterface = static_cast<IMediaPosition*>(&mFG_pFGC->m_implMediaPosition);
    } else if (riid == IID_IQueueCommand) {
        pInterface = static_cast<IQueueCommand*>(&mFG_pFGC->m_qcmd);
    } else if (riid == IID_IVideoFrameStep) {
        pInterface = static_cast<IVideoFrameStep*>(this);
    } else if (riid == IID_IFilterChain) {
        pInterface =  static_cast<IFilterChain*>(m_pFilterChain);
    } else if (riid == IID_IAMStats) {
        return mFG_Stats->QueryInterface(riid, ppv);
    } else if (riid == IID_IMarshal) {
        return m_pMarshaler->QueryInterface(riid, ppv);
    } else if (riid == IID_IUrlReaderCodePageAware) {
        return CUnknown::NonDelegatingQueryInterface(IID_IUnknown, ppv);
    } else if (riid == IID_IRegisterServiceProvider) {
        pInterface =  static_cast<IRegisterServiceProvider *>(this);
    } else if (riid == IID_IServiceProvider) {
        pInterface =  static_cast<IServiceProvider *>(this);
    } else {
        // not an interface we know. Try the plug-in distributor.
        if (!mFG_pDistributor)
        {   // Create the distributor if we haven't got one yet.

                mFG_pDistributor = new CDistributorManager(GetOwner(), &m_CritSec);
            if (!mFG_pDistributor) return E_OUTOFMEMORY;
        }
        {
            HRESULT hr = mFG_pDistributor->QueryInterface(riid, ppv);
            if (SUCCEEDED(hr)) return hr;
        }
        // If nothing could be found in the registry - give it to the
        // base class (which will handle IUnknown and reject everything else.
    CUnknownNDQI:
            return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
    ASSERT( pInterface );
    return GetInterface( pInterface, ppv );
} // CFilterGraph::NonDelegatingQueryInterface


//========================================================================
//=====================================================================
// Persistent object support
//=====================================================================
//========================================================================


// Serialising to a stream:
//
// SYNTAX:
// <graph> ::= <version3><filters><connections><clock>END
//           | <version2><filters><connections>END
// <version3> ::= 0003\r\n
// <version2> ::= 0002\r\n
// <clock> ::= CLOCK <b> <required><b><clockid>\r\n
// <required> ::= 1|0
// <clockid> ::= <n>|<class id>
// <filters ::=FILTERS <b>[<filter list><b>]
// <connections> ::= CONNECTIONS [<b> <connection list>]
// <filter list> ::= [<filter> <b>] <filter list>
// <connection list> ::= [<connection><b>]<connection list>
// <filter> ::= <n><b>"<name>"<b><class id><b>[<file>]<length><b1><filter data>
// <n> ::= a decimal number
// <file> ::= SOURCE "<name>"<b> | SINK "<name>"<b>
// <class id> ::= class id of the filter in standard string form
// <name> ::= any sequence of characters NOT including "
// <length> ::= character string representing unsigned decimal number e.g. 23
//              this is the number of bytes of data that follow the following space.
// <b> ::= any combination of space, \t, \r or \n
// <b1> ::= exactly one space character
// <n> ::= an identifier which will in fact be an integer, 0001, 0002, 0003, etc
// <connection> ::= <n1><b>"<pin1 id>"<b><n2><b>"<pin2 id>" <media type>
// <n1> ::= identifier of first filter
// <n2> ::= identifier of second filter
// <pin1 id> ::= <Name>
// <pin2 id> ::= <Name>
// <media type> ::= <major type><b><sub type><b><flags><length><b1><format>
// <major type> ::= <class id>
// <sub type> ::= <class id>
// <flags> ::= <FixedSizeSamples><b><TemporalCompression><b>
// <FixedSizeSamples> ::= 1|0
// <TemporalCompression> ::= 1|0
// <Format> ::= <SampleSize><b><FormatType><b><FormatLength><b1><FormatData>
// <FormatType> ::= class id of the format in standard string form
// <FormatLength> ::= character string representing unsigned decimal number
//              this is the number of bytes of data that follow the following space.
// <FormatData> ::= glob of binary data
// <clock> ::= CLOCK <b> <required><b><clockid>\r\n
// <required> ::= 1|0
// <clockid> ::= <n>|<class id>
//
// On output there will be a new line (\r\n) per filter, one per connection,
// and one for each of the two keywords.
// Each other case of <B> will be a single space.
// Note that the two keywords FILTERS and CONNECTIONS are NOT LOCALISABLE.
// Note that the filter data and the format data are binary, so they may contain
// bogus line breaks, nulls etc.
// All strings are UNICODE
//
// What it will look like (well, nearly - a connection line is long and so
// has been split for presentation here):
// 0003
// FILTERS
// 0001 "Source" {00000000-0000-0000-0000-000000000001} SOURCE "foo.mpg" 0000000000
// 0002 "another filter" {00000000-0000-0000-0000-000000000002} 0000000008 XXXXXXXX
// CONNECTIONS
// 0001 "Output pin" 0002 "In"                                // no line break here
//     0000000172 {00000000-0000-0000-0000-000000000003}      // no line break here
//     {00000000-0000-0000-0000-000000000004} 1 0             // no line break here
//     0000000093 {00000000-0000-0000-0000-000000000005} 18 YYYYYYYYYYYYYYYYYY
// CLOCK 1 0002
// END
//
// XXX... represents filter data
// YYY... represents format data
//
// Whether we are ANSI or UNICODE, the data in the file will always be ANSI
// aka MultiByte




// IsDirty
//
// The graph is dirty if there have been any new filters added or removed
// any connections made or broken or if any filter says that it's dirty.
STDMETHODIMP CFilterGraph::IsDirty()
{
    HRESULT hr = S_FALSE;    // meaning clean
    if (mFG_bDirty) {
        return S_OK;  // OK means dirty
    }

    BOOL bDirty = FALSE;

    // Ask all filters if they are dirty - at least up to the first that says "yes"
    TRAVERSEFILGENS(Pos, pfg)

        IPersistStream * pps;
        hr = pfg->pFilter->QueryInterface(IID_IPersistStream, (void**)&pps);
        // A filter that does not expose IPersistStream has no data to persist
        // and therefore is always clean.  A filter that gives some other error
        // is all fouled up and so gives a failure return code.
        if (hr==E_NOINTERFACE){
            continue;
        } else if (FAILED(hr)) {
            break;
        }

        if (S_OK==pps->IsDirty()) {
            bDirty = TRUE;
        }

        pps->Release();
        if (bDirty) {
            break;
        }
    ENDTRAVERSEFILGENS

    if (SUCCEEDED(hr)) {
        hr = (bDirty ? S_OK : S_FALSE);
    }

    return hr;
} // IsDirty



//========================================================================
// BackUpOneChar
//
// Seek one UNICODE char back to read the last char again
//========================================================================
HRESULT BackUpOneChar(LPSTREAM pStm)
{
    LARGE_INTEGER li;
    li.QuadPart = -(LONGLONG)sizeof(WCHAR);
    return pStm->Seek(li, STREAM_SEEK_CUR, NULL);
} // BackUpOneChar


//========================================================================
// ReadInt
//
// Consume one optionally signed decimal integer from the stream.
// Consume also a single delimiting following white space character
// from the set {' ', '\n', '\r', '\t', '\0' }
// Other characters result in VFW_E_INVALID_FILE_FORMAT with the
// stream positioned at the first such character.
// Set n to the integer read.  Return any failure in hr.
// Overflows are NOT checked - so you'll get the number modulo something or other
// white space is not consumed.
// By a quirk "- " will be accepted and read as 0.
//========================================================================
HRESULT ReadInt(LPSTREAM pStm, int &n)
{
    HRESULT hr;
    ULONG uLen;
    WCHAR ch[1];
    int Sign = 1;
    n = 0;

    hr = pStm->Read(ch, sizeof(WCHAR), &uLen);
    if (FAILED(hr)) {
        return hr;
    }
    if (uLen!=sizeof(WCHAR)){
        return VFW_E_FILE_TOO_SHORT;
    }
    if (ch[0]==L'-'){
        Sign = -1;
        hr = pStm->Read(ch, sizeof(WCHAR), &uLen);
        if (FAILED(hr)) {
            return hr;
        }
        if (uLen!=sizeof(WCHAR)){
            return VFW_E_FILE_TOO_SHORT;
        }
    }

    for( ; ; ) {
        if (ch[0]>=L'0' && ch[0]<=L'9') {
            n = 10*n+(int)(ch[0]-L'0');
        } else if (  ch[0] == L' '
                  || ch[0] == L'\t'
                  || ch[0] == L'\r'
                  || ch[0] == L'\n'
                  || ch[0] == L'\0'
                  ) {
            break;
        } else {
            BackUpOneChar(pStm);
            return VFW_E_INVALID_FILE_FORMAT;
        }

        hr = pStm->Read(ch, sizeof(WCHAR), &uLen);
        if (FAILED(hr)) {
            return hr;
        }
        if (uLen!=sizeof(WCHAR)){
            return VFW_E_FILE_TOO_SHORT;
        }
    }
    return NOERROR;
} // ReadInt


//========================================================================
// ConsumeBlanks
//
// consume ' ', '\t', '\r', '\n' until something else is found
// Leave the stream positioned at the first non-blank
// if a failure occurs first, return the failure code
// Set Delim to the first non white space character found.
//========================================================================
HRESULT ConsumeBlanks(LPSTREAM pStm, WCHAR &Delim)
{
    HRESULT hr;
    ULONG uLen;
    WCHAR ch[1];

    for( ; ; ) {
        hr = pStm->Read(ch, sizeof(WCHAR), &uLen);
        if (FAILED(hr)) {
            return hr;
        }

        if (uLen!=sizeof(WCHAR)){
            return VFW_E_FILE_TOO_SHORT;
        }

        if (  ch[0] != L' '
           && ch[0] != L'\t'
           && ch[0] != L'\r'
           && ch[0] != L'\n'
           ) {
            break;
        }
    }

    BackUpOneChar(pStm);
    Delim = ch[0];
    return hr;

} // ConsumeBlanks


//========================================================================
// Consume
//
// Consume the given constant up to but not including its terminating NULL.
// In the event of a mismatch, return VFW_E_INVALID_FILE_FORMAT.
// If the file fails to read (too short or whatever) return the failure code.
// If the constant is found, return S_OK with the file positioned at the
// first character after the constant.
// (If there is a mismatch the file will be positioned one character after
// the mismatch).
//========================================================================
HRESULT Consume(LPSTREAM pStm, LPCWSTR pstr)
{
    ULONG uLen;
    WCHAR ch[1];
    HRESULT hr;

    while (pstr[0] != L'\0') {
        hr = pStm->Read(ch, sizeof(WCHAR), &uLen);
        if (FAILED(hr)) {
            return hr;
        }
        if (uLen!=sizeof(WCHAR)) {
            return VFW_E_FILE_TOO_SHORT;
        }
        if (pstr[0] != ch[0]){
            return VFW_E_INVALID_FILE_FORMAT;
        }
        ++pstr;
    }
    return NOERROR;
} // Consume


//========================================================================
// ReadNonBlank
//
// Given a stream positioned at some character and a pre-allocated pstr
// with room for cch (UNICODE) chars.
// read everything up to but not including the next blank into pstr.
// Consume that next blank character.   (blank is any of  ' ', '\n', '\t', '\r')
// If there are more than cb-1 non-blanks to read
// then return VFW_INVALID_FILE_FORMAT
// NULL terminate pstr.  pstr must be pre-allocated by caller.
//========================================================================
HRESULT ReadNonBlank(LPSTREAM pStm, LPWSTR pstr, int cch)
{
    HRESULT hr;

    ULONG uLen;
    if (cch<=0) {
        return E_INVALIDARG;
    }

    hr = pStm->Read(pstr, sizeof(WCHAR), &uLen);
    if (FAILED(hr)) {
        return hr;
    }
    if (uLen!=sizeof(WCHAR)) {
        return VFW_E_FILE_TOO_SHORT;
    }
    while (  *pstr != L'\t'
          && *pstr != L'\n'
          && *pstr != L'\r'
          && *pstr != L' '
          ) {
        ++pstr;
        --cch;
        if (cch==0) {
            return VFW_E_INVALID_FILE_FORMAT;  // string is too long
        }

        hr = pStm->Read(pstr, sizeof(WCHAR), &uLen);
        if (FAILED(hr)) {
            return hr;
        }
        if (uLen!=sizeof(WCHAR)) {
            return VFW_E_FILE_TOO_SHORT;
        }
    }

    // Overwrite terminating " with terminating null.
    *pstr = L'\0';
    return NOERROR;

} // ReadNonBlank


//========================================================================
// ReadString
//
// Given a stream positioned at a leading "
// read the string that follows into pstr whose size is cch UNICODE chars
// (including space for the final NULL).
// Replace final delimiting " in pstr with NULL.
// Leave pStm positioned at first character after the trailing "
//========================================================================
HRESULT ReadString(LPSTREAM pStm, LPWSTR pstr, int cch)
{
    HRESULT hr;
    ULONG uLen;

    hr = Consume(pStm, L"\"");
    if (FAILED(hr)) {
        return hr;
    }

    if (cch<=0) {
        return E_INVALIDARG;
    }

    hr = pStm->Read(pstr, sizeof(WCHAR), &uLen);
    if (FAILED(hr)) {
        return hr;
    }
    if (uLen!=sizeof(WCHAR)) {
        return VFW_E_FILE_TOO_SHORT;
    }
    while (*pstr != L'\"') {
        ++pstr;
        --cch;
        if (cch==0) {
            return VFW_E_INVALID_FILE_FORMAT;  // string is too long
        }
        hr = pStm->Read(pstr, sizeof(WCHAR), &uLen);
        if (FAILED(hr)) {
            return hr;
        }
        if (uLen!=sizeof(WCHAR)) {
            return VFW_E_FILE_TOO_SHORT;
        }
    }

    // Overwrite terminating " with terminating null.
    *pstr = L'\0';
    return NOERROR;

} // ReadString


//========================================================================
// LoadFilter
//
// Given a stream positioned at what might be the start of a <filter>
// Load the filter from the stream.
// A filter looks like
// 0002 "another filter" {00000000-0000-0000-0000-000000000002} 0000000008 XXXXXXXX
// Normally return NOERROR.
// S_FALSE means the filter didn't load its data
// VFW_S_NO_MORE_ITEMS means that the data didn't start with a number and
// so probably it's the end of the <filters> and the start of CONNECTIONS
// In this case the stream is left at the same position.
// See filgraph.h for explanation of nPersistOfset.
//========================================================================
HRESULT CFilterGraph::LoadFilter(LPSTREAM pStm, int nPersistOffset){
    // Allocate filgen
    // Read filter, name, clsid
    // Instantiate it
    // Read length
    // Load it
    BOOL bFilterError = FALSE;  // True if the filter didn't load its data.
    HRESULT hr = S_OK;

    int rcLen = 0;
    int len = 0;
    WCHAR Delim;
    FilGen * pfg;

    // Apologies for GOTOs - I can't find a better resource unwinding strategy.

    // Read nPersist - try this before allocating pfg as it might be the end.
    int nPersist;
    hr = ReadInt(pStm, nPersist);
    if (FAILED(hr)) {
        if (nPersist==0 && hr == VFW_E_INVALID_FILE_FORMAT) {
            hr = VFW_S_NO_MORE_ITEMS;
        }
        goto BARE_RETURN;
    }
    nPersist += nPersistOffset;

    pfg = new FilGen(NULL, 0 /* !!! */);
    if ( pfg==NULL ) {
        hr = E_OUTOFMEMORY;
        goto BARE_RETURN;
    }

    pfg->nPersist = nPersist;

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    // read name
    WCHAR Buffer[MAX_PATH+1];
    hr = ReadString(pStm, Buffer, MAX_FILTER_NAME+1);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    len = 1+lstrlenW(Buffer);
    pfg->pName = new WCHAR[len];
    if (!(pfg->pName)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    CopyMemory(pfg->pName, Buffer, len*sizeof(WCHAR));

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    // read clsid
    WCHAR wstrClsid[CHARS_IN_GUID];
    hr = ReadNonBlank(pStm, wstrClsid, CHARS_IN_GUID);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    CLSID clsid;
    hr = QzCLSIDFromString(wstrClsid, &clsid);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    // Instantiate the filter
    hr = CreateFilter( &clsid, &pfg->pFilter);
    if (FAILED(hr)) {
        goto FREE_FILGEN_AND_RETURN;
    }

    // We don't do AddFilter explicitly (Why not??? Code sharing???)


    // Get any Source file name and load it.
    if (Delim==L'S') {
        // SOURCE?
        hr = Consume(pStm, L"SOURCE");
        if (SUCCEEDED(hr)) {
            hr = ConsumeBlanks(pStm, Delim);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

            // Read the file name
            hr = ReadString(pStm, Buffer, MAX_PATH+1);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

            IFileSourceFilter * pifsf;
            hr = pfg->pFilter->QueryInterface(IID_IFileSourceFilter, (void**)&pifsf);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }
            hr = pifsf->Load(Buffer, NULL);
            pifsf->Release();
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

            hr = ConsumeBlanks(pStm, Delim);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

        } else if (hr==VFW_E_INVALID_FILE_FORMAT) {
            BackUpOneChar(pStm);
            BackUpOneChar(pStm);
        } else {
            goto FREE_FILGEN_AND_RETURN;
        }


        hr = Consume(pStm, L"SINK");
        if (SUCCEEDED(hr)) {
            hr = ConsumeBlanks(pStm, Delim);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

            // Read the file name
            hr = ReadString(pStm, Buffer, MAX_PATH+1);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

            IFileSinkFilter * pifsf;
            hr = pfg->pFilter->QueryInterface(IID_IFileSinkFilter, (void**)&pifsf);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }
            hr = pifsf->SetFileName(Buffer, NULL);
            pifsf->Release();
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

            hr = ConsumeBlanks(pStm, Delim);
            if (FAILED(hr)) {
                goto FREE_FILGEN_AND_RETURN;
            }

        } else if (hr==VFW_E_INVALID_FILE_FORMAT) {
            BackUpOneChar(pStm);
        } else {
            goto FREE_FILGEN_AND_RETURN;
        }
    }

    // Must add to list before calling JoinFilterGraph to allow callbacks
    // such as SetSyncSource
    // We are usually working downstream.  By adding it to the head  we are
    // probably putting it in upstream order.  May save time on the sorting.
    POSITION pos;
    pos = mFG_FilGenList.AddHead( pfg );
    if (pos==NULL) {
        hr = E_OUTOFMEMORY;
        goto FREE_FILGEN_AND_RETURN;
    }

    hr = pfg->pFilter->JoinFilterGraph( this, pfg->pName );
    if (FAILED(hr)) {
        goto REMOVE_FILTER_AND_RETURN;
    }

    // Read size of filter's private data
    int cbFilter;
    hr = ReadInt(pStm, cbFilter);
    if (FAILED(hr)) {
        goto REMOVE_FILTER_FROM_GRAPH_AND_RETURN;
    }
    if (cbFilter<0) {
        hr = VFW_E_INVALID_FILE_FORMAT;
        goto REMOVE_FILTER_FROM_GRAPH_AND_RETURN;
    }

    // The above also consumed exactly one (UNICODE) space after the end of the size
    if (cbFilter>0) {

        // Get the filter to read its private data
        // Take no chances on rogue filter - snapshot file position now.
        ULARGE_INTEGER StreamPos;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        hr = pStm->Seek(li, STREAM_SEEK_CUR, &StreamPos);  // get position
        if (FAILED(hr)) {
            goto REMOVE_FILTER_FROM_GRAPH_AND_RETURN;
        }

        // Get filter to read from stream
        IPersistStream * pips;
        hr = pfg->pFilter->QueryInterface(IID_IPersistStream, (void**)&pips);
        if (hr==E_NOINTERFACE) {
            // This is anomalous, because we *do* have data for it to read.
            // We will IGNORE the error and carry on loading (sort of best-can-do).
            bFilterError = TRUE;
        } else if (SUCCEEDED(hr)) {
            hr = pips->Load(pStm);
            if (FAILED(hr)) {
               bFilterError = TRUE;
            }
            pips->Release();
        } else {
            bFilterError = TRUE;
        }

        // Now seek to where the filter should have left things

        // Let's see if the filter behaved itself.  Find the current position again.
        ULARGE_INTEGER StreamPos2;
        li.QuadPart = 0;
        hr = pStm->Seek(li, STREAM_SEEK_CUR, &StreamPos2);  // get position
        if (FAILED(hr)) {
            goto REMOVE_FILTER_FROM_GRAPH_AND_RETURN;
        }

        // Is it where it should be?
        if (StreamPos2.QuadPart != StreamPos.QuadPart + cbFilter) {

            if (!bFilterError) {
                DbgBreak("Filter left stream wrongly positioned");
            }
            // The rat-bag!
            // Note we have a wobbly filter and seek to the right place.
            li.QuadPart = StreamPos.QuadPart + cbFilter;
            bFilterError = TRUE;
            hr = pStm->Seek(li, STREAM_SEEK_SET, NULL);   // reset position
            if (FAILED(hr)) {
                goto REMOVE_FILTER_FROM_GRAPH_AND_RETURN;
            }

        }

    }


    goto BARE_RETURN;

REMOVE_FILTER_FROM_GRAPH_AND_RETURN:
    EXECUTE_ASSERT( SUCCEEDED( pfg->pFilter->JoinFilterGraph( NULL, NULL ) ) );
REMOVE_FILTER_AND_RETURN:
    mFG_FilGenList.RemoveHead();
FREE_FILGEN_AND_RETURN:
    delete pfg;
BARE_RETURN:
    if (SUCCEEDED(hr) && hr!=VFW_S_NO_MORE_ITEMS) {
        hr = (bFilterError ? S_FALSE : NOERROR);
    }
    return hr;
} // LoadFilter

//========================================================================
// LoadFilters
//
// Given a stream positioned at the start of <filters>
// Load all the filters from the stream.
// Normally return NOERROR.
// S_FALSE means some filter didn't load its data (you guess which)
// Leaves the stream positioned at the end of the filters.
// See filgraph.h for explanation of nPersistOfset.
//========================================================================

HRESULT CFilterGraph::LoadFilters(LPSTREAM pStm, int nPersistOffset)
{
    BOOL bAllOK = TRUE;
    WCHAR Delim;
    HRESULT hr = NOERROR;
    while (SUCCEEDED(hr)) {
        hr = ConsumeBlanks(pStm, Delim);
        if (FAILED(hr)) {
            return hr;
        }
        hr = LoadFilter(pStm, nPersistOffset);
        if (hr==S_FALSE) {
            bAllOK = FALSE;
        }
        if (hr==VFW_S_NO_MORE_ITEMS) {
            break;
        }

    }

    if (hr==VFW_S_NO_MORE_ITEMS) {
        hr = NOERROR;
    }
    if (SUCCEEDED(hr)) {
        hr = (bAllOK ? S_OK : S_FALSE);
    }
    return hr;
} // LoadFilters


HRESULT CFilterGraph::ReadMediaType(LPSTREAM pStm, CMediaType &mt)
{
    int cb;                      // count of bytes to read
    HRESULT hr = ReadInt(pStm, cb);
    if (FAILED(hr)) {
        return hr;
    }

    BYTE * pBuf = new BYTE[cb];          // read raw bytes
    if (pBuf==NULL) {
        return E_OUTOFMEMORY;
    }

    ULONG uLen;
    hr = pStm->Read(pBuf, cb, &uLen);
    if (FAILED(hr)) {
        delete[] pBuf;
        return hr;
    }
    if ((int)uLen!=cb) {
        delete[] pBuf;
        return VFW_E_FILE_TOO_SHORT;
    }

    hr = CMediaTypeFromText((LPWSTR)pBuf, mt);

    delete[] pBuf;

    return hr;
} // ReadMediaType


//========================================================================
// LoadConnection
//
// Given a stream positioned at a <connection> load it.
// A connection looks like.
// 0001 "Output pin" 0002 "In"                                // no line break here
//     0000000172 {00000000-0000-0000-0000-000000000003}      // no line break here
//     {00000000-0000-0000-0000-000000000004} 1 0             // no line break here
//     {00000000-0000-0000-0000-000000000005}         18 YYYYYYYYYYYYYYYYYY
// See filgraph.h for explanation of nPersistOfset.
//========================================================================
HRESULT CFilterGraph::LoadConnection(LPSTREAM pStm, int nPersistOffset)
{
    HRESULT hr = S_OK;
    int len;
    WCHAR Delim;
    ConGen *pcg;
    BOOL bTypeIgnored = FALSE;   // TRUE => we used a default media type

    // Read nPersist - try this before allocating pfg as it might be the end.
    int nPersist;
    hr = ReadInt(pStm, nPersist);
    if (FAILED(hr)) {
        if (nPersist==0 && hr == VFW_E_INVALID_FILE_FORMAT) {
            hr = VFW_S_NO_MORE_ITEMS;
        }
        goto BARE_RETURN;
    }
    nPersist += nPersistOffset;

    pcg = new ConGen;
    if (pcg==NULL) {
        hr = E_OUTOFMEMORY;
        goto BARE_RETURN;
    }
    FilGen *pfg;

    pfg = mFG_FilGenList.GetByPersistNumber(nPersist);
    if (pfg==NULL) {
        hr = VFW_E_INVALID_FILE_FORMAT;
        goto FREE_CONGEN_AND_RETURN;
    }
    pcg->pfFrom = pfg->pFilter;
    if (pcg->pfFrom==NULL)
    {
        DbgBreak("pfFrom == NULL");
        hr = E_FAIL;
        goto FREE_CONGEN_AND_RETURN;  // Don't think this should happen
    }
    WCHAR Buffer[MAX_FILTER_NAME+1];

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }

    hr = ReadString(pStm, Buffer, MAX_FILTER_NAME);   // actually a pinname
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }

    len = 1+lstrlenW(Buffer);
    pcg->piFrom = new WCHAR[len];
    if (pcg->piFrom==NULL) {
        goto FREE_CONGEN_AND_RETURN;
    }

    CopyMemory(pcg->piFrom, Buffer, len*sizeof(WCHAR));

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }

    hr = ReadInt(pStm, nPersist);
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }
    nPersist += nPersistOffset;
    pfg = mFG_FilGenList.GetByPersistNumber(nPersist);
    if (pfg==NULL) {
        hr = VFW_E_INVALID_FILE_FORMAT;
        goto FREE_CONGEN_AND_RETURN;
    }
    pcg->pfTo = pfg->pFilter;
    if (pcg->pfTo==NULL)
    {
        DbgBreak("pfTo == NULL");
        hr = E_FAIL;
        goto FREE_CONGEN_AND_RETURN;  // Don't think this should happen
    }

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }

    hr = ReadString(pStm, Buffer, MAX_FILTER_NAME);   // actually a pinname
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }

    len = 1+lstrlenW(Buffer);
    pcg->piTo = new WCHAR[len];
    if (pcg->piTo==NULL) {
        goto FREE_CONGEN_AND_RETURN;
    }

    CopyMemory(pcg->piTo, Buffer, len*sizeof(WCHAR));

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        goto FREE_CONGEN_AND_RETURN;
    }

    hr = ReadMediaType(pStm, pcg->mt);
    if (FAILED(hr)){
        goto FREE_CONGEN_AND_RETURN;
    }

    // Try to make the connection and if it fails, put the
    // congen on the list.  NOTE: We do not have IPins in cg because
    // we might not be able to get any pins yet.
    hr = MakeConnection(pcg);
    if (FAILED(hr)) {
       if (NULL==mFG_ConGenList.AddTail(pcg)) {
           goto FREE_CONGEN_AND_RETURN;
       }
       hr = S_FALSE;      // deferred
       goto BARE_RETURN;  // It's on the list, so don't free it
    }
    if (hr==VFW_S_MEDIA_TYPE_IGNORED) {
        bTypeIgnored = TRUE;
    }

    hr = AttemptDeferredConnections();
    if (hr==VFW_S_MEDIA_TYPE_IGNORED) {
        bTypeIgnored = TRUE;
    }

    // drop through to free the congen that we have dealt with

FREE_CONGEN_AND_RETURN:
    // no need to delete[] pcg->piTo etc as the destructor does that.
    delete pcg;
BARE_RETURN:
    if (hr==NOERROR) {
        // We could have both a MEDIA_TYPE_IGNORED and a DEFERRED, but we
        // have only one return code.  Deferred is probably more serious.
        // Type ignored is probably more insidious.
        if (bTypeIgnored) {
            hr=VFW_S_MEDIA_TYPE_IGNORED;
        }
    }
    return hr;
} // LoadConnection


//========================================================================
// LoadConnections
//
// Given a stream positioned after <version> FILTERS <b> <filters>
// Load the connections from the stream
// See filgraph.h for explanation of nPersistOfset.
//========================================================================
HRESULT  CFilterGraph::LoadConnections(LPSTREAM pStm, int nPersistOffset){

    BOOL bAllOK = TRUE;
    BOOL bTypeIgnored = FALSE;
    HRESULT hr = NOERROR;
    WCHAR Delim;

    while (SUCCEEDED(hr)) {
        hr = ConsumeBlanks(pStm, Delim);
        if (FAILED(hr)) {
            return hr;
        }
        hr = LoadConnection(pStm, nPersistOffset);
        if (hr==S_FALSE) {
            bAllOK = FALSE;
        }
        if (hr==VFW_S_NO_MORE_ITEMS) {
            break;
        }
        if (hr==VFW_S_MEDIA_TYPE_IGNORED) {
            bTypeIgnored = TRUE;
        }
    }

    if (hr==VFW_S_NO_MORE_ITEMS) {
        hr = NOERROR;
    }
    if (SUCCEEDED(hr)) {
        if (!bAllOK) {
            hr = S_FALSE;
        } else if (bTypeIgnored) {
            hr = VFW_S_MEDIA_TYPE_IGNORED;
        } else {
            hr = S_OK;
        }
    }
    return hr;
} // LoadConnections


//========================================================================
// FindPersistOffset
//
// Return the value of the largest nPersist found in the list of filgens.
//========================================================================
int CFilterGraph::FindPersistOffset()
{
    int nPersist = 0;
    TRAVERSEFILGENS(Pos, pfg)
        if (pfg->nPersist>nPersist) {
            nPersist = pfg->nPersist>nPersist;
        }
    ENDTRAVERSEFILGENS
    return nPersist;

} // FindPersistOffset


HRESULT CFilterGraph::LoadClock(LPSTREAM pStm, int nPersistOffset)
{
    WCHAR Delim;
    HRESULT hr = Consume(pStm, L"CLOCK");  // do not localise!
    if (FAILED(hr)) {
        return hr;
    }

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        return hr;
    }

    int n;
    hr = ReadInt(pStm, n);
    if (FAILED(hr)) {
        return hr;
    }
    mFG_bNoSync = (n==0);

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        return hr;
    }

    IReferenceClock * pirc = NULL;

    // Read the file to find the new reference clock, instantiate it if need be
    // and set pirc to point to it
    if (Delim==L'{') {
        // We have a class id rather than a filter number
        WCHAR wstrClsid[CHARS_IN_GUID];
        hr = ReadNonBlank(pStm, wstrClsid, CHARS_IN_GUID);
        if (FAILED(hr)) {
            return hr;
        }

        CLSID clsid;
        hr = QzCLSIDFromString(wstrClsid, &clsid);
        if (FAILED(hr)) {
            return hr;
        }

        hr = CoCreateInstance( clsid, NULL, CLSCTX_INPROC
                             , IID_IReferenceClock, (void **) &pirc
                             );
        if (FAILED(hr)) {
            return hr;
        }

    } else {
        // We have a filter number (could be zero)
        int nClock;
        hr = ReadInt(pStm, nClock);
        if (FAILED(hr)) {
            return hr;
        }

        if (nClock!=0) {
            nClock += nPersistOffset;
            FilGen *pfg = mFG_FilGenList.GetByPersistNumber(nClock);
            if (pfg==NULL) {
                return VFW_E_INVALID_FILE_FORMAT;
            }

            hr = pfg->pFilter->QueryInterface( IID_IReferenceClock, (void**)(&pirc) );
            if (FAILED(hr)) {
                return hr;
            }
        }
    }

    // Either there was an error and we have already returned, or pirc is NULL
    // and no clock was defined
    // or pirc is a ref counted point3er to an IReferenceClock which we must use.

    if (pirc!=NULL) {
        hr = SetSyncSource(pirc);
        pirc->Release();
        if (FAILED(hr)) {
            return hr;
        }
    }

    hr = ConsumeBlanks(pStm, Delim);

    return hr;

} // LoadClock



//========================================================================
// LoadInternal
//
// Load the filter graph from the stream.
// If the operation FAILS the then filter graph may be left in an inconsistent state.
//========================================================================
HRESULT CFilterGraph::LoadInternal(LPSTREAM pStm)
{
    HRESULT hr;
    int nVersion;
    BOOL bDeferred = FALSE;      // connections deferred
    BOOL bWobblyFilter = FALSE;  // filter didn't load its data
    WCHAR Delim;
    BOOL bTypeIgnored = FALSE;

    // If the graph is not empty then we will become dirty as the file (whichever
    // one) won't contain what we will now have.
    // Mark it right now, at the beginning in case we bail out before the end.
    BOOL bDirty = (mFG_FilGenList.GetCount()>0);
    mFG_bDirty = bDirty;

    int nPersistOffset = FindPersistOffset();

    // Read the file version
    hr = ReadInt(pStm, nVersion);
    if (FAILED(hr)) {
        return hr;
    }
    if (nVersion>3 || nVersion<2) {
        return VFW_E_INVALID_FILE_VERSION;
    }

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        return hr;
    }

    hr = Consume(pStm, mFG_FiltersString);
    if (FAILED(hr)) {
        return hr;
    }

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        return hr;
    }

    hr = LoadFilters(pStm, nPersistOffset);
    if (FAILED(hr)) {
        return hr;
    } else if (hr==S_FALSE) {
        bWobblyFilter = TRUE;
    }

    hr = Consume(pStm, mFG_ConnectionsString);
    if (FAILED(hr)) {
        return hr;
    }

    hr = ConsumeBlanks(pStm, Delim);
    if (FAILED(hr)) {
        return hr;
    }
    if( mFG_bSyncUsingStreamOffset )
    {
        //
        // now that all filters and pins have been created, reset the max graph
        // latency on push source filters before restoring connections
        //
        SetMaxGraphLatencyOnPushSources( );
    }

    hr = LoadConnections(pStm, nPersistOffset);
    if (FAILED(hr)) {
        return hr;
    } else if (hr==S_FALSE) {
        bDeferred = TRUE;
    } else if (hr==VFW_S_MEDIA_TYPE_IGNORED) {
        bTypeIgnored = TRUE;
    }

    if (nVersion>=3) {
        hr = LoadClock(pStm, nPersistOffset);
    }
    if (FAILED(hr)) {
        return hr;
    }

    hr = Consume(pStm, L"END");
    if (FAILED(hr)) {
        // We may be missing a large chunk off the end.  Can't tell how much.
        return hr;
    }

    if (bWobblyFilter) {
        hr = VFW_S_SOME_DATA_IGNORED;
        // and there may be deferred connections too
    } else if (bDeferred) {
        hr = VFW_S_CONNECTIONS_DEFERRED;
    } else if (bTypeIgnored) {
        hr = VFW_S_MEDIA_TYPE_IGNORED;
    } else {
        hr = NOERROR;
    }

    // If we loaded into a clean graph, then the graph is now clean.
    // Many operations during load probably set the dirty bit, so fix it now.
    mFG_bDirty = bDirty;

    return hr;
} // LoadInternal



//========================================================================
// Load
//
// Load the filter graph from the stream.  Order it.
// If the operation FAILS the then filter graph may be left in an inconsistent state.
//========================================================================
STDMETHODIMP CFilterGraph::Load(LPSTREAM pStm)
{
    // MSR_INTEGER(0,1234567);
    mFG_bAborting = FALSE;             // possible race.  Doesn't matter
    CheckPointer(pStm, E_POINTER);
    HRESULT hr;
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);
        hr = LoadInternal(pStm);
        // ASSERT - the graph is actually ordered OK, because that's how we saved it.
        // Except that the sorting might have failed then - in which case it will fail
        // here too - but we must not try to run a circular graph.
        IncVersion();

        HRESULT hrUSO = UpstreamOrder();
        if( SUCCEEDED( hr ) && FAILED( hrUSO ) ) {
            return hrUSO;
        }
    }

    // outside lock, notify change
    NotifyChange();
    // MSR_INTEGER(0,7654321);
    return hr;
} // Load


//=======================================================================
// MakeConnection
//
// Make the connection described by pcg*
// return a failure code if it won't connect
//=======================================================================
HRESULT CFilterGraph::MakeConnection(ConGen * pcg)
{
    HRESULT hr;
    IPin * ppFrom;

    hr = pcg->pfFrom->FindPin(pcg->piFrom, &ppFrom);
    if (FAILED(hr)) {
        return hr;
    }
    ASSERT(ppFrom!=NULL);

    IPin * ppTo;

    hr = pcg->pfTo->FindPin(pcg->piTo, &ppTo);
    if (FAILED(hr)) {
        ppFrom->Release();
        return hr;
    }
    ASSERT(ppTo!=NULL);

    mFG_RList.Active();
    hr = ConnectDirectInternal(ppFrom, ppTo, &(pcg->mt));
    if (FAILED(hr)) {
        hr = ConnectDirectInternal(ppFrom, ppTo, NULL);
        if (SUCCEEDED(hr)) {
            hr = VFW_S_MEDIA_TYPE_IGNORED;
        }
    }
    mFG_RList.Passive();

    ppFrom->Release();
    ppTo->Release();
    return hr;

} // MakeConnection


//=======================================================================
// AttemptDeferredConnections
//
// Attempt all the connections on mFG_ConGenList.
// if there's any progress, try them again until no progress or all done.
// Delete from the list any that succeed.
// return S_FALSE if any left outstanding, S_OK if all done (and deleted)
// RList should probably be Active when you call this.
//=======================================================================
HRESULT CFilterGraph::AttemptDeferredConnections()
{
    BOOL bDeferred = FALSE;     // avoid compiler warning
    BOOL bProgress = TRUE;
    while (bProgress) {
        bProgress = FALSE;
        bDeferred = FALSE;
        POSITION pos = mFG_ConGenList.GetHeadPosition();
        while (pos != NULL)
        {
            ConGen * pcg;
            POSITION posRemember = pos;
            pcg = (mFG_ConGenList.GetNext(pos));   // pos now moved on

            if (  NULL==mFG_FilGenList.GetByFilter(pcg->pfFrom)
               || NULL==mFG_FilGenList.GetByFilter(pcg->pfTo)
               ) {
                // The filter has been removed - so purge it.
                delete pcg;
                mFG_ConGenList.Remove(posRemember);
            } else {
                HRESULT hr = MakeConnection(pcg);
                if (FAILED(hr)){
                    bDeferred = TRUE;
                } else {
                    delete pcg;
                    mFG_ConGenList.Remove(posRemember);
                    bProgress = TRUE;
                }
            }
        }
    }
    return (bDeferred ? S_FALSE : S_OK);
}  // AttemptDeferredConnections


//----------------------------------------------------------------------
// SaveFilterPrivateData
//
// Given that pips is a pointer to the IPersistStream interface on a filter,
// write to pStm the length of the private data of the filter as 10 decimal digits
// expressed as chars followed by a single space, followed by the private data
// of the filter.  Leave the stream positioned at the end of the private data.
// Pass the fClearDirty flag on to the filter.
//----------------------------------------------------------------------
HRESULT CFilterGraph::SaveFilterPrivateData
    (LPSTREAM pStm, IPersistStream* pips, BOOL fClearDirty)
{
    // We actually do things in a different order to achieve the above effect.
    // To allow the filter to do what it likes without advance notice, but
    // allow the stream to be parsed in one pass when we read it back in
    // we
    //    Snapshot the position at this point,
    //    Write bkanks where the size will go (10 digits plus a space)
    //    Call the filter,
    //    Find the position again,
    //    Subtract the two positions to get the real size of the filter,
    //    Seek back to the first position,
    //    Write the size data,
    //    Seek forward to the second position

    ULARGE_INTEGER StreamPos1;
    LARGE_INTEGER li;
    li.QuadPart = 0;
    HRESULT hr = pStm->Seek(li, STREAM_SEEK_CUR, &StreamPos1);  // get position
    if (FAILED(hr)) {
        return hr;
    }

    // make some space where we will go back and write a length
    const int SIZEOFLENGTH = 22;
    hr = pStm->Write(L"           ", SIZEOFLENGTH, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    hr = pips->Save(pStm, fClearDirty);                   // Write filter data
    if (FAILED(hr)) {
        return hr;
    }

    ULARGE_INTEGER StreamPos2;
    hr = pStm->Seek(li, STREAM_SEEK_CUR, &StreamPos2);     // get position
    if (FAILED(hr)) {
        return hr;
    }
    int cbFilter = (int)(StreamPos2.QuadPart-StreamPos1.QuadPart);
    cbFilter -= SIZEOFLENGTH;            // subtract our own size field and delimiter
    WCHAR Buff[12];
    wsprintfW(Buff, L"%010d ", cbFilter);   // must be SIZEOFLENGTH bytes (or less)
    li.QuadPart = StreamPos1.QuadPart;
    hr = pStm->Seek(li, STREAM_SEEK_SET, NULL);   // reset position
    if (FAILED(hr)) {
        return hr;
    }

    hr = pStm->Write( Buff, 22, NULL);      // write length
    if (FAILED(hr)) {
        return hr;
    }

    li.QuadPart = StreamPos2.QuadPart;
    hr = pStm->Seek(li, STREAM_SEEK_SET, NULL);   // reset position
    return hr;
} // SaveFilterPrivateData


//----------------------------------------------------------------------
// SaveFilters
//
// Write the keyword FILTERS and write all the filters and their private
// data out to pStm.  Pass the fClearDirty flag on to them.
// (It can be false in the SaveAs case)
// Bring filgen nPersist up to date.
//----------------------------------------------------------------------
HRESULT CFilterGraph::SaveFilters(LPSTREAM pStm, BOOL fClearDirty)
{
    // This routine progressively acquires resources and then releases them
    // in the inverse order.  Because the compiler isn't very good, multiple returns
    // are inefficient (at the moment).  To avoid this, there is code at
    // the end (ONE copy) which releases everything.  It has a bunch of
    // (shut-eyes, cross fingers behind back) GOTO targets.  Each target
    // causes some level of releasing and then exits.  Sorry.
    // The alternatives were so verbose, they seemed worse.

    HRESULT hr = pStm->Write( mFG_FiltersStringX
                            , lstrlenW(mFG_FiltersStringX)*sizeof(WCHAR)
                            , NULL
                            );
    if (FAILED(hr)) return hr;

    IPersist * pip;
    IPersistStream * pips;
    int nPersistFilter = 1;   // MUST NOT start from 0 (loading depends on this
                              // the persist offset thing would go wrong).

    // Reverse traverse of FILGENs to put the filters in the graph in
    // downstream order.
    POSITION Pos = mFG_FilGenList.GetTailPosition();
    while(Pos!=NULL) {
        /* Retrieve the current IBaseFilter, side-effect Pos on to the next */
        FilGen * pfg = mFG_FilGenList.Get(Pos);
        Pos = mFG_FilGenList.Prev(Pos);

        //-----------------------------------------------------------------
        // Write filter number followed by blank
        //-----------------------------------------------------------------

        pfg->nPersist = nPersistFilter; // SaveConnections needs this up to date
        WCHAR Buff[MAX_PATH+3];

        wsprintfW(Buff, L"%04d ", nPersistFilter);

        hr = pStm->Write(Buff, 10, NULL);
        if (FAILED(hr)) {
            goto BARE_RETURN;
        }

        //-----------------------------------------------------------------
        // Write filter name in quotes followed by blank
        //-----------------------------------------------------------------

        int Len = wsprintfW(Buff, L"\"%ls\" ", pfg->pName);
        hr = pStm->Write(Buff, Len*sizeof(WCHAR), NULL);


        //-----------------------------------------------------------------
        // Write filter clsid followed by blank
        //-----------------------------------------------------------------
        hr = pfg->pFilter->QueryInterface(IID_IPersist, (void**)&pip);
        if (FAILED(hr)) {
            goto BARE_RETURN;
        }

        CLSID clsid;
        hr = pip->GetClassID(&clsid);
        if (FAILED(hr)) {
            goto RELEASE_PERSIST;
        }

        hr = StringFromGUID2( clsid, Buff, CHARS_IN_GUID);
        if (FAILED(hr)) {
            goto RELEASE_PERSIST;
        }
        // Originally I had
        // lstrcatW(Buff, L" ");
        // here - but the compiler appeared to optimise it away!!!!
        // So now I'm doing the thing in two separate writes

        hr = pStm->Write(Buff, lstrlenW(Buff)*sizeof(WCHAR), NULL);
        if (FAILED(hr)) {
            goto RELEASE_PERSIST;
        }
        hr = pStm->Write(L" ", sizeof(WCHAR), NULL);
        if (FAILED(hr)) {
            goto RELEASE_PERSIST;
        }


        //-----------------------------------------------------------------
        // If it's a file source or sink, write the file name
        //-----------------------------------------------------------------

        {
            IFileSourceFilter * pifsource;
            IFileSinkFilter * pifsink;

            hr = pfg->pFilter->QueryInterface(IID_IFileSourceFilter, (void**)&pifsource);
            if (hr==E_NOINTERFACE) {
                // nothing to do
            } else if (FAILED(hr)) {
                goto RELEASE_PERSIST;
            } else {
                // it's a file source
                hr = pStm->Write( L"SOURCE "                         // DO NOT LOCALISE
                                , lstrlenW(L"SOURCE ")*sizeof(WCHAR) // DO NOT LOCALISE
                                , NULL
                                );
                if (FAILED(hr)) {
                    pifsource->Release();
                    goto RELEASE_PERSIST;
                }
                AM_MEDIA_TYPE mt;
                WCHAR *WBuff;
                hr = pifsource->GetCurFile(&WBuff, &mt);
                pifsource->Release();
                if (FAILED(hr)) {
                    goto RELEASE_PERSIST;
                }

                wsprintfW(Buff, L"\"%ls\" ", WBuff);
                hr = pStm->Write(Buff, lstrlenW(Buff)*sizeof(WCHAR), NULL);
                QzTaskMemFree(WBuff);
                if (FAILED(hr)) {
                    goto RELEASE_PERSIST;
                }
            }

            hr = pfg->pFilter->QueryInterface(IID_IFileSinkFilter, (void**)&pifsink);
            if (hr==E_NOINTERFACE) {
                // nothing to do
            } else if (FAILED(hr)) {
                goto RELEASE_PERSIST;
            } else {
                // it's a file source
                hr = pStm->Write( L"SINK "                         // DO NOT LOCALISE
                                , lstrlenW(L"SINK ")*sizeof(WCHAR) // DO NOT LOCALISE
                                , NULL
                                );
                if (FAILED(hr)) {
                    pifsink->Release();
                    goto RELEASE_PERSIST;
                }
                AM_MEDIA_TYPE mt;
                WCHAR *WBuff;
                hr = pifsink->GetCurFile(&WBuff, &mt);
                pifsink->Release();
                if (FAILED(hr)) {
                    goto RELEASE_PERSIST;
                }

                wsprintfW(Buff, L"\"%ls\" ", WBuff);
                hr = pStm->Write(Buff, lstrlenW(Buff)*sizeof(WCHAR), NULL);
                QzTaskMemFree(WBuff);
                if (FAILED(hr)) {
                    goto RELEASE_PERSIST;
                }
            }
        }

        hr = pfg->pFilter->QueryInterface(IID_IPersistStream, (void**)&pips);
        if (hr==E_NOINTERFACE) {
            hr = pStm->Write(L"0000000000 \r\n", 26, NULL);
            if (FAILED(hr)) {
                goto RELEASE_PERSIST;
            }
        } else if (FAILED(hr)) {
                goto RELEASE_PERSIST;
        } else {

            hr = SaveFilterPrivateData(pStm, pips, fClearDirty);
            if (FAILED(hr)) {
                goto RELEASE_PERSISTSTREAM;
            }

            hr = pStm->Write(L"\r\n", 4, NULL);
            if (FAILED(hr)) {
                goto RELEASE_PERSISTSTREAM;
            }

            pips->Release();
        }
        pip->Release();

        ++nPersistFilter;
    }  // end of reverse traverse of filgens

    goto BARE_RETURN;

RELEASE_PERSISTSTREAM:
    pips->Release();
RELEASE_PERSIST:
    pip->Release();
BARE_RETURN:
    return hr;
} // SaveFilters


// Write the id of ppin to stream pStm in quotes, followed by a space
HRESULT CFilterGraph::WritePinId(LPSTREAM pStm, IPin * ppin)
{
    LPWSTR id;

    HRESULT hr = ppin->QueryId(&id);
    if (FAILED(hr)) {
        return hr;
    }

    hr = pStm->Write( L"\"", 2, NULL);
    if (FAILED(hr)) {
        QzTaskMemFree(id);
        return hr;
    }

    hr = pStm->Write( id, lstrlenW(id)*sizeof(WCHAR), NULL);
    if (FAILED(hr)) {
        QzTaskMemFree(id);
        return hr;
    }


    hr = pStm->Write( L"\" ", 4, NULL);
    if (FAILED(hr)) {
        QzTaskMemFree(id);
        return E_FAIL;
    }

    QzTaskMemFree(id);
    return NOERROR;
} // WritePinId


HRESULT CFilterGraph::SaveConnection( LPSTREAM     pStm
                                    , int          nFilter1
                                    , IPin *       pp1
                                    , int          nFilter2
                                    , IPin *       pp2
                                    , CMediaType & cmt
                                    )
{
// 0001 "Output pin" 0002 "In"                                // no line break here
//     0000000172 {00000000-0000-0000-0000-000000000003}      // no line break here
//     {00000000-0000-0000-0000-000000000004} 1 0             // no line break here
//     {00000000-0000-0000-0000-000000000005}         18 YYYYYYYYYYYYYYYYYY

    WCHAR Buff[12];

    wsprintfW(Buff, L"%04d ", nFilter1);
    HRESULT hr = pStm->Write( Buff, 10, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    hr = WritePinId(pStm, pp1);
    if (FAILED(hr)) {
        return hr;
    }

    wsprintfW(Buff, L"%04d ", nFilter2);
    hr = pStm->Write( Buff, 10, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    hr = WritePinId(pStm, pp2);
    if (FAILED(hr)) {
        return hr;
    }

    wsprintfW(Buff, L"%010d ", MediaTypeTextSize(cmt));
    hr = pStm->Write( Buff, 22, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    LPWSTR pstr;
    MediaTypeToText(cmt, pstr);         // ??? Unnecessary copy - value parm

    hr = pStm->Write( pstr, MediaTypeTextSize(cmt), NULL);
    QzTaskMemFree(pstr);
    if (FAILED(hr)) {
        return hr;
    }

    hr = pStm->Write( L"\r\n", 4, NULL);

    return hr;

} // SaveConnection


//===================================================================
// Save all the connections to pStm in such an order that
// UPstream nodes are always encountered before DOWNstream nodes.
// This means that just working through the saved file is a valid order
// for re-establishing connections.
//===================================================================

HRESULT CFilterGraph::SaveConnections(LPSTREAM pStm)
{
    HRESULT hr;

    hr = pStm->Write( mFG_ConnectionsStringX
                    , lstrlenW(mFG_ConnectionsStringX)*sizeof(WCHAR)
                    , NULL
                    );
    if (FAILED(hr)) return hr;

    // for each filter
    //    for each pin

    // Work through the filgen list in REVERSE ORDER.
    // The connections have to be DOWNSTREAM sorted.
    POSITION Pos = mFG_FilGenList.GetTailPosition();;
    while (Pos!=NULL) {
        FilGen * pfg;

        pfg = mFG_FilGenList.Get(Pos);
        Pos = mFG_FilGenList.Prev(Pos);

        // Only enumerate input pins
        // (Note for the future.  There is no way in this scheme to
        // save out-of-graph connections).
        CEnumPin Next(pfg->pFilter, CEnumPin::PINDIR_INPUT);
        IPin *pPinIn;
        while ((PVOID) ( pPinIn = Next() )) {

           IPin *pPinOut;
           pPinIn->ConnectedTo(&pPinOut);
           if (pPinOut!=NULL) {
               PIN_INFO pi;
               HRESULT hr1 = pPinOut->QueryPinInfo(&pi);
               if (FAILED(hr1)) {
                   pi.pFilter=NULL;
                   hr = hr1;
               }
               CMediaType cmt;
               hr1 = pPinOut->ConnectionMediaType(&cmt);
               if (FAILED(hr1)) {
                   hr = hr1;
               }
               hr1 = SaveConnection( pStm
                                   , mFG_FilGenList.FilterNumber(pi.pFilter)
                                   , pPinOut
                                   , mFG_FilGenList.FilterNumber(pfg->pFilter)
                                   , pPinIn
                                   , cmt
                                   );
               if (FAILED(hr1)) {
                   hr = hr1;
               }
               QueryPinInfoReleaseFilter(pi);
               FreeMediaType(cmt);
               pPinOut->Release();
           }
           pPinIn->Release();
        }
    }

    return hr;
} // SaveConnections



HRESULT CFilterGraph::SaveClock(LPSTREAM pStm)
{
    HRESULT hr;
    // Write out whether the clock is required or not.
    hr = pStm->Write( (mFG_bNoSync ? L"CLOCK 0 " : L"CLOCK 1 "), 16, NULL);

    int nClock = 0;            // filter number of clock filter, default 0 (no filter)
    CLSID clsid = CLSID_NULL;  // class id of clock when it's not a filter.
    if (m_pClock) {

        // See if the clock comes from some filter in the graph

        FilGen *pfg = mFG_FilGenList.GetByFilter(m_pClock);
        if (pfg) {
            nClock = pfg->nPersist;
        }

        if (nClock==0) {
            // There is a clock, but it doesn't come from a filter.
            // Get its class id instead.
            IPersist *pip;
            hr = m_pClock->QueryInterface(IID_IPersist, (void**)&pip);
            if (SUCCEEDED(hr) && pip!=NULL) {
                hr = pip->GetClassID(&clsid);
                pip->Release();
                if (FAILED(hr)) {
                    return hr;
                }
            } else {
                return hr;
            }

        }
    }

    // We now have one of the following:
    // clock from filter: nClock
    // clock from elsewhere: clsid (not CLSID_NULL)
    // no clock: nClock==0 and clsid==CLSID_NULL

    if (clsid!=CLSID_NULL) {
        WCHAR Buff[CHARS_IN_GUID];
        hr = StringFromGUID2( clsid, Buff, CHARS_IN_GUID);
        if (FAILED(hr)) {
            return hr;
        }

        // CHARS_IN_GUID allows for a trailing null
        hr = pStm->Write(Buff, (CHARS_IN_GUID-1)*sizeof(WCHAR), NULL);
        if (FAILED(hr)) {
            return hr;
        }
    } else {
        WCHAR Buff[5];
        wsprintfW(Buff, L"%04d", nClock);

        hr = pStm->Write(Buff, 8, NULL);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // write a delimiter
    hr = pStm->Write(L"\r\n", 2*sizeof(WCHAR), NULL);

    return hr;

} // SaveClock




STDMETHODIMP CFilterGraph::Save(LPSTREAM pStm, BOOL fClearDirty)
{
    CheckPointer(pStm, E_POINTER);
    HRESULT hr;
    // We save this even if we are not dirty.  It could be a SaveAs
    // saving it to a new place.

    CAutoMsgMutex cObjectLock(&m_CritSec);
    hr = UpstreamOrder();
    if( FAILED( hr ) ) {
        return hr;
    }

    // Write file format version number.
    // If we change the format, increase this, then we can retain the
    // ability to read old files, or at least detect them.
    hr = pStm->Write( L"0003\r\n", 12, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    hr = SaveFilters(pStm, fClearDirty);
    if (FAILED(hr)) {
        return hr;
    }

    hr = SaveConnections(pStm);
    if (FAILED(hr)) {
        return hr;
    }

    hr = SaveClock(pStm);
    if (FAILED(hr)) {
        return hr;
    }

    hr = pStm->Write(L"END", sizeof(L"END")-2, NULL);// DO NOT LOCALISE
    if (FAILED(hr)) return hr;

    if (mFG_bDirty) {
        mFG_bDirty = !fClearDirty;
    }
    return NOERROR;

} // Save


// set cbSize to the max number of bytes that will be needed to save
// all the connections into a stream
HRESULT CFilterGraph::GetMaxConnectionsSize(int &cbSize)
{
    HRESULT hr = NOERROR;
    cbSize = 0;
    // Same traversal as for SaveConnections
    POSITION Pos = mFG_FilGenList.GetTailPosition();;
    while (Pos!=NULL) {
        FilGen * pfg;

        pfg = mFG_FilGenList.Get(Pos);
        Pos = mFG_FilGenList.Prev(Pos);

        // Only enumerate input pins
        CEnumPin Next(pfg->pFilter, CEnumPin::PINDIR_INPUT);
        IPin *pPinIn;
        while ((PVOID) ( pPinIn = Next() )) {

            IPin *pPinOut;
            pPinIn->ConnectedTo(&pPinOut);
            if (pPinOut!=NULL) {
                CMediaType cmt;
                HRESULT hr1 = pPinOut->ConnectionMediaType(&cmt);
                if (FAILED(hr1)) {
                    hr = hr1;
                }

                cbSize += 28; // n1, n2, + 2 spaces +crlf in UNICODE
                cbSize += MediaTypeTextSize(cmt);

                LPWSTR id;
                hr1 = pPinOut->QueryId(&id);
                if (FAILED(hr1)) {
                    hr = hr1;
                } else {
                    cbSize += sizeof(WCHAR)*lstrlenW(id)+6;  // two " and a space
                    CoTaskMemFree(id);
                }

                hr1 = pPinIn->QueryId(&id);
                if (FAILED(hr1)) {
                    hr = hr1;
                } else {
                    cbSize += sizeof(WCHAR)*lstrlenW(id)+6;  // two " and a space
                    CoTaskMemFree(id);
                }
                FreeMediaType(cmt);
                pPinOut->Release();
            }
            pPinIn->Release();
        }
    }

    return hr;
} // GetMaxConnectionsSize



STDMETHODIMP CFilterGraph::GetSizeMax(ULARGE_INTEGER * pcbSize)
{
    CheckPointer(pcbSize, E_POINTER);
    // The size will be
    // sizeof(WCHAR)
    // * (  7+2    // FILTERS
    //   + for each filter
    //     ( 4+1                     // number
    //     + CHARS_IN_GUID +1        // uuid
    //     + length of name +2 +1    // "filter name"
    //     + 10 +1                   // length of filter data
    //     + 2                       // new line
    //     )
    //   + 11 +2                     // CONNECTIONS
    //   + for each connection
    //     ( 4+1                     // filter1 number
    //     + length of pin name 2 +1 // "pin1 name"
    //     + 4+1                     // filter2 number
    //     + length of pin name 2 +1 // "pin2 name"
    //     + 154                     // basic media type
    //     )
    // + for each filter
    //   ( GetSizeMax() for its own private data
    //   )
    // + for each connection
    //   ( length of format block in text form
    //   )
    //
    // which amounts to
    //
    //      44
    //    + nFilters*120
    //    + nConnection*340
    //    + sum(filter name lengths)
    //    + sum(pin name lengths)
    //  WCHARs
    //    + sum(filter data lengths)
    //    + sum(format data lengths)
    //  bytes
    //
    // NOTE: these are always ANSI chars, not TCHARS, so a char is a byte


    HRESULT hr = NOERROR;

    // Sigh.  Do we have to allow for the filter that wants to save a
    // 5GB movie as part of its filter data.
    LONGLONG MaxSize = 44;

    TRAVERSEFILGENS(Pos, pfg)                                              \

        // Add overhead for the filter
        MaxSize += 120;

        FILTER_INFO fi;
        hr = pfg->pFilter->QueryFilterInfo(&fi);
        if (SUCCEEDED(hr)) {
            MaxSize += sizeof(WCHAR)*lstrlenW(fi.achName);
            QueryFilterInfoReleaseGraph(fi);
        } else {
            break;          // Ouch!
        }

        IPersistStream * pps;
        hr = pfg->pFilter->QueryInterface(IID_IPersistStream, (void**)&pps);
        if (FAILED(hr)) {
            continue;        // a filter with no IPersist has no data
        }

        ULARGE_INTEGER li;
        hr = pps->GetSizeMax(&li);
        if (SUCCEEDED(hr)) {
            MaxSize += li.QuadPart;
        } else {
            pps->Release();
            break;           // Ouch!
        }
        pps->Release();


    ENDTRAVERSEFILGENS


    if (SUCCEEDED(hr)) {
        // Add to MaxSize the size needed for all the connections.
        int cbSize;
        hr = GetMaxConnectionsSize(cbSize);
        pcbSize->QuadPart += cbSize;

    }


    if (SUCCEEDED(hr)) {
        hr = S_OK;
        pcbSize->QuadPart = MaxSize;
    } else {
        pcbSize->QuadPart = 0;
    }

    return hr;

} // GetSizeMax

HRESULT CFilterGraph::RunningStartFilters()
{
    ASSERT(CritCheckIn(&m_CritSec));

    if(m_State == State_Stopped) {
        return S_OK;
    }

    HRESULT hr = NOERROR;

    // If the list was not in upstream order already, make it so now.
    if (mFG_iVersion !=mFG_iSortVersion) {
        hr = UpstreamOrder();
        if (FAILED(hr)) {
            return hr;    // e.g. VFW_E_CIRCULAR_GRAPH
        }
    }

    CumulativeHRESULT chr(S_OK);
    chr.Accumulate(S_OK);
    TRAVERSEFILGENS(Pos, pfg)

        if(pfg->dwFlags & FILGEN_ADDED_RUNNING)
        {
            // !!! filters may already be in the running state. harm?

            if(m_State == State_Running) {
                chr.Accumulate( pfg->pFilter->Run(m_tStart) );
            } else {
                ASSERT(m_State == State_Paused);
                chr.Accumulate( pfg->pFilter->Pause() );
            }
        }

    ENDTRAVERSEFILGENS
    hr = chr;

    return hr;
}

// These strings are NOT LOCALISABLE!  They are real constants.
const WCHAR CFilterGraph::mFG_FiltersString[] = L"FILTERS";         // DON'T LOCALISE
const WCHAR CFilterGraph::mFG_FiltersStringX[] = L"FILTERS\r\n";    // DON'T LOCALISE
const WCHAR CFilterGraph::mFG_ConnectionsString[] = L"CONNECTIONS"; // DON'T LOCALISE
const WCHAR CFilterGraph::mFG_ConnectionsStringX[] = L"CONNECTIONS\r\n"; // DON'T LOCALISE
const OLECHAR CFilterGraph::mFG_StreamName[] = L"ActiveMovieGraph";   // DON'T LOCALISE


//========================================================================
//=====================================================================
// Other methods of class FilGen
//=====================================================================
//========================================================================


//========================================================================
//
// Constructor(IBaseFilter *)
//
// QI to see if this filter supports IPersistStorage.
// AddRef the filter.
// if pF is NULL then just do a minimal initialisation.
//========================================================================

CFilterGraph::FilGen::FilGen(IBaseFilter *pF, DWORD dwFlags)
    : pFilter(pF)
    , pName(NULL)
    , dwFlags(dwFlags)
{
    Rank = -1;
    nPersist = -1;

} // FilGen construct from filter


//=======================================================================
//
// Destructor
//
// Release the Filter & PersistStorage interfaces we got
//=======================================================================

CFilterGraph::FilGen::~FilGen()
{
    delete[] pName;
} // ~FilGen



//========================================================================
//=====================================================================
// Methods of class CFilGenList
//=====================================================================
//========================================================================

//=====================================================================
//
// GetByPersistNumber
//
// Find the FilGen that has the supplied nPersist
// return NULL if none exists.
//=====================================================================

CFilterGraph::FilGen * CFilterGraph::CFilGenList::GetByPersistNumber(int nPersist)
{

    POSITION pos = GetHeadPosition();
    while (pos != NULL) {
        CFilterGraph::FilGen *pFilGen = GetNext(pos);
        if (pFilGen->nPersist == nPersist) {
            return pFilGen;
        }
    }
    return NULL;
} // GetByPersistNumber


//===================================================================
//
// GetByFilter(IBaseFilter *)
//
// Find a filter in the list of FilGen
// return a pointer to that FilGen node.
// return NULL if it's not there.
//===================================================================

CFilterGraph::FilGen * CFilterGraph::CFilGenList::GetByFilter(IUnknown * pFilter)
{
    POSITION Pos = GetHeadPosition();

    // in the first pass, compare IFilter pointers directly (faster).
    while(Pos!=NULL) {
        CFilterGraph::FilGen * pfg = GetNext(Pos); // side-efects Pos onto next
        if (pFilter == pfg->pFilter)
        {
            return pfg;
        }
    }

    // 2nd pass: try the more expensive IsEqualObject()
    Pos = GetHeadPosition();

    while(Pos!=NULL) {
        CFilterGraph::FilGen * pfg = GetNext(Pos); // side-efects Pos onto next
        if (IsEqualObject(pfg->pFilter,pFilter))
        {
            return pfg;
        }
    }

    return NULL;
} // GetByFilter

int CFilterGraph::CFilGenList::FilterNumber(IBaseFilter * pF)
{
    FilGen *pfg = GetByFilter(pF);
    if (pfg) {
        return pfg->nPersist;
    } else {
        return -1;
    }
} // CFilGenList::FilterNumber

void CFilterGraph::SetInternalFilterFlags( IBaseFilter* pFilter, DWORD dwFlags )
{
    // A race condition could occur if the caller does not hold
    // the filter graph lock.
    ASSERT( CritCheckIn( GetCritSec() ) );

    // Make sure the filter is in the filter graph.
    ASSERT( SUCCEEDED( CheckFilterInGraph( pFilter ) ) );

    // Make sure flags are valid.
    ASSERT( IsValidInternalFilterFlags( dwFlags ) );

    CFilterGraph::FilGen *pfgen = mFG_FilGenList.GetByFilter( pFilter );

    // If this ASSERT fires, then the filter is not in the filter graph.
    ASSERT( NULL != pfgen );

    pfgen->dwFlags = dwFlags;
}

DWORD CFilterGraph::GetInternalFilterFlags( IBaseFilter* pFilter )
{
    // A race condition could occur if the caller does not hold
    // the filter graph lock.
    ASSERT( CritCheckIn( GetCritSec() ) );

    // Make sure the filter is in the filter graph.
    ASSERT( SUCCEEDED( CheckFilterInGraph( pFilter ) ) );

    CFilterGraph::FilGen *pfgen = mFG_FilGenList.GetByFilter( pFilter );

    // If this ASSERT fires, then the filter is not in the filter graph.
    ASSERT( NULL != pfgen );

    // Make sure flags we are returning are valid.
    ASSERT( IsValidInternalFilterFlags( pfgen->dwFlags ) );

    return pfgen->dwFlags;
}


//========================================================================
//=====================================================================
// Methods of class CFilGenList::CEnumFilters
//=====================================================================
//========================================================================


//=====================================================================
//
// CFilGenList::CEnumFilters::operator()
//
// return the next IBaseFilter
//=====================================================================

IBaseFilter * CFilterGraph::CFilGenList::CEnumFilters::operator++ (void)
{
    if (m_pos != NULL) {
        FilGen * pfg = m_pfgl->GetNext(m_pos);
        ASSERT(pfg->pFilter);
        return pfg->pFilter;
    }
    return NULL;
}

//========================================================================
//=====================================================================
// Methods of class CEnumFilters
//=====================================================================
//========================================================================


//=====================================================================
//
// CEnumFilters constructor   (normal, public version)
//
//=====================================================================

CEnumFilters::CEnumFilters
    ( CFilterGraph *pFilterGraph )
    : CUnknown(NAME("CEnumFilters"), NULL),
      mEF_pFilterGraph(pFilterGraph)
{
    // The graph whose filters we are going to enumerate is allowed to
    // asynchronously change the list while we are doing it.
    // This is expected to be rare (even anomolous).
    // Therefore we take a copy of the version number when we start
    // and check that it doesn't alter as we enumerate.  If it does
    // we fail the enumeration and the caller can either reset or
    // get a new enumerator to start again (or give up).

    CAutoMsgMutex cObjectLockGraph(&mEF_pFilterGraph->m_CritSec);
    mEF_pFilterGraph->AddRef();
    mEF_iVersion = mEF_pFilterGraph->GetVersion();
    mEF_Pos = pFilterGraph->mFG_FilGenList.GetHeadPosition();

} // CEnumFilters constructor (public version)



//=====================================================================
//
// CEnumFilters constructor   (private version for clone)
//
//=====================================================================

CEnumFilters::CEnumFilters
    ( CFilterGraph *pFilterGraph,
      POSITION Position,
      int iVersion
    )
    : CUnknown(NAME("CEnumFilters"), NULL),
      mEF_pFilterGraph(pFilterGraph)
{
    CAutoMsgMutex cObjectLockGraph(&mEF_pFilterGraph->m_CritSec);
    mEF_pFilterGraph->AddRef();
    mEF_iVersion = iVersion;
    mEF_Pos = Position;

} // CEnumFilters::CEnumFilters - private constructor



//=====================================================================
//
// CEnumFilters destructor
//
//=====================================================================

CEnumFilters::~CEnumFilters()
{
    // Release the reference that the constructor got.
    mEF_pFilterGraph->Release();

} // CEnumFilters destructor



//=====================================================================
//
// CEnumFilters::NonDelegatingQueryInterface
//
//=====================================================================

STDMETHODIMP CEnumFilters::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IEnumFilters) {
        return GetInterface((IEnumFilters *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
} // CEnumFilters::NonDelegatingQueryInterface



//=====================================================================
//
// CEnumFilters::Next
//
//=====================================================================

STDMETHODIMP CEnumFilters::Next
    (   ULONG cFilters,           // place this many AddReffed filters...
        IBaseFilter ** ppFilter,  // ...in this array of IBaseFilter*
        ULONG * pcFetched         // actual count passed returned here
    )
{
    CheckPointer(ppFilter, E_POINTER);
    CAutoLock cObjectLock(this);
    CAutoMsgMutex cObjectLockGraph(&mEF_pFilterGraph->m_CritSec);
    if (pcFetched!=NULL) {
        *pcFetched = 0;           // default unless we succeed
    }
    // now check that the parameter is valid
    else if (cFilters>1) {        // pcFetched == NULL
        return E_INVALIDARG;
    }

    if (mEF_iVersion!=mEF_pFilterGraph->GetVersion() ) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    ULONG cFetched = 0;           // increment as we get each one.

    if (NULL==mEF_Pos) {
       return S_FALSE;
    }

    while(cFetched < cFilters) {

        // Retrieve the current and step to the next (Eugh)
        CFilterGraph::FilGen * pFilGen = mEF_pFilterGraph->mFG_FilGenList.GetNext(mEF_Pos);
        ASSERT(pFilGen !=NULL);

        ppFilter[cFetched] = pFilGen->pFilter;
        pFilGen->pFilter->AddRef();
        ++cFetched;

        if (NULL==mEF_Pos) {
            break;
        }
    }

    if (pcFetched!=NULL) {
        *pcFetched = cFetched;
    }

    return (cFilters==cFetched ? S_OK : S_FALSE);

} // CEnumFilters::Next



//=====================================================================
//
// CEnumFilters::Skip
//
//=====================================================================
STDMETHODIMP CEnumFilters::Skip(ULONG cFilters)
{
    // We not only need to lock ourselves (so that we can update m_position)
    // We also need to lock the list that we are traversing
    CAutoLock cObjectLockEnum(this);

    if (mEF_iVersion!=mEF_pFilterGraph->GetVersion() ) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    // Now we need the second lock
    CAutoMsgMutex cObjectLockGraph(&mEF_pFilterGraph->m_CritSec);

    // Do we have any left to Skip?
    if (!mEF_Pos) {
        return(E_INVALIDARG);
        // This matches the OLE spec for IENUMx::Skip
        // IF we interpret being at the end of the list as
        // an invalid place at which to start skipping
    }


    while(cFilters--) {

        // Do we have any left to Skip?
        // If there are no more to skip, but the skip count has not
        // been exhausted then we should return S_FALSE.
        if (!mEF_Pos)
            return(S_FALSE);
            // we skipped fewer than requested, but we did skip at least one
            // note: putting this here only make sense for the second and
            // subsequent iteration.  However, putting it after the call to
            // GetNext means we end up testing cFilters again.

        // Note: GetNext(NULL) leaves it still NULL
        mEF_pFilterGraph->mFG_FilGenList.GetNext(mEF_Pos);
    }
    return NOERROR;
};  // CEnumFilters::Skip



/* Reset has 3 simple steps:
 *
 * Set position to head of list
 * Sync enumerator with object being enumerated
 * return S_OK
 */

STDMETHODIMP CEnumFilters::Reset(void)
{
    CAutoLock cObjectLock(this);
    CAutoMsgMutex cObjectLockGraph(&mEF_pFilterGraph->m_CritSec);

    HRESULT hr = mEF_pFilterGraph->UpstreamOrder();
    if( SUCCEEDED( hr ) ) {
        mEF_iVersion = mEF_pFilterGraph->GetVersion();
        mEF_Pos = mEF_pFilterGraph->mFG_FilGenList.GetHeadPosition();
    }

    return hr;
};



//=====================================================================
//
// CEnumFilters::Clone
//
//=====================================================================

STDMETHODIMP CEnumFilters::Clone(IEnumFilters **ppEnum)
{
    CheckPointer(ppEnum, E_POINTER);
    // Since we are taking a snapshot
    // of an object (current position and all) we must lock access at the start
    CAutoLock cObjectLock(this);

    HRESULT hr = NOERROR;
    CEnumFilters *pEnumFilters;

    pEnumFilters = new CEnumFilters(mEF_pFilterGraph, mEF_Pos, mEF_iVersion);
    if (pEnumFilters == NULL) {
        *ppEnum = NULL;
        return E_OUTOFMEMORY;
    }

    /* Get a reference counted IID_IEnumFilters interface to "return" */

    return pEnumFilters->QueryInterface(IID_IEnumFilters,(void **)ppEnum);

} // CEnumFilters::Clone


// IObjectWithSite::SetSite
// remember who our container is, for QueryService or other needs
//        Used also by objects locally registered in IRegisterServiceProvider when
//        they can't find local objects.

STDMETHODIMP
CFilterGraph::SetSite(IUnknown *pUnkSite)
{
    DbgLog((LOG_TRACE, 3, TEXT("SetSite")));

    // note: we cannot addref our site without creating a circle
    // luckily, it won't go away without releasing us first.
    mFG_punkSite = pUnkSite;

    return S_OK;
}

// IObjectWithSite::GetSite
// return an addrefed pointer to our containing object
STDMETHODIMP
CFilterGraph::GetSite(REFIID riid, void **ppvSite)
{
    DbgLog((LOG_TRACE, 3, TEXT("GetSite")));

    if (mFG_punkSite)
        return mFG_punkSite->QueryInterface(riid, ppvSite);

    return E_NOINTERFACE;
}


// Request that the graph builder should return as soon as possible from
// its current task.  Returns E_UNEXPECTED if there is no task running.
// Note that it is possible fot the following to occur in the following
// sequence:
//     Operation begins; Abort is requested; Operation completes normally.
// This would be normal whenever the quickest way to finish an operation
// was to simply continue to the end.
STDMETHODIMP CFilterGraph::Abort(){
    mFG_bAborting = TRUE;
    return NOERROR;
}


// Return S_OK if the curent operation is to continue,
// return S_FALSE if the current operation is to be aborted.
// E_UNEXPECTED may be returned if there was no operation in progress.
// This method can be called as a callback from a filter which is doing
// some operation at the request of the graph.
STDMETHODIMP CFilterGraph::ShouldOperationContinue(){
    return (mFG_bAborting ? S_FALSE : S_OK);
}


// Have the application thread call this entry point
STDMETHODIMP CFilterGraph::PostCallBack(LPVOID pfn, LPVOID pvParam)
{
    if (m_hwnd == NULL) return E_FAIL;

    // Use AWM_CREATEFILTER, since that's the only message guaranteed to be dispatched
    // on the background thread....

    AwmCreateFilterArg *pcfa = new AwmCreateFilterArg;

    if (!pcfa)
        return E_OUTOFMEMORY;

    pcfa->creationType = AwmCreateFilterArg::USER_CALLBACK;
    pcfa->pfn = (LPTHREAD_START_ROUTINE) pfn;
    pcfa->pvParam = pvParam;

    if (!PostMessage(m_hwnd, AWM_CREATEFILTER, (WPARAM) pcfa, 0)) {
        delete pcfa;
        return E_OUTOFMEMORY;
    }

    return S_OK;
};


// --- IAMOpenProgress ---

STDMETHODIMP
CFilterGraph::QueryProgress(LONGLONG* pllTotal, LONGLONG* pllCurrent)
{
    CAutoLock lock(&mFG_csOpenProgress);

    HRESULT hr = E_NOINTERFACE;

    *pllTotal = *pllCurrent = 0;

    POSITION Pos = mFG_listOpenProgress.GetHeadPosition();
    while (Pos!=NULL) {
    LONGLONG llTotal, llCurrent;

        IAMOpenProgress * pOp;
        pOp = mFG_listOpenProgress.GetNext(Pos);    // side-efects Pos onto next

    HRESULT hr2 = pOp->QueryProgress(&llTotal, &llCurrent);
    if (SUCCEEDED(hr2)) {
        hr = hr2;
        *pllTotal += llTotal;
        *pllCurrent += llCurrent;
    }
    }

    return hr;
}

STDMETHODIMP
CFilterGraph::AbortOperation()
{
    CAutoLock lock(&mFG_csOpenProgress);

    if (mFG_RecursionLevel > 0)
    mFG_bAborting = TRUE;

    HRESULT hr = E_NOINTERFACE;

    POSITION Pos = mFG_listOpenProgress.GetHeadPosition();
    while (Pos!=NULL) {
        IAMOpenProgress * pOp;
        pOp = mFG_listOpenProgress.GetNext(Pos);    // side-efects Pos onto next

    hr = pOp->AbortOperation();
    }

    return hr;
}

// --- Other methods ---

void CFilterGraph::NotifyChange()
{
    if (mFG_RecursionLevel==0) {
    if (mFG_pDistributor) mFG_pDistributor->NotifyGraphChange();
    }
}

//  Initialize our thread creating cs
void CFilterGraph::InitClass(BOOL bCreate, const CLSID *pclsid)
{
    // pointers referenced out of scope, so make it static. Ok to
    // use global variable in DLL_ATTACH
    static SECURITY_DESCRIPTOR g_sd;
    static SECURITY_ATTRIBUTES g_sa;
    static PACL     g_pACL;


    if (bCreate) {
        g_pACL = NULL;
        _Module.Init(NULL, g_hInst);
        InitializeCriticalSection(&g_Stats.m_cs);
        g_Stats.Init();
        InitializeCriticalSection(&g_csObjectThread);

        g_psaNullDescriptor = 0;
        if(g_osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            PSID pSid = NULL;
            SID_IDENTIFIER_AUTHORITY authority = SECURITY_WORLD_SID_AUTHORITY;


            // Allocate and initialize the SID
            if (AllocateAndInitializeSid(   &authority,
                                            1, 
                                            SECURITY_WORLD_RID,  
                                            0, 0, 0, 0, 0, 0, 0,
                                            &pSid)) 
            {
                ULONG nSidSize = GetLengthSid(pSid);

                ULONG AclSize = nSidSize * 2 +
                    sizeof(ACCESS_ALLOWED_ACE) +
                    sizeof (ACCESS_DENIED_ACE) +
                    sizeof(ACL);

                g_pACL = (PACL) LocalAlloc(LPTR, AclSize);
                if (NULL == g_pACL)
                {
                    DbgLog((LOG_ERROR, 0, TEXT("Error : Allocating ACL")));
                    ASSERT(FALSE);
                    FreeSid(pSid);
                    return;
                }

                // Initialize ACL
                if (InitializeAcl(g_pACL,
                                  AclSize,
                                  ACL_REVISION)) 
                {
                    if (AddAccessAllowedAce(g_pACL,
                                            ACL_REVISION,
                                            (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL | GENERIC_ALL) & 
                                            ~(WRITE_DAC | WRITE_OWNER),
                                            pSid))
                    {
                        // I know that I won't need more than this
                        if(InitializeSecurityDescriptor(&g_sd, SECURITY_DESCRIPTOR_REVISION))
                        {
                            if(SetSecurityDescriptorDacl(
                                &g_sd,
                                TRUE,       // acl present?
                                g_pACL, // Grant:Everyone (World):(ALL_ACCESS & ~(WRITE_DAC | WRITE_OWNER))
                                FALSE))     // bDaclDefaulted
                            {
                                FreeSid(pSid);
                                g_sa.nLength = sizeof(g_sa);
                                g_sa.lpSecurityDescriptor = &g_sd;
                                g_sa.bInheritHandle = TRUE;
                                g_psaNullDescriptor = &g_sa;
                            }
                            else
                            {
                                DbgLog((LOG_ERROR, 0, TEXT("Error : SetSecurityDescriptorDacl()")));
                                FreeSid(pSid);
                            }
                        }
                        else
                        {
                            DbgLog((LOG_ERROR, 0, TEXT("Error : InitializeSecurity()")));
                            FreeSid(pSid);
                        }
                    }
                    else
                    {
                        DbgLog((LOG_ERROR, 0, TEXT("Error : AddAccessAllowedAce()")));
                        FreeSid(pSid);
                    }
                }
                else
                {
                    DbgLog((LOG_ERROR, 0, TEXT("Error : InitializeAcl()")));
                    FreeSid(pSid);
                }
            }
            else
                DbgLog((LOG_ERROR, 0, TEXT("AllocateAndInitializeSid() Failed !!!")));

            ASSERT(g_psaNullDescriptor);
        }
        else
        {
            ASSERT(g_psaNullDescriptor == 0);
        }


    } else {
        //  For some reason g_dwObjectThreadId can be 0 here
        ASSERT(g_cFGObjects == 0 /*&& g_dwObjectThreadId == 0*/);
        DeleteCriticalSection(&g_csObjectThread);
        _Module.Term();
        DeleteCriticalSection(&g_Stats.m_cs);
        // free up the memory allocated for the ACL above.
        if (g_pACL)
        {
            LocalFree(g_pACL);
        }
    }
}


struct CreateRequest
{
    CAMEvent evDone;
    LPUNKNOWN pUnk;
    HRESULT hr;
    CUnknown *pObject;
};

//  Object thread
DWORD WINAPI ObjectThread(LPVOID pv)
{
    //  Try to avoid creating the OLE DDE window
    if (FAILED(CAMThread::CoInitializeHelper())) {
        CoInitialize(NULL);
    }

    //  Make sure we have a message loop (will CoInitialize ensure this?)
    //  and tell our initializer we're running
    MSG msg;
    EXECUTE_ASSERT(FALSE == PeekMessage(&msg, NULL, 0, 0, PM_REMOVE));
    EXECUTE_ASSERT(SetEvent((HANDLE)pv));

    //  Our task is to create objects, pump messages and go
    //  away when there are no objects left

    for (;;) {

        GetMessage(&msg, NULL, 0, 0);

        BOOL bFailedCreate = FALSE;

#ifdef DO_RUNNINGOBJECTTABLE
        if (msg.hwnd == NULL && msg.message == WM_USER + 1) {
            //  Unregister ourselves from the ROT
            CFilterGraph *pfg = (CFilterGraph *) (msg.wParam);

            IRunningObjectTable *pirot;
            if (SUCCEEDED(GetRunningObjectTable(0, &pirot))) {
                pirot->Revoke(pfg->m_dwObjectRegistration);
                pirot->Release();
            }

            CAMEvent * pevDone = (CAMEvent *) msg.lParam;

            pevDone->Set();
        } else
#endif
        if (msg.hwnd == NULL && msg.message == WM_USER) {
            //  Create request
            struct CreateRequest *pCreate = (struct CreateRequest *)msg.wParam;
            pCreate->pObject = CFilterGraph::CreateInstance(
                                  pCreate->pUnk, &pCreate->hr);
            if (pCreate->pObject == NULL) {
                bFailedCreate = TRUE;
            }
            pCreate->evDone.Set();
        } else {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        BOOL bExit = FALSE;
        EnterCriticalSection(&g_csObjectThread);
        if (bFailedCreate) {
            g_cFGObjects--;
        }
        if (g_cFGObjects == 0) {
            g_dwObjectThreadId = 0;
            bExit = TRUE;
        }
        LeaveCriticalSection(&g_csObjectThread);
        if (bExit) {
            break;
        }
    }
    CoUninitialize();
    FreeLibraryAndExitThread(g_hInst, 0);
    return 0;
}

//
//  Create objects on the thread
//  This thread serves 2 purposes :
//  1.  Keep objects (windows) alive
//  2.  Dispatch messages
//
CUnknown *CFilterGraph::CreateThreadedInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    //  Make sure we've got a thread that won't go away
    struct CreateRequest req;

    BOOL bOK = TRUE;
    if ((HANDLE)req.evDone == NULL) {
        bOK = FALSE;
    }
    req.hr = S_OK;
    req.pObject = NULL;
    req.pUnk = pUnk;
    EnterCriticalSection(&g_csObjectThread);
    if (g_dwObjectThreadId == 0 && bOK) {
        // The painful bit is to increment our load count
        // Note the thread can't exit without going through the
        // critical section we're currently holding so order doesn't
        // matter too much here
        TCHAR sz[1000];
        bOK = 0 != GetModuleFileName(g_hInst, sz, sizeof(sz) / sizeof(sz[0]));
        if (bOK) {
            HINSTANCE hInst = LoadLibrary(sz);
            if (hInst != NULL) {
                ASSERT(hInst == g_hInst);
            } else {
                bOK = FALSE;
            }
        }
        ASSERT(g_dwObjectThreadId == 0);
        if (bOK) {
            HANDLE hThread = CreateThread(NULL,
                                          0,
                                          ObjectThread,
                                          (PVOID)(HANDLE)req.evDone,
                                          0,
                                          &g_dwObjectThreadId);
            if (hThread == NULL) {
                bOK = FALSE;
                FreeLibrary(g_hInst);
            } else {
                req.evDone.Wait();
            }
            CloseHandle(hThread);
        }
    }
    if (bOK) {
        bOK = PostThreadMessage(g_dwObjectThreadId, WM_USER,
                                (WPARAM)&req, 0);
        //  Make sure the thread doesn't go away before seeing our request
        if (bOK) {
             g_cFGObjects++;
        } else {
            DbgLog((LOG_TRACE, 0, TEXT("PostThreadMessage failed")));
        }
    }
    LeaveCriticalSection(&g_csObjectThread);
    if (bOK) {
        WaitDispatchingMessages(HANDLE(req.evDone), INFINITE);
        if (FAILED(req.hr)) {
            *phr = req.hr;
        }
    } else {
        *phr = E_OUTOFMEMORY;
    }
    return req.pObject;
}


#ifdef DO_RUNNINGOBJECTTABLE
//  Add ourselves to the Running Object Table - doesn't matter
//  if this fails
void CFilterGraph::AddToROT()
{
    if (m_dwObjectRegistration) {
        return;
    }
    //  Keep alive - we're in the constructor so this is OK
    m_cRef++;

#if 1
    //  This doesn't currently work if we want to use VB's GetObject because
    //  VB only creates file monikers
    IMoniker * pmk;
    IRunningObjectTable *pirot;
    if (FAILED(GetRunningObjectTable(0, &pirot))) {
        return;
    }
    WCHAR wsz[256];
    // !!!
    wsprintfW(wsz, L"FilterGraph %08x  pid %08x", (DWORD_PTR) this, GetCurrentProcessId());
    HRESULT hr = CreateItemMoniker(L"!", wsz, &pmk);
    if (SUCCEEDED(hr)) {
        hr = pirot->Register(0, GetOwner(), pmk, &m_dwObjectRegistration);
        pmk->Release();

        // release us to compensate for the reference the ROT will keep
        this->Release();
    }
    pirot->Release();
#else

    //  This only lets us register one object but we can at least
    //  work with VB
    HRESULT hr = RegisterActiveObject(GetOwner(),
                                      CLSID_FilterGraph,
                                      ACTIVEOBJECT_WEAK,
                                      &m_dwObjectRegistration);
#endif
    m_cRef--;
}
#endif // DO_RUNNINGOBJECTTABLE

// Video frame stepping support

HRESULT CFilterGraph::SkipFrames(DWORD dwFramesToSkip, IUnknown *pStepObject, IFrameSkipResultCallback* pFSRCB)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    if (NULL == pFSRCB) {
        return E_INVALIDARG;
    }

    if (State_Running != m_State) {
        return VFW_E_WRONG_STATE;
    }

    // A filter cannot do a frame skip operation if another
    // frame step or frame skip operation is in progress.
    if (FST_NOT_STEPPING_THROUGH_FRAMES != m_fstCurrentOperation)  {
        return E_FAIL;
    }

    return StepInternal(dwFramesToSkip, pStepObject, pFSRCB, FST_DONT_BLOCK_AFTER_SKIP);
}

STDMETHODIMP CFilterGraph::Step(DWORD dwFrames, IUnknown *pStepObject)
{
    return StepInternal(dwFrames, pStepObject, NULL, FST_BLOCK_AFTER_SKIP);
}

HRESULT CFilterGraph::StepInternal(DWORD dwFramesToSkip, IUnknown *pStepObject, IFrameSkipResultCallback* pFSRCB, FRAME_STEP_TYPE fst)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    // The pFSRCB callback in only used by the frame skipping code.
    ASSERT( ((NULL == pFSRCB) && (FST_BLOCK_AFTER_SKIP == fst)) ||
            ((NULL != pFSRCB) && (FST_DONT_BLOCK_AFTER_SKIP == fst)) );

    // The application cannot do a frame step operation while a 
    // frame skip operation is in progress.  Also, a filter
    // should not do a frame skip operation if another frame skip 
    // operation is in progress.
    if (FST_DONT_BLOCK_AFTER_SKIP == m_fstCurrentOperation)  {
        return E_FAIL;
    }

    if (NULL == pStepObject) {
        //  This returns a non-AddRef()'d pointer
        pStepObject = GetFrameSteppingFilter(dwFramesToSkip != 1 ? true : false);
    }

    if (NULL == pStepObject) {
        return VFW_E_FRAME_STEP_UNSUPPORTED;
    }

    // Cancel any previous step (no notify)
    // CancelStep(false);

    // Tell the relevant filter to step
    HRESULT hr = CallThroughFrameStepPropertySet(pStepObject,
                                                 AM_PROPERTY_FRAMESTEP_STEP,
                                                 dwFramesToSkip);

    if (SUCCEEDED(hr)) {
        m_pVideoFrameSteppingObject = pStepObject;
        m_fstCurrentOperation = fst;
        m_pFSRCB = pFSRCB;
        hr = mFG_pFGC->m_implMediaControl.StepRun();
        if (FAILED(hr)) {
            CancelStep();
            return hr;
        }
    }

    return S_OK;
}

STDMETHODIMP CFilterGraph::CanStep(long bMultiple, IUnknown *pStepObject)
{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    // The application cannot do a frame step operation while a 
    // frame skip operation is in progress.
    if (FST_DONT_BLOCK_AFTER_SKIP == m_fstCurrentOperation)  {
        return S_FALSE;
    }

    if (NULL == pStepObject) {
        //  This returns an non-AddRef()'d pointer
        pStepObject = GetFrameSteppingFilter(!!bMultiple);
        if (pStepObject) {
            return S_OK;
        } else {
            return S_FALSE;
        }
    }

    return  CallThroughFrameStepPropertySet(
                     pStepObject,
                     bMultiple ?
                          AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE :
                          AM_PROPERTY_FRAMESTEP_CANSTEP,
                     0);
}

//  Cancel stepping
STDMETHODIMP CFilterGraph::CancelStep()
{
    return CancelStepInternal(FSN_NOTIFY_FILTER_IF_FRAME_SKIP_CANCELED);
}

HRESULT CFilterGraph::CancelStepInternal(FRAME_SKIP_NOTIFY fsn)

{
    CAutoMsgMutex cObjectLock(&m_CritSec);

    if (m_pVideoFrameSteppingObject) {
        HRESULT hr = CallThroughFrameStepPropertySet(
                                               m_pVideoFrameSteppingObject,
                                               AM_PROPERTY_FRAMESTEP_CANCEL,
                                               0);

        mFG_pFGC->m_implMediaEvent.ClearEvents(EC_STEP_COMPLETE);
        mFG_pFGC->m_dwStepVersion++;
        m_pVideoFrameSteppingObject = NULL;
        if ((FSN_DO_NOT_NOTIFY_FILTER_IF_FRAME_SKIP_CANCELED != fsn) &&
             FrameSkippingOperationInProgress()) {
            m_pFSRCB->FrameSkipFinished(E_ABORT);
        }
        m_fstCurrentOperation = FST_NOT_STEPPING_THROUGH_FRAMES;
        m_pFSRCB = NULL;
        return hr;
    } else {
        return S_OK;
    }
}

IUnknown *CFilterGraph::GetFrameSteppingFilter(bool bMultiple)
{
    CFilGenList::CEnumFilters NextOne(mFG_FilGenList);
    IBaseFilter *pf;
    while ((PVOID) (pf = ++NextOne)) {
        if (S_OK == CanStep(bMultiple, pf)) {
            return pf;
        }
    }
    return NULL;
}

HRESULT CFilterGraph::CallThroughFrameStepPropertySet(
    IUnknown *punk,
    DWORD dwPropertyId,
    DWORD dwData)
{
    IKsPropertySet *pProp;
    HRESULT hr = punk->QueryInterface(IID_IKsPropertySet, (void**)&pProp);
    if (SUCCEEDED(hr)) {

        hr = pProp->Set(AM_KSPROPSETID_FrameStep,
                        dwPropertyId,
                        NULL,
                        0,
                        dwPropertyId == AM_PROPERTY_FRAMESTEP_STEP ? &dwData : NULL,
                        dwPropertyId == AM_PROPERTY_FRAMESTEP_STEP ? sizeof(DWORD) : 0);

        pProp->Release();
    }
    return hr;
}

REFERENCE_TIME CFilterGraph::GetStartTimeInternal( void )
{
    // A race condition could occur if the caller does not hold
    // the filter graph lock when it calls this function.
    ASSERT( CritCheckIn( GetCritSec() ) );

    // The m_tStart variable is only valid when the filter graph
    // is running because it's the time the filter graph switched to
    // the run state.
    ASSERT( State_Running == GetStateInternal() );

    return m_tStart;
}

HRESULT CFilterGraph::IsRenderer( IBaseFilter* pFilter )
{
    return mFG_pFGC->IsRenderer( pFilter );
}

HRESULT CFilterGraph::UpdateEC_COMPLETEState( IBaseFilter* pRenderer, FILTER_STATE fsFilter )
{
    return mFG_pFGC->UpdateEC_COMPLETEState( pRenderer, fsFilter );
}

//  IServiceProvider
STDMETHODIMP CServiceProvider::QueryService(REFGUID guidService, REFIID riid,
                          void **ppv)
{
    if (NULL == ppv) {
        return E_POINTER;
    }
    *ppv = NULL;
    CAutoLock lck(&m_cs);
    for (ProviderEntry *pEntry = m_List; pEntry; pEntry = pEntry->pNext) {
        if (pEntry->guidService == guidService) {
            return pEntry->pProvider->QueryInterface(riid, ppv);
        }
    }

    CFilterGraph *pGraph = static_cast<CFilterGraph *>(this);
    if(!pGraph->mFG_punkSite)
        return E_NOINTERFACE;

    IServiceProvider *pSPSite=NULL;     // get the site...
                                    // does it support IServiceProvider?
    HRESULT hr = pGraph->mFG_punkSite->QueryInterface(IID_IServiceProvider, (void **) &pSPSite);
    if(!FAILED(hr))
    {
        hr = pSPSite->QueryService(guidService, riid, ppv);
        pSPSite->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\filgraph.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __DefFilGraph
#define __DefFilGraph

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "MsgMutex.h"
#include "stats.h"
#include "statsif.h"

#if _MSC_VER >= 1100 || defined(NT_BUILD)
#include "sprov.h"
#include "urlmon.h"
#else
#include "datapath.h"
#endif
#include "rlist.h"
#include "distrib.h"
#include "dyngraph.h"
#include "sprov.h" // CServiceProvider
#include <buildcb.h>
#include <skipfrm.h>

class CFGControl;
class CFilterChain;
class CEnumCachedFilters;

// push source list
typedef struct {
    IAMPushSource   *pips;
    IReferenceClock *pClock;
    ULONG            ulFlags;
} PushSourceElem;
typedef CGenericList<PushSourceElem> PushSourceList;

//  Do graph spy stuff

// #define DO_RUNNINGOBJECTTABLE

// Hungarian (sort of)
// member variables of the filter graph of type t are prefixed mFG_tName
// member variables of FilGenList  ............................mfgl_tName
// member variables of FilGen      ............................mfg_tName
// member variables of ConGenList  ............................mcgl_tName
// member variables of FilGen      ............................mcg_tName
// member variables inherited (typically) .....................m_tName
// This convention has not been observed by all authors, and there may still be
// some inconsistencies, but let's work towards uniformity!

#ifdef DEBUG
DEFINE_GUID(IID_ITestFilterGraph,0x69f09720L,0x8ec8,0x11ce,0xaa,0xb9,0x00,0x20,0xaf,0x0b,0x99,0xa3);


DECLARE_INTERFACE_(ITestFilterGraph, IUnknown)
{
    STDMETHOD(TestRandom) (THIS) PURE;
    STDMETHOD(TestSortList) (THIS) PURE;
    STDMETHOD(TestUpstreamOrder) (THIS) PURE;
    // STDMETHOD(TestTotallyRemove) (THIS) PURE;
};

class CTestFilterGraph;       // forwards
#endif // DEBUG

// Used to get callbacks into filters on the main application thread
DEFINE_GUID(IID_IAMMainThread,0x69f09721L,0x8ec8,0x11ce,0xaa,0xb9,0x00,0x20,0xaf,0x0b,0x99,0xa3);

DECLARE_INTERFACE_(IAMMainThread,IUnknown)
{
    STDMETHOD(PostCallBack) (THIS_ LPVOID pfn, LPVOID pvParam) PURE;
    STDMETHOD(IsMainThread) (THIS) PURE;
    STDMETHOD(GetMainThread) (THIS_ ULONG *pThreadId) PURE;
};

enum FRAME_STEP_TYPE 
{
    FST_NOT_STEPPING_THROUGH_FRAMES,
    FST_DONT_BLOCK_AFTER_SKIP,
    FST_BLOCK_AFTER_SKIP
};

enum FRAME_SKIP_NOTIFY 
{
    FSN_NOTIFY_FILTER_IF_FRAME_SKIP_CANCELED,
    FSN_DO_NOT_NOTIFY_FILTER_IF_FRAME_SKIP_CANCELED
};

// Abstract class implementing the IGraphBuilder and IEnumFilters interfaces.
class CEnumFilters;  // Forward declaration

// CumulativeHRESULT - this function can be used to aggregate the return
// codes that are received from the filters when a method is distributed.
// After a series of Accumulate()s m_hr will be:
// a) the first non-E_NOTIMPL failure code, if any;
// b) else the first non-S_OK success code, if any;
// c) E_NOINTERFACE if no Accumulates were made;
// d) E_NOTIMPL iff all Accumulated HRs are E_NOTIMPL
// e) else the first return code (S_OK by implication).

class CumulativeHRESULT
{
protected:
    HRESULT m_hr;
public:
    CumulativeHRESULT(HRESULT hr = E_NOINTERFACE) : m_hr(hr)
    {}

    void __fastcall Accumulate( HRESULT );

    operator HRESULT() { return m_hr; }
};

STDAPI CoCreateFilter(const CLSID *pclsid, IBaseFilter **ppFilter);

//==========================================================================
//==========================================================================
// CFilterGraph class.
//==========================================================================
//==========================================================================

class CFilterGraph : public IFilterGraph2
                   , public IGraphVersion
                   , public IPersistStream
#ifdef THROTTLE
                   , public IQualityControl
#endif // IQualityControl
                   , public IObjectWithSite
                   , public IAMMainThread
                   , public IAMOpenProgress
                   , public IAMGraphStreams
                   , public IVideoFrameStep
                   , public CServiceProvider				// IServiceProvider, IRegisterServiceProvider
                   , public CBaseFilter
{
        friend class CEnumFilters;
        friend class CTestFilterGraph;
        friend class CFGControl;
        friend class CGraphConfig;

    public:
        DECLARE_IUNKNOWN

    private:
        CFGControl * mFG_pFGC;
#ifdef DEBUG
        CTestFilterGraph * mFG_Test;
#endif

    public:
        CMsgMutex *GetCritSec() { return &m_CritSec; };
        CMsgMutex m_CritSec;

        // If SetSyncSource(NULL) has been called explicitly then we must
        // avoid setting a default sync source
        // note that we also need this to be accessible from fgctl which uses it to "unset" the graph clock
        BOOL mFG_bNoSync;

        //=========================================================================
        // FilGen
        // What we know ("the gen") about the filters in the graph.
        // The graph has a list of these.  See below.
        // Note that this is a thin, public class.  Almost just a glorified struct
        //=========================================================================

// added_manually - distinguish filters Intelligent Connect picked up
// from those added external code. !!! persist this bit?
//
#define FILGEN_ADDED_MANUALLY       0x8000

// filter added while graph was running and hasn't been run()
#define FILGEN_ADDED_RUNNING        0x4000

// IGraphConfig::Reconnect() searches for a pin to reconnect to if the
// caller only specifies one pin.  For example, if the caller
// only specifies the input pin, Reconnect() searches for an output pin
// to reconnect to.  Reconnect() stops searching if it encounters a
// filter with the FILGEN_ADDED_MANUALLY flag set and the
// FILGEN_FILTER_REMOVEABLE flag is not set.  Reconnect()
// always continues to search if the FILGEN_FILTER_REMOVEABLE flag is set.
#define FILGEN_FILTER_REMOVEABLE    0x2000

        class FilGen {
            public:
                CComPtr<IBaseFilter> pFilter;  // The interface to the filter
                LPWSTR    pName;        // Its name in this graph
                                        // Caching it here makes FindFilterByName much easier
                int       nPersist;     // Its number (for the persistent graph)
                int       Rank;         // How far from the rendering end of chain
                DWORD     dwFlags;

            public:
                FilGen(IBaseFilter *pF, DWORD dwFlags);
                ~FilGen();
        }; //Filgen

        // nPersist and nPersistOffset
        // We obviously can't store pointers in a saved graph, so filters are
        // identified by an integer (nPersist) which is broadly their position
        // in the list of FilGen.  If we load a file and then decide to merge
        // in another file, the nPersist numbers in the second file will be
        // already in use, so we find the largest value in use and offset all
        // the nPersist numbers in the new file by this much when we read them in.


        //=========================================================================
        // CFilGenList
        //
        // This list is normally kept in upstream order (renderers first).
        // To help this along, as the graph normally grows downstream we add to
        // new filters to the head of the list.  We sort it when it looks like
        // the sorting is going to matter, not after every operation, but we
        // bump the version number every time we do anything significant.
        // The ordering of the list controls the order in which operations (such
        // as Stop) are distributed to the filters - i.e. the head will be a
        // renderer, the tail will be a source.  This is a partial ordering in
        // the mathematical sense.
        //=========================================================================

        class CFilGenList : public CGenericList<FilGen>
        {
            private:
                CFilterGraph *mfgl_pGraph;
            public:

                CFilGenList(TCHAR *pName, CFilterGraph * pGr)
                    : CGenericList<FilGen>(pName)
                    , mfgl_pGraph(pGr)
                    {}
                ~CFilGenList() {}

                // IBaseFilter Enumerator (see fgenum.h for general comments)

                class CEnumFilters {
                    // Use it like this:
                    //     CFilGenList::CEnumFilters NextOne(mFG_FilGenList);
                    //     while ((BOOL) (pf = NextOne())) {
                    //         etc
                    //     }
                    //
                    public:
                        CEnumFilters(CFilGenList& fgl)
                            { m_pfgl = &fgl; m_pos = fgl.GetHeadPosition(); }
                        ~CEnumFilters() {}

                        IBaseFilter *operator++ (void);

                    private:
                        CFilGenList *m_pfgl;
                        POSITION    m_pos;
                };

                // utilities to find the thing in the list:
                int FilterNumber(IBaseFilter * pF);
                FilGen *GetByPersistNumber(int n);
                FilGen *GetByFilter(IUnknown *pFilter);


        }; // CFilGenList

        void SetInternalFilterFlags( IBaseFilter* pFilter, DWORD dwFlags );
        DWORD GetInternalFilterFlags( IBaseFilter* pFilter );

        #ifdef DEBUG
        static bool IsValidInternalFilterFlags( DWORD dwFlags );
        #endif // DEBUG

        //========================================================================
        // ConGen
        // A description of a connection that has come from a saved graph
        // but was not able to be made at that time (e.g. because what was
        // saved was only a partial graph).  Pins are described as ids
        // rather than IPin* because the pins might not even exist (once
        // again Robin's splitter comes to mind) as some filters do not
        // expose their pins unless the filter is in just the right state.
        // It's possible to construct graphs that can be saved,
        // but which then won't load, (hint: add scaffolding;
        // build part you want to save; delete scaffolding; save).
        // Such graphs "ought to be valid" (in some sense).
        // To allow them, we keep a list of these outstanding connections
        // that didn't work when we loaded.
        // We try to complete these whenever we get a chance.
        //     (After any Connect, ConnectDirect, before Pause).
        // We do not purge the list on RemoveFilterInternal (which might be logical)
        // but we do purge from the list any reference to a missing filter when
        // we attempt the deferred connections.
        //
        // If the list still has outstanding items then Pause etc. must
        // give some sort of "not totally successful" return code.
        //========================================================================

        class ConGen {
            public:
                // no extra addrefs for these IBaseFilter*s.
                IBaseFilter * pfFrom;   // The interface to the FROM FILTER
                IBaseFilter * pfTo;     // The interface to the TO FILTER

                LPWSTR    piFrom;   // The id of the FROM pin
                LPWSTR    piTo;     // The id of the TO pin

                CMediaType mt;      // the media type of the connection

                ConGen()
                    : pfFrom(NULL)
                    , pfTo(NULL)
                    , piFrom(NULL)
                    , piTo(NULL)
                {};
                ~ConGen()
                {
                    if (piFrom) delete[] piFrom;
                    if (piTo) delete[] piTo;
                };
        };


        class CConGenList : public CGenericList<ConGen>
        {
            public:

                CConGenList(TCHAR *pName)
                    : CGenericList<ConGen>(pName)
                    {}
                ~CConGenList() {}
        }; // CConGenList


        // The complete topology of the filtergraph can be worked out by
        // EnumFilters to get all the filters
        // EnumPins to get the pins on a filter in the list
        // QueryConnection to get a ConnectionInfo with the peer in it
        // QueryPinInfo to get a PIN_INFO with the other IBaseFilter in it.


        // RunningStartFilters is called when the graph has been
        // changed while running.
        HRESULT RunningStartFilters();

    private:

        // Constants in the stream:  (THESE ARE NOT LOCALISABLE!)
        static const WCHAR mFG_FiltersString[];
        static const WCHAR mFG_FiltersStringX[];
        static const WCHAR mFG_ConnectionsString[];
        static const WCHAR mFG_ConnectionsStringX[];
        static const OLECHAR mFG_StreamName[];


        //=========================================================================
        // The member variables
        //=========================================================================

        CFilGenList mFG_FilGenList;  // list of filter objects in the filtergraph
        CConGenList mFG_ConGenList;  // list of connections that didn't load
        CReconnectList mFG_RList;    // list of pending reconnections
        // There is no explicit code to free the contents of mFG_RList.  The RList
        // is only non-empty during a connect or Render type of operation.

        // VERSIONs and DIRT
        // In order to traverse a list of filters quickly, we don't want to
        // go digging in the registry or interrogating the filters all the time
        // (if only because it expands the volume of code by a factor of four
        // or so checking the return codes all the time).
        // Therefore we want to keep here the
        // information on what filters we have in the graph and how they are
        // connected together.  It is only safe to perform state changes on filters
        // working from downstream to upstream.  Therefore the list is kept
        // sorted in that order (actually it's a partial ordering).  To avoid
        // excessive sorting, we only bother to sort it when we need to.
        // We increment the version number whenever a significant change occurs
        // and we record the last version number that was sorted.
        // A significant change is
        // 1. Something that alters the sort order (Connect - nothing else)
        // 2. Something that would break the enumerator (RemoveFilter, because
        //    it might leave it pointing at an object that had gone away).
        // 3. Something that might give a strange enumeration (AddFilter, etc.)
        //    (We don't need to break the enum, but it seems kinder).
        // External functions increment the version, internal ones do not because
        // Incrementing it in mid render causes sorting in mid-render.  Not good.
        // So the version is incremented by:
        // 1. Connect, ConnectDirect, Render, RenderFile,
        // 2. RemoveFilter,
        // 3. AddFilter, AddSourceFilter
        //
        // the IGraphVersion interface makes this version number
        // visible externally to eg plug-in distributors or
        // apps like graphedt
        //
        // The dirty flag indicates that changes have happened since the graph was
        // saved.  The graph starts clean and the dirty flag is set by lowest level
        // internal functions.
        //     ConnectDirectInternal,

        int mFG_iSortVersion; // version number when the list was sorted


        // you must call mFG_Distributor.NotifyGraphChange whenever version
        // is changed. You must not be holding the filtergraph
        // lock when you do the call.
        int mFG_iVersion;     // Version number, ++ whenever Add or Remove filter
                              // or alter connections.  See CEnumFilters.
                              // See VERSION comment above.
        // If mFG_iVersion==mFG_iSortVersion then the graph is sorted.

        BOOL mFG_bDirty;             // Changes made since last save
                                     // (Add, Remove Connect, Disconnect)
                                     // There could also be filter changes underneath.



        // Presentation time == base + stream time.
        // The base time is therefore the time when the zeroth sample
        // is to be rendered.

        CRefTime mFG_tBase;     // Stopped => 0, else must be valid.

        // When we pause, the stream time stops but real time goes on.
        // Therefore the time when the zeroth sample would have been
        // rendered moves.  So we need to know when we paused so that
        // we can reset tBase when we start Running.

        CRefTime mFG_tPausedAt; // time when we paused, 0 if Stopped

        // mapper unknown for aggregation
        IUnknown * mFG_pMapperUnk;

        // if this flag is TRUE the filter graph attempts to determine
        // a max latency for all graph streams and pass this value to
        // IAMPushSource filters to use as the offset in their timestamping
        BOOL mFG_bSyncUsingStreamOffset;
        REFERENCE_TIME mFG_rtMaxGraphLatency;

        int mFG_RecursionLevel;    // used to detect recursive calls.
        IPin *mFG_ppinRender;      // Some protection for bottomless Streambuilders

        HANDLE mFG_hfLog;                    // log file to trace intel actions.

        DWORD mFG_dwFilterNameCount;        // Used for name-mangling of filter names
        HRESULT InstallName(LPCWSTR pName, LPWSTR &pNewName);

        //=========================================================================
        // IAMMainThread support - get application thread callbacks
        //=========================================================================

        DWORD m_MainThreadId;
        HWND m_hwnd;

    public:
        //  IVideoFrameStep
        STDMETHODIMP Step(DWORD dwFrames, IUnknown *pStepObject);
        STDMETHODIMP CanStep(long bMultiple, IUnknown *pStepObject);
        STDMETHODIMP CancelStep();

        HRESULT SkipFrames(DWORD dwFramesToSkip, IUnknown *pStepObject, IFrameSkipResultCallback* pFSRCB);
        HRESULT CancelStepInternal(FRAME_SKIP_NOTIFY fNotifyFrameSkipCanceled);

        bool BlockAfterFrameSkip();
        bool DontBlockAfterFrameSkip();
        IFrameSkipResultCallback* GetIFrameSkipResultCallbackObject();

    private:
        //  Internal stuff
        IUnknown *GetFrameSteppingFilter(bool bMultiple);
        HRESULT CallThroughFrameStepPropertySet(IUnknown *punk,
                                            DWORD dwPropertyId,
                                            DWORD dwData);
        HRESULT StepInternal(DWORD dwFramesToSkip, IUnknown *pStepObject, IFrameSkipResultCallback* pFSRCB, FRAME_STEP_TYPE fst);
        bool FrameSkippingOperationInProgress();

        // Have the application thread call this entry point
        STDMETHODIMP PostCallBack(LPVOID pfn, LPVOID pvParam);

        // Is this current thread the application thread
        STDMETHOD(IsMainThread) (THIS)
        {
            if (GetCurrentThreadId() == m_MainThreadId)
                return S_OK;
            else return S_FALSE;
        };

        // Return the application thread identifier
        STDMETHOD(GetMainThread) (THIS_ ULONG *pThreadId)
        {
            CheckPointer(pThreadId,E_POINTER);
            *pThreadId = m_MainThreadId;
            return S_OK;
        };



    public:
        //=========================================================================
        // IPersist* support
        //=========================================================================
        // IPersistStream methods
        STDMETHODIMP IsDirty();
        STDMETHODIMP Load(LPSTREAM pStm);
        STDMETHODIMP Save(LPSTREAM pStm, BOOL fClearDirty);
        STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize);
    private:
        HRESULT LoadInternal(LPSTREAM pStm);
        HRESULT LoadFilters(LPSTREAM pStm, int nPersistOffset);
        HRESULT LoadFilter(LPSTREAM pStm, int nPersistOffset);
        HRESULT ReadMediaType(LPSTREAM pStm, CMediaType &mt);
        HRESULT LoadConnection(LPSTREAM pStm, int nPersistOffset);
        HRESULT LoadConnections(LPSTREAM pStm, int nPersistOffset);
        HRESULT LoadClock(LPSTREAM pStm, int nPersistOffset);
        HRESULT MakeConnection(ConGen * pcg);
        HRESULT SaveFilterPrivateData
            (LPSTREAM pStm, IPersistStream* pips, BOOL fClearDirty);
        HRESULT SaveFilters(LPSTREAM pStm, BOOL fClearDirty);
        HRESULT WritePinId(LPSTREAM pStm, IPin * ppin);
        HRESULT SaveConnection( LPSTREAM pStm
                              , int nFilter1, IPin *pp1
                              , int nFilter2, IPin *pp2
                              , CMediaType & cmt
                              );
        HRESULT SaveConnections(LPSTREAM pStm);
        HRESULT SaveClock(LPSTREAM pStm);
        int FindPersistOffset();
        HRESULT GetMaxConnectionsSize(int &cbSize);
        HRESULT RemoveDeferredList(void);

#ifdef DO_RUNNINGOBJECTTABLE
        void AddToROT();
#if 0
        //  IExternalConnection
        STDMETHODIMP_(DWORD) AddConnection(DWORD extconn, DWORD Res)
        {
            return 1;
        }
        STDMETHODIMP_(DWORD) ReleaseConnection(DWORD extconn, DWORD Res,
                                               BOOL fLastReleaseCloses)

        {
            return 0;
        }
#endif
#endif // DO_RUNNINGOBJECTTABLE

        //  Create a filter on the application's thread so that
        //  The filter can create windows etc there
        HRESULT CreateFilter(const CLSID *pclsid, IBaseFilter **ppFilter);
        HRESULT CreateFilter(IMoniker *pMoniker, IBaseFilter **ppFilter);
        // !!! replace CreateFilter?
        HRESULT CreateFilterAndNotify(IMoniker *pMoniker, IBaseFilter **ppFilter);

        HRESULT CreateFilterHelper(
            const struct AwmCreateFilterArg *pArg,
            IBaseFilter **ppFilter);

        //  Return code for CreateFilter
        volatile HRESULT m_CreateReturn;

        CAMEvent m_evDone;

    public:
        void OnCreateFilter(const AwmCreateFilterArg *pArg, IBaseFilter **ppFilter);
        void OnDeleteSpareList(WPARAM wParam);

#ifdef THROTTLE
        // IQualityControl stuff
        STDMETHODIMP SetSink(IQualityControl * piqc)
            // This interface is not distributed (leastways, not yet).
            { UNREFERENCED_PARAMETER(piqc); return E_NOTIMPL; }

        // Used to receive notifications, especially from the audio renderer
        STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
#endif // THROTTLE

    public:
        // --- IObjectWithSite methods
        // This interface is here so we can keep track of the context we're
        // living in.  In particular, we use this site object to get an
        // IBindHost interface which we can use to create monikers to help
        // interpret filenames that are passed in to us.
        STDMETHODIMP    SetSite(IUnknown *pUnkSite);

        STDMETHODIMP    GetSite(REFIID riid, void **ppvSite);

        IUnknown *mFG_punkSite;
        CComAggObject<CStatContainer> *mFG_Stats;

        IAMStats *Stats() {
            return &mFG_Stats->m_contained;
        }

    private:

#ifdef THROTTLE
        // Audio-video throttle stuff

        // We make a list of audio and video renderers for quality control purposes.
        // The lists are initially empty (class constructor does that), get filled
        // when the graph is sorted (must happen before Run).
        // Entries are removed when the filter leaves the graph (must happen before
        // graph destruction).
        // We already have a ref-count on every filter, so they can't go away.
        // But we need their IQualityControl interface, and this
        // could be in some separate object, so we hold ref counts.
        /// For Audio Renderers we really want to not only pass information to video
        /// renderers, but to pass it upstream too (there might be a decoder or
        /// source filter that could do something), but experience says that
        /// this deadlocks and this problem will not be solved for Quartz 1.0
        /// Worse - it should really be a list of upstream pins
        /// for each  filter as it could presumably be some sort of mixing renderer.
        /// In that case we really wish that the quality sink stuff was defined per
        /// pin rather than per filter as we are in architectural difficulties that
        /// will not be fixed for Quartz version 1.

        // Note that to destroy the Audio render structure we must
        // 1. Release the IQualityControl
        // 2. delete the structure
        // 3. Remove the list element. (As Virgil never wrote: "Nolite collander")

        typedef struct {
            IBaseFilter * pf;              // no ref-count held
            IQualityControl * piqc;        // ref count held
        } AudioRenderer;

        CGenericList<AudioRenderer> mFG_AudioRenderers;
        CGenericList<IQualityControl> mFG_VideoRenderers;  // ref count held

        HRESULT TellVideoRenderers(Quality q);
        HRESULT FindPinAVType(IPin* pPin, BOOL &bAudio, BOOL &bVideo);
        HRESULT FindRenderers();
        HRESULT ClearRendererLists();
#endif // THROTTLE

    public:
        // IPersist method
        STDMETHODIMP GetClassID(CLSID * pclsid)
            {   CheckPointer(pclsid, E_POINTER);
                *pclsid = CLSID_FilterGraph;
                return NOERROR;
            }

        // Utility
        HRESULT RemoveAllFilters(void);

        //=====================================================================
        // Utility functions
        //=====================================================================

        HRESULT RemoveAllConnections2( IBaseFilter * pFilter );
    private:
        FilGen * RemovePointer(CFilGenList &cfgl, IBaseFilter * pFilter);
        void Log(int id,...);
        WCHAR *LoggingGetDisplayName(WCHAR szDisplayName[MAX_PATH] , IMoniker *pMon);

    public:  // used by FilGen constructor during Load.
        HRESULT AddFilterInternal( IBaseFilter * pFilter, LPCWSTR pName, bool fIntelligent );

        // used by CConGenList::Restore during Load
        HRESULT ConnectDirectInternal(
                    IPin * ppinOut,
                    IPin * ppinIn,
                    const AM_MEDIA_TYPE * pmt
                    );

    private:
        HRESULT RemoveFilterInternal( IBaseFilter * pFilter, DWORD RemoveFlags = 0 );

        HRESULT AddSourceFilterInternal( LPCWSTR lpcwstrFileName
                                       , LPCWSTR lpcwstrFilterName
                                       , IBaseFilter **ppFilter
                                       , BOOL &bGuess
                                       );

        //=====================================================================
        // Filter sorting stuff - see sort.cpp
        //=====================================================================

        void SortList( CFilGenList & cfgl );
        HRESULT NumberNodes(CFilGenList &cfgl, CFilGenList &cfglRoots);
        HRESULT NumberNodesFrom( CFilGenList &cfgAll, FilGen * pfg, int cRank);
        void ClearRanks( CFilGenList &cfgl);
        HRESULT MergeRootNodes(CFilGenList &cfglRoots, CFilGenList &cfgl);
        HRESULT MergeRootsFrom( CFilGenList &cfgAll, CFilGenList &cfglRoots, FilGen * pfg);
        void Merge( CFilGenList &cfgl, FilGen * pfg );

        // sort the filter graph into an order such that downstream nodes are
        // always encountered before upstream nodes.  Subsequent EnumFilters
        // will retrieve them in that order.
        HRESULT UpstreamOrder();

        HRESULT AttemptDeferredConnections();


        //=====================================================================
        // Performance measurement stuff
        //=====================================================================
        // incidents
#ifdef PERF
        int mFG_PerfConnect;
        int mFG_PerfConnectDirect;
        int mFG_NextFilter;
        int mFG_idIntel;
        int mFG_idConnectFail;
#ifdef THROTTLE
        int mFG_idAudioVideoThrottle;
#endif // THROTTLE
#endif

        //=======================================================================
        // INTELLIGENT CONNECTION AND RENDERING - SEE INTEL.CPP
        //=======================================================================

        //------------------------------------------------------------------------
        // To iterate through all candidate filters, allocate a Filter,
        // set the initial State to F_ZERO, set the search fields
        // bInputNeeded..SubType and then call NextFilter repeatedly.
        // If Next returns a filter with State F_INFINITY then you are done
        // If you find a filter you like and want to stop, then call TidyFilter
        // to release enumerators etc.  AddRef the filter you found first.
        //------------------------------------------------------------------------

        BOOL mFG_bAborting;   // We are requested to stop ASAP.

    public:
        typedef enum {F_ZERO, F_LOADED, F_CACHED, F_REGISTRY, F_INFINITY} F_ENUM_STATE;

    private:
        class Filter {
        public:
            F_ENUM_STATE State;

                                         // Next fields not needed for loaded filters
            IMoniker *pMon;
            IEnumMoniker * pEm;          // Registry enumerator
            BOOL bInputNeeded;           // Need at least one input pin
            BOOL bOutputNeeded;          // Need at least one output pin
            BOOL bLoadNew;               // Load a new filter?
            GUID *pTypes;                // Types (major, sub) pairs
            DWORD cTypes;                // Number of types
            LPWSTR Name;                 // Name of filter (debug & logging only)

                                         // Next fields not needed unless filter is loaded
            IBaseFilter * pf;            // The filter (when loaded)
            IEnumFilters * pef;          // filter graph enumerator

            CEnumCachedFilters*          m_pNextCachedFilter;

            Filter();
            ~Filter();

            HRESULT AddToCache( IGraphConfig* pGraphConfig );
            void RemoveFromCache( IGraphConfig* pGraphConfig );

            void ReleaseFilter( void );
        };

        void NextFilter(Filter &F, DWORD dwFlags);
        HRESULT NextFilterHelper(Filter &F);

        //------------------------------------------------------------------------
        // Intelligent Connection hierarchy  - see Intel.cpp
        //------------------------------------------------------------------------

        HRESULT GetAMediaType( IPin * ppin
                             , CLSID & MajorType
                             , CLSID & SubType
                             );
        HRESULT GetMediaTypes(
            IPin * ppin,
            GUID **ppTypes,
            DWORD *pcTypes);
        HRESULT CompleteConnection
            ( IPin * ppinIn, const Filter& F, IPin * pPin, DWORD dwFlags, int iRecurse);
        HRESULT ConnectByFindingPin
            ( IPin * ppinOut, IPin * ppinIn, const AM_MEDIA_TYPE* pmtConnection, const Filter& F, DWORD dwFlags, int iRecurse);
        HRESULT ConnectUsingFilter
            ( IPin * ppinOut, IPin * ppinIn, const AM_MEDIA_TYPE* pmtConnection, Filter& F, DWORD dwFlags, int iRecurse);
        HRESULT ConnectViaIntermediate
            ( IPin * ppinOut, IPin * ppinIn, const AM_MEDIA_TYPE* pmtConnection, DWORD dwFlags, int iRecurse);
        HRESULT ConnectRecursively
            ( IPin * ppinOut, IPin * ppinIn, const AM_MEDIA_TYPE* pmtConnection, DWORD dwFlags, int iRecurse);

        public:
        HRESULT ConnectInternal
            ( IPin * ppinOut, IPin * ppinIn, const AM_MEDIA_TYPE* pmtFirstConnection, DWORD dwFlags );
        private:

        static bool IsValidConnectFlags( DWORD dwConnectFlags );

        //------------------------------------------------------------------------
        // Backout and spares lists for filters - see Intel.cpp
        //
        // A wrinkle on intelligent rendering requires us to sometimes partially
        // succeed in order that we can do something on a machine that has no sound
        // card in it.  Every graph that we build is given a score (actually a
        // two part score) and we keep track of the Best So Far.  If by the end of
        // the rendering we have not succeeded in rendering the graph completely
        // then we build the Best So Far (by this time it is the Best Can Do).
        // This means that we are building a graph from a description made
        // previously, and this is the same problem as loading a pre-canned filter
        // graph.  The following structure therefore handles both the description
        // of a graph for IPersist purposes and the creation of a Best Can Do graph.
        // Actually at the moment the two sections of code are regrettably separate.
        //-----------------------------------------------------------------------

        // BACKOUT is for IStreamBuilder::Backout, other two obvious
        typedef enum { DISCONNECT, REMOVE, BACKOUT} VERB;

        typedef struct{

            VERB Verb;
            union {
               struct{
                  IBaseFilter *pfilter;    // for REMOVE and pre-existers
                  IMoniker    *pMon;
                  CLSID       clsid;      // for spares or BestGraph
                  LPWSTR      Name;       // for BestGraph (new/delete)

                  // This member is true if the filter was removed from the filter cache.
                  bool        fOriginallyInFilterCache;
               } f;
               struct {
                  IPin * ppin;          // for DISCONNECT
                  int nFilter1;         // for BestGraph
                  int nFilter2;         // for BestGraph

                  LPWSTR id1;           // for the BestGraph only. (CoTaskMem)
                  LPWSTR id2;           // for the BestGraph only.
               } c;
               struct {
                  IStreamBuilder * pisb;// for BACKOUT
                  BOOL bFoundByQI;      // TRUE if pisb was fond by QueryInterface
                  IPin * ppin;          //
                  int nFilter;          // for BestGraph only
                  LPWSTR id;            // for the BestGraph only.
               } b;
            } Object;

            bool FilterOriginallyCached( void ) const { return Object.f.fOriginallyInFilterCache; }

        } Action;

        // Handling of StreamBuilders and their refcounts:
        // It follows one of these patterns:
        // 1a. In RenderViaIntermediate:
        //         QueryInterface()                    CoCreateInstance
        //         Render             (fails)          Render
        //         Release                             Release
        // 1b. In RenderViaIntermediate:
        //         QueryInterface()                    CoCreateInstance
        //         Render             (succeeds)       Render
        //         Add to Acts ("backout") list        Add to Acts
        //         set bFoundByQI                      clear bFoundByQI
        //
        //     However created we now have one addreffed pisb on Acts
        //
        // 2.  That can possibly be followed by
        //     In CopySearchState:
        //         Copy representation (filter,pin)    Copy pisb
        //                                             AddRef
        //
        //     If pisb was obtained by CoCreateInstance, it's still live
        //     and addreffed and bFoundByQI is FALSE.  Otherwise we have
        //     released it and copied info as to how to get it back again.
        //
        // 3.  If the whole thing later fails either way we do
        //     In Backout:
        //         Backout                             Backout
        //         Release                             Release
        //         delete from Acts                    delete from Acts
        //
        // 4.  If we decide to build the best-can-do graph
        //     In BuildFromSearchState:
        //         QueryInterface()                    use pisb
        //         Render             (succeeds)       Render
        //         Release                             DO NOT Release
        //
        // 5.  If we kept the built graph and did not back anything out:
        //     In DeleteBackoutList:
        //         Release                             Release
        //         delete                              delete
        //
        // 6.  If we ever built a best-so-far list
        //      In FreeList:
        //                                             Release
        //         delete                              delete
        //
        //     And that gets rid of the ref count

        typedef CGenericList<Action> CActionList;

        // information needed to do Backout
        typedef struct {
            POSITION Pos;            // see CSearchState
            double StreamsToRender;  // see CSearchState
            double StreamsRendered;  // see CSearchState
            int nFilters;            // see CSearchState
        } snapshot;

        class CSearchState {
            public:

                CActionList GraphList;   // None of the filters on this will be
                                         // adreffed.  Some may be on Spares.

                double StreamsToRender;  // fraction of the original we're doing now.
                double StreamsRendered;  // Major part of the score for BestSoFar
                int nFilters;            // Minor part of the score for BestSoFar,
                                         // number of filters added for Render.
                int nInitialFilters;     // Num pre-existing filters from Initialise
                                         // BuildFromSearchState mustn't build these
            public:
                CSearchState()
                : GraphList(NAME("GraphList"))
                {   StreamsToRender = 1.0;
                    StreamsRendered = 0.0;
                    nFilters = 0;
                    nInitialFilters = 0;
                }


                // There is no destructor.
                // Just call FreeList to get rid of the stuff

                static BOOL IsBetter(CSearchState &A, CSearchState &B)
                { return (  A.StreamsRendered>B.StreamsRendered
                         || (  A.StreamsRendered==B.StreamsRendered
                            && A.nFilters < B.nFilters
                         )  );
                }
        };

        HRESULT AddRemoveActionToList( CSearchState* pActionsList, Filter* pFilter );

        void CopySearchState(CSearchState &To, CSearchState &From);
        void FreeList(CSearchState &css);
        IBaseFilter * SearchNumberToIFilter(CActionList &cal, int nFilter);
        int SearchIFilterToNumber(CActionList &cal, IBaseFilter *pf);
        HRESULT InitialiseSearchState(CSearchState &css);

        // Spare filters that we loaded, but they didn't work in that
        // context, so we keep them lying around in case they will work once
        // we've put an extra transform or two in.
        typedef struct{
            IBaseFilter* pfilter;
            CLSID    clsid;
            IMoniker *pMon;
        } Spare;

        typedef CGenericList<Spare> CSpareList;

        void TakeSnapshot(CSearchState &Acts, snapshot &s);

        HRESULT Backout( CSearchState &Acts
                            , CSpareList &Spares, snapshot Snapshot);
        HRESULT DeleteBackoutList( CActionList &Acts);
        HRESULT DeleteSpareList( CSpareList &Spares);
        IBaseFilter * GetFilterFromSpares(IMoniker *pMon , CSpareList &Spares);
        HRESULT GetFilter(IMoniker *pMon, CSpareList &Spares, IBaseFilter **ppf);
        HRESULT DumpSearchState(CSearchState &css);
        HRESULT BuildFromSearchState
            (IPin * pPin, CSearchState &css, CSpareList &Spares);
        static HRESULT FindOutputPins2
        ( IPin* ppinIn, IPin * *appinOut, const UINT nSlots, int &nPinOut,
          bool fAllOutputPins);

        static HRESULT FindOutputPinsHelper
        ( IPin* ppinIn, IPin ***pappinOut, const int nSlots, int &nPinOut,
          bool fAllOutputPins);

        BOOL IsUpstreamOf( IPin * ppinUp, IPin* ppinDown );

        //------------------------------------------------------------------------
        // Intelligent Rendering hierarchy  - see Intel.cpp
        //------------------------------------------------------------------------

        HRESULT CompleteRendering
            ( IBaseFilter *pF, IPin * pPin, int iRecurse
            , CSearchState &Acts, CSpareList &Spares, CSearchState &State);
        HRESULT RenderByFindingPin
            ( IPin * ppinOut, IBaseFilter *pF, int iRecurse
            , CSearchState &Acts, CSpareList &Spares, CSearchState &State);
        HRESULT RenderUsingFilter
            ( IPin * ppinOut, Filter& F, int iRecurse
            , CSearchState &Acts, CSpareList &Spares, CSearchState &State);
        HRESULT RenderViaIntermediate
            ( IPin * ppinOut, int    iRecurse
            , CSearchState &Acts, CSpareList &Spares, CSearchState &State);
        HRESULT RenderRecursively
            ( IPin * ppinOut, int    iRecurse
            , CSearchState &Acts, CSpareList &Spares, CSearchState &State);

        //========================================================================


#ifdef DEBUG
        void DbgDump();
        CLSID DbgExpensiveGetClsid(const Filter &F);
#else
        #define DbgDump()
#endif


        // Constructor is private.  You don't "new" it you CoCreateInstance it.
        CFilterGraph( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr );
        ~CFilterGraph();

    public:
        //========================================================================
        // Access functions to avoid having friends.
        //========================================================================

        int GetVersion() { return mFG_iVersion; }

        // increment version, probably inside lock
        void IncVersion() { ++mFG_iVersion; }

        // notify change in version number, must be outside lock
        void NotifyChange();

        CRefTime GetBaseTime() { return mFG_tBase; }

        CRefTime GetPauseTime() { return mFG_tPausedAt; }

        // Use when changing the start time in pause mode to put the stream time
        // offset back to ensure that the first sample played from the
        // new position is played at run time
        void ResetBaseTime() { mFG_tBase = mFG_tPausedAt; }

        FILTER_STATE GetStateInternal( void );
        REFERENCE_TIME GetStartTimeInternal( void );

        //========================================================================
        // The public methods (IFilterGraph, IGraphBuilder)
        //========================================================================

        static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

        // Stuff to create ourselves on a thread.
        static void InitClass(BOOL, const CLSID *);
        static CUnknown *CreateThreadedInstance(LPUNKNOWN pUnk, HRESULT *phr);

        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

        //--------------------------------------------------------------------------
        // Low level functions
        //--------------------------------------------------------------------------

        // Add a filter to the graph and name it with *pName.
        // The name is allowed to be NULL,
        // If the name is not NULL and not unique, The request will fail.
        // The Filter graph will call the JoinFilterGraph
        // member function of the filter to inform it.
        // This must be called before attempting Connect, ConnectDirect, Render
        // Pause, Run, Stopped etc.

        HRESULT CheckFilterInGraph(IBaseFilter *const pFilter) const;
        HRESULT CheckPinInGraph(IPin *const pPin) const;

        STDMETHODIMP AddFilter
            ( IBaseFilter * pFilter,
              LPCWSTR pName
            );


        // Remove a filter from the graph. The filter graph implementation
        // will inform the filter that it is being removed.

        STDMETHODIMP RemoveFilter
            ( IBaseFilter * pFilter
            );


        // Set *ppEnum to be an enumerator for all filters in the graph.

        STDMETHODIMP EnumFilters
            ( IEnumFilters **ppEnum
            );


        // Set *ppFilter to be the filter which was added with the name *pName
        // Will fail and set *ppFilter to NULL if the name is not in this graph.

        STDMETHODIMP FindFilterByName
            ( LPCWSTR pName,
              IBaseFilter ** ppFilter
            );


        // Connect these two pins directly (i.e. without intervening filters)

        STDMETHODIMP ConnectDirect
            ( IPin * ppinOut,    // the output pin
              IPin * ppinIn,      // the input pin
              const AM_MEDIA_TYPE* pmt
            );


        // On a separate thread (which will not hold any relevant locks)
        // Break the connection that this pin has and reconnect it to
        // the same other pin.

        STDMETHODIMP Reconnect
            ( IPin * ppin        // the pin to disconnect and reconnect
            );

        STDMETHODIMP ReconnectEx
            ( IPin * ppin,       // the pin to disconnect and reconnect
              AM_MEDIA_TYPE const *pmt
            );


        //--------------------------------------------------------------------------
        // intelligent connectivity
        //--------------------------------------------------------------------------

        // Disconnect this pin, if connected.  Successful no-op if not connected.

        STDMETHODIMP Disconnect
            ( IPin * ppin
            );


        // Connect these two pins directly or indirectly, using transform filters
        // if necessary.

        STDMETHODIMP Connect
            ( IPin * ppinOut,    // the output pin
              IPin * ppinIn      // the input pin
            );


        // Connect this output pin directly or indirectly, using transform filters
        // if necessary to something that will render it.

        STDMETHODIMP Render
            ( IPin * ppinOut     // the output pin
            );


        // Build a filter graph that will render this file using this play list
        // If lpwstrPlayList is NULL then it will use the default play list
        // which will typically render the whole file.

        STDMETHODIMP RenderFile
            ( LPCWSTR lpcwstrFile,
              LPCWSTR lpcwstrPlayList
            );

        // Add to the filter graph a source filter for this file.  This would
        // be the same source filter that would be added by calling RenderFile.
        // This call permits you to get then have more control over building
        // the rest of the graph, e.g. AddFilter(<a renderer of your choice>)
        // and then Connect the two.
        STDMETHODIMP AddSourceFilter
            ( LPCWSTR lpcwstrFileName,     // name of file for source
              LPCWSTR lpcwstrFilterName,   // Add the filter as this name
              IBaseFilter **ppFilter       // resulting IBaseFilter* "handle"
                                           // of the filter added.
            );

        // Add a source filter for the given moniker to the graph
        // We first try BindToStorage and if this fails we try
        // BindToObject
        STDMETHODIMP AddSourceFilterForMoniker
            ( IMoniker *pMoniker,          // Moniker to load
              IBindCtx *pCtx,              // Bind context
              LPCWSTR lpcwstrFilterName,   // Add the filter as this name
              IBaseFilter **ppFilter       // resulting IBaseFilter* "handle"
                                           // of the filter added.
            );

        // Attempt a RenderFile without adding any renderers
        STDMETHODIMP RenderEx(
             /* [in] */ IPin *pPinOut,         // Pin to render
             /* [in] */ DWORD dwFlags,         // flags
             /* [in out] */ DWORD * pvContext   // Unused - set to NULL
        );

        // If this call is made then trace information will be written to the
        // file showing the actions taken in attempting to perform an operation.
        STDMETHODIMP SetLogFile(DWORD_PTR hFile)
                {
            if (hFile==0)
                mFG_hfLog = INVALID_HANDLE_VALUE;
            else
                mFG_hfLog = (HANDLE) hFile;
            return NOERROR;
                }


        // Request that the graph builder should return as soon as possible from
        // its current task.
        // Note that it is possible fot the following to occur in the following
        // sequence:
        //     Operation begins; Abort is requested; Operation completes normally.
        // This would be normal whenever the quickest way to finish an operation
        // was to simply continue to the end.
        STDMETHODIMP Abort();

        // Return S_OK if the curent operation is to continue,
        // return S_FALSE if the current operation is to be aborted.
        // This method can be called as a callback from a filter which is doing
        // some operation at the request of the graph.
        STDMETHODIMP ShouldOperationContinue();


        //--------------------------------------------------------------------------
        // Whole graph functions
        //--------------------------------------------------------------------------

        // Once a graph is built, it can behave as a (composite) filter.
        // To control this filter, QueryInterface for IMediaFilter.

        STDMETHODIMP SetDefaultSyncSource(void);

        //--------------------------------------------------------------------------
        // Methods being overridden from CBaseFilter
        //--------------------------------------------------------------------------

        STDMETHODIMP Stop();
        STDMETHODIMP Pause();

        // override this to handle async state change completion
        STDMETHODIMP GetState(DWORD dwTimeout, FILTER_STATE * pState);

        // Set all the filters in the graph to Run from their current position.
        //
        // tStart is the base time i.e. (presentation time - stream time) which is
        // the reference time for the zeroth sample to be rendered.
        //
        // The filter graph remembers the base time.  Supplying a base time of
        // zero means "continue with the one you knew".
        //
        // e.g. at reference ("wall clock") time Tr we wish to start running
        // from a point in the Ts after the start.  In that case we should
        // seek to the point Ts and Pause then Run(Ts-Ts).
        STDMETHODIMP Run(REFERENCE_TIME tStart);

        int GetPinCount(void) { return 0;};
        CBasePin *GetPin(int n) {UNREFERENCED_PARAMETER(n);return NULL;};

        //  Get tStart
        STDMETHODIMP SetSyncSource( IReferenceClock * pirc );
        STDMETHODIMP GetSyncSource( IReferenceClock ** pirc );

        STDMETHODIMP FindPin(LPCWSTR Id, IPin **ppPin)
            {UNREFERENCED_PARAMETER(Id); *ppPin = NULL; return E_NOTIMPL;}

        // IPin method
        // STDMETHODIMP QueryId(LPWSTR *Id)
        //    { Id = NULL; return E_NOTIMPL;}

        //
        // --- IGraphVersion methods ---
        //
        // return the version of the graph so that clients know
        // that they don't need to re-enumerate
        STDMETHODIMP QueryVersion(LONG * pVersion)
        {
            CheckPointer(pVersion, E_POINTER);
            *pVersion = (LONG) mFG_iVersion;
            return S_OK;
        };

        // --- IAMOpenProgress ---
        STDMETHODIMP QueryProgress(LONGLONG* pllTotal, LONGLONG* pllCurrent);
    STDMETHODIMP AbortOperation();

#ifdef DO_RUNNINGOBJECTTABLE
    // Registration in the running object table
    DWORD m_dwObjectRegistration;
#endif

    private:
#ifdef DEBUG
        //==========================================================================
        // Internal functions for testing only
        //==========================================================================

        BOOL CheckList( CFilGenList &cfgl );
        void RandomList( CFilGenList &cfgl );
        void RandomRank( CFilGenList &cfgl );
#endif // DEBUG


    // ========================================================================
    // internal helper: try loading a .grf file
    // ========================================================================
        STDMETHODIMP RenderFileTryStg
            ( LPCWSTR lpcwstrFile);

    //==========================================================================
    // IAMGraphStreams interface
    //==========================================================================
        STDMETHODIMP FindUpstreamInterface(
            IPin   *pPin,
            REFIID riid,
            void   **ppvInterface,
            DWORD  dwFlags );

        STDMETHODIMP SyncUsingStreamOffset( BOOL bUseStreamOffset );
        STDMETHODIMP SetMaxGraphLatency( REFERENCE_TIME rtMaxGraphLatency );

        HRESULT  SetMaxGraphLatencyOnPushSources( );
        HRESULT  BuildPushSourceList(PushSourceList & lstPushSource, BOOL bConnected, BOOL bGetClock);
        REFERENCE_TIME GetMaxStreamLatency(PushSourceList & lstPushSource);
        void     DeletePushSourceList(PushSourceList & lstPushSource);

    //==========================================================================
    // Plug-in distributor management
    //==========================================================================
        // this object manages plug-in distributors. See distrib.h for a
        // description.
        // If asked for an interface we don't support directly, such as
        // IBasicAudio, we ask this class to find a distributor that will
        // support it. The distributor talks to the filters in the graph
        // to do this. We also use the run, pause, stop and setsyncsource
        // methods to pass on state and clock changes to these distributors.
        CDistributorManager * mFG_pDistributor;

    // open progress notification
        // this is used in QueryProgress to ask the source filter for
        // progress info *during* a renderfile. To provide threadsafe
        // access to this without deadlocking we have a dedicated
        // critsec that is held only when accessing this member.
        CCritSec mFG_csOpenProgress;
        CGenericList<IAMOpenProgress> mFG_listOpenProgress;

    // cached BindCtx for BindToObject.
    LPBC m_lpBC;

    // determine the offset that IAMPushSource filters should use
    HRESULT SetStreamOffset( void );

    // Determine if adding renderers is allowed
    bool mFG_bNoNewRenderers;

    // Which object are we using to step
    // If != NULL we are stepping
    CComPtr<IUnknown> m_pVideoFrameSteppingObject;

    CComPtr<IFrameSkipResultCallback> m_pFSRCB;

    FRAME_STEP_TYPE m_fstCurrentOperation;

    // Support IMarshal
    CComPtr<IUnknown> m_pMarshaler;

    // Dynamic graph stuff
    CGraphConfig m_Config;
    CFilterChain* m_pFilterChain;

    protected:

    STDMETHODIMP RemoveFilterEx( IBaseFilter * pFilter, DWORD Flags = 0 );


public:
    HRESULT IsRenderer( IBaseFilter* pFilter );
    HRESULT UpdateEC_COMPLETEState( IBaseFilter* pRenderer, FILTER_STATE fsFilter );

};  // CFilterGraph


//  Helper
bool RenderPinByDefault(IPin *pPin);


#ifdef DEBUG
class CTestFilterGraph : public ITestFilterGraph, public CUnknown
{
    public:
        DECLARE_IUNKNOWN
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
        CFilterGraph * m_pCFG;
        CTestFilterGraph( TCHAR *pName, CFilterGraph * pCFG, HRESULT *phr );

        STDMETHODIMP TestRandom();
        STDMETHODIMP TestSortList();
        STDMETHODIMP TestUpstreamOrder();
        int  Random(int Range);
        // STDMETHODIMP TestTotallyRemove(void);

};  // CTestFilterGraph
#endif // DEBUG





//==========================================================================
//==========================================================================
// CEnumFilters class.
// This enumerates filters in Upstream order.
// If the filter graph is updated during the enumeration the enumeration will
// fail.  Reset or get a new enumerator to fix it.
//==========================================================================
//==========================================================================

class CEnumFilters : public IEnumFilters,  // The interface we support
                     public CUnknown,      // A non delegating IUnknown
                     public CCritSec       // Provides object locking
{
    private:

        // It's possible that the list that we are traversing may change underneath us.
        // In that case we will fail the enumeration.
        // To do this a FilterGraph has a version number which is incremented
        // whenever a filter is added or removed.  If this changes then the
        // enumeration is sick and we fail it.  Reset or getting a new enumerator
        // will fix it.

        int mEF_iVersion;          // The version that we are enumerating.

        POSITION mEF_Pos;          // Cursor on mEF_pFilterGraph->mFG_FilGenList

        CFilterGraph * const mEF_pFilterGraph;   // The filter graph which owns us

    public:

        // Normal constructor that creates an enumerator set at the start
        CEnumFilters
            ( CFilterGraph *pFilterGraph
            );

    private:
        // Private constructor for use by clone
        CEnumFilters
            ( CFilterGraph *pFilterGraph,
              POSITION Pos,
              int iVersion
            );

    public:
        ~CEnumFilters();

        DECLARE_IUNKNOWN

        // Note that changes to the filter graph
        STDMETHODIMP Next
            ( ULONG cFilters,           // place this many filters...
              IBaseFilter ** ppFilter,  // ...in this array of IBaseFilter*
              ULONG * pcFetched         // actual count passed returned here
            );


        STDMETHODIMP Skip(ULONG cFilters);


        // Reset the enumerator to start again at the beginning.
        // Includes recovery from failure due to changing filter graph.
        STDMETHODIMP Reset(void);


        STDMETHODIMP Clone(IEnumFilters **ppEnum);


        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
};

BOOL ClsidFromText( CLSID & clsid, LPTSTR szClsid);

inline FILTER_STATE CFilterGraph::GetStateInternal( void )
{
    // The filter graph can only be in three states: stopped, running and paused.
    // See the Direct Show SDK documentation for FILTER_STATE for more information.
    ASSERT( (State_Stopped == m_State) ||
            (State_Paused == m_State) ||
            (State_Running == m_State) );

    return m_State;
}

#ifdef DEBUG
inline bool CFilterGraph::IsValidInternalFilterFlags( DWORD dwFlags )
{
    const DWORD VALID_FLAGS_MASK = FILGEN_ADDED_MANUALLY |
                                   FILGEN_ADDED_RUNNING |
                                   FILGEN_FILTER_REMOVEABLE;

    return ValidateFlags( VALID_FLAGS_MASK, dwFlags );
}
#endif // DEBUG

inline bool CFilterGraph::BlockAfterFrameSkip()
{
    // The caller must hold the filter lock because this function
    // uses m_fstCurrentOperation.
    ASSERT(CritCheckIn(&m_CritSec));

    return (FST_BLOCK_AFTER_SKIP == m_fstCurrentOperation);
}

inline bool CFilterGraph::DontBlockAfterFrameSkip()
{
    // The caller must hold the filter lock because this function
    // uses m_fstCurrentOperation.
    ASSERT(CritCheckIn(&m_CritSec));

    return (FST_DONT_BLOCK_AFTER_SKIP == m_fstCurrentOperation);
}

inline IFrameSkipResultCallback* CFilterGraph::GetIFrameSkipResultCallbackObject()
{
    // The caller must hold the filter lock because this function
    // uses m_pFSRCB and m_fstCurrentOperation.
    ASSERT(CritCheckIn(&m_CritSec));

    // m_pFSRCB only points to a valid object if someone calls
    // SkipFrames() to skip several frames.
    ASSERT(FST_DONT_BLOCK_AFTER_SKIP == m_fstCurrentOperation);

    if( m_pFSRCB ) { // m_pFSRCB != NULL
        m_pFSRCB->AddRef();
    }    

    return m_pFSRCB;
}

inline bool CFilterGraph::FrameSkippingOperationInProgress()
{
    return DontBlockAfterFrameSkip() && m_pFSRCB; // m_pFSRCB != NULL
}

#endif // __DefFilGraph
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\filgtest.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

// These are functions which have to be part of CFilterGraph because

// they (well, some of them) use a private type of CFilterGraph as
// parameters.  I wanted them to be part of a friend class, but it
// wouldn't compile for those that use private types as parameters.
// So some of them have to be in the main class - but I still
// introduce a friend for the public ones - because these can't have
// private parameter types and otherwise they'd have to be in the idl too.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

// #include <windows.h>    already included in streams.h
#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)

#ifdef DEBUG

#include "distrib.h"
#include "rlist.h"
#include "filgraph.h"


CTestFilterGraph::CTestFilterGraph( TCHAR *pName, CFilterGraph * pCFG, HRESULT *phr )
: CUnknown(pName, pCFG->GetOwner())
{
     m_pCFG = pCFG;
} // constructor


//========================================================================
// Check that Random is behaving OK.  Only checks for errors
// This is NOT a full scale randomness test!
//========================================================================
STDMETHODIMP CTestFilterGraph::TestRandom(  )
{
    DbgLog((LOG_TRACE, 2, TEXT("Test Me:%d"), m_pCFG->mFG_iSortVersion));


    int i;
    for (i=0; i<100; ++i) {
        if (Random(0)!=0) {
            DbgLog((LOG_ERROR, 1, TEXT("Random(0) !=0" )));
            return E_FAIL;
        }
    }

    int Count;
    Count = 0;
    for (i=0; i<100; ++i) {
        if (Random(1)==0) {
            ++Count;
        }
    }

    if (Count<20) {
        DbgLog((LOG_ERROR, 1, TEXT("Random(1) not 1 often enough")));
        return E_FAIL;
    }
    if (Count>80) {
        DbgLog((LOG_ERROR, 1, TEXT("Random(1) == 1 too often" )));
        return E_FAIL;
    }

    Count = 0;
    for (i=0; i<100; ++i) {
        Count +=Random(100);
    }

    if (Count < 40*100 || Count > 60*100) {
        DbgLog((LOG_ERROR, 1, TEXT("Random(100) implausible total" )));
        return E_FAIL;
    }

    return NOERROR;

} // TestRandom


//=====================================================================
//
// CTestFilterGraph::NonDelegatingQueryInterface
//
//=====================================================================

STDMETHODIMP CTestFilterGraph::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_ITestFilterGraph) {
        return GetInterface((ITestFilterGraph *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
} // CTestFilterGraph::NonDelegatingQueryInterface






// set *pfg to each FilGen in cfgl in turn
// use Pos as a name of a temp
#define TRAVERSEFGLIST(cfgl, Pos, pfg) {                                       \
        POSITION Pos = cfgl.GetHeadPosition();                                 \
        while(Pos!=NULL) {                                                     \
            /* Retrieve the current IBaseFilter, side-effect Pos on to the next */ \
            CFilterGraph::FilGen * pfg = cfgl.GetNext(Pos);                                  \
            {


#define ENDTRAVERSELIST    \
            }              \
        }                  \
    }


//=================================================================
// return a random integer in the range 0..Range
// Range must be in the range 0..2**31-1
//
// The only reason for making this a member of CTestFilterGraph is to
// reduce the chance of name conflict as Random is rather common
//=================================================================
int CTestFilterGraph::Random(int Range)
{
    // These really must be DWORDs - the magic only works for 32 bit
    const DWORD Seed = 1664525;              // seed for random (Knuth)
    static DWORD Base = Seed * (GetTickCount() | 1);  // Really random!
                // ORing 1 ensures that we cannot arrive at sero and stick there

    Base = Base*Seed;

    // Base is a good 32 bit random integer - but we want it scaled down to
    // 0..Range.  We will actually scale the last 31 bits of it.
    // which sidesteps problems of negative numbers.
    // MulDiv rounds - it doesn't truncate.
    int Result = MulDiv( (Base&0x7FFFFFFF), (Range), 0x7FFFFFFF);

    return Result;
} // Random



//=================================================================
// Check that the ranks are in non-descending order
//
// Note that a friend class cannot access a private typedef as a parameter,
// so in order to access CFilGenList this has to be a member of CFilterGraph
// Eugh!
//=================================================================
BOOL CFilterGraph::CheckList( CFilterGraph::CFilGenList &cfgl )
{
    int LastRankSeen = 0;
    // set *pfg to each FilGen in mFG_FilGenList in turn,
    // use Pos as the name of a temp.
    TRAVERSEFGLIST(cfgl, Pos, pfg)
        if (pfg->Rank < LastRankSeen) return FALSE;
        if (pfg->Rank > LastRankSeen) LastRankSeen = pfg->Rank;
    ENDTRAVERSELIST

    return TRUE;
} // CheckList


//=================================================================
// Set the ranks to something random
// Each Rank is randomly chosen from 0..cfgl.GetCount()
//=================================================================
void CFilterGraph::RandomRank( CFilterGraph::CFilGenList &cfgl )
{

    int Count = cfgl.GetCount();
    // set *pfg to each FilGen in mFG_FilGenList in turn,
    // use Pos as the name of a temp.
    TRAVERSEFGLIST(cfgl, Pos, pfg)
        pfg->Rank = mFG_Test->Random(Count);
    ENDTRAVERSELIST

} // RandomRank



//=================================================================
// Put the list into a random order
// Each Rank is randomly chosen from 0..cfgl.GetCount()
//=================================================================
void CFilterGraph::RandomList( CFilterGraph::CFilGenList &cfgl )
{

    CFilGenList cfglNew(NAME("Random ordered filter list"), this);

    // Make a series of traverses through the list picking a random member out
    // and adding it to the tail of the new list.

    while( cfgl.GetCount() >0 ) {
        int R = mFG_Test->Random(cfgl.GetCount() -1);
        int i;

        i = 0;
        /* Traverse the list up to the Rth member (counting from 0) */
        POSITION Pos = cfgl.GetHeadPosition();
        while(Pos!=NULL) {
            POSITION OldPos = Pos;
            cfgl.GetNext(Pos);

            ++i;
            if (i>R) {
               cfglNew.AddTail( cfgl.Remove(OldPos) );
               break;
            }
        }
    }

    // Now cfglNew is full and cfgl is empty - add it back to cfgl
    cfgl.AddTail(&cfglNew);


} // RandomList



//================================================================
// Test the SortList function.  return TRUE iff it works
//================================================================
STDMETHODIMP CTestFilterGraph::TestSortList( void )
{
    CFilterGraph * foo = NULL;
    CFilterGraph::CFilGenList cfgl(NAME("Test sort list"), foo);
    CFilterGraph::FilGen * pfg;

    // Sort a list of length zero
    m_pCFG->SortList(cfgl);
    if (cfgl.GetCount() != 0) return E_FAIL;  // about all you can do with an empty list

    // Create a list of length 1 and sort it
    m_pCFG->SortList(cfgl);

    pfg = new CFilterGraph::FilGen(NULL, false);
    pfg->Rank = 0;
    cfgl.AddTail(pfg);
    m_pCFG->SortList(cfgl);
    if (cfgl.GetCount() != 1) return E_FAIL;  // about all you can do with a unit list

    // Create a list of length 2 in order, sort it and check it
    pfg = new CFilterGraph::FilGen(NULL, false);
    cfgl.AddTail(pfg);
    pfg->Rank = 1;
    m_pCFG->SortList(cfgl);
    if (!m_pCFG->CheckList(cfgl)) return E_FAIL;

    // Reverse the order, sort it and check it
    int Rank = 2;
    TRAVERSEFGLIST(cfgl, Pos, pfg)
       pfg->Rank = Rank;
       -- Rank;
    ENDTRAVERSELIST
    m_pCFG->SortList(cfgl);
    if (!m_pCFG->CheckList(cfgl)) return E_FAIL;


    // Create a list of length 5, randomise it and sort it several times

    int i;
    for (i=0; i<3; ++i) {
       pfg = new CFilterGraph::FilGen(NULL, false);
       cfgl.AddTail(pfg);
    }

    for (i=0; i<10; ++i) {
       m_pCFG->RandomRank(cfgl);          // assign random ranks
       m_pCFG->SortList(cfgl);
       m_pCFG->RandomList(cfgl);          // now shuffle them and try again (exercises RandomList)
       m_pCFG->SortList(cfgl);

       if (!m_pCFG->CheckList(cfgl)) return E_FAIL;
    }

    // Clean up
    TRAVERSEFGLIST(cfgl, Pos, pfg)
       delete pfg;
    ENDTRAVERSELIST

    return NOERROR;

} // TestSortList



//==================================================================
// Sort the nodes into upstream order and check that the sorting is good
// Need to call this with several differently connected filter graphs
// to get any sort of valid test.
//==================================================================
STDMETHODIMP CTestFilterGraph::TestUpstreamOrder()
{
    int i;
    for (i=0; i<=10; ++i) {
        m_pCFG->IncVersion();
        m_pCFG->RandomList(m_pCFG->mFG_FilGenList);

        m_pCFG->UpstreamOrder();

        if (!m_pCFG->CheckList(m_pCFG->mFG_FilGenList)) return E_FAIL;
    }

    return NOERROR;
} // TestUpstreamOrder


#if 0
    //==================================================================
    // Pick on the first filter in the graph and TotallyRemove it
    // ??? How does this TEST it - just exercises it!
    //==================================================================
    STDMETHODIMP CTestFilterGraph::TestTotallyRemove(void)
    {

        POSITION Pos = m_pCFG->mFG_FilGenList.GetHeadPosition();
        /* Retrieve the current IBaseFilter, side-effect Pos on to the next */
        CFilterGraph::FilGen * pfg = m_pCFG->mFG_FilGenList.GetNext(Pos);
        HRESULT hr;
        hr = m_pCFG->TotallyRemove(pfg->pFilter);
        return hr;

    } // TestTotallyRemove
#endif //0

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\fgenum.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// fgenum.h
//

// A set of wrappers for IEnumXXX interfaces.

// Long term these could (should?) replace all the TRAVERSEXXX macros

// In general these are all constructed with the object supplying
// the IEnumXXX interface as a parameter to the constructor.
// You then call the object repeatedly (using operator()) to
// get each item in turn. When the enumerator is finished
// NULL will be returned. Taking CEnumPin as an example:
//
//   CEnumPin Next(pFilter);
//   IPin *pPin;
//
//   while ((BOOL) ( pPin = Next() )) {
//
//      //... Use pPin
//
//      pPin->Release();
//   }


#include <atlbase.h>


//
// CEnumPin
//
// wrapper for IEnumPins
// Can enumerate all pins, or just one direction (input or output)
class CEnumPin {

public:

    enum DirType {PINDIR_INPUT, PINDIR_OUTPUT, All};

    CEnumPin(IBaseFilter *pFilter, DirType Type = All, BOOL bDefaultRenderOnly = FALSE);
    ~CEnumPin();

    // the returned interface is addref'd
    IPin * operator() (void);

private:

    PIN_DIRECTION m_EnumDir;
    DirType       m_Type;
    BOOL          m_bDefaultRenderOnly;

    IEnumPins	 *m_pEnum;
};

//  Enumerate pins connected to a pin
class CEnumConnectedPins
{
public:
    CEnumConnectedPins(IPin *pPin, HRESULT *phr);
    ~CEnumConnectedPins();

    // the returned interface is addref'd
    IPin * operator() (void);

private:
    CComPtr<IEnumPins> m_pEnum;
    IPin             **m_ppPins;
    DWORD              m_dwPins;
    DWORD              m_dwCurrent;
    int                m_pindir;
};


//
// CEnumElements
//
// Wrapper for IEnumSTATSTG
// returns 'new' allocated STATSTG *'s which need the
// pwcsName element CoTaskMemFree'ing..,
class CEnumElements {
public:

    CEnumElements(IStorage *pStorage);

    ~CEnumElements() { m_pEnum->Release(); }

    STATSTG *operator() (void);

private:

    IEnumSTATSTG *m_pEnum;
};

class CEnumCachedFilters
{
public:
    CEnumCachedFilters( IGraphConfig* pFilterCache, HRESULT* phr );
    ~CEnumCachedFilters();

    IBaseFilter* operator()( void );

private:
    HRESULT TakeFilterCacheStateSnapShot( IGraphConfig* pFilterCache );
    void DestoryCachedFiltersEnum( void );

    POSITION m_posCurrentFilter;

    CGenericList<IBaseFilter>* m_pCachedFiltersList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\filcache.cpp ===
// Copyright (c) Microsoft Corporation 1996-1999. All Rights Reserved

//
//    filcache.cpp
//
//    Implementation of filter graph cache
//

#include <streams.h>
#include "FilCache.h"
#include "EFCache.h"
#include "MsgMutex.h"
#include "fgenum.h"

/******************************************************************************
    CFilterCache Interface
******************************************************************************/
CFilterCache::CFilterCache( CMsgMutex* pcsFilterCache, HRESULT* phr ) :
    m_pcsFilterCache(NULL),
    m_pCachedFilterList(NULL),
    m_ulFilterCacheVersion(0)
{
    // See the documentation for CGenericList::CGenericList() for more
    // information on these constants.
    const int nDEAFULT_LIST_SIZE = 10;

    m_pCachedFilterList = new CGenericList<IBaseFilter>( NAME("Filter Cache List"),
                                                         nDEAFULT_LIST_SIZE );

    if( NULL == m_pCachedFilterList )
    {
        *phr = E_OUTOFMEMORY;
        return;
    }

    m_pcsFilterCache = pcsFilterCache;
}

CFilterCache::~CFilterCache()
{
#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    if( NULL != m_pCachedFilterList )
    {
        IBaseFilter* pCurrentFilter;

        do
        {
            pCurrentFilter = m_pCachedFilterList->RemoveHead();

            // CGenericList::RemoveHead() returns NULL if the list is empty.
            if( NULL != pCurrentFilter )
            {
                pCurrentFilter->Release();
            }
        }
        while( NULL != pCurrentFilter );
    }

    delete m_pCachedFilterList;
}

bool CFilterCache::IsFilterInCache( IBaseFilter* pFilter )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    // It makes no sense to look for a NULL filter.
    ASSERT( NULL != pFilter );

    ValidateReadPtr( pFilter, sizeof(IBaseFilter*) );

    return FindCachedFilter( pFilter, NULL );
}

HRESULT CFilterCache::AddFilterToCache( IBaseFilter* pFilter )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    HRESULT hr = AddFilterToCacheInternal( pFilter );

#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    return hr;
}

HRESULT CFilterCache::RemoveFilterFromCache( IBaseFilter* pFilter )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    HRESULT hr = RemoveFilterFromCacheInternal( pFilter );

#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    return hr;
}

HRESULT CFilterCache::EnumCacheFilters( IEnumFilters** ppCurrentCachedFilters )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    HRESULT hr = EnumCacheFiltersInternal( ppCurrentCachedFilters );

#ifdef DEBUG
    // Make sure the filter cache is in a valid state.
    AssertValid();
#endif // DEBUG

    return hr;
}

HRESULT CFilterCache::AddFilterToCacheInternal( IBaseFilter* pFilter )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    // Make sure the object was successfully created.
    ASSERT( NULL != m_pCachedFilterList );

    ValidateReadPtr( pFilter, sizeof(IBaseFilter*) );

    if( NULL == pFilter )
    {
        return E_POINTER;
    }

    if( IsFilterInCache( pFilter ) )
    {
        return S_FALSE; // TBD - Define VFW_S_FILTER_ALREADY_CACHED
    }

    //  RobinSp - if it's not in a filter graph do we really need to check
    //  if any pins are connected?
    //  Also note that E_NOTIMPL is probably OK for EnumPins
    HRESULT hr = AreAllPinsUnconnected( pFilter );
    if( FAILED( hr ) )
    {
        return hr;
    }
    else if( S_FALSE == hr )
    {
        return E_FAIL; // TBD - Define VFW_E_CONNECTED
    }

    FILTER_STATE fsCurrent;

    //  Check if the filter is stopped - we don't want to wait here
    //  so set a 0 timeout.

    hr = pFilter->GetState( 0, &fsCurrent );
    if( FAILED( hr ) )
    {
        return hr;
    }

    POSITION posNewFilter = m_pCachedFilterList->AddHead( pFilter );

    // CGenericList::AddHead() returns NULL if an error occurs.
    if( NULL == posNewFilter )
    {
        return E_FAIL;
    }

    FILTER_INFO fiFilter;

    // Check to see if the filter was added to a filter graph.
    hr = pFilter->QueryFilterInfo( &fiFilter );
    if( FAILED( hr ) )
    {
        m_pCachedFilterList->Remove( posNewFilter );
        return hr;
    }

    bool bFilterRemovedFromGraph = false;

    // Make sure the filter is not released because we remove it from the filter graph.
    pFilter->AddRef();

    // Check to see if the filter is already in the filter graph.
    if( NULL != fiFilter.pGraph )
    {
        hr = fiFilter.pGraph->RemoveFilter( pFilter );
        if( FAILED( hr ) )
        {
            m_pCachedFilterList->Remove( posNewFilter );
            QueryFilterInfoReleaseGraph( fiFilter );
            pFilter->Release();
            return hr;
        }
        bFilterRemovedFromGraph = true;
    }

    if( State_Stopped != fsCurrent )
    {
        hr = pFilter->Stop();
        if( FAILED( hr ) )
        {
            m_pCachedFilterList->Remove( posNewFilter );
            if( bFilterRemovedFromGraph )
            {
                HRESULT hrAddFilter = fiFilter.pGraph->AddFilter( pFilter, fiFilter.achName );

                // If IFilterGraph::AddFilter() fails, then pFilter will not be a
                // member of the filter graph it was originally in.
                ASSERT( SUCCEEDED( hrAddFilter ) );
            }
            QueryFilterInfoReleaseGraph( fiFilter );
            pFilter->Release();
            return hr;
        }
    }

    QueryFilterInfoReleaseGraph( fiFilter );

    m_ulFilterCacheVersion++;

    return S_OK;
}

HRESULT CFilterCache::RemoveFilterFromCacheInternal( IBaseFilter* pFilter )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    // Make sure the object was successfully created.
    ASSERT( NULL != m_pCachedFilterList );

    // The filter cannot be removed from the cache because the
    // cahce is empty.
    ASSERT( m_pCachedFilterList->GetCount() > 0 );

    ValidateReadPtr( pFilter, sizeof(IBaseFilter*) );

    if( NULL == pFilter )
    {
        return E_POINTER;
    }

    POSITION posFilter;

    if( !FindCachedFilter( pFilter, &posFilter ) )
    {
        // The filter is not stored in the cache.  Therefore,
        // it can not be removed.
        ASSERT( false );
        return S_FALSE;
    }

    m_pCachedFilterList->Remove( posFilter );

    m_ulFilterCacheVersion++;

    return S_OK;
}

HRESULT CFilterCache::EnumCacheFiltersInternal( IEnumFilters** ppCurrentCachedFilters )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    // Make sure the object was successfully created.
    ASSERT( NULL != m_pCachedFilterList );

    ValidateWritePtr( ppCurrentCachedFilters, sizeof(IEnumFilters*) );
    *ppCurrentCachedFilters = NULL;

    CEnumCachedFilter* pNewFilterCacheEnum;

    if( NULL == ppCurrentCachedFilters )
    {
        return E_POINTER;
    }

    pNewFilterCacheEnum = new CEnumCachedFilter( this, m_pcsFilterCache );
    if( NULL == pNewFilterCacheEnum )
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = ::GetInterface( pNewFilterCacheEnum, (void**)ppCurrentCachedFilters );

    ASSERT(SUCCEEDED(hr));

    return S_OK;
}

ULONG CFilterCache::GetCurrentVersion( void ) const
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    return m_ulFilterCacheVersion;
}

POSITION CFilterCache::GetFirstPosition( void )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    return m_pCachedFilterList->GetHeadPosition();
}

bool CFilterCache::GetNextFilterAndFilterPosition
    (
    IBaseFilter** ppNextFilter,
    POSITION posCurrent,
    POSITION* pposNext
    )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    POSITION posCurrentThenNext;
    IBaseFilter* pNextFilter;

    if( NULL == posCurrent )
    {
        return false;
    }

    posCurrentThenNext = posCurrent;
    pNextFilter = m_pCachedFilterList->GetNext( posCurrentThenNext /* IN and OUT */ );

    *ppNextFilter = pNextFilter;
    *pposNext = posCurrentThenNext;

    return true;
}

bool CFilterCache::GetNextFilterPosition( POSITION posCurrent, POSITION* pposNext )
{
    CAutoMsgMutex alFilterCache( m_pcsFilterCache );

    IBaseFilter* pUnusedFilter;

    return GetNextFilterAndFilterPosition( &pUnusedFilter, posCurrent, pposNext );
}

bool CFilterCache::FindCachedFilter( IBaseFilter* pFilter, POSITION* pPosOfFilter )
{
    // It makes no sense to look for a NULL filter.
    ASSERT( NULL != pFilter );

    if( NULL != pPosOfFilter )
    {
        *pPosOfFilter = NULL;
    }

    POSITION posFilter;
    POSITION posCurrentFilter;
    IBaseFilter* pCurrentFilter;

    posFilter = m_pCachedFilterList->GetHeadPosition();

    while( NULL != posFilter )
    {
        posCurrentFilter = posFilter;

        // CGenericList::GetNext() moves posFilter to the next object's
        // position.
        pCurrentFilter = m_pCachedFilterList->GetNext( posFilter );

        if( ::IsEqualObject( pCurrentFilter, pFilter ) )
        {
            if( NULL != pPosOfFilter )
            {
                *pPosOfFilter = posCurrentFilter;
            }
            return true;
        }
    }

    return false;
}

//
//  Check if all pins are unconnected
//
//  Returns:
//    S_FALSE if any pin is connected
//    S_OK    otherwise
//
HRESULT CFilterCache::AreAllPinsUnconnected( IBaseFilter* pFilter )
{
#if 1
    bool bConnected = false;
    CEnumPin Next(pFilter);
    IPin *pCurrentPin;
    for (; ; ) {
        pCurrentPin = Next();
        if (NULL == pCurrentPin) {
            break;
        }
        IPin *pConnected;
        HRESULT hr = pCurrentPin->ConnectedTo(&pConnected);
        if (SUCCEEDED(hr)) {
            bConnected = true;
            pConnected->Release();
            break;
        }
        pCurrentPin->Release();
    }
    return bConnected ? S_FALSE : S_OK;
#else
    IPin* pCurrentPin;
    IPin* pConnectedPin;
    HRESULT hrConnectedTo;
    IEnumPins* pFiltersPins;

    HRESULT hr = pFilter->EnumPins( &pFiltersPins );
    if( FAILED( hr ) )
    {
        return hr;
    }

    do
    {
        hr = pFiltersPins->Next( 1, &pCurrentPin, NULL );
        if( FAILED( hr ) )
        {
            pFiltersPins->Release();
            return hr;
        }

        // IEnumPins::Next() returns S_OK if it can get the next pin
        // from the enumeration.
        if( S_OK == hr )
        {
            hrConnectedTo = pCurrentPin->ConnectedTo( &pConnectedPin );
            if( FAILED( hrConnectedTo ) )
            {
                // Ignore the failure code.  IPin::ConnectedTo()'s documentation
                // states that pConnectedPin MUST be set to NULL if the pin is
                // not connected.
            }

            pCurrentPin->Release();
            pCurrentPin = NULL;

            // IPin::ConnectedTo() sets *ppPin to NULL if the pin in unconnected.
            if( NULL != pConnectedPin )
            {
                pFiltersPins->Release();
                pConnectedPin->Release();
                return S_FALSE;
            }
        }
    }
    while( S_OK == hr );

    pFiltersPins->Release();

    return S_OK;
#endif
}

#ifdef DEBUG
void CFilterCache::AssertValid( void )
{
    HRESULT hr;
    POSITION posCurrent;
    FILTER_STATE fsCurrentState;
    IBaseFilter* pCurrentFilter;
    FILTER_INFO fiCurrentFilterInfo;

    posCurrent = m_pCachedFilterList->GetHeadPosition();

    while( NULL != posCurrent )
    {
        pCurrentFilter = m_pCachedFilterList->GetNext( posCurrent );

        // Cached filters should NEVER be in the filter graph.
        hr = pCurrentFilter->QueryFilterInfo( &fiCurrentFilterInfo );
        if( SUCCEEDED( hr ) )
        {
            // A cached filter should NEVER be in any filter graph.
            ASSERT( NULL == fiCurrentFilterInfo.pGraph );

            QueryFilterInfoReleaseGraph( fiCurrentFilterInfo );
        }

        // While this is not a critical failure, it's cause should be investigated.
        ASSERT( SUCCEEDED( hr ) );

        // Cached filters should never be connected to any other filters.
        ASSERT( S_OK == AreAllPinsUnconnected( pCurrentFilter ) );

        hr = pCurrentFilter->GetState( INFINITE, &fsCurrentState );

        // Cached filter should never be in an intermediate state.  In addition,
        // they should be able to tell the cache what its current state is.
        ASSERT( SUCCEEDED( hr ) && (hr != VFW_S_STATE_INTERMEDIATE) && (hr != VFW_S_CANT_CUE) );

        // All cached filters should be stopped.
        ASSERT( State_Stopped == fsCurrentState );
    }
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\msgmutex.h ===
// Copyright (c) Microsoft Corporation 1999. All Rights Reserved

//
//   Filter graph locking definitions
//

#ifndef MsgMutex_h
#define MsgMutex_h

// Special mutex style locking
class CMsgMutex
{
public:
    HANDLE m_hMutex;
    DWORD  m_dwOwnerThreadId;  //  Thread Id
    DWORD  m_dwRecursionCount;
    HWND   m_hwnd;
    UINT   m_uMsg;
    DWORD  m_dwWindowThreadId;

    CMsgMutex(HRESULT *phr);
    ~CMsgMutex();
    BOOL Lock(HANDLE hEvent = NULL);
    void Unlock();
    void SetWindow(HWND hwnd, UINT uMsg);
};

class CAutoMsgMutex
{
public:
    CAutoMsgMutex(CMsgMutex *pMutex) : m_pMutex(pMutex)
    {
        pMutex->Lock();
    }
    ~CAutoMsgMutex()
    {
        m_pMutex->Unlock();
    }

private:
    CMsgMutex * const m_pMutex;

};

#ifdef DEBUG
BOOL WINAPI CritCheckIn( const CMsgMutex *pMutex );
#endif // DEBUG

#endif // MsgMutex_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\grphstrm.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <atlbase.h>
#include "Util.h"
#include "fgenum.h"
#include "filgraph.h"

extern HRESULT GetFilterMiscFlags(IUnknown *pFilter, DWORD *pdwFlags);

//=====================================================================
//
// CFilterGraph::FindUpstreamInterface
//
// Search a filter chain for an interface
// Find the first upstream output pin or filter which supports this interface
//
// Later:: 
// If we wanted to extend this into a generic function then we should allow
// defining a search criteria, of the superset of:
//              AM_INTF_SEARCH_INPUT_PIN | 
//              AM_INTF_SEARCH_OUTPUT_PIN | 
//              AM_INTF_SEARCH_FILTER
//
//=====================================================================
STDMETHODIMP CFilterGraph::FindUpstreamInterface
(
    IPin   *pPin, 
    REFIID riid,
    void   **ppvInterface, 
    DWORD  dwFlags
)
{
    
    ASSERT( ppvInterface );
    if( !ppvInterface )
        return E_POINTER;
        
    if( 0 == dwFlags )
    { 
        // 0 means search everything   
        dwFlags = AM_INTF_SEARCH_INPUT_PIN | AM_INTF_SEARCH_OUTPUT_PIN | 
                  AM_INTF_SEARCH_FILTER;
    }                  
        
    HRESULT hr = S_OK;
    BOOL bFound = FALSE;
    if ( PINDIR_INPUT == Direction( pPin ) ) 
    {
        if( AM_INTF_SEARCH_INPUT_PIN & dwFlags )
        {
            hr = pPin->QueryInterface( riid, (void **) ppvInterface );
            if( SUCCEEDED( hr ) ) 
            {
                bFound = TRUE;
                DbgLog( ( LOG_TRACE, 8, "interface found on input pin %x", pPin ) );
            }
        }
        if( !bFound )
        {        
            IPin * pConnectedPin;
            hr = pPin->ConnectedTo( &pConnectedPin );
            if ( S_OK == hr )
            {
                hr = FindUpstreamInterface( pConnectedPin, riid, ppvInterface, dwFlags );
                pConnectedPin->Release( );
                if( SUCCEEDED( hr ) )
                {
                    bFound = TRUE;
                }
            }
        }            
    }
    else
    {                
        if( AM_INTF_SEARCH_OUTPUT_PIN & dwFlags )
        {        
    	    // check for pin interface first, then filter
            hr = pPin->QueryInterface( riid, (void **) ppvInterface );
            if( SUCCEEDED( hr ) )
            {
                bFound = TRUE;
                DbgLog( ( LOG_TRACE, 8, "interface found on output pin %x", pPin ) );
            }                    
        }
                    
        if( !bFound )
        { 
            if( AM_INTF_SEARCH_FILTER & dwFlags )
            {            
                PIN_INFO pinfo;
                hr = pPin->QueryPinInfo( &pinfo );
                ASSERT( SUCCEEDED( hr ) );
                if ( SUCCEEDED( hr ) )
                {
                    hr = pinfo.pFilter->QueryInterface( riid, (void **) ppvInterface );
                    pinfo.pFilter->Release( );
                    if( SUCCEEDED( hr ) ) 
                    {
                        bFound = TRUE;
                        DbgLog( ( LOG_TRACE, 8, "interface found on filter %x", pinfo.pFilter ) );
                    }
                }
            }                
            if( !bFound )
            {                            
                //  move upstream and on to any internally connected pins
                CEnumConnectedPins EnumPins(pPin, &hr);
                if (SUCCEEDED(hr)) {
                    IPin *pPin;
                    for (; ; ) {
                        pPin = EnumPins();
                        if (NULL == pPin) {
                            break;
                        }
                        hr = FindUpstreamInterface( pPin, riid, ppvInterface, dwFlags );
                        pPin->Release();
                        if (SUCCEEDED(hr)) {
                            bFound = TRUE;
                            break;
                        }
                    }
                }                    
            }
        }            
    }    
    if (!( SUCCEEDED( hr ) && bFound ) ) 
    {
        DbgLog( ( LOG_TRACE, 8, "FindUpstreamInterface - interface not found" ) );
        hr = E_NOINTERFACE;
    }
    return hr;
}

//=====================================================================
//
// CFilterGraph::SetMaxGraphLatency
//
// Allows an app to change the maximum latency allowed for this graph.
//
//=====================================================================

STDMETHODIMP CFilterGraph::SetMaxGraphLatency( REFERENCE_TIME rtMaxGraphLatency )
{
    if( !mFG_bSyncUsingStreamOffset )
        return E_FAIL;
        
    HRESULT hr = S_OK;
    if( rtMaxGraphLatency != mFG_rtMaxGraphLatency )
    {
        // just assert that this value isn't bogus (say, under 2 seconds?)
        ASSERT( rtMaxGraphLatency < 2000 * ( UNITS / MILLISECONDS ) );
        
        mFG_rtMaxGraphLatency = rtMaxGraphLatency;
        
        // now reset on all push source pins in the graph
        hr = SetMaxGraphLatencyOnPushSources();
    }        
    return hr;
}

//=====================================================================
//
// CFilterGraph::SyncUsingStreamOffset
//
// Turns on/off graph latency settings
//
//=====================================================================

STDMETHODIMP CFilterGraph::SyncUsingStreamOffset( BOOL bUseStreamOffset )
{
    BOOL bLastState = mFG_bSyncUsingStreamOffset;
    mFG_bSyncUsingStreamOffset = bUseStreamOffset;
    
    if( bUseStreamOffset && 
        bUseStreamOffset != bLastState )
    {
        SetMaxGraphLatencyOnPushSources();
    }        
    return S_OK; 
}


//=====================================================================
//
// CFilterGraph::SetMaxGraphLatencyOnPushSources
//
// Tell all push sources the max graph latency
//
//=====================================================================

HRESULT CFilterGraph::SetMaxGraphLatencyOnPushSources( )
{
    if( !mFG_bSyncUsingStreamOffset ) // should be redundant
        return E_FAIL;
        
    HRESULT hr = S_OK;
        
    CAutoMsgMutex cObjectLock(&m_CritSec); // make sure this is needed!!
    
    // reset on all push source pins in the graph
    PushSourceList lstPushSource( TEXT( "IAMPushSource filter list" ) );
    hr = BuildPushSourceList( lstPushSource, FALSE, FALSE );
    if( SUCCEEDED( hr ) )
    {
        for ( POSITION Pos = lstPushSource.GetHeadPosition(); Pos; )
        {
            PushSourceElem *pElem = lstPushSource.GetNext(Pos);
    
            if( pElem->pips )  // first verify it's an IAMPushSource pin
                pElem->pips->SetMaxStreamOffset( mFG_rtMaxGraphLatency );
        } 
        DeletePushSourceList( lstPushSource );
    }
    return hr;
}


//=====================================================================
//
// CFilterGraph::BuildPushSourceList
//
// Build a list of all output pins that support IAMPushSource
//
//=====================================================================

HRESULT CFilterGraph::BuildPushSourceList(PushSourceList & lstPushSource, BOOL bConnected, BOOL bGetClock )
{
    //    
    // (doing this the easy way, for now)
    //
    // build a list of the output pins that support IAMPushSource
    //    
    // really, we need to build a list of all the streams which are sourced by an 
    // IAMPushSource pin, store the sum latency for the chain, as well as
    // maybe a ptr to the renderer (input pin) for the chain (if one exists)
    //
    // note that we're really only interested in pins the are actually connected 
    // to a renderer of some kind, so for now we at least make sure that an 
    // output pin is connected before considering it at a push source
    //
    CFilGenList::CEnumFilters Next(mFG_FilGenList);
    IBaseFilter *pf;
    HRESULT hr, hrReturn = S_OK;
    IAMPushSource * pips;
    
    while ((PVOID) (pf = ++Next)) 
    {
        // First check that filter supports IAMFilterMiscFlags and is an 
        // AM_FILTER_MISC_FLAGS_IS_SOURCE filter
        ULONG ulFlags;
        GetFilterMiscFlags(pf, &ulFlags);
        BOOL bAddPinToSourceList = FALSE;
        BOOL bCheckPins = FALSE;
        IKsPropertySet * pKsFilter;
        
        if( AM_FILTER_MISC_FLAGS_IS_SOURCE & ulFlags )
        {
            bCheckPins = TRUE;
        }
        else
        {
            //
            // Else see if it's ksproxy filter and if so always check output pins for
            // capture or push source support. This is because some ksproxy capture devices 
            // (i.e. stream class) don't correctly expose themselves as a source filter
            //
            hr = pf->QueryInterface( IID_IKsPropertySet, (void**)(&pKsFilter) );
            if( SUCCEEDED( hr ) )
            {
                pKsFilter->Release();
                bCheckPins = TRUE;
            }            
        }
        if( bCheckPins )        
        {                    
            // Enumerate the output pins for IAMPushSource support
            CEnumPin NextPin(pf, CEnumPin::PINDIR_OUTPUT);
            IPin *pPin;
            while ((PVOID) (pPin = NextPin()))
            {
                // check whether the caller's only interested in connected output pins
                if( bConnected )
                {
                    // first verify that it's connected, otherwise we're not interested
                    IPin * pConnected;
                    hr = pPin->ConnectedTo( &pConnected );
                    if( SUCCEEDED( hr ) )
                    {                
                        pConnected->Release();
                    }
                    else
                    {
                        pPin->Release();
                        continue;
                    }
                }                                                                    
                hr = pPin->QueryInterface( IID_IAMPushSource, (void**)(&pips) );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Got IAMPushSource from pin of filter %x %ls")
                      , pf, (mFG_FilGenList.GetByFilter(pf))->pName));

                    bAddPinToSourceList = TRUE;
                }
                else
                {
                    //else see if it's ksproxy 'capture' pin
                    IKsPropertySet * pKs;
                    hr = pPin->QueryInterface( IID_IKsPropertySet, (void**)(&pKs) );
                    if( SUCCEEDED( hr ) )
                    {
                        GUID guidCategory;
                        DWORD dw;
                        hr = pKs->Get( AMPROPSETID_Pin
                                     , AMPROPERTY_PIN_CATEGORY
                                     , NULL
                                     , 0
                                     , &guidCategory
                                     , sizeof(GUID)
                                     , &dw );
                        if( SUCCEEDED( hr ) )                         
                        {
                            if( guidCategory == PIN_CATEGORY_CAPTURE )
                            {
                                DbgLog((LOG_TRACE, 5, TEXT("Found capture pin that doesn't support IAMPushSource from pin of filter %x %ls")
                                  , pf, (mFG_FilGenList.GetByFilter(pf))->pName));
                                bAddPinToSourceList = TRUE;
                            } 
                        }                    
                    	pKs->Release();
                    }
                }
                                        
                if( bAddPinToSourceList )
                {    
                    PushSourceElem *pElem = new PushSourceElem;
                    if( NULL == pElem ) 
                    {                        
                        hrReturn = E_OUTOFMEMORY;
                        if( pips )
                            pips->Release();
                            
                        pPin->Release();                                
                        break;
                    }
                    pElem->pips = pips; // remember, can be NULL if the pin isn't a true IAMPushSource pin!
                    
                    // initialize pClock                        
                    pElem->pClock = NULL;
                    
                    // init flags
                    pElem->ulFlags = 0;
                                            
                    if( pips )                        
                        ASSERT( SUCCEEDED( pips->GetPushSourceFlags( &pElem->ulFlags ) ) );
                                            
                    if( bGetClock )
                    {                    
                        PIN_INFO PinInfo;  
                        hr = pPin->QueryPinInfo( &PinInfo );
                        if( SUCCEEDED( hr ) )
                        {
                            hr = PinInfo.pFilter->QueryInterface( IID_IReferenceClock
                                                                , (void **)&pElem->pClock );
                            PinInfo.pFilter->Release();
                        }
                    }
                
                    // add this interface pointer to our list                   
                    if (NULL==lstPushSource.AddTail(pElem)) 
                    {
                        hrReturn = E_OUTOFMEMORY;
                        if( pips )
                            pips->Release();
                        if( pElem->pClock )
                            pElem->pClock->Release();
                            
                        break;
                    }
                }                        
                pPin->Release();
            }
        }
    } // while loop
    return hrReturn;
}

//=====================================================================
//
// CFilterGraph::GetMaxStreamLatency
//
// Search over all graph streams for pins which support IAMPushSource
// and IAMLatency and attempt to determine a maximum stream latency
//
//=====================================================================

REFERENCE_TIME CFilterGraph::GetMaxStreamLatency(PushSourceList & lstPushSource)
{
    // now go through the list we built and set the offset times based on the max 
    // value we just found
    REFERENCE_TIME rtLatency, rtMaxLatency = 0;
    HRESULT hr = S_OK;
    for ( POSITION Pos = lstPushSource.GetHeadPosition(); Pos; )
    {
        PushSourceElem *pElem = lstPushSource.GetNext(Pos);
        // first verify it's a true push source        
        if( pElem->pips )
        {
            REFERENCE_TIME rtLatency = 0;
            hr = pElem->pips->GetLatency( &rtLatency );
            if( SUCCEEDED( hr ) )
            {        
                if( rtLatency > rtMaxLatency )
                {
                    rtMaxLatency = rtLatency;
                }                        
                else
                {
                    // else check that the filter can handle this amount of offset
                    // it may not be able to tell for sure, so even if it thinks it
                    // can't we'll still try to use it for now.
                    REFERENCE_TIME rtMaxOffset;
                    hr = pElem->pips->GetMaxStreamOffset( &rtMaxOffset );
                    if( S_OK == hr )
                    {
                        ASSERT( rtMaxLatency <= rtMaxOffset );
                    }
                } 
            }
        }            
    }
    // don't return anything larger than our established limit
    return min( rtMaxLatency, mFG_rtMaxGraphLatency) ;
}    
    
//=====================================================================
//
// CFilterGraph::DeletePushSourceList
//
// Delete the push source list we built in BuildPushSourceList
//
//=====================================================================

void CFilterGraph::DeletePushSourceList(PushSourceList & lstPushSource)
{
    PushSourceElem * pElem;
    while ( ( PVOID )( pElem = lstPushSource.RemoveHead( ) ) )
    {
        if( pElem->pClock )
        {
            pElem->pClock->Release();
        }
        if( pElem->pips )
            pElem->pips->Release();
    
        delete pElem;
    } // while loop
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\mapper.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __DefFilMapper
#define __DefFilMapper

#include "cachemap.h"
#include "fil_data.h"

// There are three classes

// CFilterMapper - you can have lots of these, but it has a static mM_pReg
// which points to the one and only MapperCache.
// CFilterMapper needs a critical section to lock access to mMpReg so that it
// never thinks it's null when it isn't really, and it needs a static
// ref count to know when to free the cache, and that means (sigh) a
// static CRITICAL_SECTION to guard that.

// CMapperCache - as mentioned.  there will only be one of these
// (OK - one per process.  One in the system would be nicer).
// It needs its own locks because...

// CEnumRegFilters - an enumerator.  These contain some data (the position)
// so they are made thread safe too.  There can be lots of these and
// they all hammer away at the same cache - that's why the cache needed a lock.


// The cache may have been rebuilt in between calls to
// RegEnumFilterInfo, so the caller needs to pass in a version # each
// time.
struct Cursor
{
    POSITION pos;
    ULONG ver;

    //  For output types only compare on wild cards for the
    //  second and subsequent types if this is set
    bool bDoWildCardsOnInput;
};


//================================================================
// CMapperCache              Registry caching
//================================================================
class CMapperCache : public CCritSec
{
private:
    // Any registration or unregistration means that
    // the cache needs to be refreshed.  We do a lazy
    // refresh.  This means that if there are several
    // changes we won't re-read it all until needed.

    BOOL m_bRefresh;            // The cache is out of date
    ULONG m_ulCacheVer;         // cache version #

    // building the cache goes through devenum which can register new
    // filters. we don't want those to break the cache.
    BOOL m_fBuildingCache;      // in Cache();

    DWORD m_dwMerit;            // merit of filters cached


    // there's a list of filters
    // every filter has a list of pins
    // every pin has a list of types
    //
    // m_lstFilter-->clsid
    //               Name
    //               dwMerit
    //               lstPin--->Output
    //                 .       bZero
    //                 .       bMany
    //                 .       clsConnectsToFilter
    //               next      strConnectsToPin
    //               filter    lstType------------>clsMajor
    //                 .         .                 clsSub
    //                 .         .                   .
    //                etc        .                   .
    //                         next                  .
    //                         pin                 next
    //                           .                 type
    //                           .                   .
    //                          etc                  .
    //                                              etc
    //

    class CMapFilter
    {
    public:
        CMapFilter() {
            pDeviceMoniker = 0;
            m_prf2 = 0;
#ifdef USE_CLSIDS
            m_clsid = GUID_NULL;
#endif
            m_pstr = NULL;
        }
        ~CMapFilter() {
            if(pDeviceMoniker) pDeviceMoniker->Release();
            CoTaskMemFree((BYTE *)m_prf2);
            CoTaskMemFree(m_pstr);
        }

        HRESULT GetFilter(IBaseFilter **ppFilter);

        IMoniker *pDeviceMoniker;
        REGFILTER2 *m_prf2;
#ifdef USE_CLSIDS
        CLSID m_clsid;
#endif
        LPOLESTR m_pstr;
    };

    //  Helper
    static HRESULT GetMapFilterClsid(CMapFilter *pFilter, CLSID *pclsid);

    typedef CGenericList<CMapFilter> CFilterList;
    CFilterList * m_plstFilter;
    typedef CGenericList<CFilterList> CFilterListList;



    bool  m_b16Color;

public:
    CMapperCache();
    ~CMapperCache();

    ICreateDevEnum *m_pCreateDevEnum;

    // Cache all the filters in the registry ready to enumerate.
    HRESULT Cache();

    // Mark the cache as out of date if we're not in Cache(); see
    // m_fBuildingCache
    HRESULT BreakCacheIfNotBuildingCache();

    // Enumerate!
    HRESULT RegEnumFilterInfo(
        Cursor & cur,
        bool bExactMatch,
        DWORD dwMerit ,
        BOOL bInputNeeded,
        const GUID *pInputTypes,
        DWORD cInputTypes,
        const REGPINMEDIUM *pMedIn ,
        const CLSID *pPinCatIn,
        BOOL bMustRender,
        BOOL bOutputNeeded,
        const GUID *pOutputTypes,
        DWORD cOutputTypes,
        const REGPINMEDIUM *pMedOut ,
        const CLSID *pPinCatOut,
        IMoniker **ppMonOut ,
        CLSID * clsFilter,
        const LPWSTR Name
        );

    //  Cache the cache stuff

    HRESULT SaveCacheToRegistry(DWORD dwMerit, DWORD dwPnPVersion);
    HRESULT RestoreFromCache(DWORD dwPnPVersion);
    HRESULT RestoreFromCacheInternal(FILTER_CACHE *pCache);
    HRESULT SaveData(PBYTE pbData, DWORD dwSize);
    FILTER_CACHE * LoadCache(DWORD dwMerit, DWORD dwPnPVersion);

private:
    // Refresh the cache from the registry.
    HRESULT Refresh();

    //
    HRESULT ProcessOneCategory(REFCLSID clsid, ICreateDevEnum *pCreateDevEnum);

    LONG CacheFilter(IMoniker *pDeviceMoniker, CMapFilter * pFil);

    static void Del(CFilterList * plstFil);
    BOOL FindType(
        const REGFILTERPINS2 * pPin,
        const GUID *pTypes,
        DWORD cTypes,
        const REGPINMEDIUM *pMed,
        const CLSID *pPinCatNeeded,
        bool fExact,
        BOOL bPayAttentionToWildCards,
        BOOL bDoWildCards);

    BOOL CheckInput(
        const REGFILTERPINS2 * pPin,
        const GUID *pTypes,
        DWORD cTypes,
        const REGPINMEDIUM *pMed,
        const CLSID *pPinCatNeeded,
        bool fExact,
        BOOL bMustRender,
        BOOL bDoWildCards);

    void Sort( CFilterList * &pfl);
    void Merge( CFilterListList & fll, CFilterList * pfl);
    void MergeTwo( CFilterList * pflA, CFilterList * pflB);
    HRESULT Split(CFilterList * pfl, CFilterListList & fll);
    int Compare(CMapFilter * pfA, CMapFilter * pfB);
    void CountPins(CMapFilter * pf, int &cIn, int &cOut);
    void DbgDumpCache(CFilterList * pfl);

}; // class CMapperCache

// class that lets you register filters with categories.
class CFilterMapper2 :
    public IFilterMapper3,
    public IFilterMapper,
    public IAMFilterData,
    public CUnknown,
    public CCritSec
{
    DECLARE_IUNKNOWN;

    // IFilterMapper2 methods
    STDMETHOD(CreateCategory)(
        /* [in] */ REFCLSID clsidCategory,
        /* [in] */ DWORD dwCategoryMerit,
        /* [in] */ LPCWSTR Description);

    STDMETHOD(UnregisterFilter)(
        /* [in] */ const CLSID *pclsidCategory,
        /* [in] */ const OLECHAR *szInstance,
        /* [in] */ REFCLSID Filter);

    STDMETHOD(RegisterFilter)(
        /* [in] */ REFCLSID clsidFilter,
        /* [in] */ LPCWSTR Name,
        /* [out][in] */ IMoniker **ppMoniker,
        /* [in] */ const CLSID *pclsidCategory,
        /* [in] */ const OLECHAR *szInstance,
        /* [in] */ const REGFILTER2 *prf2);

    STDMETHODIMP EnumMatchingFilters(
        /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppEnum,
        /* [in] */ DWORD dwFlags,
        /* [in] */ BOOL bExactMatch,
        /* [in] */ DWORD dwMerit,
        /* [in] */ BOOL bInputNeeded,
        /* [in] */ DWORD cInputTypes,
        /* [size_is] */ const GUID __RPC_FAR *pInputTypes,
        /* [in] */ const REGPINMEDIUM __RPC_FAR *pMedIn,
        /* [in] */ const CLSID __RPC_FAR *pPinCategoryIn,
        /* [in] */ BOOL bRender,
        /* [in] */ BOOL bOutputNeeded,
        /* [in] */ DWORD cOutputTypes,
        /* [size_is] */ const GUID __RPC_FAR *pOutputTypes,
        /* [in] */ const REGPINMEDIUM __RPC_FAR *pMedOut,
        /* [in] */ const CLSID __RPC_FAR *pPinCategoryOut);

    //
    // IFilterMapper methods
    //
    STDMETHODIMP RegisterFilter
    ( CLSID   clsid,    // GUID of the filter
      LPCWSTR Name,     // Descriptive name for the filter
      DWORD   dwMerit     // DO_NOT_USE, UNLIKELY, NORMAL or PREFERRED.
      );

    STDMETHODIMP RegisterFilterInstance
    ( CLSID   clsid,// GUID of the filter
      LPCWSTR Name, // Descriptive name of instance.
      CLSID  *MRId  // Returned Media Resource Id which identifies the instance,
      // a locally unique id for this instance of this filter
      );

    STDMETHODIMP  RegisterPin
    ( CLSID   clsFilter,        // GUID of filter
      LPCWSTR strName,          // Descriptive name of the pin
      BOOL    bRendered,        // The filter renders this input
      BOOL    bOutput,          // TRUE iff this is an Output pin
      BOOL    bZero,            // TRUE iff OK for zero instances of pin
      // In this case you will have to Create
      // a pin to have even one instance
      BOOL    bMany,            // TRUE iff OK for many instances of pin
      CLSID   clsConnectsToFilter, // Filter it connects to if it has a
      // subterranean connection, else NULL
      LPCWSTR strConnectsToPin  // Pin it connects to
      // else NULL
      );

    STDMETHODIMP RegisterPinType
    ( CLSID   clsFilter,        // GUID of filter
      LPCWSTR strName,          // Descriptive name of the pin
      CLSID   clsMajorType,     // Major type of the data stream
      CLSID   clsSubType        // Sub type of the data stream
      );

    STDMETHODIMP UnregisterFilter
    ( CLSID  Filter     // GUID of filter
      );


    STDMETHODIMP UnregisterFilterInstance
    ( CLSID  MRId       // Media Resource Id of this instance
      );

    STDMETHODIMP UnregisterPin
    ( CLSID   Filter,    // GUID of filter
      LPCWSTR strName    // Descriptive name of the pin
      );

    STDMETHODIMP EnumMatchingFilters
    ( IEnumRegFilters **ppEnum  // enumerator returned
      , DWORD dwMerit             // at least this merit needed
      , BOOL  bInputNeeded        // Need at least one input pin
      , CLSID clsInMaj            // input major type
      , CLSID clsInSub            // input sub type
      , BOOL bRender              // must the input be rendered?
      , BOOL bOutputNeeded        // Need at least one output pin
      , CLSID clsOutMaj           // output major type
      , CLSID clsOutSub           // output sub type
      );

    // new IFilterMapper3 method
    STDMETHODIMP GetICreateDevEnum( ICreateDevEnum **ppEnum );

    // IAMFilterData methods

    STDMETHODIMP ParseFilterData(
        /* [in, size_is(cb)] */ BYTE *rgbFilterData,
        /* [in] */ ULONG cb,
        /* [out] */ BYTE **prgbRegFilter2);

    STDMETHODIMP CreateFilterData(
        /* [in] */ REGFILTER2 *prf2,
        /* [out] */ BYTE **prgbFilterData,
        /* [out] */ ULONG *pcb);


public:

    CFilterMapper2(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr);
    ~CFilterMapper2();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    // initialize cs
    static void MapperInit(BOOL bLoading,const CLSID *rclsid);

    //  Break the cache


private:

    // make cache if none exists
    HRESULT CreateEnumeratorCacheHelper();

    // Break the cache
    void BreakCacheIfNotBuildingCache();

    //  Invalidate registry cache
    static HRESULT InvalidateCache();


    ULONG m_ib;
    BYTE *m_rgbBuffer;
    ULONG m_cbLeft;

    static CMapperCache * mM_pReg;
    // we need to separately count references to this thing so that
    // we know when the last mapper has gone.
    static long           mM_cCacheRefCount;
    static CRITICAL_SECTION mM_CritSec;
};

//==========================================================================
//==========================================================================
// CEnumRegFilters class.
// This enumerates filters in the registry.
//==========================================================================
//==========================================================================

class CEnumRegFilters : public IEnumRegFilters,  // The interface we support
                        public CUnknown,         // A non delegating IUnknown
                        public CCritSec          // Provides object locking
{

    // This thing has lots of data, so needs locking to make it thread safe,
    // but in addition, there can be many of these accessing a single copy
    // of the MapperCache so that needs separate locking.

    private:

        DWORD mERF_dwMerit;      // at least this merit needed

        //  Keep the next 4 items consecutive otherwise the call to
        //  RegEnumFilterInfo won't work
        CLSID mERF_clsInMaj;     // major type reqd for input pin
        CLSID mERF_clsInSub;     // sub type reqd for input pin
        CLSID mERF_clsOutMaj;    // major type reqd for output pin
        CLSID mERF_clsOutSub;    // sub type reqd for output pin

        BOOL  mERF_bRender;      // does the input pin have to be rendered
        BOOL  mERF_bInputNeeded; // must have at least one input pin
        BOOL  mERF_bOutputNeeded;// must have at least one output pin
        BOOL  mERF_Finished ;    // Pos==NULL could mean finished or not started
        Cursor mERF_Cur;         // cursor (together with Finished)
        CMapperCache * mERF_pReg; // Registry cache

    public:

        // Normal constructor that creates an enumerator set at the start
        CEnumRegFilters( DWORD dwMerit
                       , BOOL  bInputNeeded
                       , REFCLSID clsInMaj
                       , REFCLSID clsInSub
                       , BOOL bRender
                       , BOOL bOutputNeeded
                       , REFCLSID clsOutMaj
                       , REFCLSID clsOutSub
                       , CMapperCache * pReg
                       );


        ~CEnumRegFilters();

        DECLARE_IUNKNOWN

        STDMETHODIMP Next
            ( ULONG cFilters,           // place this many filters...
              IMoniker **rgpMoniker,
              ULONG * pcFetched         // actual count passed returned here
            );

    STDMETHODIMP Next
            ( ULONG cFilters,           // place this many filters...
              REGFILTER ** apRegFilter, // ...in this array of REGFILTER*
              ULONG * pcFetched         // actual count passed returned here
            );

        STDMETHODIMP Skip(ULONG cFilters)
        {
            UNREFERENCED_PARAMETER(cFilters);
            return E_NOTIMPL;
        }

        STDMETHODIMP Reset(void)
        {
            CAutoLock cObjectLock(this);
            ZeroMemory(&mERF_Cur, sizeof(mERF_Cur));
            mERF_Finished = FALSE;
            return NOERROR;
        };

        // No cloning - ALWAYS returns E_NOTIMPL.
        // If need be do one enumeration at a time and cache the results.

        STDMETHODIMP Clone(IEnumRegFilters **ppEnum)
        {
            UNREFERENCED_PARAMETER(ppEnum);
            return E_NOTIMPL;
        }

        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
};  // class CEnumRegFilters

// ------------------------------------------------------------------------
// return monikers. could probably be combined with CEnumRegFilters
//

class CEnumRegMonikers : public IEnumMoniker,    // The interface we support
                        public CUnknown,         // A non delegating IUnknown
                        public CCritSec          // Provides object locking
{

    // This thing has lots of data, so needs locking to make it thread safe,
    // but in addition, there can be many of these accessing a single copy
    // of the MapperCache so that needs separate locking.

private:

    bool mERF_bExactMatch;    // no wildcards?
    DWORD mERF_dwMerit;       // at least this merit needed
    GUID *mERF_pInputTypes;   // types reqd for input pin
    DWORD mERF_cInputTypes;   // number of input
    CLSID mERF_clsInPinCat;   // this pin category needed
    GUID *mERF_pOutputTypes;  // types reqd for output pin
    DWORD mERF_cOutputTypes;  // number of output types
    CLSID mERF_clsOutPinCat;  // this pin category needed
    REGPINMEDIUM mERF_medIn;  // medium reqd for input pin
    REGPINMEDIUM mERF_medOut; // medium reqd for output pin
    bool mERF_bMedIn;         // medium reqd for input pin?
    bool mERF_bMedOut;        // medium reqd for output pin?
    BOOL  mERF_bRender;       // does the input pin have to be rendered
    BOOL  mERF_bInputNeeded;  // must have at least one input pin
    BOOL  mERF_bOutputNeeded; // must have at least one output pin
    BOOL  mERF_Finished ;     // Pos==NULL could mean finished or not started
    Cursor mERF_Cur;          // cursor (together with Finished)
    CMapperCache * mERF_pReg; // Registry cache

public:

        // Normal constructor that creates an enumerator set at the start
    CEnumRegMonikers(
        BOOL bExactMatch,
        DWORD dwMerit,
        BOOL bInputNeeded,
        const GUID *pInputTypes,
        DWORD cInputTypes,
        const REGPINMEDIUM *pMedIn,
        const CLSID *pPinCatIn,
        BOOL bRender,
        BOOL bOutputNeeded,
        const GUID *pOutputTypes,
        DWORD cOutputTypes,
        const REGPINMEDIUM *pMedOut,
        const CLSID *pPinCatOut,
        CMapperCache * pReg,
        HRESULT *phr
        );


    ~CEnumRegMonikers();

    DECLARE_IUNKNOWN

    STDMETHODIMP Next
    ( ULONG cFilters,           // place this many filters...
      IMoniker **rgpMoniker,
      ULONG * pcFetched         // actual count passed returned here
      );

    STDMETHODIMP Skip(ULONG cFilters)
    {
        UNREFERENCED_PARAMETER(cFilters);
        return E_NOTIMPL;
    }

    STDMETHODIMP Reset(void)
    {
        CAutoLock cObjectLock(this);
        ZeroMemory(&mERF_Cur, sizeof(mERF_Cur));
        mERF_Finished = FALSE;
        return NOERROR;
    };

    // No cloning - ALWAYS returns E_NOTIMPL.
    // If need be do one enumeration at a time and cache the results.

    STDMETHODIMP Clone(IEnumMoniker **ppEnum)
    {
        UNREFERENCED_PARAMETER(ppEnum);
        return E_NOTIMPL;
    }

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
};  // class CEnumRegFilters



#ifdef DEBUG

#define CBMAX 160
#define DBG_MON_GET_NAME(pmon) DbgMonGetName((WCHAR *)_alloca(CBMAX), pmon)
static WCHAR *DbgMonGetName(WCHAR *wszMonName, IMoniker *pMoniker)
{
    extern WCHAR *MonGetName(IMoniker *pMon);
    WCHAR *wszTmp;
    ZeroMemory(wszMonName, CBMAX);
    if (pMoniker) {
        wszTmp = MonGetName(pMoniker);
        if(wszTmp)
        {
            long cb = (lstrlenW(wszTmp) + 1) * sizeof(WCHAR);
            cb = (long)min((CBMAX - sizeof(WCHAR)) , cb);

            CopyMemory(wszMonName, wszTmp, cb);
            CoTaskMemFree(wszTmp);
        }
    } else {
        lstrcpyW(wszMonName, L"Unknown name");
    }

    return wszMonName;
}

#endif // DEBUG

WCHAR *MonGetName(IMoniker *pMon);


#endif // __DefFilMapper
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\msgmutex.cpp ===
// Copyright (c) Microsoft Corporation 1999. All Rights Reserved

//
//  Filter graph locking implementation
//

#include <streams.h>
#include "MsgMutex.h"

//
//  Special locking stuff
//

CMsgMutex::CMsgMutex(HRESULT *phr) :
    m_dwOwnerThreadId(0),
    m_dwRecursionCount(0),
    m_hMutex(CreateMutex(NULL, FALSE, NULL)),
    m_uMsg(0),
    m_hwnd(NULL),
    m_dwWindowThreadId(0)
{
    if (m_hMutex == NULL) {
        *phr = E_OUTOFMEMORY;
    }
}

CMsgMutex::~CMsgMutex()
{
    if (m_hMutex) {
        EXECUTE_ASSERT(CloseHandle(m_hMutex));
        m_hMutex = NULL;
    }
    ASSERT(m_dwOwnerThreadId == 0 && m_dwRecursionCount == 0);
}

void CMsgMutex::SetWindow(HWND hwnd, UINT uMsg)
{
    m_hwnd = hwnd;
    m_uMsg = uMsg;
    m_dwWindowThreadId = GetWindowThreadProcessId(hwnd, NULL);
}

BOOL CMsgMutex::Lock(HANDLE hEvent)
{
    BOOL bReturn = TRUE;
    ASSERT(m_hMutex != NULL);
    const DWORD dwCurrentThreadId = GetCurrentThreadId();
    if (dwCurrentThreadId != m_dwOwnerThreadId) {
        bReturn =
        (WaitDispatchingMessages(
            m_hMutex,
            INFINITE,
            dwCurrentThreadId == m_dwWindowThreadId ? m_hwnd : NULL,
            m_uMsg,
            hEvent) ==
            WAIT_OBJECT_0);
        if (bReturn) {
            ASSERT(m_dwRecursionCount == 0 && m_dwOwnerThreadId == 0);
            m_dwOwnerThreadId = dwCurrentThreadId;
        }
    } else {
        ASSERT(m_dwRecursionCount != 0);
    }
    if (bReturn) {
        m_dwRecursionCount++;
    }
    return bReturn;
}

void CMsgMutex::Unlock()
{
    ASSERT(m_dwRecursionCount != 0 &&
           m_dwOwnerThreadId == GetCurrentThreadId());
    if (--m_dwRecursionCount == 0) {
        m_dwOwnerThreadId = 0;
        EXECUTE_ASSERT(ReleaseMutex(m_hMutex));
    }
}

#ifdef DEBUG
BOOL WINAPI CritCheckIn( const CMsgMutex *pMutex )
{
    return pMutex->m_dwOwnerThreadId == GetCurrentThreadId();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\makefile.inc ===
# NOTE:
# this directory contains a makefile which contains a single line that
# includes the global build process makefile.def. If the
# NTTARGETFILE1 or NTTARGETFILE0 environment
# variable is set then makefile.def includes makefile.inc from the current
# directory. This makefile.inc creates an extra target for nmake to create
# when it is run. NTTARGETFILE0 is built before everything else, and
# NTTARGETFILE1 is built after everything else.

copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll     \
         $(SDK_ROOT)\bin\*.*
  @if not exist $(QUARTZ)\lib\$(TARGET_DIRECTORY) \
    md $(QUARTZ)\lib\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib     \
         $(QUARTZ)\lib\$(TARGET_DIRECTORY)\*.*

# Browse data for the app

SBRS=obj\$(TARGET_DIRECTORY)\filgraph.sbr  \
     obj\$(TARGET_DIRECTORY)\mapper.sbr    \
     obj\$(TARGET_DIRECTORY)\filgtest.sbr  \
     obj\$(TARGET_DIRECTORY)\fgenum.sbr    \
     obj\$(TARGET_DIRECTORY)\storeobj.sbr  \
     obj\$(TARGET_DIRECTORY)\store.sbr

BSCMAKETMP=obj\$(TARGET_DIRECTORY)\bscmake.tmp

# nmake rule for .bsc targets
$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).bsc: $(SBRS)
    $(VCROOT)\bin\bscmake /o $@ $**

copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll     \
         $(SDK_ROOT)\bin\*.*
  @if not exist $(QUARTZ)\lib\$(TARGET_DIRECTORY) \
    md $(QUARTZ)\lib\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib     \
         $(QUARTZ)\lib\$(TARGET_DIRECTORY)\*.*


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\intel.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

// MUST TURN ALL THE LOG STRINGS INTO RESOURCES OR THIS IS NON-LOCALISABLE!!

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)
#include <hrExcept.h>

// Many of these are needed to make filgraph.h compile, even though they
// are not otherwise used here
#include "fgenum.h"
#include "distrib.h"
#include "rlist.h"
#include "filgraph.h"
#include "resource.h"
#include <fgctl.h>
#include <fgcallb.h>

//#define FILGPERF 1
#ifdef FILGPERF
#define MSR_INTEGERX(a,b) MSR_INTEGER(a,b)
#else
#define MSR_INTEGERX(a,b)
#endif

#ifdef DEBUG
static void DbgValidateHeaps()
{
  HANDLE rgh[512];
  DWORD dwcHeaps = GetProcessHeaps(512, rgh);
  for(UINT i = 0; i < dwcHeaps; i++)
    ASSERT(HeapValidate(rgh[i], 0, 0) );
}
#endif

#ifdef DEBUG
#define IS_DEBUG 1
#else
#define IS_DEBUG 0
#endif

// when enumerating, start with a few pins on the stack and then use
// alloca once we know the right number. fewer in debug so we can test
// the rarer code path.
#ifdef DEBUG
#define C_PINSONSTACK 2
#else
#define C_PINSONSTACK 20
#endif

// we need the display name only for debug builds and logging
// purposes. and the caller wants it on the stack.
WCHAR *CFilterGraph::LoggingGetDisplayName(
    WCHAR szDisplayName[MAX_PATH] , IMoniker *pMon)
{
    szDisplayName[0] = 0;
    if(pMon && ( mFG_hfLog != INVALID_HANDLE_VALUE || IS_DEBUG))
    {

        WCHAR *wsz = 0; pMon->GetDisplayName(0, 0, &wsz);
        if(wsz)
        {
            lstrcpynW(szDisplayName, wsz, MAX_PATH);
            QzTaskMemFree(wsz);
        }
    }

    return szDisplayName;
}

void CFilterGraph::Log(int id,...)
{
    const cch = 400;

    TCHAR szFormat[cch];
    TCHAR szBuffer[2000];       // big to allow for large filenames in the parameters

#ifndef DEBUG
    // Don't waste time if there's no log running
    if (mFG_hfLog == INVALID_HANDLE_VALUE) {
        return;
    }

#endif


    if (LoadString(g_hInst, id, szFormat, cch) == 0) {
        return;   // Tough!
    }

    va_list va;
    va_start(va, id);

    // Format the variable length parameter list
    wvsprintf(szBuffer, szFormat, va);

    // First put it out on the debugger (if it's a debug build etc)
    DbgLog(( LOG_TRACE, 2, szBuffer));

    // Then put it out into the log file (if any)
    if (mFG_hfLog != INVALID_HANDLE_VALUE) {
        lstrcat(szBuffer, TEXT("\r\n"));
        DWORD dw;
        WriteFile(mFG_hfLog, (BYTE *) szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dw, NULL);
    }
    va_end(va);
}

#ifdef DEBUG
static CLSID DbgExpensiveGetClsid(IMoniker *pMon)
{
    CLSID retClsid = GUID_NULL;
    if(pMon)
    {
        IPropertyBag *pPropBag;
        HRESULT hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
        if(SUCCEEDED(hr))
        {
            VARIANT var;
            var.vt = VT_BSTR;
            hr = pPropBag->Read(L"CLSID", &var, 0);
            if(SUCCEEDED(hr))
            {
                CLSID clsid;
                if (CLSIDFromString(var.bstrVal, &clsid) != S_OK)
                {
                    DbgBreak("couldn't convert CLSID");
                }
                else
                {
                    retClsid = clsid;
                }

                SysFreeString(var.bstrVal);
            }
            pPropBag->Release();
        }
    }
    return retClsid;
}

CLSID CFilterGraph::DbgExpensiveGetClsid(const Filter &F)
{
    CLSID clsid = ::DbgExpensiveGetClsid(F.pMon);
    if(clsid != GUID_NULL)
        return clsid;

    // if we found the filter in the graph, we don't have the
    // moniker. but we do have the filter loaded, so we can ask it its
    // clsid
    if(F.pf)
    {
        IPersist *pp;
        if(F.pf->QueryInterface(IID_IPersist, (void **)&pp) == S_OK)
        {
            CLSID clsid;
            pp->GetClassID(&clsid);
            pp->Release();
            return clsid;
        }
    }

    return GUID_NULL;
}
#endif

WCHAR *MonGetName(IMoniker *pMon)
{
    WCHAR *pszRet = 0;
    IPropertyBag *pPropBag;
    HRESULT hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    if(SUCCEEDED(hr))
    {
        VARIANT var;
        var.vt = VT_BSTR;
        hr = pPropBag->Read(L"FriendlyName", &var, 0);
        if(SUCCEEDED(hr))
        {
            hr = AMGetWideString(var.bstrVal, &pszRet);
            SysFreeString(var.bstrVal);
        }
        pPropBag->Release();
    }

    return pszRet;
}

// certain error codes mean that this filter will never connect, so
// best give up now. really this should have been formalized with
// documented success and failure codes

inline BOOL IsAbandonCode(HRESULT hr)
{
    return hr == VFW_E_NOT_CONNECTED || hr == VFW_E_NO_AUDIO_HARDWARE;
}

// errors that are more useful than any others we could give the end
// user.
inline bool IsInterestingCode(HRESULT hr) {
    return hr == VFW_E_NO_AUDIO_HARDWARE;
}

//========================================================================
//
//  Helper for return codes
//
//========================================================================
HRESULT ConvertFailureToInformational(HRESULT hr)
{
    ASSERT(FAILED(hr));
    if (VFW_E_NO_AUDIO_HARDWARE == hr) {
        hr = VFW_S_AUDIO_NOT_RENDERED;
    } else if (VFW_E_NO_DECOMPRESSOR == hr) {
        hr = VFW_S_VIDEO_NOT_RENDERED;
    } else if (VFW_E_RPZA == hr) {
        hr = VFW_S_RPZA;
    } else {
        hr = VFW_S_PARTIAL_RENDER;
    }
    return hr;
}

CFilterGraph::Filter::Filter() : State(F_ZERO),
                   pTypes(NULL),
                   pef(NULL),
                   pMon(NULL),
                   pEm(NULL),
                   cTypes(0),
                   pf(NULL),
                   Name(NULL),
                   m_pNextCachedFilter(NULL)
{
};

HRESULT CFilterGraph::Filter::AddToCache( IGraphConfig* pGraphConfig )
{
    // This function should only be called if the filter cache is being enumerated.
    ASSERT( F_CACHED == State );

    // It's impossible to add an non-existent filter to the filter cache.
    ASSERT( NULL != pf );

    return pGraphConfig->AddFilterToCache( pf );
}

void CFilterGraph::Filter::RemoveFromCache( IGraphConfig* pGraphConfig )
{
    // This function should only be called if the filter cache is being enumerated.
    ASSERT( F_CACHED == State );

    // It's impossible to remove an non-existent filter from the filter cache.
    ASSERT( NULL != pf );

    HRESULT hr = pGraphConfig->RemoveFilterFromCache( pf );

    // IGraphConfig::RemoveFilterFromCache() should return S_OK because 
    // 1) A cached filter can always be successfully removed from the
    //    filter cache
    // 2) IGraphConfig::RemoveFilterFromCache() returns S_OK if a 
    //    cached filter is successfully removed.
    // 3) pf MUST be cached because State == F_CACHED.
    ASSERT( S_OK == hr );

    // Release the filter cache's reference count.
    pf->Release();
}

void CFilterGraph::Filter::ReleaseFilter( void )
{
    // It's impossible to release a non-existent filter.
    ASSERT( NULL != pf );

    pf->Release();
    pf = NULL;
}

CFilterGraph::Filter::~Filter()
{
    delete [] pTypes;
    if (pef) {
        pef->Release();
    }
    if (pMon) {
        pMon->Release();
    }
    if (pEm) {
        pEm->Release();
    }
    if (pf) {
        pf->Release();
    }
    if( m_pNextCachedFilter ) {
        delete m_pNextCachedFilter;
    }

    QzTaskMemFree(Name);
}

//===========================================================================
//
// Intelligent connection/rendering design notes:
//
// Media types are structures which are open ended - there's a type, subtype
// and then extra bits.  The complexity of the way that filters respond to
// this is also open ended - therefore it will never be enough to look in the
// registry and play some games deciding how to wire things up.  We cannot
// know in advance how a filter will behave until it's actually wired up.
// Therefore the intelligent connection or rendering must be done actually
// loading the real filters and really wiring them up.
//
// Ground rules ("dogma")
// 1. Use spare input pins that are already in the graph
// 2. Don't break any connection made previous to this call to Connect or Render
// 3. Always work downstream
// 4. Connect input pins before querying output pins.
//    PINDIR_OUTPUT pins may appear on connection.
//    This might correspond to being told to connect a file output pin to
//    an audio codec.  We connect it via a parser which also generates a
//    video output.
//    Once a filter has an input pin connected, the output pin where
//    the data appears is well defined and can be queried.
// 5. Try hardware before software (= try filters in order of Merit)
// 6. It is fair game to call ConnectedTo for a pin that's not yet connected.
//    but it is likely to FAIL and in this case may return bad data.
//
//
// We may have to make an N stage connection where N is at least 2
// (parser + codec).  This makes the thing rather like a look-ahead search.
// We may need at least 3 stages to do an intelligent Render (parser, codec,
// renderer).
//
// There is no way to tell whether we are making progress or going down a
// blind alley as we start extending the chain of codecs, so we have to do
// a full scale search of the tree of possibilities with full back-out from
// blind alleys.
//
// Breadth first might be nice, but it leaves a lot of resources hanging
// around else risks going even slower than depth first.  Depth first requires
// some cut-off to prevent an infinite blind alley.
//
// Therefore I am going for a depth first search with a maximum
// depth cut-off.  The cut-off makes deep cuts in the otherwise potentially
// infinite search tree.
//
// There is an ordering of the search tree. Hence the "NextChainToTry" is
// well defined.
// In the case of "Connect" a step in the search consists of a chain of filters,
// characterised by <Filter1, InputPin1>, <Filter2, InputPin1>, ...
// In the ordering, Filter1 is the most significant part, InputPin1 next, Filter2
// next and so on.  The ordering of filters is:
//    Filters in the filter cache which are ordered arbitrarly.
//    Followed by filters already in the filter graph, in the order in which they lie
//    in FilGenList
//    followed by filters in the registry in the order in which the registry
//    enumerates them.
// The ordering of pins is the order in which they enumerate when the
// filter is queried.
// NOTE: A filter in the graph will be tried again from the registry.
// If the filter in the graph is already connected, a second instance
// might well work.
//
// NOTE:  When we are making or breaking connections we do NOT alter
// the sequence of the FilGenList other than possibly to add things
// to the end.  Otherwise we risk a closed loop.
//
// Thus if the current step in the search looked like
//           -->Parser, Pin1, MyCodec, Pin3
// meaning that Pin1 was the input pin of the parser and the parser's output
// was connected to Pin3 of MyCodec then the search would proceed by looking
// for
//         a filter in the filtergraph to connect the output of MyCodec to
//                 an input pin on that filter
//                         a filter to connect THAT to etc.
// and if that fails it backs up by trying successively:
//         a different input pin on MyCodec to connect to
//         a different second filter to use instead of MyCodec
//         a different input pin to use on the parser
//         a different filter to use instead of the parser
//         and if that doesn't work then it fails.
//
// It finds the first connection rather than the best.  This is because
// I think that often there will only be one that works and that we
// want to find a connection quickly.
//
// With luck, many of the search stages will only have one viable candidate
// and the search will go fast.  A deep tree search with multiple branches
// per level would be bound to be slow.
//
// The Connect and Render algorithms are similar, but different in detail.
// In each case we go through many stages to grow the chain and finish up
// with either another pair of pins to connect or another set of pins to
// render.  For this reason a recursive implementation seems neatest.
//
// It isn't clear to me at the moment whether the registry is or is not
// happy to have multiple enumerations at various stages.  The help for
// RegEnumKeyEx says that you can either enumerate through the keys
// forwards or backwards, but it doesn't say you can hop about.
// The alternative is to read the filters once and cache them all
// which is what the mapper actually does.

// See also RLIST.H << READ THIS before tinkering(!)

// Search depth for intelligent connection
#define CONNECTRECURSIONLIMIT 5


// THE HIERARCHY OF FUNCTIONS AND PARAMTERS
//
// For intelligent CONNECT

// Connect(pOut, pIn)                            start point
// ConnectRecursively(pOut, pIn, iRecurse)       with depth
// ConnectViaIntermediate(pnOut, pIn, iRecurse)  Finds an intermediate4 filter
// ConnectUsingFilter(pOut, pIn,  F, iRecurse)   Loads F (if need be)
// ConnectByFindingPin(pOut, pIn, F, iRecurse)   Finds input pin on F
// CompleteConnection(pIn, F, pPin, iRecurse)    Finds output pin on F
// ConnectRecursively(pOut, pIn, iRecurse+1)     Next step in the chain


// Render(ppinOut)                                start point
// RenderRecursively(ppinOut,     iRecurse,...) with depth and backout
// RenderViaIntermediate(ppinOut, iRecurse,...) Finds an intermediate filter
// RenderUsingFilter(ppinOut,  F, iRecurse,...) Loads F (if need be)
// RenderByFindingPin(ppinOut, F, iRecurse,...) Finds input pin on F
// CompleteRendering(F, pPin,     iRecurse,...) Finds all output pins  on F
// RenderRecursively(ppinOut,   iRecurse+1,...) Next step in the chain

// The ... stands for three extra parameters on every call.
// 1. A list of actions that might need backing out.  This is also the
// state of the search.
// 2. The list of spare filters.  During the course of Rendering or
// Connecting, we may find that we try a filter and it's no good.
// In that case, rather than unload it, we stick it, together with its
// CLSID, on the Spares list, a list of filters to unload eventually.
// When a new filter is to be loaded, we try the spares list before we
// try CoCreate...  This will (with luck) speed things up.
// 3. The best-so-far state.
// Best means rendering the greatest proportion of the streams with ties
// broken by using the smallest number of filters.


//========================================================================
//
// NextFilter
//
// Update F to the next filter after F in the enumeration.
// Any filter with State F_ZERO represents the start of the enumeration
// Next come filters in the filter cache.
// Next come filters already in the filter graph
// Next come filters from the registry
// After all these comes any filter with State F_INFINITY
//========================================================================
void CFilterGraph::NextFilter(Filter &F, DWORD dwFlags)
{
    HRESULT hr;         // return code from thing(s) we call

    if (F.State==F_ZERO) {
        // F.m_pNextCachedFilter should be NULL because the Filter's state
        // is not F_CACHED.  F.m_pNextCachedFilter is only used when the filter
        // cache is being searched.
        ASSERT( NULL == F.m_pNextCachedFilter );

        F.State = F_CACHED;

        // CEnumCachedFilters only changes hr's value if an error occurs.
        hr = S_OK;

        F.m_pNextCachedFilter = new CEnumCachedFilters( &m_Config, &hr );
        if( (NULL == F.m_pNextCachedFilter) || FAILED( hr ) ) {
            delete F.m_pNextCachedFilter;
            F.m_pNextCachedFilter = NULL;
            F.State = F_INFINITY;
            return;
        }
    }

    if( NULL != F.pf ) {
        F.ReleaseFilter();
    }

    if( F_CACHED == F.State ) {
        IBaseFilter* pNextCachedFilter;

        CEnumCachedFilters& NextCachedFilter = *F.m_pNextCachedFilter;  
        pNextCachedFilter = NextCachedFilter();
        if( NULL != pNextCachedFilter ) {
            F.pf = pNextCachedFilter;
            return;
        }

        // NextCachedFilter() returns NULL if it has enumerated all the filters in
        // the filter cache.  If this occurs then the filter graph should be searched.

        delete F.m_pNextCachedFilter;
        F.m_pNextCachedFilter = NULL;

        
        // IGraphConfig::Reconnect() allows the user to preform a reconnect operation useing
        // only cached filters.  
        if( dwFlags & AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS ) {
            F.State = F_INFINITY;
            return;
        }

        // F.pef should be NULL because the Filter's state is not
        // E_LOADED.  F.pef is only used when the filter graph is 
        // being searched for filters.
        ASSERT( NULL == F.pef );

        F.State = F_LOADED;

        hr = EnumFilters( &(F.pef) );
        if( FAILED( hr ) ) {
            F.State = F_INFINITY;
            return;                
        }
    }

    if (F.State==F_LOADED) {
       //------------------------------------------------------------------------
       // Try to get next filter from filtergraph, if so return it.
       //------------------------------------------------------------------------
        ULONG cFilter;
        IBaseFilter* aFilter[1];
        F.pef->Next(1, aFilter, &cFilter);

        if (cFilter==1) {
            F.pf = aFilter[0];
            DbgLog(( LOG_TRACE, 4, TEXT("NextFilter from graph %x"), F.pf));
            return;
        } else {
            // Enumeration from the filter graph failed, try enumerating the filters in the registry.
            F.pef->Release();
            F.pef = NULL;

            if (!F.bLoadNew) {
                F.State = F_INFINITY;
                return;
            }

            F.State = F_REGISTRY;
            hr = NextFilterHelper( F );
            if (FAILED(hr)) {
                F.State = F_INFINITY;
                return;
            }

            ASSERT(F.Name == NULL);

        }
    }

    //------------------------------------------------------------------------
    // Try to get next filter from registry, if so return it, else tidy up.
    //------------------------------------------------------------------------

    {
        ULONG cFilter;
        IMoniker *pMoniker;
        if (F.Name!=NULL) {
            QzTaskMemFree(F.Name);
            F.Name = NULL;
        }
        if (F.pMon != 0) {
            F.pMon->Release();
            F.pMon = 0;
        }

        while(F.pEm->Next(1, &pMoniker, &cFilter) == VFW_E_ENUM_OUT_OF_SYNC)
        {
            F.pEm->Release();
            F.pEm = 0;

            HRESULT hrTmp = NextFilterHelper(F);
            if(FAILED(hrTmp)) {
                break;
            }
        }

        if (cFilter==1) {

            DbgLog(( LOG_TRACE, 4, TEXT("NextFilter from registry %x")
                   , ::DbgExpensiveGetClsid(pMoniker).Data1
                  ));
            ASSERT(F.pMon == 0);
            F.pMon = pMoniker;  // transfer refcount

            F.Name = MonGetName(pMoniker);
            if (F.Name == 0) {
                F.State = F_INFINITY;
            }

            return;
        } else {
            F.State = F_INFINITY;
            return;
        }
    }

}  // NextFilter

// ========================================================================
// just a helper for something done twice

HRESULT CFilterGraph::NextFilterHelper(Filter &F)
{
    // qi for this each time; can't hold onto interface
    // because it'll addref us.
    IFilterMapper2 *pfm2;
    HRESULT hr = mFG_pMapperUnk->QueryInterface(IID_IFilterMapper2, (void **)&pfm2);
    if(SUCCEEDED(hr))
    {
        ASSERT(F.pEm == NULL);
        hr = pfm2->EnumMatchingFilters(
            &(F.pEm)
            , 0
            , FALSE           // do match wildcards
            , MERIT_DO_NOT_USE+1
            , F.bInputNeeded
            , F.cTypes, F.pTypes
            , 0               // medium in
            , 0               // pin category in
            , FALSE           // bRender
            , F.bOutputNeeded
            , 0, NULL
            , 0               // medium out
            , 0               // pin category out
            );
        pfm2->Release();
    }
    else
    {
        DbgBreak("filgraph/intel.cpp: qi for IFilterMapper2 failed.");
    }

    return hr;
}

// helper to use the private IAMGraphBuildingCB_PRIV interface
HRESULT CFilterGraph::CreateFilterAndNotify(IMoniker *pMoniker, IBaseFilter **ppFilter)
{
    HRESULT hr = S_OK;
    
    // mFG_punkSite can be null.
    CComQIPtr<IAMGraphBuildCB_PRIV, &__uuidof(IAMGraphBuildCB_PRIV)> pcb(mFG_punkSite);
    if(pcb) {
        hr = pcb->SelectedFilter(pMoniker);
    }
    if(FAILED(hr)) {
        DbgLog((LOG_TRACE, 2, TEXT("callback rejected moniker %08x."), hr));
    }
    if(SUCCEEDED(hr)) {
        hr = CreateFilter(pMoniker, ppFilter);
    }
    if(SUCCEEDED(hr) && pcb)
    {
        hr = pcb->CreatedFilter(*ppFilter);

        if(FAILED(hr)) {
            (*ppFilter)->Release();
            *ppFilter = 0;
            DbgLog((LOG_TRACE, 2, TEXT("callback rejected filter %08x."), hr));
        }
    }
    return hr;
}

//========================================================================
//
// GetAMediaType
//
// Enumerate the media types of *ppin.  If they all have the same majortype
// then set MajorType to that, else set it to CLSID_NULL.  If they all have
// the same subtype then set SubType to that, else set it to CLSID_NULL.
// If something goes wrong, set both to CLSID_NULL and return the error.
//========================================================================
HRESULT CFilterGraph::GetAMediaType( IPin * ppin
                                   , CLSID & MajorType
                                   , CLSID & SubType
                                   )
{

    HRESULT hr;
    IEnumMediaTypes *pEnumMediaTypes;

    /* Set defaults */
    MajorType = CLSID_NULL;
    SubType = CLSID_NULL;

    hr = ppin->EnumMediaTypes(&pEnumMediaTypes);

    if (FAILED(hr)) {
        return hr;    // Dumb or broken filters don't get connected.
    }

    ASSERT (pEnumMediaTypes!=NULL);

    /* Put the first major type and sub type we see into the structure.
       Thereafter if we see a different major type or subtype then set
       the major type or sub type to CLSID_NULL, meaning "dunno".
       If we get so that both are dunno, then we might as well return (NYI).
    */

    BOOL bFirst = TRUE;

    for ( ; ; ) {

        AM_MEDIA_TYPE *pMediaType = NULL;
        ULONG ulMediaCount = 0;

        /* Retrieve the next media type
           Need to delete it when we've done.
        */
        hr = pEnumMediaTypes->Next(1, &pMediaType, &ulMediaCount);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr)) {
            MajorType = CLSID_NULL;
            SubType = CLSID_NULL;
            pEnumMediaTypes->Release();
            return NOERROR;    // we can still plough on
        }

        if (ulMediaCount==0) {
            pEnumMediaTypes->Release();
            return NOERROR;       // normal return
        }

        if (bFirst) {
            MajorType = pMediaType[0].majortype;
            SubType = pMediaType[0].subtype;
            bFirst = FALSE;
        } else {
            if (SubType != pMediaType[0].subtype) {
                SubType = CLSID_NULL;
            }
            if (MajorType != pMediaType[0].majortype) {
                MajorType = CLSID_NULL;
            }
        }
        DeleteMediaType(pMediaType);
    }
} // GetAMediaType


//========================================================================
//
// GetMediaTypes
//
// Enumerate the media types of *ppin.  If they all have the same majortype
// then set MajorType to that, else set it to CLSID_NULL.  If they all have
// the same subtype then set SubType to that, else set it to CLSID_NULL.
// If something goes wrong, set both to CLSID_NULL and return the error.
//========================================================================
HRESULT CFilterGraph::GetMediaTypes( IPin * ppin
                                   , GUID **ppTypes
                                   , DWORD *cTypes
                                   )
{

    HRESULT hr;
    IEnumMediaTypes *pEnumMediaTypes;

    ASSERT(*ppTypes == NULL);

    hr = ppin->EnumMediaTypes(&pEnumMediaTypes);

    if (FAILED(hr)) {
        return hr;    // Dumb or broken filters don't get connected.
    }

    ULONG ulTypes = 0;
    AM_MEDIA_TYPE *pMediaTypes[100];
    hr = pEnumMediaTypes->Next(sizeof(pMediaTypes) / sizeof(pMediaTypes[0]),
                               pMediaTypes,
                               &ulTypes);

    pEnumMediaTypes->Release();
    ASSERT(ulTypes <= 100);
    ULONG ulActualTypes = ulTypes < 2 ? 1 : ulTypes;
    *ppTypes = new GUID[ulActualTypes * 2];
    if (*ppTypes == NULL) {
        hr = E_OUTOFMEMORY;
    } else {
        hr = S_OK;
    }

    for (ULONG iType = 0; iType < ulTypes; iType++) {
        AM_MEDIA_TYPE *pmt = pMediaTypes[iType];
        if (S_OK == hr) {
            CopyMemory(&(*ppTypes)[iType * 2], &pmt->majortype,
                       2 * sizeof(GUID));
        }
        DeleteMediaType(pmt);
    }
    if (SUCCEEDED(hr)) {
        if (ulTypes == 0) {
            (*ppTypes)[0] = MEDIATYPE_NULL;
            (*ppTypes)[1] = MEDIASUBTYPE_NULL;
        }
        *cTypes = ulActualTypes;
    }
    return hr;
} // GetMediaTypes


struct CDelRgPins
{
    inline CDelRgPins(IPin **rgpPins) { m_rgpPins = rgpPins; }
    inline ~CDelRgPins() { delete[] m_rgpPins; }
    IPin **m_rgpPins;
};

//========================================================================
//
// CompleteConnection
//
// Trace the input from pPin through F and connect the output
// stream to ppinIn.  If there is not exactly one output stream then fail.
//
// given that F is loaded in the filtergraph and its input is connected
//========================================================================
HRESULT CFilterGraph::CompleteConnection
    ( IPin * ppinIn      // the input pin to ultimately connect to
    , const Filter& F           // the intermed filter (acts as cursor for filter enum)
    , IPin * pPin        // a connected input pin of F
    , DWORD dwFlags
    , int    iRecurse    // the recursion level.  0 means no recursion yet.
    )
{
    // Check for legal flags.
    ASSERT( IsValidConnectFlags( dwFlags ) );

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+7);
    DbgLog(( LOG_TRACE, 4, TEXT("CompleteConnection Pins %x->(filter %x)...>%x level %d")
           , pPin, F.pf, ppinIn, iRecurse));
    HRESULT hr;             // return code from thing(s) we call
    IPin * ppinOut = NULL;  // output pin of F that ppinIn's stream emerges through

    // We allow graphs that have spare output pins - so we enumerate the output
    // pins that the input in streams through to and try connecting each in
    // turn.  We first try QueryInternalConnections.  If that is not
    // implemented we assume that any input pin connects to every output pin.

    int nPin;
    IPin * apPinStack[C_PINSONSTACK];
    IPin **apPin = apPinStack;
    hr = FindOutputPinsHelper( pPin, &apPin, C_PINSONSTACK, nPin, false );
    if (FAILED(hr)) {
        Log( IDS_CONQICFAIL, ppinIn, hr);
        return hr;
    }
    CDelRgPins rgPins(apPin == apPinStack ? 0 : apPin);

    // apPin[0..nPin-1] are addreffed output pins.

    if (nPin==0) {
        Log(IDS_CONNOOUTPINS, F.pf);
    }

    // Do two passes.  in the first pass, take only pins whose media type
    // has a major type which matches F.MajorType
    for (int iPass = 0; iPass<=1; ++iPass) {

       BOOL bSparePins = FALSE;
       for (int iPin = 0; iPin<nPin; ++iPin) {
           if (apPin[iPin]==NULL) {
               continue;       // we must have done this one in pass 1
           }

           if (mFG_bAborting) {
               apPin[iPin]->Release();  // release the ref count on this pin
               continue;
           }

           if (iPass==0) {
              CLSID MT, ST;
              hr = GetAMediaType(apPin[iPin], MT, ST);
              if (MT!=F.pTypes[0]) {
                 continue;      // try this one only in pass 2
              }
           }

           Log(IDS_CONRECURSE, apPin[iPin], F.pf, ppinIn );
           hr = ConnectRecursively(apPin[iPin], ppinIn, NULL, dwFlags, iRecurse);
           apPin[iPin]->Release();  // release the ref count on this pin
           apPin[iPin] = NULL;      // ensure we never look again in pass 2
           if (SUCCEEDED(hr)) {
               Log(IDS_CONRECURSESUC, apPin[iPin], F.pf, ppinIn );

               // Release the ref count on the remaining untried pins
               for (int i=iPin+1; i<nPin; ++i) {
                   apPin[i]->Release();
                   bSparePins = TRUE;
               }
               MSR_INTEGERX(mFG_idIntel, 100*iRecurse+17);
               return (bSparePins ? VFW_S_PARTIAL_RENDER : NOERROR);
           } else {
               bSparePins = TRUE;
               Log(IDS_CONRECURSEFAIL, apPin[iPin], F.pf, ppinIn, hr );
           }
       }
       if (mFG_bAborting) {
          break;
       }

    }


    Log(IDS_CONNOMOREOUTPINS, F.pf);
    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+37);
    return (mFG_bAborting ? E_ABORT : VFW_E_CANNOT_CONNECT);

} // CompleteConnection




//========================================================================
//
// ConnectByFindingPin
//
// Connect ppinOut to ppinIn using F as an intermediate filter
// given that F is loaded and in the filter graph
// Finds an input pin on F to connect to.
//========================================================================
HRESULT CFilterGraph::ConnectByFindingPin
    ( IPin * ppinOut     // the output pin
    , IPin * ppinIn      // the input pin
    , const AM_MEDIA_TYPE* pmtConnection
    , const Filter& F           // the intermed filter (acts as cursor for filter enum)
    , DWORD dwFlags
    , int    iRecurse    // the recursion level.  0 means no recursion yet.
    )
{
    // Check for legal flags.
    ASSERT( IsValidConnectFlags( dwFlags ) );

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+6);
    DbgLog(( LOG_TRACE, 4, TEXT("ConnectByFindingPin %8x..(%8x)...>%8x level %d")
           , ppinOut, F.pf, ppinIn, iRecurse));
    HRESULT hr;         // return code from thing(s) we call

    // Set pPin to each pin in F to find the input pin on F
    CEnumPin Next(F.pf, CEnumPin::PINDIR_INPUT, TRUE);        // only want input pins
    IPin *pPin;

    Log(IDS_CONTRYPINS, F.pf, ppinOut, ppinIn);
    while ((LPVOID) (pPin = Next())) {
        if (mFG_bAborting) {
            pPin->Release();
            break;
        }
        DbgLog(( LOG_TRACE, 4, TEXT("ConnectByF...P Pin %x --> Trying input pin: %x ...>%x (level %d)")
                , ppinOut, pPin, ppinIn, iRecurse));

        IPin *pConnected;
        hr = pPin->ConnectedTo(&pConnected);
        if ( FAILED(hr) || pConnected==NULL) {    // don't try if already connected
            hr = ConnectDirectInternal(ppinOut, pPin, pmtConnection); // no version count
            if (SUCCEEDED(hr)) {
                Log( IDS_CONDISUC, ppinOut, pPin, F.pf );
                hr = CompleteConnection(ppinIn, F, pPin, dwFlags, iRecurse);

                if (FAILED(hr)) {
                    Log( IDS_CONCOMPLFAIL, pPin, F.pf, ppinIn, hr );
                    // Disconnect the input pin and see if there was another.
                    // Purge any pending reconnects between these two pins
                    mFG_RList.Purge(pPin);
                    mFG_RList.Purge(ppinOut);
                    DbgLog((LOG_TRACE, 3, TEXT("Disconnecting pin %x"), pPin));
                    hr = pPin->Disconnect();
                    ASSERT(SUCCEEDED(hr));
                    DbgLog((LOG_TRACE, 3, TEXT("Disconnecting pin %x"), ppinOut));
                    hr = ppinOut->Disconnect();
                    ASSERT(SUCCEEDED(hr));
                } else {

                    pPin->Release();
                    DbgLog((LOG_TRACE, 4, TEXT("Released D pin %x"), pPin));
                    DbgLog(( LOG_TRACE, 4, TEXT("ConnectByFindingPin succeeded level %d")
                           , iRecurse));
                    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+16);
                    Log( IDS_CONCOMPLSUC, pPin, F.pf, ppinIn );
                    return hr;

                }
            } else {
                Log( IDS_CONDIFAIL, ppinOut, pPin, F.pf, hr);
            }

        } else {
            pConnected->Release();
        }
        pPin->Release();
    }
    Log( IDS_CONNOMOREINPINS, F.pf);

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+26);
    return (mFG_bAborting ? E_ABORT : VFW_E_CANNOT_CONNECT);

} // ConnectByFindingPin



//========================================================================
//
// ConnectUsingFilter
//
// Connect ppinOut to ppinIn using F as an intermediate filter
//========================================================================
HRESULT CFilterGraph::ConnectUsingFilter
    ( IPin * ppinOut     // the output pin
    , IPin * ppinIn      // the input pin
    , const AM_MEDIA_TYPE* pmtConnection
    , Filter& F          // the intermed filter (acts as cursor for filter enum)
    , DWORD dwFlags
    , int    iRecurse    // the recursion level.  0 means no recursion yet.
    )
{
    // Check for legal flags.
    ASSERT( IsValidConnectFlags( dwFlags ) );

    // CFilterGraph::ConnectUsingFilter() expects the proposed filter (F) to be in the
    // F_LOADED state (F is in the filter graph), the F_CACHED state (F is in the filter cache) or
    // the F_REGISTRY state (F has been found in the registry but it has not been created).
    ASSERT( (F_LOADED == F.State) || (F_CACHED == F.State) || (F_REGISTRY == F.State) );

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+5);
    DbgLog(( LOG_TRACE, 4, TEXT("Connect Using... pins %x...>%x filter (%d %x %x) level %d")
           , ppinOut, ppinIn, F.State, F.pf, DbgExpensiveGetClsid(F).Data1, iRecurse ));
    HRESULT hr;         // return code from thing(s) we call

    if( (F_REGISTRY == F.State) || (F_CACHED == F.State) ) {

        switch( F.State ) {
        case F_REGISTRY:
            ASSERT( F.pf == NULL );

            hr = CreateFilterAndNotify(F.pMon, &(F.pf));
            {
                WCHAR szDisplayName[MAX_PATH];
                LoggingGetDisplayName(szDisplayName, F.pMon);
                Log( IDS_CONVIAREG, ppinOut, ppinIn, szDisplayName);

                if (FAILED(hr)) {
                    Log( IDS_CONLOADFAIL, szDisplayName, hr );
                    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+25);
                    return hr;
                } else {
                    Log( IDS_CONLOADSUC, szDisplayName, F.pf );
                }

            }

            ASSERT( NULL != F.Name );
            break;

        case F_CACHED:
            break;

        default:
            // This code should never be executed.
            ASSERT( false );
            return E_UNEXPECTED;

        }

        hr = AddFilterInternal(F.pf, F.Name, true);   // AddReffed, no version count
        if (hr==VFW_E_DUPLICATE_NAME) {
             // This is getting out of hand.  This is expected to be an unusual case.
             // The obvious thing to do is just to add something like _1 to the end
             // of the name - but F.Name doesn't have room on the end - and where
             // do we draw the line?  On the other hand people really could want
             // filter graphs with 50 effects filters in them...?
             hr = AddFilterInternal(F.pf, NULL, true);
        }

        if (FAILED(hr)) {
            Log( IDS_CONADDFAIL, F.pf, hr );
            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+35);

            return hr;
        }

        hr = ConnectByFindingPin(ppinOut, ppinIn, pmtConnection, F, dwFlags, iRecurse);
        if (FAILED(hr)) {
            DbgLog((LOG_TRACE, 4,
                    TEXT("ConnectUsing failed (C..ByFind failure) - unloading filter %x level %d") ,
                    DbgExpensiveGetClsid(F).Data1, iRecurse));

            // If this ASSERT fires then a filter could not be removed from the filter graph.
            // This is not a fatal error but the filter graph will have an extra filter
            // in it.
            EXECUTE_ASSERT( SUCCEEDED( RemoveFilterInternal( F.pf ) ) );   // Releases AddFilter refcount

            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+55);
            return hr;
        }
    } else {
        // A filter from the filter graph
        Log( IDS_CONVIA, ppinOut, ppinIn, F.pf );
        hr = ConnectByFindingPin(ppinOut, ppinIn, pmtConnection, F, dwFlags, iRecurse);
        if (FAILED(hr)) {
            DbgLog(( LOG_TRACE, 4
                  , TEXT("ConnectUsing failed (C..ByFind failure) level %d")
                  , iRecurse));
            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+65);
            return hr;
        }
    }
    DbgLog(( LOG_TRACE, 4, TEXT("ConnectUsing succeeded level %d")
           , iRecurse));
    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+15);
    return hr;  // This is the hr from ConnectByFindingPin

} // ConnectUsingFilter



//========================================================================
//
// ConnectViaIntermediate
//
// Connect ppinOut to ppinIn using another filter as an intermediate
//========================================================================
HRESULT CFilterGraph::ConnectViaIntermediate
    ( IPin * ppinOut     // the output pin
    , IPin * ppinIn      // the input pin
    , const AM_MEDIA_TYPE* pmtConnection
    , DWORD dwFlags
    , int    iRecurse    // the recursion level.  0 means no recursion yet.
    )
{
    // Check for legal flags.
    ASSERT( IsValidConnectFlags( dwFlags ) );

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+4);
    DbgLog(( LOG_TRACE, 4, TEXT("Connect Via... pins %x...>%x level %d")
           , ppinOut, ppinIn, iRecurse ));

    HRESULT hr;         // return code from thing(s) we call
    Filter F;           // represents the intermediate filter
    F.bInputNeeded = TRUE;
    F.bOutputNeeded = TRUE;

    /* Find out what we can about the media types it will tolerate */
    hr = GetMediaTypes(ppinOut, &F.pTypes, &F.cTypes);
    if (FAILED(hr)) {
        Log (IDS_CONNOMT, ppinOut, hr );
        MSR_INTEGERX(mFG_idIntel, 100*iRecurse+24);
        return hr;
    }
    /* Try to eliminate incompatible types - we're just never going to
       support weird conversions during automatic connection - it's
       way too slow so only try filters actually in the graph in this
       case
    */
    F.bLoadNew = TRUE;
    if (F.pTypes[0] == MEDIATYPE_Audio || F.pTypes[0] == MEDIATYPE_Video) {
        GUID MajorType, SubType;
        HRESULT hr1 = GetAMediaType(ppinIn, MajorType, SubType);
        if (SUCCEEDED(hr)) {
            if (MajorType != F.pTypes[0] &&
                MajorType != GUID_NULL) {
                F.bLoadNew = FALSE;
            }
        }
    }

    // For each candidate filter, either here or in registry
    for ( ; ; ) {

        if (mFG_bAborting) {
            break;
        }

        NextFilter(F, dwFlags);
        if (F.State==F_INFINITY) {
            break;
        }

        if( F_CACHED == F.State ) {
            F.RemoveFromCache( &m_Config );
        }

        hr = ConnectUsingFilter(ppinOut, ppinIn, pmtConnection, F, dwFlags, iRecurse);
        if (SUCCEEDED(hr)) {
            DbgLog(( LOG_TRACE, 4, TEXT("ConnectVia succeeded level %d")
                   , iRecurse));
            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+14);
            return hr;

        } else {
            if( F_CACHED == F.State ) {
                hr = F.AddToCache( &m_Config );
                if( FAILED( hr ) ) {
                    return hr;
                }
            }       
        
            if( IsAbandonCode(hr) ) {
                // no point in trying heroics if the filter is not in a state
                // where anything will connect to it.

                return hr;
            }
        }
    }

    DbgLog(( LOG_TRACE, 4, TEXT("ConnectVia: failed level %d")
           , iRecurse));
    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+34);
    return (mFG_bAborting ? E_ABORT : VFW_E_CANNOT_CONNECT);
} // ConnectViaIntermediate

//========================================================================
//
// ConnectRecursively
//
// Connect these two pins directly or indirectly, using transform filters
// if necessary.   Trace the recursion level  Fail if it gets too deep.
//========================================================================
HRESULT CFilterGraph::ConnectRecursively
    ( IPin * ppinOut     // the output pin
    , IPin * ppinIn      // the input pin
    , const AM_MEDIA_TYPE* pmtConnection
    , DWORD dwFlags
    , int    iRecurse    // the recursion level.  0 means no recursion yet.
    )

{
    // Check for legal flags.
    ASSERT( IsValidConnectFlags( dwFlags ) );

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+3);
    HRESULT hr;         // return code from thing(s) we call
    Log( IDS_CONTRYDIRECT, ppinOut, ppinIn);

    //-----------------------------------------------------------
    // Try direct connection
    //-----------------------------------------------------------
    hr = ConnectDirectInternal(ppinOut, ppinIn, pmtConnection);  // no version count

    if (SUCCEEDED(hr)) {
        MSR_INTEGERX(mFG_idIntel, 100*iRecurse+13);
        Log( IDS_CONDIRECTSUC, ppinOut, ppinIn);
        return hr;
    } else if (IsAbandonCode(hr)) {
        // no point in trying any heroics if the filters won't connect to
        // anything else because their own inputs are not connected.
        // Everything will fall down the same hole.
        Log( IDS_CONCON, ppinOut, ppinIn);
        return hr;
    }

    if (iRecurse>CONNECTRECURSIONLIMIT) {
        MSR_INTEGERX(mFG_idIntel, 100*iRecurse+23);
        Log( IDS_CONTOODEEP, ppinOut, ppinIn);
        return VFW_E_CANNOT_CONNECT;
    }

    hr = ConnectViaIntermediate(ppinOut, ppinIn, pmtConnection, dwFlags, 1+iRecurse);
    if (SUCCEEDED(hr)) {
       Log( IDS_CONINDIRECTSUC, ppinOut, ppinIn);
    } else {
       Log( IDS_CONINDIRECTFAIL, ppinOut, ppinIn, hr);
    }
    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+93);
    return hr;
} // ConnectRecursively



//========================================================================
//
// Connect
//
// Connect these two pins directly or indirectly, using transform filters
// if necessary.  Do not AddRef or Release() them.  The caller should
// Release() them if he's finished.  Connect() will AddRef them underneath us.
//========================================================================

bool CFilterGraph::IsValidConnectFlags( DWORD dwConnectFlags )
{
    const DWORD VALID_CONNECT_FLAGS_MASK = AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS;

    return ((VALID_CONNECT_FLAGS_MASK & dwConnectFlags) == dwConnectFlags);
}

STDMETHODIMP CFilterGraph::Connect
    ( IPin * ppinOut     // the output pin
    , IPin * ppinIn      // the input pin
    )
{
    return ConnectInternal( ppinOut,
                            ppinIn,
                            NULL, // No first connection media type.
                            0 ); // No flags.
}

HRESULT CFilterGraph::ConnectInternal
    ( IPin * ppinOut     // the output pin
    , IPin * ppinIn      // the input pin
    , const AM_MEDIA_TYPE* pmtFirstConnection
    , DWORD dwFlags
    )
{
    // Check for legal flags.
    ASSERT( IsValidConnectFlags( dwFlags) );

    mFG_bAborting = FALSE;             // possible race.  Doesn't matter
    CheckPointer(ppinOut, E_POINTER);
    CheckPointer(ppinIn, E_POINTER);

    HRESULT hr;         // return code from thing(s) we call
    if (FAILED(hr=CheckPinInGraph(ppinOut)) || FAILED(hr=CheckPinInGraph(ppinIn))) {
        return hr;
    }
    MSR_INTEGERX(mFG_idIntel, 8);
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);
        ++mFG_RecursionLevel;

        Log( IDS_CONNECT, ppinOut, ppinIn);
        DbgDump();
        mFG_RList.Active();
        hr = ConnectRecursively(ppinOut, ppinIn, pmtFirstConnection, dwFlags, 0);

        if (SUCCEEDED(hr)) {
            IncVersion();
            Log( IDS_CONNECTSUC, ppinOut, ppinIn);

        } else {
            Log( IDS_CONNECTFAIL, ppinOut, ppinIn, hr);
        }

        AttemptDeferredConnections();
        mFG_RList.Passive();
        ASSERT(mFG_RList.m_lListMode == 0);
        DbgLog(( LOG_TRACE, 2, TEXT("Connect Ended hr=%x")
               , hr));
        DbgDump();
        --mFG_RecursionLevel;
    }
    MSR_INTEGERX(mFG_idIntel, 18);

    NotifyChange();
    if (SUCCEEDED(hr)) {
        // including partial success
        mFG_bDirty = TRUE;
    }
    return hr;
} // Connect



//======================================================================
// Intelligent Rendering design notes
//
// This is somewhat like intelligent connection, EXCEPT
// 1. No target pin to connect to
// 2. No requirement that the plumbing connects the input stream to
//    exactly one output stream.  Instead we simply render each output stream.
//    The recursion may either return success, leaving a tree, or failure
//    in which case at some point the tree must be backed out.
// 3. When backing out a blind alley we need to back out any other
//    output pins already connected (which could be a whole tree of
//    connections).
// 4. A consequence is that the call stack cannot contain enough state
//    to control the back-out.  i.e. we may construct a chain connected to
//    output pin A of a filter F and return leaving it constructed and
//    apparently good, but only later discover that we cannot render pin B
//    of the filter and therefore need to try a new filter instead of F
//    which means backing out what we did for pin A.
//
// At every stage we have a list of what we have done (or equivalently
// what we need to do to undo it) and we keep track
// of positions in this list that we might want to back up to.
// An operation typically records the position in the list CActionList at
// the start of the operation so that it can back out everything up to there
// if the operation goes wrong.  An operation will then either succeed and
// grow the list or fail and leave the list unchanged.
// There are only two real actions:
//    Disconnect pin
//    Remove and Release filter
// We record the position to back up to (and on failure back it out)
// 1. When we try to add a connection
// 2. When we try to add a filter
// 3. When (in CompleteRendering) we add a series of branches and where
//    a failure in a later branch requires backing out the previous
//    successful ones.
// ??? It occurs to me that this system could probably be tightened up.
// ??? I think we only really need to back things out (and hence need to
// ??? record a backout position to back it out up to) when either
// ??? a. We have something else to try (in RenderViaIntermediate) or
// ??? b. The whole thing has failed (in RenderRecursively, top level).
// ??? But we will need the others if we ever improve the retry stuff
// ??? to handle convergent streams properly.  Suppose filter A has
// ??? two pins.  We render pin 1 successfully, but pin 2 has a StreamBuilder
// ??? which fails.  It wanted pin 1 to be rendered so as to introduce a
// ??? particular filter that it wants to converge onto.  At present we
// ??? do NOT go back and se if we can re-do pin 1 differently.
//
// Filters go on the list with ONE ref count (i.e. AddFilter only)
// There is no separate count for the backout list.
//
// As the search recurses along we keep track of how well we are doing.
// Whenever we get more rendered than we ever have achieved before we
// take a snapshot of the list of backout actions.  At this point we need
// to beef it up a little as the information needed to recreate something
// is actually a litle different from the information needed to undo it.
// If the filter is there, we can record a pin as an IPin*, but if the
// filter needs to be recreated we need a persistent representation of
// the pin.  If we get to the end and the best we ever did was a partial
// rendering, we recreate that.  This solves the "no sound card" problem
// and other related problems (SMPTE streams,...).
//
// The search state is
//     The current state of the graph
//         This is the CActionList which records the operations
//         needed to build the graph or equally well, the actions
//         needed to unbuild it.  For historical reasons the
//         nomnclature refers to the way to unbuild (destroy) it.
//     The point in the graph where it is growing
//         This depends on the current operation
//             Render               : <ppinOut>
//             RenderRecursively    : <ppinOut>
//             RenderViaIntermediate: <ppinOut>
//             RenderUsingFilter    : <ppinOut, F>
//             RenderByFindingPin   : <ppinOut, F>
//             CompleteRendering    : <F, pPinIn>
//     The stream value at this point
//         This is 1.0/(the number of subdivisions that the stream has had
//         upstream of here).
//         If it was split into three and then one of those into seven and
//         the growth point is one of the seven, the value would be (1.0/21.0)
//     The current (two-part) value of the graph so far.
//         The value is the total proportion of streams rendered (a fraction)
//         and the number of filters in the graph.




//========================================================================
// TakeSnapshot
// Record information needed to do a Backout back to this popsition
//========================================================================
void CFilterGraph::TakeSnapshot(CSearchState &Acts, snapshot &Snapshot)
{
    Snapshot.StreamsRendered = Acts.StreamsRendered;
    Snapshot.StreamsToRender = Acts.StreamsToRender;
    Snapshot.nFilters = Acts.nFilters;
    Snapshot.Pos = Acts.GraphList.GetTailPosition();
}  // TaksSnapshot

//========================================================================
//
// Backout
//
// Do all the actions in Acts so as to back out what has been done.
// From the end of the list back to but NOT including the item at Snapshot.Pos.
// Do them in reverse list order.  Leave Acts with Pos as the last element.
// Pos==NULL means back them all out and leave Acts empty.
// Put any filters that were in Acts into Spares.  Keep 1 ref count on each.
// As backing out a large chunk can also back out some entire successfully
// rendered streams, the StreamsRendered must also be reset - and therefore
// also the StreamsToRender.
//========================================================================
HRESULT CFilterGraph::Backout( CSearchState &Acts
                             , CSpareList &Spares
                             , snapshot Snapshot
                             )
{

    MSR_INTEGERX(mFG_idIntel, 9);
    HRESULT hr;
    HRESULT hrUs = NOERROR;  // our return code

    Acts.StreamsRendered = Snapshot.StreamsRendered;
    Acts.StreamsToRender = Snapshot.StreamsToRender;
    Acts.nFilters = Snapshot.nFilters;

    while(Acts.GraphList.GetCount()>0){
        Action *pAct;
        POSITION posTail = Acts.GraphList.GetTailPosition();
        if (posTail==Snapshot.Pos)
            break;
        pAct = Acts.GraphList.Get(posTail);
        switch(pAct->Verb){
            case DISCONNECT:
                Log( IDS_BACKOUTDISC, pAct->Object.c.ppin );

                // kill any scheduled reconnects of this connection
                mFG_RList.Purge(pAct->Object.c.ppin);
                hr = pAct->Object.c.ppin->Disconnect();
                if (FAILED(hr)) {
                   hrUs = hr;
                }
                break;
            case REMOVE:
                Log( IDS_BACKOUTREMF, pAct->Object.f.pfilter );

                // Make sure it doesn't go away.
                pAct->Object.f.pfilter->AddRef();

                // Undo AddFilter, this loses a RefCount
                hr = RemoveFilterInternal(pAct->Object.f.pfilter);
                if (FAILED(hr)) {
                   hrUs = hr;
                }

                if( pAct->FilterOriginallyCached() ) {
                    hr = m_Config.AddFilterToCache( pAct->Object.f.pfilter );

                    pAct->Object.f.pfilter->Release();
                    pAct->Object.f.pfilter = NULL;

                    if( FAILED( hr ) ) {
                        // A previously cached filter could not be added to the filter cache.
                        // This is not a fatal error but filter cache users will notice that
                        // a previously cached filter is not in the filter cache.
                        ASSERT( false );
                        hrUs = hr;                        
                    }

                } else {
                    // Keep it alive on Spares
                    Spare *psp = new Spare;
                    if (psp==NULL) {
                        // OK - don't keep it alive.  Release it and try to
                        // re-create it when we need it again.
                        pAct->Object.f.pfilter->Release();
                        pAct->Object.f.pfilter = NULL;
                    } else {
                        psp->clsid = pAct->Object.f.clsid;
                        psp->pfilter = pAct->Object.f.pfilter;
                        psp->pMon = pAct->Object.f.pMon;
                        psp->pMon->AddRef();
                        Spares.AddTail(psp);
                    }
                }

                if( NULL != pAct->Object.f.pMon ) {
                    pAct->Object.f.pMon->Release();
                    pAct->Object.f.pMon = NULL;
                }

                if ( pAct->Object.f.Name) {
                    delete[] pAct->Object.f.Name;
                    pAct->Object.f.Name = NULL;
                }

                break;
            case BACKOUT:
                Log( IDS_BACKOUTSB, pAct->Object.b.ppin);
                pAct->Object.b.pisb->Backout(pAct->Object.b.ppin, this);
                pAct->Object.b.pisb->Release();
                break;
        }
        pAct = Acts.GraphList.Remove(posTail);
        delete pAct;
    }
    MSR_INTEGERX(mFG_idIntel, 19);
    return hrUs;
} // Backout



//========================================================================
//
// DeleteBackoutList
//
// Empty the list
//========================================================================
HRESULT CFilterGraph::DeleteBackoutList( CActionList &Acts)
{
    while(Acts.GetCount()>0){
        Action * pAct;
        pAct = Acts.RemoveHead();
        if (pAct->Verb==BACKOUT) {
            pAct->Object.b.pisb->Release();
        } else if (pAct->Verb==REMOVE) {
            if (pAct->Object.f.pMon) {
                pAct->Object.f.pMon->Release();
            }
            if (pAct->Object.f.Name) {
                delete[] pAct->Object.f.Name;
            }
        }
        delete pAct;
    }
    return NOERROR;
} // DeleteBackoutList



//========================================================================
//
// GetFilterFromSpares
//
// IF the Spares list contains a filter for clsid then delete it from the
// list and return a pointer to its IBaseFilter interface with 1 ref count
// else leave the list alone and return NULL.
//========================================================================
IBaseFilter * CFilterGraph::GetFilterFromSpares
    ( IMoniker *pMon
    , CSpareList &Spares
    )
{
    Spare * psp;
    POSITION pos;
    MSR_INTEGERX(mFG_idIntel, 1001);
    pos = Spares.GetHeadPosition();
    for (; ; ) {
        POSITION pDel = pos;            // in case we need to delete this one
        psp = Spares.GetNext(pos);      // pos is side-effected to next
        if (psp==NULL)
            break;
        if (psp->pMon == pMon ||
            psp->pMon->IsEqual(pMon) == S_OK)
        {
            psp = Spares.Remove(pDel);
            IBaseFilter * pif;
            pif = psp->pfilter;
            psp->pMon->Release();
            delete psp;
            MSR_INTEGERX(mFG_idIntel, 1002);
            return pif;
        }
    }
    MSR_INTEGERX(mFG_idIntel, 1003);
    return NULL;
} // GetFilterFromSpares



//========================================================================
//
// GetFilter
//
// IF the Spares list contains a filter for clsid then delete it from the
// list and return a pointer to its IBaseFilter interface with 1 ref count
// else instantiate the filter and return its IBaseFilter * with 1 ref count.
//========================================================================
HRESULT CFilterGraph::GetFilter
    ( IMoniker *pMon
    , CSpareList &Spares
    , IBaseFilter **ppf
    )
{
    HRESULT hr = NOERROR;
    *ppf = GetFilterFromSpares(pMon, Spares);
    if (*ppf==NULL){
        MSR_INTEGERX(mFG_idIntel, 1004);

        hr = CreateFilterAndNotify(pMon, ppf);

        MSR_INTEGERX(mFG_idIntel, 1005);
    }

    return hr;
} // GetFilter


// Put the filters which are already in the graph into the
// action list as REMOVE entries.
// Because all backup actions are given a specified
// point to back up to, we will never back out these initial entries,
// we will simply discard them once we have finished rendering.
// We will never instantiate these filters from this list either,
// so we don't ned a CLSID, so the CLSID will be recorded as NULL.
// They already have names in the graph, so we don't need those either.
HRESULT CFilterGraph::InitialiseSearchState(CSearchState &css)
{
    // Traverse all the filters in the graph
    POSITION Pos = mFG_FilGenList.GetHeadPosition();
    while(Pos!=NULL) {
        /* Retrieve the current IBaseFilter, side-effect Pos on to the next */
        FilGen * pfg = mFG_FilGenList.GetNext(Pos);

        // Add this filter into the action list
        Action * pAct = new Action;
        if (pAct==NULL) {
            // We're screwed
            return E_OUTOFMEMORY;
        }
        pAct->Verb = REMOVE;
        pAct->Object.f.Name = NULL;
        pAct->Object.f.pfilter = pfg->pFilter;
        pAct->Object.f.clsid = CLSID_NULL;
        pAct->Object.f.pMon = 0;
        pAct->Object.f.fOriginallyInFilterCache = false;
        css.GraphList.AddTail(pAct);
        ++css.nInitialFilters;
    }
    return NOERROR;
}



// find pf in cal, return the position 0 = first in list.
// -1 means not in the list.
int CFilterGraph::SearchIFilterToNumber(CActionList &cal, IBaseFilter *pf)
{
    POSITION pos;
    Action *pA;
    int n = 0;
    pos = cal.GetHeadPosition();
    while (pos!=NULL) {
        pA = cal.GetNext(pos);
        if (pA->Verb==REMOVE && pA->Object.f.pfilter==pf)
            return n;
        ++n;
    }
    // ASSERT(!"Failed to find filter in Actions List");
    // This happens when we encounter the source filter with the original
    // pin we were trying to render.
    return -1;
} // SearchIFilterToNumber

// Get the nth element of the list.  0 is the first
IBaseFilter * CFilterGraph::SearchNumberToIFilter(CActionList &cal, int nFilter)
{

    DbgLog(( LOG_TRACE, 3, TEXT("SearchNumber %d ToIFilter "), nFilter));
    POSITION pos;
    pos = cal.GetHeadPosition();
    Action *pA = NULL;
    while (nFilter>=0) {
        pA = cal.GetNext(pos);
        --nFilter;
    }
    ASSERT(pA!=NULL);
    ASSERT(pA->Verb==REMOVE);
    return pA->Object.f.pfilter;
} // SearchNumberToIFilter


//========================================================================
//
// DeleteSpareList
//
// Release all the filters on the list and delete the elements of the list too.
// Must do this on the application thread so that DestroyWindow() will
// work for any windows the filters created
//========================================================================
HRESULT CFilterGraph::DeleteSpareList( CSpareList &Spares)
{
    if (S_OK == CFilterGraph::IsMainThread()) {
        while (0<Spares.GetCount()) {
            Spare * ps;
            ps = Spares.RemoveHead();
            ps->pfilter->Release();
            ps->pMon->Release();
            delete ps;
        }
    } else {
        SendMessage(m_hwnd,
                    AWM_DELETESPARELIST,
                    (WPARAM)&Spares,
                    (LPARAM)0
                   );
    }
    return NOERROR;
} // DeleteSpareList


// Free up everything and delete the list
void CFilterGraph::FreeList(CSearchState &css)
{
    POSITION pos;
    pos = css.GraphList.GetHeadPosition();
    while (pos!=NULL) {
        Action *pA;
        POSITION posRemember = pos;
        pA = css.GraphList.GetNext(pos);   // pA gets the data, pos is side-efected to next
        if (pA->Verb==DISCONNECT) {
            if (pA->Object.c.id1 !=NULL) QzTaskMemFree(pA->Object.c.id1);
            if (pA->Object.c.id2 !=NULL) QzTaskMemFree(pA->Object.c.id2);
        } else if (pA->Verb==BACKOUT) {
            if (!pA->Object.b.bFoundByQI) {
                pA->Object.b.pisb->Release();
            }
        } else {  // REMOVE
            if (pA->Object.f.pMon) {
                pA->Object.f.pMon->Release();
            }
            if (pA->Object.f.Name) {
                delete[] pA->Object.f.Name;
            }
        }
        delete pA;
        css.GraphList.Remove(posRemember);
    }
} // FreeList



// Copy the score and copy the action list by doing a minimal update.
// Scan through the action list we already have (To) and see what
// initial portion is already the same.  Delete and free the
// rest that we already have.  Copy the rest of From and find
// the persistent ids of everything.
// ppinOrig is the original pin that we were rendering.
// The SearchState may contain connections to it which are held as -1.
void CFilterGraph::CopySearchState(CSearchState &To, CSearchState &From)
{

    BOOL bFailed = FALSE;
    MSR_INTEGERX(mFG_idIntel, 1006);
    DbgLog(( LOG_TRACE, 3
           , TEXT("Copy search state... ToCount=%d FromCount=%d nFilters=%d, rendered=%g")
           , To.GraphList.GetCount()
           , From.GraphList.GetCount()
           , From.nFilters
           , From.StreamsRendered
           ));
    To.StreamsToRender = -1.0;                   // hygeine.
    To.StreamsRendered = From.StreamsRendered;
    To.nFilters = From.nFilters;
    To.nInitialFilters = From.nInitialFilters;

    POSITION posF;
    POSITION posT;

    //.................................................................
    // Look for a prefix portion that's unchanged
    // set posF and posT to the first non-matching positions.
    //.................................................................

    posF = From.GraphList.GetHeadPosition();
    posT = To.GraphList.GetHeadPosition();
    for (; ; ) {
        DbgLog(( LOG_TRACE, 3, TEXT("Looking at elements for==?")));
        if (posF==NULL || posT==NULL) break;
        Action *pF = From.GraphList.Get(posF);
        Action *pT = To.GraphList.Get(posT);

        if (pF->Verb!=pT->Verb) break;
        if (pF->Verb==REMOVE) {
            DbgLog(( LOG_TRACE, 3, TEXT("To Clsid: %8x %x %x")
                   , pT->Object.f.clsid.Data1
                   , pT->Object.f.clsid.Data2
                   , pT->Object.f.clsid.Data3
                  ));
            DbgLog(( LOG_TRACE, 3, TEXT("From Clsid: %8x %x %x")
                   , pF->Object.f.clsid.Data1
                   , pF->Object.f.clsid.Data2
                   , pF->Object.f.clsid.Data3
                  ));
            if (pF->Object.f.pfilter!=pT->Object.f.pfilter) break;
            ASSERT(pF->Object.f.pfilter!=NULL);
        }
        else if (pF->Verb==DISCONNECT){

            break;

            // The alternative is to actually check that the filter has
            // the same pins as recorded and that they are connected to
            // the same other pins on the same filter.  Starts getting messy.
            // Maybe remove this whole lot and just rebuild the list from scratch???

//             DbgLog(( LOG_TRACE, 2, TEXT("DISCONNECT entry")));
//             if (pF->Object.c.ppin!=pT->Object.c.ppin) break;
        }
        else { // Verb==BACKOUT

            break;

            // The alternative is to actually check.
            // Maybe remove this whole lot and just rebuild the list from scratch???

//             DbgLog(( LOG_TRACE, 2, TEXT("Backout entry")));
//             if (pF->Object.c.ppin!=pT->Object.c.ppin) break;
        }
        posF = From.GraphList.Next(posF);
        posT = To.GraphList.Next(posT);
    }

    // posF and posT are the first non-matching positions
    // either or both can be null

    //.................................................................
    // free up everything left on the end of To
    //.................................................................
    while (posT!=NULL) {
        DbgLog(( LOG_TRACE, 3, TEXT("Freeing end of To list")));
        POSITION posRemember = posT;
        Action * pT;
        pT = To.GraphList.GetNext(posT);   // pT gets the data, posT is side-efected to next
        if (pT->Verb==DISCONNECT) {
            if (pT->Object.c.id1 !=NULL) QzTaskMemFree(pT->Object.c.id1);
            if (pT->Object.c.id2 !=NULL) QzTaskMemFree(pT->Object.c.id2);
        } else if (pT->Verb==REMOVE) {
            if( NULL != pT->Object.f.pMon ) {
                pT->Object.f.pMon->Release();
            }
            if (pT->Object.f.Name !=NULL) delete[] pT->Object.f.Name;
        } else if (pT->Verb==BACKOUT) {
            if (!pT->Object.b.bFoundByQI) {
                pT->Object.b.pisb->Release();
            }
        }
        delete pT;
        To.GraphList.Remove(posRemember);
    }

    //.................................................................
    // Copy everything left on From to the end of To
    //.................................................................
    while (posF!=NULL) {
        Action * pF;
        pF = From.GraphList.GetNext(posF);   // pF gets the data, posF is side-efected to next
        Action *pA = new Action;
        if (pA==NULL) {
            bFailed = TRUE;
            break;
        }

        pA->Verb = pF->Verb;
        // Only the id might need marshalling, but it's not used in pF
        if (pF->Verb==DISCONNECT) {

            DbgLog(( LOG_TRACE, 3, TEXT("Copying DISCONNECT")));
            pA->Object.c = pF->Object.c;    // copy unmarshalled fields
            // Get external ids for the pins
            HRESULT hr = pA->Object.c.ppin->QueryId(&(pA->Object.c.id1));
            if (FAILED(hr)) {
                bFailed = TRUE;
                break;
            }
            IPin * pip;
            hr = pA->Object.c.ppin->ConnectedTo(&pip);
            if (FAILED(hr) || pip==NULL) {
                bFailed = TRUE;
                break;
            }
            hr = pip->QueryId(&(pA->Object.c.id2));
            if (FAILED(hr)) {
                bFailed = TRUE;
                break;
            }

            // Get external ids (well, numbers) for the filters
            PIN_INFO pi;
            hr = pA->Object.c.ppin->QueryPinInfo(&pi);
            if (FAILED(hr)) {
                bFailed = TRUE;
                break;
            }

            pA->Object.c.nFilter1 = SearchIFilterToNumber(To.GraphList, pi.pFilter);
            QueryPinInfoReleaseFilter(pi);
            hr = pip->QueryPinInfo(&pi);
            if (FAILED(hr)) {
                bFailed = TRUE;
                break;
            }

            pA->Object.c.nFilter2 = SearchIFilterToNumber(To.GraphList, pi.pFilter);
            QueryPinInfoReleaseFilter(pi);
            pip->Release();
            DbgLog(( LOG_TRACE, 4, TEXT("Copying DISCONNECT (%x %d,%ls)-(%d,%ls)")
                   , pA->Object.c.ppin
                   , pA->Object.c.nFilter1
                   , pA->Object.c.id1
                   , pA->Object.c.nFilter2
                   , pA->Object.c.id2
                  ));
        } else if (pF->Verb==REMOVE){
            IPersist * pip;
            pA->Object.f = pF->Object.f;    // copy unmarshalled fields

            pA->Object.f.fOriginallyInFilterCache = pF->FilterOriginallyCached();

            if(pA->Object.f.pMon)
              pA->Object.f.pMon->AddRef();
            pA->Object.f.pfilter->QueryInterface(IID_IPersist, (void**)&pip);
            if (pip) {
                pip->GetClassID(&(pA->Object.f.clsid));
                pip->Release();
                DbgLog(( LOG_TRACE, 4, TEXT("Copying REMOVE Clsid: %8x %x %x")
                       , pA->Object.f.clsid.Data1
                       , pA->Object.f.clsid.Data2
                       , pA->Object.f.clsid.Data3
                      ));
            } else {
                pA->Object.f.clsid = CLSID_NULL;  // hope we never need it!
                DbgLog(( LOG_TRACE, 4, TEXT("Copying REMOVE- but CAN'T GET CLSID!!!")));
            }
            if (pF->Object.f.Name!=NULL) {
                pA->Object.f.Name = new WCHAR[ 1+lstrlenW(pF->Object.f.Name) ];
                if (pA->Object.f.Name!=NULL) {
                    lstrcpyW(pA->Object.f.Name, pF->Object.f.Name);
                }
                // else the name just gets lost as though it didn't have one
            }
        } else {  // BACKOUT
            DbgLog(( LOG_TRACE, 3, TEXT("Copying BACKOUT")));
            pA->Object.b = pF->Object.b;    // copy unmarshalled fields
            // Get external id for the pin
            HRESULT hr = pA->Object.b.ppin->QueryId(&(pA->Object.b.id));
            if (FAILED(hr)) {
                bFailed = TRUE;
                break;
            }

            // Get external id (well, number) for the filter
            PIN_INFO pi;
            hr = pA->Object.b.ppin->QueryPinInfo(&pi);
            if (FAILED(hr)) {
                bFailed = TRUE;
                break;
            }

            pA->Object.b.nFilter = SearchIFilterToNumber(To.GraphList, pi.pFilter);
            QueryPinInfoReleaseFilter(pi);

            if (!pA->Object.b.bFoundByQI) {
                pA->Object.b.pisb->AddRef();  // This one is still live
            }

            DbgLog(( LOG_TRACE, 4, TEXT("Copying BACKOUT (%x %d,%ls)")
                   , pA->Object.b.ppin
                   , pA->Object.b.nFilter
                   , pA->Object.b.id
                  ));

        }
        To.GraphList.AddTail(pA);
    }
    MSR_INTEGERX(mFG_idIntel, 1007);
    if (bFailed) {
        To.StreamsRendered = -1;   // messed up!!!
    }

} // CopySearchState

HRESULT CFilterGraph::DumpSearchState(CSearchState &css)
{
#ifndef DEBUG
    return NOERROR;
#else
    DbgLog(( LOG_TRACE, 3, TEXT("Start of search state dump")));
    HRESULT hr = NOERROR;
    POSITION pos = css.GraphList.GetHeadPosition();
    while (pos!=NULL) {
        Action *pA = css.GraphList.GetNext(pos);

        if (pA->Verb == REMOVE) { 
            DbgLog(( LOG_TRACE, 3
                   , "REMOVE pf %x (Clsid: %08x...)  Originally In Filter Cache: %d"
                   , pA->Object.f.pfilter
                   , pA->Object.f.clsid.Data1
                   , pA->FilterOriginallyCached()
                  ));

        } else if (pA->Verb == DISCONNECT) { 
            DbgLog(( LOG_TRACE, 3
                   , "DISCONNECT (%d,%ls)-(%d,%ls)"
                   , pA->Object.c.nFilter1
                   , pA->Object.c.id1
                   , pA->Object.c.nFilter2
                   , pA->Object.c.id2
                  ));

        } else { 
            DbgLog(( LOG_TRACE, 3
                   , "BACKOUT (%d,%ls) pisb=0x%x ppin=0x%x bFoundByQI=%d)"
                   , pA->Object.b.nFilter
                   , pA->Object.b.id
                   , pA->Object.b.pisb
                   , pA->Object.b.ppin
                   , pA->Object.b.bFoundByQI
                  ));

        }
    }

    DbgLog(( LOG_TRACE, 3, TEXT("End of search state dump")));

    return hr;
#endif
} // DumpSearchState


//========================================================================
// BuildFromSearchState
//
// Create a new filtergraph
// from css.  (This should have been almost the same code as for Restore,
// and maybe it should be altered to be that way.  That would mean beating
// a path away from the current format of the stored filtergraphs.
//
// Does NOT clear the list out.
//
//========================================================================
HRESULT CFilterGraph::BuildFromSearchState( IPin * pPin
                                          , CSearchState &css
                                          , CSpareList &Spares
                                          )
{
    // The action list is the list of things to undo the graph at the
    // point when it was the best we ever saw.  These are also the
    // actions (well inverse-actions - when it says DISCONNECT we must
    // CONNECT) needed to rebuild it.
    Log( IDS_RENDPART );
    Log( IDS_BESTCANDO );

    DumpSearchState(css);

    if (css.StreamsRendered<=0.000001) {  // probably 0.0 is exact, but...
        return E_FAIL;           // This is a messed up state.
    }


    HRESULT hr = NOERROR;
    POSITION pos = css.GraphList.GetHeadPosition();
    int nActions = 0;
    while (pos!=NULL) {
        if (mFG_bAborting) {
           hr = E_ABORT;
           break;  // Nothing to tidy up here as we do not clear the list anyway
        }
        Action *pA = css.GraphList.GetNext(pos);

        // The action list begins with pre-existers (if any)
        ++nActions;
        if (nActions<=css.nInitialFilters) {
            continue;
        }

        if (pA->Verb == REMOVE) { // meaning that we UN-REMOVE it
            Log( IDS_ADDINGF, pA->Object.f.clsid.Data1);

            if( pA->FilterOriginallyCached() ) {
                hr = m_Config.RemoveFilterFromCache( pA->Object.f.pfilter );
            
                // IGraphConfig::RemoveFilterFromCache() returns S_OK if the filter
                // was successfully removed from the filter cache.
                if( S_OK != hr ) {
                    // This should almost never occur because
                    // 1. Cached filters can only be placed on the the GraphList list once.
                    // 2. Cached filters are placed back in the cache if a Render() operation
                    //    fails.
                    // 
                    // This ASSERT may fire if a cached filter could not be successfully placed
                    // back in the filter cache.  However, it's unlikely this will occur.
                    ASSERT( false );
                    return E_UNEXPECTED;
                }
            
            } else {
                IBaseFilter * pf;

                hr = GetFilter( pA->Object.f.pMon, Spares, &pf);
                if (FAILED(hr)) {
                    // ??? Back out everything!
                    Log( IDS_GETFFAIL, hr);
                    return hr;
                }
                pA->Object.f.pfilter = pf;

                // The list now contains the real IBaseFilter*, as opposed to some
                // IBaseFilter* that may have been reused elsewhere and hence be
                // totally bogus.  We can now retrieve this by position in
                // the list and use it in connecting filters up.
            }

            // If AddFilterInternal AddRefs the filter if it is successful.
            hr = AddFilterInternal(pA->Object.f.pfilter, pA->Object.f.Name, true);

            pA->Object.f.pfilter->Release();

            if (FAILED(hr)) {
                Log( IDS_ADDFFAIL );
                // ??? Back out everything!?
                return hr;
            }

            Log( IDS_ADDFSUC, pA->Object.f.pfilter);

        } else if (pA->Verb == DISCONNECT) { // meaning that we will UN-DISCONNECT it

            Log( IDS_CONNING );
            IPin *ppin1;
            IBaseFilter * pf1;
            if (pA->Object.c.nFilter1 == -1) {
                ppin1 = pPin;          // the original pin.
                Log( IDS_ORIGINALP, ppin1);
            } else {
                pf1 = SearchNumberToIFilter
                                    (css.GraphList, pA->Object.c.nFilter1);
                Log( IDS_FOUNDF1, pf1);
                ASSERT(pf1!=NULL);
                hr = pf1->FindPin(pA->Object.c.id1, &ppin1);
                Log( IDS_FOUNDP1, ppin1);
                if(FAILED(hr)) {
                    // occurs if pin config. changes on reconnect
                    DbgLog((LOG_TRACE, 1, TEXT("backout DISCONNECT: FindPin failed.")));
                    return E_FAIL;
                }
                ASSERT(ppin1!=NULL);
            }

            IBaseFilter * pf2 = SearchNumberToIFilter
                                (css.GraphList, pA->Object.c.nFilter2);
            Log( IDS_FOUNDF2, pf2);

            ASSERT(pf2!=NULL);
            // By now these IBaseFilter*s are guaranteed to be non-bogus!

            IPin *ppin2;
            hr = pf2->FindPin(pA->Object.c.id2, &ppin2);
            if(FAILED(hr)) {
                // occurs if pin config. changes on reconnect
                DbgLog((LOG_TRACE, 1, TEXT("backout DISCONNECT: FindPin failed.")));
                ppin1->Release();
                return E_FAIL;
            }            

            ASSERT(ppin2!=NULL);
            Log( IDS_FOUNDP2, ppin2);

            // No need to check for circularity as we have been here before.
            hr = ConnectDirectInternal(ppin1, ppin2, NULL);

            // We're done with the pins that we found.
            ppin1->Release();
            ppin2->Release();

            // but did the connect work?
            if (FAILED(hr)) {
                // ??? Back out everything!
                Log( IDS_CONNFAIL, hr);
                return hr;
            }

            // DISCONNECTs always come in pairs to disconnect both ends
            // so skip the other end.
            // DbgLog(( LOG_TRACE, 2, TEXT("Skipping DISCONNECT")));
            pA = css.GraphList.GetNext(pos);
            ASSERT(pA->Verb==DISCONNECT);

        } else { // BACKOUT - meaning call stream builder again

            Log( IDS_STREAMBUILDING );
            IPin *ppin;
            IBaseFilter * pf;
            if (pA->Object.b.nFilter == -1) {
                ppin = pPin;          // the original pin.
                Log( IDS_ORIGINALP, ppin);
            } else {
                pf = SearchNumberToIFilter
                                    (css.GraphList, pA->Object.b.nFilter);
                Log( IDS_FOUNDF, pf);
                ASSERT(pf!=NULL);
                hr = pf->FindPin(pA->Object.b.id, &ppin);
                Log( IDS_FOUNDP, ppin);
                if(FAILED(hr)) {
                    // occurs if pin config. changes on reconnect
                    DbgLog((LOG_TRACE, 1, TEXT("backout IStreamBuilder: FindPin failed.")));
                    return E_FAIL;
                }            
                ASSERT(ppin!=NULL);
            }

            IStreamBuilder * pisb;
            if (pA->Object.b.bFoundByQI) {
                ppin->QueryInterface(IID_IStreamBuilder, (void**)&pisb);
            } else {
                // if it was found by CoCreateInstance then it is still valid.
                pisb = pA->Object.b.pisb;
            }

            mFG_ppinRender = ppin;
            hr = pisb->Render(ppin, this);
            mFG_ppinRender = NULL;

            // Balance our actions.  Release what we got in this routine.
            if (pA->Object.b.bFoundByQI) {
                pisb->Release();
            }

            // We're done with the pins that we found.
            ppin->Release();

            // but did the Render work?
            if (FAILED(hr)) {
                // ??? Back out everything!
                Log( IDS_SBFAIL, hr);
                return hr;           // we are in a mess!
            }
        }
        DbgLog(( LOG_TRACE, 3, TEXT("Done one [more] step of building best-can-do graph!")));

    }

    Log( IDS_BESTCANDONE );


    return hr;

} // BuildFromSearchState



//========================================================================
//
// CompleteRendering
//
// trace the input from pPin through F and render all the output streams
// F is loaded in the filtergraph.  Its input is connected
// Acts is left unchanged if it FAILs, may grow if it succeeds.
// (If the stream is rendered by this filter, it won't grow).
//========================================================================
HRESULT CFilterGraph::CompleteRendering
    ( IBaseFilter *pF            // the intermed filter (acts as cursor for filter enum)
    , IPin * pPin         // a connected input pin of F
    , int    iRecurse     // the recursion level.  0 means no recursion yet.
    , CSearchState &Acts   // how to back out what we have done
    , CSpareList &Spares  // spare filters that were loaded and backed out
    , CSearchState &Best // The score, and how to rebuild it.
    )
{
    // We need to try all the pins as some of them (Murphy's law says not the
    // first) may succeed, giving a partially successful graph that might be
    // the best so far.  After a failure below us, what failed will already be
    // backed out, but we need to record the partial failure and backout all
    // the bits that succeeded at the end and return a failure code.

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+7);
    HRESULT hr;         // return code from thing(s) we call

    snapshot Snap;      // Backout to here if we fail;
    TakeSnapshot(Acts, Snap);

    IPin * apPinStack[C_PINSONSTACK];
    IPin **apPin = apPinStack;
    int nOutPins;        // the score for this stream is divided by this number.
    BOOL bSomethingFailed = FALSE;

    Log( IDS_RENDSEARCHOUTP, pF);

    int nPin;
    hr = FindOutputPinsHelper( pPin, &apPin, C_PINSONSTACK, nPin, false );
    if (FAILED(hr)) {
        Log( IDS_RENDQISFAIL, pF);
        return hr;  // hr from QueryinternalStreams attempt
    }
    CDelRgPins rgPins(apPin == apPinStack ? 0 : apPin);

    // apPin[0..nPin-1] are addreffed output pins.

    {
        int iPin;


        nOutPins = nPin;
        if (nOutPins>0) {

            // return the most specific error we get from any stream
            HRESULT hrSpecific = VFW_E_CANNOT_RENDER;

            // We subdivide the stream for score-keeping.
            double StreamsToRender = Acts.StreamsToRender;
            Acts.StreamsToRender /= nOutPins;

            for (iPin = 0; iPin<nPin; ++iPin) {

                IPin *p = apPin[iPin];
                if (mFG_bAborting) {
                    hr = hrSpecific = E_ABORT;
                    p->Release();
                    continue;      // to release the other pins
                }
                IPin * pConTo;
                p->ConnectedTo(&pConTo);
                if (pConTo!=NULL) {
                    pConTo->Release();
                    // Assume that the pin is connected already to something
                    // that renders it.  This is a quick and dirty hack.
                    // The real solution is to trace the flow to the death
                    // and try to render all spare pins.
                    Acts.StreamsRendered += Acts.StreamsToRender;
                } else {
                    Log( IDS_RENDOUTP, p, pF);
                    hr = RenderRecursively(p, iRecurse, Acts, Spares, Best);

                    if (FAILED(hr)) {
                        bSomethingFailed = TRUE;
                        MSR_INTEGERX(mFG_idIntel, 100*iRecurse+27);
                        // we don't return hr any more - we see if we cab
                        // render any of the other streams
                        Log( IDS_RENDOUTPFAIL, p, pF);

                        if ((VFW_E_CANNOT_CONNECT != hr) &&
                            (VFW_E_CANNOT_RENDER != hr))
                        {
                            hrSpecific = hr;
                        }

                    } else {
                        Log( IDS_RENDOUTPSUC, p, pF);
                    }
                }
                p->Release();
            }

            // Chances are this is could be a new high water mark.
            if ((!mFG_bAborting) && CSearchState::IsBetter(Acts, Best)) {
                CopySearchState(Best, Acts);
            }
            if (mFG_bAborting) {
                hr = hrSpecific = E_ABORT;
                bSomethingFailed = TRUE;
            }


            // reinstate original slice size as we emerge from the slicing
            Acts.StreamsToRender = StreamsToRender;

            if (bSomethingFailed) {
                Log( IDS_RENDOUTPPART, pF);
                Backout(Acts, Spares, Snap);
                MSR_INTEGERX(mFG_idIntel, 100*iRecurse+27);
                return hrSpecific;
            }

        } else {
            // no outputs => all rendered.
            Log( IDS_RENDNOOUT, pF);
            Acts.StreamsRendered += Acts.StreamsToRender;

            // Chances are this is a new high water mark.
            if (CSearchState::IsBetter(Acts, Best)) {
                CopySearchState(Best, Acts);
            }
        }

    }

    // At this point Acts has the full list of all the actions needed
    // to back out the full rendering of every pin.
    // Every time we +=d StreamsRendered we checked if we should
    // update Best, so Best is now up to date too.

    DbgLog((LOG_TRACE, 4, TEXT("End of CompleteRendering")));
    DumpSearchState(Best);

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+17);
    return NOERROR;

} // CompleteRendering



//========================================================================
//
// RenderByFindingPin
//
// Render ppinOut by using F as an intermediate filter, finding an input pin
// on it, connecting to it and following the stream through, rendering the output
// given that F is loaded and in the filter graph
// On failure, Acts will be restored to the way it was on entry.
// On success, Acts will have grown.
//========================================================================
HRESULT CFilterGraph::RenderByFindingPin
    ( IPin * ppinOut      // the output pin
    , IBaseFilter *pF     // the intermed filter (acts as cursor for filter enum)
    , int    iRecurse     // the recursion level.  0 means no recursion yet.
    , CSearchState &Acts   // how to back out what we have done
    , CSpareList &Spares  // Filters that were loaded then backed out
    , CSearchState &Best // The score, and how to rebuild it.
    )
{
    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+6);
    HRESULT hr;         // return code from thing(s) we call
    Log( IDS_RENDSEARCHINP, pF, ppinOut);

    snapshot Snap;      // Backout to here if we fail;
    TakeSnapshot(Acts, Snap);

    CEnumPin Next(pF, CEnumPin::PINDIR_INPUT, TRUE);        // input pins
    IPin *pPin;

    // try to remember a specific error code if one appears
    HRESULT hrSpecific = VFW_E_CANNOT_RENDER;

    // search F to find an input pin to try
    while ( (LPVOID) (pPin = Next()) ) {

        if (mFG_bAborting) {
            pPin->Release();
            hr = hrSpecific = E_ABORT;
            break;
        }
        Log( IDS_RENDTRYP, ppinOut, pPin, pF);

        IPin *pConnected;
        hr = pPin->ConnectedTo(&pConnected);
        if (FAILED(hr) || pConnected==NULL) {       // don't try if already connected

            // Connect to the input pin we have found
            hr = ConnectDirectInternal(ppinOut, pPin, NULL);  // no version count

            if (SUCCEEDED(hr)) {
                Log( IDS_RENDCONNED, ppinOut, pPin, pF );

                // to back out a connect, disconnect both ends
                // we will need to backout upstream so add output pin first
                // (Backout reads the list backwards)
                Action * pAct1 = new Action;
                Action * pAct2 = new Action;
                // both or neither!
                if (pAct1==NULL || pAct2==NULL) {
                    pPin->Release();
                    if (pAct1!=NULL) delete pAct1;
                    if (pAct2!=NULL) delete pAct2;
                    return E_OUTOFMEMORY;
                }

                pAct1->Verb = DISCONNECT;
                pAct1->Object.c.ppin = ppinOut;
                Acts.GraphList.AddTail(pAct1);

                pAct2->Verb = DISCONNECT;        // subroutine???
                pAct2->Object.c.ppin = pPin;
                Acts.GraphList.AddTail(pAct2);

                hr = CompleteRendering(pF, pPin, iRecurse, Acts, Spares, Best);
                if (FAILED(hr)) {
                    Log( IDS_BACKOUTLEV, iRecurse );

                    Backout(Acts, Spares, Snap);

                    // remember this error code if specific
                    if ((VFW_E_CANNOT_CONNECT != hr) &&
                        (VFW_E_CANNOT_RENDER != hr)) {
                            hrSpecific = hr;
                    }
                } else {
                    pPin->Release();
                    DbgLog((LOG_TRACE, 4, TEXT("Released F  pin %x"), pPin));
                    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+16);
                    return NOERROR;
                }
            } else if (IsAbandonCode(hr)) {
                // no point in trying heroics if we're being asked to render a
                // stream on a filter whose input is dangling and so who won't
                // connect at all in this state.
                Log( IDS_RENDCONFAIL, ppinOut, pPin, pF);
                Log( IDS_RENDNOTCON, ppinOut );
                pPin->Release();
                MSR_INTEGERX(mFG_idIntel, 100*iRecurse+26);
                return hr;
            } else {
                Log ( IDS_RENDPINCONFAIL, ppinOut, pPin, pF);

                // remember this error if 'interesting'
                if ((hr != E_FAIL) &&
                    (hr != E_INVALIDARG)) {
                        hrSpecific = hr;
                }
            }
        } else {
            Log( IDS_RENDPINCON, pPin );
            pConnected->Release();
        }
        pPin->Release();
    }

    Log( IDS_RENDNOPIN, pF);

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+36);
    return hrSpecific;

} // RenderByFindingPin



//========================================================================
//
// RenderUsing
//
// Render ppinOut using F as an intermediate filter
//========================================================================
HRESULT CFilterGraph::RenderUsingFilter
    ( IPin * ppinOut      // the output pin
    , Filter& F            // the intermed filter (acts as cursor for filter enum)
    , int    iRecurse     // the recursion level.  0 means no recursion yet.
    , CSearchState &Acts  // how to back out what we have done
    , CSpareList &Spares  // Any filters that were loaded but backed out
    , CSearchState &Best  // The score, and how to rebuild it.
    )
{
    // CFilterGraph::RenderUsingFilter() expects the proposed filter (F) to be in the
    // F_LOADED state (F is in the filter graph), the F_CACHED state (F is in the filter cache) or
    // the F_REGISTRY state (F has been found in the registry but it has not been created).
    ASSERT( (F_LOADED == F.State) || (F_CACHED == F.State) || (F_REGISTRY == F.State) );

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+5);
    HRESULT hr;         // return code from thing(s) we call
    DbgLog(( LOG_TRACE, 3, TEXT("RenderUsingFilter output pin %x on filter (%d %x %x) level %d")
           , ppinOut,  F.State, F.pf, DbgExpensiveGetClsid(F).Data1, iRecurse ));

    WCHAR szDisplayName[MAX_PATH];
    LoggingGetDisplayName(szDisplayName, F.pMon);

    if( (F_REGISTRY == F.State) || (F_CACHED == F.State) ) {
    
        snapshot Snap;      // Backout to here if we fail;
        TakeSnapshot(Acts, Snap);

        Log( IDS_RENDTRYNEWF, szDisplayName );
        
        switch( F.State ) {
        case F_REGISTRY:

            // When the filter graph manager is searching the registry,
            // filter's loaded in GetFilter().  F.pf should be 
            // NULL because GetFilter() has not been called.
            ASSERT( NULL == F.pf );

            hr = GetFilter(F.pMon, Spares, &(F.pf));
            if (F.pf==NULL){
                MSR_INTEGERX(mFG_idIntel, 100*iRecurse+25);
                Log( IDS_RENDLOADFAIL, szDisplayName);
                return hr;
            }

            ASSERT( NULL != F.Name );
            break;
        
        case F_CACHED:
            F.RemoveFromCache( &m_Config );
            break;

        default:
            // This code should never be executed because this case 
            // was not considered.
            ASSERT( false );
            return E_UNEXPECTED;
        }

        MSR_INTEGERX(mFG_idIntel, 1008);
        hr = AddFilterInternal(F.pf, F.Name, true);   // no version count
        MSR_INTEGERX(mFG_idIntel, 1009);
        if (hr==VFW_E_DUPLICATE_NAME) {
             // This is getting out of hand.  This is expected to be an unusual case.
             // The obvious thing to do is just to add something like _1 to the end
             // of the name - but F.Name doesn't have room on the end - and where
             // do we draw the line?  On the other hand people really could want
             // filter graphs with 50 effects filters in them...?
             hr = AddFilterInternal(F.pf, NULL, true);
             MSR_INTEGERX(mFG_idIntel, 1010);
        }

        // If AddFilter SUCCEEDED then that got rid of the QzCreate... count.
        if (FAILED(hr)) {

            if( F_CACHED == F.State ) {
                // If this ASSERT fires, then a previously cached filter could not
                // be added back into the filter cache.  While this is not a fatal
                // error, users will notice that a previously cached filter
                // is no longer in the filter cache.
                EXECUTE_ASSERT( SUCCEEDED( F.AddToCache( &m_Config ) ) );
            }

            // If AddFilter FAILED then it did NOT addref it, so that deleted it.
            // Such a filter is apparently imnpossible to Add to the filter graph.
            // It's sick!  That's why we do NOT add it to Spares.
            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+35);
            Log( IDS_RENDADDFAIL, szDisplayName, hr);
            return hr;
        }

        // It now has one RefCount (from AddFilter)

        Log( IDS_RENDERADDEDF, szDisplayName, F.pf, F.Name);

        hr = AddRemoveActionToList( &Acts, &F );
        if( FAILED(hr) ) {
            // If this ASSERT fires, an extra filter will be left in the 
            // filter graph.  
            EXECUTE_ASSERT( SUCCEEDED( RemoveFilterInternal( F.pf ) ) );

            if( F_CACHED == F.State ) {
                // If this ASSERT fires, then a previously cached filter could not
                // be added back into the filter cache.  While this is not a fatal
                // error, users will notice that a previously cached filter
                // is no longer in the filter cache.
                EXECUTE_ASSERT( SUCCEEDED( F.AddToCache( &m_Config ) ) );
            }

            return hr;            
        }

        hr = RenderByFindingPin(ppinOut, F.pf, iRecurse, Acts, Spares, Best);
        if (FAILED(hr)) {
            Backout(Acts, Spares, Snap);
            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+55);
            return hr;
        } 

    } else if( F_LOADED == F.State ) {

        Log( IDS_RENDTRYF, F.pf);
        hr = RenderByFindingPin(ppinOut, F.pf, iRecurse, Acts, Spares, Best);
        if (FAILED(hr)) {
            MSR_INTEGERX(mFG_idIntel, 100*iRecurse+65);
            return hr;
        }
    } else {

        // This state was not expected.  This code should never be executed.
        ASSERT( false );
        return E_UNEXPECTED;
    }

    DbgLog((LOG_TRACE, 4, TEXT("End of RenderUsing...")));
    DumpSearchState(Best);

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+15);
    return NOERROR;

} // RenderUsingFilter

HRESULT CFilterGraph::AddRemoveActionToList( CSearchState* pActionsList, Filter* pFilter )
{
    Action * pNewRemoveAction = new Action;
    if( NULL == pNewRemoveAction) {
        return E_OUTOFMEMORY;
    }

    pNewRemoveAction->Verb = REMOVE;
    pNewRemoveAction->Object.f.pfilter = pFilter->pf;
    pNewRemoveAction->Object.f.pMon = pFilter->pMon;
    if( NULL != pNewRemoveAction->Object.f.pMon ) {
        pNewRemoveAction->Object.f.pMon->AddRef();
    }
    pNewRemoveAction->Object.f.fOriginallyInFilterCache = (F_CACHED == pFilter->State);

    // While it's nice to give filters a descriptive name,
    // it's not necessary to do so.
    if( NULL == pFilter->Name ) {
        pNewRemoveAction->Object.f.Name = NULL;
    } else {
        pNewRemoveAction->Object.f.Name = new WCHAR[ 1+lstrlenW(pFilter->Name) ];
        if( pNewRemoveAction->Object.f.Name!=NULL ) {
            lstrcpyW( pNewRemoveAction->Object.f.Name, pFilter->Name );
        }
    }

    POSITION posNewRemoveAction = pActionsList->GraphList.AddTail( pNewRemoveAction );
    if( NULL == posNewRemoveAction ) {
        delete pNewRemoveAction;
        return E_FAIL;
    }
    
    pActionsList->nFilters++;

    return S_OK;
}

// Look up the class ids in the registry and see if a StreamBuilder is registered
IStreamBuilder * GetStreamBuilder(CLSID Major, CLSID Sub)
{
    return NULL;  // NYI ???
}


//========================================================================
//
// RenderViaIntermediate
//
// Render ppinOut using another filter which we have to find
// (it isn't necessarily an intermediate, it might be the end we seek)
//========================================================================
HRESULT CFilterGraph::RenderViaIntermediate
    ( IPin * ppinOut      // the output pin
    , int    iRecurse     // the recursion level.  0 means no recursion yet.
    , CSearchState &Acts   // how to back out what we have done
    , CSpareList &Spares  // Any filters that were loaded but backed out
    , CSearchState &Best // The score, and how to rebuild it.
    )
{
    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+4);
    HRESULT hr;         // return code from thing(s) we call
    Filter F;           // represents the intermediate filter
    F.bLoadNew = TRUE;
    F.bInputNeeded = TRUE;
    F.bOutputNeeded = mFG_bNoNewRenderers;
    DbgLog(( LOG_TRACE, 4, TEXT("RenderVia pin %x level %d")
           , ppinOut, iRecurse ));

    /* Find out what we can about the media types it will accept */
    hr = GetMediaTypes(ppinOut, &F.pTypes, &F.cTypes);
    if (FAILED(hr)) {
        Log( IDS_RENDGETMTFAIL, ppinOut, hr);
        MSR_INTEGERX(mFG_idIntel, 100*iRecurse+24);
        return hr;
    }

    Log( IDS_RENDMAJTYPE, ppinOut, F.pTypes[0]);

    IStreamBuilder *pisb = NULL;
    BOOL bFoundByQI = FALSE;          // FALSE => CoCreate, TRUE => QueryInterface
                                      // See filgraph.h
    if (ppinOut!=mFG_ppinRender) {
        hr = ppinOut->QueryInterface(IID_IStreamBuilder, (void**)&pisb);
        ASSERT (pisb==NULL || SUCCEEDED(hr));

        if (pisb==NULL) {
            pisb = GetStreamBuilder(F.pTypes[0], F.pTypes[1]);
        } else {
            bFoundByQI = TRUE;
        }
    } else {
        pisb = NULL;
        DbgBreak("StreamBuilder is buck passing!");
    }

    HRESULT hrSpecific;

    if (pisb!=NULL) {   

        mFG_ppinRender = ppinOut;
        hrSpecific = pisb->Render(ppinOut, this);
        mFG_ppinRender = NULL;

        if (SUCCEEDED(hrSpecific)) {

            Action * pAct = new Action;
            if (pAct != NULL) {

                // CGenericList::AddTail() returns NULL if an error occurs.
                if (NULL != Acts.GraphList.AddTail(pAct)) {
                    Acts.StreamsRendered += Acts.StreamsToRender;

                    pisb->AddRef();

                    pAct->Verb = BACKOUT;
                    pAct->Object.b.pisb = pisb;
                    pAct->Object.b.ppin = ppinOut;
                    pAct->Object.b.bFoundByQI = bFoundByQI;

                    // Chances are this is could be a new high water mark.
                    if (CSearchState::IsBetter(Acts, Best)) {
                        CopySearchState(Best, Acts);
                    }
                } else {
                    hrSpecific = E_OUTOFMEMORY;
                    EXECUTE_ASSERT(SUCCEEDED(pisb->Backout(ppinOut, this)));
                    delete pAct;
                }
            } else {
                hrSpecific = E_OUTOFMEMORY;
                EXECUTE_ASSERT(SUCCEEDED(pisb->Backout(ppinOut, this)));
            }
        }

        pisb->Release();

    } else {

        // remember specific error codes if possible
        hrSpecific = VFW_E_CANNOT_RENDER;

        // For each possible candidate filter, either here or in registry
        for ( ; ; ) {
            if (mFG_bAborting) {
                return E_ABORT;
            }
            MSR_INTEGERX(mFG_idIntel, 1013);
            NextFilter(F, 0 /* No Flags */ );
            MSR_INTEGERX(mFG_idIntel, 1014);
            if (F.State==F_INFINITY) {
                if (mFG_punkSite) {
                    IAMFilterGraphCallback *pCallback;

                    HRESULT hrCallback = mFG_punkSite->
                             QueryInterface(IID_IAMFilterGraphCallback,
                                    (void **) &pCallback);

                    if (SUCCEEDED(hrCallback)) {
                        DbgLog((LOG_TRACE, 1, "Calling the UnableToRender callback on pin %x",
                            ppinOut));
                    
                        hrCallback = pCallback->UnableToRender(ppinOut);

                        pCallback->Release();
                    
                        DbgLog((LOG_TRACE, 1, "UnableToRender callback returned %x", hrCallback));
                    
                        // if it returned "success", then try rendering this pin again.
                        if (hrCallback == S_OK) {
                            if (F.pEm) {
                                F.pEm->Release();
                                F.pEm = 0;
                            }
                        
                            F.State = F_ZERO;

                            continue;
                        } else {
                            // we could propagate the error code out, but why?
                        }
                    }
                }

                break;
            }
            hr = RenderUsingFilter(ppinOut, F, iRecurse, Acts, Spares, Best);
            if (SUCCEEDED(hr)){
                MSR_INTEGERX(mFG_idIntel, 100*iRecurse+14);
                return hr;
            }
            else if (IsAbandonCode(hr)) {
                // no point in trying heroics if the filter is not in a state
                // where anything will connect to it.
                MSR_INTEGERX(mFG_idIntel, 100*iRecurse+24);
                return hr;
            } else {
                if ((hr != E_FAIL) &&
                    (hr != E_INVALIDARG) &&
                    (hr != VFW_E_CANNOT_CONNECT) &&
                    (hr != VFW_E_CANNOT_RENDER) &&
                    (hr != VFW_E_NO_ACCEPTABLE_TYPES)) {
                        hrSpecific = hr;
                }
            }
        }
    }

    if( FAILED( hrSpecific ) ) {
        DbgLog(( LOG_TRACE, 4, TEXT("RenderVia: failed level %d"), iRecurse )); 
    }

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+34);
    return hrSpecific;
} // RenderViaIntermediate




//========================================================================
//
// RenderRecursively
//
// Connect these two pins directly or indirectly, using transform filters
// if necessary.   Trace the recursion level  Fail if it gets too deep.

// ??? Can't we just get rid of this function and have its callers call
// ??? RenderViaIntermediate directly?

//========================================================================
HRESULT CFilterGraph::RenderRecursively
    ( IPin * ppinOut      // the output pin
    , int    iRecurse     // the recursion level.  0 means no recursion yet.
    , CSearchState &Acts   // how to back out what we have done
    , CSpareList &Spares  // Any filters that were loaded but backed out
    , CSearchState &Best // The score, and how to rebuild it.
    )

{

    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+3);
    HRESULT hr;         // return code from thing(s) we call
    DbgLog(( LOG_TRACE, 4, TEXT("RenderRecursively pin %x level %d")
           , ppinOut, iRecurse ));

    if (iRecurse>CONNECTRECURSIONLIMIT) {
        return VFW_E_CANNOT_RENDER;
    }
    if (mFG_bAborting) {
        return E_ABORT;
    }

    hr = RenderViaIntermediate(ppinOut, 1+iRecurse, Acts, Spares, Best);
    DumpSearchState(Best);


    MSR_INTEGERX(mFG_idIntel, 100*iRecurse+13);
    return hr;

} // RenderRecursively



//========================================================================
//
// Render
//
// Render this pin directly or indirectly, using transform filters
// if necessary.
//========================================================================

STDMETHODIMP CFilterGraph::Render
    ( IPin * ppinOut     // the output pin
    )
{
    mFG_bAborting = FALSE;             // possible race.  Doesn't matter
    CheckPointer(ppinOut, E_POINTER);
    MSR_INTEGERX(mFG_idIntel, 2);
    HRESULT hr;         // return code from thing(s) we call
    {
        CAutoMsgMutex cObjectLock(&m_CritSec);

        // Now that we're locked, we can check.  If we didn't lock first
        // we might find a pin that's about to be backed out.
        // We need to check that this pin is in our filter garph.
        // i.e. that the pin's filter's filter info points to us.
        hr = CheckPinInGraph(ppinOut);
        if (FAILED(hr)) {
            return hr;
        }

        ++mFG_RecursionLevel;
        Log( IDS_RENDP, ppinOut);
        DbgDump();

        CSearchState Acts;  // The search state itself
        CSearchState Best;  // The best that we ever manage
        CSpareList Spares(NAME("Spare filter list"));

        hr = InitialiseSearchState(Acts);
        if (FAILED(hr)) {
            DeleteBackoutList(Acts.GraphList);
            return hr;  // OUTOFMEMORY for sure
        }

        mFG_RList.Active();

        hr = RenderRecursively(ppinOut, 0, Acts, Spares, Best);

        DumpSearchState(Best);

        if (SUCCEEDED(hr)) {
            IncVersion();
            Log( IDS_RENDERSUCP, ppinOut);
        } else {
            Log( IDS_RENDERPART, ppinOut);
            if (Best.StreamsRendered>0.0) {
                HRESULT hrTmp = BuildFromSearchState(ppinOut, Best, Spares);
                if (FAILED(hrTmp)){
                    // Something nasty is going on.  Are we dying?
                    Log( IDS_RENDFAILTOT, ppinOut);
                }
                IncVersion();

                // note that we only partly succeeded
                if (S_OK == hrTmp) {
                    hr = ConvertFailureToInformational( hr );
                } else {
                    hr = hrTmp;
                }
            }
            // else the best we did was nothing - do not bump mFG_iVersion
        }
        Log( IDS_RENDENDSB, ppinOut);

        // Clear the backout actions (no longer needed)
        // Any reconnections left are valid and don't want purging
        DeleteBackoutList(Acts.GraphList);
        DeleteSpareList(Spares);
        FreeList(Best);
        AttemptDeferredConnections();
        mFG_RList.Passive();

        DbgLog((LOG_TRACE, 4, TEXT("Render returning %x"), hr));
        DbgDump();
        MSR_INTEGERX(mFG_idIntel, 12);
        --mFG_RecursionLevel;
    }

    // notify a change in the graph if we did anything successful.
    if (SUCCEEDED(hr)) {
        NotifyChange();
    }

    if (SUCCEEDED(hr)) {
        // including partial success
        mFG_bDirty = TRUE;
    }

    return hr;
} // Render


STDMETHODIMP CFilterGraph::RenderFileTryStg(LPCWSTR lpcwstrFile)
{
    IPersistStream* pPerStm = NULL;
    IStream * pStream;
    IStorage* pStg;
    HRESULT hr;


    hr = StgIsStorageFile(lpcwstrFile);

    if (S_OK == hr)
    {
        hr = StgOpenStorage( lpcwstrFile
                             , NULL
                             ,  STGM_TRANSACTED
                             | STGM_READ
                             | STGM_SHARE_DENY_WRITE
                             , NULL
                             , 0
                             , &pStg
                             );

        if (SUCCEEDED(hr))
        {
            // obtain our own IPersistStream interface
            hr = QueryInterface(IID_IPersistStream, (void**) &pPerStm);
            if (SUCCEEDED(hr))
            {

                // Open the filtergraph stream in the file
                hr = pStg->OpenStream( mFG_StreamName
                                       , NULL
                                       , STGM_READ|STGM_SHARE_EXCLUSIVE
                                       , 0
                                       , &pStream
                                       );
                if(SUCCEEDED(hr))
                {
                    // Load calls NotifyChange and must not be called holding a lock.
                    // Load takes out its own lock.

                    // It's a doc file with our stream in it - so load it.
                    hr = pPerStm->Load(pStream);

                    pStream->Release();
                }
                else
                {
                    // Most likely we will have a "Steam not found" return code
                    // which looks just like "file not found" and confuses the
                    // gibberish out of the OCX who knows he gave us a file.
                    // So let's be kind and give a more meaningful code.
                    hr = VFW_E_INVALID_FILE_FORMAT;
                }

                pPerStm->Release();
            }
            else
            {
                DbgBreak("unexpected failure");
            }

            pStg->Release();
        }
    }
    else
    {
        hr = VFW_E_UNSUPPORTED_STREAM;
    }

    return hr;
}


// allow RenderFile to open .grf files on a per-application basis
#define APPSHIM_ALLOW_GRF 0x1

DWORD GetAppShim()
{
    DWORD dwReturn = 0;
    // return value could be cached (it won't change)
    TCHAR *szBase = TEXT("software\\Microsoft\\DirectShow\\Compat");

    HKEY hk;
    LONG lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, szBase, 0, KEY_READ, &hk);
    if(lResult == ERROR_SUCCESS)
    {
        TCHAR szApp[MAX_PATH];
        if(GetModuleFileName(0, szApp, NUMELMS(szApp)))
        {
            TCHAR szOut[MAX_PATH];
            TCHAR *pszMod;
            if(GetFullPathName(szApp, MAX_PATH, szOut, &pszMod))
            {
                DWORD dwType, dwcb = sizeof(dwReturn);
                lResult = RegQueryValueEx(
                    hk, pszMod, 0, &dwType, (BYTE *)&dwReturn, &dwcb);
            }
        }
        
        RegCloseKey(hk);
    }

    return dwReturn;
}

//========================================================================
//
// RenderFile
//
// Build a filter graph that will render this file using this play list
// If lpwstrPlayList is NULL then it will use the default play list
// which will typically render the whole file.
//========================================================================
STDMETHODIMP CFilterGraph::RenderFile( LPCWSTR lpcwstrFile, LPCWSTR lpcwstrPlayList )
{
    // This parameter is not used.  See the IGraphBuilder::RenderFile() documentation in the Platform SDK.
    UNREFERENCED_PARAMETER(lpcwstrPlayList);

    CAutoTimer Timer(L"RenderFile");
    mFG_bAborting = FALSE;             // possible race.  Doesn't matter

    CheckPointer(lpcwstrFile, E_POINTER);
    MSR_INTEGERX(mFG_idIntel, 1);
    HRESULT hr;


    {
        CAutoMsgMutex cObjectLock(&m_CritSec);

        Log( IDS_RENDFILE, lpcwstrFile);
        DbgDump();


        IBaseFilter * pfSource;
        // not a storage - or at least not one that we recognise.
        // (Is it just possible that some media file might look like a storage?
        // We'll soon see anyway as we try to recognise its media type.


        // Try to find source filter and then render all pins.

        #ifdef DEBUG
        LONG lInitialListMode = mFG_RList.m_lListMode;
        #endif // DEBUG

        mFG_RList.Active();

        BOOL bDirt = mFG_bDirty;
        BOOL bGuess;
        hr = AddSourceFilterInternal( lpcwstrFile, lpcwstrFile, &pfSource, bGuess );
        mFG_bDirty = mFG_bDirty;  // We'll handle this later.

        if (FAILED(hr)){
            mFG_RList.Passive();
            Log( IDS_RENDADDSOURCEFAIL, hr);
            return hr;
        }
        pfSource->Release();    // Get rid of the "caller's refcount", just keep our own


        Log( IDS_RENDADDEDSOURCE, pfSource);

        ++mFG_RecursionLevel;
        CEnumPin Next(pfSource, CEnumPin::All, TRUE);
        IPin *pPin;

        // We maintain a single spares list across all the rendering atempts.
        // We do NOT maintain a single backout list.  The current rules are that
        // if anything succeeds, we leave it.
        CSpareList Spares(NAME ("Spare filter list"));

        BOOL bAllWorked = TRUE;
        int nTried = 0;
        HRESULT hrTotal = S_OK;

        while ((LPVOID) (pPin = Next())) {
            if (mFG_bAborting) {
                pPin->Release();
                hr = E_ABORT;
                break;
            }

            ++nTried;
            CSearchState PinActs;  // back out actions for this pin
            CSearchState Best;
            hr = InitialiseSearchState(PinActs);
            if (FAILED(hr)) {
                DeleteBackoutList(PinActs.GraphList);
                pPin->Release();
                break;
            }

            Log( IDS_RENDSOURCEP, pPin);
            hr = RenderRecursively(pPin, 0, PinActs, Spares, Best);
            if (SUCCEEDED(hr)) {
                Log( IDS_RENDSUC, pPin, pfSource);
            }
            if (FAILED(hr)) {
                bAllWorked = FALSE;
                // ASSERT: Everything is backed out.
                // Should have been backed out at or below the RenderUsing level.
                ASSERT(PinActs.GraphList.GetCount()==PinActs.nInitialFilters);

                Log( IDS_RENDPARTSOURCEP, pPin, hr);

                if (Best.StreamsRendered>0.0) {
                    Log( IDS_RENDBESTCANDOP, pPin);
                    HRESULT hrTmp = BuildFromSearchState(pPin, Best, Spares);
                    if (SUCCEEDED(hrTmp)) {
                        Log( IDS_RENDBESTCANDONEP, pPin);

                        // now try to fix up a partial-success code
                        // based on the error code returned
                        hr = ConvertFailureToInformational(hr);

                    } else {
                        hr = hrTmp;
                        Log( IDS_RENDBESTCANFAIL, pPin, hr);
                    }
                } else {
                    if (bGuess && !IsInterestingCode(hr)) {
                        hr = VFW_E_UNSUPPORTED_STREAM;
                    }
                    Log( IDS_RENDWORTHLESS, pPin);
                }

            }

            /*  Aggregate hrTotal over all the pins in order of
                precedence :
                  first success code != S_OK
                  VFW_S_PARTIAL_RENDER if only S_OK and failures
                  first failure code
            */
            if (nTried == 1) {
                hrTotal = hr;
            } else {
                /*  9 cases */
                int i = (S_OK == hr ? 0 : SUCCEEDED(hr) ? 1 : 2)
                      + (S_OK == hrTotal ? 0 : SUCCEEDED(hrTotal) ? 3 : 6);

                switch (i) {
                case 0: /*  Both S_OK */
                    break;

                case 1: /*  SUCCEEDED(hr), hrTotal == S_OK */
                    hrTotal = hr;
                    break;

                case 2: /*  FAILED(hr), hrTotal == S_OK */
                    hrTotal = ConvertFailureToInformational(hr);
                    break;

                case 3: /*  hr == S_OK, SUCCEEDED(hrTotal) */
                    break;

                case 4: /*  SUCCEEDED(hr), SUCCEEDED(hrTotal) */
                    break;

                case 5: /*  FAILED(hr), SUCCEEDED(hrTotal) */
                    break;

                case 6: /*  hr == S_OK, FAILED(hrTotal) */
                    hrTotal = ConvertFailureToInformational(hrTotal);
                    break;

                case 7: /*  SUCCEEDED(hr), FAILED(hrTotal) */
                    hrTotal = hr;
                    break;

                case 8: /*  FAILED(hr), FAILED(hrTotal) */
                    break;
                }
            }

            if (FAILED(hr)) {
                // either the best we did was nothing or else all attempts failed
                Log( IDS_RENDTOTFAILP, pPin, hr);
            }

            pPin->Release();

            DeleteBackoutList(PinActs.GraphList);
            FreeList(Best);
        }
        hr = hrTotal;

        // nTried==0 means that this is a filter with no output pins.
        // In this case no success is also complete success!
        if (SUCCEEDED(hr) || nTried==0) {
            IncVersion();
        } else {
            // The only thing left is the source filter - kill that too.
            HRESULT hrTmp = RemoveFilterInternal(pfSource);
            ASSERT(SUCCEEDED(hrTmp));

            // try to preserve interesting specific error codes
            // without returning obscure internal ones
            if ((hr == VFW_E_CANNOT_CONNECT) ||
                (hr == VFW_E_NO_ACCEPTABLE_TYPES) ||
                (hr == E_FAIL) ||
                (hr == E_INVALIDARG))
            {
                hr = VFW_E_CANNOT_RENDER;
            }
        }


        DeleteSpareList(Spares);
        AttemptDeferredConnections();
        mFG_RList.Passive();

	// This ASSERT's purpose is to make sure each call to 
        // CReconnectList::Active() has a corresponding call 
        // to CReconnectList::Passive().  If the ASSERT fires,
        // CReconnectList::Passive() was called too many or 
        // too few times.
        ASSERT(mFG_RList.m_lListMode == lInitialListMode);

        Log( IDS_RENDRETCODE, hr);
        --mFG_RecursionLevel;

    } // lock

    // maybe it was a .grf
    if(hr == VFW_E_UNSUPPORTED_STREAM)
    {
        // extension must be .grf
        int cchSz = lstrlenW(lpcwstrFile);
        // note CompareStringW probably unavailable on Win9x
        if(cchSz > 4 &&
           CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE,
                          lpcwstrFile + cchSz - 4, -1, L".grf", -1) == CSTR_EQUAL)
        {
            if(GetAppShim() & APPSHIM_ALLOW_GRF)
            {
                return RenderFileTryStg(lpcwstrFile);
            }
        }
        // note we don't call NotifyChange or set mFG_bDirty;
    }

    // notify a change in the graph
    if (SUCCEEDED(hr)) {
        NotifyChange();
    }

    MSR_INTEGERX(mFG_idIntel, 11);

    if (SUCCEEDED(hr)) {
        // including partial success
        mFG_bDirty = TRUE;
    }
    // In the event of total failure, no reconnections will have been done
    // because all the filters will have been backed out first and the
    // reconnect lists purged.

    return hr;

} // RenderFile

void EliminatePinsWithTildes(IPin **appinOut, ULONG &nPin)
{
    ULONG nRemoved = 0;
    for (ULONG i = 0; i < nPin; i++) {
        appinOut[i - nRemoved] = appinOut[i];
        if (!RenderPinByDefault(appinOut[i - nRemoved])) {
            appinOut[i - nRemoved]->Release();
            nRemoved++;
        }
    }
    nPin -= nRemoved;
}


// Helper that calls FindOutputPins2 and allocates memory if too few
// slots were passed in. *pappinOut should contain an array of nSlots
// IPin * pointers. if that's not enough, *pappinOut will be changed
// to memory allocated with new
//
HRESULT CFilterGraph::FindOutputPinsHelper( IPin* ppinIn
                                            , IPin ***pappinOut
                                            , const int nSlots
                                            , int &nPin
                                            , bool fAll
                                            )
{
    HRESULT hr = FindOutputPins2( ppinIn, *pappinOut, nSlots, nPin, fAll );
    if(hr == S_FALSE)
    {
        ASSERT(nPin > C_PINSONSTACK);
        IPin **appinHeap = new IPin *[nPin];
        if(appinHeap)
        {
            hr = FindOutputPins2( ppinIn, appinHeap, nPin, nPin, fAll);
            if(hr == S_OK) {
                *pappinOut = appinHeap;
            } else {
                delete[] appinHeap;
            }

            if (hr == S_FALSE)
            {
                DbgBreak("S_FALSE from FindOutputPins2 2x");
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


// Precondition:
//     nSlots is the number of elements in appinOut
//     appinOut is an array of IPin*
//     ppinIn is an input pin
//
// set nPinOut to the number of output pins that *ppinIn is internally connected to
// set appinOut[0..nPinOut-1] to be these pins.
//
// if ppinIn supports QueryInternalConnections, then use it.
//
// otherwise return all output pins on the filter. if fAll is set, all
// output pins are returned. o/w just those that succeed
// RenderPinByDefault()
//
// Every pin returned in appinOut is AddReffed.
//
// If it FAILs return no pins and leave no new AddReffs.
// S_FALSE means nSlots was too small. nPinOut contains required no.

HRESULT CFilterGraph::FindOutputPins2( IPin* ppinIn
                                       , IPin * *appinOut
                                       , const UINT nSlots
                                       , int &nPinOut
                                       , bool fAll
                                       )
{
    ULONG nPin = nSlots;
    HRESULT hr;
    {
        hr = ppinIn->QueryInternalConnections(appinOut, &nPin);
        if(hr == S_OK && !fAll) {
            EliminatePinsWithTildes(appinOut, nPin);
        }
        if(hr == S_OK || hr == S_FALSE)
        {
            // ok or not enough slots.
            nPinOut = nPin;
            return hr;
        }

        // E_NOTIMPL is an expected failure from QIC
        ASSERT(hr == E_NOTIMPL);
    }

    // we can try the hacky version that assumes all output pins are
    // streams from the input pin.

    PIN_INFO pi;
    hr = ppinIn->QueryPinInfo(&pi);
    if (FAILED(hr)) {
        return hr;   // nothing yet addreffed
    }
    ASSERT(pi.dir == PINDIR_INPUT);
    ASSERT(pi.pFilter);

    ULONG cOutPinFound = 0;
    IEnumPins *pep;
    hr = pi.pFilter->EnumPins(&pep);
    pi.pFilter->Release();
    if(SUCCEEDED(hr))
    {
        // enumerate output pins in bunches of C_PINSONSTACK
        IPin *rgPinTmp[C_PINSONSTACK];
        while(SUCCEEDED(hr))
        {
            ULONG cFetched;
            hr = pep->Next(C_PINSONSTACK, rgPinTmp, &cFetched);
            ASSERT(hr == S_OK && cFetched == C_PINSONSTACK ||
                   hr == S_FALSE && cFetched < C_PINSONSTACK ||
                   FAILED(hr));
            if(SUCCEEDED(hr))
            {
                // cannot exit this loop until all pins have been
                // transferred or released. errors from QueryDirection
                // are lost
                for(UINT iPin = 0;
                    iPin < cFetched /* && SUCCEEDED(hr) */;
                    iPin++)
                {
                    PIN_DIRECTION dir;
                    hr = rgPinTmp[iPin]->QueryDirection(&dir);
                    if(SUCCEEDED(hr) && dir == PINDIR_OUTPUT &&
                       (fAll || RenderPinByDefault(rgPinTmp[iPin])))
                    {
                        if(cOutPinFound < nSlots)
                        {
                            // transfer ref
                            appinOut[cOutPinFound] = rgPinTmp[iPin];
                        }
                        else
                        {
                            rgPinTmp[iPin]->Release();
                        }
                        cOutPinFound++;
                    }
                    else
                    {
                        rgPinTmp[iPin]->Release();
                    }

                } // for

                if(cFetched < C_PINSONSTACK) {
                    break;
                }

            } // Next

        } // while

        pep->Release();
    }

    if(FAILED(hr) || cOutPinFound > nSlots) {
        for(UINT iPin = 0; iPin < min(nSlots, cOutPinFound); iPin++) {
            appinOut[iPin]->Release();
        }
    }

    if(SUCCEEDED(hr))
    {
        nPinOut = cOutPinFound;
        hr = cOutPinFound <= nSlots ? S_OK : S_FALSE;
    }
    return hr;

} // FindOutputPins2


// return TRUE iff you can go continuously downstream from ppinUp to ppinDown
// PreCondition: The graph must not already contain a cycle.
//               this is used to ensure that we cannot make a cycle.
//               ppinUp is an input pin.
//               ppinDown is an output pin
// Call this before attempting to connect ppinDown to ppinUp.
// If the answer is TRUE, don't do it - you'll make a cycle.
// In the event of a failure it returns "TRUE".
// No new addrefs, no extra releases.
BOOL CFilterGraph::IsUpstreamOf( IPin * ppinUp, IPin* ppinDown )
{
    // Algorithm:
    // Start from ppinUp.
    // just enumerate all output pins on the filter (cannot trust
    // QueryInternalConnections because pins may legitimately not be
    // connected internally).
    //
    // For each output pin so found:
    // {   If it's the same as ppinDown, return TRUE
    //     else if it's not connected, continue
    //     else if IsUpstreamOf(the connected input pin, ppinDown) return TRUE
    //     else continue
    // }
    // return FALSE

    HRESULT hr;

    IPin * appinOutStack[C_PINSONSTACK];
    IPin **appinOut = appinOutStack;
    int nPinOut;

    // Enumerate all pins, including names beginning with "~" that are not
    // rendered by default (fAll == true)
    //
    hr = FindOutputPinsHelper( ppinUp, &appinOut, C_PINSONSTACK, nPinOut, true);
    if (FAILED(hr)) {
        DbgBreak("FindOutputPins failed");
        return TRUE;   // actually "don't know"
    }
    CDelRgPins rgPins(appinOut == appinOutStack ? 0 : appinOut);

    // appinOut[0..nPinOut-1] are addreffed output pins.
    // They will each be investigated (unless we already know the overall answer)
    // and each released.

    // for i = 0..nPinOut-1
    BOOL bResult = FALSE;
    for (int i=0; i<nPinOut ; ++i) {
        if (bResult==TRUE)
        {   // Nothing to do except release appinOut[i]
        }
        else if (appinOut[i]==ppinDown) {
            bResult = TRUE;
        } else {
            IPin * ppinIn;
            appinOut[i]->ConnectedTo(&ppinIn);
            if (ppinIn) {
                if (IsUpstreamOf(ppinIn, ppinDown)) {
                    bResult = TRUE;
                }
                ppinIn->Release();
            }

        }
        appinOut[i]->Release();
    }

    return bResult;
} // IsUpstreamOf


// return VFW_E_NOT_IN_GRAPH     iff     pFilter->pGraph != this
// otherwise return NOERROR
HRESULT CFilterGraph::CheckFilterInGraph(IBaseFilter *const pFilter) const
{
    HRESULT hr;
    ASSERT( pFilter );
    ASSERT( this );
    if (pFilter)
    {
        FILTER_INFO FilterInfo;
        hr = pFilter->QueryFilterInfo(&FilterInfo);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr) && FilterInfo.pGraph)
        {
            hr = IsEqualObject( FilterInfo.pGraph,
                                const_cast<IFilterGraph*>(static_cast<const IFilterGraph*>(this)) )
                 ? NOERROR
                 : VFW_E_NOT_IN_GRAPH;
            FilterInfo.pGraph->Release();
        }
        else hr = VFW_E_NOT_IN_GRAPH;
    }
    else hr = VFW_E_NOT_IN_GRAPH;

    return hr;
} // CheckFilterInGraph

// return VFW_E_NOT_IN_GRAPH     iff     pPin->pFilter->pGraph != this
// otherwise return NOERROR
HRESULT CFilterGraph::CheckPinInGraph(IPin *const pPin) const
{
    HRESULT hr;
    ASSERT(pPin);
    if (pPin)
    {
        PIN_INFO PinInfo;
        hr = pPin->QueryPinInfo(&PinInfo);
        ASSERT(SUCCEEDED(hr));
        ASSERT(PinInfo.pFilter);
        if (SUCCEEDED(hr))
        {
            hr = CheckFilterInGraph(PinInfo.pFilter);
            PinInfo.pFilter->Release();
        }
    }
    else hr = VFW_E_NOT_IN_GRAPH;
    return hr;
} // CheckPinInGraph
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\mtutil.cpp ===
//==========================================================================;
//
//  Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "mtutil.h"

// const char c_szGuidFormat[] = L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}";

//==========================================================================
// MediaTypeToText
//
// set pText to point to QzTaskMemAlloc allocated storage, filled with an ANSI
// text representation of the media type.  At the moment, it's not fully ANSI
// because there's a binary format glob on the end.
//==========================================================================
HRESULT MediaTypeToText(CMediaType cmt, LPWSTR &pText)
{
    pText = (LPWSTR) QzTaskMemAlloc(MediaTypeTextSize(cmt));
    if (pText==NULL) {
        return E_OUTOFMEMORY;
    }
    LPWSTR p = pText;
    HRESULT hr = StringFromGUID2( cmt.majortype, p, CHARS_IN_GUID);
    if (SUCCEEDED(hr)) {
        // CHARS_IN_GUID allows for a trailing null, not there in a file format
        p += CHARS_IN_GUID-1;               // that's counting WCHARs of course
        *p = L' ';
        ++p;
        hr = StringFromGUID2( cmt.subtype, p, CHARS_IN_GUID);
        if (SUCCEEDED(hr)) {
            p += CHARS_IN_GUID-1;
            *p = L' ';
            ++p;
            *p = (cmt.bFixedSizeSamples ? L'1' : L'0');
            ++p;
            *p = L' ';
            ++p;
            *p = (cmt.bTemporalCompression ? L'1' : L'0');
            ++p;
            *p = L' ';
            ++p;
            wsprintfW(p, L"%010d ", cmt.lSampleSize);
            p += 11;
            hr = StringFromGUID2( cmt.formattype, p, CHARS_IN_GUID);
            if (SUCCEEDED(hr)) {
                p += CHARS_IN_GUID-1;
                *p = L' ';
                ++p;
                wsprintfW(p, L"%010d ", cmt.cbFormat);
                p += 11;
                // and the rest of the format is a binary glob
                // which may contain binary zeros, so don't try to print it!
                memcpy(p, cmt.pbFormat, cmt.cbFormat);
            }
        }
    }
    if (FAILED(hr)) {
        QzTaskMemFree(pText);
        pText = NULL;
    }
    return hr;
} // MediaTypeToText


// number of bytes in the string representation
int MediaTypeTextSize(CMediaType &cmt) {
    return
      sizeof(WCHAR)       // NOTE: WCHAR not TCHAR - always UNICODE
      * ( CHARS_IN_GUID   // majortype+space
        + CHARS_IN_GUID   // subtype+space
        + 1+1             // bFixedSizeSamples
        + 1+1             // bTemporalCompression
        + 10+1            // lSampleSize
        + CHARS_IN_GUID   // formattype+space
        + 0               // pUnk - not saved
        + 10+1            // cbFormat
        )
      + cmt.cbFormat       // *pbFormat
      +2;
    // The plus 2 on the end allows for a terminating UNICODE null
    // in the case where the format length is 0 and the
    // trailing null of the last wsprintf formatting never
    // gets overwritten, but pokes over the end.
}


//===========================================================================
// NHexToInt
//
// Convert cb UNICODE hex characters of pstr to an Int without dragging in C Runtime
// pstr must start with an integer which is terminated by white space or null
//===========================================================================
int NHexToInt(LPWSTR pstr, int cb, HRESULT &hr)
{
    int Res = 0;                // result
    hr = NOERROR;

    for( ; cb>0; --cb) {
        if (pstr[0]>=L'0' && pstr[0]<=L'9') {
            Res = 16*Res+(int)(pstr[0]-L'0');
        } else if ( pstr[0]>=L'A' && pstr[0]<=L'F') {
            Res = 16*Res+(int)(pstr[0]-L'A'+10);
        } else if ( pstr[0]>=L'a' && pstr[0]<=L'f') {
            Res = 16*Res+(int)(pstr[0]-L'a'+10);
        } else {
            hr = E_INVALIDARG;
            break;
        }
        ++pstr;
    }
    return Res;

} // NHexToInt


//===========================================================================
// StrToInt
//
// sort of stripped down atoi without dragging in C Runtime
// pstr must start with an integer which is terminated by white space or null
//===========================================================================
HRESULT StrToInt(LPWSTR pstr, int &n)
{
    int Sign = 1;
    n = 0;                // result wil be n*Sign

    if (pstr[0]==L'-'){
        Sign = -1;
        ++pstr;
    }

    for( ; ; ) {
        if (pstr[0]>=L'0' && pstr[0]<=L'9') {
            n = 10*n+(int)(pstr[0]-L'0');
        } else if (  pstr[0] == L' '
                  || pstr[0] == L'\t'
                  || pstr[0] == L'\r'
                  || pstr[0] == L'\n'
                  || pstr[0] == L'\0'
                  ) {
            break;
        } else {
            return E_INVALIDARG;
        }
        ++pstr;
    }
    return NOERROR;

} // StrToInt


//============================================================================
// CMediaTypeFromText
//
// Initialises cmt from the text string pstr.
// Does the inverse of CTextMediaType
//============================================================================
HRESULT CMediaTypeFromText(LPWSTR pstr, CMediaType &cmt)
{


    pstr[CHARS_IN_GUID-1] = L'\0';   // delimit the GUID
    HRESULT hr = QzCLSIDFromString(pstr, &(cmt.majortype));
    if (FAILED(hr)) {
        return VFW_E_INVALID_CLSID;
    }

    pstr += CHARS_IN_GUID;  // includes skipping delimiting NULL

    pstr[CHARS_IN_GUID-1] = L'\0';   // delimit the GUID
    hr = QzCLSIDFromString(pstr, &(cmt.subtype));
    if (FAILED(hr)) {
        return VFW_E_INVALID_CLSID;
    }

    pstr += CHARS_IN_GUID;  // includes delimiting NULL

    if (*pstr == L'0') {
        cmt.bFixedSizeSamples = FALSE;
    } else if (*pstr == L'1') {
        cmt.bFixedSizeSamples = TRUE;
    } else {
        return VFW_E_INVALID_MEDIA_TYPE;
    }

    pstr += 1+1;

    if (*pstr == L'0') {
        cmt.bTemporalCompression = FALSE;
    } else if (*pstr == L'1') {
        cmt.bTemporalCompression = TRUE;
    } else {
        return VFW_E_INVALID_MEDIA_TYPE;
    }

    pstr += 1+1;

    int n;
    hr = StrToInt(pstr, n);
    cmt.lSampleSize = n;

    pstr += 10+1;

    pstr[CHARS_IN_GUID-1] = L'\0';   // delimit the GUID
    hr = QzCLSIDFromString(pstr, &(cmt.formattype));
    if (FAILED(hr)) {
        return VFW_E_INVALID_CLSID;
    }

    pstr += CHARS_IN_GUID;  // includes delimiting NULL

    hr = StrToInt(pstr, n);

    // format byte count is exactly 10 digits followed by a single space
    pstr += 10+1;

    // we rely on the format block being empty because we don't always
    // set it.
    ASSERT(cmt.cbFormat == 0);

    // zero is a special case to CMediaType class meaning pbFormat has
    // not been allocated. allocating 0 bytes confuses it.
    if(n != 0)
    {
        if(!cmt.SetFormat((BYTE *)pstr, n)) {
            return E_OUTOFMEMORY;
        }
    }

    return NOERROR;
} // CMediaTypeFromText


#pragma warning(disable: 4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\mapper.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

//
// Guide to enumeration for the uninitiated:
// The game starts in filgraph.cpp where
//    NextFilter enumerates filters from the graph and then calls our
//       EnumMatchingFilters to get an IEnumRegFilters interface thanks to
//           CEnumRegFilters::CEnumRegFilters.  All is now ready for
//               CEnumRegFilters::Next which calls
//                   RegEnumFilterInfo and
//                   RegEnumPinInfo to do the work.
// (This is an awful lot of storage shuffling just so as to
// have something that looks like a standard COM enumerator).

// ??? Do we want an UnregisterPinType

// #include <windows.h>   already included in streams.h
#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)
#include <string.h>
// #include <initguid.h>
#include <wxutil.h>
#include <wxdebug.h>

#include "mapper.h"
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <stats.h>
#include "..\squish\regtypes.h"
#include "..\squish\squish.h"
#include "util.h"
#include "isactive.h"

#define DbgBreakX(_x_) DbgBreakPoint(_x_, TEXT(__FILE__),__LINE__)


#ifdef PERF
static int iBindCache;
static int iReadFilterData;
static int iReadCLSID;
static int iUnSquish;
#endif

#ifdef DEBUG
static void DbgValidateHeaps()
{
  HANDLE rgh[512];
  DWORD dwcHeaps = GetProcessHeaps(512, rgh);
  for(UINT i = 0; i < dwcHeaps; i++)
    ASSERT(HeapValidate(rgh[i], 0, 0) );
}
#endif

#ifdef PERF
#define FILGPERF(x) x
#else
#define FILGPERF(x)
#endif

// Need to declare the statics (the cache pointer and its ref count
// and its critical section) separately:

CMapperCache * CFilterMapper2::mM_pReg = NULL;
long CFilterMapper2::mM_cCacheRefCount = 0;
CRITICAL_SECTION CFilterMapper2::mM_CritSec;

// Wide strings that are names of registry keys or values
// These are NOT localisable
const WCHAR szRegFilter[]       = L"Filter";
const WCHAR szCLSID[]           = L"CLSID";
const WCHAR szInproc[]          = L"InprocServer32";
const WCHAR szName[]            = L"Name";
const WCHAR szMerit[]           = L"Merit";
const WCHAR szPins[]            = L"Pins";
const WCHAR szTypes[]           = L"Types";
const WCHAR szMajorType[]       = L"MajorType";
const WCHAR szSubType[]         = L"SubType";
const WCHAR szIsRendered[]      = L"IsRendered";
const WCHAR szDirection[]       = L"Direction";
const WCHAR szAllowedZero[]     = L"AllowedZero";
const WCHAR szAllowedMany[]     = L"AllowedMany";
const WCHAR szConnectsToFilter[]= L"ConnectsToFilter";
const WCHAR szConnectsToPin[]   = L"ConnectsToPin";
const WCHAR szThreadingModel[]  = L"ThreadingModel";
const WCHAR szBoth[]            = L"Both";
static const WCHAR g_wszInstance[] = L"Instance";

static const TCHAR g_szKeyAMCat[] = TEXT("CLSID\\{DA4E3DA0-D07D-11d0-BD50-00A0C911CE86}\\Instance");


#define MAX_STRING 260       // max length for a string found in the registry
#define MAX_KEY_LEN 260       // max length for a value name or key name
#define CLSID_LEN 100        // enough characters for a clsid in text form

// lets you define DWORD as FCC('xyzw')
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))



// A filter is registered by creating the following in the registry.
// (HKCR is HKEY_CLASSES_ROOT)

// ------Key------------------- -valuename------ -----value---------------

// \HKCR\Filter\<CLSID>                                <descriptive name of filter>
// \HKCR\CLSID\<CLSID>\InprocServer32                  <path to executable>
// \HKCR\CLSID\<CLSID>                Merit            <merit>
//
// \HKCR\CLSID\<CLSID>\Pins\<Name>    Direction        <0==PINDIR_INPUT, 1==PINDIR_OUTPUT>
// \HKCR\CLSID\<CLSID>\Pins\<Name>    IsRendered       <1==Yes, 0==No>
//                                                     Only makes sense for input
// \HKCR\CLSID\<CLSID>\Pins\<Name>    AllowedZero      <1==Yes, 0==No>
// \HKCR\CLSID\<CLSID>\Pins\<Name>    AllowedMany      <1==Yes, 0==No>
// \HKCR\CLSID\<CLSID>\Pins\<Name>    ConnectsToFilter <GUID>
// \HKCR\CLSID\<CLSID>\Pins\<Name>    ConnectsToPin    <Pin name>
// ...\Pins\<Name>\Types\<MajorType1> <Subtype1a>      - These
// ...\Pins\<Name>\Types\<MajorType1> <Subtype1b>      - do
//                                       etc             not
// ...\Pins\<Name>\Types\<MajorType2> <Subtype2a>      - have
//                                       etc             values

// graphically this is:
//<clsid>
//      Pins
//         <pin1Name>                         Direction, IsRendered, etc.
//                  Types
//                      <majortype1>
//                              <subtype1a>
//                              <subtype1b>
//                      <majortype2>
//                              <subtype2a>
//                                 ...
//         <pin2Name>                         Direction, IsRendered, etc.
// etc.
//<--                keys               -->   <--- values names ----  ->



//=====================================================================
//=====================================================================
// Auxiliary functions etc.
//=====================================================================
//=====================================================================



//=====================================================================
// Return the length in bytes of str, including the terminating null
//=====================================================================
int ByteLen(LPTSTR str)
{
    if (str==NULL) {
        return 0;
    }
#ifdef UNICODE
    return (sizeof(TCHAR))*(1+wcslen(str));
#else
    return (sizeof(TCHAR))*(1+strlen(str));
#endif
} // ByteLen

// ========================================================================
// build a moniker
// ========================================================================

// HRESULT  GetMoniker(
//     const CLSID *clsCat,
//     const CLSID *clsFilter,
//     const WCHAR *wszInstance,
//     IMoniker **ppMoniker)
// {
//     WCHAR wszDisplayName[CHARS_IN_GUID + CHARS_IN_GUID + MAX_PATH];
//     WCHAR *wszPtr = wszDisplayName;

//     const WCHAR wsz1[] = L"@device:sw:CLSID\\";
//     lstrcpyW(wszDisplayName, wsz1);
//     wszPtr += NUMELMS(wsz1) - 1;

//     EXECUTE_ASSERT(StringFromGUID2(*clsCat, wszPtr, CHARS_IN_GUID) ==
//                    CHARS_IN_GUID);

//     wszPtr += CHARS_IN_GUID - 1;

//     const WCHAR wsz2[] = L"\\Instance\\";

//     // no lstrcatW on win95, so use CopyMemory
//     CopyMemory(wszPtr, wsz2, sizeof(wsz2));
//     wszPtr += sizeof(wsz2) - sizeof(WCHAR);

//     EXECUTE_ASSERT(StringFromGUID2(*clsFilter, wszPtr, CHARS_IN_GUID) ==
//                    CHARS_IN_GUID);

//     IBindCtx *lpBC;
//     HRESULT hr = CreateBindCtx(0, &lpBC);
//     if(SUCCEEDED(hr))
//     {
//         IParseDisplayName *ppdn;
//         ULONG cchEaten;

//         hr = CoCreateInstance(
//             CLSID_CDeviceMoniker,
//             NULL,
//             CLSCTX_INPROC_SERVER,
//             IID_IParseDisplayName,
//             (void **)&ppdn);
//         if(SUCCEEDED(hr))
//         {
//             hr = ppdn->ParseDisplayName(
//                 lpBC, wszDisplayName, &cchEaten, ppMoniker);
//             ppdn->Release();
//         }

//         lpBC->Release();
//     }

//     return hr;
// }



//=====================================================================
//.....................................................................
// Routines to make calling the registry easier -
// Suppress common parameters and do unicode/ANSI conversion
//---------------------------------------------------------------------
//=====================================================================


//==========================================================================
// ClsidFromText
//
// Convert szClsid to clsid.  return TRUE if it worked.
//==========================================================================

BOOL ClsidFromText( CLSID & clsid, LPTSTR szClsid)
{

#ifndef UNICODE
    WCHAR wstrClsid[CLSID_LEN];
    int rc = MultiByteToWideChar( CP_ACP, 0
                                , szClsid, -1, wstrClsid, CLSID_LEN);
    if (rc==0) {
        return FALSE;
    }

    HRESULT hr = QzCLSIDFromString(wstrClsid, &clsid);

#else  // it is UNICODE

    HRESULT hr = QzCLSIDFromString(szClsid, &clsid);

#endif

    return SUCCEEDED(hr);

} // ClsidFromText


HRESULT ParseDisplayNameHelper(WCHAR *wsz, IMoniker **ppmon)
{
    HRESULT hr;
    CComPtr<IBindCtx> lpBC;
    hr = CreateBindCtx(0, &lpBC); // !!! cache IBindCtx?
    if (SUCCEEDED(hr))
    {
        {
            CComPtr<IParseDisplayName> pParse;
            // First try our own monikers
            //
            // call CoInitialize() ???
            //
            hr = CoCreateInstance(CLSID_CDeviceMoniker,
                                  NULL,
                                  CLSCTX_INPROC,
                                  IID_IParseDisplayName,
                                  (void **)&pParse);

            DWORD dwEaten;
            if (SUCCEEDED(hr)) {
                hr = pParse->ParseDisplayName(
                    lpBC,
                    wsz,
                    &dwEaten,
                    ppmon);
            }
        }
        if (FAILED(hr)) {
#ifdef DEBUG
            DWORD dwTime = timeGetTime();
#endif
            DWORD dwEaten;
            hr = MkParseDisplayName(lpBC, wsz, &dwEaten,
                                    ppmon);

#ifdef DEBUG
            DbgLog((LOG_TRACE, 0, TEXT("MkParseDisplayName took %d ms"),
                    timeGetTime() - dwTime));
#endif
        }
    }

    return hr;
}


//==========================================================================
// GetRegDword
//
// Read value <szValueName> under open key <hk>
//==========================================================================

BOOL GetRegDword( HKEY hk             // [in]  Open registry key
                , LPCWSTR szValueName // [in]  name of value under that key
                                      //       which is a class id
                , DWORD &dw           // [out] returned dword
                )
{
    TCHAR ValueNameBuff[MAX_KEY_LEN];

    wsprintf(ValueNameBuff, TEXT("%ls"), szValueName);
    DWORD cb;                    // Count of bytes in dw
    LONG rc;                     // return code from RegQueryValueEx
    cb = sizeof(DWORD);
    rc = RegQueryValueEx( hk, ValueNameBuff, NULL, NULL, (LPBYTE)(&dw), &cb);
    if (rc!=ERROR_SUCCESS) {
        return FALSE;
    }
    return TRUE;

} // GetRegDword



//==========================================================================
// GetRegBool
//
// Read value <szValueName> under open key <hk>, decode it into BOOL b
//==========================================================================

BOOL GetRegBool( HKEY hk             // [in]  Open registry key
               , LPCWSTR szValueName // [in]  name of value under that key
                                     //       which is a class id
               , BOOL &b             // [out] returned bool
               )
{
    DWORD dw;
    BOOL bRc = GetRegDword(hk, szValueName, dw);
    b = (dw!=0);
    return bRc;

} // GetRegBool


//==========================================================================
// GetRegString
//
// Read value <szValueName> under open key <hk>, turn it into a wide char string
// szValueName can be NULL in which case it just gets the value of the key.
//==========================================================================

BOOL GetRegString( HKEY hk              // [in]  Open registry key
                 , LPCWSTR szValueName  // [in]  name of value under that key
                                        //       which is a class id
                 , LPWSTR &wstr         // [out] returned string allocated
                                        //       by CoTaskMemAlloc
                 )
{

    TCHAR ResultBuff[MAX_STRING];         // TEXT result before conversio to wstr
    DWORD dw = MAX_STRING*sizeof(TCHAR);  // needed for RegQueryValueEx
    LONG rc;                              // rc from RegQueryValueEx

    wstr = NULL;                      // tidiness - default result.

    //------------------------------------------------------------
    // ResultBuff = string value from  <hk, szValueName>
    //------------------------------------------------------------
    if (szValueName==NULL) {

        rc = RegQueryValueEx( hk, NULL, NULL, NULL, (LPBYTE)(ResultBuff), &dw);
        if (rc!=ERROR_SUCCESS) {
            return FALSE;
        }

    } else {

        TCHAR ValueNameBuff[MAX_KEY_LEN];
        wsprintf(ValueNameBuff, TEXT("%ls"), szValueName);
        rc = RegQueryValueEx( hk, ValueNameBuff, NULL, NULL
                            , (LPBYTE)(ResultBuff), &dw);
        if (rc!=ERROR_SUCCESS) {
            return FALSE;
        }

    }

    //------------------------------------------------------------
    // Convert ResultBuff to wide char from TCHAR
    //------------------------------------------------------------
    int cb = ByteLen(ResultBuff);
    wstr = (LPWSTR)QzTaskMemAlloc(cb*sizeof(WCHAR)/sizeof(TCHAR));
    if (NULL == wstr) {
        return FALSE;
    }
#ifndef UNICODE
    {
        // The registry delivered us TCHARs

        int rc = MultiByteToWideChar( CP_ACP, 0, ResultBuff, -1
                                    , wstr, cb);
        if (rc==0) {
            return FALSE;
        }
        return TRUE;
    }
#else
    {
        lstrcpyW(wstr, ResultBuff);
        return TRUE;
    }
#endif

} // GetRegString




//==========================================================================
// GetRegClsid
//
// Read value <szValueName> under open key <hk>, decode it into CLSID cls
//==========================================================================

BOOL GetRegClsid( HKEY hk              // [in]  Open registry key
                , LPCWSTR szValueName  // [in]  name of value under that key
                                       //       which is a class id
                , CLSID &cls           // [out] returned clsid
                )
{
    LPWSTR wstrClsid;                      // receives the clsid in text form

    if (!GetRegString(hk, szValueName, wstrClsid)){
        cls = CLSID_NULL;
        return FALSE;
    }

    HRESULT hr = QzCLSIDFromString(wstrClsid, &cls);
    QzTaskMemFree(wstrClsid);
    return SUCCEEDED(hr);

} // GetRegClsid




//=====================================================================
// GetRegKey
//
// Return an open registry key HKEY_CLASSES_ROOT\<strKey>
// or return NULL if it fails.
// The returned key has to have RegCloseKey done some time.
//=====================================================================

HKEY GetRegKey( LPCTSTR strKey )
{
    // registering filters is expected to be rare, so no particular care
    // taken to optimise.  Could avoid wsprintf when we are in UNICODE.

    DWORD dwOptions = REG_OPTION_NON_VOLATILE;
    HKEY hKey;
    DWORD dwDisp;      // return code from registry
                       // CREATED_NEW_KEY means we got the lock
                       // OPENED_EXISTING_KEY means we didn't
    LONG lRC;          // return codes from various operations


    // ------------------------------------------------------------------------
    // Create the \HKCR\<lpwstrKey> key
    // ------------------------------------------------------------------------
    lRC = RegCreateKeyEx( HKEY_CLASSES_ROOT    // open key
                        , strKey               // subkey name
                        , 0                    // reserved
                        , NULL                 // ??? What is a class?
                        , dwOptions            // Volatile or not
                        , MAXIMUM_ALLOWED
                        , NULL                 // Security attributes
                        , &hKey
                        , &dwDisp
                        );
    if (lRC!=ERROR_SUCCESS) {
       return (HKEY)NULL;
    }

    return hKey;
} // GetRegKey



//=====================================================================
// CheckRegKey
//
// Return TRUE if the register key HKEY_CLASSES_ROOT\<strKey> exists
// return FALSE if it doesn't
//=====================================================================

BOOL CheckRegKey( LPCTSTR strKey )
{
    // registering filters is expected to be rare, so no particular care
    // taken to optimise.  Could avoid wsprintf when we are in UNICODE.

    HKEY hKey;
    LONG lRC;          // return codes from various operations


    // ------------------------------------------------------------------------
    // Create the \HKCR\<lpwstrKey> key
    // ------------------------------------------------------------------------
    lRC = RegOpenKeyEx( HKEY_CLASSES_ROOT    // open key
                      , strKey               // subkey name
                      , 0                    // reserved
                      , KEY_READ             // security access
                      , &hKey
                      );
    if (lRC==ERROR_SUCCESS) {
       RegCloseKey(hKey);
       return TRUE;
    }

    return FALSE;
} // CheckRegKey



//=====================================================================
// SetRegString
//
// Set the value for hKey + strName to be strValue
// Works for either unicode or ANSI registry
// arbitrary limit of 300 chars
// Returns 0 if successful, else error code.
//=====================================================================

LONG SetRegString( HKEY hKey,           // an open key
                   LPCWSTR strName,     // The name of the value (or NULL if none)
                   LPCWSTR strValue     // the value
                 )
{

    LONG lRC;          // return codes from various operations
    LPTSTR lptstrName; // value name parameter for RegSetValueEx (could be NULL)

    TCHAR ValueBuff[300]; // Value converted from wchar to set in registry
    TCHAR NameBuff[300];  // Name converted from WCHAR

    wsprintf(ValueBuff, TEXT("%ls"), strValue);

    if (NULL!=strName) {
        wsprintf(NameBuff, TEXT("%ls"), strName);
        lptstrName = NameBuff;
    }
    else lptstrName = NULL;

    lRC = RegSetValueEx( hKey, lptstrName, 0, REG_SZ
                       , (unsigned char *)ValueBuff, ByteLen(ValueBuff) );

    return lRC;

} // SetRegString



//=====================================================================
// SetRegDword
//
// Set the value for hKey + strName to be dwValue
// Works for either unicode or ANSI registry
// arbitrary limit of 300 chars
// Returns 0 if successful, else error code.
//=====================================================================

LONG SetRegDword( HKEY hKey,           // an open key
                  LPCWSTR strName,     // The name of the value (or NULL if none)
                  DWORD dwValue        // the value
                )
{

    LONG lRC;          // return codes from various operations
    LPTSTR lptstrName; // value name parameter for RegSetValueEx (could be NULL)

    TCHAR NameBuff[300];  // Name converted from WCHAR

    if (NULL!=strName) {
        wsprintf(NameBuff, TEXT("%ls"), strName);
        lptstrName = NameBuff;
    }
    else lptstrName = NULL;

    lRC = RegSetValueEx( hKey, lptstrName, 0, REG_DWORD
                       , (unsigned char *)&dwValue, sizeof(dwValue) );

    return lRC;

} // SetRegDword



//=====================================================================
// SetRegClsid
//
// Set the value for hKey + strName to be clsValue
// Works for either unicode or ANSI
// Returns 0 if successful, else error code.
//=====================================================================

LONG SetRegClsid( HKEY hKey,           // an open key
                  LPCWSTR strName,     // The name of the value (or NULL if none)
                  CLSID clsValue       // the value
                )
{
    OLECHAR  str[CHARS_IN_GUID];
    HRESULT hr;
    LONG lRc;

    hr = StringFromGUID2( clsValue, str, CHARS_IN_GUID);

    lRc = SetRegString(hKey, strName, str);

    return lRc;

} // SetRegClsid



//=====================================================================
// DeleteRegValue
//
// Delete the value for  hKey+strName
// Works for either unicode or ANSI registry
// arbitrary limit of 300 chars
// Returns 0 if successful, else error code.
//=====================================================================

LONG DeleteRegValue( HKEY hKey,           // an open key
                     LPCWSTR strName      // The name of the value (or NULL if none)
                   )
{

    LONG lRC;          // return codes from various operations
    LPTSTR lptstrName; // value name parameter for RegSetValueEx (could be NULL)

    TCHAR NameBuff[300];  // Name converted from WCHAR

    if (NULL!=strName) {
        wsprintf(NameBuff, TEXT("%ls"), strName);
        lptstrName = NameBuff;
    }
    else lptstrName = NULL;

    lRC = RegDeleteValue( hKey, lptstrName);

    return lRC;

} // DeleteRegValue



//===========================================================
// List of class IDs and creator functions for class factory
//===========================================================

// See filgraph.cpp -- The filter graph and mapper share a DLL.


//==================================================================
// Register the GUID, descriptive name and binary path of the filter
// This also needs to create the Pins key as a filter with no pins
// key is taken as a duff registration. (IFilterMapper)
//==================================================================


// did have a 3rd param "LPCWSTR strBinPath, // Path to the executable"
// but this is now handled separately so that the server
// type (Inproc, etc) can be decided separately

STDMETHODIMP CFilterMapper2::RegisterFilter
    ( CLSID  Clsid,       // GUID of the filter
      LPCWSTR strName,    // Descriptive name
      DWORD  dwMerit      // DO_NOT_USE, UNLIKELY, NORMAL or PREFERRED.
    )
{
    CheckPointer(strName, E_POINTER);
    HKEY hKey;          // registry key for the filter list
    LONG lRC;           // return codes from various operations
    LONG lRcSet;        // retcode from SetRegString
    TCHAR Buffer[MAX_KEY_LEN];
    OLECHAR pstr[CHARS_IN_GUID];   // Wstring representation of clsid

    CAutoLock foo(this);

    BreakCacheIfNotBuildingCache();

    // remove the 2.0 entry created by the class manager so it can
    // notice any changes. ignore error code.
    UnregisterFilter(
        0,                      // pclsidCategory
        0,                      // szInstance
        Clsid);

    //-----------------------------------------------------------------
    // Add key HKCR\Filter\<clsid>
    //-----------------------------------------------------------------

    {   HRESULT hr;

        hr = StringFromGUID2(Clsid, pstr, CHARS_IN_GUID);
    }


    wsprintf(Buffer, TEXT("%ls\\%ls"), szRegFilter, pstr);
    hKey = GetRegKey( Buffer );

    if (hKey==NULL) {
        return VFW_E_BAD_KEY;
    }

    //-----------------------------------------------------------------
    // Add strName as a value for HKCR\Filter\<clsid>
    //-----------------------------------------------------------------

    lRcSet = SetRegString(hKey, NULL, strName);

    lRC = RegCloseKey(hKey);
    ASSERT (lRC==0);

    if (lRcSet!=ERROR_SUCCESS) {
        return AmHresultFromWin32(lRcSet);
    }

    // ------------------------------------------------------------------------
    // Add key HKCR\CLSID\<clsid>
    // ------------------------------------------------------------------------

    wsprintf(Buffer, TEXT("%ls\\%ls"), szCLSID, pstr);

    hKey = GetRegKey( Buffer );

    if (hKey==NULL) {
        return VFW_E_BAD_KEY;
    }

    // should this bit be kept???
    //
    // // ------------------------------------------------------------------------
    // // Add strName as the new value for HKCR\CLSID\<clsid>
    // // ------------------------------------------------------------------------
    //
    // lRcSet = SetRegString(hKey, NULL, strName);
    //
    // if (lRcSet!=ERROR_SUCCESS) {
    //     lRC = RegCloseKey(hKey);
    //     return AmHresultFromWin32(lRcSet);
    // }


    //-----------------------------------------------------------------
    // Add dwMerit as a value for HKCR\Filter\<clsid> Merit
    //-----------------------------------------------------------------
    lRcSet = SetRegDword(hKey, szMerit, dwMerit);
    lRC = RegCloseKey(hKey);
    ASSERT(lRC==0);

    if (lRcSet!=ERROR_SUCCESS) {
        return AmHresultFromWin32(lRcSet);
    }


    // // ------------------------------------------------------------------------
    // // Add key HKCR\CLSID\<clsid>\InprocServer32
    // // (Precond: Buffer still holds HKCR\CLSID\<clsid>)
    // // ------------------------------------------------------------------------
    //
    // TCHAR NewBuffer[MAX_KEY_LEN];
    //
    // wsprintf(NewBuffer, TEXT("%s\\%ls"), Buffer, szInproc);
    //
    // hKey = GetRegKey( NewBuffer );
    //
    // if (hKey==NULL) {
    //   return VFW_E_BAD_KEY;
    // }


    // // ------------------------------------------------------------------------
    // // Add strBinPath as the new value for HKCR\CLSID\<clsid>\InprocServer32
    // // ------------------------------------------------------------------------
    //
    // lRC = SetRegString( hKey, NULL, strBinPath );
    //
    // if (lRC!=ERROR_SUCCESS) {
    //    RegCloseKey(hKey);
    //    return AmHresultFromWin32(lRC);
    // }
    //
    // lRC = SetRegString( hKey, szThreadingModel, szBoth );
    //
    // if (lRC!=ERROR_SUCCESS) {
    //    RegCloseKey(hKey);
    //    return AmHresultFromWin32(lRC);
    // }
    //
    // RegCloseKey(hKey);


    // ------------------------------------------------------------------------
    // Add key HKCR\CLSID\<clsid>\Pins
    // (Precond: Buffer still holds HKCR\CLSID\<clsid>)
    // Buffer gets mangled.
    // ------------------------------------------------------------------------

    wsprintf(Buffer, TEXT("%s\\%ls"), Buffer, szPins);

    HKEY hKeyNew = GetRegKey( Buffer );

    if (hKeyNew==NULL) {
        RegCloseKey(hKey);
        return VFW_E_BAD_KEY;
    }
    lRC = RegCloseKey(hKeyNew);
    ASSERT(lRC==0);

    return NOERROR;


} // RegisterFilter



//=============================================================================
// Register an instance of a filter.  This is not needed if there is only one
// instance of the filter (e.g. there is only one sound card in the machine)
// or if all instances of the filter are equivalent.  It is used to distinguish
// between instances of a filter where the executable is the same - for instance
// two sound cards, one of which drives studio monitors and one broadcasts.
//=============================================================================

STDMETHODIMP CFilterMapper2::RegisterFilterInstance
    ( CLSID  Clsid, // GUID of the filter
      LPCWSTR pName, // Descriptive name of instance.
      CLSID *pMRId   // Returned Media Resource Id which identifies the instance,
                     // a locally unique id for this instance of this filter
    )
{
    UNREFERENCED_PARAMETER(Clsid);
    UNREFERENCED_PARAMETER(pName);
    UNREFERENCED_PARAMETER(pMRId);
    return E_NOTIMPL;
} // RegisterFilterInstance



//=============================================================================
//
// RegisterPin (IFilterMapper)
//
// Register a pin
// This does not exhibit transactional semantics.
// Thus it is possible to get a partially registered filter if it fails.
//=============================================================================

STDMETHODIMP CFilterMapper2::RegisterPin
    ( CLSID   clsFilter,          // GUID of filter
      LPCWSTR strName,            // Descriptive name of the pin
      BOOL    bRendered,          // The filter renders this input
      BOOL    bOutput,            // TRUE iff this is an Output pin
      BOOL    bZero,              // TRUE iff OK to have zero instances of pin
                                  // In this case you will have to Create a pin
                                  // to have even one instance
      BOOL   bMany,               // TRUE iff OK to create many instance of  pin
      CLSID  clsConnectsToFilter, // Filter it connects to if it has a
                                  // subterranean connection, else NULL
      LPCWSTR strConnectsToPin    // Pin it connects to if it has a
                                  // subterranean connection, else NULL
    )
{
    CheckPointer(strName, E_POINTER);
    HKEY hKeyPins;        // \HKCR\<strFilter>\Pins
    HKEY hKeyPin;         // \HKCR\<strFilter>\Pins\<n>
    LONG lRC;             // return code from some operation
    DWORD dwDisp;
    TCHAR Buffer[MAX_KEY_LEN];
    HRESULT hr;
    DWORD  dwOptions = REG_OPTION_NON_VOLATILE;

    //-----------------------------------------------------------------
    // Check integrity of parameters
    //-----------------------------------------------------------------

    if (bRendered && bOutput ) {
       return E_INVALIDARG;
                           //  A Filter can render only an input pin not output
    }

    // CAN now have ConnectsToPin without ConnectsToFilter

    // Cannot have ConnectsToFilter without ConnectsToPin
    if (  (NULL==strConnectsToPin || strConnectsToPin[0]==L'\0')
       && CLSID_NULL!=clsConnectsToFilter
       ) {
        return E_INVALIDARG;
    }

    CAutoLock foo(this);

    BreakCacheIfNotBuildingCache();

    // remove the 2.0 entry created by the class manager so it can
    // notice any changes. ignore error code.
    UnregisterFilter(
        0,                      // pclsidCategory
        0,                      // szInstance
        clsFilter);


    //-----------------------------------------------------------------
    // hKeyPins = open key for Create \HKCR\CLSID\<strFilter>\Pins
    //-----------------------------------------------------------------
    OLECHAR  strFilter[CHARS_IN_GUID];
    hr = StringFromGUID2(clsFilter, strFilter, CHARS_IN_GUID);
    wsprintf(Buffer, TEXT("%ls\\%ls"), szCLSID, strFilter);
    if (!CheckRegKey( Buffer ))
        return VFW_E_BAD_KEY;

    wsprintf(Buffer, TEXT("%ls\\%ls\\%ls"), szCLSID, strFilter, szPins);

    hKeyPins = GetRegKey( Buffer );
    if (hKeyPins==NULL) {
       return VFW_E_BAD_KEY;
    }


    //-----------------------------------------------------------------
    // hKeyPin = open key for \HKCR\CLSID\<strFilter>\Pins\<Name>
    //-----------------------------------------------------------------
    wsprintf(Buffer, TEXT("%ls"), strName);

    lRC = RegCreateKeyEx( hKeyPins             // open key
                        , Buffer               // subkey name
                        , 0                    // reserved
                        , NULL                 // ??? What is a class?
                        , dwOptions            // volatile or not
                        , KEY_WRITE
                        , NULL                 // Security attributes
                        , &hKeyPin
                        , &dwDisp
                        );
    if (lRC!=ERROR_SUCCESS) {
       RegCloseKey(hKeyPins);
       return AmHresultFromWin32(lRC);
    }


    //-----------------------------------------------------------------
    // Don't need the higher level key any more, so tidy it up now
    //-----------------------------------------------------------------
    lRC = RegCloseKey(hKeyPins);
    ASSERT(lRC==0);


    //-----------------------------------------------------------------
    // Create the key \HKCR\CLSID\<strFilter>\Pins\<Name>\Types
    //-----------------------------------------------------------------
    wsprintf(Buffer, TEXT("%ls"), szTypes);
    HKEY hKeyTypes;

    lRC = RegCreateKeyEx( hKeyPin              // open key
                        , Buffer               // subkey name
                        , 0                    // reserved
                        , NULL                 // ??? What is a class?
                        , dwOptions            // volatile or not
                        , KEY_WRITE
                        , NULL                 // Security attributes
                        , &hKeyTypes
                        , &dwDisp
                        );
    if (lRC!=ERROR_SUCCESS) {
        RegCloseKey(hKeyPin);
        return AmHresultFromWin32(lRC);
    }

    // We don't need to keep the types key open, we just create it.
    lRC = RegCloseKey(hKeyTypes);
    ASSERT(lRC==0);

    //-----------------------------------------------------------------
    // register whether the direction of this pin is Out (1) or In (0)
    //-----------------------------------------------------------------
    lRC = SetRegDword( hKeyPin, szDirection, !!bOutput);

    if (lRC!=ERROR_SUCCESS) {
        RegCloseKey(hKeyPin);
        return AmHresultFromWin32(lRC);
    }


    //-----------------------------------------------------------------
    // register whether data on this pin is rendered - only makes sense for Input pins
    //-----------------------------------------------------------------
    lRC = SetRegDword( hKeyPin, szIsRendered, !!bRendered);

    if (lRC!=ERROR_SUCCESS) {
        RegCloseKey(hKeyPin);
        return AmHresultFromWin32(lRC);
    }


    //-----------------------------------------------------------------
    // register whether this pin is optional
    //-----------------------------------------------------------------
    lRC = SetRegDword( hKeyPin, szAllowedZero, !!bZero);

    if (lRC!=ERROR_SUCCESS) {
        RegCloseKey(hKeyPin);
        return AmHresultFromWin32(lRC);
    }


    //-----------------------------------------------------------------
    // register whether we can create several of this pin
    //-----------------------------------------------------------------
    lRC = SetRegDword( hKeyPin, szAllowedMany, !!bMany);

    if (lRC!=ERROR_SUCCESS) {
        RegCloseKey(hKeyPin);
        return AmHresultFromWin32(lRC);
    }

    //-----------------------------------------------------------------
    // register which filter this pin connects to
    //-----------------------------------------------------------------
    if (CLSID_NULL!=clsConnectsToFilter) {

        //.................................................................
        // register in which filter this subterranean stream emerges
        //.................................................................
        lRC = SetRegClsid( hKeyPin, szConnectsToFilter, clsConnectsToFilter );

        if (lRC!=ERROR_SUCCESS) {
            RegCloseKey(hKeyPin);
            return AmHresultFromWin32(lRC);
        }

    } else {
        //.................................................................
        // Doesn't connect to another filter - kill any previous registration
        //.................................................................
        lRC = DeleteRegValue( hKeyPin, szConnectsToFilter );
        if (lRC!=ERROR_SUCCESS &&  lRC!=ERROR_FILE_NOT_FOUND) {
            RegCloseKey(hKeyPin);
            return AmHresultFromWin32(lRC);
        }
    }

    //-----------------------------------------------------------------
    // register which pin this pin connects to
    //-----------------------------------------------------------------
    if ( NULL!=strConnectsToPin && strConnectsToPin[0]!=L'\0' ) {

        //.................................................................
        // register on which pin this data stream emerges
        //.................................................................
        lRC = SetRegString( hKeyPin, szConnectsToPin, strConnectsToPin );
        if (lRC!=ERROR_SUCCESS) {
            RegCloseKey(hKeyPin);
            return AmHresultFromWin32(lRC);
        }
    } else {

        //.................................................................
        // This pin doesn't emerge - kill any previous registration
        //.................................................................
        lRC = DeleteRegValue( hKeyPin, szConnectsToPin );
        if (lRC!=ERROR_SUCCESS &&  lRC!=ERROR_FILE_NOT_FOUND) {
            RegCloseKey(hKeyPin);
            return AmHresultFromWin32(lRC);
        }
    }



    // ------------------------------------------------------------------------
    // Tidy up any litter
    // ------------------------------------------------------------------------
    lRC = RegCloseKey(hKeyPin);
    ASSERT(lRC==0);


    return NOERROR;


} // RegisterPin


//  (IFilterMapper) method
STDMETHODIMP CFilterMapper2::RegisterPinType
    ( CLSID  clsFilter,           // GUID of filter
      LPCWSTR strName,            // Descriptive name of the pin
      CLSID  clsMajorType,        // Major type of the data stream
      CLSID  clsSubType           // Sub type of the data stream
    )
{
    CheckPointer(strName, E_POINTER);

    //-----------------------------------------------------------------
    // Convert all three clsids to strings
    //-----------------------------------------------------------------
    OLECHAR strFilter[CHARS_IN_GUID];
    StringFromGUID2(clsFilter, strFilter, CHARS_IN_GUID);

    OLECHAR  strMajorType[CHARS_IN_GUID];
    StringFromGUID2(clsMajorType, strMajorType, CHARS_IN_GUID);

    OLECHAR strSubType[CHARS_IN_GUID];
    StringFromGUID2(clsSubType, strSubType, CHARS_IN_GUID);

    CAutoLock foo(this);

    BreakCacheIfNotBuildingCache();

    // remove the 2.0 entry created by the class manager so it can
    // notice any changes. ignore error code.
    UnregisterFilter(
        0,                      // pclsidCategory
        0,                      // szInstance
        clsFilter);


    //-----------------------------------------------------------------
    // Open \HKCR\CLSID\<filterClsid>\Pins\<PinName>\Types
    //                           \<strMajorType>\strSubType
    // as hkType
    //-----------------------------------------------------------------
    TCHAR Buffer[2*MAX_KEY_LEN];      // this is a long one!
    wsprintf( Buffer, TEXT("%ls\\%ls\\%ls\\%ls\\%ls")
            , szCLSID, strFilter, szPins, strName, szTypes
            );
    if (!CheckRegKey(Buffer)) {
        return VFW_E_BAD_KEY;
    }

    wsprintf( Buffer, TEXT("%ls\\%ls\\%ls\\%ls\\%ls\\%ls\\%ls")
            , szCLSID, strFilter, szPins, strName, szTypes
            , strMajorType, strSubType);

    HKEY hkType;
    hkType = GetRegKey( Buffer );
    if (hkType==NULL) {
        return VFW_E_BAD_KEY;
    }

    RegCloseKey(hkType);

    return NOERROR;
} // RegisterPinType;


//=============================================================================
//
// UnRegisterFilter  (IFilterMapper)
//
// Unregister a filter and any pins that it might have.
//=============================================================================
STDMETHODIMP CFilterMapper2::UnregisterFilter
    ( CLSID clsFilter     // GUID of filter
    )
{
    TCHAR Buffer[MAX_KEY_LEN];

    OLECHAR  strFilter[CHARS_IN_GUID];
    StringFromGUID2(clsFilter, strFilter, CHARS_IN_GUID);

    CAutoLock foo(this);

    BreakCacheIfNotBuildingCache();

    // remove the 2.0 entry created by the class manager so it can
    // notice any changes. ignore error code.
    UnregisterFilter(
        0,                      // pclsidCategory
        0,                      // szInstance
        clsFilter);

    //--------------------------------------------------------------------------
    // Delete HKCR\Filter\<clsid> and all below
    //--------------------------------------------------------------------------

    wsprintf(Buffer, TEXT("%ls\\%ls"), szRegFilter, strFilter);

    EliminateSubKey(HKEY_CLASSES_ROOT, Buffer);


    //--------------------------------------------------------------------------
    // Remove Merit value
    // Delete HKCR\CLSID\<clsid>\Pins and all below
    //--------------------------------------------------------------------------

    wsprintf(Buffer, TEXT("%ls\\%ls"), szCLSID, strFilter);

    HKEY hkey;
    LONG lRC = RegOpenKeyEx( HKEY_CLASSES_ROOT    // open key
                           , Buffer               // subkey name
                           , 0                    // reserved
                           , MAXIMUM_ALLOWED      // security access
                           , &hkey
                           );

    if (lRC==ERROR_SUCCESS)  {
        lRC = RegDeleteValue( hkey, TEXT("Merit") );
        RegCloseKey(hkey);
    }

    lstrcat( Buffer, TEXT("\\Pins") );

    EliminateSubKey(HKEY_CLASSES_ROOT, Buffer);

    return NOERROR;

} // UnregisterFilter



//=====================================================================
//
// UnregisterPin (IFilterMapper)
//
// Unergister a pin, completely removing it and everything underneath
//=====================================================================

STDMETHODIMP CFilterMapper2::UnregisterPin
    ( CLSID   clsFilter,    // GUID of filter
      LPCWSTR strName    // Descriptive name of the pin
    )
{
    CheckPointer(strName, E_POINTER);

    TCHAR Buffer[MAX_KEY_LEN];

    OLECHAR strFilter[CHARS_IN_GUID];
    StringFromGUID2(clsFilter, strFilter, CHARS_IN_GUID);

    CAutoLock foo(this);

    BreakCacheIfNotBuildingCache();

    // remove the 2.0 entry created by the class manager so it can
    // notice any changes. ignore error code.
    UnregisterFilter(
        0,                      // pclsidCategory
        0,                      // szInstance
        clsFilter);

    //--------------------------------------------------------------------------
    // Delete HKCR\CLSID\<clsid>\Pins\<strName>
    //--------------------------------------------------------------------------

    wsprintf(Buffer, TEXT("%ls\\%ls\\%ls\\%ls"), szCLSID, strFilter, szPins, strName);
    EliminateSubKey(HKEY_CLASSES_ROOT, Buffer);
    return NOERROR;
} // UnregisterPin



// (IFilterMapper) method
STDMETHODIMP CFilterMapper2::UnregisterFilterInstance
    ( CLSID MRId       // Media Resource Id of this instance
    )
{
    UNREFERENCED_PARAMETER(MRId);
    return E_NOTIMPL;
} // UnregisterFilterInstance



//========================================================================
//========================================================================
//
// Registry cacheing - see class CMapperCache in mapper.h
//
//========================================================================
//========================================================================



CMapperCache::CMapperCache()
    : m_bRefresh(TRUE)
    , m_ulCacheVer(0)
    , m_dwMerit(MERIT_PREFERRED)
    , m_plstFilter(NULL)
    , m_fBuildingCache(FALSE)
    , m_pCreateDevEnum(NULL)
{
    //  See if we're on a 16-color machine
    HDC hdc = GetDC(NULL);
    if (hdc) {
        if (4 == GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES)) {
            m_b16Color = true;
        } else {
            m_b16Color = false;
        }
        ReleaseDC(NULL, hdc);
    } else {
        m_b16Color = false;
    }
}


//======================================================================
// Del
//
// Delete all the entries in pLstFil to leave the list allocated but empty
//======================================================================

void CMapperCache::Del(CFilterList * plstFil)
{
    if (plstFil==NULL) {
        return;
    }

    CMapFilter * pFil;
    while((LPVOID)(pFil = plstFil->RemoveHead())) {
        delete pFil;
    }
}// Del


CMapperCache::~CMapperCache()
{
    // One hopes that ref-counting etc. ensure that this cannot be re-entered
    // and so it doesn't need locking.
    if (m_plstFilter!=NULL) {
        Del( m_plstFilter);
        delete m_plstFilter;
    }
    if (m_pCreateDevEnum!=NULL) {
        m_pCreateDevEnum->Release();
    }
}// ~CMapperCache


//======================================================================
//
// CacheFilter
//
// Read everything in the registry about it into *pFil
//======================================================================
LONG CMapperCache::CacheFilter(IMoniker *pDevMon, CMapFilter * pFil)
{
    ASSERT(pFil->pDeviceMoniker == 0);
    LONG lRc = ERROR_GEN_FAILURE;

    IPropertyBag *pPropBag;
    // FILGPERF(MSR_START(iBindCache));
    HRESULT hr = pDevMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    // FILGPERF(MSR_STOP(iBindCache));
    if(SUCCEEDED(hr))
    {
        // open clsid/{filter-clsid} key
        VARIANT varbstrClsid;
        varbstrClsid.vt = VT_BSTR;
        varbstrClsid.bstrVal = 0;
        //FILGPERF(MSR_START(iReadCLSID));
        {
            // try reading the FilterData value
            //
            VARIANT varFilData;
            varFilData.vt = VT_UI1 | VT_ARRAY;
            varFilData.parray = 0; // docs say zero this

            //FILGPERF(MSR_START(iReadFilterData));
            hr = pPropBag->Read(L"FilterData", &varFilData, 0);
            //FILGPERF(MSR_STOP(iReadFilterData));
            if(SUCCEEDED(hr))
            {
                BYTE *pbFilterData;
                DWORD dwcbFilterDAta;

                ASSERT(varFilData.vt == (VT_UI1 | VT_ARRAY));
                dwcbFilterDAta = varFilData.parray->rgsabound[0].cElements;

                EXECUTE_ASSERT(SafeArrayAccessData(
                    varFilData.parray, (void **)&pbFilterData) == S_OK);

                ASSERT(pbFilterData);

                REGFILTER2 *prf2;
                REGFILTER2 **pprf2 = &prf2;
                //FILGPERF(MSR_START(iUnSquish));
                hr = UnSquish(
                    pbFilterData, dwcbFilterDAta,
                    &pprf2);
                //FILGPERF(MSR_STOP(iUnSquish));

                if(hr == S_OK)
                {
                    pFil->m_prf2 = prf2;
                    ASSERT(pFil->m_prf2->dwVersion == 2);

                    // this is the only place that sets the
                    // success code.
                    ASSERT(lRc != ERROR_SUCCESS);
                    lRc = ERROR_SUCCESS;
                }

                EXECUTE_ASSERT(SafeArrayUnaccessData(
                    varFilData.parray) == S_OK);

                EXECUTE_ASSERT(VariantClear(
                    &varFilData) == S_OK);

            }
            else
            {
                lRc = ERROR_GEN_FAILURE;
            }

            if(lRc == ERROR_SUCCESS)
            {
                pFil->pDeviceMoniker = pDevMon;
                pDevMon->AddRef();

                // HACK HACK for 16-color mode - increase
                // the merit of the ditherer
                CLSID clsid;
                if (m_b16Color &&
                    SUCCEEDED(GetMapFilterClsid(pFil, &clsid)) &&
                    clsid == CLSID_Dither) {
                    pFil->m_prf2->dwMerit = MERIT_PREFERRED;
                }
            }
        }

        pPropBag->Release();
    }
    else
    {
        lRc = ERROR_GEN_FAILURE;
    }

    return lRc;

} //CacheFilter


// Get the clsid for an entry (we only need this to return
// it to the application and anyway what can they do with it?)
HRESULT CMapperCache::GetMapFilterClsid(CMapFilter *pFilter, CLSID *pclsid)
{
    IPropertyBag *pPropBag;
    FILGPERF(MSR_START(iBindCache));
    HRESULT hr = pFilter->pDeviceMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    FILGPERF(MSR_STOP(iBindCache));
    if (FAILED(hr)) {
        return hr;
    }

    // open clsid/{filter-clsid} key
    VARIANT varbstrClsid;
    varbstrClsid.vt = VT_BSTR;
    varbstrClsid.bstrVal = 0;
    //FILGPERF(MSR_START(iReadCLSID));
    hr = pPropBag->Read(L"CLSID", &varbstrClsid, 0);
    //FILGPERF(MSR_STOP(iReadCLSID));
    if(SUCCEEDED(hr))
    {
        ASSERT(varbstrClsid.vt == VT_BSTR);
        WCHAR *strFilter = varbstrClsid.bstrVal;

        hr = CLSIDFromString(varbstrClsid.bstrVal, pclsid);
        SysFreeString(varbstrClsid.bstrVal);
    }
    pPropBag->Release();
    return hr;
}

//======================================================================
//
// Cache
//
// Read everything in the registry about filters into a hierarchy of lists
// the top list is m_plstFilter which points to a CFilterList
// see mapper.h for a picture
//======================================================================
HRESULT CMapperCache::Cache()
{
    CAutoLock foo(this);
    if (m_plstFilter!=NULL) {
        Del(m_plstFilter);
    } else {
        m_plstFilter = new CFilterList(NAME("Filter list"));
        if (m_plstFilter==NULL) {
            m_bRefresh = TRUE;
            return E_OUTOFMEMORY;
        }
    }

    //  Can we restore the cache?
    DWORD dwPnPVersion = 0;
    if (m_dwMerit > MERIT_DO_NOT_USE) {

        if (g_osInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
            GetRegistryDWORD(HKEY_DYN_DATA,
                             TEXT("Config Manager\\Global"),
                             TEXT("Changed"),
                             &dwPnPVersion);
        }
        HRESULT hr = RestoreFromCache(dwPnPVersion);
        DbgLog((LOG_TRACE, 2, TEXT("RestoreFromCache returned %x"), hr));
        if (SUCCEEDED(hr)) {
            return S_OK;
        }

        // Destroy the partially built filter list.
        Del(m_plstFilter);
    }
    DbgLog((LOG_TRACE, 2, TEXT("Entering(CMapperCache::Cache)")));

    CAutoTimer T1(L"Build Mapper Cache");

    ASSERT(!m_fBuildingCache);
    // all exit points must reset this!
    m_fBuildingCache = TRUE;
    m_ulCacheVer++;

    //
    // add pnp filters
    //
    {
        HRESULT hr = S_OK;
        if (!m_pCreateDevEnum)
        {
            DbgLog((LOG_TRACE, 2, TEXT("Creating System Dev Enum")));
            hr = CoCreateInstance( CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                                   IID_ICreateDevEnum, (void**)&m_pCreateDevEnum);
        }

        if(SUCCEEDED(hr))
        {

            DbgLog((LOG_TRACE, 2, TEXT("Created System Dev Enum")));
            IEnumMoniker *pEmCat = 0;
            hr = m_pCreateDevEnum->CreateClassEnumerator(
                CLSID_ActiveMovieCategories,
                &pEmCat,
                0);

            if(hr == S_OK)
            {
                IMoniker *pMCat;
                ULONG cFetched;
                while(hr = pEmCat->Next(1, &pMCat, &cFetched),
                      hr == S_OK)
                {
                    IPropertyBag *pPropBag;
                    hr = pMCat->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                    if(SUCCEEDED(hr))
                    {
                        // read merit for category. may be missing in
                        // which case we treat as MERIT_DO_NOT_USE

                        VARIANT varMerit;
                        varMerit.vt = VT_I4;

                        HRESULT hrRead = pPropBag->Read(L"Merit", &varMerit, 0);
                        if((SUCCEEDED(hrRead) && varMerit.lVal >= (LONG)m_dwMerit) ||
                           (FAILED(hrRead) && m_dwMerit <= MERIT_DO_NOT_USE))
                        {

                            VARIANT varCatClsid;
                            varCatClsid.vt = VT_BSTR;
                            hr = pPropBag->Read(L"CLSID", &varCatClsid, 0);
                            if(SUCCEEDED(hr))
                            {
                                CLSID clsidCat;
                                if(CLSIDFromString(varCatClsid.bstrVal, &clsidCat) == S_OK)
                                {
                                    VARIANT varCatName;
                                    varCatName.vt = VT_BSTR;
                                    hr = pPropBag->Read(L"FriendlyName", &varCatName, 0);
                                    if(SUCCEEDED(hr))
                                    {
                                        DbgLog((LOG_TRACE, 2,
                                                TEXT("CMapperCache: enumerating %S"),
                                                varCatName.bstrVal));
                                    }
                                    else
                                    {
                                        DbgLog((LOG_TRACE, 2,
                                                TEXT("CMapperCache: enumerating %S"),
                                                varCatClsid.bstrVal));
                                    }

                                    {
                                    CAutoTimer Timer(L"Process Category ",
                                               SUCCEEDED(hr) ? varCatName.bstrVal : NULL);

                                    ProcessOneCategory(
                                            clsidCat,
                                            m_pCreateDevEnum);
                                    }
                                    if (SUCCEEDED(hr)) {
                                        SysFreeString(varCatName.bstrVal);
                                    }

                                    // ignore any errors
                                }

                                SysFreeString(varCatClsid.bstrVal);
                            } // catclsid
                        } // merit

                        pPropBag->Release();
                    } // bind to storage
                    else
                    {
                        break;
                    }

                    pMCat->Release();
                } // for loop

                pEmCat->Release();
            }
        }

        if(FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("mapper: pnp enum step failed")));
        }
        // ignore pnp errors for now
    }

    // all exit points must reset this!
    ASSERT(m_fBuildingCache);
    m_fBuildingCache = FALSE;

    if (m_dwMerit > MERIT_DO_NOT_USE) {
        HRESULT hr = SaveCacheToRegistry(MERIT_DO_NOT_USE + 1, dwPnPVersion);
        DbgLog((LOG_TRACE, 2, TEXT("SaveCacheToRegistry returned %x"), hr));
    }

    DbgLog((LOG_TRACE, 2, TEXT("Leaving(CMapperCache::Cache)")));
    return NOERROR;
} // Cache

HRESULT CMapperCache::ProcessOneCategory(REFCLSID clsid, ICreateDevEnum *pCreateDevEnum)
{
    FILGPERF(static int iPerfProc = MSR_REGISTER(TEXT("CMapperCache::ProcessOneCategory")));
    FILGPERF(static int iPerfCache = MSR_REGISTER(TEXT("CMapperCache::CacheFilter")));
    FILGPERF(iBindCache = MSR_REGISTER(TEXT("CMapperCache::BindFilter")));
    FILGPERF(iReadFilterData = MSR_REGISTER(TEXT("ReadFilterData")));
    FILGPERF(iReadCLSID = MSR_REGISTER(TEXT("Read CLSID")));
    FILGPERF(iUnSquish = MSR_REGISTER(TEXT("UnSquish")));
    FILGPERF(MSR_INTEGER(iPerfProc, clsid.Data1));
    FILGPERF(MSR_START(iPerfProc));

    HRESULT hr;

    DbgLog((LOG_TRACE, 2, TEXT("Process one category enter")));

    IEnumMoniker *pEm;
    hr = pCreateDevEnum->CreateClassEnumerator(
        clsid,
        &pEm,
        m_dwMerit > MERIT_DO_NOT_USE ? CDEF_MERIT_ABOVE_DO_NOT_USE : 0);

    DbgLog((LOG_TRACE, 2, TEXT("Start caching filters")));
    if(hr == S_OK)
    {
        ULONG cFetched;
        IMoniker *pM;

        while(hr = pEm->Next(1, &pM, &cFetched),
              hr == S_OK)
        {
            CMapFilter * pFil = new CMapFilter;
            if (pFil!=NULL) {

                // FILGPERF(MSR_START(iPerfCache));
                LONG lResult = CacheFilter(pM, pFil);
                // FILGPERF(MSR_STOP(iPerfCache));

                if (lResult==ERROR_SUCCESS)
                {
                    if(!m_plstFilter->AddTail(pFil))
                    {
                        lResult = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                if (lResult != ERROR_SUCCESS)
                {
                    delete pFil;

                    if(lResult == ERROR_GEN_FAILURE)
                    {
                        // some sort of registration problem. just
                        // skip over the filter.
                        hr = S_OK;

#ifdef DEBUG
                        WCHAR *szDisplayName = 0;
                        pM->GetDisplayName(0, 0, &szDisplayName);
                        if(szDisplayName)
                        {
                            DbgLog((
                                LOG_ERROR, 1,
                                TEXT("CMapperCache: skipped filter %S"),
                                szDisplayName));
                            CoTaskMemFree(szDisplayName);
                        }

#endif
                    }
                    else
                    {
                        hr = AmHresultFromWin32(lResult);
                        m_bRefresh = TRUE;
                    }
                }
            } else {
                hr = E_OUTOFMEMORY;
                m_bRefresh = TRUE;
            }

            pM->Release();

            if(FAILED(hr))
                break;
        }

        pEm->Release();
    }

    FILGPERF(MSR_STOP(iPerfProc));
    DbgLog((LOG_TRACE, 2, TEXT("Process one category leave")));

    return hr;
}



//======================================================================
//
// Refresh
//
// If the cache does not yet exist or if it's out of date then
// delete anything we have and re-create it from the registry.
// return NOERROR if the cache was up to date
//        S_FALSE if we re-cached
//        failure code if we failed
//======================================================================
HRESULT CMapperCache::Refresh()
{
    HRESULT hr;
    BOOL bNew = (m_plstFilter==NULL);

    if (m_plstFilter==NULL || m_bRefresh) {
        m_bRefresh = FALSE;
        Del(m_plstFilter);

        hr = Cache();
        if (FAILED(hr)) return hr;
        Sort(m_plstFilter);

        return (m_bRefresh ? E_OUTOFMEMORY : (bNew ? NOERROR : S_FALSE));
    }
    return NOERROR;
} // Refresh


//======================================================================
//
// BreakCache
//
// Mark the cache as out of date.
//
//======================================================================
HRESULT CMapperCache::BreakCacheIfNotBuildingCache()
{
    CAutoLock foo(this);

    // don't break the cache while building it. many failure paths set
    // m_bRefresh manually
    if(!m_fBuildingCache) {
        m_bRefresh = TRUE;
    }
    return NOERROR;
}


//===========================================================================
// The cache has to be sorted so as to try the most useful filters first.
// The sorting is first on Merit, then on number of output pins (the fewer
// the better, then on number of input pins (the more the better)
// The sorting is done by using a merge sort.  This is an n Log n sorting
// algorithm (so it's broadly speaking as effecient as quicksort) and
// is suitable for sorting lists (i.e. sequential rather than random access).
// it uses very little intermediate storage, doesn't copy nodes.
//===========================================================================

// I haven't tried to make this a reusable sort because we don't seem to
// sort lists very often.  It could easily be made generic.

// this is gonna generate objects like they're going out of fashion
// want lightweight lists!  The number of allocated lists is equal to
// the number of sections in the original filter list.



//=======================================================================
// CountPins
//
// set cIn and cOut to the number of input and output pins respectively
// on filter pf
//=======================================================================
void CMapperCache::CountPins(CMapFilter * pf, int &cIn, int &cOut)
{
    cIn = 0;
    cOut = 0;
    for(UINT iPin = 0; iPin < pf->m_prf2->cPins; iPin++)
    {
        const REGFILTERPINS2 * pPin = &pf->m_prf2->rgPins2[iPin];
        if (pPin->dwFlags & REG_PINFLAG_B_OUTPUT) {
            ++cOut;
        } else {
            ++cIn;
        }
    }
} // CountPins



//=======================================================================
//
// Compare
//
// return -1 if pfAA < pfB, 0 if pfA == pfB, 1 if pfA > pfB
// < means lower Merit or failing that
//   more output pins or failing that
//   fewer input pins
// (Rationale - we work downstream, output pins are a nuisance, we're
// liable to have to render them too.  Input pins can be handy.
// I may change my mind about the input pins.  Current thinking is that
// a filter will always work even if not all its inputs are connected
//=======================================================================
int CMapperCache::Compare(CMapFilter * pfA, CMapFilter * pfB)
{
    if (pfA->m_prf2->dwMerit < pfB->m_prf2->dwMerit)
        return -1;
    if (pfA->m_prf2->dwMerit > pfB->m_prf2->dwMerit)
        return 1;

    // counts of pins
    int cAIn;
    int cAOut;
    int cBIn;
    int cBOut;
    CountPins(pfA, cAIn, cAOut);
    CountPins(pfB, cBIn, cBOut);

    if (cAOut > cBOut)
        return -1;
    if (cAOut < cBOut)
        return 1;

    if (cAIn < cBIn)
        return -1;
    if (cAIn > cBIn)
        return 1;

    return 0;

} // Compare


//=======================================================================
//
// Split
//
// empty fl and put the bits into fll so that each bit in fll is sorted
// the set of filters is preserved, i.e. the set of filters in fl is that
// same as the set of filters in all the fll.  Part of merge-sort.
// Allocates a lot of lists which are freed in Merge.
//=======================================================================
HRESULT CMapperCache::Split(CFilterList * pfl, CFilterListList & fll)
{
    // Move steadily through fl comparing successive elements as long as
    // we find they compare OK, keep trucking.  When we find one that's
    // out of sequence, split off the part before it into a new element
    // that gets added to fll.

    POSITION pos;
    pos = pfl->GetHeadPosition();
    if (pos==NULL) {
        return NOERROR;           // everything's empty
    }

    // *pflNew will become the next section to go onto fll
    CFilterList * pflNew = new CFilterList( NAME("fragment"));
    if (pflNew==NULL) {
        // Oh we're in desperate trouble.
        return E_OUTOFMEMORY;
    }

    for( ; ; ) {

       // (partial) loop invariant:
       //   Elements are preserved:
       //     the concatenation of all the lists in fll followed by fl
       //     makes up the original fl.
       //   Every list within fll is sorted.
       //   fl[...pos] is sorted.

       // We split the list after pos if:
       //   There is no element after pos OR
       //   The element after pos is out of sequence w.r.t. pos

       BOOL bSplit = FALSE;
       POSITION pNext = pfl->Next(pos);
       if (pNext==NULL)
           bSplit = TRUE;
       else {
           CMapFilter * pfA;
           CMapFilter * pfB;
           pfA = pfl->Get(pos);
           pfB = pfl->Get(pNext);

           if (0>Compare(pfA, pfB)) {
               bSplit = TRUE;
           }
       }

       if (bSplit) {
           pfl->MoveToTail(pos, pflNew);
           pos = pNext;
           fll.AddTail( pflNew);

           if (pos!=NULL) {
               pflNew = new CFilterList( NAME("Fragment"));
               if (pflNew==NULL) {
                   return E_OUTOFMEMORY;
               }
           } else {
               break;
           }
       }
       pos = pNext;
    }
    return NOERROR;

} // Split



//=========================================================================
//
// MergeTwo
//
// Merge pflA and pflB into pflA.
// the result will have all the original elements and be well sorted.
// Does not free storage of either one.
// Part of merge-sort
//=========================================================================
void CMapperCache::MergeTwo( CFilterList * pflA, CFilterList * pflB)
{
    POSITION pos = pflA->GetHeadPosition();

    // This is a loop to traverse B, meanwhile pos tries to keep pace through A
    for (; ; ) {
        CMapFilter * pfB = pflB->RemoveHead();
        if (pfB==NULL) {
            return;
        }

        // traverse pos past any elements that go before pfB
        // we want earlier elements to be >= subsequent ones
        // pos stops at the first element that goes after pfB
        // that might be NULL if it gets to the end.
        for (; ; ) {
            CMapFilter * pfA = pflA->Get(pos);
            if (Compare(pfA, pfB)<0) {
                break;                // b goes before pos
            }
            // b doesn't go before pos, so move pos on
            pos = pflA->Next(pos);
            if (pos==NULL) {
                // everything left in B goes after the end of A
                // Add the one we removed
                pflA->AddTail(pfB);
                // Add allthe rest
                pflB->MoveToTail(pflB->GetTailPosition(), pflA);
                // and we are completely done.
                return;
            }
        }
        pflA->AddBefore(pos, pfB);
    }
} // MergeTwo



//=========================================================================
//
// Merge
//
// Precondition: all the lists in fll must be sorted
// pfl must be empty.
//
// Merge all the lists in fll into one and set pfl to that.
// do the merging so as to keep the result sorted
// part of merge-sort
//=========================================================================
void CMapperCache::Merge( CFilterListList & fll, CFilterList * pfl)
{
    // while there are more than two lists in pfl, take the first two off
    // the queue, merge them and put the resulting merged list back on
    // the end of the queue.
    // When there's only one left, return that as the new *pfl

    for (; ; ) {
        CFilterList * pflA = fll.RemoveHead();
        if (pflA==NULL) {
           return;                   // the whole thing's empty!
        }
        CFilterList * pflB = fll.RemoveHead();
        ASSERT(pflA != NULL);
        if (pflB ==NULL) {
            pflA->MoveToTail(pflA->GetTailPosition(), pfl);
            delete pflA;
            return;
        }
        MergeTwo(pflA, pflB);
        fll.AddTail(pflA);
        delete pflB;
    }
} // Merge


//=========================================================================
//
// DbgDumpCache
//
// Dump the cache, showing enough fields that we can tell if we sorted it
//=========================================================================
void CMapperCache::DbgDumpCache(CFilterList * pfl)
{
    DbgLog(( LOG_TRACE, 3, TEXT("FilterMapper Cache Dump:-")));

    POSITION pos;
    for ( pos = pfl->GetHeadPosition(); pos!=NULL; /*no-op*/ ) {
        CMapFilter * pFil = pfl->GetNext(pos);  // Get AND Next of course!
        int cIn;
        int cOut;
        CountPins(pFil, cIn, cOut);
        DbgLog(( LOG_TRACE, 4
           , TEXT("Cache: Merit %d in %d out %d name %ls")
           , pFil->m_prf2->dwMerit, cIn, cOut
           , DBG_MON_GET_NAME(pFil->pDeviceMoniker) ));

        ASSERT(pFil->m_prf2->dwVersion == 2);

        for(UINT iPin = 0; iPin < pFil->m_prf2->cPins2; iPin++)
        {
            const REGFILTERPINS2 * pPin = &pFil->m_prf2->rgPins2[iPin];

            for(UINT iType = 0; iType < pPin->nMediaTypes; iType++)
            {
                const REGPINTYPES * pType = &pPin->lpMediaType[iType];

                DbgLog(( LOG_TRACE, 4 , TEXT("Major %x Sub %x") ,
                         pType->clsMajorType ? pType->clsMajorType->Data1 : 0,
                         pType->clsMinorType ? pType->clsMinorType->Data1 : 0 ));
            }
        }
    }
} // DbgDumpCache


//=========================================================================
//
// Sort
//
// Sort the filter list so that filters which should be tried first come first
//=========================================================================
void CMapperCache::Sort( CFilterList * &pfl)
{
    // Algorithm: split the list into bits where each bit is well sorted
    // merge the bits pairwise until there's ony one left.
    // The ideal strategy is to always pick the two smallest lists to merge
    // of course this is supposing that finding them is free, which it's not
    // We just merge 1-2, 3-4, 5-6, 7-8, 9-10 etc in the first pass then
    // merge 1+2-3+4, 5+6-7+8 etc in as two, in pass three 1+2+3+4-5+6+7+8
    // etc.  It's probably not bad though you can get ill-conditioned data.

    CFilterListList fll( NAME("sort's list of lists"));   // a list of CFilterLists

    HRESULT hr = Split(pfl, fll);
    if (FAILED(hr)) {
        m_bRefresh = FALSE;  // This is a hacky way to make the error surface
                             // with minimal rewriting.
    }
    ASSERT(SUCCEEDED(hr));
    // We still merge, even if we ran out of memory as it will clean up the mess.
    Merge(fll, pfl);
    DbgDumpCache(pfl);

} // Sort


//==============================================================================
// FindType
//
// Search through the list of types for *pPin
// to see if there is a pair of types that match clsMajor and clsSub
// return (a match is found)
//==============================================================================
BOOL CMapperCache::FindType(
    const REGFILTERPINS2 * pPin,
    const GUID *pTypes,
    DWORD cTypes,
    const REGPINMEDIUM *pMedNeeded,
    const CLSID *pPinCatNeeded,
    bool fExact,
    BOOL bPayAttentionToWildCards,
    BOOL bDoWildCards)
{
    //  When we're doing wild card stuff we don't want to match on
    //  a wild card if there's also an exact match
    BOOL bMatched = FALSE;

    //     if (clsMajor==CLSID_NULL) {
    //         DbgLog(( LOG_TRACE, 4
    //            , TEXT("Wild card match (requested NULL type)") ));

//         return TRUE;       // wild card
//     }

    // first test pin categories, then  mediums then media types
    bool fMediumsOk = false, fPinCatOk = false;

    // caller doesn't care ||
    // items specified and match ||
    // caller accepts filter with wildcard item
    //
    if((pPinCatNeeded == 0) ||
       (pPinCatNeeded != 0 && pPin->clsPinCategory != 0 && *pPinCatNeeded == *pPin->clsPinCategory) ||
       (!fExact && pPin->clsPinCategory == 0))
    {
        fPinCatOk = true;

        DbgLog(( LOG_TRACE, 5 ,
                 TEXT("pin categories match: Req (%08x) Found(%08x)") ,
                 pPinCatNeeded ? pPinCatNeeded->Data1 : 0,
                 pPin->clsPinCategory ? pPin->clsPinCategory->Data1 : 0
                 ));
    }
    else
    {
        DbgLog(( LOG_TRACE, 5 ,
                 TEXT("pin categories don't match: Req (%08x) Found(%08x)") ,
                 pPinCatNeeded ? pPinCatNeeded->Data1 : 0,
                 pPin->clsPinCategory ? pPin->clsPinCategory->Data1 : 0
                 ));
    }


    if(fPinCatOk)
    {
        if(pPin->nMediums == 0)
        {
            // this pin advertises no mediums, so pin is ok if caller
            // doesn't care or caller accepts wildcard items.
            fMediumsOk = (pMedNeeded == 0 || !fExact);

            if(fMediumsOk)
            {
                DbgLog(( LOG_TRACE, 5 ,
                         TEXT("mediums match: Req (%08x) Found(*)") ,
                         pMedNeeded ? pMedNeeded->clsMedium.Data1 : 0));
            }
            else
            {
                DbgLog(( LOG_TRACE, 5 ,
                         TEXT("mediums don't match: Req (%08x) Found(*)") ,
                         pMedNeeded ? pMedNeeded->clsMedium.Data1 : 0));
            }
        }
        else
        {
            for (UINT iMedium = 0;
                 iMedium < pPin->nMediums;
                 iMedium++)
            {
                ASSERT(!fMediumsOk);
                const REGPINMEDIUM *pMedPin = &pPin->lpMedium[iMedium];

                // no reason to allocate a null medium
                ASSERT(pMedPin != 0);

                // caller doesn't care ||
                // items specified and match ||
                // caller accepts filter with wildcard item
                //
                if((pMedNeeded == 0) ||
                   (pMedNeeded != 0 && pMedPin != 0 && IsEqualMedium(pMedNeeded, pMedPin)) ||
                   (!fExact && pMedPin == 0))
                {
                    DbgLog(( LOG_TRACE, 5 ,
                             TEXT("mediums match: Req (%08x) Found(%08x)") ,
                             pMedNeeded ? pMedNeeded->clsMedium.Data1 : 0,
                             pMedPin ? pMedPin->clsMedium.Data1 : 0));

                    fMediumsOk = true;
                    break;
                }

                DbgLog(( LOG_TRACE, 5 ,
                         TEXT("No medium match yet: Req (%08x) Found(%08x)") ,
                         pMedNeeded ? pMedNeeded->clsMedium.Data1 : 0,
                         pMedPin ? pMedPin->clsMedium.Data1 : 0));
            }
        }
    }

    if(fMediumsOk && fPinCatOk)
    {
        //  No types to match == wild card
        if (cTypes == 0) {
            return TRUE;
        }

        for (UINT iType = 0; iType < pPin->nMediaTypes; iType++)
        {

            const REGPINTYPES *pType = &pPin->lpMediaType[iType];

            // test maj then min types tests look like
            //
            // caller doesn't care ||
            // items specified and match ||
            // caller accepts filter with wildcard item
            //
            for (DWORD i = 0; i < cTypes; i++)
            {
                const GUID& clsMajor = pTypes[i * 2];
                const GUID& clsSub = pTypes[i * 2 + 1];
                const BOOL bMajorNull = clsMajor == CLSID_NULL;
                const BOOL bSubNull = clsSub == CLSID_NULL;
                if(bMajorNull ||
                   (pType->clsMajorType && clsMajor == *pType->clsMajorType) ||
                   (!fExact && (pType->clsMajorType == 0 || *pType->clsMajorType == CLSID_NULL)))
                {

                    if(bSubNull ||
                       (pType->clsMinorType && clsSub == *pType->clsMinorType) ||
                       (!fExact && (pType->clsMinorType == 0 || *pType->clsMinorType == CLSID_NULL)))
                    {
                        DbgLog(( LOG_TRACE, 4 ,
                                 TEXT("Types match: Req (%08x %08x) Found(%08x %08x)") ,
                                 clsMajor.Data1, clsSub.Data1 ,
                                 pType->clsMajorType ? pType->clsMajorType->Data1 : 0,
                                 pType->clsMinorType ? pType->clsMinorType->Data1 : 0));

                        //  Check the wild card stuff
                        if (!bPayAttentionToWildCards) {
                            return TRUE;
                        }

                        //  Only delay wild card matching on 2nd
                        //  or subsequent types
                        if (i > 0) {

                            BOOL bMatchedNull = bMajorNull || bSubNull;
                            if (!bDoWildCards && !bMatchedNull) {
                                return TRUE;
                            }
                            if (bDoWildCards && !bMatchedNull) {
                                //  Exact match so don't enumerate
                                return FALSE;
                            }
                            if (bDoWildCards && bMatchedNull) {
                                //  This is a match provided we
                                //  don't subsequently find an exact
                                //  match
                                bMatched = TRUE;
                            }
#if 0
                            if (!bDoWildCards && bMatchedNull) {
                                //  Not a match we're interested in
                            }
#endif
                        } else {
                            //  Always return a match on the first type
                            //  in the first pass
                            return !bDoWildCards;
                        }
                    }
                }
            }

#if 0
            DbgLog(( LOG_TRACE, 5 ,
                     TEXT("No type match yet: Req (%08x %08x) Found(%08x %08x)") ,
                     clsMajor.Data1, clsSub.Data1 ,
                     pType->clsMajorType ? pType->clsMajorType->Data1 : 0,
                     pType->clsMinorType ? pType->clsMinorType->Data1 : 0));
#endif
        }
    }

    return bMatched;

} // FindType


//==============================================================================
// CheckInput
//
// See if the types for pPin* match {clsMajor, clsSub}
// If bMustRender is TRUE, see if the pin hkPin has Renders set true
// if all OK, return TRUE - any error return FALSE.
//==============================================================================
BOOL CMapperCache::CheckInput(
    const REGFILTERPINS2 * pPin,
    const GUID *pTypes,
    DWORD cTypes,
    const REGPINMEDIUM *pMed,
    const CLSID *pPinCatNeeded,
    bool fExact,
    BOOL bMustRender,
    BOOL bDoWildCards)
{
    if ( bMustRender && !(pPin->dwFlags & REG_PINFLAG_B_RENDERER)) {
        return FALSE;
    }

    return FindType( pPin, pTypes, cTypes, pMed, pPinCatNeeded, fExact, TRUE, bDoWildCards);
} // CheckInput



//==============================================================================
//
// RegEnumFilterInfo
//
// Precondition:  The registration stuff is cached and tolerably up to date
//                or else never yet cached.
//
// Return clsid and name of filters matching { {clsInput, bRender}, clsOutput}
//
// set pos to NULL and call it.  On future calls recall it with the pos
// that it returned last time.  If it returns a pos of NULL then that's the end.
// Further calls would go through them again.
//
// if bInputNeeded is TRUE then it requires at least one input pin to match
// if it is false then it ignores input pins.
// if bOutputNeeded is TRUE then it requires at least one output pin to match
// if it is false then it ignores output pins.
// CLSID_NULL acts as a wild card and matches any type, otherwise a type
// found on a pin of the appropriate direction must match the types given.
// If bMustRender is TRUE then it will only enumerate filters which have an
// input pin which is rendered (and of the right type).
// bMustRender without bInputNeeded is nonsense.
// return NOERROR if we found one
//        S_FALSE if we fell off the end without finding one
//        failure code if we failed (e.g. out of sync)
//==============================================================================

HRESULT CMapperCache::RegEnumFilterInfo
    ( Cursor & cur          // cursor
    , bool bExactMatch      // no wildcards
    , DWORD   dwMerit       // at least this merit needed
    , BOOL bInputNeeded
    , const GUID *pInputTypes
    , DWORD cInputTypes
    , const REGPINMEDIUM *pMedIn
    , const CLSID *pPinCatIn
    , BOOL    bMustRender   // input pin must be rendered
    , BOOL    bOutputNeeded // at least one output pin wanted
    , const GUID *pOutputTypes
    , DWORD cOutputTypes
    , const REGPINMEDIUM *pMedOut
    , const CLSID *pPinCatOut
    , IMoniker **ppMoniker    // [out] moniker for filter
    , CLSID * clsFilter       // [out]
    , const LPWSTR Name       // [out]
    )
{


    // if the registry cache has never been used, set it up.
    CAutoLock foo(this);

    HRESULT hr;

    if(dwMerit < m_dwMerit)
    {
        m_bRefresh = TRUE;
        m_dwMerit = dwMerit;
    }

    hr = Refresh();
    if (FAILED(hr)) return hr;

#if 0
    DbgLog(( LOG_TRACE, 3
           , TEXT("RegEnumFilterInfo pin %8x (%d: %8x %8x %d)-(%d: %8x %8x)")
           , pos, bInputNeeded, clsInMaj.Data1, clsInSub.Data1, bMustRender
           , bOutputNeeded, clsOutMaj.Data1, clsOutSub.Data1 ));
#endif

    ASSERT(m_ulCacheVer >= cur.ver);

    if (cur.pos==NULL)
    {
        cur.pos = m_plstFilter->GetHeadPosition();
        cur.ver = m_ulCacheVer;
        cur.bDoWildCardsOnInput = false;
    }
    else if (hr==S_FALSE || cur.ver != m_ulCacheVer)
    {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    // until we find a filter that meets the criteria, or until we run out of them
    for ( /* cur.pos */; cur.pos!=NULL; /*no-op*/ ) {

        CMapFilter * pFil;
        pFil = m_plstFilter->GetNext(cur.pos); // Get pFil, side-effect pos onto Next
        ASSERT( pFil !=NULL );

        if (cur.pos == NULL && !cur.bDoWildCardsOnInput) {
            for (DWORD cType = 1; cType < cInputTypes; cType++) {
                if (pInputTypes[cType * 2] == GUID_NULL ||
                    pInputTypes[cType * 2 + 1] == GUID_NULL) {
                    cur.bDoWildCardsOnInput = true;
                    cur.pos = m_plstFilter->GetHeadPosition();
                    break;
                }
            }
        }

        // We have a filter - now decide if we want it.
        // CLSID_NULL for media types means automatically passes criterion

        BOOL bOutputOK = !bOutputNeeded;
        BOOL bInputOK  = !bInputNeeded;

        DbgLog(( LOG_TRACE, 2, TEXT("RegEnumFilterInfo[%x]: Considering (%ls)")
               , cur.pos, DBG_MON_GET_NAME(pFil->pDeviceMoniker)));

        if (pFil->m_prf2->dwMerit<dwMerit) {
            DbgLog(( LOG_TRACE, 2, TEXT("RegEnumFilterInfo[%x]: Rejected (%ls) - insufficient merit")
                   , cur.pos, DBG_MON_GET_NAME(pFil->pDeviceMoniker)));
            continue;
        }

        for(UINT iPin = 0; iPin < pFil->m_prf2->cPins; iPin++)
        {
            if (bOutputOK && bInputOK)
                break;                        // no need to look further!


            const REGFILTERPINS2 * pPin = &pFil->m_prf2->rgPins2[iPin];
            ASSERT( pPin !=NULL );


            //............................................................
            // if input - see if we need it rendered, if so check it is
            // and see if its type matches.
            //............................................................

            if (!(pPin->dwFlags & REG_PINFLAG_B_OUTPUT)) {
                bInputOK = bInputOK ||
                           CheckInput(pPin,
                                      pInputTypes,
                                      cInputTypes,
                                      pMedIn,
                                      pPinCatIn,
                                      bExactMatch,
                                      bMustRender,
                                      cur.bDoWildCardsOnInput);
            } else {
                bOutputOK = bOutputOK ||
                            FindType(pPin,
                                     pOutputTypes,
                                     cOutputTypes,
                                     pMedOut,
                                     pPinCatOut,
                                     bExactMatch,
                                     FALSE,
                                     FALSE);
            }

        } // end pins loop


        if (bInputOK && bOutputOK) {

            // Get the Moniker or whatever
            if (pFil->pDeviceMoniker == NULL)
            {
                if (pFil->m_pstr == NULL) {
                    continue;
                }
                hr = ParseDisplayNameHelper(pFil->m_pstr, &pFil->pDeviceMoniker);
            }
            if (FAILED(hr)) {
                continue;
            }
            // Make sure we got the clsid
            if (clsFilter != NULL) {
                if (FAILED(GetMapFilterClsid(pFil, clsFilter))) {
                    DbgLog((LOG_ERROR, 2, TEXT("Couldn't get filter(%ls) clsid")
                           , DBG_MON_GET_NAME(pFil->pDeviceMoniker)));
                    continue;
                }
            }

            //-------------------------------------------------------------------
            // This filter is one we want!
            // Copy the the stuff into our parameters
            //-------------------------------------------------------------------

            if(ppMoniker)
            {
                *ppMoniker = pFil->pDeviceMoniker;
                (*ppMoniker)->AddRef();
            }

            if(Name)
            {
                WCHAR *wszFilterName;
                wszFilterName = MonGetName(pFil->pDeviceMoniker);
                if(wszFilterName)
                {
                    lstrcpyW(Name, wszFilterName);
                    CoTaskMemFree(wszFilterName);
                }
            }

#ifdef DEBUG
                WCHAR *wszFilterName;
                wszFilterName = MonGetName(pFil->pDeviceMoniker);
                if(wszFilterName)
                {
                    DbgLog(( LOG_TRACE, 2, TEXT("RegEnumFilterInfo returning %ls"), wszFilterName));
                    CoTaskMemFree(wszFilterName);
                }
#endif

            return NOERROR;

        }
        else {

            DbgLog(( LOG_TRACE, 3
                     , TEXT("RegEnumFilterInfo: %ls not wanted (input %s output %s)")
                     , DBG_MON_GET_NAME(pFil->pDeviceMoniker)
                     , (bInputOK ? "OK" : "wrong")
                     , (bOutputOK ? "OK" : "wrong")
                     ));


            continue; // look for the next filter
        }

    }

    return S_FALSE;   // fell off the end without finding one

} // RegEnumFilterInfo


#if 0

//==============================================================================
//
// RegEnumPinInfo
//
// hkPins on input must be an open key to \HKCR\CLSID\<clsid>\Pins.
// where <clsid> is the class id for the filter whose pins are enumerated.
// If TRUE is returned then te key is left open and data is returned.
// If FALSE is returned then the enumeration is finished and the key is closed.
//
// Set iPin to zero to start the enumeration, then increment it each time by 1
// and keep going until FALSE is returned.
// The enumeration is NOT guaranteed to deliver the pins in any particular order.
//
//==============================================================================

BOOL RegEnumPinInfo( int iPin             // cursor of the enumeration
                   , HKEY hkPins          //
                   , LPCWSTR Name
                   , CLSID  &MajorType
                   , CLSID  &SubType
                   , BOOL   &bAllowedMany
                   , BOOL   &bAllowedZero
                   , BOOL   &bOutput
                   , BOOL   &bIsRendered
                   )
{
    TCHAR szPinName[MAX_KEY_LEN];   // TCHAR type buffer for pin name
    DWORD cchPinName = MAX_KEY_LEN; // Keep RegEnumKeyEx happy
    FILETIME ft;                    // Keep RegEnumKeyEx happy
    LONG rc;                        // retcode from things we call


    //............................................................
    // Find the first/next \HKCR\<clsid>\Pins\<pin name>
    //............................................................

    rc = RegEnumKeyEx(hkPins, iPin, szPinName, &cchPinName, NULL, NULL, NULL, &ft);
    if (rc!=ERROR_SUCCESS) {
        RegCloseKey(hkPins);    // We're done
        return FALSE;
    }

    HKEY hkPin;


    //............................................................
    // Open \HKCR\<clsid>\Pins\<pin name>
    //............................................................

    rc = RegOpenKeyEx( hkPins, szPinName, NULL, KEY_READ, &hkPin);
    if (rc==ERROR_NO_MORE_ITEMS){             // normal  exit
        RegCloseKey(hkPins);
        return FALSE;
    }
    if (rc!=ERROR_SUCCESS) {
        RegCloseKey(hkPins);
        return FALSE;
    }


    //............................................................
    // Get the major type for \HKCR\<clsid>\Pins\<pin name>
    // and store it in appropriate parameter
    // If it's an input, see if it renders it.
    //............................................................

    if ( !GetRegClsid(hkPin, szMajorType, MajorType) ) {
        RegCloseKey(hkPins);
        RegCloseKey(hkPin);
        return FALSE;
    }


    //............................................................
    // Get the sub type for \HKCR\<clsid>\Pins\<pin name>
    // and store it in appropriate parameter
    // If it's an input, see if it renders it.
    //............................................................

    if ( !GetRegClsid(hkPin, szSubType, SubType) ) {
        RegCloseKey(hkPins);
        RegCloseKey(hkPin);
        return FALSE;
    }


    //............................................................
    // Get the direction for \HKCR\<clsid>\Pins\<pin name>
    //............................................................

    if ( !GetRegBool(hkPin, szDirection, bOutput) ) {
        RegCloseKey(hkPins);
        RegCloseKey(hkPin);
        return FALSE;
    }


    //............................................................
    // if input, see if it's rendered
    //............................................................

    if (bOutput==FALSE) {

        if ( !GetRegBool(hkPin,szIsRendered, bIsRendered) ) {
            RegCloseKey(hkPins);
            RegCloseKey(hkPin);
        }
    }

    //............................................................
    // Get bAllowedMany
    //............................................................

    if ( !GetRegBool(hkPin, szAllowedMany, bAllowedMany) ) {
        RegCloseKey(hkPins);
        RegCloseKey(hkPin);
        return FALSE;
    }



    //............................................................
    // Get bAllowedZero
    //............................................................

    if ( !GetRegBool(hkPin, szAllowedZero, bAllowedZero) ) {
        RegCloseKey(hkPins);
        RegCloseKey(hkPin);
        return FALSE;
    }


    //............................................................
    // Close \HKCR\<clsid>\Pins\<pin name>
    //............................................................
    RegCloseKey(hkPin);
    return TRUE;

} // RegEnumPinInfo

#endif // 0


//========================================================================
//
// EnumMatchingFiters
//
// Get an enumerator to list filters in the registry.
//========================================================================

STDMETHODIMP CFilterMapper2::EnumMatchingFilters
   ( IEnumRegFilters **ppEnum  // enumerator returned
   , DWORD dwMerit             // at least this merit needed
   , BOOL  bInputNeeded        // Need at least one input pin
   , CLSID clsInMaj            // input major type
   , CLSID clsInSub            // input sub type
   , BOOL bRender              // must the input be rendered?
   , BOOL bOutputNeeded        // Need at least one output pin
   , CLSID clsOutMaj           // output major type
   , CLSID clsOutSub           // output sub type
   )
{
    CheckPointer(ppEnum, E_POINTER);
    *ppEnum = NULL;           // default

    CEnumRegFilters *pERF;

    // Create a new enumerator, pass in the one and only cache

    CAutoLock cObjectLock(this);   // must lock to create only one cache ever.

    HRESULT hr = CreateEnumeratorCacheHelper();
    if(FAILED(hr))
        return hr;

    pERF = new CEnumRegFilters( dwMerit
                              , bInputNeeded
                              , clsInMaj
                              , clsInSub
                              , bRender
                              , bOutputNeeded
                              , clsOutMaj
                              , clsOutSub
                              , mM_pReg
                              );
    if (pERF == NULL) {
        return E_OUTOFMEMORY;
    }

    // Get a reference counted IID_IEnumRegFilters interface

    return pERF->QueryInterface(IID_IEnumRegFilters, (void **)ppEnum);

} // EnumMatchingFilters

// ========================================================================
// =====================================================================
// Methods of class CEnumRegFilters. This one should only return
// things which can be CoCreated (but doesn't yet)
//=====================================================================
//========================================================================


//=====================================================================
// CEnumRegFilters constructor
//=====================================================================

CEnumRegFilters::CEnumRegFilters( DWORD dwMerit
                                , BOOL bInputNeeded
                                , REFCLSID clsInMaj
                                , REFCLSID clsInSub
                                , BOOL bRender
                                , BOOL bOutputNeeded
                                , REFCLSID clsOutMaj
                                , REFCLSID clsOutSub
                                , CMapperCache * pReg
                                )
    : CUnknown(NAME("Registry filter enumerator"), NULL)
{
    mERF_dwMerit = dwMerit;
    mERF_bInputNeeded = bInputNeeded;
    mERF_bOutputNeeded = bOutputNeeded;
    mERF_clsInMaj = clsInMaj;
    mERF_clsInSub = clsInSub;
    mERF_bRender  = bRender;
    mERF_clsOutMaj = clsOutMaj;
    mERF_clsOutSub = clsOutSub;
    ZeroMemory(&mERF_Cur, sizeof(mERF_Cur));
    mERF_Finished = FALSE;
    mERF_pReg = pReg;

} // CEnumRegFilters constructor





//=====================================================================
// CEnumFilters destructor
//=====================================================================

CEnumRegFilters::~CEnumRegFilters()
{
   // Nothing to do

} // CEnumRegFilters destructor



//=====================================================================
// CEnumFilters::NonDelegatingQueryInterface
//=====================================================================

STDMETHODIMP CEnumRegFilters::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IEnumRegFilters) {
        return GetInterface((IEnumRegFilters *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
} // CEnumRegFilters::NonDelegatingQueryInterface



STDMETHODIMP CEnumRegFilters::Next
    (   ULONG cFilters,           // place this many Regfilters*
        REGFILTER ** apRegFilter,   // ...in this array of RegFilter*
        ULONG * pcFetched         // actual count passed returned here
    )
{
    CheckPointer(apRegFilter, E_POINTER);

    CAutoLock cObjectLock(this);
    // It's always possible that someone may decide that the clever
    // way to call this is to ask for filters a hundred at a time,
    // but I'm not optimising for that case.  The buffers returned
    // will be over-size and I'm not going to waste time re-sizing
    // and packing.

    ULONG cFetched = 0;           // increment as we get each one.

    if (mERF_Finished) {
        if (pcFetched!=NULL) {
            *pcFetched = 0;
        }
        return S_FALSE;
    }

    if (pcFetched==NULL && cFilters>1) {
        return E_INVALIDARG;
    }

    // Buffer in which the result is built
    // The buffer layout will be
    //        apRegFilter--->pRegFilter[0] -------       This lot
    //                       pRegFilter[1] --------+--   is allocated
    //                       . . .                 |  |  by our
    //                       pRegFilter[cFilters] -+--+--  caller
    //                                             |  |  |
    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX |  |  | XXXXXXXXXXXXXXX
    //                                             |  |  |
    //         REGFILTER <-------------------------   |  | This lot
    //            Filter Clsid                        |  | is allocated
    //            Filter Name                         |  | by us
    //               array of unsigned shorts in Name |  |
    //                                                |  |
    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX |  | XXXXXXXXXXXXXXX
    //                                                |  |
    //         REGFILTER <----------------------------   | Another buffer
    //            . . .                                  | allocated by us
    //                                                   |
    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX | XXXXXXXXXXXXXXX
    //                                                   |
    //         REGFILTER <-------------------------------  etc

    while(cFetched < cFilters) {


        REGFILTER * pRF
                  = (REGFILTER *)QzTaskMemAlloc(sizeof(REGFILTER)+ MAX_STRING);

        if (pRF==NULL) {
            break;
        }

        // Make Name point to first byte after REGFILTER
        pRF->Name = (LPWSTR)(pRF+1);   // that adds sizeof(REGFILTER)

        //----------------------------------------------------------------------
        // Get the next filter to return (including how many pins)
        //----------------------------------------------------------------------

        HRESULT hr;
        hr = mERF_pReg->RegEnumFilterInfo(
            mERF_Cur,
            false ,
            mERF_dwMerit ,
            mERF_bInputNeeded ,
            &mERF_clsInMaj,
            1,
            0 ,                 // medium in
            0 ,                 // pin category in
            mERF_bRender ,
            mERF_bOutputNeeded ,
            &mERF_clsOutMaj,
            1,
            0 ,                 // medium out
            0 ,                 // pin category out
            0 ,                 // moniker out
            &pRF->Clsid,
            pRF->Name
            );
        if (FAILED(hr)) {
            return hr;
        }
        if (hr==NOERROR) {
            apRegFilter[cFetched] = pRF;
            ++cFetched;
        } else if (hr==S_FALSE) {
            mERF_Finished = TRUE;
            QzTaskMemFree(pRF);
            break;
        } else {
#ifdef DEBUG
            TCHAR Msg[200];
            wsprintf(Msg, TEXT("Unexpected hresult (%d == 0x%8x) from RegEnumFilterInfo"), hr, hr);
            DbgBreakX(Msg);
#endif
            return E_UNEXPECTED;  // We have here an unexpected success code
                                  // from RegEnumFilterInfo (which should not
                                  // occur.  I have no idea what it means, but
                                  // it probably means that overall we failed.
        }

        if (mERF_Cur.pos==NULL) {
            mERF_Finished = TRUE;
            break;
        }

    } // for each filter

    if (pcFetched!=NULL) {
        *pcFetched = cFetched;
    }

    DbgLog(( LOG_TRACE, 4, TEXT("EnumRegFilters returning %d filters")
           , cFetched));

    return (cFilters==cFetched ? S_OK : S_FALSE);

} // CEnumRegFilters::Next

//========================================================================
//=====================================================================
// Methods of class CEnumRegMonikers
//=====================================================================
//========================================================================


//=====================================================================
// CEnumRegMonikers constructor
//=====================================================================

CEnumRegMonikers::CEnumRegMonikers(
    BOOL         bExactMatch,
    DWORD        dwMerit,
    BOOL         bInputNeeded,
    const GUID  *pInputTypes,
    DWORD        cInputTypes,
    const        REGPINMEDIUM *pMedIn,
    const        CLSID *pPinCatIn,
    BOOL         bRender,
    BOOL         bOutputNeeded,
    const GUID  *pOutputTypes,
    DWORD        cOutputTypes,
    const        REGPINMEDIUM *pMedOut,
    const        CLSID *pPinCatOut,
    CMapperCache *pReg,
    HRESULT     *phr
    )
    : CUnknown(NAME("Registry moniker enumerator"), NULL)
{
    mERF_cInputTypes = cInputTypes;
    mERF_cOutputTypes = cOutputTypes;
    mERF_dwMerit = dwMerit;
    mERF_bInputNeeded = bInputNeeded;
    mERF_bOutputNeeded = bOutputNeeded;
    mERF_clsInPinCat = pPinCatIn ? *pPinCatIn : GUID_NULL;
    mERF_bRender  = bRender;
    mERF_clsOutPinCat = pPinCatOut ? *pPinCatOut : GUID_NULL;
    ZeroMemory(&mERF_Cur, sizeof(mERF_Cur));
    mERF_Finished = FALSE;
    mERF_pReg = pReg;
    mERF_bExactMatch = bExactMatch ? true : false;

    if(pMedIn) {
        mERF_bMedIn = true;
        mERF_medIn = *pMedIn;
    } else {
        mERF_bMedIn = false;
    }

    if(pMedOut) {
        mERF_bMedOut = true;
        mERF_medOut = *pMedOut;
    } else {
        mERF_bMedOut = false;
    }

    mERF_pInputTypes = new GUID[cInputTypes * 2];
    mERF_pOutputTypes = new GUID[cOutputTypes * 2];
    if (mERF_pInputTypes == NULL || mERF_pOutputTypes == NULL) {
        *phr = E_OUTOFMEMORY;
    } else {
        CopyMemory(mERF_pInputTypes, pInputTypes, cInputTypes * (2 * sizeof(GUID)));
        CopyMemory(mERF_pOutputTypes, pOutputTypes, cOutputTypes * (2 * sizeof(GUID)));
    }

} // CEnumRegMonikers constructor




//=====================================================================
// CEnumFilters destructor
//=====================================================================

CEnumRegMonikers::~CEnumRegMonikers()
{
   delete [] mERF_pInputTypes;
   delete [] mERF_pOutputTypes;

} // CEnumRegMonikers destructor



//=====================================================================
// CEnumFilters::NonDelegatingQueryInterface
//=====================================================================

STDMETHODIMP CEnumRegMonikers::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IEnumMoniker) {
        return GetInterface((IEnumMoniker *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
} // CEnumRegMonikers::NonDelegatingQueryInterface



//=====================================================================
// CEnumFilters::Next
//=====================================================================

STDMETHODIMP CEnumRegMonikers::Next
    (   ULONG cFilters,           // place this many Regfilters*
        IMoniker **rgpMoniker,    // ...in this array of monikers
        ULONG * pcFetched         // actual count passed returned here
    )
{
    CheckPointer(rgpMoniker, E_POINTER);

    CAutoLock cObjectLock(this);
    // It's always possible that someone may decide that the clever
    // way to call this is to ask for filters a hundred at a time,
    // but I'm not optimising for that case.  The buffers returned
    // will be over-size and I'm not going to waste time re-sizing
    // and packing.

    ULONG cFetched = 0;           // increment as we get each one.

    if (mERF_Finished) {
        if (pcFetched!=NULL) {
            *pcFetched = 0;
        }
        return S_FALSE;
    }

    if (pcFetched==NULL && cFilters>1) {
        return E_INVALIDARG;
    }

    while(cFetched < cFilters) {


        //----------------------------------------------------------------------
        // Get the next filter to return (including how many pins)
        //----------------------------------------------------------------------

        IMoniker *pMon = 0;
        HRESULT hr;
        hr = mERF_pReg->RegEnumFilterInfo( mERF_Cur
                                         , mERF_bExactMatch
                                         , mERF_dwMerit
                                         , mERF_bInputNeeded
                                         , mERF_pInputTypes, mERF_cInputTypes
                                         , mERF_bMedIn ? &mERF_medIn : 0
                                         , mERF_clsInPinCat == GUID_NULL ? 0 : &mERF_clsInPinCat
                                         , mERF_bRender
                                         , mERF_bOutputNeeded
                                         , mERF_pOutputTypes, mERF_cOutputTypes
                                         , mERF_bMedOut ? &mERF_medOut : 0
                                         , mERF_clsOutPinCat == GUID_NULL ? 0 : &mERF_clsOutPinCat
                                         , &pMon, NULL, 0
                                         );
        if (FAILED(hr)) {
            return hr;
        }
        if (hr==NOERROR) {
            rgpMoniker[cFetched] = pMon;
            ++cFetched;
        } else if (hr==S_FALSE) {
            ASSERT(pMon == 0);
            mERF_Finished = TRUE;
            break;
        } else {
#ifdef DEBUG
            TCHAR Msg[200];
            wsprintf(Msg, TEXT("Unexpected hresult (%d == 0x%8x) from RegEnumFilterInfo"), hr, hr);
            DbgBreakX(Msg);
#endif
            return E_UNEXPECTED;  // We have here an unexpected success code
                                  // from RegEnumFilterInfo (which should not
                                  // occur.  I have no idea what it means, but
                                  // it probably means that overall we failed.
        }

        if (mERF_Cur.pos==NULL) {
            mERF_Finished = TRUE;
            break;
        }

    } // for each filter

    if (pcFetched!=NULL) {
        *pcFetched = cFetched;
    }

    DbgLog(( LOG_TRACE, 4, TEXT("EnumRegFilters returning %d filters")
           , cFetched));

    return (cFilters==cFetched ? S_OK : S_FALSE);

} // CEnumRegMonikers::Next


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// CFilterMapper2

CFilterMapper2::CFilterMapper2 ( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr )
        : CUnknown(pName, pUnk, phr),
          m_rgbBuffer(0)
{
    EnterCriticalSection(&mM_CritSec);
    InterlockedIncrement(&mM_cCacheRefCount);
    LeaveCriticalSection(&mM_CritSec);
}

CFilterMapper2::~CFilterMapper2()
{
    delete[] m_rgbBuffer;

    EnterCriticalSection(&mM_CritSec);
    LONG lRef = InterlockedDecrement(&mM_cCacheRefCount);
    ASSERT(lRef >= 0);          // refcount can't be negative
    // If the cache has been created - get rid of it again.
    if (lRef==0) {
        if (mM_pReg!=NULL) {
            delete mM_pReg;
            // We really need to set this to null
            mM_pReg = NULL;
        }
    }
    LeaveCriticalSection(&mM_CritSec);

}

HRESULT CFilterMapper2::RegisterFilter(
        /* [in] */ REFCLSID clsidFilter,
        /* [in] */ LPCWSTR Name,
        /* [out][in] */ IMoniker **ppMoniker,
        /* [in] */ const CLSID *pclsidCategory,
        /* [in] */ const OLECHAR *szInstance,
        /* [in] */ const REGFILTER2 *prf2)
{
    CheckPointer(Name, E_POINTER);

    CAutoLock foo(this);
    BreakCacheIfNotBuildingCache();

    IMoniker *pMonikerIn = 0;
    BOOL fMonikerOut = FALSE;

    TCHAR szDisplayName[16384];

    if(ppMoniker)
    {
        pMonikerIn = *ppMoniker;
        *ppMoniker = 0;
        if(!pMonikerIn)
            fMonikerOut = TRUE;
    }

    // set wszInstanceKey. if not passed in, use filter guid
    WCHAR wszInstanceKeyTmp[CHARS_IN_GUID];
    const WCHAR *wszInstanceKey;
    if(szInstance)
    {
        wszInstanceKey = szInstance;
    }
    else
    {
        StringFromGUID2(clsidFilter, wszInstanceKeyTmp, CHARS_IN_GUID);
        wszInstanceKey = wszInstanceKeyTmp;
    }

    //
    // get the moniker for this device
    //

    OLECHAR wszClsidCat[CHARS_IN_GUID], wszClsidFilter[CHARS_IN_GUID];
    IMoniker *pMoniker = 0;
    HRESULT hr = S_OK;

    const CLSID *clsidCat = pclsidCategory ? pclsidCategory : &CLSID_LegacyAmFilterCategory;
    EXECUTE_ASSERT(StringFromGUID2(*clsidCat, wszClsidCat, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);
    EXECUTE_ASSERT(StringFromGUID2(clsidFilter, wszClsidFilter, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);
    if(pMonikerIn == 0)
    {
        // Create or open HKCR/CLSID/{clsid}, and the instance key,
        // set FriendlyName, CLSID values
        USES_CONVERSION;
        const TCHAR *szClsidFilter = OLE2CT(wszClsidFilter);
        const TCHAR *szClsidCat = OLE2CT(wszClsidCat);

        IBindCtx *lpBC;
        hr = CreateBindCtx(0, &lpBC);
        if(SUCCEEDED(hr))
        {
            // no strcat on win95, so use tchars
            lstrcpy(szDisplayName, TEXT("@device:sw:"));
            lstrcat(szDisplayName, szClsidCat);
            lstrcat(szDisplayName, TEXT("\\"));
            lstrcat(szDisplayName, W2CT(wszInstanceKey));
            ULONG cchEaten;

            IParseDisplayName *ppdn;

            hr = CoCreateInstance(
                CLSID_CDeviceMoniker,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IParseDisplayName,
                (void **)&ppdn);
            if(SUCCEEDED(hr))
            {
                hr = ppdn->ParseDisplayName(
                    lpBC, T2OLE(szDisplayName), &cchEaten, &pMoniker);
                ppdn->Release();
            }

            lpBC->Release();
        }

    }
    else
    {
        pMoniker = pMonikerIn;
        pMonikerIn->AddRef();
    }


    //
    // write FriendlyName, clsid, and pin/mt data
    //

    if(SUCCEEDED(hr))
    {
        IPropertyBag *pPropBag;
        hr = pMoniker->BindToStorage(
            0, 0, IID_IPropertyBag, (void **)&pPropBag);
        if(SUCCEEDED(hr))
        {
            VARIANT var;
            var.vt = VT_BSTR;
            var.bstrVal = SysAllocString(Name);
            if(var.bstrVal)
            {
                hr = pPropBag->Write(L"FriendlyName", &var);
                SysFreeString(var.bstrVal);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString(wszClsidFilter);
                if(var.bstrVal)
                {
                    hr = pPropBag->Write(L"CLSID", &var);
                    SysFreeString(var.bstrVal);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

            }

            if(SUCCEEDED(hr))
            {
                // cbMax is set to the maxium size required
                ULONG cbMax = 0;
                hr = RegSquish(0, &prf2, &cbMax);
                if(SUCCEEDED(hr))
                {
                    BYTE *pbSquished = new BYTE[cbMax];
                    if(pbSquished)
                    {
                        // cbUsed is set to the exact size required
                        ULONG cbUsed = cbMax;
                        hr = RegSquish(pbSquished, &prf2, &cbUsed);
                        if(hr == S_OK)
                        {
                            // copy squished data to variant array now
                            // that we know the proper size.
                            VARIANT var;
                            var.vt = VT_UI1 | VT_ARRAY;
                            SAFEARRAYBOUND rgsabound[1];
                            rgsabound[0].lLbound = 0;
                            rgsabound[0].cElements = cbUsed;
                            var.parray = SafeArrayCreate(VT_UI1, 1, rgsabound);

                            if(var.parray)
                            {
                                BYTE *pbData;
                                EXECUTE_ASSERT(SafeArrayAccessData(
                                    var.parray, (void **)&pbData) == S_OK);

                                CopyMemory(pbData, pbSquished, cbUsed);

                                hr = pPropBag->Write(L"FilterData", &var);

                                EXECUTE_ASSERT(SafeArrayUnaccessData(
                                    var.parray) == S_OK);

                                EXECUTE_ASSERT(SafeArrayDestroy(
                                    var.parray) == S_OK);
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }

                        } // squish succeeded

                        delete[] pbSquished;

                    } // allocate pbSquish
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                } // squish to get size succeeded
            }

        } // bindtostorage

        pPropBag->Release();
    }

    if(SUCCEEDED(hr) && pMoniker)
    {
        if(fMonikerOut)
        {
            *ppMoniker = pMoniker;
        }
        else
        {
            pMoniker->Release();
        }
    }

    return hr;
}

HRESULT CFilterMapper2::CreateCategory(
    /* [in] */ REFCLSID clsidCategory,
    /* [in] */ const DWORD dwCategoryMerit,
    /* [in] */ LPCWSTR Description)
{
    HRESULT hr = S_OK;

    // Create or open ActiveMovie Filter Categories key
    CRegKey rkAMCat;
    LONG lResult = rkAMCat.Create(HKEY_CLASSES_ROOT, g_szKeyAMCat);
    if(lResult == ERROR_SUCCESS)
    {
        OLECHAR szClsid[CHARS_IN_GUID];
        StringFromGUID2(clsidCategory, szClsid, CHARS_IN_GUID);
        CRegKey rkCatGuid;

        USES_CONVERSION;
        lResult = rkCatGuid.Create(rkAMCat, OLE2CT(szClsid));

        if(lResult == ERROR_SUCCESS)
        {
            lResult = rkCatGuid.SetValue(W2CT(Description), TEXT("FriendlyName"));
            if(lResult == ERROR_SUCCESS)
            {
                OLECHAR wszGuid[CHARS_IN_GUID];
                StringFromGUID2(clsidCategory, wszGuid, CHARS_IN_GUID);
                lResult = rkCatGuid.SetValue(OLE2CT(wszGuid), TEXT("CLSID"));
            }
        }
        if(lResult == ERROR_SUCCESS)
        {
            lResult = rkCatGuid.SetValue(dwCategoryMerit, TEXT("Merit"));
        }
    }
    if(lResult != ERROR_SUCCESS)
    {
        hr = AmHresultFromWin32(lResult);
    }

    return hr;
}

HRESULT CFilterMapper2::UnregisterFilter(
    /* [in] */ const CLSID *pclsidCategory,
    /* [in] */ const OLECHAR *szInstance,
    /* [in] */ REFCLSID clsidFilter)
{
    HRESULT hr = S_OK;

    CAutoLock foo(this);
    BreakCacheIfNotBuildingCache();

    OLECHAR wszClsidCat[CHARS_IN_GUID];
    const CLSID *clsidCat = pclsidCategory ? pclsidCategory :
        &CLSID_LegacyAmFilterCategory;
    EXECUTE_ASSERT(StringFromGUID2(*clsidCat, wszClsidCat, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);

    USES_CONVERSION;

    // set wszInstanceKey. if not passed in, use filter guid
    WCHAR wszInstanceKeyTmp[CHARS_IN_GUID];
    const WCHAR *wszInstanceKey;
    if(szInstance)
    {
        wszInstanceKey = szInstance;
    }
    else
    {
        StringFromGUID2(clsidFilter, wszInstanceKeyTmp, CHARS_IN_GUID);
        wszInstanceKey = wszInstanceKeyTmp;
    }

    // build "CLSID\\{cat-guid}\\Instance. we put slashes where
    // the terminators go
    const cchszClsid = NUMELMS(szCLSID);
    const cchCatGuid = CHARS_IN_GUID;
    const cchInstance = NUMELMS(g_wszInstance);

    WCHAR *wszInstancePath = (WCHAR *)
        alloca((cchszClsid + cchCatGuid + cchInstance) * sizeof(WCHAR));

    CopyMemory(wszInstancePath,
               szCLSID,
               (cchszClsid - 1) * sizeof(WCHAR));
    wszInstancePath[cchszClsid - 1] = L'\\';

    CopyMemory(wszInstancePath + cchszClsid,
               wszClsidCat,
               (cchCatGuid - 1) * sizeof(WCHAR));
    wszInstancePath[cchszClsid + cchCatGuid - 1] = L'\\';

    CopyMemory(wszInstancePath + cchszClsid + cchCatGuid,
               g_wszInstance,
               cchInstance * sizeof(WCHAR)); // copy terminator

    LONG lResult;
    CRegKey rkInstance;
    if((lResult = rkInstance.Open(HKEY_CLASSES_ROOT, W2CT(wszInstancePath)),
        lResult == ERROR_SUCCESS) &&
       (lResult = rkInstance.RecurseDeleteKey(OLE2CT(wszInstanceKey)),
        lResult == ERROR_SUCCESS))
    {
        hr = S_OK;
    }
    else
    {
        hr = AmHresultFromWin32(lResult);
    }

    return hr;
}

#if 0
STDMETHODIMP CFilterMapper2::EnumMatchingFilters(
    /* [out] */ IEnumMoniker **ppEnum,
    /* [in] */ BOOL bExactMatch,
    /* [in] */ DWORD dwMerit,
    /* [in] */ BOOL bInputNeeded,
    /* [in] */ REFCLSID clsInMaj,
    /* [in] */ REFCLSID clsInSub,
    /* [in] */ const REGPINMEDIUM *pMedIn,
    /* [in] */ const CLSID *pPinCategoryIn,
    /* [in] */ BOOL bRender,
    /* [in] */ BOOL bOutputNeeded,
    /* [in] */ REFCLSID clsOutMaj,
    /* [in] */ REFCLSID clsOutSub,
    /* [in] */ const REGPINMEDIUM *pMedOut,
    /* [in] */ const CLSID *pPinCategoryOut
    )
{
    CheckPointer(ppEnum, E_POINTER);

    *ppEnum = NULL;           // default

    CEnumRegMonikers *pERM;

    // Create a new enumerator, pass in the one and only cache

    CAutoLock cObjectLock(this);   // must lock to create only one cache ever.

    HRESULT hr = CreateEnumeratorCacheHelper();
    if(FAILED(hr))
        return hr;

    GUID guidInput[2];
    guidInput[0] = clsInMaj;
    guidInput[1] = clsInSub;
    GUID guidOutput[2];
    guidOutput[0] = clsOutMaj;
    guidOutput[1] = clsOutSub;
    pERM = new CEnumRegMonikers(
        bExactMatch,
        dwMerit,
        bInputNeeded,
        guidInput,
        1,
        pMedIn,
        pPinCategoryIn,
        bRender,
        bOutputNeeded,
        guidOutput,
        1,
        pMedOut,
        pPinCategoryOut,
        mM_pReg,
        &hr
        );

    if (S_OK != hr || pERM == NULL) {
        delete pERM;
        return E_OUTOFMEMORY;
    }

    // Get a reference counted IID_IEnumMoniker interface

    return pERM->QueryInterface(IID_IEnumMoniker, (void **)ppEnum);
}
#endif

HRESULT BuildMediumCacheEnumerator(
    const REGPINMEDIUM  *pMedIn,
    const REGPINMEDIUM *pMedOut,
    IEnumMoniker **ppEnum)
{
    HRESULT hr;

    {
        HKEY hk;
        LONG lResult = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("System\\CurrentControlSet\\Control\\MediumCache"),
            0,                  // ulOptions
            KEY_READ,
            &hk);
        if(lResult == ERROR_SUCCESS)
        {
            RegCloseKey(hk);
        }
        else
        {
            // caller relies on S_FALSE on older platforms without a
            // MediumCache key to use mapper cache.
            return S_FALSE;
        }
    }

    TCHAR szMedKey[MAX_PATH];
    const REGPINMEDIUM *pmed = pMedIn ? pMedIn : pMedOut;

    const CLSID& rguid = pmed->clsMedium;
    wsprintf(
        szMedKey,
        TEXT("System\\CurrentControlSet\\Control\\MediumCache\\{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}-%x-%x"),
        rguid.Data1, rguid.Data2, rguid.Data3,
        rguid.Data4[0], rguid.Data4[1],
        rguid.Data4[2], rguid.Data4[3],
        rguid.Data4[4], rguid.Data4[5],
        rguid.Data4[6], rguid.Data4[7],
        pmed->dw1, pmed->dw2);

    HKEY hk;
    LONG lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        szMedKey,
        0,                  // ulOptions
        KEY_READ,
        &hk);

    TCHAR szValue[MAX_PATH]; // max symbolic link is 255 chars.
    if(lResult == ERROR_SUCCESS)
    {
        IMoniker *rgpmon[200];
        DWORD dwMonIndex = 0;
        for(DWORD dwIndex = 0; lResult == ERROR_SUCCESS && dwMonIndex < NUMELMS(rgpmon);
            dwIndex++)
        {
            DWORD cchValue = NUMELMS(szValue);
            PIN_DIRECTION dir;
            DWORD cbData = sizeof(dir);

            lResult = RegEnumValue(
                hk,
                dwIndex,
                szValue,
                &cchValue,
                0,              // lpReserved
                0,              // lpType
                (BYTE *)&dir,
                &cbData);

            ASSERT(cbData == sizeof(dir));

            if(lResult == ERROR_SUCCESS && (
                dir == PINDIR_OUTPUT && pMedOut ||
                dir == PINDIR_INPUT && pMedIn))
            {

                WCHAR wszDisplayName[MAX_PATH + 100];
                wsprintfW(wszDisplayName, L"@device:pnp:%s", szValue);

                IMoniker *pmon;
                hr = ParseDisplayNameHelper(wszDisplayName, &pmon);
                if(SUCCEEDED(hr))
                {
                    // The MediumCache key is never purged on win9x,
                    // so we need to check that the key is active. we
                    // could check g_amPlatform and not do the test on
                    // NT.
                    //
                    CIsActive *pcia;
                    bool fReleaseMon = true;
                    if(pmon->QueryInterface(CLSID_CIsActive, (void **)&pcia) == S_OK)
                    {
                        if(pcia->IsActive())
                        {
                            // keep refcount
                            rgpmon[dwMonIndex++] = pmon;
                            fReleaseMon = false;
                        }

                        pcia->Release();
                    }
                    if(fReleaseMon) {
                        pmon->Release();
                    }
                }
            }
        }

        EXECUTE_ASSERT(RegCloseKey(hk) == ERROR_SUCCESS);

        typedef CComEnum<IEnumMoniker,
            &IID_IEnumMoniker, IMoniker*,
            _CopyInterface<IMoniker> >
            CEnumMonikers;

        CEnumMonikers *pDevEnum;
        pDevEnum = new CComObject<CEnumMonikers>;
        if(pDevEnum)
        {
            IMoniker **ppMonikerRgStart = rgpmon;
            IMoniker **ppMonikerRgEnd = ppMonikerRgStart + dwMonIndex;

            hr = pDevEnum->Init(ppMonikerRgStart,
                                ppMonikerRgEnd,
                                0,
                                AtlFlagCopy);

            if(SUCCEEDED(hr))
            {
                hr = pDevEnum->QueryInterface(IID_IEnumMoniker, (void **)ppEnum);
                ASSERT(hr == S_OK);
            }
            else
            {
                delete pDevEnum;
            }

        }
        else
        {
            hr =  E_OUTOFMEMORY;
        }

        for(ULONG i = 0; i < dwMonIndex; i++)
        {
            rgpmon[i]->Release();
        }
    }
    else
    {
        hr = VFW_E_NOT_FOUND;
    }

    return hr;
}


STDMETHODIMP CFilterMapper2::EnumMatchingFilters(
    /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppEnum,
    /* [in] */ DWORD dwFlags,
    /* [in] */ BOOL bExactMatch,
    /* [in] */ DWORD dwMerit,
    /* [in] */ BOOL bInputNeeded,
    /* [in] */ DWORD cInputTypes,
    /* [size_is] */ const GUID __RPC_FAR *pInputTypes,
    /* [in] */ const REGPINMEDIUM __RPC_FAR *pMedIn,
    /* [in] */ const CLSID __RPC_FAR *pPinCategoryIn,
    /* [in] */ BOOL bRender,
    /* [in] */ BOOL bOutputNeeded,
    /* [in] */ DWORD cOutputTypes,
    /* [size_is] */ const GUID __RPC_FAR *pOutputTypes,
    /* [in] */ const REGPINMEDIUM __RPC_FAR *pMedOut,
    /* [in] */ const CLSID __RPC_FAR *pPinCategoryOut)
{
    CheckPointer(ppEnum, E_POINTER);
    *ppEnum = NULL;           // default

    CEnumRegMonikers *pERM;

    // if caller is searching for just one medium, use the MediumCache key
    if(bExactMatch &&
       !cInputTypes && !pPinCategoryIn &&
       !cOutputTypes && !pPinCategoryOut &&
       (pMedIn && !pMedOut || !pMedIn && pMedOut))
    {
        HRESULT hr = BuildMediumCacheEnumerator(pMedIn, pMedOut, ppEnum);
        if(hr != S_FALSE) {
            return hr;
        }
    }

    {
        // Create a new enumerator, pass in the one and only cache

        CAutoLock cObjectLock(this);   // must lock to create only one cache ever.

        HRESULT hr = CreateEnumeratorCacheHelper();
        if(FAILED(hr))
            return hr;

        pERM = new CEnumRegMonikers(
            bExactMatch,
            dwMerit,
            bInputNeeded,
            pInputTypes,
            cInputTypes,
            pMedIn,
            pPinCategoryIn,
            bRender,
            bOutputNeeded,
            pOutputTypes,
            cOutputTypes,
            pMedOut,
            pPinCategoryOut,
            mM_pReg,
            &hr
            );

        if (S_OK != hr || pERM == NULL) {
            delete pERM;
            return E_OUTOFMEMORY;
        }

        // Get a reference counted IID_IEnumMoniker interface
    }


    return pERM->QueryInterface(IID_IEnumMoniker, (void **)ppEnum);

}

HRESULT CFilterMapper2::CreateEnumeratorCacheHelper()
{
    ASSERT(CritCheckIn(this));  // not really necessary

    HRESULT hr = S_OK;
    EnterCriticalSection(&mM_CritSec);   // must lock to create only one cache ever.

    ASSERT(mM_cCacheRefCount > 0); // from our constructor

    if (mM_pReg==NULL) {
        DbgLog((LOG_TRACE, 3, TEXT("creating new mapper cache.")));

        // another mapper may be looking at a partially constructed
        // mapper cache without taking the global critical section
        // (calls to BreakCacheIfNotBuildingCache, for example). So
        // make sure they don't see an partially constructed cache.
        CMapperCache *pMapperCacheTmp = new CMapperCache;

        if (pMapperCacheTmp != NULL)
        {
            // force the compiler to do the assignment here since
            // mM_pReg pointer isn't volatile. (seems to do this
            // anyway).
            CMapperCache * /* volatile */ &pMapperCacheVol = mM_pReg;
            pMapperCacheVol = pMapperCacheTmp;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    LeaveCriticalSection(&mM_CritSec);

    return hr;
}

void CFilterMapper2::BreakCacheIfNotBuildingCache()
{
    // Break our registry cache
    InvalidateCache();

    // Break the internal cache
    if (mM_pReg!=NULL) {
        mM_pReg->BreakCacheIfNotBuildingCache();
    }
}

STDMETHODIMP CFilterMapper2::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IFilterMapper3) {
        return GetInterface((IFilterMapper3 *)this, ppv);
    } if (riid == IID_IAMFilterData) {
        return GetInterface((IAMFilterData *)this, ppv);
    } else if (riid == IID_IFilterMapper2) {
        return GetInterface((IFilterMapper2 *)this, ppv);
    } else if (riid == IID_IFilterMapper) {
        return GetInterface((IFilterMapper *)this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}
#ifdef DEBUG
extern bool g_fUseKASSERT;
#endif

void CFilterMapper2::MapperInit(BOOL bLoading,const CLSID *rclsid)
{
    UNREFERENCED_PARAMETER(rclsid);
    if (bLoading) {
        InitializeCriticalSection(&mM_CritSec);

#ifdef DEBUG
        // don't put up assert message boxes if we're running stress
        // -- break into the debugger instead.
        g_fUseKASSERT = (GetFileAttributes(TEXT("C:/kassert")) != 0xFFFFFFFF);
#endif

    } else {
        DeleteCriticalSection(&mM_CritSec);
    }

}

CUnknown *CFilterMapper2::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CFilterMapper2(NAME("filter mapper2"),pUnk, phr);

    // The idea was to only ever have one mapper - but:
    // Suppose one thread creates the first (and only) one successfully.
    // Another thread then tries to create one and, seeing that one exists
    // it returns that one.  Meanwhile, before it returns, the original
    // thread Releases and thereby destroys The Only One, so that the second
    // thread, when it resumes, is now returning a freed object.
    // So we just have static data instead.

} // CFilterMapper::Createinstance

STDMETHODIMP CFilterMapper2::GetICreateDevEnum( ICreateDevEnum **ppEnum )
{
    CAutoLock cObjectLock(this);   // must lock?

    HRESULT hr = CreateEnumeratorCacheHelper();
    if(SUCCEEDED(hr)) {
        if (!mM_pReg->m_pCreateDevEnum) {
            hr = CoCreateInstance( CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                                   IID_ICreateDevEnum, (void**)&mM_pReg->m_pCreateDevEnum);
        }
    }

    if (SUCCEEDED(hr)) {
        *ppEnum = mM_pReg->m_pCreateDevEnum;
        (*ppEnum)->AddRef();
    }

    return hr;
}


#include "fil_data_i.c"
STDMETHODIMP CFilterMapper2::ParseFilterData(
    /* [in, size_is(cb)] */ BYTE *rgbFilterData,
    /* [in] */ ULONG cb,
    /* [out] */ BYTE **prgbRegFilter2)
{
    *prgbRegFilter2 = 0;

    REGFILTER2 *prf2;
    REGFILTER2 **pprf2 = &prf2;

    HRESULT hr = UnSquish(
        rgbFilterData, cb,
        &pprf2);


    ASSERT(hr != S_FALSE);      // undefined

    if(hr == S_OK)
    {
        // allocated with CoTaskMemAlloc above.
        *prgbRegFilter2 = (BYTE *)pprf2;
    }

    return hr;
}

STDMETHODIMP CFilterMapper2::CreateFilterData(
    /* [in] */ REGFILTER2 *prf2_nc,
    /* [out] */ BYTE **prgbFilterData,
    /* [out] */ ULONG *pcb)
{
    *pcb = 0;
    *prgbFilterData = 0;

    const REGFILTER2 *&prf2 = prf2_nc;

    // cbMax is set to the maxium size required
    ULONG cbMax = 0;
    HRESULT hr = RegSquish(0, &prf2, &cbMax);
    if(SUCCEEDED(hr))
    {
        BYTE *pbSquished = (BYTE *)CoTaskMemAlloc(cbMax);
        if(pbSquished)
        {
            // cbUsed is set to the exact size required
            ULONG cbUsed = cbMax;
            hr = RegSquish(pbSquished, &prf2, &cbUsed);
            if(hr == S_OK)
            {
                *prgbFilterData = pbSquished;
                *pcb = cbUsed;
            }
            else
            {
                DbgBreak("bug somewhere if this happens?");

                // S_FALSE means too few bytes -- shouldn't happen
                ASSERT(FAILED(hr));
                CoTaskMemFree(pbSquished);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\mtutil.h ===
//==========================================================================;
//
//  Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


//==========================================================================
// MediaTypeToText
//
// set pText to point to QzTaskMemAlloc allocated storage, filled with an ANSI
// text representation of the media type.  At the moment, it's not fully ANSI
// because there's a binary format glob on the end which can be large (for
// instance it can include a whole palete).
//==========================================================================
HRESULT MediaTypeToText(CMediaType cmt, LPWSTR &pText);


// number of bytes in the string representation
int MediaTypeTextSize(CMediaType &cmt);


//============================================================================
// CMediaTypeFromText
//
// Initialises cmt from the UNICODE text string pstr.
// Does the inverse of CTextMediaType.
//============================================================================
HRESULT CMediaTypeFromText(LPWSTR pstr, CMediaType &cmt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\sort.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

//===========================================================================
// Filter ordering.
// State changes have to be propagated upstream. To do this, make a list
// of all the nodes in the graph in an acceptable order.  "Upstream" is
// normally only a partial ordering of the nodes of the graph.
// The list is ordered as follows:
// Let a Root node be one that is maximally downstream (i.e.. has no nodes
// downstream of it)
// Find all root nodes
//     by starting from each node in turn and taking all possible downstream
//     branches until you reach the end of each branch.
//     Merge this node into the set of roots.
//     (This is like enumerating leaves in a tree)
// Set all the filter rank nu mbers to 0.
// For each root node
//     Work upstream taking all possible branches and number the node according
//     to the number of steps taken to get there.  If the node has already been
//     numbered, then if its number is >= the proposed number then leave it
//     alone and don't explore that branch further, otherwise write in the
//     proposed number and contiune exploring that branch.
// Reorder the list to get it into upstream order.
//     The sort algorithm is dead crude as the list is expected to be short
//     If they ever become long enough to worry about, use a mergesort.
//     (There's a special purpose merge sort in the mapper)
// Record the version number of the filter graph that the list applies to.
//
// The version number is incremented by Add, AddSource, Remove, ConnectDirect,
// Connect, Render and Disconnect.
// If the version numbers match the list can be reused.  For normal usage
// I hope that the list will only need to be sorted once.
//
// The connections list is sorted DOWNSTREAM (that's the other way).
// Connections are sorted by completely re-building the list of connections.
// First the filters are sorted, then the filters list is traversed and for
// each filter we find each input connection and add it to the HEAD of the
// connections list.

// The calling tree is:
//     UpstreamOrder
//     |   ClearRanks
//     |   MergeRootNodes
//     |   |   MergeRootsFrom
//     |   |   |   Merge
//     |   |   |   MergeRootsFrom (recursing)
//     |   NumberNodes
//     |   |   NumberNodesFrom
//     |   |   |   NumberNodesFrom (recursing)
//     |   SortList
//         RebuildConnectionList

#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)
#include <hrExcept.h>

#include "distrib.h"
#include "fgenum.h"
#include "rlist.h"
#include "filgraph.h"

//===================================================================
//
// ClearRanks
//
// Set the Rank of every FilGen in cfgl to zero
//===================================================================

void CFilterGraph::ClearRanks( CFilGenList &cfgl)
{
    POSITION Pos;
    Pos = cfgl.GetHeadPosition();
    while(Pos!=NULL) {
        FilGen * pfg;
        pfg = cfgl.GetNext(Pos);    // side-efects Pos onto next
        pfg->Rank = 0;
    }
} // ClearRanks


//===================================================================
//
// Merge
//
// Merge this *filgen into the list of *filgen cfgl
// by AddTail-ing it if it isn't already there.
//===================================================================

void CFilterGraph::Merge( CFilGenList &cfgl, FilGen * pfg )
{
    // Run through the list.  If we find pfg then return
    // otherwise AddTail it to the list.

    POSITION Pos;
    Pos = cfgl.GetHeadPosition();
    while(Pos!=NULL) {
        FilGen * pfgCursor;
        pfgCursor = cfgl.GetNext(Pos);    // side-efects Pos onto next
        if (pfgCursor == pfg) {
            return;                        // we found it
        }
    }

    cfgl.AddTail(pfg);

} // Merge



//===================================================================
//
// MergeRootsFrom
//
// Merge into cfglRoots all the nodes which turn out to be
// maximally downstream, starting from pfg.  If pfg itself has
// no downstream connection then it gets merged in.
// Merging avoids adding duplicates.
// cfgAll is a list of all the FilGens in the graph.
// This is needed for mapping back from a filter to its FilGen.
// Rank fields must all be zero before calling this at the top level
// of recursion.
//===================================================================

HRESULT CFilterGraph::MergeRootsFrom
                     (CFilGenList &cfgAll, CFilGenList &cfglRoots, FilGen * pfg)
{
    // recursive tree walk

    // Circularity detection:
    // When we visit a node we decrement its Rank before exploring its branch.
    // When we leave it (unwinding the recursion) we increment it again.
    // Hitting a rank other than 0 means circularity.

    //------------------------------------------------------------------------
    // For pfgDownstream = each node which is a downstream connection from pfg
    //------------------------------------------------------------------------

    FilGen * pfgDownstream;

    int cDownstream;  // number of downstream connections found

    cDownstream = 0;
    --pfg->Rank;

    CEnumPin Next(pfg->pFilter, CEnumPin::PINDIR_OUTPUT);	// want output only
    IPin *pPin;

    while ((LPVOID) (pPin = Next())) {
        HRESULT hr;

        IPin *pConnected;
        hr = pPin->ConnectedTo( &pConnected );          // Get ConnectionInfo

        pPin->Release();

        if (SUCCEEDED(hr) && pConnected!=NULL) {          // if it's connected
            PIN_INFO PinInf;
            hr = pConnected->QueryPinInfo( &PinInf );   // Get PIN_INFO of peer
            pConnected->Release();
            ASSERT(SUCCEEDED(hr));

            pfgDownstream = cfgAll.GetByFilter(PinInf.pFilter);

            QueryPinInfoReleaseFilter(PinInf);

            // This error occurs when a filter which is in the filter graph is connected to
            // a filter which is not in the filter graph.  This can occur if the user uses 
            // IGraphConfig::RemoveFilterEx() to remove a filter without disconnecting its'
            // pins. 
            if( NULL == pfgDownstream ) {
                return VFW_E_NOT_IN_GRAPH;
            }

            if (pfgDownstream->Rank<0) {
                // It only SEEMS circular, it's not (or other code would
                // have prevented it from being built)
                //DbgBreak("Circular graph detected!");

                // The graph cannot be circular because CFilterGraph::ConnectDirectInternal()
                // will not connect two pins if connecting the pins would create a circular
                // filter graph.  CFilterGraph::ConnectDirectInternal() is the ONLY way to
                // legally connect two pins.  

                ++pfg->Rank;

                // We'll count the point we got to arbitrarily as a root.
		// This can't hurt because numbering nodes from here will never
		// give a higher score than numbering them from a REAL root.
                return S_OK;
            } else {
                //---------------------------------------------------------------
                // count it as a downstream connection and
                // merge its roots (recursively).
                //---------------------------------------------------------------
                ++cDownstream;                 // We are NOT maximally downstream
                HRESULT hr = MergeRootsFrom(cfgAll, cfglRoots, pfgDownstream);
                if( FAILED( hr ) ) {
                    return hr;
                }
            }
        }
    }
    ++pfg->Rank;        // restore it back to zero before we leave this branch

    if (cDownstream ==0) {
        Merge( cfglRoots, pfg );
    }
    return S_OK;
} // MergeRootsFrom



//===================================================================
//
// MergeRootNodes
//
// Merge into cfglRoots all the nodes in cfgl which are
// maximally downstream (i.e. have no downstream connections)
//===================================================================

HRESULT CFilterGraph::MergeRootNodes(CFilGenList & cfglRoots, CFilGenList &cfgl)
{
    FilGen * pfg;
    POSITION Pos;
    HRESULT hr;

    ClearRanks(cfgl);

    //-------------------------------------------------------------
    // for pfg = each node in cfgl
    //-------------------------------------------------------------
    Pos = cfgl.GetHeadPosition();
    while (Pos!=NULL) {
        pfg = cfgl.GetNext(Pos);

        //-------------------------------------------------------------
        // merge into cfglRoots all the roots found by starting from pfg
        //-------------------------------------------------------------
        hr = MergeRootsFrom(cfgl, cfglRoots, pfg);
        if( FAILED( hr ) ) {
            return hr;
        }
    }
    return S_OK;

} // MergeRootNodes



//===================================================================
//
// NumberNodesFrom
//
// Revise the Rank of all nodes reachable by upstream steps from pfg
// If we find the Rank of an immediately upstream node is set to >=cRank+1
// then we leave it alone.  Otherwise we set it to cRank+1 and recursively
// number the nodes on from it.
//===================================================================

HRESULT CFilterGraph::NumberNodesFrom( CFilGenList &cfgAll, FilGen * pfg, int cRank)
{
    // the 40000000 thing is to prevent infinite loops on cyclic-looking graphs
    // filters we've visited before won't be traversed past.
    pfg->Rank += 0x40000000;

    HRESULT hr;   // return code from things we call

    // recursive tree walk

    //------------------------------------------------------------------------
    // For pfgUpstream = each node which is an upstream connection from pfg
    //------------------------------------------------------------------------

    FilGen * pfgUpstream;

    CEnumPin Next(pfg->pFilter, CEnumPin::PINDIR_INPUT);	// input pins only
    IPin *pPin;

    while ((LPVOID) (pPin = Next())) {

        IPin *pConnected;
        hr = pPin->ConnectedTo( &pConnected );        // Get ConnectionInfo

        pPin->Release();

        if (SUCCEEDED(hr) && pConnected!=NULL) {      // if it's connected
            PIN_INFO PinInf;

            hr = pConnected->QueryPinInfo( &PinInf);  // Get PIN_INFO of peer
            pConnected->Release();
            ASSERT(SUCCEEDED(hr));

            pfgUpstream = cfgAll.GetByFilter(PinInf.pFilter);

            QueryPinInfoReleaseFilter(PinInf);

            // This error occurs when a filter which is in the filter graph is connected to
            // a filter which is not in the filter graph.  This can occur if the user uses 
            // IGraphConfig::RemoveFilterEx() to remove a filter without disconnecting its'
            // pins. 
            if( NULL == pfgUpstream ) {
                return VFW_E_NOT_IN_GRAPH;
            }

            //----------------------------------------------------------------
            // if it's worth numbering, Number on from pfgUpstream
            //----------------------------------------------------------------
            if (pfgUpstream->Rank < cRank+1) {
                pfgUpstream->Rank = cRank+1;
                HRESULT hr = NumberNodesFrom(cfgAll, pfgUpstream, cRank+1);
                if( FAILED( hr ) ) {
                    return hr;
                }
            } // worth numbering
        } //connected
    }

    pfg->Rank -= 0x40000000;

    return S_OK;
} // NumberNodesFrom




//===================================================================
//
// NumberNodes
//
// Store in the Rank of each node the maximum number of upstream steps
// from any node in cfglRoots
//===================================================================
HRESULT CFilterGraph::NumberNodes(CFilGenList &cfgl, CFilGenList &cfglRoots)
{
    HRESULT hr;
    POSITION Pos;

    // for pfg = each node in the graph
    Pos = cfglRoots.GetHeadPosition();;
    while (Pos!=NULL) {
        FilGen * pfg;
        pfg = cfglRoots.GetNext(Pos);

        hr = NumberNodesFrom(cfgl, pfg, 0);
        if( FAILED( hr ) ) {
            return hr;
        }
    }

    return S_OK;
} // NumberNodes



//===================================================================
//
// SortList
//
// sort cfgl so that lower Ranks appear before higher ones
// PRECONDITION: The ranks are all set to non-negative small numbers.
// If something has a rank of a few million it will go very slowly!
//===================================================================
void CFilterGraph::SortList( CFilGenList & cfgl )
{

    CFilGenList cfglGrow(NAME("Temporary filter sort list"), this);
    int iRank;


    //----------------------------------------------------------------
    // Make successive passes through cfgl pulling out all the nodes
    // with rank 1, then all with rank 2 etc.  AddTail these to the end of
    // the growing list and delete them from the original list.
    // Stop when they have all gone.
    //----------------------------------------------------------------

    for (iRank=0; cfgl.GetCount()>0; ++iRank) {
        POSITION Pos;
        Pos = cfgl.GetHeadPosition();;
        while (Pos!=NULL) {
            FilGen * pfg;
            POSITION OldPos = Pos;
            pfg = cfgl.GetNext(Pos);        // side-effect Pos onto the next
            if (pfg->Rank==iRank) {
               cfglGrow.AddTail( cfgl.Remove(OldPos) );
            }
        }
    }


    //----------------------------------------------------------------
    // cfglGrow now has everything in it in the right order
    // so copy them all back to cfgl and let cfglGrow destroy itself.
    //----------------------------------------------------------------

    cfgl.AddTail(&cfglGrow);

} // SortList




//===================================================================
//
// UpstreamOrder
//
// sort mFG_FilGenList into an order such that downstream nodes are
// always encountered before upstream nodes.  Sort the connections too.
// If there is a Storage, destroy and re-write the connections list to it.
//===================================================================
HRESULT CFilterGraph::UpstreamOrder()
{
    if (mFG_iVersion==mFG_iSortVersion) return NOERROR;

    MSR_INTEGER(mFG_idIntel, 2001);

    CFilGenList cfglRoots(NAME("List of root filters"), this);

    // Find all the root nodes.  (cfglRoots is initially empty)
    HRESULT hr = MergeRootNodes( cfglRoots, mFG_FilGenList);
    if( FAILED( hr ) ) {
        return hr;
    }

    // NOTE:  This leaves the graph with the old version set.
    // So we will continue trying to sort it.  We will not
    // Run or Pause without another go.  That will trap the error.

    // set all the ranks to zero (zero steps from a root)
    ClearRanks( mFG_FilGenList );

    // number all the nodes in the graph by distance from a root
    hr = NumberNodes( mFG_FilGenList, cfglRoots );
    if( FAILED( hr ) ) {
        return hr;
    }

    // Sort the list according to rank order
    SortList( mFG_FilGenList );

    mFG_iSortVersion = mFG_iVersion;

#ifdef THROTTLE
    FindRenderers();
#endif // THROTTLE

    return NOERROR;

} // UpstreamOrder


#ifdef THROTTLE
HRESULT CFilterGraph::FindPinAVType(IPin* pPin, BOOL &bAudio, BOOL &bVideo)
{
    bAudio = FALSE;
    bVideo = FALSE;

    CMediaType cmt;
    HRESULT hr = pPin->ConnectionMediaType(&cmt);

    if (FAILED(hr)) {
        // I guess we just plough on, feeling ill.
    } else {

        if (cmt.majortype==MEDIATYPE_Audio) {
            bAudio = TRUE;
        }
        if (cmt.majortype==MEDIATYPE_Video) {
            bVideo = TRUE;
        }
        FreeMediaType(cmt);
    }

    return NOERROR;
}
#endif // THROTTLE


#ifdef THROTTLE
//===============================================================================
// FindRenderers
//
// Find all the audio renderers;
// store a non-AddReffed IBaseFilter pointers in mFG_AudioRenderers<[]>.pf
// and an AddReffed IQualityControl* in mFG_AudioRenderers<[]>.piqc
//
// Find all the video renderers; store their AddReffed IQualityControl pointers
// in mFG_VideoRenderers<[]>.
//
// An Audio(/Video) renderer has an input pin that is connected with a type
// with majortype of MEDIATYPE_Audio(/MEDIATYPE_Video) and either has
// no output pins or the input pin supports QueryInternalConnections and
// goes nowhere.
// (Sigh) I suppose a filter could be both an audio and a video renderer.
// (Deep sigh) Multiple input pin audio renderers not supported.
//===============================================================================
HRESULT CFilterGraph::FindRenderers()
{
    HRESULT hr;
    ClearRendererLists();

    // for pfg->pFilter = each filter in the graph
    POSITION Pos = mFG_FilGenList.GetHeadPosition();
    while(Pos!=NULL) {
        // Make *pfg the current FilGen, side-effect Pos on to the next
        FilGen * pfg = mFG_FilGenList.GetNext(Pos);

        BOOL bHasOutputPin = FALSE;  // TRUE iff we ever find one
        BOOL bAudioRender = FALSE;   // TRUE<=>Found a pin that QIC says renders
        BOOL bVideoRender = FALSE;   // TRUE<=>Found a pin that QIC says renders
        BOOL bAudioPin = FALSE;      // TRUE<=>Found pin, but no QIC info
        BOOL bVideoPin = FALSE;      // TRUE<=>Found pin, but no QIC info

        // for pPin = each pin in pfg->pFilter
        //     (We could exit early if we have established already that it renders
        //      both types, but this is probably rare, so no early loop exits.)
        CEnumPin NextPin(pfg->pFilter);
        IPin *pPin;
        while ((LPVOID) (pPin = NextPin())) {

            // Check the direction
            PIN_DIRECTION pd;
            hr = pPin->QueryDirection(&pd);
            if (FAILED(hr)) {
                // Unknown direction!  really!!  Whatever next!!!
                // treat as output pin => we won't mess with it.
                bHasOutputPin = TRUE;
            } else if ( pd==PINDIR_OUTPUT ) {
                bHasOutputPin = TRUE;
            } 
            else {
                // it's an input pin
                BOOL bA;
                BOOL bV;
                hr = FindPinAVType(pPin, bA, bV);
                if ( (hr==NOERROR) && (bA || bV) ) {
                    // See if it is a pin that goes nowhere
                    ULONG nPin = 0;
                    hr = pPin->QueryInternalConnections(NULL, &nPin);
                    if (FAILED(hr)) {
                        if (bA) {
                            bAudioPin = TRUE; // wait to see if no output pins
                        }
                        if (bV) {
                            bVideoPin = TRUE; // wait to see if no output pins
                        }

                    } else if (hr==NOERROR) {
                        if (bA) {
                            bAudioRender = TRUE;
                        }
                        if (bV) {
                            bVideoRender = TRUE;
                        }
                    }
                }
            }

            pPin->Release();
        } // pins loop

        if (!bHasOutputPin) {
            if (bVideoPin) {
                bVideoRender = TRUE;
            }
            if (bAudioPin) {
                bAudioRender = TRUE;
            }
        }

        if (bAudioRender) {
            AudioRenderer* pAR = new AudioRenderer;
            if (pAR!=NULL) {
                pAR->pf = pfg->pFilter;

                hr = pAR->pf->QueryInterface( IID_IQualityControl
                                            , (void**)&pAR->piqc
                                            );
                if (SUCCEEDED(hr)) {
                    hr = pAR->piqc->SetSink(this);
                    ASSERT(SUCCEEDED(hr));
                    mFG_AudioRenderers.AddTail(pAR);
                } else {
                    // It's a dud - throw it all away
                    delete pAR;
                }
            }
        }

        if (bVideoRender) {
            IQualityControl * piqc;
            hr = pfg->pFilter->QueryInterface(IID_IQualityControl, (void**)&piqc);
            if (SUCCEEDED(hr)) {
                mFG_VideoRenderers.AddTail(piqc);
            }
        }
    } // filters loop

    return NOERROR;

} // FindRenderers


// Clear out anything that's in mFG_AudioRenderers and mFG_VideoRenderers
// Release any ref counts held
HRESULT CFilterGraph::ClearRendererLists()
{

    // for pAR = each audio renderer filter
    POSITION Pos = mFG_AudioRenderers.GetHeadPosition();
    while(Pos!=NULL) {
        // Retrieve the current IBaseFilter, side-effect Pos on to the next
        // but remember where we were to delete it.
        POSITION posDel = Pos;
        AudioRenderer * pAR = mFG_AudioRenderers.GetNext(Pos);

        // Undo the SetSink
        if (pAR->piqc) {
            pAR->piqc->SetSink(NULL);
            pAR->piqc->Release();
            pAR->piqc = NULL;
        }

        mFG_AudioRenderers.Remove(posDel);
        delete pAR;
    }

    // for piqc = the IQualityControl interface on each video renderer filter
    Pos = mFG_VideoRenderers.GetHeadPosition();
    while(Pos!=NULL) {
        // Retrieve the current IBaseFilter, side-effect Pos on to the next
        // but remember where we were to delete it.
        POSITION posDel = Pos;
        IQualityControl * piqc = mFG_VideoRenderers.GetNext(Pos);

        piqc->Release();
        mFG_VideoRenderers.Remove(posDel);
    }

    return NOERROR;

} // ClearRendererLists

#endif // THROTTLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\rlist.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.

// Filters are allowed to Reconnect, which breaks the current connection and remakes
// it with the same two filters.
// If two filters which are connected both did this simultaneously on their own
// threads then they could deadlock as each would already have the critical section
// for its one filter and would be asking for the CS of the other one.
// Therefore the filters do not do this themselves, they ask the filter graph
// to do it for them, and the worst that will happen is that the reconnect
// might get done twice.
// The filter graph cannot just do the reconnect on the thread that it is
// called on as that is (probably) a filter thread.  The obvious idea of
// spawning a separate thread and just doing the work there doesn't work
// either.  The following can (did!) occur:
//
// PROBLEM 1:
// A chain of filters were connected up in order to do an intelligent
// connection or Render.
// Call them A->B->C with B and C being added by the filter graph.
// A can accept types t1 or t2.
// B can also accept t1 or t1 so they agree on t1.
// C can only accept t2.
// B can accept that and sees that this is acceptable to A so agrees to
// connect to B with type t2 and asks to Reconnect the A->B link.
// The Reconnect thread is blocked because the filter graph is busy.
// The filter graph (possibly after adding other filters such as D,...)
// discovers that it cannot make the connection at all (or at least not
// that way) and BACKS OUT C AND B!!
// Eventually the connection either succeeds or fails, and the filter
// graph then attempts to reconnect A->B, but B is no longer there!
// At this point it access violates
//
// PROBLEM 2:
// Another awkward scenario is that we get a successful chain
// A->B->C with a reconnect scheduled for A->B.
// The filter graph returns and the application immediately asks the
// graph to Run. The Run occurs before the Reconnect thread gets in
// (this is a race) and the Reconnect fails because the graph is Running.
// Of course the Run fails because it's not properly connected!
//
// Some Possible alternatives:
// 1. Make Reconnect be robust about handling filters that have been Released
// (this would avoid the trap in the first scenario but nothing else)
//
// 2. When a Reconnect is scheduled (on the original thread) AddRef both
// ends of the connection.  This would stop the filters going away and would
// prevent the trap.  Better than solution 1, but doesn't solve problem 2.
//
// 3. Ensure that all Reconnects occur before anything else.  This means that
// we retain a list of pending Reconnects and complete these on the filter
// graph thread
//     A. Immediately before any back-out.
//     B. Immediately before returning.
// Filters are not allowed to call back to the filter graph (apart from
// Reconnect) so the filter graph will not be holding any embarrassing
// locks at those points.
//
// This is better than solution 2 as it has a crack at both problems,
// however it's wasting time doing Reconnects before backouts.  Those
// Reconnects should be thrown away.  It would be nice if we could just
// toss the whole list, but there's nothing to stop other filters from
// requesting a Reconnect during this time, and those have to be done.
//
// 4. (Variant on 3)
// Retain a list of Reconnects to be done, purge the list as part of
// Backout.  Execute whatever is left on the list on Return.
//
// Better still, but fails to handle "normal" Reconnects.  If a Reconnect
// comes in when the filter graph is NOT active, such a Reconnect must be
// done on a spawned thread.  This means that on return we have to switch
// from Reconnect-via-List to Reconnect-via-Thread mode.  Of course there
// can be a race or a window at that point, so we have to do the switch
// inside yet another critical section that Reconnect will also enter.
//
// 5. (The full solution)
// Retain a list of Reconnects which were requested when the filter graph
// was active.
// AddRef both pins when they go on the list, Release when reconnected
// AddRef the filter graph too the same way.
// Purge the list as part of Backout.
// Execute whatever is left on the list on Return.
// On Return, switch back to "normal" Reconnect-via-spawned-thread more.
// On Entry to the filter graph, switch to Reconnect-List mode.
// Have a Critical Section to control such switching.
//
// I expect the great majority of Reconnects to go via the List mechanism
// Most filter graph operations (AddFilter etc) are not affected by this.
// Only Connect(), Render() and RenderFile() are affected.
//
// This class implements it.

#ifndef __R_LIST__
#define __R_LIST__

typedef struct tagRLIST_DATA {
    struct tagRLIST_DATA *pNext;
    IPin                 *pPin;
    AM_MEDIA_TYPE        *pmt;
} RLIST_DATA;

//  there's no need for a lock here because the filter graph
//  is always locked when we consult the list
class CReconnectList
{
    public:
        // Constructor
        CReconnectList();

        // Destructor
        ~CReconnectList();

        // Make the list active - enter Reconnect-List mode
        void Active();

        // Execute all the actions on the list
        // Return to Reconnect-via-spawned thread mode
        void Passive();

        // Put an action on the list or spawn a thread according to mode
        HRESULT Schedule(IPin * pPin, AM_MEDIA_TYPE const *pmt);

        // Remove from the list any reconnects of this connection
        HRESULT Purge(IPin * pPin);

        // Actually do a reconnection
        HRESULT DoReconnect(IPin *pPin1, AM_MEDIA_TYPE const *pmt);

        LONG m_lListMode;        // ListMode == Active, non-list mode == Passive
    private:

        RLIST_DATA *m_RList;

}; // CReconnectList

#endif // __R_LIST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\sprov.h ===
// Copyright (c)2000 Microsoft Corporation.  All Rights Reserved.

#ifndef __SPROV__H_
#define __SPROV__H_

/////////////////////////////////////////////////////////////////////////////
//  CServiceProvider
//
//      Maintains a map between a service identifier guid (SID), and an IUnknown.
//      Objects can register COM objects, and other com objects can extract them
//      later.  This makes cross object access easier.  Only one object with a
//      give SID can be registered at any one time.   Registering another one will
//      cause the first one to be released.
//
//      To use:
//          1) some main object hosts the CServiceProvider
//                  pUnkMain,,,
//          2) That object supports a way for other objects to access it.  It
//              is suggested that it aggregates with this one.
//          3) The object intializes the client site...
//                 pUnkMain->SetServiceProviderClientSite(),
//                probably done in the SetSite() method call...
//          4) Some object access the main object, and registers a sub-object via.
//                  IRegisterServiceProvider *pRSP;
//                  CRandomComObject    cObj;
//                  hr = pUnkMain->QueryInterface(IRegisterServiceProvider, &pRSP);
//                  if(!FAILED(hr)) {
//                      IRandomInterface *pIRI;
//                      hr = cObj->QueryInterface(IRandomInterface, &pIRI);
//                      pRSP->RegisterService(SID, pIRI);
//          5) Some final object access the main object to locate this one
//                  IServiceProvider *pSP;
//                  hr = pUnkMain->QueryInterface(IServiceProvider, &pRSP);
//                  if(!FAILED(hr)) {
//                      IRandomInterface *pIRI;
//                      hr = pRSP->QueryService(SID, IID_IRandomInterface, &pIRI);
//
//
//      To avoid ref-counting circular loops, objects should never register themselves (or
//      objects that hold reference counts back on them).  They should always register
//      sub-objects.  Either that, or the system must call UnregisterAllServices()
//      before it's final release.
//
//      Objects are reference counted inside this internal list. They must be either unregistered
//      (by registering them with same SID and a NULL value), the object m_filterGraph object
//      must be deleted cleanly, or the UnRegisterAll() method must be called.
//      (Use of UnRegisterAll is not suggested.   Instead, registered services should not
//      refcount the filter graph to avoid introducing circular reference countes in the first place.)
// -----------------------------------------------------------------------------

class CFilterGraph;

//  Container for IServiceProvider objects
class CServiceProvider : public IServiceProvider,
                         public IRegisterServiceProvider
{
    //  Members
    CCritSec m_cs;                      // not using?  Not implemented?
    struct ProviderEntry {
        struct ProviderEntry *pNext;
        CComPtr <IUnknown> pProvider;
        GUID               guidService;
        ProviderEntry(IUnknown *pUnk, REFGUID guid) :
            pProvider(pUnk), guidService(guid)
        {
        }
    } *m_List;

public:

    CServiceProvider() : m_List(NULL)
    {
    }

    ~CServiceProvider()                 // deletes all services
    {
        UnregisterAll();
    }

    //  IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid,
                              void **ppv);

    //  IRegisterServiceProvider
    STDMETHODIMP RegisterService(REFGUID guidService, IUnknown *pService)
    {
        CAutoLock lck(&m_cs);
        ProviderEntry **ppSearch = &m_List;
        while (*ppSearch) {
            if ((*ppSearch)->guidService == guidService) {
                break;
            }
            ppSearch = &(*ppSearch)->pNext;
        }
        if (pService) {
            if (*ppSearch) {
                return E_FAIL;
            } else {
                ProviderEntry *pEntry = new ProviderEntry(pService, guidService);
                if (NULL == pEntry) {
                    return E_OUTOFMEMORY;
                }
                pEntry->pNext = m_List;		// push new entry onto front of list...
                m_List = pEntry;
                return S_OK;
            }
        } else {
            if (*ppSearch) {
                ProviderEntry *pEntry = *ppSearch;
                *ppSearch = pEntry->pNext;
                delete pEntry;
            }
            return S_OK;
        }
    }



    STDMETHODIMP UnregisterAll()                        // deletes all services
    {
        while (m_List) {
            ProviderEntry *pEntry = m_List;
            m_List = m_List->pNext;
            delete pEntry;
        }
        return S_OK;
    }
};

#endif // __SPROV__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\stats.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <stats.h>
#include <statsif.h>
#include <math.h>

CStat::CStat(LPCWSTR lpszName)
{
    m_dMultiplier = 1.0;
    Reset();

    //  Save the name
    AMGetWideString(lpszName, &m_szName);
}

CStat::~CStat()
{
    CoTaskMemFree(m_szName);
}

void CStat::Reset()
{
    m_lCount = 0;
    m_dTotal = 0.0;
    m_dSumSq = 0.0;
    m_dMin   = 0.0;
    m_dMax   = 0.0;
    m_dLast  = 0.0;
}


CStats::CStats() :
    m_nEntries(0),
    m_ppStats(NULL)
{
}

void CStats::Init()
{
    LARGE_INTEGER Freq;
    QueryPerformanceFrequency(&Freq);
    m_QPFMultiplier = 1000.0 / (double)Freq.QuadPart;
}

CStats::~CStats()
{
    for (long i = 0; i < m_nEntries; i++) {
        delete m_ppStats[i];
    }
    delete [] m_ppStats;
}

void CStats::Reset()
{
    CAutoLock lck(&m_cs);

    //  Free all the entries
    for (long i = 0; i < m_nEntries; i++) {
        m_ppStats[i]->Reset();
    }
}

long CStats::Find(LPCWSTR lpszName, bool bCreate)
{
    CAutoLock lck(&m_cs);

    for (long i = 0; i < m_nEntries; i++) {
        if (0 == lstrcmpiWInternal(lpszName, m_ppStats[i]->m_szName)) {
            return i;
        }
    }
    if (!bCreate) {
        return -1;
    }
    CStat *pStat = new CStat(lpszName);
    if (NULL == pStat || pStat->m_szName == NULL) {
        delete pStat;
        return -1;
    }
    //  Check if we can extend the array
    if (0 == (m_nEntries % ALLOCATION_SIZE)) {
        CStat **ppNew = new PCSTAT[m_nEntries + ALLOCATION_SIZE];
        if (ppNew == NULL) {
            delete pStat;
            return -1;
        }
        CopyMemory(ppNew, m_ppStats, m_nEntries * sizeof(ppNew[0]));
        delete [] m_ppStats;
        m_ppStats = ppNew;
    }
    m_ppStats[m_nEntries++] = pStat;
    return m_nEntries - 1;
}

HRESULT CStats::GetValues(
        long iStat,
        BSTR *szName,
        long *lCount,
        double *dLast,
        double *dAverage,
        double *dStdDev,
        double *dMin,
        double *dMax
)
{
    CAutoLock lck(&m_cs);
    if (iStat >= m_nEntries || iStat < 0) {
        return E_INVALIDARG;
    }
    if (szName) {
        *szName = SysAllocString(m_ppStats[iStat]->m_szName);
        if (*szName == NULL) {
            return E_OUTOFMEMORY;
        }
    }
    CStat *pStat = m_ppStats[iStat];

    *lCount = pStat->m_lCount;
    if (pStat->m_lCount != 0) {
        *dAverage = pStat->m_dTotal / pStat->m_lCount;
    } else {
        *dAverage = 0.0;
    }
    if (pStat->m_lCount > 1) {
        *dStdDev = sqrt((pStat->m_dSumSq - pStat->m_lCount * (*dAverage * *dAverage)) / (pStat->m_lCount - 1));
    } else {
        *dStdDev = 0.0;
    }
    *dMin = pStat->m_dMin;
    *dMax = pStat->m_dMax;
    *dLast = pStat->m_dLast;
    return S_OK;
}

//  This is like an initialization method
void CStats::SetMultiplier(long iStat, double dMultiplier)
{
    CAutoLock lck(&m_cs);
    m_ppStats[iStat]->m_dMultiplier = dMultiplier;
}

bool CStats::NewValue(LPCWSTR lpszName, double dValue)
{
    long iStat = Find(lpszName);
    if (iStat >= 0) {
        NewValue(iStat, dValue);
        return true;
    } else {
        return false;
    }
}

bool CStats::NewValue(LPCWSTR lpszName, LONGLONG dValue)
{
    long iStat = Find(lpszName);
    if (iStat >= 0) {
        NewValue(iStat, dValue);
        return true;
    } else {
        return false;
    }
}
bool CStats::NewValue(long iStat, LONGLONG llValue)
{
    return NewValue(iStat, (double)llValue);
}
bool CStats::NewValue(long iStat, double dValue)
{
    CAutoLock lck(&m_cs);
    if (iStat < 0 || iStat >= m_nEntries) {
        return false;
    }
    ASSERT(iStat < m_nEntries);
    CStat *pStat = m_ppStats[iStat];
    dValue *= pStat->m_dMultiplier;
    pStat->m_dLast = dValue;
    if (pStat->m_lCount == 0) {
        pStat->m_dMin = dValue;
        pStat->m_dMax = dValue;
    }
    pStat->m_lCount++;
    pStat->m_dTotal += dValue;
    pStat->m_dSumSq += dValue * dValue;
    if (dValue < pStat->m_dMin) {
        pStat->m_dMin = dValue;
    } else {
        if (dValue > pStat->m_dMax) {
            pStat->m_dMax = dValue;
        }
    }
    return true;
}

double CStats::GetQPFMultiplier()
{
    return m_QPFMultiplier;
}

double CStats::GetTime()
{
    LARGE_INTEGER li;
    QueryPerformanceCounter(&li);
    return (double)li.QuadPart * m_QPFMultiplier;
}

//  Reset all stats
STDMETHODIMP CStatContainer::Reset()
{
    g_Stats.Reset();
    return S_OK;
}

//  Get number of stats collected
STDMETHODIMP CStatContainer::get_Count(LONG* plCount)
{
    if (plCount == NULL) {
        return E_POINTER;
    }
    *plCount = g_Stats.m_nEntries;
    return S_OK;
}

//  Pull out a specific value by position
STDMETHODIMP CStatContainer::GetValueByIndex(
                             long lIndex,
                             BSTR *szName,
                             long *lCount,
                             double *dLast,
                             double *dAverage,
                             double *dStdDev,
                             double *dMin,
                             double *dMax)
{
    if (NULL == ((DWORD_PTR)szName |
                 (DWORD_PTR)lCount |
                 (DWORD_PTR)dLast |
                 (DWORD_PTR)dAverage |
                 (DWORD_PTR)dStdDev |
                 (DWORD_PTR)dMin |
                 (DWORD_PTR)dMax)) {
        return E_POINTER;
    }
    return g_Stats.GetValues(lIndex, szName, lCount, dLast, dAverage, dStdDev, dMin, dMax);
}

//  Pull out a specific value by name
STDMETHODIMP CStatContainer::GetValueByName(BSTR szName,
                       long *plIndex,
                       long *lCount,
                       double *dLast,
                       double *dAverage,
                       double *dStdDev,
                       double *dMin,
                       double *dMax)
{
    if (NULL == ((DWORD_PTR)plIndex |
                 (DWORD_PTR)lCount |
                 (DWORD_PTR)dLast |
                 (DWORD_PTR)dAverage |
                 (DWORD_PTR)dStdDev |
                 (DWORD_PTR)dMin |
                 (DWORD_PTR)dMax)) {
        return E_POINTER;
    }

    long lIndex = g_Stats.Find(szName);
    if (lIndex < 0) {
        return E_INVALIDARG;
    }
    *plIndex = lIndex;
    g_Stats.GetValues(lIndex, NULL, lCount, dLast, dAverage, dStdDev, dMin, dMax);
    return S_OK;
}

//  Return the index for a string - optinally create
STDMETHODIMP CStatContainer::GetIndex(BSTR szName,
                                       long lCreate,
                                       long *plIndex)
{
    if (plIndex == NULL) {
        return E_POINTER;
    }
    long lIndex = g_Stats.Find(szName, lCreate != 0);
    if (lIndex < 0) {
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }
    *plIndex = lIndex;
    return S_OK;
}

//  Add a new value
STDMETHODIMP CStatContainer::AddValue(long lIndex,
                      double dValue)
{
    return g_Stats.NewValue(lIndex, dValue) ? S_OK : E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\resource.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
// resource ids
#ifndef __FILGRAPH_RESOURCE__
#define __FILGRAPH_RESOURCE__

#define IDS_ADDFFAIL          1001
#define IDS_ADDFSUC           1002
#define IDS_ADDINGF           1003
#define IDS_BACKOUTDISC       1004
#define IDS_BACKOUTLEV        1005
#define IDS_BACKOUTREMF       1006
#define IDS_BACKOUTSB             1060
#define IDS_BESTCANDO         1007
#define IDS_BESTCANDONE       1008
#define IDS_CONNFAIL          1009
#define IDS_CONNING           1010
#define IDS_DISCON            1011
#define IDS_FOUNDF                1064
#define IDS_FOUNDF1           1012
#define IDS_FOUNDF2           1013
#define IDS_FOUNDP                1063
#define IDS_FOUNDP1           1014
#define IDS_FOUNDP2           1015
#define IDS_GETFFAIL          1016
#define IDS_ORIGINALP         1017
#define IDS_REMOVE            1018
#define IDS_RENDFILE          1019
#define IDS_RENDADDEDSOURCE   1020
#define IDS_RENDADDFAIL       1021
#define IDS_RENDADDSOURCEFAIL 1022
#define IDS_RENDBESTCANDONEP  1023
#define IDS_RENDBESTCANDOP    1024
#define IDS_RENDBESTCANFAIL   1025
#define IDS_RENDCONFAIL       1026
#define IDS_RENDCONNED        1027
#define IDS_RENDERADDEDF      1028
#define IDS_RENDERPART        1029
#define IDS_RENDERSUCP        1030
#define IDS_RENDFAILTOT       1031
#define IDS_RENDGETMTFAIL     1032
#define IDS_RENDLOADFAIL      1033
#define IDS_RENDMAJTYPE       1034
#define IDS_RENDNOOUT         1035
#define IDS_RENDNOPIN         1036
#define IDS_RENDNOTCON        1037
#define IDS_RENDOUTP          1038
#define IDS_RENDOUTPFAIL      1039
#define IDS_RENDOUTPPART      1040
#define IDS_RENDOUTPSUC       1041
#define IDS_RENDP             1042
#define IDS_RENDPART          1043
#define IDS_RENDPARTSOURCEP   1044
#define IDS_RENDPINCON        1045
#define IDS_RENDQISFAIL       1046
#define IDS_RENDRETCODE       1047
#define IDS_RENDSEARCHINP     1048
#define IDS_RENDSEARCHOUTP    1049
#define IDS_RENDSOURCEP       1050
#define IDS_RENDSTGFAIL       1051
#define IDS_RENDENDSB         1052
#define IDS_RENDTOTFAILP      1053
#define IDS_RENDTRYF          1054
#define IDS_RENDTRYNEWF       1055
#define IDS_RENDTRYP          1056
#define IDS_RENDWORTHLESS     1057
#define IDS_RENDPINCONFAIL    1058
#define IDS_RENDSUC           1059
#define IDS_SBFAIL                1062
#define IDS_STREAMBUILDING        1061

#define IDS_CONNECT           2001
#define IDS_CONNECTSUC        2002
#define IDS_CONNECTFAIL       2003
#define IDS_CONTOODEEP        2004
#define IDS_CONTRYDIRECT      2005
#define IDS_CONDIRECTSUC      2006
#define IDS_CONCON            2007
#define IDS_CONINDIRECTSUC    2008
#define IDS_CONINDIRECTFAIL   2009
#define IDS_CONVIAREG         2010
#define IDS_CONLOADFAIL       2011
#define IDS_CONLOADSUC        2012
#define IDS_CONADDFAIL        2013
#define IDS_CONNOMT           2014
#define IDS_CONVIA            2015
#define IDS_CONTRYPINS        2016
#define IDS_CONDISUC          2017
#define IDS_CONDIFAIL         2018
#define IDS_CONCOMPLFAIL      2019
#define IDS_CONCOMPLSUC       2020
#define IDS_CONQICFAIL        2021
#define IDS_CONRECURSE        2022
#define IDS_CONTOOMANYOUTPINS 2023
#define IDS_CONNOOUTPINS      2024
#define IDS_CONRECURSESUC     2025
#define IDS_CONRECURSEFAIL    2026
#define IDS_CONNOMOREINPINS   2027
#define IDS_CONNOMOREOUTPINS  2028
#define IDS_CONQICTOOMANY     2029


#define IDS_UNKNOWNFILETYPE   2500
#define IDS_GETMEDIATYPEFAIL  2501
#define IDS_MEDIATYPEFILE     2502
#define IDS_SOURCEFILTERCLSID 2503
#define IDS_SOURCECREATEFAIL  2504
#define IDS_NOSOURCEINTFCE    2505
#define IDS_LOADFAIL          2507
#define IDS_LOADED            2508
#define IDS_ADDSOURCEOK       2509
#define IDS_ADDFILTERFAIL     2510
#define IDS_ADDFILTEROK       2511

#endif // __FILGRAPH_RESOURCE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\rlist.cpp ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.

// Disable some of the sillier level 4 warnings
#pragma warning(disable: 4097 4511 4512 4514 4705)

//#include <windows.h>     already included in streams.h
#include <streams.h>
// Disable some of the sillier level 4 warnings AGAIN because some <deleted> person
// has turned the damned things BACK ON again in the header file!!!!!
#pragma warning(disable: 4097 4511 4512 4514 4705)
#include <rlist.h>

//========================================================================
//
// DoReconnect
//
// This is NOT a member of the class, because it is a thread procedure.
//
// Break the connection indicated by to lpv (which is really a ToDo *)
// and reconnect it with the same pins in the same filter graph.
// This is done "underneath" the filter graph.
//========================================================================

HRESULT CReconnectList::DoReconnect(IPin *pPin1, AM_MEDIA_TYPE const *pmt)
{
    Active();
    IPin *pPin2;

    HRESULT hr;                    // return code from things we call
    hr = pPin1->ConnectedTo(&pPin2);
    if (FAILED(hr)) {
        Passive();
        return hr;
    }

    //----------------------------------------------------------
    // find which pin is which, set ppIn, ppinOut
    //----------------------------------------------------------

    IPin * ppinIn;           // the input pin
    IPin * ppinOut;          // the output pin

    PIN_DIRECTION pd;
    hr = pPin1->QueryDirection(&pd);
    ASSERT(SUCCEEDED(hr));

    if (pd==PINDIR_INPUT) {
        ppinIn = pPin1;
        ppinOut = pPin2;
    } else {
        ppinOut = pPin1;
        ppinIn = pPin2;
    }

    // In debug builds show who is being reconnected to who

    #ifdef DEBUG

        PIN_INFO piInput,piOutput;
        WCHAR Format[128];
        CLSID FilterClsid;

        hr = ppinIn->QueryPinInfo(&piInput);
        ASSERT(SUCCEEDED(hr));
        hr = ppinOut->QueryPinInfo(&piOutput);
        ASSERT(SUCCEEDED(hr));

        DbgLog((LOG_TRACE,2,TEXT("Reconnecting pins")));
        DbgLog((LOG_TRACE,2,TEXT("Input pin name: %ws"),piInput.achName));
        DbgLog((LOG_TRACE,2,TEXT("Output pin name: %ws"),piOutput.achName));

        IPersist *pPersistInput = (IPersist *) piInput.pFilter;
        hr = pPersistInput->GetClassID(&FilterClsid);
        ASSERT(SUCCEEDED(hr));
        QzStringFromGUID2(FilterClsid,Format,128);
        DbgLog((LOG_TRACE,2,TEXT("Input pin CLSID: %ws"),Format));

        IPersist *pPersistOutput = (IPersist *) piOutput.pFilter;
        hr = pPersistOutput->GetClassID(&FilterClsid);
        ASSERT(SUCCEEDED(hr));
        QzStringFromGUID2(FilterClsid,Format,128);
        DbgLog((LOG_TRACE,2,TEXT("Output pin CLSID: %ws"),Format));

	QueryPinInfoReleaseFilter(piInput);
	QueryPinInfoReleaseFilter(piOutput);

    #endif // DEBUG

    //----------------------------------------------------------
    // Disconnect going upstream
    //----------------------------------------------------------

    hr = ppinIn->Disconnect();
    ASSERT(SUCCEEDED(hr));

    hr = ppinOut->Disconnect();
    ASSERT(SUCCEEDED(hr));

    //----------------------------------------------------------
    // reconnect - ask the output pin first.
    //----------------------------------------------------------
    hr = ppinOut->Connect(ppinIn, pmt);
    ASSERT (SUCCEEDED(hr));

    // Release everybody
    pPin2->Release();

    //
    // See if this caused any reconnections and do them if we
    // weren't previously in a reconnect sequence
    //
    Passive();

    // We didn't need to increment the filter graph's iVersion as the
    // filtergraph is back the way it was at least as far as topology goes.
    // However a media type has probably changed, so it's dirty.
    // Fortunately Connect already handled that.

    return 0;
} // DoReconnect



// Construct a CReconnectList in Passive mode
CReconnectList::CReconnectList()
              : m_lListMode(0)         // start in thread mode
              , m_RList(NULL)
{
} // CReconnectList constructor


// Destructor
// Free all the storage and Release all references.
// The filter graph is being destroyed, so abort it all.
CReconnectList::~CReconnectList()
{
    IPin *pPin;
    while (m_RList) {   // cast kills l4 warning
        DbgBreak("Reconnect list was not empty");
        RLIST_DATA *pData = m_RList;
        pData->pPin->Release();
        DeleteMediaType(pData->pmt);
        m_RList = pData->pNext;
        delete pData;
    }
} // ~CReconnectList



// Switch to Active (i.e. Reconnect-via-list) mode.
// The list is expected to be empty at this point.
void CReconnectList::Active()
{
    m_lListMode++;
} // Active



// Execute all the actions on the list
// Return to Passive (i.e. Reconnect-via-spawned thread) mode
void CReconnectList::Passive()
{
    m_lListMode--;
    ASSERT(m_lListMode >= 0);
    if (m_lListMode == 0) {
        IPin * pToDo;
        while (m_RList) {
            RLIST_DATA *pData = m_RList;
            m_RList = pData->pNext;
            DoReconnect(pData->pPin, pData->pmt);
            pData->pPin->Release();
            DeleteMediaType(pData->pmt);
            delete pData;
        }
    }
} // Passive



// Schedule a reconnection for pin pPin in the filter graph
// AddRef both pins (the one given and the other one) at once
// AddRef punk at once.
// Release it all when the reconnect is done
// (punk is the filter graph itself).
HRESULT CReconnectList::Schedule(IPin * pPin, AM_MEDIA_TYPE const *pmt)
{
     HRESULT hr;                       // return code from things we call

    //-----------------------------------------------------------------------
    // The pin must be connected (or else we won't be able to tell who to
    // reconnect it to)
    //-----------------------------------------------------------------------

    IPin *pConnected;
    hr = pPin->ConnectedTo(&pConnected);
    if (FAILED(hr)) return hr;
    pConnected->Release();

    if (m_lListMode) {

        RLIST_DATA *pData = new RLIST_DATA;
        if (pData == NULL) {
            return E_OUTOFMEMORY;
        }
        if (pmt) {
            pData->pmt = CreateMediaType(pmt);
            if (pData->pmt == NULL) {
                delete pData;
                return E_OUTOFMEMORY;
            }
        } else {
            pData->pmt = NULL;
        }

        pData->pNext = NULL;
        pData->pPin  = pPin;
        pPin->AddRef();

        //  Add it to the tail
        for (RLIST_DATA **ppDataSearch = &m_RList; *ppDataSearch != NULL;
             ppDataSearch = &(*ppDataSearch)->pNext) {
        }
        *ppDataSearch = pData;
        return NOERROR;
    } else {


        //-----------------------------------------------------------------------
        // Do it now
        //-----------------------------------------------------------------------

        DoReconnect(pPin, pmt);
        return NOERROR;
    }
} // Schedule


// Remove from the list any reconnects mentioning this pin
// Actually this will only be called for both pins
HRESULT CReconnectList::Purge(IPin * pPin)
{
    RLIST_DATA **ppData = &m_RList;
    while (*ppData!=NULL) {
        RLIST_DATA *pData = *ppData;
        IPin *pPin2;
        IPin *pPin1 = pData->pPin;
        HRESULT hr = pPin1->ConnectedTo(&pPin2);
        if (  FAILED(hr)
           || EqualPins(pPin1, pPin)
           || EqualPins(pPin2, pPin)
           ) {

            /*  Remove this entry */
            pPin1->Release();
            DeleteMediaType(pData->pmt);
            *ppData = pData->pNext;
            delete pData;
        } else {
            ppData = &pData->pNext;
        }
        if (SUCCEEDED(hr)) {
            pPin2->Release();
        }
    }
    return NOERROR;
} // Purge
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\statsif.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//  Container for stats info to expose it as an interface

class CStatContainer :
	public IDispatchImpl<IAMStats, &IID_IAMStats, &LIBID_QuartzTypeLib>,
	public CComObjectRootEx<CComMultiThreadModel>
{
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CStatContainer)
	COM_INTERFACE_ENTRY(IAMStats)
	COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

    CStatContainer() {}

    //  Interface methods

    //  Reset all stats
    STDMETHODIMP Reset();

    //  Get number of stats collected
    STDMETHODIMP get_Count(LONG* plCount);

    //  Pull out a specific value by position
    STDMETHODIMP GetValueByIndex(long lIndex,
                                 BSTR *szName,
                                 long *lCount,
                                 double *dLast,
                                 double *dAverage,
                                 double *dStdDev,
                                 double *dMin,
                                 double *dMax);

    //  Pull out a specific value by name
    STDMETHODIMP GetValueByName(BSTR szName,
                           long *lIndex,
                           long *lCount,
                           double *dLast,
                           double *dAverage,
                           double *dStdDev,
                           double *dMin,
                           double *dMax);

    //  Return the index for a string - optinally create
    STDMETHODIMP GetIndex(BSTR szName,
                          long lCreate,
                          long *plIndex);

    STDMETHODIMP AddValue(long lIndex, double dValue);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\squish\regtypes.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#ifndef _REGTYPES_H
#define _REGTYPES_H

// // OK to have zero instances of pin In this case you will have to
// // Create a pin to have even one instance
// #define REG_PIN_B_ZERO 0x1

// // The filter renders this input
// #define REG_PIN_B_RENDERER 0x2

// // OK to create many instance of  pin
// #define REG_PIN_B_MANY 0x4

// // This is an Output pin
// #define REG_PIN_B_OUTPUT 0x8

// format used to store filters in the registry

typedef struct
{
    CLSID clsMedium;
    DWORD dw1;
    DWORD dw2;
} REGPINMEDIUM_REG;

// structure used to identify media types this pin handles. these look
// like the ones used by IFilterMapper2 but are used to read the info
// out of the registry
typedef struct
{
    DWORD dwSignature;          // '0ty2'
    DWORD dwReserved;           // 0
    DWORD dwclsMajorType;
    DWORD dwclsMinorType;
} REGPINTYPES_REG2;

typedef struct
{
    DWORD dwSignature;          // '0pi2'
    DWORD dwFlags;
    DWORD nInstances;

    DWORD nMediaTypes;
    DWORD nMediums;
    DWORD dwClsPinCategory;
    
} REGFILTERPINS_REG2;

typedef struct
{
    // must match REGFILTER_REG2
    DWORD dwVersion;            // 1 
    DWORD dwMerit;
    DWORD dwcPins;

} REGFILTER_REG1;

typedef struct
{
    // first three must match REGFILTER_REG1
    DWORD dwVersion;            // 2
    DWORD dwMerit;
    DWORD dwcPins;
    DWORD dwReserved;           // 0
} REGFILTER_REG2;

// from ie4

typedef struct
{
    DWORD dwSignature;          // '0typ'
    CLSID clsMajorType;
    CLSID clsMinorType;
} REGPINTYPES_REG1;

typedef struct
{
    DWORD dwSignature;          // '0pin'
    DWORD dwFlags;
    CLSID clsConnectsToFilter;
    UINT nMediaTypes;
    DWORD rgMediaType;
    DWORD strName;              // ansi strings
    DWORD strConnectsToPin;

} REGFILTERPINS_REG1;

typedef struct
{
    DWORD dwiPin;               // pin to which these mediums belongs
    DWORD dwcMediums;           // number of mediums in list
    // array of dwcMediums REGPINMEDIUM_REG structures follow
} REGMEDIUMSDATA_REG;


#endif // _REGTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\util.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1999 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <atlbase.h>
#include "util.h"

//=====================================================================
//  Get a pin's direction
//=====================================================================
int Direction(IPin *pPin)
{
    PIN_DIRECTION dir;
    if (SUCCEEDED(pPin->QueryDirection(&dir))) {
        return dir;
    } else {
        return -1;
    }
}

bool IsConnected( IPin* pPin )
{
    IPin* pConnectedPin;

    HRESULT hr = pPin->ConnectedTo( &pConnectedPin );

    // IPin::ConnectedTo() sets its' *ppPin parameter to NULL if an error
    // occurs or the pin is unconnected.  If IPin::ConnectedTo() succeedes,
    // the *ppPin contains a pointer to the connected pin.
    ASSERT( (FAILED( hr ) && (NULL == pConnectedPin)) ||
            (SUCCEEDED( hr ) && (NULL != pConnectedPin)) );

    if( FAILED( hr ) ) {
        return false;
    }

    pConnectedPin->Release();

    return true;
}

void GetFilter(IPin *pPin, IBaseFilter **ppFilter)
{
    PIN_INFO pi;
    if (SUCCEEDED(pPin->QueryPinInfo(&pi))) {
        *ppFilter = pi.pFilter;
    } else {
        *ppFilter = NULL;
    }
}

HRESULT GetFilterWhichOwnsConnectedPin( IPin* pPin, IBaseFilter** ppFilter )
{
    // Prevent the caller from accessing random memory.
    *ppFilter = NULL;

    CComPtr<IPin> pConnectedPin;

    HRESULT hr = pPin->ConnectedTo( &pConnectedPin );

    // IPin::ConnectedTo() sets its' *ppPin parameter to NULL if an error
    // occurs or the pin is unconnected.  If IPin::ConnectedTo() succeedes,
    // the *ppPin contains a pointer to the connected pin.
    ASSERT( (SUCCEEDED(hr) && pConnectedPin) ||
            (FAILED(hr) && !pConnectedPin) );

    if( FAILED( hr ) ) {
        return VFW_E_NOT_CONNECTED;
    }

    CComPtr<IBaseFilter> pFilterWhichOwnsConnectedPin;

    GetFilter( pConnectedPin, &pFilterWhichOwnsConnectedPin );
    if( !pFilterWhichOwnsConnectedPin ) { // NULL == pDownStreamFilter
        return E_FAIL;
    }

    *ppFilter = pFilterWhichOwnsConnectedPin;
    (*ppFilter)->AddRef();

    return S_OK;
}

bool ValidateFlags( DWORD dwValidFlagsMask, DWORD dwFlags )
{
    return ( (dwValidFlagsMask & dwFlags) == dwFlags );
}

//  Registry helper to read DWORDs from the registry
//  Returns ERROR ... codes returned by registry APIs
LONG GetRegistryDWORD(HKEY hkStart, LPCTSTR lpszKey, LPCTSTR lpszValueName,
                      DWORD *pdwValue)
{
    HKEY hk;
    LONG lResult = RegOpenKeyEx(hkStart, lpszKey, 0, KEY_READ, &hk);
    if (ERROR_SUCCESS == lResult) {
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hk, lpszValueName, NULL,
                                  &dwType, (LPBYTE)pdwValue, &dwSize);
        RegCloseKey(hk);
    }
    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\squish\squish.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <aviriff.h>

#include "regtypes.h"
#include "squish.h"
#include "malloc.h"

//  code to take the REGFILTER2 structure and generate a REGFILTER_REG
//  structure for the FilterData value in the registry.

/* allocate space sequentially in memory block for FilterData
   block. return byte offset */
DWORD CSquish::RgAlloc(DWORD cb)
{
    ASSERT(cb % sizeof(DWORD) == 0);

    // our code makes sure enough space is available before hand
    ASSERT(cb <= m_rgMemAlloc.cbLeft);

    DWORD ib = m_rgMemAlloc.ib;
    m_rgMemAlloc.cbLeft -= cb;
    m_rgMemAlloc.ib += cb;

    return ib;
}

// return a offset to the guid (re-using any existing, matching guid)
//
DWORD CSquish::AllocateOrCollapseGuid(const GUID *pGuid)
{
    if(pGuid == 0) {
        return 0;
    }

    for(UINT iGuid = 0; iGuid < m_cGuids; iGuid++)
    {
        if(m_pGuids[iGuid] == *pGuid)
        {
            return (DWORD)((BYTE *)&m_pGuids[iGuid] - m_rgMemAlloc.pb);
        }
    }

    DWORD dwi = RgAlloc(sizeof(GUID));
    if(m_cGuids == 0) {
        m_pGuids = (GUID *)(m_rgMemAlloc.pb + dwi);
    }
    else
    {
        ASSERT(m_rgMemAlloc.pb + dwi == (BYTE *)(m_pGuids + m_cGuids));
    }
    m_pGuids[m_cGuids++] = *pGuid;
    return dwi;
}

DWORD CSquish::AllocateOrCollapseMedium(const REGPINMEDIUM *pMedium)
{
    if(pMedium == 0) {
        return 0;
    }

    for(UINT iMedium = 0; iMedium < m_cMediums; iMedium++)
    {
        if(IsEqualMedium(&m_pMediums[iMedium], pMedium))
        {
            return (DWORD)((BYTE *)&m_pMediums[iMedium] - m_rgMemAlloc.pb);
        }
    }

    DWORD dwi = RgAlloc(sizeof(REGPINMEDIUM));
    if(m_cMediums == 0) {
        m_pMediums = (REGPINMEDIUM *)(m_rgMemAlloc.pb + dwi);
    }
    else
    {
        ASSERT(m_rgMemAlloc.pb + dwi == (BYTE *)(m_pMediums + m_cMediums));
    }
    m_pMediums[m_cMediums++] = *pMedium;
    return dwi;
}

/* access same member (must be the same type) in two structures
   depending on dwVersion. The compiler does realize they are at the
   same offset. but it appears to compute structure offset often
   though */

#define GetPinMember(prf, i, member) (                  \
    prf->dwVersion == 1 ? prf->rgPins[i].member :       \
    prf->rgPins2[i].member)

#define GetTypeMember(prf, iPin, iType, member) (                       \
    prf->dwVersion == 1 ? prf->rgPins[iPin].lpMediaType[iType].member : \
    prf->rgPins2[iPin].lpMediaType[iType].member)

ULONG CSquish::CbRequiredSquish(const REGFILTER2 *pregFilter)
{
    ULONG cb = sizeof(REGFILTER_REG2);
    ULONG cPins = pregFilter->cPins;
    ULONG iPin;

    ASSERT(cb % sizeof(DWORDLONG) == 0);
    ASSERT(sizeof(REGFILTERPINS_REG2) % sizeof(DWORDLONG) == 0);
    ASSERT(sizeof(REGPINTYPES_REG2) % sizeof(DWORDLONG) == 0);

    cb += cPins * sizeof(REGFILTERPINS_REG2);

    for(iPin = 0; iPin < cPins; iPin++)
    {
        ULONG iType;
        const WCHAR *wszTmp;
        const CLSID *pclsidTmp;

        if(pregFilter->dwVersion == 2)
        {
            const REGFILTERPINS2 *prfp2 = &pregFilter->rgPins2[iPin];

            // space for the pointer and the medium for each medium
            cb += prfp2->nMediums *
                (sizeof(REGPINMEDIUM_REG) + sizeof(DWORD));

            if(prfp2->clsPinCategory) {
                cb += sizeof(GUID);
            }
        }

        // worst case: REGPINTYPES_REG struct + 2 guids per media type
        cb += (ULONG)(GetPinMember(pregFilter, iPin, nMediaTypes) *
            (sizeof(REGPINTYPES_REG2) + sizeof(GUID) * 2));
    }

    return cb;
}

// constructor
//
CSquish::CSquish() :
        m_pGuids(0),
        m_cGuids(0),
        m_pMediums(0),
        m_cMediums(0)
{

}

// fill out the bits. S_FALSE means caller needs to allocate *pcbUsed
// bytes in pb
// Filters are stored one after the other

HRESULT CSquish::RegSquish(
    BYTE *pb,
    const REGFILTER2 **ppregFilter,
    ULONG *pcbUsed,
    int nFilters
)
{
    HRESULT hr = S_OK;
    ULONG cbLeft;               /* bytes required */
    ULONG ib = 0;               /* current byte offset */

    if(pcbUsed == 0) {
        return E_POINTER;
    }

    // save pointer to the first pin for each filter
    REGFILTERPINS_REG2 **ppPinReg0 =
        (REGFILTERPINS_REG2 **)_alloca(nFilters * sizeof(REGFILTERPINS_REG2 *));

    // caller needs to know how much space to allocate. we don't care
    // much about performance registering filters; caller calls twice
    // per filter.
    cbLeft = 0;
    for (int i = 0; i < nFilters; i++) {
        cbLeft += CbRequiredSquish(ppregFilter[i]);
    }
    if(cbLeft > *pcbUsed)
    {
        *pcbUsed = cbLeft;
        return S_FALSE;
    }

    m_rgMemAlloc.ib = 0;
    m_rgMemAlloc.cbLeft = cbLeft;
    m_rgMemAlloc.pb = pb;

    for (int iFilter = 0; iFilter < nFilters; iFilter++) {
        const REGFILTER2 *pregFilter = ppregFilter[iFilter];
        if(pregFilter->dwVersion != 2 &&
           pregFilter->dwVersion != 1)
        {
            return E_INVALIDARG;
        }

        {
            DWORD dwi = RgAlloc(sizeof(REGFILTER_REG2));

            ((REGFILTER_REG2 *)(pb + dwi))->dwMerit = pregFilter->dwMerit;
            ((REGFILTER_REG2 *)(pb + dwi))->dwcPins = pregFilter->cPins;
            ((REGFILTER_REG2 *)(pb + dwi))->dwVersion = 2;
            ((REGFILTER_REG2 *)(pb + dwi))->dwReserved = 0;
        }


        UINT iPin;
        ULONG cPins = pregFilter->cPins;


        // first pass: allocate space for everything exceept the guids and
        // mediums at the end (the pins, mediatypes, and medium ptrs need
        // to be contiguous).

        for(iPin = 0; iPin < cPins; iPin++)
        {
            DWORD dwi = RgAlloc(sizeof(REGFILTERPINS_REG2));
            REGFILTERPINS_REG2 *pPinReg = (REGFILTERPINS_REG2 *)(pb + dwi);
            if(iPin == 0) {
                ppPinReg0[iFilter] = pPinReg;
            }

            {
                DWORD dwSig = FCC('0pi3');
                (*(BYTE *)&dwSig) += (BYTE)iPin;
                pPinReg->dwSignature = dwSig;
            }

            pPinReg->nMediaTypes = GetPinMember(pregFilter, iPin, nMediaTypes);
            RgAlloc(sizeof(REGPINTYPES_REG2) * pPinReg->nMediaTypes);

            if(pregFilter->dwVersion == 1)
            {
                const REGFILTERPINS *prfp = &pregFilter->rgPins[iPin];
                pPinReg->dwFlags =
                    (prfp->bRendered ? REG_PINFLAG_B_RENDERER : 0) |
                    (prfp->bOutput   ? REG_PINFLAG_B_OUTPUT   : 0) |
                    (prfp->bMany     ? REG_PINFLAG_B_MANY     : 0) |
                    (prfp->bZero     ? REG_PINFLAG_B_ZERO     : 0) ;

                pPinReg->nMediums = 0;
                pPinReg->nInstances = 0;
            }
            else
            {
                const REGFILTERPINS2 *prfp2 = &pregFilter->rgPins2[iPin];
                pPinReg->dwFlags = prfp2->dwFlags & (
                    REG_PINFLAG_B_RENDERER |
                    REG_PINFLAG_B_OUTPUT  |
                    REG_PINFLAG_B_MANY    |
                    REG_PINFLAG_B_ZERO);

                pPinReg->nMediums = prfp2->nMediums;
                RgAlloc(sizeof(DWORD) * pPinReg->nMediums);

                pPinReg->nInstances = prfp2->cInstances;
            }
        }
    }


    for (iFilter = 0; iFilter < nFilters; iFilter++) {
        const REGFILTER2 *pregFilter = ppregFilter[iFilter];
        // 2nd pass: fill in the pointers for guids
        REGFILTERPINS_REG2 *pPinReg = ppPinReg0[iFilter];
        UINT iPin;
        ULONG cPins = pregFilter->cPins;
        for(iPin = 0; iPin < cPins; iPin++)
        {

            const REGPINTYPES *rgpt = GetPinMember(pregFilter, iPin, lpMediaType);
            UINT ctypes = GetPinMember(pregFilter, iPin, nMediaTypes);

            if(pregFilter->dwVersion == 2)
            {
                const REGFILTERPINS2 *prfp2 = &pregFilter->rgPins2[iPin];
                pPinReg->dwClsPinCategory = AllocateOrCollapseGuid(prfp2->clsPinCategory);
            }
            else
            {
                pPinReg->dwClsPinCategory = 0;
            }

            // media types start immediately after pin this pin
            REGPINTYPES_REG2 *pmtReg = (REGPINTYPES_REG2 *)(pPinReg + 1);

            for(UINT imt = 0; imt < ctypes; imt++)
            {
                DWORD dwSig = FCC('0ty3');
                (*(BYTE *)&dwSig) += (BYTE)imt;
                pmtReg->dwSignature = dwSig;

                pmtReg->dwclsMajorType = AllocateOrCollapseGuid(rgpt[imt].clsMajorType);
                pmtReg->dwclsMinorType = AllocateOrCollapseGuid(rgpt[imt].clsMinorType);
                pmtReg->dwReserved = 0;
                pmtReg++;
            }


            // mediums start immediately after media types
            DWORD *pmedReg = (DWORD *)pmtReg;
            if(pregFilter->dwVersion == 2)
            {
                const REGFILTERPINS2 *prfp2 = &pregFilter->rgPins2[iPin];
                UINT cMediums = prfp2-> nMediums;
                pmedReg += cMediums;
            }

            // then comes the next pin
            pPinReg = (REGFILTERPINS_REG2 *)pmedReg;
        }
    }

    for (iFilter = 0; iFilter < nFilters; iFilter++) {
        // 3rd pass: fill in the pointers for mediums
        const REGFILTER2 *pregFilter = ppregFilter[iFilter];
        REGFILTERPINS_REG2 *pPinReg = ppPinReg0[iFilter];
        UINT iPin;
        ULONG cPins = pregFilter->cPins;
        for(iPin = 0; iPin < cPins; iPin++)
        {
            // media types start immediately after pin
            REGPINTYPES_REG2 *pmtReg = (REGPINTYPES_REG2 *)(pPinReg + 1);
            UINT ctypes = GetPinMember(pregFilter, iPin, nMediaTypes);
            pmtReg += ctypes;

            // mediums start immediately after media types
            DWORD *pmedReg = (DWORD *)pmtReg;
            if(pregFilter->dwVersion == 2)
            {
                const REGFILTERPINS2 *prfp2 = &pregFilter->rgPins2[iPin];
                UINT cMediums = prfp2->nMediums;
                const REGPINMEDIUM *rgrpm = prfp2->lpMedium;
                for(UINT iMed = 0; iMed < cMediums; iMed++)
                {
                    *pmedReg = AllocateOrCollapseMedium(rgrpm);
                    rgrpm++;
                    pmedReg++;
                }
            }

            // then comes the next pin
            pPinReg = (REGFILTERPINS_REG2 *)pmedReg;
        }
    }

    *pcbUsed = m_rgMemAlloc.ib;

    return hr;
}

HRESULT
RegSquish(
    BYTE *pb,
    const REGFILTER2 **ppregFilter,
    ULONG *pcbUsed,
    int nFilters
)
{
    CSquish rs;
    return rs.RegSquish(pb, ppregFilter, pcbUsed, nFilters);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\squish\squish.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
// code to convert between the REGFILTER2 structure (defined in
// axextend.idl) and the REGFILTER_REG structure (defined in
// regtypes.h).

// exported functions

HRESULT RegSquish(
    BYTE *pb,                   // REGFILTER_REG (version = 2) out; can be null
    const REGFILTER2 **ppregFilter, // in
    ULONG *pcbUsed,               // bytes necessary/used
    int nFilters = 1);            //

HRESULT UnSquish(
    BYTE *pbSrc, ULONG cbIn,    // REGFILTER_REG (1 or 2) in
    REGFILTER2 ***pppDest,        // out
    int nFilters = 1);


// private stuff

struct RgMemAlloc
{
    DWORD ib;                   /* current byte */
    DWORD cbLeft;               /* bytes left */
    BYTE *pb;                   /* beginning of block */
};


class CSquish
{
public:
    CSquish();
    HRESULT RegSquish(BYTE *pb, const REGFILTER2 **pregFilter, ULONG *pcbUsed, int nFilters);
private:

    RgMemAlloc m_rgMemAlloc;

    // pointer to first guid/medium
    GUID *m_pGuids;
    REGPINMEDIUM *m_pMediums;

    // # allocated in m_pGuids/mediums
    UINT m_cGuids;
    UINT m_cMediums;

    DWORD RgAlloc(DWORD cb);
    DWORD AllocateOrCollapseGuid(const GUID *pGuid);
    DWORD AllocateOrCollapseMedium(const REGPINMEDIUM *pMed);
    ULONG CbRequiredSquish(const REGFILTER2 *pregFilter);
};

class CUnsquish
{
public:
    HRESULT UnSquish(
        BYTE *pbSrc, ULONG cbIn,
        REGFILTER2 ***pppDest, int iFilters);

private:
    RgMemAlloc m_rgMemAlloc;

    HRESULT CUnsquish::CbRequiredUnquishAndValidate(
        const BYTE *pbSrc,
        ULONG *pcbOut, ULONG cbIn
        );

    inline void *RgAllocPtr(DWORD cb);
    HRESULT UnSquishPins(
        REGFILTER2 *prf2, const REGFILTER_REG1 **prfr1, const BYTE *pbSrc);

    HRESULT UnSquishTypes(
        REGFILTERPINS2 *prfp2,
        const REGFILTERPINS_REG1 *prfpr1,
        const BYTE *pbSrc);

};

static inline bool IsEqualMedium(
    const REGPINMEDIUM *rp1,
    const REGPINMEDIUM *rp2)
{
    return
        rp1->clsMedium == rp2->clsMedium &&
        rp1->dw1 == rp2->dw1 &&
        rp1->dw2 == rp2->dw2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\squish\unsquish.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <aviriff.h>

#include "regtypes.h"
#include "squish.h"

// code to parse the FilterData value in the registry and return the
// REGFILTER2 structure defined in axextend.idl

/* allocate space sequentially in memory block for a structure
   block. return pointer.  */
/* inline */ void *CUnsquish::RgAllocPtr(DWORD cb)
{

    // our code makes sure enough space is available before hand
    ASSERT(cb <= m_rgMemAlloc.cbLeft);
    ASSERT(cb % sizeof(DWORD) == 0);

    DWORD ib = m_rgMemAlloc.ib;
    m_rgMemAlloc.cbLeft -= cb;
    m_rgMemAlloc.ib += cb;

    return ib + m_rgMemAlloc.pb;
}

// for the REGFILTERPINS_REG1 (old format) of pins only: parse the
// media types.

HRESULT CUnsquish::UnSquishTypes(
    REGFILTERPINS2 *prfp2,
    const REGFILTERPINS_REG1 *prfpr1,
    const BYTE *pbSrc)
{
    UINT imt;
    UINT cmt = prfpr1->nMediaTypes;
    REGPINTYPES *prpt = (REGPINTYPES *)RgAllocPtr(sizeof(REGPINTYPES) * cmt);

    prfp2->lpMedium = 0;
    prfp2->nMediums = 0;

    prfp2->lpMediaType = prpt;
    prfp2->nMediaTypes = cmt;

    for(imt = 0; imt < cmt ; imt++)
    {
        REGPINTYPES_REG1 *prptr = (REGPINTYPES_REG1 *)(pbSrc + prfpr1->rgMediaType) + imt;

        prpt->clsMajorType = (CLSID *)RgAllocPtr(sizeof(CLSID));
        CopyMemory((void *)prpt->clsMajorType, &prptr->clsMajorType, sizeof(GUID));

        prpt->clsMinorType = (CLSID *)RgAllocPtr(sizeof(CLSID));
        CopyMemory((void *)prpt->clsMinorType, &prptr->clsMinorType, sizeof(GUID));

        prpt++;
    }


    return S_OK;
}

// parse the pins
//
HRESULT CUnsquish::UnSquishPins(
    REGFILTER2 *prf2,           /* output */
    const REGFILTER_REG1 **pprfr1,
    const BYTE *pbSrc)
{
    HRESULT hr = S_OK;
    ASSERT(pprfr1);              // from validate step
    const REGFILTER_REG1 *prfr1 = *pprfr1;

    /* beginning of the buffer read from the registry */
    if(prfr1->dwVersion == 0)
    {
        UINT cPins = prf2->cPins;

        REGFILTERPINS2 *prfp2 = (REGFILTERPINS2 *)RgAllocPtr(sizeof(REGFILTERPINS2) * cPins);
        prf2->rgPins2 = prfp2;

        // array of pins is immediately after the REGFILTER_REG
        // structure
        REGFILTERPINS_REG1 *prfpr = (REGFILTERPINS_REG1 *)(prfr1 + 1);

        for(UINT iPin = 0; iPin < cPins; iPin++, prfpr++)
        {
            prfp2->dwFlags = prfpr->dwFlags & (REG_PINFLAG_B_RENDERER |
                                               REG_PINFLAG_B_OUTPUT |
                                               REG_PINFLAG_B_MANY |
                                               REG_PINFLAG_B_ZERO);

            // not available in the old format
            prfp2->cInstances = 0;
            prfp2->clsPinCategory = 0;

            hr = UnSquishTypes(prfp2, prfpr, pbSrc);
            if(FAILED(hr)) {
                return hr;
            }

            // not available in the old format
            prfp2->nMediums = 0;
            prfp2->lpMedium = 0;

            prfp2++;
        }
    }
    else if(prfr1->dwVersion == 2)
    {
        // get a pointer to the beginning of the buffer passed in
        const REGFILTER_REG2 *prfr2 = (REGFILTER_REG2 *)prfr1;
        UINT cPinsFilterData = prf2->cPins;

        REGFILTERPINS2 *pDestPin = (REGFILTERPINS2 *)RgAllocPtr(sizeof(REGFILTERPINS2) * cPinsFilterData);
        prf2->rgPins2 = pDestPin;

        // first pin immediate after REGFILTER_REG struct
        REGFILTERPINS_REG2 *pRegPin = (REGFILTERPINS_REG2 *)(prfr2 + 1);

        for(UINT iPin = 0; iPin < cPinsFilterData; iPin++, pDestPin++)
        {
            pDestPin->dwFlags = pRegPin->dwFlags & (REG_PINFLAG_B_RENDERER |
                                                    REG_PINFLAG_B_OUTPUT |
                                                    REG_PINFLAG_B_MANY |
                                                    REG_PINFLAG_B_ZERO);

            pDestPin->cInstances = pRegPin->nInstances;

            if(pRegPin->dwClsPinCategory)
            {
                pDestPin->clsPinCategory = (GUID *)RgAllocPtr(sizeof(GUID));
                CopyMemory(
                    (void *)pDestPin->clsPinCategory,
                    pbSrc + pRegPin->dwClsPinCategory,
                    sizeof(GUID));
            }
            else
            {
                pDestPin->clsPinCategory = 0;
            }

            UINT cmt = pRegPin->nMediaTypes;
            pDestPin->nMediaTypes = cmt;

            // media types immediately after corresponding pin
            REGPINTYPES_REG2 *pRegMt = (REGPINTYPES_REG2 *)(pRegPin + 1);

            pDestPin->lpMediaType = (REGPINTYPES *)RgAllocPtr(sizeof(REGPINTYPES) * cmt);
            for(UINT imt = 0; imt < cmt; imt++, pRegMt++)
            {
                {
                    DWORD dwSig1 = FCC('0ty3');
                    (*(BYTE *)&dwSig1) += (BYTE)imt;
                    ASSERT(pRegMt->dwSignature == dwSig1);
                }

                REGPINTYPES *pmt = (REGPINTYPES *)&pDestPin->lpMediaType[imt];
                if(pRegMt->dwclsMajorType)
                {
                    pmt->clsMajorType = (GUID *)RgAllocPtr(sizeof(GUID));
                    CopyMemory(
                        (void *)pmt->clsMajorType,
                        pbSrc + pRegMt->dwclsMajorType,
                        sizeof(GUID));
                }
                else
                {
                    pmt->clsMajorType = 0;
                }

                if(pRegMt->dwclsMinorType)
                {
                    pmt->clsMinorType= (GUID *)RgAllocPtr(sizeof(GUID));
                    CopyMemory(
                        (void *)pmt->clsMinorType,
                        pbSrc + pRegMt->dwclsMinorType,
                        sizeof(GUID));
                }
                else
                {
                    pmt->clsMinorType = 0;
                }

            } // mt loop

            //
            // mediums - first medium is immediately after last media
            // type. also we need to find any mediums in the
            // MediumsData value that need to go on this pin.
            //
            const DWORD *prpm = (DWORD *)(pRegMt);// first medium
            UINT cmedFilterData = pRegPin->nMediums;
            UINT cmed = cmedFilterData;
            pDestPin->nMediums = cmed;
            pDestPin->lpMedium = (REGPINMEDIUM *)RgAllocPtr(sizeof(REGPINMEDIUM) * cmed);

            const REGPINMEDIUM *pmed = pDestPin->lpMedium;

            for(UINT imed = 0; imed < cmedFilterData; imed++, prpm++, pmed++)
            {
                if(prpm)
                {
                    CopyMemory((void *)pmed, pbSrc + *prpm, sizeof(REGPINMEDIUM));
                }
                else
                {
                    DbgBreak("null medium");
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
            } // medium loop

            // next pin is after last medium
            pRegPin = (REGFILTERPINS_REG2 *)prpm;

        } // pin loop
        *pprfr1 = (const REGFILTER_REG1 *)pRegPin;

    }

    return hr;
}

// find out how many bytes to allocate and validate that the structure
// is valid. mainly make sure we don't read unallocated memory
HRESULT CUnsquish::CbRequiredUnquishAndValidate(
    const BYTE *pbSrc,
    ULONG *pcbOut, ULONG cbIn
    )
{
    HRESULT hr = S_OK;
    ULONG cb = 0;
    *pcbOut = 0;

    const REGFILTER_REG1 *prfr1 = (REGFILTER_REG1 *)pbSrc;

    if(prfr1 == 0 ||( prfr1->dwVersion != 0 && prfr1->dwVersion != 2)) {
        DbgLog((LOG_ERROR, 0, TEXT("invalid version #")));
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    ASSERT(prfr1);
    cb += sizeof(REGFILTER2);

    if(prfr1->dwVersion == 0)
    {
        UINT cPins = prfr1->dwcPins; // # pins from FilterData
        cb += cPins * sizeof(REGFILTERPINS2);

        UINT iPin;

        if(sizeof(REGFILTER_REG1) + cPins * sizeof(REGFILTERPINS_REG1) > cbIn)
        {
            DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        // first pin is immediately after REGFILTER_REG structure
        const REGFILTERPINS_REG1 *prfp1 = (REGFILTERPINS_REG1 *)(prfr1 + 1);

        for(iPin = 0; iPin < cPins; iPin++, prfp1++)
        {
            DWORD dwSig1 = FCC('0pin');
            (*(BYTE *)&dwSig1) += (BYTE)iPin;

            if(prfp1->dwSignature != dwSig1)
            {
                DbgLog((LOG_ERROR, 0, TEXT("invalid pin signature")));
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            // ignore strName, strConnectsToPin
            //

            UINT cmt = prfp1->nMediaTypes;
            UINT imt;
            cb += cmt * sizeof(REGPINTYPES);

            if(prfp1->rgMediaType + cmt * sizeof(REGPINTYPES_REG1) > cbIn)
            {
                DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }


            // pointer to media types
            const REGPINTYPES_REG1 *prpt1 =
                (REGPINTYPES_REG1 *)(pbSrc + prfp1->rgMediaType);

            for(imt = 0; imt < cmt ; imt++, prpt1++)
            {
                DWORD dwSig1 = FCC('0typ');
                (*(BYTE *)&dwSig1) += (BYTE)imt;


                if(prpt1->dwSignature != dwSig1)
                {
                    DbgLog((LOG_ERROR, 0, TEXT("invalid type signature")));
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }

                // major + minor type
                cb += sizeof(CLSID) * 2;

            } /* mt loop */

        } /* pin for loop */

    } // version 0
    else
    {
        ASSERT(prfr1->dwVersion == 2);

        UINT iPin;
        const REGFILTER_REG2 *prfr2 = (REGFILTER_REG2 *)pbSrc;
        UINT cPins = prfr2->dwcPins; // # pins from FilterData
        cb += cPins * sizeof(REGFILTERPINS2);

        // first pin is immediately after REGFILTER_REG structure
        const REGFILTERPINS_REG2 *pRegPin = (REGFILTERPINS_REG2 *)(prfr2 + 1);

        for(iPin = 0; iPin < cPins; iPin++)
        {
            if((BYTE *)(pRegPin + 1) - pbSrc > (LONG)cbIn)
            {
                DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            DWORD dwSig1 = FCC('0pi3');
            (*(BYTE *)&dwSig1) += (BYTE)iPin;

            if(pRegPin->dwSignature != dwSig1)
            {
                DbgLog((LOG_ERROR, 0, TEXT("invalid pin signature")));
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            if(pRegPin->dwClsPinCategory)
            {
                if(pRegPin->dwClsPinCategory + sizeof(GUID) > cbIn) {
                    DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
                cb += sizeof(GUID);
            }

            UINT cmt = pRegPin->nMediaTypes;
            UINT imt;
            cb += cmt * sizeof(REGPINTYPES);

            // media types immediately after corresponding pin
            const REGPINTYPES_REG2 *pRegMt = (REGPINTYPES_REG2 *)(pRegPin + 1);

            if((BYTE *)(pRegMt + cmt) - pbSrc > (LONG)cbIn)
            {
                DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            for(imt = 0; imt < cmt ; imt++, pRegMt++)
            {
                DWORD dwSig1 = FCC('0ty3');
                (*(BYTE *)&dwSig1) += (BYTE)imt;

                if(pRegMt->dwSignature != dwSig1)
                {
                    DbgLog((LOG_ERROR, 0, TEXT("invalid type signature")));
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }

                if(pRegMt->dwclsMajorType + sizeof(CLSID) > cbIn)
                {
                    DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
                cb += pRegMt->dwclsMajorType ? sizeof(CLSID) : 0;
                if(pRegMt->dwclsMinorType + sizeof(CLSID) > cbIn)
                {
                    DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
                cb += pRegMt->dwclsMinorType ? sizeof(CLSID) : 0;

            } /* mt loop */

            //
            // mediums - first medium is immediately after last media
            // type
            //
            const DWORD *prpm = (DWORD *)(pRegMt);
            UINT cmed = pRegPin->nMediums;
            for(UINT imed = 0; imed < cmed; imed++, prpm++)
            {
                if(*prpm + sizeof(REGPINMEDIUM_REG) > cbIn)
                {
                    DbgLog((LOG_ERROR, 0, TEXT("corrupt buffer")));
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
            }

            cb += sizeof(REGPINMEDIUM) * cmed;

            // next pin is after last medium
            pRegPin = (REGFILTERPINS_REG2 *)prpm;

        } /* pin for loop */
    } // version 2

    *pcbOut = cb;
    return hr;
}

HRESULT UnSquish(
    BYTE *pbSrc,
    ULONG cbIn,
    REGFILTER2 ***pppbDest,
    int nFilters)
{
    for (int iFilter = 0; iFilter < nFilters; iFilter++) {
        *pppbDest[iFilter] = NULL;
    }
    CUnsquish unsquish;
    HRESULT hr = unsquish.UnSquish(pbSrc, cbIn, pppbDest, nFilters);
    if (FAILED(hr)) {
        for (int iFilter = 0; iFilter < nFilters; iFilter++) {
            CoTaskMemFree( (PBYTE)*(pppbDest[iFilter]));
        }
    }
    return hr;
}

HRESULT CUnsquish::UnSquish(
    BYTE *pbSrc, ULONG cbIn,
    REGFILTER2 ***pppbDest, int nFilters)
{
    HRESULT hr = S_OK;

    const REGFILTER_REG1 *prfr1 = (REGFILTER_REG1 *)pbSrc;
    for (int iFilter = 0; iFilter < nFilters; iFilter++) {
        ULONG cbReq;
        hr = CbRequiredUnquishAndValidate((const BYTE *)prfr1, &cbReq, cbIn);
        if(FAILED(hr)) {
            return hr;
        }

        BYTE *pbDest = (BYTE *)CoTaskMemAlloc(cbReq);
        if(pbDest == 0)
        {
            return E_OUTOFMEMORY;
        }

        m_rgMemAlloc.ib = 0;
        m_rgMemAlloc.cbLeft = cbReq;
        m_rgMemAlloc.pb = (BYTE *)pbDest;


        REGFILTER2 *prf2 =  (REGFILTER2 *)RgAllocPtr(sizeof(REGFILTER2));
        ASSERT(prfr1);

        // from CbRequiredUnquish
        ASSERT(prfr1 == 0 || prfr1->dwVersion == 0 || prfr1->dwVersion == 2);

        prf2->dwVersion = 2;
        prf2->dwMerit = prfr1->dwMerit;
        prf2->cPins = prfr1->dwcPins;

        hr = UnSquishPins(prf2, &prfr1, (const BYTE *)pbSrc);
        if(SUCCEEDED(hr))
        {
            ASSERT(m_rgMemAlloc.cbLeft == 0);
            *pppbDest[iFilter] = (REGFILTER2 *)pbDest;
        }
        else
        {
            CoTaskMemFree(pbDest);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\filgraph\util.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1999 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef Utility_h
#define Utility_h

//  Useful pin list type
template<class _Class> class CInterfaceList : public CGenericList<_Class>
{
public:
    ~CInterfaceList() {
        while (0 != GetCount()) {
            RemoveTail()->Release();
        }
    }

    CInterfaceList() : CGenericList<_Class>(NAME("CInterfaceList")) {}

    //  Base class doesn't support GetPrev
    _Class *GetPrev(POSITION& rp) const
    {
        /* have we reached the end of the list */

        if (rp == NULL) {
            return NULL;
        }

        /* Lock the object before continuing */

        void *pObject;

        /* Copy the original position then step on */

        CNode *pn = (CNode *) rp;
        ASSERT(pn != NULL);
        rp = (POSITION) pn->Prev();

        /* Get the object at the original position from the list */

        pObject = pn->GetData();
        // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed.
        return (_Class *)pObject;
    }
};

typedef CInterfaceList<IPin> CPinList;
typedef CInterfaceList<IBaseFilter> CFilterList;

// Pin Utility Functions
void GetFilter(IPin *pPin, IBaseFilter **ppFilter);
HRESULT GetFilterWhichOwnsConnectedPin(IPin* pPin, IBaseFilter** ppFilter);
int Direction(IPin *pPin);
bool IsConnected(IPin* pPin);

bool ValidateFlags( DWORD dwValidFlagsMask, DWORD dwFlags );

//  Registry helper to read DWORDs from the registry
//  Returns ERROR ... codes returned by registry APIs
LONG GetRegistryDWORD(HKEY hkStart, LPCTSTR lpszKey, LPCTSTR lpszValueName,
                      DWORD *pdwValue);

#endif // Utility_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\test\fgtest.cpp ===
// Implementation of TestFilterGraph and other utilities
// for checking filter registration and mapping

// TestFilterGraph is a friend of CFiltergraph and is only for test purposes.

#include <streams.h>
#include <mmsystem.h>
#include <string.h>

#include <TstShell.h>

#include <wxdebug.h>

#include <initguid.h>    /* define the GUIDs for streams and my CLSID in this file */
#include <uuids.h>

#include "distrib.h"
// #include "storeobj.h"
// #include "store.h"
#include "rlist.h"
#include "filgraph.h"
#include "fgtest.h"

#include <Measure.h>

#include "qcmd.h"

#include <stdio.h>

IFilterMapper * pFM;   // The filter mapper - short name because so common
IFilterGraph * pFG;    // The filter graph - The only reason for this is to
                       // get the DLL loaded early so it's there for the debugger.

#define MAX_STRING 300
#define MAX_KEY_LEN 300

// with a bit of luck it will INLINE this.
int STRCMP(LPTSTR a, LPTSTR b)
{
#ifdef UNICODE
    return wcscmp( a,b );
#else
    return strcmp( a,b );
#endif
} // STRCMP


#ifndef DEBUG
DEFINE_GUID(IID_ITestFilterGraph,0x69f09720L,0x8ec8,0x11ce,0xaa,0xb9,0x00,0x20,0xaf,0x0b,0x99,0xa3);


DECLARE_INTERFACE_(ITestFilterGraph, IUnknown)
{
    STDMETHOD(TestRandom) (THIS) PURE;
    STDMETHOD(TestSortList) (THIS) PURE;
    STDMETHOD(TestUpstreamOrder) (THIS) PURE;
    // STDMETHOD(TestTotallyRemove) (THIS) PURE;
};

#endif // not-DEBUG


// get an ITestFilterGraph interface and report a sensible
// error if not there. Returns the interface pointer or null.
ITestFilterGraph*
GetTestInterface(IGraphBuilder * pFG)
{
    ITestFilterGraph * pTFG;
    HRESULT hr = pFG->QueryInterface(IID_ITestFilterGraph, (void **)(&pTFG));

    if (FAILED(hr)) {
        tstLog(TERSE, "Requires debug build of filtergraph");
        return NULL;
    }
    return pTFG;
} // GetTestInterface

/***************************************************************************\
*                                                                           *
*   BOOL CheckResult                                                        *
*                                                                           *
*   Description:                                                            *
*       Check an HRESULT, and notify if failed                              *
*                                                                           *
*   Arguments:                                                              *
*       HRESULT hr:         The value to check                              *
*       LPTSTR szAction:    String to notify on failure                     *
*                                                                           *
*   Return (void):                                                          *
*       True if HRESULT is a success code, FALSE if a failure code          *
*                                                                           *
\***************************************************************************/

BOOL
CheckResult(HRESULT hr, LPTSTR szAction)
{
    if (FAILED(hr)) {
        tstLog(TERSE, "%s failed: 0x%x", szAction, hr);
        return FALSE;
    }
    return TRUE;
}


//
// WaitForPlayComplete
//
// Given a filtergraph in running state (represented by the IMediaControl
// interface to it) this function blocks until the operation completes
// (using IMediaEvent::WaitForCompletion). It logs any errors and returns
// TST_FAIL or TST_PASS.
int
WaitForPlayComplete(IMediaControl * pMC)
{
    // wait for movie to end
    IMediaEvent * pME;

    HRESULT hr = pMC->QueryInterface(IID_IMediaEvent, (void **)&pME);
    if (!CheckResult(hr, "QI for IMediaEvent")) {
        return TST_FAIL;
    }

    LONG lEvCode;
    hr = pME->WaitForCompletion(INFINITE, &lEvCode);

    pME->Release();

    if (!CheckResult(hr, "WaitForCompletion")) {
        return TST_FAIL;
    }

    if (lEvCode != EC_COMPLETE) {
        DbgLog((LOG_ERROR, 0, TEXT("E58b: ev code %d"), lEvCode));
        return TST_FAIL;
    }
    return TST_PASS;

}


//=================================================================
// return a random integer in the range 0..Range
// Range must be in the range 0..2**31-1
//=================================================================
int Random(int Range)
{
    // These really must be DWORDs - the magic only works for 32 bit
    const DWORD Seed = 1664525;              // seed for random (Knuth)
    static DWORD Base = Seed * (GetTickCount() | 1);  // Really random!
                // ORing 1 ensures that we cannot arrive at sero and stick there

    Base = Base*Seed;

    // Base is a good 32 bit random integer - but we want it scaled down to
    // 0..Range.  We will actually scale the last 31 bits of it.
    // which sidesteps problems of negative numbers.
    // MulDiv rounds - it doesn't truncate.
    int Result = MulDiv( (Base&0x7FFFFFFF), (Range), 0x7FFFFFFF);

    return Result;
} // Random



//==========================================================================
// GetRegString
//
// Read value <szValueName> under open key <hk>, turn it into a wide char string
// szValueName can be NULL in which case it just gets the value of the key.
// return 0 if successful else an error code
//==========================================================================

LONG GetRegString( HKEY hk              // [in]  Open registry key
                 , LPWSTR szValueName   // [in]  name of value under that key
                                        //       which is a class id
                 , LPWSTR wstr          // [out] returned string
                 , DWORD  cb            // [in]  buffer size of str in wchars
                 )
{

    TCHAR ResultBuff[MAX_STRING];         // TEXT result before conversio to wstr
    DWORD dw = MAX_STRING*sizeof(TCHAR);  // needed for RegQueryValueEx
    LONG rc;                              // rc from RegQueryValueEx

    wstr[0] = L'\0';                      // tidiness - default result.

    //------------------------------------------------------------
    // ResultBuff = string value from  <hk, szValueName>
    //------------------------------------------------------------
    if (szValueName==NULL) {

        rc = RegQueryValueEx( hk, NULL, NULL, NULL, (LPBYTE)(ResultBuff), &dw);
        if (rc!=ERROR_SUCCESS) {
            return rc;
        }

    } else {

        TCHAR ValueNameBuff[MAX_KEY_LEN];
        wsprintf(ValueNameBuff, TEXT("%ls"), szValueName);
        rc = RegQueryValueEx( hk, ValueNameBuff, NULL, NULL
                            , (LPBYTE)(ResultBuff), &dw);
        if (rc!=ERROR_SUCCESS) {
            return rc;
        }

    }

    //------------------------------------------------------------
    // Convert ResultBuff to wide char wstr
    //------------------------------------------------------------
#ifndef UNICODE
    {
        int rc = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, ResultBuff, -1
                                    , wstr, cb);
        if (rc==0) {
            return ERROR_GEN_FAILURE;
        }
        return ERROR_SUCCESS;
    }
#else
    lstrcpyW(wstr, ResultBuff);
    return rc;
#endif

} // GetRegString




//==========================================================================
// GetRegDword
//
// Read value <szValueName> under open key <hk>, decode it into dw
//==========================================================================

LONG GetRegDword( HKEY hk              // [in]  Open registry key
                , LPWSTR szValueName  // [in]  name of value under that key
                                      //       which is a class id
                , DWORD &dw           // [out] returned dword
                )
{
    TCHAR ValueNameBuff[MAX_KEY_LEN];

    wsprintf(ValueNameBuff, TEXT("%ls"), szValueName);
    DWORD cb;                    // Count of bytes in dw
    LONG rc;                     // return code from RegQueryValueEx
    cb = 4;
    rc = RegQueryValueEx( hk, ValueNameBuff, NULL, NULL, (LPBYTE)(&dw), &cb);
    return rc;
} // GetRegDword




// Read the value from HKCR\<strKey> + <Name> and check it is Value and of type REG_SZ
// Assert if reading fails, return TRUE iff it's value and type are OK

BOOL CheckRegString( LPTSTR strKey    // Key
                   , LPWSTR strName   // name of value
                   , LPWSTR strValue  // correct value of value
                   )
{
    WCHAR ValueBuff[300];   // value read back from registry to here
    DWORD dwSize = sizeof(ValueBuff);   // input to RegQueryValueEx

    HKEY hKey;

    LONG rc;
    LONG lRcGet;
    BOOL bRc;

    rc = RegOpenKey( HKEY_CLASSES_ROOT, strKey, &hKey);
    ASSERT (rc==ERROR_SUCCESS);

    lRcGet = GetRegString( hKey, strName, ValueBuff, dwSize );

    rc = RegCloseKey(hKey);
    ASSERT (rc==ERROR_SUCCESS);

    // set rc to comparison value - 0 is OK, other is not OK
    if (lRcGet==0) {
        if (strValue==NULL)
            rc = 1;                // got a value when it shouldn't be there
        else {
            rc = lstrcmpW(strValue, ValueBuff);
        }
    }
    else if (lRcGet==2 && strValue==NULL) {  //2 is "File not found" (i.e. value not found)
        lRcGet = 0;
        rc = 0;
    }
    else rc = 1;   // failed to get

    bRc = (lRcGet==0) && (rc==0);
    return bRc;

} // CheckRegString



// Read the value from HKCR\<strKey> + <Name> and check it is <Value> and of type REG_DWORD
// Assert if reading fails, return TRUE iff it's value and type are OK

BOOL CheckRegDword( LPTSTR strKey    // Key name
                  , LPWSTR strName   // name of value
                  , DWORD  Value     // correct value of value
                  )
{
    DWORD ValueGotten;        // value read back from registry to here
    HKEY hKey;
    LONG rc;
    LONG lRcGet;
    BOOL bRc;

    rc = RegOpenKey( HKEY_CLASSES_ROOT, strKey, &hKey);
    ASSERT (rc==ERROR_SUCCESS);

    lRcGet = GetRegDword( hKey, strName, ValueGotten );

    rc = RegCloseKey(hKey);
    ASSERT (rc==ERROR_SUCCESS);

    bRc = (lRcGet==0) && (Value == ValueGotten);
    return bRc;

} // CheckRegDword

#if 0

// following function unused for the moment - it is required
// by SetupUnregisterServer().
// (will be use in testing IFilterMapper.UnregisterFilter)

//---------------------------------------------------------------------------
//
// EliminateSubKey
//
// Unregister everything below Key\SubKey, then delete SubKey
//
// returns NOERROR if it succeeds
//         an error code (passed back from relevant subsys) otherwise
//
//---------------------------------------------------------------------------

HRESULT EliminateSubKey( HKEY hkey, LPTSTR strSubKey )
{
  // Try to enumerate all keys under this one.
  // if we find anything, delete it completely.
  // Otherwise just delete it.

  HKEY hk;
  LONG lreturn = RegOpenKeyEx( hkey
                             , strSubKey
                             , 0
                             , MAXIMUM_ALLOWED
                             , &hk );
  if( ERROR_SUCCESS != lreturn )
  {
    return HRESULT_FROM_WIN32(lreturn);
  }

  // Keep on enumerating the first (zero-th) key and deleting that

  for( ; ; )
  {
    TCHAR Buffer[MAX_KEY_LEN];
    DWORD dw = MAX_KEY_LEN;
    FILETIME ft;

    lreturn = RegEnumKeyEx( hk
                          , 0
                          , Buffer
                          , &dw
                          , NULL
                          , NULL
                          , NULL
                          , &ft);

    ASSERT(    lreturn == ERROR_SUCCESS
            || lreturn == ERROR_NO_MORE_ITEMS );

    if( ERROR_SUCCESS == lreturn )
    {
      EliminateSubKey(hk, Buffer);
    }
    else
    {
      break;
    }
  }

  RegCloseKey(hk);
  RegDeleteKey(hkey, strSubKey);

  return NOERROR;
}

#endif

//---------------------------------------------------------------------------
//
// SetupRegisterServer()
//
// Registers OLE Server by
// 1. creating CLSID\{CLSID-...} key
// 2. and <No Name> REG_SZ "Description" value
//
// 3. creating CLSID\{CLSID-...}\"Server" key
//    [ where "Server" must be one of the following
//      InprocServer32 (default), InprocHandler32,
//      LocalServer32, (or, in the future, RemoteServer32?) ]
// 4. and <No Name> REG_SZ "Server binary" value
//    [ e.g. c:\winnt40\system32\quartz.dll ]
// 5. and ThreadingModel REG_SZ "Model" value
//    [ "Both" (default), "Apartment" or NULL ]
//
// returns NOERROR (== S_OK) if it succeeds
//         an error code (passed back from relevant subsys) otherwise
//
//---------------------------------------------------------------------------

HRESULT
SetupRegisterServer( CLSID   clsServer             // server's OLE Class ID
                   , LPCWSTR szDescription         // Description string
                   , LPCWSTR szFileName            // server binary
                   , LPCWSTR szThreadingModel      // see above
                             = L"Both"             // - default value
                   , LPCWSTR szServerType          // see above
                             = L"InprocServer32" ) // - default value
{
  // convert Class ID to string value and
  // append to CLSID\ to create key path
  // relative to HKEY_CLASSES_ROOT
  //
  OLECHAR szCLSID[CHARS_IN_GUID];
  HRESULT hr = QzStringFromGUID2( clsServer
                                , szCLSID
                                , CHARS_IN_GUID );
  ASSERT( SUCCEEDED(hr) );

  WCHAR achsubkey[MAX_PATH];
  wsprintfW( achsubkey, L"CLSID\\%ls", szCLSID );

  // Create HKEY_CLASSES_ROOT\CLSID\{CLSID-} key
  //
  HKEY hkey;

  {
    LONG lreturn = RegCreateKeyW( HKEY_CLASSES_ROOT
                                , (LPCWSTR)achsubkey
                                , &hkey              );
    if( ERROR_SUCCESS != lreturn )
    {
      return HRESULT_FROM_WIN32(lreturn);
    }
  }

  // create description string value
  //
  {
    LONG lreturn = RegSetValueW( hkey
                               , (LPCWSTR)NULL
                               , REG_SZ
                               , szDescription
                               , sizeof(szDescription) );
    if( ERROR_SUCCESS != lreturn )
    {
      RegCloseKey( hkey );
      return HRESULT_FROM_WIN32(lreturn);
    }
  }

  // create CLSID\\{"CLSID"}\\"ServerType" key,
  // using key to CLSID\\{"CLSID"} passed back by
  // last call to RegCreateKey().
  //
  {
    HKEY hsubkey;

    {
      LONG lreturn = RegCreateKeyW( hkey
                                  , szServerType
                                  , &hsubkey     );
      if( ERROR_SUCCESS != lreturn )
      {
        RegCloseKey( hkey );
        return HRESULT_FROM_WIN32(lreturn);
      }
    }

    // create Server binary string value
    //
    {
      LONG lreturn = RegSetValueW( hsubkey
                                 , (LPCWSTR)NULL
                                 , REG_SZ
                                 , (LPCWSTR)szFileName
                                 , sizeof(szFileName) );
      if( ERROR_SUCCESS != lreturn )
      {
        RegCloseKey( hkey );
        RegCloseKey( hsubkey );
        return HRESULT_FROM_WIN32(lreturn);
      }

      // and, if the server is of type InprocServer32,
      // create ThreadingModel string value
      //
      if(     ( 0    == lstrcmpW( szServerType, L"InprocServer32" ) )
          &&  ( NULL == szThreadingModel                            ) )
      {
        lreturn = RegSetValueExW( hsubkey
                                , L"ThreadingModel"
                                , 0L
                                , REG_SZ
                                , (CONST BYTE *)szThreadingModel
                                , sizeof(szThreadingModel) );
        if( ERROR_SUCCESS != lreturn )
        {
          RegCloseKey( hkey );
          RegCloseKey( hsubkey );
          return HRESULT_FROM_WIN32(lreturn);
        }
      }
    }

    // close reg subkey
    //
    RegCloseKey( hsubkey );
  }

  // close reg key
  //
  RegCloseKey( hkey );

  return NOERROR;
}

#if 0

// following function unused for the moment
// (will be use in testing IFilterMapper.UnregisterFilter)

//---------------------------------------------------------------------------
//
// SetupUnregisterServer()
//
// Unregisters OLE Server by removing
// KHEY_CLASSES_ROOT\CLSID\{CLSID-}
// key and all its subkeys and values.
//
// returns NOERROR
//
//---------------------------------------------------------------------------

HRESULT
SetupUnregisterServer( CLSID clsServer )
{
  OLECHAR szCLSID[CHARS_IN_GUID];
  HRESULT hr = QzStringFromGUID2( clsServer
                                , szCLSID
                                , CHARS_IN_GUID );
  ASSERT( SUCCEEDED(hr) );

  TCHAR achBuffer[MAX_KEY_LEN];
  wsprintf( achBuffer, TEXT("CLSID\\%ls"), szCLSID );

  hr = EliminateSubKey( HKEY_CLASSES_ROOT, achBuffer );
  ASSERT( SUCCEEDED(hr) );

  return NOERROR;
}

#endif

//==================================================================
// Read the registration back and return TRUE iff it looks correct
//==================================================================


BOOL CheckFilterRegistration
    ( CLSID  Clsid        // GUID of the filter
    , LPWSTR strName      // Descriptive name for the filter
    , LPWSTR strExePath   // for the InprocServer32 key
    , DWORD  dwMerit      // corect value of Merit
    )
{
    TCHAR KeyBuff[300];   // key name built up here
    BOOL bRc;             // a boolean return code

    LPOLESTR strClsid;    // GUID of filter as string

    HRESULT hr;           // result from something we call

    hr = StringFromCLSID(Clsid, &strClsid);
    ASSERT(SUCCEEDED(hr));

    //-----------------------------------------------------------------
    // Look for the HKCR\Filter\<clsid> value in the registry
    // this implicitly checks for the existence of the keys too
    //-----------------------------------------------------------------
    wsprintf(KeyBuff, TEXT("Filter\\%ls"), strClsid);

    bRc = CheckRegString(KeyBuff, NULL, strName );

    if (bRc!=TRUE)
       return FALSE;

    //-----------------------------------------------------------------
    // Look for the HKCR\CLSID\<clsid> value in the registry
    // this implicitly checks for the existence of the keys too
    //-----------------------------------------------------------------
    wsprintf(KeyBuff, TEXT("CLSID\\%ls"), strClsid );

    bRc =  CheckRegString(KeyBuff, NULL, strName );

    if (bRc!=TRUE)
       return FALSE;

    //-----------------------------------------------------------------
    // Look for HKCR\CLSID\<clsid>\InprocServer32 value in the registry
    // this implicitly checks for the existence of the keys too
    //-----------------------------------------------------------------
    wsprintf(KeyBuff, TEXT("CLSID\\%ls\\InprocServer32"), strClsid );

    bRc = CheckRegString(KeyBuff, NULL, strExePath );

    if (bRc!=TRUE)
       return FALSE;

    wsprintf(KeyBuff, TEXT("CLSID\\%ls"), strClsid );

    bRc = CheckRegDword(KeyBuff, L"Merit", dwMerit );

    if (bRc!=TRUE)
       return FALSE;

    return TRUE;

} // CheckFilterRegistration



//==================================================================
// Read the registration back and return TRUE iff it looks correct
//==================================================================


BOOL CheckPinRegistration
    ( CLSID  clsFilter,           // GUID of filter
      LPWSTR strName,             // Descriptive name of the pin
      BOOL   bRendered,           // The filter renders this input
      BOOL   bOutput,             // TRUE iff this is an Output pin
      BOOL   bZero,               // TRUE iff OK to have zero instances of pin
                                  // In this case you will have to Create a pin
                                  // to have even one instance
      BOOL   bMany,               // TRUE iff OK to create many instance of  pin
      CLSID  clsConnectsToFilter, // Filter it connects to if it has a
                                  // subterranean connection, else NULL
      LPWSTR strConnectsToPin     // Pin it connects to if it has a
                                  // subterranean connection, else NULL
    )
{
    TCHAR KeyBuff[300];     // key name built up here
    BOOL bRc;               // our return code (eventually)

    LPOLESTR strFilter;
    LPOLESTR strConnectsToFilter;

    HRESULT hr;


    hr = StringFromCLSID(clsFilter, &strFilter);
    ASSERT(SUCCEEDED(hr));

    wsprintf(KeyBuff, TEXT("CLSID\\%ls\\Pins\\%ls"), strFilter, strName);

    hr = StringFromCLSID(clsConnectsToFilter, &strConnectsToFilter);
    ASSERT(SUCCEEDED(hr));

    bRc =        CheckRegDword(KeyBuff, L"Direction",  (DWORD)(bOutput?1:0) );
    bRc = bRc && CheckRegDword(KeyBuff, L"IsRendered",  (DWORD)(bRendered?1:0) );
    bRc = bRc && CheckRegDword(KeyBuff, L"AllowedZero",  (DWORD)(bZero?1:0) );
    bRc = bRc && CheckRegDword(KeyBuff, L"AllowedMany",  (DWORD)(bMany?1:0) );
    if (CLSID_NULL!=clsConnectsToFilter) {
        bRc = bRc && CheckRegString(KeyBuff, L"ConnectsToFilter",  strConnectsToFilter );
    } else {
        bRc = bRc && CheckRegString(KeyBuff, L"ConnectsToFilter", NULL );
    }

    bRc = bRc && CheckRegString(KeyBuff, L"ConnectsToPin",  strConnectsToPin );

    CoTaskMemFree(strFilter);
    CoTaskMemFree(strConnectsToFilter);

    return bRc;
} // CheckPinRegistration



//=====================================================================
// Register the pin and check the registration
//=====================================================================
HRESULT RegAndCheckPin( CLSID  clFilter
                      , LPWSTR strPinName
                      , BOOL   bRendered
                      , BOOL   bOutput
                      , BOOL   bZero
                      , BOOL   bMany
                      , CLSID  clOtherFilter     // connects To
                      , LPWSTR strOtherPin        // connecs to
                      )
{
    HRESULT hr;                       // our final return code

    BOOL bRc;                         // a return code

    //===========================================================================
    // Convert clsid to string
    //===========================================================================

    hr = pFM->RegisterPin( clFilter, strPinName
                         , bRendered, bOutput, bZero, bMany
                         , clOtherFilter, strOtherPin
                         );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E1: Failed to RegisterPin")));
        return hr;
    }

    bRc = CheckPinRegistration( clFilter, strPinName
                              , bRendered, bOutput, bZero, bMany
                              , clOtherFilter, strOtherPin
                              );
    if (!bRc) return E_FAIL;

    return NOERROR;

} // RegAndCheckPin



//========================================================================
// Register all the types for AVICodec, Video Render and Audio Render
//========================================================================
HRESULT RegisterFilterTypes()
{
    HRESULT hr;
    hr = pFM->RegisterPinType( CLSID_AVIDec
                             , L"Input"
                             , MEDIATYPE_Video
                             , CLSID_NULL
                             );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E2: Failed to RegisterPinType")));
        return hr;
    }

    hr = pFM->RegisterPinType( CLSID_VideoRenderer
                             , L"Input"
                             , MEDIATYPE_Video
                             , CLSID_NULL
                             );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E3: Failed to RegisterPinType")));
        return hr;
    }

    hr = pFM->RegisterPinType( CLSID_AudioRender
                             , L"Input"
                             , MEDIATYPE_Audio
                             , CLSID_NULL
                             );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E4: Failed to RegisterPinType")));
        return hr;
    }

    return NOERROR;

} // RegisterFilterTypes






//========================================================================
// Register all the pins on the filters and get it checked
//========================================================================
HRESULT RegisterFilterPins()
{
    HRESULT hr;

    //================================================================
    // AVI Codec - and some silliness
    //================================================================
    // input pin of AVI codec
    hr = RegAndCheckPin( CLSID_AVIDec
                       , L"Input"
                       , FALSE             // bRendered
                       , FALSE             // bOutput
                       , FALSE             // bZero
                       , FALSE             // bMany
                       , CLSID_NULL        // strOtherFilter     connects To
                       , L"Output"         // strOtherPin        connects to
                       );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E5: Failed RegAndCheckPin")));
        return hr;
    }

    // Output pin of AVI codec - first a version that has
    // connects to stuff in
    hr = RegAndCheckPin( CLSID_AVIDec
                       , L"Output"
                       , FALSE             // bRendered
                       , TRUE              // bOutput
                       , FALSE             // bZero
                       , FALSE             // bMany
                       , CLSID_AVIDec    // strOtherFilter     connects To
                       , L"Input"          // strOtherPin        connects to
                       );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E6: Failed RegAndCheckPin")));
        return hr;
    }

    // Now a version that should fail to register
    // (connects to filter without pin)

    hr = RegAndCheckPin( CLSID_AVIDec
                       , L"Output"
                       , FALSE             // bRendered
                       , TRUE              // bOutput
                       , FALSE             // bZero
                       , FALSE             // bMany
                       , CLSID_AVIDec    // strOtherFilter     connects To
                       , NULL              // strOtherPin        connects to
                       );
    if (SUCCEEDED(hr))  {
        DbgLog((LOG_ERROR, 0, TEXT("E7: RegAndCheckPin succeeded where it should fail")));
        return E_FAIL;
    }



    //================================================================
    // Input pin of image renderer
    //================================================================
    hr = RegAndCheckPin( CLSID_VideoRenderer
                       , L"Input"
                       , TRUE              // bRendered
                       , FALSE             // bOutput
                       , FALSE             // bZero
                       , FALSE             // bMany
                       , CLSID_NULL        // strOtherFilter     connects To
                       , NULL              // strOtherPin        connects to
                       );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E8: Failed RegAndCheckPin")));
        return hr;
    }


    //================================================================
    // Let's try to register a rendered OUTPUT pin - should fail
    //================================================================
    hr = RegAndCheckPin( CLSID_AudioRender
                       , L"Output"
                       , TRUE              // bRendered
                       , TRUE              // bOutput
                       , FALSE             // bZero
                       , FALSE             // bMany
                       , CLSID_NULL        // strOtherFilter     connects To
                       , NULL              // strOtherPin        connects to
                       );
    if (SUCCEEDED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E9: Failed RegAndCheckPin")));
        return E_FAIL;
    }


    //================================================================
    // Input pin of audio renderer
    //================================================================
    hr = RegAndCheckPin( CLSID_AudioRender
                       , L"Input"
                       , TRUE              // bRendered
                       , FALSE             // bOutput
                       , FALSE             // bZero
                       , FALSE             // bMany
                       , CLSID_NULL        // strOtherFilter     connects To
                       , NULL              // strOtherPin        connects to
                       );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E10: Failed RegAndCheckPin")));
        return hr;
    }


    hr = RegisterFilterTypes();
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E11: Failed RegisterFilterTypes")));
        return hr;
    }


    return NOERROR;

} // RegisterFilterPins



//=======================================================================
// Register one filter, convert the clsid to string first
// Register it as volatile.
// Check that the registration is OK
// Log all failures
//=======================================================================

HRESULT RegisterFilterClsid( CLSID clsid
                           , LPWSTR strName
                           , LPWSTR strBinName
                           , DWORD  dwMerit
                           )
{
    HRESULT hr;                       // our final return code
    BOOL bRc;                         // a return code

    // NOTE
    //
    // to allow the Server type (as in InprocServer32,
    // InprocHandler32, LocalServer32) to be determined
    // independently the creation of the server key has
    // been pulled from the RegisterFilter method.
    //
    // So the test nust now set up the additional
    // entries itself.

    hr = SetupRegisterServer( clsid
                            , strName
                            , strBinName );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("---: Failed to register Server")));
        return hr;
    }

    hr = pFM->RegisterFilter( clsid
                            , strName
                            , dwMerit
                            );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E12: Failed to RegisterFilter")));
        return hr;
    }

    bRc = CheckFilterRegistration( clsid
                                 , strName
                                 , strBinName
                                 , dwMerit
                                 );
    if (bRc!=TRUE) {
        return E_FAIL;
    }


    return NOERROR;
} // RegisterFilterClsid



//=================================================================
// Register the Video, pAudio, pCodec and pSource filters
// check that the registration is OK
//=================================================================

int TestRegister()
{
	WCHAR wszSerDir[MAX_PATH];
	char szSysDir[MAX_PATH] = "";
	GetSystemDirectory( szSysDir, MAX_PATH );

// it's really not nice to do this on single-dll builds as everyone's
// registry contains something other than the below...
#if 1
    HRESULT hr;

    hr = CoCreateInstance( CLSID_FilterMapper,       // clsid input
                           NULL,                     // Outer unknown
                           CLSCTX_INPROC,            // Inproc server
                           IID_IFilterMapper,        // Interface required
                           (void **) &pFM            // Where to put result
                         );

    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E21: Failed to CoCreate... FilterMapper")));
        return TST_FAIL;
    }

	swprintf( wszSerDir, L"%hs\\quartz.dll", szSysDir );
    hr = RegisterFilterClsid( CLSID_AVIDec
                            , L"AVI Codec"
                            , wszSerDir
                            , MERIT_NORMAL
                            );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E14: Failed RegisterFilterClsid")));
        pFM->Release();
        return TST_FAIL;
    }


    hr = RegisterFilterClsid( CLSID_VideoRenderer
                            , L"Video Renderer"
                            , wszSerDir
                            , MERIT_NORMAL
                            );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E15: Failed RegisterFilterClsid")));
        pFM->Release();
        return TST_FAIL;
    }

    hr = RegisterFilterClsid( CLSID_AudioRender
                            , L"Audio Renderer"
                            , wszSerDir
                            , MERIT_NORMAL
                            );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E16: Failed RegisterFilterClsid")));
        pFM->Release();
        return TST_FAIL;
    }

    hr = RegisterFilterClsid( CLSID_AVIDoc
                            , L"AVI//WAV File Source"
                            , L"AVISRC.DLL"
                            , MERIT_NORMAL
                            );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E17: Failed RegisterFilterClsid")));
        pFM->Release();
        return TST_FAIL;
    }

    hr = RegisterFilterPins();
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E18: Failed RegisterFilterPins")));
        pFM->Release();
        return TST_FAIL;
    }

    pFM->Release();
#endif
    return TST_PASS;

} // TestRegister



//=================================================================
// Returns a new filter graph to play with
//=================================================================

IGraphBuilder * GetFilterGraph()
{
    HRESULT hr;
    IGraphBuilder * pfg;
    hr = CoCreateInstance( CLSID_FilterGraph,        // clsid input
                           NULL,                     // Outer unknown
                           CLSCTX_INPROC,            // Inproc server
                           IID_IGraphBuilder,         // Interface required
                           (void **) &pfg            // Where to put result
                         );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E19: Failed to CoCreate... FilterGraph")));
        return NULL;
    }
    return pfg;

} // GetFilterGraph




//=================================================================
// Call this first - creates the filter graph *pFG and mapper *pFM
// This has the effect of loading the DLL and making debugging easier.
//=================================================================

int InitFilterGraph()
{

    pFG = GetFilterGraph();
    if (pFG==NULL){
        return TST_FAIL;
    }

    HRESULT hr;
    hr = CoCreateInstance( CLSID_FilterMapper,       // clsid input
                           NULL,                     // Outer unknown
                           CLSCTX_INPROC,            // Inproc server
                           IID_IFilterMapper,        // Interface required
                           (void **) &pFM            // Where to put result
                         );

    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E21: Failed to CoCreate... FilterMapper")));
	pFG->Release();
	pFG = NULL;
        return TST_FAIL;
    }

    return  TST_PASS;

} // InitFilterGraph



//==============================================================
// Call this last - Gets rid of the filter graph *pFG
//==============================================================

int TerminateFilterGraph()
{
    pFG->Release();
    DbgLog((LOG_TRACE, 2, TEXT("TerminateFilterGraph.")));
    return TST_PASS;
} // TerminateFilterGraph



//=================================================================
// Test the list sorting internal functions
//=================================================================
int TestSorting()
{
    IGraphBuilder * pFG = GetFilterGraph();
    ITestFilterGraph * pTFG = GetTestInterface(pFG);
    if (pTFG == NULL) {
        pFG->Release();
        return TST_FAIL;
    }

    HRESULT hr;
    hr = pTFG->TestSortList();

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 0, TEXT("E21.5: TestSorting failed")));
    }

    pTFG->Release();
    pFG->Release();
    return ( SUCCEEDED(hr)
           ? TST_PASS
           : TST_FAIL
           );

} // TestSorting



//=================================================================
// Test the list sorting internal functions
//=================================================================
int TestRandom()
{
    IGraphBuilder * pFG = GetFilterGraph();
    ITestFilterGraph * pTFG = GetTestInterface(pFG);
    if ((pFG == NULL) || (NULL == pTFG)) {
        if (pTFG) pTFG->Release();
        if (pFG) pFG->Release();
        return TST_FAIL;
    }

    HRESULT hr;

    hr = pTFG->TestRandom();

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 0, TEXT("E21.6: TestRandom failed")));
    }
    pTFG->Release();
    pFG->Release();
    return ( SUCCEEDED(hr)
           ? TST_PASS
           : TST_FAIL
           );

} // TestRandom



//=================================================================
// Test the upstream ordering with the CURRENT graph only
//=================================================================
int TestUpstream()
{
    IGraphBuilder * pFG = GetFilterGraph();
    ITestFilterGraph * pTFG = GetTestInterface(pFG);
    if (pTFG == NULL) {
        pFG->Release();
        return TST_FAIL;
    }

    HRESULT hr;

    hr = pTFG->TestUpstreamOrder();

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 0, TEXT("E21.7: TestUpstreamOrder failed")));
    }

    pTFG->Release();
    pFG->Release();
    return ( SUCCEEDED(hr)
           ? TST_PASS
           : TST_FAIL
           );

} // TestUpstream




//=================================================================
// Enumerate the filters in the graph and return the count
//=================================================================
int CountFilters(IGraphBuilder * pFG)
{
    int iTotal = 0;
    IEnumFilters * pEnumFil;
    typedef IBaseFilter * PFilter;
    PFilter apFil[9];       // an array of IBaseFilter*
    ULONG ulFetched;

    pFG->EnumFilters( &pEnumFil);
    pEnumFil->Reset();
    for (; ; ) {
        // We ask for them in random sized lumps.
        int iRand = Random(3);

        pEnumFil->Next(iRand, apFil, &ulFetched);
        iTotal += ulFetched;
        {   ULONG i;
            for (i=0; i<ulFetched; ++i) {
                apFil[i]->Release();
            }
        }
        if ((int)ulFetched<iRand) {
            pEnumFil->Release();
            return iTotal;
        }
    }
    pEnumFil->Release();

} // CountFilters



//=================================================================
// Get a pin with a given direction from a filter
// ??? I'm worried that we dont know enough about pins to find
// ??? suitable ones.  I guess we'd really have to go looking in the
// ??? registry for the MEDIATYPE.
// return an AddReffed pin.
//=================================================================
IPin * GetSuitablePin( IBaseFilter * pFilter, PIN_DIRECTION PinDir)
{
    // enumerate the pins and return the first that has the right direction

    HRESULT hr;           // retcode from things we call
    PENUMPINS pEnumPins;
    PPIN pPin;
    ULONG ulFetched;

    hr = pFilter->EnumPins(&pEnumPins);
    if (FAILED(hr)) return NULL;

    hr = pEnumPins->Reset();
    if (FAILED(hr)) { pEnumPins->Release(); return NULL; }

    for (; ; ) {
        hr = pEnumPins->Next( 1, &pPin, &ulFetched);
        if (ulFetched==0) break;

        if (FAILED(hr)) { pEnumPins->Release(); return NULL; }

        PIN_DIRECTION pd;
        hr = pPin->QueryDirection(&pd);
        pPin->Release();
        ASSERT(SUCCEEDED(hr));
        if (PinDir==pd){
            pEnumPins->Release();
            return pPin;
        }
    }

    pEnumPins->Release();
    return NULL;

} // GetSuitablePin


//===========================================================
// Connect an output pin on pif1 to an input on pif2
// Try all possible pins until it works.
//===========================================================

HRESULT ConnectFilters( IGraphBuilder * pFG, IBaseFilter * pif1, IBaseFilter * pif2)
{
    IPin * pPinOut;  // an output pin on pif1
    IPin * pPinIn;   // an input pin on pif2


    HRESULT hr;           // retcode from things we call
    PENUMPINS pep1;       // pin enumerator for filter1
    PENUMPINS pep2;       // pin enumerator for filter2

    ULONG ulFetched;      // number of pins fetched

    //----------------------------------------------------
    // Get pin enumerators for both filters
    //----------------------------------------------------
    hr = pif1->EnumPins(&pep1);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E22: EnumPins failed")));
        return hr;
    }

    hr = pif2->EnumPins(&pep2);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E23: EnumPins failed")));
        pep1->Release(); return hr;
    }


    //----------------------------------------------------
    // for each pin on filter 1
    //----------------------------------------------------
    hr = pep1->Reset();
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E24: Reset of pin enumerator failed")));
        pep1->Release(); pep2->Release(); return hr;
    }

    for (; ; ) {
        hr = pep1->Next( 1, &pPinOut, &ulFetched);
        if (ulFetched==0) break;  // no more pins
        if (FAILED(hr)){
            DbgLog((LOG_ERROR, 0, TEXT("E25: pin enumerator Next failed oddly")));
            pep1->Release(); pep2->Release(); return hr;
        }

        //----------------------------------------------------
        // see if it's an output pin.  if so carry on else continue
        //----------------------------------------------------
        PIN_DIRECTION pd1;
        hr = pPinOut->QueryDirection(&pd1);
        ASSERT(SUCCEEDED(hr));
        if (PINDIR_OUTPUT!=pd1) {
            pPinOut->Release();
            continue;
        }

        //----------------------------------------------------
        // check it's not already connected, if so continue else carry on
        //----------------------------------------------------
        IPin *pConnected1;
        hr = pPinOut->ConnectedTo(&pConnected1);
        if (SUCCEEDED(hr)) {
            pConnected1->Release();
            pPinOut->Release();
            continue;
        }

        //----------------------------------------------------
        // for each pin on filter 2
        //----------------------------------------------------
        hr = pep2->Reset();
        if (FAILED(hr)){
            DbgLog((LOG_ERROR, 0, TEXT("E26: Reset of pin enumerator failed")));
            pep1->Release(); pep2->Release(); return hr;
        }

        for (; ; ) {
            hr = pep2->Next( 1, &pPinIn, &ulFetched);
            if (ulFetched==0) break;  // no more pins
            if (FAILED(hr)){
                DbgLog((LOG_ERROR, 0, TEXT("E27: Pin enumerator Next failed oddly")));
                pPinOut->Release(); pep1->Release(); pep2->Release(); return hr;
            }

            //----------------------------------------------------
            // see if it's an input pin else continue
            //----------------------------------------------------
            PIN_DIRECTION pd2;
            hr = pPinIn->QueryDirection(&pd2);
            ASSERT(SUCCEEDED(hr));
            if (PINDIR_INPUT!=pd2) {
                pPinIn->Release();
                continue;
            }

// ??? It tests a few more cases if we don't do this
//          //----------------------------------------------------
//          // see if it's already connected, else continue
//          //----------------------------------------------------
//          IPin *pConnected2;
//          hr = pPinIn->ConnectedTo(&pConnected2);
//          if (SUCCEEDED(hr)) {
//              pConnected2->Release();
//              pPinIn->Release();
//              continue;
//          }

            //----------------------------------------------------
            // try to connect them - if so, we're done, else try more pins
            //----------------------------------------------------
            hr = pFG->Connect( pPinOut, pPinIn );
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, 1, TEXT("E28: Connect failed")));
                pPinIn->Release();
                continue;
            }

            //----------------------------------------------------
            // we're done
            //----------------------------------------------------
            pep1->Release();
            pep2->Release();
            pPinOut->Release();
            pPinIn->Release();
            return hr;
        }
        pPinOut->Release();
    }

    //----------------------------------------------------
    // We ran out of pins to try
    //----------------------------------------------------
    pep1->Release();
    pep2->Release();
    return E_FAIL;

} // ConnectFilters




//==================================================================
// enumerate the pins and Render every one
//==================================================================
HRESULT RenderAllPins( IGraphBuilder * pFG, IBaseFilter * pf)
{
    PENUMPINS pep;   // pin enumerator for filter

    HRESULT hr;      // a return code
    IPin * pp;       // a pin to find and render

    //----------------------------------------------------
    // Get pin enumerator
    //----------------------------------------------------
    hr = pf->EnumPins(&pep);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E30: Failed to get a pin enumerator")));
        return hr;           // ??? ASSERT?
    }


    //----------------------------------------------------
    // for each pin on filter
    //----------------------------------------------------
    hr = pep->Reset();
    if (FAILED(hr)) {
        ASSERT(FALSE);
        pep->Release();
        return hr;
    }

    pp = NULL;   // default
    for (; ; ) {
        ULONG ulFetched;      // number of pins fetched

        //----------------------------------------------------
        // Set pp to the next pin
        //----------------------------------------------------
        hr = pep->Next( 1, &pp, &ulFetched);

        // ??? Should I test hr before ulFetched?

        if (ulFetched==0) break;                  // no more pins
        if (FAILED(hr)) {
            ASSERT(FALSE);
            pep->Release();
            return hr;
        }


        //-----------------------------------------------------------
        // If it's an output and isn't already connected, Render it
        //-----------------------------------------------------------

        PIN_DIRECTION pd;
        hr = pp->QueryDirection(&pd);
        ASSERT(SUCCEEDED(hr));
        if (PINDIR_OUTPUT!=pd) {
            pp->Release();
            continue;
        }

        IPin *pConnected;
        hr = pp->ConnectedTo(&pConnected);

        if (FAILED(hr)) {
            hr = pFG->Render(pp);
            if (FAILED(hr)){
                DbgLog((LOG_ERROR, 1, TEXT("E31: Render failed")));
                pep->Release();
                pp->Release();
                return hr;
            }
        } else {
            pConnected->Release();
        }
        pp->Release();     // it's connected, we don't need to hold it too

    }
    pep->Release();

    return NOERROR;
} // RenderAllPins


//=================================================================
// Test Adding, connecting and enumerating filters within the group
// Should NOT have to go near the registry to pass this lot
//=================================================================
int TestConnectInGraph()
{

    // The diagrams show filters and ref counts

    HRESULT hr;
    IGraphBuilder * pFG = GetFilterGraph();

    IBaseFilter * pfCodec;        // an instance of an AVICodec
    IBaseFilter * pfVideo;        // a video renderer
    IBaseFilter * pfAudio;        // an audio renderer
    IBaseFilter * pfSource;       // a source filter



    //-------------------------------------------------------
    // Create and add a bunch of filters to the graph
    //-------------------------------------------------------


    //........................................................
    // Add a codec
    //........................................................

    hr = CoCreateInstance( CLSID_AVIDec, NULL, CLSCTX_INPROC, IID_IBaseFilter
                         , (void **) &pfCodec);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E32: CoCreate... AVI Codec failed")));
        pFG->Release();
        return TST_FAIL;
    }

    hr = pFG->AddFilter( pfCodec, L"AVI Codec" );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E33: AddFilter failed")));
        pfCodec->Release();
        pFG->Release();
        return TST_FAIL;
    }


    //........................................................
    // Add a source
    //........................................................

    hr = pFG->AddSourceFilter(L"Curtis8.AVI", L"SourceFilter", &pfSource);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E34: AddSourceFilter failed")));
        pfCodec->Release();
        pFG->Release();
        return TST_FAIL;
    }

    //........................................................
    // Connect the two (should connect directly)
    //........................................................

    hr = ConnectFilters(pFG, pfSource, pfCodec);    // should connect directly
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E35: ConnectFilters source->codec Failed")));
        pfCodec->Release();
        pfSource->Release();
        pFG->Release();
        return TST_FAIL;
    }

    //........................................................
    // Undo the connection and remove the codec
    //........................................................

    hr = pFG->RemoveFilter(pfCodec);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E36: RemoveFilter Failed")));
        pfCodec->Release();
        pfSource->Release();
        pFG->Release();
        return TST_FAIL;
    }

    if (CountFilters(pFG) != 1) return TST_FAIL;

    //........................................................
    // Add the codec back again
    //........................................................

    hr = pFG->AddFilter( pfCodec, L"AVI Codec" );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E37: AddFilter (codec) Failed")));
        pfCodec->Release();
        pfSource->Release();
        pFG->Release();
        return TST_FAIL;
    }


    //........................................................
    // add a video renderer
    //........................................................

    hr = CoCreateInstance( CLSID_VideoRenderer, NULL, CLSCTX_INPROC, IID_IBaseFilter
                         , (void **) &pfVideo);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E38: CoCreate... (renderer) Failed")));
        pfCodec->Release();
        pfSource->Release();
        pFG->Release();
        return TST_FAIL;
    }

    hr = pFG->AddFilter( pfVideo, L"Video renderer" );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E39: AddFilter(renderer) Failed")));
        pfCodec->Release();
        pfSource->Release();
        pfVideo->Release();
        pFG->Release();
        return TST_FAIL;
    }


    //........................................................
    // Connect source to videorenderer (via the codec
    //........................................................

    hr = ConnectFilters(pFG, pfSource, pfVideo);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E40: ConnectFilters source->video renderer Failed")));
        pfCodec->Release();
        pfSource->Release();
        pfVideo->Release();
        pFG->Release();
        return TST_FAIL;
    }

    if (CountFilters(pFG) != 3) return TST_FAIL;


    //........................................................
    // add an audio renderer
    //........................................................

    hr = CoCreateInstance( CLSID_AudioRender, NULL, CLSCTX_INPROC, IID_IBaseFilter
                         , (void **) &pfAudio);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E41: CoCreate... (audio render) Failed")));
        pfCodec->Release();
        pfSource->Release();
        pfVideo->Release();
        pFG->Release();
        return TST_FAIL;
    }

    hr = pFG->AddFilter( pfAudio, L"Audio renderer" );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E42: AddFilter(audio render) Failed")));
        pfCodec->Release();
        pfSource->Release();
        pfVideo->Release();
        pfAudio->Release();
        pFG->Release();
        return TST_FAIL;
    }


    //-------------------------------------------------------
    // Connect the source to the audio renderer
    //-------------------------------------------------------

    hr = ConnectFilters(pFG, pfSource, pfAudio);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E43: ConnectFilters source->audio render Failed")));
        pfCodec->Release();
        pfSource->Release();
        pfVideo->Release();
        pfAudio->Release();
        pFG->Release();
        return TST_FAIL;
    }

    pfCodec->Release();
    pfVideo->Release();
    pfAudio->Release();
    pfSource->Release();

    hr = pFG->RemoveFilter(pfVideo);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E44: Remove filter (video) Failed")));
        pFG->Release();
        return TST_FAIL;
    }

    hr = pFG->RemoveFilter(pfCodec);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E45: Remove filter (codec) Failed")));
        pFG->Release();
        return TST_FAIL;
    }

    hr = pFG->RemoveFilter(pfAudio);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E46: Remove filter (audio) Failed")));
        pFG->Release();
        return TST_FAIL;
    }

    hr = pFG->RemoveFilter(pfSource);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E47: Remove filter (source) Failed")));
        pFG->Release();
        return TST_FAIL;
    }

    pFG->Release();

    return TST_PASS;

} // TestConnectInGraph


//=================================================================
// Test Adding, connecting and enumerating filters
//=================================================================
int TestConnectUsingReg()
{

    // The diagrams show filters and ref counts

    HRESULT hr;

    IGraphBuilder * pFG = GetFilterGraph();

    //-------------------------------------------------------
    // Create and add a bunch of filters to the graph
    //-------------------------------------------------------

    IBaseFilter * pfVideo;        // a video renderer
    IBaseFilter * pfSource;       // a source filter


    // Add a source
    hr = pFG->AddSourceFilter(L"Curtis8.AVI", L"SourceFilter", &pfSource);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E48: AddSourceFilter Failed")));
        pFG->Release();
        return TST_FAIL;
    }

    if (CountFilters(pFG) != 1) return TST_FAIL;


    // add a video renderer

    hr = CoCreateInstance( CLSID_VideoRenderer, NULL, CLSCTX_INPROC, IID_IBaseFilter
                         , (void **) &pfVideo);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E49: CoCreate... (video renderer) Failed")));
        pfSource->Release();
        pFG->Release();
        return TST_FAIL;
    }

    hr = pFG->AddFilter( pfVideo, L"Video renderer" );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E50: AddFilter(video renderer) Failed")));
        pfVideo->Release();
        pfSource->Release();
        pFG->Release();
        return TST_FAIL;
    }


    //-------------------------------------------------------
    // Connect the source to the renderer - will need registry.
    //-------------------------------------------------------

    hr = ConnectFilters(pFG, pfSource, pfVideo);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E51: ConnectFilters source->video Failed")));
        pfVideo->Release();
        pfSource->Release();
        pFG->Release();
        return TST_FAIL;
    }

    hr = RenderAllPins(pFG, pfSource);


    pfVideo->Release();

    pfSource->Release();

    pFG->Release();

    return TST_PASS;

} // TestConnectUsingReg


void ReconnectFilter(IGraphBuilder * pFG, IBaseFilter * pf)
{
    ASSERT(pf!=NULL /* Name of Codec changed? */ );

    {
        IEnumPins * pep;
        pf->EnumPins( &pep );
        for (; ; ) {
            IPin * pPin;
            unsigned long cPin;
            pep->Next(1, &pPin, &cPin ); /* Get a pPin */
            if (cPin<1)
                break;                   /* (or else get out) */

            {
                HRESULT hr;
                hr = pFG->Reconnect(pPin);
                ASSERT (SUCCEEDED(hr));

                IPin *pConnected;
                hr = pPin->ConnectedTo(&pConnected);
                ASSERT (SUCCEEDED(hr));
                hr = pFG->Reconnect(pConnected);
                pConnected->Release();
                ASSERT (SUCCEEDED(hr));
                pPin->Release();
            }
        }
        pep->Release();
    }

    Sleep(5000);  // try to let reconnect complete

} // ReconnectFilter



// enumerate all the filters iun the graph and Reconnect all their pins

int TestReconnect(void)
{

    IGraphBuilder * pFG = GetFilterGraph();
    HRESULT hr;

    hr = pFG->RenderFile(L"Curtis8.AVI", NULL);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E52: RenderFile Failed")));
        pFG->Release();
        return TST_FAIL;
    }

    IEnumFilters * pEF;
    pFG->EnumFilters(&pEF);
    IBaseFilter * af[1];

    for (; ; ) {
        ULONG cFound;
        pEF->Next(1, af, &cFound);
        if (cFound>0) {
            ReconnectFilter(pFG, af[0]);
        }
    }
    pFG->Release();
    return TST_PASS;     // and let everything anihilate.

} // TestReconnect



// Test that it will Run, Stop, etc.  - but also test Reconnect() here
// because that doesn't give much of a return code and might fail
// silently.  So we'll do it and then see if it plays OK.
int TestPlay() {
    HRESULT hr;
    IMediaFilter * pmf;        // interface for controlling whole graph
    IMediaControl * pmc;       // er - ditto
    CRefTime tBase;

    IReferenceClock * pClock;  // a clock

    IGraphBuilder * pFG = GetFilterGraph();

    hr = pFG->RenderFile(L"Curtis8.AVI", NULL);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E53: RenderFile Failed")));
        pFG->Release();
        return TST_FAIL;
    }

//    TestReconnect(pFG);   ??? put this back in when it works!


    //-------------------------------------------------------
    // Get the IMediaFilter interface to control it all
    //-------------------------------------------------------

    pFG->QueryInterface( IID_IMediaFilter, (void**)(&pmf) );
    if (pmf==NULL) {
        pFG->Release();
        return E_FAIL;
    }

    //-------------------------------------------------------
    // Get the IMediaControl interface to control it all
    //-------------------------------------------------------

    pFG->QueryInterface( IID_IMediaControl, (void**)(&pmc) );
    if (pmc==NULL) {
        pmf->Release();
        pFG->Release();
        return E_FAIL;
    }


    //-------------------------------------------------------
    // Create (another) clock
    //-------------------------------------------------------

    hr = CoCreateInstance( CLSID_SystemClock, NULL, CLSCTX_INPROC
                         , IID_IReferenceClock, (void **) &pClock);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E54: CoCreate...(system clock) Failed")));
        pmf->Release();
        pmc->Release();
        pFG->Release();
        return hr;
    }


    //-------------------------------------------------------
    // Set it as the sync source
    //-------------------------------------------------------

    hr = pmf->SetSyncSource( pClock );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E55: SetSyncSource Failed")));
        pClock->Release();
        pmf->Release();
        pmc->Release();
        pFG->Release();
        return hr;
    }

    //-------------------------------------------------------
    // Make it go - but jerkily
    //-------------------------------------------------------

    hr = pClock->GetTime((REFERENCE_TIME*)&tBase);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E56: GetTime Failed")));
        pClock->Release();
        pmf->Release();
        pmc->Release();
        pFG->Release();
        return TST_FAIL;
    }

    // need to use IMediaControl::Run if you want to wait for
    // completion, since the completion handling is tied to the
    // run start.

    // !!!there *may* be other bugs hidden here, to do with pause/run at t
    // time, but for now, let's get a test that should run and sort these more
    // subtle bugs out post-alpha. -- G.
    hr = pmc->Run();
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 0, TEXT("E58a: Run Failed")));
        pClock->Release();
        pmf->Release();
        pmc->Release();
        pFG->Release();
        return TST_FAIL;
    }

    if (WaitForPlayComplete(pmc) == TST_FAIL) {
        pClock->Release();
        pmf->Release();
        pmc->Release();
        pFG->Release();
        return TST_FAIL;
    }



    // As of today 25/3/95 this hangs in Stop for the source filter.
    // This does not appear to be a filtergraph problem.

    hr = pmf->Stop();
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E59: Stop() Failed")));
        pClock->Release();
        pmf->Release();
        pmc->Release();
        pFG->Release();
        return TST_FAIL;
    }

    pClock->Release();

    pmc->Release();

    pmf->Release();

    pFG->Release();

    return TST_PASS;
} // TestPlay;



//=====================================================================
// TestNullClock
//=====================================================================
int TestNullClock()
{

    HRESULT hr;

    //--------------------------------------------------------
    // Get a new filter graph to mess about with
    //--------------------------------------------------------
    IGraphBuilder * pFilG;
    hr = CoCreateInstance( CLSID_FilterGraph,        // clsid input
                           NULL,                     // Outer unknown
                           CLSCTX_INPROC,            // Inproc server
                           IID_IGraphBuilder,         // Interface required
                           (void **) &pFilG          // Where to put result
                         );
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E60: CoCreate...(filter graph) Failed")));
        return TST_FAIL;
    }


    IMediaFilter * pmf;
    pFilG->QueryInterface( IID_IMediaFilter, (void**)(&pmf) );
    if (pmf==NULL) {
        DbgLog((LOG_ERROR, 0, TEXT("E61: QueryInterface Failed")));
        pFilG->Release();
        return E_FAIL;
    }


    hr = pFilG->RenderFile(L"Curtis8.AVI", NULL);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E62: RenderFile Failed")));
        pmf->Release();
        pFilG->Release();
        return TST_FAIL;
    }

    hr = pmf->SetSyncSource(NULL);
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E63: SetSyncSource (NULL) Failed")));
        pmf->Release();
        pFilG->Release();
        return TST_FAIL;
    }


    hr = pmf->Pause();
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E64: Pause Failed")));
        pmf->Release();
        pFilG->Release();
        return TST_FAIL;
    }

    hr = pmf->Run(CRefTime(0L));
    if (FAILED(hr)){
        DbgLog((LOG_ERROR, 0, TEXT("E64: Pause Failed")));
        pmf->Release();
        pFilG->Release();
        return TST_FAIL;
    }

    pmf->Release();
    pFilG->Release();

    return TST_PASS;

} // TestNullClock



int TestRelease(void)
{
    IGraphBuilder * pfg;
    HRESULT hr;
    hr = CoCreateInstance( CLSID_FilterGraph,        // clsid
                           NULL,                     // Outer unknown
                           CLSCTX_INPROC,            // Inproc server
                           IID_IGraphBuilder,         // Interface required
                           (void **) &pfg            // Where to put result
                         );
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 0, TEXT("E65: Could not CoCreate... Filter graph.")));
        return TST_FAIL;
    }
    pfg->Release();

    DbgLog((LOG_TRACE, 0, TEXT("End of TestRelease")));
    return TST_PASS;
} // TestRelease



//=================================================================
// Test the simple functions that the rest of the filter graph relies on
//=================================================================
int TestLowLevelStuff()
{
    if (TST_PASS != TestRandom()){
        DbgLog((LOG_ERROR, 0, TEXT("E67: TestRandom failed")));
        return TST_FAIL;
    }
    if (TST_PASS != TestSorting()){
        DbgLog((LOG_ERROR, 0, TEXT("E68: TestSorting failed")));
        return TST_FAIL;
    }
    if (TST_PASS != TestUpstream()){
        DbgLog((LOG_ERROR, 0, TEXT("E69: TestUpstream failed")));
        return TST_FAIL;  // sorting a null graph - boring!
    }
    return TST_PASS;
} // TestLowLevelStuff



//=================================================================
// Do a full unit test.
//=================================================================
int TheLot()
{
    if (TST_PASS != TestLowLevelStuff()) {
        DbgLog((LOG_ERROR, 0, TEXT("E70: TestLowLevelStuff failed")));
        return TST_FAIL;
    }

    if (TST_PASS != TestRelease()) {
        DbgLog((LOG_ERROR, 0, TEXT("E70.1: TestRelease failed")));
        return TST_FAIL;
    }

    if (TST_PASS != TestRegister()){
        DbgLog((LOG_ERROR, 0, TEXT("E71: TestRegister failed")));
        return TST_FAIL;
    }

    if (TST_PASS != TestConnectInGraph()){
        DbgLog((LOG_ERROR, 0, TEXT("E72: TestConnectInGraph failed")));
        return TST_FAIL;
    }

    if (TST_PASS != TestConnectUsingReg()){
        DbgLog((LOG_ERROR, 0, TEXT("E73 TestConnectUsingReg failed")));
        return TST_FAIL;
    }


//    if (TST_PASS != TestNullClock())
//        DbgLog((LOG_ERROR, 0, TEXT("E74: TestNullClock failed")));
//        return TST_FAIL;
//    }

    if (TST_PASS != TestPlay()){
        DbgLog((LOG_ERROR, 0, TEXT("E75: TestPlay failed")));
        return TST_FAIL;
    }

    return TST_PASS;
} // TheLot



//--------------------------------------------------------------------------;
//
//  int expect
//
//  Description:
//      Compares the expected result to the actual result.  Note that this
//      function is not at all necessary; rather, it is a convenient
//      method of saving typing time and standardizing output.  As an input,
//      you give it an expected value and an actual value, which are
//      unsigned integers in our example.  It compares them and returns
//      TST_PASS indicating that the test was passed if they are equal, and
//      TST_FAIL indicating that the test was failed if they are not equal.
//      Note that the two inputs need not be integers.  In fact, if you get
//      strings back, you can modify the function to use lstrcmp to compare
//      them, for example.  This function is NOT to be copied to a test
//      application.  Rather, it should serve as a model of construction to
//      similar functions better suited for the specific application in hand
//
//  Arguments:
//      UINT uExpected: The expected value
//
//      UINT uActual: The actual value
//
//      LPSTR CaseDesc: A description of the test case
//
//  Return (int): TST_PASS if the expected value is the same as the actual
//      value and TST_FAIL otherwise
//
//   History:
//      06/08/93    T-OriG (based on code by Fwong)
//
//--------------------------------------------------------------------------;

int expect
(
    UINT    uExpected,
    UINT    uActual,
    LPSTR   CaseDesc
)
{
    if(uExpected == uActual)
    {
        tstLog(TERSE, "PASS : %s",CaseDesc);
        return(TST_PASS);
    }
    else
    {
        tstLog(TERSE,"FAIL : %s",CaseDesc);
        return(TST_FAIL);
    }
} // Expect()

/***************************************************************************\
*                                                                           *
*   IMediaControl* OpenGraph                                                 *
*                                                                           *
*   Description:                                                            *
*       Instantiate the filtergraph and open a file                         *
*                                                                           *
*   Arguments:                                                              *
*                                                                           *
*   Return (void):                                                          *
*       Pointer to the IMediaControl interface of the filter graph, or NULL *
*       on failure                                                          *
*                                                                           *
\***************************************************************************/

IMediaControl*
OpenGraph(void)
{

    tstLog(TERSE, "Opening Curtis8.avi");

    // instantiate the filtergraph
    IGraphBuilder* pFG;
    HRESULT hr = CoCreateInstance(
                            CLSID_FilterGraph,
                            NULL,
                            CLSCTX_INPROC,
                            IID_IGraphBuilder,
                            (void**) &pFG);
    if (!CheckResult(hr, "Open")) {
        return NULL;
    }

    // tell it to build the graph for this file
    hr = pFG->RenderFile(L"Curtis8.avi", NULL);

    if (!CheckResult(hr, "RenderFile") ) {
        pFG->Release();
        return NULL;
    }

    // get an IMediaControl interface
    IMediaControl* pMF;
    hr = pFG->QueryInterface(IID_IMediaControl, (void**) &pMF);
    if (!CheckResult(hr, "QI for IMediaControl")) {
        pFG->Release();
        return NULL;
    }

    // dont need this. We keep the IMediaControl around and
    // release that to get rid of the filter graph
    pFG->Release();

    tstLog(VERBOSE, "Open Completed");
    return pMF;
}


// simple seek test to play all the movie

int FAR PASCAL ExecSeek1(void)
{
    IMediaControl * pMC = OpenGraph();
    if (pMC == NULL) {
        return TST_FAIL;
    }

    IMediaPosition * pMP;
    HRESULT hr = pMC->QueryInterface(IID_IMediaPosition, (void**)&pMP);
    if (!CheckResult(hr, "QI for IMediaPosition")) {
        return TST_FAIL;
    }

    BOOL bFailed = FALSE;

    hr = pMC->Stop();
    if (!CheckResult(hr, "Stop")) {
        bFailed = TRUE;
    }

    double d;
    hr = pMP->get_Duration(&d);

    if (CheckResult(hr, "get_Duration")) {
        tstLog(TERSE,
            "Duration is %d.%d secs",
            (long)d,
            (long)(d*1000)%1000
        );
    } else {
        bFailed = TRUE;
    }

    hr = pMP->put_CurrentPosition(0);
    if (!CheckResult(hr, "put_CurrentPosition")) {
        bFailed = TRUE;
    }
    hr = pMP->put_StopTime(d);
    if (!CheckResult(hr, "put_StopTime")) {
        bFailed = TRUE;
    }
    hr = pMC->Run();
    if (!CheckResult(hr, "Run")) {
        bFailed = TRUE;
    } else {
	// only wait for completion if Run succeeds

        if (WaitForPlayComplete(pMC) == TST_FAIL) {
            return TST_FAIL;
        }
    }


    hr = pMC->Stop();
    if (!CheckResult(hr, "Stop")) {
	bFailed = TRUE;
    }


    pMP->Release();
    pMC->Release();

    if (bFailed) {
        return TST_FAIL;
    } else {
        return TST_PASS;
    }
}

// play 2secs to 5 secs at normal speed
int FAR PASCAL ExecSeek2(void)
{
    IMediaControl * pMC = OpenGraph();
    if (pMC == NULL) {
        return TST_FAIL;
    }

    IMediaPosition * pMP;
    HRESULT hr = pMC->QueryInterface(IID_IMediaPosition, (void**)&pMP);
    if (!CheckResult(hr, "QI for IMediaPosition")) {
        return TST_FAIL;
    }

    BOOL bFailed = FALSE;

    hr = pMC->Stop();
    if (!CheckResult(hr, "Stop")) {
        bFailed = TRUE;
    }

    double d;
    hr = pMP->get_Duration(&d);

    if (CheckResult(hr, "get_Duration")) {
        tstLog(TERSE,
            "Duration is %d.%d secs",
            (long)d,
            (long)(d*1000)%1000
        );
    } else {
        bFailed = TRUE;
    }

    hr = pMP->put_CurrentPosition(2);
    if (!CheckResult(hr, "put_CurrentPosition")) {
        bFailed = TRUE;
    }
    hr = pMP->put_StopTime(5);
    if (!CheckResult(hr, "put_StopTime")) {
        bFailed = TRUE;
    }
    hr = pMC->Run();
    if (!CheckResult(hr, "Run")) {
        bFailed = TRUE;
    } else {

	// only wait for completion if run succeeded
        if (WaitForPlayComplete(pMC) == TST_FAIL) {
            return TST_FAIL;
        }
    }

    // teardown
    hr = pMC->Stop();
    if (!CheckResult(hr, "Stop")) {
	bFailed = TRUE;
    }

    pMP->Release();
    pMC->Release();

    if (bFailed) {
        return TST_FAIL;
    } else {
        return TST_PASS;
    }

}

// play 2 secs to 5 secs at 1/2 speed
int FAR PASCAL ExecSeek3(void)
{
    IMediaControl *pMC = OpenGraph();
    if (pMC == NULL) {
        return TST_FAIL;
    }

    IMediaPosition * pMP;
    HRESULT hr = pMC->QueryInterface(IID_IMediaPosition, (void**)&pMP);
    if (!CheckResult(hr, "QI for IMediaPosition")) {
        return TST_FAIL;
    }

    BOOL bFailed = FALSE;

    hr = pMC->Stop();
    if (!CheckResult(hr, "Stop")) {
        bFailed = TRUE;
    }

    double d;
    hr = pMP->get_Duration(&d);

    if (CheckResult(hr, "get_Duration")) {
        tstLog(TERSE,
            "Duration is %d.%d secs",
            (long)d,
            (long)(d*1000)%1000
        );
    } else {
        bFailed = TRUE;
    }

    hr = pMP->put_CurrentPosition(2);
    if (!CheckResult(hr, "put_CurrentPosition")) {
        bFailed = TRUE;
    }
    hr = pMP->put_StopTime(5);
    if (!CheckResult(hr, "put_StopTime")) {
        bFailed = TRUE;
    }
    hr = pMP->put_Rate(0.5);
    if (!CheckResult(hr, "put_Duration")) {
        bFailed = TRUE;
    }
    hr = pMC->Run();
    if (!CheckResult(hr, "Run")) {
        bFailed = TRUE;
    } else {
        // wait for movie to end
        if (WaitForPlayComplete(pMC) == TST_FAIL) {
            return TST_FAIL;
        }
    }

    // teardown
    hr = pMC->Stop();
    if (!CheckResult(hr, "Stop")) {
	bFailed = TRUE;
    }

    pMP->Release();
    pMC->Release();

    if (bFailed) {
        return TST_FAIL;
    } else {
        return TST_PASS;
    }
}

// simple oleaut32 test for bug repro
int FAR PASCAL TestInvoke()
{
    IMediaControl *pMC = OpenGraph();
    if (pMC == NULL) {
        return TST_FAIL;
    }
    IMediaPosition* pInterface;
    REFIID riid = IID_IMediaPosition;
	OLECHAR* pMethodName = L"StopTime";

    HRESULT hr = pMC->QueryInterface(riid, (void**)&pInterface);
    if (!CheckResult(hr, "QueryInterface")) {
        return TST_FAIL;
    }
    pMC->Release();

    VARIANT v0;
    v0.vt = VT_R8;
    v0.dblVal = 4.0;

    DISPPARAMS disp;
    DISPID mydispid = DISPID_PROPERTYPUT;
    disp.cNamedArgs = 1;
    disp.cArgs = 1;
    disp.rgdispidNamedArgs = &mydispid;
    disp.rgvarg = &v0;
    VARIANT vRes;
    VariantInit(&vRes);

    ITypeLib * ptlib;
    hr = LoadRegTypeLib(LIBID_QuartzTypeLib, 1, 0, 0, &ptlib);
    if (!CheckResult(hr, "LoadRegTypeLib")) {
        pInterface->Release();
        return TST_FAIL;
    }

    ITypeInfo *pti;
    hr = ptlib->GetTypeInfoOfGuid(
            riid,
            &pti);
    if (!CheckResult(hr, "GetTypeInfoOfGuid")) {
        ptlib->Release();
        pInterface->Release();
        return TST_FAIL;
    }
    ptlib->Release();

    long dispid;
    hr = pti->GetIDsOfNames(
            &pMethodName,
            1,
            &dispid);
    if (!CheckResult(hr, "GetIDsOfNames")) {
        pti->Release();
        pInterface->Release();
        return TST_FAIL;
    }


    EXCEPINFO expinfo;
    UINT uArgErr;
    tstLog(TERSE, "Testing invoke");
    hr = pti->Invoke(
            pInterface,
            dispid,
            DISPATCH_PROPERTYPUT,
            &disp,
            &vRes,
            &expinfo,
            &uArgErr);

    pti->Release();
    pInterface->Release();

    if (!CheckResult(hr, "Invoke")) {
        return TST_FAIL;
    } else {
        tstLog(TERSE, "Testing invoke succeeded");
        return TST_PASS;
    }
}

// simple deferred command test
int FAR PASCAL ExecDefer()
{
    if (TestInvoke() != TST_PASS) {
        return TST_FAIL;
    }

    IMediaControl *pMC = OpenGraph();
    if (pMC == NULL) {
        return TST_FAIL;
    }

    // must pause the graph for this to work
    pMC->Pause();
    pMC->Stop();

    BOOL bFailed = FALSE;

    IQueueCommand * pQ;
    HRESULT hr = pMC->QueryInterface(IID_IQueueCommand, (void**)&pQ);
    if (!CheckResult(hr, "QI for IQueueCommand")) {
        pMC->Release();
        return TST_FAIL;
    }

    // use this for queueing the commands
    {
        CQueueCommand q(pQ);


        // queue a seek at stream 1s to go to 4s
        // param for put_Start is 4s, executed at 1s
        CVariant arg1;
        arg1 = double(4.0);
        CVariant result;

        hr = q.InvokeAt(
            TRUE,                       // bStream
            1.0,                        // execute at time
            L"CurrentPosition",         // method name
            IID_IMediaPosition,         // on this interface
            DISPATCH_PROPERTYPUT,
            1,                          // 1 param
            &arg1,
            &result);

        if (!CheckResult(hr, "InvokeAt 1")) {
            bFailed = TRUE;
        }
    }
    // can now release pQ since its addrefed
    pQ->Release();


    hr = pMC->QueryInterface(IID_IQueueCommand, (void**)&pQ);
    if (!CheckResult(hr, "QI for IQueueCommand")) {
        pMC->Release();
        return TST_FAIL;
    }

    // use this for queueing the commands
    {
        CQueueCommand q(pQ);


        // queue a seek at stream 1s to go to 4s
        // param for put_Start is 4s, executed at 1s
        CVariant arg1;
        CVariant result;

        // at 5s go to 3s
        arg1 = double(3);
        hr = q.InvokeAt(
                TRUE,
                5.0,
                L"CurrentPosition",
                IID_IMediaPosition,
                DISPATCH_PROPERTYPUT,
                1,
                &arg1,
                &result);


        if (!CheckResult(hr, "InvokeAt 2")) {
            bFailed = TRUE;
        }
    }
    // can now release pQ since its addrefed
    pQ->Release();

    // now play to end

    hr = pMC->Run();
    if (!CheckResult(hr, "Run")) {
        bFailed = TRUE;
    } else {

        // wait for movie to end
        if (WaitForPlayComplete(pMC) == TST_FAIL) {
            bFailed = TRUE;
        }
    }

    // cleanup
    pMC->Release();

    if (bFailed) {
        return TST_FAIL;
    }
    return TST_PASS;
}


// seek while paused, checking current posn
int FAR PASCAL ExecSeek4(void)
{
    IMediaControl *pMC = OpenGraph();
    if (pMC == NULL) {
        return TST_FAIL;
    }

    IMediaPosition * pMP;
    HRESULT hr = pMC->QueryInterface(IID_IMediaPosition, (void**)&pMP);
    if (!CheckResult(hr, "QI for IMediaPosition")) {
        return TST_FAIL;
    }

    BOOL bFailed = FALSE;

    hr = pMC->Pause();
    if (!CheckResult(hr, "Pause")) {
        bFailed = TRUE;
    }

    double d;
    hr = pMP->get_Duration(&d);

    if (CheckResult(hr, "get_Duration")) {
        tstLog(TERSE,
            "Duration is %d.%d secs",
            (long)d,
            (long)(d*1000)%1000
        );
    } else {
        bFailed = TRUE;
    }

    hr = pMP->get_CurrentPosition(&d);

    if (CheckResult(hr, "get_CurrentPosition")) {
        tstLog(TERSE,
            "Current at 0 is %d.%d secs",
            (long)d,
            (long)(d*1000)%1000
        );
    } else {
        bFailed = TRUE;
    }

    // sleep for a second so interactive user can see the frame
    Sleep(1000);

    hr = pMP->put_CurrentPosition(1.5);
    if (!CheckResult(hr, "put_CurrentPosition when paused")) {
        bFailed = TRUE;
    }

    hr = pMP->get_CurrentPosition(&d);

    if (CheckResult(hr, "get_CurrentPosition")) {
        tstLog(TERSE,
            "Current at 1.5 is %d.%d secs",
            (long)d,
            (long)(d*1000)%1000
        );
    } else {
        bFailed = TRUE;
    }

    // sleep for a second so interactive user can see the frame
    Sleep(1000);

    // now play to end

    hr = pMC->Run();
    if (!CheckResult(hr, "Run")) {
        bFailed = TRUE;
    } else {

        // wait for movie to end
        if (WaitForPlayComplete(pMC) == TST_FAIL) {
            return TST_FAIL;
        }
    }

    // now pause and check current position
    hr = pMC->Pause();
    if (!CheckResult(hr, "Pause at end")) {
        bFailed = TRUE;
    }

    hr = pMP->get_CurrentPosition(&d);

    if (CheckResult(hr, "get_CurrentPosition")) {
        tstLog(TERSE,
            "Current at end (ie 0) is %d.%d secs",
            (long)d,
            (long)(d*1000)%1000
        );
    } else {
        bFailed = TRUE;
    }

    // teardown
    hr = pMC->Stop();
    if (!CheckResult(hr, "Stop")) {
	bFailed = TRUE;
    }

    pMP->Release();
    pMC->Release();

    if (bFailed) {
        return TST_FAIL;
    } else {
        return TST_PASS;
    }
}

// check for repaint messages by:
//  hide the window
//  set the position in the movie
//  clear out the event queue
//  show the window
//  play the movie to/from same position
//  eat all events until the EC_COMPLETE. Any repaints will be before
//   the EC_COMPLETE.

// returns S_OK if there were EC_REPAINTS, S_FALSE if there were none,
// or an error code if something went wrong
// called from ExecRepaint

HRESULT
CheckRepaints(
    double dPos,
    IMediaPosition *pMP,
    IMediaEvent *pME,
    IMediaControl *pMC,
    IVideoWindow *pVW)
{
    // hide the window
    HRESULT hr = pVW->put_Visible(0);
    if (!CheckResult(hr, "put_Visible")) {
        return hr;
    }


    // set start and stop to dPos
    hr = pMP->put_CurrentPosition(dPos);
    if (!CheckResult(hr, "put_CurrentPosition")) {
        return hr;
    }
    hr = pMP->put_StopTime(dPos);
    if (!CheckResult(hr, "put_StopTime")) {
        return hr;
    }

    LONG lEvent;
	LONG_PTR lParam1, lParam2;


    // clear out the event queue
    while (pME->GetEvent(&lEvent, &lParam1, &lParam2, 0) != E_ABORT)
        ;   // just eat the events

    // show the window
    hr = pVW->put_Visible(-1);
    if (!CheckResult(hr, "put_Visible")) {
        return hr;
    }

    // play the movie
    hr = pMC->Run();
    if (!CheckResult(hr, "Run")) {
        return hr;
    }

    // wait for completion, checking for EC_REPAINTs
    HRESULT hrReturn = S_FALSE;     // assume no EC_REPAINTs

    do  {

        hr = pME->GetEvent(
                &lEvent,
                &lParam1,
                &lParam2,
                INFINITE);

        if (!CheckResult(hr, "GetEvent")) {
            return hr;
        }

        if (lEvent == EC_REPAINT) {
            hrReturn = S_OK;
        }

        // check for error/user aborts
        if ((lEvent == EC_ERRORABORT) ||
            (lEvent == EC_USERABORT)) {
                tstLog(TERSE, "Operation aborted");
                hrReturn = E_ABORT;

                // make sure we exit the loop
                lEvent = EC_COMPLETE;
        }
    } while (lEvent != EC_COMPLETE);

    hr = pMC->Stop();
    if (!CheckResult(hr, "Stop")) {
        return hr;
    }

    return hrReturn;
}

// repaint, default repaint handling
int FAR PASCAL ExecRepaint(void)
{
    BOOL bFailed = FALSE;

    IMediaControl *pMC = OpenGraph();
    if (pMC == NULL) {
        return TST_FAIL;
    }

    IMediaPosition * pMP;
    HRESULT hr = pMC->QueryInterface(IID_IMediaPosition, (void**)&pMP);
    if (!CheckResult(hr, "QI for IMediaPosition")) {
        return TST_FAIL;
    }

    IMediaEvent * pME;
    hr = pMC->QueryInterface(IID_IMediaEvent, (void**)&pME);
    if (!CheckResult(hr, "QI for IMediaEvent")) {
        return TST_FAIL;
    }

    IVideoWindow *pVW;
    hr = pMC->QueryInterface(IID_IVideoWindow, (void**)&pVW);
    if (!CheckResult(hr, "QI for IVideoWindow")) {
        return TST_FAIL;
    }


    // check for repaints at the middle of the movie,

    // first with default handling in place
    hr = pME->RestoreDefaultHandling(EC_REPAINT);
    if (!CheckResult(hr, "RestoreDefaultHandling")) {
        return TST_FAIL;
    }


    // check whether we get any repaints (S_OK -> yes, S_FALSE->no, or an
    // error
    hr = CheckRepaints(
            1.5,            // position
            pMP,
            pME,
            pMC,
            pVW);

    // look for errors (already reported)
    if (FAILED(hr)) {
        bFailed = TRUE;
    }

    // make sure we didn't get any repaints
    if (hr != S_FALSE) {
        tstLog(TERSE, "Got EC_REPAINT when default handling set");
        bFailed = TRUE;
    }

    // now disable default handling - we should get them all
    hr = pME->CancelDefaultHandling(EC_REPAINT);
    if (!CheckResult(hr, "CancelDefaultHandling")) {
        bFailed = TRUE;
    }


    // check whether we get any repaints (S_OK -> yes, S_FALSE->no, or an
    // error
    hr = CheckRepaints(
            1.5,            // position
            pMP,
            pME,
            pMC,
            pVW);

    // look for errors (already reported)
    if (FAILED(hr)) {
        bFailed = TRUE;
    }

    // make sure we didn't get any repaints
    if (hr != S_OK) {
        tstLog(TERSE, "Got no EC_REPAINT when default handling cancelled");
        bFailed = TRUE;
    }

    // now the same two tests but at the end of the movie
    double dDuration;
    hr = pMP->get_Duration(&dDuration);

    if (CheckResult(hr, "get_Duration")) {
        tstLog(TERSE,
            "Duration is %d.%d secs",
            (long)dDuration,
            (long)(dDuration*1000)%1000
        );
    } else {
        bFailed = TRUE;
    }

    // first with default handling in place
    hr = pME->RestoreDefaultHandling(EC_REPAINT);
    if (!CheckResult(hr, "RestoreDefaultHandling")) {
        bFailed = TRUE;
    }


    // check whether we get any repaints (S_OK -> yes, S_FALSE->no, or an
    // error
    hr = CheckRepaints(
            dDuration,            // position
            pMP,
            pME,
            pMC,
            pVW);

    // look for errors (already reported)
    if (FAILED(hr)) {
        bFailed = TRUE;
    }

    // make sure we didn't get any repaints
    if (hr != S_FALSE) {
        tstLog(TERSE, "Got EC_REPAINT when default handling set");
        bFailed = TRUE;
    }

    // now disable default handling - we should get them all
    hr = pME->CancelDefaultHandling(EC_REPAINT);
    if (!CheckResult(hr, "CancelDefaultHandling")) {
        bFailed = TRUE;
    }


    // check whether we get any repaints (S_OK -> yes, S_FALSE->no, or an
    // error
    hr = CheckRepaints(
            dDuration,            // position
            pMP,
            pME,
            pMC,
            pVW);

    // look for errors (already reported)
    if (FAILED(hr)) {
        bFailed = TRUE;
    }

    // make sure we didn't get any repaints
    if (hr != S_OK) {
        tstLog(TERSE, "Got no EC_REPAINT when default handling cancelled");
        bFailed = TRUE;
    }



    // teardown
    hr = pMC->Stop();
    if (!CheckResult(hr, "Stop")) {
	bFailed = TRUE;
    }

    pVW->Release();
    pME->Release();
    pMP->Release();
    pMC->Release();

    if (bFailed) {
        return TST_FAIL;
    } else {
        return TST_PASS;
    }
}

#pragma warning(disable: 4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\test\fgtest.h ===
// The work is split into:
// The test shell:  the actual main program
// FgtMain: really just an interface to the test shell
// FgTest: the tests.  The starting point for these are the calls listed here.


// These all return one of the standard test shell return codes TST_PASS etc.

//==============================================================
// Call this first - creates the filter graph *pFG
//==============================================================
int InitFilterGraph();

//==============================================================
// Call this last - Gets rid of the filter graph *pFG
//==============================================================
int TerminateFilterGraph();


//==============================================================
// Test registration of filters and pins
//==============================================================
int TestRegister();

//==============================================================
// Test the internal SortList function of filtergraph
//==============================================================
int TestSorting();


//=================================================================
// Test the upstream ordering with the CURRENT graph only
//=================================================================
int TestUpstream();


//=================================================================
// Test the list sorting internal functions
//=================================================================
int TestRandom();


//=================================================================
// Do a full unit test
//=================================================================
int TheLot();


//=================================================================
// Test reconnect
//=================================================================
int TestReconnect(void);


//=================================================================
// Test the simple functions that the rest of the filter graph relies on
//=================================================================
int TestLowLevelStuff();


//=================================================================
// Test connections of filters NOT using the registry
//=================================================================
int TestConnectInGraph();


//=================================================================
// Test connections of filters using the registry
//=================================================================
int TestConnectUsingReg();

int TestNullClock();
int TestRegister();
int TestPlay();

//=================================================================
// Test play using IMediaControl and IMediaPosition
//=================================================================
int ExecSeek1();
int ExecSeek2();
int ExecSeek3();
int ExecSeek4();
int ExecRepaint();
int ExecDefer();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\test\fgtmain.h ===
/***************************************************************************\
*                                                                           *
*   Copyright (c) 1993,1996 Microsoft Corporation.  All rights reserved     *
*                                                                           *
*                                                                           *
\***************************************************************************/


// Prototypes

extern LRESULT FAR PASCAL MenuProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
extern BOOL InitOptionsMenu (LRESULT (CALLBACK* ManuProc)(HWND, UINT, WPARAM, LPARAM));
extern LRESULT FAR PASCAL tstAppWndProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Constants

// Stops the logging intensive test
#define VSTOPKEY            VK_SPACE

// The string identifiers for the group's names
#define GRP_REG             100
#define GRP_SORT            101
#define GRP_CONNECT         102
#define GRP_ALL             103
#define GRP_SEEK            104
#define GRP_LAST            GRP_SEEK

// The string identifiers for the test's names
#define ID_TESTREG         200
#define ID_TESTSORT        201
#define ID_TESTRAND        202
#define ID_TESTALL         203
#define ID_TESTSEEK1       204
#define ID_TESTSEEK2	   205
#define ID_TESTSEEK3	   206
#define ID_TESTSEEK4	   207
#define ID_TESTREPAINT     208
#define ID_TESTDEFER       209
#define ID_TESTLAST        ID_TESTDEFER

// The test case identifier (used in the switch statement in execTest)
#define FX_TEST1            300
#define FX_TEST2            301
#define FX_TEST3            303
#define FX_TEST4            304
#define FX_TESTSEEK1	    305
#define FX_TESTSEEK2        306
#define FX_TESTSEEK3	    307
#define FX_TESTSEEK4	    308
#define FX_TESTREPAINT      309
#define FX_TESTDEFER        310

// Menu identifiers
#define IDM_REGISTER        401
#define IDM_SETFILE         402
#define IDM_CREATE          403
#define IDM_RELEASE         404
#define IDM_SORT            405
#define IDM_RANDOM          406
#define IDM_UPSTREAMORDER   407
#define IDM_THELOT          408
#define IDM_PLAY            409
#define IDM_NULLCLOCK       410
#define IDM_RECONNECT       411
#define IDM_CONNECT         412
#define IDM_DISCONNECT      413
#define IDM_TRANSFORM       414
#define IDM_STOP            415
#define IDM_PAUSE           416
#define IDM_RUN             417
#define IDM_EXIT            418
#define IDM_LOW             419
#define IDM_CONNECTIN       420
#define IDM_CONNECTREG      421

// Identifies the test list section of the resource file
#define TEST_LIST           500

// Multiple platform support
#define PLATFORM1           1


// Global variables

extern HWND      ghwndTstShell;  // Handle of main window of test shell

extern HINSTANCE hinst;          // Handle of the running instance of the test

extern HMENU   hmenuOptions;     // Handle of the options menu

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\test\fgtmain.cpp ===
//==========================================================================
//
//  Copyright (c) 1996 Microsoft Corporation.  All rights reserved
//
//  Abstract:
//     Interface to test shell to test FilterGraph.
//     The actual tests are in fgtest.cpp
//  Contents:
//
//  History:
//      16-Mar-95   lauriegr - created - based on quartz test sample app
//==========================================================================

#include <streams.h>    // Streams architecture
//#include <windows.h>    // Include file for windows APIs
#include <windowsx.h>   // Windows macros etc.
// #include <vfw.h>        // Video for windows
#include <tstshell.h>   // Include file for the test shell's APIs
#include <measure.h>    // Performance measurements

//#include <string.h>
#include <wxdebug.h>
// #include <filgraph.h>
#include "fgtest.h"   // interface to the real work

#include "fgtmain.h"   // our own one.  menu constants etc.

// Globals

HMENU   hmenuOptions;     // Handle of the options menu
HWND      ghwndTstShell;  // Handle of main window of test shell
HINSTANCE hinst;          // Handle of the running instance of the test

// App Name - can be used by the test apps.
LPSTR           szAppName = "Filter Graph Unit Test";

//==========================================================================
//
//  int tstGetTestInfo
//
//  Description:
//      Called by test shell.
//      Saves a hInstance from test shell.
//      Returns a name for the test and a name for the ini section
//      (actually we use the same name for both)
//
//  Arguments:
//  In  HINSTANCE hinstance       - from test shell
//
//  Out LPSTR lpszTestName: Name for test.
//          Used by test shell as caption for main window
//          and as the name of its class.
//
//  Out LPSTR lpszPathSection: Name of section in win.ini in which
//          the default input and output paths are stored.
//
//      LPWORD wPlatform: The platform on which the tests are to be run,
//          which may be determined dynamically.  In order for a test to
//          be shown on the run list, it must have all the bits found in
//          wPlatform turned on.  Zero means that all tests will be run.
//          In general, tests are run iff
//               ((wTestPlatform & wPlatform) == wPlatform)
//
//  Return (int):
//      Identifies the test list resource (in the resource file).
//
//==========================================================================

int tstGetTestInfo
    ( HINSTANCE   hinstance
    , LPSTR       lpszTestName
    , LPSTR       lpszPathSection
    , LPWORD      wPlatform
    )
{
    hinst = hinstance;
    lstrcpyA (lpszTestName, szAppName);
    lstrcpyA (lpszPathSection, szAppName);
    *wPlatform = 0;

    return TEST_LIST;
} // tstGetTestInfo()



//===========================================================================
//
//  void InitOptionsMenu
//
//  Description:
//      Creates an additional app-specific menu from TestMenu in the rc file
//
//  Arguments:
//          MenuProc (not used)
//
//  Return (BOOL):
//      TRUE if menu installation is successful, FALSE otherwise
//
//==========================================================================

BOOL InitOptionsMenu
    ( LRESULT (CALLBACK* MenuProc)(HWND, UINT, WPARAM, LPARAM)
    )
{
    HMENU   hTestMenu;

    hTestMenu = LoadMenu(hinst, TEXT("TestMenu"));
    if (NULL == hTestMenu)
        return(FALSE);

    HMENU hmShell = GetMenu(ghwndTstShell);
    if ( !AppendMenu(hmShell, MF_POPUP, (UINT)hTestMenu, TEXT("TestMenu") ) ) {
        return(FALSE);
    }

    DrawMenuBar(ghwndTstShell);
    return TRUE;
}



//==========================================================================
//
//  BOOL tstInit
//
//  Description:
//      Called by the test shell before anything else.
//
//      -- Do any menu installation here by calling tstInstallCustomTest
//         to add all menus that the test application wants to add.
//         MUST do that here (can't do later)
//
//      -- To trap window messages of the main test shell window, install
//          window procedure here by calling tstInstallDefWindowProc.
//
//      -- To use the status bar for (e.g. to display the name of the
//         currently running test, call tstDisplayCurrentTest here.
//
//      -- To change the stop key from ESC to something else,
//         call tstChangeStopVKey now.
//
//      -- To add dynamic test cases to the test list, first add their
//         names to the virtual string table using tstAddNewString
//         (and add their group's name too), and then add the actual tests
//         using tstAddTestCase.
//
//  Return (BOOL):
//      TRUE if initialization went well, FALSE otherwise which will abort
//      execution.
//
//==========================================================================

BOOL tstInit
    ( HWND    hwndMain  // handle to the main window from test shell
    )
{

    HRESULT hr;
    int rc;

    hr = CoInitialize(NULL);            // Initialise COM library
    if (FAILED(hr)) {
         MessageBox(NULL
                   , TEXT("!! CoInitialize failed !! (This test is completely shot)")
                   , TEXT("ERROR")
                   , 0
                   );
         return FALSE;
    }
    DbgInitialise(hinst);          // initialise debug output
    MSR_INIT();

    // It might have been nice to have this a few lines earlier
    // - but we gotta do DbgInitialise first!
    DbgLog((LOG_TRACE, 2, TEXT("Entering tstInit")));

    // Keep a copy of a handle to the main window
    ghwndTstShell = hwndMain;

    // Install our window procedure to trap msgs for test shell main window
    tstInstallDefWindowProc (tstAppWndProc);

    // Install our menus
    if (InitOptionsMenu(NULL)==FALSE) {
        DbgLog((LOG_ERROR, 1, TEXT("Menu initialisation failed.  I'm shot!") ));
        return FALSE;
    }

    // Tell Test Shell to display the name of the currenly executing API
    // in its status bar.  (Would be rude not to).
    tstDisplayCurrentTest();

    rc = InitFilterGraph();
    if (rc!=TST_PASS) {
        DbgLog((LOG_ERROR, 1, TEXT("Filter graph initialisation failed.  I'm shot!") ));
        return FALSE;
    }

    DbgLog((LOG_TRACE, 1, TEXT("Tests initialised OK")));
    return TRUE;
} // tstInit()




//==========================================================================
//
//  int execTest
//
//  Description:
//      Called by test shell to run a test
//      Note that it needs not switch on nFxID, but may also
//      use iCase or wID.
//
//  Return (int): Indicates the result of the test by using TST_FAIL,
//          TST_PASS, TST_OTHER, TST_ABORT, TST_TNYI, TST_TRAN, or TST_TERR
//
//==========================================================================

int execTest
    (   int     nFxID    // test case id - third column of test list in rc file
    ,   int     iCase    // test case number
    ,   UINT    wID      // test case string id
    ,   UINT    wGroupID // test case group id
    )
{
    int ret = TST_OTHER;

    tstBeginSection(" ");

    switch(nFxID)
    {
        case FX_TEST1:
            ret = TestRegister();
            break;

        case FX_TEST2:
            ret = TestSorting();
            break;

        case FX_TEST3:
            ret = TestRandom();
            break;

        case FX_TEST4:
            ret = TheLot();
            break;

	case FX_TESTSEEK1:
	    ret = ExecSeek1();
	    break;

	case FX_TESTSEEK2:
	    ret = ExecSeek2();
	    break;

	case FX_TESTSEEK3:
	    ret = ExecSeek3();
	    break;

	case FX_TESTSEEK4:
	    ret = ExecSeek4();
	    break;

        case FX_TESTREPAINT:
            ret = ExecRepaint();
            break;

        case FX_TESTDEFER:
            ret = ExecDefer();
            break;

        default:
            break;
    }

    HANDLE hFile;
    hFile = CreateFile("Perf.log", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
    MSR_DUMP(hFile);     // to file
//  Msr_Dump(NULL);      // to debugger
    CloseHandle(hFile);

    tstEndSection();

    return(ret);

} // execTest()




//==========================================================================
//
//  void tstTerminate
//
//  Description:
//      Clean up.  Called when the test series is finished.
//
//==========================================================================

void tstTerminate(void)
{
    DbgLog((LOG_TRACE, 1, TEXT("Entering tstTerminate")));

    DbgTerminate();
    CoUninitialize();

    return;
} // tstTerminate()




//==========================================================================
//
//  LRESULT tstAppWndProc
//
//  Description:
//      Traps the window messages of the main Test Shell window.
//      Is installed by  tstInstallDefWindowProc and gets
//      all window messages thereafter.  Allows us to
//      be notified of events via a window without creating our
//      own hidden window or waiting in a tight PeekMessage() loop.
//      Must call DefWindowProcA in the default case -
//      DefWindowProcA because the test shell main window is an ANSI window.
//
//==========================================================================

LRESULT FAR PASCAL tstAppWndProc
    ( HWND    hWnd
    , UINT    msg
    , WPARAM  wParam
    , LPARAM  lParam
    )
{
    switch (msg)
    {
        case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

            case IDM_THELOT:
                TheLot();
                break;

            case IDM_LOW:
                TestLowLevelStuff();
                break;

            case IDM_REGISTER:
                TestRegister();
                break;

            case IDM_RANDOM:
                TestRandom();
                break;

            case IDM_UPSTREAMORDER:
                TestUpstream();
                break;

            case IDM_RECONNECT:
                TestReconnect();
                break;

            case IDM_CONNECTIN:
                TestConnectInGraph();
                break;

            case IDM_CONNECTREG:
                TestConnectUsingReg();
                break;

            case IDM_PLAY:
                TestPlay();
                break;

            case IDM_NULLCLOCK:
                TestNullClock();
                break;

            case IDM_STOP:

                break;

            case IDM_PAUSE:

                break;

            case IDM_RUN:

                break;
        }

        HANDLE hFile;
        hFile = CreateFile("Perf.log", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
        MSR_DUMP(hFile);     // to file
    //  Msr_Dump(NULL);      // to debugger
        CloseHandle(hFile);
        break;
    }

    return DefWindowProcA (hWnd, msg, wParam, lParam);
}


#pragma warning(disable: 4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\test\qcmd.cpp ===
//
// implementation of IQueueCommand app helper classes

#include <streams.h>
#include "qcmd.h"



CQueueCommand::CQueueCommand(IQueueCommand* pQ)
  : m_pQCmd(pQ)
{
    m_pQCmd->AddRef();
}

CQueueCommand::~CQueueCommand()
{
    if (m_pQCmd) {
        m_pQCmd->Release();
    }
}


HRESULT
CQueueCommand::GetTypeInfo(REFIID riid, ITypeInfo** pptinfo)
{
    HRESULT hr;

    *pptinfo = NULL;

    if (NULL == pptinfo) {
        return E_POINTER;
    }


    // always look for v 1.0, neutral lcid

    ITypeLib *ptlib;
    hr = LoadRegTypeLib(LIBID_QuartzTypeLib, 1, 0, 0, &ptlib);
    if (FAILED(hr)) {
        return hr;
    }

    ITypeInfo *pti;
    hr = ptlib->GetTypeInfoOfGuid(
                riid,
                &pti);

    ptlib->Release();

    if (FAILED(hr)) {
        return hr;
    }

    *pptinfo = pti;
    return S_OK;

}

HRESULT
CQueueCommand::InvokeAt(
            BOOL bStream,
            REFTIME time,
            WCHAR* pMethodName,
            REFIID riid,
            short wFlags,
            long cArgs,
            VARIANT* pDispParams,
            VARIANT* pvarResult
            )
{
    if (!m_pQCmd) {
        return E_NOTIMPL;
    }

    // first convert method to id
    long dispid;
    ITypeInfo* pti;
    HRESULT hr = GetTypeInfo(riid, &pti);
    if (FAILED(hr)) {
        return hr;
    }

    hr = pti->GetIDsOfNames(
            &pMethodName,
            1,
            &dispid);

    pti->Release();

    if (FAILED(hr)) {
        return hr;
    }

    // now queue the command
    IDeferredCommand* pCmd;
    short uArgErr;
    if (bStream) {
        hr = m_pQCmd->InvokeAtStreamTime(
                    &pCmd,
                    time,
                    (struct _GUID*)&riid,
                    dispid,
                    wFlags,
                    cArgs,
                    pDispParams,
                    pvarResult,
                    &uArgErr);
    } else {
        hr = m_pQCmd->InvokeAtPresentationTime(
                    &pCmd,
                    time,
                    (struct _GUID*)&riid,
                    dispid,
                    wFlags,
                    cArgs,
                    pDispParams,
                    pvarResult,
                    &uArgErr);
    }

    if (SUCCEEDED(hr)) {

        // we don't need the pCmd
        pCmd->Release();
    }

    return hr;
}
#pragma warning(disable: 4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\ourcrt\cruntime.inc ===
;***
;cruntime.inc - multi-model assembly macros for interfacing to HLLs
;
;       Copyright (c) 1996 - 1996  Microsoft Corporation.  All Rights Reserved.
;
;Purpose:
;       This file defines the current memory model being used.
;
;*******************************************************************************

;==============================================================================
;
;Use the following defines to control processor/segment model
;
;   -DI86               8086/8088 processor
;   -DI286              80286 processor
;   -DI386              80386 processor with 32-bit code/data segment
;
;   -Dmem_S             Small memory model   (near code, near data)
;   -Dmem_M             Medium memory model  (far code, near data)
;   -Dmem_C             Compact memory model (near code, fat data)
;   -Dmem_L             Large memory model   (far code, far data)
;
;   -DSS_NEQ_DGROUP     SS and DS point to different segments
;
;   default is -DI86 -Dmem_S
;
;==============================================================================
;
;The following variables are defined by this file:
;   cpu                         86, 286, or 386
;   sizeC                       code distance; 1 = far code, 0 = near code
;   sizeD                       data distance; 1 = far data, 0 = near data
;   mmodel                      english name of the memory model, i.e. "Medium"
;   ISIZE, LSIZE, NSIZE         size of ints, longs, shorts
;   FLTSIZE, DBLSIZE, LDBLSIZE  size of float, double, long double
;   NPSIZE, FPSIZE              size of near/far pointers
;   CPSIZE, DPSIZE              size of code/data pointers
;   ISHIFT, LSHIFT              bits to shift to convert byte to int/long
;
;The following macros allow easy writing of combined 16/32 bit code:
;
; 16/32 bit registers:
;   rax, rbx, rcx, rdx,         expand to native registers (rax = eax or ax)
;   rsi, rdi, rsp, rbp
; 16/32 bit register instructions:
;   JRCXZ                       jump when rcx is zero
;   CBI                         convert byte to int (al to rax)
;   CAXDX                       convert rax to rax:rdx
;   ZXAL, ZXBL, ZXCL, ZXDL      zero extend al,bl,cl,dl to rax,rbx,rcx,rdx
; Pointer instructions:
;   LPDS, LPES                  load data pointer with ES or DS
;   PDS, PES                    segment overrides when pointer loaded as above
;   PCS, PSS                    segment override to get at code/stack segment
;   LFPDS, LFPES                load far pointer with ES or DS
;   FPDS, FPES                  segment overrides when pointer loaded as above
;   CPTR                        data type of code pointer
;   CPDIST                      distance of code (near/far)
;   DNPTR, DFPTR                define near/far pointer
;   DCPTR, DDPTR                define code/data pointer
;   DCPTR?, DDPTR?              define uninitialized code/data pointer
;   CPWORD, DPWORD              data type of code or data pointer
; Numeric type instructions:
;   IWORD, LWORD, SWORD         data type of int, long, short
;   DINT, DLONG, DSHORT         define int, long, short
;   DFLOAT, DDOUBLE, DLDOUBLE   define float, double, long double
; Offsets:
;   codeoffset, dataoffset      offsets from code and data segments
; API calls:
;   APIDIST                     distance of API calls (near/far)
;   APIEXT ApiName              extrn declaration for an API function
;
;The following utility macros are provided:
;   codeseg                     define/declare code segment
;   error <msg>                 stop assembly with message
;   display <msg>               display a message, unless QUIET defined
;   savelist [<reg> ...]        init list of regs to be save by 'proc uses'
;   _if cond <instruction>      assemble instruction only if cond is TRUE
;   _ife cond <instruction>     assemble instruction only if cond is FALSE
;   _ifd symbol <instruction>   assemble instruction only if symbol defined
;   _ifnd symbol <instruction>  assemble instruction only if symbol not defined
;
;   lab  LabelName              assembles to "LabelName:" If DEBUG is defined
;                               LabelName is made public
;
;   JS* (ex. JSE,JSZ,JSB ...)   assemble to "je short","jz short","jb short"
;
;   Cmacro look alikes
;   static* Name, InitialValue, Repeat   defines a static variable of type *
;   global* Name, InitialValue, Repeat   defines a global variable of type *
;   label*  Name, {PUBLIC,PASCAL,C}      defines a label of type *
;
;   PUSH16  SegmentReg          pushes 16 bits in a use32 segment
;   JMPFAR16  label             will do a far 16:16 jmp from a use32 segment
;
;==============================================================================

; error <msg>   -    Output message and generate error

error   MACRO   msg
if2                     ;; only on pass 2 can we generate errors
        %out    **********************************************************
        %out    *** E r r o r  --  msg
        %out    **********************************************************
        .err
endif
        ENDM

; display msg   -    Output message unless QUIET defined

display MACRO   msg
ifndef QUIET            ;; only when quiet flag not set
if1                     ;; and on pass 1, then display message
        %out msg
endif
endif
        ENDM

; One line conditionals:
;   here we create the capability of writing code lines like
;
; _if sizeD   <push ds>   as opposed to    if sizeD
;                                              push  ds
;                                          endif

_if     MACRO   cond,text
    if  cond
        text
    endif
        ENDM

_ife    MACRO   cond,text
    ife cond
        text
    endif
        ENDM

_ifd    MACRO   cond,text
    ifdef   cond
        text
    endif
        ENDM

_ifnd   MACRO   cond,text
    ifndef  cond
        text
    endif
        ENDM

; set windows flag to 0

        ?WIN    equ     0       ; disable windows-specific code

; check for _MT, requires 286 or greater processor

ifdef _MT
ifndef I386
ifndef I286
; _MT implies 286 processor
display <Multi-thread specified - assuming 80286 processor>
I286 equ <>
endif
endif
endif

; Process memory-model arguments

ifdef  mem_M
        ; Medium model
        sizeC   equ     1
        sizeD   equ     0
        mmodel  equ     <Medium>
elseifdef  mem_C
        ; Compact model
        sizeC   equ     0
        sizeD   equ     1
        mmodel  equ     <Compact>
elseifdef  mem_L
        ; Large model
        sizeC   equ     1
        sizeD   equ     1
        mmodel  equ     <Large>
else
        ; Small model - default
        sizeC   equ     0
        sizeD   equ     0
        mmodel  equ     <Small>
endif

; Process processor arguments

ifdef   _WIN32
        display <Processor:             486/586>
        cpu equ 586
        .586
elseifdef   I286
        display <Processor:             80286>
        cpu equ 286
        .286
elseifdef   I386
        display <Processor:             80386>
        cpu equ 386
        .386
else
        display <Processor:             8086/8088>
        cpu equ 86
        .8086
endif

;  386 32-bit checking.  Currently we are only expecting small model
;  32 bit segments, so we make a few checks to be sure nothing is
;  incorrectly being defined.

ifdef I386
    if sizeC or sizeD
        error <Must use Small memory model for 386 version.>
    endif

    ifdef _LOAD_DGROUP
        error <No loading DGROUP in 386 version.>
    endif

    ifdef SS_NEQ_DGROUP
        error <SS always equals DGROUP in 386 version.>
    endif
endif

;  Set memory model

%       display <Memory model:          mmodel>
%       .model  mmodel, C

;
; *** Temporary Workaround ***
; Currently, MASM will not recognize the 'FLAT' keyword unless it previously
; appears in an 'assume' statement.  Presumably, when the '.model FLAT' feature
; is implemented, this will go away.  [Use 'gs:' since we never use that
; segment register.
;

ifdef   I386
        ; ensure that MASM recognizes 'FLAT'
        assume  gs:FLAT
endif


; Define registers:
; Instead of using the "word" registers directly, we will use a set of
; text equates.  This will allow you to use the native word size instead of
; hard coded to 16 bit words.  We also have some instruction equates for
; instruction with the register type hard coded in.

ifdef I386

    rax equ <eax>
    rbx equ <ebx>
    rcx equ <ecx>
    rdx equ <edx>
    rdi equ <edi>
    rsi equ <esi>
    rbp equ <ebp>
    rsp equ <esp>

    JRCXZ equ <jecxz>
    CBI   equ <movsx eax, al>    ; convert byte to int (al to rax)
    CAXDX equ <cdq>              ; convert rax to rdx:rax
    ZXAL  equ <movzx eax, al>    ; zero extend al
    ZXBL  equ <movzx ebx, bl>    ; zero extend bl
    ZXCL  equ <movzx ecx, cl>    ; zero extend cl
    ZXDL  equ <movzx edx, dl>    ; zero extend dl

else

    rax equ <ax>
    rbx equ <bx>
    rcx equ <cx>
    rdx equ <dx>
    rdi equ <di>
    rsi equ <si>
    rbp equ <bp>
    rsp equ <sp>

    JRCXZ equ <jcxz>
    CBI   equ <cbw>              ; convert byte to int (al to rax)
    CAXDX equ <cwd>              ; convert rax to rdx:rax
    ZXAL  equ <xor ah, ah>       ; zero extend al
    ZXBL  equ <xor bh, bh>       ; zero extend bl
    ZXCL  equ <xor ch, ch>       ; zero extend cl
    ZXDL  equ <xor dh, dh>       ; zero extend dl

endif

; The following equates deal with the differences in near versus
; far data pointers, and segment overrides.
;
; Use LPES and PES when loading a default size pointer -- it loads
; a 16-bit pointer register in 286 Small/Medium model,
; a 16-bit pointer register and 16-bit segment register in 8086/286
; Compact/Large model, and a 32-bit pointer register in 386 mode.
;
; Use LFPES and FPES when loading an always far pointer -- it loads a
; 16-bit pointer register and 16-bit segment register in 8086/286,
; all models; a 32-bit pointer register in 386 mode.

if sizeD
    LPES equ <les>
    LPDS equ <lds>
    PDS  equ <ds:>
    PES  equ <es:>
else
    LPES equ <mov>
    LPDS equ <mov>
    PDS  equ <>
    PES  equ <>
endif

ifdef I386
    LFPES equ <mov>
    LFPDS equ <mov>
    FPES equ <>
    FPDS equ <>
else
    LFPES equ <les>
    LFPDS equ <lds>
    FPES equ <es:>
    FPDS equ <ds:>
endif

if sizeC or @WordSize eq 2
    PCS  equ <cs:>              ; large code model or non-386
else
 IF 1   ;*** TEMP 16/32 TESTBED ***
    PCS  equ <cs:>
 ELSE
    PCS  equ <>                 ; 386 small code model
 ENDIF  ;*** END TEMP CODE
endif

ifdef SS_NEQ_DGROUP
    PSS   equ <ss:>             ; SS != DS
else
    PSS   equ <>                ; SS == DS
endif

; Define offset macros:
;   The 32-bit segments will not have 'groups'

ifdef I386
    codeoffset  equ <offset FLAT:>
    dataoffset  equ <offset FLAT:>
else
    codeoffset  equ <offset @code:>
    dataoffset  equ <offset DGROUP:>
endif

; The next set of equates deals with the size of SHORTS, INTS, LONGS, and
; pointers in the 16 and 32 bit versions.

ifdef I386       ;--- 32 bit segment ---

    ; parameters and locals
    IWORD   equ <dword>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dd>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc.
    ISIZE   equ 4
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 4
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 2               ; byte-to-int shift count
    LSHIFT  equ 2               ; byte-to-long shift count

    ; sizes dependent upon memory model.  dq -vs- df is not yet clear
    DNPTR equ <dd>              ; near pointer
    DFPTR equ <dd>              ; far pointer

    DCPTR   equ <dd offset FLAT:>; 32 bit offset only
    DCPTR?  equ <dd>            ; No seg override for uninitialized values
    CPSIZE  equ 4
    CPDIST  equ <near>          ; code pointers are near
    CPTR    equ <near ptr>

    DDPTR   equ <dd offset FLAT:>
    DDPTR?  equ <dd>
    DPSIZE  equ 4

    CPWORD  equ <dword>         ; code pointers are dwords
    DPWORD  equ <dword>         ; data pointers are dwords

    APIDIST equ <near>          ; all API calls are NEAR in the 32 bit model

; macro to declare API functions
EXTAPI  macro   apiname
        extrn pascal apiname:near
endm

else    ;--- 16-bit segment ---

    ; parameters and locals
    IWORD   equ <word>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dw>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc
    ISIZE   equ 2
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 2
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 1               ; byte-to-int shift count
    LSHIFT  equ 2               ; byte-to-long shift count

    ; sizes dependent upon memory model
    DNPTR equ <dw>              ; near pointer
    DFPTR equ <dd>              ; far pointer

    if sizeC
        DCPTR   equ <dd>       ; 16 bit segment and 16 bit offset
        DCPTR?  equ <dd>
        CPSIZE  equ 4
        CPDIST  equ <far>      ; code pointers are far
        CPTR    equ <far ptr>
        CPWORD  equ <dword>    ; code pointers are dwords
    else
        DCPTR   equ <dw>       ; 16 bit offset only
        DCPTR?  equ <dw>
        CPSIZE  equ 2
        CPDIST  equ <near>     ; code pointers are near
        CPTR    equ <near ptr>
        CPWORD  equ <word>     ; code pointers are words
    endif

    if sizeD
        DDPTR   equ <dd>
        DDPTR?  equ <dd>
        DPSIZE  equ 4
        DPWORD  equ <dword>    ; data pointers are dwords
    else
        DDPTR   equ <dw>
        DDPTR?  equ <dw>
        DPSIZE  equ 2
        DPWORD  equ <word>     ; data pointers are words
    endif

    APIDIST equ <far>           ; API calls are FAR in 16 bit model

; macro to declare API functions
EXTAPI  macro   apiname
        extrn pascal apiname:far
endm

endif   ; --- 16/32 segment ---

; Float/double definitions
; (currently the same for 16- and 32-bit segments)

FLTSIZE  equ    4       ; float
DBLSIZE  equ    8       ; double
LDBLSIZE equ    10      ; long double

DFLOAT   equ    <dd>
DDOUBLE  equ    <dq>
DLDOUBLE equ    <dt>

;
; savelist - Generate a list of regs to be saved by the proc 'uses' option.
;
; Input:
;       reg1, reg2, reg3, reg4 = registers to be saved across function
; Output:
;       reglist = text string of registers that can be passed to the 'uses'
;       option on the 'proc' command.
;

savelist  MACRO   reg1, reg2, reg3, reg4
        local   ws, listsize
        ws      catstr  < >             ; whitespace char

        IFNDEF  I386
         rbx equ <>                     ; 8086/286 don't save rbx
        ENDIF

        IFNB        <reg4>
         reglist     catstr  reg1, ws, reg2, ws, reg3, ws, reg4
        ELSEIFNB    <reg3>
         reglist     catstr  reg1, ws, reg2, ws, reg3, ws
        ELSEIFNB    <reg2>
         reglist     catstr  reg1, ws, reg2, ws,       ws
        ELSEIFNB    <reg1>
         reglist     catstr  reg1, ws,       ws,       ws
        ELSE
         reglist     catstr  <>
        ENDIF

        listsize sizestr reglist        ; size of register list

        IF      listsize LE 3           ; if list is only the 3 ws chars...
         reglist catstr  <>
        ENDIF

        IFNDEF  I386
         rbx equ <bx>                   ; restore rbx
        ENDIF

        ENDM    ; savelist

;
; codeseg - Define/declare the standard code segment. Maps to the proper
; form of the .code directive.
;
; Input:
;
; Output:
;       .code _TEXT     ; for large code models
;       .code           ; for small code models
;       assume  cs:FLAT ; for 386
;       assume  ds:FLAT ; for 386
;       assume  es:FLAT ; for 386
;       assume  ss:FLAT ; for 386
;

codeseg MACRO

if      sizeC
        .code _TEXT
else
        .code
endif

ifdef   I386
        assume  ds:FLAT
        assume  es:FLAT
        assume  ss:FLAT
endif

        ENDM

;*========
;*
;*  Debug lab macro
;*
;*========

lab     macro name
ifdef   DEBUG
    public  pascal name     ;; define label public for Symdeb
endif
name:
        endm


;*========
;*
;*  Conditional jump short macros
;*
;*========


        irp     x,<Z,NZ,E,NE,S,NS,C,NC,P,NP,PE,PO,A,AE,B,BE,NB,G,GE,L,LE>
JS&x    equ   <j&x short>
        endm


;*========
;*
;*  Global data definition macros
;*
;*  Usage:
;*      globalI   Name, InitialValue, Repeat
;*
;*========


MakeGlobal  macro   suffix, DataType        ;; makes all of the global* macros

global&suffix  macro   name, data, rep
public  name
ifb     <rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name    &DataType  _repeat dup( data )
        endm

        endm


    MakeGlobal  T, dt                   ; globalT
    MakeGlobal  Q, dq                   ; globalQ
    MakeGlobal  D, dd                   ; globalD
    MakeGlobal  W, dw                   ; globalW
    MakeGlobal  B, db                   ; globalB

%   MakeGlobal  I, <DINT>               ; globalI

%   MakeGlobal  DP, <DDPTR>             ; globalDP
%   MakeGlobal  CP, <DCPTR>             ; globalCP
%   MakeGlobal  FP, <DFPTR>             ; globalFP
%   MakeGlobal  NP, <DNPTR>             ; globalNP



;*========
;*
;*  Static data definition macros
;*
;*  Usage:
;*      staticI   Name, InitialValue, Repeat
;*
;*========


MakeStatic  macro   suffix, DataType        ;; makes all of the static* macros

static&suffix  macro   name, data, rep

ifdef  DEBUG
    public  pascal name                     ;; make statics public if DEBUG
endif

ifb     <rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name    &DataType  _repeat dup( data )
        endm

        endm


    MakeStatic  T, dt                   ; staticT
    MakeStatic  Q, dq                   ; staticQ
    MakeStatic  D, dd                   ; staticD
    MakeStatic  W, dw                   ; staticW
    MakeStatic  B, db                   ; staticB

%   MakeStatic  I, <DINT>               ; staticI

%   MakeStatic  DP, <DDPTR>             ; staticDP
%   MakeStatic  CP, <DCPTR>             ; staticCP
%   MakeStatic  FP, <DFPTR>             ; staticFP
%   MakeStatic  NP, <DNPTR>             ; staticNP

;*========
;*
;*  Label definition macros
;*
;*========
;*
;*  Label definition macros
;*
;*  Usage:
;*      labelI   Name, {PUBLIC, PASCAL, C}
;*
;*========

__MakePublic    macro   name, option    ;; decides if a label should be
ifidni  <option>, <PUBLIC>              ;; made public
    public  name
elseifidni  <option>, <PASCAL>
    public  pascal name
elseifidni  <option>, <C>
    public  C name
elseifb  <option>
    ifdef  DEBUG
        public  pascal name     ;; make public if DEBUG
    endif
endif
                endm


MakeLabel   macro suffix, LabelType     ;; makes all of the label* macros

%@CatStr(<label>,<suffix>)      macro   name, option
        __MakePublic    <name>,<option>
name    label   &LabelType
        endm

        endm


        MakeLabel   T, tbyte    ; make labelT
        MakeLabel   Q, qword    ; make labelQ
        MakeLabel   D, dword    ; make labelD
        MakeLabel   W, word     ; make labelW
        MakeLabel   B, byte     ; make labelB

        MakeLabel   P, proc     ; make labelP
        MakeLabel   FP, far     ; make labelFP
        MakeLabel   NP, near    ; make labelNP

%       MakeLabel   I, IWORD    ; make labelI


labelDP macro   name, option                ;; labelDP
        __MakePublic    <name>,<option>
ifdef  I386
    if sizeD
        name    label   fword
    else
        name    label   dword
    endif
else    ;not I386
    if sizeD
        name    label   dword
    else
        name    label   word
    endif
endif   ;not I386
        endm

labelCP macro   name, option                ;; labelCP
        __MakePublic    <name>,<option>
ifdef  I386
    if sizeC
        name    label   fword
    else
        name    label   dword
    endif
else    ;not I386
    if sizeC
        name    label   dword
    else
        name    label   word
    endif
endif   ;not I386
        endm


;*
;*  PUSH16 SegReg   - pushes 16 bits in a use32 segment
;*

PUSH16  macro   SegReg

ifdef I386
        nop
        db      66h         ; operand size over-ride
endif   ; I386

        push    SegReg
        endm


;*
;*  JMPFAR16  label - jmps far from a use32 to a use16 segment
;*

JMPFAR16 macro  label

ifndef I386
        error  <JMPFAR16 can only be used in a use32 code segment>
endif   ;I386

        nop
        db      66h         ;; operand size over-ride
        db      0eah        ;; jmp far immediate op code
        dw      offset label
        dw      seg label
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\test\makefile.inc ===
# NOTE:
# this directory contains a makefile which contains a single line that
# includes the global build process makefile.def. If the
# NTTARGETFILE1 or NTTARGETFILE0 environment
# variable is set then makefile.def includes makefile.inc from the current
# directory. This makefile.inc creates an extra target for nmake to create
# when it is run. NTTARGETFILE0 is built before everything else, and
# NTTARGETFILE1 is built after everything else.

copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).exe  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).exe     \
         $(TESTDIR)\bin\$(TARGET_DIRECTORY)\*.*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\filgraph\test\qcmd.h ===
//
// helper classes for apps that use IQueueCommand
//


// this class is a variant with some methods to get and set the values in
// a safe and easy way

class CVariant : public VARIANT
{

public:
    // init to VT_EMPTY
    inline CVariant();
    inline ~CVariant();

    // releases BSTR types
    inline void FreeResource();

    // set types and values together by assignment type
    // some types need a cast to disambiguate

    inline CVariant& operator=(const BYTE b);
    inline CVariant& operator=(const long l);
    inline CVariant& operator=(const short s);
    inline CVariant& operator=(const float f);
    inline CVariant& operator=(const double d);

    // all these make a bstr (copy)
    // WCHAR* is the same as BSTR
    inline CVariant& operator=(const WCHAR *);


    // get and set BOOL explicitly
    inline void SetBOOL(BOOL b);
    inline BOOL GetBOOL();

    // get type
    VARTYPE Type() {
        return vt;
    };

    // get the value by a cast:
    inline operator BYTE() const;
    inline operator short() const;
    inline operator long() const;
    inline operator float() const;
    inline operator double() const;
    inline operator WCHAR*() const;

};


// this class will convert the method string to a dispid before calling
// the queue command
class CQueueCommand
{
    IQueueCommand* m_pQCmd;

    HRESULT GetTypeInfo(REFIID iid, ITypeInfo** ppti);

public:
    // pass it the IQueueCommand interface at construction
    // we addref it and keep it until destruction
    CQueueCommand(IQueueCommand*);
    ~CQueueCommand();

    HRESULT InvokeAt(
                BOOL bStream,
                REFTIME time,
                WCHAR* pMethodName,
                REFIID riid,
                short wFlags,
                long cArgs,
                VARIANT* pDispParams,
                VARIANT* pvarResult
                );
};






// --- inline functions ----------------------------


CVariant::CVariant()
{
    VariantInit(this);
}

CVariant::~CVariant()
{
    FreeResource();
}

void
CVariant::FreeResource()
{
    // only resource is a BSTR
    if (vt == VT_BSTR) {
        SysFreeString(bstrVal);
    }
}


CVariant& CVariant::operator=(const BYTE b)
{
    FreeResource();

    vt = VT_UI1;
    bVal = b;

    return *this;
};


CVariant& CVariant::operator=(const long l)
{
    FreeResource();

    vt = VT_I4;
    lVal = l;

    return *this;
};

CVariant& CVariant::operator=(const short s)
{
    FreeResource();

    vt = VT_I2;
    iVal = s;

    return *this;
};

CVariant& CVariant::operator=(const float f)
{
    FreeResource();

    vt = VT_R4;
    fltVal = f;

    return *this;
};

CVariant& CVariant::operator=(const double d)
{
    FreeResource();

    vt = VT_R8;
    dblVal = d;

    return *this;
};

CVariant& CVariant::operator=(const WCHAR* str)
{
    FreeResource();

    vt = VT_BSTR;

    bstrVal = SysAllocString(str);

    return *this;
};

void
CVariant::SetBOOL(BOOL b)
{
    FreeResource();

    vt = VT_BOOL;
    boolVal = b;
}

BOOL
CVariant::GetBOOL()
{
    ASSERT(vt == VT_BOOL);

    return boolVal;
}

CVariant::operator BYTE() const
{
    ASSERT(vt == VT_UI1);
    return bVal;
}

CVariant::operator short() const
{
    ASSERT(vt == VT_I2);
    return iVal;
}

CVariant::operator long() const
{
    ASSERT(vt == VT_I4);
    return lVal;
}

CVariant::operator float() const
{
    ASSERT(vt == VT_R4);
    return fltVal;
}

CVariant::operator double() const
{
    ASSERT(vt == VT_R8);
    return dblVal;
}

CVariant::operator WCHAR*() const
{
    ASSERT(vt == VT_BSTR);
    return bstrVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\ourcrt\ourcrt.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>

#ifndef USE_MSVCRT_IMPL
extern "C" const int _fltused = 0;
#endif

void * _cdecl operator new(size_t size)
{
    void * pv;
    pv = (void *)LocalAlloc(LMEM_FIXED, size);
    DbgLog((LOG_MEMORY, 4, TEXT("Allocating: %lx = %d"), pv, size));

    return pv;
}
void _cdecl operator delete(void *ptr)
{
    DbgLog((LOG_MEMORY, 4, TEXT("Freeing: %lx"), ptr));
    if (ptr)
	LocalFree(ptr);
}

/*
 * This function serves to avoid linking CRT code
 */

int __cdecl  _purecall(void)
{
#ifdef DEBUG
    DebugBreak();
#endif

    return(FALSE);
}

#if 0
#ifdef _X86_

// ---------------------------------------------------
//	asm_ftol()
// ---------------------------------------------------
extern "C" long __cdecl _ftol(float flX)
{
	long lResult;
	WORD wCW;
	WORD wNewCW;

	_asm
	{
		fld       flX			// Push the float onto the stack
		wait
		fnstcw    wCW			// Store the control word
		wait
		mov       ax,wCW		// Setup our rounding
		or        ah,0x0c
		mov       wNewCW,ax
		fldcw     wNewCW		// Set Control word to our new value
		fistp     lResult		// Round off top of stack into result
		fldcw     wCW			// Restore control word
		fnclex					// clear the status word of exceptions
	}

	return(lResult);
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\smarttee\smarttee.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __SMARTTEE__
#define __SMARTTEE__

extern const AMOVIESETUP_FILTER sudSmartTee;

class CSmartTee;
class CSmartTeeOutputPin;
class CMyOutputQueue;

// class for the Tee filter's Input pin

class CSmartTeeInputPin : public CBaseInputPin
{
    friend class CSmartTeeOutputPin;
    CSmartTee *m_pTee;                  // Main filter object

public:

    // Constructor and destructor
    CSmartTeeInputPin(TCHAR *pObjName,
                 CSmartTee *pTee,
                 HRESULT *phr,
                 LPCWSTR pPinName);

#ifdef DEBUG
    ~CSmartTeeInputPin();
#endif

    // Used to check the input pin connection
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT BreakConnect();
    HRESULT Active();

    // Reconnect outputs if necessary at end of completion
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly);

    // Pass through calls downstream
    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    // how many frames in a row were not sent out the preview pin
    int m_nFramesSkipped;

    int m_cBuffers;	    // number of buffers in allocator
    int m_cbBuffer;	    // size of the allocator buffers
    int m_nMaxPreview;      // The number of samples in the preview pipe
                            // must be at most this value for us to 
                            // queue another one. 
    CCritSec m_csReceive;

};


// Class for the Tee filter's Output pins.

class CSmartTeeOutputPin : public CBaseOutputPin, public CBaseStreamControl
{
    friend class CSmartTeeInputPin;
    friend class CSmartTee;

    CSmartTee *m_pTee;                  // Main filter object pointer
    CMyOutputQueue *m_pOutputQueue;  // Streams data to the peer pin
    BOOL m_bIsPreview;             // TRUE if Preview pin

    BOOL m_fLastSampleDiscarded;   // after discarding, next sample is discont

public:

    // Constructor and destructor

    CSmartTeeOutputPin(TCHAR *pObjName,
                   CSmartTee *pTee,
                   HRESULT *phr,
                   LPCWSTR pPinName,
                   INT PinNumber);

#ifdef DEBUG
    ~CSmartTeeOutputPin();
#endif

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    DECLARE_IUNKNOWN


    // Override to enumerate media types
    STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);

    // Check that we can support an output type
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition,
                         CMediaType *pMediaType);

    // Negotiation to use our input pins allocator
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);
    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator,
                              ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Used to create output queue objects
    HRESULT Active();
    HRESULT Inactive();

    // Overriden to create and destroy output pins
    HRESULT CompleteConnect(IPin *pReceivePin);

    // Overriden to pass data to the output queues
    HRESULT Deliver(IMediaSample *pMediaSample);
    HRESULT DeliverEndOfStream();
    HRESULT DeliverBeginFlush();
    HRESULT DeliverEndFlush();
    HRESULT DeliverNewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);


    // Overriden to handle quality messages
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);
};


// Class for the Tee filter

class CSmartTee: public CCritSec, public CBaseFilter
{
    // Let the pins access our internal state
    friend class CSmartTeeInputPin;
    friend class CSmartTeeOutputPin;
    typedef CGenericList <CSmartTeeOutputPin> COutputList;

    // Declare an input pin.
    CSmartTeeInputPin m_Input;

    // And two output pins
    CSmartTeeOutputPin *m_Capture;
    CSmartTeeOutputPin *m_Preview;

    INT m_NumOutputPins;            // Current output pin count
    COutputList m_OutputPinsList;   // List of the output pins
    INT m_NextOutputPinNumber;      // Increases monotonically.
    IMemAllocator *m_pAllocator;    // Allocator from our input pin

public:

    CSmartTee(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CSmartTee();

    CBasePin *GetPin(int n);
    int GetPinCount();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    // Send EndOfStream if no input connection
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP Pause();
    STDMETHODIMP Stop();

    // override GetState to return VFW_S_CANT_CUE when pausing
    //
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

   // for IAMStreamControl
   STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
   STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

protected:

    // The following manage the list of output pins

    void InitOutputPinsList();
    CSmartTeeOutputPin *GetPinNFromList(int n);
    CSmartTeeOutputPin *CreateNextOutputPin(CSmartTee *pTee);
};


// overridden to get number of samples the thread has queued
//
class CMyOutputQueue: public COutputQueue
{

    friend class CSmartTeeOutputPin;

public:
    CMyOutputQueue(IPin    *pInputPin,          //  Pin to send stuff to
                 HRESULT   *phr,                //  'Return code'
                 BOOL       bAuto = TRUE,       //  Ask pin if blocks
                 BOOL       bQueue = TRUE,      //  Send through queue (ignored if
                                                //  bAuto set)
                 LONG       lBatchSize = 1,     //  Batch
                 BOOL       bBatchExact = FALSE,//  Batch exactly to BatchSize
                 LONG       lListSize =         //  Likely number in the list
                                DEFAULTCACHE,
                 DWORD      dwPriority =        //  Priority of thread to create
                                THREAD_PRIORITY_NORMAL
                );
    ~CMyOutputQueue();

    int GetThreadQueueSize();
    BOOL m_nOutstanding;	// # objects on queue not released yet
};


class CMyMediaSample: public CMediaSample
{
public:
    CMyMediaSample(
        TCHAR *pName,
        CBaseAllocator *pAllocator,
        CMyOutputQueue *pQ,
        HRESULT *phr,
        LPBYTE pBuffer = NULL,
        LONG length = 0);

    ~CMyMediaSample();

    STDMETHODIMP_(ULONG) Release();

    IMediaSample *m_pOwnerSample;
    CMyOutputQueue *m_pQueue;	// what queue gets these samples
};

#endif // __SMARTTEE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\smarttee\smarttee.cpp ===
//depot/private/lab06_multimedia/multimedia/DShow/filters/core/smarttee/smarttee.cpp#4 - edit change 19434 (text)
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "smarttee.h"
#include <tchar.h>
#include <stdio.h>

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Video,        // Major CLSID
    &MEDIASUBTYPE_NULL       // Minor type
};

const AMOVIESETUP_PIN psudPins[] =
{
    { L"Input",             // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      1,                    // Number of types
      &sudPinTypes },       // Pin information
    { L"Capture",           // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      1,                    // Number of types
      &sudPinTypes },       // Pin information
    { L"Preview",           // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      1,                    // Number of types
      &sudPinTypes }        // Pin information
};

const AMOVIESETUP_FILTER sudSmartTee =
{
    &CLSID_SmartTee,       // CLSID of filter
    L"Smart Tee",          // Filter's name
    MERIT_DO_NOT_USE,       // Filter merit
    3,                      // Number of pins
    psudPins                // Pin information
};

#ifdef FILTER_DLL
//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
CFactoryTemplate g_Templates[] = 
{
    // --- Smart Capture Tee ---
    {L"Smart Tee",                         &CLSID_SmartTee,
        CSmartTee::CreateInstance, NULL, &sudSmartTee }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

// Using this pointer in constructor
#pragma warning(disable:4355)

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CSmartTee::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CSmartTee(NAME("Smart Tee Filter"), pUnk, phr);
}


// ================================================================
// CSmartTee Constructor
// ================================================================

CSmartTee::CSmartTee(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    m_OutputPinsList(NAME("Tee Output Pins list")),
    m_pAllocator(NULL),
    m_NumOutputPins(0),
    m_NextOutputPinNumber(0),
    m_Input(NAME("Input Pin"), this, phr, L"Input"),
    CBaseFilter(NAME("Smart Tee filter"), pUnk, this, CLSID_SmartTee)
{
    ASSERT(phr);

    // Create a single output pin at this time
    InitOutputPinsList();

    // Create the capture pin
    CSmartTeeOutputPin *pOutputPin = CreateNextOutputPin(this);
    if (pOutputPin != NULL )
    {
        m_NumOutputPins++;
        m_OutputPinsList.AddTail(pOutputPin);
        m_Capture = pOutputPin;
    }

    // Create the preview pin
    pOutputPin = CreateNextOutputPin(this);
    if (pOutputPin != NULL )
    {
        m_NumOutputPins++;
        m_OutputPinsList.AddTail(pOutputPin);
        m_Preview = pOutputPin;
    }
}


//
// Destructor
//
CSmartTee::~CSmartTee()
{
    InitOutputPinsList();
}


// tell the stream control stuff what clock to use
STDMETHODIMP CSmartTee::SetSyncSource(IReferenceClock *pClock)
{
    int n = m_NumOutputPins;
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
	pOutputPin->SetSyncSource(pClock);
        n--;
    }
    return CBaseFilter::SetSyncSource(pClock);
}


// tell the stream control stuff what sink to use
STDMETHODIMP CSmartTee::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    DbgLog((LOG_TRACE,1,TEXT("CSmartTee::JoinFilterGraph")));

    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);

    int n = m_NumOutputPins;
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
	pOutputPin->SetFilterGraph(m_pSink);
        n--;
    }
    return hr;
}

//
// If both output pins are connected to renderers, the preview pin will run
// as fast as the source can push (no time stamps) but the capture pin will
// only go as fast as the playback of the file is supposed to be.  Thus, 
// all buffers between us and the upstream filter are probably outstanding.
// Then when you go from RUN->PAUSE, the preview renderer will insist on 
// seeing another frame before pausing, which the upstream filter won't be
// able to send because all buffers are outstanding by the capture pin, which
// is blocked delivering to the renderer and can't free any.
// So we have to declare ourselves a "live graph" to avoid hanging when we are
// in the graph.  We do this by returning VFW_S_CANT_CUE in pause mode.
//
STDMETHODIMP CSmartTee::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    if (m_State == State_Paused) {
        //DbgLog((LOG_TRACE,1,TEXT("*** Cant cue!")));
	return VFW_S_CANT_CUE;
    } else {
        return S_OK;
    }
}



//
// GetPinCount
//
int CSmartTee::GetPinCount()
{
    return (1 + m_NumOutputPins);
}


//
// GetPin
//
CBasePin *CSmartTee::GetPin(int n)
{
    if (n < 0)
        return NULL ;

    // Pin zero is the one and only input pin
    if (n == 0)
        return &m_Input;

    // return the output pin at position(n - 1) (zero based)
    return GetPinNFromList(n - 1);
}


//
// InitOutputPinsList
//
void CSmartTee::InitOutputPinsList()
{
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(pos)
    {
        CSmartTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
        ASSERT(pOutputPin->m_pOutputQueue == NULL);
        delete pOutputPin;
    }
    m_NumOutputPins = 0;
    m_OutputPinsList.RemoveAll();

} // InitOutputPinsList


//
// CreateNextOutputPin
//
CSmartTeeOutputPin *CSmartTee::CreateNextOutputPin(CSmartTee *pTee)
{
    WCHAR *szbuf;    
    m_NextOutputPinNumber++;     // Next number to use for pin
    HRESULT hr = NOERROR;

    szbuf = ((m_NextOutputPinNumber == 1) ?  L"Capture" : L"Preview");

    CSmartTeeOutputPin *pPin = new CSmartTeeOutputPin(NAME("Tee Output"), pTee,
					    &hr, szbuf,
					    m_NextOutputPinNumber);

    if (FAILED(hr) || pPin == NULL) {
        delete pPin;
        return NULL;
    }

    return pPin;

} // CreateNextOutputPin


//
// GetPinNFromList
//
CSmartTeeOutputPin *CSmartTee::GetPinNFromList(int n)
{
    // Validate the position being asked for
    if (n >= m_NumOutputPins)
        return NULL;

    // Get the head of the list
    POSITION pos = m_OutputPinsList.GetHeadPosition();

    n++;       // Make the number 1 based

    CSmartTeeOutputPin *pOutputPin;
    while(n) {
        pOutputPin = m_OutputPinsList.GetNext(pos);
        n--;
    }
    return pOutputPin;

} // GetPinNFromList


//
// Stop
//
// Overriden to give new state to stream control
//
STDMETHODIMP CSmartTee::Stop()
{
    CAutoLock cObjectLock(m_pLock);

    // this will unblock Receive, which may be blocked in CheckStreamState
    int n = m_NumOutputPins;
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
	pOutputPin->NotifyFilterState(State_Stopped, 0);
        n--;
    }

    // Now make sure Receive is not using m_pOutputQueue right now.
    CAutoLock lock_4(&m_Input.m_csReceive);

    // Input pins are stopped before the output pins, because GetPin returns
    // our input pin first.  This will ensure that 1) Receive is never called
    // again, and 2) finally m_pOutputQueue will be destroyed
    return CBaseFilter::Stop();
}

//
// Pause
//
// Overriden to handle no input connections
//
STDMETHODIMP CSmartTee::Pause()
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = CBaseFilter::Pause();
    if (m_Input.IsConnected() == FALSE) {
        m_Input.EndOfStream();
    }
    int n = m_NumOutputPins;
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
	pOutputPin->NotifyFilterState(State_Paused, 0);
        n--;
    }
    return hr;
}


//
// Run
//
// Overriden to handle no input connections
//
STDMETHODIMP CSmartTee::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = CBaseFilter::Run(tStart);
    if (m_Input.IsConnected() == FALSE) {
        m_Input.EndOfStream();
    }
    int n = m_NumOutputPins;
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
	pOutputPin->NotifyFilterState(State_Running, tStart);
        n--;
    }
    return hr;
}

// ================================================================
// CSmartTeeInputPin constructor
// ================================================================

CSmartTeeInputPin::CSmartTeeInputPin(TCHAR *pName,
                           CSmartTee *pTee,
                           HRESULT *phr,
                           LPCWSTR pPinName) :
    CBaseInputPin(pName, pTee, pTee, phr, pPinName),
    m_pTee(pTee),
    m_nMaxPreview(0)
{
    ASSERT(pTee);
}


#ifdef DEBUG
//
// CSmartTeeInputPin destructor
//
CSmartTeeInputPin::~CSmartTeeInputPin()
{
    //DbgLog((LOG_TRACE,2,TEXT("CSmartTeeInputPin destructor")));
    ASSERT(m_pTee->m_pAllocator == NULL);
}
#endif

//
// CheckMediaType
//
HRESULT CSmartTeeInputPin::CheckMediaType(const CMediaType *pmt)
{
    //DbgLog((LOG_TRACE,3,TEXT("Input::CheckMT %d bit"), HEADER(pmt->Format())->biBitCount));

    CAutoLock lock_it(m_pLock);

    HRESULT hr = NOERROR;

#ifdef DEBUG
    // Display the type of the media for debugging perposes
    //!!!DisplayMediaType(TEXT("Input Pin Checking"), pmt);
#endif

    // The media types that we can support are entirely dependent on the
    // downstream connections. If we have downstream connections, we should
    // check with them - walk through the list calling each output pin

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();

    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            if (pOutputPin->m_Connected != NULL) {
                // The pin is connected, check its peer
                hr = pOutputPin->m_Connected->QueryAccept(pmt);
                if (hr != NOERROR) {
    		    //DbgLog((LOG_TRACE,3,TEXT("NOT ACCEPTED!")));
                    return VFW_E_TYPE_NOT_ACCEPTED;
		}
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }

    // Either all the downstream pins have accepted or there are none.
    //DbgLog((LOG_TRACE,3,TEXT("ACCEPTED!")));
    return NOERROR;

} // CheckMediaType


//
// BreakConnect
//
HRESULT CSmartTeeInputPin::BreakConnect()
{
    //DbgLog((LOG_TRACE,3,TEXT("Input::BreakConnect")));

    // Release any allocator that we are holding
    if (m_pTee->m_pAllocator)
    {
        m_pTee->m_pAllocator->Release();
        m_pTee->m_pAllocator = NULL;
    }
    return NOERROR;

} // BreakConnect


//
// NotifyAllocator
//
STDMETHODIMP
CSmartTeeInputPin::NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly)
{
    CAutoLock lock_it(m_pLock);
    if (pAllocator == NULL)
        return E_FAIL;

    // Free the old allocator if any
    if (m_pTee->m_pAllocator)
        m_pTee->m_pAllocator->Release();

    // Store away the new allocator
    pAllocator->AddRef();
    m_pTee->m_pAllocator = pAllocator;

    ALLOCATOR_PROPERTIES prop;
    HRESULT hr = m_pTee->m_pAllocator->GetProperties(&prop);
    if (SUCCEEDED(hr)) {
        DbgLog((LOG_TRACE,2,TEXT("Allocator is using %d buffers, size %d"),
						prop.cBuffers, prop.cbBuffer));
	m_cBuffers = prop.cBuffers;
	m_cbBuffer = prop.cbBuffer;
    }

    // Notify the base class about the allocator
    return CBaseInputPin::NotifyAllocator(pAllocator,bReadOnly);

} // NotifyAllocator


//
// EndOfStream
//
HRESULT CSmartTeeInputPin::EndOfStream()
{
    // protect from m_pOutputQueue going away
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    //DbgLog((LOG_TRACE,3,TEXT("::EndOfStream")));

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->DeliverEndOfStream();
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return(NOERROR);

} // EndOfStream


//
// BeginFlush
//
HRESULT CSmartTeeInputPin::BeginFlush()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
	    pOutputPin->Flushing(TRUE);
            hr = pOutputPin->DeliverBeginFlush();
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return CBaseInputPin::BeginFlush();

} // BeginFlush


//
// EndFlush
//
HRESULT CSmartTeeInputPin::EndFlush()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
	    pOutputPin->Flushing(FALSE);
            hr = pOutputPin->DeliverEndFlush();
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return CBaseInputPin::EndFlush();

} // EndFlush

//
// NewSegment
//
                    
HRESULT CSmartTeeInputPin::NewSegment(REFERENCE_TIME tStart,
                                 REFERENCE_TIME tStop,
                                 double dRate)
{
    // protect from m_pOutputQueue going away
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->DeliverNewSegment(tStart, tStop, dRate);
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return CBaseInputPin::NewSegment(tStart, tStop, dRate);

} // NewSegment


//
// Receive
//
HRESULT CSmartTeeInputPin::Receive(IMediaSample *pSample)
{
    //DbgLog((LOG_TRACE,3,TEXT("SmartTee::Receive")));

    CAutoLock lock_it(&m_csReceive);
    int nQ = 0;

    // Check that all is well with the base class
    HRESULT hr = NOERROR;
    hr = CBaseInputPin::Receive(pSample);
    if (hr != NOERROR) {
        //DbgLog((LOG_TRACE,1,TEXT("Base class ERROR!")));
        return hr;
    }

    // Walk through the output pins list, delivering to the first pin (capture)
    // and only delivering to the preview pin if it won't affect capture
    // performance. Send at least every 30th frame !!!

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
	    if (n == m_pTee->m_NumOutputPins) {
                hr = pOutputPin->Deliver(pSample);
		if (pOutputPin->m_pOutputQueue)
		    nQ = pOutputPin->m_pOutputQueue->GetThreadQueueSize();
    		DbgLog((LOG_TRACE,3,TEXT("Delivered CAPTURE: Queued=%d"), nQ));
	        // This will prevent us from receiving any more data!
                if (hr != NOERROR) {
    		    DbgLog((LOG_ERROR,1,TEXT("ERROR: failing Receive")));
                    return hr;
		}
	    } else {
		// here's the deal.  It's only OK to send something to the
		// preview pin if it won't hurt capture.  IE: never send more
		// than one at a time, wait until there are no outstanding
		// samples on the queue before sending another one. Also, if
		// the capture queue is getting full, that's another good reason
		// not to send a preview frame.  But, we will at least send
		// every 30th frame.
		m_nFramesSkipped++;
		int nOK = m_cBuffers < 8 ? 1 :
			(m_cBuffers < 16 ? 2 : 4);
		BOOL fOK = FALSE;
		if (pOutputPin->m_pOutputQueue)
		    fOK = pOutputPin->m_pOutputQueue->m_nOutstanding <= m_nMaxPreview;
		if ((m_nFramesSkipped >= 30 || nQ <= nOK) && fOK) {
                    hr = pOutputPin->Deliver(pSample);
		    if (hr != NOERROR)
    		        DbgLog((LOG_ERROR,1,TEXT("ERROR: delivering PREVIEW")));
		    else {
    		        DbgLog((LOG_TRACE,3,TEXT("Delivered PREVIEW")));
			pOutputPin->m_pOutputQueue->m_nOutstanding++;
		    }
		    m_nFramesSkipped = 0;	// reset AFTER DELIVER!
		    // don't bother to flag an error and halt capture just 
		    // because something went wrong with preview
		}
#if 0
                // else
                // {
                //     m_nDropped++;
                // }
                // m_nTotal++;
#endif
	    }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }

    return NOERROR;

} // Receive


//
// Completed a connection to a pin
//
HRESULT CSmartTeeInputPin::CompleteConnect(IPin *pReceivePin)
{
    //DbgLog((LOG_TRACE,1,TEXT("TT Input::CompleteConnect")));

    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr)) {
        return hr;
    }

    // Force any output pins to use our type

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();

    while(n) {
        CSmartTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            // Check with downstream pin
            if (pOutputPin->m_Connected != NULL) {
                if (m_mt != pOutputPin->m_mt) {
    		    //DbgLog((LOG_TRACE,1,TEXT("IN Connected: RECONNECT OUT")));
                    m_pTee->ReconnectPin(pOutputPin, &m_mt);
		}
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return S_OK;
}

//
// Active
//
// This is called when we transition from stop to paused. The purpose of
// this routine is to set m_nMaxPreview once for all. m_nMaxPreview is
// used in CSmartTeeInputPin::Receive, which queues a sample to the 
// preview pin iff the #samples currently in the preview pipe is no
// more than m_nMaxPreview. For Win9x and NT 4, m_nMaxPreview == 0 
// has worked well. For Win2K, in dv scenarios where the Smart Tee is used
// to capture+preview from msdv, dv frames are dropped causing audio 
// stuttering even when cpu consumption is low (~30%). See Manbugs 42032.
// Setting m_nMaxPreview to 2 in this case is a hack to work around 
// the problem.
//
HRESULT CSmartTeeInputPin::Active()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr;

    hr = CBaseInputPin::Active();
    m_nMaxPreview = 0;

    if (!IsConnected())
    {
        return hr;
    }
    if (!IsEqualGUID(*m_mt.FormatType(), FORMAT_DvInfo))
    {
        return hr;
    }

    
#if 0
    // @@@ For tuning only
    // HKEY hk;
    // if (RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Debug\\qcap.dll"), &hk) == ERROR_SUCCESS)
    // {
    //    DWORD type;
    //    int value;
    //    DWORD len = sizeof(value);
        
    //    if (RegQueryValueEx(hk, TEXT("MaxPreview"), 0, &type, (LPBYTE) (&value), &len) == ERROR_SUCCESS &&
    //        type == REG_DWORD && len == sizeof(value))
    //    {
    //        m_nMaxPreview = value;
    //        RegCloseKey(hk);
    //        return hr;
    //    }
    //    RegCloseKey(hk);
    // }
    // End - for tuning only.
#endif

    if (g_osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&
        g_osInfo.dwMajorVersion >= 5)
    {
        // For Win2K and future NT OS only:
        // 2 works better than 1 on P3/600 w/ full or half decode.
        // With 1, frames are occasionally dropped.
        m_nMaxPreview = 2;
    }

    return hr;

} // Active


// ================================================================
// CSmartTeeOutputPin constructor
// ================================================================

CSmartTeeOutputPin::CSmartTeeOutputPin(TCHAR *pName,
                             CSmartTee *pTee,
                             HRESULT *phr,
                             LPCWSTR pPinName,
                             int PinNumber) :
    CBaseOutputPin(pName, pTee, pTee, phr, pPinName) ,
    m_pOutputQueue(NULL),
    m_pTee(pTee)
{
    ASSERT(pTee);

    // capture is 1, preview is 2
    m_bIsPreview = (PinNumber == 2);
}



#ifdef DEBUG
//
// CSmartTeeOutputPin destructor
//
CSmartTeeOutputPin::~CSmartTeeOutputPin()
{
    ASSERT(m_pOutputQueue == NULL);
}
#endif


//
// DecideBufferSize
//
// This has to be present to override the PURE virtual class base function
//
HRESULT CSmartTeeOutputPin::DecideBufferSize(IMemAllocator *pMemAllocator,
                                        ALLOCATOR_PROPERTIES * ppropInputRequest)
{
    return NOERROR;

} // DecideBufferSize


//
// DecideAllocator
//
HRESULT CSmartTeeOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    ASSERT(m_pTee->m_pAllocator != NULL);
    *ppAlloc = NULL;

    // Tell the pin about our allocator, set by the input pin.
    // We always say the samples are READONLY because the preview pin is sharing
    // the data going out the capture pin, which better not be changed
    HRESULT hr = NOERROR;
    hr = pPin->NotifyAllocator(m_pTee->m_pAllocator, TRUE);
    if (FAILED(hr))
        return hr;

    // Return the allocator
    *ppAlloc = m_pTee->m_pAllocator;
    m_pTee->m_pAllocator->AddRef();
    return NOERROR;

} // DecideAllocator


//
// CheckMediaType
//
HRESULT CSmartTeeOutputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);
    //DbgLog((LOG_TRACE,3,TEXT("TTOut: CheckMT %d bit"), HEADER(pmt->Format())->biBitCount));

    HRESULT hr = NOERROR;

#ifdef DEBUG
    // Display the type of the media for debugging purposes
    //!!!DisplayMediaType(TEXT("Output Pin Checking"), pmt);
#endif

    // The input needs to have been connected first
    if (m_pTee->m_Input.m_Connected == NULL) {
        //DbgLog((LOG_TRACE,3,TEXT("FAIL: In not connected")));
        return VFW_E_NOT_CONNECTED;
    }

    // If it doesn't match our input type, the input better be willing to
    // reconnect, and the other output better be too
    if (*pmt != m_pTee->m_Input.m_mt) {
        //DbgLog((LOG_TRACE,3,TEXT("Hmmm.. not same as input type")));
	for (int z = 0; z < m_pTee->m_NumOutputPins; z++) {
	    CSmartTeeOutputPin *pOut = m_pTee->GetPinNFromList(z);
	    IPin *pCon = pOut->m_Connected;
	    if (pOut != this && pCon) {
	        if (pCon->QueryAccept(pmt) != S_OK) {
        	    //DbgLog((LOG_TRACE,3,TEXT("FAIL:Other out can't accept")));
		    return VFW_E_TYPE_NOT_ACCEPTED;
		}
	    }
	}
	hr = m_pTee->m_Input.m_Connected->QueryAccept(pmt);
	if (hr != S_OK) {
            //DbgLog((LOG_TRACE,3,TEXT("FAIL: In can't reconnect")));
            return VFW_E_TYPE_NOT_ACCEPTED;
	}
    }

    return NOERROR;

} // CheckMediaType


//
// EnumMediaTypes
//
STDMETHODIMP CSmartTeeOutputPin::EnumMediaTypes(IEnumMediaTypes **ppEnum)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(ppEnum);

    // Make sure that we are connected
    if (m_pTee->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    return CBaseOutputPin::EnumMediaTypes (ppEnum);
} // EnumMediaTypes

//
// GetMediaType
//
HRESULT CSmartTeeOutputPin::GetMediaType(   
    int iPosition,
    CMediaType *pMediaType
    )
{
    // Make sure that we have an input connected
    if (m_pTee->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    IEnumMediaTypes *pEnum;
    HRESULT hr;

    // the first thing we offer is the current type other pins are connected
    // with... because if one output pin is connected to a filter whose input
    // pin offers media types, the current connected type might not be in
    // the list we're about to enumerate!
    if (iPosition == 0) {
	*pMediaType = m_pTee->m_Input.m_mt;
	return S_OK;
    }

    // offer all the types the filter upstream of us can offer, because we
    // may be able to reconnect and end up using any of them.
    AM_MEDIA_TYPE *pmt;
    hr = m_pTee->m_Input.m_Connected->EnumMediaTypes(&pEnum);
    if (hr == NOERROR) {
        ULONG u;
        pEnum->Skip(iPosition - 1);
        hr = pEnum->Next(1, &pmt, &u);
        pEnum->Release();
	if (hr == S_OK) {
	    *pMediaType = *pmt;
	    DeleteMediaType(pmt);
	    return S_OK;
	} else {
	    return VFW_S_NO_MORE_ITEMS;
	}
    } else {
        return E_FAIL;
    }

} // GetMediaType

//
// SetMediaType
//
HRESULT CSmartTeeOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

#ifdef DEBUG
    // Display the format of the media for debugging purposes
    // !!! DisplayMediaType(TEXT("Output pin type agreed"), pmt);
#endif

    // Make sure that we have an input connected
    if (m_pTee->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    // Make sure that the base class likes it
    HRESULT hr = NOERROR;
    hr = CBaseOutputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    return NOERROR;

} // SetMediaType


//
// CompleteConnect
//
HRESULT CSmartTeeOutputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_Connected == pReceivePin);
    HRESULT hr = NOERROR;

    //DbgLog((LOG_TRACE,3,TEXT("Output::CompleteConnect %d bit"), HEADER(m_mt.Format())->biBitCount));

    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
        return hr;

    // If the type is not the same as that stored for the input
    // pin then force the input pins peer to be reconnected

    if (m_mt != m_pTee->m_Input.m_mt)
    {
    	//DbgLog((LOG_TRACE,3,TEXT("OUT Connected: RECONNECT IN")));
        hr = m_pTee->ReconnectPin(m_pTee->m_Input.m_Connected, &m_mt);
        if(FAILED(hr)) {
            return hr;
        }
    }

    // We may need to reconnect the other output pin too
    for (int z = 0; z < m_pTee->m_NumOutputPins; z++) {
	CSmartTeeOutputPin *pOut = m_pTee->GetPinNFromList(z);
	if (pOut != this && pOut->m_Connected && pOut->m_mt != this->m_mt) {
    	    //DbgLog((LOG_TRACE,3,TEXT("OUT Connected: RECONNECT OUT")));
            hr = m_pTee->ReconnectPin(pOut, &m_mt);
            if(FAILED(hr)) {
                return hr;
            }
	}
    }

    return NOERROR;

} // CompleteConnect


//
// Active
//
// This is called when we transition from stop to paused. We create the
// output queue object to send data to our associated peer pin
//
HRESULT CSmartTeeOutputPin::Active()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    m_fLastSampleDiscarded = FALSE;

    // reset the skipped count to zero every time we start streaming
    m_pTee->m_Input.m_nFramesSkipped = 0;

    // Make sure that the pin is connected
    if (m_Connected == NULL)
        return NOERROR;

    // Create the output queue if we have to
    if (m_pOutputQueue == NULL)
    {
 	// ALWAYS use a separate thread... it's the only way we can tell
	// if we have time to preview
        m_pOutputQueue = new CMyOutputQueue(m_Connected, &hr, FALSE, TRUE);
        if (m_pOutputQueue == NULL)
            return E_OUTOFMEMORY;

        // Make sure that the constructor did not return any error
        if (FAILED(hr))
        {
            delete m_pOutputQueue;
            m_pOutputQueue = NULL;
            return hr;
        }
    }

    // Pass the call on to the base class
    CBaseOutputPin::Active();
    return NOERROR;

} // Active


//
// Inactive
//
// This is called when we stop streaming
// We delete the output queue at this time
//
HRESULT CSmartTeeOutputPin::Inactive()
{
    CAutoLock lock_it(m_pLock);

    // Delete the output queue associated with the pin.
    if (m_pOutputQueue)
    {
        delete m_pOutputQueue;
        m_pOutputQueue = NULL;
    }

    CBaseOutputPin::Inactive();
    return NOERROR;

} // Inactive



// expose IAMStreamControl
//
STDMETHODIMP CSmartTeeOutputPin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IAMStreamControl) {
	return GetInterface((LPUNKNOWN)(IAMStreamControl *)this, ppv);
    }

    return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
}

//
// Deliver
//
HRESULT CSmartTeeOutputPin::Deliver(IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR;

    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    if (CheckStreamState(pMediaSample) != STREAM_FLOWING) {
	m_fLastSampleDiscarded = TRUE;
	return S_OK;
    }

    if (m_fLastSampleDiscarded) {
	pMediaSample->SetDiscontinuity(TRUE);
    }
    m_fLastSampleDiscarded = FALSE;

    // capture pin? just give it to the queue
    if (!m_bIsPreview) {
        pMediaSample->AddRef();
        //DbgLog((LOG_TRACE,1,TEXT("Putting on capture Q")));
        return m_pOutputQueue->Receive(pMediaSample);
    }

    // For the preview pin, we need to remove the time stamps because preview
    // pin frames will always be late, and dropped by the renderer if they
    // are time stamped, since we don't know the latency of the graph.
    // We can't remove the time stamp on this sample, because the capture pin
    // is using it, so we make a new sample with the same data to use, which
    // will be identical except without time stamps, and when it is freed, we
    // release our ref count on the original sample (which has the data)

    CMyMediaSample *pNewSample = new CMyMediaSample(NAME("Preview sample"),
			(CBaseAllocator *)m_pTee->m_pAllocator, m_pOutputQueue,
			&hr);
    if (pNewSample == NULL || hr != NOERROR)
	return E_OUTOFMEMORY;
    pNewSample->AddRef();	// not done in constructor

    BYTE *pBuffer;
    hr = pMediaSample->GetPointer(&pBuffer);
    if (hr != NOERROR) {
	pNewSample->Release();
	return E_UNEXPECTED;
    }

    hr = pNewSample->SetPointer(pBuffer, pMediaSample->GetSize());
    if (hr != NOERROR) {
	pNewSample->Release();
	return E_UNEXPECTED;
    }
    pNewSample->SetTime(NULL, NULL);
    // did we send the last capture frame out the preview or not?
    pNewSample->SetDiscontinuity(m_pTee->m_Input.m_nFramesSkipped != 1);
    pNewSample->SetSyncPoint(pMediaSample->IsSyncPoint() == S_OK);
    pNewSample->SetPreroll(pMediaSample->IsPreroll() == S_OK);
    pNewSample->m_pOwnerSample = pMediaSample;
    pMediaSample->AddRef();
    //DbgLog((LOG_TRACE,1,TEXT("Putting on Receive Q")));
    return m_pOutputQueue->Receive(pNewSample);

} // Deliver


//
// DeliverEndOfStream
//
HRESULT CSmartTeeOutputPin::DeliverEndOfStream()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    //DbgLog((LOG_TRACE,1,TEXT("::DeliverEndOfStream")));

    m_pOutputQueue->EOS();
    return NOERROR;

} // DeliverEndOfStream


//
// DeliverBeginFlush
//
HRESULT CSmartTeeOutputPin::DeliverBeginFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->BeginFlush();
    return NOERROR;

} // DeliverBeginFlush


//
// DeliverEndFlush
//
HRESULT CSmartTeeOutputPin::DeliverEndFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->EndFlush();
    return NOERROR;

} // DeliverEndFlish

//
// DeliverNewSegment
//
HRESULT CSmartTeeOutputPin::DeliverNewSegment(REFERENCE_TIME tStart, 
                                         REFERENCE_TIME tStop,  
                                         double dRate)          
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->NewSegment(tStart, tStop, dRate);
    return NOERROR;

} // DeliverNewSegment


//
// Notify
//
STDMETHODIMP CSmartTeeOutputPin::Notify(IBaseFilter *pSender, Quality q)
{
    // Quality management is unneccessary with a live source
    return E_NOTIMPL;
} // Notify


#ifdef FILTER_DLL
//
// DllRegisterServer
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}


//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}
#endif



CMyOutputQueue::CMyOutputQueue(IPin *pInputPin, HRESULT *phr,
                 		BOOL bAuto, BOOL bQueue, LONG lBatchSize,
                 		BOOL bBatchExact, LONG lListSize,
                 		DWORD dwPriority) :
    COutputQueue(pInputPin, phr, bAuto, bQueue, lBatchSize, bBatchExact,
			lListSize, dwPriority)
{
    m_nOutstanding = 0;
}


CMyOutputQueue::~CMyOutputQueue()
{
}


// how many samples are queued but not sent?
int CMyOutputQueue::GetThreadQueueSize()
{
    if (m_List)
        return m_List->GetCount();
    else
	return 0;
}

CMyMediaSample::CMyMediaSample(TCHAR *pName, CBaseAllocator *pAllocator,
		CMyOutputQueue *pQ, HRESULT *phr, LPBYTE pBuffer, LONG length) :
	CMediaSample(pName, pAllocator, phr, pBuffer, length)
{
    m_pOwnerSample = NULL;
    m_pQueue = pQ;
}

CMyMediaSample::~CMyMediaSample()
{
}

STDMETHODIMP_(ULONG) CMyMediaSample::Release()
{
    /* Decrement our own private reference count */
    LONG lRef;
    if (m_cRef == 1) {
        lRef = 0;
        m_cRef = 0;
    } else {
        lRef = InterlockedDecrement(&m_cRef);
    }
    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"),
	    this, m_cRef));

    /* Did we release our final reference count */
    if (lRef == 0) {

	// make a note that we're done with this sample
	m_pQueue->m_nOutstanding--;

        /* Free all resources */
        if (m_dwFlags & Sample_TypeChanged) {
            SetMediaType(NULL);
        }
        ASSERT(m_pMediaType == NULL);
#if 0
        m_dwFlags = 0;
        m_dwTypeSpecificFlags = 0;
        m_dwStreamId = AM_STREAM_MEDIA;
#endif

// we overrode this function to avoid this, because the memory actually belongs
// to another sample, so instead we do:
#if 0
        /* This may cause us to be deleted */
        // Our refcount is reliably 0 thus no-one will mess with us
        m_pAllocator->ReleaseBuffer(this);
#else
        if (m_pOwnerSample) {
	    m_pOwnerSample->Release();
	    m_pOwnerSample = NULL;
            DbgLog((LOG_TRACE,4,TEXT("Release Released OWNER sample")));
	}
#endif

        delete this;	// no allocator to do this for me
    }

    return (ULONG)lRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\ourcrt\dllsupp.asm ===
page    ,132
        title   dllsupp - definnlg_es some public constants
;***
;dllsupp.asm - Definitions of public constants
;
;       Copyright (c) 1992, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Provides definitions for public constants (absolutes) that are
;       'normally' defined in objects in the C library, but must be defined
;       here for clients of crtdll.dll & msvcrt*.dll.  These constants are:
;
;                           _except_list
;                           _fltused
;                           _ldused
;
;*******************************************************************************

.xlist
include cruntime.inc
.list

; offset, with respect to FS, of pointer to currently active exception handler.
; referenced by compiler generated code for SEH and by _setjmp().

        public  _except_list
_except_list    equ     0

        public  _fltused
_fltused        equ     9876h

        public  _ldused
_ldused         equ     9876h

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\strmaloc\code\buffers.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*
    CCircularBuffer

        A buffer with the start mapped at the end to provide contiguous
        access to a moving window of data

    CCircularBufferList

        Structure on top of CCircularBuffer for managing a list
        of buffers

    See buffers.h for a description
*/

#include <streams.h>
#include <buffers.h>

// !!! hacky win95 stuff, needs cleaning up!
int	crefVxD = 0;
HANDLE	hVxD = NULL;

#define VXD_NAME TEXT("\\\\.\\QUARTZ.VXD")
#define IOCTL_ALLOCALIASEDBUFFER    1
#define IOCTL_FREEALIASEDBUFFER     2
#ifndef PAGESIZE
#define PAGESIZE 4096
#endif

/*  CCircularBuffer implementation */

CCircularBuffer::~CCircularBuffer()
{
    if (m_pBuffer != NULL) {
	if (hVxD && hVxD != INVALID_HANDLE_VALUE) {
	    DWORD cbRet;
	
	    if (!DeviceIoControl(hVxD,
				 IOCTL_FREEALIASEDBUFFER,
				 &m_pBuffer,
				 sizeof(m_pBuffer),
				 NULL,
				 0,
				 &cbRet,
				 NULL)) {
		ASSERT(0);
	    }

            DbgLog((LOG_TRACE, 1, TEXT("VxD refcount-- = %d..."), crefVxD - 1));
	    if (--crefVxD == 0) {
                DbgLog((LOG_TRACE, 1, TEXT("Closing VxD")));
		CloseHandle(hVxD);
		hVxD = 0;
	    }
	} else {
	    EXECUTE_ASSERT(UnmapViewOfFile(m_pBuffer));
	    EXECUTE_ASSERT(UnmapViewOfFile((PVOID)((PBYTE)m_pBuffer + m_lTotalSize)));
	}
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("NULL pBuffer... in ~CCircularBuffer")));
    }
}

CCircularBuffer::CCircularBuffer(LONG lTotalSize,
                                 LONG lMaxContig,
                                 HRESULT& hr) :
    m_lTotalSize(lTotalSize),
    m_lMaxContig(lMaxContig),
    m_pBuffer(NULL)
{
    //  Check they used ComputeSizes
    if (!CheckSizes(lTotalSize, lMaxContig)) {
        hr = E_UNEXPECTED;
        return;
    }

    if (hVxD != INVALID_HANDLE_VALUE) {
	if (hVxD == 0) {
            DbgLog((LOG_TRACE, 1, TEXT("Loading VxD...")));
	    hVxD = CreateFile(
		VXD_NAME,
		GENERIC_WRITE,
		FILE_SHARE_WRITE,
		NULL,
		OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL, // FILE_FLAG_GLOBAL_HANDLE???
		NULL);
	}

	if (hVxD == INVALID_HANDLE_VALUE) {
	    goto PerhapsWeAreOnNT;
	}

	crefVxD++;
        DbgLog((LOG_TRACE, 1, TEXT("VxD refcount++ = %d..."), crefVxD));
	
	DWORD dwPages = lTotalSize / PAGESIZE;
	DWORD cbRet;
	
	if (!DeviceIoControl(hVxD,
				IOCTL_ALLOCALIASEDBUFFER,
				&dwPages,
				sizeof(dwPages),
				&m_pBuffer,
				sizeof(m_pBuffer),
				&cbRet,
				NULL)) {
	    DbgLog((LOG_ERROR, 1, TEXT("DeviceIOControl failed")));
	    hr = E_OUTOFMEMORY;
	    return;
	}
	DbgLog((LOG_TRACE, 2, TEXT("Using VxD to allocate memory")));
    } else {
PerhapsWeAreOnNT:
	HANDLE hMapping;

	/*  Create a file mapping of the first buffer */
	hMapping = CreateFileMapping(
		       INVALID_HANDLE_VALUE,
		       NULL,
		       PAGE_READWRITE,
		       0,
		       m_lTotalSize,
		       NULL);

	if (hMapping == NULL) {
	    DWORD dwErr = GetLastError();
	    hr = AmHresultFromWin32(dwErr);
	    return;
	}


	/*  Try to create the mappings - this can fail due to bad luck
	    so try a few times
	*/
	for (int i = 0; i < 20; i++) {
	    hr = CreateMappings(hMapping);
	    if (SUCCEEDED(hr)) {
		break;
	    } else {
		DbgLog((LOG_TRACE, 1, TEXT("Create file mappings failed - %8.8X"),
		       hr));
	    }
	}

	/*  We don't need this handle any more.  The mapping will actually
	    close when we unmap all the views
	*/

	CloseHandle(hMapping);
    }
}

/*  Try to create the mapping objects */
HRESULT CCircularBuffer::CreateMappings(HANDLE hMapping)
{
    /*  Big hack */
    PVOID pData = VirtualAlloc(NULL,
                               m_lTotalSize + m_lMaxContig,
                               MEM_RESERVE,
                               PAGE_READWRITE);

    if (pData == NULL) {
        DWORD dwErr = GetLastError();
        DbgLog((LOG_ERROR, 1, TEXT("Could not allocate page space")));
        return AmHresultFromWin32(dwErr);
    }
    VirtualFree(pData, 0, MEM_RELEASE);

    /*  Now map the thing in two places */
    pData = MapViewOfFileEx(hMapping,
                            FILE_MAP_WRITE,
                            0,
                            0,
                            m_lTotalSize,
                            pData);

    if (pData == NULL) {
        DWORD dwErr = GetLastError();
        return AmHresultFromWin32(dwErr);
    }

    PVOID pRequired = (PVOID)((PBYTE)pData + m_lTotalSize);

    /*  We want to see lMaxContig bytes duplicated */

    PVOID pRest = MapViewOfFileEx(hMapping,
                                  FILE_MAP_WRITE,
                                  0,
                                  0,
                                  m_lMaxContig,
                                  pRequired);

    ASSERT(pRest == NULL || pRest == pRequired);

    if (pRest == NULL) {
        DWORD dwErr = GetLastError();
        UnmapViewOfFile(pData);
        return AmHresultFromWin32(dwErr);
    }

    m_pBuffer = (PBYTE)pData;

    return S_OK;
}

LONG CCircularBuffer::AlignmentRequired()
{
   SYSTEM_INFO SystemInfo;
   GetSystemInfo(&SystemInfo);
   return (LONG)SystemInfo.dwAllocationGranularity;
}

/*  Check the sizes we're going to use are valid */
BOOL CCircularBuffer::CheckSizes(LONG lTotalSize, LONG lMaxContig)
{
    return lTotalSize != 0 &&
           lMaxContig != 0 &&
           lMaxContig <= lTotalSize &&
           (lTotalSize & (AlignmentRequired() - 1)) == 0;
}

HRESULT CCircularBuffer::ComputeSizes(
    LONG& lSize,
    LONG& cBuffers,
    LONG  lMaxContig)
{
    /*  Now make fiddle the numbers upwards until :

        PAGE_SIZE | lSize * cBuffers
        lMaxContig <= lSize * cBuffers;

        DON'T cheat by making PAGE_SIZE | lSize

        We don't need to fiddle lMaxContig because it's just
        the amount of stuff we remap at the end.
    */

    /*  Work out what the alignment of the count is */
    ASSERT(cBuffers != 0);
    LONG lAlign = AlignmentRequired() / (cBuffers & -cBuffers);
    lSize = (lSize + lAlign - 1) & ~(lAlign - 1);
    ASSERT(CheckSizes(lSize * cBuffers, lMaxContig));
    return S_OK;
}

//
//  Return where our buffer starts
//

PBYTE CCircularBuffer::GetPointer() const
{
    return m_pBuffer;
}

/* CCirculareBufferList implementation */


CCircularBufferList::CCircularBufferList(
            LONG     cBuffers,
            LONG     lSize,
            LONG     lMaxContig,
            HRESULT& hr) :
    CCircularBuffer(cBuffers * lSize, lMaxContig, hr),
    CBaseObject(NAME("Circular buffer")),
    m_lSize(lSize),
    m_lCount(cBuffers),
    m_cValid(0),
    m_lValid(0),
    m_pStartBuffer(NULL),
    m_bEOS(FALSE)
{
    DbgLog((LOG_TRACE, 1, TEXT("Creating buffer list...")));
};

CCircularBufferList::~CCircularBufferList()
{
    DbgLog((LOG_TRACE, 1, TEXT("Destroying buffer list...")));
};

/*
    Add a buffer to the valid region
*/
BOOL CCircularBufferList::Append(PBYTE pBuffer, LONG lSize)
{
    ASSERT(!Valid(pBuffer));
    ASSERT(lSize <= m_lSize);
    if (m_bEOS) {
        DbgLog((LOG_ERROR, 2, TEXT("CCircularBufferList rejecting buffer because of EOS")));
        return FALSE;
    }
    if (m_cValid == 0) {
        m_pStartBuffer = pBuffer;
    } else {
        if (pBuffer == NextBuffer(LastBuffer())) {
            ASSERT(m_cValid < m_lCount);
        } else {
            DbgLog((LOG_TRACE, 2, TEXT("CCircularBufferList rejecting buffer %8.8p expected %8.8p"),
                    pBuffer, NextBuffer(LastBuffer())));
            return FALSE;
        }
    }
    m_cValid++;
    m_lValid += lSize;
    if (lSize != m_lSize) {
        m_bEOS = TRUE;
    }
    return TRUE;
};

/*
    Remove a buffer from the valid region
*/
LONG CCircularBufferList::Remove(PBYTE pBuffer)
{
    ASSERT(ValidBuffer(pBuffer));
    PBYTE pBuf = m_pStartBuffer;
    for (int i = 0; i < m_cValid; i++, pBuf = NextBuffer(pBuf)) {
        if (pBuffer == pBuf) {
            m_cValid -= i + 1;
            ASSERT(m_cValid >= 0);
            m_pStartBuffer = NextBuffer(pBuffer);
            m_lValid -= (i + 1) * m_lSize;
            if (m_lValid < 0) {
                ASSERT(m_bEOS);
                m_lValid = 0;
            }
            return (i + 1) * m_lSize;
        }
    }
    return 0;
};

/*
    Return offset of buffer within the valid region
*/
LONG CCircularBufferList::Offset(PBYTE pBuffer) const
{
    if (m_cValid == 0) {
        return 0;
    }
    ASSERT(m_pStartBuffer != 0);
    LONG lOffset = (LONG)(pBuffer - m_pStartBuffer);
    if (lOffset < 0) {
        lOffset += m_lTotalSize;
    }
    ASSERT(lOffset <= m_lValid);
    return lOffset;
};

/*
    Find the buffer corresponding to the given offset in the valid
    region
*/
PBYTE CCircularBufferList::GetBuffer(LONG lOffset) const
{
    ASSERT(lOffset >= 0);
    if (lOffset >= m_lValid) {
        return NULL;
    }
    return AdjustPointer(m_pStartBuffer + lOffset);
}

/*
    Return the size of each buffer
*/
LONG CCircularBufferList::BufferSize() const
{
    return m_lSize;
}

/*
    Return the length in bytes of the valid region
*/
LONG CCircularBufferList::LengthValid() const
{
    ASSERT(m_lValid >= 0 &&
           m_lValid <= m_cValid * m_lSize);
    return m_lValid;
}

/*
    Return the length that can be seen contigously from the current position
*/
LONG CCircularBufferList::LengthContiguous(PBYTE pb) const
{
    LONG lValid = m_lValid - Offset(pb);
    if (pb + lValid > (m_pBuffer + m_lTotalSize) + m_lMaxContig) {
        lValid = (LONG)(((m_pBuffer + m_lTotalSize) + m_lMaxContig) - pb);
    }
    ASSERT(lValid >= 0);
    return lValid;
}
/*
    Return whether we've received end of stream
*/
BOOL CCircularBufferList::EOS() const
{
    return m_bEOS;
};

/*
    Coerce a possibly aliased pointer to a real pointer
*/
PBYTE CCircularBufferList::AdjustPointer(PBYTE pBuf) const
{
    if (pBuf >= m_pBuffer + m_lTotalSize) {
        pBuf -= m_lTotalSize;
    }
    ASSERT(pBuf >= m_pBuffer && pBuf < m_pBuffer + m_lTotalSize);
    return pBuf;
};

/*
    Return whether a buffer is in the valid region
*/
BOOL CCircularBufferList::Valid(PBYTE pBuffer)
{
    PBYTE pBuf = m_pStartBuffer;
    ASSERT(ValidBuffer(pBuffer));
    for (int i = 0; i < m_cValid; i++, pBuf = NextBuffer(pBuf)) {
        if (pBuf == pBuffer) {
            return TRUE;
        }
    }
    return FALSE;
};
void CCircularBufferList::Reset()
{
    DbgLog((LOG_TRACE, 2, TEXT("On Reset() m_cValid = %d, m_lValid = %d"),
            m_cValid, m_lValid));
    m_cValid = 0;
    m_lValid = 0;
    m_pStartBuffer = NULL;
    m_bEOS = FALSE;
};

int CCircularBufferList::Index(PBYTE pBuffer)
{
    int index = (int)(pBuffer - m_pBuffer) / m_lSize;
    if (index >= m_lCount) {
        index -= m_lCount;
    }
    ASSERT(index < m_lCount);
    return index;
}

/*
    Step on to the next buffer
*/
PBYTE CCircularBufferList::NextBuffer(PBYTE pBuffer)
{
    ASSERT(ValidBuffer(pBuffer));
    PBYTE pNew = pBuffer + m_lSize;
    if (pNew == m_pBuffer + m_lTotalSize) {
        return m_pBuffer;
    } else {
        return pNew;
    }
};

/*
    Check the pointer is one of our buffers
*/
BOOL CCircularBufferList::ValidBuffer(PBYTE pBuffer) {
    if (pBuffer < m_pBuffer || pBuffer >= m_pBuffer + m_lTotalSize) {
        return FALSE;
    }
    if (((pBuffer - m_pBuffer) % m_lSize) != 0) {
        return FALSE;
    }
    return TRUE;
};

/*
    Return a pointer to the last buffer in the valid region
*/
PBYTE CCircularBufferList::LastBuffer() {
    ASSERT(m_lValid != 0);
    return AdjustPointer(m_pStartBuffer + m_lSize * (m_cValid - 1));
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\strmaloc\code\stmalloc.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*
    stmalloc.cpp

    CCircularBuffer

        A buffer with the start mapped at the end to provide contiguous
        access to a moving window of data

    CStreamAllocator

        Implements classes required to provide an allocator for an input
        pin which maps the samples to a circular buffer.

    CSubAllocator

        An allocator which gets its samples from the buffer in a
        CStreamAllocator object.

        This allows samples to be allocated on top of samples from
        an input pin which can be sent to an output pin.

*/


#include <streams.h>
#include <buffers.h>
#include <stmalloc.h>


/*  CStreamAllocator implementation */

CStreamAllocator::CStreamAllocator(
    TCHAR    * pName,
    LPUNKNOWN  pUnk,
    HRESULT  * phr,
    LONG       lMaxContig) :
    CBaseAllocator(pName, pUnk, phr),
    m_pBuffer(NULL),
    m_lMaxContig(lMaxContig),
    m_NextToAllocate(0),
#ifdef DEBUG
    m_bEventSet(FALSE),
#endif
    m_pSamples(NULL),
    m_bPositionValid(FALSE),
    m_bSeekTheReader(FALSE)
{
}

CStreamAllocator::~CStreamAllocator()
{
    DbgLog((LOG_TRACE, 3, TEXT("CStreamAllocator::~CStreamAllocator")));
    /*  Free our resources */
    EXECUTE_ASSERT(SUCCEEDED(Decommit()));
    ReallyFree();
}

/* CBaseAllocator overrides */
STDMETHODIMP CStreamAllocator::SetProperties(
    ALLOCATOR_PROPERTIES *pRequest,
    ALLOCATOR_PROPERTIES *pActual)
{
    if (NULL == pRequest || NULL == pActual) {
        return E_POINTER;
    }
    CAutoLock lck(this);
    SYSTEM_INFO SysInfo;
    GetSystemInfo(&SysInfo);

    DbgLog((LOG_TRACE, 4, TEXT("CStreamAllocator::SetProperties(%d,%d,%d,%d...)"),
            pRequest->cBuffers, pRequest->cbBuffer, pRequest->cbAlign));

    long alignmentRequest = pRequest->cbAlign;
    long sizeRequest = pRequest->cbBuffer;
    long countRequest = pRequest->cBuffers;

    if (pRequest->cbPrefix > 0) {
        return E_INVALIDARG;
    }

    /*  Check alignment request is a power of 2 */
    if ((-alignmentRequest & alignmentRequest) != alignmentRequest) {
        DbgLog((LOG_ERROR, 1, TEXT("Alignment 0x%x not a power of 2!"),
               alignmentRequest));
    }

    if (SysInfo.dwAllocationGranularity & (alignmentRequest - 1)) {
        DbgLog((LOG_ERROR, 1, TEXT("Alignment 0x%x requested too great!"),
               alignmentRequest));
        return E_INVALIDARG;
    }

    /* Can't do this if already committed, there is an argument that says we
       should not reject the SetProperties call if there are buffers still
       active. However this is called by the source filter, which is the same
       person who is holding the samples. Therefore it is not unreasonable
       for them to free all their samples before changing the requirements */

    if (m_bCommitted == TRUE) {
        return E_ACCESSDENIED;
    }

    /*  Combine with any old values :
           Take the max of the aligments
           Take the max of the number of buffers
           Use the max of the total sizes
    */

    if (m_lCount > 0) {
        if (alignmentRequest < m_lAlignment) {
            alignmentRequest = m_lAlignment;
        }
        LONG lTotalSizeRequest = countRequest * sizeRequest;
        LONG lTotalSize        = m_lCount * m_lSize;
        LONG lMaxSize = max(lTotalSizeRequest, lTotalSize);
        countRequest = max(countRequest, m_lCount);
        sizeRequest = (lMaxSize + countRequest - 1) / countRequest;
    }

    /*  Align the size with the alignment */
    sizeRequest = (sizeRequest + alignmentRequest - 1) & ~(alignmentRequest - 1);

    HRESULT hr = CCircularBuffer::ComputeSizes(sizeRequest, countRequest, m_lMaxContig);
    if (SUCCEEDED(hr)) {
        m_lAlignment = alignmentRequest;
        m_lCount = countRequest;
        m_lSize = sizeRequest;

        pActual->cbAlign = m_lAlignment;

        /*  Make sure we reallocate our buffers next time round */
        m_bChanged = TRUE;

        /*  Allow for bad disks */
        #define DISK_READ_MAX_SIZE 32768
        if (m_lSize > DISK_READ_MAX_SIZE) {
            LONG lTotal = m_lSize * m_lCount;
            if ((lTotal & (DISK_READ_MAX_SIZE - 1)) == 0) {
                m_lSize = DISK_READ_MAX_SIZE;
                m_lCount = lTotal / DISK_READ_MAX_SIZE;
            }
        }
        pActual->cbBuffer = m_lSize;
        pActual->cBuffers = m_lCount;
    } else {
        DbgLog((LOG_ERROR, 2, TEXT("CStreamAllocator::SetProperties could not satisfy count %d, size %d"),
                countRequest, sizeRequest));
    }
    return hr;
}

// get container for a sample. Blocking, synchronous call to get the
// next free buffer (as represented by an IMediaSample interface).
// on return, the time etc properties will be invalid, but the buffer
// pointer and size will be correct.

HRESULT CStreamAllocator::GetBuffer(IMediaSample **ppBuffer,
                                    REFERENCE_TIME *pStartTime,
                                    REFERENCE_TIME *pEndTime,
                                    DWORD dwFlags)
{
    UNREFERENCED_PARAMETER(pStartTime);
    UNREFERENCED_PARAMETER(pEndTime);
    UNREFERENCED_PARAMETER(dwFlags);
    *ppBuffer = NULL;
    CMediaSample * pSample = NULL;

    while (TRUE) {
        {
            CAutoLock cObjectLock(this);

            /* Check we are committed */
            if (m_bCommitted == FALSE) {
                return E_OUTOFMEMORY;
            }

            CMediaSample *pSampleNext =
                (CMediaSample *) m_pSamples[m_NextToAllocate];

            /* Only return the one we want */
            pSample = m_lFree.Head();
            while (pSample) {
                if (pSampleNext == pSample) {
                    m_lFree.Remove(pSample);
                    /*  This is the point at which the data pointed to
                        by this sample becomes invalid.

                        We postpone until now to give us limited backward
                        seek capability which is essential for good
                        performance
                    */
                    PBYTE ptr;
                    pSample->GetPointer(&ptr);
                    m_pBuffer->Remove(ptr);
                    DbgLog((LOG_TRACE, 4,
                            TEXT("Stream allocator allocated buffer %p"),
                            ptr));

                    m_NextToAllocate++;
                    if (m_NextToAllocate == m_lCount) {
                        m_NextToAllocate = 0;
                    }
                    break;
                } else {
                    pSample = m_lFree.Next(pSample);
                }
            }
            if (pSample == NULL) {
#ifdef DEBUG
                DbgLog((LOG_TRACE, 4, TEXT("CStreamAllocator::GetBuffer() waiting - %d on list"),
                        m_lFree.GetCount()));
                m_bEventSet = FALSE;
                if (m_lFree.GetCount() == m_lAllocated) {
                    DbgLog((LOG_ERROR, 1, TEXT("Expected sample was %8.8X"), pSampleNext));
                    DbgLog((LOG_ERROR, 1, TEXT("Samples on list are :")));
                    CMediaSample *pSample = m_lFree.Head();
                    while(pSample) {
                        DbgLog((LOG_ERROR, 1, TEXT("    %8.8X"), pSample));
                        pSample = m_lFree.Next(pSample);
                    }
                }
#endif
                /*  If there were some samples but just not ours someone
                    else may be waiting
                */
                if (m_lFree.GetCount() != 0) {
                    NotifySample();
                }
                SetWaiting();
            }
        }

        if (pSample != NULL) {
            break;
        }

        EXECUTE_ASSERT(WaitForSingleObject(m_hSem, INFINITE) == WAIT_OBJECT_0);
    }

    /* Addref the buffer up to one. On release
       back to zero instead of being deleted, it will requeue itself by
       calling the ReleaseBuffer member function. NOTE the owner of a
       media sample must always be derived from CBaseAllocator */

    pSample->m_cRef = 1;
    *ppBuffer = pSample;

    // cause the start time on the returned buffer to be a file seek
    // position.  This causes the file reader to begin reading from
    // that position.
    //
    if (m_bSeekTheReader)
    {
        REFERENCE_TIME tSeek = CRefTime(m_llSeekTheReader * UNITS);
        (*ppBuffer)->SetTime(&tSeek, &tSeek);
        (*ppBuffer)->SetDiscontinuity(TRUE);
        m_bSeekTheReader = FALSE;
    }
    return S_OK;
}

BOOL CStreamAllocator::SeekTheReader(LONGLONG llPos)
{
   CAutoLock lck(this);
   m_bSeekTheReader = TRUE;
   m_llSeekTheReader = llPos;
   return TRUE;
}

//  Reset valid region.  This is called when some kind of disconinuity
//  occurs
void CStreamAllocator::ResetPosition()
{
    CAutoLock lck(this);
    if (m_lFree.GetCount() != m_lAllocated) {
        Advance(TotalLengthValid());
    }
    if (m_lFree.GetCount() == m_lAllocated) {
        m_NextToAllocate = 0;
    }
    m_pCurrent = NULL;
    m_bEmpty = TRUE;
    if (m_pBuffer != NULL) {
        m_pBuffer->Reset();
    }
}

//
//   Allocate our samples
//

HRESULT CStreamAllocator::Alloc()
{
    CAutoLock lck(this);

    DbgLog((LOG_TRACE, 3, TEXT("CStreamAllocator::Alloc()")));

    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
        return hr;
    }

    /* If the requirements haven't changed then don't reallocate */
    if (hr == S_FALSE) {
        ASSERT(m_pBuffer);
        /*  Reset the pointer in any case */
        ResetPosition();
        return NOERROR;
    }

    if (m_pBuffer != NULL) {
        ReallyFree();
    }

    m_pSamples = new PMEDIASAMPLE[m_lCount];
    if (m_pSamples == NULL) {
        return E_OUTOFMEMORY;
    }

    /*  Allocate our special circular buffer */
    m_pBuffer = new CCircularBufferList(m_lCount,
                                        m_lSize,
                                        m_lMaxContig,
                                        hr);
    if (m_pBuffer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    if (FAILED(hr)) {
        delete m_pBuffer;
        delete [] m_pSamples;
        m_pBuffer = NULL;
        m_pSamples = NULL;
        return hr;
    }

    LPBYTE pNext = m_pBuffer->GetPointer();
    CMediaSample *pSample;


    ASSERT(m_lAllocated == 0);

    /* Create the new samples */
    for (; m_lAllocated < m_lCount; m_lAllocated++) {

        pSample = new CMediaSample(NAME("CStreamAllocator media sample"),
                                   this, &hr, pNext, m_lSize);

        DbgLog((LOG_TRACE, 4, TEXT("CStreamAllocator creating sample %8.8X"),
                pSample));

        if (FAILED(hr) || pSample == NULL) {
            return E_OUTOFMEMORY;
        }

        m_pSamples[m_lAllocated] = pSample;
        m_lFree.Add(pSample);
        pNext += m_lSize;
    }

    m_bChanged = FALSE;

    /*  Reset the pointer */
    ResetPosition();
    return NOERROR;
}


// override this to free up any resources we have allocated.
// called from the base class on Decommit when all buffers have been
// returned to the free list.
//
// caller has already locked the object.

// in our case, we keep the memory until we are deleted, so
// we do nothing here. The memory is deleted in the destructor by
// calling ReallyFree()

void
CStreamAllocator::Free(void)
{
    DbgLog((LOG_TRACE, 1, TEXT("CStreamAllocator::Free()")));

    /*  Advance our pointer */
    ResetPosition();
    return;
}

void
CStreamAllocator::ReallyFree()
{
    CAutoLock lck(this);
    DbgLog((LOG_TRACE, 1, TEXT("CStreamAllocator::ReallyFree()")));
    ASSERT(m_lFree.GetCount() == m_lAllocated);

    /*  Free the samples first */
    while (m_lFree.GetCount() != 0) {
        delete m_lFree.RemoveHead();
    }
    m_lAllocated = 0;
    delete m_pBuffer;
    m_pBuffer = NULL;
    delete [] m_pSamples;
    m_pSamples = NULL;
}

//
//  A sample is being returned to us in a Receive() call
//

HRESULT CStreamAllocator::Receive(PBYTE ptr, LONG lData)
{
    CAutoLock lck(this);

    DbgLog((LOG_TRACE, 4, TEXT("Stream allocator received buffer %p"),
           ptr));

    if (m_bPositionValid && m_pBuffer->Append(ptr, lData)) {
        if (m_pCurrent == NULL) {
            ASSERT(m_bEmpty);
            m_pCurrent = ptr;
        }
        if (lData != 0) {
            m_bEmpty = FALSE;
        }
        return S_OK;
    } else {
        if (!m_bPositionValid) {
            DbgLog((LOG_ERROR, 1, TEXT("CStreamAllocator::Receive() - position not valid")));
        } else {
            DbgLog((LOG_ERROR, 1, TEXT("CStreamAllocator::Receive() - Data after EOS")));
        }
        return E_UNEXPECTED;
    }
}

//
//  Set a new start position
//
void CStreamAllocator::SetStart(LONGLONG llPos)
{
    CAutoLock lck(this);
    ResetPosition();
    m_bPositionValid = TRUE;
    m_llPosition     = llPos;
}

// Lock data and get a pointer
// If we're at the end of the file cBytes can be modified.
// It's an error to ask for more than m_lMaxContig bytes
HRESULT CStreamAllocator::LockData(PBYTE pData, LONG& cBytes)
{
    CAutoLock lck(this);
    ASSERT(cBytes <= m_lMaxContig);
    pData = m_pBuffer->AdjustPointer(pData);
    LONG lOffset = m_pBuffer->Offset(pData);

    //  See if this many bytes are available or we're at the end of
    //  the file
    if (lOffset + cBytes > m_pBuffer->LengthValid()) {
        if (!m_pBuffer->EOS()) {
            return MAKE_HRESULT(SEVERITY_SUCCESS,
                                FACILITY_WIN32,
                                ERROR_MORE_DATA);
        } else {
            cBytes = m_pBuffer->LengthValid() - lOffset;
        }
    }

    /*  Find the start sample and lock down all the relevant
        samples
    */
    LockUnlock(pData, cBytes, TRUE);
    return S_OK;
}

HRESULT CStreamAllocator::UnlockData(PBYTE pData, LONG cBytes)
{
    CAutoLock lck(this);
    /*  pData can legitimately be beyond the end of the buffer */
    LockUnlock(m_pBuffer->AdjustPointer(pData), cBytes, FALSE);
    return S_OK;
}

/*
    CStreamAllocator

    LockUnlock

    Parameters:
        PBYTE pStart - start of area to lock or unlock
        LONG  cBytes - length to lock/unlock
        BOOL  bLock  - length to lock/unlock

    Note:
        The allocator must be locked before calling this
*/
void CStreamAllocator::LockUnlock(PBYTE pStart, LONG cBytes, BOOL bLock)
{
    DbgLog((LOG_TRACE, 4, TEXT("LockUnlock(%p, %X, %d)"),
            pStart, cBytes, bLock));

    ASSERT(cBytes != 0);
    int index = m_pBuffer->Index(pStart);
    CMediaSample *pSample = (CMediaSample *)m_pSamples[index];
    PBYTE pBuffer;
    pSample->GetPointer(&pBuffer);
    ASSERT(m_pBuffer->Index(pBuffer) == index);

    cBytes += (LONG)(pStart - pBuffer);

    /*  Can only LOCK buffers in the valid region,
        but buffers not in the valid region can be unlocked
    */
    ASSERT(!bLock || cBytes <= m_pBuffer->TotalLength());
    while (TRUE) {
        if (bLock) {
            pSample->AddRef();
            /*  Ugly hack - make sure it's not on the free list !!!
                This can happen if we reseek the allocator backwards.
                We should really just redesign all of this not to use lists

                We AddRef()'d it first so it's not going to pop straight
                back on the free list
            */
            CMediaSample *pListSample = m_lFree.Head();
            while (pListSample) {
                if (pSample == pListSample) {
                    m_lFree.Remove(pSample);
                    break;
                }
                pListSample = m_lFree.Next(pListSample);
            }
        } else {
            pSample->Release();
        }
        cBytes -= m_lSize;
        if (cBytes <= 0) {
            break;
        }
        if (++index == m_lCount) {
            index = 0;
        }
        pSample = (CMediaSample *)m_pSamples[index];
    }
}

// Seek to a given position
BOOL CStreamAllocator::Seek(LONGLONG llPos)
{
    CAutoLock lck(this);

    //  Can't seek if there's no buffer or we've got no data
    if (m_pBuffer == NULL || m_pCurrent == NULL) {
        DbgLog((LOG_TRACE, 2, TEXT("Allocator seek failed, no buffer")));
        return FALSE;
    }

    /*  Check the seek distance is reasonably short */
    LONGLONG llSeek       = llPos - m_llPosition;
    LONGLONG llBufferSize = (LONGLONG)m_pBuffer->TotalLength();
    BOOL bRc;
    if (llSeek <= llBufferSize && llSeek >= - llBufferSize) {
        bRc = Advance((LONG)llSeek);
    } else {
        /*  Do the best we can */
        if (llSeek > llBufferSize) {
            llSeek = llBufferSize;
            //ResetPosition();
        } else {
            llSeek = -llBufferSize;
        }
        bRc = FALSE;
    }
    if (bRc) {
        DbgLog((LOG_TRACE, 2, TEXT("Allocator seek to %s succeeded"),
                (LPCTSTR)CDisp(llPos, CDISP_HEX)));
    } else {
        DbgLog((LOG_TRACE, 2, TEXT("Allocator seek to %s failed"),
                (LPCTSTR)CDisp(llPos, CDISP_HEX)));
        /*  Seek to one end or the other */
        LONG lNewOffset = CurrentOffset() + (LONG)llSeek;
        if (lNewOffset < 0) {
            Advance((LONG)(-CurrentOffset()));
        } else {
            Advance(TotalLengthValid());
        }
    }
    return bRc;
}

// Advance our parsing pointer freeing data no longer needed
BOOL CStreamAllocator::Advance(LONG lAdvance)
{
    CAutoLock lck(this);
    /*  This is equivalent (though rather inefficiently) to

        Lock new range
        Unlock old range
    */
    if (m_pCurrent == NULL) {
        ASSERT(lAdvance == 0);
        return FALSE;
    }

    PBYTE pOldCurrent = m_pCurrent;
    ASSERT(m_llPosition >= 0);
    ASSERT(m_pCurrent != NULL);
    LONG lNewOffset = CurrentOffset() + lAdvance;
    if (lAdvance >= 0) {
        if (lNewOffset <= m_pBuffer->LengthValid()) {
            m_pCurrent = m_pBuffer->AdjustPointer(m_pCurrent + lAdvance);
            if (lNewOffset == m_pBuffer->LengthValid()) {
                if (lAdvance != 0) {
                    LockUnlock(pOldCurrent, lAdvance, FALSE);
                }
                m_bEmpty = TRUE;
            } else {
                ASSERT(LengthValid() > 0);
                LockUnlock(m_pCurrent, 1, TRUE);
                LockUnlock(pOldCurrent, lAdvance + 1, FALSE);
            }
            m_llPosition += lAdvance;
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        if (lNewOffset >= 0) {
            LONG lOldValid = LengthValid();
            m_pCurrent = m_pBuffer->GetBuffer(lNewOffset);
            if (lOldValid > 0) {
                ASSERT(!m_bEmpty);
                LockUnlock(m_pCurrent, -lAdvance + 1, TRUE);
                LockUnlock(pOldCurrent, 1, FALSE);
            } else {
                ASSERT(m_bEmpty);
                LockUnlock(m_pCurrent, -lAdvance, TRUE);
                m_bEmpty = FALSE;
            }
            m_llPosition += lAdvance;
            return TRUE;
        } else {
            return FALSE;
        }
    }
}

//
// implementation of CSubAllocator
//
// an allocator of IMediaSample objects, and implementation of IMemAllocator
// for streaming file-reading tasks, based on CFileReader.


CSubAllocator::CSubAllocator(TCHAR            * pName,
                             LPUNKNOWN          pUnk,
                             CStreamAllocator * pAllocator,
                             HRESULT          * phr) :
    CBaseAllocator(pName, pUnk, phr, FALSE),
    m_pStreamAllocator(pAllocator)
{
    pAllocator->AddRef();
}

CSubAllocator::~CSubAllocator()
{
    m_pStreamAllocator->Release();
}


// call this to get a CMediaSample object whose data pointer
// points directly into the read buffer for the given file position.
// The length must not be greater than MaxContig.
HRESULT
CSubAllocator::GetSample(PBYTE pData, LONG cBytes, IMediaSample** ppSample)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSubAllocator::GetSample")));
    *ppSample = 0;

    // is it a valid size - ie less than the max set by SetProperties?
    if (cBytes > m_lSize) {
	return E_INVALIDARG;
    }

    if (cBytes == 0) {
        DbgLog((LOG_ERROR, 1, TEXT("Getting sample with 0 bytes - pointer 0x%p"),
                pData));
    }

    // get a sample from the list

    // need to duplicate the code from CBaseAllocator::GetBuffer since
    // we need a CMediaSample * not an IMediaSample*

    // We allocate on the fly as needed
    //
    CAutoLock lock(this);

    // Check we are committed
    if (!m_bCommitted) {
	return VFW_E_NOT_COMMITTED;
    }

    CMediaSample* pSamp = m_lFree.RemoveHead();
    if (pSamp == NULL) {
        pSamp = NewSample();
        if (pSamp == NULL) {
            return E_OUTOFMEMORY;
        }
        m_lAllocated++;
    }

    // this is the bit we needed to insert into the CBaseAllocator code!
    pSamp->SetPointer(pData, cBytes);

    // when this addref is released to 0, the object will call
    // our ReleaseBuffer instead of just deleting itself.
    pSamp->m_cRef = 1;
    *ppSample = pSamp;

    // lock the data
#ifdef DEBUG
    LONG cBytesOld = cBytes;
#endif
    HRESULT hr = m_pStreamAllocator->LockData(pData, cBytes);
    ASSERT(cBytes == cBytesOld);
    if (FAILED(hr)) {
        pSamp->Release();
        delete pSamp;
        m_lAllocated--;
	return hr;
    }

    return S_OK;

}

// CBaseAllocator Overrides

// we have to be based on CBaseAllocator in order to use CMediaSample.
// we use CBaseAllocator to manage the list of CMediaSample objects, but
// override most of the functions as we dont support GetBuffer directly.

// pass hints as to size and count of samples to be used.
// we will take the smallest size  and smallest count of any call
// (resetting when a file is opened). The count we will use as the actual
// count of CMediaSample objects to use, and the size is the maximum
// size of GetSample request that will succeed. We also use the size
// as a hint to the file buffer allocator( to ensure that the minimum
// file buffer is this big).
STDMETHODIMP
CSubAllocator::SetProperties(
    ALLOCATOR_PROPERTIES * pRequest,
    ALLOCATOR_PROPERTIES * pActual
)
{
    if (NULL == pRequest || NULL == pActual) {
        return E_POINTER;
    }

    // since we are derived from CBaseAllocator, we can lock him
    CAutoLock lock(this);

    // Check no alignment is wanted (!)
    if (pRequest->cbAlign != 1) {
        DbgLog((LOG_ERROR, 1, TEXT("Wanted greater than 1 alignment 0x%x"),
               pRequest->cbAlign));
        return E_UNEXPECTED;
    }

    if (pRequest->cbPrefix > 0) {
        DbgLog((LOG_ERROR, 1, TEXT("Wanted %d prefix bytes"),
               pRequest->cbPrefix));
        return E_UNEXPECTED;
    }

    // take a copy so we can modify it
    ALLOCATOR_PROPERTIES prop;
    prop = *pRequest;


    // we take this as a hint, and use the smallest.
    if (m_lCount > 0) {
	prop.cBuffers = min(prop.cBuffers, m_lCount);
    }

    if (m_lSize > 0) {
	prop.cbBuffer = min(prop.cbBuffer, m_lSize);
    }

    return CBaseAllocator::SetProperties(
                                &prop,
                                pActual);
}

// returns an error always
STDMETHODIMP
CSubAllocator::GetBuffer(IMediaSample **ppBuffer,
                         REFERENCE_TIME *pStartTime,
                         REFERENCE_TIME *pEndTime,
                         DWORD dwFlags
                         )
{
    UNREFERENCED_PARAMETER(pStartTime);
    UNREFERENCED_PARAMETER(pEndTime);
    UNREFERENCED_PARAMETER(ppBuffer);
    UNREFERENCED_PARAMETER(dwFlags);
    return E_NOTIMPL;
}

// called by CMediaSample to return it to the free list and
// unblock block any pending GetSample call.
STDMETHODIMP
CSubAllocator::ReleaseBuffer(IMediaSample * pSample)
{
    // unlock the data area before putting on free list

    BYTE * ptr;
    HRESULT hr = pSample->GetPointer(&ptr);
    if (FAILED(hr)) {
	//!!!
	ASSERT(SUCCEEDED(hr));
    } else {

	hr = m_pStreamAllocator->UnlockData(ptr, pSample->GetActualDataLength());
	if (FAILED(hr)) {
	    //!!!
	    ASSERT(SUCCEEDED(hr));
	}
    }

    // pointer is no longer valid
    CMediaSample * pSamp = (CMediaSample *)pSample;
    pSamp->SetPointer(NULL, 0);

    return CBaseAllocator::ReleaseBuffer(pSample);
}

// free all the CMediaSample objects. Called from base class when
// in decommit state (after StopStreaming) when all the buffers
// are on the free list
void
CSubAllocator::Free(void)
{
    CAutoLock lck(this);

    // Should never be deleting this unless all buffers are freed
    ASSERT(m_lAllocated == m_lFree.GetCount());

    //* Free up all the CMediaSamples

    while (m_lFree.GetCount() != 0) {
        delete m_lFree.RemoveHead();
    }

    // empty the lists themselves
    m_lAllocated = 0;

    // Tell the base class
    m_bChanged = TRUE;

    // done
    return;
}	

//
//  Allocate our samples

HRESULT
CSubAllocator::Alloc(void)
{
    CAutoLock lck(this);

    DbgLog((LOG_TRACE, 3, TEXT("CSubAllocator::Alloc()")));

    // check with base that it is ok to do the alloc
    HRESULT hr = CBaseAllocator::Alloc();

    // Note that S_FALSE actually means that everthing is already
    // allocated and OK - see base class.
    if (hr != S_OK) {
	return hr;
    }

    ASSERT(m_lCount > 0);
    ASSERT(m_lAllocated == 0);

    m_bChanged = FALSE;

    return S_OK;
}

// this is called to create new CMediaSample objects. If you want to
// use objects derived from CMediaSample, override this to create them.
CMediaSample*
CSubAllocator::NewSample()
{
    HRESULT hr = S_OK;
    CMediaSample* pSamp = new CMediaSample(NAME("File media sample"), this, &hr);

    if (FAILED(hr)) {
	delete pSamp;
	return NULL;
    } else {
	return pSamp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\strmaloc\test\gen.h ===
// Copyright (c) Microsoft Corporation 1996. All Rights Reserved

/*  Generate a stream of data of known contents */

class CGenerate
{
public:
    CGenerate() {};
    BYTE ByteAt(LONGLONG ll) { return (BYTE)(ll & 0xFF); };
    void FillBuffer(PBYTE pb, LONGLONG llPos, LONG l)
    {
        for (int i = 0; i < l; i++) {
            pb[i] = ByteAt(llPos + i);
        }
    };
    BOOL CheckBuffer(PBYTE pb, LONGLONG llPos, LONG l)
    {
        for (int i = 0; i < l; i++) {
            if (pb[i] != ByteAt(llPos + i)) {
                return FALSE;
            }
        }
        return TRUE;
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\strmaloc\inc\buffers.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

/*

    File buffers.h

    Description

        Defines 2 classes :

           CCircularBuffer     - creates a circular buffer
           CCircularBufferList - creates a set of buffers mapped on a buffer


        CCircularBuffer
        ---------------

        The buffer created by CCircularBuffer looks as follows :


        <--------------- lTotalSize ------------------> <-- lMaxContig ----->
        ---------------------------------------------------------------------
       | abc ............pqr....................... xyz|abc ..............pqr|
        ---------------------------------------------------------------------

        A
        |

   GetPointer()


        Any data inserted at the start also appears just after the end.  This
        is done by making the page tables point twice at the same memory.

        GetPointer() returns the start of the buffer


        CCircularBufferList
        -------------------

        CCircularBufferList creates a circular buffer which is divided into
        a set of sub-buffers, all the same length, and implements a 'valid
        region' :

        ---------------------------------------------------------------------
       | buffer 0  | buffer 1  | buffer 2  | buffer 3  | shadow              |
        ---------------------------------------------------------------------

        The Append() method adds a buffer to the (end of) the valid region.
        If EOS is specified on Append() then the buffer appended can be
        non-full, otherwise it must be full.  No buffers are accepted after
        EOS is specified until Reset() is issued.

        The Remove() method removes a buffer from the valid region.

        Reset() removes the whole valid region.

        LengthValid() returns the total amount of data in the valid region.

        LengthContigous(pb) returns the amount of the valid region visible
        from pb.

        AdjustPointer(pb) maps a pointer (which may be in the shadow area) to
        its equvalent in the main buffer.

*/

#ifndef __BUFFERS_H__

#define __BUFFERS_H__

// CCircularBuffer
//
// Create a buffer which wraps on itself so you can always see
// at least a given amount of data
//
class CCircularBuffer
{
public:
    // Constructor and destructor

    CCircularBuffer(LONG lTotalSize,           // Total data size
                    LONG lMaxContig,           // How much contiguous?
                    HRESULT& hr);              // Check this return!
    ~CCircularBuffer();

    //  Use this static member so the allocator can precompute stuff
    //  for SetCountAndSize
    static HRESULT ComputeSizes(LONG& lSize, LONG& cBuffers, LONG lMaxContig);

    // Where the buffer starts
    PBYTE GetPointer() const;

private:
    static BOOL    CheckSizes(LONG lTotalSize, LONG lMaxConfig);
           HRESULT CreateMappings(HANDLE hMapping);
    static LONG    AlignmentRequired();

protected:
    /*  Data members */
          PBYTE  m_pBuffer;
    const LONG   m_lTotalSize;
    const LONG   m_lMaxContig;

};

/*  Build a class on top of the circular buffer which creates a list
    of equal sized buffers.

    The buffer is the unit of allocation for our allocator.
*/
class CCircularBufferList : public CCircularBuffer, public CBaseObject
{
public:
    CCircularBufferList(
                LONG     cBuffers,
                LONG     lSize,
                LONG     lMaxContig,
                HRESULT& hr);

    ~CCircularBufferList();

    int Index(PBYTE pBuffer);
    BOOL Append(PBYTE pBuffer, LONG lSize);
    LONG Remove(PBYTE pBuffer);
    LONG Offset(PBYTE pBuffer) const;
    PBYTE GetBuffer(LONG lOffset) const;
    LONG BufferSize() const;
    LONG LengthValid() const;
    LONG TotalLength() const
    {
        return m_lTotalSize;
    };
    LONG LengthContiguous(PBYTE pb) const;
    BOOL EOS() const;
    void SetEOS() { m_bEOS = TRUE; };
    PBYTE AdjustPointer(PBYTE pBuf) const;
    BOOL Valid(PBYTE pBuffer);
    void Reset();

private:
    PBYTE NextBuffer(PBYTE pBuffer);
    BOOL ValidBuffer(PBYTE pBuffer);
    PBYTE LastBuffer();

private:
    //  Remember our parameters
    const LONG  m_lSize;
    const LONG  m_lCount;

    //  Define the valid region of the buffer in terms start, buffers and
    //  length
    LONG        m_cValid;
    PBYTE       m_pStartBuffer;
    LONG        m_lValid;

    //  End of stream?
    BOOL        m_bEOS;
};

#endif // __BUFFERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\strmaloc\inc\stmalloc.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

//
// CStreamAllocator
//
// an allocator of IMediaSample objects, and implementation of IMemAllocator
// for streaming file-reading tasks
//

// additionally, CStreamAllocator is an IMemAllocator implementation
// and provides support for
//  -- creating IMediaSample interfaces for specified regions of file
//  -- ensuring contiguity for IMediaSample-mapped regions
//
//

class CCircularBufferList;

class CStreamAllocator : public CBaseAllocator
{
public:

    // Constructor and Destructor
    CStreamAllocator(TCHAR *, LPUNKNOWN, HRESULT *, LONG lMaxContig);
    ~CStreamAllocator();

    // CBaseAllocator Overrides

    // we have to be based on CBaseAllocator in order to use CMediaSample.
    // we use CBaseAllocator to manage the list of CMediaSample objects, but
    // override most of the functions as we dont support GetBuffer directly.

    STDMETHODIMP SetProperties(
        ALLOCATOR_PROPERTIES * pRequest,
        ALLOCATOR_PROPERTIES * pActual
    );

    //  Get the next buffer
    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer,
                           REFERENCE_TIME *pStartTime,
                           REFERENCE_TIME *pEndTime,
                           DWORD dwFlags);

protected:
    // this is pure virtual in CBaseAllocator, and so we must override.
    virtual void    Free(void);
    virtual HRESULT Alloc(void);

public:
    // Stuff to generate samples for an output pin and to scan the
    // data without it going away

    // Lock data and get a pointer
    // If we're at the end of the file cBytes can be modified.
    // It's an error to ask for more than m_lMaxContig bytes
    HRESULT LockData(PBYTE pData, LONG& cBytes);

    // Unlock data
    HRESULT UnlockData(PBYTE ptr, LONG cBytes);

    // Get a buffer back from the upstream filter
    HRESULT Receive(PBYTE pData, LONG lData);

    // Set a new start position
    void SetStart(LONGLONG llPos);

    // End of stream
    void EndOfStream()
    {
        m_pBuffer->SetEOS();
    };

    PBYTE GetPosition() const
    {
        return m_pCurrent;
    };

    LONG CurrentOffset() const
    {
        return m_bEmpty ? m_pBuffer->LengthValid() :
                          m_pBuffer->Offset(m_pCurrent);
    };

    LONGLONG GetCurrentOffset() const
    {
        return m_llPosition;
    };

    void ResetPosition();

    LONG LengthValid() const
    {
        return m_bEmpty ? 0 : m_pBuffer->LengthContiguous(m_pCurrent);
    };

    LONG TotalLengthValid() const
    {
        return m_bEmpty ? 0 :
                   m_pBuffer->LengthValid() - m_pBuffer->Offset(m_pCurrent);
    };

    // Advance our parsing pointer, freeing data no longer needed
    BOOL Advance(LONG lAdvance);

    // Seek to a fixed position if the data is in the buffer
    BOOL Seek(LONGLONG llPos);

    // Request that the reeder seek
    //
    BOOL SeekTheReader(LONGLONG llPos);

    // Number of free buffers
    BOOL IsBlocked()
    {
        CAutoLock lck(this);
        return m_lWaiting != 0;
    }

private:
    void LockUnlock(PBYTE pData, LONG cBytes, BOOL Lock);
    void ReallyFree();

private:
    CCircularBufferList * m_pBuffer;         // Circular buffer
    const LONG            m_lMaxContig;      // Max contig requirement

    /*  Track position of samples received */
    int                   m_NextToAllocate;
    PBYTE                 m_pCurrent;
    BOOL                  m_bEmpty;          // m_pCurrent is just
                                             // after valid data
    LONGLONG              m_llPosition;      // Position in stream
    BOOL                  m_bPositionValid;  // Have we had a SetStart
                                             // since the last ResetPosition?

    BOOL                  m_bSeekTheReader;  // force reader to seek on next
    LONGLONG              m_llSeekTheReader; // get buffer

#ifdef DEBUG
    BOOL                  m_bEventSet;
#endif

    /*  Sample elements */
    IMediaSample       ** m_pSamples;
};

//  Minimal allocator so that we get a different ReleaseBuffer callback
//  Plus allocate samples on top of a CStreamAllocator's memory
//
// you can call GetSample to lock a range and get an IMediaSample* back that
// references this data. You can call SetProperties to set limits on the
// number of IMediaSamples available and the maximum size of each lock.
// Multiple successive calls to SetProperties will cause it to take the
// smallest value for each figure.
//

class CSubAllocator : public CBaseAllocator
{
public:
    CSubAllocator(TCHAR            * Name,
                  LPUNKNOWN          pUnk,
                  CStreamAllocator * pAllocator,
                  HRESULT          * phr);
    ~CSubAllocator();
    STDMETHODIMP SetProperties(
        ALLOCATOR_PROPERTIES * pRequest,
        ALLOCATOR_PROPERTIES * pActual
    );

    // Just return an error
    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer,
                           REFERENCE_TIME *pStartTime,
                           REFERENCE_TIME *pEndTime,
                           DWORD dwFlags);

    // called by CMediaSample to return it to the free list and
    // block any pending GetSample call.
    STDMETHODIMP ReleaseBuffer(IMediaSample * pSample);
    // obsolete: virtual void PutOnFreeList(CMediaSample * pSample);

    // call this to get a CMediaSample object whose data pointer
    // points directly into the read buffer for the given pointer.
    // The length must not be greater than MaxContig.
    HRESULT GetSample(PBYTE pData, LONG cBytes, IMediaSample** ppSample);

protected:
    // this is pure virtual in CBaseAllocator, and so we must override.
    virtual void Free(void);
    virtual HRESULT Alloc(void);

    // this is called to create new CMediaSample objects. If you want to
    // use objects derived from CMediaSample, override this to create them.
    virtual CMediaSample* NewSample();

private:
    CStreamAllocator * const m_pStreamAllocator;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\strmaloc\test\tests.cpp ===
// Copyright (c) Microsoft Corporation 1996. All Rights Reserved

/*
    Tests for buffer list and stream allocator code

*/


#include <streams.h>
#include <tstshell.h>
#include <testfuns.h>
#include <buffers.h>
#include <stmalloc.h>
#include <tstshell.h>
#include "gen.h"
#include "strmtest.h"

BOOL bFreed = FALSE;
BOOL bSubFreed = FALSE;

/*  Track destruction */
class CTestAllocator : public CStreamAllocator
{
public:
    CTestAllocator(HRESULT * hr, LONG lMaxContig) :
        CStreamAllocator(NAME("Test Allocator"), NULL, hr, lMaxContig)
    {
        bFreed = FALSE;
    };
    ~CTestAllocator()
    {
        bFreed = TRUE;
    };
};

class CTestSubAllocator : public CSubAllocator
{
public:
    CTestSubAllocator(HRESULT * hr, CStreamAllocator *pStream) :
        CSubAllocator(NAME("Test SubAllocator"), NULL, pStream, hr)
    {
        bSubFreed = FALSE;
        ALLOCATOR_PROPERTIES propRequest, propActual;
        propRequest.cBuffers = 50;
        propRequest.cbBuffer = 20000;
        propRequest.cbAlign = 1;
        propRequest.cbPrefix = 0;

        SetProperties(&propRequest, &propActual);
    };
    ~CTestSubAllocator()
    {
        bSubFreed = TRUE;
    };
};

class CTestError
{
public:
    CTestError(int iTestError)
    {
        m_iError = iTestError;
    };
    int ErrorCode() { return m_iError; };

private:
    int   m_iError;
};

int FillAllocator(CStreamAllocator *pAlloc, LONGLONG llStart, LONG lBytes)
{
    LONGLONG llPos = llStart;
    //  Set the start position - otherwise the allocator won't accept anything!
    pAlloc->SetStart(0);
    while (lBytes != 0) {
        IMediaSample *pSample;
        if (FAILED(pAlloc->GetBuffer(&pSample,NULL,NULL,0))) {
            tstLog(TERSE, "GetBuffer failed in FillAllocator");
            return TST_FAIL;
        }
        PBYTE pb;
        if (FAILED(pSample->GetPointer(&pb))) {
            tstLog(TERSE, "GetPointer failed in FillAllocator");
            return TST_FAIL;
        }
        LONG lSize = pSample->GetSize();
        if (lSize > lBytes) {
            lSize = lBytes;
        }
        CGenerate gen;
        gen.FillBuffer(pb, llPos, lSize);
        pSample->SetActualDataLength(lSize);
        REFERENCE_TIME tStart;
        tStart = llPos;
        llPos += lSize;
        lBytes -= lSize;
        REFERENCE_TIME tStop;
        tStop = llPos;
        pSample->SetTime(&tStart, &tStop);

        if (FAILED(pAlloc->Receive(pb, lSize))) {
            tstLog(TERSE, "Receive() failed in FillAllocator");
            return TST_FAIL;
        }
        if (lBytes == 0) {
            pAlloc->EndOfStream();
        }
    }
    return TST_PASS;
}

/*  Test allocator samples */
int TestSamples(IMemAllocator *pAlloc, LONG lCountActual, LONG lSizeActual)
{
    tstLog(VERBOSE, "Get and Release all samples");
    tstLogFlush();

    /*  Now try to get a few buffers  - we should be able to get lCountActual!*/
    IMediaSample **ppSample = new PMEDIASAMPLE[lCountActual];
    for (int i = 0; i < lCountActual; i++) {
        PBYTE    pbStart, pbRealStart;
        if (FAILED(pAlloc->GetBuffer(&ppSample[i],NULL,NULL,0))) {
            tstLog(TERSE, "Failed to get sample");
            return TST_FAIL;
        }
        REFERENCE_TIME tStart = 0, tStop = 1;
        if (FAILED(ppSample[i]->SetTime(&tStart, &tStop))) {
            tstLog(TERSE, "Failed to set start and stop times");
            return TST_FAIL;
        }
        if (FAILED(ppSample[i]->GetTime(&tStart, &tStop))) {
            tstLog(TERSE, "Failed to get start and stop times");
            return TST_FAIL;
        }
        if (FAILED(ppSample[i]->GetPointer(&pbStart))) {
            tstLog(TERSE, "Failed to get sample pointer");
            return TST_FAIL;
        }
        LONG lSampleSize = ppSample[i]->GetSize();
        if (lSampleSize != lSizeActual) {
            tstLog(TERSE, "Sample size wrong - expected %d, got %d",
                             lSizeActual, lSampleSize);
            return TST_FAIL;
        }
        if (i == 0) {
            pbRealStart = pbStart;
        } else {
            pbRealStart += lSizeActual;
            if (pbRealStart != pbStart) {
                tstLog(TERSE, "Sample start wrong - expected 0x%8.8X, got 0x%8.8X",
                       pbRealStart, pbStart);
                return TST_FAIL;
            }
        }
    }
    /*  Release all the samples */
    for (i = 0; i < lCountActual; i++) {
        ppSample[i]->Release();
    }
    return TST_PASS;
}

/*  Test the special allocator functions of CStreamAllocator */
int TestSeek(CStreamAllocator *pAlloc,
              CSubAllocator *pSubAlloc,
              LONG lCount,
              LONG lSize,
              LONG lRealSize,
              LONG lMaxContig)
{
    tstLog(VERBOSE, "Seeking tests");
    tstLogFlush();
    int result;

    /* Seek(0) should fail if there is no data */
    if (pAlloc->Seek(0)) {
        tstLog(TERSE, "Seek(0) succeeded with no data");
        return TST_FAIL;
    }

    /* Put some data in the buffer and seek around a bit */
    result = FillAllocator(pAlloc, (LONGLONG)0, lCount * lSize - 1);
    if (result != TST_PASS) {
        return result;
    }

    /* Do a bit of seeking and locking */
    if (!pAlloc->Advance(lCount + 25)) {
        tstLog(TERSE, "Advance(lCount + 25) failed in TestSeek");
        return TST_FAIL;
    }
    if (!pAlloc->Advance(lCount * lSize - 1 - (lCount + 25))) {
        tstLog(TERSE, "Advance(end) failed in TestSeek");
        return TST_FAIL;
    }

    if (pAlloc->LengthValid() != 0) {
        tstLog(TERSE, "LengthValid() non-zero at end of data");
        return TST_FAIL;
    }

    /* Advance(0) should succeed if we are at the end of data */
    if (!pAlloc->Advance(0)) {
        tstLog(TERSE, "Advance(0) failed at end of data");
        return TST_FAIL;
    }

    /* Seek(0) should succeed if we are at the end of data */
    if (!pAlloc->Seek(0)) {
        tstLog(TERSE, "Seek(0) failed at end of data");
        return TST_FAIL;
    }

    /*  Seek back to where we were */
    for (int i = 0; i <= 90; i++) {
        if (!pAlloc->Seek(((lCount * lSize - 1) * i) / 90)) {
            tstLog(TERSE, "Seek(xxx) failed");
            return TST_FAIL;
        }
    }

    for (i = 0; i <= 90; i++) {
        if (!pAlloc->Seek(((lCount * lSize - 1) * (90 - i)) / 90)) {
            tstLog(TERSE, "Seek(xxx) failed");
            return TST_FAIL;
        }
    }
    if (pAlloc->LengthValid() != lCount * lSize - 1) {
        tstLog(TERSE, "Wrong length valid");
        return TST_FAIL;
    }
    /*  Lock a few bits'n pieces */
    IMediaSample *Samples[12];
    for (int j = 0; j < 12; j++) {
        LONG lOffset = ((lCount * lSize - 1) * j) / 12;
        LONG lLen    = lRealSize - 1;
        if (lCount * lSize - 1 < lOffset + lLen) {
            lLen = lCount * lSize - lOffset - 1;
        }
        HRESULT hr = pSubAlloc->GetSample(pAlloc->GetPosition() + lOffset,
                                          lLen,
                                          &Samples[j]);
        if (FAILED(hr)) {
            tstLog(TERSE, "GetSample at offset %d length %d failed code 0x%8.8X",
                   lOffset, lLen, hr);
            return TST_FAIL;
        }
    }
    for (i = 0; i <= 90; i++) {
        if (!pAlloc->Seek(((lCount * lSize - 1) * i) / 90)) {
            tstLog(TERSE, "Seek(xxx) failed");
            return TST_FAIL;
        }
    }
    for (j = 0; j < 12; j++) {
        Samples[j]->Release();
    }

    /*  Cycle the samples */
    result = TestSamples(pAlloc, lCount, lSize);
    if (result != TST_PASS) {
        return result;
    }

    /* Seek(0) should fail if there's no data */
    tstLog(VERBOSE | FLUSH, "Seek to 0 after all samples freed");
    if (pAlloc->Seek(0)) {
        tstLog(TERSE, "Seek(0) succeded with no data (2nd invocation)");
        return TST_FAIL;
    }
    tstLog(VERBOSE | FLUSH, "End Seeking tests");
    return TST_PASS;
}


/*  Test allocator */

int TestAllocator(LONG lCount, LONG lSize, LONG lAlign, LONG lMaxContig)
{
    HRESULT hr = E_FAIL;
    int result;
    tstLog(VERBOSE, "Testing allocator Count = %d, Size = %d, Align = %d, MaxContig = %d",
           lCount, lSize, lAlign, lMaxContig);
    tstLogFlush();

    CStreamAllocator *pAlloc = new CTestAllocator(&hr,
                                                 lMaxContig);
    if (SUCCEEDED(hr)) {
        tstLog(TERSE, "CStreamAllocator constructor changed bad return code");
        return TST_FAIL;
    }

    delete pAlloc;
    hr = S_OK;
    pAlloc = new CTestAllocator(&hr,
                                lMaxContig);

    if (FAILED(hr)) {
        delete pAlloc;
        tstLog(TERSE, "Failed to create allocator");
        return TST_FAIL;
    }

    pAlloc->AddRef();

    CSubAllocator *pSubAlloc = new CTestSubAllocator(&hr, pAlloc);
    if (FAILED(hr)) {
        delete pSubAlloc;
        tstLog(TERSE, "Failed to create sub allocator");
        return TST_FAIL;
    }

    pSubAlloc->AddRef();

    /*  Test SetProperties */
    ALLOCATOR_PROPERTIES propRequest;
    propRequest.cBuffers = lCount;
    propRequest.cbBuffer = lSize;
    propRequest.cbAlign = lAlign;
    propRequest.cbPrefix = 0;
    ALLOCATOR_PROPERTIES propActual;
    if (FAILED(pAlloc->SetProperties(&propRequest, &propActual))) {
        tstLog(TERSE, "SetProperties Failed");
        return TST_FAIL;
    }
    LONG lSizeActual = propActual.cbBuffer;
    LONG lCountActual = propActual.cBuffers;
    LONG lAlignActual = propActual.cbAlign;

    ASSERT(lSizeActual != 0 && lCountActual != 0 && lAlignActual != 0);
    tstLog(VERBOSE, "Allocator actuals Count = %d, Size = %d, Align = %d",
           lCountActual, lSizeActual, lAlignActual);

    /*  Try to get a sample when not committed */
    IMediaSample *pSample;
    if (SUCCEEDED(pAlloc->GetBuffer(&pSample,NULL,NULL,0))) {
        tstLog(TERSE, "Got a sample while decommitted !");
        return TST_FAIL;
    }

    if (FAILED(pAlloc->Commit())) {
        tstLog(TERSE, "Commit failed!");
        return TST_FAIL;
    }

    /*  Test all the samples twice */
    result = TestSamples(pAlloc, lCountActual, lSizeActual);
    if (result != TST_PASS) {
        return result;
    }
    result = TestSamples(pAlloc, lCountActual, lSizeActual);
    if (result != TST_PASS) {
        return result;
    }

    pAlloc->Decommit();

    if (SUCCEEDED(pAlloc->GetBuffer(&pSample,NULL,NULL,0))) {
        tstLog(TERSE, "Got a sample while decommitted !");
        return TST_FAIL;
    }

    if (FAILED(pAlloc->Commit())) {
        tstLog(TERSE, "Commit failed!");
        return TST_FAIL;
    }
    pSubAlloc->Commit();

    /*  OK - now do some real work */
    result = TestSeek(pAlloc, pSubAlloc, lCountActual, lSizeActual, lSize, lMaxContig);
    if (result != TST_PASS) {
        return result;
    }

    pSubAlloc->Decommit();

    /*  Now see what happens when we Release() */
    if (0 != pSubAlloc->Release()) {
        tstLog(TERSE, "Failed to Release allocator");
        return TST_FAIL;
    }

    pAlloc->Decommit();

    if (0 != pAlloc->Release()) {
        tstLog(TERSE, "Failed to Release allocator");
        return TST_FAIL;
    }
    if (!bFreed) {
        tstLog(TERSE, "Allocator failed to free itself!");
        return TST_FAIL;
    }
    if (!bSubFreed) {
        tstLog(TERSE, "SubAllocator failed to free itself!");
        return TST_FAIL;
    }
    return TST_PASS;
}

STDAPI_(int) Test1()
{
    tstLog(TERSE, "Entering test #1");
    tstLogFlush();
    int result = TST_PASS;
    result = TestAllocator(10, 10000, 1, 15000);
    if (result != TST_PASS) {
        tstLog(TERSE, "Exiting test #1");
        tstLogFlush();
        return result;
    }
    result = TestAllocator(1, 20000, 4, 20000);
    if (result != TST_PASS) {
        tstLog(TERSE, "Exiting test #1");
        tstLogFlush();
        return result;
    }
    result = TestAllocator(50, 2, 1, 3);
    if (result != TST_PASS) {
        tstLog(TERSE, "Exiting test #1");
        tstLogFlush();
        return result;
    }
    tstLog(TERSE, "Exiting test #1");
    tstLogFlush();
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\strmaloc\test\strmtest.h ===
/***************************************************************************\
*                                                                           *
*   File: StrmTest.h                                                        *
*                                                                           *
*   Copyright (c) 1996 Microsoft Corporation.  All rights reserved          *
*                                                                           *
\***************************************************************************/


// Prototypes



// From tests.cpp
STDAPI_(int) Test1();
STDAPI_(int) Test2();

// Constants

// Stops the logging intensive test
#define VSTOPKEY            VK_SPACE


// The string identifiers for the group's names
#define GRP_STREAM          100
#define GRP_Q               101
#define GRP_LAST            GRP_Q

// The string identifiers for the test's names
#define ID_TEST1           200
#define ID_TEST2           201
#define ID_TESTLAST        ID_TEST2

// The test case identifier (used in the switch statement in execTest)
#define FX_TEST1            300
#define FX_TEST2            301

// Identifies the test list section of the resource file
#define TEST_LIST           500

// Global variables

extern HWND         ghwndTstShell;      // Handle to test shell main window
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\strmaloc\test\strmtest.cpp ===
//--------------------------------------------------------------------------;
//
//  File: StrmTest.cpp
//
//  Copyright (c) 1993,1996 Microsoft Corporation.  All rights reserved
//
//  Abstract:
//
//  Contents:
//      tstGetTestInfo()
//      tstInit()
//      execTest()
//      tstTerminate()
//
//  History:
//      08/03/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

#include <streams.h>    // Streams architecture
#include <tstshell.h>   // Include file for the test shell's APIs
#include "StrmTest.h"   // Various includes, constants, prototypes, globals


// Globals

HWND    ghwndTstShell;  // A handle to the main window of the test shell.
                        // It's not used here, but may be used by test apps.

HINSTANCE hinst;        // A handle to the running instance of the test
                        // shell.  It's not used here, but may be used by
                        // test apps.

HMENU   hmenuOptions;   // A handle to the options menu

LPTSTR          szAppName = TEXT("Quartz stream allocator tests");

//--------------------------------------------------------------------------;
//
//  int tstGetTestInfo
//
//  Description:
//      Called by the test shell to get information about the test.  Also
//      saves a copy of the running instance of the test shell.
//
//      We also do most basic initialisation here (including instantiating
//      the test sink object) so that the custom profile handler can set
//      everything up when running automatically from a profile.
//
//  Arguments:
//      HINSTANCE hinstance: A handle to the running instance of the test
//          shell
//
//      LPSTR lpszTestName: Pointer to buffer of name for test.  Among
//          other things, it is used as a caption for the main window and
//          as the name of its class.  Always ANSI.
//
//      LPSTR lpszPathSection: Pointer to buffer of name of section in
//          win.ini in which the default input and output paths are
//          stored.  Always ANSI.
//
//      LPWORD wPlatform: The platform on which the tests are to be run,
//          which may be determined dynamically.  In order for a test to
//          be shown on the run list, it must have all the bits found in
//          wPlatform turned on.  It is enough for one bit to be turned off
//          to disqualify the test.  This also means that if this value is
//          zero, all tests will be run.  In order to make this more
//          mathematically precise, I shall give the relation which Test
//          Shell uses to decide whether a test with platform flags
//          wTestPlatform may run:  It may run if the following is TRUE:
//          ((wTestPlatform & wPlatform) == wPlatform)
//
//  Return (int):
//      The value which identifies the test list resouce (found in the
//      resource file).
//
//  History:
//      08/03/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

int tstGetTestInfo
(
    HINSTANCE   hinstance,
    LPSTR       lpszTestName,
    LPSTR       lpszPathSection,
    LPWORD      wPlatform
)
{
    hinst = hinstance;      // Save a copy of a handle to the running instance

    CoInitialize(NULL);            // Initialise COM library
    DbgInitialise(hinst);

    // It might have been nice to have this a few lines earlier
    // - but we gotta do DbgInitialise first!
    DbgLog((LOG_TRACE, 1, TEXT("Entering tstInit")));

    // Pass app name to test shell
#ifdef UNICODE
    WideCharToMultiByte(CP_ACP, 0, szAppName, -1, lpszTestName, 100, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, szAppName, -1, lpszPathSection, 100, NULL, NULL);
#else
    lstrcpy(lpszTestName, szAppName);
    lstrcpy(lpszPathSection, szAppName);
#endif

    *wPlatform = 0;         // The platform the test is running on, to be
                            // determined dynamically.
    return TEST_LIST;
} // tstGetTestInfo()




//--------------------------------------------------------------------------;
//
//  BOOL tstInit
//
//  Description:
//      Called by the test shell to provide the test program with an
//      opportunity to do whatever initialization it needs to do before
//      user interaction is initiated.  It also provides the test program
//      with an opportunity to keep a copy of a handle to the main window,
//      if the test program needs it.  In order to use some of the more
//      advanced features of test shell, several installation must be done
//      here:
//
//      -- All menu installation must be done here by calling
//          tstInstallCustomTest (that is, all menus that the test
//          application wants to add).
//
//      -- If the test application wants to trap the window messages of
//          the main test shell window, it must install its default
//          window procedure here by calling tstInstallDefWindowProc.
//
//      -- If the test application would like to use the status bar for
//          displaying the name of the currently running test, it must
//          call tstDisplayCurrentTest here.
//
//      -- If the test application would like to change the stop key from
//          ESC to something else, it must do so here by calling
//          tstChangeStopVKey.
//
//      -- If the test application would like to add dynamic test cases
//          to the test list, it must first add their names to the
//          virtual string table using tstAddNewString (and add their
//          group's name too), and then add the actual tests using
//          tstAddTestCase.  The virtual string table is an abstraction
//          which behaves just like a string table from the outside with
//          the exception that it accepts dynamically added string.
//
//  Arguments:
//      HWND hwndMain: A handle to the main window
//
//  Return (BOOL):
//      TRUE if initialization went well, FALSE otherwise which will abort
//      execution.
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

BOOL tstInit
(
    HWND    hwndMain
)
{
   // Keep a copy of a handle to the main window
    ghwndTstShell = hwndMain;

    // This is a shell API which tells Test Shell to display the name of
    // the currenly executing API in its status bar.  It is a really nice
    // feature for test applications which do not use the toolbar for any
    // other purpose, as it comfortably notifies the user of the progress
    // of the tests.
    tstDisplayCurrentTest();

    // Change the stop key from ESC to SPACE
    tstChangeStopVKey (VSTOPKEY);

    DbgLog((LOG_TRACE,1, TEXT("Exiting tstInit")));
    return(TRUE);
} // tstInit()




//--------------------------------------------------------------------------;
//
//  int execTest
//
//  Description:
//      This is the actual test function which is called from within the
//      test shell.  It is passed various information about the test case
//      it is asked to run, and branches off to the appropriate test
//      function.  Note that it needs not switch on nFxID, but may also
//      use iCase or wID.
//
//  Arguments:
//      int nFxID: The test case identifier, also found in the third column
//          in the third column of the test list in the resource file
//
//      int iCase: The test case's number, which expresses the ordering
//          used by the test shell.
//
//      UINT wID: The test case's string ID, which identifies the string
//          containing the description of the test case.  Note that it is
//          also a good candidate for use in the switch statement, as it
//          is unique to each test case.
//
//      UINT wGroupID: The test case's group's string ID, which identifies
//          the string containing the description of the test case's group.
//
//  Return (int): Indicates the result of the test by using TST_FAIL,
//          TST_PASS, TST_OTHER, TST_ABORT, TST_TNYI, TST_TRAN, or TST_TERR
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

int execTest
(
    int     nFxID,
    int     iCase,
    UINT    wID,
    UINT    wGroupID
)
{
    int ret = TST_OTHER;

    tstBeginSection(" ");

    switch(nFxID)
    {
        //
        //  The test cases
        //

        case FX_TEST1:
            ret = Test1();
            break;

        case FX_TEST2:
            ret = Test2();
            break;

        default:
            break;
    }

    tstEndSection();

    return(ret);

} // execTest()




//--------------------------------------------------------------------------;
//
//  void tstTerminate
//
//  Description:
//      This function is called when the test series is finished to free
//      structures and do whatever cleanup work it needs to do.  If it
//      needs not do anything, it may just return.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

void tstTerminate
(
    void
)
{
    DbgLog((LOG_TRACE, 1, TEXT("Entering tstTerminate")));

    DbgTerminate();
    CoUninitialize();

    DbgLog((LOG_TRACE, 1, TEXT("Exiting tstTerminate")));
    return;
} // tstTerminate()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\strmaloc\test\qtests.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved

#include <streams.h>
#include "src.h"
#include "sink.h"
#include "stmonfil.h"
#include "tstream.h"
#include "tstshell.h"
#include "qtests.h"


/*  Predeclare */
class CTestOutputQ;

/* -- CTestSink definitions -- */

CTestSink::CTestSink(CTestOutputQ *pTest, HRESULT *phr) :
    CSinkFilter(NULL, phr),
    m_pTest(pTest),
    m_nSamplesOK(0),
    m_nSamplesBad(0)
{
    CTestInputPin *pPin = new CTestInputPin(m_pTest,
                                            this,
                                            &m_CritSec,
                                            m_pTest->m_bBlockingPin,
                                            phr);
    m_pInputPin = pPin;
}

CTestSink::~CTestSink()
{
}

/* -- CTestInputPin definitions -- */

CTestInputPin::CTestInputPin(CTestOutputQ *pTest,
                             CTestSink *pFilter,
                             CCritSec *pLock,
                             BOOL bBlocking,
                             HRESULT *phr) :
    CSinkPin(pFilter, pLock ,phr),
    m_pTest(pTest),
    m_pTestFilter(pFilter),
    m_bReceiveCanBlock(bBlocking),
    m_bDiscontinuity(TRUE)
{
}

STDMETHODIMP CTestInputPin::ReceiveCanBlock()
{
    return m_bReceiveCanBlock ? S_OK : S_FALSE;
}

STDMETHODIMP CTestInputPin::ReceiveMultiple(IMediaSample **ppSamples,
                                            long nSamples,
                                            long *nSamplesProcessed)
{
    m_pTest->GotBatch(nSamples);
    DbgLog((LOG_TRACE, 3, TEXT("CTestInputPin::ReceiveMultiple %d samples"),
            nSamples));
    return CSinkPin::ReceiveMultiple(ppSamples, nSamples, nSamplesProcessed);
}
STDMETHODIMP CTestInputPin::Receive(IMediaSample * pSample)
{
    HRESULT hr;
    LONG    lBytes = pSample->GetActualDataLength();
    DbgLog((LOG_TRACE, 4, TEXT("CTestInputPin::Receive %d bytes"), lBytes));
    PBYTE pbData;
    pSample->GetPointer(&pbData);
    if (m_bDiscontinuity && pSample->IsDiscontinuity() != S_OK) {
        m_pTest->m_nUnexpected++;
    }
    m_bDiscontinuity = FALSE;
    if (m_bReceiveCanBlock) {
        hr = CSinkPin::Receive(pSample);
    } else {
        if (IsStopped()) {
            DbgLog((LOG_ERROR, 2, TEXT("Receive called when stopped!")));
            hr = E_FAIL;
        }
        hr = S_OK;
    }
    m_pTestFilter->SampleReceived(hr == S_OK);

    /*  Signal complete (if it is!) */
    m_pTest->GotBytes(pbData, lBytes);

    return hr;
}

STDMETHODIMP CTestInputPin::EndOfStream()
{
    DbgLog((LOG_TRACE, 3, TEXT("CTestInputPin::EndOfStream")));
    tstLog(VERBOSE, "Input pin received EndOfStream()");
    CSinkPin::EndOfStream();
    m_pTest->m_nEOS++;
    m_bDiscontinuity = TRUE;
    m_pTest->m_evComplete.Set();
    return S_OK;
}

STDMETHODIMP CTestInputPin::EndFlush()
{
    m_bDiscontinuity = TRUE;
    return CSinkPin::EndFlush();
}

/* -- CTestSource definitions -- */


CTestSource::CTestSource(CTestOutputQ *pTest,
                         IStream      *pStream,
                         LONG          lSize,
                         LONG          lCount,
                         HRESULT      *phr) :
    CSourceFilter(NULL, phr)
{
    m_pOutputPin = new CTestOutputPin(pTest,
                                      pStream,
                                      lSize,
                                      lCount,
                                      this,
                                      &m_CritSec,
                                      phr);
    if (m_pOutputPin == NULL) {
        *phr = E_OUTOFMEMORY;
    }
}

CTestSource::~CTestSource()
{
}


/* -- CTestOutputPin definitions -- */


CTestOutputPin::CTestOutputPin(
                   CTestOutputQ *pTest,
                   IStream *pStream,
                   LONG lSize,
                   LONG lCount,
                   CBaseFilter *pFilter,
                   CCritSec *pLock,
                   HRESULT *phr) :
    CSourcePin(pStream, TRUE, lSize, lCount, pFilter, pLock, phr),
    m_pTest(pTest)
{
}

CTestOutputPin::~CTestOutputPin()
{
}

HRESULT CTestOutputPin::Deliver(IMediaSample *pSample)
{
    /*  Fix the times to give reasonable results */
    REFERENCE_TIME tStart, tStop;
    pSample->GetTime(&tStart, &tStop);
    tStart =
        (tStart * (8 * 10000000)) / m_pTest->m_lBitsPerSec;
    pSample->SetTime(&tStart, &tStart);
    m_pTest->m_nSamplesSent++;

    /*  AddRef() it because the caller is going to Release() it and
        so is the output q
    */
    pSample->AddRef();
    return m_pTest->m_pQueue->Receive(pSample);
}


void CTestOutputPin::DoBeginFlush()
{
    DbgLog((LOG_TRACE, 3, TEXT("CTestOutputPin::DoBeginFlush()")));
    m_pTest->m_pQueue->BeginFlush();
}
void CTestOutputPin::DoEndFlush()
{
    DbgLog((LOG_TRACE, 3, TEXT("CTestOutputPin::DoEndFlush()")));
    m_pTest->m_pQueue->EndFlush();
    m_pTest->ResetCounts();
}

/*  Send EOS downstream */
void CTestOutputPin::DoEndOfStream()
{
    DbgLog((LOG_TRACE, 3, TEXT("CTestOutputPin::EndOfStream()")));
    m_pTest->m_pQueue->EOS();
}

/* -- CTestOutputQ -- */

CTestOutputQ::CTestOutputQ(BOOL bDefault,
                           BOOL bQueue,
                           BOOL bExact,
                           LONG lBatchSize,
                           BOOL bBlock,
                           LONG lSize,
                           LONG lCount,
                           LONG lBitsPerSecond,
                           LONGLONG llLength,
                           int *result) :
    m_pSink(NULL),
    m_pSource(NULL),
    m_pQueue(NULL),
    m_pStream(NULL),
    m_lBitsPerSec(lBitsPerSecond),
    m_bBlockingPin(bBlock),
    m_pClock(NULL),
    m_llLength(llLength),
    m_Connected(FALSE),
    m_lBatchSize(lBatchSize)
{
    /* The whole thing will hang if the batch size is NOT smaller than
       the allocator count
    */
    ASSERT(lBatchSize <= lCount);
    tstLog(TERSE | FLUSH, "Testing queue bAuto = %d, bBlock = %d, bExact = %d, batch size = %d, %d byte stream",
           bDefault, bBlock, bExact, lBatchSize, (LONG)llLength);

    HRESULT hr = S_OK;

    /*  Construct our components */

    m_pStream = new CIStreamOnFunction(NULL, llLength, llLength != 0, &hr);
    ASSERT(SUCCEEDED(hr));
    m_pStream->AddRef();

    m_pSource = new CTestSource(this, m_pStream, lSize, lCount, &hr);
    ASSERT(SUCCEEDED(hr));
    m_pSource->AddRef();

    m_pSink = new CTestSink(this, &hr);
    ASSERT(SUCCEEDED(hr));
    m_pSink->AddRef();

    m_pQueue = new COutputQueue(m_pSink->GetPin(0),
                                &hr,
                                bDefault,
                                bBlock,
                                lBatchSize,
                                bExact);
    if (FAILED(m_hr) || m_pQueue == NULL) {
        tstLog(TERSE, "Failed to initialize CTestOutputQ queue code 0x%8.8X", m_hr);
        *result = TST_FAIL;
        return;
    }
    // make a reference clock
    hr = CoCreateInstance(CLSID_SystemClock,
                          NULL,
                          CLSCTX_INPROC,
                          IID_IReferenceClock,
                          (void**) &m_pClock);
    ASSERT(SUCCEEDED(hr));

    m_pSource->SetSyncSource(m_pClock);
    m_pSink->SetSyncSource(m_pClock);
}

CTestOutputQ::~CTestOutputQ()
{
    delete m_pQueue;   // Delete this first to free the pin
    if (m_pSource != NULL) {
        m_pSource->Release();
    }
    if (m_pSink != NULL) {
        m_pSink->Release();
    }
    if (m_pStream != NULL) {
        m_pStream->Release();
    }
    if (m_pClock) {
        m_pClock->Release();
    }
}

/*  This is where we do all the testing! - this tells us what bytes we got */

void CTestOutputQ::GotBytes(PBYTE pbData, LONG lLength)
{
    DbgLog((LOG_TRACE, 4, TEXT("CTestOutputQ::GotBytes() %d bytes"), lLength));
    m_nBytes += lLength;
    tstLog(VERBOSE, "Received %d bytes out of %d", (LONG)m_nBytes, (LONG)m_llLength);
}

void CTestOutputQ::GotBatch(LONG nSamples)
{
    /*  Work out what size batch we expected based on the input
        parameters
    */
    if (nSamples > m_lBatchSize) {
        /*  How do we report errors? */
        tstLog(TERSE, "Batch too big - batch size is %d, got batch sized %d",
               m_lBatchSize, nSamples);
        Fail(TST_FAIL);
    }

    m_nSamplesReceived += nSamples;
}

void CTestOutputQ::ResetCounts()
{
    /*  Reset counts so they match if everything works */
    m_nEOS = 0;
    m_nBytes = 0;
    m_nSamplesReceived = 0;
    m_nSamplesSent = 0;

    m_evComplete.Reset();
}
int CTestOutputQ::TestConnect()
{
    TestStop();
    if (!m_Connected) {
        EXECUTE_ASSERT(
            SUCCEEDED(
                m_pSource->GetPin(0)->Connect(m_pSink->GetPin(0), NULL)
            )
        );
        m_Connected = TRUE;
    }
    return TST_PASS;
}

int CTestOutputQ::TestDisconnect()
{
    TestStop();
    if (m_Connected) {
        EXECUTE_ASSERT(
            SUCCEEDED(
                m_pSource->GetPin(0)->Disconnect()
            )
        );
        EXECUTE_ASSERT(
            SUCCEEDED(
                m_pSink->GetPin(0)->Disconnect()
            )
        );
        m_Connected = FALSE;
    }
    return TST_PASS;
}

int CTestOutputQ::TestPause()
{
    TestConnect();
    EXECUTE_ASSERT(
        SUCCEEDED(
            m_pSink->Pause()
        )
    );
    EXECUTE_ASSERT(
        SUCCEEDED(
            m_pSource->Pause()
        )
    );
    return TST_PASS;
}

int CTestOutputQ::TestRun()
{
    CRefTime tNow;
    m_pClock->GetTime((REFERENCE_TIME*)&tNow);
    EXECUTE_ASSERT(
        SUCCEEDED(
            m_pSink->Run(tNow + CRefTime(100L))
        )
    );
    EXECUTE_ASSERT(
        SUCCEEDED(
            m_pSource->Run(tNow + CRefTime(100L))
        )
    );
    return TST_PASS;
}

int CTestOutputQ::TestStop()
{
    EXECUTE_ASSERT(
        SUCCEEDED(
            m_pSink->Stop()
        )
    );
    EXECUTE_ASSERT(
        SUCCEEDED(
            m_pSource->Stop()
        )
    );
    return TST_PASS;
}

int CTestOutputQ::TestSend(DWORD dwFlushAfter)
{
    /*  Just connect the filters and set them running */
    int result;
    result = TestConnect();
    if (result != TST_PASS) {
        return result;
    }

    /*  Initialize our counters - these will be updated and checked
        by our GotBatch() and GotBytes() methods
    */
    /*  Reset counts so they match if everything works */

    m_nExpectedEOS = 1;
    m_nUnexpected = 0;

    ResetCounts();

    m_iResult = TST_PASS;
    //SetStart(0);
    //SetStop(nBytes);
    result = TestRun();
    if (result != TST_PASS) {
        return result;
    }

    /*  Allow our logging to take place */
    HANDLE h = m_evComplete;

    DWORD dwResult;
    while (TRUE)
    {
        dwResult = MsgWaitForMultipleObjects(1,
                                             &h,
                                             FALSE,
                                             dwFlushAfter,
                                             QS_ALLINPUT);
        if (dwResult == WAIT_OBJECT_0) {
            break;
        }
        if (dwResult == WAIT_TIMEOUT) {
            IMediaPosition *pPosition;
            m_pSink->QueryInterface(IID_IMediaPosition, (void **)&pPosition);
            ASSERT(pPosition != NULL);

            /*  Do a hack pause, seek and run */
            result = TestPause();
            if (result != TST_PASS) {
                return result;
            }
            //  'Play it again'
            pPosition->put_CurrentPosition(COARefTime());
            result = TestRun();
            if (result != TST_PASS) {
                return result;
            }

            tstLog(VERBOSE | FLUSH, "Replaying from 0");
            dwFlushAfter = INFINITE;
        } else {
            MSG  msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
    tstLog(VERBOSE, "Send complete");

    if (m_nBytes != m_llLength) {
        tstLog(TERSE, "Got wrong number of bytes! - expected %s, got %s",
               (LPCTSTR)CDisp(m_llLength, CDISP_HEX), (LPCTSTR)CDisp(m_nBytes, CDISP_HEX));
        m_iResult = TST_FAIL;
    }
    if (m_nEOS != m_nExpectedEOS) {
        tstLog(TERSE, "Got %d calls to EndOfStream! - expected %d",
               m_nEOS, m_nExpectedEOS);
        m_iResult = TST_FAIL;
    }
    if (m_nSamplesReceived != m_nSamplesSent) {
        tstLog(TERSE, "Got wrong number of samples! - expected %d, got %d",
               m_nSamplesSent, m_nSamplesReceived);
        m_iResult = TST_FAIL;
    }
    if (m_nUnexpected != 0) {
        tstLog(TERSE, "Got %d unexpected samples", m_nUnexpected);
        m_iResult = TST_FAIL;
    }

    return m_iResult;
}


/*  Create and test an output Q instance */
int TestOutputQ(BOOL bAuto,         //  COutputQueue initializers
                BOOL bQueue,        //      "             "
                BOOL bExact,        //      "             "
                LONG lBatchSize,    //      "             "
                BOOL bBlockingPin,  //
                LONG lSize,         //  Allocator initializers
                LONG lCount,        //      "             "
                LONG lBitsPerSec,   //  Affects rate of processing
                LONGLONG llLength)  //  Length of stream (0 means not seekable)
{
    int result = TST_PASS;
    CTestOutputQ testQ(bAuto, bQueue, bExact, lBatchSize, bBlockingPin, lSize,
                       lCount, lBitsPerSec, llLength, &result);
    if (result != TST_PASS) {
        return result;
    }
    result = testQ.TestSend(INFINITE);
    if (result != TST_PASS) {
        return result;
    }
    result = testQ.TestStop();
    if (result != TST_PASS) {
        return result;
    }
    result = testQ.TestSend(100);
    if (result != TST_PASS) {
        return result;
    }
    result = testQ.TestDisconnect();
    if (result != TST_PASS) {
        return result;
    }
    result = testQ.TestSend(INFINITE);
    if (result != TST_PASS) {
        return result;
    }
    result = testQ.TestDisconnect();
    if (result != TST_PASS) {
        return result;
    }
    return TST_PASS;
}

/*  Create our tests */
STDAPI_(int) Test2()
{
    DbgSetModuleLevel(LOG_TRACE, 1);
    DbgSetModuleLevel(LOG_ERROR, 2);

    /*  Instantiate a number of instances of CTestOutputQ and test them */
    tstLog(TERSE, "Entering test #2");
    tstLogFlush();
    int result;
    result =
        TestOutputQ(TRUE,              // bAuto
                    FALSE,             // bQueue
                    TRUE,              // bExact
                    2,                 // lBatchSize
                    FALSE,             // bBlockingPin
                    5000,              // lSize
                    2,                 // lCount
                    100000,            // lBitsPerSec
                    (LONGLONG)1);      // Length of stream in bytes
    if (result != TST_PASS) {
        tstLog(TERSE, "Exiting test #2");
        tstLogFlush();
        return result;
    }
    result =
        TestOutputQ(TRUE,              // bAuto
                    FALSE,             // bQueue
                    TRUE,              // bExact
                    2,                 // lBatchSize
                    TRUE,              // bBlockingPin
                    5000,              // lSize
                    2,                 // lCount
                    100000,            // lBitsPerSec
                    (LONGLONG)1);      // Length of stream in bytes
    if (result != TST_PASS) {
        tstLog(TERSE, "Exiting test #2");
        tstLogFlush();
        return result;
    }
    result =
        TestOutputQ(TRUE,              // bAuto
                    FALSE,             // bQueue
                    TRUE,              // bExact
                    10,                // lBatchSize
                    TRUE,              // bBlockingPin
                    500,               // lSize
                    20,                // lCount
                    100000,            // lBitsPerSec
                    (LONGLONG)100000); // Length of stream in bytes
    if (result != TST_PASS) {
        tstLog(TERSE, "Exiting test #2");
        tstLogFlush();
        return result;
    }
    result =
        TestOutputQ(TRUE,              // bAuto
                    FALSE,             // bQueue
                    TRUE,              // bExact
                    2,                 // lBatchSize
                    FALSE,             // bBlockingPin
                    5000,              // lSize
                    2,                 // lCount
                    100000,            // lBitsPerSec
                    (LONGLONG)200000); // Length of stream in bytes
    if (result != TST_PASS) {
        tstLog(TERSE, "Exiting test #2");
        tstLogFlush();
        return result;
    }
    result =
        TestOutputQ(TRUE,              // bAuto
                    FALSE,             // bQueue
                    TRUE,              // bExact
                    5,                 // lBatchSize
                    FALSE,             // bBlockingPin
                    49,                // lSize
                    11,                // lCount
                    100000,            // lBitsPerSec
                    (LONGLONG)200000); // Length of stream in bytes
    if (result != TST_PASS) {
        tstLog(TERSE, "Exiting test #2");
        tstLogFlush();
        return result;
    }
    result =
        TestOutputQ(TRUE,              // bAuto
                    FALSE,             // bQueue
                    TRUE,              // bExact
                    5,                 // lBatchSize
                    FALSE,             // bBlockingPin
                    49,                // lSize
                    11,                // lCount
                    100000,            // lBitsPerSec
                    (LONGLONG)0);      // Length of stream in bytes
    if (result != TST_PASS) {
        tstLog(TERSE, "Exiting test #2");
        tstLogFlush();
        return result;
    }
    result =
        TestOutputQ(TRUE,              // bAuto
                    FALSE,             // bQueue
                    TRUE,              // bExact
                    5,                 // lBatchSize
                    TRUE,              // bBlockingPin
                    49,                // lSize
                    11,                // lCount
                    100000,            // lBitsPerSec
                    (LONGLONG)0);      // Length of stream in bytes
    if (result != TST_PASS) {
        tstLog(TERSE, "Exiting test #2");
        tstLogFlush();
        return result;
    }
    result =
        TestOutputQ(TRUE,              // bAuto
                    FALSE,             // bQueue
                    FALSE,             // bExact
                    5,                 // lBatchSize
                    TRUE,              // bBlockingPin
                    49,                // lSize
                    11,                // lCount
                    100000,            // lBitsPerSec
                    (LONGLONG)0);      // Length of stream in bytes
    if (result != TST_PASS) {
        tstLog(TERSE, "Exiting test #2");
        tstLogFlush();
        return result;
    }
    result =
        TestOutputQ(TRUE,              // bAuto
                    FALSE,             // bQueue
                    FALSE,             // bExact
                    5,                 // lBatchSize
                    TRUE,              // bBlockingPin
                    49,                // lSize
                    11,                // lCount
                    100000,            // lBitsPerSec
                    (LONGLONG)91919);  // Length of stream in bytes
    if (result != TST_PASS) {
        tstLog(TERSE, "Exiting test #2");
        tstLogFlush();
        return result;
    }
    tstLog(TERSE, "Exiting test #2");
    tstLogFlush();
    return TST_PASS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\util\code\callback.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

#include <streams.h>
#include "callback.h"

const int LOG_CALLBACK_RELATED = 5 ;
const   int TGT_CALLBACK_TOKEN = 0x99999999 ;

// implementation of callback thread object

CCallbackThread::CCallbackThread(CCritSec* pCritSec)
  : m_pCritSec(pCritSec),
    m_hThread(NULL),
    m_evUser(0),
    m_pClock(NULL),
    m_fAbort(FALSE),	// thread carries on until this is set
    m_evSignalThread(TRUE),	// manual reset
    m_evAdvise(TRUE),	// manual reset
    m_Items(NAME("Callback Item list")),
    m_dwAdvise(0),
    m_dwTGTCallbackToken (0),
    m_fnTGTCallback (NULL),
    m_dwNextTGTCallback (0),
    m_dwTGTCallbackPeriod (0),
    m_dwScheduleCookie(0)
{

}

// should not be holding the critsec during this destructor
// in case the worker thread is attempting to lock it
CCallbackThread::~CCallbackThread()
{
    // cancel any advise with the clock
    CancelAdvise();

    //make sure the exits
    CloseThread();

    // clean up list of outstanding requests
    POSITION pos = m_Items.GetHeadPosition();
    while(pos) {
        CAdviseItem* pItem = m_Items.GetNext(pos);
        delete pItem;
    }
    m_Items.RemoveAll();

}

HRESULT
CCallbackThread::SetSyncSource(IReferenceClock* pClock)
{
    CAutoLock lock(m_pCritSec);

    // cancel existing advise
    CancelAdvise();

    // don't need to addref pClock since we will get a
    // SetSyncSource(NULL) before it goes away

    m_pClock = pClock;

    // set up advise on new clock
    SetAdvise();

    return S_OK;
}


// queue a request to callback a given function. returns a token that can
// be passed to Cancel.
//
// The token is actually a pointer to the CAdviseItem*

HRESULT
CCallbackThread::Advise(
    CCallbackAdvise fnAdvise,
    DWORD_PTR dwUserToken,
    REFERENCE_TIME rtCallbackAt,
    DWORD_PTR* pdwToken
)	
{
    // use this to lock all our structures as well as
    // callbacks
    CAutoLock lock(m_pCritSec);

    // need a clock to do this
    if (!m_pClock) {
        return VFW_E_NO_CLOCK;
    }

    // first create an item to hold the info
    ASSERT(rtCallbackAt > 0);
    CAdviseItem* pItem = new CAdviseItem(fnAdvise, dwUserToken, rtCallbackAt);
    if (!pItem) {
        return E_OUTOFMEMORY;
    }

    // cheap version: we don't sort the list -- we find the soonest
    // time whenever we need it.
    m_Items.AddTail(pItem);

    // force a recheck of the advise
    SetAdvise();

    // the token we return is a pointer to the object
    *pdwToken = (DWORD_PTR) pItem;
    return S_OK;
}

// AdvisePeriodicWithEvent is currently called by the DSound renderer to
// schedule a periodic callback that needs to happen irrespective of how
// the reference clock is behaving. We do not link this to the clock's
// callback mechanism, but handle this separately using timeGetTime. Refer
// to the ThreadProc code to see how this is done.
//
// We can deal with only one such event.
//
// The token returned is a magic signature.
//
// IF hUser is not null then also wait on this event handle, and call back
// the user's routine if the event fires.
//

HRESULT
CCallbackThread::AdvisePeriodicWithEvent(
    CCallbackAdvise fnAdvise,
    DWORD_PTR dwUserToken,
    REFERENCE_TIME rtPeriod,
    HANDLE hUser,
    DWORD_PTR* pdwToken
)	
{
    // use this to lock all our structures as well as
    // callbacks
    CAutoLock lock(m_pCritSec);

    // Ensure that a thread is there now.
    const HRESULT hr = EnsureThread();
    if (FAILED(hr)) return hr;

    DWORD rtNow;

    // we only allow one active user hEvent
    if (m_evUser && hUser) return E_FAIL;

    // we allow only one such event, period.
    if (m_dwTGTCallbackToken)
        return E_FAIL ;
    
    ASSERT(rtPeriod > 0);

    // get the time now.  the periodic advise is always from the last
    // wakeup point. Also we base this on the GetPrivateTime time as the
    // GetTime time can stall when the private time goes back. We will
    // set the  trigger based on private time and make adjustments to
    // the trigger time when private time is adjusted.

    rtNow = timeGetTime() ;
    m_dwTGTCallbackPeriod = DWORD(rtPeriod/10000) ;

    // set the time callback time.
    m_dwNextTGTCallback = rtNow + m_dwTGTCallbackPeriod ;

    // save the other callback parameters
    m_dwTGTUserToken = dwUserToken ;
    m_fnTGTCallback = fnAdvise ;
    
    // Make sure the thread wakes up if the event is signalled
    if (hUser) {
        m_evUser = hUser;
    }

    m_evSignalThread.Set();

    // the token we return is a magic signature.

    m_dwTGTCallbackToken = 0x99999999 ;
    *pdwToken = m_dwTGTCallbackToken ;

    return S_OK;
}

HRESULT CCallbackThread::ServiceClockSchedule
( CBaseReferenceClock * pClock
, CAMSchedule * pSchedule
, DWORD * dwCookie
)
{
    *dwCookie = 0;
    if (m_dwScheduleCookie != 0) return E_FAIL;

    // we need to make sure we have a thread now
    const HRESULT hr = EnsureThread();
    if (FAILED(hr)) return hr;

    m_pBaseClock = pClock;
    m_pSchedule = pSchedule;
    DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: Setting m_dwScheduleCookie")));
    m_dwScheduleCookie = 0xFFFFFFFF;
    *dwCookie = m_dwScheduleCookie;
    m_evSignalThread.Set();
    return S_OK;
}


HRESULT
CCallbackThread::Cancel(DWORD_PTR dwToken)
{
    // need to check for the object on our list
    CAutoLock lock(m_pCritSec);

    if (dwToken == m_dwScheduleCookie)
    {
        DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: Clearing m_dwScheduleCookie")));
        m_dwScheduleCookie = 0;
        return S_OK;
    }

    // special case the token for timeGetTime based callback
    if ((dwToken == 0x99999999) && (m_dwTGTCallbackToken == dwToken))
    {
        if (m_evUser)
        {
            // Get the thread to remove the event handle
            m_evSignalThread.Set();
            m_evUser = 0 ;
        }

        m_dwTGTCallbackToken = 0 ;
        return S_OK;
    }

    POSITION pos = m_Items.GetHeadPosition();
    while(pos) {
        // GetNext advances pos, so remember the
        // one we will delete
        POSITION posDel = pos;
        CAdviseItem*pItem = m_Items.GetNext(pos);

        if (pItem == (CAdviseItem*) dwToken)
        {
            m_Items.Remove(posDel);
            delete pItem;
            return S_OK;
        }
    }
    return VFW_E_ALREADY_CANCELLED;
}

void CCallbackThread::CancelAllAdvises()
{
    CloseThread();
}

// must hold critsec before checking this
HRESULT
CCallbackThread::EnsureThread()
{
    if (m_hThread) {
        return S_OK;
    }
    return StartThread();
}

// must hold critsec before checking this
HRESULT
CCallbackThread::StartThread()
{
    // call EnsureThread to start the thread
    ASSERT(!m_hThread);

    // clear the stop event before starting
    m_evSignalThread.Reset();

    DWORD dwThreadID;
    m_hThread = CreateThread(
                    NULL,
                    0,
                    InitialThreadProc,
                    this,
                    0,
                    &dwThreadID);
    if (!m_hThread)
    {
        DWORD dwErr = GetLastError();
        return AmHresultFromWin32(dwErr);
    }
    else
        SetThreadPriority( m_hThread, THREAD_PRIORITY_TIME_CRITICAL );


    return S_OK;

}

void
CCallbackThread::CloseThread()
{
    // signal the thread-exit object
    m_fAbort = TRUE;  // thread will now die when it wakes up
    m_evSignalThread.Set();

    if (m_hThread) {

        WaitForSingleObject(m_hThread, INFINITE);
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }
}

// static function called as thread starts -
// param is actually a CCallbackThread*
DWORD
CCallbackThread::InitialThreadProc(void * pvParam)
{
    CCallbackThread* pThis = (CCallbackThread*)pvParam;
    ASSERT(pThis);
    return pThis->ThreadProc();
}

DWORD
CCallbackThread::ThreadProc(void)
{
    // the first-placed object will be reported if both are
    // set, so ordering is important - put the exit event first

    // rather than allowing multiple users, each with their own event,
    // we only allow one user to pass an event handle in.  Otherwise
    HANDLE ahev[4] = {m_evSignalThread, m_evAdvise};

    for(;;) {

        // The number of events can change on every iteration
        DWORD dwEventCount = 2;
        DWORD timeout = INFINITE;
        {
            CAutoLock lock(m_pCritSec);

            if (m_evUser) ahev[dwEventCount++] = m_evUser;
            if (m_dwScheduleCookie)
            {
                ahev[dwEventCount++] = m_pSchedule->GetEvent();
                const REFERENCE_TIME rtNow = m_pBaseClock->GetPrivateTime();
                if (m_pSchedule->GetAdviseCount() > 0 )
                {

                    // NB: Add in an extra millisecond to prevent thrashing
                    const REFERENCE_TIME rtNext = m_pSchedule->Advise(rtNow + 10000);
                    if ( rtNext != MAX_TIME ) timeout = DWORD((rtNext - rtNow)/10000);
                }
            }

            // if we have a TGT (timeGetTime based) advise event set, deal with it.
            if (m_dwTGTCallbackToken)
            {
                // get current time.
                DWORD t1 = timeGetTime () ;
                DWORD t2 ;

                // if it is time to callback the event, do so and set next callback time
                if (((long)(t1 - m_dwNextTGTCallback)) >= 0)
                {
                    DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: DS callback late %ums"), (t1 - m_dwNextTGTCallback)));
                    m_fnTGTCallback (m_dwTGTUserToken) ;
                    m_dwNextTGTCallback = t1 + m_dwTGTCallbackPeriod ;
                    t2 = m_dwTGTCallbackPeriod ;
                }
                else
                {
                    // figure out how much more to go till the TGT callback.
                    t2 = m_dwNextTGTCallback - t1 ;
                }
                // adjust time timeout to account for the TGT callback

                if (timeout > t2)
                    timeout = t2 ;
            }
        }


        DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: TimeOut = %u"), timeout));

        const DWORD dw = WaitForMultipleObjects(
                                            dwEventCount,
                                            ahev,
                                            FALSE,
                                            timeout);

        if (m_fAbort)
        {
            DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: Aborting...")));
            return 0;
        }

        switch (dw)
        {
        case WAIT_OBJECT_0:
            // We were woken up deliberately.  Probably
            // to re-evaluate the event handles
            DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: ReEvaluate")));
            m_evSignalThread.Reset();
            break;

        case WAIT_OBJECT_0 + 1:
            // requests need processing
            DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: ProcessRequest")));
            ProcessRequests();
            break;

        case WAIT_OBJECT_0 + 2:
            if (m_evUser)
            {
                // user passed event has been signalled. This is related to the
                // dsound callback.

                DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: User Signal")));
                ProcessUserSignal();
                break;
            }
            // Deliberate fall-through
        case WAIT_OBJECT_0 + 3:
            DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: Object+3")));
            break ;

        case WAIT_TIMEOUT:
            // no-op We'll Advise in the "if (m_dwScheduleCookie)" block.
            DbgLog((LOG_TIMING, LOG_CALLBACK_RELATED,TEXT("CallBack: TimeOut")));
            break;

        default:
            // What happened??
            DbgBreak("WaitForMultipleObjects failed or produced an unexpected return code.");
            return 0;
        }
    }
}

// Process the TGT callback via event.
void
CCallbackThread::ProcessUserSignal(void)
{
    // we take the lock while managing the lists as well as processing
    // the dispatches. This is the same lock any cancelling thread
    // will hold and the same lock that will be used to remove/set the clock
    CAutoLock lock(m_pCritSec);

    if (m_evUser && m_dwTGTCallbackToken)
    {
        m_fnTGTCallback (m_dwTGTUserToken) ;
        m_dwNextTGTCallback = timeGetTime() + m_dwTGTCallbackPeriod ;
    }
    else
    {
        // the user probably cancelled before we took the lock
    }
}

//loop through the list looking for any advises that are ready
void
CCallbackThread::ProcessRequests(void)
{
    // we take the lock while managing the lists as well as processing
    // the dispatches. This is the same lock any cancelling thread
    // will hold and the same lock that will be used to remove/set the clock
    CAutoLock lock(m_pCritSec);

    // we can't work without a clock
    ASSERT( (m_Items.GetCount() == 0) || (m_pClock));
    if (m_pClock) {

        REFERENCE_TIME rt  ;
        m_pClock->GetTime(&rt);

        POSITION pos = m_Items.GetHeadPosition();
        while (pos) {
            // remember location in case we need to dispatch it
            POSITION posDel = pos;
            CAdviseItem *pItem = m_Items.GetNext(pos);

            // is it ready?
            if (pItem->Time() <= rt) {
                BOOL fIsPeriodic;

                if (!(fIsPeriodic = pItem->UpdateTime(rt))) {
                    m_Items.Remove(posDel);
                }

                pItem->Dispatch();
                if (!fIsPeriodic) delete pItem;
            }
        }

        // reset the clock for next time
        SetAdvise();
    }
}


// find the earliest requested time
// simple implementation based on the assumption that there will at most
// one item on the list normally - search the list.
// returns S_OK if there is a item or S_FALSE if the list is empty.
HRESULT
CCallbackThread::GetSoonestAdvise(REFERENCE_TIME& rrtFirst)
{
    REFERENCE_TIME rtFirst;
    BOOL bSet = FALSE;

    POSITION pos = m_Items.GetHeadPosition();
    while(pos) {
        CAdviseItem* pItem = m_Items.GetNext(pos);

        REFERENCE_TIME rt = pItem->Time();
        if (!bSet || rt < rtFirst) {
            rtFirst = rt;
            bSet = TRUE;
        }
    }
    if (bSet) {
        rrtFirst = rtFirst;
        return S_OK;
    } else {
        return S_FALSE;
    }
}

// se.t up a new advise with the clock if needed
// must be called within the critsec
HRESULT
CCallbackThread::SetAdvise()
{
    if (!m_pClock) {
        return VFW_E_NO_CLOCK;
    }

    // always cancel the current advise first
    CancelAdvise();

    // work out what the new advise time should be
    REFERENCE_TIME rtFirst;
    HRESULT hr = GetSoonestAdvise(rtFirst);
    if (hr != S_OK) {
        return S_OK;
    }

    // we need to make sure we have a thread now
    hr = EnsureThread();
    if (FAILED(hr)) {
        return hr;
    }

    // request an advise (in reference time)
    hr = m_pClock->AdviseTime(
                        rtFirst,
                        TimeZero,
                        (HEVENT) HANDLE(m_evAdvise),
                        &m_dwAdvise);
    ASSERT(SUCCEEDED(hr));

    return hr;
}

void
CCallbackThread::CancelAdvise(void)
{
    if (m_dwAdvise) {
        m_pClock->Unadvise(m_dwAdvise);
        m_dwAdvise = 0;
    }
    m_evAdvise.Reset();
}


// --- implementation of CAdviseItem ---

CCallbackThread::CAdviseItem::CAdviseItem(
    CCallbackAdvise fnAdvise,
    DWORD_PTR dwUserToken,
    REFERENCE_TIME rtAt,
    REFERENCE_TIME rtPeriod,
    DWORD flags)
  : m_fnAdvise(fnAdvise)
  , m_dwUserToken(dwUserToken)
  , m_rtCallbackAt(rtAt)
  , m_rtPeriod(rtPeriod)
  , m_dwAdviseFlags (flags)
{

}

void
CCallbackThread::CAdviseItem::Dispatch()
{
    m_fnAdvise(m_dwUserToken);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\util\code\creg.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

#include <windows.h>
#include <winreg.h>
#include <creg.h>

/*
    Registry access classes :

    CEnumKey
    CEnumValue
*/

CKey::CKey(HKEY hKey,
           LPCTSTR lpszKeyName,
           HRESULT *phr,
           BOOL bCreate,
           REGSAM Access) :
    m_hKey(NULL),
    m_lpszName(m_szName),
    m_dwIndex(0),
    m_cSubKeys(0),
    m_cValues(0)
{
    LONG lRc;
    if (bCreate) {
        lRc = RegCreateKeyEx(hKey,
                             lpszKeyName,
                             0,
                             NULL,
                             0,
                             Access,
                             NULL,
                             &m_hKey,
                             NULL);
    } else {
        lRc = RegOpenKeyEx(hKey,
                           lpszKeyName,
                           0,
                           Access,
                           &m_hKey);
    }
    if (NOERROR == lRc) {
        DWORD dwSecDescLen;      // Bounds checker likes to see this
        FILETIME ft;
        lRc = RegQueryInfoKey(m_hKey,
                        NULL,
                        NULL,
                        NULL,
                        &m_cSubKeys,
                        &m_cbMaxSubkeyLen,
                        NULL,
                        &m_cValues,
                        &m_cbMaxValueNameLen,
                        &m_cbMaxValueLen,
                        &dwSecDescLen,      // just to shut BC up
                        &ft);               // just to shut BC up
        if (NOERROR != lRc) {
	    // shame... but we need the key information to
	    // complete construction correctly...
            RegCloseKey(m_hKey);
            m_hKey = NULL;
        }
    }
    *phr = HRESULT_FROM_WIN32(lRc);
}
CKey::~CKey()
{
    if (m_hKey != NULL) {
        RegCloseKey(m_hKey);
    }
    if (m_lpszName != m_szName) {
        delete [] m_lpszName;
    }
}


CEnumKey::CEnumKey(HKEY hKey,
         LPCTSTR lpszKeyName,
         HRESULT *phr,
         BOOL bCreate,
         REGSAM Access) :
    CKey(hKey, lpszKeyName, phr, bCreate, Access | KEY_ENUMERATE_SUB_KEYS)
{
    if (FAILED(*phr)) {
        return;
    }
    if (m_cbMaxSubkeyLen + 1 > sizeof(m_szName) / sizeof(TCHAR)) {
        m_lpszName = new TCHAR[m_cbMaxSubkeyLen + 1];
        if (m_lpszName == NULL) {
            *phr = E_OUTOFMEMORY;
        }
    }
}
CEnumKey::~CEnumKey()
{
}

BOOL CEnumKey::Next()
{
    /*  Optimize */
    if (m_dwIndex >= m_cSubKeys) {
        return FALSE;
    }
    DWORD cbName = m_cbMaxSubkeyLen + 1;
    LONG lRc = RegEnumKeyEx(m_hKey,
                            m_dwIndex,
                            m_lpszName,
                            &cbName,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
    if (NOERROR == lRc) {
        m_dwIndex++;
        return TRUE;
    }
    return FALSE;
}

CEnumValue::CEnumValue(HKEY hKey,
                       LPCTSTR lpszKeyName,
                       HRESULT *phr,
                       BOOL bCreate,
                       REGSAM Access) :
    CKey(hKey, lpszKeyName, phr, bCreate, Access | KEY_QUERY_VALUE),
    m_lpbData(m_bData),
    m_cbLen(0)
{
    if (FAILED(*phr)) {
        return;
    }
    if (m_cbMaxValueNameLen + 1 > sizeof(m_szName) / sizeof(TCHAR)) {
        m_lpszName = new TCHAR[m_cbMaxValueNameLen + 1];
        if (m_lpszName == NULL) {
            *phr = E_OUTOFMEMORY;
        }
    }
    if (m_cbMaxValueLen > sizeof(m_bData)) {
        m_lpbData = new BYTE[m_cbMaxValueLen];
        if (m_lpbData == NULL) {
            *phr = E_OUTOFMEMORY;
        }
    }
}

CEnumValue::~CEnumValue()
{
    if (m_lpbData != m_bData) {
        delete [] m_lpbData;
    }
}

BOOL CEnumValue::Next()
{
    if (m_dwIndex >= m_cValues) {
        return FALSE;
    }
    DWORD ccNameLen = m_cbMaxValueNameLen + 1;
    m_cbLen = m_cbMaxValueLen;
    LONG lRc = RegEnumValue(m_hKey,
                            m_dwIndex,
                            m_lpszName,
                            &ccNameLen,
                            NULL,
                            &m_dwType,
                            m_lpbData,
                            &m_cbLen);
    if (NOERROR == lRc) {
        m_dwIndex++;
        return TRUE;
    }
    return FALSE;
}

BOOL CEnumValue::Next(DWORD dwType)
{
    while (Next()) {
        if (m_dwType == dwType) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CEnumValue::Read(DWORD dwType, LPCTSTR lpszValueName)
{
    Reset();
    while (Next(dwType)) {
        if (lstrcmpi(lpszValueName, ValueName()) == 0) {
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\util\code\ftype.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*
    Find the type of a file

*/

#include <windows.h>
#include <uuids.h>
#include <wxdebug.h>
#include <winreg.h>
#include <creg.h>
#include <ftype.h>
#include <comlite.h>
#include <errors.h>


BOOL ValueExists(HKEY hKey, LPCTSTR ValueName);

inline int ReadInt(const TCHAR * &sz)
{
    int i = 0;

    while (*sz && *sz >= TEXT('0') && *sz <= TEXT('9'))
    	i = i*10 + *sz++ - TEXT('0');
    	
    return i;    	
}

/*  Sort out class ids */
#ifdef UNICODE
#define CLSIDFromText CLSIDFromString
#define TextFromGUID2 StringFromGUID2
#else
HRESULT CLSIDFromText(LPCSTR lpsz, LPCLSID pclsid)
{
    WCHAR sz[100];
    if (MultiByteToWideChar(GetACP(), 0, lpsz, -1, sz, 100) == 0) {
        return E_INVALIDARG;
    }
    return QzCLSIDFromString(sz, pclsid);
}
HRESULT TextFromGUID2(REFGUID refguid, LPSTR lpsz, int cbMax)
{
    WCHAR sz[100];

    HRESULT hr = QzStringFromGUID2(refguid, sz, 100);
    if (FAILED(hr)) {
        return hr;
    }
    if (WideCharToMultiByte(GetACP(), 0, sz, -1, lpsz, cbMax, NULL, NULL) == 0) {
        return E_INVALIDARG;
    }
    return S_OK;
}
#endif

/*  Mini class for extracting quadruplets from a string */

// A quadruplet appears to be of the form <offset><length><mask><data>
// with the four fields delimited by a space or a comma with as many extra spaces
// as you please, before or after any comma.
// offset and length appear to be decimal numbers.
// mask and data appear to be hexadecimal numbers.  The number of hex digits in
// mask and data must be double the value of length (so length is bytes).
// mask appears to be allowed to be missing (in which case it must have a comma
// before and after e.g. 0, 4, , 000001B3) A missing mask appear to represent
// a mask which is all FF i.e. 0, 4, FFFFFFFF, 000001B3

class CExtractQuadruplets
{
public:
    CExtractQuadruplets(LPCTSTR lpsz) : m_psz(lpsz), m_pMask(NULL), m_pData(NULL)
    {};
    ~CExtractQuadruplets() { delete [] m_pMask; delete [] m_pData; };


    // This appears to
    BOOL Next()
    {
        StripWhite();
        if (*m_psz == TEXT('\0')) {
            return FALSE;
        }
        /*  Convert offset and length from base 10 tchar */
        m_Offset = ReadInt(m_psz);
        SkipToNext();
        m_Len = ReadInt(m_psz);
        if (m_Len <= 0) {
            return FALSE;
        }
        SkipToNext();

        /*  Allocate space for the mask and data */
        if (m_pMask != NULL) {
            delete [] m_pMask;
            delete [] m_pData;
        }

        m_pMask = new BYTE[m_Len];
        m_pData = new BYTE[m_Len];
        if (m_pMask == NULL || m_pData == NULL) {
            return FALSE;
        }
        /*  Get the mask */
        for (int i = 0; i < m_Len; i++) {
            m_pMask[i] = ToHex();
        }
        SkipToNext();
        /*  Get the data */
        for (i = 0; i < m_Len; i++) {
            m_pData[i] = ToHex();
        }
        SkipToNext();
        return TRUE;
    };
    PBYTE   m_pMask;
    PBYTE   m_pData;
    LONG    m_Len;
    LONG    m_Offset;
private:

    // move m_psz to next non-space
    void StripWhite() { while (*m_psz == TEXT(' ')) m_psz++; };

    // move m_psz past any spaces and up to one comma
    void SkipToNext() { StripWhite();
                        if (*m_psz == TEXT(',')) {
                            m_psz++;
                            StripWhite();
                        }
                      };

    BOOL my_isdigit(TCHAR ch) { return (ch >= TEXT('0') && ch <= TEXT('9')); };
    BOOL my_isxdigit(TCHAR ch) { return my_isdigit(ch) ||
			    (ch >= TEXT('A') && ch <= TEXT('F')) ||
			    (ch >= TEXT('a') && ch <= TEXT('f')); };

    // very limited toupper: we know we're only going to call it on letters
    TCHAR my_toupper(TCHAR ch) { return ch & ~0x20; };



    // This appears to translate FROM hexadecimal characters TO packed binary !!!!!
    // It appears to operate on m_psz which it side-effects past characters it recognises
    // as hexadecimal.  It consumes up to two characters.
    // If it recognises no characters then it returns 0xFF.
    BYTE ToHex()
    {
        BYTE bMask = 0xFF;

        if (my_isxdigit(*m_psz))
        {
            bMask = my_isdigit(*m_psz) ? *m_psz - '0' : my_toupper(*m_psz) - 'A' + 10;

            m_psz++;
            if (my_isxdigit(*m_psz))
            {
                bMask *= 16;
                bMask += my_isdigit(*m_psz) ? *m_psz - '0' : my_toupper(*m_psz) - 'A' + 10;
                m_psz++;
            }
        }
        return bMask;
    }

    LPCTSTR m_psz;
};


/* Compare pExtract->m_Len bytes of hFile at position pExtract->m_Offset
   with the data pExtract->m_Data.
   If the bits which correspond the mask pExtract->m_pMask differ
   then return S_FALSE else return S_OK. failure codes indicate unrecoverrable
   failures.
*/

HRESULT CompareUnderMask(HANDLE hFile, const CExtractQuadruplets *pExtract)
{
    /*  Read the relevant bytes from the file */
    PBYTE pbFileData = new BYTE[pExtract->m_Len];
    if (pbFileData == NULL) {
        return S_FALSE;
    }

    /*  Seek the file and read it */
    if (0xFFFFFFFF == (LONG)SetFilePointer(hFile,
                                           pExtract->m_Offset,
                                           NULL,
                                           pExtract->m_Offset < 0 ?
                                           FILE_END : FILE_BEGIN)) {
        delete pbFileData;
        return S_FALSE;
    }

    /*  Read the file */
    DWORD cbRead;
    BOOL fRead = ReadFile(hFile, pbFileData, (DWORD)pExtract->m_Len, &cbRead, NULL);
    if (!fRead || (LONG)cbRead != pExtract->m_Len)
    {
        delete pbFileData;
        if(!fRead && GetLastError() == ERROR_FILE_OFFLINE)
        {
            // abort if user canceled operation to fetch remote file
            return HRESULT_FROM_WIN32(ERROR_FILE_OFFLINE);
        }
        
        return S_FALSE;
    }

    /*  Now do the comparison */
    for (int i = 0; i < pExtract->m_Len; i++) {
        if (0 != ((pExtract->m_pData[i] ^ pbFileData[i]) &
                  pExtract->m_pMask[i])) {
            delete pbFileData;
            return S_FALSE;
        }
    }

    delete pbFileData;
    return S_OK;
}

/*
    See if a file conforms to a byte string

    hk is an open registry key
    lpszSubKey is the name of a sub key of hk which must hold REG_SZ data of the form
    <offset, length, mask, data>...
    offset and length are decimal numbers, mask and data are hexadecimal.
    a missing mask represents a mask of FF...
    (I'll call this a line of data).
    If there are several quadruplets in the line then the file must match all of them.

    There can be several lines of data, typically with registry names 0, 1 etc
    and the file can match any line.

    The same lpsSubKey should also have a value "Source Filter" giving the
    class id of the source filter.  If there is a match, this is returned in clsid.
    If there is a match but no clsid then clsid is set to CLSID_NULL
*/
HRESULT CheckBytes(HANDLE hFile, HKEY hk, LPCTSTR lpszSubkey, CLSID& clsid)
{
    HRESULT hr;
    CEnumValue EnumV(hk, lpszSubkey, &hr);
    if (FAILED(hr)) {
        return S_FALSE;
    }

    // for each line of data
    while (EnumV.Next(REG_SZ)) {
        /*  The source filter clsid is not a list of compare values */
        if (lstrcmpi(EnumV.ValueName(), SOURCE_VALUE) != 0) {
            DbgLog((LOG_TRACE, 4, TEXT("CheckBytes trying %s"), EnumV.ValueName()));

            /*  Check every quadruplet */
            CExtractQuadruplets Extract = CExtractQuadruplets((LPCTSTR)EnumV.Data());
            BOOL bFound = TRUE;

            // for each quadruplet in the line
            while (Extract.Next()) {
                /*  Compare a particular offset */
                HRESULT hrComp = CompareUnderMask(hFile, &Extract);
                if(FAILED(hrComp)) {
                    return hrComp;
                }
                if (hrComp != S_OK) {
                    bFound = FALSE;
                    break;
                }
            }

            if (bFound) {
                /*  Get the source */
                if (EnumV.Read(REG_SZ, SOURCE_VALUE)) {
                    return SUCCEEDED(CLSIDFromText((LPTSTR)EnumV.Data(),
                                                   &clsid)) ? S_OK : S_FALSE;
                } else {
                    clsid = GUID_NULL;
                    return S_OK;
                }
            }
        }
    }
    return S_FALSE;
}


//  Helper - find the extension (including '.') of a file
//  The extension is the string starting with the final '.'
LPCTSTR FindExtension(LPCTSTR pch)
{
    LPCTSTR pchDot = NULL;
    while (*pch != 0) {
        if (*pch == TEXT('.')) {
            pchDot = pch;
        }
        pch = CharNext(pch);
    }
    //  Avoid nasty things
    if (pch - pchDot > 50) {
        pchDot = NULL;
    }
    return pchDot;
}

// given a URL name, find a class id if possible.
// If the protocol specified has an Extensions key, then search for the
// extension of this file and use that CLSID. If not, look for the
// Source Filter named value which will give the class id.
//
// returns S_OK if found or an error otherwise.
HRESULT
GetURLSource(
    LPCTSTR lpszURL,        // full name
    int cch,                // character count of the protocol up to the colon
    CLSID* clsidSource      // [out] param for clsid.
)
{
    // make a copy of the protocol string from the beginning
    TCHAR* pch = new TCHAR[cch + 1];
    if (NULL == pch) {
        return E_OUTOFMEMORY;
    }
    for (int i = 0; i < cch; i++) {
        pch[i] = lpszURL[i];
    }
    pch[i] = '\0';

    // look in HKCR/<protocol>/
    HRESULT hr = S_OK;
    CEnumValue EnumV(HKEY_CLASSES_ROOT, pch, &hr);
    delete [] pch;

    CLSID clsid;

    if (SUCCEEDED(hr)) {

        // is there an Extensions subkey?
        hr = S_OK;
        CEnumValue eExtensions(EnumV.KeyHandle(), EXTENSIONS_KEY, &hr);
        if (SUCCEEDED(hr)) {

            // Set idx to point to the last dot (or -1 if none)
            LPCTSTR pchDot = FindExtension(lpszURL);

            if (pchDot != NULL) {

                // for each value, compare against current extension
                while (eExtensions.Next()) {
                    if (lstrcmpi(pchDot, eExtensions.ValueName()) == 0) {
                        hr = CLSIDFromText((LPTSTR)eExtensions.Data(),
                                                       &clsid);
                        if (SUCCEEDED(hr)) {
                            if (clsidSource) {
                                *clsidSource = clsid;
                            }
                        }

                        return hr;
                    }
                }
            }

        }

        // specific extension not found -- look for generic
        // source filter for this protocol

        if (EnumV.Read(REG_SZ, SOURCE_VALUE)) {
            hr = CLSIDFromText((LPTSTR)EnumV.Data(),
                                           &clsid);
            if (SUCCEEDED(hr)) {
                if (clsidSource) {
                    *clsidSource = clsid;
                }
                return hr;
            }
        }
    }

    // failed to find protocol reader - try generic URL reader??
    if (cch > 1) { // ignore 1-letter protocols, they're drive letters
	*clsidSource = CLSID_URLReader;
	return S_OK;
    }

    return E_FAIL;
}


//  Helper
BOOL ReadGUID(HKEY hKey, LPCTSTR lpszName, GUID *pGUID)
{
    TCHAR szClsid[50];
    DWORD dwType;
    DWORD dwSize = sizeof(szClsid);
    if (NOERROR == RegQueryValueEx(
                       hKey,
                       lpszName,
                       NULL,
                       &dwType,
                       (PBYTE)szClsid,
                       &dwSize)
        && S_OK == CLSIDFromText(szClsid, pGUID)) {
        return TRUE;
    } else {
        return FALSE;
    }
}
//  Helper
BOOL WriteGUID(HKEY hKey, LPCTSTR lpszName, const GUID *pGUID)
{
    TCHAR szClsid[50];
    TextFromGUID2(*pGUID, szClsid, 50);
    if (NOERROR == RegSetValueEx(
                       hKey,
                       lpszName,
                       0,
                       REG_SZ,
                       (PBYTE)szClsid,
                       sizeof(TCHAR) * (lstrlen(szClsid) + 1))) {
        return TRUE;
    } else {
        return FALSE;
    }
}


/* Get the media type and source filter clsid for a file
   Return S_OK if it succeeds else return an hr such that FAILED(hr)
   in which case the outputs are meaningless.
*/
//
// for URL names that may not be locally readable, find a source filter
// clsid for the given protocol and return that (leaving media type and
// subtype as GUID_NULL).

STDAPI GetMediaTypeFile(LPCTSTR lpszFile,    // [in] filename
                        GUID   *Type,        // [out] type
                        GUID   *Subtype,     // [out] subtype
                        CLSID  *clsidSource) // [out] clsid
{
    HRESULT hr;
    CLSID clsid;

    // search for a protocol name at the beginning of the filename
    // this will be any string (not including a \) that preceeds a :
    const TCHAR* p = lpszFile;
    while(*p && (*p != '\\') && (*p != ':')) {
	p = CharNext(p);
    }
    if (*p == ':') {
	// from lpszFile to p is potentially a protocol name.
	// see if we can find a registry entry for this protocol

	// make a copy of the protocol name string
	int cch = (int)(p - lpszFile);

#ifdef _WIN64
        //  Allow for weird overruns
        if (cch < 0) {
            return E_UNEXPECTED;
        }
#endif

        hr = GetURLSource(lpszFile, cch, clsidSource);
        if (S_OK == hr) {
            *Type = GUID_NULL;
            *Subtype = GUID_NULL;
            return hr;
        }
    }

    // search for extensions
    // Don't do this if clsidSource is not specified as for instance
    // when the source filter itself is trying to determine the type
    // from the checkbytes
    if (clsidSource) {
        const TCHAR *pPeriod = FindExtension(lpszFile);
        if (pPeriod) {
            TCHAR sz[100];
            lstrcpy(sz, TEXT("Media Type\\Extensions\\"));
            lstrcat(sz, pPeriod);
            HKEY hKey;
            if (0 == RegOpenKeyEx(HKEY_CLASSES_ROOT, sz, 0, KEY_READ, &hKey)) {
                BOOL bOK = ReadGUID(hKey, SOURCE_VALUE, clsidSource);
                if (bOK) {
                    *Type = GUID_NULL;
                    *Subtype = GUID_NULL;
                    ReadGUID(hKey, TEXT("Media Type"), Type);
                    ReadGUID(hKey, TEXT("Subtype"), Subtype);
                }
                RegCloseKey(hKey);

                if (bOK) {
                    return S_OK;
                }
            }
        }
    }

    /*  Check we can open the file */
    HANDLE hFile = CreateFile(lpszFile,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        LONG lResult = GetLastError();
        return HRESULT_FROM_WIN32(lResult);
    }

    /*  Now scan the registry looking for a match */
    // The registry looks like
    // ---KEY-----------------  value name    value (<offset, length, mask, data> or filter_clsid )
    // Media Type
    //    {clsid type}
    //        {clsid sub type}  0             4, 4,  , 6d646174
    //                          1             4, 8, FFF0F0F000001FFF , F2F0300000000274
    //                          Source Filter {clsid}
    //        {clsid sub type}  0             4, 4,  , 12345678
    //                          Source Filter {clsid}
    //    {clsid type}
    //        {clsid sub type}  0             0, 4,  , fedcba98
    //                          Source Filter {clsid}


    /*  Step through the types ... */

    CEnumKey EnumType(HKEY_CLASSES_ROOT, MEDIATYPE_KEY, &hr);
    if (FAILED(hr)) {
        CloseHandle(hFile);
        if (hr==HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
            hr = VFW_E_BAD_KEY;  // distinguish key from file
        }
        return hr;
    }

    // for each type
    while (EnumType.Next()) {

        /*  Step through the subtypes ... */
        CEnumKey EnumSubtype(EnumType.KeyHandle(), EnumType.KeyName(), &hr);
        if (FAILED(hr)) {
            CloseHandle(hFile);
            return hr;
        }

        // for each subtype
        while (EnumSubtype.Next()) {
            hr = CheckBytes(hFile,
                            EnumSubtype.KeyHandle(),
                            EnumSubtype.KeyName(),
                            clsid);
            if(hr == S_OK)
            {
                if (SUCCEEDED(CLSIDFromText((LPTSTR)EnumType.KeyName(),
                                            (CLSID *)Type)) &&
                    SUCCEEDED(CLSIDFromText((LPTSTR)EnumSubtype.KeyName(),
                                            (CLSID *)Subtype))) {
                    if (clsidSource != NULL) {
                        *clsidSource = clsid;
                    }
                    CloseHandle(hFile);
                    return S_OK;
                }
            }
            else if(FAILED(hr)) {
                CloseHandle(hFile);
                return hr;
            }
            
            // S_FALSE
        }
    }

    CloseHandle(hFile);

    /*  If we haven't found out the type return a wild card MEDIASUBTYPE_NULL
        and default the async reader as the file source

        The effect of this is that every parser of MEDIATYPE_Stream data
        will get a chance to connect to the output of the async reader
        if it detects its type in the file
    */

    *Type = MEDIATYPE_Stream;
    *Subtype = MEDIASUBTYPE_NULL;
    if (clsidSource != NULL) {
        *clsidSource = CLSID_AsyncReader;
    }
    return S_OK;
}

/*
**    Test if a value exists in a given key
*/

BOOL ValueExists(HKEY hKey, LPCTSTR ValueName)
{
    DWORD Type;

    return ERROR_SUCCESS ==
           RegQueryValueEx(hKey,
                           (LPTSTR)ValueName,
                           NULL,
                           &Type,
                           NULL,
                           NULL);
}

/*  Create the concatenated key name :
    Media Type\{Type clsid}\{Subtype clsid}
    if SubType is NULL we just return the path to the type subkey
*/
HRESULT GetMediaTypePath(const GUID *Type, const GUID *Subtype, LPTSTR psz)
{
    lstrcpy(psz, MEDIATYPE_KEY);
    lstrcat(psz, TEXT("\\"));
    HRESULT hr = TextFromGUID2(*Type, psz + lstrlen(psz), 100);
    if (FAILED(hr)) {
        return hr;
    }
    if (Subtype != NULL) {
        lstrcat(psz, TEXT("\\"));
        hr = TextFromGUID2(*Subtype, psz + lstrlen(psz), 100);
    }
    return hr;
}

/*  Add a media type entry to the registry */

STDAPI SetMediaTypeFile(const GUID *Type,
                        const GUID *Subtype,
                        const CLSID *clsidSource,
                        LPCTSTR lpszMaskAndData,
                        DWORD dwIndex)
{
    HKEY hKey;
    TCHAR sz[200];

    //  If starting on a new one remove the old
    if (dwIndex == 0) {
        DeleteMediaTypeFile(Type, Subtype);
    }
    HRESULT hr = GetMediaTypePath(Type, Subtype, sz);
    if (FAILED(hr)) {
        return hr;
    }
    /*  Check the source is value */
    TCHAR szSource[100];
    if (clsidSource != NULL) {
        hr = TextFromGUID2(*clsidSource, szSource, 100);
        if (FAILED(hr)) {
            return hr;
        }
    }

    /*  Open or create the key */
    LONG lRc = RegCreateKey(HKEY_CLASSES_ROOT, sz, &hKey);
    if (NOERROR != lRc) {
        return HRESULT_FROM_WIN32(lRc);
    }
    TCHAR ValueName[10];
    wsprintf(ValueName, TEXT("%d"), dwIndex);


    /*  Set the value */
    lRc = RegSetValueEx(hKey,
                        ValueName,
                        0,
                        REG_SZ,
                        (LPBYTE)lpszMaskAndData,
                        (lstrlen(lpszMaskAndData) + 1) * sizeof(TCHAR));
    /*  Set the source filter clsid */
    if (NOERROR == lRc && clsidSource != NULL) {
        lRc = RegSetValueEx(hKey,
                            SOURCE_VALUE,
                            0,
                            REG_SZ,
                            (LPBYTE)szSource,
                            (lstrlen(szSource) + 1) * sizeof(TCHAR));
    }
    RegCloseKey(hKey);
    return HRESULT_FROM_WIN32(lRc);
}

STDAPI DeleteMediaTypeFile(const GUID *Type, const GUID *Subtype)
{
    TCHAR sz[200];
    HRESULT hr = GetMediaTypePath(Type, Subtype, sz);
    if (FAILED(hr)) {
        return hr;
    }
    LONG lRc = RegDeleteKey(HKEY_CLASSES_ROOT, sz);
    if (NOERROR != lRc) {
        return HRESULT_FROM_WIN32(lRc);
    }
    /*  Now see if we should delete the key */
    hr = GetMediaTypePath(Type, NULL, sz);
    if (FAILED(hr)) {
        return hr;
    }

    /*  See if there is still a subkey (win95 RegDeleteKey will delete
        all subkeys!)
    */
    if (CEnumKey(HKEY_CLASSES_ROOT, sz, &hr).Next()) {
        return S_OK;
    }

    lRc = RegDeleteKey(HKEY_CLASSES_ROOT, sz);
    return HRESULT_FROM_WIN32(lRc);
}

/*  Register a file extension - must include leading "." */
HRESULT RegisterExtension(LPCTSTR lpszExt, const GUID *Subtype)
{
    HKEY hkey;
    TCHAR szKey[200];
    lstrcpy(szKey, MEDIATYPE_KEY TEXT("\\") EXTENSIONS_KEY TEXT("\\"));
    lstrcat(szKey, lpszExt);
    LONG lRc = RegCreateKey(HKEY_CLASSES_ROOT, szKey, &hkey);
    if (NOERROR == lRc) {
        if (WriteGUID(hkey, SOURCE_VALUE, &CLSID_AsyncReader)) {
            WriteGUID(hkey, TEXT("Media Type"), &MEDIATYPE_Stream);
            WriteGUID(hkey, TEXT("Subtype"), Subtype);
        }
        RegCloseKey(hkey);
    }
    return HRESULT_FROM_WIN32(lRc);
}


//  Add a protocol handler
HRESULT AddProtocol(LPCTSTR lpszProtocol, const CLSID *pclsidHandler)
{
    HKEY hkProtocol;

    HRESULT hr = S_OK;
    LONG lRc = RegOpenKey(HKEY_CLASSES_ROOT, lpszProtocol, &hkProtocol);
    if (NOERROR == lRc) {
        if (!WriteGUID(hkProtocol, SOURCE_VALUE, pclsidHandler)) {
            hr = E_ACCESSDENIED;
        }
        RegCloseKey(hkProtocol);
    } else {
        hr = HRESULT_FROM_WIN32(hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\strmaloc\test\qtests.h ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved


/*
    Definitions for tests for the COutputQueue class
*/

class CTestError
{
public:
    CTestError(int iTestError)
    {
        m_iError = iTestError;
    };
    int ErrorCode() { return m_iError; };

private:
    int   m_iError;
};

/*  Predeclare */
class CTestOutputQ;

/*  Create a test sink filter out of the sink filter */
class CTestSink : public CSinkFilter
{
public:
    CTestSink(CTestOutputQ *pTest, HRESULT *phr);
    ~CTestSink();

    CStateInputPin *CreateInputPin();

    /*  Private test methods */
    void SampleReceived(BOOL bOK) {
        if (bOK) {
            m_nSamplesOK++;
        } else {
            m_nSamplesBad++;
        }
    }
    void ResetCount() { m_nSamplesOK = 0; m_nSamplesBad = 0; };
    int  SamplesReceived(BOOL bOK) {
        return bOK ? m_nSamplesOK : m_nSamplesBad;
    };
private:
    CTestOutputQ * const m_pTest;

    int  m_nSamplesOK;
    int  m_nSamplesBad;

};

class CTestInputPin : public CSinkPin
{
public:
    CTestInputPin(CTestOutputQ *pTest, CTestSink *, CCritSec *, BOOL bBlocking, HRESULT *);
    STDMETHODIMP ReceiveCanBlock();
    STDMETHODIMP Receive(IMediaSample * pSample);
    STDMETHODIMP ReceiveMultiple(IMediaSample **ppSamples,
                                 long nSamples,
                                 long *nSamplesProcessed);
    STDMETHODIMP EndOfStream();
    STDMETHODIMP EndFlush();

private:
    BOOL           const m_bReceiveCanBlock;
    CTestSink    * const m_pTestFilter;
    CTestOutputQ * const m_pTest;
    BOOL                 m_bDiscontinuity;
};


class CTestSource : public CSourceFilter
{
public:
    CTestSource(CTestOutputQ *pTest,
                IStream *pStream,
                LONG lSize,
                LONG lCount,
                HRESULT *phr);
    ~CTestSource();

private:
    BOOL   m_bBlock;
};

class CTestOutputPin : public CSourcePin
{
public:
    CTestOutputPin(CTestOutputQ *pTest,
                   IStream      *pStream,
                   LONG          lSize,
                   LONG          lCount,
                   CBaseFilter  *pFilter,
                   CCritSec     *pLock,
                   HRESULT      *phr);
    ~CTestOutputPin();

    /*  Override these in order to use the output queue */
    HRESULT Deliver(IMediaSample *);
    void DoEndOfStream();
    virtual void DoBeginFlush();
    virtual void DoEndFlush();

private:
    CTestOutputQ *m_pTest;
};


/*  Our test object - we throw an exception if we fail to construct */
class CTestOutputQ
{
public:
    CTestOutputQ(BOOL bAuto,         //  COutputQueue initializers
                 BOOL bQueue,        //      "             "
                 BOOL bExact,        //      "             "
                 LONG lBatchSize,    //      "             "
                 BOOL bBlockingPin,  //
                 LONG lSize,         //  Allocator initializers
                 LONG lCount,        //      "             "
                 LONG lBitsPerSec,   //  Affects rate of processing
                 LONGLONG llLength,  //  Length of stream (0 means not seekable)
                 int *result);
    ~CTestOutputQ();
    int TestConnect();
    int TestDisconnect();
    int TestPause();
    int TestRun();
    int TestStop();
    int TestSend(DWORD dwFlushAfter);

    /*  Notify when the input pin has processed some bytes */
    void GotBytes(PBYTE pbData, LONG lBytes);
    void GotBatch(LONG nSamples);
    void Fail(int iCode)
    {
        if (m_iResult == TST_PASS) {
            m_iResult = iCode;
            m_evComplete.Set();
        }
    };
    void ResetCounts();

private:
    HRESULT             m_hr;
    CTestSink          *m_pSink;
    CTestSource        *m_pSource;
    COutputQueue       *m_pQueue;
    CIStreamOnFunction *m_pStream;
    IReferenceClock    *m_pClock;

    LONG               m_lBitsPerSec;

    friend class CTestSource;
    friend class CTestSink;
    friend class CTestInputPin;
    friend class CTestOutputPin;

    BOOL               m_bBlockingPin;
    LONG               m_lBatchSize;

    /*  Synchronize with output */
    CAMEvent             m_evComplete;
    int                m_iResult;

    /*  Keep track of stuff */
    LONG               m_nSamplesSent;
    LONG               m_nSamplesReceived;
    LONGLONG           m_nBytes;
    LONGLONG           m_llLength;
    LONG               m_nEOS;
    LONG               m_nExpectedEOS;
    LONG               m_nUnexpected;

    /*  To stop bad return codes in Connect */
    BOOL               m_Connected;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\util\code\instrm.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

//
//  CInputStream class
//

#include <streams.h>
#include <pullpin.h>
#include <rdr.h>
#include <instrm.h>

#pragma warning(disable:4355)

CInputStream::CInputStream(TCHAR *Name,
                           LPUNKNOWN pUnk,
                           CCritSec *pLock,
                           HRESULT *phr) :
    CSourcePosition(Name, pUnk, phr, pLock),
    m_pPosition(NULL),
    m_Connected(FALSE),
    m_bPulling(FALSE),
    m_puller(this)
{
}

HRESULT CInputStream::Connect(
    IPin *pOutputPin,
    AM_MEDIA_TYPE const *pmt,
    IMemAllocator * pAlloc
    )
{
    CAutoLock lck(m_pLock);
    if (m_Connected) {
        return S_OK;
    }
    ASSERT(m_pPosition == NULL);

    // simple file reader class for use by GetStreamsAndDuration.
    // we can build one of these on IStream or IAsyncReader
    CReader* pReader = NULL;
    SYSTEM_INFO SysInfo;
    GetSystemInfo(&SysInfo);
    LONG lSize = max(SysInfo.dwPageSize, 2048);

    //
    // look for IAsyncReader on the output pin and if found set up for
    // pulling data instead of using IMemInputPin.
    //
    HRESULT hr = m_puller.Connect(pOutputPin, pAlloc, FALSE);
    if (S_OK == hr) {
        m_bPulling = TRUE;

	CReaderFromAsync* pR = new CReaderFromAsync;
	IAsyncReader* pSource = m_puller.GetReader();
	ASSERT(pSource != NULL);

	hr = pR->Init(
		m_puller.GetReader(),
		lSize,
		lSize,
		TRUE);
	if (FAILED(hr)) {
	    pSource->Release();
	    delete pR;
	    return hr;
	}
	// if it succeeded, it addrefed the interface

	pReader = pR;
    } else {

        /*  See if the pin supports IMediaPosition */
        pOutputPin->QueryInterface(IID_IMediaPosition, (void **)&m_pPosition);

        /*  See if the pin supports IStream */
        IStream *pStream;

        HRESULT hr = pOutputPin->QueryInterface(IID_IStream, (void **)&pStream);
        if (FAILED(hr)) {
            return hr;
        }

        /*  Read the stream to get the stream data */
	CReaderFromStream* pR = new CReaderFromStream;
	hr = pR->Init(
		pStream,
		lSize,
		lSize,
		m_pPosition != NULL);

	if (FAILED(hr)) {
	    pStream->Release();
	    delete pR;
	    return hr;
	}
	// if it succeeded it addrefed the stream.
	pReader = pR;
    }

    /*  Check the stream */
    hr = CheckStream(pReader, pmt);

    // release any addrefs it made
    delete pReader;

    if (SUCCEEDED(hr)) {
        m_Connected = TRUE;
    } else {
        Disconnect();
    }
    return hr;
}

HRESULT CInputStream::Disconnect()
{
    CAutoLock lck(m_pLock);
    m_Connected = FALSE;

    if (m_bPulling) {
        m_puller.Disconnect();
        m_bPulling = FALSE;
    }

    if (m_pPosition != NULL) {
        m_pPosition->Release();
        m_pPosition = NULL;
    }
    return S_OK;
}

CInputStream::~CInputStream()
{
    /*  Connects should be balanced by Disconnects */
    ASSERT(m_pPosition == NULL);
    ASSERT(!m_bPulling);
}

// call this when we transition to and from streaming
// in the pulling (IAsyncReader) case, this will start the worker thread.
HRESULT
CInputStream::StartStreaming()
{
    if (m_bPulling) {

        // !!! may need to seek here!

        HRESULT hr = m_puller.Active();
        if (FAILED(hr)) {
            return hr;
        }
    }
    return S_OK;
}

HRESULT
CInputStream::StopStreaming()
{
    if (m_bPulling) {
        HRESULT hr = m_puller.Inactive();
        if (FAILED(hr)) {
            return hr;
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\util\code\reader.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved

/*

    File:  reader.cpp

    Description:

        Mini file reader class used by parsers to search for stream
        and duration information

*/

#include <streams.h>
#include <wxdebug.h>
#include "rdr.h"

/*  Constructor and destructor */
CReader::CReader() :
    m_pbBuffer(NULL)
{
}

/*  Initialize our mini-file reader class

    Parameters:

        lBufferSize - size of buffer we should create to read into
        lReadSize  - size of reads to do
        bSeekable - it it's seekable
        llFileSize - total file length

    Returns:
        Standard HRESULT - can fail because of problems with the stream or
        lack of memory

*/
HRESULT CReader::Init(
    LONG lBufferSize,
    LONG lReadSize,
    BOOL bSeekable,
    LONGLONG llFileSize
)
{
    m_lBufferSize = lBufferSize;
    m_lReadSize   = lReadSize;
    m_bSeekable   = bSeekable;
    m_llPosition  = 0;
    m_lValid      = 0;
    m_pbBuffer    = new BYTE[lBufferSize];

    if (m_pbBuffer == NULL) {
        return E_OUTOFMEMORY;
    }

    /*  Now to get the duration */
    if (bSeekable) {
        m_llSize = llFileSize;

        /*  Seek to 0 (important if we're reusing this stream!) */
        HRESULT hr = Seek((LONGLONG)0);
        if (FAILED(hr)) {
            return hr;
        }
        ASSERT(m_llPosition == 0);
    }

    return S_OK;
}

CReader::~CReader()
{
    if (m_pbBuffer) {
	delete [] m_pbBuffer;
    }
}

/*
    Seek the reader

    Parameters:
        llPos - where to seek to (absolute seek)

    The stream is seeked and our 'cache' in the buffer is discarded.
*/
HRESULT CReader::Seek(LONGLONG llPos)
{
    ASSERT(m_bSeekable);

    LONGLONG llNewPos;

    HRESULT hr = SeekDevice(llPos, &llNewPos);

    if (FAILED(hr)) {
        return hr;
    }
    m_llPosition = llNewPos;
    m_lValid     = 0;
    return S_OK;
}


/*
    Return the length of the stream we were given
*/
LONGLONG CReader::GetSize(LONGLONG *pllAvailable)
{
    ASSERT(m_bSeekable);
    if (pllAvailable != NULL) {
        *pllAvailable = m_llSize;
    }
    return m_llSize;
}

/*
    Get the current position parameters

    Returns pointer to the buffer of valid data

    Length of valid data returned in LengthValid

    Current file position as represented by the start of the buffer in llPos
*/
PBYTE CReader::GetCurrent(LONG& lLengthValid, LONGLONG& llPos) const
{
    lLengthValid = m_lValid;
    llPos        = m_llPosition;
    return m_pbBuffer;
};

/*
    Read more data from the stream

    Returns standard HRESULT
*/
HRESULT CReader::ReadMore()
{
    /*  See how much will fit */
    LONG lRemaining = m_lBufferSize - m_lValid;
    ASSERT(lRemaining >= 0);
    LONG lToRead;
    if (lRemaining < m_lReadSize) {
        lToRead = lRemaining;
    } else {
        lToRead = m_lReadSize;
    }

    DWORD dwRead;
    HRESULT hr = ReadFromDevice((PVOID)(m_pbBuffer + m_lValid),
                                  lToRead,
                                  &dwRead);
    if (FAILED(hr)) {
        return hr;
    }

    m_lValid += dwRead;
    return dwRead == 0 ? S_FALSE : S_OK;
}

/*
     Advance our pointer by lAdvance

     Implementation is to make m_pBuffer point to the start of any data
     still valid by shifting the remaining data to the front.
*/
void CReader::Advance(LONG lAdvance)
{
    ASSERT(m_lValid >= lAdvance);
    m_lValid      -= lAdvance;
    m_llPosition  += lAdvance;
    memmoveInternal((PVOID)m_pbBuffer, (PVOID)(m_pbBuffer + lAdvance), m_lValid);
    ASSERT(m_lValid >= 0);
}


// --- CReaderFromStream implementation ---

CReaderFromStream::CReaderFromStream()
  : m_pStream(NULL)
{
}

CReaderFromStream::~CReaderFromStream()
{
    if (m_pStream) {
	m_pStream->Release();
    }
}

HRESULT CReaderFromStream::Init(IStream *pStream, LONG lBufferSize, LONG lReadSize, BOOL bSeekable)
{
    m_pStream     = pStream;

    /*  Get the file stats */
    /*  Now to get the duration */
    LONGLONG llSize;
    if (bSeekable) {
        STATSTG statstg;
        HRESULT hr = m_pStream->Stat(&statstg, STATFLAG_NONAME);
        if (FAILED(hr)) {
            /*  We take this to mean the stream is not seekable */

            DbgLog((LOG_ERROR, 1, TEXT("Stat failed code 0x%8.8X"), hr));
            return hr;
        }
        llSize = (LONGLONG)statstg.cbSize.QuadPart;
    }

    return CReader::Init(
		    	lBufferSize,
			lReadSize,
			bSeekable,
			llSize);

}

HRESULT
CReaderFromStream::SeekDevice(LONGLONG llPos, LONGLONG* llNewPos)
{
    LARGE_INTEGER liSeekTo;
    ULARGE_INTEGER liNewPosition;
    liSeekTo.QuadPart = llPos;
    ASSERT(llPos >= 0 && llPos < GetSize());
    HRESULT hr = m_pStream->Seek(liSeekTo, STREAM_SEEK_SET, &liNewPosition);

    if (FAILED(hr)) {
	return hr;
    }

    *llNewPos = liNewPosition.QuadPart;
    return S_OK;
}

HRESULT
CReaderFromStream::ReadFromDevice(PVOID p, DWORD length, DWORD* pcbActual)
{
    return m_pStream->Read(p,
			     length,
			     pcbActual);
}


// --- CReaderFromAsync implementation ---

CReaderFromAsync::CReaderFromAsync()
  : m_pReader(NULL)
{
}

CReaderFromAsync::~CReaderFromAsync()
{
    if (m_pReader) {
	m_pReader->Release();
    }
}

HRESULT CReaderFromAsync::Init(IAsyncReader *pReader, LONG lBufferSize, LONG lReadSize, BOOL bSeekable)
{
    m_pReader     = pReader;


    // get the file length
    LONGLONG llSize, llCurrent;
    if (bSeekable) {

	HRESULT hr = m_pReader->Length(&llSize, &llCurrent);

	if (FAILED(hr)) {
	    return hr;
	}
	
	// !!! for now, ignore the current length and wait for the whole
	// lot if necessary
    }

    return CReader::Init(
		    	lBufferSize,
			lReadSize,
			bSeekable,
			llSize);

}

HRESULT
CReaderFromAsync::SeekDevice(LONGLONG llPos, LONGLONG* llNewPos)
{
    // need to keep our own seek pointer since base class refers to the
    // beginning of the buffer
    m_llNextRead = llPos;

    // do nothing to seek now - we will do it on the next read
    *llNewPos = llPos;
    return S_OK;
}


HRESULT
CReaderFromAsync::ReadFromDevice(PVOID p, DWORD length, DWORD* pcbActual)
{

    *pcbActual = 0;

    // check for past eof
    if (m_llNextRead + length >  m_llSize) {

	if (m_llNextRead >= m_llSize) {
	    return S_FALSE;
	}

	length = (DWORD) (m_llSize - m_llNextRead);
    }

    HRESULT hr = m_pReader->SyncRead(
			    	m_llNextRead,
				length,
				(LPBYTE) p);
    if (FAILED(hr)) {
	return hr;
    }

    *pcbActual = length;
    m_llNextRead += length;
    return S_OK;
}


/*
    Return the length of the stream we were given
*/
LONGLONG CReaderFromAsync::GetSize(LONGLONG *pllAvailable)
{
    ASSERT(m_bSeekable);
    if (pllAvailable != NULL) {
        LONGLONG llTotal;
        m_pReader->Length(&llTotal, pllAvailable);
        ASSERT(llTotal == m_llSize);
    }
    return m_llSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\util\test\arithtst.cpp ===
// Copyright (c) Microsoft Corporation 1996. All Rights Reserved

#include <objbase.h>
#include <streams.h>
#include <tstshell.h>

/*  Test arithmetic routines */

int TestMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG d, LONGLONG llExpected)
{
    DWORD dwTime = timeGetTime();
    LONGLONG llResult;
    for (int i = 0; i < 1000000; i++) {
        llResult = llMulDiv(a, b, c, d);
    }
    dwTime = timeGetTime() - dwTime;
    if (llResult != llExpected) {
        tstLog(TERSE, "llMulDiv(%s, %s, %s, %s) \n  returned %s, expected %s",
               (LPCTSTR)CDisp(a, CDISP_HEX),
               (LPCTSTR)CDisp(b, CDISP_HEX),
               (LPCTSTR)CDisp(c, CDISP_HEX),
               (LPCTSTR)CDisp(d, CDISP_HEX),
               (LPCTSTR)CDisp(llResult, CDISP_HEX),
               (LPCTSTR)CDisp(llExpected, CDISP_HEX));
        return TST_FAIL;
    } else {
        tstLog(TERSE, "llMulDiv(%s, %s, %s, %s) \n  returned %s, took %d ns",
               (LPCTSTR)CDisp(a),
               (LPCTSTR)CDisp(b),
               (LPCTSTR)CDisp(c),
               (LPCTSTR)CDisp(d),
               (LPCTSTR)CDisp(llResult),
               dwTime);
        return TST_PASS;
    }
}

int TestMulDivShort(LONGLONG a, LONG b, LONG c, LONG d)
{
    DWORD dwTime = timeGetTime();
    LONGLONG llResult;
    for (int i = 0; i < 1000000; i++) {
        llResult = Int64x32Div32(a, b, c, d);
    }
    dwTime = timeGetTime() - dwTime;
    LONGLONG llExpected = llMulDiv(a, (LONGLONG)b, (LONGLONG)c, (LONGLONG)d);
    if (llResult != llExpected) {
        tstLog(TERSE, "Int64x32Div32(%s, %d, %d, %d) \n  returned %s, expected %s",
               (LPCTSTR)CDisp(a),
               b,
               c,
               d,
               (LPCTSTR)CDisp(llResult),
               (LPCTSTR)CDisp(llExpected));
        return TST_FAIL;
    } else {
        tstLog(TERSE, "Int64x32Div32(%s, %d, %d, %d) \n  returned %s, took %d ns",
               (LPCTSTR)CDisp(a),
               b,
               c,
               d,
               (LPCTSTR)CDisp(llResult),
               dwTime);
        return TST_PASS;
    }
}

/*  Assume c | a and c | d */
int TestDividesMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG d)
{
    LONGLONG llExpected = (a / c) * b + d / c;
    LONGLONG llResult;
    DWORD dwTime = timeGetTime();
    for (int i = 0; i < 1000000; i++) {
        llResult = llMulDiv(a, b, c, d);
    }
    dwTime = timeGetTime() - dwTime;
    ASSERT(a % c == (LONGLONG)0);
    ASSERT(d % c == (LONGLONG)0);
    if (llResult != llExpected) {
        tstLog(TERSE, "llMulDiv(%s, %s, %s, %s) \n  returned %s, expected %s",
               (LPCTSTR)CDisp(a, CDISP_HEX),
               (LPCTSTR)CDisp(b, CDISP_HEX),
               (LPCTSTR)CDisp(c, CDISP_HEX),
               (LPCTSTR)CDisp(d, CDISP_HEX),
               (LPCTSTR)CDisp(llResult, CDISP_HEX),
               (LPCTSTR)CDisp(llExpected, CDISP_HEX));
        return TST_FAIL;
    } else {
        tstLog(TERSE, "llMulDiv(%s, %s, %s, %s) \n  returned %s, took %d ns",
               (LPCTSTR)CDisp(a),
               (LPCTSTR)CDisp(b),
               (LPCTSTR)CDisp(c),
               (LPCTSTR)CDisp(d),
               (LPCTSTR)CDisp(llResult),
               dwTime);
        return TST_PASS;
    }
}


STDAPI_(int) TestArithmetic()
{
    int result;
    /*  Test muldiv */
    tstLog(TERSE, "Testing Arithmetic functions");
    result = TestMulDiv(1, 1, 1, 0, 1);
    if (result != TST_PASS) {
        return result;
    }
    result = TestMulDiv(-1, -1, -50, -1, 0);
    if (result != TST_PASS) {
        return result;
    }
    result = TestMulDiv(-1, 1, 0, -1, 0x8000000000000000);
    if (result != TST_PASS) {
        return result;
    }
    result = TestMulDiv(-1, 1, 0, 0, 0x8000000000000000);
    if (result != TST_PASS) {
        return result;
    }
    result = TestMulDiv(-0x100000000, -0x100000000, -1, 1, 0x8000000000000000);
    if (result != TST_PASS) {
        return result;
    }
    result = TestDividesMulDiv(0x77777777 * (LONGLONG)0x4545,
                               0x100000000,
                               0x77777777,
                               0);
    if (result != TST_PASS) {
        return result;
    }
    result = TestDividesMulDiv(-(LONGLONG)0x77777777777 * (LONGLONG)0x4545,
                               0x555555555555,
                               -0x77777777777,
                               0);
    if (result != TST_PASS) {
        return result;
    }
    result = TestDividesMulDiv(-(LONGLONG)0x77777777,
                               (LONGLONG)0x5555555555555555,
                               -0x77777777,
                               0x77777777 * (LONGLONG)0x55555);
    if (result != TST_PASS) {
        return result;
    }

    result = TestMulDivShort(-(LONGLONG)0x7777777777, 0x80000000, 0x7FFFFFFF, 0x80000000);
    if (result != TST_PASS) {
        return result;
    }

    result = TestMulDivShort((LONGLONG)0, 0x80000000, 0x7FFFFFFF, 0x80000000);
    if (result != TST_PASS) {
        return result;
    }
    result = TestMulDivShort((LONGLONG)1, 0x80000000, 0x7FFFFFFF, 0x80000000);
    if (result != TST_PASS) {
        return result;
    }

    result = TestMulDivShort((LONGLONG)0x1234567812345678, 0x80000000, 0x7FFFFFFF, 0x7FFFFFFF);
    if (result != TST_PASS) {
        return result;
    }

    return TST_PASS;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\util\test\cregtest.cpp ===
// Copyright (c) Microsoft Corporation 1996. All Rights Reserved

/*  Test classes:

    CEnumKey
    CEnumValue
*/

#include <windows.h>
#include <winreg.h>
#include <creg.h>
#include <tstshell.h>

const TCHAR OurKey[] = TEXT("SOFTWARE\\Microsoft\\TestCReg");

void AddValue(DWORD dwType, LPCTSTR lpszName, DWORD dwLen, LPBYTE lpbData)
{
    HRESULT hr;
    CKey Key = CKey(HKEY_CURRENT_USER, OurKey, &hr);
    if (SUCCEEDED(hr)) {
        RegSetValueEx(Key.KeyHandle(), lpszName, 0, dwType, lpbData, dwLen);
    }
}

void AddKey(LPCTSTR lpszName)
{
    TCHAR szName[200];
    wsprintf(szName, TEXT("%s\\%s"), OurKey, lpszName);
    HKEY hk;
    LONG lRc = RegCreateKey(HKEY_CURRENT_USER, szName, &hk);
    if (NOERROR == lRc) {
        RegCloseKey(hk);
    }
}

void FreeKey(HKEY hk, LPCTSTR OurKey)
{
    /*  Delete any subkeys */
    {
        HRESULT hr;
        CEnumKey EnumK(hk, OurKey, &hr, FALSE, MAXIMUM_ALLOWED);
        if (FAILED(hr)) {
            return;
        }
        while (EnumK.Next()) {
            FreeKey(EnumK.KeyHandle(), EnumK.KeyName());
        }
    }
    RegDeleteKey(hk, OurKey);
}


int Tests()
{
    FreeKey(HKEY_CURRENT_USER, OurKey);
    /*  Test1 - try to enum subkeys or values of non-existent key */
    HRESULT hr;
    {
        CEnumKey EnumK(HKEY_CURRENT_USER, OurKey, &hr);
        if (SUCCEEDED(hr)) {
            tstLog(TERSE, "CEnumKey of non-existent key succeeded!");
            return TST_FAIL;
        }

        CEnumValue EnumV(HKEY_CURRENT_USER, OurKey, &hr);
        if (SUCCEEDED(hr)) {
            tstLog(TERSE, "CEnumValue of non-existent key succeeded!");
            return TST_FAIL;
        }
    }

    /*  Create the key */
    {
        CEnumKey EnumK(HKEY_CURRENT_USER, OurKey, &hr, TRUE);
        if (FAILED(hr)) {
            tstLog(TERSE, "CEnumKey failed to create key");
            return TST_FAIL;
        }
        /*  Enumerate the (0) keys */
        if (EnumK.Next()) {
            tstLog(TERSE, "CEnumKey returned >0 keys with 0 keys!");
            return TST_FAIL;
        }
        FreeKey(HKEY_CURRENT_USER, OurKey);
        CEnumValue EnumV(HKEY_CURRENT_USER, OurKey, &hr, TRUE);
        if (FAILED(hr)) {
            tstLog(TERSE, "CEnumValue failed to create key");
            return TST_FAIL;
        }
        /*  Enumerate the (0) keys */
        if (EnumV.Next()) {
            tstLog(TERSE, "CEnumValue returned >0 keys with 0 keys!");
            return TST_FAIL;
        }
    }

    /*  Add some values and subkeys to the key and test it's all OK */
    {
        static BYTE Data1[] = { 0x12, 0x23, 0x34, 0x45 };
        static BYTE Data2[] = { 0x54, 0x43, 0x32, 0x21 };
        DWORD dwLen1 = sizeof(DWORD), dwLen2 = sizeof(DWORD);
        static TCHAR Key1[] = TEXT("Key1");
        static TCHAR Key2[] = TEXT("Key2");
        static TCHAR Value1[] = TEXT("Value1");
        static TCHAR Value2[] = TEXT("Value2");

        AddValue(REG_DWORD, Value1, dwLen1, Data1);
        AddValue(REG_BINARY, Value2, dwLen2, Data2);
        AddKey(Key1);
        AddKey(Key2);
        CEnumKey EnumK(HKEY_CURRENT_USER, OurKey, &hr);
        if (!EnumK.Next()) {
            tstLog(TERSE, "Failed to read first subkey");
            return TST_FAIL;
        }
        if (lstrcmp(EnumK.KeyName(), Key1) &&
            lstrcmp(EnumK.KeyName(), Key2)) {
            tstLog(TERSE, "First key name wrong");
            return TST_FAIL;
        }
        BOOL bFirst = lstrcmp(EnumK.KeyName(), Key1) == 0;
        if (!EnumK.Next()) {
            tstLog(TERSE, "Failed to read second subkey");
            return TST_FAIL;
        }
        if (lstrcmp(EnumK.KeyName(), bFirst ? Key2 : Key1)) {
            tstLog(TERSE, "Second key name wrong");
            return TST_FAIL;
        }
        if (EnumK.Next()) {
            tstLog(TERSE, "Found too many subkeys");
            return TST_FAIL;
        }
        CEnumValue EnumV(HKEY_CURRENT_USER, OurKey, &hr);
        if (!EnumV.Next()) {
            tstLog(TERSE, "Failed to read first value");
            return TST_FAIL;
        }
        BOOL GotDWORD;
        switch (EnumV.ValueType())
        {
        case REG_DWORD:
            GotDWORD = TRUE;
            if (EnumV.ValueLength() != sizeof(DWORD)) {
                tstLog(TERSE, "Value length incorrect");
                return TST_FAIL;
            }
            if (memcmp((PVOID)EnumV.Data(), (PVOID)Data1, dwLen1)) {
                tstLog(TERSE, "First value incorrect");
                return TST_FAIL;
            }
            break;
        case REG_BINARY:
            GotDWORD = FALSE;
            if (EnumV.ValueLength() != dwLen2) {
                tstLog(TERSE, "Value length incorrect");
                return TST_FAIL;
            }
            if (memcmp((PVOID)EnumV.Data(), (PVOID)Data2, dwLen2)) {
                tstLog(TERSE, "Second value incorrect");
                return TST_FAIL;
            }
            break;
        default:
            tstLog(TERSE, "Incorrect data type");
            return TST_FAIL;
        }
        if (!EnumV.Next()) {
            tstLog(TERSE, "Failed to read second value");
            return TST_FAIL;
        }
        if (EnumV.ValueLength() != sizeof(DWORD)) {
            tstLog(TERSE, "Value length incorrect");
            return TST_FAIL;
        }
        if (GotDWORD) {
            if (EnumV.ValueType() != REG_BINARY ||
                memcmp((PVOID)EnumV.Data(), (PVOID)Data2, dwLen2)) {
                tstLog(TERSE, "Seoncd value incorrect");
                return TST_FAIL;
            }
        } else {
            if (EnumV.ValueType() != REG_DWORD ||
                memcmp((PVOID)EnumV.Data(), (PVOID)Data1, dwLen1)) {
                tstLog(TERSE, "Second value incorrect");
                return TST_FAIL;
            }
        }
        if (EnumV.Next()) {
            tstLog(TERSE, "Too many values");
            return TST_FAIL;
        }
    }

    FreeKey(HKEY_CURRENT_USER, OurKey);
    {
        /*  Try some long values */
        CEnumValue EnumV(HKEY_CURRENT_USER, OurKey, &hr, TRUE);
    }
    return TST_PASS;
}


STDAPI_(int) TestCReg()
{
    int result = Tests();
    FreeKey(HKEY_CURRENT_USER, OurKey);
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\util\code\geterror.cpp ===
//--------------------------------------------------------------------------;
//
//  File: geterror.cpp
//
//  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//       Functions to get the error text for a given HRESULT.
//
//  Contents:
//
//  History:
//      06/11/96 PeterGib   Moved from header file to be exported from DLL
//
//      09/08/96 StephenE   Added WINAPI calling convention and removed
//                          unecessary unicode quartz.dll string, also
//                          made string literal const.
//
//--------------------------------------------------------------------------;

#include <windows.h>

#define _AMOVIE_
#include "errors.h"


const char quartzdllname[] = "quartz.dll";

// We try to obtain resources strings in the languages shown below
LANGID Lang[] = {
    // Quartz is a system object, try the system default language first
    MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
    // Failing that try the users preferred language
    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),     
    // Otherwise go for anything!
    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)     
};

const int iLangIds = sizeof Lang / sizeof Lang[0];


// Unicode Version..
// This function stores the requested message in the buffer passed.
//
// Inputs: HRESULT - the message id
//         WCHAR * - address of the buffer to store the message in.
//         DWORD   - length of the supplied buffer
// Output: DWORD   - the number of characters stored in the buffer.

DWORD WINAPI AMGetErrorTextW(HRESULT hr, WCHAR *pbuffer, DWORD MaxLen)
{
    HMODULE hMod = GetModuleHandleA(quartzdllname);
    DWORD result=0;
    int i=0;

    // Look for Quartz messages
    do {
        result = FormatMessageW(FORMAT_MESSAGE_IGNORE_INSERTS |
                               FORMAT_MESSAGE_FROM_HMODULE |
                               FORMAT_MESSAGE_FROM_SYSTEM,
                               hMod,
                               hr,
                               Lang[i++],
                               pbuffer,
                               MaxLen,
                               NULL);
    } while(result == 0 && i<iLangIds);

    // Failing that look for system messages
    for(i = 0; i<iLangIds && !result; i++)
        result = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                               NULL,
                               hr,
                               Lang[i++],
                               pbuffer,
                               MaxLen,
                               NULL);

    return result;
}




// ANSI version
// This function stores the requested message in the buffer passed.
//
// Inputs: HRESULT - the message id
//         char *  - address of the buffer to store the message in.
//         DWORD   - length of the supplied buffer
// Output: DWORD   - the number of bytes stored in the buffer.

DWORD WINAPI AMGetErrorTextA(HRESULT hr , char *pbuffer , DWORD MaxLen)
{
    HMODULE hMod = GetModuleHandleA(quartzdllname);
    DWORD result=0;
    int i=0;

    do {
        result = FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS |
                               FORMAT_MESSAGE_MAX_WIDTH_MASK |
                               FORMAT_MESSAGE_FROM_HMODULE |
                               FORMAT_MESSAGE_FROM_SYSTEM,
                               hMod,
                               hr,
                               Lang[i++],
                               pbuffer,
                               MaxLen,
                               NULL);
    } while(result == 0 && i<iLangIds);

    // Failing that look for system messages
    for(i = 0; i<iLangIds && !result; i++)
        result = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
                               NULL,
                               hr,
                               Lang[i++],
                               pbuffer,
                               MaxLen,
                               NULL);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\util\test\ftyptest.cpp ===
// Copyright (c) Microsoft Corporation 1996. All Rights Reserved

#include <streams.h>
#include <mmsystem.h>
#include <ftype.h>
#include <tstshell.h>
#include <commdlg.h>
#include "utiltest.h"

/*  Test GetMediaTypeFile */

STDAPI_(int) TestGetMediaTypeFile()
{
    TCHAR szFile[MAX_PATH];
    szFile[0] = TEXT('\0');
    /*  Just ask for a file and test it */
    OPENFILENAME ofn;
    ZeroMemory((LPVOID)&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.lpstrFilter = TEXT("Files\0*.*\0\0");
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = TEXT("Select file to test type");
    ofn.Flags = OFN_FILEMUSTEXIST;

    if (!GetOpenFileName(&ofn)) {
        DbgLog((LOG_TRACE, 0, TEXT("GetOpenFileName failed code 0x%8.8X"),
                CommDlgExtendedError()));
    }
    GUID Type;
    GUID Subtype;
    CLSID Source;
    timeBeginPeriod(1);
    DWORD dwTime = timeGetTime();
    HRESULT hr = GetMediaTypeFile(szFile, &Type, &Subtype, &Source);
    dwTime = timeGetTime() - dwTime;
    tstLog(TERSE, "GetMediaTypeFile() took %d milliseconds", dwTime);
    timeEndPeriod(1);
    if (SUCCEEDED(hr)) {
        tstLog(TERSE, "Major type %s, Subtype %s, Source %s",
               GuidNames[Type],
               GuidNames[Subtype],
               GuidNames[Source]);
    } else {
        tstLog(TERSE, "GetMediaTypeFile returned 0x%8.8X", hr);
    }
    /*  Create a bunch of values */
    GUID guidArr[50];
    for (int i = 0; i < 50; i++) {
        CoCreateGuid(&guidArr[i]);
    }
    tstLog(TERSE, "Creating 50 new entries");
    for (i = 0; i < 50; i++) {
        HRESULT hr = SetMediaTypeFile(&guidArr[i], &guidArr[i], &guidArr[i], TEXT("4, 4, FFFFFFFF, 00000000"));
        if (FAILED(hr)) {
            tstLog(TERSE, "Failed to create entry");
            break;
        }
        hr = SetMediaTypeFile(&MEDIATYPE_Stream, &guidArr[i], &CLSID_FileSource, TEXT("4, 4, FFFFFFFF, 00000000"));
        if (FAILED(hr)) {
            tstLog(TERSE, "Failed to create entry");
            break;
        }
    }
    timeBeginPeriod(1);
    dwTime = timeGetTime();
    hr = GetMediaTypeFile(szFile, &Type, &Subtype, &Source);
    dwTime = timeGetTime() - dwTime;
    tstLog(TERSE, "GetMediaTypeFile() took %d milliseconds", dwTime);
    timeEndPeriod(1);
    if (SUCCEEDED(hr)) {
        tstLog(TERSE, "Major type %s, Subtype %s, Source %s",
               GuidNames[Type],
               GuidNames[Subtype],
               GuidNames[Source]);
    } else {
        tstLog(TERSE, "GetMediaTypeFile returned 0x%8.8X", hr);
    }
    while (i-- > 0) {
        DeleteMediaTypeFile(&guidArr[i], &guidArr[i]);
        DeleteMediaTypeFile(&MEDIATYPE_Stream, &guidArr[i]);
    }
    return TST_PASS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\util\test\utiltest.cpp ===
//--------------------------------------------------------------------------;
//
//  File: StrmTest.cpp
//
//  Copyright (c) 1993,1996 Microsoft Corporation.  All rights reserved
//
//  Abstract:
//
//  Contents:
//      tstGetTestInfo()
//      tstInit()
//      execTest()
//      tstTerminate()
//
//  History:
//      08/03/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

#include <streams.h>    // Streams architecture
//#include <windows.h>    // Include file for windows APIs
#include <windowsx.h>   // Windows macros etc.
#include <tstshell.h>   // Include file for the test shell's APIs
#include "utiltest.h"   // Various includes, constants, prototypes, globals


// Globals

HWND    ghwndTstShell;  // A handle to the main window of the test shell.
                        // It's not used here, but may be used by test apps.

HINSTANCE hinst;        // A handle to the running instance of the test
                        // shell.  It's not used here, but may be used by
                        // test apps.

HMENU   hmenuOptions;   // A handle to the options menu

LPTSTR          szAppName = TEXT("Quartz utility tests");

//--------------------------------------------------------------------------;
//
//  int tstGetTestInfo
//
//  Description:
//      Called by the test shell to get information about the test.  Also
//      saves a copy of the running instance of the test shell.
//
//      We also do most basic initialisation here (including instantiating
//      the test sink object) so that the custom profile handler can set
//      everything up when running automatically from a profile.
//
//  Arguments:
//      HINSTANCE hinstance: A handle to the running instance of the test
//          shell
//
//      LPSTR lpszTestName: Pointer to buffer of name for test.  Among
//          other things, it is used as a caption for the main window and
//          as the name of its class.  Always ANSI.
//
//      LPSTR lpszPathSection: Pointer to buffer of name of section in
//          win.ini in which the default input and output paths are
//          stored.  Always ANSI.
//
//      LPWORD wPlatform: The platform on which the tests are to be run,
//          which may be determined dynamically.  In order for a test to
//          be shown on the run list, it must have all the bits found in
//          wPlatform turned on.  It is enough for one bit to be turned off
//          to disqualify the test.  This also means that if this value is
//          zero, all tests will be run.  In order to make this more
//          mathematically precise, I shall give the relation which Test
//          Shell uses to decide whether a test with platform flags
//          wTestPlatform may run:  It may run if the following is TRUE:
//          ((wTestPlatform & wPlatform) == wPlatform)
//
//  Return (int):
//      The value which identifies the test list resouce (found in the
//      resource file).
//
//  History:
//      08/03/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

int tstGetTestInfo
(
    HINSTANCE   hinstance,
    LPSTR       lpszTestName,
    LPSTR       lpszPathSection,
    LPWORD      wPlatform
)
{
    hinst = hinstance;      // Save a copy of a handle to the running instance

    CoInitialize(NULL);            // Initialise COM library
    DbgInitialise(hinst);

    // It might have been nice to have this a few lines earlier
    // - but we gotta do DbgInitialise first!
    DbgLog((LOG_TRACE, 1, TEXT("Entering tstInit")));

    // Pass app name to test shell
#ifdef UNICODE
    WideCharToMultiByte(CP_ACP, 0, szAppName, -1, lpszTestName, 100, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, szAppName, -1, lpszPathSection, 100, NULL, NULL);
#else
    lstrcpy(lpszTestName, szAppName);
    lstrcpy(lpszPathSection, szAppName);
#endif

    *wPlatform = 0;         // The platform the test is running on, to be
                            // determined dynamically.
    return TEST_LIST;
} // tstGetTestInfo()




//--------------------------------------------------------------------------;
//
//  BOOL tstInit
//
//  Description:
//      Called by the test shell to provide the test program with an
//      opportunity to do whatever initialization it needs to do before
//      user interaction is initiated.  It also provides the test program
//      with an opportunity to keep a copy of a handle to the main window,
//      if the test program needs it.  In order to use some of the more
//      advanced features of test shell, several installation must be done
//      here:
//
//      -- All menu installation must be done here by calling
//          tstInstallCustomTest (that is, all menus that the test
//          application wants to add).
//
//      -- If the test application wants to trap the window messages of
//          the main test shell window, it must install its default
//          window procedure here by calling tstInstallDefWindowProc.
//
//      -- If the test application would like to use the status bar for
//          displaying the name of the currently running test, it must
//          call tstDisplayCurrentTest here.
//
//      -- If the test application would like to change the stop key from
//          ESC to something else, it must do so here by calling
//          tstChangeStopVKey.
//
//      -- If the test application would like to add dynamic test cases
//          to the test list, it must first add their names to the
//          virtual string table using tstAddNewString (and add their
//          group's name too), and then add the actual tests using
//          tstAddTestCase.  The virtual string table is an abstraction
//          which behaves just like a string table from the outside with
//          the exception that it accepts dynamically added string.
//
//  Arguments:
//      HWND hwndMain: A handle to the main window
//
//  Return (BOOL):
//      TRUE if initialization went well, FALSE otherwise which will abort
//      execution.
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

BOOL tstInit
(
    HWND    hwndMain
)
{
   // Keep a copy of a handle to the main window
    ghwndTstShell = hwndMain;

    // This is a shell API which tells Test Shell to display the name of
    // the currenly executing API in its status bar.  It is a really nice
    // feature for test applications which do not use the toolbar for any
    // other purpose, as it comfortably notifies the user of the progress
    // of the tests.
    tstDisplayCurrentTest();

    // Change the stop key from ESC to SPACE
    tstChangeStopVKey (VSTOPKEY);

    DbgLog((LOG_TRACE,1, TEXT("Exiting tstInit")));
    return(TRUE);
} // tstInit()




//--------------------------------------------------------------------------;
//
//  int execTest
//
//  Description:
//      This is the actual test function which is called from within the
//      test shell.  It is passed various information about the test case
//      it is asked to run, and branches off to the appropriate test
//      function.  Note that it needs not switch on nFxID, but may also
//      use iCase or wID.
//
//  Arguments:
//      int nFxID: The test case identifier, also found in the third column
//          in the third column of the test list in the resource file
//
//      int iCase: The test case's number, which expresses the ordering
//          used by the test shell.
//
//      UINT wID: The test case's string ID, which identifies the string
//          containing the description of the test case.  Note that it is
//          also a good candidate for use in the switch statement, as it
//          is unique to each test case.
//
//      UINT wGroupID: The test case's group's string ID, which identifies
//          the string containing the description of the test case's group.
//
//  Return (int): Indicates the result of the test by using TST_FAIL,
//          TST_PASS, TST_OTHER, TST_ABORT, TST_TNYI, TST_TRAN, or TST_TERR
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

int execTest
(
    int     nFxID,
    int     iCase,
    UINT    wID,
    UINT    wGroupID
)
{
    int ret = TST_OTHER;

    tstBeginSection(" ");

    switch(nFxID)
    {
        //
        //  The test cases
        //

        case FX_TEST2:
            ret = TestArithmetic();
            break;

        case FX_TEST3:
            ret = TestCReg();
            break;

        case FX_TEST4:
            ret = TestGetMediaTypeFile();
            break;

        default:
            break;
    }

    tstEndSection();

    return(ret);

} // execTest()




//--------------------------------------------------------------------------;
//
//  void tstTerminate
//
//  Description:
//      This function is called when the test series is finished to free
//      structures and do whatever cleanup work it needs to do.  If it
//      needs not do anything, it may just return.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

void tstTerminate
(
    void
)
{
    DbgLog((LOG_TRACE, 1, TEXT("Entering tstTerminate")));

    DbgTerminate();
    CoUninitialize();

    DbgLog((LOG_TRACE, 1, TEXT("Exiting tstTerminate")));
    return;
} // tstTerminate()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\core\util\test\utiltest.h ===
/***************************************************************************\
*                                                                           *
*   File: UtilTest.h                                                        *
*                                                                           *
*   Copyright (c) 1996 Microsoft Corporation.  All rights reserved          *
*                                                                           *
\***************************************************************************/


// Prototypes



// From tests.cpp
STDAPI_(int) TestArithmetic();
STDAPI_(int) TestCReg();
STDAPI_(int) TestGetMediaTypeFile();

// Constants

// Stops the logging intensive test
#define VSTOPKEY            VK_SPACE


// The string identifiers for the group's names
#define GRP_UTIL            100
#define GRP_LAST            GRP_UTIL

// The string identifiers for the test's names
#define ID_TEST1           200
#define ID_TEST2           201
#define ID_TEST3           202
#define ID_TEST4           203
#define ID_TESTLAST        ID_TEST4

// The test case identifier (used in the switch statement in execTest)
#define FX_TEST1            300
#define FX_TEST2            301
#define FX_TEST3            302
#define FX_TEST4            303

// Identifies the test list section of the resource file
#define TEST_LIST           500

// Global variables

extern HWND         ghwndTstShell;      // Handle to test shell main window
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvdec\decode.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.

// flags for lFlags in codec capability
#define AM_DVDEC_Full		0x00000001
#define AM_DVDEC_Half		0x00000002
#define AM_DVDEC_Quarter	0x00000004
#define AM_DVDEC_DC	        0x00000008

#define AM_DVDEC_NTSC		0x00000010
#define AM_DVDEC_PAL		0x00000020

// This number includes on the Modes our code supports in it's current state.
// Currently these modes are YUY2 UYVY RGB24 RGB565 RGB555 RGB8 RGB32 ARGB32


#define AM_DVDEC_CSNUM  8               //Increment when adding a new color space below.



#define AM_DVDEC_YUY2		0x00000040
#define AM_DVDEC_UYVY		0x00000080
#define AM_DVDEC_RGB24		0x00000100
#define AM_DVDEC_RGB565		0x00000200
#define AM_DVDEC_RGB555		0x00000400
#define AM_DVDEC_RGB8		0x00000800
#define AM_DVDEC_Y41P		0x00001000
#define AM_DVDEC_RGB32		0X00001100
#define AM_DVDEC_ARGB32         0x00001200


#define AM_DVDEC_DVSD		0x00002000
#define AM_DVDEC_DVHD		0x00004000
#define AM_DVDEC_DVSL		0x00008000

#define AM_DVDEC_DV		0x00010000
#define AM_DVDEC_DVCPRO		0x00020000

#define AM_DVDEC_MMX		0x01000000
#define AM_DVDEC_DR219RGB	0x00100000
		
typedef unsigned long DWORD;



//extern "C" int	__fastcall DvDecodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );

extern "C" int __stdcall    DvDecodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, long lwidth, char *pMem);
//extern "C" int	__stdcall   DvDecodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem,
//					 unsigned int iWidth, unsigned char bFlag);
//extern "C" int	__cdecl DvDecodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );


int  InitMem4Decoder(char **ppMem,DWORD dwCodecReq);
void TermMem4Decoder(char *pMem);

DWORD GetCodecCapabilities(  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvdec\pdecode.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "decode.h"

 int	InitMem4Decoder( char **ppMem, DWORD dwCodecReq )
 {
     *ppMem=NULL;
     return S_OK;
 }

 void	TermMem4Decoder(char *pMem)
 {
     if(pMem!=NULL)
	delete[] pMem;
 }

DWORD GetCodecCapabilities(  )
{

    DWORD cap;
    cap =   AM_DVDEC_DC	    | AM_DVDEC_Quarter | AM_DVDEC_Half | AM_DVDEC_Full | 
	    AM_DVDEC_NTSC   | AM_DVDEC_PAL	|
	    AM_DVDEC_RGB24  | AM_DVDEC_UYVY  | AM_DVDEC_YUY2 | AM_DVDEC_RGB565 | AM_DVDEC_RGB555 |
	    AM_DVDEC_RGB8   | 
            AM_DVDEC_DR219RGB |
	    AM_DVDEC_DVSD   | AM_DVDEC_MMX; 
    return cap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvdec\resource.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by display.rc
//
#define IDS_DECTITLE                    1
#define IDD_DVDec                       101
#define IDC_DEC720x480                  1000
#define IDC_DEC360x240                  1001
#define IDC_DEC180x120                  1002
#define IDC_DEC88x60                    1003
#define IDC_DISPLAY                     1004
#define IDC_CHECKSAVEASDEFAULT           1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvdec\dvdec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
/******************************Module*Header*******************************\
* Module Name: DVVideo.h
*
* Prototype DV Video codec
*
\**************************************************************************/

#ifndef __DVDEC__
#define __DVDEC__

extern const AMOVIESETUP_FILTER sudDVVideo;

				
#define MAXSAMPLEQUEUE 20	// 20 is enough to hold half second worth video stream


#define FLUSH		   ((IMediaSample *)0xFFFFFFFC)  
#define STOPSTREAM	   ((IMediaSample *)0xFFFFFFFD)  
#define ENDSTREAM	   ((IMediaSample *)0xFFFFFFFE)  

		
#define DEFAULT_QUEUESIZE   2

typedef struct _PROP
{
    int iDisplay;
    long lPicWidth;
    long lPicHeight;
}PROP;

class CDVVideoCodec
	: public CVideoTransformFilter,
	  public IIPDVDec,
	  public ISpecifyPropertyPages,
	  public CPersistStream,
      public IDVRGB219

{

public:

    //
    // --- Com stuff ---
    //
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);
    static void InitClass(BOOL, const CLSID *);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    DECLARE_IUNKNOWN;

    //
    // --- CVideoTransformFilter overrides ---
    //
    HRESULT Transform(IMediaSample * pIn, IMediaSample *pOut);

    HRESULT CheckInputType(const CMediaType* mtIn);
    HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut);
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES * pProperties);
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT StartStreaming(void);
    HRESULT StopStreaming(void);
    HRESULT Receive(IMediaSample *pSample);


    // Quality control notifications sent to us
    HRESULT AlterQuality(Quality q);
    
    CDVVideoCodec(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *pHr);
    ~CDVVideoCodec();

    // CPersistStream override
    STDMETHODIMP GetClassID(CLSID *pClsid);
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();

    // These implement the custom IIPDVDec interface
    STDMETHODIMP get_IPDisplay(int *iDisplay);
    STDMETHODIMP put_IPDisplay(int iDisplay);

    // ISpecifyPropertyPages interface
    STDMETHODIMP GetPages(CAUUID *pPages);

    // IDVRGB219 interface
    STDMETHODIMP SetRGB219 (BOOL bState);


private:
    char		*m_pMem4Dec;
    LPBYTE		m_pSample;
    int			m_perfidDVDeliver;

    CCritSec		m_DisplayLock;  // Private play critical section
    int			m_iDisplay;     // Which display are we processing
    long		m_lPicWidth;
    long		m_lPicHeight;

    void		InitDestinationVideoInfo(VIDEOINFO *pVI, DWORD Comp, int n);
    
    BOOL		m_fStreaming;   
    DWORD		m_CodecCap;	    //what the Codec can do 
    DWORD		m_CodecReq;     //what users want it to do
    long		m_lStride;
    
    int		    m_iOutX;		//X value of Aspect Ratio Displayed
	int		    m_iOutY;		//Y value of Aspect Ratio Displayed
    
    char	        *m_pMem;		//memory for MEI's decoder
    char	        *m_pMemAligned;		//m_pMem aligned on 8 byte boundary

    BOOL		m_bUseVideoInfo2;   //Indicates that we are using the VIDEOINFOHEADER2 structure with 
									// downstream filter
    BOOL        m_bRGB219;          // TRUE if the 219 range is required

    //////////////////////////////////////////////////////////////////////////
    // DVCPRO format detection variables
    // we set the m_bExamineFirstValidFrameFlag flag in StartStreaming()
    // and we check it in Transform() to see if we should parse the first frame
    // note: we don't check it in Receive(), because Receive() calls
    // StartStreaming() again.
    // and detect DVCPRO format
    // the flag is then cleared.
    //////////////////////////////////////////////////////////////////////////
    BOOL                m_bExamineFirstValidFrameFlag;    // look at the first frame

    //////////////////////////////////////////////////////////////////////////
    // strategy:
    // only perform quality control if AlterQuality() overloaded function has 
    // been called at least once. otherwise do not drop frames.
    //////////////////////////////////////////////////////////////////////////
    BOOL                m_bQualityControlActiveFlag;      // should we be performing quality control

    // private utility methods for registry reading
    void                ReadFromRegistry();


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvdec\decprop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#include <windows.h>
#include <windowsx.h>
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
//#include <initguid.h>

#include "DecProp.h"
#include "resource.h"

const TCHAR *szSubKey =
    TEXT("Software\\Microsoft\\DirectShow\\DVDecProperties");
const TCHAR *szPropValName =
    TEXT("PropDisplay");

//
// CreateInstance
//
// Used by the ActiveMovie base classes to create instances
//
CUnknown *CDVDecProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CDVDecProperties(lpunk, phr);
    if (punk == NULL) {
	*phr = E_OUTOFMEMORY;
    }
    return punk;

} // CreateInstance


//
// Constructor
//
CDVDecProperties::CDVDecProperties(LPUNKNOWN pUnk, HRESULT *phr) :
    CBasePropertyPage(NAME("DVDec Property Page"),
                      pUnk,IDD_DVDec,IDS_DECTITLE),
    m_pIPDVDec(NULL),
    m_bIsInitialized(FALSE)
{
    ASSERT(phr);

} // (Constructor)


//
// OnReceiveMessage
//
// Handles the messages for our property window
//
INT_PTR CDVDecProperties::OnReceiveMessage(HWND hwnd,
                                           UINT uMsg,
                                           WPARAM wParam,
                                           LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_COMMAND:
        {
            if (m_bIsInitialized)
            {
                m_bDirty = TRUE;
                if (m_pPageSite)
                {
                    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
                }
            }
            return (LRESULT) 1;
        }

    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

} // OnReceiveMessage


//
// OnConnect
//
// Called when we connect to a transform filter
//
HRESULT CDVDecProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pIPDVDec == NULL);

    HRESULT hr = pUnknown->QueryInterface(IID_IIPDVDec, (void **) &m_pIPDVDec);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    ASSERT(m_pIPDVDec);

    // Get the initial  property
    m_pIPDVDec->get_IPDisplay(&m_iPropDisplay);
    m_bIsInitialized = FALSE ;
    return NOERROR;

} // OnConnect


//
// OnDisconnect
//
// Likewise called when we disconnect from a filter
//
HRESULT CDVDecProperties::OnDisconnect()
{
    // Release of Interface after setting the appropriate old effect value

    if (m_pIPDVDec == NULL) {
        return E_UNEXPECTED;
    }

    m_pIPDVDec->Release();
    m_pIPDVDec = NULL;
    return NOERROR;

} // OnDisconnect


//
// OnActivate
//
// We are being activated
//
HRESULT CDVDecProperties::OnActivate()
{
    
    CheckRadioButton(m_Dlg, IDC_DEC720x480, IDC_DEC88x60, m_iPropDisplay);
    m_bIsInitialized = TRUE;
    return NOERROR;

} // OnActivate


//
// OnDeactivate
//
// We are being deactivated
//
HRESULT CDVDecProperties::OnDeactivate(void)
{
    ASSERT(m_pIPDVDec);
    m_bIsInitialized = FALSE;
    GetControlValues();
    return NOERROR;

} // OnDeactivate


//
// OnApplyChanges
//
// Apply any changes so far made 
//
HRESULT CDVDecProperties::OnApplyChanges()
{
    HRESULT hr = NOERROR;

    GetControlValues();

    // if user wants to save settings as default
    if(m_bSetAsDefaultFlag)
    {
        // try to save
        hr = SavePropertyInRegistry();
    }

    // try to apply settings to current video in all cases, and propagate error code
    return (hr | ( m_pIPDVDec->put_IPDisplay(m_iPropDisplay) ));
    
} // OnApplyChanges


//
// GetControlValues
//
// Get the values of the DlgBox controls
// and set member variables to their values
//
void CDVDecProperties::GetControlValues()
{
    ASSERT(m_pIPDVDec);

    // Find which special DVDec we have selected
    for (int i = IDC_DEC720x480; i <= IDC_DEC88x60; i++) {
       if (IsDlgButtonChecked(m_Dlg, i)) {
            m_iPropDisplay = i;
            break;
        }
    }

    // Find if the Save As Default button is checked or not
    m_bSetAsDefaultFlag = (IsDlgButtonChecked(m_Dlg, IDC_CHECKSAVEASDEFAULT) == BST_CHECKED);

    // if Save as default is checked, then clear it
    if(m_bSetAsDefaultFlag)
    {
        // this msg always returns 0, no need to error check
        SendDlgItemMessage(m_Dlg, IDC_CHECKSAVEASDEFAULT, BM_SETCHECK, (WPARAM) BST_UNCHECKED, 0);
    }
}


//
// SavePropertyInRegistry
//
// Save the m_iPropDispay to the registry
// so the correct default property can be loaded by the
// filter next time
//
HRESULT CDVDecProperties::SavePropertyInRegistry()
{
    HKEY    hKey = NULL;
    LRESULT lResult = 0;
    DWORD   dwStatus = 0;

    // just try to create the key everytime,
    // it will either open existing, or try to create a new one
    if((lResult = RegCreateKeyEx(HKEY_CURRENT_USER,             // open key
                                    szSubKey,                   // sub key string
                                    0,                          // reserved
                                    NULL,                       // class string
                                    REG_OPTION_NON_VOLATILE,    // special options
                                    KEY_WRITE,                  // Security access
                                    NULL,                       // default security descriptor
                                    &hKey,                      // resulting key handle
                                    &dwStatus                   // status of creation (new/old key)
                                    )) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    // now that we have a key, set the value for the key
    if((lResult = RegSetValueEx(hKey,                           // open key
                                szPropValName,                  // name of the value
                                0,                              // reserved
                                REG_DWORD,                      // type of the value
                                (const BYTE*) &m_iPropDisplay,  // pointer to value data
                                sizeof(m_iPropDisplay)          // sizeof data
                                )) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvdec\decprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// externs
extern const TCHAR *szSubKey;
extern const TCHAR *szPropValName;


// class definition
class CDVDecProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

private:

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void    GetControlValues();
    HRESULT SavePropertyInRegistry();

    CDVDecProperties(LPUNKNOWN lpunk, HRESULT *phr);

    BOOL m_bIsInitialized;				// Used to ignore startup messages

    // Display state holders
    int     m_iPropDisplay;                             // holds the id of the property chosen
    BOOL    m_bSetAsDefaultFlag;                        // holds whether user chose to set the property as future default

    IIPDVDec *m_pIPDVDec;				// The custom interface on the filter
   //IIPDVDec *pIPDVDec(void) { ASSERT(m_pIPDVDec); return m_pIPDVDec; }


}; // DVDecProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvenc\dvenc.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
/******************************Module*Header*******************************\
* Module Name: dvenc.cpp
*
* Implements a prototype DV Video Encoder AM filter.  
*
\**************************************************************************/
#include <streams.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <stddef.h>
#include <string.h>
#ifndef FILTER_LIB									    
#include <initguid.h>
#endif
#include <olectl.h>

#include <dv.h>
#include "encode.h"
#include "Encprop.h"
#include "dvenc.h"
#include "resource.h"

#define WRITEOUT(var)  hr = pStream->Write(&var, sizeof(var), NULL); \
		       if (FAILED(hr)) return hr;

#define READIN(var)    hr = pStream->Read(&var, sizeof(var), NULL); \
		       if (FAILED(hr)) return hr;


// setup data
const AMOVIESETUP_MEDIATYPE
psudOpPinTypes[] = { { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvsd  }		// clsMinorType
                   , { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvhd}		// clsMinorType
					, { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvsl}		// clsMinorType
		     }; 

const AMOVIESETUP_MEDIATYPE
sudIpPinTypes = { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN
psudPins[] = { { L"Input"            // strName
               , FALSE               // bRendered
               , FALSE               // bOutput
               , FALSE               // bZero
               , FALSE               // bMany
               , &CLSID_NULL         // clsConnectsToFilter
               , L"Output"           // strConnectsToPin
               , 1                   // nTypes
               , &sudIpPinTypes }    // lpTypes
             , { L"Output"           // strName
               , FALSE               // bRendered
               , TRUE                // bOutput
               , FALSE               // bZero
               , FALSE               // bMany
               , &CLSID_NULL         // clsConnectsToFilter
               , L"Input"	     // strConnectsToPin
               , 1                   // nTypes
               , psudOpPinTypes } }; // lpTypes

const AMOVIESETUP_FILTER
sudDVEnc = { &CLSID_DVVideoEnc	// clsID
               , L"DV Video Encoder"	// strName
               , MERIT_DO_NOT_USE         // dwMerit
               , 2                      // nPins
               , psudPins };            // lpPin

#ifdef FILTER_DLL
/* -------------------------------------------------------------------------
** list of class ids and creator functions for class factory
** -------------------------------------------------------------------------
*/
CFactoryTemplate g_Templates[] =
{
    { L"DV Video Encoder", 
    &CLSID_DVVideoEnc, 
    CDVVideoEnc::CreateInstance,
    NULL,
    NULL
    },
    {L"Format",
    &CLSID_DVEncPropertiesPage, 
    CDVEncProperties::CreateInstance
    }

};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

const WCHAR *g_wszUniq = L"DV Video Encoder" ;

STDAPI DllRegisterServer()
{
 HRESULT hr = AMovieDllRegisterServer2( TRUE );
 if( FAILED(hr) )
     return hr;

 
 
 IFilterMapper2 *pFm2 = 0;

 hr = CoCreateInstance( CLSID_FilterMapper2
                         , NULL
                         , CLSCTX_INPROC_SERVER
                         , IID_IFilterMapper2
                         , (void **)&pFm2       );
    
 if(FAILED(hr))
     return hr;


 hr = pFm2->RegisterFilter(
      CLSID_DVVideoEnc,
      g_wszUniq,
      0,
      &CLSID_VideoCompressorCategory,
      g_wszUniq,
      MERIT_DO_NOT_USE,
      NULL,
      0);

 pFm2->Release();
 
 return hr;

}

STDAPI DllUnregisterServer()
{

 HRESULT hr = AMovieDllRegisterServer2( FALSE );
 if( FAILED(hr) )
     return hr;

 
 IFilterMapper2 *pFm2 = 0;

 hr = CoCreateInstance( CLSID_FilterMapper2
                         , NULL
                         , CLSCTX_INPROC_SERVER
                         , IID_IFilterMapper2
                         , (void **)&pFm2       );
    
 if(FAILED(hr))
     return hr;


 hr = pFm2->UnregisterFilter(
      &CLSID_VideoCompressorCategory,
      g_wszUniq,
      CLSID_DVVideoEnc);

 pFm2->Release();
 
 return hr;
}
#endif

//* -------------------------------------------------------------------------
//** CDVVideoEnc
//** -------------------------------------------------------------------------
CDVVideoEnc::CDVVideoEnc(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr
    )
    : CTransformFilter(pName, pUnk, CLSID_DVVideoEnc),
    CPersistStream(pUnk, phr),
    m_fStreaming(0),
    m_iVideoFormat(IDC_NTSC),
    m_iDVFormat(IDC_dvsd),
    m_iResolution(IDC_720x480),
    m_fDVInfo(FALSE),	//as default we are not going to output DVINFO structure
    m_fConvert (0),
    m_pMem4Convert (NULL),
    m_lPicWidth(0),
    m_lPicHeight(0),
    m_EncCap(0),
    m_EncReg(0),
    m_bRGB219(FALSE)
{
    //set DVInfo to 0xff
    memset(&m_sDVInfo, 0xff, sizeof(DVINFO) );

    //get encoder's abilities
    m_EncCap=GetEncoderCapabilities(  );

}

CDVVideoEnc::~CDVVideoEnc(     )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::~CDVVideoEnc")));

}

/******************************Public*Routine******************************\
* CreateInstance
*
* This goes in the factory template table to create new instances
*
\**************************************************************************/
CUnknown *
CDVVideoEnc::CreateInstance(
    LPUNKNOWN pUnk,
    HRESULT * phr
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::CreateInstance")));
    return new CDVVideoEnc(TEXT("DV Video Encoder filter"), pUnk, phr);
}

//=============================================================================

// IAMVideoCompression stuff


HRESULT CDVVideoEnc::GetInfo(LPWSTR pszVersion, int *pcbVersion, LPWSTR pszDescription, int *pcbDescription, long FAR* pDefaultKeyFrameRate, long FAR* pDefaultPFramesPerKey, double FAR* pDefaultQuality, long FAR* pCapabilities)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMVideoCompression::GetInfo")));

    // we can't do anything programmatically
    if (pCapabilities)
        *pCapabilities = 0;
    if (pDefaultKeyFrameRate)
        *pDefaultKeyFrameRate = 0;
    if (pDefaultPFramesPerKey)
        *pDefaultPFramesPerKey = 0;
    if (pDefaultQuality)
        *pDefaultQuality = 0;

    if (pcbVersion == NULL && pcbDescription == NULL)
	return NOERROR;

    
    // get the driver version and description
    #define DESCSIZE 80
    WCHAR wachVer[DESCSIZE], wachDesc[DESCSIZE];

    wsprintfW(wachVer, L"Ver02");
    wsprintfW(wachDesc, L"MEI DV Software Encoder");


    // copy 
    if (pszVersion && pcbVersion)
        lstrcpynW(pszVersion, wachVer, min(*pcbVersion / 2, DESCSIZE));
    if (pszDescription && pcbDescription)
        lstrcpynW(pszDescription, wachDesc, min(*pcbDescription / 2, DESCSIZE));

    // return the length in bytes needed (incl. NULL)
    if (pcbVersion)
	*pcbVersion = lstrlenW(wachVer) * 2 + 2;
    if (pcbDescription)
	*pcbDescription = lstrlenW(wachDesc) * 2 + 2;
    
    return NOERROR;
}

/******************************Public*Routine******************************\
* NonDelegatingQueryInterface
*
* Here we would reveal ISpecifyPropertyPages and IDVVideoDecoder if
* the framework had a property page.
*
\**************************************************************************/
STDMETHODIMP
CDVVideoEnc::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv
    )
{
    if (riid == IID_IDVEnc) {			    
        return GetInterface((IDVEnc *) this, ppv);
    } else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } else if (riid == IID_IAMVideoCompression) {
	return GetInterface((LPUNKNOWN)(IAMVideoCompression *)this, ppv);
    } else if(riid == IID_IPersistStream)
    {
        return GetInterface((IPersistStream *) this, ppv);
    } else if (riid == IID_IDVRGB219) {
        return GetInterface((IDVRGB219 *) this, ppv);
    } else {
        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }

}


HRESULT CDVVideoEnc::Transform(IMediaSample * pIn, IMediaSample *pOut)
{
    unsigned char *pSrc, *pDst;
    HRESULT hr = S_OK;
    
    CAutoLock lck(&m_csReceive);

    // get  output buffer
    hr = pOut->GetPointer(&pDst);
    if (FAILED(hr)) 
    {
        return NULL;
    }
    ASSERT(pDst);
    
    // get the source buffer
    hr = pIn->GetPointer(&pSrc);
    if (FAILED(hr)) 
    {
	return hr;
    }
    ASSERT(pDst);
    

    // if the source not standard 720*480 or 720*576, 
    // a convertion is nneded
    if( m_fConvert){

	// this code will stretch any RGB format, and the most popular YUV formats.
	// we stretch YUV by treating it as a 32-bit bitmap that's half as wide as the original. 
	
	CMediaType* pmtOut;
	pmtOut = &(m_pOutput->CurrentMediaType() );
	CMediaType* pmtIn;
	pmtIn = &(m_pInput->CurrentMediaType() );


	BITMAPINFOHEADER *pbiOut = HEADER(pmtOut->Format());
	BITMAPINFOHEADER *pbiIn = HEADER(pmtIn->Format());

	// normal RGB case
        DWORD dw1=pbiIn->biCompression;
	DWORD dw2=pbiOut->biCompression;
	pbiIn->biCompression = BI_RGB;
	pbiOut->biCompression = BI_RGB;

	StretchDIB(pbiOut, 
		m_pMem4Convert,
		0, 
		0, 
		pbiOut->biWidth, 
		pbiOut->biHeight,
		pbiIn,
		pSrc, 
		0, 
		0, 
		pbiIn->biWidth, 
		pbiIn->biHeight);

        //put original data back
        pbiIn->biCompression = dw1;
	pbiOut->biCompression = dw2;

	pSrc=(unsigned char *)m_pMem4Convert;
    }

    if( DvEncodeAFrame(pSrc,pDst, m_EncReg, m_pMem4Enc) != S_OK )
	return E_FAIL;

    if( m_iVideoFormat == IDC_NTSC )
	pOut->SetActualDataLength(120000);
    else
	pOut->SetActualDataLength(144000);


    return hr;
}

/******************************Public*Routine******************************\
* CheckInputType
* TYPE:	    MEDIATYPE_Video
* SubType:   
* FORMAT:   FORMAT_VideoInfo
\**************************************************************************/
HRESULT
CDVVideoEnc::CheckInputType(   const CMediaType* pmtIn    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::CheckInputType")));

    DWORD dwTmp=0;

    if ( *pmtIn->Type()	== MEDIATYPE_Video)	 
    {	
        if (*pmtIn->FormatType() != FORMAT_VideoInfo) 
        {
            return VFW_E_TYPE_NOT_ACCEPTED;
        }

    	
	if (  *pmtIn->Subtype()	 == MEDIASUBTYPE_UYVY  )
	{
	    dwTmp=AM_DVENC_UYVY	;
	}
	else if( *pmtIn->Subtype()	== MEDIASUBTYPE_YUY2 )
	{
	    dwTmp=AM_DVENC_YUY2;
	}
	else if(*pmtIn->Subtype()	== MEDIASUBTYPE_RGB565 )
	{
	    dwTmp=AM_DVENC_RGB565	;
	}
	else if(*pmtIn->Subtype()	== MEDIASUBTYPE_RGB555 )
	{
	    dwTmp=AM_DVENC_RGB565	;
	}
	else if(*pmtIn->Subtype()	== MEDIASUBTYPE_RGB24 )
	{
	    dwTmp=AM_DVENC_RGB24	;
	}
	else if(*pmtIn->Subtype()	== MEDIASUBTYPE_Y41P  )
    {
	    dwTmp=AM_DVENC_Y41P	;
    }
	else 
	    return VFW_E_TYPE_NOT_ACCEPTED;   //only converting RGB now.
			
	if( !(m_EncCap  & dwTmp) )
		return VFW_E_TYPE_NOT_ACCEPTED;   //only converting RGB now.



	//check image size
	VIDEOINFO *videoInfo = (VIDEOINFO *)pmtIn->pbFormat;
	
	m_lPicWidth	= videoInfo->bmiHeader.biWidth;
	m_lPicHeight	= videoInfo->bmiHeader.biHeight;

	if( ( ( m_lPicWidth == 720 ) && (m_lPicHeight == 480) && (m_iVideoFormat==IDC_NTSC) )  ||	
            ( ( m_lPicWidth == 720 ) && (m_lPicHeight == 576) && (m_iVideoFormat==IDC_PAL)  )   ||	
            ( m_EncCap & AM_DVENC_AnyWidHei ) 
          )
	    m_fConvert =0;
	else
	{
	    if (*pmtIn->Subtype() != MEDIASUBTYPE_RGB24 )
		return VFW_E_TYPE_NOT_ACCEPTED;   //only converting RGB now.
	    m_fConvert =1;
	}

    }
    else
	return VFW_E_TYPE_NOT_ACCEPTED;

	
   return S_OK;
}


/******************************Public*Routine******************************\
* CheckTransform				       
\**************************************************************************/
HRESULT
CDVVideoEnc::CheckTransform(
    const CMediaType* pmtIn,
    const CMediaType* pmtOut
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::CheckTransform")));


    // we only accept Video as  toplevel type.
    if (*pmtOut->Type() != MEDIATYPE_Video || *pmtIn->Type() != MEDIATYPE_Video)
    {
	return E_INVALIDARG;
    }

    if (*pmtOut->Subtype() != MEDIASUBTYPE_dvsd &&
    				*pmtOut->Subtype() != MEDIASUBTYPE_dvhd &&
    				*pmtOut->Subtype() != MEDIASUBTYPE_dvsl) {
	return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmtIn->FormatType() != FORMAT_VideoInfo) {
        return E_INVALIDARG;
    }

    if ( *pmtOut->FormatType() != FORMAT_VideoInfo) 
    {
        return E_INVALIDARG;
    }

    VIDEOINFO *videoInfo = (VIDEOINFO *)pmtIn->pbFormat;
	
    m_lPicWidth		= videoInfo->bmiHeader.biWidth;
    m_lPicHeight	= videoInfo->bmiHeader.biHeight;

    if( ( ( m_lPicWidth == 720 ) && (m_lPicHeight == 480) && (m_iVideoFormat==IDC_NTSC) )  ||	
            ( ( m_lPicWidth == 720 ) && (m_lPicHeight == 576) && (m_iVideoFormat==IDC_PAL)  )   ||	
            ( m_EncCap & AM_DVENC_AnyWidHei ) 
          )
    	m_fConvert =0;
    else
    {
    	if (*pmtIn->Subtype() != MEDIASUBTYPE_RGB24 )
	    return E_FAIL;
	m_fConvert =1;
    }

    return S_OK;
}


/******************************Public*Routine******************************\
* SetMediaType
*
* Overriden to know when the media type is actually set
*
\**************************************************************************/
HRESULT
CDVVideoEnc::SetMediaType(   PIN_DIRECTION direction, const CMediaType *pmt    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::SetMediaType")));

    if (direction == PINDIR_INPUT) 
    {
    }
    else 
    {
        SetOutputPinMediaType(pmt);
    }
    return S_OK;
}


/*****************************Private*Routine******************************\
* SetOutputPinMediaType
*
\**************************************************************************/
void
CDVVideoEnc::SetOutputPinMediaType(     const CMediaType *pmt    )
{    
	
    //
    // lStride is the distance between in bytes between a pel on the
    // screen and the pel directly underneath it.
    //
    VIDEOINFO   *pvi;
    LONG        lStride;
    LONG        lOffset;
    pvi = (VIDEOINFO *)pmt->pbFormat;
    lStride = ((pvi->bmiHeader.biWidth * pvi->bmiHeader.biBitCount) + 7) / 8;
    lStride = (lStride + 3) & ~3;


    //
    // lOffset is the distance in bytes from the top corner of the
    // target bitmap to the top corner of the video image.  When we are
    // using DIBs this value allways be zero.
    //
    // When we are using DCI/DirectDraw this value will only be zero if
    // we are drawing the video image at the top left hand corner of the
    // display.
    //

    lOffset = (((pvi->rcTarget.left * pvi->bmiHeader.biBitCount) + 7) / 8) +
                (pvi->rcTarget.top * lStride);

}

/******************************Public*Routine******************************\
* GetMediaType
*
* Return our preferred output media types (in order)
*
\**************************************************************************/
HRESULT
CDVVideoEnc::GetMediaType( int iPosition,  CMediaType *pmt )
{
    VIDEOINFO   *pVideoInfo;
    CMediaType  cmt;

    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::GetMediaType")));

    if (iPosition != 0) {
        return E_INVALIDARG;
    }
   

    //X* copy current media type from input pin
    cmt = m_pInput->CurrentMediaType();


    if  (*cmt.Type() != MEDIATYPE_Video)  
	return VFW_S_NO_MORE_ITEMS;

    //get input format
    VIDEOINFO *InVidInfo = (VIDEOINFO *)m_pInput->CurrentMediaType().pbFormat;

    //allocate memory for output format
    int iSize;

    //m_fDVInfo==TRUE;

    if(m_fDVInfo==TRUE)
	iSize=	SIZE_VIDEOHEADER+sizeof(DVINFO);
    else
	iSize=	SIZE_VIDEOHEADER;

    pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(iSize);
    if (pVideoInfo == NULL) {
        return E_OUTOFMEMORY;
    }
    

    LPBITMAPINFOHEADER lpbi = HEADER(pVideoInfo);

    if(m_fDVInfo==TRUE)
	iSize=	sizeof(BITMAPINFOHEADER)+sizeof(DVINFO);
    else
	iSize=	sizeof(BITMAPINFOHEADER);

    lpbi->biSize          = (DWORD) iSize;

    lpbi->biWidth         = 720;	

    if( m_iVideoFormat == IDC_NTSC )
    	lpbi->biHeight        = 480;	
    else
	lpbi->biHeight        = 576;

    lpbi->biPlanes        = 1;
    lpbi->biBitCount      = 24;			//dvdecoder, avi mux or dv mux write do not matter, 24 for strechDIB func
    lpbi->biXPelsPerMeter = 0;
    lpbi->biYPelsPerMeter = 0;
    //lpbi->biCompression   = BI_RGB;		//dvdecoder,avi mux or dv mux write do not care, BI_RGB only for StrechDIB func
// how to build an explicit FOURCC
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))

    lpbi->biCompression     =FCC('dvsd');       //7/19/20, Ivan maltz cares this in his application, we will set this to BI_RGB for stretchDIB and switch back.
    lpbi->biSizeImage     = GetBitmapSize(lpbi);

    
    if(m_fDVInfo==TRUE)
    {
	unsigned char *pc   =(unsigned char *)( lpbi+ sizeof(BITMAPINFOHEADER));
	unsigned char *pDV  =(unsigned char *)&m_sDVInfo;
	//copy DVINFO

	memcpy(pc,pDV,sizeof(DVINFO) ); 
    }
    
    //pVideoInfo->bmiHeader.biClrUsed = STDPALCOLOURS;
    //pVideoInfo->bmiHeader.biClrImportant = STDPALCOLOURS;
    	
    pVideoInfo->rcSource.top	= 0;
    pVideoInfo->rcSource.left	= 0;
    pVideoInfo->rcSource.right	= lpbi->biWidth;			
    pVideoInfo->rcSource.bottom = lpbi->biHeight;			
    pVideoInfo->AvgTimePerFrame = InVidInfo->AvgTimePerFrame;		//copy input's avgTimePerFrame
    pVideoInfo->rcTarget	= pVideoInfo->rcSource;

    //
    // The "bit" rate is image size in bytes times 8 (to convert to bits)
    // divided by the AvgTimePerFrame.  This result is in bits per 100 nSec,
    // so we multiply by 10000000 to convert to bits per second, this multiply
    // is combined with "times" 8 above so the calculations becomes:
    //
    // BitRate = (biSizeImage * 80000000) / AvgTimePerFrame
    //
    LARGE_INTEGER li;
    li.QuadPart = pVideoInfo->AvgTimePerFrame;
    pVideoInfo->dwBitRate = MulDiv(lpbi->biSizeImage, 80000000, li.LowPart);
    pVideoInfo->dwBitErrorRate = 0L;


    *pmt = cmt;
    if(m_iDVFormat == IDC_dvsd)
	pmt->SetSubtype(&MEDIASUBTYPE_dvsd);
    else 	if(m_iDVFormat == IDC_dvhd)
	pmt->SetSubtype(&MEDIASUBTYPE_dvhd);
    else	if(m_iDVFormat == IDC_dvsl)
    	pmt->SetSubtype(&MEDIASUBTYPE_dvsl);
    else 
	ASSERT(m_iDVFormat== IDC_dvsd);
    
    //
    // This block assumes that lpbi has been set up to point to a valid
    // bitmapinfoheader and that cmt has been copied into *pmt.
    // This is taken care of in the switch statement above.  This should
    // kept in mind when new formats are added.
    //
    pmt->SetType(&MEDIATYPE_Video);
   
    pmt->SetFormatType(&FORMAT_VideoInfo);

    //150*80*10 or *12
    pmt->SetSampleSize(HEADER(pVideoInfo)->biSizeImage);

    return S_OK;
}



/******************************Public*Routine******************************\
* DecideBufferSize
*
* Called from CBaseOutputPin to prepare the allocator's count
* of buffers and sizes
*
\**************************************************************************/
HRESULT
CDVVideoEnc::DecideBufferSize(
    IMemAllocator * pAllocator,
    ALLOCATOR_PROPERTIES * pProperties
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoEnc::DecideBufferSize")));

    ASSERT(pAllocator);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    pProperties->cBuffers = 4;
	if(m_iVideoFormat == IDC_NTSC )
	     pProperties->cbBuffer = 150*80*10;
	else
	     pProperties->cbBuffer = 150*80*12;


    ASSERT(pProperties->cbBuffer);
    DbgLog((LOG_TRACE, 2, TEXT("Sample size = %ld\n"), pProperties->cbBuffer));

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    //ASSERT(Actual.cbAlign == 1);
    //ASSERT(Actual.cbPrefix == 0);

    if ((Actual.cbBuffer < pProperties->cbBuffer )||
        (Actual.cBuffers < 1 )) {
            // can't use this allocator
            return E_INVALIDARG;
    }
    return S_OK;
}


/******************************Public*Routine******************************\
* StartStreaming
* Before inputpin receive anything, StartStreaming is called
\**************************************************************************/
HRESULT
CDVVideoEnc::StartStreaming(    void    )
{
    CAutoLock   lock(&m_csFilter);
    GUID guid;

	//reset m_EncReg
    DWORD dwEncReq=0;
	
    //check output subtype()
    guid=*m_pOutput->CurrentMediaType().Subtype();
    if (  guid != MEDIASUBTYPE_dvsd  )
    {	
	if(guid != MEDIASUBTYPE_dvhd )
	{
	    if(guid != MEDIASUBTYPE_dvsl )
	       return E_INVALIDARG;
	    else
	        dwEncReq=AM_DVENC_DVSL;
	}
	else
	    dwEncReq=AM_DVENC_DVHD;	
    }
     else
	dwEncReq=AM_DVENC_DVSD;	


    //check input subtype()
    guid=*m_pInput->CurrentMediaType().Subtype();
    if (  guid != MEDIASUBTYPE_UYVY  )
    {	
	if(guid != MEDIASUBTYPE_YUY2 )
	{
	    if(guid != MEDIASUBTYPE_RGB565 )
	    {
		if(guid != MEDIASUBTYPE_RGB555 )
		{
		    if(guid != MEDIASUBTYPE_RGB24 )
		    {
			if(guid != MEDIASUBTYPE_Y41P  )
			   return E_INVALIDARG;
			else
			    dwEncReq |=AM_DVENC_Y41P;	
		    }
		    else
			dwEncReq |=AM_DVENC_RGB24;	
		}
		else
		    dwEncReq |=AM_DVENC_RGB555;	
	    }
	    else
		dwEncReq |=AM_DVENC_RGB565;	
	}
	else
	    dwEncReq |=AM_DVENC_YUY2;
    }
    else
		dwEncReq |=AM_DVENC_UYVY;
    
    if (m_bRGB219 && ( dwEncReq & AM_DVENC_RGB24))
        dwEncReq |= AM_DVENC_DR219RGB;

    //NTSC or PAL 		
    if(m_iVideoFormat == IDC_NTSC )
	dwEncReq  = dwEncReq | AM_DVENC_NTSC |AM_DVENC_DV;	
    else
	dwEncReq  = dwEncReq | AM_DVENC_PAL |AM_DVENC_DV;	

    //resolution
    if(m_iResolution ==  IDC_720x480 )
	dwEncReq |= AM_DVENC_Full;
    else if(m_iResolution ==  IDC_360x240 )
	dwEncReq |= AM_DVENC_Half;
    else if(m_iResolution ==  IDC_180x120 )
	dwEncReq |= AM_DVENC_Quarter;
    else if(m_iResolution ==  IDC_88x60 )
	dwEncReq |= AM_DVENC_DC;

    extern BOOL bMMXCPU;

    if( ( bMMXCPU==TRUE) && ( m_EncCap & AM_DVENC_MMX ) )
    	dwEncReq |= AM_DVENC_MMX;

    m_EncReg=dwEncReq;
    
    HRESULT hr;
	//Allocate memory for decoder												   
    if (FAILED (hr = InitMem4Encoder( &m_pMem4Enc,  dwEncReq )))
        return hr;


    //Allocate memory for converter
    ASSERT( m_pMem4Convert == NULL );
    if( m_fConvert )
    {	
	m_pMem4Convert =  new char [720*576*3 ];
    }
  
    m_fStreaming=1;
    return CTransformFilter::StartStreaming();

}


/******************************Public*Routine******************************\
* StopStreaming
\**************************************************************************/
HRESULT
CDVVideoEnc::StopStreaming(    void    )
{
    CAutoLock       lock(&m_csFilter);
    CAutoLock       lck(&m_csReceive);

    if(m_fStreaming)
    {

	m_fStreaming=0;

	TermMem4Encoder(m_pMem4Enc);

	//release converting memory													  
	if(m_pMem4Convert!= NULL){
	    delete[] m_pMem4Convert;
	    m_pMem4Convert=NULL;
	}
    }

    return CTransformFilter::StopStreaming();

}

STDMETHODIMP CDVVideoEnc::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) 
    {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_DVEncPropertiesPage;
    return NOERROR;

} // GetPages

//
// get_IPDisplay
//
// Return the current effect selected
//
STDMETHODIMP CDVVideoEnc::get_IFormatResolution(int *iVideoFormat, int *iDVFormat,int *iResolution, BYTE fDVInfo, DVINFO *psDvInfo)
{
    CAutoLock cAutolock(&m_DisplayLock);

    CheckPointer(iVideoFormat,E_POINTER);
    *iVideoFormat = m_iVideoFormat;

    CheckPointer(iDVFormat,E_POINTER);
    *iDVFormat = m_iDVFormat;

    CheckPointer(iResolution,E_POINTER);
    *iResolution = m_iResolution;
   
    if(fDVInfo==TRUE)
    {
	if( psDvInfo ==NULL)
	    return E_FAIL;
	else
	    //we do wnat get m_sDVInfo
	    *psDvInfo=m_sDVInfo;
    }
    return NOERROR;

} // get_IFormatResolution

//
// put_IFormatResolution
//
STDMETHODIMP CDVVideoEnc::put_IFormatResolution(int iVideoFormat, int iDVFormat, int iResolution, BYTE fDVInfo, DVINFO *psDvInfo)
{
    CAutoLock cAutolock(&m_DisplayLock);

    //check if display resolution change
    if( (m_iVideoFormat == iVideoFormat)	&&
	(m_iDVFormat	== iDVFormat)		&& 
	(m_iResolution == iResolution) 		&&
	(m_fDVInfo == fDVInfo)   )
	return NOERROR;

    //can not change property if m_fStreaming=1
    if(m_fStreaming)
	return E_FAIL;

    if (m_pOutput == NULL) 
    {
	CTransformOutputPin * pPin;
        pPin = (CTransformOutputPin *)GetPin(1);
        ASSERT(m_pOutput==pPin);
	ASSERT(m_pOutput!=NULL);
    }

    // Ignore if we are not connected  to video render yet
    //CAutoLock cSampleLock(&m_RendererLock);
    if (m_pOutput->IsConnected() == FALSE) {
	m_iVideoFormat	= iVideoFormat;
	m_iDVFormat	= iDVFormat;
	m_iResolution	= iResolution;
	return NOERROR;
    }
    
    //check iVideoformat
    if ( ( (iVideoFormat == IDC_NTSC) &&	(m_EncCap & AM_DVENC_NTSC )  ) ||
	 ( (iVideoFormat == IDC_PAL)  &&	(m_EncCap & AM_DVENC_PAL )    )	 )
	m_iVideoFormat = iVideoFormat;
    else 
    	return E_FAIL;

    //check iDVFormat
    if ( ( (iDVFormat == IDC_dvsd) &&	(m_EncCap & AM_DVENC_DVSD )  )		||
	 ( (iDVFormat == IDC_dvhd)  &&	(m_EncCap & AM_DVENC_DVHD )  )		||
	 ( (iDVFormat == IDC_dvsl) &&	(m_EncCap & AM_DVENC_DVSL )	 )		 )
	m_iDVFormat = iDVFormat;
    else 
    	return E_FAIL;

    //check resolution
    if ( ( ( iResolution== IDC_720x480) &&	(m_EncCap & AM_DVENC_Full )  ) ||
	 ( ( iResolution== IDC_360x240)  &&	(m_EncCap & AM_DVENC_Half )  )  ||
	 ( ( iResolution== IDC_180x120  &&	(m_EncCap & AM_DVENC_Quarter )  )  ||
	 ( ( iResolution== IDC_360x240)  &&	(m_EncCap & AM_DVENC_DC )  )  )  )
    {
	m_iResolution = iResolution;
    }
    else
	return E_FAIL;
	
    if(fDVInfo==TRUE)
    {
	if( psDvInfo==NULL )
	    return E_FAIL;
	else
	{   
	    m_fDVInfo=TRUE;
	    m_sDVInfo=*psDvInfo;
	}
    }
    else
        m_fDVInfo=FALSE;   //as default


    /*X*
    //make sure down stream filter accecpt us
    CMediaType* pmt;
    pmt = &(m_pOutput->CurrentMediaType() );
    if(m_pOutput->GetConnected()->QueryAccept(pmt) != S_OK)
    	return E_FAIL;
    *X*/
   
    //reconnect
    m_pGraph->Reconnect( m_pOutput );

    return NOERROR;
    
} // put_IFormatResolution


//
// ScribbleToStream
//
// Overriden to write our state into a stream
//
HRESULT CDVVideoEnc::WriteToStream(IStream *pStream)
{
    HRESULT hr;
    WRITEOUT(m_iVideoFormat);
    WRITEOUT(m_iDVFormat);
    WRITEOUT(m_iResolution);
    return NOERROR;

} // ScribbleToStream

//
// ReadFromStream
//
// Likewise overriden to restore our state from a stream
//
HRESULT CDVVideoEnc::ReadFromStream(IStream *pStream)
{
    HRESULT hr;
    READIN(m_iVideoFormat);
    READIN(m_iDVFormat);
    READIN(m_iResolution);
    return NOERROR;

} // ReadFromStream
			   

//
// GetClassID
// This is the only method of IPersist
//
STDMETHODIMP CDVVideoEnc::GetClassID(CLSID *pClsid)
{
    *pClsid = CLSID_DVVideoEnc;
    return NOERROR;

} // GetClassID

STDMETHODIMP CDVVideoEnc::SetRGB219(BOOL bState)
// This method is used in the case of RGB24 to specify that the Dynamic
// Range to be used is (16,16,16)--(235,235,235)
{
    m_bRGB219 = bState;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvdec\dvdec.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
/******************************Module*Header*******************************\
* Module Name: dvdec.cpp
*
* Implements a prototype DV Video AM filter.  
*
\**************************************************************************/
#include <streams.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <stddef.h>
#include <string.h>									    
#ifndef FILTER_LIB
#include <initguid.h>
#endif
#include <olectl.h>
#include <dvdmedia.h>       //VIDEOINFOHEADER2

#include "decode.h"
#include "Decprop.h"
#include "dvdec.h"
#include "resource.h"

#ifdef DEBUG
static long glGlobalSentCount = 0;
static long glGlobalRecvdCount = 0;
#endif

BOOL bMMXCPU = FALSE;

// serialize access to the decoder
//
CRITICAL_SECTION g_CritSec;

/***********************************************************************\
* IsMMXCPU
*
* Function to check if the current processor is an MMX processor.
*
\***********************************************************************/
BOOL IsMMXCPU() {
#ifdef _X86_

    //////////////////////////////////////////////////////
    // work around for Cyrix M2 hang (when MMX flag is on)
    // emit cpuid and detect Cyrix M2, if its present, then return FALSE
    // WARNING: This will not work in 64 bit architectures
    __try
    {
        DWORD   s1, s2, s3;     // temporary holders for the vendor name        

        __asm
        {
            // null out eax
            mov eax, 0x00;

            // load opcode CPUID == (0x0FA2)
            _emit 0x0f;
            _emit 0xa2;
            mov s1, ebx;    // copy "Cyri" (backwards)
            mov s2, edx;    // copy "xIns" (backwards)
            mov s3, ecx;    // copy "tead" (backwards)
        }

        DbgLog((LOG_TRACE, 1, TEXT("CPUID Instruction Supported")));

        // check Vendor Id
        if( (s1 == (('i' << 24) | ('r' << 16) | ('y' << 8) | ('C')))
            && (s2 == (('s' << 24) | ('n' << 16) | ('I' << 8) | ('x')))
            && (s3 == (('d' << 24) | ('a' << 16) | ('e' << 8) | ('t'))) )

        {
            DbgLog((LOG_TRACE, 1, TEXT("Cyrix detected")));
            return FALSE;
        }
        else
        {
            // otherwise it's some other vendor and continue with MMX detection
            DbgLog((LOG_TRACE, 1, TEXT("Cyrix not found, reverting to MMX detection")));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // log it and continue on to MMX detection sequence
        DbgLog((LOG_TRACE, 1, TEXT("CPUID instruction not supported, reverting to MMX detection")));
    }
    // END Cyrix M2 detection
    //////////////////////////////////////////////////////


    //
    // If this is an Intel platform we need to make sure that we
    // are running on a machine that supports MMX instructions
    //
    __try {

    __asm _emit 0fh;
    __asm _emit 77h;

    return TRUE;

    }
     __except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
#else

    // Note for IA64: return FALSE. MMX files are not compiled into the 
    // MEI codec libs for IA64
    return FALSE;
#endif
}


#define WRITEOUT(var)  hr = pStream->Write(&var, sizeof(var), NULL); \
		       if (FAILED(hr)) return hr;

#define READIN(var)    hr = pStream->Read(&var, sizeof(var), NULL); \
		       if (FAILED(hr)) return hr;


// 20( )63(c)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvc ' == MEDIASUBTYPE_dvc 
EXTERN_GUID(MEDIASUBTYPE_dvc,
0x20637664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);


// setup data
const AMOVIESETUP_MEDIATYPE
psudIpPinTypes[] = { { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvsd  }		// clsMinorType
                   , { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvc}		// clsMinorType
		   , { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvhd}		// clsMinorType
		   , { &MEDIATYPE_Video			// clsMajorType
                     , &MEDIASUBTYPE_dvsl}		// clsMinorType
		     }; 

const AMOVIESETUP_MEDIATYPE
sudOpPinTypes = { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN
psudPins[] = { { L"Input"            // strName
               , FALSE               // bRendered
               , FALSE               // bOutput
               , FALSE               // bZero
               , FALSE               // bMany
               , &CLSID_NULL         // clsConnectsToFilter
               , L"Output"           // strConnectsToPin
               , 2		     // nTypes, so far, only support dvsd and dvc
               , psudIpPinTypes }    // lpTypes
             , { L"Output"           // strName
               , FALSE               // bRendered
               , TRUE                // bOutput
               , FALSE               // bZero
               , FALSE               // bMany
               , &CLSID_NULL         // clsConnectsToFilter
               , L"Input"	     // strConnectsToPin
               , 1                   // nTypes
               , &sudOpPinTypes } }; // lpTypes

const AMOVIESETUP_FILTER
sudDVVideo = { &CLSID_DVVideoCodec	// clsID
               , L"DV Video Decoder"	// strName
               , MERIT_PREFERRED        // merit slightly higher than AVI Dec's (resolves 3rd Party DVDec issue), Bug 123862 Millen.
               , 2                      // nPins
               , psudPins };            // lpPin

#ifdef FILTER_DLL

/* -------------------------------------------------------------------------
** list of class ids and creator functions for class factory
** -------------------------------------------------------------------------
*/
CFactoryTemplate g_Templates[] =
{
    {L"DV Video Decoder", 
	&CLSID_DVVideoCodec, 
	CDVVideoCodec::CreateInstance,
	CDVVideoCodec::InitClass,
	&sudDVVideo
    },
    {L"Display",
    &CLSID_DVDecPropertiesPage, 
    CDVDecProperties::CreateInstance
    }
    
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
     return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

#endif
//* -------------------------------------------------------------------------
//** CDVVideoCodec
//** -------------------------------------------------------------------------
CDVVideoCodec::CDVVideoCodec(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr
    )
    : CVideoTransformFilter(pName, pUnk, CLSID_DVVideoCodec),
    CPersistStream(pUnk, phr),
    m_fStreaming(0),
    m_iDisplay(IDC_DEC360x240),//m_iDisplay(IDC_DEC360x240), //m_iDisplay(IDC_DEC180x120), //m_iDisplay(IDC_DEC88x60),
    m_lPicWidth(360),//360),//180), //88	  
    m_lPicHeight(240), //240),//120),//60	  
    m_lStride(0),
    m_CodecCap(0),
    m_pMem(NULL),
    m_pMemAligned(NULL),
    m_CodecReq(0),
    m_bExamineFirstValidFrameFlag(FALSE),
    m_bQualityControlActiveFlag(FALSE),
    m_iOutX(4),							//Initial default values for Aspect Ratio
	m_iOutY(3),
    m_bRGB219(FALSE)
{
    // try to read previously saved default video settings
    // no need to error check this one
    ReadFromRegistry();

    //get decoder's abilities
    m_CodecCap=GetCodecCapabilities( );


}

CDVVideoCodec::~CDVVideoCodec(     )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::~CDVVideoCodec")));

#ifdef DEBUG
    DbgLog((LOG_TRACE, 1, TEXT("Recvd: %d, Sent: %d"), glGlobalRecvdCount, glGlobalSentCount));
#endif

}


/******************************Private*Routine*****************************\
* ReadFromRegistry
*
* Used to read default value of m_iDisplay from persistent registry
* and set m_lPicWidth and Height accordingly
* if the default doesn't exist, and the settings are not modified
*
* History
* dd-mm-99 - anuragsh - Created
\**************************************************************************/
void
CDVVideoCodec::ReadFromRegistry()
{
    // we know externs regarding SubKey string, and property value from Decprop.h

    HKEY    hKey = NULL;
    DWORD   dwType = REG_DWORD;
    DWORD   dwTempPropDisplay = 0;
    DWORD   dwDataSize = sizeof(dwTempPropDisplay);

    // try to open the key
    if(RegOpenKeyEx(HKEY_CURRENT_USER,
                    szSubKey,
                    0,
                    KEY_READ,
                    &hKey
                    ) != ERROR_SUCCESS)
    {
        return;
    }

    // try to read the value
    if(RegQueryValueEx(hKey,
                        szPropValName,
                        NULL,
                        &dwType,
                        (LPBYTE) &dwTempPropDisplay,
                        &dwDataSize
                        ) != ERROR_SUCCESS)
    {
        return;
    }

    // perform type checking on the data retrieved
    // it must be a DWORD
    if(dwType != REG_DWORD)
    {
        return;
    }

    // set our member variables correctly
    switch (dwTempPropDisplay)
    {
    case IDC_DEC360x240 :
        m_lPicHeight=240;
        m_lPicWidth=360;
        break;
    case IDC_DEC720x480 :
        m_lPicHeight=480;
        m_lPicWidth=720;
        break;
    case IDC_DEC180x120 :
        m_lPicHeight=120;
        m_lPicWidth=180;
        break;
    case IDC_DEC88x60 :
        m_lPicHeight=60;
        m_lPicWidth=88;
       	break;
    default:
        // error case
        return;
    }
    
    // if we are here, then we set m_lPicWidth and m_lPicHeight correctly
    // finally copy m_iDisplay
    m_iDisplay = dwTempPropDisplay;
    
    return;
}



/******************************Public*Routine******************************\
* InitClass
*
* Gets called for our class when the DLL gets loaded and unloaded
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
CDVVideoCodec::InitClass(
    BOOL bLoading,
    const CLSID *clsid
    )
{
    if (bLoading) {
        bMMXCPU = IsMMXCPU();
        InitializeCriticalSection(&g_CritSec);
    } else {
        DeleteCriticalSection(&g_CritSec);
    }

}

/******************************Public*Routine******************************\
* CreateInstance
*
* This goes in the factory template table to create new instances
*
\**************************************************************************/
CUnknown *
CDVVideoCodec::CreateInstance(
    LPUNKNOWN pUnk,
    HRESULT * phr
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::CreateInstance")));
    return new CDVVideoCodec(TEXT("DV Video codec filter"), pUnk, phr);
}


/******************************Public*Routine******************************\
* NonDelegatingQueryInterface
*
* Here we would reveal ISpecifyPropertyPages and IDVVideoDecoder if
* the framework had a property page.
*
\**************************************************************************/
STDMETHODIMP
CDVVideoCodec::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv
    )
{
    if (riid == IID_IIPDVDec) {			    //X* talking with property page
        return GetInterface((IIPDVDec *) this, ppv);
    } else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } else if(riid == IID_IPersistStream)
    {
        return GetInterface((IPersistStream *) this, ppv);
    } else if (riid == IID_IDVRGB219) {
        return GetInterface ((IDVRGB219 *) this, ppv);
    } else {
        return CVideoTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}


/******************************Public*Routine******************************\
* Transform
*
\**************************************************************************/
HRESULT CDVVideoCodec::Transform(IMediaSample * pIn, IMediaSample *pOut)
{
    unsigned char *pSrc, *pDst;
    HRESULT hr = S_OK;

    
    CAutoLock lck(&m_csReceive);

    // get  output buffer
    hr = pOut->GetPointer(&pDst);
    if (FAILED(hr)) 
    {
        return hr;
    }
    ASSERT(pDst);
    
    // get the source buffer
    hr = pIn->GetPointer(&pSrc);
    if (FAILED(hr)) 
    {
	return hr;
    }
    ASSERT(pSrc);


    // DVCPRO PAL format discovery
    BYTE    *pBuf = NULL;

    // Do this for the first sample, after
    // StartStreaming() is called
    // if we should examine the first buffer
    // if buffer is valid,
    // and if we could get ptr to buffer's data area
    // and we managed to successfully get a pointer out
    if( (m_bExamineFirstValidFrameFlag)
        && (pIn->GetActualDataLength())
        && (SUCCEEDED(hr = pIn->GetPointer(&pBuf)))
        && (pBuf) )
    {
        // strategy:
        // look in the header of each sequence of the first track
        // for the first valid header check the
        // APT, AP1, AP2, AP3, lowest 3 bits of each
        // they should be "001" in case of DVCPRO
        // and "000" in all other cases
        // if no valid header is found, then look at the next frame
        
        // check to see if we are PAL or NTSC (by looking at DataLength
        const DWORD dwDIFBlockSize = 80;                    // DIF == 80 bytes
        const DWORD dwSeqSize = 150*dwDIFBlockSize;         // 150 DIF blocks per sequence
        DWORD       dwNumSeq = 0;                           // num sequences (10/12 == NTSC/PAL)
        DWORD       dwLen = pIn->GetActualDataLength();

        // detect NTSC/PAL
        if(dwLen == 10*dwSeqSize)
        {
            // NTSC
            dwNumSeq = 10;
        }
        else if(dwLen == 12*dwSeqSize)
        {
            // PAL
            dwNumSeq = 12;
        }
        // if dwLen != NTSC or PAL, then dwNumSeq == 0;

        // run through all the sequences
        for(DWORD i = 0; i < dwNumSeq; i++)
        {
            // make sure DIF ID == Header is valid
            // the first 3 bits should be "000"
            if( ((*pBuf) & 0xE0) == 0 )
            {
                // now check the APT, AP1, AP2, AP3, for DVCPRO signature
                if( ((*(pBuf + 4) & 0x03) == 0x01)       // APT Low 3 bits == "001"
                    && ((*(pBuf + 5) & 0x03) == 0x01)    // AP1 Low 3 bits == "001"
                    && ((*(pBuf + 6) & 0x03) == 0x01)    // AP2 Low 3 bits == "001"
                    && ((*(pBuf + 7) & 0x03) == 0x01) )  // AP3 Low 3 bits == "001"
                {
                    // this is a DVCPRO PAL format, turn on the DVCPRO flag
                    m_CodecReq |= AM_DVDEC_DVCPRO;
                }

                // turn flag off, because we examined a valid header
                m_bExamineFirstValidFrameFlag = FALSE;

                // no need to look at any other sequences or frames
                break;
            }
            
            // otherwise move to the Next Sequence
            pBuf += dwSeqSize;
        }// end for(all sequences)

    }// End DVCPRO detection
    //MEI's version 4.0 requires 440000 bytes memory 


    // ASSERT(m_pMem);
    // *m_pMem = 0;	//(3) 

    // need to serialize access to the decoder, since if you don't, it will crash. Looks like
    // somebody's using a global!
    //
    EnterCriticalSection( &g_CritSec );
    long result = DvDecodeAFrame(pSrc,pDst, m_CodecReq, m_lStride, m_pMemAligned);
    DbgLog((LOG_TRACE, 4, TEXT("m_CodecReq = %x\n"), m_CodecReq));
    LeaveCriticalSection( &g_CritSec );

    //m_lStride: positive is DirectDraw, negative is DIB
    if( result != S_OK )
	return E_FAIL;

    // DIBSIZE() might only work for RGB and we can output YUV
    LPBITMAPINFOHEADER lpbiDst ;
	if (!m_bUseVideoInfo2)
		lpbiDst = HEADER(m_pOutput->CurrentMediaType().Format());
	else
	{
		VIDEOINFOHEADER2 * pvi2 = (VIDEOINFOHEADER2 * )m_pOutput->CurrentMediaType().Format();
		lpbiDst =& (pvi2->bmiHeader);
	}

    // deal with alpha bits
    //
    if( *m_pOutput->CurrentMediaType( ).Subtype( ) == MEDIASUBTYPE_ARGB32 )
    {
        RGBQUAD * pDstQuad = (RGBQUAD*) pDst;

        for( long i = lpbiDst->biSizeImage / sizeof( RGBQUAD ) ; i > 0 ; i-- )
        {
            pDstQuad->rgbReserved = 255;
            pDstQuad++;
        }
    }

    pOut->SetActualDataLength(lpbiDst->biSizeImage);

    return hr;
}


/******************************Public*Routine******************************\
* Receive
*
\**************************************************************************/
HRESULT CDVVideoCodec::Receive(IMediaSample *pSample)
{
    // If the next filter downstream is the video renderer, then it may
    // be able to operate in DirectDraw mode which saves copying the data
    // and gives higher performance.  In that case the buffer which we
    // get from GetDeliveryBuffer will be a DirectDraw buffer, and
    // drawing into this buffer draws directly onto the display surface.
    // This means that any waiting for the correct time to draw occurs
    // during GetDeliveryBuffer, and that once the buffer is given to us
    // the video renderer will count it in its statistics as a frame drawn.
    // This means that any decision to drop the frame must be taken before
    // calling GetDeliveryBuffer.
    
    ASSERT(CritCheckIn(&m_csReceive));

#ifdef DEBUG
    glGlobalRecvdCount++;
    DbgLog((LOG_TRACE,1,TEXT("--------RECEIVED SAMPLE")));
#endif

    AM_MEDIA_TYPE *pmtOut, *pmt;
#ifdef DEBUG
    FOURCCMap fccOut;
#endif
    HRESULT hr;
    ASSERT(pSample);
    IMediaSample * pOutSample;

    // If no output pin to deliver to then no point sending us data
    ASSERT (m_pOutput != NULL) ;

    //ShouldSkipFrame(pSample)
    REFERENCE_TIME trStart, trStopAt;
    pSample->GetTime(&trStart, &trStopAt);
    int itrFrame = (int)(trStopAt - trStart);	//frame duration

    m_bSkipping =FALSE;
    // only drop frames if Quality Control is going on.
    if ( (m_bQualityControlActiveFlag) && (  m_itrLate > ( itrFrame - m_itrAvgDecode  ) ) )
    {
        MSR_NOTE(m_idSkip);
        m_bSampleSkipped = TRUE;
	m_bSkipping =TRUE;

        m_itrLate = m_itrLate - itrFrame;
    
	MSR_INTEGER(m_idLate, (int)m_itrLate/10000 ); // Note how late we think we are
	if (!m_bQualityChanged) {
            m_bQualityChanged = TRUE;
            NotifyEvent(EC_QUALITY_CHANGE,0,0);
        }

        DbgLog((LOG_TRACE,1,TEXT("--------DROPPED SAMPLE (Quality Control)")));

        return NOERROR;
    }


    // Set up the output sample
    hr = InitializeOutputSample(pSample, &pOutSample);

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,1,TEXT("--------DROPPED SAMPLE (Couldn't init output sample")));
        return hr;
    }

    m_bSampleSkipped = FALSE;


    // The source filter may dynamically ask us to start transforming from a
    // different media type than the one we're using now.  If we don't, we'll
    // draw garbage. (typically, this is a palette change in the movie,
    // but could be something more sinister like the compression type changing,
    // or even the video size changing)

#define rcS1 ((VIDEOINFOHEADER *)(pmt->pbFormat))->rcSource
#define rcT1 ((VIDEOINFOHEADER *)(pmt->pbFormat))->rcTarget

    pSample->GetMediaType(&pmt);
    if (pmt != NULL && pmt->pbFormat != NULL) {

	// spew some debug output
	ASSERT(!IsEqualGUID(pmt->majortype, GUID_NULL));
#ifdef DEBUG
        fccOut.SetFOURCC(&pmt->subtype);
	LONG lCompression = HEADER(pmt->pbFormat)->biCompression;
	LONG lBitCount = HEADER(pmt->pbFormat)->biBitCount;
	LONG lStride = (HEADER(pmt->pbFormat)->biWidth * lBitCount + 7) / 8;
	lStride = (lStride + 3) & ~3;
        DbgLog((LOG_TRACE,3,TEXT("*Changing input type on the fly to")));
        DbgLog((LOG_TRACE,3,TEXT("FourCC: %lx Compression: %lx BitCount: %ld"),
		fccOut.GetFOURCC(), lCompression, lBitCount));
        DbgLog((LOG_TRACE,3,TEXT("biHeight: %ld rcDst: (%ld, %ld, %ld, %ld)"),
		HEADER(pmt->pbFormat)->biHeight,
		rcT1.left, rcT1.top, rcT1.right, rcT1.bottom));
        DbgLog((LOG_TRACE,3,TEXT("rcSrc: (%ld, %ld, %ld, %ld) Stride: %ld"),
		rcS1.left, rcS1.top, rcS1.right, rcS1.bottom,
		lStride));
#endif

	// now switch to using the new format.  I am assuming that the
	// derived filter will do the right thing when its media type is
	// switched and streaming is restarted.

        // DANGER DANGER - we've already called GetBuffer here so we
        // have the win16 lock - so we have to be VERY careful what we
        // do in StopStreaming

	StopStreaming();
	m_pInput->CurrentMediaType() = *pmt;
	DeleteMediaType(pmt);
	// not much we can do if this fails
	hr = StartStreaming();
    }

    // The renderer may ask us to on-the-fly to start transforming to a
    // different format.  If we don't obey it, we'll draw garbage

    pOutSample->GetMediaType(&pmtOut);
    if (pmtOut != NULL && pmtOut->pbFormat != NULL) {
        ASSERT(pmtOut->formattype!=FORMAT_None);
        m_bUseVideoInfo2 =  (pmtOut->formattype == FORMAT_VideoInfo2);
       
	// spew some debug output
	ASSERT(!IsEqualGUID(pmtOut->majortype, GUID_NULL));
#ifdef DEBUG
		// Different debug output according to whether we are using VIDEOINFOHEADER2 or VIDEOINFOHEADER
		// with the output pin
		VIDEOINFOHEADER *  pVIout = NULL;
		VIDEOINFOHEADER2 * pVIout2 = NULL;
		if (m_bUseVideoInfo2)
			pVIout2 = (VIDEOINFOHEADER2 *) pmtOut->pbFormat;
		else
			pVIout = (VIDEOINFOHEADER *) pmtOut->pbFormat;

		fccOut.SetFOURCC(&pmtOut->subtype);
		LONG lCompression = HEADER(pmtOut->pbFormat)->biCompression;
		LONG lBitCount = HEADER(pmtOut->pbFormat)->biBitCount;
		LONG lStride = (HEADER(pmtOut->pbFormat)->biWidth * lBitCount + 7) / 8;
		lStride = (lStride + 3) & ~3;
		DbgLog((LOG_TRACE,3,TEXT("*Changing output type on the fly to")));
		DbgLog((LOG_TRACE,3,TEXT("FourCC: %lx Compression: %lx BitCount: %ld"),
		fccOut.GetFOURCC(), lCompression, lBitCount));
		if (m_bUseVideoInfo2)
		{
			DbgLog((LOG_TRACE,3,TEXT("biHeight: %ld rcDst: (%ld, %ld, %ld, %ld)"),
				HEADER(pmtOut->pbFormat)->biHeight,
				pVIout2->rcTarget.left, pVIout2->rcTarget.top, pVIout2->rcTarget.right,
				pVIout2->rcTarget.bottom));
			DbgLog((LOG_TRACE,3,TEXT("rcSrc: (%ld, %ld, %ld, %ld) Stride: %ld"),
				pVIout2->rcSource.left, pVIout2->rcSource.top, pVIout2->rcSource.right, 
				pVIout2->rcSource.bottom,lStride));
			DbgLog ((LOG_TRACE, 3, TEXT("Aspect Ratio: %d:%d"), pVIout2->dwPictAspectRatioX,
					pVIout2->dwPictAspectRatioY));
		}
		else
		{
			DbgLog((LOG_TRACE,3,TEXT("biHeight: %ld rcDst: (%ld, %ld, %ld, %ld)"),
				HEADER(pmtOut->pbFormat)->biHeight,
				pVIout->rcTarget.left, pVIout->rcTarget.top, pVIout->rcTarget.right,
				pVIout->rcTarget.bottom));
			DbgLog((LOG_TRACE,3,TEXT("rcSrc: (%ld, %ld, %ld, %ld) Stride: %ld"),
				pVIout->rcSource.left, pVIout->rcSource.top, pVIout->rcSource.right, 
				pVIout->rcSource.bottom,lStride));
		
		}
#endif

	// now switch to using the new format.  I am assuming that the
	// derived filter will do the right thing when its media type is
	// switched and streaming is restarted.

	StopStreaming();
	m_pOutput->CurrentMediaType() = *pmtOut;
	DeleteMediaType(pmtOut);
	hr = StartStreaming();

	if (SUCCEEDED(hr)) {
 	    // a new format, means a new empty buffer, so wait for a keyframe
	    // before passing anything on to the renderer.
	    // !!! a keyframe may never come, so give up after 30 frames
            DbgLog((LOG_TRACE,3,TEXT("Output format change means we must wait for a keyframe")));
	    m_nWaitForKey = 30;
	}
    }

    // Start timing the transform (and log it if PERF is defined)

    if (SUCCEEDED(hr)) {

        		//Check for Aspect Ratio Changes
	

		if (m_bUseVideoInfo2)

		{	
			unsigned char *pSrc;
			hr = pSample->GetPointer(&pSrc);
			if (FAILED (hr))
            {   pOutSample->Release();
				return hr;
            }

			BYTE	bDisp, bBcsys;
			//Check Aspect Ratio
			BYTE * pSearch = NULL;
			pSearch = pSrc + 453;			//Location of the VAUX source control block in the frame   
			if (*pSearch == 0x061)
			{
				//Get the DISP	and BCSYS  fields from the VAUX
				DbgLog((LOG_TRACE,3,TEXT("Found the VAUX source control structure")));
				bDisp = *(pSearch+2) & 0x07;
				bBcsys= *(pSearch+3) & 0x03;

				DbgLog((LOG_TRACE,3,TEXT("BCSYS = %d   DISP = %d"),bBcsys,bDisp));
			
				//Compute the aspect ratio of frame
				int iFramex=0;
				int iFramey=0;
				switch (bBcsys)
				{
				case 0:
					switch (bDisp)
					{
					case 0:
						iFramex = 4;
						iFramey = 3;
						break;
					case 1:
					case 2:
						iFramex = 16;
						iFramey = 9;
						break;
					}
					break;
				case 1:
					switch (bDisp)
					{
					case 0:
						iFramex = 4;
						iFramey = 3;
						break;
					case 1:
					case 2:
					case 6:
						iFramex = 14;
						iFramey = 9;
						break;
					case 3:
					case 4:
					case 5:
					case 7:
						iFramex = 16;
						iFramey = 9;
						break;
					}
					break;

				}

				// Compare to the Aspect Ratio we are currently using and if different 
				// set aspect ratio to new value
				if (iFramex != 0)  //Means we were able to compute the Aspect Ratio
				{
					if ((iFramex != m_iOutX) || (iFramey != m_iOutY))   //Aspect Ratio has changed
					{
						//Set Aspect Ratio to new values
						m_iOutX = iFramex;
						m_iOutY = iFramey;
						
                        //Create the new media type structure
						AM_MEDIA_TYPE  Newmt ;
					
						CopyMediaType(&Newmt, (AM_MEDIA_TYPE *)&m_pOutput->CurrentMediaType());
						VIDEOINFOHEADER2 * pvi2 = (VIDEOINFOHEADER2 *)Newmt.pbFormat;
						pvi2->dwPictAspectRatioX = iFramex;
						pvi2->dwPictAspectRatioY = iFramey;
						
						
						IPinConnection * iPC;
                        IPin * pInput = m_pOutput->GetConnected();
                        
                        if (pInput)
                        {
						    hr = pInput->QueryInterface(IID_IPinConnection, (void **)&iPC);
						    if (SUCCEEDED (hr))
						    {   
							    hr = iPC->DynamicQueryAccept(&Newmt);
							    if (SUCCEEDED (hr))
								    pOutSample->SetMediaType(&Newmt);
													
							    iPC->Release();
						    }
                        }
						
						FreeMediaType(Newmt);
						
                   }
				}
			
			}
		}


        m_tDecodeStart = timeGetTime();
        MSR_START(m_idTransform);

        // have the derived class transform the data
        hr = Transform(pSample, pOutSample);

        // Stop the clock (and log it if PERF is defined)
        MSR_STOP(m_idTransform);
        m_tDecodeStart = timeGetTime()-m_tDecodeStart;
        m_itrAvgDecode = m_tDecodeStart*(10000/16) + 15*(m_itrAvgDecode/16);

        // Maybe we're waiting for a keyframe still?
        if (m_nWaitForKey)
            m_nWaitForKey--;
        if (m_nWaitForKey && pSample->IsSyncPoint() == S_OK)
	    m_nWaitForKey = FALSE;

        // if so, then we don't want to pass this on to the renderer
        if (m_nWaitForKey && hr == NOERROR) {
            DbgLog((LOG_TRACE,3,TEXT("still waiting for a keyframe")));
	    hr = S_FALSE;
	}
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,1,TEXT("--------DROPPED SAMPLE (Bad failure from Transform())")));
        DbgLog((LOG_TRACE,4,TEXT("Error from video transform")));
    }
    else
    {
        // the Transform() function can return S_FALSE to indicate that the
        // sample should not be delivered; we only deliver the sample if it's
        // really S_OK (same as NOERROR, of course.)
        // Try not to return S_FALSE to a direct draw buffer (it's wasteful)
        // Try to take the decision earlier - before you get it.

        if (hr == NOERROR)
        {
#ifdef DEBUG
            glGlobalSentCount++;
            DbgLog((LOG_TRACE,1,TEXT("--------SENT SAMPLE")));
#endif

    	    hr = m_pOutput->Deliver(pOutSample);

            if(FAILED(hr))
            {
	            DbgLog((LOG_TRACE,1,TEXT("--------SEND SAMPLE FAILED******")));
            }
        }
        else
        {
            DbgLog((LOG_TRACE,1,TEXT("--------DROPPED SAMPLE (S_FALSE from Transform())")));

            // S_FALSE returned from Transform is a PRIVATE agreement
            // We should return NOERROR from Receive() in this case because returning S_FALSE
            // from Receive() means that this is the end of the stream and no more data should
            // be sent.
            if (S_FALSE == hr)
            {
                //  We must Release() the sample before doing anything
                //  like calling the filter graph because having the
                //  sample means we may have the DirectDraw lock
                //  (== win16 lock on some versions)
                pOutSample->Release();
                m_bSampleSkipped = TRUE;

                if (!m_bQualityChanged)
                {
                    m_bQualityChanged = TRUE;
                    NotifyEvent(EC_QUALITY_CHANGE,0,0);
                }
                return NOERROR;
            }
        }
    }

    // release the output buffer. If the connected pin still needs it,
    // it will have addrefed it itself.
    pOutSample->Release();
    ASSERT(CritCheckIn(&m_csReceive));

    return hr;
}


/******************************Public*Routine******************************\
* CheckInputType
* TYPE:	    MEDIATYPE_Video
* SubType:  MEDIASUBTYPE_dvsd or MEDIASUBTYPE_dvhd or MEDIASUBTYPE_dvsl 
* FORMAT:   1.FORMAT_DvInfo (32 bytes DVINFO structure)
*	    2.FORMAT_VideoInfo
*		a. VIDEOINFO( does not contain DVINFO)
*		b. VIDEOINFO( contains DVINFO)
* is called by the CheckMediaType member function of the input pin to determine 
* whether the proposed media type is acceptable
\**************************************************************************/

HRESULT
CDVVideoCodec::CheckInputType(   const CMediaType* pmtIn    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::CheckInputType")));

    //
    //  Check for DV video streams
    //
    if (    (*pmtIn->Type()	== MEDIATYPE_Video)	&&
        (   (*pmtIn->Subtype()	== MEDIASUBTYPE_dvsd)	||
	    (*pmtIn->Subtype()	== MEDIASUBTYPE_dvc)	||
	    (*pmtIn->Subtype()	== MEDIASUBTYPE_dvhd)	||
 	   (*pmtIn->Subtype()	== MEDIASUBTYPE_dvsl) )  ) 
    {
       if(   (*pmtIn->FormatType() == FORMAT_VideoInfo ) )
       {

	 if (pmtIn->cbFormat < 0x20 ) //sizeof(BITMAPHEADER) )	    //SIZE_VIDEOHEADER  )
		return E_INVALIDARG;
       }
	
	if ( *pmtIn->Subtype()	== MEDIASUBTYPE_dvsd ||
                *pmtIn->Subtype()	== MEDIASUBTYPE_dvc) 
	{
	    if( !( m_CodecCap & AM_DVDEC_DVSD ) )
		return 	E_INVALIDARG;

	}
	else
	{
	    if ( *pmtIn->Subtype()	== MEDIASUBTYPE_dvhd) 
	    {
		if( !( m_CodecCap & AM_DVDEC_DVHD ) )
		    return 	E_INVALIDARG;
	    }
	    else if ( *pmtIn->Subtype()	== MEDIASUBTYPE_dvsl) 
	    {
		if( !( m_CodecCap & AM_DVDEC_DVSL ) )
		    return 	E_INVALIDARG;
	    }
	}

   }
   else
	return E_INVALIDARG;
 
   return S_OK;
}


/******************************Public*Routine******************************\
* CheckTransform				       
\**************************************************************************/
HRESULT
CDVVideoCodec::CheckTransform(
    const CMediaType* pmtIn,
    const CMediaType* pmtOut
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::CheckTransform")));


    // we only accept Video as  toplevel type.
    if ( (*pmtOut->Type() != MEDIATYPE_Video) && 
	 (*pmtIn->Type() != MEDIATYPE_Video) ) 
    {
        DbgLog((LOG_TRACE,4,TEXT("Output Major type %s"),GuidNames[*pmtOut->Type()]));
	DbgLog((LOG_TRACE,4,TEXT("Input Major type %s"),GuidNames[*pmtIn->Type()]));
	return E_INVALIDARG;
    }


    GUID guid=*pmtOut->Subtype();
    



    //check output subtype()

    if (guid == MEDIASUBTYPE_UYVY)
    {
         m_CodecReq |= AM_DVDEC_UYVY;
    }
    else if (guid == MEDIASUBTYPE_YUY2)
    {
        m_CodecReq |= AM_DVDEC_YUY2; 
    }
    else if (guid == MEDIASUBTYPE_RGB565)
    {
        m_CodecReq |= AM_DVDEC_RGB565;
    }
    else if (guid == MEDIASUBTYPE_RGB555)
    {
        m_CodecReq |= AM_DVDEC_RGB555; 
    }
    else if (guid == MEDIASUBTYPE_RGB24)
    {
        m_CodecReq |= AM_DVDEC_RGB24; 
    }
    else if (guid == MEDIASUBTYPE_RGB32)
    {
        m_CodecReq |= AM_DVDEC_RGB32;
    }
    else if (guid == MEDIASUBTYPE_ARGB32)
    {
        m_CodecReq |= AM_DVDEC_RGB32;
    }
    else if (guid == MEDIASUBTYPE_RGB8)
    {
         m_CodecReq |= AM_DVDEC_RGB8; 
    }
    else
    {
        DbgLog((LOG_TRACE,4,TEXT("subtype is wrong %s")));
		return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER or VIDEOINFOHEADER2 type
    if ((*pmtOut->FormatType() != FORMAT_VideoInfo) && 
		(*pmtOut->FormatType() != FORMAT_VideoInfo2))
	{
        DbgLog((LOG_TRACE,4,TEXT("Output formate is not videoinfo")));
	return E_INVALIDARG;
    }

    if ( (*pmtIn->FormatType() != FORMAT_VideoInfo) &&
	 (*pmtIn->FormatType() != FORMAT_DvInfo)  )
    {
        DbgLog((LOG_TRACE,4,TEXT("input formate is neither videoinfo no DVinfo")));
	return E_INVALIDARG;
    }

   
    ASSERT(pmtOut->Format());
    long biHeight, biWidth;
    
    
    //NTSC or PAL
    //get input format
    bool IsNTSC;
    VIDEOINFO * InVidInfo = (VIDEOINFO*) pmtIn->Format();
    LPBITMAPINFOHEADER lpbi = HEADER(InVidInfo);
    
    if( (lpbi->biHeight== 480) || (lpbi->biHeight== 240) ||(lpbi->biHeight== 120) || (lpbi->biHeight== 60) )
    {
        IsNTSC = TRUE;
	}
    else  if( (lpbi->biHeight== 576) || (lpbi->biHeight== 288) ||(lpbi->biHeight== 144) || (lpbi->biHeight== 72) )
    {
        IsNTSC = FALSE;
    }
	  else
	      return E_FAIL; 


	if (*pmtOut->FormatType() == FORMAT_VideoInfo2)
	{
		VIDEOINFOHEADER2 * pVidInfo2 = (VIDEOINFOHEADER2*) pmtOut->Format();
		
		//if rcSource is not empty, it must be the same as rcTarget, otherwise, FAIL
		if (!IsRectEmpty(&pVidInfo2->rcSource ))
		{
           if (     pVidInfo2->rcSource.left   !=  pVidInfo2->rcTarget.left
                ||  pVidInfo2->rcSource.top    !=  pVidInfo2->rcTarget.top
				||  pVidInfo2->rcSource.right  !=  pVidInfo2->rcTarget.right
                ||  pVidInfo2->rcSource.bottom !=  pVidInfo2->rcTarget.bottom ) 

            return VFW_E_INVALIDMEDIATYPE;
		}


    // if rcTarget is not empty, use its dimensions instead of biWidth and biHeight,
    // to see if it's an acceptable size.  Then use biWidth as the stride.  
    // Also, make sure biWidth and biHeight are bigger than the rcTarget size.
		if (!IsRectEmpty(&pVidInfo2->rcTarget) )
		{
			if(     abs(pVidInfo2->bmiHeader.biHeight) < abs(pVidInfo2->rcTarget.bottom-pVidInfo2->rcTarget.top)        
				||  abs(pVidInfo2->bmiHeader.biWidth) < abs(pVidInfo2->rcTarget.right-pVidInfo2->rcTarget.left) )
				return VFW_E_INVALIDMEDIATYPE;
			 else
			{
				biHeight=abs(pVidInfo2->rcTarget.bottom-pVidInfo2->rcTarget.top);
				biWidth=abs(pVidInfo2->rcTarget.right-pVidInfo2->rcTarget.left);
			}
		}
		else
		{
			biHeight=abs(pVidInfo2->bmiHeader.biHeight);
			biWidth=pVidInfo2->bmiHeader.biWidth;
		}

	}
	else
	{
		VIDEOINFOHEADER * pVidInfo = (VIDEOINFOHEADER*) pmtOut->Format();
		
		//if rcSource is not empty, it must be the same as rcTarget, otherwise, FAIL
		if (!IsRectEmpty(&pVidInfo->rcSource ))
		{
           if (     pVidInfo->rcSource.left   !=  pVidInfo->rcTarget.left
                ||  pVidInfo->rcSource.top    !=  pVidInfo->rcTarget.top
				||  pVidInfo->rcSource.right  !=  pVidInfo->rcTarget.right
                ||  pVidInfo->rcSource.bottom !=  pVidInfo->rcTarget.bottom ) 

            return VFW_E_INVALIDMEDIATYPE;
		}


    // if rcTarget is not empty, use its dimensions instead of biWidth and biHeight,
    // to see if it's an acceptable size.  Then use biWidth as the stride.  
    // Also, make sure biWidth and biHeight are bigger than the rcTarget size.
		if (!IsRectEmpty(&pVidInfo->rcTarget) )
		{
			if(     abs(pVidInfo->bmiHeader.biHeight) < abs(pVidInfo->rcTarget.bottom-pVidInfo->rcTarget.top)        
				||  abs(pVidInfo->bmiHeader.biWidth) < abs(pVidInfo->rcTarget.right-pVidInfo->rcTarget.left) )
				return VFW_E_INVALIDMEDIATYPE;
			 else
			{
				biHeight=abs(pVidInfo->rcTarget.bottom-pVidInfo->rcTarget.top);
				biWidth=abs(pVidInfo->rcTarget.right-pVidInfo->rcTarget.left);
			}
		}
		else
		{
			biHeight=abs(pVidInfo->bmiHeader.biHeight);
			biWidth=pVidInfo->bmiHeader.biWidth;
		}
	}
    
    
   
    //check down stream filter's require height and width
    if(   (IsNTSC &&(biHeight ==480 )) || (!IsNTSC &&(biHeight ==576)) )
    {
	if ( (biWidth !=720) || (!(m_CodecCap & AM_DVDEC_Full) ) )		
        {
            DbgLog((LOG_TRACE,4,TEXT("Format biWidth F W=%d, H=%d"),biWidth,biHeight));
	    return VFW_E_TYPE_NOT_ACCEPTED;
        }

    }
    else if(   (IsNTSC &&(biHeight ==240 )) || (!IsNTSC &&(biHeight ==288)) )
    {
	if ( (biWidth !=360) ||( !(m_CodecCap & AM_DVDEC_Half) )	)		
        {
            DbgLog((LOG_TRACE,4,TEXT("Format biWidth H W=%d,H=%d"),biWidth,biHeight));
	    return VFW_E_TYPE_NOT_ACCEPTED;
        }

    }
    else if(   (IsNTSC &&(biHeight ==120 )) || (!IsNTSC &&(biHeight ==144)) )
    {
	if ( (biWidth != 180) || ( !(m_CodecCap & AM_DVDEC_Quarter) ) )		
        {
	    DbgLog((LOG_TRACE,4,TEXT("Format biWidth Q W=%d,H=%d"),biWidth,biHeight));
	    return VFW_E_TYPE_NOT_ACCEPTED;
        }
	
    }
    else if( (   (IsNTSC &&(biHeight ==60 )) || (!IsNTSC &&(biHeight ==72)) ) )
    {
	if ( (biWidth != 88) || ( !(m_CodecCap & AM_DVDEC_DC) )	)		
        {
            DbgLog((LOG_TRACE,4,TEXT("Format biWidth E W=%d, H=%d"),biWidth,biHeight));
	    return VFW_E_TYPE_NOT_ACCEPTED;
        }
    }
    else
    {
        DbgLog((LOG_TRACE,4,TEXT("Format biWidth EE W=%d,H=%d"),biWidth,biHeight));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::CheckTransform, OK")));
   
    return S_OK;
}


/******************************Public*Routine******************************\
* SetMediaType
*
* Overriden to know when the media type is actually set
*
\**************************************************************************/
HRESULT
CDVVideoCodec::SetMediaType(   PIN_DIRECTION direction, const CMediaType *pmt    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::SetMediaType")));

    if (direction == PINDIR_INPUT) 
    {
	ASSERT( (*pmt->Subtype() == MEDIASUBTYPE_dvsd)  ||
		(*pmt->Subtype() == MEDIASUBTYPE_dvc)  ||
		(*pmt->Subtype() == MEDIASUBTYPE_dvhd)  ||
		(*pmt->Subtype() == MEDIASUBTYPE_dvsl)	);

	//if input video changed from PAL to NTSC, or NTSC to PAL
	// 1> reset m_lPicHeight 
	// 2> reconnect the output pin if the output pin is connected
	VIDEOINFO *InVidInfo = (VIDEOINFO *)pmt->Format();
	LPBITMAPINFOHEADER lpbi = HEADER(InVidInfo);
	BOOL fChanged=FALSE;
    	if( (lpbi->biHeight== 480) || (lpbi->biHeight== 240) ||(lpbi->biHeight== 120) || (lpbi->biHeight== 60) )
	{   
	    //PAL to NTSC changed
	    if ( m_lPicHeight!= 480 && m_lPicHeight!= 240 && m_lPicHeight!= 120 && m_lPicHeight!= 60)
	    {
		switch (m_iDisplay)
		{
		case IDC_DEC360x240 :
		    m_lPicHeight=240;
		    break;
		case IDC_DEC720x480 :
		    m_lPicHeight=480;
    		    break;
		case IDC_DEC180x120 :
		    m_lPicHeight=120;
		    break;
		case IDC_DEC88x60 :
		    m_lPicHeight=60;
       		    break;
		default:
		    break;
		}
		fChanged=TRUE;
	    }
	}
	else  if( (lpbi->biHeight== 576) || (lpbi->biHeight== 288) ||(lpbi->biHeight== 144) || (lpbi->biHeight== 72) )
	{
	    //NTSC to PAL changed
	    if ( m_lPicHeight!= 576 && m_lPicHeight!= 288 &&  m_lPicHeight!= 144 && m_lPicHeight!= 72 )
	    {
		switch (m_iDisplay)
		{
		case IDC_DEC360x240 :
		    m_lPicHeight=288;
		    break;
		case IDC_DEC720x480 :
		    m_lPicHeight=576;
    		    break;
		case IDC_DEC180x120 :
		    m_lPicHeight=144;
		    break;
		case IDC_DEC88x60 :
		    m_lPicHeight=72;
       		    break;
		default:
		    break;
		}
		fChanged=TRUE;
	    }
	}
	else
	    return VFW_E_INVALIDMEDIATYPE; 
   
	if( fChanged ==TRUE && m_pOutput->IsConnected() )
	    m_pGraph->Reconnect( m_pOutput );

    }
    else   //output direction
	{
		if (*pmt->FormatType() == FORMAT_VideoInfo2)
			m_bUseVideoInfo2 = TRUE;
		else m_bUseVideoInfo2 = FALSE;
	}
      
    return  CVideoTransformFilter::SetMediaType( direction,pmt    );
}


/******************************Public*Routine******************************\
* GetMediaType
*
* Return our preferred output media types (in order)
*
\**************************************************************************/
HRESULT
CDVVideoCodec::GetMediaType( int iPosition,  CMediaType *pmt )
{
    BOOL bUseVideoInfo2;
    VIDEOINFO   *pVideoInfo;
    CMediaType  cmt;

    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::GetMediaType")));

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    //
    // We copy the proposed output format so that we can play around with
    // it all we like and still leave the original preferred format
    // untouched.  We try each of the known BITMAPINFO types in turn
    // starting off with the best quality moving through to the worst
    // (palettised) format
    //

    //X* get current media type from input pin
    cmt = m_pInput->CurrentMediaType();

    if ( (*cmt.Type() != MEDIATYPE_Video)  ||  ((*cmt.Subtype() != MEDIASUBTYPE_dvsd) &&
                                                (*cmt.Subtype() != MEDIASUBTYPE_dvc)))
    	return VFW_S_NO_MORE_ITEMS;
    

   
   // Determine if we are currently looking at the VIDEOINFOHEADER2 modes or the VIDEOINFO modes
   // so if iPosition is in the first cModeCounter videomodes that means that it is using the 
   // VIDEOINFOHEADER2.  if it is greater than that it is either using the VIDEOINFO mode or 
   // it is an incorrect value
   if ( iPosition < AM_DVDEC_CSNUM )
	   bUseVideoInfo2 = TRUE;
   else
   {
	   iPosition = iPosition - AM_DVDEC_CSNUM;
	   bUseVideoInfo2 = FALSE;
   }

    //
    // Fill in the output format according to requested position
    //

    //looking for format flag

    DWORD  dw =0;
   
    //The cases below are the modes we currently support.
    // to add more, add a case below in the correct priority position
    // and increment the constant AM_DVDEC_CSNUM in decode.h
    switch (iPosition)  
    {
    case 0:
        dw = AM_DVDEC_YUY2;
        break;
    case 1:
        dw = AM_DVDEC_UYVY;
        break;
    case 2:
        dw = AM_DVDEC_RGB24;
        break;
    case 3:
        dw = AM_DVDEC_RGB32;
        break;
    case 4:
        dw = AM_DVDEC_ARGB32;
        break;
    case 5:
        dw = AM_DVDEC_RGB565;
        break;
    case 6:
        dw = AM_DVDEC_RGB555;
        break;
    case 7:
        dw = AM_DVDEC_RGB8;
        break;
    default:
   	    return VFW_S_NO_MORE_ITEMS;
    }
        

    switch (dw ) {

    case AM_DVDEC_YUY2:
        
	pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, MAKEFOURCC('Y','U','Y','2'), 16);

        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_YUY2);
        break;
    
    case AM_DVDEC_UYVY:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, MAKEFOURCC('U','Y','V','Y'), 16);

        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_UYVY);
        break;

    case AM_DVDEC_RGB24:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, BI_RGB, 24);

        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_RGB24);
        break;
        
    case AM_DVDEC_RGB32:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, BI_RGB, 32);
        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_RGB32);
        break;

    case AM_DVDEC_ARGB32:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, BI_RGB, 32);
        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_ARGB32);
        break;

    case AM_DVDEC_RGB565:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER +
                                                          SIZE_MASKS);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }

        InitDestinationVideoInfo(pVideoInfo, BI_BITFIELDS, 16);

        DWORD *pdw;
        pdw = (DWORD *)(HEADER(pVideoInfo) + 1);
        pdw[iRED]   = bits565[iRED];
        pdw[iGREEN] = bits565[iGREEN];
        pdw[iBLUE]  = bits565[iBLUE];

        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_RGB565);
        break;

    case AM_DVDEC_RGB555:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, BI_RGB, 16);

        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_RGB555);
        break;

    case AM_DVDEC_RGB8:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER+SIZE_PALETTE);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
	    InitDestinationVideoInfo(pVideoInfo, BI_RGB, 8);
	
        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_RGB8);
        break;
        
    case AM_DVDEC_Y41P:
        pVideoInfo = (VIDEOINFO *)cmt.ReallocFormatBuffer(SIZE_VIDEOHEADER);
        if (pVideoInfo == NULL) {
            return E_OUTOFMEMORY;
        }
        InitDestinationVideoInfo(pVideoInfo, MAKEFOURCC('Y','4','1','P'), 12);

        *pmt = cmt;
        pmt->SetSubtype(&MEDIASUBTYPE_Y41P);
        break;
 
    default:
        return VFW_S_NO_MORE_ITEMS;

    }

    //
    // This block assumes that lpbi has been set up to point to a valid
    // bitmapinfoheader and that cmt has been copied into *pmt.
    // This is taken care of in the switch statement above.  This should
    // kept in mind when new formats are added.
    //
    pmt->SetType(&MEDIATYPE_Video);
    pmt->SetFormatType(&FORMAT_VideoInfo);

    //
    // the output format is uncompressed
    //
    pmt->SetTemporalCompression(FALSE);
    pmt->SetSampleSize(HEADER(pVideoInfo)->biSizeImage);

    if (bUseVideoInfo2)
	{
		VIDEOINFOHEADER2 *pVideoInfo2;
		ConvertVideoInfoToVideoInfo2( pmt);
		pVideoInfo2 = (VIDEOINFOHEADER2 *)pmt->Format();
		pVideoInfo2->dwPictAspectRatioX =4;
		pVideoInfo2->dwPictAspectRatioY =3;
	 }

    return S_OK;
}


/*****************************Private*Routine******************************\
* InitDestinationVideoInfo
*
* Fills in common video and bitmap info header fields
*
\**************************************************************************/
void
CDVVideoCodec::InitDestinationVideoInfo(
    VIDEOINFO *pVideoInfo,
    DWORD dwComppression,
    int nBitCount
    )
{
    LPBITMAPINFOHEADER lpbi = HEADER(pVideoInfo);
    lpbi->biSize          = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth         = m_lPicWidth;	
    lpbi->biHeight        = m_lPicHeight;	;
    lpbi->biPlanes        = 1;
    lpbi->biBitCount      = (WORD)nBitCount;
    lpbi->biXPelsPerMeter = 0;
    lpbi->biYPelsPerMeter = 0;
    lpbi->biCompression   = dwComppression;
    lpbi->biSizeImage     = GetBitmapSize(lpbi);
    //pVideoInfo->bmiHeader.biClrUsed = STDPALCOLOURS;
    //pVideoInfo->bmiHeader.biClrImportant = STDPALCOLOURS;
    if(nBitCount >8 ){
        lpbi->biClrUsed	    = 0;
    	lpbi->biClrImportant  = 0;
    }else if( nBitCount==8)
    {
	lpbi->biClrUsed = SIZE_PALETTE / sizeof(RGBQUAD);
	lpbi->biClrImportant = 0;
        
	RGBQUAD * prgb = (RGBQUAD *) (lpbi+1);

	// fixed PALETTE table	(0 <= i < 256)
	for(int i=0; i<256;i++)
	{
	    prgb[i].rgbRed	    = (i/64) << 6;
	    prgb[i].rgbGreen	    = ((i/4)%16) << 4;
	    prgb[i].rgbBlue	    = (i%4) << 6 ;
	    prgb[i].rgbReserved	    =0;
	}
    }
	
    pVideoInfo->rcSource.top = 0;
    pVideoInfo->rcSource.left = 0;
    pVideoInfo->rcSource.right = m_lPicWidth;			
    pVideoInfo->rcSource.bottom = m_lPicHeight;			
    if( m_lPicHeight== 576 || m_lPicHeight== 288 || m_lPicHeight== 144 || m_lPicHeight== 72 )
	pVideoInfo->AvgTimePerFrame =UNITS/25; //InVidInfo->AvgTimePerFrame;
    else
	pVideoInfo->AvgTimePerFrame =UNITS*1000L/29970L; //InVidInfo->AvgTimePerFrame;
    pVideoInfo->rcTarget = pVideoInfo->rcSource;

    //
    // The "bit" rate is image size in bytes times 8 (to convert to bits)
    // divided by the AvgTimePerFrame.  This result is in bits per 100 nSec,
    // so we multiply by 10000000 to convert to bits per second, this multiply
    // is combined with "times" 8 above so the calculations becomes:
    //
    // BitRate = (biSizeImage * 80000000) / AvgTimePerFrame
    //
    LARGE_INTEGER li;
    li.QuadPart = pVideoInfo->AvgTimePerFrame;
    pVideoInfo->dwBitRate = MulDiv(lpbi->biSizeImage, 80000000, li.LowPart);
    pVideoInfo->dwBitErrorRate = 0L;
}


/******************************Public*Routine******************************\
* DecideBufferSize
*
* Called from CBaseOutputPin to prepare the allocator's count
* of buffers and sizes
*
\**************************************************************************/
HRESULT
CDVVideoCodec::DecideBufferSize(
    IMemAllocator * pAllocator,
    ALLOCATOR_PROPERTIES * pProperties
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVVideoCodec::DecideBufferSize")));

    ASSERT(pAllocator);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    pProperties->cBuffers = 1;
    pProperties->cbBuffer = m_pOutput->CurrentMediaType().GetSampleSize();
    pProperties->cbAlign = 1;
    pProperties->cbPrefix= 0;

    ASSERT(pProperties->cbBuffer);
    DbgLog((LOG_TRACE, 2, TEXT("Sample size = %ld\n"), pProperties->cbBuffer));

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    ASSERT(Actual.cbAlign == 1);
    ASSERT(Actual.cbPrefix == 0);

    if ((Actual.cbBuffer < pProperties->cbBuffer )||
        (Actual.cBuffers < 1 )) {
            // can't use this allocator
            return E_INVALIDARG;
    }
    return S_OK;
}


/******************************Public*Routine******************************\
* StartStreaming
* Before inputpin receive anything, StartStreaming is called
\**************************************************************************/
HRESULT
CDVVideoCodec::StartStreaming(    void    )
{
    CAutoLock   lock(&m_csReceive);
    GUID guid;

    // set the flag to look at the first valid frame, to detect DVCPRO format
    m_bExamineFirstValidFrameFlag = TRUE;

    // turn off Quality Control flag, because we have started streaming fresh.
    m_bQualityControlActiveFlag = FALSE;


    guid=*m_pOutput->CurrentMediaType().Subtype();    

     //reset m_CodecReq
    DWORD dwCodecReq=0;

    

    //check output subtype()
    if (  guid != MEDIASUBTYPE_UYVY  )
    {	
	if(guid != MEDIASUBTYPE_YUY2 )
	{
    	    if(guid != MEDIASUBTYPE_RGB565 )
	    {
		if(guid != MEDIASUBTYPE_RGB555 )
		{
		    if(guid != MEDIASUBTYPE_RGB24 )
		    {
			if(guid != MEDIASUBTYPE_RGB8 )
			{

			    if(guid != MEDIASUBTYPE_Y41P  )
                            {    
                                if (guid != MEDIASUBTYPE_RGB32 && guid != MEDIASUBTYPE_ARGB32)
                                    return E_INVALIDARG;
                                else dwCodecReq = AM_DVDEC_RGB32;
                            }
			    else
				dwCodecReq=AM_DVDEC_Y41P;	
			}
			else
			    dwCodecReq=AM_DVDEC_RGB8;
		    }
		    else
			dwCodecReq=AM_DVDEC_RGB24;	
		}
		else
		    dwCodecReq=AM_DVDEC_RGB555;	
	    }
	    else
	        dwCodecReq=AM_DVDEC_RGB565;	
	}
	else
	    dwCodecReq=AM_DVDEC_YUY2;
    }
    else
	dwCodecReq=AM_DVDEC_UYVY;

    // if we are using RGB 24 and the Dynamic Range 219 flag is set
    // then we update CodecRec telling the Decoder to use the following 
    // dynamic range (16,16,16)--(235,235,235)
    
    if (m_bRGB219 && (( dwCodecReq & AM_DVDEC_RGB24)|| (dwCodecReq &AM_DVDEC_RGB32) ))
        dwCodecReq |= AM_DVDEC_DR219RGB;


    guid=*m_pInput->CurrentMediaType().Subtype();

    //check input subtype()
    if (  guid != MEDIASUBTYPE_dvsd && guid != MEDIASUBTYPE_dvc )
    {
	if  (guid != MEDIASUBTYPE_dvhd) 
	{
	    if (guid != MEDIASUBTYPE_dvsl)  
		return E_INVALIDARG;
	    else
		dwCodecReq  = dwCodecReq | AM_DVDEC_DVSL;
	}
	else
    	    dwCodecReq  = dwCodecReq |AM_DVDEC_DVHD;
    }
    else
	dwCodecReq  = dwCodecReq | AM_DVDEC_DVSD;

	

    CMediaType* pmt;
    VIDEOINFO   *pVideoInfo;
	VIDEOINFOHEADER2 * pVideoInfo2;
	BITMAPINFOHEADER * pBmiHeader;
    pmt = &(m_pOutput->CurrentMediaType() );
	
	BOOL bUseVideoInfo2 = (*pmt->FormatType() == FORMAT_VideoInfo2);

	
	
	if (bUseVideoInfo2)
	{
		pVideoInfo2 = (VIDEOINFOHEADER2 * )pmt->pbFormat;
		pBmiHeader = &pVideoInfo2->bmiHeader;
		
	}
	else
	{
		pVideoInfo = (VIDEOINFO *)pmt->pbFormat;
		pBmiHeader = &pVideoInfo->bmiHeader;
	}

    long biWidth=pBmiHeader->biWidth;
    
    //require decoding resolution
	
	if (bUseVideoInfo2)
	{
		if (!IsRectEmpty(&(pVideoInfo2->rcTarget)))
		{
		    long l1=pVideoInfo2->rcTarget.left;
            long l2=pVideoInfo2->rcTarget.right;
            biWidth=abs(l1-l2);
		}
	}
	else
	{
		if (!IsRectEmpty(&(pVideoInfo->rcTarget)))
		{
		    long l1=pVideoInfo->rcTarget.left;
            long l2=pVideoInfo->rcTarget.right;
            biWidth=abs(l1-l2);
		}
	}

    if(biWidth == 88 )
	dwCodecReq  = dwCodecReq | AM_DVDEC_DC;
    else if(biWidth== 180 )
	    dwCodecReq  = dwCodecReq | AM_DVDEC_Quarter; 
	  else if( biWidth == 360 )
		  dwCodecReq  = dwCodecReq | AM_DVDEC_Half;    
		else if(biWidth== 720 )
			dwCodecReq  = dwCodecReq | AM_DVDEC_Full;	
		    else
			  return E_INVALIDARG;

    //NTSC or PAL
    //get input format
    VIDEOINFO *InVidInfo = (VIDEOINFO *)m_pInput->CurrentMediaType().pbFormat;
    LPBITMAPINFOHEADER lpbi = HEADER(InVidInfo);
    
    if( (lpbi->biHeight== 480) || (lpbi->biHeight== 240) ||(lpbi->biHeight== 120) || (lpbi->biHeight== 60) )
	dwCodecReq  = dwCodecReq | AM_DVDEC_NTSC;	
    else  if( (lpbi->biHeight== 576) || (lpbi->biHeight== 288) ||(lpbi->biHeight== 144) || (lpbi->biHeight== 72) )
	    dwCodecReq  = dwCodecReq | AM_DVDEC_PAL;	
	  else
	      return E_FAIL; 
   
        
    if((bMMXCPU==TRUE) &&  (m_CodecCap & AM_DVDEC_MMX ) )
    	dwCodecReq|=AM_DVDEC_MMX;

    // finally update the member
    m_CodecReq=dwCodecReq;
    
    InitMem4Decoder( &m_pMem4Dec,  dwCodecReq );

    m_fStreaming=1;

    //m_lStride = ((pvi->bmiHeader.biWidth * pvi->bmiHeader.biBitCount) + 7) / 8;
    m_lStride = pBmiHeader->biWidth ;
    m_lStride = (m_lStride + 3) & ~3;
    if( ( pBmiHeader->biHeight <0)  || (pBmiHeader->biCompression > BI_BITFIELDS ) )
	m_lStride=ABSOL(m_lStride);	    //directDraw
    else
	m_lStride=-ABSOL(m_lStride);	    //DIB
    
    //memory for MEI's decoder
    ASSERT(m_pMem ==NULL);
    m_pMem = new char[440000+64];
    if(m_pMem==NULL)
	return E_OUTOFMEMORY;

    // Always align on an 8 byte boundary: the version 6.4 of the 
    // decoder does this (so as avoid an #ifdef WIN64)
    m_pMemAligned = (char*) (((UINT_PTR)m_pMem + 63) & ~63);
    *m_pMemAligned = 0;

    return CVideoTransformFilter::StartStreaming();

}


/******************************Public*Routine******************************\
* StopStreaming
\**************************************************************************/
HRESULT
CDVVideoCodec::StopStreaming(    void    )
{
    //  NOTE - this is called from Receive in this filter so we should
    //  never grab the filter lock.  However we grab the Receive lock so
    //  that when we're called from Stop we're synchronized with Receive().
    CAutoLock       lck(&m_csReceive);

    if(m_fStreaming)
    {

	m_fStreaming=0;

	TermMem4Decoder(m_pMem4Dec);
    }


    if(m_pMem)
    {
	delete []m_pMem;	//(2)
	m_pMem=NULL;
	m_pMemAligned=NULL;
    }


    return CVideoTransformFilter::StopStreaming();

}


/******************************Public*Routine******************************\
* 
*
* Handle quality control notifications sent to us
* ReActivated: anuragsh "Dec 16, 1999"
*
\**************************************************************************/
HRESULT
CDVVideoCodec::AlterQuality(Quality q)
{
    // turn on the Quality Control Flag so we can drop frames if needed in Receive()
    m_bQualityControlActiveFlag = TRUE;

    // call the parent's AlterQuality() so m_itrLate can be set appropriately
    return CVideoTransformFilter::AlterQuality(q);
}


//
// GetPages
//
// Returns the clsid's of the property pages we support
//
STDMETHODIMP CDVVideoCodec::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) 
    {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_DVDecPropertiesPage;
    return NOERROR;

} // GetPages

//
// get_IPDisplay
//
// Return the current effect selected
//
STDMETHODIMP CDVVideoCodec::get_IPDisplay(int *iDisplay)
{
    CAutoLock cAutolock(&m_DisplayLock);

    CheckPointer(iDisplay,E_POINTER);
    
    *iDisplay = m_iDisplay;
   
    return NOERROR;

} // get_IPDisplay


//
// put_IPDisplay
//
// Set the required video display
//
// if the isplay is changed, reconnect filters.
STDMETHODIMP CDVVideoCodec::put_IPDisplay(int iDisplay)
{
    CAutoLock cAutolock(&m_DisplayLock);
    BYTE bNTSC=TRUE;

    //check if display resolution change
    if(m_iDisplay == iDisplay)
        return NOERROR;

    //can not change property if m_fStreaming=1
    if(m_fStreaming)
	return E_FAIL;

    if (m_pInput == NULL) 
    {
	CTransformInputPin * pPin;
        pPin = (CTransformInputPin *)GetPin(0);
        ASSERT(m_pInput==pPin);
	ASSERT(m_pInput!=NULL);
    }
    if (m_pOutput == NULL) 
    {
	CTransformOutputPin * pPin;
        pPin = (CTransformOutputPin *)GetPin(1);
        ASSERT(m_pOutput==pPin);
	ASSERT(m_pOutput!=NULL);
    }

    // Ignore if we are not connected  to video render yet
    //CAutoLock cSampleLock(&m_RendererLock);
    if (m_pInput->IsConnected() == FALSE)  {
	m_iDisplay = iDisplay;
	//if it becomes PAL, SetMediaType will take care it when connected.
	switch (m_iDisplay)
	{
	case IDC_DEC360x240 :
	    m_lPicHeight=240;
	    m_lPicWidth=360;
	    break;
	case IDC_DEC720x480 :
	    m_lPicHeight=480;
    	    m_lPicWidth=720;
	    break;
	case IDC_DEC180x120 :
	    m_lPicHeight=120;
	    m_lPicWidth=180;
	    break;
	case IDC_DEC88x60 :
	    m_lPicHeight=60;
	    m_lPicWidth=88;
       	    break;
	default:
	    break;
	}
	return NOERROR;
    }
   

    //decide NTSC , PAL
    VIDEOINFO *InVidInfo = (VIDEOINFO *)m_pInput->CurrentMediaType().pbFormat;
    LPBITMAPINFOHEADER lpbi = HEADER(InVidInfo);
    if( (lpbi->biHeight== 480) || (lpbi->biHeight== 240) ||(lpbi->biHeight== 120) || (lpbi->biHeight== 60) )
	;
    else if( (lpbi->biHeight== 576) || (lpbi->biHeight== 288) ||(lpbi->biHeight== 144) || (lpbi->biHeight== 72) )
	    bNTSC=FALSE;
	  else
	      return E_FAIL; 
   
    //display resolution changed 
    if(iDisplay==IDC_DEC720x480){

	if ( !(m_CodecCap & AM_DVDEC_Full) )
	    return E_FAIL;

  	m_lPicWidth=720; 
	if(bNTSC==TRUE)
	    m_lPicHeight=480; 
	else
	    m_lPicHeight=576;
    }
    else if(iDisplay==IDC_DEC360x240){
	
	if ( !(m_CodecCap & AM_DVDEC_Half) )
	    return E_FAIL;
	m_lPicWidth=360; 
	if(bNTSC==TRUE)
	    m_lPicHeight=240;
	else
	    m_lPicHeight=288;
    }
    else if(iDisplay==IDC_DEC180x120){
	if ( !(m_CodecCap & AM_DVDEC_Quarter) )
	    return E_FAIL;
	m_lPicWidth=180; 
	if(bNTSC==TRUE)
	    m_lPicHeight=120;
	else
	    m_lPicHeight=144;
    }else if(iDisplay==IDC_DEC88x60){
	if ( !(m_CodecCap & AM_DVDEC_DC) )
	    return E_FAIL;
	m_lPicWidth=88; 
	if(bNTSC==TRUE)
	    m_lPicHeight=60;
	else
	    m_lPicHeight=72;
    }else{
	return E_FAIL;
    }

    m_iDisplay = iDisplay;
    if(m_pOutput->IsConnected())
    {	
        //reconnect, it would never fail
	m_pGraph->Reconnect( m_pOutput );

    }
    return NOERROR;
    
} // put_IPDisplay


//IPersistStream
//
// GetClassID
//
STDMETHODIMP CDVVideoCodec::GetClassID(CLSID *pClsid)
{
    *pClsid = CLSID_DVVideoCodec;
    return NOERROR;

} // GetClassID

HRESULT CDVVideoCodec::WriteToStream(IStream *pStream)
{
    PROP prop;
    HRESULT hr = S_OK;

    if( (hr = get_IPDisplay(&prop.iDisplay) ) == NOERROR )
    {
	ASSERT(prop.iDisplay==m_iDisplay);
	prop.lPicWidth=m_lPicWidth;
	prop.lPicHeight=m_lPicHeight;
        hr = pStream->Write(&prop, sizeof(PROP), 0);
    }

    return hr;
}

HRESULT CDVVideoCodec::ReadFromStream(IStream *pStream)
{
    PROP prop;
    HRESULT hr = S_OK;

    hr = pStream->Read(&prop, sizeof(PROP), 0);
    if(FAILED(hr))
        return hr;


    if(m_pOutput !=NULL)
    {
	int iDisplay=prop.iDisplay;
	hr = put_IPDisplay(iDisplay);

    }
    else
    {
	m_iDisplay=prop.iDisplay;
	m_lPicWidth=prop.lPicWidth;
	m_lPicHeight=prop.lPicHeight;
    }
    return hr;
}

int CDVVideoCodec::SizeMax()
{
    return sizeof(PROP);
}


STDMETHODIMP CDVVideoCodec::SetRGB219(BOOL bState)
// This method is used in the case of RGB24 to specify that the Dynamic
// Range to be used is (16,16,16)--(235,235,235)
{
    m_bRGB219 = bState;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvenc\encprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

class CDVEncProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

private:

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void    GetControlValues();

    CDVEncProperties(LPUNKNOWN lpunk, HRESULT *phr);

    BOOL m_bIsInitialized;				// Used to ignore startup messages
    int m_iPropDVFormat;
    int m_iPropVidFormat;
    int m_iPropResolution;

    IDVEnc *m_pIDVEnc;				// The custom interface on the filter


}; // DVDecProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvenc\resource.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by display.rc
//
#define IDS_TITLE                       2
#define IDD_DVEnc                       201
#define IDC_NTSC                        2000
#define IDC_PAL                         2001
#define IDC_RESOLUTION                  2006
#define IDC_dvsd                        2007
#define IDC_dvhd                        2008
#define IDC_dvsl                        2009
#define IDC_DVFORMAT                    2010
#define IDC_VIDEOFORMAT                 2011
#define IDC_720x480                     2012
#define IDC_360x240                     2013
#define IDC_180x12                      2014
#define IDC_180x120                     2014
#define IDC_88x60                       2015
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvenc\pencode.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "encode.h"

int	InitMem4Encoder( char **ppMem, DWORD dwCodecReq )\
{
     *ppMem= new char[720*576*2];   //NULL;
     if (*ppMem)
     {
        **ppMem = 1;       // DvEncodeAFrame uses this field to determine if 
                            // it has initialized ppMem previously. Setting it
                            // to 1 forces the initialization.
        return S_OK;
     }
     else 
         return E_OUTOFMEMORY;
}

void	TermMem4Encoder(char *pMem)
{
     if(pMem!=NULL)
		delete [] pMem;
 }

DWORD GetEncoderCapabilities(  )
{

    DWORD cap;
    cap =   AM_DVENC_Full	|
	    AM_DVENC_DV		| 
	    AM_DVENC_DVCPRO	|
	    AM_DVENC_DVSD	|
	    AM_DVENC_NTSC	|
	    AM_DVENC_PAL	|
	    AM_DVENC_MMX	|
	    AM_DVENC_RGB24     |
            AM_DVENC_RGB565     |
            AM_DVENC_RGB555     |
            AM_DVENC_RGB8;

    return		 cap;
}
/**
int DvEncodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwEncReq, char *pMem)
{

	DWORD dwPanReq=0;

	if(dwEncReq & AM_DVENC_RGB24)
		dwPanReq=0x100;
	else
		return ERROR;

	if(dwEncReq & AM_DVENC_NTSC)
		dwPanReq |=0x10000;
	else
		return ERROR;

	if(dwEncReq & AM_DVENC_DVSD)
		dwPanReq |=0x100000;
	else
		return ERROR;


	dwPanReq |=0x10000000;


	yvutrans( (unsigned char * )pMem, pSrc, dwPanReq	);
	
	unsigned short *pTmp;

	pTmp = (unsigned short *)pDst;

	DvEncode(pTmp, (unsigned char * )pMem, dwPanReq	);

     return S_OK;
}
**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvenc\encode.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.

// flags for in encoder capability
#define AM_DVENC_Full		0x00000001
#define AM_DVENC_Half       0x00000002
#define AM_DVENC_Quarter    0x00000004
#define AM_DVENC_DC	        0x00000008

#define AM_DVENC_NTSC		0x00000010	    //encoder can output NTSC DV stream
#define AM_DVENC_PAL		0x00000020	    //encoder can output PAL DV stream

#define AM_DVENC_YUY2		0x00000040	    //encoder can take any YUY2 video as input
#define AM_DVENC_UYVY	    0x00000080	    //encoder can take any UYVY video as input
#define AM_DVENC_RGB24		0x00000100	    //encoder can take any RGB24 video as input
#define AM_DVENC_RGB565		0x00000200	    //encoder can take any RGB565 video as input
#define AM_DVENC_RGB555		0x00000400	    //encoder can take any RGB555 video as input
#define AM_DVENC_RGB8		0x00000800	    //encoder can take any RGB8 video as input

// Note: V6.4 of the codec has eliminated the #define for AM_DVENC_Y41
// altogether. If they ever add it back, verify that the value has not
// changed. (GetEncoderCapabilities() never did return this as a
// capability, so the capabilities of our filter haven't changed in 
// going to V6.4.)
#define AM_DVENC_Y41P		0x00001000	    //encoder can take any y41p video as input


#define AM_DVENC_DVSD		0x00002000	    //encoder can output dvsd
#define AM_DVENC_DVHD		0x00004000	    //encoder can output dvhd
#define AM_DVENC_DVSL		0x00008000	    //encoder can output dvsl


#define AM_DVENC_DV			0x00010000

#define AM_DVENC_DVCPRO		0x00020000

#define AM_DVENC_AnyWidHei	0x00040000	    //encoder can take any width and height input
#define AM_DVENC_MMX		0x01000000	
#define AM_DVENC_DR219RGB	0x00100000		

				
typedef unsigned long DWORD;

int  InitMem4Encoder(char **ppMem,DWORD dwEncReq);

void TermMem4Encoder(char *pMem);

DWORD GetEncoderCapabilities(  );


//extern "C" int	__fastcall DvEncodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );

extern "C" int	__stdcall DvEncodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );
//extern "C" int	__cdecl DvEncodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvenc\encprop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#include <windows.h>
#include <windowsx.h>
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

#include <dv.h>
#include "EncProp.h"
#include "resource.h"

//
// CreateInstance
//
// Used by the ActiveMovie base classes to create instances
//
CUnknown *CDVEncProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CDVEncProperties(lpunk, phr);
    if (punk == NULL) {
	*phr = E_OUTOFMEMORY;
    }
    return punk;

} // CreateInstance


//
// Constructor
//
CDVEncProperties::CDVEncProperties(LPUNKNOWN pUnk, HRESULT *phr) :
	CBasePropertyPage	(NAME("DVenc Property Page"),
                      pUnk,IDD_DVEnc,IDS_TITLE),
    m_pIDVEnc(NULL),
    m_bIsInitialized(FALSE)
{
    ASSERT(phr);

} // (Constructor)


//
// OnReceiveMessage
//
// Handles the messages for our property window
//
INT_PTR CDVEncProperties::OnReceiveMessage(HWND hwnd,
                                          UINT uMsg,
                                          WPARAM wParam,
                                          LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_COMMAND:
        {
            if (m_bIsInitialized)
            {
                m_bDirty = TRUE;
                if (m_pPageSite)
                {
                    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
                }
            }
            return (LRESULT) 1;
        }

    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

} // OnReceiveMessage


//
// OnConnect
//
// Called when we connect to a transform filter
//
HRESULT CDVEncProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pIDVEnc == NULL);

    HRESULT hr = pUnknown->QueryInterface(IID_IDVEnc, (void **) &m_pIDVEnc);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    ASSERT(m_pIDVEnc);

    // Get the initial  property
    m_pIDVEnc->get_IFormatResolution(&m_iPropVidFormat,&m_iPropDVFormat, &m_iPropResolution, FALSE, NULL);

    m_bIsInitialized = FALSE ;
    return NOERROR;

} // OnConnect


//
// OnDisconnect
//
// Likewise called when we disconnect from a filter
//
HRESULT CDVEncProperties::OnDisconnect()
{
    // Release of Interface after setting the appropriate old effect value

    if (m_pIDVEnc == NULL) {
        return E_UNEXPECTED;
    }

    m_pIDVEnc->Release();
    m_pIDVEnc = NULL;
    return NOERROR;

} // OnDisconnect


//				
// OnActivate
//
// We are being activated
//
HRESULT CDVEncProperties::OnActivate()
{
    
    //Button_Enable(hwndCtl, fEnable);

    CheckRadioButton(m_Dlg, IDC_NTSC, IDC_PAL, m_iPropVidFormat);
    CheckRadioButton(m_Dlg, IDC_dvsd, IDC_dvsl, m_iPropDVFormat);
    CheckRadioButton(m_Dlg, IDC_720x480, IDC_88x60, m_iPropResolution);
    m_bIsInitialized = TRUE;
    return NOERROR;

} // OnActivate


//
// OnDeactivate
//
// We are being deactivated
//
HRESULT CDVEncProperties::OnDeactivate(void)
{
    ASSERT(m_pIDVEnc);
    m_bIsInitialized = FALSE;
    GetControlValues();
    return NOERROR;

} // OnDeactivate


//
// OnApplyChanges
//
// Apply any changes so far made 
//
HRESULT CDVEncProperties::OnApplyChanges()
{
    GetControlValues();
    return ( m_pIDVEnc->put_IFormatResolution(m_iPropVidFormat, m_iPropDVFormat, m_iPropResolution, FALSE, NULL ) );
} // OnApplyChanges


void CDVEncProperties::GetControlValues()
{
    int i;

    ASSERT(m_pIDVEnc);

    for (i = IDC_720x480; i <= IDC_88x60; i++) {
       if (IsDlgButtonChecked(m_Dlg, i)) {
            m_iPropResolution = i;
            break;
        }
    }

    for ( i = IDC_dvsd; i <= IDC_dvsl; i++) {
       if (IsDlgButtonChecked(m_hwnd, i)) {
            m_iPropDVFormat = i;
            break;
        }
    }


    for ( i = IDC_NTSC; i <= IDC_PAL; i++) {
	if (IsDlgButtonChecked(m_hwnd, i)){
                m_iPropVidFormat = i;
            break;
        }
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvenc\dvenc.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
/******************************Module*Header*******************************\
* Module Name: DVVideo.h
*
* Prototype DV Video codec
*
\**************************************************************************/

#ifndef __DVENC__
#define __DVENC__

extern const AMOVIESETUP_FILTER sudDVEnc;


// link to vfw32.lib to get this function....
extern "C" void FAR PASCAL StretchDIB(
	LPBITMAPINFOHEADER biDst,   //	BITMAPINFO of destination
	LPVOID	lpDst,		    //	The destination bits
	int	DstX,		    //	Destination origin - x coordinate
	int	DstY,		    //	Destination origin - y coordinate
	int	DstXE,		    //	x extent of the BLT
	int	DstYE,		    //	y extent of the BLT
	LPBITMAPINFOHEADER biSrc,   //	BITMAPINFO of source
	LPVOID	lpSrc,		    //	The source bits
	int	SrcX,		    //	Source origin - x coordinate
	int	SrcY,		    //	Source origin - y coordinate
	int	SrcXE,		    //	x extent of the BLT
	int	SrcYE); 	    //	y extent of the BLT


class CDVVideoEnc
	: public CTransformFilter,
	  public IDVEnc,
	  public ISpecifyPropertyPages,
	  public CPersistStream,
	  public IAMVideoCompression,
      public IDVRGB219

{

public:

    //
    // --- Com stuff ---
    //
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
	DECLARE_IUNKNOWN;

    //
    // --- CVideoTransformFilter overrides ---
    //
    HRESULT Transform(IMediaSample * pIn, IMediaSample *pOut);

    HRESULT CheckInputType(const CMediaType* mtIn);
    HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut);
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES * pProperties);
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT StartStreaming(void);
    HRESULT StopStreaming(void);
 

    // Quality control notifications sent to us
    //HRESULT AlterQuality(Quality q);
    
    CDVVideoEnc(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *pHr);
    ~CDVVideoEnc();

    // CPersistStream stuff
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);

    // CPersistStream override
    STDMETHODIMP GetClassID(CLSID *pClsid);

    // These implement the custom IDVEnc interface
    STDMETHODIMP get_IFormatResolution(int *iVideoFormat,int *iDVFormat, int *iResolution, BYTE fDVInfo, DVINFO *psDVInfo);
    STDMETHODIMP put_IFormatResolution(int iVideoFormat, int iDVFormat,int iResolution,BYTE fDVInfo, DVINFO *psDVInfo);

    // ISpecifyPropertyPages interface
    STDMETHODIMP GetPages(CAUUID *pPages);

    // IAMVideoCompression methods 
    STDMETHODIMP put_KeyFrameRate(long KeyFrameRate) {return E_NOTIMPL;};
    STDMETHODIMP get_KeyFrameRate(long FAR* pKeyFrameRate) {return E_NOTIMPL;};
    STDMETHODIMP put_PFramesPerKeyFrame(long PFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP get_PFramesPerKeyFrame(long FAR* pPFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP put_Quality(double Quality) {return E_NOTIMPL;};
    STDMETHODIMP get_Quality(double FAR* pQuality) {return E_NOTIMPL;};
    STDMETHODIMP put_WindowSize(DWORDLONG WindowSize) {return E_NOTIMPL;};
    STDMETHODIMP get_WindowSize(DWORDLONG FAR* pWindowSize) {return E_NOTIMPL;};
    STDMETHODIMP OverrideKeyFrame(long FrameNumber) {return E_NOTIMPL;};
    STDMETHODIMP OverrideFrameSize(long FrameNumber, long Size)
			{return E_NOTIMPL;};
    STDMETHODIMP GetInfo(LPWSTR pstrVersion,
			int *pcbVersion,
			LPWSTR pstrDescription,
			int *pcbDescription,
			long FAR* pDefaultKeyFrameRate,
			long FAR* pDefaultPFramesPerKey,
			double FAR* pDefaultQuality,
			long FAR* pCapabilities);

    // IDVRGB219 interface
    STDMETHODIMP SetRGB219 (BOOL bState);


private:
    char		*m_pMem4Enc;
    LPBYTE		m_pSample;
    int			m_perfidDVDeliver;

    CCritSec		m_DisplayLock;  // Private play critical section
    int			m_iVideoFormat;   
    int			m_iDVFormat;   
    int			m_iResolution;   
    BYTE		m_fDVInfo;
    DVINFO		m_sDVInfo;
    long		m_lPicWidth;
    long		m_lPicHeight;

    void		SetOutputPinMediaType(const CMediaType *pmt);
 
    
    BOOL		    m_fStreaming;   
    DWORD		    m_EncCap;	    //what the Enc can do 
    DWORD		    m_EncReg;	    //what users want it to do
    char		    m_fConvert;
    char *		    m_pMem4Convert;
    BOOL            m_bRGB219;


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvmux\dvmux.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


#include <streams.h>
#include <commctrl.h>
#ifndef FILTER_LIB
#include <initguid.h>
#endif
#if (1100 > _MSC_VER)
#include <olectlid.h>
#else
#include <olectl.h>
#endif
#include "dvmux.h"
#include "resource.h"


// setup data
const AMOVIESETUP_FILTER sudDVMux =
{ &CLSID_DVMux		// clsID
, L"DV Muxer"		// strName
, MERIT_UNLIKELY	// dwMerit
, 0			// nPins
, NULL   };		// lpPin


#ifdef FILTER_DLL

/*****************************************************************************/
// COM Global table of objects in this dll
CFactoryTemplate g_Templates[] =
{
    { L"DV Muxer"
    , &CLSID_DVMux
    , CDVMuxer::CreateInstance
    , NULL
    , &sudDVMux }
};

// Count of objects listed in g_cTemplates
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
     return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

#endif


HRESULT Copy(
  IMediaSample *pDest,
  IMediaSample *pSource)
{
  {
    // Copy the sample data

    BYTE *pSourceBuffer, *pDestBuffer;
    long lSourceSize	= pSource->GetSize();
    long lDestSize	= pDest->GetSize();

    ASSERT(lDestSize >= lSourceSize);

    pSource->GetPointer(&pSourceBuffer);
    pDest->GetPointer(&pDestBuffer);

    CopyMemory( (PVOID) pDestBuffer, (PVOID) pSourceBuffer, lSourceSize );
  }
  {
    // copy the sample time

    REFERENCE_TIME TimeStart, TimeEnd;

    if (NOERROR == pSource->GetTime(&TimeStart, &TimeEnd)) {
	pDest->SetTime(&TimeStart, &TimeEnd);
    }
  }
  {
    // copy the media time

    REFERENCE_TIME TimeStart, TimeEnd;

    if (NOERROR == pSource->GetMediaTime(&TimeStart, &TimeEnd)) {
	pDest->SetMediaTime(&TimeStart, &TimeEnd);
    }
  }
  {
    // Copy the Sync point property

    HRESULT hr = pSource->IsSyncPoint();
    if (hr == S_OK)
    {
      pDest->SetSyncPoint(TRUE);
    }
    else if (hr == S_FALSE)
    {
      pDest->SetSyncPoint(FALSE);
    }
    else {	// an unexpected error has occured...
      return E_UNEXPECTED;
    }
  }
  {
    // Copy the media type

    AM_MEDIA_TYPE *pMediaType;
    pSource->GetMediaType(&pMediaType);
    pDest->SetMediaType(pMediaType);
    DeleteMediaType( pMediaType );
  }
  {
    // Copy the preroll property

    HRESULT hr = pSource->IsPreroll();
    if (hr == S_OK)
    {
      pDest->SetPreroll(TRUE);
    }
    else if (hr == S_FALSE)
    {
      pDest->SetPreroll(FALSE);
    }
    else {	// an unexpected error has occured...
      return E_UNEXPECTED;
    }
  }
  {
    // Copy the actual data length

    long lDataLength = pSource->GetActualDataLength();
    pDest->SetActualDataLength(lDataLength);
  }

  return NOERROR;
}



/******************************Public*Routine******************************\
* CreateInstance
*
* This goes in the factory template table to create new instances
*
\**************************************************************************/
CUnknown *
CDVMuxer::CreateInstance(
    LPUNKNOWN pUnk,
    HRESULT * phr
    )
{
    DbgLog((LOG_TRACE, 2, TEXT("CDVMuxer::CreateInstance")));
    return new CDVMuxer(TEXT("DV muxer filter"), pUnk,CLSID_DVMux, phr);
}


// =================================================================
// Implements the CDVMuxer class
// =================================================================

// CDVMuxer::CDVMuxer
//
CDVMuxer::CDVMuxer( TCHAR     *pName,
                LPUNKNOWN pUnk,
                CLSID     clsid,
                HRESULT   *phr )
    : CBaseFilter(pName, pUnk, &m_csFilter, clsid)
    , m_pOutput(NULL)				// Output pin
    , m_iInputPinCount(0 ) // Number of input pins, (1 )video pin+ 1 audio pin 
    , m_fMuxStreaming(FALSE)
    , m_iVideoFormat(IDC_DVMUX_NTSC)		//default, it gets reset in inputpin's SetMediatype(
    , m_fWaiting_Audio(FALSE)
    , m_fWaiting_Video(FALSE)
    , m_pExVidSample(NULL)
    , m_MediaTypeChanged(FALSE)
    , m_DVINFOChanged(FALSE)
    , m_TimeFormat(FORMAT_TIME)
    , m_fEOSSent(FALSE)				// Have we sent EOS?
{
    ASSERT(phr != NULL);
    m_LastVidTime=0;
    m_LastVidMediatime=0;

    FillMemory ( m_UsedAudSample, (DWORD)(DVMUX_MAX_AUDIO_PIN*sizeof(LONG)), 0); 

    InitDVInfo();

    for(int i=0; i<DVMUX_MAX_AUDIO_PIN; i++)
    {	
	m_wMinAudSamples[i] =0;
	m_wMaxAudSamples[i] =0;
    }

    if (*phr == NOERROR)
        *phr = CreatePins();
}

HRESULT CDVMuxer::pExVidSample(   IMediaSample ** ppSample, BOOL fEndOfStream )
{
    if(m_pExVidSample==NULL && fEndOfStream==FALSE) // TRUE may not mean 1.
    {
        HRESULT hr = m_pOutput->GetDeliveryBuffer(&m_pExVidSample,NULL,NULL,0);
	if ( FAILED(hr) ) 
	    return hr;

	ASSERT(m_pExVidSample);
    }

    *ppSample	= m_pExVidSample;
    return NOERROR;
}

HRESULT CDVMuxer::InitDVInfo()
{

	//for 1st 5/6 DIF seq.
	m_OutputDVFormat.dwDVAAuxSrc=AM_DV_DEFAULT_AAUX_SRC;
	m_OutputDVFormat.dwDVAAuxCtl=AM_DV_DEFAULT_AAUX_CTL;

	//for 2nd  5/6 DIF seq.
	m_OutputDVFormat.dwDVAAuxSrc1=AM_DV_DEFAULT_AAUX_SRC;
	m_OutputDVFormat.dwDVAAuxCtl1=AM_DV_DEFAULT_AAUX_CTL;

	//for video information
	m_OutputDVFormat.dwDVVAuxSrc=AM_DV_DEFAULT_VAUX_SRC;
	m_OutputDVFormat.dwDVVAuxCtl=AM_DV_DEFAULT_VAUX_CTL;

	return NOERROR;

}


//X
// CDVMuxer::CreatePins
//
// Creates the pins for the DVMux. Override to use different
// pins
HRESULT CDVMuxer::CreatePins()
{
    HRESULT hr = NOERROR;

    // Allocate the output pin
    m_pOutput = new CDVMuxerOutputPin(NAME("DVMuxer output pin"),
                                   this,          // Owner filter
                                   this,          // Route through here
                                   &hr,           // Result code
                                   L"Output");    // Pin name
    if (m_pOutput == NULL)
        hr = E_OUTOFMEMORY;
	
    // Allocate the input pin
    m_apInput = new CDVMuxerInputPin *[DVMUX_MAX_AUDIO_PIN + 1];
    if (m_apInput)
    {
        for (int i=0; i<(DVMUX_MAX_AUDIO_PIN + 1); i++)
	    m_apInput[i]=NULL;
    }
    
    // Allocate the input pin
    m_apInputPin = new CDVMuxerInputPin *[DVMUX_MAX_AUDIO_PIN + 1];
    if (m_apInputPin)
    {
        // Destructor relies on array element being NULL to 
        // determine whether to delete the pin
        for (int i=0; i<(DVMUX_MAX_AUDIO_PIN + 1); i++)
	    m_apInputPin[i]=NULL;
    }


    if ( (m_pOutput ==  NULL) || (m_apInput ==  NULL) || (m_apInputPin ==  NULL) )
        hr = E_OUTOFMEMORY;
    else 
    {
      	//Create One input pin
        m_apInputPin[0]=new CDVMuxerInputPin(NAME("DVMuxer Input pin"),
				    this,       // Owner filter
				    this,       // Route through here
                                    &hr,        // Result code
                                    L"Stream 0", // Pin Name
                                    0);         // Pin Number

        if (m_apInputPin[0] == NULL) 
	    hr = E_OUTOFMEMORY;
	else
    	    m_iInputPinCount++;
    }

    return hr;
}

//X
// destructor
CDVMuxer::~CDVMuxer()
{
    /* Delete the pins */
    if (m_apInputPin) {
	for (int i = 0; i < m_iInputPinCount; i++)
            if (m_apInputPin[i] != NULL)
                delete m_apInputPin[i];

        delete [] m_apInputPin;
	delete [] m_apInput;

    }

    if (m_pOutput)
        delete m_pOutput;

}

//X return the number of pins we provide
int CDVMuxer::GetPinCount()
{
    return m_iInputPinCount + 1;
}


//X return a non-addrefed CBasePin *
CBasePin * CDVMuxer::GetPin(int n)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::GetPin(%d)"), n));

    if (n > m_iInputPinCount) {
        DbgBreak("Bad pin requested");
        return NULL;
    } else if (n == m_iInputPinCount) { // our output pin
        return m_pOutput;
    } else {                            // we are dealing with an input pin
        return m_apInputPin[n];
    }
} // GetPin
//X
HRESULT CDVMuxer::StartStreaming()
{
    
    DbgLog((LOG_TRACE, 2, TEXT("CDVMuxer::StartStreaming()")));

    m_LastVidTime	=0;
    m_LastVidMediatime	=0;

    //Reset	Audio sample count
    FillMemory ( m_UsedAudSample, 
		(DWORD)(DVMUX_MAX_AUDIO_PIN*sizeof(LONG)),
		0); 
	
    m_fWaiting_Audio		=FALSE;
    m_fWaiting_Video            =FALSE;
    m_fEOSSent			= FALSE;

    m_fMuxStreaming		=TRUE;

    //to support audio longer then video case
    ASSERT(m_pExVidSample==NULL);

    for (int i = 0; i < m_iInputPinCount; i ++)
        ASSERT(! m_apInputPin[i]->SampleReady( 1 ) );
            
    for (int iPin=0; iPin < DVMUX_MAX_AUDIO_PIN; iPin++)
    {
	// Note: m_apInput[1..2] contain the audio pins
        // if they are connected. See CompleteConnect,
        // CheckMediaType and Disconnect in CDVMuxerInputPin

        // A call to Reset only serves to batch the same audio  
        // samples with the same DV frames if the file is replayed 
        // by stopping and starting the graph. (And it makes a 
        // difference only for the NTSC locked audio case.)
        // This call (and the Reset function itself) are not essential.

        if (m_apInput[iPin+1] != NULL)
	{
            m_AudSampleSequence[iPin].Reset(m_wMinAudSamples[iPin], m_wMaxAudSamples[iPin]);
        }
    }

    return NOERROR;


}

//X
HRESULT CDVMuxer::StopStreaming()
{
    // Free any media samples that we are holding on to
    // we need to have been locked for this operation
    // (done by Stop)

    CAutoLock waitUntilStoppedSending(&m_csMuxLock);

    DbgLog((LOG_TRACE, 2, TEXT("CDVMuxer::StopStreaming()")));

    ReleaseAllQueuedSamples();

    m_fMuxStreaming		=FALSE;
    m_fWaiting_Audio		=FALSE;
    m_fWaiting_Video            =FALSE;

    if(m_pExVidSample)
    {
	m_pExVidSample->Release();
	m_pExVidSample=NULL;
    }

    return NOERROR;
}

HRESULT CDVMuxer::Receive()
{
   
    IMediaSample    *pSampleOut;
    BYTE	    *pDst;
    CRefTime	    VidStart, VidStop;
    CRefTime	    AudStart[DVMUX_MAX_AUDIO_PIN], AudStop[DVMUX_MAX_AUDIO_PIN];
    BOOL	    fNoVideo=FALSE;
    HRESULT	    hr;
    BOOL	    fNot_VideoEOSReceived=TRUE;
    long lDataLength = 12*150*80;   //PAL
    REFERENCE_TIME TimeStart;

    CAutoLock lock(&m_csMuxLock);
	
    //*************************************************
    //Video has to be connected. Get dv video sample
    //*************************************************
    m_fWaiting_Video = FALSE;
    if (m_apInput[DVMUX_VIDEO_INPUT_PIN]->SampleReady( 1 ) )
    {

    	//get one dv video sample
    	pSampleOut=m_apInput[ DVMUX_VIDEO_INPUT_PIN ]->GetNthSample( 0 );
    	
	//get time stamp
    	pSampleOut->GetTime( (REFERENCE_TIME*)&VidStart,  (REFERENCE_TIME*)&VidStop);		    

	//get data pointer
	pSampleOut->GetPointer( &pDst );
    }
    else
    {
	if ( m_apInput[DVMUX_VIDEO_INPUT_PIN]->m_fEOSReceived)
	{
	    fNoVideo			=TRUE;

	    fNot_VideoEOSReceived	=FALSE;
	    HRESULT hr = m_pOutput->GetDeliveryBuffer(&pSampleOut,NULL,NULL,0);
	    if ( FAILED(hr) ) 
		return hr;

	    ASSERT(pSampleOut);
	    if( m_pExVidSample ==NULL)
            {
                // m_fWaiting_Video should probably be set to TRUE, but this 
                // is unlikely to happen - should happen only if there were 
                // other errors or no video has been received at all
                return NOERROR;
            }
	    else
	    {
		Copy(pSampleOut, m_pExVidSample);

		if( m_iVideoFormat==IDC_DVMUX_NTSC)
		{
		VidStop=m_LastVidTime+ UNITS*1000L/29970L;		//DV has to output 29.97frames/sec if it is NTSC,
		pSampleOut->SetTime( (REFERENCE_TIME*)&m_LastVidTime,  (REFERENCE_TIME*)&VidStop);
		}
		else
		{
		VidStop=m_LastVidTime+ UNITS/25;		//DV has to output 25frames/sec if it is PAL,
		pSampleOut->SetTime( (REFERENCE_TIME*)&m_LastVidTime,  (REFERENCE_TIME*)&VidStop);
		}

		//get time stamp
    		VidStart=m_LastVidTime;
	 
		//get data pointer
		pSampleOut->GetPointer( &pDst );
	    }
	}
	else
        {
	    m_fWaiting_Video = TRUE;
            return NOERROR;	    //waiting for more video
        }

    }



   //*************************************************
    //Audio does not have to be connected. 
    //get Audio Samples
    //*************************************************
    BYTE         *apAudData [DVMUX_MAX_AUDIO_PIN] [DVMUX_MAX_AUDIO_SAMPLES];
    IMediaSample *pAudSample [DVMUX_MAX_AUDIO_PIN] [DVMUX_MAX_AUDIO_SAMPLES ];
    WORD 	 wAudSampleSize [DVMUX_MAX_AUDIO_PIN] [DVMUX_MAX_AUDIO_SAMPLES];
    LONG         nUsedAudSample [DVMUX_MAX_AUDIO_PIN];
    WORD         wAudBlk [DVMUX_MAX_AUDIO_PIN];
    WORD 	 wTotalAudSamples [DVMUX_MAX_AUDIO_PIN];
    int          nNumSamplesProcessed [DVMUX_MAX_AUDIO_PIN];

    BOOL fAud_Mute[DVMUX_MAX_AUDIO_PIN];
    for(int iPin=1; iPin<= DVMUX_MAX_AUDIO_PIN; iPin++)
    {
	fAud_Mute[iPin-1]   = FALSE;
        wTotalAudSamples[iPin-1] = 0;

	//since max audio sample needed per frame=48000*4/30=6400byte
	//init
	for(int j=0; j<DVMUX_MAX_AUDIO_SAMPLES; j++)
	{	
	    apAudData[iPin-1][j]=NULL;
	    wAudSampleSize[iPin-1][j]=0;
	    pAudSample[iPin-1][j]=NULL;
	}

	if ( m_apInput[iPin]!= NULL)
	{
	    ASSERT(m_apInput[iPin]->IsConnected() );

            //fetch enough audio data
	    WAVEFORMATEX *pWave =(WAVEFORMATEX *)m_apInput[iPin]->CurrentMediaType().pbFormat ;

            nUsedAudSample[iPin-1] = m_UsedAudSample[iPin-1];

            // @@@ jaisri:Isn't it safer to use pWave->nBlockAlign?
            wAudBlk[iPin-1] = (pWave->wBitsPerSample) * (pWave->nChannels) >> 3 ;

	    int Ind;
    	    int j=0; // j is an alias for nNumSamplesProcessed[iPin-1]; we
                     // could have declared: int& j = nNumSamplesProcessed[iPin-1]; j = 0;
                     // but this is probably clearer.
            nNumSamplesProcessed[iPin-1] = 0; 

	    do
	    {
FETCH_AGAIN:
		if( m_apInput[iPin]->SampleReady( j+1 )  )
		{
                    if(j)
                       nUsedAudSample[iPin-1]=0;
                                  
		    m_fWaiting_Audio	= FALSE;
		    pAudSample[iPin-1][j]	= m_apInput[ iPin ]->GetNthSample( j );
		    ASSERT( pAudSample[iPin-1][j] !=  NULL);
		
		    int DataLenght=pAudSample[iPin-1][j]->GetActualDataLength();

		    if(!DataLenght)
		    {
			// jaisri: Note: this if clause was added to fix bug 32702 or bug 33821
                        // in some database. Which one? (in v38 of \\faulty\slm, amovie\filters\dv\dvmux.)
                        // Ideally, this this condition should be handled
                        // below rather than being special cased.

                        //this is zero length audio bufer. It just tells us that there 
			// is no audio during AudStart[iPin-1], VidStart 
			pAudSample[iPin-1][j]->GetTime( (REFERENCE_TIME*)&AudStart[iPin-1],  (REFERENCE_TIME*)&AudStop[iPin-1] );

			//release all audio samples before this one and this one
			m_UsedAudSample[iPin-1] = nUsedAudSample[iPin-1] = 0;
			m_apInput[ iPin ]->ReleaseNSample(j+1);
			
		    	if( AudStart[iPin-1] >= VidStart ) 
			{			    
                            // @@@ jaisri: How is this justified if j > 0?
                            // And shouldn't the comparison be with VidStop?

                            //if audio start is later than video start , there is no audio for this dv frame			//video should always continoues(no time gap)
		    	    fAud_Mute[iPin-1]=TRUE;
			    break;      // goto SET_AAUX;
			}
			else
			{
			    // @@@ jaisri: Shouldn't we check AudStop[iPin-1] v/s VidStart if j == 0?
                            goto WAITING_AUDIO; 
			    //allow video waiting longer for more audio
			}
		    }

		    ASSERT( DataLenght >= nUsedAudSample[iPin-1] );

		    //get audio data buffer
		    pAudSample[iPin-1][j]->GetPointer( &apAudData[iPin-1][j] );

	    
		    if(!j){	    //get rid of already muxed audio samples
			pAudSample[iPin-1][j]->GetTime( (REFERENCE_TIME*)&AudStart[iPin-1],  (REFERENCE_TIME*)&AudStop[iPin-1] );
			apAudData[iPin-1][j] += nUsedAudSample[iPin-1] ;
			if( nUsedAudSample[iPin-1] )
			    AudStart[iPin-1] += ( nUsedAudSample[iPin-1] *(AudStop[iPin-1]-AudStart[iPin-1]) /pAudSample[iPin-1][j]->GetActualDataLength() ); 

			//if audio is much later than video , do not mux audio in this DV frame frame
			//video should always continoues(no time gap)
		    	if( AudStart[iPin-1] >= VidStop ) 
			{
			    ASSERT(nUsedAudSample[iPin-1] == 0);
                            fAud_Mute[iPin-1]=TRUE;
			    break;                  // goto SET_AAUX;
			}
			//if audio is much earlier than video, release this sample
			//get another one
			if( AudStop[iPin-1] <= VidStart)
			{
	    		    m_apInput[ iPin ]->ReleaseNSample(1);
			    m_UsedAudSample[iPin-1] = nUsedAudSample[iPin-1] = 0;

                            // Manbugs # 32869
                            apAudData[iPin-1][0] = NULL;
                            pAudSample[iPin-1][0] = NULL;
			    goto FETCH_AGAIN;
			}
		
		    }

		    //get audio samples left in the buffer 
		    if(!j)  //first sample
		    {
			wTotalAudSamples[iPin-1]=(WORD) ( (pAudSample[iPin-1][j]->GetActualDataLength() - nUsedAudSample[iPin-1])/wAudBlk[iPin-1] );
			wAudSampleSize[iPin-1][j] = wTotalAudSamples[iPin-1];
		    }
		    else    //2nd sample or 3rd sample
		    {
	    		wAudSampleSize[iPin-1][j] =(WORD) ( pAudSample[iPin-1][j]->GetActualDataLength()/wAudBlk[iPin-1] );
			wTotalAudSamples[iPin-1] += wAudSampleSize[iPin-1][j];
		    }

		    //how many samples we need
		    if(  ( wTotalAudSamples[iPin-1] >= m_wMinAudSamples[iPin-1] ) &&  ( wTotalAudSamples[iPin-1] <=	m_wMaxAudSamples[iPin-1] ) )
		    {
		        //Sample rate is right, we take all samples
		        nUsedAudSample[iPin-1]  = 0;
			break;
		    }
		    else if(   wTotalAudSamples[iPin-1] > m_wMaxAudSamples[iPin-1] )
		    {
		        //too many audio samples
			WORD wTmp;
			if(!j)
			{	
			    // @@@ jaisri: makes more sense to compare AudStop[iPin-1] and VidStop??
                            if( (VidStart >= AudStart[iPin-1] ) ) // || ( AudStop[iPin-1] <= VidStop ) )
			        wAudSampleSize[iPin-1][j]=m_wMaxAudSamples[iPin-1];	    //lot of audio sample are needed to be muxed
			    else
			        wAudSampleSize[iPin-1][j]=m_wMinAudSamples[iPin-1];
				
			    nUsedAudSample[iPin-1] +=(wAudSampleSize[iPin-1][j]*wAudBlk[iPin-1]);   //can not use wTmp because it may not wAudBlk[iPin-1] Aligned
			    ASSERT( pAudSample[iPin-1][j]->GetActualDataLength() > nUsedAudSample[iPin-1] );
			    wTotalAudSamples[iPin-1]=wAudSampleSize[iPin-1][j];
				
			}
			else
			{
			   
                            if( (VidStart >= AudStart[iPin-1] ) ) // || ( AudStop[iPin-1] <= VidStop ) ) - note AudStop[iPin-1] is not currently updated for j = 1, 2, ...
			    {
			        wAudSampleSize[iPin-1][j]=m_wMaxAudSamples[iPin-1]-(wTotalAudSamples[iPin-1] -wAudSampleSize[iPin-1][j]);
			    }
			    else
			    {
				wAudSampleSize[iPin-1][j]=m_wMinAudSamples[iPin-1] -(wTotalAudSamples[iPin-1] -wAudSampleSize[iPin-1][j]);
			    }
				
			    ASSERT(wAudSampleSize[iPin-1][j]>0);

			    nUsedAudSample[iPin-1]  =wAudSampleSize[iPin-1][j]*wAudBlk[iPin-1];
			    ASSERT( pAudSample[iPin-1][j]->GetActualDataLength() >= nUsedAudSample[iPin-1] );
			    if( pAudSample[iPin-1][j]->GetActualDataLength() ==nUsedAudSample[iPin-1])
			        nUsedAudSample[iPin-1]=0;

			    Ind=0;
			    wTotalAudSamples[iPin-1]=0;
			    do
			    {
				wTotalAudSamples[iPin-1]+=wAudSampleSize[iPin-1][Ind];
			    } while(Ind++<j);
			}
			break;
	    	    }
		    else
		    {
			//not enough sample
			//nUsedAudSample[iPin-1]=0;
			ASSERT(  wTotalAudSamples[iPin-1] < m_wMaxAudSamples[iPin-1]  );
		    }
		}
		else  //if( m_apInput[iPin]->SampleReady( j+1 )  )
		{
		    if( m_apInput[ iPin ]->m_fEOSReceived)
		    {
		    	m_fWaiting_Audio=TRUE;
	   		if(j)	 //if we are fetch (j+1) nd sample, 
			{
			    // jaisri: Following assertion will not hold for locked audio.
                            // For unlocked audio, all audio samples will typically be used
                            // since each DV frame can hold a range of samples. For locked 
                            // audio, each DV frame can hold only a fixed number of samples.
                            // So a few samples could be bumped at the end of the stream.

                            // We should really keep a member variable that tells us if
                            // audio is locked - could add "m_bLocked ||" to this assertion

                            // ASSERT( apAudData[iPin-1][0] !=NULL   &&  !nUsedAudSample[iPin-1]  );

			    m_UsedAudSample[iPin-1] = nUsedAudSample[iPin-1] = 0;
			    //since it is end of Received release existing samples
			    m_apInput[ iPin ]->ReleaseNSample(j);
			}
			else
			{
			    ASSERT(!j);
			    ASSERT(apAudData[iPin-1][0]==NULL);
			}
			    
			//this audio pin is not going to receive audio anymore 			
			fAud_Mute[iPin-1]=TRUE;
			if(m_apInput[DVMUX_VIDEO_INPUT_PIN]->m_fEOSReceived)
                        {
			    // @@@ jaisri: hr is not initialized and is returned.
                            // Note that m_fWaiting_Audio is set to TRUE.

                            // Don't understand why this is done anyway. What if
                            // the other pin has audio to be processed?
                            // goto RELEASE;

                            // ============ Changed to following:

                            // jaisri: The goto RELEASE caused an infinite loop: Pin 1 has got 
                            // end of stream, Pin 2 just received end of stream and
                            // is calling this function from CDVMuxerInputPin::EndOfStream

                            // The worst thing that can happen if we remove this goto
                            // is that one extra video frame gets delivered, and, in 
                            // the case that only 1 pin is connected, it has no audio.

                            break;  // This is equivalent to the old "goto SET_AAUX"
                        }
			else
                        {
			    break;  // goto SET_AAUX;
                        }
		    }
		    else
		    {	
WAITING_AUDIO:
			//not enough audio for this frame, have to wait for more audio
			m_fWaiting_Audio=TRUE;
			if(fNot_VideoEOSReceived==FALSE)
			    pSampleOut->Release();

		    	return Waiting_Audio;
		    }
		}

                // @@@ jaisri: What is the rationale for choosing 
                // DVMUX_MAX_AUDIO_SAMPLES = 3? Also, what's the
                // guarantee that j won't become DVMUX_MAX_AUDIO_SAMPLES
                // and we drop out of the loop here when we don't
                // have the minimum number of samples for the video 
                // frame?

		j++;
                nNumSamplesProcessed[iPin-1]++;

	    } while (j< DVMUX_MAX_AUDIO_SAMPLES);

        } // if ( m_apInput[i]->IsConnected() )

    } // for iPin

    // We now have determined that we have sufficient
    // audio samples (for both pins) for this DV frame
    for(int iPin=1; iPin<= DVMUX_MAX_AUDIO_PIN; iPin++)
    {
	if ( m_apInput[iPin]!= NULL)
	{
	    int j = nNumSamplesProcessed[iPin-1];

            //*************************************************
	    //we do get enough audio sample for this frame
	    //*************************************************
	    
            m_UsedAudSample[iPin-1] = nUsedAudSample[iPin-1];

	    if (!fAud_Mute[iPin-1])
            {
                //*************************************************
	        //mux audio from the audio pin(iPin) to the dv video sample
	        //*************************************************
	        ASSERT( AudStop[iPin-1] > VidStart);    //check audio sample rate is too heigh
	        ASSERT( VidStop > AudStart[iPin-1]);    //check whether audio sample rate is too low
	        ASSERT( ( wTotalAudSamples[iPin-1] >= m_wMinAudSamples[iPin-1] ) &&  ( wTotalAudSamples[iPin-1] <= m_wMaxAudSamples[iPin-1] ) );

                ScrambleAudio(pDst, apAudData[iPin-1], (iPin-1), wAudSampleSize[iPin-1]);

                #if defined(DEBUG) && (DVMUX_MAX_AUDIO_SAMPLES != 3)
                #error DbgLog assumes DVMUX_MAX_AUDIO_SAMPLES is 3; change it.
                #endif

                DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Receive: iPin=%d, Delivered %d=%d+%d+%d samples"),
                        iPin, wTotalAudSamples[iPin-1], wAudSampleSize[iPin-1][0], wAudSampleSize[iPin-1][1], wAudSampleSize[iPin-1][2]
                        ));

                //*************************************************
	        //release audio samples
	        // we have j+1 audio media samples will be used by muxing
	        // when we have one sample,j=0
	        // when we have n sample, j=n-1;
	        //*************************************************
	        if( !m_UsedAudSample[iPin-1] )
	        {	
		    //all audio in j+1 samples will be used, release all of them
    		    ASSERT(apAudData[iPin-1][j] !=NULL );
	            m_apInput[ iPin ]->ReleaseNSample(j+1); 

                    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Receive: iPin=%d, No unused samples"), iPin));
	        }
	        else
	        {
		    //only used j+1-1 sample

                    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Receive: iPin=%d, %d unused samples, j = %d"),
                        iPin, (pAudSample[iPin-1][j]->GetActualDataLength()-m_UsedAudSample[iPin-1])/wAudBlk[iPin-1], j));


                    if( (j-1) >= 0 )  //when j=0, we do not release sample
	    	        m_apInput[ iPin ]->ReleaseNSample(j);
	        }	     
            }
        }
    }

// SET_AAUX:   // label is no longer used

    // Manbugs 47563. Sonic Foundry relied on the DV mux not clobbering the audio in the
    // DV stream when no audio pins were connected. This was the pre-DX8 behavior. The
    // if below restores that behavior.
    //
    // Note that, if the output is played on the PC, there won't be audio - this is 
    // determined by the output pin's connection format, not by the DV stream headers.
    // This is the way it has always been.
    if (m_apInput[1] != NULL || m_apInput[2] != NULL)
    {
        // Manbugs 37710:If we don't write audio to an audio block, make sure
        // that we zap the audio headers. This is a departure from Win ME and 
        // previous versions of the mux (which never zapped the header if no 
        // audio pins were connected and sometimes did it wrong if an audio pin
        // was connected). If we didn't do this and played this dv to a camcorder, 
        // it would still see the old audio (i.e., the audio that was in the video stream).
        // On the PC, the connection format is used to determine the audio 
        // streams, and the "old" (unzapped) audio in the video stream is totally 
        // masked out. So we had conflicting behavior if the dv was rendered to a 
        // camcorder v/s rendered on the PC.
        //
        // While we are at it, we've removed a few deviations from the Blue Book that
        // the code previously had, fixed the bug mentioned above and one other, and 
        // simplified the code some. Note that we always write the pack headers to all 
        // DIF sequences now, independent of pin connections.

        //*************************************************
        //set audio sample size(AAUX source pack)
        //*************************************************    

        int iPos=0;
        int DifCnt=10;
        if ((m_OutputDVFormat.dwDVVAuxSrc & AM_DV_AUDIO_5060))
        {
	    // PAL
            DifCnt=12;
        }

        // Write AuxSrc and AuxCtl to each DIF sequence in the first audio block. The first audio 
        // block contains half the DIF sequences. Note: The terms "track" (which is extensively
        // used in the Blue Book) and "DIF sequence" are synonymous - see Table 42 in Part 2 of 
        // the Blue Book.

        DWORD dwAAuxSrc = m_OutputDVFormat.dwDVAAuxSrc;
        DWORD dwAAuxCtl = m_OutputDVFormat.dwDVAAuxCtl;
        DWORD dwNumSamples = 0;

        // Make sure that AF_SIZE is not set in m_OutputDVFormat.dwDVAAuxSrc
        ASSERT((dwAAuxSrc & AM_DV_AUDIO_AFSIZE) == 0);
        dwAAuxSrc &= ~AM_DV_AUDIO_AFSIZE; // zap it if it is

        // Determine if the first audio block is muted. Note that
        // the first audio block's audio is got from 
        // m_apInput[DVMUX_VIDEO_INPUT_PIN+1] if that pin is connected.
        // If it is not connected and m_apInput[DVMUX_VIDEO_INPUT_PIN+2]
        // has stereo, 16 bit 44.1 or 48KHz audio, it is got from the second pin.
        // (Note that 32K, 16 bit stereo audio is recorded in SD 4ch mode.)

        if (m_apInput[DVMUX_VIDEO_INPUT_PIN+1] == NULL)
        {
            // The pin is not connected
            if ((dwAAuxSrc & AM_DV_AUDIO_MODE) != AM_DV_AUDIO_NO_AUDIO)
            {
                // The audio block is determined by the other audio pin
                fAud_Mute[0] = fAud_Mute[1];

	        if (!fAud_Mute[0])
	        {
                    ASSERT( wTotalAudSamples[1] >= m_wMinAudSamples[1]  );
                    ASSERT( wTotalAudSamples[1] <=	m_wMaxAudSamples[1]  );
                    dwNumSamples = wTotalAudSamples[1] - m_wAudSamplesBase[1];  		
	        }
	        else
	        {
                    // dwNumSamples is not used even for the JVC camera workaround
                    // because both audio blocks are muted. Anyway, assert it is 0.
                    ASSERT(dwNumSamples == 0);
	        }       

            }
            else
            {
                // The audio block has no audio, so we are muted
                fAud_Mute[0] = TRUE;

                // dwNumSamples is unused

                // Now it is used for the JVC camera workaround - see
                // below. The value should be 0.

                ASSERT(dwNumSamples == 0);
            }

        }
        else
        {
            // Assert we have audio in this block if the pin is connected
            ASSERT((dwAAuxSrc & AM_DV_AUDIO_MODE) != AM_DV_AUDIO_NO_AUDIO);

            // The pin is connected. fAud_Mute[0] has been set correctly
            if (!fAud_Mute[0])
            {
	        ASSERT( wTotalAudSamples[0] >= m_wMinAudSamples[0]  );
	        ASSERT( wTotalAudSamples[0] <=	m_wMaxAudSamples[0]  );
                dwNumSamples = wTotalAudSamples[0] - m_wAudSamplesBase[0];
            }
            else
            {
                // dwNumSamples is unused

                // Now it is used for the JVC camera workaround - see
                // below. The value should be 0.

                ASSERT(dwNumSamples == 0);
            }
        }

        // Update the src and ctl packs
        if (fAud_Mute[0])
        {
            dwAAuxSrc |= AM_DV_AUDIO_NO_AUDIO;
            dwAAuxCtl |= AM_DV_AAUX_CTL_IVALID_RECORD; // REC_MODE = 0x111
        }
        else
        {
            // Set AF_SIZE in the source pack
            dwAAuxSrc |= dwNumSamples;
        }

        for (int i = 0; i < DifCnt/2; i++)
        {
	    unsigned char *pbTmp;

	    pbTmp = pDst + 483 + i*12000;  //6*80+3=483, 150*80=12000

	    if (i % 2)
            {
                // Odd track. Src goes in pack 0 and Ctl in pack 1
            
                // We leave this in for compatibility with the old code;

                // Check if pack 3 has Aux source
                if ( *(pbTmp + 3*16*80) == 0x50 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp + 3*16*80, 0xff, 5);
                }
            
                // Check if pack 4 has Aux control
                if ( *(pbTmp + 4*16*80) == 0x51 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp + 4*16*80, 0xff, 5);
                }
            }
            else
            {
                // Even track. Src goes in pack 3, Ctl in pack 4.

                // We leave this in for compatibility with the old code;

                // Check if pack 0 has Aux source
                if ( *(pbTmp) == 0x50 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp, 0xff, 5);
                }
            
                // Check if pack 1 has Aux control
                if ( *(pbTmp + 1*16*80) == 0x51 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp + 1*16*80, 0xff, 5);
                }

                // Position at pack 3
                pbTmp += 3*16*80;
            }

	    // Set Src pack
            *pbTmp=0x50;
	    *(pbTmp+1)=(BYTE)(  dwAAuxSrc	& 0xff );
	    *(pbTmp+2)=(BYTE)( (dwAAuxSrc >>8)	& 0xff );
	    *(pbTmp+3)=(BYTE)( (dwAAuxSrc >>16)	& 0xff );
	    *(pbTmp+4)=(BYTE)( (dwAAuxSrc >>24)	& 0xff );

	    // Set Ctl pack
	    pbTmp += (16*80);

            *pbTmp=0x51;
	    *(pbTmp+1)=(BYTE)(  dwAAuxCtl	& 0xff );
	    *(pbTmp+2)=(BYTE)( (dwAAuxCtl >>8)	& 0xff );
	    *(pbTmp+3)=(BYTE)( (dwAAuxCtl >>16)	& 0xff );
	    *(pbTmp+4)=(BYTE)( (dwAAuxCtl >>24)	& 0xff );	
        }

        // Now write AuxSrc and AuxCtl to each DIF sequence in the second audio block. 

        dwAAuxSrc = m_OutputDVFormat.dwDVAAuxSrc1;
        dwAAuxCtl = m_OutputDVFormat.dwDVAAuxCtl1;

        // Manbugs 44568. In the case that audio block 1 has audio and audio
        // block 2 has no audio, JVCs want the number of audio samples (the AF_SIZE
        // field) in the audio two blocks to be the same, else they stutter.
        // Don't know what they do if there are two independent tracks and 
        // each has a different number of audio samples. Anyway, work around
        // their bug in the case we can.
        //
        // (Note that we don't allow audio block 2 to have audio if audio block
        // 1 has no audio. So we don't need to worry about setting the AF_SIZE
        // field of audio block 1 to the number of samples in audio block 2.)

        DWORD dwNumSamplesFirstAudioBlock = dwNumSamples;

        dwNumSamples = 0;

        // Make sure that AF_SIZE is not set in m_OutputDVFormat.dwDVAAuxSrc1
        ASSERT((dwAAuxSrc & AM_DV_AUDIO_AFSIZE) == 0);
        dwAAuxSrc &= ~AM_DV_AUDIO_AFSIZE; // zap it if it is

        // Determine if the second audio block is muted. Note that
        // the second audio block's audio is got from 
        // m_apInput[DVMUX_VIDEO_INPUT_PIN+2] if that pin is connected.
        // If it is not connected and m_apInput[DVMUX_VIDEO_INPUT_PIN+1]
        // has stereo, 16 bit 44.1 or 48KHz audio, it is got from the first pin.
        // (Note that 32K, 16 bit stereo audio is recorded in SD 4ch mode.)

        if (m_apInput[DVMUX_VIDEO_INPUT_PIN+2] == NULL)
        {
            // The pin is not connected
            if ((dwAAuxSrc & AM_DV_AUDIO_MODE) != AM_DV_AUDIO_NO_AUDIO)
            {
                // The audio block is determined by the other audio pin
                fAud_Mute[1] = fAud_Mute[0];

	       if (!fAud_Mute[1])
	        {
		        ASSERT( wTotalAudSamples[0] >= m_wMinAudSamples[0]  );
		        ASSERT( wTotalAudSamples[0] <=	m_wMaxAudSamples[0]  );
		        dwNumSamples = wTotalAudSamples[0] - m_wAudSamplesBase[0];  	
	        }
	        

        }
        else
        {
            // The audio block has no audio, so we are muted
            fAud_Mute[1] = TRUE;
            // dwNumSamples is unused
        }


        }
        else
        {
            // Assert we have audio in this block if the pin is connected
            ASSERT((dwAAuxSrc & AM_DV_AUDIO_MODE) != AM_DV_AUDIO_NO_AUDIO);

            // The pin is connected. fAud_Mute[1] has been set correctly
            if (!fAud_Mute[1])
            {
	        ASSERT( wTotalAudSamples[1] >= m_wMinAudSamples[1]  );
	        ASSERT( wTotalAudSamples[1] <=	m_wMaxAudSamples[1]  );
                dwNumSamples = wTotalAudSamples[1] - m_wAudSamplesBase[1];
            }
            else
            {
                // dwNumSamples is unused
            }
        }

        // Update the src and ctl packs
        if (fAud_Mute[1])
        {
            // OR'ing dwNumSamplesFirstAudioBlock is for JVCs and Thomsons,
            // see note above.

            dwAAuxSrc |= AM_DV_AUDIO_NO_AUDIO | dwNumSamplesFirstAudioBlock;
            dwAAuxCtl |= AM_DV_AAUX_CTL_IVALID_RECORD; // REC_MODE = 0x111
        }
        else
        {
            // Set AF_SIZE in the source pack
            dwAAuxSrc |= dwNumSamples;
        }

        ASSERT(i == DifCnt/2);
        for (; i < DifCnt; i++)
        {
	    unsigned char *pbTmp;

	    pbTmp = pDst + 483 + i*12000;  //6*80+3=483, 150*80=12000

	    if (i % 2)
            {
                // Odd track. Src goes in pack 0 and Ctl in pack 1
            
                // We leave this in for compatibility with the old code;

                // Check if pack 3 has Aux source
                if ( *(pbTmp + 3*16*80) == 0x50 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp + 3*16*80, 0xff, 5);
                }
            
                // Check if pack 4 has Aux control
                if ( *(pbTmp + 4*16*80) == 0x51 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp + 4*16*80, 0xff, 5);
                }
            }
            else
            {
                // Even track. Src goes in pack 3, Ctl in pack 4.

                // We leave this in for compatibility with the old code;

                // Check if pack 0 has Aux source
                if ( *(pbTmp) == 0x50 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp, 0xff, 5);
                }
            
                // Check if pack 1 has Aux control
                if ( *(pbTmp + 1*16*80) == 0x51 ) 
                {
                    // Zap it - the pack length is 5
                    memset(pbTmp + 1*16*80, 0xff, 5);
                }

                // Position at pack 3
                pbTmp += 3*16*80;
            }

	    // Set Src pack
            *pbTmp=0x50;
	    *(pbTmp+1)=(BYTE)(  dwAAuxSrc	& 0xff );
	    *(pbTmp+2)=(BYTE)( (dwAAuxSrc >>8)	& 0xff );
	    *(pbTmp+3)=(BYTE)( (dwAAuxSrc >>16)	& 0xff );
	    *(pbTmp+4)=(BYTE)( (dwAAuxSrc >>24)	& 0xff );

	    // Set Ctl pack
	    pbTmp += (16*80);

            *pbTmp=0x51;
	    *(pbTmp+1)=(BYTE)(  dwAAuxCtl	& 0xff );
	    *(pbTmp+2)=(BYTE)( (dwAAuxCtl >>8)	& 0xff );
	    *(pbTmp+3)=(BYTE)( (dwAAuxCtl >>16)	& 0xff );
	    *(pbTmp+4)=(BYTE)( (dwAAuxCtl >>24)	& 0xff );	
        }
    }


    
    // in the future, vidaux or audaux or text can be muxed in

    //in order to hear audio when we dump these DV frame to camcorder, 
    //VAUX's contrl REC MODE can no be 0x111
    
    if( (*(pDst+3*80+3) != 0x60 ) && ( *(pDst+5*80+3+9*5)!=0x60 ) )//VAUX source pack header
    {
	DWORD dwAAuxSrc;
	unsigned char *pbTmp;
	pbTmp=pDst+3*80+3;
	*pbTmp=0x60;

	dwAAuxSrc=m_OutputDVFormat.dwDVVAuxSrc;		    

	*(pbTmp+1)=(BYTE)(  dwAAuxSrc	& 0xff );
	*(pbTmp+2)=(BYTE)( (dwAAuxSrc >>8)	& 0xff );
	*(pbTmp+3)=(BYTE)( (dwAAuxSrc >>16)	& 0xff );
	*(pbTmp+4)=(BYTE)( (dwAAuxSrc >>24)	& 0xff );

	*(pbTmp+5)=0x61;

	dwAAuxSrc=m_OutputDVFormat.dwDVVAuxCtl;		    
	*(pbTmp+6)=(BYTE)(  dwAAuxSrc	& 0xff );
	*(pbTmp+7)=(BYTE)( (dwAAuxSrc >>8)	& 0xff );
	*(pbTmp+8)=(BYTE)( (dwAAuxSrc >>16)	& 0xff );
	*(pbTmp+9)=(BYTE)( (dwAAuxSrc >>24)	& 0xff );
    }
    
    //for audio is longer then video case
    if(	( fNoVideo == TRUE  )					    &&    //no video
	( (m_apInput[DVMUX_VIDEO_INPUT_PIN+1] ==NULL ) ||  fAud_Mute[0] ) &&
	( (m_apInput[DVMUX_VIDEO_INPUT_PIN+2] ==NULL ) ||  fAud_Mute[1] ) )
    {
	if(fNot_VideoEOSReceived==FALSE)
	    pSampleOut->Release();

	return NOERROR;

    }

	
    //deliver muxed sample
    pSampleOut->SetSyncPoint(TRUE);	//to let AVI muxer know that very frame is a key frame


    if( m_MediaTypeChanged )
    {
	CMediaType cmt(m_pOutput->CurrentMediaType());
	DVINFO *pdvi = (DVINFO *) cmt.AllocFormatBuffer(sizeof(DVINFO));
	if (NULL == pdvi) {
	    if(fNot_VideoEOSReceived==FALSE)
		pSampleOut->Release();

	    return(E_OUTOFMEMORY);
	}

	memcpy(pdvi, &m_OutputDVFormat, sizeof(DVINFO));

	pSampleOut->SetMediaType(&cmt);
	m_MediaTypeChanged=FALSE;
    }

    //SET data length
    if( m_iVideoFormat==IDC_DVMUX_NTSC)
	lDataLength = 10*150*80;    //NTSC

    pSampleOut->SetActualDataLength(lDataLength);

    //set mediatime
    TimeStart=m_LastVidMediatime++;
    pSampleOut->SetMediaTime(&TimeStart, &m_LastVidMediatime);
    
    //if this is first sample and AAUX is difference than default
    if (m_DVINFOChanged==TRUE) 
    {
	CMediaType cmt(m_pOutput->CurrentMediaType());
	//set audio mediatype 
	pSampleOut->SetMediaType(&cmt);
	m_DVINFOChanged=FALSE;
    }
	
		
    hr = m_pOutput->Deliver(pSampleOut);

    for (iPin=0; iPin < DVMUX_MAX_AUDIO_PIN; iPin++)
    {
	// Note: m_apInput[1..2] contain the audio pins
        // if they are connected. See CompleteConnect,
        // CheckMediaType and Disconnect in CDVMuxerInputPin

        if (m_apInput[iPin+1] != NULL)
	{
            m_AudSampleSequence[iPin].Advance(m_wMinAudSamples[iPin], m_wMaxAudSamples[iPin]);
        }
    }

// RELEASE:     // label not used any more
    //release video sample from list
    if(fNot_VideoEOSReceived==TRUE )	    //release sample in the queue
	m_apInput[ DVMUX_VIDEO_INPUT_PIN ]->ReleaseNSample(1);
    else
    {	//release sample which we just copied from m_pExVidSample
	m_LastVidTime =VidStop;
	pSampleOut->Release();
    }

    return hr;
}

// ReleaseAllQueuedSamples
// - release all samples which are held on our input pins
HRESULT CDVMuxer::ReleaseAllQueuedSamples(void)
{
    // Calls ReleaseHeadSample (as opposed to m_SampleList.RemoveAll)
    // to ensure that we actually release the sample
    for (int i = 0; i < m_iInputPinCount; i ++)
        while (m_apInputPin[i]->SampleReady( 1 ))
	    m_apInputPin[i]->ReleaseNSample(1);

    return NOERROR;
}

//X
HRESULT CDVMuxer::DeliverEndOfStream()
{
    if( m_fEOSSent )
        return NOERROR;

    CAutoLock lock(&m_csMuxLock);

    ASSERT(m_apInput[DVMUX_VIDEO_INPUT_PIN]->m_fEOSReceived);
    ASSERT( !m_apInput[DVMUX_VIDEO_INPUT_PIN]->SampleReady( 1 ) ); //no input dv video sample in the queue
    m_pOutput->DeliverEndOfStream();
    m_fEOSSent = TRUE;

    return NOERROR;
}

//X
// only input video pin call this func to pass flush to down stream .
// filter enter flush state. Receives already blocked
HRESULT CDVMuxer::BeginFlush(void)
{
    // check we are able to receive commands
    HRESULT hr = CanChangeState();
    if (FAILED(hr)) {
        return hr;
    }

    // call downstream
    return m_pOutput->DeliverBeginFlush();
}

//X
// leave flush state.
HRESULT CDVMuxer::EndFlush(void)
{
    // check we are able to receive commands

    HRESULT hr = CanChangeState();
    if (FAILED(hr)) {
        return hr;
    }

    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::EndFlush()")));
    // sync with pushing thread -- we have no worker thread

    // caller (the input pin's method) will unblock Receives

    // call EndFlush on downstream pins
    return m_pOutput->DeliverEndFlush();

}


//X check we are in a position to change state
HRESULT CDVMuxer::CanChangeState()
{
    // check we have a valid input connection(s)

    // we don't lock. If the caller requires the state not to change
    // after the check then they must provide the lock

    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::CanChangeState(...)")));

    //if at lease one iput pin is connected and the output pin is also connected, 
    // video pin has to be connected and
    // video's input format has to be correct, 
    if ( ( ( m_apInput[DVMUX_VIDEO_INPUT_PIN +1] != NULL ) ||
	   ( m_apInput[DVMUX_VIDEO_INPUT_PIN+2]	!= NULL )  ||
	   ( m_apInput[DVMUX_VIDEO_INPUT_PIN]	!= NULL )     ) &&   //at least one input pin is connected
	 ( m_pOutput->IsConnected()			      ) &&   //output pin is connected
	 ( ( m_apInput[DVMUX_VIDEO_INPUT_PIN] == NULL ) ||
	   ( !m_apInput[DVMUX_VIDEO_INPUT_PIN]->m_mt.IsValid()) )
	)
        return E_FAIL;


    // check we have a valid output connection if output is connected
    if ( m_pOutput->IsConnected()    &&
	 (!m_pOutput->m_mt.IsValid()   )  )
        return E_FAIL;

    return NOERROR;
}


//X
STDMETHODIMP CDVMuxer::Stop()
{
    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Stop(...)")));
    CAutoLock l(&m_csFilter);

    // Is there any change needed
    if (m_State == State_Stopped) {
        return NOERROR;
    }

    // Succeed the Stop if we are not completely connected
    if( !m_pOutput || !m_pOutput->IsConnected() ){
        m_State = State_Stopped;
        return NOERROR;
    }

    // decommit the input pins before locking or we can deadlock
    for( int iPin = 0; iPin < m_iInputPinCount; iPin++ )
    {
	    if(m_apInputPin[iPin]->IsConnected())
	    {    
            m_apInputPin[iPin]->Inactive();
            m_apInputPin[iPin]->m_fEOSReceived =TRUE;
        }
    }

    // synchronize with Receive calls
    m_pOutput->Inactive();
    
    //input pin's 
    for( iPin = 0; iPin < m_iInputPinCount; iPin++ )
    {
	if(m_apInputPin[iPin]->IsConnected())
	{
	    CAutoLock lck2(&m_apInputPin[iPin]->m_csReceive);
	}
    }


    // check we can change state
    HRESULT hr = CanChangeState();
    if (FAILED(hr)) {
        return hr;
    }

    // allow a class derived from CDVMuxer
    // to know about starting and stopping streaming
    hr = StopStreaming();
    if (FAILED(hr)) {
        return hr;
    }

    // reset m_iLeadPin in case it changed
    //m_iLeadPin = m_iStartingLeadPin;

    // do the state transition
    return CBaseFilter::Stop();
}


STDMETHODIMP CDVMuxer::Pause()
{
    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Pause(...)")));
    CAutoLock l(&m_csFilter);

    // Is there any change needed
    if (m_State == State_Paused) {
        return NOERROR;
    }

    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Pause(...)")));

    //if any input pin is connected and output pin is also connected, 
    //video pin is no connected, refuse muxing
    if( ( (m_apInput[DVMUX_VIDEO_INPUT_PIN+1] !=NULL) ||
	  (m_apInput[DVMUX_VIDEO_INPUT_PIN+2] !=NULL) ||
	  (m_apInput[DVMUX_VIDEO_INPUT_PIN]   !=NULL)   )  &&
	( m_pOutput->IsConnected()		        )  &&
	( m_apInput[DVMUX_VIDEO_INPUT_PIN] ==NULL)
      )
	return VFW_E_NOT_CONNECTED;

    // Manbugs 37710. If the audio mode of the first audio block (CH1) is
    // 0xf (first audio block has no audio), the audio mode of the second audio 
    // block (CH2) must also be 0xf (per the Blue Book).
    //
    // For us, m_iPinNo == DVMUX_VIDEO_INPUT_PIN+1 has the first audio block
    // and DVMUX_VIDEO_INPUT_PIN+2 has the second audio block. The only exception
    // to this is when DVMUX_VIDEO_INPUT_PIN+1 is not connected and 
    // DVMUX_VIDEO_INPUT_PIN+2 carries 16 bit, stereo, 48KHz or 44.1KHz audio
    // (Note that we always write 32KHz 16 bit stereo audio in SD 4ch mode.)
    // Rather than mess with checking pin connections, we look directly at m_OutputDVFormat.
    // Note that, since the video input pin and the output pins are both 
    // connected, m_OutputDVFormat must be legit (see the note in 
    // CDVMuxerInputPin::Disconnect)
    //
    // Note that it is easier to fail the Pause here rather than build the logic
    // into CDVMuxerInputPin::CheckMediaType(). Otherwise, if the user connected
    // both audio pins and temporarily disconnected the first, we'd have to forcibly 
    // disconnect the second one. (Here "first" and "second" mean first connected
    // and second connected audio pins - not first created and second created.)
    //
    // @@@ When we clean up dynamic format changes, ensure that this condition is
    // met by checking for it in CheckMediaType. Clearly, dynamic format changes
    // are going to be an issue for the mux because the format changes on the 
    // input audio pins must be processed "together". 
    
    if ((m_OutputDVFormat.dwDVAAuxSrc  & AM_DV_AUDIO_MODE) == AM_DV_AUDIO_NO_AUDIO &&
        (m_OutputDVFormat.dwDVAAuxSrc1 & AM_DV_AUDIO_MODE) != AM_DV_AUDIO_NO_AUDIO)
    {
        // Assert that the "first connected" audio pin is now 
        // disconnected and the second connected one is connected.
        ASSERT(m_apInput[DVMUX_VIDEO_INPUT_PIN+1] == NULL);
	ASSERT(m_apInput[DVMUX_VIDEO_INPUT_PIN+2] != NULL);
        return VFW_E_NOT_CONNECTED;
    }



    // check we can change state

    // @@@ jaisri: Never understood the logic behind this.
    HRESULT hr = CanChangeState();
    if (FAILED(hr)) {
        if (m_pOutput) {
            m_pOutput->DeliverEndOfStream();
        }
        return hr;
    }

    // allow CDVMuxer
    // to know about starting and stopping streaming

    if (m_State == State_Stopped) {
        hr = StartStreaming();
        if (FAILED(hr)) {
            return hr;
        }
    }
    return CBaseFilter::Pause();
}


STDMETHODIMP CDVMuxer::Run(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDVMuxer::Run(...)")));
    CAutoLock l(&m_csFilter);

    // Is there any change needed
    if (m_State == State_Running) {
        return NOERROR;
    }

    HRESULT hr = CanChangeState();
    if (FAILED(hr)) {
        return hr;
    }

    // This will call CDVMuxer::Pause if necessary, so we don't
    // need to call StartStreaming here.
    m_cNTSCSample = 1;

    return CBaseFilter::Run(tStart);
}

/******* Media Type Handling ******/
//
// CheckInputType
//
// check the input type is OK. We only accept video input, with the same format on
// each pin.
//
// Unlike CTransform derived classes, CheckMediaType is called for the output pin
// as well the input pin. (this removes the need for CheckTransform, which is a bit
// tricky when we have more than one input pin! )
//
/*X*

//X* 
//X* 77 bytes Audio in A-DIF block:
//X* Audio Aux(5 byte) + audio data(72 bytes) on tape
//X* 9 audio block/DIF
//X* 10 or 12 DIF /frame
//X* 2 bytes for evry audio sample at 48k, 44.1k or 32k_1ch
//X*	48k requires  48000*2/30= 3200 bytes/frame 
//X*	48k requires  48000*2/25= 3840 bytes/frame
//X* MAX(10): 72*9*5=3240 bytes/frame	==	1620 samples/frame
//X* MAX(12): 72*9*6=3888 bytes/frame	==	1944 samples/frame
//X* see table 18 and 19 in part2 sepc for audio sampels/frame
//X*
//X* Agri:
//X*			iDIFBlkNum=(n/3)+2
//*X*
/*X*
typedef struct Tag_DVAudInfo
{
	BYTE	bAudStyle[2];		
	//LSB 6 bits for starting DIF sequence number
	//MSB 2 bits: 0 for mon. 1: stereo in one 5/6 DIF sequences, 2: stereo audio in both 5/6 DIF sequences
	//example: 0x00: mon, audio in first 5/6 DIF sequence
	//		   0x05: mon, audio in 2nd 5 DIF sequence
	//		   0x15: stereo, audio only in 2nd 5 DIF sequence
	//		   0x10: stereo, audio only in 1st 5/6 DIF sequence
	//		   0x20: stereo, left ch in 1st 5/6 DIF sequence, right ch in 2nd 5/6 DIF sequence
	//		   0x26: stereo, rightch in 1st 6 DIF sequence, left ch in 2nd 6 DIF sequence
	BYTE	bAudQu[2];			//qbits, only support 12, 16, 		
		
	BYTE	bNumAudPin;			//how many pin(language)
	WORD	wAvgBytesPerSec[2];	//
	WORD	wBlkMode;			//45 for NTSC, 54 for PAL
	WORD	wDIFMode;			//5  for NTSC, 6 for PAL
	WORD	wBlkDiv;			//15  for NTSC, 18 for PAL
} DVAudInfo;
*X*/
//
//  pSrc: pointer to begining of one frame's 16 bits mono/stereo PCM audio	
//  pDst: point to one frame DV buffer which contains 10/12 DIF sequences
//  bAudPinInd:  it can support up to two language
//  wSampleSixe: how many samples from this frame
//
HRESULT CDVMuxer::ScrambleAudio(BYTE *pDst, BYTE **ppSrc, int bAudPinInd, WORD *wSampleSize)
{
    // @@@ jaisri: This function should convert 16 bit audio samples with
    // the value 0x8000 and 12 bit audio samples with the value 0x800 to
    // 0x8001 and 0x801 respectively. See p18, Sec 6.4.3 of the Blue Book.

    BYTE *pTDst;	//temp point
    WORD *pwSize;
    INT iDIFPos;																	
    INT iBlkPos;
    INT iBytePos;
    short sI;
    INT n;
    INT iShift;
    INT iPos;
    INT ind;
    WORD wStart[DVMUX_MAX_AUDIO_SAMPLES];
    WORD wEnd[DVMUX_MAX_AUDIO_SAMPLES];
    WORD wBlkMode,wDIFMode,	wBlkDiv;

    //pointer to Desg
    pTDst		= pDst;

    //point to size
    pwSize		= wSampleSize;

    //pointers to input audio source
    wStart[0]		= 0;
    wEnd[0]		= pwSize[0];
    for(ind=1; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
    {
    	wStart[ind]	= wEnd[ind-1];
    	wEnd[ind]	= wStart[ind] + pwSize[ind];
    }


    // So much for maintaining m_OutputDVFormat!
    DVINFO *pDVInfo =(DVINFO *)m_pOutput->CurrentMediaType().pbFormat;
    ASSERT(memcmp(&m_OutputDVFormat, pDVInfo, sizeof(DVINFO)) == 0);

    //PAL or NTSC
    if(	pDVInfo->dwDVVAuxSrc & AM_DV_AUDIO_5060 )
    {  	//PAL
	wBlkMode=54;
        wDIFMode=6;
        wBlkDiv=18;
    }
    else
    {    //525_60, NTSC
        wBlkMode=45;
        wDIFMode=5;
        wBlkDiv=15;
    }
		
    //current pin's audio format				
    WAVEFORMATEX *pWave =(WAVEFORMATEX *)m_apInput[bAudPinInd+1]->CurrentMediaType().pbFormat ;
    
    if( pWave->wBitsPerSample == 16 )
    {
	//X******* 16 bits /sample input audio
	//X*******  support 
	//	    Case 1. 16bits, 48K, 32K , 44.1K mono
	//	    Case 2. 16bits-32K-stereo
	//	    Case 3. 16bits, 48K or 44.k stereo
	if( pWave->nChannels==1)
	{
	    //CASE 1
	    //16 bits Mono. audio only in one of 5/6 DIF sequencec
	    if(bAudPinInd)
		iPos=( pDVInfo->dwDVVAuxSrc & AM_DV_AUDIO_5060 ) ? (6*150*80) : (5*150*80);
	    else
		iPos=0;

	    // Manbugs 37710. We have to step down the 16 bit to 12 bit if
            // we are outputting SD 4ch audio
            BOOL bStepDown = 0;
            if (pWave->nSamplesPerSec == 32000)
            {
                DWORD dwAuxSrc = bAudPinInd? pDVInfo->dwDVAAuxSrc1 : pDVInfo->dwDVAAuxSrc; 
                bStepDown = ((dwAuxSrc & AM_DV_AUDIO_QU) == AM_DV_AUDIO_QU12)? 1 : 0;
            }

            if (bStepDown)
            {
                // This is the same as the 32K stero code below except that
                // we set the unused channel (Chb or Chd) to silence, Blue Book
                // specifies that we should either set it to silence or copy the value
                // we put in Cha/Chc.

	        int Mask	=0x20;
	        int Cnt	=6;
	        int Shift=1;

	        for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
	        {
	          BYTE *pTSrc=&*ppSrc[ind];
	          for( n=wStart[ind]; n< wEnd[ind]; n++)
	          {
		    
		    //
		    //calc buffer location to put audio
		    //
		    iDIFPos=( (n/3)+2*(n%3) )%wDIFMode;	//0-4 for NTSC, 0-5 for PAl
		    iBlkPos= 3*(n%3)+(n%wBlkMode)/wBlkDiv;	//0-9 
		    iBytePos=8+3*(n/wBlkMode);
		    pTDst=pDst+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		    
		    //	pTDst			=  pDst+ iDIFPos*150*80 + 6*80 + 16*iBlkPos*80 + iBytePos;
		    //	iDIFPos*150*80	-> skip iDIFPos number DIF sequence
		    //	6*80			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
		    //	16*iBlkPos*80	-> skip 16 blk for evrey iBLkPos audio
	            //	iPos: 0 if this audio in 1st 5/6 DIF sequences, 5(or 6)*150*80 for 2nd DIF seq
		    //
	            //#######we do convertion from 16bits to 12 bits######
	    	    //
		    

	            // Left Sample
		    sI=  pTSrc[0] | (  pTSrc[1]  << 8  );
	            pTSrc +=2;

            if ((sI & 0x8000) && !(sI & 0x7FC0))
            {
                sI = 0x0801;
            }
            else
            {
                iShift	=sI <0 ?  (-(sI+1)) >> 9  :  sI >> 9  ;	
    		    if( iShift )
    		    {
    		    
    		        Mask    =0x20;
    		        Cnt	    =6;
    		        while( ! (Mask & iShift) )
    		        {
    			    Cnt--;
    			    Mask>>=1;
    		        }
    		        iShift=Cnt;
    		    }
    
    		    sI =sI<0 ? ( ( (sI +1) >> iShift   ) -(256*iShift+1) )   :	//negitive
    			       ( (    sI   >> iShift ) + 256*iShift );		//positive
            }
		    pTDst[0]= (unsigned char)( ( sI & 0xff0) >>4  );	//most significant 8 bits
		    pTDst[2]= (unsigned char)( ( sI & 0xf) <<4 );		//lese significant 4 bits

		    // Right Sample - silence
                    pTDst[1] = 0;
                    // The lower nibble of pTDst[2] is already 0.

	          } //for( n=wStart[ind]; n< wEnd[ind]; n++)
	        } //for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
            }
            else
            {
                for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
	        {	
		    BYTE *pTSrc=&(*ppSrc[ind]);
		    for( n=wStart[ind]; n< wEnd[ind]; n++)
		    {
	    	        iDIFPos=( (n/3)+2*(n%3) )%wDIFMode;	//0-4 for NTSC, 0-5 for PAL
		        iBlkPos= 3*(n%3)+(n%wBlkMode)/wBlkDiv; //0-9 
		        iBytePos=8+2*(n/wBlkMode);					//

		        pTDst=pDst+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		        //	iDIFPos*150*80=12000iDIFPos	-> skip iDIFPos number DIF sequence
		        //	6*80=480			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
		        //	16*iBlkPos*80=1280*iBlkPos	-> skip 16 blk for evrey iBLkPos audio
		        //	iPos:				=0 if this audio in 1st 5/6 DIF sequences, =5(or 6)*150*80 for 2nd DIF seq

		        pTDst[1]=*pTSrc++;	//lease significant byte
		        *pTDst=*pTSrc++;	//most significant byte
		    }
	        }
            }
	}
	else if( ( pWave->nSamplesPerSec == 32000) &&
		 ( pWave->nChannels == 2)
		)
	{
	    //CASE 2
	    //32K stereo audio
	    if(bAudPinInd)
	    {	
		ASSERT( pDVInfo->dwDVAAuxSrc1 & AM_DV_AUDIO_CHN2);
		ASSERT( pDVInfo->dwDVAAuxSrc1 & AM_DV_AUDIO_QU12);
		iPos=( pDVInfo->dwDVVAuxSrc & AM_DV_AUDIO_5060 ) ? (6*150*80) : (5*150*80);
	    }
	    else
	    {
		ASSERT( pDVInfo->dwDVAAuxSrc & AM_DV_AUDIO_CHN2);
		ASSERT( pDVInfo->dwDVAAuxSrc & AM_DV_AUDIO_QU12);
		iPos=0;
	    }

	    int Mask	=0x20;
	    int Cnt	=6;
	    int Shift=1;

	    for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
	    {
	      BYTE *pTSrc=&*ppSrc[ind];
	      for( n=wStart[ind]; n< wEnd[ind]; n++)
	      {
		
		//
		//calc buffer location to put audio
		//
		iDIFPos=( (n/3)+2*(n%3) )%wDIFMode;	//0-4 for NTSC, 0-5 for PAl
		iBlkPos= 3*(n%3)+(n%wBlkMode)/wBlkDiv;	//0-9 
		iBytePos=8+3*(n/wBlkMode);
		pTDst=pDst+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		
		//	pTDst			=  pDst+ iDIFPos*150*80 + 6*80 + 16*iBlkPos*80 + iBytePos;
		//	iDIFPos*150*80	-> skip iDIFPos number DIF sequence
		//	6*80			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
		//	16*iBlkPos*80	-> skip 16 blk for evrey iBLkPos audio
	        //	iPos: 0 if this audio in 1st 5/6 DIF sequences, 5(or 6)*150*80 for 2nd DIF seq
		//
	        //#######we do convertion from 16bits to 12 bits######
	    	//
		

	        // Left Sample
		sI=  pTSrc[0] | (  pTSrc[1]  << 8  );
	        pTSrc +=2;

       
        if ((sI & 0x8000) && !(sI & 0x7FC0))
        {
            // This special case is a fix for the case of values which are near the lower
            // limit of possible 16 bit values in which case the code below would produce the 
            // 12 bit value 0x7FF instead of the correct 0x801
            // The case we handle here is inputs in the range starting 0x8000 to 0x803F
            sI = 0x0801;
        }
        else
        {

            // This code converts 16 bit to NON LINEAR 12 bit which is why it could not be simplified
            // to just shift right four bits.  so the farther away you are from the zero line, the more
            // your 16 bit values are compressed... So if your input is a 16 bit sine wav
            // the output would look more square like.
            iShift	=sI <0 ?  (-(sI+1)) >> 9  :  sI >> 9  ;	
    		if( iShift )
    		{
    		
    		    Mask    =0x20;
    		    Cnt	    =6;
    		    while( ! (Mask & iShift) )
    		    {
    			Cnt--;
    			Mask>>=1;
    		    }
    		    iShift=Cnt;
    		}
    
    		sI =sI<0 ? ( ( (sI +1) >> iShift   ) -(256*iShift+1) )   :	//negitive
    			   ( (    sI   >> iShift ) + 256*iShift );		//positive
        }
		pTDst[0]= (unsigned char)( ( sI & 0xff0) >>4  );	//most significant 8 bits
		pTDst[2]= (unsigned char)( ( sI & 0xf) <<4 );		//lese significant 4 bits

		// Right Sample
		sI=  pTSrc[0] | (  pTSrc[1]  << 8  );
		pTSrc +=2;


        if ((sI & 0x8000) && !(sI & 0x7FC0))
        {
            sI = 0x0801;
        }
        else
        {
            iShift	=sI<0 ?  (-(sI+1)) >> 9  : ( sI >> 9 ) ;	
    		if( iShift )
    		{
    		
    		    Mask    =0x20;
    		    Cnt	    =6;
    		    while( ! (Mask & iShift) )
    		    {
    			Cnt--;
    			Mask>>=1;
    		    }
    		    iShift=Cnt;
    		}
    
    		sI =sI<0 ? ( ( (sI +1) >> iShift   ) -(256*iShift+1) )   :	//negitive
    			   ( (    sI   >> iShift ) + 256*iShift );		//positive
        }

		pTDst[1]= (unsigned char)( ( sI & 0xff0) >>4  );	//most significant 8 bits
		pTDst[2] |= (unsigned char)( ( sI & 0xf) );			//lese significant 4 bits
	      } //for( n=wStart[ind]; n< wEnd[ind]; n++)
	    } //for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
	}
	else 
	{
	    //CASE 3
	    //one 48K or 44.1K stereo audio
	    //16 bits stereo audio in all 10 or 12 DIF sequences
	    //left Channel always in 1st 5/6 DIF
	    iPos = 0;
	    INT iRPos =	(pDVInfo->dwDVVAuxSrc & AM_DV_AUDIO_5060 ) ? 6*150*80 : 5*150*80;
	  
	    for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
	    {
	        BYTE *pTSrc=&*ppSrc[ind];
	        for( n=wStart[ind]; n< wEnd[ind]; n++)
	        {
	    	    iDIFPos=( (n/3)+2*(n%3) )%wDIFMode;	//0-4 for NTSC, 0-5 for PAL
		    iBlkPos= 3*(n%3)+(n%wBlkMode)/wBlkDiv; //0-9 
		    iBytePos=8+2*(n/wBlkMode);					//

		    //Left first
		    pTDst=pDst+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		    //iDIFPos*150*80=12000iDIFPos		-> skip iDIFPos number DIF sequence
		    //	6*80=480					-> skip 1 header blk, 2 subcode blk and 3 vaux blk
		    //	16*iBlkPos*80=1280*iBlkPos	-> skip 16 blk for evrey iBLkPos audio
		    //  iPos: =0 if this audio in 1st 5/6 DIF sequences, =5(or 6)*150*80 for 2nd DIF seq
		    pTDst[1]=*pTSrc++;	//lease significant byte
		    *pTDst=*pTSrc++;	//most significant byte

		    //Right second
		    pTDst=pDst+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iRPos;
		    pTDst[1]=*pTSrc++;	//lease significant byte
		    *pTDst=*pTSrc++;	//most significant byte
			
		}
	    }
	}												
	return NOERROR;
    }
#if 0
    // Manbugs 37710. This is no longer supported; see the comment in CDVMuxerInputPin::CheckMediaType
    else if( pWave->wBitsPerSample ==12 )
    {		
	//X* 12 bits per sample
	
        // @@@ jaisri: should be:
	// if(bAudPinInd)
	//    iPos=( pDVInfo->dwDVVAuxSrc & AM_DV_AUDIO_5060 ) ? (6*150*80) : (5*150*80);
	// else
	//    iPos=0;

        iPos =	(pDVInfo->dwDVVAuxSrc & AM_DV_AUDIO_5060 ) ? 6*150*80 : 5*150*80;
	    

	if( pWave->nChannels ==2 )
	{
	  //stereo audio
	  for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
	  {
	    BYTE *pTSrc=&*ppSrc[ind];
	    for( n=wStart[ind]; n< wEnd[ind]; n++)
	    {
		//
		//calc buffer location to put audio
		//
		iDIFPos=( (n/3)+2*(n%3) )%wDIFMode;	//0-4 for NTSC, 0-5 for PAl
		iBlkPos= 3*(n%3)+(n%wBlkMode)/wBlkDiv;	//0-9 
		iBytePos=8+3*(n/wBlkMode);
		pTDst=pDst+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		//	pTDst			=  pDst+ iDIFPos*150*80 + 6*80 + 16*iBlkPos*80 + iBytePos;
		//	iDIFPos*150*80	-> skip iDIFPos number DIF sequence
		//	6*80			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
	        //	16*iBlkPos*80	-> skip 16 blk for evrey iBLkPos audio
	        //	iPos: 0 if this audio in 1st 5/6 DIF sequences, 5(or 6)*150*80 for 2nd DIF seq
		//
	        
		// @@@ jaisri: This assumes that the byte packing in the sample matches
                // the DV format's packing

                // Left Sample and right Sample
	        pTDst[0]= pTSrc[0];			//most significant 8 bits
		pTDst[1]= pTSrc[1];			//most significant 8 bits
		pTDst[2]= pTSrc[2];		//lese significant 4 bits
	    }   //  for( n=wStart[ind]; n< wEnd[ind]; n++)
	  } // for(ind=0; ind<DVMUX_MAX_AUDIO_SAMPLES; ind++)
	} //if( pWave->nChannels ==2 )  
	else
	{
            // We should support this if we support stereo 12 bit.
            return VFW_E_INVALIDMEDIATYPE;
	    //mon. 12 bits
	}

	return NOERROR;
    } //end if( m_DVAudInfo.bAudQu[bAudPinInd] ==12 )
#endif
    else{
        //only support 16 bits/samples
        return VFW_E_INVALIDMEDIATYPE;
    }
    return NOERROR;
}


// =================================================================
// Implements the CDVMuxerInputPin class
// =================================================================


// constructor

CDVMuxerInputPin::CDVMuxerInputPin(
                            TCHAR *pObjectName,
                            CBaseFilter *pBaseFilter,
                            CDVMuxer *pDVMux,
                            HRESULT * phr,
                            LPCWSTR pName,
                            int iPinNo)
    : CBaseInputPin(pObjectName, pBaseFilter, &pDVMux->m_csFilter, phr, pName)
    , m_SampleList(NAME("CDVMuxInpuPin::m_SampleList"))
    , m_iPinNo(iPinNo)
    , m_pDVMuxer(pDVMux)
    , m_fCpyAud(FALSE)
    , m_PinVidFrmCnt(0)
    , m_pLocalAllocator(NULL)
{
    DbgLog((LOG_TRACE,4,TEXT("CDVMuxerInputPin::CDVMuxerInputPin")));
}


// destructor

CDVMuxerInputPin::~CDVMuxerInputPin()
{
    DbgLog((LOG_TRACE,4,TEXT("CDVMuxerInputPin::~CDVMuxerInputPin")));

    if (m_pLocalAllocator)
    {
        m_pLocalAllocator->Release();
        m_pLocalAllocator = NULL;
    }
}


IMediaSample *CDVMuxerInputPin::GetNthSample( int i )
{
    int k=m_SampleList.GetCount();

    if ( m_SampleList.GetCount() < ( i +1 ) )
		return NULL;
    else
    {
	POSITION pos = m_SampleList.GetHeadPosition();
	while (i ) {
	    pos=m_SampleList.Next(pos);
	    i--;
	}

	IMediaSample *tmp;
	tmp=m_SampleList.Get( pos ) ;
	int j=m_SampleList.GetCount();
	return tmp;
    }
}

void CDVMuxerInputPin::ReleaseNSample( int n  )
{

    ASSERT( m_SampleList.GetCount() >=   n  );

    DbgLog((LOG_TRACE, 4, TEXT("CDVMuxerInputPin::ReleaseNSample() on pin %d"), m_iPinNo));

    for( int  i =0; i<  n; i++)
    {
	m_SampleList.Get(m_SampleList.GetHeadPosition())->Release();
	m_SampleList.RemoveHead();
    }

}


BOOL CDVMuxerInputPin::SampleReady( int i)
{
    if(this)
	return m_SampleList.GetCount() >= i;
    else
	return FALSE;
}

HRESULT CDVMuxerInputPin::SetMediaType(const CMediaType *pmt)
{

    // Set the base class media type (should always succeed)
    HRESULT hr = CBasePin::SetMediaType(pmt);
    if( SUCCEEDED(hr) )
    {
	 
	if(m_iPinNo==DVMUX_VIDEO_INPUT_PIN )	    //DV video pin
	{	
	    VIDEOINFO *pVideoInfo;
	    pVideoInfo=(VIDEOINFO *)pmt->pbFormat;
	    LPBITMAPINFOHEADER lpbi = HEADER(pVideoInfo);
    	    if( lpbi->biHeight  != 480 )
    		m_pDVMuxer->m_iVideoFormat=IDC_DVMUX_PAL;
	    else
		m_pDVMuxer->m_iVideoFormat=IDC_DVMUX_NTSC;
	}
	
	//if out putpin is already connected, reconnected based on new audio or video
	if(   m_pDVMuxer->m_pOutput->IsConnected()	)
	    m_pDVMuxer->m_pGraph->Reconnect( m_pDVMuxer->m_pOutput );
	
    }
    return hr;
}

/*  Disconnect */
STDMETHODIMP CDVMuxerInputPin::Disconnect()
{
  HRESULT hr = CBaseInputPin::Disconnect();

  // @@@ jaisri: This is correct as it stands, but
  // it's probably safer to do this in BreakConnect

  //make sure m_apInput[m_iPinNo]==NULL if it is not connected
  m_pDVMuxer->m_apInput[m_iPinNo] =NULL;

  // Manbugs 37710. m_OutputDVFormat and the output pin's format
  // must be updated here. (m_OutputDVFormat and the output 
  // pin's format must always be the same, ScrambleAudio assumes that.)
  //
  // Otherwise, consider the following sequence of actions:
  // (a) An input pin is connected to the video source and >= 1 input
  // pins are connected to audio sources (b) The output pin is 
  // connected (c) One of the audio input pins is disconnected
  // (d) The graph is played. (In step (c), disconnect the audio pin
  // that was last connected, i.e., the one whose m_iPinNo = DVMUX_VIDEO_INPUT_PIN+1.
  // Otherwise, Pause might fail anyway.)
  //
  // m_OutputDVFormat is never updated and the format of the output pin is
  // bogus.
  //
  // Since Pause fails if the video input pin is not connected or the output
  // pin is not connected, it suffices to do this only if both these pins
  // are connected.
  //
  if (SUCCEEDED(hr) &&
      m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN] != NULL &&
      m_pDVMuxer->m_pOutput->IsConnected())
  {
      CMediaType pmt;

      EXECUTE_ASSERT(SUCCEEDED(m_pDVMuxer->m_pOutput->GetMediaType(0, &pmt)));
      EXECUTE_ASSERT(SUCCEEDED(m_pDVMuxer->m_pOutput->SetMediaType(&pmt)));
  }

  return hr;
}


// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.
// ------------------------------------------------------------------------
HRESULT
CDVMuxerInputPin::CompleteConnect(IPin *pReceivePin)
{
  HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
  if(FAILED(hr))
  {
      m_pDVMuxer->m_apInput[m_iPinNo] =NULL;
      return hr;
  }

  //set up		
  m_pDVMuxer->m_apInput[m_iPinNo] = this;
  
  //X* now Create next input pin
  if( m_pDVMuxer->m_iInputPinCount <= DVMUX_MAX_AUDIO_PIN  )
  {
     
	WCHAR szbuf[20];             // Temporary scratch buffer
	wsprintfW(szbuf, L"Stream %d", m_pDVMuxer->m_iInputPinCount);


	m_pDVMuxer->m_apInputPin[m_pDVMuxer->m_iInputPinCount]=new CDVMuxerInputPin(NAME("DVMuxer Input pin"),
				    m_pDVMuxer,		// Owner filter
				    m_pDVMuxer,		// Route through here
                                    &hr,		// Result code
                                    szbuf,	// Pin Name
                                    m_pDVMuxer->m_iInputPinCount); // Pin Number

	if (m_pDVMuxer->m_apInputPin[m_pDVMuxer->m_iInputPinCount] != NULL) 
	    m_pDVMuxer->m_iInputPinCount++;
  }

  return hr;
}

// check whether we can support a given input media type
HRESULT CDVMuxerInputPin::CheckMediaType(const CMediaType* pmt)
{
    ASSERT( m_iPinNo < m_pDVMuxer->m_iInputPinCount );
    
    if(  *pmt->Type() == MEDIATYPE_Video   ) 
    {
        if(  (	IsEqualGUID( *pmt->Subtype(), MEDIASUBTYPE_dvsd) 
    	 // |	IsEqualGUID( *pmt->Subtype(), MEDIASUBTYPE_dvhd )  //do not support dvhd yet
	 // |	IsEqualGUID( *pmt->Subtype(), MEDIASUBTYPE_dvsl )  //do not support dvhd yet
	 )
	 &&  ( *pmt->FormatType() == FORMAT_VideoInfo )	)
	{
	    if( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN] ==NULL )
	    {
		m_iPinNo    = DVMUX_VIDEO_INPUT_PIN;
		return NOERROR;
	    }
	    else if( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN] != this ) 
	    {
		//only support one video pin
		ASSERT( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN]->IsConnected() );
		return E_INVALIDARG;		//we already has a video pin
	    }
	    else
	    {
		if( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN]->IsConnected() )
		{
		    // m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN] == this
		    // media type changed from NTSC to PAL
		    // does not support video type change on fly yet!
		    //if video does changed from NTSC to PAL or PAL to NTSC
		    if( HEADER( (VIDEOINFO *)( pmt->Format()  ) )->biHeight != 
			HEADER( (VIDEOINFO *)( m_mt.pbFormat) )->biHeight )
		    {
			return E_INVALIDARG;
		    }
		}

		return NOERROR;
	    }
	}
    }
    //PCM audio input pin(s)
    else if( IsEqualGUID( *pmt->Type(), MEDIATYPE_Audio ) )
	 {

	    if(   ( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN +1 ] == this )  
	       || ( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN +2 ] == this ) ) 
	    {
		// @@@ jaisri. Why are the checks below bypassed?
                // If we are streaming how can we be sure that the 
                // new mediatype is consistent with the spec, 
                // particularly for 4 channel audio output?
                
                if( IsConnected() )
		    //allow audio mediatype change on fly
		    return NOERROR;
	    }


	    if( (( *pmt->Subtype() == MEDIASUBTYPE_PCM ) ||  ( *pmt->Subtype()==GUID_NULL ) )
	        && (*pmt->FormatType() == FORMAT_WaveFormatEx)  )
	    {
		//get format
	   	WAVEFORMATEX *pwfx=(WAVEFORMATEX *)pmt->pbFormat;
		int OtherAudPin;

                
                if( m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN +1 ] != NULL )
		{
		    // Note that the audio pin connected LAST has the 
                    // index DVMUX_VIDEO_INPUT_PIN +2; the one connected
                    // before that has the index DVMUX_VIDEO_INPUT_PIN +1.
                    //
                    // DVMUX_VIDEO_INPUT_PIN +1 has the first audio block
                    // and DVMUX_VIDEO_INPUT_PIN +2 the second. 
                    //
                    // Again, note that which pin has the first audio block and
                    // which the second is determined by pin connection order,
                    // NOT pin creation order.
                    //
                    // We could just change all this to create 3 pins up front,
                    // force the first to be the video, second to be the audio pin
                    // that creates the first audio block and the third to be the
                    // audio pin that creates the second audio block. However, this
                    // could break some ISV apps, so swing the proposal by them first! @@@
                    //
		    m_iPinNo	=  DVMUX_VIDEO_INPUT_PIN +2;
		    OtherAudPin	=  DVMUX_VIDEO_INPUT_PIN +1;
		}
		else
		{
		    m_iPinNo	=  DVMUX_VIDEO_INPUT_PIN +1;
		    OtherAudPin	=  DVMUX_VIDEO_INPUT_PIN +2;
		}
	
		//check whether another audio pin is connected
		if( m_pDVMuxer->m_apInput[ OtherAudPin ]!=NULL )
		{    
		    ASSERT( m_pDVMuxer->m_apInput[OtherAudPin]->IsConnected() );
	
		    //##########yes this audio pin is connected########
		    
		    //fetch another audio pin's media format
		    WAVEFORMATEX *pwfxTmp = (WAVEFORMATEX *)(m_pDVMuxer->m_apInput[ OtherAudPin ]->CurrentMediaType().pbFormat);
		    
                    // @@@ jaisri:
                    // Note: The Blue Book does not permit sampling rates
                    // to be mixed. Also, it does not allow CH1 to be 
                    // recorded in 12 bit and CH2 in 16 bit (which is 
                    // what we do in the 32K stereo + mono case).
                    // Finally we should allow the second channel to have 
                    // 32K 12 bit mono.

		    if (pwfx->nSamplesPerSec != 32000 &&
			pwfx->nSamplesPerSec != 44100 &&
			pwfx->nSamplesPerSec != 48000 
                       )
                    {
                        return E_FAIL;
                    }
                    
                    // wBitsPerSample must be 8 or 16, see note in mono case below.
                    // Blue Book requires sampling rate on the 2 tracks to be 
                    // identical
                    if (pwfx->wBitsPerSample    != 16    ||
                        pwfxTmp->wBitsPerSample != 16    ||
                        pwfxTmp->nSamplesPerSec != pwfx->nSamplesPerSec
                       )
                    {
                        return E_FAIL;
                    }

                    if (pwfx->nChannels == 1 && pwfxTmp->nChannels == 1)
                    {
                        // mono on each track, we are ok
                    }
                    else if (pwfx->nChannels > 2 || pwfxTmp->nChannels > 2)
                    {
                        // @@@ jaisri
                        // Blue Book requires us to support 3/1 stereo for 32KHz but does
                        // Windows support this?

                        return E_FAIL;
                    }
                    else if (pwfx->nSamplesPerSec != 32000)
                    {
                        // Only 32K can have stereo muxed with another audio input
                        return E_FAIL;
                    }
		}
		else
		{
		    //##########not, another audio pin is not connected####
		    if(  pwfx->wBitsPerSample	==16	    &&
			(pwfx->nSamplesPerSec	== 48000 || 
			 pwfx->nSamplesPerSec	== 44100 ||  
			 pwfx->nSamplesPerSec	== 32000 )  
		      )
			;//if 16bits goes with 32K, 44.1K and 48K
#if 0
		    // Manbugs 37710 - jaisri:
                    // The WAVEFORMATEX description in the MSDN clearly states that 
                    // wBitsPerSample must be 8 or 16. ScrambleAudio has assumed 
                    // that the bits in the sample are packed the same way as 
                    // specified in the DV format. If we did get 12 bit audio, 
                    // there might in fact be 1 sample in 2 bytes (i.e., unpacked
                    // and effectively equivalent to 16 bit audio).
                    //
                    // I'm pulling out this code. If this is an issue with any
                    // existing software package, we should work with the vendor to 
                    // establish a clear standard for 12 bit audio. Also, note
                    // that 12 bit mono audio should be accepted since the DV
                    // format accommodates it.
                    else if( pwfx->nSamplesPerSec  == 32000 && 
		          pwfx->wBitsPerSample ==12	    &&
			     pwfx->nChannels ==2 )
			;//if 12bits, stereo 32K is requried
                        // @@@ jaisri - that's not what the Blue Book says
                        // We should allow 12 bit 32K mono
#endif
                    else 
			return E_FAIL;
		}
		    
	  	return NOERROR;
	    }
	}

    return E_FAIL;
}

HRESULT CDVMuxerInputPin::Active()
{
    m_fEOSReceived = FALSE;
    m_PinVidFrmCnt=0;
    if( m_fCpyAud )
    {
	if (m_pAllocator)
        {
            // Not clear that we should do this, but it doesn't hurt
            EXECUTE_ASSERT(SUCCEEDED(m_pAllocator->Commit()));
        }
        ASSERT(m_pLocalAllocator);
        return m_pLocalAllocator->Commit();
    }
    else
	return NOERROR;

 }

HRESULT CDVMuxerInputPin::Inactive()
{
    if( m_fCpyAud )
    {
        ASSERT(m_pLocalAllocator);
        return m_pLocalAllocator->Decommit();
    }
    else
	return NOERROR;

 }

// =================================================================
// Implements IMemInputPin interface
// =================================================================

// put EOS to video or audio queue
STDMETHODIMP CDVMuxerInputPin::EndOfStream(void)
{
    CAutoLock lck(&m_csReceive);

    HRESULT hr = CheckStreaming();

    // @@@ This function has numerous race conditions when the 
    // graph is stopped, many leading to infinite loops. Consider
    // restructuring it.

    if (S_OK == hr) {

        // @@@ jaisri: Note: This member is set after obtaining 
        // m_csReceive for this input pin. However, m_fEOSReceived 
        // of other input pins are accessed without acquiring 
        // m_csReceive of those pins later in this function and 
        // in CDVMuxer::Receive

	//refuse any more sample on this pin
	m_fEOSReceived = TRUE;
	m_PinVidFrmCnt=0;
    }
    
    if( m_iPinNo !=DVMUX_VIDEO_INPUT_PIN )
    {
	//no more audio from this audio pin
	int iPin=m_iPinNo+1;	    // this pin is first audio pin, iPin is 2nd audio pin
	if(m_iPinNo==(DVMUX_VIDEO_INPUT_PIN+2) )
	   //this pin is second audio pin, iPin is 1st audio pin
	    iPin= m_iPinNo-1;

	//what is index for m_apInputPin[]
	if( ( m_pDVMuxer->m_apInput[ DVMUX_VIDEO_INPUT_PIN  ]->m_fEOSReceived ) &&
	    ( (m_pDVMuxer->m_apInput[ iPin  ] ==NULL)	   ||  
	      (m_pDVMuxer->m_apInput[ iPin  ]->m_fEOSReceived == TRUE) )
	  )
	{    
	    //no more sample from any input pin
	    for (int i = 0; i < m_pDVMuxer->m_iInputPinCount; i ++)
	    {
		//use all samples in the queue
		while ( m_pDVMuxer->m_apInput[ i ]->SampleReady( 1 ) )
		{
		    hr = m_pDVMuxer->Receive(  );
		    ASSERT(hr!=Waiting_Audio);
                    if (FAILED(hr))
                    {
                        // Happens when graph is stopped and Receive returns
                        // VFW_E_NOT_COMMITTED (0x80040211). Don't know if
                        // we should do this for other errors (e.g., Waiting_Audio)
                        break;
                    }
		}
	    }

            // jaisri: Should m_pExVidSample be set to NULL here?
            // (StopStreaming releases it again)
            // jaisri: Let StopStreaming do this - it's safer from a concurrency 
            // standpoint (not sure which locks are held to access this member 
            // variable - other pins could be executing CDVMuxer::Receive)
            // IMediaSample* p;
	    // hr=m_pDVMuxer->pExVidSample(&p, TRUE);
	    // if(hr==NOERROR && p!=NULL)
	    //     p->Release();


	    m_pDVMuxer->ReleaseAllQueuedSamples();	
	    hr=m_pDVMuxer->DeliverEndOfStream();
	}
	else
	{
	    //use all video samples in the queue 
	    while ( m_pDVMuxer->m_apInput[ DVMUX_VIDEO_INPUT_PIN ]->SampleReady( 1 ) )
	    {
	        hr = m_pDVMuxer->Receive(  );

                // We get this status back if the 
                // other audio pin has not received EOS
	        // ASSERT(hr!=Waiting_Audio);
	    }
	    hr=NOERROR;
	}    
   }
   else
   {
 
       //no more video
       if(     ( (m_pDVMuxer->m_apInput[1]==NULL ) || ( m_pDVMuxer->m_apInput[ 1]->m_fEOSReceived) )
	    && ( (m_pDVMuxer->m_apInput[2]==NULL ) || ( m_pDVMuxer->m_apInput[ 2]->m_fEOSReceived) ) 
	 )
       {
	    
	   //no more audio sample from any input pin
	    for (int i = 0; i < m_pDVMuxer->m_iInputPinCount; i ++)
	    {
		//use all samples in the queue
		while ( m_pDVMuxer->m_apInputPin[ i ]->SampleReady( 1 ) )
		{
		    hr = m_pDVMuxer->Receive(  );
		    ASSERT(hr!=Waiting_Audio);
		}
	    }

            // jaisri: Should m_pExVidSample be set to NULL here?
            // (StopStreaming releases it again)
            // jaisri: Let StopStreaming do this - it's safer from a concurrency 
            // standpoint (not sure which locks are held to access this member 
            // variable - other pins could be executing CDVMuxer::Receive)
            // IMediaSample* p;
	    // hr=m_pDVMuxer->pExVidSample(&p, TRUE);
	    // if(hr==NOERROR && p!=NULL )
	    //     p->Release();
	    m_pDVMuxer->ReleaseAllQueuedSamples();	
	    hr=m_pDVMuxer->DeliverEndOfStream();
       }
       else
       {
	   //mux all video samples in the queue because it is possible that audio buffers are used up 
	   //at this moment, If we do not mux audio with video, audio input can not input more audio data.
	    while (	(hr = m_pDVMuxer->Receive(  ) )!= Waiting_Audio  && 
			SUCCEEDED(hr)  )
	    {
		if(    ( (m_pDVMuxer->m_apInput[1]==NULL ) || ( m_pDVMuxer->m_apInput[ 1]->m_fEOSReceived ) )
		    && ( (m_pDVMuxer->m_apInput[2]==NULL ) || ( m_pDVMuxer->m_apInput[ 2]->m_fEOSReceived  )  )
		)
       		    break;
	    }
	    hr=NOERROR;
	}
   }


   return hr;
}


// X
// if it is the input video pin, flush  video pin's queue and pass flush to down stream Enter flushing state. 
// else it(they) is(are) auido input pin(s), flush auido pin's queue, does not pass down stream enter flushing state
// this input pin's Receives already blocked
// Call default handler to block Receives, 
// flush all samples on the its queue, if this is video input pin, 
// pass to dvmux filter to flush outputpin
//
STDMETHODIMP CDVMuxerInputPin::BeginFlush(void)
{

    // Call default handler to block Receives, 
    HRESULT hr = CBaseInputPin::BeginFlush();
    if (FAILED(hr)) {
        return hr;
    }

    // Need to lock to make sure that we don't flush away something
    // that is being used.
    CAutoLock lock(&m_pDVMuxer->m_csMuxLock);
	
    //flush all samples on the queus
    while ( SampleReady( 1 ) )
        ReleaseNSample( 1 );

    //if it is video, pass flush to down stream
    if(m_iPinNo ==DVMUX_VIDEO_INPUT_PIN )
	return m_pDVMuxer->BeginFlush();
    else
	return NOERROR;
}

//X
// leave flushing state.
STDMETHODIMP CDVMuxerInputPin::EndFlush(void)
{

    m_PinVidFrmCnt=0;
    
    //if it is video, pass endflush to down stream
    if(m_iPinNo ==DVMUX_VIDEO_INPUT_PIN )
    {
   
	HRESULT hr = m_pDVMuxer->EndFlush();
	if (FAILED(hr)) {
	    return hr;
	}
    }
   
    m_fEOSReceived = FALSE; 
    return CBaseInputPin::EndFlush();
}

//X
// receive on sample from upstream
HRESULT CDVMuxerInputPin::Receive(IMediaSample * pSample)
{
    CRefTime	Stop, VidStart, VidStop;

    ASSERT(pSample!=NULL);
    HRESULT hr;

    CAutoLock lock(&m_csReceive);

    // ...or we'll crash
    if (!m_pDVMuxer->m_pOutput->IsConnected())
	return VFW_E_NOT_CONNECTED;

    DbgLog((LOG_TRACE, 4, TEXT("CDVMuxerInputPin::Receive(..) on pin %d"), m_iPinNo));

    //input video pin has to be connected
    if ( !m_pDVMuxer->InputVideoConnected() )
    {
        DbgLog((LOG_TRACE, 2, TEXT("CDVMuxerInputPin::Receive() without video pin connected!")));
        return S_FALSE;
    }

    // check all is well with the base class
    hr = CBaseInputPin::Receive(pSample);
    if (FAILED(hr)) {
        return hr;
    }

    if( m_fEOSReceived )
    {
        // @@@ jaisri: Why do we have this? Is it legit for a pin to send a sample
        // after delivering EOS (what will the sample have)? Is this just defensive 
        // programming?

        if(m_iPinNo ==DVMUX_VIDEO_INPUT_PIN )
	{
	    //end of video
	    if(!SampleReady( 1 ))
	    {
		// @@@ jaisri: This doesn't seem right. What about audio after video ends?
                m_pDVMuxer->ReleaseAllQueuedSamples();	
		m_pDVMuxer->DeliverEndOfStream();
	    }
	    else if(   ( (m_pDVMuxer->m_apInput[1]==NULL ) || ( m_pDVMuxer->m_apInput[ 1]->m_fEOSReceived ) )
		    && ( (m_pDVMuxer->m_apInput[2]==NULL ) || ( m_pDVMuxer->m_apInput[ 2]->m_fEOSReceived ) )
		 )

	    {
		//No more audio neither
		
		//deliver everything left in the bother Queue
                hr=NOERROR;
		while( SampleReady( 1 ) && (hr==NOERROR) )  
		    hr = m_pDVMuxer->Receive(  );
	
		m_pDVMuxer->ReleaseAllQueuedSamples();	
		m_pDVMuxer->DeliverEndOfStream();
	    }
	    else //refuse any more samples this pin, waiting audio's EOS
	    {
		hr = m_pDVMuxer->Receive(  );
	    }
	    
	}
	else
	{
	    int pin;
	    if( m_iPinNo == 1 ) 
		pin=2;
	    else
		pin=1;

	    //end of audio, Audio can not do m_pDVMuxer->DeliverEndOfStream() without deliver all video frame
	    if( m_pDVMuxer->m_apInput[ DVMUX_VIDEO_INPUT_PIN  ]->m_fEOSReceived )
	    {
		 if( !m_pDVMuxer->m_apInput[ DVMUX_VIDEO_INPUT_PIN  ]->SampleReady( 1 ) )
		 {
		    m_pDVMuxer->ReleaseAllQueuedSamples();	
		    m_pDVMuxer->DeliverEndOfStream();
		 }
		 else if ( (m_pDVMuxer->m_apInput[pin]==NULL ) || ( m_pDVMuxer->m_apInput[ pin]->m_fEOSReceived ) )
		 {
		    //not going to receive any more video sample neither 
		    //if another audio pin will not receive any sample neither
            hr=NOERROR;
		    while ( m_pDVMuxer->m_apInput[ DVMUX_VIDEO_INPUT_PIN  ]->SampleReady( 1 )  && (hr==NOERROR))
		    {
			hr = m_pDVMuxer->Receive(  );
			ASSERT(hr!=Waiting_Audio);
		    }
		    m_pDVMuxer->ReleaseAllQueuedSamples();	
		    m_pDVMuxer->DeliverEndOfStream();
		}
		else
		{
		    hr = m_pDVMuxer->Receive(  );
	   	}
		
	    }
	    else //refuse any more samples on this pin, waiting video's EOS
	    {
		hr = m_pDVMuxer->Receive(  );
	    }
	    
	}

	//refuse accept any more samples on this pin
	return S_FALSE;
    }
    

    // If a graph is stopped and a late sample comes along,
    // then we need to reject the sample. If we don't, we'll end up
    // with a sample with a late time stamp hanging around in our
    // buffers, and that will mess up the algorithm in MixAndOutputSamples
    if (m_pDVMuxer->m_State == State_Stopped) {
        DbgLog((LOG_ERROR, 1, TEXT("Receive while stopped!")));
        return VFW_E_WRONG_STATE;
    }
  
    if(m_iPinNo ==DVMUX_VIDEO_INPUT_PIN )
    {
	//This is video input pin
	//Figure out how many time this frame has to be copied
	pSample->GetTime( (REFERENCE_TIME*)&VidStart,  (REFERENCE_TIME*)&VidStop);		    

	//How many DV frames do we need to copy
	int FrmCnt=0;
	if( m_pDVMuxer->m_iVideoFormat==IDC_DVMUX_NTSC)
	{
            FrmCnt= (int)( (VidStart*29970/1000 + 0xff)/UNITS );
	    if( m_PinVidFrmCnt < FrmCnt )
		FrmCnt= FrmCnt - m_PinVidFrmCnt +(int)( (VidStop*29970/1000+0xff)/UNITS );
	    else
		FrmCnt= (int)( (VidStop*29970/1000+0xff)/UNITS );
	}
	else
	{
	    FrmCnt= (int)( (VidStart*25+0xff)/UNITS );
	    if( m_PinVidFrmCnt < FrmCnt )
		FrmCnt= FrmCnt - m_PinVidFrmCnt +(int)( (VidStop*25+0xff)/UNITS );
	    else
		FrmCnt= (int)( (VidStop*25+0xff)/UNITS );
	}

	//in order to support audio is longer then video
	IMediaSample    *pOut;
	if( !FAILED( m_pDVMuxer->pExVidSample(  &pOut,FALSE ) ) )
	    Copy( pOut, pSample);



	IMediaSample    *pOutSample;
	unsigned char *pDst, *pSrc;

	HRESULT Mux_hr=NOERROR;

	for(int i=m_PinVidFrmCnt; i<FrmCnt; i++)
	{
	    // get output media sample 
	    hr = m_pDVMuxer->m_pOutput->GetDeliveryBuffer(&pOutSample,NULL,NULL,0);
	    if ( FAILED(hr) ) 
		return hr;


	    ASSERT(pOutSample);
	    //fetch output buffer
	    hr = pOutSample->GetPointer(&pDst);
	    if( FAILED( hr ) )
                return hr;
	    ASSERT(pDst);

	    //fetch input  buffer
	    hr = pSample->GetPointer(&pSrc);
	    if( FAILED( hr ) )
                return hr;
	    ASSERT(pSrc);

      	    //copy input DV frame data to output buffer
	    if( m_pDVMuxer->m_iVideoFormat==IDC_DVMUX_NTSC)
	    {
		memcpy(pDst,pSrc,120000);		//80*150*10
		//update time stampe
		Stop=m_pDVMuxer->m_LastVidTime+ UNITS*1000L/29970L;		//DV has to output 30frames/sec if it is NTSC,
            if (m_pDVMuxer->m_cNTSCSample %3 == 0)
                Stop = Stop - 1;
            m_pDVMuxer->m_cNTSCSample++;

		pOutSample->SetTime( (REFERENCE_TIME*)&m_pDVMuxer->m_LastVidTime,  (REFERENCE_TIME*)&Stop);
	    }
	    else
	    {
		memcpy(pDst,pSrc,144000);	//80*150*12
		//update time stampe
		Stop=m_pDVMuxer->m_LastVidTime+ UNITS/25;		//DV has to output 30frames/sec if it is NTSC,
		pOutSample->SetTime( (REFERENCE_TIME*)&m_pDVMuxer->m_LastVidTime,  (REFERENCE_TIME*)&Stop);
	    }
	 
	    m_pDVMuxer->m_LastVidTime =Stop;
	    
      	    // add this video sample to sample list
	    //pOutSample->AddRef();	//since  GetDeliveryBuffe(), we have to release pOutSample.
	    m_SampleList.AddTail(pOutSample);

	    //try to mux this sample with other samples to build 10 DV DIF sequences (one frame)
	    if(Mux_hr==NOERROR)
	    {
		Mux_hr = m_pDVMuxer->Receive(  );
		if( Mux_hr!=Waiting_Audio )
		    if (FAILED(hr)) 
			 return hr;
	    }
	    //else maybe nor audio

    	    m_PinVidFrmCnt++;

	}

    }
    else
    {
	// alway copy audio since the AVI splitter can not guarant to diliver if this filter holds one buffer
	IMediaSample * pAudSample=NULL;

	ASSERT( m_fCpyAud );
	ASSERT(m_pLocalAllocator != NULL);
	
        // @@@ jaisri: So if an audio sample comes in before a video sample
        // (and video has not flagged end of stream) and video and audio are
        // delivered by the  same thread, we are going to sit in an infinite 
        // loop here? See ManBugs # 35432.
        //
        // The m_fWaiting_Video is an attempt to fix this. However, note that
        // there are several other code segments (e.g., in CDVMuxerInputPin::EndOfStream)
        // that also loop over Receive. These may need to be modified as well.

        hr=NOERROR;
	while(   ( m_SampleList.GetCount() >= 1) 
	      && ( m_pDVMuxer->m_fWaiting_Audio == FALSE   )  
	      && ( m_pDVMuxer->m_fWaiting_Video == FALSE   )  
              &&  (hr==NOERROR) )
	    //try not let m_pLocalAllocator->GetBuffer( &pAudSample, NULL, NULL , 0 ) wait
	    //and if audio sample changed format type in this justed received sample,
	    //m_pDVMuxer->m_MediaTypeChanged will be set just at right time for changing
	    hr = m_pDVMuxer->Receive(  );

        if ( FAILED(hr) && 	m_fEOSReceived )
        {
            m_pDVMuxer->ReleaseAllQueuedSamples();	
	    m_pDVMuxer->DeliverEndOfStream();
            //refuse accept any more samples on this pin
	    return S_FALSE;
        }

		
	hr = m_pLocalAllocator->GetBuffer( &pAudSample, NULL, NULL , 0 );

	if ( FAILED(hr) ) 
	    return hr;
	   
	ASSERT(pAudSample != NULL);

	//check if format is changed
	AM_MEDIA_TYPE *pmt=NULL;
	pSample->GetMediaType(&pmt);
    
	if (pmt != NULL && pmt->pbFormat != NULL) 
	{
            // @@@ jaisri: All this should be done when the
            // sample is processed in CDVMuxer::Receive(), not here
            // since m_SampleList.GetCount() could be > 0 still

	    ASSERT(m_mt.subtype	    == pmt->subtype);
	    ASSERT(m_mt.majortype   == pmt->majortype);
	    ASSERT(m_mt.formattype  == pmt->formattype	);
	    ASSERT(m_mt.cbFormat    == pmt->cbFormat );

	    memcpy(m_mt.pbFormat, pmt->pbFormat, sizeof(WAVEFORMATEX) );

	    m_pDVMuxer->m_MediaTypeChanged=TRUE;

	    // *************************
	    // BUILD NEW AAUX, ONLY SUPPORT AUDIO sample rate change 
	    // 48000,44100,32000, CHANGE ON FLY
	    // ***************************
	    
	    //get input video Mediatype
	    CMediaType *pInputVidMediaType = &m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN]->CurrentMediaType();
	    VIDEOINFO *pVideoInfo;
	    pVideoInfo=(VIDEOINFO *)pInputVidMediaType->pbFormat;
	    LPBITMAPINFOHEADER lpbi = HEADER(pVideoInfo);
    
	    //get input audio Mediatype
	    CMediaType *ppInputAudMediaType[DVMUX_MAX_AUDIO_PIN];
	    //get input Audio's information
	    WAVEFORMATEX *ppwfx[DVMUX_MAX_AUDIO_PIN];

	    //how many language							 
	    int cnt=0;
	    for(int k=1; k <= DVMUX_MAX_AUDIO_PIN; k++)
		if( m_pDVMuxer->m_apInput[k] !=NULL)
		{
		    ASSERT(m_pDVMuxer->m_apInput[k]->IsConnected() );
		    if( m_pDVMuxer->m_apInput[k] != this )
		    {
			ppInputAudMediaType[k-1] = &m_pDVMuxer->m_apInput[k]->CurrentMediaType();
			ppwfx [k-1] = (WAVEFORMATEX *)ppInputAudMediaType[k-1]->pbFormat;
		    }
		    else
		    {
			ppwfx [k-1] = (WAVEFORMATEX *)pmt->pbFormat;
		    }
		    cnt++;  
		}
		else
		    ppwfx [k-1]=NULL;
        {
            CAutoLock lock(&m_pDVMuxer->m_csMuxLock);
	        // build new DVINFO
	        hr=BuildDVINFO(&m_pDVMuxer->m_OutputDVFormat,
    			    ppwfx,
    			    lpbi, 
    			    cnt,
                                m_pDVMuxer->m_AudSampleSequence,
    			    m_pDVMuxer->m_wMinAudSamples, 
    			    m_pDVMuxer->m_wMaxAudSamples,
                                m_pDVMuxer->m_wAudSamplesBase);
        }

	    //set new output format
            // @@@ jaisri: Safer to call SetMediaType or set m_pOutput->m_mt??
	    memcpy( m_pDVMuxer->m_pOutput->CurrentMediaType().pbFormat, &m_pDVMuxer->m_OutputDVFormat, sizeof(DVINFO) );


	} //end of media type change

	Copy(pAudSample,pSample);

	m_SampleList.AddTail(pAudSample);

#ifdef DEBUG
        WAVEFORMATEX *pWave =(WAVEFORMATEX *) CurrentMediaType().pbFormat ;

	int nSamples = pAudSample->GetActualDataLength()/pWave->nBlockAlign;

        DbgLog((LOG_TRACE, 3, TEXT("CDVMuxerInputPin::Receive: m_iPinNo=%d got %d samples"),
                m_iPinNo, nSamples));

#endif // ifdef DEBUG
        
	//try mux this audio sample with video data to build 10 DV DIF sequences (one frame)
	hr = m_pDVMuxer->Receive(  );
    }
    
    if(hr==Waiting_Audio)
	 return NOERROR;
    else
	 return hr;
}


STDMETHODIMP CDVMuxerInputPin::GetAllocatorRequirements(
    ALLOCATOR_PROPERTIES *pProps
)
{
    /*  Go for 4 0.5 second buffers - 8 byte aligned */

    // Manbugs 41398: This is a workaround in the case that the
    // MSDV vid only pin is connected to the dv mux. 
    // MSDV is hardcoded to having a max of 8 buffers. 
    pProps->cBuffers =  m_iPinNo ==DVMUX_VIDEO_INPUT_PIN? 8 : 10;
    pProps->cbBuffer = 1024*8;
    pProps->cbAlign = 4;
    pProps->cbPrefix = 0;
    return S_OK;
}

/* Get told which allocator the upstream output pin is actually going to use */
STDMETHODIMP CDVMuxerInputPin::NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly)
{
    if(m_iPinNo ==DVMUX_VIDEO_INPUT_PIN )
    	;
    else
    {
	ALLOCATOR_PROPERTIES propActual, Prop;
        HRESULT hr;
	
	//  always Copy audio
	m_fCpyAud=TRUE;
        CheckPointer(pAllocator,E_POINTER);
        ValidateReadPtr(pAllocator,sizeof(IMemAllocator));
        

        // @@@ jaisri: Why do we copy audio samples? 
        // There're some comments in CDVMuxerInputPin::Receive
        // about AVI splitter not liking us holding on to 
        // an audio sample, is this still true?

        // Note that, pre-DX8, m_pAllocator was used instead of
        // m_pLocalAllocator. If the muxer's audio pin was connected to 
        // a Ksproxy'd filter's pin, CDVMuxerInputPin::Receive hung 
        // when it received the first audio sample. KsProxy::Active
        // grabs all the allocator's buffers and hands it off to the device.
        // CDVMuxerInputPin::Receive then called m_pAllocator->GetBuffer
        // (so that it could copy the audio sample) and hung.
        //
        // Dazzle reported this problem - Manbugs 41400
        //
        // Post-DX8: re-examine why we are copying audio samples at all
        // and why we need this allocator.
        
        if( m_pLocalAllocator==NULL)
        {
            HRESULT hr = ::CreateMemoryAllocator(&m_pLocalAllocator);
	    if (FAILED(hr)) 
	        return hr;
	}

	hr = pAllocator->GetProperties( &Prop );
        ASSERT(SUCCEEDED(hr));
	    
	hr = m_pLocalAllocator->SetProperties(&Prop, &propActual);
	if (FAILED(hr)) 
	{
	    return hr;
	}

	if (propActual.cbBuffer < Prop.cbBuffer ) {
	    ASSERT(propActual.cbBuffer >= Prop.cbBuffer );
	    return E_INVALIDARG;
	}

        // All this should not be necessary since the output pin's DecideBufferSize
        // should have called SetProperties on m_pAllocator if it was the one
        // actually used to transfer samples. However, do this here to minimize the
        // risk of regressions in DX8 since the code was doing this before.
        if (m_pAllocator)
        {
            // Call GetProperties again just in case the previous call to SetProperties
            // changed *Prop - though it has no business doing that.
            hr = pAllocator->GetProperties( &Prop );
            ASSERT(SUCCEEDED(hr));

            hr = m_pAllocator->SetProperties(&Prop, &propActual);
	    if (FAILED(hr)) 
	    {
	        return hr;
	    }

	    if (propActual.cbBuffer < Prop.cbBuffer ) {
	        ASSERT(propActual.cbBuffer >= Prop.cbBuffer );
	        return E_INVALIDARG;
	    }
        }

	return NOERROR;
    }

    return  CBaseInputPin::NotifyAllocator(pAllocator,bReadOnly);
} // NotifyAllocator


//X 
HRESULT CDVMuxerInputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    return VFW_S_NO_MORE_ITEMS;
}


// =================================================================
// Implements the CDVMuxerOutputPin class
// =================================================================
// constructor

CDVMuxerOutputPin::CDVMuxerOutputPin(
    TCHAR *pObjectName,
    CBaseFilter *pBaseFilter,
    CDVMuxer *pDVMux,
    HRESULT * phr,
    LPCWSTR pPinName)
    : CBaseOutputPin(pObjectName, pBaseFilter, &pDVMux->m_csFilter, phr, pPinName)
    //m_iOutputPin(pDVMux->m_iInputPinCount)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVMuxerOutputPin::CDVMuxerOutputPin")));
    m_pDVMuxer = pDVMux;

}

// destructor

CDVMuxerOutputPin::~CDVMuxerOutputPin()
{
    DbgLog((LOG_TRACE,2,TEXT("CDVMuxerOutputPin::~CDVMuxerOutputPin")));

}


//
// Called after we have agreed a media type to actually set it in which case
// we run the CheckTransform function to get the output format type again
//
HRESULT CDVMuxerOutputPin::SetMediaType(const CMediaType* pmtOut)
{
    HRESULT hr = NOERROR;
    
    if( (pmtOut->majortype == MEDIATYPE_Interleaved)							    &&
	(pmtOut->subtype   ==  MEDIASUBTYPE_dvsd )							    &&
	(pmtOut->formattype==FORMAT_DvInfo	)							    && 
	(pmtOut->cbFormat  == sizeof(DVINFO)	)							    &&	
	(pmtOut->pbFormat   != NULL		) 
	//(m_pDVMuxer->InputVideoConnected() )							    
       )
    {
	// Set the base class media type (should always succeed)
	hr = CBasePin::SetMediaType(pmtOut);
	ASSERT(SUCCEEDED(hr));
	m_pDVMuxer->m_OutputDVFormat=*( (DVINFO *) pmtOut->pbFormat );

	return hr;
    }	 //if'iavs'
    else 
	return E_UNEXPECTED;
}
//
// Input dv video pin has to be connected
// if output is 'iavs' stream, both audio and video have to be connected
//
HRESULT CDVMuxerOutputPin::CheckMediaType(const CMediaType* pmtOut)
{
    //insist its own mediatype
    CMediaType TmpMt;
    HRESULT hr = NOERROR;

    if(FAILED(hr = GetMediaType(0, &TmpMt)))
    {
        // couldn't get valid media type
        return hr;
    }
    
    if(TmpMt== *pmtOut)
	return NOERROR;
    else
	return E_FAIL;
}
	 
//X The Input dv video pin has to be connected before the output pin can be connected.
HRESULT CDVMuxerOutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{								  

    if(iPosition != 0)
	return E_INVALIDARG;

    if(iPosition > 0)
	return VFW_S_NO_MORE_ITEMS;;

    DVINFO DVInfo;
    FillMemory ( &DVInfo, sizeof(DVINFO), 0); 
	
    //make outputpin's mediatype
    //'iavs' type
    pMediaType->majortype		= MEDIATYPE_Interleaved;
    pMediaType->bFixedSizeSamples	= 1;	//X* 1 for lSampleSize is not 0 and fixed
    pMediaType->bTemporalCompression	= FALSE; //no I frame exists
    pMediaType->formattype		= FORMAT_DvInfo; 
    pMediaType->cbFormat		= sizeof(DVINFO);
    if( m_pDVMuxer->m_iVideoFormat==IDC_DVMUX_PAL)
	pMediaType->lSampleSize = 140000L;
    else
	pMediaType->lSampleSize = 120000L;

	    
    if( m_pDVMuxer->InputVideoConnected()== FALSE )
    {
	pMediaType->subtype		= MEDIASUBTYPE_dvsd;

    	//give a defaul one, even video is no connected, we use default one to make connection
	DVInfo.dwDVAAuxSrc	= 0xc0c000d6;           // audio is locked
	DVInfo.dwDVAAuxCtl	= AM_DV_DEFAULT_AAUX_CTL;
	DVInfo.dwDVAAuxSrc1	= 0xc0c001d6;           // audio is locked
	DVInfo.dwDVAAuxCtl1	= AM_DV_DEFAULT_AAUX_CTL;
	DVInfo.dwDVVAuxSrc	= 0xff00ffff;
	DVInfo.dwDVVAuxCtl	= 0xfffcc83f;
	
    }
    else
    {	//build DVInfo according to input pin

	//##############get input video's information##############
	//get input video Mediatype
	CMediaType *pInputVidMediaType = &m_pDVMuxer->m_apInput[DVMUX_VIDEO_INPUT_PIN]->CurrentMediaType();
	VIDEOINFO *pVideoInfo;
	pVideoInfo=(VIDEOINFO *)pInputVidMediaType->pbFormat;
	LPBITMAPINFOHEADER lpbi = HEADER(pVideoInfo);
    
	//get input audio Mediatype
	CMediaType *ppInputAudMediaType[DVMUX_MAX_AUDIO_PIN];
	//get input Audio's information
	WAVEFORMATEX *ppwfx[DVMUX_MAX_AUDIO_PIN];

	//how many language							 
	int cnt=0;
	for(int k=1; k <= DVMUX_MAX_AUDIO_PIN; k++)
	    if( m_pDVMuxer->m_apInput[k] !=NULL)
	    {
		ASSERT(m_pDVMuxer->m_apInput[k]->IsConnected() );
		ppInputAudMediaType[k-1] = &m_pDVMuxer->m_apInput[k]->CurrentMediaType();
		ppwfx [k-1] = (WAVEFORMATEX *)ppInputAudMediaType[k-1]->pbFormat;
		cnt++;
	    }
	    else
		ppwfx [k-1]=NULL;

	//build DVINFO
	HRESULT hr=BuildDVINFO(&DVInfo, ppwfx,lpbi, cnt,
                               m_pDVMuxer->m_AudSampleSequence,
                               m_pDVMuxer->m_wMinAudSamples, m_pDVMuxer->m_wMaxAudSamples,
                               m_pDVMuxer->m_wAudSamplesBase);
	
        // @@@ jaisri: The way m_DVINFOChanged is used makes little sense.
        // First, we should never get NOERROR here (if we cleaned up the 
        // dynamic format change code). Second, even if we did, wouldn't the
        // connection of the output pin fail? We don't reset this variable
        // till a sample is sent on the output pin.

        //so, output sample can be set
	if(hr!=NOERROR)
	    m_pDVMuxer->m_DVINFOChanged=TRUE;
   
	pMediaType->subtype	= pInputVidMediaType->subtype;
    
	if(hr!=NOERROR)
	   return hr;
    }

     if(pMediaType->pbFormat==NULL)
	 pMediaType->pbFormat=(PBYTE)CoTaskMemAlloc( sizeof(DVINFO) );

    pMediaType->SetFormat ((unsigned char *)&DVInfo, sizeof(DVINFO) );

	    

    return NOERROR;
}

//----------------------------------------------------------------------------
// CDVMuxerOutputPin::DecideBufferSize
// X* called by DecideAllocate
// let get 10 buffers from down stream filter 
//----------------------------------------------------------------------------
HRESULT CDVMuxerOutputPin::DecideBufferSize (IMemAllocator *pMemAllocator,
                                         ALLOCATOR_PROPERTIES * pProp)
{
    // set the size of buffers based on the expected output frame size, and
    // the count of buffers to 1.
    //
    pProp->cBuffers = 10;			//10 DIF sequence per frame
    
    if(m_pDVMuxer->m_iVideoFormat==IDC_DVMUX_NTSC)
	pProp->cbBuffer =120000 ;	//*X* return m_mt.lSampleSize *X
    else
	pProp->cbBuffer =144000 ;	/*X* return m_mt.lSampleSize *X*/

    pProp->cbAlign = 4;
    pProp->cbPrefix = 0;
   	   
  
    ALLOCATOR_PROPERTIES propActual;
    HRESULT hr = m_pAllocator->SetProperties(pProp, &propActual);
    if (FAILED(hr)) {
        return hr;
    }

    if (propActual.cbBuffer < pProp->cbBuffer ) {
	ASSERT(propActual.cbBuffer >= pProp->cbBuffer );
        return E_INVALIDARG;
    }

    return S_OK;
}

// rMin, rMax set to min, max audio samples for first DV frame.
// rBase has the value that must be added to the AF_SIZE field.
// Init should be called after a format change and before the 
// first DV frame is delivered with the new format.
void CAudioSampleSizeSequence::Init(BOOL bLocked, BOOL bNTSC, 
                                    DWORD nSamplingFrequency,
                                    WORD& rMin, WORD& rMax,
                                    WORD& rBase)
{
    m_nCurrent = 1;
    if (bLocked && bNTSC)
    {
        if (nSamplingFrequency == 48000)
        {
            m_nSequenceSize = 5;
            rMin = rMax = 1600;
            rBase = 1580;
        }
        else
        {
            ASSERT(nSamplingFrequency == 32000 && bNTSC && bLocked);
            m_nSequenceSize = 15;
            rMin = rMax = 1066;
            rBase = 1053;
        }
    }
    else if (bLocked)
    {
        // PAL
        m_nSequenceSize = 1;
        switch (nSamplingFrequency)
        {
            case 48000:
                rMin = rMax = 1920;
                rBase = 1896;
                break;

            case 32000:
                rMin = rMax  = 1280;
                rBase = 1264;
                break;

            default:
		ASSERT(nSamplingFrequency==32000 && !bNTSC && bLocked);
                break;
        }
    }
    else
    {
        // Unlocked.
        m_nSequenceSize = 1;
        switch (nSamplingFrequency)
        {
            case 48000:
                rMin = bNTSC? 1580 : 1896;
                rMax = bNTSC? 1620 : 1944;
                rBase = rMin;
                break;

            case 44100:
                rMin = bNTSC? 1452 : 1742;
                rMax = bNTSC? 1489 : 1786;
                rBase = rMin;
                break;

            case 32000:
                rMin = bNTSC? 1053 : 1264;
                rMax = bNTSC? 1080 : 1296;
                rBase = rMin;
                break;

            default:
		ASSERT(nSamplingFrequency==32000);
                break;
        }
        
    }
} // CAudioSampleSizeSequence::Init()


// Called after each frame is delivered. Sets the min/max audio 
// samples for the next DV frame.
void CAudioSampleSizeSequence::Advance(WORD& rMin, WORD& rMax)
{
    ASSERT(m_nSequenceSize > 0);
    ASSERT(m_nCurrent > 0 && m_nCurrent <= m_nSequenceSize);

    if (m_nSequenceSize > 1)
    {
        // We use the sequence size to infer the frequency
        // to eliminate saving the frequency as a member var
        if (m_nSequenceSize == 5)
        {
            // NTSC, Sampling Frequency = 48000
            if (++m_nCurrent > m_nSequenceSize)
            {
                m_nCurrent = 1;
                rMin = rMax = 1600;
            }
            else
            {
                rMin = rMax = 1602;
            }
        }
        else
        {
            ASSERT(m_nSequenceSize == 15);

            // NTSC, Sampling Frequency == 32000
            if (++m_nCurrent > m_nSequenceSize)
            {
                m_nCurrent = 1;
                rMin = rMax = 1066;
            }
            else if (m_nCurrent == 8)
            {
                rMin = rMax = 1066;
            }
            else 
            {
                rMin = rMax = 1068;
            }
        }
    }
} // CAudioSampleSizeSequence::Advance()

// Called to reset counter to 1, typically on restarting the graph.
// Same as Init except that only rMin and rMax have to be changed
// and there is no need to supply the other input arguments.
void CAudioSampleSizeSequence::Reset(WORD& rMin, WORD& rMax)
{
    ASSERT(m_nSequenceSize > 0);
    ASSERT(m_nCurrent > 0 && m_nCurrent <= m_nSequenceSize);

    if (m_nSequenceSize > 1)
    {
        // We use the sequence size to infer the frequency
        // to eliminate saving the frequency as a member var
        if (m_nSequenceSize == 5)
        {
            // NTSC, Sampling Frequency = 48000
            m_nCurrent = 1;
            rMin = rMax = 1600;
        }
        else
        {
            ASSERT(m_nSequenceSize == 15);

            // NTSC, Sampling Frequency == 32000
            m_nCurrent = 1;
            rMin = rMax = 1066;
        }
    }
} // CAudioSampleSizeSequence::Reset()

  
/*X###################################################################
Accepted input audio formats
    pin	    stereo	Freqeuncy	    bits
    	    yes		32K, 44.1K, 48K	    16bits or 32K 12bits
    1	    ----
	    no		32K, 44.1K, 48K	    16bits only	
    -----------------------------------------------------------
	    yes		both pins=32K only  16bits or 12 bits
    2	    ----
	    no		32K, 44.1K, 48K     16 bits only
	    ----
	    mix		stereo pin ==32K	16 bits or 
			mon pin=32K,44.K,48K	16 bits only
Accepted video format
    biHeight  = 480(NTSC) or 576(PAL)
    will oupt dvsp only
######################################################################X*/
HRESULT BuildDVINFO(DVINFO *pDVInfo,
		    WAVEFORMATEX **ppwfx, 
		    LPBITMAPINFOHEADER lpbi, 
		    int cnt,
                    CAudioSampleSizeSequence* pAudSampleSequence,
		    WORD *wpMinAudSamples, 
		    WORD *wpMaxAudSamples,
                    WORD *wpAudSamplesBase)
{
    int k;

    //set 1st 5/6 DIF's reserved bits
    pDVInfo->dwDVAAuxSrc    = 0x00800040 | AM_DV_AUDIO_EF | AM_DV_AUDIO_ML|AM_DV_AUDIO_LF;  //no multiple lang. 
    pDVInfo->dwDVAAuxCtl    = AM_DV_DEFAULT_AAUX_CTL; 

    //set 2nd 5/6 DIF's reserved bits
    pDVInfo->dwDVAAuxSrc1   = 0x00800040 |AM_DV_AUDIO_EF | AM_DV_AUDIO_ML|AM_DV_AUDIO_LF;
    pDVInfo->dwDVAAuxCtl1    = AM_DV_DEFAULT_AAUX_CTL; 

    pDVInfo->dwDVVAuxSrc =AM_DV_DEFAULT_VAUX_SRC;
    pDVInfo->dwDVVAuxCtl =AM_DV_DEFAULT_VAUX_CTL;

    //set 50/60 and STYPE: PAL or NTSC
    if( lpbi->biHeight  != 480 )
    {
	//PAL
        //set 1st 5/6 DIF's 50/60
        pDVInfo->dwDVAAuxSrc |= AM_DV_AUDIO_5060; 
        //set 2nd 5/6 DIF's 50/60
        pDVInfo->dwDVAAuxSrc1 |= AM_DV_AUDIO_5060;

        pDVInfo->dwDVVAuxSrc |=AM_DV_AUDIO_5060;
    }
	

    switch ( cnt )
    {
	case 0:	    //no audio
	    pDVInfo->dwDVAAuxSrc	|= AM_DV_AUDIO_NO_AUDIO;
	    pDVInfo->dwDVAAuxSrc1	|= AM_DV_AUDIO_NO_AUDIO;
	    pDVInfo->dwDVAAuxCtl	|= AM_DV_AAUX_CTL_IVALID_RECORD;
	    pDVInfo->dwDVAAuxCtl1	|= AM_DV_AAUX_CTL_IVALID_RECORD ;
	    break;

	case 1:	    //one audio
		    //RULE: audio pin1 goes to 1st 5/6 DIF, Audio pin2 goes to 2nd 5/6 DIF, 
		    //Always!!!, even audio pin1 is not connected, audio pin2 still goes to 2nd 5/6  DIF
	    //which pin
	    if( ppwfx[0]!=NULL )
	    {
		ASSERT(ppwfx[1]==NULL);
		k=0;
	    }
	    else
	    {
		k=1;
		ASSERT(ppwfx[0]==NULL);
	    }
		
    	    //sample rate
	    switch  (	ppwfx [k]->nSamplesPerSec )
	    { 
		case 48000:
		    pDVInfo->dwDVAAuxSrc	|= AM_DV_AUDIO_SMP48;
		    pDVInfo->dwDVAAuxSrc1	|= AM_DV_AUDIO_SMP48;
		    pDVInfo->dwDVAAuxSrc        &= ~AM_DV_AUDIO_LF;     // turn audio locking on
		    pDVInfo->dwDVAAuxSrc1       &= ~AM_DV_AUDIO_LF;     // turn audio locking on
                    pAudSampleSequence[k].Init(1, lpbi->biHeight == 480, 48000,                                           
                                               wpMinAudSamples[k], wpMaxAudSamples[k],
                                               wpAudSamplesBase[k]); 
		    break;
		case 44100:
		    pDVInfo->dwDVAAuxSrc	|= AM_DV_AUDIO_SMP44;
		    pDVInfo->dwDVAAuxSrc1	|= AM_DV_AUDIO_SMP44;
                    pAudSampleSequence[k].Init(0, (lpbi->biHeight == 480 ), 44100,
                                               wpMinAudSamples[k], wpMaxAudSamples[k],
                                               wpAudSamplesBase[k]); 
		    break;
		case 32000:
		    // Note that 32K stereo is recorded in SD 4 ch mode (i.e., as 12 bit), so the PA bit is turned on.
                    // The Blue Book does not require this; but the comments below state that DV camcorders
                    // support only 12 bits for 32KHz audio. That is not easily verified, but we don't want a major 
                    // regression, so go with this. - jaisri
		    pDVInfo->dwDVAAuxSrc	|= ( AM_DV_AUDIO_SMP32 | AM_DV_AUDIO_EF |AM_DV_AUDIO_PA);
		    pDVInfo->dwDVAAuxSrc1	|= ( AM_DV_AUDIO_SMP32 | AM_DV_AUDIO_EF |AM_DV_AUDIO_PA);
		    pDVInfo->dwDVAAuxSrc        &= ~AM_DV_AUDIO_LF;     // turn audio locking on
		    pDVInfo->dwDVAAuxSrc1       &= ~AM_DV_AUDIO_LF;     // turn audio locking on
                    pAudSampleSequence[k].Init(1, (lpbi->biHeight == 480 ), 32000,
                                               wpMinAudSamples[k], wpMaxAudSamples[k],
                                               wpAudSamplesBase[k]); 
		    break;
		default:
		    ASSERT(ppwfx [k]->nSamplesPerSec==32000 ||
                           ppwfx [k]->nSamplesPerSec==44100 ||
                           ppwfx [k]->nSamplesPerSec==48000
                          );
		    return E_INVALIDARG;
	    }

	    //bits/samples
	    if ( ppwfx [k]->wBitsPerSample ==16 )
	    {
		if( ppwfx [k]->nChannels ==2 )
		{
		    if( ppwfx [k]->nSamplesPerSec == 32000 )
		    {
			//32k, has to convert  to 12 bits, the DV camcorder does not support
			//32k-16bits, 7-14-98
			if(!k)
			{
			    // Note the Blue Book (Table 16 or the second table on page 265) does
                            // not specify this combination. If SD 4ch has only stereo, the stereo
                            // should go in CH1, not CH2. But this has always been this way, so
                            // don't change it now - jaisri
			    pDVInfo->dwDVAAuxSrc |= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE0 | AM_DV_AUDIO_QU12);
			    pDVInfo->dwDVAAuxSrc1 |= (AM_DV_AUDIO_NO_AUDIO | AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE0 | AM_DV_AUDIO_QU12);
		    	    pDVInfo->dwDVAAuxCtl1 |= AM_DV_AAUX_CTL_IVALID_RECORD;
        		}
			else{
			    pDVInfo->dwDVAAuxSrc1 |= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE0 | AM_DV_AUDIO_QU12);
			    pDVInfo->dwDVAAuxSrc |= ( AM_DV_AUDIO_NO_AUDIO |AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE0 | AM_DV_AUDIO_QU12);
		    	    pDVInfo->dwDVAAuxCtl |= AM_DV_AAUX_CTL_IVALID_RECORD;
			}
		    }
		    else
		    {
			//left in 1st 5/6 DIF , CHN=0
			pDVInfo->dwDVAAuxSrc	|=  ( AM_DV_AUDIO_MODE0| AM_DV_AUDIO_QU16 );
			//right in 2nd 5/6 DIF, CHN=0
			pDVInfo->dwDVAAuxSrc1	|= ( AM_DV_AUDIO_MODE1 | AM_DV_AUDIO_QU16 );
		    }
		}
		else
		{
		    // Note that 32K 16 bit mono is recorded in SD 2 ch mode
                    // (i.e., as 16 bit rather than 12 bit) notwithstanding
                    // the "cameras cannot record 32K 16bit" comment.
                    // Always has been this way - jaisri

		    //if mono. one of following  will be set to AM_DV_AUDIO_NO_AUDIO later.
		    pDVInfo->dwDVAAuxSrc	|=  ( AM_DV_AUDIO_MODE2| AM_DV_AUDIO_QU16 | AM_DV_AUDIO_PA);
		    //right in 2nd 5/6 DIF, CHN=0
		    pDVInfo->dwDVAAuxSrc1	|= ( AM_DV_AUDIO_MODE2 | AM_DV_AUDIO_QU16 | AM_DV_AUDIO_PA);
		}
	    }
            else
            {
                ASSERT(ppwfx[k]->wBitsPerSample ==16);
		return E_INVALIDARG;
            }
#if 0
            // Manbugs 37710. This is no longer supported; see the comment in CDVMuxerInputPin::CheckMediaType
	    else if ( ppwfx [k]->wBitsPerSample ==12 )
	    {
		ASSERT(ppwfx [k]->nSamplesPerSec == 32000);
		ASSERT(ppwfx [k]->nChannels ==2);
		
		//only use 1st or 2nd 5/6 DIF
		if( ppwfx [k]->nChannels ==2 )
		{
		    //stereo
		    if(!k)
		    {
			pDVInfo->dwDVAAuxSrc |= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE0 | AM_DV_AUDIO_QU12);
			pDVInfo->dwDVAAuxSrc1 |= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE0 |
						    AM_DV_AUDIO_QU12|AM_DV_AUDIO_NO_AUDIO ) ;
			pDVInfo->dwDVAAuxCtl1 |= AM_DV_AAUX_CTL_IVALID_RECORD;
		    }
		    else
		    {
			pDVInfo->dwDVAAuxSrc1 |= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE0 | AM_DV_AUDIO_QU12);
			pDVInfo->dwDVAAuxSrc |= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE0 | 
						AM_DV_AUDIO_QU12| AM_DV_AUDIO_NO_AUDIO);
			pDVInfo->dwDVAAuxCtl |= AM_DV_AAUX_CTL_IVALID_RECORD;

		    }
		    
		}
	    }
#endif

	    //mono or stereo
	    if( ppwfx [k]->nChannels ==1 ) 
	    {
	        if(!k)
	        {   //audio pin1 is connected
		    //no audio in 2nd 5/6 DIF
		    pDVInfo->dwDVAAuxSrc1 |= ( AM_DV_AUDIO_NO_AUDIO | AM_DV_AUDIO_PA );
	    	    pDVInfo->dwDVAAuxCtl1 |= AM_DV_AAUX_CTL_IVALID_RECORD;
		}
		else
		{
		    //audio pin2 is connected, no audio in 1st 5/6 DIF
		    pDVInfo->dwDVAAuxSrc |= (AM_DV_AUDIO_NO_AUDIO  | AM_DV_AUDIO_PA);
	    	    pDVInfo->dwDVAAuxCtl |= AM_DV_AAUX_CTL_IVALID_RECORD;
		}
	    }
	    break;

	case 2: //both pins connected
	    //ML: multi-language
	    pDVInfo->dwDVAAuxSrc	&= (~AM_DV_AUDIO_ML);
	    pDVInfo->dwDVAAuxSrc1	&= (~AM_DV_AUDIO_ML);

	    //independent channel
	    pDVInfo->dwDVAAuxSrc	|= AM_DV_AUDIO_PA;
	    pDVInfo->dwDVAAuxSrc1	|= AM_DV_AUDIO_PA;

            if (ppwfx[0]->nSamplesPerSec != 32000 &&
                ppwfx[0]->nSamplesPerSec != 44100 &&
                ppwfx[0]->nSamplesPerSec != 48000)
            {
                ASSERT(ppwfx[0]->nSamplesPerSec == 32000 ||
                       ppwfx[0]->nSamplesPerSec == 44100 ||
                       ppwfx[0]->nSamplesPerSec == 48000);
                return E_INVALIDARG;
            }
	    
	    if (ppwfx[0]->nSamplesPerSec != ppwfx[1]->nSamplesPerSec)
            {
                ASSERT(ppwfx[0]->nSamplesPerSec == ppwfx[1]->nSamplesPerSec);
                return E_INVALIDARG;
            }

            if (ppwfx[0]->wBitsPerSample != 16)
            {
                ASSERT(ppwfx[0]->wBitsPerSample == 16);
                return E_INVALIDARG;
            }
            if (ppwfx[1]->wBitsPerSample != 16)
            {
	        ASSERT(ppwfx[1]->wBitsPerSample == 16);
                return E_INVALIDARG;
            }

            //###########sample rate
	    switch  (ppwfx[0]->nSamplesPerSec )
	    { 
		case 48000:
		    pDVInfo->dwDVAAuxSrc |= AM_DV_AUDIO_SMP48;
		    pDVInfo->dwDVAAuxSrc &= ~AM_DV_AUDIO_LF;     // turn audio locking on
                    pAudSampleSequence[0].Init(1, lpbi->biHeight == 480, 48000,                                           
                                               wpMinAudSamples[0], wpMaxAudSamples[0],
                                               wpAudSamplesBase[0]); 
		    pDVInfo->dwDVAAuxSrc1 |= AM_DV_AUDIO_SMP48;
		    pDVInfo->dwDVAAuxSrc1 &= ~AM_DV_AUDIO_LF;     // turn audio locking on
                    pAudSampleSequence[1].Init(1, lpbi->biHeight == 480, 48000,
                                               wpMinAudSamples[1], wpMaxAudSamples[1],
                                               wpAudSamplesBase[1]); 
		    break;
		case 44100:
		    pDVInfo->dwDVAAuxSrc |= AM_DV_AUDIO_SMP44;
                    pAudSampleSequence[0].Init(0, lpbi->biHeight == 480, 44100,
                                               wpMinAudSamples[0], wpMaxAudSamples[0],
                                               wpAudSamplesBase[0]); 
		    pDVInfo->dwDVAAuxSrc1 |= AM_DV_AUDIO_SMP44;
                    pAudSampleSequence[1].Init(0, lpbi->biHeight == 480, 44100,
                                               wpMinAudSamples[1], wpMaxAudSamples[1],
                                               wpAudSamplesBase[1]); 
		    break;
		case 32000:
		    pDVInfo->dwDVAAuxSrc |= (AM_DV_AUDIO_SMP32| AM_DV_AUDIO_EF |AM_DV_AUDIO_PA);
		    pDVInfo->dwDVAAuxSrc &= ~AM_DV_AUDIO_LF;     // turn audio locking on
                    pAudSampleSequence[0].Init(1, lpbi->biHeight == 480, 32000,
                                               wpMinAudSamples[0], wpMaxAudSamples[0],
                                               wpAudSamplesBase[0]); 
		    pDVInfo->dwDVAAuxSrc1 |= (AM_DV_AUDIO_SMP32| AM_DV_AUDIO_EF |AM_DV_AUDIO_PA);
		    pDVInfo->dwDVAAuxSrc1 &= ~AM_DV_AUDIO_LF;     // turn audio locking on
                    pAudSampleSequence[1].Init(1, lpbi->biHeight == 480, 32000,
                                               wpMinAudSamples[1], wpMaxAudSamples[1],
                                               wpAudSamplesBase[1]); 
		    break;
	    }

	    //#######bits/samples
	    if( ppwfx [0]->nChannels	==2		&& 
		ppwfx [1]->nChannels	==2		&&
		ppwfx[0]->nSamplesPerSec == 32000)
	    {
		//if both stereo audio, 32K is required
		pDVInfo->dwDVAAuxSrc  |= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_QU12);
	    	pDVInfo->dwDVAAuxSrc1 |= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_QU12);
	    }
	    else if(ppwfx[1]->nChannels	==1		&& 
		    ppwfx[0]->nChannels	==2		&&
		    ppwfx[0]->nSamplesPerSec    == 32000
		   ) 
	    {
		//if one is stereo audio, 32K is required
		pDVInfo->dwDVAAuxSrc	|= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_QU12);
		pDVInfo->dwDVAAuxSrc1	|= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE1 | AM_DV_AUDIO_QU12 );
	    }
	    else if(ppwfx[0]->nChannels	==1		&& 
		    ppwfx[1]->nChannels	==2		&&
		    ppwfx[0]->nSamplesPerSec    == 32000
		   ) 
	    {
		//if one is stereo audio, 32K is required
		pDVInfo->dwDVAAuxSrc1	|= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_QU12);
		pDVInfo->dwDVAAuxSrc	|= (AM_DV_AUDIO_CHN2 | AM_DV_AUDIO_MODE1 | AM_DV_AUDIO_QU12 );
	    }
	    else if(ppwfx[0]->nChannels	==1		&& 
		    ppwfx[1]->nChannels	==1		
		    )
	    {
		pDVInfo->dwDVAAuxSrc	|= ( AM_DV_AUDIO_MODE2 | AM_DV_AUDIO_QU16 );
		pDVInfo->dwDVAAuxSrc1	|= ( AM_DV_AUDIO_MODE2 | AM_DV_AUDIO_QU16 );
	    }
	    else
            {
		ASSERT(0);
                return E_INVALIDARG; 
            }
	    break;

        default:
            ASSERT(0);
	    return E_INVALIDARG;
    } //switch ( cnt )

    return NOERROR;
}   //end BuildDVINFO()

//IMediaSeeking
HRESULT CDVMuxer::IsFormatSupported(const GUID * pFormat)
{
  return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE;
}

HRESULT CDVMuxer::QueryPreferredFormat(GUID *pFormat)
{
  *pFormat = TIME_FORMAT_MEDIA_TIME;
  return S_OK;
}

HRESULT CDVMuxer::SetTimeFormat(const GUID * pFormat)
{
  HRESULT hr = S_OK;
  if(*pFormat == TIME_FORMAT_MEDIA_TIME)
    m_TimeFormat = FORMAT_TIME;

  return hr;
}

HRESULT CDVMuxer::IsUsingTimeFormat(const GUID * pFormat)
{
  HRESULT hr = S_OK;
  if (m_TimeFormat == FORMAT_TIME && *pFormat == TIME_FORMAT_MEDIA_TIME)
    ;
  else
    hr = S_FALSE;

  return hr;
}

HRESULT CDVMuxer::GetTimeFormat(GUID *pFormat)
{
  *pFormat = TIME_FORMAT_MEDIA_TIME ;

  return S_OK;
}

HRESULT CDVMuxer::GetDuration(LONGLONG *pDuration)
{
  HRESULT hr = S_OK;
  CAutoLock lock(&m_csFilter);

  if(m_TimeFormat == FORMAT_TIME)
  {
    *pDuration = 0;
    for(int i = 0; i < m_iInputPinCount; i++)
    {

      if(m_apInputPin[i]->IsConnected())
      {
        IPin *pPinUpstream;
        if(m_apInputPin[i]->ConnectedTo(&pPinUpstream) == S_OK)
        {
          IMediaSeeking *pIms;
          hr = pPinUpstream->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
          if(SUCCEEDED(hr))
          {
            LONGLONG dur = 0;
	    LONGLONG stop = 0;
            hr = pIms->GetPositions(&dur, &stop);

            if(SUCCEEDED(hr))
              *pDuration = max(stop, *pDuration);

            pIms->Release();
          }

          pPinUpstream->Release();
        }
      }

      if(FAILED(hr))
        break;
    }
  }
  else
  {
    *pDuration = 0;
    return E_UNEXPECTED;
  }

  return hr;
}

HRESULT CDVMuxer::GetStopPosition(LONGLONG *pStop)
{
  return E_NOTIMPL;
}

HRESULT CDVMuxer::GetCurrentPosition(LONGLONG *pCurrent)
{
  CheckPointer(pCurrent, E_POINTER);

  if(m_TimeFormat == FORMAT_TIME)
      *pCurrent = m_LastVidTime;
    
  return S_OK;
}

HRESULT CDVMuxer::GetCapabilities( DWORD * pCapabilities )
{
  CAutoLock lock(&m_csFilter);
  *pCapabilities = 0;

  // for the time format, we can get a duration by asking the upstream
  // filters
  if(m_TimeFormat == FORMAT_TIME)
  {
    *pCapabilities |= AM_SEEKING_CanGetDuration;
    for(int i = 0; i < m_iInputPinCount; i++)
    {
      if(m_apInputPin[i]->IsConnected())
      {
        IPin *pPinUpstream;
        if(m_apInputPin[i]->ConnectedTo(&pPinUpstream) == S_OK)
        {
          IMediaSeeking *pIms;
          HRESULT hr = pPinUpstream->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
          if(SUCCEEDED(hr))
          {
            hr = pIms->CheckCapabilities(pCapabilities);
            pIms->Release();
          }

          pPinUpstream->Release();
        }
      }
    }
  }

  // we always know the current position
  *pCapabilities |= AM_SEEKING_CanGetCurrentPos ;

  return S_OK;
}

HRESULT CDVMuxer::CheckCapabilities( DWORD * pCapabilities )
{
  DWORD dwMask = 0;
  GetCapabilities(&dwMask);
  *pCapabilities &= dwMask;

  return S_OK;
}


HRESULT CDVMuxer::ConvertTimeFormat(
  LONGLONG * pTarget, const GUID * pTargetFormat,
  LONGLONG    Source, const GUID * pSourceFormat )
{
  return E_NOTIMPL;
}


HRESULT CDVMuxer::SetPositions(
  LONGLONG * pCurrent,  DWORD CurrentFlags,
  LONGLONG * pStop,  DWORD StopFlags )
{
  // not yet implemented. this might be how we append to a file. and
  // how we write less than an entire file.
  return E_NOTIMPL;
}


HRESULT CDVMuxer::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
  HRESULT hr;
  if( pCurrent )
    *pCurrent = m_LastVidTime;
  
  hr=GetDuration( pStop);
  
  return hr;
}

HRESULT CDVMuxer::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
  return E_NOTIMPL;
}

HRESULT CDVMuxer::SetRate( double dRate)
{
  return E_NOTIMPL;
}

HRESULT CDVMuxer::GetRate( double * pdRate)
{
  return E_NOTIMPL;
}

HRESULT CDVMuxer::GetPreroll(LONGLONG *pPreroll)
{
  return E_NOTIMPL;
}

//
// NonDelegatingQueryInterface
//
//
STDMETHODIMP
CDVMuxer::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
  if(riid == IID_IMediaSeeking)
  {
    return GetInterface((IMediaSeeking *)this, ppv);
  }
  else
  {
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvmux\resource.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by property.rc
//
//#define VERSION_RES_MINOR_VER           0
//#define VERSION_RES_BUILD               0
//#define VER_DEBUG                       0
//#define VERSION_RES_MAJOR_VER           3
#define IDS_DVMUXER_TITLE               3
#define IDD_DVMUX                       300
#define IDC_DVMUX_VIDFORMAT             3022
#define IDC_DVMUX_NTSC                  3023
#define IDC_DVMUX_PAL                   3024
#define IDC_DVMUX_DVFORMAT              3026
#define IDC_DVMUX_DVSD                  3027
#define IDC_DVMUX_DVHD                  3028
#define IDC_DVMUX_DVSL                  3029
//#define VERSION_RES_LANGUAGE            0x409
//#define VERSION_RES_CHARSET             3252
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvmux\dvmux.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __DVDVMuxer__
#define __DVDVMuxer__

#include <dv.h>



#define Waiting_Audio  0xfffffff6


#define AM_DV_AUDIO_AFSIZE		0x3f
#define AM_DV_AUDIO_LF			0x80       // bit set ==> audio is NOT locked
#define AM_DV_AUDIO_MODE		0x0f00
#define AM_DV_AUDIO_MODE0		0x0000
#define AM_DV_AUDIO_MODE1		0x0100
#define AM_DV_AUDIO_MODE2		0x0200
#define AM_DV_AUDIO_NO_AUDIO		0x0f00
#define AM_DV_AUDIO_PA			0x1000
#define AM_DV_AUDIO_CHN1		0x0000
#define AM_DV_AUDIO_CHN2		0x2000
#define AM_DV_AUDIO_SM			0x8000
#define AM_DV_AUDIO_QU			0x07000000

//#define AM_DV_AUDIO_STYPE		0x8000
#define AM_DV_AUDIO_ML			0x400000    //bit set means NO multiple language
#define AM_DV_AUDIO_SMP48		0x0
#define AM_DV_AUDIO_SMP44		0x08000000
#define AM_DV_AUDIO_SMP32		0x10000000
#define AM_DV_AUDIO_QU16		0x0
#define AM_DV_AUDIO_QU12		0x01000000
#define AM_DV_AUDIO_QU20		0x02000000

#define AM_DV_AUDIO_EF			0xc0000000  //EF: off: TC: 50/15us
#define AM_DV_AUDIO_5060		0x00200000


//AUDIO source control
// Note: Speed must be set to 0x78 to record to DVCPro NTSC and 0x64 to record to DVCPro PAL
// MSDV does this.
#define AM_DV_DEFAULT_AAUX_CTL		0xffa0cf3f	
//					   | | | |---no info. about 1.src and recorded situation 2.num. of times of compress 3. input src of just previus recording
//					   | | |---1>no info. about insert ch, 2> original recording mode 3. not recording start point 4. not recording end point 
//					   | |--forward direction (1 bit - MSB), normal playback speed (7 bits = 0x40)
//					   |--no info. about the category fo the audio src
#define AM_DV_DEFAULT_AAUX_SRC		0x00800f40

#define AM_DV_DEFAULT_VAUX_SRC		0xff80ffff
#define AM_DV_DEFAULT_VAUX_CTL		0xfffcc83f
#define AM_DV_AAUX_CTL_IVALID_RECORD	0x3800	//recodrede auduio data are not cared


class CAudioSampleSizeSequence;

HRESULT BuildDVINFO(DVINFO *pDVInfo, WAVEFORMATEX **ppwfx, LPBITMAPINFOHEADER lpbi, 
		    int cnt, 
                    CAudioSampleSizeSequence* pAudSampleSequence,
                    WORD *wpMinAudSamples, WORD *rMaxAudSamples,
                    WORD *wpAudSamplesBase);


extern const AMOVIESETUP_FILTER sudDVMux;

#define DVMUX_AUDIO_DEFAULT	0xffffffff

#define DVMUX_MAX_AUDIO_SAMPLES 3
#define DVMUX_VIDEO_INPUT_PIN 0
#define DVMUX_MAX_AUDIO_PIN  2



// We export this:
class CDVMuxer;
class CDVMuxerInputPin;
class CDVMuxerOutputPin;

// ==================================================
// Implements the input pins
// ==================================================

class CDVMuxerInputPin : public CBaseInputPin
{
    friend class CDVMuxer;

    // owning DV DVMuxerer
protected:
    CDVMuxer *m_pDVMuxer;
    IMemAllocator *m_pLocalAllocator;

public:
    CDVMuxerInputPin(
        TCHAR *pObjectName,
        CBaseFilter *pBaseFilter,
        CDVMuxer *pTransformFilter,
        HRESULT * phr,
        LPCWSTR pName,
        int iPinNo);

    ~CDVMuxerInputPin();

    // check that we can support this output type
    HRESULT CheckMediaType(const CMediaType* mtIn);

    HRESULT CompleteConnect(IPin *pReceivePin);
    STDMETHODIMP Disconnect();

    // set the connection media type
    HRESULT SetMediaType(const CMediaType *pmt);

    // upstream filter get media type
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    //use video input pin's allocator 
    STDMETHODIMP NotifyAllocator (IMemAllocator *pAllocator, BOOL bReadOnly);

    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);


    // --- IMemInputPin -----

    // here's the next block of data from the stream.
    STDMETHODIMP Receive(IMediaSample * pSample);

    // provide EndOfStream
    STDMETHODIMP EndOfStream(void);

    // passes it to CDVMuxer::BeginFlush
    STDMETHODIMP BeginFlush(void);

    // passes it to CDVMuxer::EndFlush
    STDMETHODIMP EndFlush(void);

    
    // Called when the stream goes active
    HRESULT Active(void);
    HRESULT Inactive(void);
    
    // The samples are held in a First in, First Out queue.
    // They are expected to arrive in order
protected:
    CGenericList<IMediaSample> m_SampleList;

    //HRESULT Copy(  IMediaSample *pDest,  IMediaSample *pSource);

    // Sample access procedures
public:
    // Is there a sample available?
    BOOL SampleReady( int n );

    // Gets the first sample in the queue
    IMediaSample *GetNthSample( int n );

    //X Releases n samples
    void ReleaseNSample( int n );

    // Releases all samples before a certain time
    //void ReleaseAllBefore( CRefTime rtTime );

    // Media type
public:
    CMediaType& CurrentMediaType() { return m_mt; };

    // Connected pin
public:
    IPin *	CurrentPeer() { return m_Connected; };

   // Attributes
protected:
    int	    m_iPinNo;             // Identifying number of this pin
    int	    m_PinVidFrmCnt ;
    BOOL    m_fCpyAud;
    CCritSec m_csReceive;           // input wide receive lock
    
public:
    BOOL    m_fEOSReceived;            // Received an EOS yet?


};

// ==================================================
// Implements the output pin
// ==================================================

class CDVMuxerOutputPin : public CBaseOutputPin
{
    //const int m_iOutputPin;             // CDVMuxer's identifier for this pin
    friend class CDVMuxer;

    // Owning DV DVMuxerer
protected:
    CDVMuxer *m_pDVMuxer;

public:

    CDVMuxerOutputPin(
        TCHAR *pObjectName,
        CBaseFilter *pBaseFilter,
        CDVMuxer *pTransformFilter,
        HRESULT * phr,
        LPCWSTR pName);

    ~CDVMuxerOutputPin();

    // --- CBaseOutputPin ------------

    // check that we can support this output type
    HRESULT CheckMediaType(const CMediaType* mtOut);

    // set the connection media type
    HRESULT SetMediaType(const CMediaType *pmt);

    // get  media type
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // called from CBaseOutputPin during connection to ask for
    // the count and size of buffers we need.
    HRESULT DecideBufferSize (IMemAllocator *pMemAllocator,
                                         ALLOCATOR_PROPERTIES * pProp);
        
    // Media type
public:
    CMediaType& CurrentMediaType() { return m_mt; };

    // Connected pin
public:
    IPin *	CurrentPeer() { return m_Connected; };

};


// Helper for locked audio, designed with the intent of minimizing 
// changes to the existing code to add the audio lock feature.

class CAudioSampleSizeSequence 
{
public:
    CAudioSampleSizeSequence() : m_nCurrent(0), m_nSequenceSize(0) {}

    // rMin, rMax set to min, max audio samples for first DV frame.
    // rBase has the value that must be added to the AF_SIZE field.
    // Init should be called after a format change and before the 
    // first DV frame is delivered with the new format.
    void Init(BOOL bLocked, BOOL bNTSC, DWORD nSamplingFrequency,
              WORD& rMin, WORD& rMax, WORD& rBase);


    // Called after each frame is delivered. Sets the min/max audio 
    // samples for the next DV frame.
    void Advance(WORD& rMin, WORD& rMax);

    // Called to reset counter to 1, typically on restarting the graph.
    // Same as Init except that only rMin and rMax have to be changed
    // and there is no need to supply the other input arguments.
    void Reset(WORD& rMin, WORD& rMax);

private:
    DWORD   m_nCurrent;
    DWORD   m_nSequenceSize;
};

/*
 * Define our DV DVMuxerer
 */

class CDVMuxer  :   public CBaseFilter,
		    public IMediaSeeking

{
    friend class CDVMuxerInputPin;
    friend class CDVMuxerOutputPin;

public:

    HRESULT InitDVInfo();


    //
    // --- COM Stuff ---
    //

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
  

    // Have we connected all input and output pins
    virtual HRESULT CanChangeState();

    // map getpin/getpincount for base enum of pins to owner
    // override this to return more specialised pin objects
    virtual int GetPinCount();
    virtual CBasePin * GetPin(int n);

    // override state changes to allow derived filters
    // to control streaming start/stop
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    // IMediaSeeking. currently used for a progress bar (how much have
      // we written?)
    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );

    STDMETHODIMP ConvertTimeFormat(
	LONGLONG * pTarget, const GUID * pTargetFormat,
	LONGLONG    Source, const GUID * pSourceFormat );

    STDMETHODIMP SetPositions(
	LONGLONG * pCurrent,  DWORD CurrentFlags,
	LONGLONG * pStop,  DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll);

 	// Construction / destruction
public:
    CDVMuxer(TCHAR *, LPUNKNOWN, CLSID clsid, HRESULT * );
    ~CDVMuxer();

// Definitions
protected:
    
    // DVMuxer dv video with audio and add AUX blocks  and header block
    HRESULT DVMuxerSamples( IMediaSample *pSampleOut ) ;

    // check if you can support this format
    HRESULT CanDVMuxerType(const CMediaType* mtIn) ;

    // create input video and audio pin
    virtual HRESULT CreatePins();

    // =================================================================
    // ----- End of DV DVMuxerer supplied functions -----------------------
    // =================================================================
    
    // contril streaming
    virtual HRESULT StartStreaming();
    virtual HRESULT StopStreaming();

    HRESULT DeliverEndOfStream();

    // chance to customize the DVMuxer process
    virtual HRESULT Receive( void );

    // Stream flushing
    virtual HRESULT BeginFlush(void);
    virtual HRESULT EndFlush(void);
    virtual HRESULT ReleaseAllQueuedSamples( void );

    HRESULT pExVidSample(   IMediaSample ** ppSample , BOOL fEndOfStream);

    // Critical sections
protected:
    CCritSec m_csFilter;                // filter wide lock
    CCritSec m_csMuxLock;               // mix lock
    CCritSec m_DisplayLock;

    // Pins
protected:
    int m_iInputPinCount;               // number of input pins
    int m_iInputPinsConnected;          // number connected
    CDVMuxerInputPin **m_apInput;// Array of input pin pointers
    CDVMuxerInputPin **m_apInputPin;// Array of input pin pointers
    CDVMuxerOutputPin *m_pOutput;// output pin

    // When do we send an end of stream signal?
protected:
	//DVmux only stop when the DV video input pin stop
	//   enum { StopWhenAllPinsStop, StopWhenFirstPinStops } m_StopMode;
    BOOL m_fEOSSent;

    // Current frame that we are working on
protected:
    //CRefTime    m_rtThisFrame;          // when will we mix?
    //CRefTime    m_rtNextFrame;          // this frame stop/next frame start

    // implement IMediaPosition by passing upstream
//protected:
    //CMultiPinPosPassThru * m_pPosition;
    //
    // --- CBaseVideoMixer Overrides --
    //

protected:
    HRESULT MixSamples( IMediaSample *pSampleOut );

private:
    enum TimeFormat
    {
	FORMAT_TIME
    } m_TimeFormat;


    CAudioSampleSizeSequence m_AudSampleSequence[DVMUX_MAX_AUDIO_PIN];

    WORD m_wMinAudSamples[DVMUX_MAX_AUDIO_PIN]; 
                // Min audio samples needed in current DV frame
    WORD m_wMaxAudSamples[DVMUX_MAX_AUDIO_PIN]; 
                // Max audio samples allowed in current DV frame
    WORD m_wAudSamplesBase[DVMUX_MAX_AUDIO_PIN];
                // The value added to the AF_SIZE field in the AAUX source pack to get the number of
                // audio samples in a DV frame

    CRefTime		m_LastVidTime;
    REFERENCE_TIME	m_LastVidMediatime;
    IMediaSample	*m_pLastVidSample;

    DVINFO		m_OutputDVFormat;


    LONG m_UsedAudSample[DVMUX_MAX_AUDIO_PIN];
		
    //shuffle audio
    HRESULT ScrambleAudio(BYTE *pDst, BYTE **pSrc, int  bAudPinInd, WORD *wSampleSize );

    	
    //input DV video has to be connected before muxing with audio
    BYTE    InputVideoConnected( void ) { if( m_apInput[DVMUX_VIDEO_INPUT_PIN] !=NULL ) return (BYTE)m_apInput[DVMUX_VIDEO_INPUT_PIN]->IsConnected(); else return NULL;};
    
    int	    m_iVideoFormat;


    BYTE    m_fWaiting_Audio;
    BYTE    m_fWaiting_Video;
    BYTE    m_fMuxStreaming;
    IMediaSample    *m_pExVidSample;
    BOOL    m_MediaTypeChanged;
    BOOL    m_DVINFOChanged; 
    DWORD   m_cNTSCSample;
    
};

#endif /* __DVDVMuxer__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvsp\dvsp.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


#ifndef __DVSP__
#define __DVSP__

#include <dv.h>

extern const AMOVIESETUP_FILTER sudDVSplit;


#define SMCHN		0x0000e000
#define AUDIOMODE	0x00000f00
#define AUDIO5060	0x00200000
#define AUDIOSMP	0x38000000
#define AUDIOQU		0x07000000
#define	NTSC525_60	0
#define	PAL625_50	1

#define DVSP_INPIN		0
#define DVSP_VIDOUTPIN	1
#define DVSP_AUDOUTPIN1 2
#define DVSP_AUDOUTPIN2 3

#define VIDEO_OUTPIN	0
#define AUDIO_OUTPIN1	1
#define AUDIO_OUTPIN2	2

//----------------------------------------------------------------------------
// forward reference to classes defined later
//----------------------------------------------------------------------------

class CDVSp ;
class CDVSpOutputPin ;

//----------------------------------------------------------------------------
// CDVspInputPin. class for the DVSpliter filter's Input pin.
//----------------------------------------------------------------------------
class CDVSpInputPin : public CBaseInputPin
{
    friend class CDVSpOutputPin ;
    friend class CDVSp ;

public:
    // constructor and destructor
    CDVSpInputPin (TCHAR *pObjName, CDVSp *pDVsp, HRESULT *phr, LPCWSTR pPinName) ;
    ~CDVSpInputPin () ;

    // Used to check the input pin connection
    HRESULT CheckMediaType (const CMediaType *pmt) ;
    HRESULT SetMediaType (const CMediaType *pmt) ;
    HRESULT BreakConnect () ;
    STDMETHODIMP NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop,
                    					double dRate);
    // reconnect outputs if necessary at end of completion
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);
    STDMETHODIMP NotifyAllocator (IMemAllocator *pAllocator, BOOL bReadOnly);

    // pass throughs
    STDMETHODIMP EndOfStream () ;
    STDMETHODIMP BeginFlush () ;
    STDMETHODIMP EndFlush () ;

    // handles the next block of data from the stream
    STDMETHODIMP Receive (IMediaSample *pSample) ;

   	
private:
    void  DetectChanges(IMediaSample *pSample);
    CDVSp *m_pDVSp ;                 // ptr to the owner filter class
    BOOL m_bDroppedLastFrame;

} ;


//----------------------------------------------------------------------------
// CTeeOutputPin. class for the Tee filter's Output pins.
//----------------------------------------------------------------------------
class CDVSpOutputPin : public CBaseOutputPin
{
    friend class CDVSpInputPin ;
    friend class CDVSp ;

    DWORD		m_AudAvgBytesPerSec;

    CDVSp		*m_pDVSp ;                  // ptr to the owner filter class
    CPosPassThru	*m_pPosition ;     // pass seek calls upstream
    BOOL		m_bHoldsSeek ;             // is this the one seekable stream
    COutputQueue	*m_pOutputQueue;

public:

    // constructor and destructor
    CDVSpOutputPin (TCHAR *pObjName, 
			CDVSp *pDVSp, 
			HRESULT *phr, 
			LPCWSTR pPinName);

    ~CDVSpOutputPin () ;

    // Override to expose IMediaPosition
    STDMETHODIMP NonDelegatingQueryInterface (REFIID riid, void **ppvoid) ;

    // Override since the life time of pins and filters are not the same.
    STDMETHODIMP_(ULONG) NonDelegatingAddRef(){
	  return CUnknown::NonDelegatingAddRef(); 
    };
    STDMETHODIMP_(ULONG) NonDelegatingRelease(){
	  return CUnknown::NonDelegatingRelease(); 
    };

    HRESULT DeliverNewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    // Check that we can support an output type
    HRESULT CheckMediaType (const CMediaType *pmt) ; 
    HRESULT SetMediaType (const CMediaType *pmt) ;
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);
    
    // Negotiation to use our input pins allocator
    HRESULT DecideAllocator (IMemInputPin *pPin, IMemAllocator **ppAlloc) ;
    HRESULT DecideBufferSize (IMemAllocator *pMemAllocator,
                              ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Used to create output queue objects
    HRESULT Active () ;
    HRESULT Inactive () ;

    
    inline DWORD GetAudAvgBytesPerSec(){return m_AudAvgBytesPerSec; };
    inline void  PutAudAvgBytesPerSec(DWORD x){ m_AudAvgBytesPerSec=x;};
};

//----------------------------------------------------------------------------
// CDVSp. class for the DV splitter filter
//----------------------------------------------------------------------------

class CDVSp: public CCritSec, public CBaseFilter, public IDVSplitter
{
    // let the pins access our internal state.
    friend class CDVSpInputPin ;
    friend class CDVSpOutputPin ;
    friend class CDVPosPassThru ;

public:
    CDVSp (TCHAR *pName, LPUNKNOWN pUnk, HRESULT *hr) ; // constructore
    ~CDVSp() ;						// destructor

    // CBaseFilter override
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();

    /*  Send EndOfStream downstream */
    void    EndOfStream();

    /*  Send BeginFlush() downstream */
    HRESULT BeginFlush();

    /*  Send EndFlush() downstream */
    HRESULT EndFlush();


    CBasePin *GetPin (int n) ;                         // gets a pin ptr
    //CDVSpOutputPin	*GetPin (int n) ;
    int GetPinCount () ;                               // rets # pins.


    // function needed for the class factory
    static CUnknown *CreateInstance (LPUNKNOWN pUnk, HRESULT *phr) ;

    HRESULT NotifyInputConnected();
    HRESULT CreateOrReconnectOutputPins();
    HRESULT RemoveOutputPins();
   
    HRESULT DeliveVideo(IMediaSample *pSample); 
    HRESULT DecodeDeliveAudio(IMediaSample *pSample); 
    HRESULT DescrambleAudio(BYTE *pDst, BYTE *pSrc, BYTE bAudPinInd, WORD wSampleSize);
    HRESULT CheckState();
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *pfs);

public:
    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // IDVSplitter method
    STDMETHODIMP DiscardAlternateVideoFrames(int nDiscard);

protected:

   
    HRESULT InsertSilence(IMediaSample *pOutSample,
                                REFERENCE_TIME rtStart,
                                REFERENCE_TIME rtStop,
                                long lActualDataLen,
                                CDVSpOutputPin *pAudOutPin);

    // Flag to denote that we haven't seen the first good frame yet.
    // this to help capture scenario involving AVI Mux (which doesn't handle dynamic format changes)
    BOOL            m_bNotSeenFirstValidFrameFlag;

    // This flag will propogate a Media type downstream even if we were stopped
    // during the middle of a dynamic format change.
    BOOL            m_bFirstValidSampleSinceStartedStreaming;

private:
    CCritSec    m_csReceive;

    // declare a input pin.
    CDVSpInputPin	m_Input ;

    DVINFO		m_LastInputFormat;

    DVAudInfo		m_sDVAudInfo;

    // declare a list to keep a list of all the output pins.
    INT m_NumOutputPins ;
    INT m_AudioStarted ;
    inline void CleanAudioStarted(){ m_AudioStarted=0;};
    //inline CDVSpOutputPin *CDVSp::GetAudOutputPin();
    typedef CGenericList <CDVSpOutputPin> COutputList ;
    //COutputList m_OutputPinsList ;
    INT m_NextOutputPinNumber ;     // increases monotonically.

    // other assorted data members.
    volatile LONG	    m_lCanSeek ;               // seekable output pin (only one is..)
    IMemAllocator   *m_pAllocator ;   // Allocator from our input pin

   
    //X* for quick delive audio and video
    CDVSpOutputPin  *m_pVidOutputPin;
    CDVSpOutputPin  *m_pAudOutputPin[2];
    
    //HRESULT	    DeliveLastAudio();
    IMediaSample    *m_pAudOutSample[2];
    BYTE	    m_MuteAud[2];
    BYTE	    m_Mute1stAud[2];
    //X* de-scramble audio sample stamp
    CRefTime	    m_tStopPrev;

    // To support a video output of 15 fps
    BOOL m_b15FramesPerSec;
    BOOL m_bDeliverNextFrame;
} ;

//----------------------------------------------------------------------------
// CDVPosPassThru
//----------------------------------------------------------------------------
class CDVPosPassThru : public CPosPassThru
{
    friend class CDVSp ;
    CDVSp	*m_pPasDVSp ;                  // ptr to the owner filter class
    
public:
    CDVPosPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *, CDVSp *);
    ~CDVPosPassThru() ;											// destructor
    STDMETHODIMP SetPositions( LONGLONG * pCurrent,  DWORD CurrentFlags
			     , LONGLONG * pStop,  DWORD StopFlags );
};

#endif // DVST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dvdgb\dvdgb.cpp ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

#include <streams.h>
#include <vfwmsgs.h>

#ifdef FILTER_DLL
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#endif

#include <dvdmedia.h>
#include <il21dec.h>
#include "dvdgb.h"

// setup data

#ifdef FILTER_DLL
// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = {
    { L"DVD Graph Builder"
		, &CLSID_DvdGraphBuilder
		, CDvdGraphBuilder::CreateInstance
		, NULL
		, NULL }    // self-registering info
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}
#endif


CDvdGraphBuilder::CDvdGraphBuilder(TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr)
: CUnknown(pName, pUnk),
m_pGB(NULL),
m_Decoders(),
m_pDVDSrc(NULL),
m_pDVDNav(NULL),
m_pVR(NULL),
m_pAR(NULL),
m_pVM(NULL),
m_pL21Dec(NULL),
m_bGraphDone(FALSE),
m_bUseVPE(TRUE),
m_dwVideoRenderStatus(0),
m_pL21PinToRender(NULL),
m_pSPPinToRender(NULL)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::CDvdGraphBuilder()"))) ;

    *phr = CreateGraph() ;
    ZeroMemory(m_achwPathName, MAX_PATH * sizeof(m_achwPathName[0])) ;
}


CDvdGraphBuilder::~CDvdGraphBuilder()
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::~CDvdGraphBuilder() entering"))) ;
	
    // If we have a graph object
    if (m_pGB)
    {
        StopGraph() ;  // make sure the graph is REALYY stopped
		
        // Break the connections and remove all the filters we added from the graph
        ClearGraph() ;
		
        m_pGB->Release() ;  // free it
        m_pGB = NULL ;
    }
	
#if 0
    //
    // Get a list of decoders in use in the graph and release them.
    // Then free the memory for the list of decoders.
    //
    IBaseFilter *pDecList ;
    int n = m_Decoders.GetList(&pDecList) ;
    for (int i = 0 ; i < n ; n++)
        (pDecList + i)->Release() ;
    if (pDecList)
        CoTaskMemFree(pDecList) ;
#endif // #if 0
	
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::~CDvdGraphBuilder() ending"))) ;
}


void CDvdGraphBuilder::StopGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::StopGraph()"))) ;
	
    // Just paranoia
    if (NULL == m_pGB)
    {
        ASSERT(FALSE) ;  // so that we know
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: How are we doing a Stop w/o a graph???"))) ;
        return ;
    }
	
    //
    // Check that the graph has stopped; otherwise stop it here. Because a 
    // playing graph can't be cleaned up or rebuilt.
    //
    IMediaControl  *pMC ;
    LONG            lState ;
    HRESULT hr = m_pGB->QueryInterface(IID_IMediaControl, (LPVOID *)&pMC) ;
    ASSERT(SUCCEEDED(hr) && pMC) ;
    pMC->GetState(INFINITE, &lState) ;
    if (State_Stopped != lState)
    {
        hr = pMC->Stop() ;
        ASSERT(SUCCEEDED(hr)) ;
        while (State_Stopped != lState)
        {
            Sleep(10) ;
            hr = pMC->GetState(INFINITE, &lState) ;
            ASSERT(SUCCEEDED(hr)) ;
        }
    }
    pMC->Release() ;
    DbgLog((LOG_TRACE, 4, TEXT("DVD-Video playback graph has stopped"))) ;
}


STDMETHODIMP CDvdGraphBuilder::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::NonDelegatingQueryInterface()"))) ;
    if (ppv)
        *ppv = NULL;
	
    if (riid == IID_IDvdGraphBuilder) 
    {
        DbgLog((LOG_TRACE, 4, TEXT("QI for IDvdGraphBuilder"))) ;
        return GetInterface((IDvdGraphBuilder *) this, ppv) ;
    } 
    else // more interfaces
    {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv) ;
    }
}


// this goes in the factory template table to create new instances
CUnknown * CDvdGraphBuilder::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CDvdGraphBuilder(TEXT("DVD Graph Builder"), pUnk, phr) ;
}



///////////////////////
// IDvdGraphBuilder stuff
///////////////////////

#if 0
//
// Use my filtergraph to build your DVD playback graph
//
HRESULT CDvdGraphBuilder::SetFiltergraph(IGraphBuilder *pGB)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::SetFiltergraph(0x%lx)"), pGB)) ;
	
    if (m_pGB)    // we already have a graph
        return E_UNEXPECTED ;  // no thanks.
	
    if (pGB == NULL)
        return E_POINTER ;
	
    m_pGB = pGB ;
    m_pGB->AddRef() ;   // we own a copy now
	
    //
    // If we want to bother about the filters that might have been added to the
    // passed in filter graph, we could enumerated and list them.  But ignore that
    // for now at least.
    //
	
    return NOERROR ;
}
#endif // #if 0

//
// What filtergraph is graph building being done in?
//
HRESULT CDvdGraphBuilder::GetFiltergraph(IGraphBuilder **ppGB)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::GetFiltergraph(0x%lx)"), ppGB)) ;
	
    if (ppGB == NULL)
        return E_POINTER ;
	
#if 0
    EnsureGraphExists() ;
#endif // #if 0
	
    *ppGB = m_pGB ;
    if (NULL == m_pGB) 
    {
        return E_UNEXPECTED ;
    }
    m_pGB->AddRef() ;   // app owns a copy now
    return NOERROR ;
}


#if 0  // NOT for now
//
// Set DVD source specification
//
HRESULT CDvdGraphBuilder::SetDvdSourceFilter(IBaseFilter *pDVDSrc, LPCWSTR lpszwSrcName)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::SetDvdSourceFilter(0x%lx, 0x%lx)"), 
		ppGB, lpszwSrcName)) ;
    BOOL   bGraphDone = m_bGraphDone ;
	
    // if (m_pDVDSrc)  // some DVD source filter was specified -- remove it
    //     m_pGB->RemoveFilter(m_pDVDSrc) ;
	
    HRESULT hr ;
#if 0
    hr = EnsureGraphExists() ;
    if (FAILED(hr))
        return hr ;
#endif
	
    if (bGraphDone)  // if graph was built before then rebuild it
    {
        ClearGraph() ;
        // Also need to unload all the decoders currently loaded
        // m_Decoders.CleanAll() ; -- should be covered by ClearGraph()
    }
	
    if (pDVDSrc)    // a new DVD source filter is specified -- add it
        m_pGB->AddFilter(pDVDSrc, lpszwSrcName) ;
	
    m_pDVDSrc = pDVDSrc ;  // this is the new DVD source (or NULL for default)
	
    if (bGraphDone)  // if graph was built then indicate rebuild needed
    {
        return VFW_S_DVD_NEEDREBUILD ;
    }
	
    // Otherwise we are done for now
	
    return NOERROR ;
}
#endif // #if 0


//
// Get a specified interface off of a filter in the DVD playback graph
//
HRESULT CDvdGraphBuilder::GetDvdInterface(REFIID riid, void **ppvIF)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::GetDvdInterface(%s, 0x%lx)"),
        (LPCSTR)CDisp(riid), ppvIF)) ;
	
    if (IsBadWritePtr(ppvIF, sizeof(LPVOID)))
        return E_INVALIDARG ;
    *ppvIF =  NULL ;
	
    // We can't return any of the internal filter interface pointers before
    // building the whole graph.
    if (! m_bGraphDone )
        return VFW_E_DVD_GRAPHNOTREADY ;
	
    if (IID_IDvdControl == riid)
    {
        if (m_pDVDSrc)  // if user specified DVD source
            return m_pDVDSrc->QueryInterface(IID_IDvdControl, (LPVOID *)ppvIF) ;
        else            // if using default DVD source -- our Nav
            return m_pDVDNav->QueryInterface(IID_IDvdControl, (LPVOID *)ppvIF) ;
    }
    else if (IID_IDvdInfo == riid)
    {
        if (m_pDVDSrc)  // if user specified DVD source
            return m_pDVDSrc->QueryInterface(IID_IDvdInfo, (LPVOID *)ppvIF) ;
        else            // if using default DVD source -- our Nav
            return m_pDVDNav->QueryInterface(IID_IDvdInfo, (LPVOID *)ppvIF) ;
    }
    else if (IID_IVideoWindow == riid)
    {
        if (m_pVR)
            return m_pGB->QueryInterface(IID_IVideoWindow, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else if (IID_IBasicVideo == riid)
    {
        if (m_pVR)
            return m_pVR->QueryInterface(IID_IBasicVideo, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else if (IID_IBasicAudio == riid)
    {
        if (m_pAR)
            return m_pAR->QueryInterface(IID_IBasicAudio, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else if (IID_IAMLine21Decoder == riid)
    {
        if (m_pL21Dec)
            return m_pL21Dec->QueryInterface(IID_IAMLine21Decoder, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else
        return E_NOINTERFACE ;
}


#define DVDGRAPH_FLAGSVALIDDEC    0x000000FF

#define DVDMG_HWDEC_NOTFOUND      0x01
#define DVDMG_SWDEC_NOTFOUND      0x02

//
// Build the whole graph for playing back the specifed or default DVD volume
//
HRESULT CDvdGraphBuilder::RenderDvdVideoVolume(LPCWSTR lpcwszPathName, DWORD dwFlags,
                                               AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::RenderDvdVideoVolume(0x%lx, 0x%lx, 0x%lx)"),
		lpcwszPathName, dwFlags, pStatus)) ;
	
    HRESULT    hr ;
	
#if 0
    hr = EnsureGraphExists() ;  // make sure that a graph exists; if not create one
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't create a filter graph object"))) ;
        return hr ;
    }
#endif // #if 0
	
    if (m_bGraphDone)  // if graph was built before,
        StopGraph() ;  // just make sure the graph is in Stopped state first
	
    ZeroMemory(pStatus, sizeof(AM_DVD_RENDERSTATUS)) ;  // clear status
    m_bUseVPE = (0 == (dwFlags & AM_DVD_NOVPE)) ;       // is VPE needed?
	
    if (0 == (dwFlags & DVDGRAPH_FLAGSVALIDDEC)) // 0 by default means HW max
    {
        DbgLog((LOG_TRACE, 3, TEXT("dwFlags specified as 0x%lx; added .._HWDEC_PREFER"), dwFlags)) ;
        dwFlags |= AM_DVD_HWDEC_PREFER ;  // use HW Decs maxm
    }
	
    //
    // Now build graph based on flag specified in the call
    //
    switch (dwFlags & DVDGRAPH_FLAGSVALIDDEC)
    {
	case AM_DVD_HWDEC_PREFER:
		hr = MakeGraphHW(FALSE, pStatus) ;
		break ;
		
	case AM_DVD_HWDEC_ONLY:
		hr = MakeGraphHW(TRUE, pStatus) ;
		break ;
		
	case AM_DVD_SWDEC_PREFER:
		// m_bUseVPE = FALSE ;
		hr = MakeGraphSW(FALSE, pStatus) ;
		break ;
		
	case AM_DVD_SWDEC_ONLY:
		// m_bUseVPE = FALSE ;
		hr = MakeGraphSW(TRUE, pStatus) ;
		break ;
		
	default:
		DbgLog((LOG_ERROR, 0, TEXT("WARNING: Got an invalid DVD Render flag"))) ;
		hr = E_INVALIDARG ;
		break ;
    }
	
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Graph building failed (Error 0x%lx)"), hr)) ;
        // m_Decoders.CleanAll() ; -- should be covered by ClearGraph()
        ClearGraph() ;
        return hr ;
    }
	
    HRESULT    hrFinal = hr ;  // as it has been so far
	
    //
    // Now get all the mixers, renderers etc to complete the graph
    //
    hr = RenderDecoderOutput(pStatus) ;
	
    //
    // If we were successful before and the decoder output rendering wasn't
    // then at least set the warning flag.
    //
    if (S_OK == hrFinal && S_OK != hr ||
        SUCCEEDED(hrFinal) && FAILED(hr))
        hrFinal = hr ;
	
    //
    // Do we really need it?
    //
    if (lpcwszPathName)
    {
        lstrcpynW(m_achwPathName, lpcwszPathName, MAX_PATH) ;
    }
	
    //
    // Set the specified root file name/DVD volume name (even NULL because
    // that causes the DVD Nav to search for one)
    //
    IDvdControl  *pDvdC ;
    if (m_pDVDSrc)
        hr = m_pDVDSrc->QueryInterface(IID_IDvdControl, (LPVOID *)&pDvdC) ;
    else
        hr = m_pDVDNav->QueryInterface(IID_IDvdControl, (LPVOID *)&pDvdC) ;
    if (FAILED(hr) || NULL == pDvdC)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't get IDvdControl interface (Error 0x%lx)"), hr)) ;
        return hr ;
    }
	
    //
    // Set the specified DVD volume path
    //
    // Does the SetRoor() function handle the NULL properly?
    //
    hr = pDvdC->SetRoot(lpcwszPathName) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 2, 
            TEXT("IDvdControl::SetRoot() call couldn't use specified volume (Error 0x%lx)"), hr)) ;
        if (lpcwszPathName)
            pStatus->bDvdVolInvalid = TRUE ;
        else
            pStatus->bDvdVolUnknown = TRUE ;
        if (SUCCEEDED(hrFinal))  // if we were so far perfect, ...
            hrFinal = S_FALSE ;  // ...we aren't so anymore
    }
	
    pDvdC->Release() ;  // done with this interface
	
    // Only if we haven't entirely failed, set the graph built flag and 
    // return overall result.
    if (SUCCEEDED(hrFinal))
        m_bGraphDone = TRUE ;
	
    return hrFinal ;
}


#if 0
HRESULT CDvdGraphBuilder::GetStatusMessage(AM_DVD_RENDERSTATUS *pStatus,
										   LPTSTR lpszMessage, int *piLength)
{
    return E_NOTIMPL ;  // for now
}
#endif // #if 0


//
// Make sure a filter graph has been created; if not create one here
//
HRESULT CDvdGraphBuilder::EnsureGraphExists(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::EnsureGraphExists()"))) ;
	
    if (m_pGB)
        return S_OK ;
	
    return CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC,
		IID_IGraphBuilder, (LPVOID *)&m_pGB) ;
}


//
// Create a fresh filter graph
//
HRESULT CDvdGraphBuilder::CreateGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateGraph()"))) ;
	
    return CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC,
		IID_IGraphBuilder, (LPVOID *)&m_pGB) ;
}


//
// Delete the existing filter graph's contents
//
HRESULT CDvdGraphBuilder::DeleteGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::DeleteGraph()"))) ;
	
    m_pGB->Release() ;
    return NOERROR ;
}


//
// Clear all the existing filters from the graph
//
HRESULT CDvdGraphBuilder::ClearGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::ClearGraph()"))) ;
	
    // Just paranoia...
    if (NULL == m_pGB)
    {
        ASSERT(FALSE) ;  // so that we know
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: How are we Clearing w/o a graph???"))) ;
        return E_FAIL ;
    }
	
    // Reset state and release interfaces
    m_dwVideoRenderStatus = 0 ;
    if (m_pL21PinToRender)
    {
        m_pL21PinToRender->Release() ;
        m_pL21PinToRender = NULL ;
    }
    if (m_pSPPinToRender)
    {
        m_pSPPinToRender->Release() ;
        m_pSPPinToRender = NULL ;
    }
	
    // Remove all (connected only?) filters from graph
    RemoveAllFilters() ;
	
    // Release all decoders too
    m_Decoders.CleanAll() ;
	
    m_bGraphDone = FALSE ;  // reset the "graph already built" flag

    return NOERROR ;
}


//
// Delete all the non-decoder filters from the current graph.
//
HRESULT CDvdGraphBuilder::RemoveAllFilters(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RemoveAllFilters()"))) ;
	
    if (m_pVR)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Removing Video Renderer from the graph"))) ;
        m_pGB->RemoveFilter(m_pVR) ;
        m_pVR->Release() ;
        m_pVR = NULL ;
    }
    if (m_pAR)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Removing Audio Renderer from the graph"))) ;
        m_pGB->RemoveFilter(m_pAR) ;
        m_pAR->Release() ;
        m_pAR = NULL ;
    }
    if (m_pVM)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Removing Video Mixer from the graph"))) ;
        m_pGB->RemoveFilter(m_pVM) ;
        m_pVM->Release() ;
        m_pVM = NULL ;
    }
    if (m_pL21Dec)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Removing Line21 dec from the graph"))) ;
        m_pGB->RemoveFilter(m_pL21Dec) ;
        m_pL21Dec->Release() ;
        m_pL21Dec = NULL ;
    }
	
    m_IntFilters.RemoveAll() ; // remove intermediate filters, if any
	
    // Now remove the Nav 
    if (m_pDVDNav)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Removing DVD Nav from the graph"))) ;
        m_pGB->RemoveFilter(m_pDVDNav) ;
        m_pDVDNav->Release() ;
        m_pDVDNav = NULL ;
    }
	
    return NOERROR ;
}


//
// Create a filter and add it to the filter graph
//
HRESULT CDvdGraphBuilder::CreateFilterInGraph(CLSID Clsid,
											  LPCTSTR lpszFilterName, IBaseFilter **ppFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateFilterInGraph(%s, %s, 0x%lx)"), 
		(LPCSTR) CDisp(Clsid), lpszFilterName, ppFilter)) ;
	
    if (NULL == m_pGB)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Filter graph object hasn't been created yet"))) ;
        return E_FAIL ;
    }
	
    HRESULT   hr ;
    hr = CoCreateInstance(Clsid, NULL, CLSCTX_INPROC, IID_IBaseFilter,
		(LPVOID *)ppFilter) ;
    if (FAILED(hr) || NULL == *ppFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't create filter %s (Error 0x%lx)"),
			(LPCTSTR)CDisp(Clsid), hr)) ;
        return hr ;
    }
	
    // Add it to the filter graph
    WCHAR   achwFilterName[MAX_FILTER_NAME] ;
#ifdef UNICODE
    lstrcpy(achwFilterName, lpszFilterName) ;
#else
    MultiByteToWideChar(CP_ACP, 0, lpszFilterName, -1, achwFilterName, MAX_FILTER_NAME) ;
#endif // UNICODE
    hr = m_pGB->AddFilter(*ppFilter, achwFilterName) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't add filter %s to graph (Error 0x%lx)"),
			(LPCTSTR)CDisp(Clsid), hr)) ;
        (*ppFilter)->Release() ;  // release filter too
        *ppFilter = NULL ;      // and set it to NULL
        return hr ;
    }
	
    return NOERROR ;
}


//
// Find the nth pin with a specific direction in a filter
//
HRESULT CDvdGraphBuilder::FindOpenPin(IBaseFilter *pFilter, PIN_DIRECTION pd,
                                      int iIndex, IPin **ppPin)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::FindOpenPin(0x%lx, %d, %d, 0x%lx)"),
		pFilter, pd, iIndex, ppPin)) ;
	
    HRESULT    hr ;
    IEnumPins *pEnumPins ;
    IPin      *pPin ;
    IPin      *pPin2 ;
    PIN_DIRECTION  pdFound ;
    ULONG      ul ;
	
    *ppPin = NULL ;
	
    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Can't find a pin from NULL filter!!!"))) ;
        return E_INVALIDARG ;
    }
	
    hr = pFilter->EnumPins(&pEnumPins) ;
    ASSERT(SUCCEEDED(hr) && pEnumPins) ;
	
    while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
    {
        hr = pPin->QueryDirection(&pdFound) ;
        ASSERT(SUCCEEDED(hr)) ;
        if (pd != pdFound)
        {
            pPin->Release() ;  // don't need this pin
            continue ;
        }
        hr = pPin->ConnectedTo(&pPin2) ;
        if (SUCCEEDED(hr) && pPin2)
        {
            pPin2->Release() ;  // we don't want this pin actually
            pPin->Release() ;   // this pin is already connected
            continue ;          // try next one
        }
        if (0 == iIndex)
        {
            // Got the reqd pin in the right direction
            *ppPin = pPin ;
            hr = S_OK ;
            break ;
        }
        else  // some more to go
        {
            iIndex-- ;          // one more down...
            pPin->Release() ;   // this is not the pin we are looking for
        }
    }
    pEnumPins->Release() ;
    return hr ;  // whatever it is
}


BOOL CDvdGraphBuilder::CheckPinMediaTypeMatch(IPin *pPinIn, DWORD dwStreamFlag)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CheckPinMediaTypeMatch(%s, %lu)"),
		(LPCTSTR) CDisp(pPinIn), dwStreamFlag)) ;
	
    BOOL              bResult = FALSE ;
    AM_MEDIA_TYPE    *pmtIn ;
    IEnumMediaTypes  *pEnumMTIn ;
    HRESULT hr = pPinIn->EnumMediaTypes(&pEnumMTIn) ;
    ASSERT(SUCCEEDED(hr) && pEnumMTIn) ;
    ULONG   ul ;
    while (!bResult  &&
		S_OK == pEnumMTIn->Next(1, &pmtIn, &ul) && 1 == ul) // more mediatypes
    {
        // Decipher the mediatype
        if (pmtIn->majortype == MEDIATYPE_MPEG2_PES  ||
            pmtIn->majortype == MEDIATYPE_DVD_ENCRYPTED_PACK)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is MPEG2_PES/DVD_ENCRYPTED_PACK"))) ;
			
            if (pmtIn->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_VIDEO"))) ;
                bResult = dwStreamFlag == AM_DVD_STREAM_VIDEO ;
            }
            else if (pmtIn->subtype == MEDIASUBTYPE_DOLBY_AC3)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is DOLBY_AC3"))) ;
                bResult = dwStreamFlag == AM_DVD_STREAM_AUDIO ;
            }
            else if (pmtIn->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_Subpicture"))) ;
                bResult = dwStreamFlag == AM_DVD_STREAM_SUBPIC ;
            }
            else
            {
                DbgLog((LOG_ERROR, 1, TEXT("WARNING: Unknown subtype %s"),
					(LPCSTR) CDisp(pmtIn->subtype))) ;
            }
        }
        else if (pmtIn->majortype == MEDIATYPE_Video)  // elementary stream
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Video elementary"))) ;
			
            if (pmtIn->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_SUBPICTURE"))) ;
                bResult = dwStreamFlag ==  AM_DVD_STREAM_SUBPIC ;
            }
            else if (pmtIn->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_VIDEO"))) ;
                bResult = dwStreamFlag ==  AM_DVD_STREAM_VIDEO ;
            }
            else
                DbgLog((LOG_TRACE, 5, TEXT("WARNING: Unknown subtype %s"),
				(LPCSTR) CDisp(pmtIn->subtype))) ;
        }
        else if (pmtIn->majortype == MEDIATYPE_Audio)  // elementary stream
        {
            ASSERT(pmtIn->subtype == MEDIASUBTYPE_DOLBY_AC3) ;  // just checking
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Audio elementary"))) ;
            bResult = dwStreamFlag ==  AM_DVD_STREAM_AUDIO ;
        }
        // 
        // There is a chance that some IHV/ISV creates a private mediatype 
        // (major or sub) as in the case of IBM (for CSS filter). We have to
        // search the parts of the mediatype to locate something we recognize.
        // 
        else 
        {
            DbgLog((LOG_TRACE, 2, 
                TEXT("Unknown mediatype %s:%s. But we won't give up..."),
                (LPCSTR) CDisp(pmtIn->majortype), (LPCSTR) CDisp(pmtIn->subtype))) ;
            if (pmtIn->subtype == MEDIASUBTYPE_DOLBY_AC3)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Audio"))) ;
                bResult = dwStreamFlag ==  AM_DVD_STREAM_AUDIO ;
            }
            else if (pmtIn->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Video"))) ;
                bResult = dwStreamFlag ==  AM_DVD_STREAM_VIDEO ;
            }
            else if (pmtIn->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Subpicture"))) ;
                bResult = dwStreamFlag ==  AM_DVD_STREAM_SUBPIC ;
            }
            else
            {
                DbgLog((LOG_TRACE, 2, TEXT("WARNING: Unknown mediatype. Couldn't detect at all."))) ;
            }
        }
		
        DeleteMediaType(pmtIn) ;
    }  // end of while()
	
    pEnumMTIn->Release() ;
	
    return bResult ;  // whatever we found
	
}


IBaseFilter * CDvdGraphBuilder::GetFilterBetweenPins(IPin *pPinOut, IPin *pPinIn)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetFilterBetweenPins(Out=%s, In=%s)"),
		    (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;

    if (NULL == pPinOut || NULL == pPinIn)  // what!!!
        return NULL ;

    IPin  *pPin ;
    PIN_INFO  pi ;
    IBaseFilter  *pFilter = NULL ;
    HRESULT  hr = pPinOut->ConnectedTo(&pPin) ;
    if (pPin && SUCCEEDED(hr))
    {
        pPin->QueryPinInfo(&pi) ;
        pFilter = pi.pFilter ;
        ASSERT(pFilter && PINDIR_INPUT == pi.dir) ;
        //
        // We intentionally keep the extra ref count because this is an intermediate
        // filter and other intermediate filters picked up based on registry based
        // filter enum (for SW decoding case) will have the extra ref count.  We
        // release the IBaseFilter interface pointer in CIntFilters::RemoveAll() and
        // if we don't keep this extra ref count here, we'll fault.  On the other
        // hand we must do Release() on CIntFilters elements, because SW enum-ed 
        // filters will not be unloaded.
        //
        // if (pi.pFilter)
        //     pi.pFilter->Release() ;  // it has an extra ref count from the Query...

        pPin->Release() ;  // done with the pin for now

        // Just for checking...
#ifdef DEBUG
        hr = pPinIn->ConnectedTo(&pPin) ;
        if (pPin && SUCCEEDED(hr))
        {
            pPin->QueryPinInfo(&pi) ;
            ASSERT(pi.pFilter && PINDIR_OUTPUT == pi.dir) ;
            if (pi.pFilter)
            {
                ASSERT(IsEqualObject(pFilter, pi.pFilter)) ; // we should have got the same filter
                pi.pFilter->Release() ;  // it has an extra ref count from the Query...
            }

            pPin->Release() ;  // done with the pin for now
        }
#endif // DEBUG

    }
    return pFilter ;
}


HRESULT CDvdGraphBuilder::ConnectSrcToHWDec(IBaseFilter *pSrc,
                                            CListDecoders *pHWDecList, 
                                            AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::ConnectSrcToHWDec(0x%lx, 0x%0x, 0x%lx)"),
		pSrc, pHWDecList, pStatus)) ;
	
    ULONG            ul ;
    int              i ;
    IPin            *pPinOut ;
    IPin            *pPinIn ;
    PIN_DIRECTION    pd ;
    BOOL             bConnected ;
    IBaseFilter     *pHWDec ;
    LPTSTR           szName ;
    BOOL             bHW ;
    IEnumPins       *pEnumPinsOut ;
    HRESULT          hr ;
    HRESULT          hrFinal = S_OK ;  // assumed innocent
	
    if (0 == pHWDecList->GetNumHWFilters())  // if there is no HW decoder
        return S_FALSE ;                     // not a failure, but not a full success
	
    if (NULL == pSrc)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: NULL Src passed to ConnectSrcToHWDec()"))) ;
        return E_INVALIDARG ;
    }
	
    hr = pSrc->EnumPins(&pEnumPinsOut) ;
    ASSERT(SUCCEEDED(hr) && pEnumPinsOut) ;
	
    while (S_OK == pEnumPinsOut->Next(1, &pPinOut, &ul)  &&  1 == ul)
    {
        pPinOut->QueryDirection(&pd) ;
        if (PINDIR_INPUT == pd)
        {
            pPinOut->Release() ;
            continue ;
        }
        hr = pPinOut->ConnectedTo(&pPinIn) ;
        if (SUCCEEDED(hr) && pPinIn)
        {
            DbgLog((LOG_TRACE, 5, 
				TEXT("Pin %s is already connected to %s"), 
				(LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
            pPinIn->Release() ;     // we don't want this pin actually
            pPinOut->Release() ;   // this pin is already connected
            continue ;             // try next one
        }
		
        DbgLog((LOG_TRACE, 5, 
			TEXT("Pin %s will be tried for connection to HW decoder"), 
			(LPCTSTR)CDisp(pPinOut))) ;
		
        // Got an unconnected output pin of the DVD source filter
        //
        // We are going to get the successive inpins of the already
        // loaded decoders and see if the outpin can connect directly 
        // to it.
        bConnected = FALSE ;
		
        // Try all HW decoders for mediatype match and then connection
        DbgLog((LOG_TRACE, 5, TEXT("Going to try %d HW decoders..."), 
			pHWDecList->GetNumHWFilters())) ;
        for (i = 0 ; !bConnected && i < pHWDecList->GetNumHWFilters() ; i++)
        {
            pHWDecList->GetFilter(i, &pHWDec, &szName, &bHW) ;
            ASSERT(pHWDec && bHW) ;  // paranoia!!!
            DbgLog((LOG_TRACE, 5, TEXT("HW Decoder: %s"), szName)) ;
			
            BOOL bNotInUse ;
            bNotInUse = (DECLIST_NOTFOUND == m_Decoders.IsInList(TRUE, (LPVOID)pHWDec)) ;
            if (bNotInUse)  // not already in the graph/decoder list
            {
                // First add filter to graph and then try to connect
                WCHAR   achwFilterName[MAX_FILTER_NAME] ;
#ifdef UNICODE
                lstrcpy(achwFilterName, szName) ;
#else
                MultiByteToWideChar(CP_ACP, 0, szName, -1, achwFilterName,
					MAX_FILTER_NAME) ;
#endif // UNICODE
                
                m_pGB->AddFilter(pHWDec, achwFilterName) ;
            }
            else
                DbgLog((LOG_TRACE, 4, TEXT("HW decoder (%s) is already in the graph"), szName)) ;

            //
            // Try all input pins of this HW decoder until we can connect the
            // Nav out pin to one (or all in pins have been tried)
            //
            int  j = 0 ;
            while ( !bConnected  &&
                    SUCCEEDED(hr = FindOpenPin(pHWDec, PINDIR_INPUT, j, &pPinIn))  &&
                    pPinIn)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Open input pin #%d found on HW decoder"), j)) ;

                //
                // Find the mediatype of this input pin of the proxy filter. If
                // it's the same type as the output pin of the Nav, then they
                // are supposed to be connected (may be) -- try it.
                //
                DWORD dwStreamIn = StreamFlagFromSWPin(pPinOut) ;
                if (CheckPinMediaTypeMatch(pPinIn, dwStreamIn))
                {
                    DbgLog((LOG_TRACE, 3, 
                        TEXT("Pin <%s> and Pin <%s> has matching mediatypes (%lu)"), 
                        (LPCTSTR) CDisp(pPinOut), (LPCTSTR) CDisp(pPinIn), dwStreamIn)) ;
					
                    //
                    // First try to do "direct connect" so that no other intermediate
                    // filter gets picked up (which is the most common case).
                    //
                    hr = m_pGB->ConnectDirect(pPinOut, pPinIn, NULL) ;
                    if (SUCCEEDED(hr))
                    {
                        bConnected = TRUE ;
                        // Add it to list, ONLY IF not already in
                        if (bNotInUse)
                            m_Decoders.AddFilter(pHWDec, szName, TRUE, NULL) ;
						
                        DbgLog((LOG_TRACE, 5, 
							TEXT("Pin %s directly connected to pin %s"), 
							(LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
                    }
                    else  // direct connection doesn't work
                    {
                        DbgLog((LOG_TRACE, 5, 
							TEXT("Pin %s did NOT directly connect to pin %s"), 
							(LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;

                        //
                        // Now do an "intelligent connect" so that any required intermediate
                        // filter can get picked up.  This is mainly to accommodate IBM's
                        // separate CSS filter.
                        //
                        hr = m_pGB->Connect(pPinOut, pPinIn) ;
                        if (SUCCEEDED(hr))
                        {
                            bConnected = TRUE ;
                            // Add it to list, ONLY IF not already in
                            if (bNotInUse)
                                m_Decoders.AddFilter(pHWDec, szName, TRUE, NULL) ;
                            
                            //
                            // BUGBUG: We assume that there will be only one intermediate
                            // filter sitting between the Nav's out pin and the decoder,
                            // which is the most likely case, but there IS a chance that
                            // there can be two more such filters. We should rather add
                            // all such filters to the intermediate filters' list inside
                            // GetFilter(s)BetweenPins() method.
                            //
                            m_IntFilters.AddFilter(GetFilterBetweenPins(pPinOut, pPinIn)) ; // add to the list

                            DbgLog((LOG_TRACE, 5, 
                                TEXT("Pin %s *indirectly* connected to pin %s"), 
                                (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
                        }
                        else
                            DbgLog((LOG_TRACE, 5, 
							    TEXT("Pin %s did NOT indirectly connect to pin %s"), 
							    (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
                    }  // end of else of if (connect direct)
                } // end of if (CheckPinMediaTypeMatch())

                pPinIn->Release() ;  // done with this in pin
                j++ ;
            }  // end of while (try all in pins untill connected to one)

            if (0 == j)
                DbgLog((LOG_TRACE, 5, TEXT("No open input pin found on HW decoder"))) ;
			
            // If we didn't connect to it AND we added it to the graph 
            // THIS TIME then ONLY remove it.  I spent almost day debugging
            // for the missing if (bNotInUse) check!!!
            if ( !bConnected  &&  bNotInUse)
                m_pGB->RemoveFilter(pHWDec) ;
			
        }   // end of for (all HW decs)
		
        if (! bConnected )  // if we couldn't connect this pin
        {
            if (NOERROR == hrFinal)  // if it was perfect so far,
                hrFinal = S_FALSE ;  // it's not so anymore
            DbgLog((LOG_TRACE, 5, TEXT("Pin (%s) couldn't be connected to any HW Dec"),
				(LPCTSTR)CDisp(pPinOut))) ;
        }
        pPinOut->Release() ;      // done with this out pin
		
    }   // end of while (out pin enum)
    pEnumPinsOut->Release() ;  // done with pin enum of DVD Src
	
    return hrFinal ;
}


BOOL CDvdGraphBuilder::StartDecAndConnect(IPin *pPinOut, 
                                          IFilterMapper *pMapper, 
                                          AM_MEDIA_TYPE *pmt)
{
    ULONG            ul ;
    IPin            *pPinIn ;
    PIN_DIRECTION    pd ;
    BOOL             bConnected ;
    LPTSTR           szName ;
    IEnumPins       *pEnumPinsOut ;
    IEnumRegFilters *pEnumFilters ;
    IBaseFilter     *pSWDec ;
    REGFILTER       *pRegDec ;
    TCHAR            achName[MAX_FILTER_NAME] ;
    IEnumMediaTypes *pEnumMT ;
    HRESULT          hr ;
    HRESULT          hrFinal = S_OK ;  // assumed innocent
    BOOL             bHW ;
    int              iDecPos ;
	
    hr = pMapper->EnumMatchingFilters(&pEnumFilters, /* MERIT_NORMAL */ 
                        MERIT_DO_NOT_USE+1, TRUE, 
		                pmt->majortype, pmt->subtype, FALSE, TRUE, 
		                GUID_NULL, GUID_NULL) ;
    if (FAILED(hr) || NULL == pEnumFilters)
    {
        DbgLog((LOG_TRACE, 3, TEXT("No matching enum for mediatype (%s:%s)"),
			(LPCSTR) CDisp(pmt->majortype), (LPCSTR) CDisp(pmt->subtype))) ;
        DeleteMediaType(pmt) ;
        return FALSE ;
    }
    DbgLog((LOG_TRACE, 5, TEXT("Got a filter enum for mediatype (%s:%s)"),
		(LPCSTR) CDisp(pmt->majortype), (LPCSTR) CDisp(pmt->subtype))) ;
	
    // Go through all the filters in this enumerator to locate a
    // suitable one to connect to.
    bConnected = FALSE ;  // clear flag at starting
    while ( !bConnected  && 
		    S_OK == pEnumFilters->Next(1, &pRegDec, &ul) && 1 == ul )
    {
        iDecPos = m_Decoders.IsInList(FALSE, (LPVOID)&(pRegDec->Clsid)) ;
        if (DECLIST_NOTFOUND == iDecPos)  // not in list
        {
            DbgLog((LOG_TRACE, 5, TEXT("Not an existing SW decoder-- going to create"))) ;
            hr = CoCreateInstance(pRegDec->Clsid, NULL, CLSCTX_INPROC, 
				        IID_IBaseFilter, (LPVOID *)&pSWDec) ;
            if (FAILED(hr) || NULL == pSWDec)
            {
                DbgLog((LOG_ERROR, 0, TEXT("Couldn't load a matching registered filter (%s) (Error 0x%lx)"),
					(LPCSTR) CDisp(pRegDec->Clsid), hr)) ;
                CoTaskMemFree(pRegDec) ;  // before we try the next
                continue ;  // onto the next matching filter...
            }
            DbgLog((LOG_TRACE, 5, TEXT("Started matching registered filter (%s)"),
				(LPCSTR) CDisp(pRegDec->Clsid))) ;
			
            hr = m_pGB->AddFilter(pSWDec, pRegDec->Name) ;
            ASSERT(SUCCEEDED(hr)) ;
        }
        else // already created; use existing instance
        {
            DbgLog((LOG_TRACE, 5, TEXT("Going to use an existing SW decoder (%d)"), 
				iDecPos)) ;
            m_Decoders.GetFilter(iDecPos, &pSWDec, &szName, &bHW) ;
            ASSERT(pSWDec && !bHW) ;  // want to be sure!!
        }
		
        if (SUCCEEDED(hr = TryConnect(pPinOut, pSWDec, NULL, TRUE)))
        {
            DbgLog((LOG_TRACE, 5, TEXT("One more pin connected (to decoder or 3rd party filter?)"))) ;

            //
            // There is a chance that the filter we just above created and connected
            // Nav's out pin to, "may NOT be" actually a decoder -- it may also be a
            // 3rd party intermediate filter, like IBM's CSS filter.
            //
            IPin            *pPinOut2 ;
            IEnumMediaTypes *pEnumMT2 ;
            AM_MEDIA_TYPE   *pmt2 ;
            BOOL             bMTDecoded = FALSE ;
            hr = FindOpenPin(pSWDec, PINDIR_OUTPUT, 0, &pPinOut2) ;
            if (SUCCEEDED(hr) && pPinOut2)
            {
                hr = pPinOut2->EnumMediaTypes(&pEnumMT2) ;
                ASSERT(SUCCEEDED(hr) && pEnumMT2) ;
                while ( !bMTDecoded && 
                        S_OK == pEnumMT2->Next(1, &pmt2, &ul) && 1 == ul)
                {
                    bMTDecoded = MEDIATYPE_Video == pmt2->majortype ||
						         MEDIATYPE_Audio == pmt2->majortype ;
                    DeleteMediaType(pmt2) ;  // otherwise
                }
                if (bMTDecoded)  // we HAVE connected to a decoder!!!
                {
                    //
                    // Add decoder info to our decoder list and set the success flag
                    //
                    DbgLog((LOG_TRACE, 5, TEXT("Nav pin / 3rd party's pin connected to decoder"))) ;
#ifdef UNICODE
                    lstrcpy(achName, pRegDec->Name) ;
#else
                    WideCharToMultiByte(CP_ACP, 0, pRegDec->Name, -1,
						        achName, MAX_FILTER_NAME, NULL, NULL) ;
#endif // UNICODE
					
                    if (DECLIST_NOTFOUND == iDecPos) // only if not in list
                        m_Decoders.AddFilter(pSWDec, achName, FALSE, &(pRegDec->Clsid)) ;
                    bConnected = TRUE ;  // success!!
                }
                else  // we have connected to an intermediate filter so far
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Nav pin (%s) connected to 3rd party filter with out pin (%s)"),
						(LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinOut2))) ;

                    m_IntFilters.AddFilter(pSWDec) ; // pSWDec is actually the intermediate filter

                    pEnumMT2->Reset() ;  // need to enum mediatypes AGAIN for connection
                    while( !bConnected  && 
						    S_OK == pEnumMT2->Next(1, &pmt2, &ul) && 1 == ul )
                    {
                        bConnected = StartDecAndConnect(pPinOut2, pMapper, pmt2) ;
                        DeleteMediaType(pmt2) ;     // done with this mediatype
                    }   // end of while (!bConnected && pEnumMT2->Next())
					
                    if ( !bConnected )  // connection attempts failed
                        DbgLog((LOG_TRACE, 5, 
						    TEXT("Pin (%s) -> Pin(%s) couldn't be connected to any SW Dec"),
						    (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinOut2))) ;
                }
                pEnumMT2->Release() ;  // media enum over
            }
            pPinOut2->Release() ; // done with this pin
			
        }
        else  // connection attempt failed
        {
            if (DECLIST_NOTFOUND == iDecPos) // only if we created it in this pass
            {
                hr = m_pGB->RemoveFilter(pSWDec) ; // connection failed; remove it
                ASSERT(SUCCEEDED(hr)) ;
                pSWDec->Release() ;                // don't need it
            }
        }
        CoTaskMemFree(pRegDec) ;   // before we forget
		
    } // end of while (!bConnected && pEnumFilters->Next())
	
    pEnumFilters->Release() ;  // let go of the filter enumerator
	
    return bConnected ;
}


HRESULT CDvdGraphBuilder::ConnectSrcToSWDec(IBaseFilter *pSrc, 
                                            AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::ConnectSrcToSWDec(0x%lx, 0x%lx)"),
		pSrc, pStatus)) ;
	
    ULONG            ul ;
    IPin            *pPinOut ;
    IPin            *pPinIn ;
    PIN_DIRECTION    pd ;
    BOOL             bConnected ;
    IEnumPins       *pEnumPinsOut ;
    AM_MEDIA_TYPE   *pmt ;
    IEnumMediaTypes *pEnumMT ;
    IFilterMapper   *pMapper ;
    HRESULT          hr ;
    HRESULT          hrFinal = S_OK ;  // assumed innocent
	
    if (NULL == pSrc)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: NULL Src passed to ConnectSrcToSWDec()"))) ;
        return E_INVALIDARG ;
    }
	
    hr = CoCreateInstance(CLSID_FilterMapper, NULL, CLSCTX_INPROC, 
		        IID_IFilterMapper, (LPVOID *)&pMapper) ;
    ASSERT(SUCCEEDED(hr)  &&  pMapper) ;
	
    hr = pSrc->EnumPins(&pEnumPinsOut) ;
    ASSERT(SUCCEEDED(hr) && pEnumPinsOut) ;
	
    while (S_OK == pEnumPinsOut->Next(1, &pPinOut, &ul) && 1 == ul)
    {
        pPinOut->QueryDirection(&pd) ;
        if (PINDIR_INPUT == pd)
        {
            pPinOut->Release() ;
            continue ;
        }
        hr = pPinOut->ConnectedTo(&pPinIn) ;
        if (SUCCEEDED(hr) && pPinIn) // already connected out pin of DVD src
        {
            DbgLog((LOG_TRACE, 5, 
				TEXT("Pin %s is already connected to pin %s"), 
				(LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
            pPinIn->Release() ;   // let the in pin go
            pPinOut->Release() ;  // let the out pin go
            continue ;
        }
		
        // Got an unconnected out pin of DVD src
        DbgLog((LOG_TRACE, 5, TEXT("Found pin %s not yet connected"), 
			(LPCTSTR)CDisp(pPinOut))) ;

        // First check if there is any existing intermediate filter(s).
        // If so, we may be able to connect through it.
        int iCount = m_IntFilters.GetCount() ;
        DbgLog((LOG_TRACE, 5, TEXT("%d intermediate filters in list"), iCount)) ;
        IBaseFilter *pIntFilter ;
        for (int i = 0 ; i < iCount ; i++)
        {
            pIntFilter = m_IntFilters.GetFilter(i) ;
            ASSERT(pIntFilter) ;
            if (SUCCEEDED(hr = TryConnect(pPinOut, pIntFilter, NULL, TRUE)))
            {
                DbgLog((LOG_TRACE, 5, TEXT("Nav's out pin (%s) connected to 3rd party filter"),
                        (LPCTSTR)CDisp(pPinOut))) ;
                pPinOut->Release() ;  // done with Nav's pin; now we need int. filter's pin
                // Next we'll get the out pin of the intermediate filter and release it
                // at the end of the while loop, in place of the above pPinOut.

                hr = FindOpenPin(pIntFilter, PINDIR_OUTPUT, 0, &pPinOut) ;
                if (SUCCEEDED(hr) && pPinOut)
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Got 3rd party filter's out pin %s"),
                        (LPCTSTR)CDisp(pPinOut))) ;
                    break ;  // done for this pin of Nav; next step below.
                }
            }
            else
                DbgLog((LOG_TRACE, 5, TEXT("Nav's pin %s didn't connect to int. filter #%d"),
                        (LPCTSTR)CDisp(pPinOut), i)) ;
        }

        // Now we try to connect to the decoder (or an intermediate filter)
        bConnected = FALSE ;
        hr = pPinOut->EnumMediaTypes(&pEnumMT) ;
        ASSERT(SUCCEEDED(hr) && pEnumMT) ;
        while( !bConnected  && 
			    S_OK == pEnumMT->Next(1, &pmt, &ul) && 1 == ul )
        {
            bConnected = StartDecAndConnect(pPinOut, pMapper, pmt) ;
            DeleteMediaType(pmt) ;     // done with this mediatype
			
        }  // end of while (!bConnected && pEnumMT->Next())
		
        pEnumMT->Release() ;  // done with mediatype enum
		
        if (!bConnected) {  // connection attempts failed
            if (NOERROR == hrFinal)  // if it was perfect so far,
                hrFinal = S_FALSE ;  // it's not so anymore
            DbgLog((LOG_TRACE, 5, TEXT("Pin (%s) couldn't be connected to any SW Dec"),
				(LPCTSTR)CDisp(pPinOut))) ;
        }
        pPinOut->Release() ;  // done with this out pin
		
    }  // end of while (pEnumPinsOut->Next())
	
    pEnumPinsOut->Release() ;  // done with DVD source's pin enum
    pMapper->Release() ;       // done with the filter mapper
	
    return hrFinal ;
}


HRESULT CDvdGraphBuilder::CheckSrcPinConnection(IBaseFilter *pSrc, 
                                                AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CheckSrcPinConnection(0x%lx, 0x%lx)"),
		pSrc, pStatus)) ;
	
    ULONG            ul ;
    IPin            *pPinOut ;
    IPin            *pPinIn ;
    PIN_DIRECTION    pd ;
    IEnumPins       *pEnumSrcPins ;
    DWORD            dwStreamOut ;
    HRESULT          hrFinal = S_OK ;
	
    HRESULT  hr = pSrc->EnumPins(&pEnumSrcPins) ;
    ASSERT(SUCCEEDED(hr) && pEnumSrcPins) ;
	
    while (S_OK == pEnumSrcPins->Next(1, &pPinOut, &ul) && 1 == ul)
    {
        pPinOut->QueryDirection(&pd) ;
        if (PINDIR_INPUT == pd)
        {
            // Huh!!! In pin for DVD Src? Anyway...
            pPinOut->Release() ;
            continue ;
        }
        dwStreamOut = StreamFlagFromSWPin(pPinOut) ;
        pStatus->iNumStreams++ ;  // one more DVD stream found
        pPinIn = NULL ;  // start as NULL

        if (m_IntFilters.GetCount() > 0) // there is indirect connection
        {
            DbgLog((LOG_TRACE, 5, 
                    TEXT("Nav pin %s connection will be checked aginst %d int. filters"),
                    (LPCTSTR)CDisp(pPinOut), m_IntFilters.GetCount())) ;
            hr = pPinOut->ConnectedTo(&pPinIn) ; // get connected filter's in pin
            if (SUCCEEDED(hr) && pPinIn)
            {
                PIN_INFO  pi ;
                pPinIn->QueryPinInfo(&pi) ;
                // pPinIn->Release() ;  // got the intermediate filter ptr, let go of the pin

                if (m_IntFilters.IsInList(pi.pFilter))  // Nav pin is going via one of the intermediate filters
                {
                    DbgLog((LOG_TRACE, 5, 
                        TEXT("Nav pin %s is connected to an int. filter in our list"),
                        (LPCTSTR)CDisp(pPinOut))) ;

                    pPinIn->Release() ;  // got the intermediate filter ptr, let go of the pin
                    pPinIn = NULL ;      // reset the pointer too

                    // Locate the "corresponding" out pin of the intermediate filter.
                    // Use the Nav out pin's mediatype to detect the correspodning out
                    // pin of the intermediate filter.
                    IPin       *pIntFPinOut ;
                    IEnumPins  *pEnumIntFPins ;
                    hr = pi.pFilter->EnumPins(&pEnumIntFPins) ;
                    ASSERT(SUCCEEDED(hr) && pEnumIntFPins) ;
                    while (NULL == pPinIn  &&
                           S_OK == pEnumIntFPins->Next(1, &pIntFPinOut, &ul) && 1 == ul)
                    {
                        pIntFPinOut->QueryDirection(&pd) ;
                        if (PINDIR_OUTPUT == pd)  // we only care about out pins
                        {
                            DbgLog((LOG_TRACE, 5, 
                                TEXT("Int. filter's pin %s mediatype is being determined..."),
                                (LPCTSTR)CDisp(pIntFPinOut))) ;  // pPinOut
                            DWORD  dwStream = StreamFlagFromSWPin(pIntFPinOut) ;
                            if (dwStream == dwStreamOut) // corresponding pin
                            {
                                DbgLog((LOG_TRACE, 5, 
                                    TEXT("Found out pin of int. filter corresponding to %s of Nav (Stream 0x%lx)"),
				                    (LPCTSTR)CDisp(pPinOut), dwStreamOut)) ;
                                hr = pIntFPinOut->ConnectedTo(&pPinIn) ;  // get connection info
                            }
                            else
                            {
                                if (0 == dwStream)
                                {
                                    DbgLog((LOG_TRACE, 5, 
                                        TEXT("Couldn't find which pin of int. filter corresponds to %s of Nav (Stream 0x%lx)"),
				                        (LPCTSTR)CDisp(pPinOut), dwStreamOut)) ;

                                    //
                                    // HACK: (for MediaMatics 3D Audio filter)
                                    // Most probably the 3rd party filters uses a custom
                                    // mediatype on the out pin. We'll see if the out is
                                    // connected at all.  If not, we'll say dwStreamOut 
                                    // is not rendered; else we'll try two methods.
                                    //
                                    hr = pIntFPinOut->ConnectedTo(&pPinIn) ;  // is it connected?
                                    if (SUCCEEDED(hr) && pPinIn)
                                    {
                                        DbgLog((LOG_TRACE, 5, 
                                            TEXT("Out pin (%s) of int. filter corresponding to %s of Nav (Stream 0x%lx) connects to %s"),
				                            (LPCTSTR)CDisp(pPinOut), dwStreamOut, (LPCTSTR)CDisp(pPinIn))) ;

                                        // Method 1: If Int filter has 1 in and 1 out pin
                                        if (m_IntFilters.GetNumInPin(pi.pFilter)  == 1 &&
                                            m_IntFilters.GetNumOutPin(pi.pFilter) == 1) // method 1 worked!!!
                                        {
                                            DbgLog((LOG_TRACE, 5, 
                                                TEXT("Int. filter has 1 in and 1 out pin. No need to try more."))) ;
                                        }
                                        else  // there are more than 1 in/out pin(s).
                                        {
                                            // Try method 2: Check mediatype of out pin of filter
                                            // downstream of int. filter's out pin.
                                            PIN_INFO   pi2 ;
                                            IEnumPins *pEnumPin2 ;
                                            IPin      *pPin2 ;
                                            pPinIn->QueryPinInfo(&pi2) ;
                                            ASSERT(pi2.pFilter) ;
                                            pi2.pFilter->EnumPins(&pEnumPin2) ;
                                            ASSERT(pEnumPin2) ;
                                            dwStream = 0 ;  // just to be sure
                                            while (0 == dwStream  &&
                                                   S_OK == pEnumPin2->Next(1, &pPin2, &ul) && 1 == ul)
                                            {
                                                pPin2->QueryDirection(&pd) ;
                                                if (PINDIR_OUTPUT == pd)  // we only care about out pins
                                                {
                                                    DbgLog((LOG_TRACE, 5, 
                                                        TEXT("Downstream filter's pin %s mediatype is being determined..."),
                                                        (LPCTSTR)CDisp(pPin2))) ;
                                                    DWORD  dwStream = StreamFlagFromSWPin(pPin2) ;
                                                }
                                                pPin2->Release() ;  // done with this pin
                                            } // end of while ()
                                            ASSERT(dwStream) ;        // I hope we didn't have another failure
                                            pEnumPin2->Release() ;    // done enum-ing
                                            pi2.pFilter->Release() ;  // else we leak

                                            // Check if we got the matching in and out pins
                                            if (dwStream == dwStreamOut)
                                            {
                                                DbgLog((LOG_TRACE, 5, 
                                                    TEXT("Downstream filter's out pin %s matches Nav's out pin %s (Stream 0x%lx)"),
                                                    (LPCTSTR)CDisp(pPin2), (LPCTSTR)CDisp(pPinOut), dwStreamOut)) ;
                                            }
                                            else
                                            {
                                                DbgLog((LOG_TRACE, 5, 
                                                    TEXT("Downstream filter's out pin %s DOES NOT match Nav's out pin %s (Stream 0x%lx). Try more..."),
                                                    (LPCTSTR)CDisp(pPin2), (LPCTSTR)CDisp(pPinOut), dwStreamOut)) ;

                                                // We weren't really looking for this pin; 
                                                // keep trying the other out pins.
                                                pPinIn->Release() ;
                                                pPinIn = NULL ;
                                            }
                                        }
                                    }  // end of if (connected?)
                                    else
                                        DbgLog((LOG_TRACE, 5, 
                                            TEXT("NOTE: Unconnected out pin (%s) of int. filter corresponding to %s of Nav (Stream 0x%lx)"),
				                            (LPCTSTR)CDisp(pIntFPinOut), (LPCTSTR)CDisp(pPinOut), dwStreamOut)) ;
                                }
                                else
                                    DbgLog((LOG_TRACE, 5, 
                                        TEXT("Skipping non-matching pin (Stream 0x%lx) of int. filter for %s of Nav (Stream 0x%lx)"),
				                        dwStream, (LPCTSTR)CDisp(pPinOut), dwStreamOut)) ;
                            }
                        }
                        pIntFPinOut->Release() ;

                    }  // end while ()

                    pEnumIntFPins->Release() ; // done with pin enum
                } // end of if (m_IntFilters.IsInList())
                else
                    DbgLog((LOG_TRACE, 5, 
                        TEXT("Nav pin %s is NOT connected to an int. filter in our list"),
                        (LPCTSTR)CDisp(pPinOut))) ;

                pi.pFilter->Release() ;  // else we leak
            }
            // Otherwise pPinIn or hr indicates the "not connected" state which
            // will be tested below to set the approp. flags etc. in the Status 
            // struct.
        }
        else  // Nav connects directly to the decoder(s)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Pin %s is NOT connected indirectly"), 
				(LPCTSTR)CDisp(pPinOut))) ;
            hr = pPinOut->ConnectedTo(&pPinIn) ;
        }

        if (/* SUCCEEDED(hr) && */ pPinIn) // already connected out pin of DVD src
        {
            pPinIn->Release() ;   // let the in pin go
        }
        else
        {
            DbgLog((LOG_ERROR, 4, TEXT("NOTE: Pin %s is not connected"), 
				(LPCTSTR)CDisp(pPinOut))) ;
            if (0 == (dwStreamOut & pStatus->dwFailedStreamsFlag))  // hasn't yet been set
            {
                pStatus->iNumStreamsFailed++ ;
                pStatus->dwFailedStreamsFlag |= dwStreamOut ;
            }
            hrFinal = S_FALSE ;
        }
		
        pPinOut->Release() ;  // let the out pin go
    }  // end of while (S_OK == ...->Next())
	
    pEnumSrcPins->Release() ;  // done with src pin enum
	
    // Check that at least one stream has been rendered right. Otherwise
    // fail the method.
    if (pStatus->iNumStreamsFailed >= pStatus->iNumStreams)
    {
        DbgLog((LOG_ERROR, 0, TEXT("None of the %d DVD streams rendered right (failed %d)"), 
			pStatus->iNumStreams, pStatus->iNumStreamsFailed)) ;
        hrFinal = VFW_E_DVD_RENDERFAIL ;
    }
	
    return hrFinal ;
}


//
// Build the DVD playback graph using all/most HW decoder
//
HRESULT CDvdGraphBuilder::MakeGraphHW(BOOL bHWOnly, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::MakeGraphHW(%d, 0x%lx)"),
		bHWOnly, pStatus)) ;
	
    HRESULT        hr ;
    HRESULT        hrFinal = S_OK ;
    CListDecoders  HWDecs ;
	
    //
    // If graph was previously built and we are rebuilding now (may be with
    // different options) then clear the existing graph.
    //
    if (m_bGraphDone)
        ClearGraph() ;
	
    //
    // Build using as many HW decoders as possible
    //
    hr = CreateDVDHWDecoders(&HWDecs) ;
    if (FAILED(hr)  ||  0 == HWDecs.GetNumHWFilters())
    {
        if (bHWOnly)
        {
            DbgLog((LOG_ERROR, 4, TEXT("No hardware DVD decoder found, but only HW decoding asked"))) ;
            return VFW_E_DVD_DECNOTENOUGH ;
        }
        else
        {
            DbgLog((LOG_TRACE, 4, TEXT("No hardware DVD decoder found, HW decoding was preferred"))) ;
        }
    }
	
    IBaseFilter *pSrc ;
	
    // Instantiate DVD Nav, only if user hasn't specified a DVD source filter
    if (m_pDVDSrc)
        pSrc = m_pDVDSrc ;
    else
    {
        hr = CreateFilterInGraph(CLSID_DVDNavigator, TEXT("DVD Navigator"), &m_pDVDNav) ;
        if (FAILED(hr)  ||  NULL == m_pDVDNav)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: DVD Nav couldn't be instantiated (Error 0x%lx)"), hr)) ;
            return VFW_E_DVD_RENDERFAIL ;
        }
        pSrc = m_pDVDNav ;
    }
	
    //
    //  Connect DVD source filters' output pins (as many as possible) to the
    //  input pins of the HW decoder filters (if any).
    //
    hr = ConnectSrcToHWDec(pSrc, &HWDecs, pStatus) ;
    if (FAILED(hr))
    {
        return VFW_E_DVD_RENDERFAIL ;  // hr ;
    }
	
    if (S_OK != hr  &&  !bHWOnly)  // if some pins are unconnected AND only if not HW-only
    {
        //
        // If we still have any output pin unconnected then try to find some
        // SW decoder to connect to.  So go through the list once more.
        //
        hr = ConnectSrcToSWDec(pSrc, pStatus) ;
        if (FAILED(hr))
        {
            return VFW_E_DVD_RENDERFAIL ;  // hr ;
        }
    }
	
    // Check if all the output pin of DVD source have been connected.  If not
    // set the warning sign for the caller to catch.
    hr = CheckSrcPinConnection(pSrc, pStatus) ;
    if (S_OK != hr && SUCCEEDED(hrFinal))
        hrFinal = hr ;
	
    // The other DVD HW decoders will get unloaded when we exit this function
    // as that will be out of scope for the HWDecs object causing its
    // destructor to be called which frees all unused items in the list.
	
    return hrFinal ;
}


//
// Build the DVD playback graph using all/most SW decoders
//
HRESULT CDvdGraphBuilder::MakeGraphSW(BOOL bSWOnly, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::MakeGraphSW(%d, 0x%lx)"),
		bSWOnly, pStatus)) ;
	
    HRESULT      hr ;
    HRESULT      hrFinal = S_OK ;
    IBaseFilter *pSrc ;
	
    //
    // If graph was previously built and we are rebuilding now (may be with
    // different options) then clear the existing graph.
    //
    if (m_bGraphDone)
        ClearGraph() ;
	
    // Instantiate DVD Nav, only if user hasn't specified a DVD source filter
    if (m_pDVDSrc)
        pSrc = m_pDVDSrc ;
    else
    {
        hr = CreateFilterInGraph(CLSID_DVDNavigator, TEXT("DVD Navigator"), &m_pDVDNav) ;
        if (FAILED(hr)  ||  NULL == m_pDVDNav)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: DVD Nav couldn't be instantiated (Error 0x%lx)"), hr)) ;
            return VFW_E_DVD_RENDERFAIL ;
        }
        pSrc = m_pDVDNav ;
    }
	
    //
    //  Connect DVD source filters' output pins (as many as possible) to the
    //  input pins of the SW decoder filters (if any).
    //
    hr = ConnectSrcToSWDec(pSrc, pStatus) ;
    if (FAILED(hr))
    {
        return VFW_E_DVD_RENDERFAIL ;  // hr ;
    }
	
    if (0 == m_Decoders.GetNumSWFilters())
    {
        if (bSWOnly)
        {
            DbgLog((LOG_ERROR, 4, TEXT("No software DVD decoder found, but only SW decoding asked"))) ;
            return VFW_E_DVD_DECNOTENOUGH ;
        }
        else
        {
            DbgLog((LOG_TRACE, 4, TEXT("No software DVD decoder found, SW decoding was preferred"))) ;
        }
    }
	
    if (S_OK != hr && !bSWOnly)  // if not all pins are connected AND if not SW-only
    {
        //
        // If we still have any output pin unconnected then try to find some
        // HW decoder to connect to.  So go through the list once more.
        //
        CListDecoders HWDecs ;
        hr = CreateDVDHWDecoders(&HWDecs) ;
        if (FAILED(hr) || 0 == HWDecs.GetNumHWFilters())  // no HW decoder found
        {
            DbgLog((LOG_ERROR, 4, TEXT("HW Decoders couldn't be instantiated/found."))) ;
        }
        else  // got some HW decoders; try them
        {
            hr = ConnectSrcToHWDec(pSrc, &HWDecs, pStatus) ;
            if (FAILED(hr))
            {
                return VFW_E_DVD_RENDERFAIL ;  // hr ;
            }
        }
    }
	
    // Check if all the output pin of DVD source have been connected.  If not
    // set the warning sign for the caller to catch.
    hr = CheckSrcPinConnection(pSrc, pStatus) ;
    if (S_OK != hr && SUCCEEDED(hrFinal))
        hrFinal = hr ;
	
    // The other DVD HW decoders will get unloaded when we exit this function
    // as that will be out of scope for the HWDecs object causing its
    // destructor to be called which frees all unused items in the list.
	
    return hrFinal ;
}


#define CLSID_VideoMixer CLSID_OverlayMixer

//
// Complete the DVD playback graph by bringing in renderers etc.
//
HRESULT CDvdGraphBuilder::RenderDecoderOutput(AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderDecoderOutput(0x%lx)"), pStatus)) ;
	
    int           i ;
    BOOL          bHW ;
    IBaseFilter  *pDecFilter ;
    HRESULT       hr ;
    IEnumPins    *pEnumPins ;
    IPin         *pPinOut ;
    ULONG         ul ;
    PIN_DIRECTION pd ;
    LPTSTR        lpszName ;
    int           iAll = m_Decoders.GetNumFilters() ;
    int           iHW  = m_Decoders.GetNumHWFilters() ;
    HRESULT       hrFinal = S_OK ;
	
    //
    // If caller didn't object about VPE, we need to create the 
    // VideoMixer first and then do the Render; otherwise it fails 
    // anyway!!!  If the caller doesn't want VPE, we'll let it
    // fail by not creating VideoMixer and detect the failure using 
    // the DetectFailedHWPin() call.
    //
    // To render the video output pin. We are going to use 
    // overlay mixing for SW decoders
    //
    if (m_bUseVPE)
    {
        // Create VideoMixer, Line21 decoder and Video Renderer here 
        // (just because it's easier)
        hr = CreateFilterInGraph(CLSID_VideoRenderer,
			TEXT("Video Renderer"), &m_pVR) ;
        ASSERT(SUCCEEDED(hr) && m_pVR) ;
        if (FAILED(hr) || NULL == m_pVR)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't start Video Renderer -- no display on monitor"))) ;
            pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;  // can't show CC or Video
            hrFinal = FALSE ;
        }
        hr = CreateFilterInGraph(CLSID_VideoMixer, TEXT("Overlay Mixer"),
			&m_pVM) ;
        if (FAILED(hr) || NULL == m_pVM)
        {
            DbgLog((LOG_ERROR, 1, TEXT("Couldn't start VideoMixer -- no mixing"))) ;
            pStatus->hrVPEStatus = hr ;
            hrFinal = FALSE ;
        }
        hr = CreateFilterInGraph(CLSID_Line21Decoder,
			TEXT("Line21 Decoder"), &m_pL21Dec) ;
        if (FAILED(hr) || NULL == m_pL21Dec)
        {
            DbgLog((LOG_ERROR, 3, TEXT("Couldn't start Line21 Dec -- no CC"))) ;
            hrFinal = FALSE ;
        }
    }
	
    //
    // Assume that video decoder (HW/SW) doesn't produce Line21 data and
    // we don't render it right until we find some proof otherway.
    //
    pStatus->bNoLine21In  = TRUE ;
    pStatus->bNoLine21Out = TRUE ;
	
    //
    // We must not connect the output of any other filter to any pin of the 
    // Video mixer filter (VPMixer/OverlayMixer) until the video decoder's 
    // output pin is connected to its primary input pin.  So if the CC pin
    // or Subpicture pin is enumerated before the video out pin of the decoder,
    // we have to remember to render them later.
    //
    // We should reset these late-rendering-helper-members
    //
    m_dwVideoRenderStatus = 0 ;
    m_pL21PinToRender     = NULL ;
    m_pSPPinToRender      = NULL ;
	
    // render the output pins of all the decoders used
    IPin  *pPinIn ;
    for (i = 0 ; i < iAll ; i++)
    {
        if (! m_Decoders.GetFilter(i, &pDecFilter, &lpszName, &bHW) )
        {
            DbgLog((LOG_ERROR, 0, TEXT("*** INTERNAL ERROR: Can't get filter from decoder list ***"))) ;
			ASSERT(FALSE) ;  // so that we know
            continue ;      // at least avoid faulting
        }
        ASSERT(pDecFilter) ;
        hr = pDecFilter->EnumPins(&pEnumPins) ;
        ASSERT(SUCCEEDED(hr) && pEnumPins) ;
        pEnumPins->Reset() ;
		
        while (S_OK == pEnumPins->Next(1, &pPinOut, &ul) && 1 == ul)
        {
            hr = pPinOut->QueryDirection(&pd) ;
            ASSERT(SUCCEEDED(hr)) ;
            if (PINDIR_INPUT == pd)   // don't want input pin
            {
                pPinOut->Release() ;  // don't need this pin
                continue ;
            }
            hr = pPinOut->ConnectedTo(&pPinIn) ;
            if (SUCCEEDED(hr) && pPinIn)  // don't want connected pin
            { 
                pPinIn->Release() ;      // not interseted in it
                pPinOut->Release() ;     // not this one
                continue ;
            }
			
            //
            // If the decoder is HW based, the proxy doesn't let us enum
            // the supported media types and then connect to a suitable in
            // pin on the other side.
            //
            if (bHW)
                hr = RenderHWOutPin(pPinOut, pStatus) ;
            else
                hr = RenderSWOutPin(pPinOut, pStatus) ;
			
            if (S_OK != hr)       // if not perfect
                hrFinal = hr ;    // use this error code
			
            pPinOut->Release() ;  // done with this pin
			
        }  // end of while (pEnumPins->Next()...)
		
        pEnumPins->Release() ;    // done with this enumerator
    } // end of for (i)
	
    //
    // If the caller didn't object about VPE (i.e, on-screen playback) then connect
    // the video mixer to the video renderer.
    //
    if (m_bUseVPE)
    {
        if (NULL == m_pVM)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Video Mixer didn't start -- no CC at least"))) ;
            // pStatus->bNoLine21Out = TRUE ;  // can't show CC with video
            if (NULL == m_pVR)
            {
                DbgLog((LOG_ERROR, 1, TEXT("WARNING: Video Renderer didn't start!!!"))) ;
                // we have already set the video stream flag in pStatus->dwFailedStreamsFlag
            }
            if (S_OK == hrFinal)  // very unlikely that we didn't know yet
                hrFinal = S_FALSE ;
        }
        else  // we have video mixer and renderer
        {
            //
            // We should connect the VideoMixer and the VideoRenderer ONLY IF
            // connection to OverlayMixer worked. So check for video render flag.
            //
            if (m_dwVideoRenderStatus & VIDEO_RENDER_MIXER)
            {
                hr = FindOpenPin(m_pVM, PINDIR_OUTPUT, 0, &pPinOut) ;
                if (SUCCEEDED(hr) && pPinOut)
                {
                    if (SUCCEEDED(hr = TryConnect(pPinOut, m_pVR, NULL, TRUE)))
                    {
                        DbgLog((LOG_TRACE, 5, TEXT("Connected %s to Video Renderer"),
							(LPCSTR) CDisp(pPinOut))) ;
                    }
                    else  // Extremely unlikely, well impossible. Still...
					{
                        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't connect %s to Video Renderer (Error 0x%lx)"),
							(LPCSTR) CDisp(pPinOut), hr)) ;
                        pStatus->iNumStreamsFailed++ ;
                        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
                        hrFinal = S_FALSE ;
					}
					
                    pPinOut->Release() ;  // let the pin go now
                }
                else  // Extremely unlikely, well impossible. Still...
				{
                    DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't find the output pin of video mixer"))) ;
                    pStatus->iNumStreamsFailed++ ;
                    pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
                    hrFinal = S_FALSE ;
				}
            }
            else
                DbgLog((LOG_TRACE, 1, TEXT("Couldn't connect to OverlayMixer. VM and VR not connected."))) ;
        }
    }
	
    //
    // There is a possibility that the Line21 decoder's out pin was not rendered
    // fully, because the video pin was not connected to the mixer till then. For
    // this case, we have to do the rendering now.
    //
    hr = CompleteLateRender(pStatus) ;
    if (S_OK != hr  &&  SUCCEEDED(hrFinal))
        hrFinal = S_FALSE ;  // hr?
	
    //
    // Remove any unused filters from the graph (is it necessary?)
    //
    RemoveUnusedFilters(pStatus) ;
	
    //
    // If there was some problem with the getting or rendering Line21 data 
    // then indicate the result as partial success (of course if it's not 
    // worse than that already :-).
    //
    if ((pStatus->bNoLine21In || pStatus->bNoLine21Out) && S_OK == hrFinal)
        hrFinal = S_FALSE ;
	
    //
    // Last minute clean-up:
    // 1.  If the "No VPE" flag was specified in the call, don't bother about CC
    // 2.  If there was no line21 data produced by the video decoder then we 
    //     shouldn't feel bad about not being able decode "nothing".
    //
    if (! m_bUseVPE )
    {
        pStatus->bNoLine21In  = FALSE ;
        pStatus->bNoLine21Out = FALSE ;
    }
    else if (pStatus->bNoLine21In)
        pStatus->bNoLine21Out = FALSE ;
	
    return hrFinal ;
}


//
// Check if we have the Line21 decoder and/or the Subpicture decoder's output
// pin unconnected.  If so, AND if the video decoder's output pin has been
// connected already then complete the remaining pending connections.
//
HRESULT CDvdGraphBuilder::CompleteLateRender(AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CompleteLateRender(0x%lx)"),
		pStatus)) ;
	
    HRESULT   hr = NOERROR ;
	
    if (m_dwVideoRenderStatus & VIDEO_RENDER_MIXER)  // only if video connects to OverlayMixer
    {
        if (m_pSPPinToRender)
        {
            if (SUCCEEDED(hr = TryConnect(m_pSPPinToRender, m_pVM, NULL, TRUE)))
            {
                DbgLog((LOG_TRACE, 1, TEXT("Late render of pin %s done"),
					(LPCSTR)(CDisp) m_pSPPinToRender)) ;
            }
            else
            {
                DbgLog((LOG_ERROR, 2, TEXT("WARNING: Pin %s couldn't be late rendered (Error 0x%lx)"),
					(LPCSTR)(CDisp) m_pSPPinToRender, hr)) ;
                hr = E_FAIL ;  // some problem
            }
			
            // We are done with it.  Reset the flag and pointer...
            m_pSPPinToRender->Release() ;
            m_pSPPinToRender = NULL ;
        }
        if (m_pL21PinToRender)
        {
            if (SUCCEEDED(hr = TryConnect(m_pL21PinToRender, m_pVM, NULL, TRUE)))
            {
                DbgLog((LOG_TRACE, 1, TEXT("Late render of pin %s done (Error 0x%lx)"),
					(LPCSTR)(CDisp) m_pL21PinToRender, hr)) ;
                pStatus->bNoLine21Out = FALSE ; // line21 data has been rendered
            }
            else
            {
                DbgLog((LOG_ERROR, 2, TEXT("WARNING: Pin %s couldn't be late rendered"),
					(LPCSTR)(CDisp) m_pL21PinToRender)) ;
                hr = E_FAIL ;  // some problem
            }
			
            // We are done with it.  Reset the flag and pointer...
            m_pL21PinToRender->Release() ;
            m_pL21PinToRender = NULL ;
        }
    }
    else  // video rendering failed somehow -- can't do SP/CC
    {
        if (m_pSPPinToRender)
        {
            // Can't do anything -- release the interface and set SP render failure flag
            m_pSPPinToRender->Release() ;
            m_pSPPinToRender = NULL ;
            if (0 == (pStatus->dwFailedStreamsFlag & AM_DVD_STREAM_SUBPIC)) // if not set yet
            {
                pStatus->iNumStreamsFailed++ ;
                pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_SUBPIC ;
            }
        }
        if (m_pL21PinToRender)
        {
            // Can't do anything -- release the interface and set CC render failure flag
            m_pL21PinToRender->Release() ;
            m_pL21PinToRender = NULL ;
            pStatus->bNoLine21Out = TRUE ;  // couldn't render
        }
    }

    return hr ;
}


BOOL CDvdGraphBuilder::RemoveFilterIfUnused(IBaseFilter *pFilter, 
                                            LPCTSTR lpszFilterName)
{
    IEnumPins  *pEnumPins ;
    HRESULT     hr ;
    IPin       *pPin ;
    IPin       *pPinOther ;
    ULONG       ul ;
    BOOL        bInUse = FALSE ;
	
    if (pFilter)
    {
        hr = pFilter->EnumPins(&pEnumPins) ;
        ASSERT(SUCCEEDED(hr) && pEnumPins) ;
        while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
        {
            pPin->ConnectedTo(&pPinOther) ;
            if (pPinOther)
            {
                pPin->Release() ;
                pPinOther->Release() ;
                bInUse = TRUE ;
                break ;  // done with our search
            }
            pPin->Release() ;
        }
        pEnumPins->Release() ;
        if (!bInUse)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Releasing unncessary filter %s"), lpszFilterName)) ;
            m_pGB->RemoveFilter(pFilter) ;
            pFilter->Release() ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("Filter %s is being used"), lpszFilterName)) ;
        }
    }
	
    return (! bInUse ) ;  // removed / in use
}


HRESULT CDvdGraphBuilder::RemoveUnusedFilters(AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RemoveUnusedFilters(0x%lx)"),
		pStatus)) ;
	
    //
    // Check if Line21 decoder, Video Mixer, Video and Audio Renderer are 
    // unused (and unconnected). If so, remove and free them.
    //
    if (RemoveFilterIfUnused(m_pVM, TEXT("Overlay Mixer")))
        m_pVM = NULL ;
	
    // Line21 decoder is removed if either
    // a) it's not in use, i.e, not connected on either side  or
    // b) it's connected on at least one side, but bLine21In/Out flag is set
    //    indicating the connection wasn't completely successful and CC won't work.
    if (RemoveFilterIfUnused(m_pL21Dec, TEXT("Line21 Decoder")))
        m_pL21Dec = NULL ;
    else if (pStatus->bNoLine21In || pStatus->bNoLine21Out &&  // if somehow CC won't work,
		     m_pL21Dec)                                        // but we have a L21Dec
    {
        DbgLog((LOG_TRACE, 1, TEXT("Line21 decoder was connected, but won't work. Hence removed."))) ;
        m_pGB->RemoveFilter(m_pL21Dec) ;
        m_pL21Dec->Release() ;
        m_pL21Dec = NULL ;
    }
	
    if (RemoveFilterIfUnused(m_pVR, TEXT("VideoRenderer")))
        m_pVR = NULL ;
	
    if (RemoveFilterIfUnused(m_pAR, TEXT("AudioRenderer")))
        m_pAR = NULL ;
	
    return NOERROR ;
}


void CDvdGraphBuilder::RenderUnknownPin(IPin *pPinOut)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderUnknownPin(0x%lx)"),
		pPinOut)) ;
	
	HRESULT   hr = m_pGB->Render(pPinOut) ;
    if (FAILED(hr))
    {
		DbgLog((LOG_TRACE, 3, TEXT("Rendering (%s) failed (Error 0x%lx)"),
			(LPCSTR) CDisp(pPinOut), hr)) ;
    }
    else  // seems to have rendered
    {
        IPin  *pPinIn ;
		pPinOut->ConnectedTo(&pPinIn) ;
        if (pPinIn)
        {
			DbgLog((LOG_TRACE, 3, TEXT("Pin %s with unknown mediatype rendered successfully"),
				(LPCSTR) CDisp(pPinOut))) ;
			pPinIn->Release() ;
        }
        else  // this may be the NTSC out pin
		{
			DbgLog((LOG_TRACE, 3, TEXT("Pin %s with unknown mediatype actually wasn't rendered"),
				(LPCSTR) CDisp(pPinOut))) ;
			// but we don't care anymore about it. So ignore it.
		}
	}
}


HRESULT CDvdGraphBuilder::RenderAudioOutPin(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderAudioOutPin(0x%lx, 0x%lx)"),
			pPinOut, pStatus)) ;
	
	HRESULT   hr ;
	
	if (NULL == m_pAR)
	{
		hr = CreateFilterInGraph(CLSID_DSoundRender, TEXT("DSound Renderer"), &m_pAR) ;
		if (FAILED(hr) || NULL == m_pAR)  // couldn't instantiate audio renderer
        {
		    DbgLog((LOG_ERROR, 0,
			    TEXT("Couldn't instantiate audio renderer (Error 0x%lx)"), hr)) ;
		    pStatus->iNumStreamsFailed++ ;
		    pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_AUDIO ;
			return hr ;
        }
	}
	else	// weird -- who started audio renderer?
		ASSERT(NULL == m_pAR) ;  // so that we know
	
	hr = TryConnect(pPinOut, m_pAR, NULL, FALSE) ;
	if (FAILED(hr))
	{
		DbgLog((LOG_TRACE, 3, 
			TEXT("Couldn't even indirectly connect pin (%s) to audio renderer (Error 0x%lx)"),
			(LPCTSTR) CDisp(pPinOut), hr)) ;
		pStatus->iNumStreamsFailed++ ;
		pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_AUDIO ;
		return hr ;
	}
	
	return NOERROR ;
}


HRESULT CDvdGraphBuilder::ConnectLine21OutPin(IPin *pPinOut)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::ConnectLine21OutPin(0x%lx)"),
			pPinOut)) ;
	
	HRESULT   hr = TryConnect(pPinOut, m_pL21Dec, NULL, TRUE) ;
	if (FAILED(hr))
	{
		DbgLog((LOG_TRACE, 5, 
			TEXT("Couldn't connect Line21 out to Line21Dec (Error 0x%lx)"),
			hr)) ;
		return hr ;
	}

	DbgLog((LOG_TRACE, 5, TEXT("Line21 output connected to Line21 Dec"))) ;
				
	ASSERT(NULL == m_pL21PinToRender) ;
    hr = FindOpenPin(m_pL21Dec, PINDIR_OUTPUT, 0, &m_pL21PinToRender) ;
    ASSERT(SUCCEEDED(hr) && m_pL21PinToRender) ;
				
    //
    // We should connect the Line21 Decoder output to the
    // VideoMixer ONLY IF the decoded video stream has already
    // been connected.
    //
    if (m_dwVideoRenderStatus & VIDEO_RENDER_MIXER)
    {
		DbgLog((LOG_TRACE, 5, TEXT("Going to connect CC output to video mixer..."))) ;
        if (SUCCEEDED(hr = TryConnect(m_pL21PinToRender, m_pVM, NULL, TRUE)))
			DbgLog((LOG_TRACE, 5, TEXT("L21Dec output connected to video mixer"))) ;
        else
			DbgLog((LOG_ERROR, 1, 
				TEXT("WARNING: L21Dec output COULDN'T be connected to Video mixer (Error 0x%lx)"), hr)) ;

        // Don't need to maintain this late rendering info anymore
        m_pL21PinToRender->Release() ;
        m_pL21PinToRender = NULL ;
    }
    else
    {
		DbgLog((LOG_TRACE, 1, TEXT("Video stream not rendered fully. L21Dec render deferred."))) ;
        //
        // There is a chance that we'll be able to do a late render on 
        // this pin after the video pin is rendered. So retain the info 
        // and try at last.
        //
    }

	return hr ;
}


HRESULT CDvdGraphBuilder::RenderHWOutPin(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderHWOutPin(0x%lx, 0x%lx)"),
		pPinOut, pStatus)) ;
	
    HRESULT         hr ;
    HRESULT         hrFinal = S_OK ;
    IPin           *pPinIn ;
    DWORD           dwStream ;
	
    dwStream = StreamFlagForHWPin(pPinOut) ;
	
    if (m_bUseVPE)  // display video (and CC) on screen
    {
        if (AM_DVD_STREAM_VIDEO == dwStream)  // this pin is video (VPE) out
        {
            if (FAILED(hr = TryConnect(pPinOut, m_pVM, NULL, TRUE))) // connect VPE outpin to OverlayMixer
            {
                DbgLog((LOG_TRACE, 1, TEXT("Can't render pin (%s) (Error 0x%lx)"),
					(LPCTSTR) CDisp(pPinOut), hr)) ;
                hrFinal = S_FALSE ;
                pStatus->iNumStreamsFailed++ ;  // video stream not rendered right
                pStatus->dwFailedStreamsFlag |= dwStream ;
                pStatus->hrVPEStatus = hr ;   // TryConnect() returns VPE failure code
            }
            else  // VPE out pin connected !!!
                m_dwVideoRenderStatus = VIDEO_RENDER_MIXER ;
        }
        else if (AM_DVD_STREAM_LINE21 == dwStream)  // this pin is Line21 out
        {
            pStatus->bNoLine21In  = FALSE ;  // CC data produced by decoder
            if (FAILED(hr = ConnectLine21OutPin(pPinOut))) // connect to Line21 Decoder
            {
                hrFinal = S_FALSE ;
                pStatus->bNoLine21Out = TRUE ;   // line21 couldn't be rendered
            }
            else  // Line21 out pin connected !!!
                pStatus->bNoLine21Out = FALSE ;
        }  // end of else if (dwStream == .._LINE21)
		else if (AM_DVD_STREAM_AUDIO == dwStream) // audio out pin (very unlikely)
		{
			hr = RenderAudioOutPin(pPinOut, pStatus) ;
			if (FAILED(hr))
				hrFinal = S_FALSE ;
		}
        else  // didn't connect to known filters -- try to just render
        {
			RenderUnknownPin(pPinOut) ;
        }  // end of else of if (AM_DVD_STREAM_... == dwStream)
    }
    else   // w/o using VPE, i.e, on-screen display
    {
        DbgLog((LOG_TRACE, 4, TEXT("User doesn't want VPE - no Video/CC to be rendered"))) ;
		if (AM_DVD_STREAM_VIDEO == dwStream)
			; // just ignore
		else if (AM_DVD_STREAM_LINE21 == dwStream)
		{
			pStatus->bNoLine21In  = FALSE ;
			pStatus->bNoLine21Out = FALSE ;
		}
		else if (AM_DVD_STREAM_AUDIO == dwStream)
		{
			hr = RenderAudioOutPin(pPinOut, pStatus) ;
			if (FAILED(hr))
				hrFinal = S_FALSE ;
		}
        else  // don't know the media type
        {
			RenderUnknownPin(pPinOut) ;
        }
    }
	
    return hrFinal ;
}


HRESULT CDvdGraphBuilder::RenderSWOutPin(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderSWOutPin(0x%lx, 0x%lx)"),
		pPinOut, pStatus)) ;
	
    IEnumMediaTypes *pEnumMT ;
    ULONG            ul ;
    AM_MEDIA_TYPE   *pmt ;
    HRESULT          hr ;
    HRESULT          hrFinal = S_OK ;
	
    hr = pPinOut->EnumMediaTypes(&pEnumMT) ;
    ASSERT(SUCCEEDED(hr) && pEnumMT) ;
    pEnumMT->Reset() ;
    hr = pEnumMT->Next(1, &pmt, &ul) ;  // getting 1st media type is fine
    ASSERT(SUCCEEDED(hr) && 1 == ul) ;
    if (pmt->majortype == MEDIATYPE_Video)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Going to render 'video' out pin (%s) of decoder"), 
            (LPCTSTR)CDisp(pPinOut))) ;

        //
        // The SW video and SP decoder both output video majortype samples.
        // So we need to distinguish them before we try to connect them and 
        // act accordingly.
        //
        DWORD dwStream = GetInTypeForVideoOutPin(pPinOut) ;
        if (AM_DVD_STREAM_VIDEO  != dwStream &&
            AM_DVD_STREAM_SUBPIC != dwStream)
        {
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: Video out pin not from video or subpic in pin"))) ;
            goto FinalExit ;  // I hate "goto", but otherwise it's too complex
        }
		
        if (NULL == m_pVM)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't start VideoMixer -- no mixing"))) ;
            pStatus->bNoLine21Out = TRUE ;
            if (AM_DVD_STREAM_SUBPIC == dwStream)
            {
                DbgLog((LOG_TRACE, 1, TEXT("Subpic stream not rendered because no videomixer"))) ;
                pStatus->iNumStreamsFailed++ ;
                pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_SUBPIC ;
            }
            else if (AM_DVD_STREAM_VIDEO == dwStream)
            {
                DbgLog((LOG_TRACE, 1, TEXT("Video stream not rendered because no videomixer"))) ;
                pStatus->iNumStreamsFailed++ ;
                pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
            }
            else
            {
                DbgLog((LOG_TRACE, 1, TEXT("Unknown stream (Id: 0x%x) not rendered"), dwStream)) ;
            }
#if 0
            else if (SUCCEEDED(hr = TryConnect(pPinOut, m_pVR, NULL, TRUE)))
            {
                DbgLog((LOG_TRACE, 5, TEXT("Video decoder's output connected to VR"))) ;
                // Though the Video stream has been rendered here, we don't 
                // go through the VideoMixer and hence can't mix the CC (and SP, if any)
                // stream. So we set the m_dwVideoRenderStatus value to VIDEO_RENDER_VR, 
                // which is checked before Line21 Decoder output is connected.
                // (I know it's kind of hacky, but...).
                m_dwVideoRenderStatus = VIDEO_RENDER_VR ;  // connected to VR directly
            }
            else  // very weird, but...
            {
                DbgLog((LOG_ERROR, 1, 
                    TEXT("WARNING: Video decoder's output COULDN'T be connected to VR (Error 0x%lx)"), hr)) ;
                pStatus->iNumStreamsFailed++ ;
                pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
            }
#endif // #if 0
            hrFinal = S_FALSE ;  // not perfect, but...
        }
        else  // VideoMixer started fine; try to connect
        {
            //
            // We should connect the decoded subpicture stream to the
            // VideoMixer ONLY IF the decoded video stream has already
            // been connected.
            //
            if (AM_DVD_STREAM_SUBPIC == dwStream)
            {
                if (m_dwVideoRenderStatus & VIDEO_RENDER_MIXER)
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Going to connect subpic output to video mixer..."))) ;
                    if (SUCCEEDED(hr = TryConnect(pPinOut, m_pVM, NULL, TRUE)))
                    {
                        DbgLog((LOG_TRACE, 5, TEXT("subpic output connected to video mixer's 2nd+ in pin"))) ;
                    }
                    else
                    {
                        DbgLog((LOG_ERROR, 1, 
                            TEXT("WARNING: Subpic output COULDN'T be connected to Video mixer (Error 0x%lx)"), hr)) ;
                        pStatus->iNumStreamsFailed++ ;
                        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_SUBPIC ;
                    }
                }
                else
                {
                    DbgLog((LOG_TRACE, 1, TEXT("Video stream not rendered fully. Subpic render deferred."))) ;
                    //
                    // We'll do a late render on this pin after the video pin is
                    // rendered. So retain the info and try at last.
                    //
                    m_pSPPinToRender = pPinOut ;  // maintain this out pin as SP out pin
                    m_pSPPinToRender->AddRef() ;  // because we release it after late render
                }
            }
            else  // it's the decoded video output pin
            {
                // Make sure that the video out pin is not already connected,
                // in which case the following connection to VR is unnecessary
                // (and will fail causing a wrong flag to be set).
                if (m_dwVideoRenderStatus & VIDEO_RENDER_MIXER)
                {
                    // We should not hit this code at all.  But if we ever do,
                    // just get out of here.
                    DbgLog((LOG_TRACE, 0, 
                            TEXT("WARNING: Pin <%s> is video? But video is already connected to mixer!!"),
                            (LPCSTR) CDisp(pPinOut))) ;
                }
                else  // let's try to connect video to OverlayMixer
                {
                    if (SUCCEEDED(hr = TryConnect(pPinOut, m_pVM, NULL, TRUE)))  // set video to mixer flag
                    {
                        DbgLog((LOG_TRACE, 5, TEXT("Video Dec output connected to VideoMixer"))) ;
                        m_dwVideoRenderStatus = VIDEO_RENDER_MIXER ;  // video pin connected to mixer
                    }
                    else  // try to connect video to VR as last resort
                    {
                        DbgLog((LOG_ERROR, 1, 
                            TEXT("WARNING: Video Dec output COULDN'T be connected to VideoMixer (Error 0x%lx)"), hr)) ;
                        pStatus->hrVPEStatus = hr ;  // pass the error code up the app
                        pStatus->iNumStreamsFailed++ ;
                        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
                        m_dwVideoRenderStatus = VIDEO_RENDER_FAILED ;  // just can't render video
                        hrFinal = S_FALSE ;  // not perfect, but...

                        // We won't try connecting to the VR directly in this case.
#if 0
                        if (SUCCEEDED(hr = TryConnect(pPinOut, m_pVR, NULL, TRUE)))  // just try to connect to video renderer
                        {
                            DbgLog((LOG_TRACE, 5, TEXT("Video decoder's output directly connected to VR"))) ;
						    // Though the Video stream has been rendered here, we don't 
						    // go through the VideoMixer and hence can't mix the CC (and SP, if any)
						    // stream. So we set the m_dwVideoRenderStatus value to VIDEO_RENDER_VR
                            // so that we know that we got the video out pin, but CC / SP streams
                            // can't be mixed/rendered.
                            m_dwVideoRenderStatus = VIDEO_RENDER_VR ;  // video is rendered, but....
                        }
                        else  // very very weird
                        {
                            DbgLog((LOG_ERROR, 1, 
                                TEXT("WARNING: Video decoder's output COULDN'T be connected to VR (Error 0x%lx)"), hr)) ;
                            pStatus->iNumStreamsFailed++ ;
                            pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
                            m_dwVideoRenderStatus = VIDEO_RENDER_FAILED ;  // just can't render video
                        }
#endif // #if 0
                    }  // end of else of if (TryConnect(.., VM, ..)
                }  // end of else of if (m_dwVideoRenderStatus & ..MIXER)
            }  // end of else of if (subpicture stream)
        }  // end of else of if (no VideoMixer)
    }  // end of if (mediatype is video)
    else if (pmt->majortype == MEDIATYPE_Audio)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Going to render 'audio' out pin (%s) of decoder"), 
            (LPCTSTR)CDisp(pPinOut))) ;

        hr = RenderAudioOutPin(pPinOut, pStatus) ;
        if (FAILED(hr))
            hrFinal = S_FALSE ;  // not perfect, but...
    }  // end of if (mediatype is audio)
    else if (pmt->majortype == MEDIATYPE_AUXLine21Data)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Going to render 'line21' out pin (%s) of decoder"), 
            (LPCTSTR)CDisp(pPinOut))) ;

        pStatus->bNoLine21In = FALSE ;  // got line21 data input
		
        //
        // When the video is being decoded in SW and the caller doesn't
        // want to use VPE (i.e, not on monitor), we can't show CC too;
        // there is no point trying to render the Line21 output pin.
        //
        if (NULL == m_pVM)
        {
            DbgLog((LOG_TRACE, 1, TEXT("WARNING: not Video Mixer => no CC rendering"))) ;
            hrFinal = S_FALSE ;   // not perfect, but...
            pStatus->bNoLine21Out = TRUE ;  // CC not available
        }
        else
        {
            //
            // There is a Video Mixer. So we should decode Line21 data and mix 
            // it with the video stream.
            //
            if (FAILED(hr = ConnectLine21OutPin(pPinOut))) // connect to Line21 Decoder
            {
                hrFinal = S_FALSE ;
                pStatus->bNoLine21Out = TRUE ;   // line21 couldn't be rendered
            }
            else  // Line21 out pin connected !!!
                pStatus->bNoLine21Out = FALSE ;
        }   // end of else of if (NULL == m_pVM)
    }   // end of else if (majortype == AUXLine21Data)
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: a non-audio/video/line21 out pin!!"))) ;
    }
	
FinalExit:
    DeleteMediaType(pmt) ;
    pEnumMT->Release() ;  // done with Media Type enum
	
    return hrFinal ;
}



//
// Helper function to detect a (in) pin from its connection mediatype
//
DWORD CDvdGraphBuilder::GetStreamFromMediaType(IPin *pPin)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetStreamFromMediaType(%s)"), 
        (LPCSTR) CDisp(pPin))) ;

    DWORD           dwStream = 0 ;
    AM_MEDIA_TYPE   mt ;

    HRESULT hr = pPin->ConnectionMediaType(&mt) ;
    ASSERT(SUCCEEDED(hr)) ;
    if ( mt.majortype == MEDIATYPE_MPEG2_PES ||
         mt.majortype == MEDIATYPE_DVD_ENCRYPTED_PACK ||
         mt.majortype == MEDIATYPE_Video )
    {
        if (mt.subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            dwStream = AM_DVD_STREAM_VIDEO ;
        else if (mt.subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            dwStream = AM_DVD_STREAM_SUBPIC ;
        else
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: Non-video/SP subtype for video data!!!"))) ;
    }
    else if ( mt.majortype == MEDIATYPE_MPEG2_PES ||
         mt.majortype == MEDIATYPE_DVD_ENCRYPTED_PACK ||
         mt.majortype == MEDIATYPE_Audio )
    {
        if (mt.subtype == MEDIASUBTYPE_DOLBY_AC3)
            dwStream = AM_DVD_STREAM_AUDIO ;
        else
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: Non-audio subtype for audio data!!!"))) ;
    }
    else
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Unknown media type!!!"))) ;

    FreeMediaType(mt) ;  // release the mediatype

    return dwStream ;
}


//
// Given a video output pin, we try to figure out if the input type is video 
// (and subpic) or if it is subpic only.  Because based on that we'll do 
// immediate or deferred pin connect.
//
DWORD CDvdGraphBuilder::GetInTypeForVideoOutPin(IPin *pPinOut)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetInTypeForVideoOutPin(%s)"), (LPCSTR) CDisp(pPinOut))) ;

    if (NULL == pPinOut)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Can't get input type for a NULL out pin"),
                (LPCSTR) CDisp(pPinOut))) ;
        return 0 ;
    }

    HRESULT  hr ;
    DWORD    dwStream = 0 ;

    //
    // See if the decoder has any in pin to out pin internal connection info.
    //
    // NOTE:
    // We only expect that in case the out pin has internal connections to more 
    // than 1 in pins then the real in pin be listed first by 
    // QueryInternalConnection() implementation.
    //
    ULONG  ulNum = 0 ;
    IPin  *apPinIn[5] ; // 5 is way too much here
    hr = pPinOut->QueryInternalConnections(apPinIn, &ulNum) ;
    // I am not sure if we should check for S_FALSE or S_OK return from the 
    // above call. So I am using SUCCEEDED().
    if (SUCCEEDED(hr) && ulNum > 0)  // Yahoo!! QueryInternalConnection is supported!!!
    {
        DbgLog((LOG_TRACE, 3, 
            TEXT("Using QueryInternalConnections() to detect in pin of <%s>"), 
            (LPCTSTR) CDisp(pPinOut))) ;
        ASSERT(ulNum <= 5) ;  // just to be sure
        hr = pPinOut->QueryInternalConnections(apPinIn, &ulNum) ;
        if (S_OK == hr)
        {
            if (ulNum > 1)
                DbgLog((LOG_TRACE, 3, 
                    TEXT("** We expect the real in pin to be listed first **"))) ;

            dwStream = GetStreamFromMediaType(apPinIn[0]) ;  // look at 1st pin only

            // Remember to release the IPin interfaces before leaving
            for (ULONG ul = 0 ; ul < ulNum ; ul++)
                apPinIn[ul]->Release() ;

            if (dwStream)          // if we know what it is...
                return dwStream ;  // ...we are done.
        }
    }

    //
    // The filter doesn't give any in pin to out pin internal connection info.
    // So we have to (kind of hack to) find out what type in pin its filter
    // has; there is a possibility that there will be more than 1 in pin in the 
    // filter (as in MediaMatics case), in which case we have to trust that 
    // the video in pin enumerates first, failing which we'll mistake the video out
    // pin as the SP out pin and connection may fail.
    //
    PIN_INFO  pi ;
    hr = pPinOut->QueryPinInfo(&pi) ;
    ASSERT(SUCCEEDED(hr)) ;
    if (NULL == pi.pFilter)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Out pin's filter pointer is NULL"),
                (LPCSTR) CDisp(pPinOut))) ;
        return 0 ;
    }
    IEnumPins *pEnumPins ;
    hr = pi.pFilter->EnumPins(&pEnumPins) ;
    ASSERT(SUCCEEDED(hr) && pEnumPins) ;
    ULONG  ul ;
    IPin  *pPin ;
    PIN_DIRECTION  pd ;
    DWORD  dw ;
    BOOL   bVideoIgnored = FALSE ;  // a way to remember we found a video in pin
    while ( 0 == dwStream  &&
            S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
    {
        hr = pPin->QueryDirection(&pd) ;
        ASSERT(SUCCEEDED(hr)) ;
        if (PINDIR_INPUT == pd)
        {
            dw = GetStreamFromMediaType(pPin) ;
            if (AM_DVD_STREAM_VIDEO == dw)  // We got a video in pin
            {
                // HACK: **
                // We want to make sure we are not mistaking the SP out as 
                // video out, but there is no good way left.
                if (VIDEO_RENDER_NONE != m_dwVideoRenderStatus)  // we already got the video out pin
                {
                    DbgLog((LOG_TRACE, 1, 
                        TEXT("We have already got a video out pin. Try after <%s>..."), 
                        (LPCTSTR) CDisp(pPin))) ;
                    bVideoIgnored = TRUE ;
                }
                else    // this is "most likely" to be the video stream
                    dwStream = AM_DVD_STREAM_VIDEO ;
            }
            else if (AM_DVD_STREAM_AUDIO  == dw ||
                     AM_DVD_STREAM_SUBPIC == dw)
                dwStream = dw ;
            else
                DbgLog((LOG_TRACE, 1, TEXT("WARNING: Unknown stream (%lu) found"), dw)) ;
        } // end of if (pd == INPUT)

        pPin->Release() ;  // let the pin go
    }
    pEnumPins->Release() ;
    pi.pFilter->Release() ;

    // (Corresponding) HACK: **
    // if we ignored the video stream, recognize that here
    if (0 == dwStream && bVideoIgnored)
        dwStream = AM_DVD_STREAM_VIDEO ;

    return dwStream ;
}


//
// Try connecting a given output pin to some input pin of the given filter
// that supports the given mediatype
//
HRESULT CDvdGraphBuilder::TryConnect(IPin *pPinOut, IBaseFilter *pFilter,
                                     CMediaType *pmt, BOOL bDirect)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::TryConnect(0x%lx, 0x%lx, 0x%lx, %d)"),
		pPinOut, pFilter, pmt, bDirect)) ;
	
    HRESULT        hr ;
    HRESULT        hrFinal = E_FAIL ;  // suspected at first
    IEnumPins     *pEnumPins ;
    ULONG          ul ;
    IPin          *pPinIn ;
    IPin          *pPin ;
    PIN_DIRECTION  pd ;
	
    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Can't connect %s to a NULL filter"),
			(LPCSTR) CDisp(pPinOut))) ;
        return E_INVALIDARG ;
    }
    if (NULL == pPinOut)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Can't connect a NULL out pin to a filter"))) ;
        return E_INVALIDARG ;
    }
	
    hr = pFilter->EnumPins(&pEnumPins) ;
    if (FAILED(hr) || NULL == pEnumPins)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: pin enum on filter failed!!"))) ;
        return E_UNEXPECTED ;
    }
	
    while (FAILED(hrFinal)  &&
		S_OK == pEnumPins->Next(1, &pPinIn, &ul) && 1 == ul)
    {
        hr = pPinIn->QueryDirection(&pd) ;
        ASSERT(SUCCEEDED(hr)) ;
        if (PINDIR_INPUT == pd)
        {
            hr = pPinIn->ConnectedTo(&pPin) ; // check if pin is already connected
            if (FAILED(hr) || NULL == pPin)   // only if not yet connected...
            {
                if (bDirect)  // must connect directly
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Connect direct out pin (%s) to (%s)"),
                        (LPCSTR) CDisp(pPinOut), (LPCSTR) CDisp(pPinIn))) ;
                    hr = m_pGB->ConnectDirect(pPinOut, pPinIn, NULL) ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Connect indirect out pin (%s) to (%s)"),
                        (LPCSTR) CDisp(pPinOut), (LPCSTR) CDisp(pPinIn))) ;
                    hr = m_pGB->Connect(pPinOut, pPinIn) ;
                }
                if (SUCCEEDED(hr))
                {             
                    DbgLog((LOG_TRACE, 5, TEXT("Connected out pin to a pin of the given filter"))) ;
                    hrFinal = S_OK ;  // we connected!!!
                }
                else
                    hrFinal = hr ;    // this is the actual error
            }
            else  // in pin already connected, skip it.
                pPin->Release() ;  // we don't need the other pin anyway
        }
        pPinIn->Release() ;  // done with this pin
    }
    pEnumPins->Release() ;
	
    return hrFinal ;
}


//
// Instantiate all the HW decoders registered under DVD Hardware Decoder
// group under the Active Filters category.
//

HRESULT CDvdGraphBuilder::CreateDVDHWDecoders(CListDecoders *pHWDecList)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateDVDHWDecoders(0x%lx)"),
		pHWDecList)) ;
	
    HRESULT  hr ;
    ICreateDevEnum *pCreateDevEnum ;
    hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
		IID_ICreateDevEnum, (void**)&pCreateDevEnum) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't create system dev enum (Error 0x%lx)"), hr)) ;
        return hr ;
    }
	
    IEnumMoniker *pEnumMon ;
    hr = pCreateDevEnum->CreateClassEnumerator(CLSID_DVDHWDecodersCategory, 
		&pEnumMon, 0) ;
    pCreateDevEnum->Release() ;
	
    if (S_OK != hr)
    {
        DbgLog((LOG_ERROR, 0, 
			TEXT("WARNING: Couldn't create class enum for DVD HW Dec category (Error 0x%lx)"), 
			hr)) ;
        return E_FAIL ;
    }
	
    hr = pEnumMon->Reset() ;
    
    ULONG     ul ;
    IMoniker *pMon ;
    TCHAR     achName[50] ;  // big enough??
    TCHAR     achFriendlyName[50] ;
    TCHAR     achClsid[50] ;
    while(S_OK == pEnumMon->Next(1, &pMon, &ul) && 1 == ul)
    {
#if 0
        WCHAR   *wszName ;
        pMon->GetDisplayName(0, 0, &wszName) ;
#ifdef UNICODE
        lstrcpy(achName, wszName) ;
#else
        WideCharToMultiByte(CP_ACP, 0, wszName, -1, achName, 50, NULL, NULL) ;
#endif // #if UNICODE
        DbgLog((LOG_TRACE, 5, TEXT("Moniker enum: %s"), achName)) ;
        CoTaskMemFree(wszName) ;
#endif // #if 0
        
        IBaseFilter *pFilter ;
        hr = pMon->BindToObject(0, 0, IID_IBaseFilter, (void**)&pFilter) ;
        if (FAILED(hr) ||  NULL == pFilter)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't create HW dec filter (Error 0x%lx)"), hr)) ;
            pMon->Release() ;
            continue ;
        }
        DbgLog((LOG_TRACE, 5, TEXT("HW decoder filter found"))) ;
        
        IPropertyBag *pPropBag ;
        pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag) ;
        if(pPropBag)
        {
            {
                VARIANT var ;
                var.vt = VT_EMPTY ;
                pPropBag->Read(L"DevicePath", &var, 0) ;
#ifdef UNICODE
                lstrcpy(achName, var.bstrVal) ;
#else
                WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, achName, 50, NULL, NULL) ;
#endif // #if UNICODE
                DbgLog((LOG_TRACE, 5, TEXT("DevicePath: %s"), achName)) ;
            }
            
            {
                VARIANT var;
                var.vt = VT_EMPTY;
                pPropBag->Read(L"FriendlyName", &var, 0);
#ifdef UNICODE
                lstrcpy(achName, var.bstrVal) ;
#else
                WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, achFriendlyName, 50, NULL, NULL) ;
#endif // #if UNICODE
                DbgLog((LOG_TRACE, 5, TEXT("FriendlyName: %s"), achFriendlyName)) ;
            }
            
            {
                VARIANT var;
                var.vt = VT_EMPTY;
                pPropBag->Read(L"CLSID", &var, 0);
#ifdef UNICODE
                lstrcpy(achClsid, var.bstrVal) ;
#else
                WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, achClsid, 50, NULL, NULL) ;
#endif // #if UNICODE
                DbgLog((LOG_TRACE, 5, TEXT("CLSID: %s"), achClsid)) ;
            }
            
            //
            // We have got a device under the required category. The proxy
            // for it is already instantiated. So add to the list of HW 
            // decoders to be used for building the graph.
            //
            pHWDecList->AddFilter(pFilter, achFriendlyName, TRUE, NULL) ;
            
            pPropBag->Release() ;
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: BindToStorage failed"))) ;
        }
        
        pMon->Release() ;
    }  // end of while()
    
    pEnumMon->Release() ;
	
    DbgLog((LOG_TRACE, 5, TEXT("Found total %d HW decoders"), pHWDecList->GetNumHWFilters())) ;
	
    return NOERROR ;
	
}



//
// Get the stream mediatype flag from the pin of the SW decoder.
// It's a hack to guess the media stream.
//
DWORD CDvdGraphBuilder::StreamFlagFromSWPin(IPin *pPin)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::StreamFlagFromSWPin(%s)"), 
            (LPCTSTR)CDisp(pPin))) ;
	
    AM_MEDIA_TYPE    *pmt ;
    IEnumMediaTypes  *pEnumMT ;
    HRESULT hr = pPin->EnumMediaTypes(&pEnumMT) ;
    ASSERT(SUCCEEDED(hr) && pEnumMT) ;
    ULONG   ul ;
    DWORD   dwStream = 0 ;
    while (0 == dwStream  &&  // we haven't got a known mediatype
		S_OK == pEnumMT->Next(1, &pmt, &ul) && 1 == ul) // more mediatypes
    {
        // Decipher the mediatype
        if (pmt->majortype == MEDIATYPE_MPEG2_PES  ||
            pmt->majortype == MEDIATYPE_DVD_ENCRYPTED_PACK)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is MPEG2_PES/DVD_ENCRYPTED_PACK"))) ;
			
            if (pmt->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_VIDEO"))) ;
                dwStream = AM_DVD_STREAM_VIDEO ;
            }
            else if (pmt->subtype == MEDIASUBTYPE_DOLBY_AC3)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is DOLBY_AC3"))) ;
                dwStream = AM_DVD_STREAM_AUDIO ;
            }
            else if (pmt->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_Subpicture"))) ;
                dwStream = AM_DVD_STREAM_SUBPIC ;
            }
            else
            {
                DbgLog((LOG_ERROR, 1, TEXT("WARNING: Unknown subtype %s"),
					(LPCSTR) CDisp(pmt->subtype))) ;
            }
        }
		
#if 0  // NOT needed for now
        else if (pmt->majortype == MEDIATYPE_AUX_Line21Data)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Line21 data"))) ;
			
            if (pmt->subtype == MEDIASUBTYPE_Line21_GOPPacket ||
                pmt->subtype == MEDIASUBTYPE_Line21_BytePair)
                dwStream =  AM_DVD_STREAM_LINE21 ;
		}
#endif // #if 0
		
        else if (pmt->majortype == MEDIATYPE_Video)  // elementary stream
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Video elementary"))) ;
			
            if (pmt->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_SUBPICTURE"))) ;
                dwStream =  AM_DVD_STREAM_SUBPIC ;
            }
            else if (pmt->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_VIDEO"))) ;
                dwStream =  AM_DVD_STREAM_VIDEO ;
            }
            else
                DbgLog((LOG_TRACE, 5, TEXT("WARNING: Unknown subtype %s"),
				(LPCSTR) CDisp(pmt->subtype))) ;
        }
        else if (pmt->majortype == MEDIATYPE_Audio)  // elementary stream
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Audio elementary"))) ;
            dwStream =  AM_DVD_STREAM_AUDIO ;
        }
        // 
        // There is a chance that some IHV/ISV creates a private mediatype 
        // (major or sub) as in the case of IBM (for CSS filter). We have to
        // search the parts of the mediatype to locate something we recognize.
        // 
        else 
        {
            DbgLog((LOG_TRACE, 2, 
                TEXT("Unknown mediatype %s:%s -- may be IHV/ISV-specific mediatype"),
                (LPCSTR) CDisp(pmt->majortype), (LPCSTR) CDisp(pmt->subtype))) ;
            if (pmt->subtype == MEDIASUBTYPE_DOLBY_AC3)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Audio"))) ;
                dwStream = AM_DVD_STREAM_AUDIO ;
            }
            else if (pmt->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Video"))) ;
                dwStream = AM_DVD_STREAM_VIDEO ;
            }
            else if (pmt->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Subpicture"))) ;
                dwStream = AM_DVD_STREAM_SUBPIC ;
            }
            else
            {
                // As of today, we don't know of any other media stream stype.
                // If more becomes known, we'll add them here and create a flag
                // in the AM_DVD_STREAM_FLAGS type.
                DbgLog((LOG_TRACE, 2, TEXT("WARNING: Unknown mediatype. Couldn't detect at all."))) ;
            }
        }
		
        DeleteMediaType(pmt) ;
    }  // end of while()
    pEnumMT->Release() ;
	
    return dwStream ;
}


DWORD CDvdGraphBuilder::StreamFlagForHWPin(IPin *pPin)
{
    DbgLog((LOG_TRACE, 5, TEXT("CDvdGraphBuilder::StreamFlagForHWPin(0x%lx)"), pPin)) ;
	
    ASSERT(pPin) ;  // so that we know
    if (NULL == pPin)
        return 0 ;
	
	DWORD     dwStream = 0 ;
    ULONG   ul ;
	AM_MEDIA_TYPE *pmt ;
	IEnumMediaTypes *pEnumMT ;
    HRESULT hr = pPin->EnumMediaTypes(&pEnumMT) ;
    ASSERT(SUCCEEDED(hr) && pEnumMT) ;
    while (0 == dwStream  &&
		S_OK == pEnumMT->Next(1, &pmt, &ul) && 1 == ul) // more mediatypes
    {
        if (pmt->majortype == MEDIATYPE_Video)
			dwStream = AM_DVD_STREAM_VIDEO ;
		else if (pmt->majortype == MEDIATYPE_Audio)
			dwStream = AM_DVD_STREAM_AUDIO ;
		else if (pmt->majortype == MEDIATYPE_AUXLine21Data)
			dwStream = AM_DVD_STREAM_LINE21 ;
		else
			DbgLog((LOG_TRACE, 3, TEXT("Unknown mediatype (%s:%s) for HW pin (%s)"), 
			    (LPCTSTR) CDisp(pmt->majortype), (LPCTSTR) CDisp(pmt->subtype), 
                (LPCTSTR) CDisp(pPin))) ;
		
		DeleteMediaType(pmt) ; // dne with this MT
	}  // end of while()
	pEnumMT->Release() ; // done with MT enum
	
    return dwStream ;
}



//
//  Implementation of the CListDecoders class...
//

CListDecoders::CListDecoders(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::CListDecoders()"))) ;
	
    m_iCount = 0 ;
    m_iHWCount = 0 ;
    for (int i = 0 ; i < DECLIST_MAX ; i++)
    {
        m_apFilters[i] = NULL ;
        m_alpszName[i] = NULL ;
        m_apClsid[i]   = NULL ;
        m_abIsHW[i]    = FALSE ;
    }
}


CListDecoders::~CListDecoders(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::~CListDecoders()"))) ;
	
    // We don't want to do CleanAll() here to avoid releasing the decoders
    // that might be in use. The decoders are freed in the DVD Graph Builder
    // object's destructor as we don't need the decoders any more.
    FreeAllMem() ;
}


void CListDecoders::CleanAll(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::CleanAll()"))) ;
	
    // don't have a pointer to the graph, so cache it here from the
    // the first filter.
    IFilterGraph *pGraph = 0;
    
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (m_apFilters[i])
        {
            if(pGraph == 0)
            {
                FILTER_INFO fi;
                HRESULT hr = m_apFilters[i]->QueryFilterInfo(&fi);
                pGraph = fi.pGraph;
				
                ASSERT(pGraph || FAILED(hr)); // filter not on our list if not in graph
            }
            if(pGraph) {
                EXECUTE_ASSERT(SUCCEEDED(pGraph->RemoveFilter(m_apFilters[i])));
            }
			
            DbgLog((LOG_TRACE, 5, TEXT("Going to release decoder #%d"), i)) ;
            m_apFilters[i]->Release() ;
            m_apFilters[i] = NULL ;
        }
        if (m_alpszName[i])
        {
            delete m_alpszName[i] ;
            m_alpszName[i] = NULL ;
        }
        if (m_apClsid[i])
        {
            delete m_apClsid[i] ;
            m_apClsid[i] = NULL ;
        }
        m_abIsHW[i] = FALSE ;
    }
	
    if(pGraph) {
        pGraph->Release();
    }
    
    m_iCount = 0 ;
    m_iHWCount = 0 ;
}


void CListDecoders::FreeAllMem(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::FreeAllMem()"))) ;
	
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (m_alpszName[i])
        {
            delete m_alpszName[i] ;
            m_alpszName[i] = NULL ;
        }
        if (m_apClsid[i])
        {
            delete m_apClsid[i] ;
            m_apClsid[i] = NULL ;
        }
        m_abIsHW[i] = FALSE ;
    }
    m_iCount = 0 ;
    m_iHWCount = 0 ;
}

BOOL CListDecoders::AddFilter(IBaseFilter *pFilter, LPTSTR lpszName, BOOL bHW, GUID *pClsid)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::AddFilter(0x%lx, %s, %d, 0x%lx)"),
		pFilter, lpszName, bHW, pClsid)) ;
	
    if (m_iCount >= DECLIST_MAX)
    {
        DbgLog((LOG_ERROR, 1, TEXT("INTERNAL ERROR: Too many filters added to CListDecoders"))) ;
        return FALSE ;
    }
    if (!bHW && NULL == pClsid)
    {
        DbgLog((LOG_ERROR, 1, TEXT("INTERNAL ERROR: NULL Clsid spcified for HW decoder"))) ;
        return FALSE ;
    }
	
    m_alpszName[m_iCount] = new TCHAR [lstrlen(lpszName) + 1] ;
    if (NULL == m_alpszName[m_iCount])
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: CListDecoders::AddFilter() -- Out of memory for filter name"))) ;
        return FALSE ;
    }
    lstrcpy(m_alpszName[m_iCount], lpszName) ;
    //
    // We store Clsid ONLY for SW decs (HW decs get filter pointer thru' DevEnum and we
    // don't instantiate them, so we don't bother about it)
    //
    if (!bHW)  // SW dec
    {
        m_apClsid[m_iCount] = (GUID *) new BYTE[sizeof(GUID)] ;
        if (NULL == m_apClsid[m_iCount])
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: CListDecoders::AddFilter() -- Out of memory for Clsid"))) ;
            delete m_alpszName[m_iCount] ;  // free the name string too
            return FALSE ;
        }
        *m_apClsid[m_iCount] = *pClsid ;
    }
    else
        m_apClsid[m_iCount] = NULL ;
	
    ASSERT(pFilter) ;
    m_apFilters[m_iCount] = pFilter ;
    m_abIsHW[m_iCount] = bHW ;
    m_iCount++ ;
    if (bHW)
        m_iHWCount++ ;
	
    return TRUE ;
}


BOOL CListDecoders::GetFilter(int i, IBaseFilter **ppFilter, LPTSTR *lpszName, BOOL *pbHW)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::GetFilter(%d, 0x%lx, 0x%lx, %d)"),
		i, ppFilter, lpszName, pbHW)) ;
	
    if (i > m_iCount)
    {
        DbgLog((LOG_ERROR, 1, TEXT("INTERNAL ERROR: Bad index (%d) for CListDecoders::GetFilter()"), i)) ;
        *ppFilter = NULL ;
        *pbHW = FALSE ;
        return FALSE ;
    }
	
    *ppFilter = m_apFilters[i] ;
    *lpszName = m_alpszName[i] ;
    *pbHW = m_abIsHW[i] ;
    return TRUE ;
}


int CListDecoders::GetList(IBaseFilter **ppFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::GetList(0x%lx)"), ppFilter)) ;
	
    if (0 == m_iCount)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Empty decoder list"))) ;
        *ppFilter = NULL ;
        return 0 ;
    }
    *ppFilter = (IBaseFilter *) CoTaskMemAlloc(m_iCount * sizeof(IBaseFilter *)) ;
    if (NULL == *ppFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Out of memory for decoder list"))) ;
        return 0 ;
    }
    for (int i = 0 ; i < m_iCount ; i++)
        ppFilter[i] = m_apFilters[i] ;
	
    return m_iCount ;
}


int CListDecoders::IsInList(BOOL bHW, LPVOID pDec)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::IsInList(%d, 0x%lx)"), bHW, pDec)) ;
	
    GUID        *pClsid ;
    IBaseFilter *pFilter ;
    if (bHW)
        pFilter = (IBaseFilter *) pDec ;
    else
        pClsid = (GUID *) pDec ;
	
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (bHW != m_abIsHW[i])  // dec type mismatch...
        {
            DbgLog((LOG_TRACE, 5, TEXT("Got a %s decoder looking for a %s decoder (i = %d)"),
				m_abIsHW[i] ? TEXT("HW") : TEXT("SW"),
				bHW ? TEXT("HW") : TEXT("SW"), i)) ;
            continue ;          // ...can't be this one
        }
		
        if (bHW)
        {
            if (pFilter == m_apFilters[i])
                return i ;
        }
        else
        {
            ASSERT(m_apClsid[i]) ;
            if (*pClsid == *m_apClsid[i])
                return i ;
        }
    }
	
    return DECLIST_NOTFOUND ;  // didn't match any
}


//
//  Implementation of the CListIntFilters class...
//
CListIntFilters::CListIntFilters(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::CListIntFilters()"))) ;

    CleanAll() ;  // start clean
}


CListIntFilters::~CListIntFilters(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::~CListIntFilters()"))) ;
	
    RemoveAll() ;  // make sure no such filters remains in graph
}


void CListIntFilters::CleanAll(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::CleanAll()"))) ;
	
    for (int i = 0 ; i < MAX_INT_FILTERS ; i++)
    {
        m_apFilters[i]   = NULL ;
        m_aNumInPins[i]  = 0 ;
        m_aNumOutPins[i] = 0 ;
    }
    m_iCount = 0 ;
}


void CListIntFilters::RemoveAll(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::RemoveAll()"))) ;
	
    // Don't have a pointer to the graph, so cache it here from the
    // the first filter.
    IFilterGraph *pGraph = NULL ;
    
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (m_apFilters[i])
        {
#ifdef DEBUG
            FILTER_INFO  fi ;
            m_apFilters[i]->QueryFilterInfo(&fi) ;
            fi.pGraph->Release() ;
            TCHAR  achName[MAX_FILTER_NAME] ;
#ifdef UNICODE
            lstrcpy(achName, fi.achName) ;
#else
            WideCharToMultiByte(CP_ACP, 0, fi.achName, -1,
						        achName, MAX_FILTER_NAME, NULL, NULL) ;
#endif // UNICODE
            DbgLog((LOG_TRACE, 5, TEXT("Intermediate filter #%d: <%s>"), i, achName)) ;
#endif // DEBUG
            if (NULL == pGraph)
            {
                FILTER_INFO fi ;
                HRESULT hr = m_apFilters[i]->QueryFilterInfo(&fi) ;
                pGraph = fi.pGraph ;
				
                ASSERT(pGraph || FAILED(hr)) ; // filter not on our list if not in graph
            }
            if (pGraph)
                EXECUTE_ASSERT(SUCCEEDED(pGraph->RemoveFilter(m_apFilters[i]))) ;

            DbgLog((LOG_TRACE, 5, TEXT("Going to release intermediate filter #%d"), i)) ;
            m_apFilters[i]->Release() ;
            m_apFilters[i]   = NULL ;
            m_aNumInPins[i]  = 0 ;
            m_aNumOutPins[i] = 0 ;
        }
    }
    if (pGraph)
        pGraph->Release() ;

    m_iCount = 0 ;
}


BOOL CListIntFilters::IsInList(IBaseFilter *pFilter)
{
    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Null filter pointer passed to CListIntFilters::IsInList()"))) ;
        ASSERT(pFilter) ;
        return FALSE ;
    }

    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (IsEqualObject(pFilter, m_apFilters[i]))
            return TRUE ;  // got a match
    }
    return FALSE ;  // no match ==> not in list
}


BOOL CListIntFilters::AddFilter(IBaseFilter *pFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::AddFilter(0x%lx)"), pFilter)) ;
	
    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Null filter pointer passed to CListIntFilters::AddFilter()"))) ;
        ASSERT(pFilter) ;
        return FALSE ;
    }

    if (m_iCount >= MAX_INT_FILTERS)
    {
        DbgLog((LOG_ERROR, 1, TEXT("INTERNAL ERROR: Too many filters added to CListIntFilters"))) ;
        ASSERT(m_iCount < MAX_INT_FILTERS) ;
        return FALSE ;
    }

    // Check if this filter is already in our list -- if so, just return
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (IsEqualObject(pFilter, m_apFilters[i]))
            return TRUE ;  // we are done
    }

    // It's NOT already in our list -- add it now
    m_apFilters[m_iCount] = pFilter ;

    //
    // Now count the # in and out pins of the intermediate filter
    //
    IPin          *pPin ;
    ULONG          ul ;
    PIN_DIRECTION  pd ;
    IEnumPins     *pEnumPin ;
    pFilter->EnumPins(&pEnumPin) ;
    ASSERT(pEnumPin) ;
    if (pEnumPin)
    {
        while (S_OK == pEnumPin->Next(1, &pPin, &ul) && 1 == ul)
        {
            pPin->QueryDirection(&pd) ;
            if (PINDIR_INPUT == pd)
                m_aNumInPins[m_iCount]++ ;
            else if (PINDIR_OUTPUT == pd)
                m_aNumOutPins[m_iCount]++ ;
            else
                ASSERT(PINDIR_INPUT == pd || PINDIR_OUTPUT == pd) ;

            pPin->Release() ;  // done with pin
        }
        pEnumPin->Release() ;  // done Enum-ing
    }
    DbgLog((LOG_TRACE, 5, TEXT("CListIntFilters::AddFilter() -- %d in, %d out pin"), 
            m_aNumInPins[m_iCount], m_aNumOutPins[m_iCount])) ;

    m_iCount++ ;   // increment counter now
	
    return TRUE ;  // added to list
}


int CListIntFilters::GetNumInPin(IBaseFilter *pFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::GetNumInPin(0x%lx)"), pFilter)) ;

    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Null filter pointer passed to CListIntFilters::GetNumInPin()"))) ;
        ASSERT(pFilter) ;
        return 0 ;
    }

    // Check if this filter is already in our list -- if so, just return
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (IsEqualObject(pFilter, m_apFilters[i]))
            return m_aNumInPins[i] ;
    }

    return 0 ;  // no match!!!
}


int CListIntFilters::GetNumOutPin(IBaseFilter *pFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::GetNumOutPin(0x%lx)"), pFilter)) ;

    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Null filter pointer passed to CListIntFilters::GetNumOutPin()"))) ;
        ASSERT(pFilter) ;
        return 0 ;
    }

    // Check if this filter is already in our list -- if so, just return
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (IsEqualObject(pFilter, m_apFilters[i]))
            return m_aNumOutPins[i] ;
    }

    return 0 ;  // no match!!!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dvdgb\dvdgb.h ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// A class managing list of HW and/or SW decoders used to build the DVD
// playback graph.
//
#define DECLIST_MAX        10
#define DECLIST_NOTFOUND  -1

class CListDecoders {

    public:  // class interface

        CListDecoders() ;
        ~CListDecoders() ;

        BOOL AddFilter(IBaseFilter *pFilter, LPTSTR lpszName, BOOL bHW, GUID *pClsid) ;
        BOOL GetFilter(int i, IBaseFilter **ppFilter, LPTSTR *lpszName, BOOL *pbHW) ;
        void CleanAll(void) ;
        void FreeAllMem(void) ;
        int  GetNumFilters(void)   { return m_iCount ; } ;
        int  GetNumSWFilters(void) { return m_iCount - m_iHWCount ; } ;
        int  GetNumHWFilters(void) { return m_iHWCount ; } ;
        int  GetList(IBaseFilter **ppFilter) ;
        int  IsInList(BOOL bHW, LPVOID pDec) ;

    private:  // internal data

        int             m_iCount ;
        int             m_iHWCount ;
        IBaseFilter    *m_apFilters[DECLIST_MAX] ;
        LPTSTR          m_alpszName[DECLIST_MAX] ;
        BOOL            m_abIsHW[DECLIST_MAX] ;
        GUID           *m_apClsid[DECLIST_MAX] ;

} ;


//
// List of intermediate filters, if any (like IBM CSS), used between DVD Nav and decoder(s)
//
#define MAX_INT_FILTERS    3

class CListIntFilters {

    public:  // class interface

        CListIntFilters() ;
        ~CListIntFilters() ;

        BOOL AddFilter(IBaseFilter *pFilter) ;
        void CleanAll(void) ;
        void RemoveAll(void) ;
        int  GetCount(void)   { return m_iCount ; } ;
        BOOL IsInList(IBaseFilter *pFilter) ;
        IBaseFilter * GetFilter(int i) {
            if (i > m_iCount)
            {
                ASSERT(FALSE) ;
                return NULL ;
            }
            return m_apFilters[i] ;
        } ;
        int GetNumInPin(IBaseFilter *pFilter) ;
        int GetNumOutPin(IBaseFilter *pFilter) ;

    private:  // internal data

        int             m_iCount ;
        IBaseFilter    *m_apFilters[MAX_INT_FILTERS] ;
        int             m_aNumInPins[MAX_INT_FILTERS] ;
        int             m_aNumOutPins[MAX_INT_FILTERS] ;

} ;


//
// An internally defined stream flag to check line21 data rendering.
// Leave enough space for future stream flags.
//
#define AM_DVD_STREAM_LINE21  0x80


//
// A set of (internal) flags to track the status of decoded video rendering
//
#define VIDEO_RENDER_NONE     0
#define VIDEO_RENDER_FAILED   1
#define VIDEO_RENDER_VR       2
#define VIDEO_RENDER_MIXER    4


//
// The actual class object implementing IDvdGraphBuilder interface
//
class CDvdGraphBuilder : public CUnknown, public IDvdGraphBuilder
{

    public:  // methods

        CDvdGraphBuilder(TCHAR *, LPUNKNOWN, HRESULT *) ;
        ~CDvdGraphBuilder() ;

        DECLARE_IUNKNOWN

        // this goes in the factory template table to create new instances
        static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *) ;
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv) ;

        // IDvdGraphBuilder stuff
#if 0
        STDMETHODIMP SetFiltergraph(IGraphBuilder *pGB) ;
#endif // #if 0
        STDMETHODIMP GetFiltergraph(IGraphBuilder **ppGB) ;
        STDMETHODIMP GetDvdInterface(REFIID riid, void **ppvIF) ;
        STDMETHODIMP RenderDvdVideoVolume(LPCWSTR lpcwszPathName, DWORD dwFlags,
                                          AM_DVD_RENDERSTATUS *pStatus) ;

    private:  // internal helper methods

        HRESULT EnsureGraphExists(void) ;
        HRESULT CreateGraph(void) ;
        HRESULT DeleteGraph(void) ;
        HRESULT ClearGraph(void) ;
        void    StopGraph(void) ;
        HRESULT RemoveAllFilters(void) ;
        BOOL    CheckPinMediaTypeMatch(IPin *pPinIn, DWORD dwStreamFlag) ;
        IBaseFilter * GetFilterBetweenPins(IPin *pPinOut, IPin *pPinIn) ;
        BOOL    StartDecAndConnect(IPin *pPinOut, IFilterMapper *pMapper, 
                                   AM_MEDIA_TYPE *pmt) ;
        HRESULT ConnectSrcToHWDec(IBaseFilter *pSrc, 
                                  CListDecoders *pHWDecList, 
                                  AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT ConnectSrcToSWDec(IBaseFilter *pSrc, 
                                  AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT CreateFilterInGraph(CLSID Clsid,
                                    LPCTSTR lpszFilterName, 
                                    IBaseFilter **ppFilter) ;
        HRESULT TryConnect(IPin *pPinOut, IBaseFilter *pFilter,
                           CMediaType *pmt, BOOL bDirect) ;
        HRESULT FindOpenPin(IBaseFilter *pFilter, PIN_DIRECTION pd, 
                            int iIndex, IPin **ppPin) ;
        HRESULT CreateDVDHWDecoders(CListDecoders *pHWDecList) ;
        HRESULT MakeGraphHW(BOOL bHWOnly, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT MakeGraphSW(BOOL bSWOnly, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT CheckSrcPinConnection(IBaseFilter *pSrc, 
                                      AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderDecoderOutput(AM_DVD_RENDERSTATUS *pStatus) ;
		HRESULT RenderAudioOutPin(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
		HRESULT ConnectLine21OutPin(IPin *pPinOut) ;
		void    RenderUnknownPin(IPin *pPinOut) ;
        HRESULT RenderHWOutPin(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderSWOutPin(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT CompleteLateRender(AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RemoveUnusedFilters(AM_DVD_RENDERSTATUS *pStatus) ;
        BOOL    RemoveFilterIfUnused(IBaseFilter *pFilter, LPCTSTR lpszFilterName) ;
        DWORD   StreamFlagFromSWPin(IPin *pPinOut) ;
		DWORD   StreamFlagForHWPin(IPin *pPin) ;
        DWORD   GetStreamFromMediaType(IPin *pPin) ;
        DWORD   GetInTypeForVideoOutPin(IPin *pPinOut) ;

    private:  // internal data

        IGraphBuilder *m_pGB ;        // the filter graph we are using
        CListDecoders  m_Decoders ;   // list of HW abd SW decoder filters
        IBaseFilter   *m_pDVDSrc ;    // non-default DVD source specified
        IBaseFilter   *m_pDVDNav ;    // our default DVD source -- DVD Nav
        IBaseFilter   *m_pVM ;        // VideoMixer filter
        IBaseFilter   *m_pVR ;        // Video Renderer filter (main)
        IBaseFilter   *m_pAR ;        // Audio Renderer filter
        IBaseFilter   *m_pL21Dec ;    // Line21 decoder filter

        CListIntFilters m_IntFilters ; // Intermediate filter(s) between Nav pin(s) -> Decoder(s)
        BOOL           m_bGraphDone ;  // has DVD graph been already built?
        BOOL           m_bUseVPE ;     // user wants to use VPE output?
        WCHAR          m_achwPathName[MAX_PATH] ;  // volume path name

        // The following two members help us doing rendering of CC after video
        DWORD          m_dwVideoRenderStatus ; // status of video pin rendering
        IPin          *m_pL21PinToRender ; // L21Dec out pin to be rendered after video pin
        IPin          *m_pSPPinToRender ;  // SubPic out pin to be rendered after video pin
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dvdgb\sample\tdvdplay.cpp ===
//
// Copyright (c) 1997 - 1997  Microsoft Corporation.  All Rights Reserved.
//
// TDVDPlay.cpp: DvdGraphBuilder test/sample app
//

#include <streams.h>
#include <windows.h>
#include <IL21Dec.h>

#include "TDVDPlay.h"

#define APPNAME  TEXT("TDVDPlay")

//
// Forward declaration of functions
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) ;
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) ;

CSampleDVDPlay  Player ;  // global player object

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    MSG             msg ;
    HACCEL          hAccelTable ;

    Player.SetAppValues(hInstance, APPNAME, IDS_APP_TITLE) ;

    if (! Player.InitApplication() )
    {
        return (FALSE) ;
    }

    // Perform application initialization:
    if (! Player.InitInstance(nCmdShow) )
    {
        return (FALSE) ;
    }

    hAccelTable = LoadAccelerators(hInstance, Player.GetAppName()) ;

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (! TranslateAccelerator(msg.hwnd, hAccelTable, &msg) )
        {
            TranslateMessage(&msg) ;
            DispatchMessage(&msg) ;
        }
    }

    return (msg.wParam) ;
}


CSampleDVDPlay::CSampleDVDPlay(void)
{
    CoInitialize(NULL) ;

    // The app stuff
    m_dwRenderFlag = 0 ;
    m_bMenuOn = FALSE ;
    m_bCCOn = FALSE ;

    // The DirectShow stuff
    HRESULT hr = CoCreateInstance(CLSID_DvdGraphBuilder, NULL, CLSCTX_INPROC,
                        IID_IDvdGraphBuilder, (LPVOID *)&m_pDvdGB) ;
    ASSERT(SUCCEEDED(hr) && m_pDvdGB) ;
    m_pGraph = NULL ;
    m_pDvdC = NULL ;
    m_pVW = NULL ;
    m_pMC = NULL ;
    m_pL21Dec = NULL ;
}


CSampleDVDPlay::~CSampleDVDPlay(void)
{
    // Release the DS interfaces we have got
    if (m_pDvdC)
        m_pDvdC->Release() ;
    if (m_pVW)
        m_pVW->Release() ;
    if (m_pMC)
        m_pMC->Release() ;
    if (m_pL21Dec)
        m_pL21Dec->Release() ;
    if (m_pGraph)
        m_pGraph->Release() ;

    if (m_pDvdGB)
        m_pDvdGB->Release() ;

    CoUninitialize() ;
    DbgLog((LOG_TRACE, 0, TEXT("CSampleDVDPlay d-tor exiting..."))) ;
}



void CSampleDVDPlay::SetAppValues(HINSTANCE hInst, LPTSTR szAppName,
                                  int iAppTitleResId)
{
    // The Windows stuff
    m_hInstance = hInst ;
    lstrcpy(m_szAppName, APPNAME) ;
    LoadString(m_hInstance, IDS_APP_TITLE, m_szTitle, 100) ;
}


BOOL CSampleDVDPlay::InitApplication(void)
{
    WNDCLASSEX  wc ;

    // Win32 will always set hPrevInstance to NULL, so lets check
    // things a little closer. This is because we only want a single
    // version of this app to run at a time
    m_hWnd = FindWindow (m_szAppName, m_szTitle) ;
    if (m_hWnd) {
        // We found another version of ourself. Lets defer to it:
        if (IsIconic(m_hWnd)) {
            ShowWindow(m_hWnd, SW_RESTORE);
        }
        SetForegroundWindow(m_hWnd);

        // If this app actually had any functionality, we would
        // also want to communicate any action that our 'twin'
        // should now perform based on how the user tried to
        // execute us.
        return FALSE;
    }

    // Fill in window class structure with parameters that describe
    // the main window.
    wc.cbSize        = sizeof(wc) ;
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = WndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = m_hInstance;
    wc.hIcon         = LoadIcon(m_hInstance, m_szAppName);
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName  = m_szAppName;
    wc.lpszClassName = m_szAppName;
    wc.hIconSm       = LoadIcon(m_hInstance, TEXT("SMALL"));

    // Register the window class and return success/failure code.
    return (0 != RegisterClassEx(&wc));
}

BOOL CSampleDVDPlay::InitInstance(int nCmdShow)
{
    DWORD dwErr = 0 ;
    m_hWnd = CreateWindowEx(0, m_szAppName, m_szTitle, WS_OVERLAPPEDWINDOW,
                    200, 400, 400, 200,
                    NULL, NULL, m_hInstance, NULL);
    if (!m_hWnd) {
        dwErr = GetLastError() ;
        return FALSE ;
    }

    ShowWindow(m_hWnd, nCmdShow);
    UpdateWindow(m_hWnd) ;

    //
    // By default we use HW decoding as preferred mode. Set menu option.
    // Also we don't turn on CC by default.
    m_dwRenderFlag = AM_DVD_HWDEC_PREFER ;
    CheckMenuItem(GetMenu(m_hWnd), IDM_HWMAX, MF_CHECKED) ;
    CheckMenuItem(GetMenu(m_hWnd), IDM_CC, MF_UNCHECKED) ;

    return TRUE;
}


void CSampleDVDPlay::BuildGraph(void)
{
    // First release any existing interface pointer(s)
    if (m_pDvdC) {
        m_pDvdC->Release() ;
        m_pDvdC = NULL ;
    }
    if (m_pVW) {
        m_pVW->Release() ;
        m_pVW = NULL ;
    }
    if (m_pMC) {
        m_pMC->Release() ;
        m_pMC = NULL ;
    }
    if (m_pL21Dec) {
        m_pL21Dec->Release() ;
        m_pL21Dec = NULL ;
    }
    if (m_pGraph) {
        m_pGraph->Release() ;
        m_pGraph = NULL ;
    }

    // Build the graph
    AM_DVD_RENDERSTATUS   Status ;
    HRESULT hr = m_pDvdGB->RenderDvdVideoVolume(NULL, // m_achwFileName,
                    m_dwRenderFlag, &Status) ;
    if (FAILED(hr))
    {
        AMGetErrorText(hr, m_achBuffer, sizeof(m_achBuffer)) ;
        MessageBox(m_hWnd, m_achBuffer, m_szAppName, MB_OK) ;
        return ;
    }
    if (S_FALSE == hr)  // if partial success
    {
        TCHAR    achStatusText[1000] ;
        if (0 == GetStatusText(&Status, achStatusText, sizeof(achStatusText)))
        {
            lstrcpy(achStatusText, TEXT("Couldn't get the exact error text")) ;
        }
        MessageBox(m_hWnd, achStatusText, TEXT("Warning"), MB_OK) ;
    }

    // Now get all the interfaces to playback the DVD-Video volume
    hr = m_pDvdGB->GetFiltergraph(&m_pGraph) ;
    ASSERT(SUCCEEDED(hr) && m_pGraph) ;

    hr = m_pGraph->QueryInterface(IID_IMediaControl, (LPVOID *)&m_pMC) ;
    ASSERT(SUCCEEDED(hr) && m_pMC) ;

    hr = m_pDvdGB->GetDvdInterface(IID_IDvdControl, (LPVOID *)&m_pDvdC) ;
    ASSERT(SUCCEEDED(hr) && m_pDvdC) ;

    hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (LPVOID *)&m_pVW) ;
    ASSERT(SUCCEEDED(hr) && m_pVW) ;

    hr = m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder, (LPVOID *)&m_pL21Dec) ;
    // ASSERT(SUCCEEDED(hr) && m_pL21Dec) ;
    if (m_pL21Dec)
        m_pL21Dec->SetServiceState(m_bCCOn ? AM_L21_CCSTATE_On : AM_L21_CCSTATE_Off) ;

    // Now change the title of the playback window
    m_pVW->put_Caption(L"Sample DVD Player") ;
    return ;
}


void CSampleDVDPlay::Play(void)
{
    if (NULL == m_pMC)
    {
        MessageBox(m_hWnd, TEXT("DVD-Video playback graph hasn't been built yet"), TEXT("Error"), MB_OK) ;
        return ;
    }
    HRESULT hr = m_pMC->Run() ;
    if (FAILED(hr))
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: IMediaControl::Run() failed (Error 0x%lx)"), hr)) ;
}

void CSampleDVDPlay::Stop(void)
{
    if (NULL == m_pMC)
    {
        MessageBox(m_hWnd, TEXT("DVD-Video playback graph hasn't been built yet"), TEXT("Error"), MB_OK) ;
        return ;
    }
    HRESULT hr = m_pMC->Stop() ;
    if (FAILED(hr))
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: IMediaControl::Stop() failed (Error 0x%lx)"), hr)) ;
}

void CSampleDVDPlay::Pause(void)
{
    if (NULL == m_pMC)
    {
        MessageBox(m_hWnd, TEXT("DVD-Video playback graph hasn't been built yet"), TEXT("Error"), MB_OK) ;
        return ;
    }
    HRESULT hr = m_pMC->Pause() ;
    if (FAILED(hr))
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: IMediaControl::Pause() failed (Error 0x%lx)"), hr)) ;
}


void CSampleDVDPlay::ShowMenu(void)
{
    if (NULL == m_pDvdC)
    {
        MessageBox(m_hWnd, TEXT("DVD-Video playback graph hasn't been built yet"), TEXT("Error"), MB_OK) ;
        return ;
    }
    if (m_bMenuOn)
    {
        m_pDvdC->Resume() ;
        m_bMenuOn = FALSE ;
        m_pVW->put_MessageDrain((OAHWND) NULL) ;
    }
    else
    {
        HRESULT hr = m_pDvdC->MenuCall(DVD_MENU_Root) ;
        if (SUCCEEDED(hr))
        {
            m_bMenuOn = TRUE ;
            m_pVW->put_MessageDrain((OAHWND) m_hWnd) ;
        }
        else
        {
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: IDvdControl::MenuCall() failed (Error 0x%lx)"), hr)) ;
        }
    }
}


BOOL CSampleDVDPlay::ClosedCaption(void)
{
    if (NULL == m_pL21Dec)
        MessageBox(m_hWnd, TEXT("DVD-Video playback graph hasn't been built yet"), TEXT("Error"), MB_OK) ;
    else
    {
        m_bCCOn = !m_bCCOn ;
        m_pL21Dec->SetServiceState(m_bCCOn ?
                        AM_L21_CCSTATE_On : AM_L21_CCSTATE_Off) ;
    }

    return m_bCCOn ;
}


void CSampleDVDPlay::SetRenderFlag(DWORD dwFlag)
{
    m_dwRenderFlag ^= dwFlag ;
}

BOOL CSampleDVDPlay::IsFlagSet(DWORD dwFlag)
{
    return (0 != (m_dwRenderFlag & dwFlag)) ;
}


DWORD CSampleDVDPlay::GetStatusText(AM_DVD_RENDERSTATUS *pStatus,
                                    LPTSTR lpszStatusText,
                                    DWORD dwMaxText)
{
    TCHAR    achBuffer[1000] ;

    if (IsBadWritePtr(lpszStatusText, sizeof(*lpszStatusText) * dwMaxText))
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetStatusText(): bad text buffer param"))) ;
        return 0 ;
    }

    int    iChars ;
    LPTSTR lpszBuff = achBuffer ;
    ZeroMemory(achBuffer, sizeof(TCHAR) * 1000) ;
    if (pStatus->iNumStreamsFailed > 0)
    {
        iChars = wsprintf(lpszBuff,
                 TEXT("* %d out of %d DVD-Video streams failed to render properly\n"),
                 pStatus->iNumStreamsFailed, pStatus->iNumStreams) ;
        lpszBuff += iChars ;

        if (pStatus->dwFailedStreamsFlag & AM_DVD_STREAM_VIDEO)
        {
            iChars = wsprintf(lpszBuff, TEXT("    - video stream\n")) ;
            lpszBuff += iChars ;
        }
        if (pStatus->dwFailedStreamsFlag & AM_DVD_STREAM_AUDIO)
        {
            iChars = wsprintf(lpszBuff, TEXT("    - audio stream\n")) ;
            lpszBuff += iChars ;
        }
        if (pStatus->dwFailedStreamsFlag & AM_DVD_STREAM_SUBPIC)
        {
            iChars = wsprintf(lpszBuff, TEXT("    - subpicture stream\n")) ;
            lpszBuff += iChars ;
        }
    }

    if (FAILED(pStatus->hrVPEStatus))
    {
        lstrcat(lpszBuff, "* ") ;
        lpszBuff += lstrlen("* ") ;
        iChars = AMGetErrorText(pStatus->hrVPEStatus, lpszBuff, 200) ;
        lpszBuff += iChars ;
        lstrcat(lpszBuff, "\n") ;
        lpszBuff += lstrlen("\n") ;
    }

    if (pStatus->bDvdVolInvalid)
    {
        iChars = wsprintf(lpszBuff, TEXT("* Specified DVD-Video volume was invalid\n")) ;
        lpszBuff += iChars ;
    }
    else if (pStatus->bDvdVolUnknown)
    {
        iChars = wsprintf(lpszBuff, TEXT("* No valid DVD-Video volume could be located\n")) ;
        lpszBuff += iChars ;
    }

    if (pStatus->bNoLine21In)
    {
        iChars = wsprintf(lpszBuff, TEXT("* The video decoder doesn't produce closed caption data\n")) ;
        lpszBuff += iChars ;
    }
    if (pStatus->bNoLine21Out)
    {
        iChars = wsprintf(lpszBuff, TEXT("* Decoded closed caption data not rendered properly\n")) ;
        lpszBuff += iChars ;
    }

    DWORD dwLength = (lpszBuff - achBuffer) * sizeof(*lpszBuff) ;
    dwLength = min(dwLength, dwMaxText) ;
    lstrcpyn(lpszStatusText, achBuffer, dwLength) ;

    return dwLength ;
}


LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
   int   wmId ;
   int   wmEvent ;
   HMENU hMenu = GetMenu(hWnd) ;

   switch (message) {

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

         //Parse the menu selections:
         switch (wmId) {

            case IDM_SELECT:
                Player.FileSelect() ;
                break;

            case IDM_ABOUT:
                DialogBox(Player.GetInstance(), TEXT("AboutBox"), Player.GetWindow(),
                          About);
                break;

            case IDM_EXIT:
                DestroyWindow(Player.GetWindow());
                break;

            case IDM_HWMAX:
                Player.SetRenderFlag(AM_DVD_HWDEC_PREFER) ;
                CheckMenuItem(hMenu, IDM_HWMAX,
                    Player.IsFlagSet(AM_DVD_HWDEC_PREFER) ?
                    MF_CHECKED : MF_UNCHECKED) ;
                break;

            case IDM_HWONLY:
                Player.SetRenderFlag(AM_DVD_HWDEC_ONLY) ;
                CheckMenuItem(hMenu, IDM_HWONLY,
                    Player.IsFlagSet(AM_DVD_HWDEC_ONLY) ?
                    MF_CHECKED : MF_UNCHECKED) ;
                break;

            case IDM_SWMAX:
                Player.SetRenderFlag(AM_DVD_SWDEC_PREFER) ;
                CheckMenuItem(hMenu, IDM_SWMAX,
                    Player.IsFlagSet(AM_DVD_SWDEC_PREFER) ?
                    MF_CHECKED : MF_UNCHECKED) ;
                break;

            case IDM_SWONLY:
                Player.SetRenderFlag(AM_DVD_SWDEC_ONLY) ;
                CheckMenuItem(hMenu, IDM_SWONLY,
                    Player.IsFlagSet(AM_DVD_SWDEC_ONLY) ?
                    MF_CHECKED : MF_UNCHECKED) ;
                break;

            case IDM_NOVPE:
                Player.SetRenderFlag(AM_DVD_NOVPE) ;
                CheckMenuItem(hMenu, IDM_NOVPE,
                    Player.IsFlagSet(AM_DVD_NOVPE) ?
                    MF_CHECKED : MF_UNCHECKED) ;
                break;

            case IDM_BUILDGRAPH:
                Player.BuildGraph() ;
                break ;

            case IDM_PLAY:
                Player.Play() ;
                break;

            case IDM_STOP:
                Player.Stop() ;
                break;

            case IDM_PAUSE:
                Player.Pause() ;
                break;

            case IDM_MENU:
                Player.ShowMenu() ;
                break;

            case IDM_CC:
                if (Player.ClosedCaption())  // CC turned on
                    CheckMenuItem(hMenu, IDM_CC, MF_CHECKED) ;
                else  // CC turned off
                    CheckMenuItem(hMenu, IDM_CC, MF_UNCHECKED) ;

                break;

            default:
                return (DefWindowProc(hWnd, message, wParam, lParam));
         }
         break;

      case WM_DESTROY:
          PostQuitMessage(0);
         break;

      default:
         return (DefWindowProc(hWnd, message, wParam, lParam));
   }
   return 0 ;
}

void CSampleDVDPlay::FileSelect(void)
{
    MessageBox(m_hWnd, TEXT("Not yet implemented"), TEXT("Info"), MB_OK) ;
}


LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;

        default:
            break ;
    }

    return FALSE;
}

LPTSTR CSampleDVDPlay::GetStringRes(int id)
{
    LoadString(GetModuleHandle(NULL), id, m_achBuffer, 100) ;
    return m_achBuffer ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dv\dvsp\dvsp.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <tchar.h>
#include <stdio.h>
#include "dvsp.h"
// how to build an explicit FOURCC
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))


HRESULT BuildDVAudInfo(DVINFO *InputFormat, WAVEFORMATEX **ppwfx, DVAudInfo *pDVAudInfo);
HRESULT BuildAudCMT(DVINFO *pDVInfo, CMediaType **ppOutCmt);
HRESULT BuildVidCMT(DVINFO *pDvinfo, CMediaType *pOutCmt);

// ------------------------------------------------------------------------
// setup data

const AMOVIESETUP_MEDIATYPE sudDVSPIpPinTypes[] =
{
    {&MEDIATYPE_Interleaved,       // MajorType
    &MEDIASUBTYPE_dvsd},         // MinorType
    {&MEDIATYPE_Interleaved,       // MajorType
    &MEDIASUBTYPE_dvhd},         // MinorType
    {&MEDIATYPE_Interleaved,       // MajorType
    &MEDIASUBTYPE_dvsl}         // MinorType

};

const AMOVIESETUP_MEDIATYPE sudDVSPOpPinTypes =
{
    &MEDIATYPE_Video,             // MajorType
    &MEDIASUBTYPE_NULL            // MinorType
};

const AMOVIESETUP_MEDIATYPE sudDVSPAudioOutputType =
{
    &MEDIATYPE_Audio, 
    &MEDIASUBTYPE_PCM 
};


const AMOVIESETUP_PIN psudDVSPPins[] =
{
  { L"Input",                     // strName
    FALSE,                        // bRendererd
    FALSE,                        // bOutput
    FALSE,                        // bZero
    FALSE,                        // bMany
    &CLSID_NULL,                  // connects to filter 
    NULL,                         // connects to pin
    NUMELMS(sudDVSPIpPinTypes),   // nMediaTypes
    sudDVSPIpPinTypes  }          // lpMediaType
,
    { L"Audio Output",
      FALSE,                               // bRendered
      TRUE,                                // bOutput
      TRUE,                                // bZero
      FALSE,                               // bMany
      &CLSID_NULL,                         // clsConnectsToFilter
      NULL,                                // ConnectsToPin
      1,				    // Number of media types
      &sudDVSPAudioOutputType    }
,
    { L"Video Output",
      FALSE,                               // bRendered
      TRUE,                                // bOutput
      TRUE,                                // bZero
      FALSE,                               // bMany
      &CLSID_NULL,                         // clsConnectsToFilter
      NULL,                                // ConnectsToPin
      1,				   // Number of media types
      &sudDVSPOpPinTypes }		   // lpMediaType
};


const AMOVIESETUP_FILTER sudDVSplit =
{
    &CLSID_DVSplitter,		// clsID
    L"DV Splitter",		// strName
    MERIT_NORMAL,               // dwMerit
    3,                          // nPins
    psudDVSPPins                // lpPin
};
// nothing to say about the output pin



#ifdef FILTER_DLL

//----------------------------------------------------------------------------
// Creator function for the class ID
//----------------------------------------------------------------------------
CFactoryTemplate g_Templates [] = {
		 {L"DV Splitter", 
		 &CLSID_DVSplitter, 
		 CDVSp::CreateInstance,
		 NULL,
		 &sudDVSplit }
	    } ;

int g_cTemplates = sizeof (g_Templates) / sizeof (g_Templates[0]) ;

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif


CUnknown *CDVSp::CreateInstance (LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CDVSp (NAME("DV Splitter Filter"), pUnk, phr) ;
}

//for calc audio samples /frame
int aiAudSampPerFrmTab[2][3]={{1580,1452,1053},{1896,1742,1264}};
int aiAudSampFrq[3]={48000,44100,32000};

//----------------------------------------------------------------------------
// CDVSp::NonDelegatingQueryInterface
//----------------------------------------------------------------------------
STDMETHODIMP CDVSp::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IDVSplitter)
    {
        DbgLog((LOG_TRACE,5,TEXT("CDVSp: QId for IDVSplitter")));
        return GetInterface(static_cast<IDVSplitter*>(this), ppv);
    }
    else
    {
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

//----------------------------------------------------------------------------
// CDVSp::DiscardAlternateVideoFrames
//----------------------------------------------------------------------------
STDMETHODIMP CDVSp::DiscardAlternateVideoFrames(int nDiscard)
{
    CAutoLock lck(m_pLock);

    if (m_State != State_Stopped)
    {
        DbgLog((LOG_TRACE,5,TEXT("CDVSp: Error: IDVSplitter::DiscardVideo called while graph not stopped; nDiscard=%d"), nDiscard));
        return E_UNEXPECTED;
    }

    DbgLog((LOG_TRACE,5,TEXT("CDVSp: IDVSplitter::DiscardVideo called: nDiscard=%d, m_b15fps was %d"), nDiscard, m_b15FramesPerSec));

    m_b15FramesPerSec = nDiscard != 0;

    // Don't need this since we allow this only in the Stopped state
    // and Pause toggles this to TRUE
    // if (!nDiscard)
    // {
    //     m_bDeliverNextFrame = TRUE;
    // }
    return S_OK;
}


//----------------------------------------------------------------------------
// CDVSp constructor
//----------------------------------------------------------------------------
#pragma warning(disable:4355) // using THIS pointer in constructor for base objects
CDVSp::CDVSp (TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr)
 : m_lCanSeek (TRUE),
   m_pAllocator (NULL),
   m_NumOutputPins(0),
   m_Input (NAME("Input Pin"), this, phr, L"Input"),
   m_pVidOutputPin(NULL),
   m_AudioStarted(1),
   m_bNotSeenFirstValidFrameFlag(TRUE),
   m_bFirstValidSampleSinceStartedStreaming(TRUE),
   m_b15FramesPerSec(FALSE),
   m_bDeliverNextFrame(TRUE),                      
   CBaseFilter (NAME("DVSp Tee Filter"), pUnk, this, CLSID_DVSplitter)	//,phr)
{
	
    DbgLog((LOG_TRACE,2,TEXT("CDVSp constructor")));

    ASSERT (phr) ;

    for(int i=0; i<2; i++)
    {
	m_pAudOutputPin[i]	=NULL;
   	m_pAudOutSample[i]	=NULL;
    	m_MuteAud[i]		=FALSE;
	m_Mute1stAud[i]		=FALSE;
    }
    
    m_tStopPrev =0;

}
#pragma warning(default:4355)

//----------------------------------------------------------------------------
// CDVSp destructor
//----------------------------------------------------------------------------
CDVSp::~CDVSp()
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSp destructor")));
    RemoveOutputPins();
}

// Return our current state and a return code to say if it's stable
// If we're splitting multiple streams see if one is potentially stuck
// and return VFW_S_CANT_CUE
STDMETHODIMP
CDVSp::GetState(DWORD dwMSecs, FILTER_STATE *pfs)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer( pfs, E_POINTER );
    ValidateReadWritePtr(pfs,sizeof(FILTER_STATE));

    *pfs = m_State;
    if (m_State == State_Paused) {
        return CheckState();
    } else {
        return S_OK;
    }
}

/* Check if a stream is stuck - filter locked on entry

   Returns S_OK           if no stream is stuck
           VFW_S_CANT_CUE if a stream is stuck

   A stream is stuck if:
	  // @@@ jaisri Why is it stuck if there is no audio in the 
          // first frame??? And, anyway, m_Mute1stAud[i] is set to 
          // TRUE for any frame, not just the first frame.
          Audio pin is connected && there is no audio in the first DV frame 

  A single stream can't get stuck because if all its data has been
   processed the allocator will have free buffers
*/
HRESULT CDVSp::CheckState()
{
    if (m_NumOutputPins <= 1) {
        /*  Can't stick on one pin */
        return S_OK;
    }

    if( m_Mute1stAud[0]==TRUE || m_Mute1stAud[1]==TRUE  )
        return VFW_S_CANT_CUE;
    else
	return S_OK;
}

//----------------------------------------------------------------------------
// CDVSp::GetPinCount, *X*
//----------------------------------------------------------------------------
int CDVSp::GetPinCount()
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSp::GetPinCount")));
   
    return 1 + m_NumOutputPins;
}
 
// Stop
STDMETHODIMP CDVSp::Stop()
{
  {
  
    CAutoLock lckFilter(m_pLock);

    CDVSpOutputPin *pOutputPin;
    for(int i=DVSP_VIDOUTPIN; i<=DVSP_AUDOUTPIN2; i++)
    {
    pOutputPin=(CDVSpOutputPin *)GetPin(i);
    if ((pOutputPin!=NULL) && pOutputPin ->IsConnected() )
    {
        if(pOutputPin->m_pOutputQueue!=NULL)
        {
        pOutputPin->m_pOutputQueue->BeginFlush();
        pOutputPin->m_pOutputQueue->EndFlush();
        }
            pOutputPin->CBaseOutputPin::Inactive();
    }
    }

    for(i=0; i<2; i++)
    {
        m_Mute1stAud[i]		=FALSE;
    }
    
    // re-init
    m_tStopPrev =0;
    m_bNotSeenFirstValidFrameFlag = TRUE;
    // m_bDeliverNextFrame = TRUE; Not necessary - this is set in Pause

    //release the filter Critical Section first
  }

  // tell each pin to stop
  CAutoLock lck(&m_csReceive);
  
  
  
  HRESULT hr = CBaseFilter::Stop();
  
  // Reset the Dropped Frame flag
  m_Input.m_bDroppedLastFrame = FALSE;

  return hr;

}

// Pause
STDMETHODIMP
CDVSp::Pause()
{
    HRESULT hr = NOERROR;
    CAutoLock lck(m_pLock); 

    // this is to help dynamic format changes happen when we are
    // stopped in the middle of one.
    // set our flag so we can send a media type on the first sample
    // but only do this if we are starting to stream
    if(m_State == State_Stopped)
    {
        m_bFirstValidSampleSinceStartedStreaming = TRUE;
        m_bDeliverNextFrame = TRUE;
    }

    // call base class pause()
    hr = CBaseFilter::Pause();

    return hr;
}

//----------------------------------------------------------------------------
// CDVSp::GetPin, *X*
// n=0: input pin
// n=1: videopin
// n=2: audio1
// n=3: audio2
//#define DVSP_INPIN 0
//#define DVSP_VIDOUTPIN    1
//#define DVSP_AUDOUTPIN1   2
//#define DVSP_AUDOUTPIN2   3
//----------------------------------------------------------------------------
CBasePin *CDVSp::GetPin(int n)
{
    
    DbgLog((LOG_TRACE,2,TEXT("CDVSp::GetPin")));

    // CAutoLock lck(m_pLock); // Removed as per RobinSp's code review comment
      
    // get the head of the list
   
    CDVSpOutputPin *pOutputPin ;
    
	if( n>m_NumOutputPins )
		return NULL ;

	switch(n){
	case DVSP_INPIN:
		return &m_Input;
	case 1:
		pOutputPin=m_pVidOutputPin;
		break;
	case 2:
		pOutputPin=	m_pAudOutputPin[0];
		break;
	case 3:
		pOutputPin=	m_pAudOutputPin[1];
		break;
	default:
		DbgLog((LOG_TRACE,2,TEXT("CDVSp::GetPin's n>NumOutputPins")));
		return NULL ;
	}
	return pOutputPin ;
}

//----------------------------------------------------------------------------
// CDVSp::RemoveOutputPins() *X*
//----------------------------------------------------------------------------
HRESULT CDVSp::RemoveOutputPins()
{
    CDVSpOutputPin *pPin;

    for(int i=0; i< m_NumOutputPins; i++)
    {
	pPin=NULL;

	if( i==VIDEO_OUTPIN)
	{
	    pPin=m_pVidOutputPin;
	    m_pVidOutputPin=NULL;
	}
	else if(i==AUDIO_OUTPIN1)
	    {
		pPin=m_pAudOutputPin[0];
		m_pAudOutputPin[0]=NULL;
	    }
	    else if(i==AUDIO_OUTPIN2)
		{
		    pPin=m_pAudOutputPin[1];
		    m_pAudOutputPin[1]=NULL;
		}

	if(pPin!=NULL){	
	    // If this pin holds the seek interface release it
	    if (pPin->m_bHoldsSeek) {
		InterlockedExchange(&m_lCanSeek, FALSE);
		pPin->m_bHoldsSeek = FALSE;
		delete pPin->m_pPosition;
	    }

	    IPin *pPeer = pPin->GetConnected();
	    if(pPeer != NULL)
	    {
    		pPeer->Disconnect();
		pPin->Disconnect();
	    }
		
	    pPin->Release();
	}
    }
    m_NumOutputPins=0;

    return S_OK;
}

/*X/----------------------------------------------------------------------------
// CDVSp::CreatOutputPins. The InputPin should not creat outputpin directly
//----------------------------------------------------------------------------*X*/
HRESULT 
CDVSp::CreateOrReconnectOutputPins()
{
	// Check inputpin's mediatype to decider 
	// how many out output pins we need

	WCHAR szbuf[20];                        // scratch buffer
	TCHAR tchar[20];
	ULONG uTmp=100;
	CDVSpOutputPin *pPin;
	CMediaType  *paCmt[2], Cmt[2];
        CMediaType& Inmt = m_Input.m_mt;
	HRESULT hr=E_FAIL;
	
	paCmt[0] =&Cmt[0];	
	paCmt[1] =&Cmt[1];	

	//rebuild m_sDVAudInfo based on new input media type
	hr=BuildDVAudInfo((DVINFO *)Inmt.pbFormat,NULL, &m_sDVAudInfo);
	if(m_sDVAudInfo.bNumAudPin)
	{
    	    BuildAudCMT((DVINFO *)Inmt.pbFormat, paCmt);
	}

	//*X*****************Video Pin****************************************
	if( m_pVidOutputPin == NULL )
        {
	    //X***************** creat a VIDEO putput pin **********************
            lstrcpyW(szbuf, L"DVVidOut0");
	    lstrcpy(tchar, TEXT("DV Video Output0"));
	    HRESULT hr = NOERROR ;
	    pPin = new CDVSpOutputPin ( tchar, 
				this,
				&hr, 
				szbuf);

	    if (!FAILED (hr) && pPin)
	    {
		uTmp=pPin->AddRef () ;
		m_NumOutputPins++;
		m_pVidOutputPin=pPin;
	    }
	}
	else
	{
	    //X****** if Video pin was connected and media type changed, reconnect
	    if( m_pVidOutputPin->IsConnected() )
	    {
		CMediaType cmType;

		hr=BuildVidCMT((DVINFO *)Inmt.pbFormat, &cmType);

		if( cmType != m_pVidOutputPin->m_mt )
		{
		    hr=ReconnectPin( m_pVidOutputPin,&cmType);
		}
	    }	
	}


	//*X*****************Audio Pins****************************************

	// jaisri: CDVSpInputPin::CheckMediaType has already verified that
        // any existing audio pin connections are compatible with the new
        // input pin connection (it calls QueryAccept on the connected pin)
        int cnt=m_sDVAudInfo.bNumAudPin;
	for(int i=0; i<2; i++)
	{
	    if( i >= cnt )
	    {
 	   	//do not need this pin anymore
		if(m_pAudOutputPin[i])
		{
		    // jaisri: The pin cannot be connected - this follows 
                    // from the comment just before the for loop. However,
                    // leave the code as is - to be safe.
                    //
                    // Specifically, what this means is that once a pin is
                    // created, it is never deleted (and m_pAudOutputPin[i]
                    // is never reset to NULL) until RemoveOutputPins is called.
                    // Currently, RemoveOutputPins is called only from the 
                    // destructor for CDVSp.
                    //
                    // Since m_pAudOutputPin[0] is created before m_pAudOutputPin[1],
                    // this also means that m_pAudOutputPin[0] cannot be
                    // NULL if m_pAudOutputPin[1] is not NULL.
                    if( m_pAudOutputPin[i]->IsConnected() ) 
		    {		
			IPin *pPeer = m_pAudOutputPin[i]->GetConnected();
			if(pPeer != NULL)
			{
    			    pPeer->Disconnect();
			    m_pAudOutputPin[i]->Disconnect();
			    m_pAudOutputPin[i]->Release();
			    m_pAudOutputPin[i]	=NULL;
			}
			else
			    ASSERT(pPeer);
		    }
                    else
                    {
                        // jaisri: We could delete the audio pin. However, since
                        // the mediatype returned by CDVSpOutputPin::GetMediaType
                        // will be invalid, it won't be possible to connect it 
                        // to anything. So, let it remain.
                    }
		}
	    }
	    else
	    {
		//yes we want this pin
		if( m_pAudOutputPin[i] == NULL )
		{
		    //X***************** creat a audio putput pin **********************
		    
		    lstrcpy(tchar, TEXT("Audio Output 00"));
		    tchar[13] += i / 10;
		    tchar[14] += i % 10;
		    lstrcpyW(szbuf, L"AudOut00");
		    szbuf[6] += i / 10;
		    szbuf[7] += i % 10;
		    hr = NOERROR ;
		    pPin = new CDVSpOutputPin (	tchar, 
					this,
					&hr, 
					szbuf);

		    if (!FAILED (hr) && pPin){
	    		uTmp=pPin->AddRef () ;
			m_NumOutputPins++;
			m_pAudOutputPin[i]=pPin;
		    }
		}
		else
		{
		    //X****** the audio pin already existed, check whether we need to reconnected
		    if( m_pAudOutputPin[i]->IsConnected() )
		    {
			if( Cmt[i] != m_pAudOutputPin[i]->m_mt )
			    hr=ReconnectPin( m_pAudOutputPin[i],&Cmt[i]);
		    }
		}	
	    }
    	}
	
	return S_OK;
}


/*X/--------------------------z--------------------------------------------------
// CDVSp::NotifyInputConnected(), called by CDVSpInputPin::CompleteConnect()
//----------------------------------------------------------------------------*X*/
HRESULT CDVSp::NotifyInputConnected()
{
    // these are reset when disconnected
    //X8 10-30-97 EXECUTE_ASSERT(m_NumOutputPins == 0);

    //creat output pins	
    HRESULT hr = this->CreateOrReconnectOutputPins();

    return hr;
}

//----------------------------------------------------------------------------
// HRESULT CDVSp::DecodingDeliveAudio(IMediaSample *pSample) 
//----------------------------------------------------------------------------
//
// Please refer to these BlueBook pages when reading these functions
// BlueBook Part2
// pp. 16-21 (Audio Signal Processing)
// pp. 68-75 (shuffling patterns for audio)
// pp. 109 - 117 (Basic DV Frame Data Structures)
// pp. 262 - 268 (AAUX Source and Source Control Packet spec.)
//
// General Algorithm:
// 1) Figure out how many streaming audio output pins we have
// 2) Try to detect a format change (do a QueryAccept downstream and change our output pin's media type)
// 3) Compute size of outgoing sample
// 4) Descramble the audio to construct the output sample
// 5) If format change is occuring or if this is the first sample since we started streaming
//      slap on the current output media type.
// 7) Deliver Sample to output queue
HRESULT CDVSp::DecodeDeliveAudio(IMediaSample *pSample) 
{
    HRESULT hr=NOERROR;
    CMediaType mt;

    BYTE	*pSrc;
    BYTE	*pDst;
    BYTE	bTmp;
    BYTE	*pbTmp;
    long	lBytesPerFrm;
    BYTE	bConnectedAudPin;
    BYTE	bAudPinInd;
    BYTE	bAudInDIF;
    INT		iPos;
    AM_MEDIA_TYPE   *pmt	=NULL;
    WAVEFORMATEX    *pawfx[2];
    CMediaType	    cmType[2];
    BYTE	    fAudFormatChanged[2]={FALSE, FALSE};

    // used to deliver silence for this sample in case this is a bad frame (with garbage data)
    BOOL        bSilenceThisSampleFlag = FALSE;
    

    //X* how many pin is conneced
    if ( m_pAudOutputPin[0] && m_pAudOutputPin[0]->IsConnected() )
    {
	if ( !m_pAudOutputPin[1] || !m_pAudOutputPin[1]->IsConnected() )
	{
	    //only pin 1 connected
	    bConnectedAudPin=1;
	    bAudPinInd=0;
	}
	else if ( m_pAudOutputPin[1]  && m_pAudOutputPin[1]->IsConnected() )
        {
            //pin1 and pin2 both connected
            bConnectedAudPin=2;
            bAudPinInd=0;
        }

    }
    else if ( m_pAudOutputPin[1] && m_pAudOutputPin[1]->IsConnected() )
    {
        //only pin 2 connected
        bConnectedAudPin=1;
        bAudPinInd=1; 
    }
    else
    {
        // no audio pins connected
        // don't care about invalid frames any more (no audio format changes will be happening)
        m_bNotSeenFirstValidFrameFlag = FALSE;
        m_AudioStarted=1;
        goto RETURN;
    }

  
    
    //X* get the source buffer which contains 10/12 DIF sequences
    hr = pSample->GetPointer(&pSrc);
    if (FAILED(hr)) {
        goto RETURN;
    }

    
    //*******check if format is changed*****
    pSample->GetMediaType(&pmt);
    if (pmt != NULL && pmt->pbFormat != NULL )
    {
	//******the upstream pin tells us audio format is changed.******
	pawfx[0] = (WAVEFORMATEX *)cmType[0].ReallocFormatBuffer(sizeof(WAVEFORMATEX));
	pawfx[1] = (WAVEFORMATEX *)cmType[1].ReallocFormatBuffer(sizeof(WAVEFORMATEX));

        // set "Not seen valid first frame" flag to false, because we can assume that this is a valid frame
        if(m_bNotSeenFirstValidFrameFlag)
        {
            m_bNotSeenFirstValidFrameFlag = FALSE;
        }
        
	//rebuild  DVAudInfo m_sDVAudInfo;
	DVINFO *InputFormat=(DVINFO *)pmt->pbFormat;

        DVAudInfo dvaiTemp;
        hr = BuildDVAudInfo( InputFormat, pawfx, &dvaiTemp) ;

        // only perform a format change downstream if
        // 1) We could build a valid DVAudInfo
        // 2) The new DVAudInfo is different from the current one
        // 3) the new format is different from the current format
        if( (SUCCEEDED(hr))
            && (memcmp((void*) &m_sDVAudInfo, (void*) &dvaiTemp, sizeof(DVAudInfo))) )
        {

            // copy new DVINFO (because it may change even if output AM_MEDIA_TYPE doesn't change
            memcpy((void*) &m_sDVAudInfo, (void*) &dvaiTemp, sizeof(DVAudInfo));
	    memcpy((unsigned char *)&m_LastInputFormat,(unsigned char *)InputFormat,sizeof(DVINFO) );

	    //*X* 3/2/99, we do not support audio change from one language to two on fly
	    if( (dvaiTemp.bNumAudPin ==2) && 
		    (m_pAudOutputPin[1] ==NULL) )
	    {
		    //audio change from one lanquage to two
		    //we can only care one now
		    dvaiTemp.bNumAudPin=1;
	    }

	    for(int i=0; i<dvaiTemp.bNumAudPin; i++) 
	    {
	        //Create mediatype for audio
	        cmType[i].majortype=MEDIATYPE_Audio; //streamtypeAUDIO
	        cmType[i].subtype=MEDIASUBTYPE_PCM; 
	        cmType[i].bFixedSizeSamples=1;	//X* 1 for lSampleSize is not 0 and fixed
	        cmType[i].bTemporalCompression=0; 
	        cmType[i].formattype=FORMAT_WaveFormatEx;
	        cmType[i].cbFormat=sizeof(WAVEFORMATEX); /*X* for audio render connection *X*/
    	        cmType[i].lSampleSize   =(dvaiTemp.wAvgSamplesPerPinPerFrm[i] + 50) << pawfx[i]->nChannels; //max sample for all case is < m_sDVAudInfo.wAvgSamplesPerPinPerFrm[i] + 50
	        //copy audio format
	        cmType[i].SetFormat ((BYTE *)pawfx[i], sizeof(WAVEFORMATEX));
	        
	        if( (NULL != m_pAudOutputPin[i]) && m_pAudOutputPin[i]->IsConnected() )
	        {
                    // only change media types if types actually changed

                    if (m_pAudOutputPin[i]->m_mt != cmType[i])
                    {
                        // if the downstream pin likes the new type, and we can set it on our output pin
                        // than change formats
		        if( S_OK != m_pAudOutputPin[i]->GetConnected()->QueryAccept((AM_MEDIA_TYPE *)&cmType[i]) )
                        {
	    	            m_MuteAud[i]=TRUE;
                        }
		        else if( SUCCEEDED(m_pAudOutputPin[i]->SetMediaType(&(cmType[i]))) )
                        {
		            fAudFormatChanged[i]   = TRUE;
                        }

                    }// endif Mediatype really changed

	        }// endif pin-connected
	    }
        }
        else if(FAILED(hr))
        {
            // otherwise if we couldnt' build a DVAudInfo, then silence this sample
            // because it has a bad format
            bSilenceThisSampleFlag = TRUE;
        }
    }
    else
    {	
	//*****support audio change in AAUX soruce pack even pmt==NULL********
	//***** Using this, the type-1 DV file can have difference audio in one file

	//*X search  first 5/6 DIF sequences's AAUX source pack
	//try audio block 0, 6->skip first 6 BLK, 3->3 byts BLK ID*X*/
	pbTmp=pSrc+483;		    //6*80+3=483
	if(*pbTmp!=0x50)
	{
	    //*try audio block 3, skip first 54 BLK, 3->3 byts BLK ID *
	    pbTmp=pSrc+4323;	    // 54*80+3=4323
	}
	
	//*X search  2nd 5/6 DIF sequences's AAUX source pack
	//try audio block 0, 6->skip first 6 BLK, 3->3 byts BLK ID*X*/
	BYTE *pbTmp1;
	pbTmp1=pSrc+483 + m_sDVAudInfo.wDIFMode*80*150; 
	if(*pbTmp1!=0x50)
	{
	    //*try audio block 3, skip first 54 BLK, 3->3 byts BLK ID *
	    pbTmp1=pSrc+4323+ m_sDVAudInfo.wDIFMode*80*150;
	}

        // if we haven't seen valid AAUX headers in a frame yet, check now
        if(m_bNotSeenFirstValidFrameFlag)
        {
            // if headers are valid, then we have now seen a valid frame
            if( (*pbTmp == 0x50) && (*pbTmp1 == 0x50) )
            {
                m_bNotSeenFirstValidFrameFlag = FALSE;
            }
            else
            {
                // otherwise garbage data again, do not deliver
                return S_FALSE;
            }
        }


        // make sure that headers are valid
        if (*pbTmp == 0x50 && *pbTmp1 == 0x50)
        {

            //***** check if audio keeps same format
                            
            DVINFO dviInputFormat;
            DVAudInfo dvaiTemp;
            HRESULT hr_BuildDVAudInfo;
            BOOL bBuilt = FALSE; // If TRUE dvaiTemp does not need to be rebuilt
            BOOL bCalled = FALSE; // If TRUE, BuildDVAudInfo has been called.
            int nNumAudPin = 0;

            if (m_pAudOutputPin[0]) nNumAudPin++;
            if (m_pAudOutputPin[1]) nNumAudPin++;

            ASSERT(nNumAudPin);         // If there are no pins, we bail out at the start of this function

            // If Pin 1 exists, Pin 0 exists - not really important for the following
            // but we should know if this is not true.
            ASSERT(!m_pAudOutputPin[1] || m_pAudOutputPin[0]);

            DWORD dwCurrentSrc  = m_LastInputFormat.dwDVAAuxSrc;
            DWORD dwCurrentSrc1 = m_LastInputFormat.dwDVAAuxSrc1;
            DWORD dwNewSrc =  ( *(pbTmp+4) <<24)  | (*(pbTmp+3) <<16)  |
                            ( *(pbTmp+2) <<8)   |  *(pbTmp+1);
            DWORD dwNewSrc1 = ( *(pbTmp1+4) <<24)  | (*(pbTmp1+3) <<16) | 
                            ( *(pbTmp1+2) <<8)   | *(pbTmp1+1);

            // Attempt a format change if there
            // are differences in the rest of the source pack

            // jaisri: However, when determining if there are differences:
            // (a) ignore the AF_SIZE field since this field only has the number
            //     of audio samples in the DV frame. This eliminates needless
            //     format changes. While we are at it, we may as well ignore
            //     the LF (audio locked) bit as well.

            dwNewSrc        &= 0xffffff40;
            dwNewSrc1       &= 0xffffff40;
            dwCurrentSrc    &= 0xffffff40;
            dwCurrentSrc1   &= 0xffffff40;

#ifdef DEBUG
            // Used in assertions
            DWORD dwNewSrcOrig = dwNewSrc;
            DWORD dwNewSrcOrig1 = dwNewSrc1;
#endif


            // and (b): (Manbugs 36729) if the AUDIO_MODE field in the DV frame is
            // indistinguishable (0xE) or no information (0xF), we replace it
            // with the corresponding field from m_LastInputFormat. (Note that
            // we ignore this field only when we are inspecting the DV data
            // for format changes. If the media sample flagged a format 
            // change, we just use the one it provides.)  The reason for this
            // is that the DV Mux uses this field to indicate silence in cases
            // that the audio starts after the video or if there are
            // intermediate periods of silence during the video. If we use
            // this field and pass 0xF (no info) in this field to BuildDVAudInfo
            // things can go very wrong:
            // - The call to BuildDVAudInfo below will tell us that the the 
            //   number of audio pins has reduced to 1 or to 0 when it really
            //   has not changed
            // - We save the new src pack info away in m_LastInputFormat.
            //   Subsequent calls to CDVSpOutputPin::GetMediaType supplies
            //   m_LastInputFormat to BuildDVAudInfo to determine the number
            //   of audio pins. This number would have reduced. So if
            //   the graph is stopped and we disconnect the audio pin and
            //   try to reconnect it, the connection fails
            // - Subsequent calls to DescrambleAudio fail. DescrambleAudio
            //   asserts m_sDVAudInfo.bAudQu for the pin we just lost is
            //   neither 32KHz nor 48KHz. (Detail: Actually, if we have 
            //   two pins and the AUDIO_MODE for the first one is 0,
            //   BuildDVAudInfo "redirects" the output that would normally go
            //   to the second pin to the first pin. So m_sDVAudInfo.bAudQu[0]
            //   is initialized by that function, but not m_sDVAudInfo.bAudQu[1].
            //   So DescrambleAudio asserts only for the second pin. However,
            //   the first pin's audio is not played any more, instead the 
            //   first pin carries the second pin's audio.)

            if ((pbTmp[2] & 0xe) == 0xe && 
                (dwCurrentSrc & 0xe00) != 0xe00 // Small opt for mono channel dv - AUD_MODE will be 0xf
               )
            {
                // The lower nibble of the byte is 0xE (indistinguishable) or
                // 0xF (no information). Replace AUDIO_MODE in dwNewSrc with
                // the AUDIO_MODE field in dwCurrentSrc
                
                // And now for some exceptions. Manbugs 40975.
                // Scenario: Panasonic DV400D plays a tape that has 16 bit 32K mono audio.
                // Use a preview graph in graphedt. Stop the tape. (Do not change graph's state.)
                // Restart it. Often, there is no audio after that. Does not repro w/
                // Sony TRV 10. Does not repro w/ Win Millenium Edition qdv and earlier (since 
                // this code wasn't there).
                //
                // Initially, the setting is CH=0, PA=1 and AUDIO_MODE (AM) = 2 (for Aux Src)
                // and 0xF (for aux src 1). After the tape is resumed, the Panasonic first sends a 
                // DV frame with CH=0, PA = 0 and AM = 0, 1. (Aux Src and Aux Src1.) This 
                // corresponds to stereo audio. Then it fixes things in the next frame by
                // sending CH=0, PA=1 and AM = 2, 0xf. Without the workaround, we leave AM as 2, 1
                // which is invalid and the rest of the audio is silenced.
                //
                // This scenario also repros if we play a tape (or a type 1 avi file) that has
                // 3 recorded segments: first has Mono 16 bit (I used 32K0, second has stereo 16 bit
                // (used 48K) and the third has mono 16 bit (used 32K)
                // 
                // All we care about is whether the number of audio tracks has decreased. So, we 
                // call BuidDVAudInfo with the NewSrc's and find the new number of
                // audio tracks. If it hasn't decreased, there is no change, we don't need to copy
                // To eliminate the perf hit, we ensure that we call BuildDVAudInfo at most
                // twice
                

                pawfx[0] = (WAVEFORMATEX *)cmType[0].ReallocFormatBuffer(sizeof(WAVEFORMATEX));
                pawfx[1] = (WAVEFORMATEX *)cmType[1].ReallocFormatBuffer(sizeof(WAVEFORMATEX));

                dviInputFormat =  m_LastInputFormat;
                
                dviInputFormat.dwDVAAuxSrc    = dwNewSrc;
                dviInputFormat.dwDVAAuxSrc1   =	dwNewSrc1;

                //rebuild  DVAudInfo with new audio source pack

                hr_BuildDVAudInfo = BuildDVAudInfo(&dviInputFormat, pawfx, &dvaiTemp);
                bCalled = TRUE;

                if (SUCCEEDED(hr_BuildDVAudInfo) && dvaiTemp.bNumAudPin >= nNumAudPin)
                {
                    // We are not going to reduce the number of pins
                    // Don't copy
                    bBuilt = TRUE;
                }
                else
                {
                    // Copy
                    dwNewSrc = (~DV_AUDIOMODE & dwNewSrc) | 
                                            (dwCurrentSrc & DV_AUDIOMODE);
                }

            }
            if (!bBuilt /* We know # of audio pins does not drop if bBuilt is TRUE */ && 
                (pbTmp1[2] & 0xe) == 0xe  && 
                (dwCurrentSrc1 & 0xe00) != 0xe00 // Small opt for mono channel dv - AUD_MODE will be 0xf
               )
            {
                // The lower nibble of the byte is 0xE (indistinguishable) or
                // 0xF (no information). Replace AUDIO_MODE in dwNewSrc1 with
                // the AUDIO_MODE field in dwCurrentSrc1

                if (!bCalled)
                {
                    pawfx[0] = (WAVEFORMATEX *)cmType[0].ReallocFormatBuffer(sizeof(WAVEFORMATEX));
                    pawfx[1] = (WAVEFORMATEX *)cmType[1].ReallocFormatBuffer(sizeof(WAVEFORMATEX));

                    dviInputFormat =  m_LastInputFormat;
            
                    ASSERT (dwNewSrc = dwNewSrcOrig);
                    ASSERT (dwNewSrc1 = dwNewSrcOrig1);
                            
                    dviInputFormat.dwDVAAuxSrc    = dwNewSrc;
                    dviInputFormat.dwDVAAuxSrc1   = dwNewSrc1;

                    //rebuild  DVAudInfo with new audio source pack

                    hr_BuildDVAudInfo = BuildDVAudInfo(&dviInputFormat, pawfx, &dvaiTemp);
                    bCalled = TRUE;
                }
                else
                {
                    // We know we have to copy since bBuilt = FALSE.
                    // Let's assert it.

                    ASSERT(FAILED(hr_BuildDVAudInfo) || 
                           dvaiTemp.bNumAudPin < nNumAudPin);
                }

                if (SUCCEEDED(hr_BuildDVAudInfo) && dvaiTemp.bNumAudPin >= nNumAudPin)
                {
                    // We are not going to reduce the number of pins
                    // Don't copy
                    bBuilt = TRUE;
                }
                else
                {
                    dwNewSrc1 = (~DV_AUDIOMODE & dwNewSrc1) | 
                                            (dwCurrentSrc1 & DV_AUDIOMODE);
                }
            }

            if (dwCurrentSrc != dwNewSrc || dwCurrentSrc1 != dwNewSrc1) 
            {
                //******the upstream pin tells us audio format is changed.******
                    
                if (bBuilt)
                {
                    // We used dwNewSrcOrig and dwNewSrcOrig1 
                    // to build the first time. Assert that 
                    // a rebuild is unnecessary since they 
                    // have not changed.
                    ASSERT (dwNewSrc = dwNewSrcOrig);
                    ASSERT (dwNewSrc1 = dwNewSrcOrig1);
                }
                else
                {
                    if (!bCalled)
                    {
                        pawfx[0] = (WAVEFORMATEX *)cmType[0].ReallocFormatBuffer(sizeof(WAVEFORMATEX));
                        pawfx[1] = (WAVEFORMATEX *)cmType[1].ReallocFormatBuffer(sizeof(WAVEFORMATEX));
                    }
                    
                    dviInputFormat =  m_LastInputFormat;
            
                    dviInputFormat.dwDVAAuxSrc    = dwNewSrc;
                    dviInputFormat.dwDVAAuxSrc1   = dwNewSrc1;

                    //rebuild  DVAudInfo with new audio source pack

                    hr_BuildDVAudInfo = BuildDVAudInfo(&dviInputFormat, pawfx, &dvaiTemp);
                }

                // only perform a format change downstream if
                // 1) We could build a valid DVAudInfo
                // 2) The new DVAudInfo is different from the current one
                // 2) the new format is different from the current format
                if( (SUCCEEDED(hr_BuildDVAudInfo))
                    && ( memcmp((void*) &m_sDVAudInfo, (void*) &dvaiTemp, sizeof(DVAudInfo)) ) )

                {
                    // now a format change may have occured
                    // create a CMediaType, and see if its different than the currently connected mediatype

                    // copy new DVINFO (because it may change even if output AM_MEDIA_TYPE doesn't change
                    memcpy((void*) &m_sDVAudInfo, (void*) &dvaiTemp, sizeof(DVAudInfo));
                    memcpy((unsigned char *)&m_LastInputFormat,(unsigned char *)&dviInputFormat,sizeof(DVINFO) );
                    //*X* 3/2/99, we do not support audio change from one language to two on fly
                    if( (dvaiTemp.bNumAudPin ==2) && 
                            (m_pAudOutputPin[1] ==NULL) )
                    {
                        //audio change from one lanquage to two
                        //we can only care one now
                        dvaiTemp.bNumAudPin=1;
                    }

                    for(int i=0; i<dvaiTemp.bNumAudPin; i++) 
                    {
                        //Create mediatype for audio
                        cmType[i].majortype=MEDIATYPE_Audio; //streamtypeAUDIO
                        cmType[i].subtype=MEDIASUBTYPE_PCM; 
                        cmType[i].bFixedSizeSamples=1;	//X* 1 for lSampleSize is not 0 and fixed
                        cmType[i].bTemporalCompression=0; 
                        cmType[i].formattype=FORMAT_WaveFormatEx;
                        cmType[i].cbFormat=sizeof(WAVEFORMATEX); /*X* for audio render connection *X*/
                        cmType[i].lSampleSize   =(dvaiTemp.wAvgSamplesPerPinPerFrm[i] + 50) << pawfx[i]->nChannels; //max sample for all case is < m_sDVAudInfo.wAvgSamplesPerPinPerFrm[i] + 50
                        //copy audio format
                        cmType[i].SetFormat ((BYTE *)pawfx[i], sizeof(WAVEFORMATEX));	            

                        if(  (NULL != m_pAudOutputPin[i]) && m_pAudOutputPin[i]->IsConnected() )
                        {
                            // only change media types if types actually changed

                            if (m_pAudOutputPin[i]->m_mt != cmType[i])
                            {
                                // if the downstream pin likes the new type, and we can set it on our output pin
                                // than change formats
                                if( S_OK != m_pAudOutputPin[i]->GetConnected()->QueryAccept((AM_MEDIA_TYPE *)&cmType[i]) )
                                {
                                    m_MuteAud[i]=TRUE;
                                }
                                else if( SUCCEEDED(m_pAudOutputPin[i]->SetMediaType(&(cmType[i]))) )
                                {                               
                                    fAudFormatChanged[i]   = TRUE;
                                }

                            }// endif Mediatype really changed

                        }// endif pin connected
                    }
                }
                else if(FAILED(hr_BuildDVAudInfo))
                {
                    // otherwise if we couldnt' build a DVAudInfo, then silence this sample
                    // because it has a bad format
                    bSilenceThisSampleFlag = TRUE;
                }
            }
        }
     }
    //X*******get exactly wAvgBytesPerSec for this frame's audio
    //X* search for audio source AAUX source data from  A0 or A2
	
    //deshuffle  audio for  1 or 2 connected pin(s)
    while(bConnectedAudPin )
    {
    if( m_MuteAud[bAudPinInd]!=TRUE )
    {
	//get right output pin
	CDVSpOutputPin *pAudOutputPin;
	pAudOutputPin = m_pAudOutputPin[bAudPinInd];
	
	//this pin's audio in one or both 5/6 DIF sequences
	if( ( m_sDVAudInfo.bAudStyle[bAudPinInd] & 0xc0 ) ==0x80 )
	{
	    //one pin's audio in both 5/6 DIF sequences
	    bAudInDIF=2;
	    iPos=0;
	}
	else
	{
	    bAudInDIF=1;

	    //one pin's audio only in one 5/6 DIF sequences 
	    //find which one
	    if( m_sDVAudInfo.bAudStyle[bAudPinInd] & 0x3f )
	    {
		//in 2nd 5/6 DIF sequence
		iPos=m_sDVAudInfo.wDIFMode*80*150;
	    }
	    else //in 1st 5/6 DIF sequences
		iPos=0;
	}
	
	//ouput auduio sample buffer pointer
	IMediaSample    *pOutSample=NULL;
	
        CRefTime        tStart;
	CRefTime        tStop;			   //CRefTime in millisecond

	//GET TIME STAMP FROM VIDEO FRAME
	pSample->GetTime((REFERENCE_TIME*)&tStart, (REFERENCE_TIME*)&tStop);

	//X********cacl sample size
	WORD wTmp=0;
        BYTE *pbTempVaux = NULL;
	do{
	    //*X search 1st 5/6 DIF sequences's AAUX source pack
	    //try audio block 0, 6->skip first 6 BLK, 3->3 byts BLK ID*X*/
	    bTmp=*(pSrc+6*80+3+iPos);
	    if(bTmp!=0x50)
	    {
		//*try audio block 3, skip first 54 BLK, 3->3 byts BLK ID *
		bTmp=*(pSrc+54*80+3+iPos);
		pbTmp=pSrc+54*80+3+iPos;
//		ASSERT( *pbTmp==0x50);

                // refer to bluebook spec Part2 pp.99-100, 109-110, 286
                // access VA2, 3 for id, and 39'th pack, Source Control (40)
                pbTempVaux = pSrc + 5*80 + 3 + 9*5 + iPos + 5;
	    }
	    else
	    {
	        pbTmp=pSrc+6*80+3+iPos;

                // refer to bluebook spec Part2 pp.99-100, 109-110, 286
                // access VA0, 3 for id, and 0'th pack, Source Control (1st)
                pbTempVaux = pSrc + 3*80 + 3 + iPos + 5;
	    }

            DbgLog((LOG_TRACE,2,TEXT("Header: %x, Source PC2: %x, Header: %x, Source Control PC3: %x"), *pbTmp, *(pbTmp + 2), *pbTempVaux, *(pbTempVaux + 3)));

	    //check if audio is muted in this frame
            // if audio is muted then we will first insert handle any discontinuities
            // and then send out the correct amount of silence for this sample
            // based on start, stop times, and avg. bytes per second.
            // MUTE Detection:
            // 1) If We have already detected bad data and want to insert silence for this sample
            // 2) If we detect Bad AAUX pack right now
            // 3) If the camera is paused then we mute the audio for this frame.
            //    - the VAUX Source Control pack valid
            //    - and if FF and FS of VAUX Source Control are both 0, then it is a mute condition
            // 4) If the Audio frame contains no information then we mute audio for this frame
            //    - if the AUDIO MODE in the AAUX source is all 1's i.e. AUDIO MODE == 0x0F
            if( (bSilenceThisSampleFlag)
                || ( (*pbTmp) != 0x50)
                || ( ( (*pbTempVaux) == 0x61) && ( ((*(pbTempVaux + 3)) & 0xC0) == 0x00) )
                || ( ((*(pbTmp + 2)) & 0x0F) == 0x0F) )
	    {
                // WARNING: Is this necessary?
                // @@@ jaisri: Don't think so.
		m_Mute1stAud[bAudPinInd]=TRUE;

                // deliver a silence sample downstream
		if ( pAudOutputPin->IsConnected() )
		{
		    hr = pAudOutputPin->GetDeliveryBuffer(&pOutSample,NULL,NULL,0);
    
		    if ( FAILED(hr) ) 
	    		goto RETURN;
	    
		    ASSERT(pOutSample);

                    if(m_bFirstValidSampleSinceStartedStreaming == TRUE)
                    {
                        // otherwise if we are the first valid sample, then
                        // pretend a dynamic format change is happening because we may
                        // have been stopped in the middle of a format changed last time we
                        // started streaming.

                        m_bFirstValidSampleSinceStartedStreaming = FALSE;
                        pOutSample->SetMediaType(&m_pAudOutputPin[bAudPinInd]->m_mt);
                    }
                    else if (fAudFormatChanged[bAudPinInd] == TRUE) 
                    {
                        //if audio format changed		
	                //set audio mediatype 
	                pOutSample->SetMediaType(&cmType[bAudPinInd]);
      
                    }

                    // set discontinuity
                    if(pSample->IsDiscontinuity() == S_OK)
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("Sample is a discontinuity")));

                        // handle the discontinuity, by inserting silence
                        pOutSample->SetDiscontinuity(TRUE);
                                           
                    }

                    // for this sample output silence becuase its muted
                    // calculate bytes of silence = (time difference in 100ns) * (avg. bytes / 100ns)
                    // and block align
                    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)pAudOutputPin->m_mt.pbFormat;
                    LONG         cbSilence = (LONG) ((tStop - tStart) * (((double)pwfx->nAvgBytesPerSec) / UNITS));
                    cbSilence -= (cbSilence % pwfx->nBlockAlign);

                    DbgLog((LOG_TRACE, 1, TEXT("This sample silence count: %d"), cbSilence));

                    // output
                    hr = InsertSilence(pOutSample, tStart, tStop, cbSilence, pAudOutputPin);
                    if(FAILED(hr))
                    {
                        goto RETURN;
                    }

                    DbgLog((LOG_TRACE,
                            1,
                            TEXT("Previous Sample Stop: %d, This Sample {%d , %d}"),
                            (int)m_tStopPrev.GetUnits(),
                            (int)tStart.GetUnits(),
                            (int)tStop.GetUnits()));

                    // update previous stop
		    m_tStopPrev = tStop;

		    m_AudioStarted=1;
		}// endif send silence

		goto MUTED_PIN;
	    }// endif mute detection
	  
	    bAudInDIF--;
	    if( !wTmp )
		wTmp = ( ( m_sDVAudInfo.wAvgSamplesPerPinPerFrm[bAudPinInd]  + ( *(pbTmp+1) & 0x3f)  )  ) ;  
//	    else if( wTmp && !bAudInDIF )	//for audio in both 5/6 DIF, check to make sure sample number is same
//	        ASSERT( wTmp ==  ( m_sDVAudInfo.wAvgSamplesPerPinPerFrm[bAudPinInd]  + ( *(pbTmp+1) & 0x3f)  ) );

	    if(bAudInDIF==1)
	    {
		    //one pin's audio in both 5/6 DIF block
		ASSERT(iPos==0);
		iPos=m_sDVAudInfo.wDIFMode*80*150; //for search second 5/6's AAUX source pack
	    }
			
	}while(bAudInDIF);

	//BYTES/FRAME
	if( m_sDVAudInfo.bAudStyle[bAudPinInd] & 0xc0 )
	    lBytesPerFrm = wTmp <<2;		//mon. shift 1->16 bits/8, stereo shift 2->2ch +16 bits/8
	else
	    lBytesPerFrm = wTmp <<1;
			
	//X********de-shuffle audio
	//X* since we deliver audio every DV frame,
	// we need to get another output buffer to hold descramble audio
	hr = pAudOutputPin->GetDeliveryBuffer(&pOutSample,NULL,NULL,0);
	
	if ( FAILED(hr) ) 
	    goto RETURN;
	    
	ASSERT(pOutSample);

	hr = pOutSample->GetPointer(&pDst);
	if ( FAILED(hr) ) 
	    goto RETURN;
	ASSERT(pDst);

        m_pAudOutSample[bAudPinInd]=pOutSample;

	hr=DescrambleAudio(pDst, pSrc , bAudPinInd, wTmp);

	if ( !FAILED(hr) ) 
	//if(m_AudLenLeftInBuffer[bAudPinInd] < (DWORD)lBytesPerFrm )
	{
	    //X* the buffer is almost full, delive it
	    if ( pAudOutputPin->IsConnected() )
	    {
		// pass call to it.
		long lActual = lBytesPerFrm;
		pOutSample->SetActualDataLength(lActual);
	
   		//put time stamp into audio buffer
		pOutSample->SetTime((REFERENCE_TIME*)&tStart,
			(REFERENCE_TIME*)&tStop);
		
                if(m_bFirstValidSampleSinceStartedStreaming == TRUE)
                {
                    // otherwise if we are the first valid sample, then
                    // pretend a dynamic format change is happening because we may
                    // have been stopped in the middle of a format changed last time we
                    // started streaming.

                    m_bFirstValidSampleSinceStartedStreaming = FALSE;
                    pOutSample->SetMediaType(&m_pAudOutputPin[bAudPinInd]->m_mt);
                }
		else if (fAudFormatChanged[bAudPinInd]==TRUE) 
		{
                    //if audio format changed		
		    //set audio mediatype 
		    pOutSample->SetMediaType(&cmType[bAudPinInd]);
		  
		}

                if(pSample->IsDiscontinuity() == S_OK)
                {
                    DbgLog((LOG_TRACE, 1, TEXT("Sample is a discontinuity")));

                    pOutSample->SetDiscontinuity(true);

                    // insert silence for the discontinuity

                }

		hr=pAudOutputPin->m_pOutputQueue->Receive(pOutSample);

                DbgLog((LOG_TRACE,
                        1,
                        TEXT("Previous Sample Stop: %d, This Sample {%d , %d}"),
                        (int)m_tStopPrev.GetUnits(),
                        (int)tStart.GetUnits(),
                        (int)tStop.GetUnits()));

                // update stop time
                m_tStopPrev = tStop;
		
		//GetState(0, &State);
		//DbgLog((LOG_TRACE, 2, TEXT("Deliver_aUD s1=%d\n"), State));

		m_AudioStarted=1;

		//
		// m_pOutputQueue will release the pOutSample
		//
		m_pAudOutSample[bAudPinInd]=NULL;

		if (hr != NOERROR)
		    goto RETURN;
	    }

	    //
	    // m_pOutputQueue will release the pOutSample
	    //
	    m_pAudOutSample[bAudPinInd]=NULL;
	} //end if(!FAIL())
    }// end if (m_MuteAud[bAudPinInd]!=TRUE )	

MUTED_PIN:
    bConnectedAudPin--;
    bAudPinInd++;
	
    }//end while(bConnectedAudPin) 

RETURN:
    if(pmt!=NULL) 
	DeleteMediaType(pmt);
    
    return hr;
}


// Please refer to these BlueBook pages when reading these functions
// BlueBook Part2
// pp. 16-21 (Audio Signal Processing)
// pp. 68-75 (shuffling patterns for audio)
// pp. 109 - 117 (Basic DV Frame Data Structures)
// pp. 262 - 268 (AAUX Source and Source Control Packet spec.)
//X* 
//X* 77 bytes Audio in A-DIF block:
//X* Audio Aux(5 byte) + audio data(72 bytes) on tape
//X* 9 audio block/DIF
//X* 10 or 12 DIF /frame
//X* 2 bytes for evry audio sample at 48k, 44.1k or 32k_1ch
//X*	48k requires  48000*2/30= 3200 bytes/frame 
//X*	48k requires  48000*2/25= 3840 bytes/frame
//X* MAX(10): 72*9*5=3240 bytes/frame	==	1620 samples/frame
//X* MAX(12): 72*9*6=3888 bytes/frame	==	1944 samples/frame
//X* see table 18 and 19 in part2 sepc for audio sampels/frame
//X*
//X* Agri:
//X*			iDIFBlkNum=(n/3)+2
//*X*
/*X*
typedef struct Tag_DVAudInfo
{
	BYTE	bAudStyle[2];		
	//LSB 6 bits for starting DIF sequence number
	//MSB 2 bits: 0 for mon. 1: stereo in one 5/6 DIF sequences, 2: stereo audio in both 5/6 DIF sequences
	//example: 0x00: mon, audio in first 5/6 DIF sequence
	//		   0x05: mon, audio in 2nd 5 DIF sequence
	//		   0x15: stereo, audio only in 2nd 5 DIF sequence
	//		   0x10: stereo, audio only in 1st 5/6 DIF sequence
	//		   0x20: stereo, left ch in 1st 5/6 DIF sequence, right ch in 2nd 5/6 DIF sequence
	//		   0x26: stereo, rightch in 1st 6 DIF sequence, left ch in 2nd 6 DIF sequence
	BYTE	bAudQu[2];			//qbits, only support 12, 16, 		
		
	BYTE	bNumAudPin;			//how many pin(language)
	WORD	wAvgBytesPerSec[2];	//
	WORD	wBlkMode;			//45 for NTSC, 54 for PAL
	WORD	wDIFMode;			//5  for NTSC, 6 for PAL
	WORD	wBlkDiv;			//15  for NTSC, 18 for PAL
} DVAudInfo;
*X*/

HRESULT CDVSp::DescrambleAudio(BYTE *pDst, BYTE *pSrc, BYTE bAudPinInd, WORD wSampleSize)
{
    BYTE *pTDst; //temp point
    BYTE *pTSrc; //temp point
    INT iDIFPos;
    INT iBlkPos;
    INT iBytePos;
    short sI;
    INT n;
    INT iShift;
    INT iPos;

    pTDst=pDst;
    if( m_sDVAudInfo.bAudQu[bAudPinInd] ==16 )
    {
	//X* 16 bits /sample
	if( !(m_sDVAudInfo.bAudStyle[bAudPinInd] & 0xC0))
	{

	    //16 bits MOn. audio only in one of 5/6 DIF sequencec
	    iPos=(m_sDVAudInfo.bAudStyle[bAudPinInd] & 0x3f)*150*80;

	    //for n=0, we need to treat it seperately 
	    //iDIFPos=0;	
	    //iBlkPos=0; 
	    //iBytePos=8;
	    BOOL bCorrupted1stLeftAudio=FALSE;
	    pTSrc=pSrc+480+8+iPos;
            // @@@ jaisri: Compare with 0x8000 on bigendian platforms
	    if(*((short *)pTSrc) ==0x0080 )
	    { 
		bCorrupted1stLeftAudio=TRUE;
    		pTDst+= 2;
	    }
	    else
	    {
	        *pTDst++=pTSrc[1];	//lease significant byte
	        *pTDst++=*pTSrc;	//most significant byte
	    }

	    for( n=1; n<wSampleSize; n++)
	    {

		iDIFPos=( (n/3)+2*(n%3) )%m_sDVAudInfo.wDIFMode;	//0-4 for NTSC, 0-5 for PAL
		iBlkPos= 3*(n%3)+(n%m_sDVAudInfo.wBlkMode)/m_sDVAudInfo.wBlkDiv; //0-9 
		iBytePos=8+2*(n/m_sDVAudInfo.wBlkMode);					//

		pTSrc=pSrc+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		//	iDIFPos*150*80=12000*iDIFPos	-> skip iDIFPos number DIF sequence
		//	6*80=480			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
		//	16*iBlkPos*80=1280*iBlkPos	-> skip 16 blk for evrey iBLkPos audio
		//	iPos:				=0 if this audio in 1st 5/6 DIF sequences, =5(or 6)*150*80 for 2nd DIF seq
		if(*((short *)pTSrc) ==0x0080 )
		{ 
		    //corrupted audio, copy previous audio
		    *((short*)pTDst)=*((short*)(pTDst-2));
		    pTDst+= 2;
		}
		else
		{
		    *pTDst++=pTSrc[1];	//lease significant byte
		    *pTDst++=*pTSrc;	//most significant byte
		}
	    }
	    
	    //update n=0 sample if needed
	    if( bCorrupted1stLeftAudio==TRUE)
		*((short *)pDst)=*((short *)(pDst+2));

	 }//end if (bAudInDIF
	 else
	 {

	    //16 bits stereo audio in all 10 or 12 DIF sequences
	    ASSERT( (m_sDVAudInfo.bAudStyle[bAudPinInd] & 0xC0) ==0x80 );


	    //looking for left Channel 
	    iPos = m_sDVAudInfo.bAudStyle[bAudPinInd] & 0x3f;
	    INT iRPos;
	    if( !iPos )
	    {
		//left in 1st 5/6 DIF
		iRPos=m_sDVAudInfo.wDIFMode*150*80;
	    }
	    else{
		  iPos=iPos*150*80;
		  iRPos=0;
	    }

	    //for n=0, we need to treat it seperately 
	    //iDIFPos=0;	
	    //iBlkPos=0; 
	    //iBytePos=8;
	    BOOL bCorrupted1stLeftAudio=FALSE;
	    BOOL bCorrupted1stRightAudio=FALSE;

	    //n=0 sample's left
	    pTSrc=pSrc+480+8+iPos;
	    if(*((short *)pTSrc) ==0x0080 )
	    { 
		bCorrupted1stLeftAudio=TRUE;
    		pTDst+= 2;
	    }
	    else
	    {
	        *pTDst++=pTSrc[1];	//lease significant byte
	        *pTDst++=*pTSrc;	//most significant byte
	    }

	    //n=0 sample's right
	    pTSrc=pSrc+480+8+iRPos;
	    if(*((short *)pTSrc) ==0x0080 )
	    { 
	    	bCorrupted1stRightAudio=TRUE;
    		pTDst+= 2;
	    }
	    else
	    {
	        *pTDst++=pTSrc[1];	//lease significant byte
	        *pTDst++=*pTSrc;	//most significant byte
	    }


	    for( n=1; n<wSampleSize; n++)
	    {
	    	iDIFPos=( (n/3)+2*(n%3) )%m_sDVAudInfo.wDIFMode;	//0-4 for NTSC, 0-5 for PAL
		iBlkPos= 3*(n%3)+(n%m_sDVAudInfo.wBlkMode)/m_sDVAudInfo.wBlkDiv; //0-9 
		iBytePos=8+2*(n/m_sDVAudInfo.wBlkMode);					//

		//Left first
		pTSrc=pSrc+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
		//	iDIFPos*150*80=12000*iDIFPos		-> skip iDIFPos number DIF sequence
		//	6*80=480					-> skip 1 header blk, 2 subcode blk and 3 vaux blk
		//	16*iBlkPos*80=1280*iBlkPos	-> skip 16 blk for evrey iBLkPos audio
		//  iPos: =0 if this audio in 1st 5/6 DIF sequences, =5(or 6)*150*80 for 2nd DIF seq
		if(*((short *)pTSrc) ==0x0080 )
		{ 
		    //bad audio, copy pre-frame's audio
		    *((short*)pTDst)=*( (short *)(pTDst-4));
		    pTDst+=2;
	    	}
		else
		{
		    *pTDst++=pTSrc[1];	//lease significant byte
		    *pTDst++=*pTSrc;	//most significant byte
		}

		//Right second
		pTSrc=pSrc+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iRPos;
		if(*((short *)pTSrc) ==0x0080 )
		{ 
		    //bad audio, copy pre-frame's audio
		    *((short*)pTDst)=*( (short *)(pTDst-4));
		    pTDst+=2;
		}
		else
		{
		    *pTDst++=pTSrc[1];	//lease significant byte
		    *pTDst++=*pTSrc;	//most significant byte
		}
	    }

	    //fix n=0 sample if needed
	    if( bCorrupted1stLeftAudio==TRUE)
		*((short *)pDst)=*((short *)(pDst+4));
	    if( bCorrupted1stRightAudio==TRUE )
		*((short *)(pDst+2))=*((short *)(pDst+6));

	}
	  
    }
    else if( m_sDVAudInfo.bAudQu[bAudPinInd] ==12 )
    {		

        //X* 12 bits per sample
        iPos=(m_sDVAudInfo.bAudStyle[bAudPinInd] & 0x3f)*150*80;

        if( ( m_sDVAudInfo.bAudStyle[bAudPinInd] & 0xc0) == 0x40)
        {
            //for n=0, we need to treat it seperately 
            //iDIFPos=0;	
            //iBlkPos=0; 
            //iBytePos=8;
            BOOL bCorrupted1stLeftAudio=FALSE;
            BOOL bCorrupted1stRightAudio=FALSE;

            //n=0 sample's left
            pTSrc=pSrc+480+8+iPos;
            //X* convert 12bits to 16 bits
            sI= ( pTSrc[0] << 4 ) | ( ( pTSrc[2] &0xf0) >>4 );  //X* 1st 12 bits
            if(sI==0x800)
            {
                //bad audio, copy last audio
                bCorrupted1stLeftAudio=TRUE;
                pTDst+=2;
            }
            else
            {
                iShift=(sI>>8);	
                if( iShift<8 ){ //X* positive
                    if(iShift>1){
                        iShift--;
                        sI=(-256*iShift+sI)<<iShift;
                    }
                }else{			//X* negtive
                    //X* make it 16 bits based negative
                    sI= 0xf000 | sI; 
                    if(iShift<14 ){
                        iShift=14-iShift;
                        sI= ( ( 256*iShift+1+sI) << iShift ) -1;
                    }
                }
        
                *pTDst++= (unsigned char)( ( sI & 0xff)  );			//least significant byte
                *pTDst++= (unsigned char)( ( sI & 0xff00) >>8 );	//most significant byte
            }

            //n=0 sample's right
            sI= ( pTSrc[1] << 4 ) | ( pTSrc[2] &0x0f) ;			//X* 2nd 12 bits
            if(sI==0x800)
            {
                //bad audio
                bCorrupted1stRightAudio=TRUE;
                pTDst+=2;
            }
            else
            {
                iShift=(sI>>8);	
                if( iShift<8 ){ //X* positive
                    if(iShift>1){
                        iShift--;
                        sI=(-256*iShift+sI)<<iShift;
                    }
                }else{			//X* negtive
                    //X* make it 16 bits based negative
                    sI= 0xf000 | sI; 
                    if( iShift<14 ){
                        iShift=14-iShift;
                        sI= ( ( 256*iShift+1+sI) << iShift ) -1;
                    }
                }
        
                *pTDst++= (unsigned char)( ( sI & 0xff)  );			//least significant byte
                *pTDst++= (unsigned char)( ( sI & 0xff00) >>8 );	//most significant byte
            }

            //stereo audio
            for( n=1; n<wSampleSize; n++)
            {

            iDIFPos=( (n/3)+2*(n%3) )%m_sDVAudInfo.wDIFMode;	//0-4 for NTSC, 0-5 for PAl
            iBlkPos= 3*(n%3)+(n%m_sDVAudInfo.wBlkMode)/m_sDVAudInfo.wBlkDiv;	//0-9 
            iBytePos=8+3*(n/m_sDVAudInfo.wBlkMode);
            pTSrc=pSrc+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
            //pTSrc=pSrc+ iDIFPos*150*80 + 6*80 + 16*iBlkPos*80 + iBytePos;
            //	iDIFPos*150*80	-> skip iDIFPos number DIF sequence
            //	6*80			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
            //	16*iBlkPos*80	-> skip 16 blk for evrey iBLkPos audio
            //  iPos: 0 if this audio in 1st 5/6 DIF sequences, 5(or 6)*150*80 for 2nd DIF seq


            //X* convert 12bits to 16 bits
            sI= ( pTSrc[0] << 4 ) | ( ( pTSrc[2] &0xf0) >>4 );  //X* 1st 12 bits
        
            if(sI==0x800)
            {
                //bad audio, copy pre-frame's audio
                *((short*)pTDst)=*( (short *)(pTDst-4));
                pTDst+=2;
            }
            else
            {
                iShift=(sI>>8);	
                if( iShift<8 ){ //X* positive
                    if(iShift>1){
                        iShift--;
                        sI=(-256*iShift+sI)<<iShift;
                    }
                }else{			//X* negtive
                    //X* make it 16 bits based negative
                    sI= 0xf000 | sI; 
                    if(iShift<14 ){
                        iShift=14-iShift;
                        sI= ( ( 256*iShift+1+sI) << iShift ) -1;
                    }
                }
        
                *pTDst++= (unsigned char)( ( sI & 0xff)  );			//least significant byte
                *pTDst++= (unsigned char)( ( sI & 0xff00) >>8 );	//most significant byte
            }
            sI= ( pTSrc[1] << 4 ) | ( pTSrc[2] &0x0f) ;			//X* 2nd 12 bits

            if(sI==0x800)
            {
                //bad audio, copy pre-frame's audio
                *((short*)pTDst)=*( (short *)(pTDst-4));
                pTDst+=2;
            }
            else
            {
                iShift=(sI>>8);	
                if( iShift<8 ){ //X* positive
                    if(iShift>1){
                        iShift--;
                        sI=(-256*iShift+sI)<<iShift;
                    }
                }else{			//X* negtive
                    //X* make it 16 bits based negative
                    sI= 0xf000 | sI; 
                    if( iShift<14 ){
                        iShift=14-iShift;
                        sI= ( ( 256*iShift+1+sI) << iShift ) -1;
                    }
                }
        
                *pTDst++= (unsigned char)( ( sI & 0xff)  );			//least significant byte
                *pTDst++= (unsigned char)( ( sI & 0xff00) >>8 );	//most significant byte
            }

        } //for( n=0; n<Info->SamplesIn1ChPerFrame; n++)
                    //fix n=0 sample if needed
        if( bCorrupted1stLeftAudio==TRUE)
            *((short *)pDst)=*((short *)(pDst+4));
        if( bCorrupted1stRightAudio==TRUE)
            *((short *)(pDst+2))=*((short *)(pDst+6));

    } //end if( ( m_sDVAudInfo.bAudStyle[bAudPinInd] & 0x80) == 0x40)
    else
    {
        ASSERT( !( m_sDVAudInfo.bAudStyle[bAudPinInd] & 0x80) );
        //mon. 12 bits

        // Manbugs 40935

        //for n=0, we need to treat it seperately 
        //iDIFPos=0;	
        //iBlkPos=0; 
        //iBytePos=8;
        BOOL bCorrupted1stLeftAudio=FALSE;

        //n=0 sample's left
        pTSrc=pSrc+480+8+iPos;
        //X* convert 12bits to 16 bits
        sI= ( pTSrc[0] << 4 ) | ( ( pTSrc[2] &0xf0) >>4 );  //X* 1st 12 bits
        if(sI==0x800)
        {
            //bad audio, copy last audio
            bCorrupted1stLeftAudio=TRUE;
            pTDst+=2;
        }
        else
        {
            iShift=(sI>>8);	
            if( iShift<8 ){ //X* positive
                if(iShift>1){
                    iShift--;
                    sI=(-256*iShift+sI)<<iShift;
                }
            }else{			//X* negtive
                //X* make it 16 bits based negative
                sI= 0xf000 | sI; 
                if(iShift<14 ){
                    iShift=14-iShift;
                    sI= ( ( 256*iShift+1+sI) << iShift ) -1;
                }
            }
    
            *pTDst++= (unsigned char)( ( sI & 0xff)  );			//least significant byte
            *pTDst++= (unsigned char)( ( sI & 0xff00) >>8 );	//most significant byte
        }

        //mono audio
        for( n=1; n<wSampleSize; n++)
        {

            iDIFPos=( (n/3)+2*(n%3) )%m_sDVAudInfo.wDIFMode;	//0-4 for NTSC, 0-5 for PAl
            iBlkPos= 3*(n%3)+(n%m_sDVAudInfo.wBlkMode)/m_sDVAudInfo.wBlkDiv;	//0-9 
            iBytePos=8+3*(n/m_sDVAudInfo.wBlkMode);
            pTSrc=pSrc+iDIFPos*12000+480+iBlkPos*1280+iBytePos+iPos;
            //pTSrc=pSrc+ iDIFPos*150*80 + 6*80 + 16*iBlkPos*80 + iBytePos;
            //	iDIFPos*150*80	-> skip iDIFPos number DIF sequence
            //	6*80			-> skip 1 header blk, 2 subcode blk and 3 vaux blk
            //	16*iBlkPos*80	-> skip 16 blk for evrey iBLkPos audio
            //  iPos: 0 if this audio in 1st 5/6 DIF sequences, 5(or 6)*150*80 for 2nd DIF seq


            //X* convert 12bits to 16 bits
            sI= ( pTSrc[0] << 4 ) | ( ( pTSrc[2] &0xf0) >>4 );  //X* 1st 12 bits
        
            if(sI==0x800)
            {
                //bad audio, copy pre-frame's audio
                *((short*)pTDst)=*( (short *)(pTDst-4));
                pTDst+=2;
            }
            else
            {
                iShift=(sI>>8);	
                if( iShift<8 ){ //X* positive
                    if(iShift>1){
                        iShift--;
                        sI=(-256*iShift+sI)<<iShift;
                    }
                }else{			//X* negtive
                    //X* make it 16 bits based negative
                    sI= 0xf000 | sI; 
                    if(iShift<14 ){
                        iShift=14-iShift;
                        sI= ( ( 256*iShift+1+sI) << iShift ) -1;
                    }
                }
        
                *pTDst++= (unsigned char)( ( sI & 0xff)  );			//least significant byte
                *pTDst++= (unsigned char)( ( sI & 0xff00) >>8 );	//most significant byte
            }

        } //for( n=0; n<Info->SamplesIn1ChPerFrame; n++)

        //fix n=0 sample if needed
        // @@@ jaisri What if that is also corrupted. What's the 
        // point of this anyway? What about corrupted samples
        // detected in the for loop?
        if( bCorrupted1stLeftAudio==TRUE)
            *((short *)pDst)=*((short *)(pDst+2));

        }
    } //end if( m_sDVAudInfo.bAudQu[bAudPinInd] ==12 )
    else{
	//only support 12 bits or 16 bits/samples
	ASSERT(m_sDVAudInfo.bAudQu[bAudPinInd] ==12 ||
	       m_sDVAudInfo.bAudQu[bAudPinInd] ==16);
	return E_UNEXPECTED;
    }

    return NOERROR;
}


//----------------------------------------------------------------------------
    // HRESULT CDVSp::DeliveVideo(IMediaSample *pSample) 
//----------------------------------------------------------------------------
HRESULT CDVSp::DeliveVideo(IMediaSample *pSample) 
{    
    
    HRESULT hr = NOERROR;

     // pass call to it.
    if (  m_AudioStarted && m_pVidOutputPin ->IsConnected() )
    {
	//What is going to happen if the upstream filter does not set sample time stamp right?
	//get time 
	//REFERENCE_TIME trStart, trStopAt;
	//pSample->GetTime(&trStart, &trStopAt);	

        BOOL bDeliverFrame = m_bDeliverNextFrame;

        if (!bDeliverFrame && pSample->IsDiscontinuity() == S_OK)
        {
            bDeliverFrame = TRUE;
        }
        
        if (bDeliverFrame)
        {
            pSample->AddRef();	    //m_pOutputQueu will do release
            hr = m_pVidOutputPin->m_pOutputQueue->Receive(pSample);
        }
        if (m_b15FramesPerSec)
        {
            m_bDeliverNextFrame = !bDeliverFrame;
        }
    }
    
    return hr;
}

//----------------------------------------------------------------------------
// InsertSilence
//
// notes:
//      assumption is that DV has 16 bits per sample, and silence == 0x0000
//      however "lActualDataLen" is already the correct number of bytes
//----------------------------------------------------------------------------
HRESULT
CDVSp::InsertSilence(IMediaSample *pOutSample,
                     REFERENCE_TIME rtStart,
                     REFERENCE_TIME rtStop,
                     long lActualDataLen,
                     CDVSpOutputPin *pAudOutPin)
{
    // error check
    if( (!pOutSample) || (!pAudOutPin) )
    {
        return E_INVALIDARG;
    }


    HRESULT         hr = NOERROR;
    BYTE            *pBuf = NULL;

    // checking type
    if(pAudOutPin->m_mt.formattype != FORMAT_WaveFormatEx)
    {
        DbgLog((LOG_TRACE,2,TEXT("Format Type not WaveFormatEx")));
        ASSERT(pAudOutPin->m_mt.formattype == FORMAT_WaveFormatEx);
        return E_FAIL;
    }

    // check audio sample size
    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)pAudOutPin->m_mt.pbFormat;
    if(pwfx->wBitsPerSample != 16)
    {
        DbgLog((LOG_TRACE,2,TEXT("Bits per sample is not 16, it is: %d"), (int)pwfx->wBitsPerSample));
        ASSERT(pwfx->wBitsPerSample == 16);
        return E_FAIL;
    }

    // error check
    if( ((long)pOutSample->GetSize()) < lActualDataLen )
    {
        DbgLog((LOG_TRACE,2,TEXT("Sample Buffer not big enough, need: %d bytes"), lActualDataLen));
        ASSERT( ((long)pOutSample->GetSize()) >= lActualDataLen );
        return E_FAIL;
    }

    // get "write" pointer
    if(FAILED(hr = pOutSample->GetPointer(&pBuf)))
    {
        DbgLog((LOG_TRACE,2,TEXT("GetDeliveryBuffer Error: %x"), hr));
        ASSERT(SUCCEEDED(hr));
        return hr;
    }

    // silence
    ZeroMemory((LPVOID)pBuf, lActualDataLen);

    // set times
    if(FAILED(hr = pOutSample->SetTime(&rtStart, &rtStop)))
    {
        DbgLog((LOG_TRACE,2,TEXT("SetTime Error: %x"), hr));
        ASSERT(SUCCEEDED(hr));
        return hr;
    }

    // set actual length
    if(FAILED(hr = pOutSample->SetActualDataLength(lActualDataLen)))
    {
        DbgLog((LOG_TRACE,2,TEXT("SetActualDataLength Error: %x"), hr));
        ASSERT(SUCCEEDED(hr));
        return hr;
    }

    // send
    if(FAILED(hr = pAudOutPin->m_pOutputQueue->Receive(pOutSample)))
    {
        DbgLog((LOG_TRACE,2,TEXT("Receive, Error: %x"), hr));

        return hr;
    }

    // SUCCEEDED(hr)
    return hr;
}



/*  Send EndOfStream */
void CDVSp::EndOfStream()      
{
    
    // walk through the output pins list, sending EndofStream message to downstream filters.
  
    //X* have to clean audio here because after audiorender get EndofStream()
    //X* message, we can not deliver any audio to it.
    //DeliveLastAudio(); 
    
    CDVSpOutputPin *pOutputPin;
    for(int i=DVSP_VIDOUTPIN; i<=DVSP_AUDOUTPIN2; i++)
    {
	pOutputPin=(CDVSpOutputPin *)GetPin(i);
	// There will be no output q if we're stopped
	if ((pOutputPin!=NULL) && pOutputPin ->IsConnected() &&
			pOutputPin->m_pOutputQueue)
	{
	    pOutputPin->m_pOutputQueue->EOS();
	}
    }

}
   
/*  Send BeginFlush() */
HRESULT CDVSp::BeginFlush()
{
    CAutoLock lck(m_pLock);
    
    ASSERT (m_NumOutputPins) ;

    HRESULT hr = NOERROR ;

    // FLUSH, don't deliver undelivered data.  If we do, we DIE. (unsynchronized
    // race condition with receive delivering the same data)
    // DeliveLastAudio();
    
    CDVSpOutputPin *pOutputPin;
    for(int i=DVSP_VIDOUTPIN; i<=DVSP_AUDOUTPIN2; i++)
    {
	pOutputPin=(CDVSpOutputPin *)GetPin(i);
	if ((pOutputPin!=NULL) && pOutputPin ->IsConnected() )
	{
	    pOutputPin->m_pOutputQueue->BeginFlush();
	}
    }

    m_tStopPrev =0;

    return S_OK;
}

/*  Send EndFlush() */
HRESULT CDVSp::EndFlush()
{
    CDVSpOutputPin *pOutputPin;

    for(int i=DVSP_VIDOUTPIN; i<=DVSP_AUDOUTPIN2; i++)
    {
	pOutputPin=(CDVSpOutputPin *)GetPin(i);
	if ((pOutputPin!=NULL) && pOutputPin ->IsConnected() )
	{
           pOutputPin->m_pOutputQueue->EndFlush();
	}
    }

 
    for(i=0; i<2; i++)
    {
	m_Mute1stAud[i]		=FALSE;
    }
    
    m_bDeliverNextFrame = TRUE;

    // Reset the Dropped Frame flag
    m_Input.m_bDroppedLastFrame = FALSE;


    return S_OK;

}

//----------------------------------------------------------------------------
// CDVSpInputPin constructor
//----------------------------------------------------------------------------

CDVSpInputPin::CDVSpInputPin (TCHAR *pName, CDVSp *pDVSp, HRESULT *phr,
                           LPCWSTR pPinName)
 :  CBaseInputPin (pName, pDVSp, pDVSp, phr, pPinName),
    m_pDVSp (pDVSp),
    m_bDroppedLastFrame(FALSE)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin constructor")));
	ASSERT (m_pFilter == pDVSp) ;
    ASSERT (pDVSp) ;
}

//----------------------------------------------------------------------------
// CDVSpInputPin destructor
//----------------------------------------------------------------------------

CDVSpInputPin::~CDVSpInputPin ()
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin destructor")));
    ASSERT (m_pDVSp->m_pAllocator == NULL) ;
}


STDMETHODIMP CDVSpInputPin::NewSegment(REFERENCE_TIME tStart,
				    REFERENCE_TIME tStop, double dRate)
{ 
    
    CAutoLock lck(&m_pDVSp->m_csReceive);

    DbgLog((LOG_TRACE,4,TEXT("NewSegment called %ld %ld"),long(tStart/10000),long(tStop/10000) ));

    if (m_pDVSp->m_pVidOutputPin)
	m_pDVSp->m_pVidOutputPin->DeliverNewSegment(tStart, tStop, dRate);
    for (int z = 1; z < m_pDVSp->m_NumOutputPins; z++) {
	if (m_pDVSp->m_pAudOutputPin[z-1])
	    m_pDVSp->m_pAudOutputPin[z-1]->DeliverNewSegment(tStart, tStop,
									dRate);
    }
    return CBasePin::NewSegment(tStart, tStop, dRate);
}


//----------------------------------------------------------------------------
// CDVSpInputPin GetAllocator
//----------------------------------------------------------------------------

STDMETHODIMP
CDVSpInputPin::GetAllocator(
    IMemAllocator **ppAllocator)
{
    CheckPointer(ppAllocator,E_POINTER);
    ValidateReadWritePtr(ppAllocator,sizeof(IMemAllocator *));
    CAutoLock cObjectLock(m_pLock);

    if(m_pAllocator == NULL)
    {
	*ppAllocator =NULL; 
	return E_FAIL;
    }
    else
    {
        m_pAllocator->AddRef();
	*ppAllocator =m_pAllocator; 
	return NOERROR;
    }

}


//----------------------------------------------------------------------------
// DisplayMediaType -- DEBUG ONLY HELPER FUNCTION
//----------------------------------------------------------------------------
void DisplayMediaType(TCHAR *pDescription,const CMediaType *pmt)
{
#ifdef DEBUG

    // Dump the GUID types and a short description

    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("%s"),pDescription));
    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("Media Type Description")));
    DbgLog((LOG_TRACE,2,TEXT("Major type %s"),GuidNames[*pmt->Type()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype %s"),GuidNames[*pmt->Subtype()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype description %s"),GetSubtypeName(pmt->Subtype())));
    DbgLog((LOG_TRACE,2,TEXT("Format size %d"),pmt->cbFormat));

    // Dump the generic media types */

    DbgLog((LOG_TRACE,2,TEXT("Fixed size sample %d"),pmt->IsFixedSize()));
    DbgLog((LOG_TRACE,2,TEXT("Temporal compression %d"),pmt->IsTemporalCompressed()));
    DbgLog((LOG_TRACE,2,TEXT("Sample size %d"),pmt->GetSampleSize()));

#endif
}

//----------------------------------------------------------------------------
// CDVSpInputPin::CheckMediaType
//----------------------------------------------------------------------------
/*X* pmt is the upstream filter output Pin's mediatype, mt is CDVSpInputPin's media type *X*/
HRESULT CDVSpInputPin::CheckMediaType (const CMediaType *pmt)
{

    DVINFO *InputFormat=(DVINFO *)pmt->Format();
    if(InputFormat==NULL )
	return S_FALSE;
	
    if ( *pmt->Type() ==MEDIATYPE_Interleaved &&
         *pmt->Subtype() ==MEDIASUBTYPE_dvsd   &&
	 *pmt->FormatType() == FORMAT_DvInfo	&&
	 pmt->FormatLength() == sizeof(DVINFO)  )   //*X 1/9/97 ask Syon put FORMAT_DVInfo support in FileReader and avi splitter
    {
       //10-30-97 if outputpin(s) is still connected, Check if output pins are happy with this new format
       //10-30-97 video outpin
	CDVSpOutputPin *pOutputPin;
	pOutputPin=(CDVSpOutputPin *)m_pDVSp->GetPin(DVSP_VIDOUTPIN);
	if ((pOutputPin!=NULL) && pOutputPin ->IsConnected() )
	{    
	    //build new video format
	    CMediaType Cmt;
	    BuildVidCMT(InputFormat, &Cmt);

            CMediaType& Outmt = pOutputPin->m_mt;
	
	    //if video does changed from NTSC to PAL or PAL to NTSC
	    if( HEADER( (VIDEOINFO *)( Cmt.Format()  ) )->biHeight != 
		HEADER( (VIDEOINFO *)( Outmt.pbFormat) )->biHeight )
		if( S_OK != pOutputPin->GetConnected()->QueryAccept((AM_MEDIA_TYPE *)&Cmt) )
		    return S_FALSE;
	}

       //10-30-97 audio outpins
       	//new audio format
	CMediaType mt[2], *pamt[2];
	pamt[0]= &mt[0];
	pamt[1]= &mt[1];
	BuildAudCMT(InputFormat, pamt);
	
	for(int i=DVSP_AUDOUTPIN1; i<=DVSP_AUDOUTPIN2; i++)
	{
	    pOutputPin=(CDVSpOutputPin *)m_pDVSp->GetPin(i);
	    if ((pOutputPin!=NULL) && pOutputPin ->IsConnected() )
	    {    
		if( S_OK != pOutputPin->GetConnected()->QueryAccept((AM_MEDIA_TYPE *)&mt[i-DVSP_AUDOUTPIN1]) )
		    return S_FALSE;
	    }
	}

	return S_OK;
    }

    return S_FALSE;
}

//----------------------------------------------------------------------------
// CDVSpInputPin::SetMediaType
//----------------------------------------------------------------------------
HRESULT CDVSpInputPin::SetMediaType (const CMediaType *pmt)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin::SetMediaType pmt = %lx"), pmt));

    CAutoLock lock_it (m_pLock) ;

    HRESULT hr = NOERROR ;

    // make sure that the base class likes it
    hr = CBaseInputPin::SetMediaType (pmt) ; /*X* CBasePin:: m_mt=*pmt *X*/
    if (FAILED (hr))
        return hr ;
    else
	memcpy((unsigned char *)(&m_pDVSp->m_LastInputFormat),(unsigned char *)(pmt->pbFormat),sizeof(DVINFO) );

    ASSERT (m_Connected != NULL) ;

    return hr ;
}

//----------------------------------------------------------------------------
// CDVSpInputPin::BreakConnect
//----------------------------------------------------------------------------
HRESULT CDVSpInputPin::BreakConnect ()
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin::BreakConnect")));

    // release any allocator that we are holding.
    if (m_pDVSp->m_pAllocator)
    {
        m_pDVSp->m_pAllocator->Release () ;
        m_pDVSp->m_pAllocator = NULL ;
    }

    //X* when inputpin is disconnected, we have to disconnect and remove all ouputpins
    //X* 10-30-97, Rethinking about this , we do remove output pins 
    //X* 10-30-97 m_pDVSp->RemoveOutputPins();

    return CBaseInputPin::BreakConnect(); 
    
}

//----------------------------------------------------------------------------
// CDVSpInputPin::NotifyAllocator,connected upstream outputpin's DecideAllocat() calls it
//----------------------------------------------------------------------------
STDMETHODIMP
CDVSpInputPin::NotifyAllocator (IMemAllocator *pAllocator, BOOL bReadOnly)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin::NotifyAllocator ptr = %lx"), pAllocator));

    CAutoLock lock_it (m_pLock) ;

    if (pAllocator == NULL)		//X* DVSp does not allocate any memory
        return E_FAIL ;             

    // free the old allocator if any.
    if (m_pDVSp->m_pAllocator)
        m_pDVSp->m_pAllocator->Release () ;

    // store away the new allocator
    pAllocator->AddRef () ;              // since we are stashing away the ptr
    m_pDVSp->m_pAllocator = pAllocator ; // save the new allocator

    // notify the base class about the allocator.
    return CBaseInputPin::NotifyAllocator (pAllocator,bReadOnly) ;
}

//----------------------------------------------------------------------------
// CDVSpInputPin::EndOfStream
//X*  do nothing except passing this message to downstream filters input pins.
//----------------------------------------------------------------------------
HRESULT CDVSpInputPin::EndOfStream ()
{

    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin::EndOfStream")));
    CAutoLock lck_it(&m_pDVSp->m_csReceive);


    m_pDVSp->EndOfStream();

       	
    // !!! Why are we NOT passing this on to the base pin when we do it for
    // BeginFlush and EndFlush
    // return CBasePin::EndOfStream () ;
    return (NOERROR) ;
}

//----------------------------------------------------------------------------
// CDVSpInputPin::BeginFlush
//----------------------------------------------------------------------------
HRESULT CDVSpInputPin::BeginFlush ()
{
    CAutoLock lck(m_pLock);

    FILTER_STATE state;
    m_pDVSp->GetState(0, &state);

    if( state == State_Stopped) {
        return S_OK;
    }

    CBaseInputPin::BeginFlush();

    // can't flush the allocator here - need to sync with receive
    // thread, so do it in EndFlush
      /*  call the downstream pins  */
    return m_pDVSp->BeginFlush();
}

//----------------------------------------------------------------------------
// CDVSpInputPin::EndFlush
//----------------------------------------------------------------------------
HRESULT CDVSpInputPin::EndFlush ()
{
    CAutoLock lck(m_pLock);
    
    if (!IsFlushing()) {
      return S_OK;
    }

    FILTER_STATE state;
    m_pDVSp->GetState(0, &state);
    
    if( state != State_Stopped) {
        m_pDVSp->EndFlush();
    }
    
    return CBaseInputPin::EndFlush();
}

//---------------------------------------------------------------------------
// CDVSPInputPin::DetectChanges
// This function keeps the m_mt structure on the input pin always up to date
// to the changes on the incoming pin as another internal variable is used for
// all other work so m_mt never gets update although it is used by the property page
// in graph edit
//---------------------------------------------------------------------------


DWORD GetDWORD(const BYTE *pbData)
{
    return (pbData[3] << 24) + (pbData[2] << 16) + (pbData[1] << 8) + pbData[0];
}
BOOL FindDWORDAtOffset(const BYTE * pbStart, BYTE bSearch, DWORD dwOffset1, DWORD dwOffset2, DWORD *pdwData)
{
    const BYTE *pbTmp;
    if (pbStart[dwOffset1] == bSearch) {
        pbTmp = pbStart + dwOffset1;
    } else if (pbStart[dwOffset2] == bSearch) {
        pbTmp = pbStart + dwOffset2;
    } else {
        return FALSE;
    }
    *pdwData = GetDWORD(pbTmp + 1);
    return TRUE;
}

void CDVSpInputPin::DetectChanges(IMediaSample *pSample)
{
    DVINFO temp;
    ZeroMemory (&temp,sizeof (DVINFO));
    BYTE * pSrc;

    pSample->GetPointer(&pSrc);  //Obtain pointer to buffer

    const BYTE* pbTmp;
    const DWORD dwTemp = m_pDVSp->m_sDVAudInfo.wDIFMode * 80 * 150; 

    
    if (FindDWORDAtOffset(pSrc, 0x50, 483, 4323, &temp.dwDVAAuxSrc) &&
        FindDWORDAtOffset(pSrc, 0x50, 483 + dwTemp, 4323 + dwTemp, 
                          &temp.dwDVAAuxSrc1) &&
        FindDWORDAtOffset(pSrc, 0x51, 1763, 5603, &temp.dwDVAAuxCtl) &&
        FindDWORDAtOffset(pSrc, 0x51, 1763 + dwTemp, 5603 + dwTemp, &temp.dwDVAAuxCtl1) &&
        FindDWORDAtOffset(pSrc, 0x60, 448, 448, &temp.dwDVVAuxSrc) &&
        FindDWORDAtOffset(pSrc, 0x61, 453, 453, &temp.dwDVVAuxCtl)) 
    {
        DVINFO * dvFormat = (DVINFO * ) m_mt.pbFormat;
        *dvFormat = temp;
    }
                                      
    return;
}








//----------------------------------------------------------------------------
// CDVSpInputPin::Receive
//----------------------------------------------------------------------------
HRESULT CDVSpInputPin::Receive (IMediaSample *pSample)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin::pSample ptr = %lx"), pSample));

    CAutoLock lck(&m_pDVSp->m_csReceive);

    // error check
    if(!pSample)
    {
        return E_INVALIDARG;
    }

    long lActual = (long) pSample->GetActualDataLength();
    
    // We need to check if the length of the sample is zero
    // Zero means that msdv detected a corrupt sample and changed the length 
    // so that downstream filters would ignore it.
    if (0 == lActual)
    {
        m_bDroppedLastFrame = TRUE;
        return S_OK;
    }

    if (m_bDroppedLastFrame)
    {
        // We need to set a discontinuity flag now...
        pSample->SetDiscontinuity(TRUE);
        m_bDroppedLastFrame = FALSE;
    }

    // format and sample size check
    // m_sDVAudInfo format has some some information that is constant
    // and different between NTSC and PAL.
    // please see defn. of "DVAudInfo" structure
    if( (m_pDVSp->m_sDVAudInfo.wBlkMode == 45)
         && (m_pDVSp->m_sDVAudInfo.wDIFMode == 5)
         && (m_pDVSp->m_sDVAudInfo.wBlkDiv == 15) )
    {
        // NTSC 120K buffers (tolerate some sizing error, i.e. -10,000 bytes)
        // some sizes of < 120,000 have been noticed sometimes for NTSC frames
        if( (lActual < 110000) || (lActual > 120000) )
        {
            m_pDVSp->NotifyEvent(EC_ERRORABORT, (long) E_INVALIDARG, 0);
            m_pDVSp->EndOfStream();
            return E_FAIL;
        }
    }
    else if( (m_pDVSp->m_sDVAudInfo.wBlkMode == 54)
              && (m_pDVSp->m_sDVAudInfo.wDIFMode == 6)
              && (m_pDVSp->m_sDVAudInfo.wBlkDiv == 18) )
    {
        // PAL 144K buffers (tolerate some sizing error, i.e. -10,000 bytes)
        if( (lActual < 140000) || (lActual > 144000) )
        {
            m_pDVSp->NotifyEvent(EC_ERRORABORT, (long) E_INVALIDARG, 0);
            m_pDVSp->EndOfStream();
            return E_FAIL;
        }
    }
    else
    {
        // bad audio info structure
        ASSERT( (m_pDVSp->m_sDVAudInfo.wBlkMode == 45) || (m_pDVSp->m_sDVAudInfo.wBlkMode == 54) \
                         && (m_pDVSp->m_sDVAudInfo.wDIFMode == 5) || (m_pDVSp->m_sDVAudInfo.wDIFMode == 6) \
                         && (m_pDVSp->m_sDVAudInfo.wBlkDiv == 15) || (m_pDVSp->m_sDVAudInfo.wBlkDiv == 18));
        m_pDVSp->NotifyEvent(EC_ERRORABORT, (long) E_INVALIDARG, 0);
        m_pDVSp->EndOfStream();
        return E_FAIL;
    }


    // check that all is well with the base class
    HRESULT hr = NOERROR;
    HRESULT hrAud = NOERROR;
    HRESULT hrVid = NOERROR;
    

    hr = CBaseInputPin::Receive (pSample);
    if (hr != NOERROR)
        return hr ;

    //skip invalid frame
    unsigned char *pSrc;
    // get input buffer
    hr = pSample->GetPointer(&pSrc);
    if (FAILED(hr)) 
    {
        return NULL;
    }
    ASSERT(pSrc);

    DetectChanges(pSample);

    hrAud = m_pDVSp->DecodeDeliveAudio(pSample);

    // if we have not seen a valid frame than do not deliver video either
    // if there are no audio pins connected then we will always set this flag to FALSE
    // and therefore we will always deliver video
    if(m_pDVSp->m_bNotSeenFirstValidFrameFlag)
    {
        // and we haven't addref'ed any samples yet, so no need to release
        // there won't be any filtergraph (sample delivery) related failures if this flag is TRUE
        // so we don't need to check for them
        return NOERROR;
    }


    //X* deliver pSample buffer to the dv video decoder through the video output pin
    AM_MEDIA_TYPE   *pmt = NULL;
    pSample->GetMediaType(&pmt);
    if (pmt != NULL && pmt->pbFormat != NULL) 
    {
	if(    ( ((DVINFO*)(m_mt.pbFormat))->dwDVAAuxSrc & AUDIO5060)
	    == ( ((DVINFO*)(pmt->pbFormat))->dwDVAAuxSrc & AUDIO5060) )
	    //only audio type changed
	{
	    if(pmt!=NULL) 
		DeleteMediaType(pmt);
    	    pmt=NULL;
	}
	
    }
    pSample->SetMediaType(pmt);    
    if(pmt!=NULL) 
	DeleteMediaType(pmt);

    hrVid = m_pDVSp->DeliveVideo(pSample);

    // analyze failure cases
    // either both pins succeeded
    // or one failed with VFW_E_NOT_CONNECTED
    if( ((SUCCEEDED(hrAud)) && (SUCCEEDED(hrVid)))
        || ((SUCCEEDED(hrAud)) && (hrVid == VFW_E_NOT_CONNECTED))
        || ((SUCCEEDED(hrVid)) && (hrAud == VFW_E_NOT_CONNECTED)) )
    {
        // only one of them or neither or them failed with VFW_E_NOT_CONNECTED
        hr = (SUCCEEDED(hrAud)) ? hrAud : hrVid;
    }
    else
    {
        // a failure happened on either one or both pins
        int             beginRange = 0;
        int             endRange = -1;      // -1 so if both pins failed, we don't send EOS in for-loop
        CDVSpOutputPin  *pOutputPin = NULL;

        // init'ed in case both failed
        hr = hrAud;

        // chose pin that did not fail
        if(SUCCEEDED(hrAud))
        {
            // EOS on connected Audio pins
            beginRange = DVSP_AUDOUTPIN1;
            endRange = DVSP_AUDOUTPIN2;

            // hrAud is success, it means hrVid is definitely fail
            hr = hrVid;
        }
        else if(SUCCEEDED(hrVid))
        {
            // EOS on Video pin
            beginRange = endRange = DVSP_VIDOUTPIN;
        }

        // send EOS on chosen pins
        for(int i = beginRange; i <= endRange; i++)
        {
            pOutputPin = (CDVSpOutputPin*) m_pDVSp->GetPin(i);
            if( (pOutputPin) && pOutputPin->IsConnected() && pOutputPin->m_pOutputQueue )
            {
                pOutputPin->m_pOutputQueue->EOS();
            }
        }
    }
    
    DbgLog((LOG_TRACE,2,TEXT("CDVSpInputPin receive() return: %x"), hr));
    return hr;
}

// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.
// ------------------------------------------------------------------------
HRESULT
CDVSpInputPin::CompleteConnect(IPin *pReceivePin)
{
  HRESULT hr = CBasePin::CompleteConnect(pReceivePin);
  if(FAILED(hr))
    return hr;

  //X* now we are definitely connected. We notyify the DVSp to creat output pins we need
  hr = m_pDVSp->NotifyInputConnected();
  
  return hr;
}


//----------------------------------------------------------------------------
// CDVSpOutputPin constructor
//----------------------------------------------------------------------------
CDVSpOutputPin::CDVSpOutputPin (TCHAR *pName, CDVSp *pDVSp, HRESULT *phr,
                            LPCWSTR pPinName /*X , int PinNumber *X*/)
 : CBaseOutputPin (pName, pDVSp, pDVSp, phr, pPinName) ,
 m_bHoldsSeek (FALSE),
 m_pPosition (NULL),
 m_pDVSp (pDVSp),
 m_pOutputQueue(NULL)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin constructor")));
    ASSERT (pDVSp) ;
}

//----------------------------------------------------------------------------
// CDVSpOutputPin destructor
//----------------------------------------------------------------------------
CDVSpOutputPin::~CDVSpOutputPin ()
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin destructor")));
}


/* CBasePin methods  */

HRESULT CDVSpOutputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    // if the input pin is not connected, we do not know output pin's media type.
    if ( m_pDVSp->m_Input.m_Connected == NULL)
	return E_INVALIDARG;

    if (!iPosition) 
    {
        CMediaType Inmt(m_pDVSp->m_Input.m_mt);
	CMediaType *pamt[2];

    
    // 7/26/99 xuping wu, qbug 42119
    // 1. Build a graph to playback a dv type1 file(with audio type change on fly)
    //    connection(32K), actual(48K)
    // 2. play this graph a couple seconds
    // 3. stop the graph
    // 4. disconnect audio render 
    // 5. reconnect audio render, audio sounds bad. It is caused by m_LastInputFormat was set to last 
    // dv sample's format(48K), and CDVSpOutputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
    // uses m_pDVSp->m_Input.m_mt (32k) to make connection,
    memcpy((unsigned char *)Inmt.pbFormat, (unsigned char *)&(m_pDVSp->m_LastInputFormat),sizeof(DVINFO) );
    // end 7/26/99
    
	ASSERT( (DVINFO *)Inmt.pbFormat );

	//build output pin's media type according to input pin
	if( (CDVSpOutputPin *)m_pDVSp->GetPin(DVSP_VIDOUTPIN) == this )
	    BuildVidCMT((DVINFO *)Inmt.pbFormat,pMediaType);
	else if( (CDVSpOutputPin *)m_pDVSp->GetPin(DVSP_AUDOUTPIN1)== this )
	    {
		pamt[0] =pMediaType;
		pamt[1] =NULL;
		BuildAudCMT((DVINFO *)Inmt.pbFormat,pamt);
	    }else if (  (CDVSpOutputPin *)m_pDVSp->GetPin(DVSP_AUDOUTPIN2)== this ) 
		{
		    pamt[1] =pMediaType;
		    pamt[0] =NULL;
		    BuildAudCMT((DVINFO *)Inmt.pbFormat,pamt);
	    }
		else
		    return E_INVALIDARG;
    }	
    else if (iPosition>0) 
    {
	return VFW_S_NO_MORE_ITEMS;
    }else
	return E_INVALIDARG;
	   					
    return S_OK;
}

//----------------------------------------------------------------------------
// CDVSpOutputPin::NonDelegatingQueryInterface
//
// This function is overwritten to expose IMediaPosition and IMediaSelection
// Note that only one output stream can be allowed to expose this to avoid
// conflicts, the other pins will just return E_NOINTERFACE and therefore
// appear as non seekable streams. We have a LONG value that if exchanged to
// produce a TRUE means that we have the honor. If it exchanges to FALSE then
// someone is already in. If we do get it and error occurs then we reset it
// to TRUE so someone else can get it.
//----------------------------------------------------------------------------
STDMETHODIMP CDVSpOutputPin::NonDelegatingQueryInterface (REFIID riid, void **ppv)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin::NonDelegatingQI" )));

    CheckPointer(ppv,E_POINTER);
    ASSERT (ppv) ;
    *ppv = NULL ;
    HRESULT hr = NOERROR ;

    // see what interface the caller is interested in.
    if (riid == IID_IMediaPosition || riid ==IID_IMediaSeeking )  //IID_IMediaSelection)
    {
        if (m_pPosition==NULL)
        {
	// Create implementation of this dynamically as sometimes we may never
	// try and seek. The helper object implements IMediaPosition and also
	// the IMediaSelection control interface and simply takes the calls
	// normally from the downstream filter and passes them upstream

	CPosPassThru *pMediaPosition = NULL ;
	CDVSp	*pSp ;                  // ptr to the owner filter class
	pSp=m_pDVSp;
	IPin *pIPin;
	pIPin=	(IPin*) &m_pDVSp->m_Input,
	pMediaPosition = new CDVPosPassThru (NAME("DVSP CPosPassThru"), 
				    GetOwner(),
				    &hr,
				    pIPin,
				    pSp) ;
	if (pMediaPosition == NULL)
	    return E_OUTOFMEMORY ;
	
	m_pPosition = pMediaPosition ;
	//X* m_pPosition->AddRef () ;
	}
	m_bHoldsSeek = TRUE ;
	return m_pPosition->NonDelegatingQueryInterface (riid, ppv) ;
        
    }
    else
        return CBaseOutputPin::NonDelegatingQueryInterface (riid, ppv) ;

}

//----------------------------------------------------------------------------
// CDVSpOutputPin::DecideBufferSize
// X* called by DecideAllocate
//*X* for the Audio Output Pin,let get 10 buffers from the audio render or allocate by 
//*X* for the Video Output Pin,this is never got called.
//----------------------------------------------------------------------------
HRESULT CDVSpOutputPin::DecideBufferSize (IMemAllocator *pMemAllocator,
                                         ALLOCATOR_PROPERTIES * pProp)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin::DecideBufferSize ptr = %lx"), pMemAllocator));

    // set the size of buffers based on the expected output frame size, and
    // the count of buffers to 1.
    //
    ALLOCATOR_PROPERTIES propActual;
    pProp->cbAlign = 4;
    pProp->cbPrefix= 0;
    pProp->cBuffers = 20;			/*X* 10 match avi splitter *X*/ 
    pProp->cbBuffer = 1024*8;
    //pProp->cbBuffer = m_mt.GetSampleSize(); /*X* return m_mt.lSampleSize *X*/
    DbgLog((LOG_TRACE, 2, TEXT("DVSp Sample size = %ld\n"), pProp->cbBuffer));

    ASSERT(pProp->cbBuffer > 0);

    HRESULT hr = pMemAllocator->SetProperties(pProp, &propActual);
    if (FAILED(hr)) {
        return hr;
    }

    DbgLog((LOG_TRACE, 2, TEXT("DVSP Actul. buf size = %ld\n"), propActual.cbBuffer));

    //if (propActual.cbBuffer < (LONG)(21*1028)) {
    if (propActual.cbBuffer < (LONG)m_mt.GetSampleSize() ) {
	ASSERT(propActual.cbBuffer >=(LONG)m_mt.GetSampleSize() );
        // can't use this allocator
        return E_INVALIDARG;
    }


    return S_OK;
}

//----------------------------------------------------------------------------
// CDVSpOutputPin::DecideAllocator
//*X* called by CompleteConnection()
//*X* for the Audio Output Pin, we get allocator from the audo render
//*X* for the Video Output Pin, we pass the current allocator to the connected filter
//*X* DecideAllocator is called by CDVSpPutputPin's CompleteConnect()
//----------------------------------------------------------------------------
HRESULT CDVSpOutputPin::DecideAllocator (IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin::DecideAllocator ptr = %lx"), pPin));

    ASSERT ( m_pDVSp->m_pAllocator != NULL ) ;

    /*X* CBaseMedia m_mt is a number of the CBasePin *X*/
    if ( *m_mt.Type() == MEDIATYPE_Video  )
    {      
	*ppAlloc = NULL ;
	// tell the connected pin about our allocator, set by the input pin.
	HRESULT hr = NOERROR ;
	hr = pPin->NotifyAllocator (m_pDVSp->m_pAllocator,TRUE) ;
	if (FAILED (hr))
	    return hr ;

	// return the allocator
	*ppAlloc = m_pDVSp->m_pAllocator ;
	m_pDVSp->m_pAllocator->AddRef () ;
    }
    else if( *m_mt.Type() ==  MEDIATYPE_Audio ) {	//X* ask render for allocator
	HRESULT hr = NOERROR ;
	hr = CBaseOutputPin::DecideAllocator(pPin,ppAlloc);
	if (FAILED (hr))
	    return hr ;
    }
    else
	return E_FAIL ;	


    return NOERROR ;
}


//----------------------------------------------------------------------------
// CDVSpOutputPin::CheckMediaType
//----------------------------------------------------------------------------
HRESULT CDVSpOutputPin::CheckMediaType (const CMediaType *pmt)
{
    CMediaType mt;
    HRESULT hr = GetMediaType(0, &mt);	
    if (FAILED(hr)) {
	return hr;
    }
    if (    *pmt->Type() == *mt.Type() 
	&&  *pmt->Subtype() == *mt.Subtype()  
	&&  *pmt->FormatType() == *mt.FormatType()  ) 
    {
	if( *mt.Subtype() == MEDIASUBTYPE_PCM )
            // jaisri: Note that, for audio pins,  mt.lSampleSize is set in the 
            // CMediaType constructor to 1 and is not changed by GetMediaType or 
            // the functions it calls, viz. BuildAudCMT()
	     if( mt.lSampleSize > pmt->lSampleSize )
		 return VFW_E_TYPE_NOT_ACCEPTED;

	return NOERROR ;
    }else
	return VFW_E_TYPE_NOT_ACCEPTED ;
 }


//----------------------------------------------------------------------------
// CDVSpOutputPin::SetMediaType
//----------------------------------------------------------------------------
HRESULT CDVSpOutputPin::SetMediaType (const CMediaType *pmt)
{
    CAutoLock lock_it (m_pLock) ;


    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin::SetMediaType ptr = %lx"), pmt));

    // display the format of the media for debugging purposes
    DisplayMediaType (TEXT("Output pin type agreed"), pmt) ;

    // make sure that we have an input connected.
    if (m_pDVSp->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED ;

    // make sure that the base class likes it.
    HRESULT hr = NOERROR ;
    hr = CBaseOutputPin::SetMediaType (pmt) ;
    if (FAILED (hr))
        return hr ;

    return NOERROR ;
}

//----------------------------------------------------------------------------
// CDVSpOutputPin::Active *X*
//
// This is called when we start running or go paused. We create the output queue
// object to send data to our associated peer pin.
//----------------------------------------------------------------------------
HRESULT CDVSpOutputPin::Active ()
{

    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin::Active")));
    //CAutoLock lck(m_pLock);

    /*  If we're not connected we don't participate so it's OK */
    if (!IsConnected()) {
        return S_OK;
    }

    HRESULT hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
        return hr;
    }

    /*  Create our batch list */
    ASSERT(m_pOutputQueue == NULL);

    hr = S_OK;
    m_pOutputQueue = new COutputQueue(GetConnected(), // input pin
                                      &hr,            // return code
                                      TRUE,	//FALSE,          // Auto detect
                                      FALSE,	//TRUE,           // ignored
                                      1,             // batch size
                                      FALSE,    //TRUE,       // exact batch
                                      15);           // queue size
    if (m_pOutputQueue == NULL) {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        delete m_pOutputQueue;
        m_pOutputQueue = NULL;
    }
    return hr;
}

//----------------------------------------------------------------------------
// CDVSpOutputPin::Inactive *X*
//
// This is called when we stop streaming. We delete the output queue at this
// time.
//----------------------------------------------------------------------------
HRESULT CDVSpOutputPin::Inactive ()
{
    //CAutoLock lock_it (m_pLock) ;
    DbgLog((LOG_TRACE,2,TEXT("CDVSpOutputPin::Inactive")));

    /*  If we're not involved just return */
    if (!IsConnected()) {
        return S_OK;
    }

    delete m_pOutputQueue;
    m_pOutputQueue = NULL;
    return S_OK;
}


// put the NewSegment on the output Q
//
HRESULT CDVSpOutputPin::DeliverNewSegment(REFERENCE_TIME tStart,
					REFERENCE_TIME tStop, double dRate)
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->NewSegment(tStart, tStop, dRate);
    return NOERROR;

}

//X**************************************************************************************
//X*  Utilities
//X**************************************************************************************
//
// -------------------------------------------------------------------------------------
// Please refer to these BlueBook pages when reading these functions
// BlueBook Part2
// pp. 16-21 (Audio Signal Processing)
// pp. 68-75 (shuffling patterns for audio)
// pp. 109 - 117 (Basic DV Frame Data Structures)
// pp. 262 - 268 (AAUX Source and Source Control Packet spec.)
//
// -------------------------------------------------------------------------------------
// General Algorithm:
// The audio for the DV Frame can be either mono or stereo (Please see pp. 265)
// it can be in either just one block or both block
// an audio block consists of 5 or 6 DIF sequences
// note: NTSC has 10 DIF sequences so each audio block is 5 DIF sequences,
// PAL has 12 DIF sequences so each audio block is 6 DIF sequences
// each audio block has its own AAUX Source Pack which is passed in as "DVINFO *InputFormat"
// -------------------------------------------------------------------------------------
// 1) Try to see if we are at least seeing PAL or NTSC data
// 2) because if the AUDIOMODE == NOINFO 0xff, we should at least deliver video correctly
// 3) Then check to see if either audio mode is NOINFO
// otherwise for each DIF block's audio mode: (refer to BlueBook pp. 262)
// 4) initialize 50/60 flag (or PAL or NTSC Flag)
// 5) initialize the audio frequency
// 6) initialize audio bits (16 or 12)
// 7) initialize DIF Block data depending on if Format is PAL or NTSC
// 8) setup the DVAudInfo, depending on what the audio mode of each of the AAUX's of each of the Audio blocks is
//  (see pp. 265)
// 9) Setup the WaveFormatEX
//
// Caveat: ppwfx[i] is intialized iff pInfo->bNumAudPin > i. So, if there is only
// one audio pin ppwfx[1] is not initialized. 
HRESULT BuildDVAudInfo(DVINFO *InputFormat, WAVEFORMATEX **ppwfx, DVAudInfo *pDVAudInfo) 
{
    DVAudInfo *pInfo;
    
    //to avoid change InoutFormat contains
    DVINFO tDvInfo;
    DVAudInfo tmpDVAudInfo;
    WAVEFORMATEX *tmpWaveFormatArray[2]={NULL,NULL};
    WAVEFORMATEX tmpWaveFormat;

    CopyMemory(&tDvInfo, InputFormat, sizeof(DVINFO));

    
    if( pDVAudInfo == NULL )
    {
	pInfo	= &tmpDVAudInfo;
    }
    else
	pInfo   =pDVAudInfo;

    //-----------------------------------------------------------
    // 1) Try to see if we are at least seeing PAL or NTSC data
    // 2) because if the AUDIOMODE == NOINFO 0xff, we should at least deliver video correctly

    // init DVAudInfo with some information in case we fail out later
    pInfo->bNumAudPin=0;

    // and set the DIF Mode flags
    if(( InputFormat->dwDVAAuxSrc & AUDIO5060 ) == ( InputFormat->dwDVAAuxSrc1 & AUDIO5060 ))
    {
        // Manbugs # 35117
        BYTE bTemp = (BYTE) (( InputFormat->dwDVAAuxSrc & AUDIO5060 ) >> 21); 
        if(!bTemp)
        {
            // 525_60
            // NTSC
            pInfo->wBlkMode=45;
            pInfo->wDIFMode=5;
            pInfo->wBlkDiv=15;
        }
        else
        {
            // 625_50
            // PAL
            pInfo->wBlkMode=54;
            pInfo->wDIFMode=6;
            pInfo->wBlkDiv=18;
        }
    }
    else
    {
        // make sure they do not denote PAL or NTSC
        pInfo->wBlkMode=0;
        pInfo->wDIFMode=0;
        pInfo->wBlkDiv=0;
    }


    if(ppwfx==NULL )
    {
	ppwfx = tmpWaveFormatArray;
    }
    

    for(int i=0; i<2; i++)
    {
        // if the caller does not want this returned,
        // it's ok to use the same array for both audio pins
        // because we only set the member sof ppwfx[i]
        if( ppwfx[i]==NULL )
	    ppwfx[i] = &tmpWaveFormat;
    }

    //---------------------------------------------------------------------
    // 3) Then check to see if either audio mode is NOINFO

    //Audio look up table's index
    BYTE bSMP[2];
    BYTE b50_60=0xff;	//first 5/6 DIF sequences's 50/60 must equal 2nd 5/6 DIF seqeences 
    BYTE bQU[2]={0xff, 0xff};

    //check 1st 5/6 DIF's SM and CHN
    DWORD dwSMCHN=0xffff;
    DWORD dwAUDMOD=InputFormat->dwDVAAuxSrc & AUDIOMODE;
    if( dwAUDMOD==0x00000f00)
    {
        //no audio
	//audio source	NTSC 0xc0c00fc0
	//PC1   1 1 0 0 0 0 0 0	    0xc0
	//PC2   0 0 0 0 1 1 1 1	    0x0f
	//PC3   1 1 0 0 0 0 0 0	    0xc0
	//PC4   1 1 0 0 0 0 0 0	    0xc0
	// PAL   0xc0e00fc0
	//PC1   1 1 0 0 0 0 0 0	    0xc0
	//PC2   0 0 0 0 1 1 1 1	    0x0f
	//PC3   1 1 1 0 0 0 0 0	    0xe0
	//PC4   1 1 0 0 0 0 0 0	    0xc0

	//control 0xffffff3f
	//PC1   0 0 1 1 1 1 1 1	    0x3f
	//PC2   1 1 1 1 1 1 1 1	    0xff
	//PC3   1 1 1 1 1 1 1 1	    0xff
	//PC4   1 1 1 1 1 1 1 1	    0xff
	if(  InputFormat->dwDVAAuxSrc & AUDIO5060  )
	    //PAL
	    tDvInfo.dwDVAAuxSrc=0xc0e00fc0;
	else
        {
            // NTSC
	    tDvInfo.dwDVAAuxSrc=0xc0c00fc0;
        }

	tDvInfo.dwDVAAuxCtl=0xffffff3f;
    }
    else
    {
        // AUDIO DIF Block 1 (from 0th DIF sequence onwards)
        // (refer to BlueBook pp 109 and pp. 262)
        // This is the SMCHN data
	dwSMCHN=InputFormat->dwDVAAuxSrc & SMCHN;

        // PAL or NTSC
	b50_60=(BYTE)( ( InputFormat->dwDVAAuxSrc & AUDIO5060 ) >> 21 );

        // audio frequency
	bSMP[0]=(BYTE)( ( InputFormat->dwDVAAuxSrc & AUDIOSMP ) >> 27 );
        ASSERT(bSMP[0] <= 0x02);
        if(bSMP[0] > 0x02)
        {
            // SMP-> 0=48K, 1=44.1K, 2=32K, everything else invalid
            return E_FAIL;
        }
	    	
	//how any audio bits
	if( !( InputFormat->dwDVAAuxSrc & AUDIOQU )  )
	{
	    bQU[0]=16;
	}
	else if( ( InputFormat->dwDVAAuxSrc & AUDIOQU ) == 0x01000000  )
	{
	    bQU[0]=12;
	}
	else
        {
	    //not support 20 bits
	    ASSERT(bQU[0]==0xff);
            return E_FAIL;
        }
    }
	
	
    //check 2nd 5/6 DIF's SM and CHN
    DWORD dwSMCHN1=0xffff;
    DWORD dwAUDMOD1=InputFormat->dwDVAAuxSrc1 & AUDIOMODE;
    if( dwAUDMOD1==0x00000f00)
    {
	if(  InputFormat->dwDVAAuxSrc1 & AUDIO5060  )
	    //PAL
	    tDvInfo.dwDVAAuxSrc1=0xc0e00fc0;
	else
        {
            // NTSC
	    tDvInfo.dwDVAAuxSrc1=0xc0c00fc0;
        }

	tDvInfo.dwDVAAuxCtl1=0xffffff3f;
    }
    else
    {
        // AUDIO DIF Block 2 (from (5th if NTSC) or (6th if PAL) DIF sequence onwards)
        // (refer to BlueBook pp 109 and pp. 262)
        dwSMCHN1=InputFormat->dwDVAAuxSrc1 & SMCHN;

        // make sure that Both audio modes are either PAL or NTSC
        // we cannot have one say NTSC and the other say PAL
        // or vice-versa
        if(b50_60==0xff)
        {
            // 1st mode invalid
	    b50_60 =(BYTE)(  ( InputFormat->dwDVAAuxSrc1 & AUDIO5060 ) >> 21 );
        }
	else
        {
            // if the other audio mode is valid than these two should match
            if(b50_60 !=(BYTE)( ( InputFormat->dwDVAAuxSrc1 & AUDIO5060 ) >> 21 ) )
            {
       	        ASSERT( b50_60 ==(BYTE)( ( InputFormat->dwDVAAuxSrc1 & AUDIO5060 ) >> 21 ) );
                return E_FAIL;
            }
	}

        // audio frequency
	bSMP[1]=(BYTE)( ( InputFormat->dwDVAAuxSrc1 & AUDIOSMP ) >> 27 );
        ASSERT(bSMP[1] <= 0x02);
        if(bSMP[1] > 0x02)
        {
            // SMP-> 0=48K, 1=44.1K, 2=32K, everything else invalid
            return E_FAIL;
        }
	
	//how any audio bits
	if( !( InputFormat->dwDVAAuxSrc1 & AUDIOQU )  )
        {
	    bQU[1]=16;
	}
        else if( ( InputFormat->dwDVAAuxSrc1 & AUDIOQU )==0x01000000  )
        {
	    bQU[1]=12;
        }
	else
        {
	    //not support 20 bits
	    ASSERT(bQU[1]==0xff);
            return E_FAIL;
        }
    }

    //---------------------------------------------------------------------
    // 7) initialize DIF Block data depending on if Format is PAL or NTSC    
    
    // either b50_60 is valid, here, or both Audio modes are 0x0f00
    if(b50_60 == 0xff)
    {
        // both blocks bad, both modes == 0x0f00
        return E_FAIL;
    }
    if(!b50_60)
    {
        //525_60
        // NTSC
        pInfo->wBlkMode=45;
        pInfo->wDIFMode=5;
        pInfo-> wBlkDiv=15;
    }
    else
    {
        //625_50
        // PAL
        pInfo->wBlkMode=54;
        pInfo->wDIFMode=6;
        pInfo-> wBlkDiv=18;
    }

    //--------------------------------------------------------------------
    // 8) setup the DVAudInfo, depending on what the audio mode of each of the AAUX's of each of the Audio blocks is
    //************************init DVAudioInfo*******************
    if ( ( (InputFormat->dwDVAAuxSrc  & AUDIOMODE) != 0x00000f00 ) && 
	 ( (InputFormat->dwDVAAuxSrc1 & AUDIOMODE) != 0x00000f00 )  )
    {
        // make sure that the audio quality is only 12 or 16
        if( ( (bQU[0] != 12) && (bQU[0] != 16) ) ||
            ( (bQU[1] != 12) && (bQU[1] != 16) ) )
        {
            return E_FAIL;
        }

        //audio data in all 10/12 DIF sequence
        if ((!dwSMCHN) && (!dwSMCHN1) && ( ( (!dwAUDMOD) && (dwAUDMOD1 == 0x00000100) ) ||  ( (!dwAUDMOD1) && (dwAUDMOD == 0x00000100) ) ) )
        {
    	    //**** 1 language
    	    //mode 1, SM=0,and CHN=0,
            // AUDIOMODE=0000 and AUDIOMODE=0001 or AUDIOMODE=0001 and AUDIOMODE=0000. 
            // Blue book doesn't allow AUDIOMODE=0001 and AUDIOMODE=0000.
    	    pInfo->bAudStyle[0]=0x80;
	    ASSERT(bQU[0]==bQU[1]);
	    pInfo->bAudQu[0]=bQU[0];
	    pInfo->bNumAudPin=1;
	    ppwfx[0]->nChannels        = 2;	//X* if stereo, then 2 
	}
	else if( (dwSMCHN&0x002000) && (dwSMCHN1&0x002000) && !dwAUDMOD && !dwAUDMOD1 )
	{
	    // stereo + stereo
            //**** 2 languages
	    //mode 5-> two stereo : SM=0 and CHN=1,AUDIOMODE=0000 in both 5/6 DIF seq
	    pInfo->bAudStyle[0]=0x40;
	    pInfo->bAudStyle[1]=0x40 | pInfo->wDIFMode;	//0x06 for PAL, 0x05 for NTSC
	    pInfo->bAudQu[0]=bQU[0];
	    pInfo->bAudQu[1]=bQU[1];
	    pInfo->bNumAudPin=2;
	    ppwfx[0]->nChannels        = 2;	//X* if stereo, then 2 
	    ppwfx[1]->nChannels        = 2;	//X* if stereo, then 2 
	}
        else if( (!dwSMCHN) && (!dwSMCHN1) && (dwAUDMOD == 0x00000200) && (dwAUDMOD1 == 0x00000200))
	{	
	    //**** 2 languages
	    //mode 3-> two mon:		SM=0 and CHN=0,AUDIOMODE=0010 in both 5/6 DIF seq
	    pInfo->bAudStyle[0]=0x00;
	    pInfo->bAudStyle[1]=0x00 | pInfo->wDIFMode;	//0x06 for PAL, 0x05 for NTSC
	    pInfo->bAudQu[0]=bQU[0];
	    pInfo->bAudQu[1]=bQU[1];
	    pInfo->bNumAudPin	=2;
	    ppwfx[0]->nChannels        = 1;	//X* if stereo, then 2 
	    ppwfx[1]->nChannels        = 1;	//X* if stereo, then 2 
	}
        else if( (dwSMCHN & 0x002000) && (dwSMCHN1 & 0x002000)
                 && ( ((dwAUDMOD <= 0x0200) && (dwAUDMOD1 <= 0x0600))       // AudMod == Ch(a,b), AudMod1 == Ch(c,d)
                      || ((dwAUDMOD <= 0x0600) && (dwAUDMOD1 <= 0x0200)) ) )// AudMod == Ch(c,d), AudMod1 == Ch(a,b)
        {
	    // **** 2 languages
	    // SM=0/1, PA= 0/1 and CHN=1 (in both blocks' AAUX's)
            // and the audio modes != 0x0F, and != 0x0E
            // we will treat this as a 2, 12 bit stereo tracks case
            // please see Bluebook, Part2 Page 265, part2 page 70, part2 pages 16-21

            // @@@ jaisri: This is bogus. This handles:
            // Stereo + 1 ch mono  - second audio pin nChannels should be set to 1 (fixed 7/12/00)
            // 1 ch mono + stereo - first audio pin should have nChannels set to 1 (fixed 7/12/00)
            // Stereo + 2 ch mono  - really requires 3 audio pins
            // 2 ch mono + Stereo - requires 3 audio pins
            // 4 ch mono - requires 4 audio pins
            // 3 ch mono case 1, 3 ch mono case 2: requires 3 audio pins
            // 2 ch mono case 2 - both audio pins should have nChannels set to 1
            // 3/1 stereo, 3/0 stereo + 1 ch mono, 3/0 stereo and 2/2 stereo
	    pInfo->bAudQu[0]=bQU[0];
	    pInfo->bAudQu[1]=bQU[1];
	    pInfo->bNumAudPin=2;

            if (dwAUDMOD == 0 && dwAUDMOD1 == 0x0100)
            {
                // stereo + 1 ch mono
                pInfo->bAudStyle[0]=0x40;
                pInfo->bAudStyle[1]=0x00 | pInfo->wDIFMode;	//0x06 for PAL, 0x05 for NTSC
                ppwfx[0]->nChannels        = 2;	//X* if stereo, then 2 
                ppwfx[1]->nChannels        = 1;	//X* if stereo, then 2
            }
            else if (dwAUDMOD1 == 0 && dwAUDMOD == 0x0100)
            {
                // 1 ch mono + stereo
                pInfo->bAudStyle[0]=0x00;
                pInfo->bAudStyle[1]=0x40 | pInfo->wDIFMode;	//0x06 for PAL, 0x05 for NTSC
                ppwfx[0]->nChannels        = 1;	//X* if stereo, then 2 
                ppwfx[1]->nChannels        = 2;	//X* if stereo, then 2
            }
            else
            {
                // Code as it was before
                pInfo->bAudStyle[0]=0x40;
                pInfo->bAudStyle[1]=0x40 | pInfo->wDIFMode;	//0x06 for PAL, 0x05 for NTSC
                ppwfx[0]->nChannels        = 2;	//X* if stereo, then 2 
                ppwfx[1]->nChannels        = 2;	//X* if stereo, then 2
            }
        }
        else	
	{
	    //error
	    return E_FAIL;
	}
    }
    else
    {
        // Ignore Audiomodes = 1110 binary, and Audiomodes = 1111 binary
        // see Bluebook Part2 page 265
        if( ( ( (dwAUDMOD) != 0x00000E00 ) &&
              ( (dwAUDMOD1) != 0x00000E00 ) )
              &&
            ( ( (dwAUDMOD) != 0x00000f00 ) ||
              ( (dwAUDMOD1) != 0x00000f00 ) ) )
        {
            // which audio mode is the good one

            // jaisri: Note: The blue book requires that the first of the two 
            // audio blocks always have good audio (see tables on pg 265), so 
            // we really don't have to handle the case when dwAUDMOD is 
            // and 0x00000f00 and dwAUDMOD1 is not. In that case (i.e.
            // if the first pin has no audio), this code "redirects" audio from
            // the second block to the first audio pin.

            int     iGoodIndex     = (dwAUDMOD != 0x00000f00) ? 0 : 1;
            WORD    wDIFMode       = (dwAUDMOD != 0x00000f00) ? 0 : pInfo->wDIFMode;
            DWORD   dwGoodAudMod   = (dwAUDMOD != 0x00000f00) ? dwAUDMOD : dwAUDMOD1;
            DWORD   dwGoodSMCHN    = (dwAUDMOD != 0x00000f00) ? dwSMCHN : dwSMCHN1;

            // make sure that the audio quality is only 12 or 16
            if( (bQU[iGoodIndex] != 12) && (bQU[iGoodIndex] != 16) )
            {
                return E_FAIL;
            }

            // always copy the good block's sampling frequency
            bSMP[0] = bSMP[iGoodIndex];

            // now we have 4 cases:
            // 1ch Mono (with 16 bit channel in the audio block)
            // with 12 bit channel in audio block
            // Stereo
            // 2ch Mono, case 1
            // 1ch Mono

            if(!dwGoodSMCHN)
            {
                // we are in 1 channel per audio block, i.e. 16 bit mode

                // this is the only valid, 1 channel scenario
                if(dwGoodAudMod == 0x0200)
                {
                    // 1ch Mono
                    pInfo->bAudStyle[0] = (BYTE) wDIFMode;     // 0, or 5/6 depending on which block is good
                    pInfo->bAudQu[0] = bQU[iGoodIndex];
                    pInfo->bNumAudPin = 1;
                    ppwfx[0]->nChannels = 1;    // mono
                }
                else
                {
                    // invalid mode
                    return E_FAIL;
                }
            }
            else
            {
                // we are in 2 channel per audio block mode
                if(!dwGoodAudMod)
                {
                    // stereo in 1 one of the 5/6 DIF blocks
                    pInfo->bAudStyle[0] = 0x40 | wDIFMode;     // 0, or 5/6 depending on which block is good
                    pInfo->bAudQu[0] = bQU[iGoodIndex];
                    pInfo->bNumAudPin = 1;
                    ppwfx[0]->nChannels = 2;    // stereo
                }
                else if(dwGoodAudMod == 0x0200)
                {
                    // 2ch mono, case 1
                    // we will treat this as stereo for now
                    // @@@ jaisri: This is wrong. Should set
                    // pInfo->bNumAudPin = 2, with each being mono
                    pInfo->bAudStyle[0] = 0x40 | wDIFMode;     // 0, or 5/6 depending on which block is good
                    pInfo->bAudQu[0] = bQU[iGoodIndex];
                    pInfo->bNumAudPin = 1;
                    ppwfx[0]->nChannels = 2;    // stereo
                }
                else if(dwGoodAudMod == 0x0100)
                {
                    // 1ch mono
                    // again, we will treat this as stereo for now
                    pInfo->bAudStyle[0] = 0x40 | wDIFMode;     // 0, or 5/6 depending on which block is good
                    pInfo->bAudQu[0] = bQU[iGoodIndex];
                    pInfo->bNumAudPin = 1;
                    // @@@ jaisri: Should set nChannels to 1.
                    ppwfx[0]->nChannels = 2;    // stereo
                }
                else
                {
                    // invalid mode
                    return E_FAIL;
                }

            }// endif (dwGoodSMCHN)
        }
	else
	{
            // both tracks are either indistinguishable (audio modes == 0x0E,
            // or have No info (audiomodes == 0x0F)
            return E_FAIL;

	}// endif (both tracks are bad)

    }// endif (at least one of the tracks is bad)


    //-----------------------------------------------------------------
    // 9) Setup the WaveFormatEX

    for(i=0; i<pInfo->bNumAudPin; i++) 
    {
	pInfo->wAvgSamplesPerPinPerFrm[i]=(WORD)aiAudSampPerFrmTab[b50_60][bSMP[i]] ;
	ppwfx[i]->nSamplesPerSec   = aiAudSampFrq[bSMP[i]];	
	ppwfx[i]->wFormatTag	   = WAVE_FORMAT_PCM;
	ppwfx[i]->wBitsPerSample   = 16;
	ppwfx[i]->nBlockAlign      = (ppwfx[i]->wBitsPerSample * ppwfx[i]->nChannels) / 8;
	ppwfx[i]->nAvgBytesPerSec  = ppwfx[i]->nSamplesPerSec * ppwfx[i]->nBlockAlign;
	ppwfx[i]->cbSize           = 0;
    }
	
    return NOERROR;
}


//build audio outpin (s)'s media type according to input pin's media type
HRESULT BuildAudCMT(DVINFO *pDVInfo, CMediaType **ppOutCmt)
{
    HRESULT hr=E_FAIL;

    if( pDVInfo ==NULL )
	return E_OUTOFMEMORY;

    WAVEFORMATEX *ppwfx[2];

    for(int i=0; i<2; i++)
    {
	ppwfx[i]=NULL;
	if(ppOutCmt[i] !=NULL)
	{   
	    ppwfx[i] = (WAVEFORMATEX *)ppOutCmt[i]->Format();
	    if(ppwfx[i]==NULL || ppOutCmt[i]->cbFormat != sizeof(WAVEFORMATEX) )
	    {
		// jaisri - this potentially leaks memory - see the 
                // implementation of CMediaType::ReallocFormatBuffer
                // ppOutCmt[i]->cbFormat = 0;

		ppwfx[i] = (WAVEFORMATEX *)ppOutCmt[i]->ReallocFormatBuffer(sizeof(WAVEFORMATEX));
		
                // jaisri - Wrong. We don't know what size was alloc'd,
                // so don't change this
                // ppOutCmt[i]->cbFormat = sizeof(WAVEFORMATEX);
	    }
	    
	    ppOutCmt[i]->majortype		    =MEDIATYPE_Audio; //streamtypeAUDIO
	    ppOutCmt[i]->subtype		    =MEDIASUBTYPE_PCM; 
	    ppOutCmt[i]->bFixedSizeSamples	    =1;	//X* 1 for lSampleSize is not 0 and fixed
	    ppOutCmt[i]->bTemporalCompression	    =0; 
	    ppOutCmt[i]->formattype		    =FORMAT_WaveFormatEx;
	}
    }

    DVAudInfo tmpDVAudInfo;

    //build pwfx
    hr=BuildDVAudInfo(pDVInfo, ppwfx, &tmpDVAudInfo);

    for(int i=1; i >= tmpDVAudInfo.bNumAudPin; i--)
    {
        // Since ppwfx[i] is not initialized, undo our initialization
        // Without this, we were relying on an uninitialized value of
        // nChannels to cause connections to the audio pin to be rejected,
        // e.g., see the call to this function from CDVSpInputPin::CheckMediaType
        // and from CDVSpOutputPin::GetMediaType

        if(ppOutCmt[i] !=NULL)
	{   
	    ppOutCmt[i]->majortype		    =GUID_NULL;
	    ppOutCmt[i]->subtype		    =GUID_NULL; 
	    ppOutCmt[i]->formattype		    =GUID_NULL;
	}
    }

    return hr;
}

//build outpin's media type according to input pin's media type
HRESULT BuildVidCMT(DVINFO *pDvinfo, CMediaType *pOutCmt)
{
    if( pDvinfo ==NULL )
	return E_OUTOFMEMORY;

    pOutCmt->majortype	    =MEDIATYPE_Video; 
    pOutCmt->subtype	    =MEDIASUBTYPE_dvsd;
    pOutCmt->formattype     =FORMAT_VideoInfo;
    pOutCmt->cbFormat	    =0;

    VIDEOINFO *pVideoInfo;
    pVideoInfo = (VIDEOINFO *)pOutCmt->Format();
    if(pVideoInfo==NULL)
    {
	pVideoInfo = (VIDEOINFO *)pOutCmt->ReallocFormatBuffer(SIZE_VIDEOHEADER);
	pOutCmt->cbFormat = SIZE_VIDEOHEADER;
    }
    else if(  pOutCmt->cbFormat != SIZE_VIDEOHEADER )
    {
	ASSERT( pDvinfo !=NULL);
	ASSERT( pVideoInfo != NULL);
	ASSERT( pOutCmt->cbFormat == SIZE_VIDEOHEADER);
	return E_UNEXPECTED;
    }

    //dvdec does not use this information yet.  3-28-97
    LPBITMAPINFOHEADER lpbi	= HEADER(pVideoInfo);
    lpbi->biSize		= sizeof(BITMAPINFOHEADER);

    if( ! ( ( pDvinfo->dwDVVAuxSrc & AUDIO5060 ) >> 21 )  )
    {  
	//525_60
	lpbi->biHeight		    = 480;
	pVideoInfo->AvgTimePerFrame = UNITS*1000L/29970L;
    }
    else
    {
	lpbi->biHeight		    = 576;
	pVideoInfo->AvgTimePerFrame = UNITS/25;
    }


    lpbi->biWidth		= 720;	
    lpbi->biPlanes		= 1;
    lpbi->biBitCount		= 24;
    lpbi->biXPelsPerMeter	= 0;
    lpbi->biYPelsPerMeter	= 0;
    lpbi->biCompression		= FCC('dvsd');
    lpbi->biSizeImage		=(lpbi->biHeight== 480 )? 120000:144000; //GetBitmapSize(lpbi);
    lpbi->biClrUsed		= 0;
    lpbi->biClrImportant	= 0;
    pVideoInfo->rcSource.top	= 0;
    pVideoInfo->rcSource.left	= 0;
    pVideoInfo->rcSource.right	= lpbi->biWidth;			
    pVideoInfo->rcSource.bottom = lpbi->biHeight;			
    
    pVideoInfo->rcTarget	= pVideoInfo->rcSource;
    LARGE_INTEGER li;
    li.QuadPart			= pVideoInfo->AvgTimePerFrame;
    pVideoInfo->dwBitRate	= MulDiv(lpbi->biSizeImage, 80000000, li.LowPart);
    pVideoInfo->dwBitErrorRate	= 0L;

    return NOERROR;
}


CDVPosPassThru::CDVPosPassThru(const TCHAR *pName,
			   LPUNKNOWN pUnk,
			   HRESULT *phr,
			   IPin *pPin,
			   CDVSp *pDVSp) 
    : CPosPassThru(pName,pUnk, phr,pPin),
      m_pPasDVSp (pDVSp)
{}
//----------------------------------------------------------------------------
// CDVSpOutputPin destructor
//----------------------------------------------------------------------------
CDVPosPassThru::~CDVPosPassThru ()
{
}


STDMETHODIMP
CDVPosPassThru::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
			  , LONGLONG * pStop, DWORD StopFlags )
{
	return CPosPassThru::SetPositions(pCurrent, CurrentFlags, pStop, StopFlags);

    // EHR: what was this code? (Danny says this will make us laugh someday)
    //
    if (InterlockedExchange (&m_pPasDVSp->m_lCanSeek, FALSE) == FALSE)
	return CPosPassThru::SetPositions(pCurrent, CurrentFlags, pStop, StopFlags);
    else
       return S_OK ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dvdgb\sample\tdvdplay.h ===
//
// TDVDPlay.h: DVDGraphBuilder test/sample app header file
//

#define IDM_SELECT           101
#define IDM_ABOUT            102
#define IDM_EXIT             103
#define IDM_HWMAX            111
#define IDM_HWONLY           112
#define IDM_SWMAX            113
#define IDM_SWONLY           114
#define IDM_NOVPE            115
#define IDM_BUILDGRAPH       121
#define IDM_PLAY             122
#define IDM_STOP             123
#define IDM_PAUSE            124
#define IDM_MENU             125
#define IDM_CC               126

#define DLG_VERFIRST        400
#define IDC_COMPANY         DLG_VERFIRST
#define IDC_FILEDESC        DLG_VERFIRST+1
#define IDC_PRODVER         DLG_VERFIRST+2
#define IDC_COPYRIGHT       DLG_VERFIRST+3
#define IDC_OSVERSION       DLG_VERFIRST+4
#define IDC_TRADEMARK       DLG_VERFIRST+5
#define DLG_VERLAST         DLG_VERFIRST+5

#define IDC_LABEL           DLG_VERLAST+1


#define IDS_APP_TITLE       500
#define IDS_VER_INFO_LANG   502
#define IDS_VERSION_ERROR   503


//
// Sample DVD Playback class
//
class CSampleDVDPlay {
public:   // public methods for Windows structure to call
    CSampleDVDPlay(void) ;
    ~CSampleDVDPlay(void) ;

    void    SetAppValues(HINSTANCE hInst, LPTSTR szAppName, 
                         int iAppTitleResId) ;
    BOOL    InitInstance(int nCmdShow) ;
    BOOL    InitApplication(void) ;
    LPTSTR  GetAppName() { return m_szAppName ; } ;
    HINSTANCE GetInstance() { return m_hInstance ; } ;
    HWND    GetWindow() { return m_hWnd ; } ;

    void    BuildGraph(void) ;
    void    Play(void) ;
    void    Pause(void) ;
    void    Stop(void) ;
    void    ShowMenu(void) ;
    BOOL    ClosedCaption(void) ;
    void    SetRenderFlag(DWORD dwFlag) ;
    BOOL    IsFlagSet(DWORD dwFlag) ;
    void    FileSelect(void) ;
    DWORD   GetStatusText(AM_DVD_RENDERSTATUS *pStatus, 
                          LPTSTR lpszStatusText,
                          DWORD dwMaxText) ;

private:  // private helper methods for the class' own use
    LPTSTR  GetStringRes (int id) ;
    
private:  // internal state info
    HINSTANCE     m_hInstance ;       // current instance
    HWND          m_hWnd ;            // app window handle
    TCHAR         m_szAppName[100] ;  // name of the app
    TCHAR         m_szTitle[100] ;    // title bar text
    TCHAR         m_achBuffer[100] ;  // app's internal buffer for res strings etc.
    BOOL          m_bMenuOn ;         // is DVD menu being shown now?
    BOOL          m_bCCOn ;           // is CC being shown?
    DWORD         m_dwRenderFlag ;    // flags to use for building graph
    // WCHAR         m_achwFileName[MAX_PATH] ;  // root file name

    IDvdGraphBuilder *m_pDvdGB ;      // IDvdGraphBuilder interface
    IVideoWindow  *m_pVW ;            // IVideoWindow interface
    IGraphBuilder *m_pGraph ;         // IGraphBuilder interface
    IDvdControl   *m_pDvdC ;          // IDvdControl interface
    IMediaControl *m_pMC ;            // IMediaControl interface
    IAMLine21Decoder *m_pL21Dec ;     // IAMLine21Decoder interface
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dvdgb3\dvdgb.h ===
// Copyright (c) Microsoft Corporation 1994-2000. All Rights Reserved

//
// A class managing list of HW and/or SW decoders used to build the DVD
// playback graph.
//
#define FILTERLIST_DEFAULT_MAX        10
#define FILTERLIST_DEFAULT_INC        10

class CFilterData {
    public:
        CFilterData(void) ;
        ~CFilterData(void) ;
        
        inline IBaseFilter * GetInterface(void)  { return m_pFilter ; } ;
        inline BOOL          IsHWFilter(void)    { return NULL == m_lpszwName ; } ;
        inline LPWSTR        GetName(void)       { return m_lpszwName ; } ;
        inline GUID        * GetClsid(void)      { return m_pClsid ; } ;
        void   SetElement(IBaseFilter *pFilter, LPCWSTR lpszwName, GUID *pClsid) ;
        void   ResetElement(void) ;

    private:
        IBaseFilter   *m_pFilter ;   // filter pointer
        LPWSTR         m_lpszwName ; // filter name (NULL for SW filters)
        GUID          *m_pClsid ;    // filter CLSID pointer
} ;

class CListFilters {

    public:  // class interface

        CListFilters(int iMax = FILTERLIST_DEFAULT_MAX, 
                     int iInc = FILTERLIST_DEFAULT_INC) ;
        ~CListFilters() ;

        BOOL AddFilter(IBaseFilter *pFilter, LPCWSTR lpszwName, GUID *pClsid) ;
        BOOL GetFilter(int iIndex, IBaseFilter **ppFilter, LPWSTR *lpszName) ;
        BOOL GetFilter(GUID *pClsid, int iIndex, IBaseFilter **ppFilter) ;
        BOOL IsInList(IBaseFilter *pFilter) ;
        void ClearList(void) ;
        void RemoveAllFromGraph(void) ;
        int  GetCount(void)                     { return m_iCount ; } ;
        void SetGraph(IGraphBuilder *pGraph)    { m_pGraph = pGraph ; } ;

    private:  // internal helper method

        BOOL ExpandList(void) ;

    private:  // internal data

        int             m_iCount ;    // number of filters (HW/SW) in the list
        int             m_iMax ;      // current max capacity of the list
        int             m_iInc ;      // increment for max capacity of list
        CFilterData    *m_pFilters ;  // list of filters
        IGraphBuilder  *m_pGraph ;    // filter graph pointer
} ;


//
// An internally defined stream flag to check line21 data rendering.
// Leave enough space for future stream flags.
//
#define AM_DVD_STREAM_LINE21      0x0080
// move the following two to dvdif.idl
#define AM_DVD_STREAM_ASF         0x0008
#define AM_DVD_STREAM_ADDITIONAL  0x0010

#define DVDGRAPH_FLAGSVALIDDEC    0x000F

//
// A set of internal flags to connect pins in various ways
//
#define AM_DVD_CONNECT_DIRECTONLY      0x01
#define AM_DVD_CONNECT_DIRECTFIRST     0x02
#define AM_DVD_CONNECT_INDIRECT        0x04

//
// The actual class object implementing IDvdGraphBuilder interface
//
class CDvdGraphBuilder : public CUnknown, public IDvdGraphBuilder
{

    public:  // methods

        CDvdGraphBuilder(TCHAR *, LPUNKNOWN, HRESULT *) ;
        ~CDvdGraphBuilder() ;

        DECLARE_IUNKNOWN

        // this goes in the factory template table to create new instances
        static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *) ;
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv) ;

        // IDvdGraphBuilder stuff
        STDMETHODIMP GetFiltergraph(IGraphBuilder **ppGB) ;
        STDMETHODIMP GetDvdInterface(REFIID riid, void **ppvIF) ;
        STDMETHODIMP RenderDvdVideoVolume(LPCWSTR lpcwszPathName, DWORD dwFlags,
                                          AM_DVD_RENDERSTATUS *pStatus) ;
#if 0
        STDMETHODIMP SetFiltergraph(IGraphBuilder *pGB) ;
#endif // #if 0

    private:  // internal helper methods

        HRESULT EnsureGraphExists(void) ;
        HRESULT CreateGraph(void) ;
        HRESULT DeleteGraph(void) ;
        HRESULT ClearGraph(void) ;
        void    StopGraph(void) ;
        // HRESULT RemoveAllFilters(void) ;
        HRESULT ResetDDrawParams(void) ;
        HRESULT EnsureOverlayMixerExists(void) ;
        HRESULT EnsureVMRExists(void) ;
        HRESULT CreateVMRInputPins(void) ;
        
        HRESULT RenderNavVideoOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderNavAudioOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderNavSubpicOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderNavASFOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderNavOtherOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT DecodeDVDStream(IPin *pPinOut, DWORD dwStream, DWORD *pdwDecFlag,
                                AM_DVD_RENDERSTATUS *pStatus, IPin **apPinOutDec) ;
        HRESULT HWDecodeDVDStream(IPin *pPinOut, DWORD dwStream, IPin **pPinIn,
                                   AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT SWDecodeDVDStream(IPin *pPinOut, DWORD dwStream, IPin **pPinIn,
                                   AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT ConnectPins(IPin *pPinOut, IPin *pPinIn, DWORD dwOption) ;
        HRESULT RenderDecodedVideo(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus,
                                   DWORD dwDecFlag) ;
        HRESULT RenderDecodedAudio(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderDecodedSubpic(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderLine21Stream(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderRemainingPins(void) ;
        BOOL    IsOutputDecoded(IPin *pPinOut) ;
        BOOL    IsOutputTypeVPVideo(IPin *pPinOut) ;

        HRESULT CreateFilterInGraph(CLSID Clsid,
                                    LPCWSTR lpszwFilterName, 
                                    IBaseFilter **ppFilter) ;
        HRESULT CreateDVDHWDecoders(void) ;
        HRESULT FindMatchingPin(IBaseFilter *pFilter, DWORD dwStream, 
                                PIN_DIRECTION pdWanted, BOOL bOpen, 
                                int iIndex, IPin **ppPin) ;
        DWORD GetStreamFromMediaType(AM_MEDIA_TYPE *pmt) ;
        DWORD   GetPinStreamType(IPin *pPin) ;
        HRESULT GetFilterCLSID(IBaseFilter *pFilter, DWORD dwStream, LPCWSTR lpszwName,
                               GUID *pClsid) ;
        HRESULT EnumFiltersBetweenPins(DWORD dwStream, IPin *pPinOut, IPin *pPinIn,
                                       AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderIntermediateOutPin(IBaseFilter *pFilter, DWORD dwStream, 
                                         AM_DVD_RENDERSTATUS *pStatus) ;
        void    CheckDDrawExclMode(void) ;
        inline  BOOL  IsDDrawExclMode(void)   { return m_bDDrawExclMode ; } ;
        IPin *  GetFilterForMediaType(DWORD dwStream, AM_MEDIA_TYPE *pmt, 
                                      IBaseFilter *pOutFilter) ;
        void ResetPinInterface(IPin **apPin, int iCount) ;
        void ReleasePinInterface(IPin **apPin) ;
        BOOL IsFilterVMRCompatible(IBaseFilter *pFilter) ;
        inline  BOOL  GetVMRUse(void)   { return m_bTryVMR ; } ;
        inline  void  SetVMRUse(BOOL bState)   { m_bTryVMR = bState ; } ;
        HRESULT RenderVideoUsingOvMixer(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderVideoUsingVMR(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderSubpicUsingOvMixer(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderSubpicUsingVMR(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderVideoUsingVPM(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus,
                                    IPin **ppPinOut) ;

    private:  // internal data

        IGraphBuilder *m_pGB ;        // the filter graph we are using
        IFilterMapper *m_pMapper ;    // filter mapper object pointer
        IBaseFilter   *m_pDVDNav ;    // our default DVD source -- DVD Nav
        IBaseFilter   *m_pOvM ;       // OverlayMixer filter
        IBaseFilter   *m_pL21Dec ;    // Line21 decoder filter
        IBaseFilter   *m_pAR ;        // Audio Renderer filter
        IBaseFilter   *m_pVR ;        // Video Renderer filter
        IBaseFilter   *m_pVPM ;       // Video Port Manager filter
        IBaseFilter   *m_pVMR ;       // Video Mixing Renderer filter

        CListFilters   m_ListHWDecs ; // list of WDM DVD decoder filters
        CListFilters   m_ListFilters ;// list of all decoder(-type) filters

        BOOL           m_bGraphDone ;  // has DVD graph been already built?
        BOOL           m_bUseVPE ;     // user wants to use VPE output?
        BOOL           m_bPinNotRendered ; // any out pin not rendered in normal run?
        BOOL           m_bDDrawExclMode ;  // building graph for DDraw exclusive mode?
        BOOL           m_bTryVMR ;     // try to VMR filter rather than OvM+VR?
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dvdgb3\dvdgb.cpp ===
// Copyright (c) 1994 - 2000  Microsoft Corporation.  All Rights Reserved.

#include <streams.h>
#include <vfwmsgs.h>

#ifdef FILTER_DLL
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#endif

#include <dvdmedia.h>
#include <IL21Dec.h>
#include "dvdgb.h"
#include "..\image2\inc\vmrp.h"

// setup data

#ifdef FILTER_DLL
// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = {
    { L"DVD Graph Builder"
        , &CLSID_DvdGraphBuilder
        , CDvdGraphBuilder::CreateInstance
        , NULL
        , NULL }    // self-registering info
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}
#endif



CDvdGraphBuilder::CDvdGraphBuilder(TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr)
: CUnknown(pName, pUnk),
m_pGB(NULL),
m_pMapper(NULL),
m_ListFilters(20, 10),
m_ListHWDecs(10, 10),
m_pDVDNav(NULL),
m_pOvM(NULL),
m_pAR(NULL),
m_pVR(NULL),
m_pVMR(NULL),
m_pVPM(NULL),
m_pL21Dec(NULL),
m_bGraphDone(FALSE),
m_bUseVPE(TRUE),
m_bPinNotRendered(FALSE),
m_bDDrawExclMode(FALSE),
m_bTryVMR(TRUE)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::CDvdGraphBuilder()"))) ;

    *phr = CreateGraph() ;
}


CDvdGraphBuilder::~CDvdGraphBuilder(void)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::~CDvdGraphBuilder() entering"))) ;

    // If we have a graph object
    if (m_pGB)
    {
        StopGraph() ;  // make sure the graph is REALYY stopped

        // Break the connections and remove all the filters we added from the graph
        ClearGraph() ;

        // Remove and release OverlayMixer now, if it was there
        if (m_pOvM)
        {
            EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pOvM))) ;
            m_pOvM->Release() ;
            m_pOvM = NULL ;
        }

        // Remove and release VMR, if it was there
        if (m_pVMR)
        {
            EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pVMR))) ;
            m_pVMR->Release() ;
            m_pVMR = NULL ;
        }

        m_pGB->Release() ;  // free it
        m_pGB = NULL ;
    }

    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::~CDvdGraphBuilder() ending"))) ;
}


// this goes in the factory template table to create new instances
CUnknown * CDvdGraphBuilder::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CDvdGraphBuilder(TEXT("DVD Graph Builder II"), pUnk, phr) ;
}


STDMETHODIMP CDvdGraphBuilder::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::NonDelegatingQueryInterface()"))) ;
    if (ppv)
        *ppv = NULL;

    if (riid == IID_IDvdGraphBuilder)
    {
        DbgLog((LOG_TRACE, 5, TEXT("QI for IDvdGraphBuilder"))) ;
        return GetInterface((IDvdGraphBuilder *) this, ppv) ;
    }
    else // more interfaces
    {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv) ;
    }
}


// -----------------------------
//  IDvdGraphBuilder stuff ....
// -----------------------------

//
// What filtergraph is graph building being done in?
//
HRESULT CDvdGraphBuilder::GetFiltergraph(IGraphBuilder **ppGB)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::GetFiltergraph(0x%lx)"), ppGB)) ;

    if (ppGB == NULL)
        return E_POINTER ;

    EnsureGraphExists() ;

    *ppGB = m_pGB ;
    if (NULL == m_pGB)
    {
        return E_UNEXPECTED ;
    }
    m_pGB->AddRef() ;   // app owns a copy now
    return NOERROR ;
}

DEFINE_GUID(IID_IDDrawNonExclModeVideo,
            0xec70205c, 0x45a3, 0x4400, 0xa3, 0x65, 0xc4, 0x47, 0x65, 0x78, 0x45, 0xc7) ;

DEFINE_GUID(IID_IAMSpecifyDDrawConnectionDevice,
            0xc5265dba, 0x3de3, 0x4919, 0x94, 0x0b, 0x5a, 0xc6, 0x61, 0xc8, 0x2e, 0xf4) ;

//
// Get a specified interface off of a filter in the DVD playback graph
//
HRESULT CDvdGraphBuilder::GetDvdInterface(REFIID riid, void **ppvIF)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::GetDvdInterface(%s, 0x%lx)"),
        (LPCTSTR)CDisp(riid), ppvIF)) ;

    HRESULT  hr ;

    if (IsBadWritePtr(ppvIF, sizeof(LPVOID)))
        return E_INVALIDARG ;
    *ppvIF =  NULL ;

    // We should be able to provide the IDDrawExclModeVideo interface even
    // before the graph is built so that apps can specify their own DDraw
    // params to be used by OvMixer to build the graph.
    if (IID_IDDrawExclModeVideo == riid ||
        IID_IDDrawNonExclModeVideo == riid ||
        IID_IAMSpecifyDDrawConnectionDevice == riid)
    {
        if (NULL == m_pVMR)  // if we are already NOT using VMR
        {
            hr = EnsureOverlayMixerExists() ;
            ASSERT(SUCCEEDED(hr) && m_pOvM) ;
            if (SUCCEEDED(hr)  &&  m_pOvM)
            {
                SetVMRUse(FALSE) ;  // can't use VMR anymore
                return m_pOvM->QueryInterface(riid, (LPVOID *)ppvIF) ;
            }
        }
        return E_NOINTERFACE ;
    }

    // We should be able to provide the IVMR* interfaces even before the graph
    // is built so that apps can specify their own rendering settings to be
    // used by VMR whille building the graph.
    if (IID_IVMRMixerBitmap       == riid ||
        IID_IVMRFilterConfig      == riid ||
        IID_IVMRWindowlessControl == riid ||
        IID_IVMRMonitorConfig     == riid)
    {
        if (NULL == m_pOvM)  // if we are already NOT using OvMixer
        {
            hr = EnsureVMRExists() ;
            ASSERT(SUCCEEDED(hr) && m_pVMR) ;
            if (SUCCEEDED(hr)  &&  m_pVMR)
            {
                // SetVMRUse(TRUE) ;  // should try to use VMR for sure
                return m_pVMR->QueryInterface(riid, (LPVOID *)ppvIF) ;
            }
        }
        return E_NOINTERFACE ;
    }

    // We don't return IVMRPinConfig pointer.  If needed the app can get the
    // VMR interface and get the pin config interface for the needed pin.

    // We can't return ANY OTHER internal filter interface pointers before
    // building the whole graph.
    if (! m_bGraphDone )
        return VFW_E_DVD_GRAPHNOTREADY ;

    if (IID_IDvdControl == riid)
    {
        return m_pDVDNav->QueryInterface(IID_IDvdControl, (LPVOID *)ppvIF) ;
    }
    else if (IID_IDvdControl2 == riid)
    {
        return m_pDVDNav->QueryInterface(IID_IDvdControl2, (LPVOID *)ppvIF) ;
    }
    else if (IID_IDvdInfo == riid)
    {
        return m_pDVDNav->QueryInterface(IID_IDvdInfo, (LPVOID *)ppvIF) ;
    }
    else if (IID_IDvdInfo2 == riid)
    {
        return m_pDVDNav->QueryInterface(IID_IDvdInfo2, (LPVOID *)ppvIF) ;
    }
    else if (IID_IVideoWindow == riid)
    {
        if (m_pVR || m_pVMR)
            return m_pGB->QueryInterface(IID_IVideoWindow, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else if (IID_IBasicVideo == riid)
    {
        if (m_pVR)
            return m_pVR->QueryInterface(IID_IBasicVideo, (LPVOID *)ppvIF) ;
        else if (m_pVMR)
            return m_pVMR->QueryInterface(IID_IBasicVideo, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else if (IID_IBasicAudio == riid)
    {
        return m_pGB->QueryInterface(IID_IBasicAudio, (LPVOID *)ppvIF) ;
    }
    else if (IID_IAMLine21Decoder == riid)
    {
        if (m_pL21Dec)
            return m_pL21Dec->QueryInterface(IID_IAMLine21Decoder, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else if (IID_IMixerPinConfig == riid  ||  IID_IMixerPinConfig2 == riid)
    {
        // First check if VMR is already being used.  In that case we don't use
        // OvMixer, and hence no such interface.
        if (m_pVMR)
        {
            DbgLog((LOG_TRACE, 3, TEXT("VMR being used. Can't get IMixerPinConfig(2)."))) ;
            return E_NOINTERFACE ;
        }

        // In all likelihood, this app wants to use the OvMixer. So we'll go on
        // that path (create OvMixer, if it's not there) and return the interface.
        *ppvIF = NULL ;  // initially
        hr = EnsureOverlayMixerExists() ;
        ASSERT(SUCCEEDED(hr) && m_pOvM) ;
        if (SUCCEEDED(hr)  &&  m_pOvM)
        {
            IEnumPins     *pEnumPins ;
            IPin          *pPin = NULL ;
            PIN_DIRECTION  pd ;
            ULONG          ul ;
            hr = m_pOvM->EnumPins(&pEnumPins) ;
            ASSERT(SUCCEEDED(hr) && pEnumPins) ;
            // Get the 1st input pin
            while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
            {
                pPin->QueryDirection(&pd) ;
                if (PINDIR_INPUT == pd)
                {
                    hr = pPin->QueryInterface(riid, (LPVOID *)ppvIF) ;
                    pPin->Release() ;
                    break ;  // we got it
                }
                pPin->Release() ;
            }
            pEnumPins->Release() ;  // release before returning
            if (*ppvIF)
                return S_OK ;
        }
        return E_NOINTERFACE ;
    }
    else
        return E_NOINTERFACE ;
}


//
// Build the whole graph for playing back the specifed or default DVD volume
//
HRESULT CDvdGraphBuilder::RenderDvdVideoVolume(LPCWSTR lpcwszPathName, DWORD dwFlags,
                                               AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::RenderDvdVideoVolume(0x%lx, 0x%lx, 0x%lx)"),
        lpcwszPathName, dwFlags, pStatus)) ;

    HRESULT    hr ;

    hr = EnsureGraphExists() ;  // make sure that a graph exists; if not create one
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't create a filter graph object"))) ;
        return VFW_E_DVD_RENDERFAIL ;
    }

    if (m_bGraphDone)  // if graph was built before,
        StopGraph() ;  // just make sure the graph is in Stopped state first

    ClearGraph() ;
    m_bPinNotRendered = FALSE ;  // reset the flag

    ZeroMemory(pStatus, sizeof(AM_DVD_RENDERSTATUS)) ;  // clear status
    m_bUseVPE = (0 == (dwFlags & AM_DVD_NOVPE)) ;       // is VPE needed?
    DbgLog((LOG_TRACE, 3, TEXT("Flag: VPE is '%s'"), m_bUseVPE ? "On" : "Off")) ;
    dwFlags &= DVDGRAPH_FLAGSVALIDDEC ;                 // mask off the VPE flag now

    if (0 == dwFlags) // 0 by default means HW max
    {
        DbgLog((LOG_TRACE, 3, TEXT("dwFlags specified as 0x%lx; added .._HWDEC_PREFER"), dwFlags)) ;
        dwFlags |= AM_DVD_HWDEC_PREFER ;  // use HW Decs maxm
    }

    if (AM_DVD_HWDEC_PREFER != dwFlags && AM_DVD_HWDEC_ONLY != dwFlags &&
        AM_DVD_SWDEC_PREFER != dwFlags && AM_DVD_SWDEC_ONLY != dwFlags)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Invalid dwFlags (0x%lx) specified "), dwFlags)) ;
        return E_INVALIDARG ;
    }

    HRESULT    hrFinal = S_OK ;

    m_ListFilters.SetGraph(m_pGB) ;  // specify graph in which all filters will be added

    CheckDDrawExclMode() ;   // check if we are building for DDraw exclusive mode

    // If we are in DDraw (non-)exclusive mode, we are supposed to use only
    // the OvMixer, and not the VMR.  We update the flag here and check it in
    // the stream render functions.
    SetVMRUse(GetVMRUse() && !IsDDrawExclMode()) ;

    //
    // Instantiate DVD Nav filter first
    //
    hr = CreateFilterInGraph(CLSID_DVDNavigator, L"DVD Navigator", &m_pDVDNav) ;
    if (FAILED(hr)  ||  NULL == m_pDVDNav)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: DVD Nav couldn't be instantiated (Error 0x%lx)"), hr)) ;
        return VFW_E_DVD_RENDERFAIL ;
    }

    //
    // If .._SWDEC_ONLY flag was NOT specified, instantiate all the useful HW
    // decoders and maintain a list.
    //
    if (AM_DVD_SWDEC_ONLY != dwFlags)
    {
        DbgLog((LOG_TRACE, 5, TEXT(".._SWDEC_ONLY flag has NOT been specified. Enum-ing HW dec filters..."))) ;
        hr = CreateDVDHWDecoders() ;
        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE, 5, TEXT("HW DVD decoder enumeration failed (Error 0x%lx)"), hr)) ;
        }
    }

    // Create filter mapper here to use it in the following calls
    hr = CoCreateInstance(CLSID_FilterMapper, NULL, CLSCTX_INPROC,
        IID_IFilterMapper, (LPVOID *)&m_pMapper) ;
    ASSERT(SUCCEEDED(hr)  &&  m_pMapper) ;

    // First render the video stream
    hr = RenderNavVideoOutPin(dwFlags, pStatus) ;
    if (S_OK != hr)   // everything isn't good
    {
        //
        //  Video stream rendering also includes line21 rendering.  If that
        //  fails due to any reason, including the reason that video decoder
        //  doesn't have a line21 output pin, we don't want to mark it as a
        //  video stream rendering failure.  The line21 rendering failure
        //  flags are set deep inside. We set the video decode/render failure
        //  flags also in the video decode/rendering code. We just downgrade
        //  the overall result here.
        //
        DbgLog((LOG_TRACE, 3, TEXT("Something wrong with video stream rendering"))) ;
        if (SUCCEEDED(hrFinal))  // was perfect so far
        {
            DbgLog((LOG_TRACE, 3, TEXT("Overall result downgraded from 0x%lx to 0x%lx"), hrFinal, hr)) ;
            hrFinal = hr ;
        }
    }

    // Then render the subpicture stream
    hr = RenderNavSubpicOutPin(dwFlags, pStatus) ;
    if (S_OK != hr)
    {
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_SUBPIC ;
        if (SUCCEEDED(hrFinal))  // was perfect so far
        {
            DbgLog((LOG_TRACE, 3, TEXT("Overall result downgraded from 0x%lx to 0x%lx"), hrFinal, hr)) ;
            hrFinal = hr ;
        }
    }

    // And then render the audio stream
    hr = RenderNavAudioOutPin(dwFlags, pStatus) ;
    if (S_OK != hr)
    {
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_AUDIO ;
        if (SUCCEEDED(hrFinal))  // was perfect so far
        {
            DbgLog((LOG_TRACE, 3, TEXT("Overall result downgraded from 0x%lx to 0x%lx"), hrFinal, hr)) ;
            hrFinal = hr ;
        }
    }
    DbgLog((LOG_TRACE, 5, TEXT("Setting number of DVD streams to 3"))) ;
    pStatus->iNumStreams = 3 ;  // so far 3 DVD streams

    //
    // In case any output pin was not rendered because we had more than one decoded
    // output pin for one stream, we try to locate that pin and render it as a last
    // ditch effort.
    //
    if (m_bPinNotRendered)
    {
        hr = RenderRemainingPins() ;
        if (S_OK != hr)  // some problem in rendering
        {
            if (SUCCEEDED(hrFinal))  // was perfect so far
            {
                DbgLog((LOG_TRACE, 3, TEXT("Overall result downgraded from 0x%lx to 0x%lx"), hrFinal, hr)) ;
                hrFinal = hr ;
            }
        }
    }

    //
    // Now render any additional streams, e.g, the ASF stream, if any.
    //
    // Currently does NOT do anything.
    //
    hr = RenderNavASFOutPin(dwFlags, pStatus) ;
    ASSERT(SUCCEEDED(hr)) ;
    hr = RenderNavOtherOutPin(dwFlags, pStatus) ;
    ASSERT(SUCCEEDED(hr)) ;

    // Done with the filter mapper. Let it go now.
    m_pMapper->Release() ;
    m_pMapper = NULL ;

    m_ListHWDecs.ClearList() ;  // don't need the extra HW filters anymore

    if (pStatus->iNumStreamsFailed >= pStatus->iNumStreams)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Failed to render %d out of %d main DVD streams (Error 0x%lx)"),
            pStatus->iNumStreamsFailed, pStatus->iNumStreams, hrFinal)) ;
        return VFW_E_DVD_DECNOTENOUGH;  // VFW_E_DVD_RENDERFAIL ;
    }

    if (FAILED(hrFinal))
    {
        DbgLog((LOG_TRACE, 1, TEXT("DVD graph building failed with error 0x%lx"),
            hrFinal)) ;
        return VFW_E_DVD_RENDERFAIL ;
    }

    //
    // Set the specified root file name/DVD volume name (even NULL because
    // that causes the DVD Nav to search for one)
    //
    IDvdControl  *pDvdC ;
    hr = m_pDVDNav->QueryInterface(IID_IDvdControl, (LPVOID *)&pDvdC) ;
    if (FAILED(hr) || NULL == pDvdC)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't get IDvdControl interface (Error 0x%lx)"), hr)) ;
        return hr ;
    }

    //
    // Set the specified DVD volume path
    //
    // Does the SetRoot() function handle the NULL properly?
    //
    hr = pDvdC->SetRoot(lpcwszPathName) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 2,
            TEXT("IDvdControl::SetRoot(%S) call couldn't use specified volume (Error 0x%lx)"),
            lpcwszPathName ? L"NULL" : lpcwszPathName, hr)) ;
        if (lpcwszPathName)
            pStatus->bDvdVolInvalid = TRUE ;
        else
            pStatus->bDvdVolUnknown = TRUE ;
        if (SUCCEEDED(hrFinal))  // if we were so far perfect, ...
            hrFinal = S_FALSE ;  // ...we aren't so anymore
    }

    pDvdC->Release() ;  // done with this interface

    // Only if we haven't entirely failed, set the graph built flag and
    // return overall result.
    if (SUCCEEDED(hrFinal))
        m_bGraphDone = TRUE ;

    m_bPinNotRendered = FALSE ;  // should reset on success too

    return hrFinal ;
}


//    private: internal helper methods

//
// Make sure a filter graph has been created; if not create one here
//
HRESULT CDvdGraphBuilder::EnsureGraphExists(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::EnsureGraphExists()"))) ;

    if (m_pGB)
        return S_OK ;

    return CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC,
        IID_IGraphBuilder, (LPVOID *)&m_pGB) ;
}



//
// Make sure OverlayMixer has been created; if not create one here.
//
HRESULT CDvdGraphBuilder::EnsureOverlayMixerExists(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::EnsureOverlayMixerExists()"))) ;

    if (m_pOvM)
        return S_OK ;

    return CreateFilterInGraph(CLSID_OverlayMixer, L"Overlay Mixer", &m_pOvM) ;
}


//
// Make sure VMR has already been created; if not create one here.
//
HRESULT CDvdGraphBuilder::EnsureVMRExists(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::EnsureVMRExists()"))) ;

    if (m_pVMR)
        return S_OK ;

    HRESULT  hr ;
    hr = CreateFilterInGraph(CLSID_VideoMixingRenderer, L"Video Mixing Renderer", &m_pVMR) ;
    ASSERT(m_pVMR) ;
    if (SUCCEEDED(hr))
    {
        IVMRFilterConfigInternal* pVMRConfigInternal;

        hr = m_pVMR->QueryInterface(IID_IVMRFilterConfigInternal, (void **) &pVMRConfigInternal);
        if( SUCCEEDED( hr )) {
            pVMRConfigInternal->SetAspectRatioModePrivate( VMR_ARMODE_LETTER_BOX );
            pVMRConfigInternal->Release();
        }

        // Create three in pins for VMR
        hr = CreateVMRInputPins() ;
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't ensure VMR's 3 in pins"))) ;
            SetVMRUse(FALSE) ;  // we shouldn't use VMR as it cannot go into mixing mode.
            // Should we return some error code to help the app indicate this to the user??
            hr = S_FALSE ;  // a little problem at least
        }
    }

    return hr ;
}


#define ATI_VENDOR_CODE                     0x1002

#define ATI_RAGE_PRO_DEVICE_CODE            0X4742
#define ATI_RAGE_MOBILITY_DEVICE_CODE       0x4C4D

#define INTEL_VENDOR_CODE                   0x8086
#define INTEL_810_DEVICE_CODE_1             0x1132
#define INTEL_810_DEVICE_CODE_2             0x7121
#define INTEL_810_DEVICE_CODE_3             0x7123
#define INTEL_810_DEVICE_CODE_4             0x7125


const GUID  OUR_IID_IDirectDraw7 =
{
    0x15e65ec0, 0x3b9c, 0x11d2,
    {
        0xb9, 0x2f, 0x00, 0x60, 0x97, 0x97, 0xea, 0x5b
    }
};

HRESULT CheckVGADriverIsVMRFriendly(
    IBaseFilter* pVMR
    )
{
    IVMRMonitorConfig* pMon;
    if (S_OK != pVMR->QueryInterface(IID_IVMRMonitorConfig, (LPVOID*)&pMon)) {
        return E_FAIL;
    }

    const DWORD dwMAX_MONITORS = 8;
    VMRMONITORINFO mi[dwMAX_MONITORS];
    DWORD dwNumMonitors;


    //
    // Get information about all the monitors in the system.
    //

    if (S_OK != pMon->GetAvailableMonitors(mi, dwMAX_MONITORS, &dwNumMonitors)) {
        pMon->Release();
        return E_FAIL;
    }


    //
    // Get the current monitors GUID.
    //

    VMRGUID gu;
    HRESULT hr = pMon->GetMonitor(&gu);
    pMon->Release();
    if (S_OK != hr) {
        return E_FAIL;
    }


    //
    // Search for the current monitor in the array of available monitors
    //

    VMRMONITORINFO* pmi = &mi[0];
    for (DWORD i = 0; i < dwNumMonitors; i++, pmi++) {

        if (gu.pGUID == NULL && pmi->guid.pGUID == NULL) {
            break;
        }

        if (gu.pGUID != NULL && pmi->guid.pGUID != NULL) {
            if (gu.GUID == pmi->guid.GUID) {
                break;
            }
        }
    }


    //
    // Make sure we found a monitor - we should always find a monitor!
    //

    if (i == dwNumMonitors) {

        return E_FAIL;
    }


    //
    // ATi chip sets that don't work with the VMR for DVD playback.
    //
    if (pmi->dwVendorId == ATI_VENDOR_CODE)
    {
        switch(pmi->dwDeviceId) {
        case ATI_RAGE_PRO_DEVICE_CODE:
            return E_FAIL;

        case ATI_RAGE_MOBILITY_DEVICE_CODE:
            {
                IVMRMixerControl* lpMixControl = NULL;
                hr = pVMR->QueryInterface(IID_IVMRMixerControl, (LPVOID*)&lpMixControl);
                if (SUCCEEDED(hr)) {
                    DWORD dw;
                    hr = lpMixControl->GetMixingPrefs(&dw);
                    if (SUCCEEDED(hr)) {
                        dw &= ~ MixerPref_FilteringMask;
                        dw |= MixerPref_PointFiltering;
                        hr = lpMixControl->SetMixingPrefs(dw);
                    }
                    lpMixControl->Release();
                }

            }
            break;
        }
    }


    //
    // Intel chip sets that don't work well with the VMR for DVD playback.
    // These chipsets do work but the VMR needs to be configured correctly
    // to get the best perf form the chipset.
    //

    else if (pmi->dwVendorId == INTEL_VENDOR_CODE)
    {
        switch(pmi->dwDeviceId) {
        case INTEL_810_DEVICE_CODE_1:
        case INTEL_810_DEVICE_CODE_2:
        case INTEL_810_DEVICE_CODE_3:
        case INTEL_810_DEVICE_CODE_4:
            {
                //
                // We should check the processor speed before
                // using the VMR - we need at least 500MHz for
                // good quality playback.
                //

                IVMRMixerControl* lpMixControl = NULL;
                hr = pVMR->QueryInterface(IID_IVMRMixerControl, (LPVOID*)&lpMixControl);
                if (SUCCEEDED(hr)) {
                    DWORD dw;
                    hr = lpMixControl->GetMixingPrefs(&dw);
                    if (SUCCEEDED(hr)) {
                        dw &= ~ MixerPref_RenderTargetMask;
                        dw |= MixerPref_RenderTargetIntelIMC3;
                        hr = lpMixControl->SetMixingPrefs(dw);
                    }
                    lpMixControl->Release();
                }
            }
            break;
        }
    }

    return S_OK;
}

//
// Make sure VMR has at least 3 in pins.
//
HRESULT CDvdGraphBuilder::CreateVMRInputPins(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateVMRInputPins()"))) ;

    if (NULL == m_pVMR)
        return E_UNEXPECTED ;

    // Create three (3) in pins for the VMR so that it can accommodate video,
    // SP and CC streams coming in. By default VMR has only one in pin.
    HRESULT  hr ;
    IVMRFilterConfig  *pVMRConfig ;
    hr = m_pVMR->QueryInterface(IID_IVMRFilterConfig, (LPVOID *) &pVMRConfig) ;
    if (SUCCEEDED(hr))
    {
        DWORD  dwStreams = 0 ;
        pVMRConfig->GetNumberOfStreams(&dwStreams) ;
        if (dwStreams < 3)  // if not enough in pins...
        {
            hr = pVMRConfig->SetNumberOfStreams(3) ;
            if (FAILED(hr))
            {
                DbgLog((LOG_TRACE, 3, TEXT("Couldn't create 3 in pins for VMR"))) ;
                hr = E_FAIL ;  // This is possible now. We need to turn off VMR use...
            }
        }
        pVMRConfig->Release() ;

        if (SUCCEEDED(hr)) {
            hr = CheckVGADriverIsVMRFriendly(m_pVMR);
            if (FAILED(hr)) {
                 DbgLog((LOG_TRACE, 3, TEXT("This VGA driver is not compatible with the VMR"))) ;
                 hr = E_FAIL ;  // This is not possible now. We need to turn off VMR use...
            }
        }
    }
    else
    {
        ASSERT(pVMRConfig) ;
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't get IVMRFilterConfig from VMR!!!"))) ;
        hr = S_FALSE ;  // a little problem at least
    }

    return hr ;
}


//
// Create a fresh filter graph
//
HRESULT CDvdGraphBuilder::CreateGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateGraph()"))) ;

    return CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC,
        IID_IGraphBuilder, (LPVOID *)&m_pGB) ;
}


//
// Delete the existing filter graph's contents
//
HRESULT CDvdGraphBuilder::DeleteGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::DeleteGraph()"))) ;

    m_pGB->Release() ;
    m_pGB = NULL ;
    return NOERROR ;
}


//
// Clear all the existing filters from the graph
//
HRESULT CDvdGraphBuilder::ClearGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::ClearGraph()"))) ;

    // Just paranoia...
    if (NULL == m_pGB)
    {
        ASSERT(FALSE) ;  // so that we know
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: How are we Clearing w/o a graph???"))) ;
        return E_FAIL ;
    }

    // If by any chance, the filter mapper object remained, delete it now
    if (m_pMapper)
    {
        m_pMapper->Release() ;
        m_pMapper = NULL ;
    }

#pragma message("WARNING: Should we remove the decoder filters first?")
    // Remove all filters in our list from the graph
    // m_ListFilters.RemoveAllFromGraph() ;

    HRESULT     hr ;
    IEnumPins  *pEnumPins ;
    IPin       *pPin ;
    IPin       *pPin2 ;
    ULONG       ul ;

    //
    // Remove the filters we know about specifically
    //

    // We don't want to remove OvMixer -- it may have external DDraw params set.
    // Just break the connections.
    if (m_pOvM)
    {
        hr = m_pOvM->EnumPins(&pEnumPins) ;
        ASSERT(SUCCEEDED(hr) && pEnumPins) ;
        while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
        {
            hr = pPin->ConnectedTo(&pPin2) ;
            if (SUCCEEDED(hr) && pPin2)
            {
                hr = m_pGB->Disconnect(pPin) ;
                ASSERT(SUCCEEDED(hr)) ;
                hr = m_pGB->Disconnect(pPin2) ;
                ASSERT(SUCCEEDED(hr)) ;
                pPin2->Release() ;
            }
            pPin->Release() ;  // done with this pin
        }
        pEnumPins->Release() ;
    }

    if (m_pDVDNav)
    {
        EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pDVDNav))) ;
        m_pDVDNav->Release() ;
        m_pDVDNav = NULL ;
    }

    // We don't want to remove VMR (only), because it might have been instantiated
    // for an app when it QI-ed for a VMR interface -- just like OvMixer case.
    if (m_pVMR)
    {
        hr = m_pVMR->EnumPins(&pEnumPins) ;
        ASSERT(SUCCEEDED(hr) && pEnumPins) ;
        while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
        {
            hr = pPin->ConnectedTo(&pPin2) ;
            if (SUCCEEDED(hr) && pPin2)
            {
                hr = m_pGB->Disconnect(pPin) ;
                ASSERT(SUCCEEDED(hr)) ;
                hr = m_pGB->Disconnect(pPin2) ;
                ASSERT(SUCCEEDED(hr)) ;
                pPin2->Release() ;
            }
            pPin->Release() ;  // done with this pin
        }
        pEnumPins->Release() ;
    }
    if (m_pVPM)
    {
        EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pVPM))) ;
        m_pVPM->Release() ;
        m_pVPM = NULL ;
    }
    if (m_pL21Dec)
    {
        EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pL21Dec))) ;
        m_pL21Dec->Release() ;
        m_pL21Dec = NULL ;
    }
    if (m_pAR)
    {
        EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pAR))) ;
        m_pAR->Release() ;
        m_pAR = NULL ;
    }
    if (m_pVR)
    {
        EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pVR))) ;
        m_pVR->Release() ;
        m_pVR = NULL ;
    }

    // Remove all filters in our list from the graph
    m_ListFilters.RemoveAllFromGraph() ;

    // Enumerate any remaining filters and remove them -- make sure to skip OvMixer
    IEnumFilters  *pEnumFilters ;
    // ULONG          ul ; -- defined at the top
    IBaseFilter   *pFilter ;
    m_pGB->EnumFilters(&pEnumFilters) ;
    ASSERT(pEnumFilters) ;
    while (S_OK == pEnumFilters->Next(1, &pFilter, &ul)  &&  1 == ul)
    {
        if (m_pOvM  &&  IsEqualObject(m_pOvM, pFilter)  ||
            m_pVMR  &&  IsEqualObject(m_pVMR, pFilter))
        {
            DbgLog((LOG_TRACE, 3,
                TEXT("Got OverlayMixer/VMR through filter enum. Not removing from graph."))) ;
        }
        else
        {
            EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(pFilter))) ;
        }
        pFilter->Release() ;   // done with this filter
    }
    pEnumFilters->Release() ;  // done enum-ing

    m_bGraphDone = FALSE ;  // reset the "graph already built" flag

    return NOERROR ;
}



void CDvdGraphBuilder::StopGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::StopGraph()"))) ;

    // Just paranoia
    if (NULL == m_pGB)
    {
        ASSERT(FALSE) ;  // so that we know
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: How are we doing a Stop w/o a graph???"))) ;
        return ;
    }

    //
    // Check that the graph has stopped; otherwise stop it here. Because a
    // playing graph can't be cleaned up or rebuilt.
    //
    IMediaControl  *pMC ;
    LONG            lState ;
    HRESULT hr = m_pGB->QueryInterface(IID_IMediaControl, (LPVOID *)&pMC) ;
    ASSERT(SUCCEEDED(hr) && pMC) ;
    pMC->GetState(INFINITE, &lState) ;
    if (State_Stopped != lState)
    {
        hr = pMC->Stop() ;
        ASSERT(SUCCEEDED(hr)) ;
        while (State_Stopped != lState)
        {
            Sleep(10) ;
            hr = pMC->GetState(INFINITE, &lState) ;
            ASSERT(SUCCEEDED(hr)) ;
        }
    }
    pMC->Release() ;
    DbgLog((LOG_TRACE, 4, TEXT("DVD-Video playback graph has stopped"))) ;
}


// 5 output pins of decoder of matching type is enough
#define MAX_DEC_OUT_PINS   5

void CDvdGraphBuilder::ResetPinInterface(IPin **apPin, int iCount)
{
    for (int i = 0 ; i < iCount ; i++)
        apPin[i] = NULL ;
}


void CDvdGraphBuilder::ReleasePinInterface(IPin **apPin)
{
    // Done with decoded video pin(s) -- release it/them
    int  i = 0 ;
    while (apPin[i])
    {
        apPin[i]->Release() ;
        i++ ;
    }
}


HRESULT CDvdGraphBuilder::RenderNavVideoOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderNavVideoOutPin(0x%lx, 0x%lx)"),
        dwDecFlag, pStatus)) ;

    HRESULT     hr ;
    IPin       *pPin ;
    IPin       *apPinOutDec[MAX_DEC_OUT_PINS + 1] ;  // 1 for terminating NULL

    ResetPinInterface(apPinOutDec, NUMELMS(apPinOutDec)) ;

    hr = FindMatchingPin(m_pDVDNav, AM_DVD_STREAM_VIDEO, PINDIR_OUTPUT, TRUE, 0, &pPin) ;
    if (FAILED(hr)  ||  NULL == pPin)
    {
        DbgLog((LOG_ERROR, 1, TEXT("No open video output pin found on the DVDNav"))) ;
        return VFW_E_DVD_RENDERFAIL ;
    }
    // The dwDecFlag out param is largely ignored, except being passed as an in
    // param to the method RenderDecodedVideo() to indicate if the video is
    // decoded in HW, so that VPM is used before VMR.
    hr = DecodeDVDStream(pPin, AM_DVD_STREAM_VIDEO, &dwDecFlag, pStatus, apPinOutDec) ;
    pPin->Release() ;  // release DVDNav's video out pin

    if (FAILED(hr))   // couldn't find video decoder
    {
        DbgLog((LOG_TRACE, 1, TEXT("Could not find a decoder for video stream!!!"))) ;
        // For video stream, any decode/rendering problem has to be flagged here
        // as we just downgrade the final result in the caller, but not set any
        // flag there.
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return S_FALSE ;  // just a stream will not be rendered
    }

    //
    // Decoding the video stream succeeded. Now if we got a decoded output pin,
    // we need to render that too.
    //
    HRESULT   hrFinal = S_OK ;
    if (apPinOutDec[0])  // if video decoding is handled and we got a valid output pin
    {
        //
        // Render the decoded video stream (and line21) ONLY IF the user wants that
        //
        if (m_bUseVPE)
        {
            hr = RenderDecodedVideo(apPinOutDec, pStatus, dwDecFlag) ;
            //
            // If the above rendering attempt is successful then we'll
            // try to render the line21 output.  If the the video decoder
            // doesn't have a video output pin, then there is very little
            // chance, well no chance, of having a line21 output.
            //
            if (SUCCEEDED(hr))
            {
                //
                // The Line21 data comes out of the video decoder filter.
                // So get the filter from the above decoded video output
                // pin and then get to the line21 output pin.
                //

                //
                // We render the line21 out pin of the video decoder
                // ONLY IF we are NOT in DDraw exclusive mode.
                //
                if (IsDDrawExclMode())
                {
                    DbgLog((LOG_TRACE, 3, TEXT("*** Line21 out pin is not rendered in DDraw excl mode"))) ;
                    pStatus->bNoLine21In  = FALSE ;  // no problem with line21
                    pStatus->bNoLine21Out = FALSE ;  // ... ... ... ... ...
                }
                else   // normal mode
                {
                    // Now we are free to render the line21 out pin...
                    IPin *pPinL21Out ;
                    PIN_INFO  pi ;
                    hr = apPinOutDec[0]->QueryPinInfo(&pi) ;  // the first out pin is fine
                    ASSERT(SUCCEEDED(hr) && pi.pFilter) ;
                    hr = FindMatchingPin(pi.pFilter, AM_DVD_STREAM_LINE21,
                        PINDIR_OUTPUT, TRUE, 0, &pPinL21Out) ;
                    if (SUCCEEDED(hr) && pPinL21Out)
                    {
                        pStatus->bNoLine21In = FALSE ;  // there is line21 output pin
                        hr = RenderLine21Stream(pPinL21Out, pStatus) ;
                        if (SUCCEEDED(hr))
                            pStatus->bNoLine21Out = FALSE ;  // line21 rendering is OK
                        else
                        {
                            pStatus->bNoLine21Out = TRUE ;   // line21 rendering failed
                            hrFinal = S_FALSE ;  // not complete success
                        }
                        pPinL21Out->Release() ;  // done with line21 pin -- release it now
                    }
                    else  // video decoder doesn't have line21 output at all
                    {
                        DbgLog((LOG_TRACE, 3, TEXT("No line21 output pin on the video decoder."))) ;
                        pStatus->bNoLine21In = TRUE ;    // no line21 data from video decoder
                        hrFinal = S_FALSE ;              // not complete success
                    }
                    pi.pFilter->Release() ;  // otherwise we'll leak it
                }
            }  // end of if (SUCCEEDED(hr))
            else
            {
                DbgLog((LOG_TRACE, 3, TEXT("Rendering video stream failed (Error 0x%lx)"), hr)) ;
                hrFinal = S_FALSE ;     // major problem -- video stream failed to render
            }
        }  // end of if (m_bUseVPE)
        else
        {
            DbgLog((LOG_TRACE, 3, TEXT("Video Stream: RenderDvdVideoVolume() was called with no VPE flag"))) ;
        }

        ReleasePinInterface(apPinOutDec) ;  // done with decoded video pin(s) -- release it
    }

    return hrFinal ;
}


HRESULT CDvdGraphBuilder::RenderNavAudioOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderNavAudioOutPin(0x%lx, 0x%lx)"),
        dwDecFlag, pStatus)) ;

    HRESULT     hr ;
    IPin       *pPin ;
    IPin       *apPinOutDec[MAX_DEC_OUT_PINS + 1] ;  // 1 for terminating NULL

    ResetPinInterface(apPinOutDec, NUMELMS(apPinOutDec)) ;

    hr = FindMatchingPin(m_pDVDNav, AM_DVD_STREAM_AUDIO, PINDIR_OUTPUT, TRUE, 0, &pPin) ;
    if (FAILED(hr)  ||  NULL == pPin)
    {
        DbgLog((LOG_ERROR, 1, TEXT("No audio output pin found on the DVDNav"))) ;
        return VFW_E_DVD_RENDERFAIL ;
    }
    hr = DecodeDVDStream(pPin, AM_DVD_STREAM_AUDIO, &dwDecFlag, // we ignore returned dwDecFlag here
        pStatus, apPinOutDec) ;
    pPin->Release() ;  // release DVDNav's audio out pin

    if (FAILED(hr))   // couldn't find audio decoder
    {
        DbgLog((LOG_TRACE, 1, TEXT("Could not find a decoder for audio stream!!!"))) ;
        return S_FALSE ;  // just a stream will not be rendered
    }

    //
    // Decoding the audio stream succeeded. Now if we got a decoded output pin,
    // we need to render that too.
    //
    if (apPinOutDec[0])  // if audio decoding is handled and we got a valid output pin
    {
        hr = RenderDecodedAudio(apPinOutDec, pStatus) ;
        if (S_OK != hr)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Could not render decoded audio stream"))) ;
            hr = S_FALSE ;  // partial failure to be returned
        }
        ReleasePinInterface(apPinOutDec) ;  // done with decoded audio pin -- release it
    }

    return hr ;
}


HRESULT CDvdGraphBuilder::RenderNavSubpicOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderNavSubpicOutPin(0x%lx, 0x%lx)"),
        dwDecFlag, pStatus)) ;

    HRESULT     hr ;
    IPin       *pPin ;
    IPin       *apPinOutDec[MAX_DEC_OUT_PINS + 1] ;  // 1 for terminating NULL

    ResetPinInterface(apPinOutDec, NUMELMS(apPinOutDec)) ;

    hr = FindMatchingPin(m_pDVDNav, AM_DVD_STREAM_SUBPIC, PINDIR_OUTPUT, TRUE, 0, &pPin) ;
    if (FAILED(hr)  ||  NULL == pPin)
    {
        DbgLog((LOG_ERROR, 1, TEXT("No subpicture output pin found on the DVDNav"))) ;
        return VFW_E_DVD_RENDERFAIL ;
    }
    // Pass dwDecFlag as a in/out param to get back what kind of SP decoder was
    // actually used.  We'll use that to hack below.
    hr = DecodeDVDStream(pPin, AM_DVD_STREAM_SUBPIC, &dwDecFlag,
        pStatus, apPinOutDec) ;
    pPin->Release() ;  // release DVDNav's subpic out pin

    if (FAILED(hr))   // couldn't find SP decoder
    {
        DbgLog((LOG_TRACE, 1, TEXT("Could not find a decoder for SP stream!!!"))) ;
        return S_FALSE ;  // just a stream will not be rendered
    }

    //
    // Decoding the SP stream succeeded. Now if we got a decoded output pin,
    // we need to render that too.
    //
    if (apPinOutDec[0])  // there is a decoded SP out pin
    {
        hr = RenderDecodedSubpic(apPinOutDec, pStatus) ;

        //
        // HACK HACK HACK:
        // In general HW decoders mix the SP and video in HW rather than popping a
        // SP output pin. We may land up getting a (seemingly) video out pin, which
        // for SW decoders may mean a decoded SP output pin, but for HW decoders it's
        // certainly some other thing (c-cube DVXplorer) and it will not connect to
        // OvMixer/VPM+VMR.
        // We don't avoid trying to connect such a pin to OvMixer/VPM+VMR (done above),
        // but in case it fails (as it is expected to), we just ignore the error and do
        // NOT consider it as a SP stream rendering failure.
        //
        if (AM_DVD_HWDEC_ONLY == dwDecFlag)  // here means HW decoder was used for SP
        {
            DbgLog((LOG_TRACE, 3,
                TEXT("SP stream is decoded in HW. We ignore any error in rendering (0x%lx)"),
                hr)) ;
            hr = S_OK ;
        }
        else  // for SW decoder
        {
            if (FAILED(hr))  // connection to renderer's in pin failed => no SP
            {
                DbgLog((LOG_TRACE, 3, TEXT("Decoded SP out pin could NOT connect to renderer"))) ;
                // propagate only S_FALSE to the caller
                hr = S_FALSE ;  // because just a stream is not rendered right
            }
        }

        ReleasePinInterface(apPinOutDec) ;  // done with decoded SP pin -- release it
    }

    return hr ;
}


//
// *** NOT YET IMPLEMENTED ***
//
HRESULT CDvdGraphBuilder::RenderNavASFOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderNavASFOutPin(0x%lx, 0x%lx) -- ** Not Implemented **"),
        dwDecFlag, pStatus)) ;

    return S_OK ;
}


//
// *** NOT YET IMPLEMENTED ***
//
HRESULT CDvdGraphBuilder::RenderNavOtherOutPin(DWORD dwDecFlag, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderNavOtherOutPin(0x%lx, 0x%lx) -- ** Not Implemented **"),
        dwDecFlag, pStatus)) ;

    return S_OK ;
}


HRESULT CDvdGraphBuilder::RenderRemainingPins(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderRemainingPins() -- ** Not Implemented **"))) ;

    ASSERT(FALSE) ;   // so that we know about it

    return S_FALSE ;  // so that graph building doesn't fail completely
}


HRESULT CDvdGraphBuilder::DecodeDVDStream(IPin *pPinOut, DWORD dwStream, DWORD *pdwDecFlag,
                                          AM_DVD_RENDERSTATUS *pStatus, IPin **apPinOutDec)
{
    DbgLog((LOG_TRACE, 4,
        TEXT("CDvdGraphBuilder::DecodeDVDStream(%s, 0x%lx, 0x%lx, 0x%lx, 0x%lx)"),
        (LPCTSTR)CDisp(pPinOut), dwStream, *pdwDecFlag, pStatus, apPinOutDec)) ;

    HRESULT    hr ;
    IPin      *pPinIn ;  // the (end) pin we finally connected to
    DWORD      dwNewDecFlag = *pdwDecFlag ;  // let's start with what we have

    // ResetPinInterface(apPinOutDec, NUMELMS(apPinOutDec)) ;

    //
    // We'll note what decoder option we actually use, but will not update the
    // value at the passed in pointer until we have checked that the stream has
    // really been decoded completely.  So the new flag is assigned way below
    // when we verify that the output stream gives decoded output.
    //
    // Also H/SWDecodeDVDStream() methods will try to detect if the video/SP
    // decoder is VMR-compatible, and if not, set a flag (m_bTryVMR to FALSE),
    // so that RenderDecodedVideo() method can determine which renderer to use.
    //
    switch (*pdwDecFlag)  // based on the user-specified decoding option
    {
    case AM_DVD_HWDEC_ONLY:
        hr = HWDecodeDVDStream(pPinOut, dwStream, &pPinIn, pStatus) ;
        if (FAILED(hr))
            return hr ;
        // *pdwDecFlag = AM_DVD_HWDEC_ONLY ; -- unchanged
        break ;

    case AM_DVD_HWDEC_PREFER:
        hr = HWDecodeDVDStream(pPinOut, dwStream, &pPinIn, pStatus) ;
        if (FAILED(hr))  // if didn't succeed, try SW decode too
        {
            hr = SWDecodeDVDStream(pPinOut, dwStream, &pPinIn, pStatus) ;
            if (FAILED(hr))  // now we give up
                return hr ;
            else
                dwNewDecFlag = AM_DVD_SWDEC_ONLY ;  // we preferred HW, but did it in SW
        }
        else
            dwNewDecFlag = AM_DVD_HWDEC_ONLY ;  // we preferred HW and got HW

        break ;

    case AM_DVD_SWDEC_ONLY:
        hr = SWDecodeDVDStream(pPinOut, dwStream, &pPinIn, pStatus) ;
        if (FAILED(hr))
            return hr ;
        break ;

    case AM_DVD_SWDEC_PREFER:
        hr = SWDecodeDVDStream(pPinOut, dwStream, &pPinIn, pStatus) ;
        if (FAILED(hr))  // if didn't succeed, try SW decode too
        {
            hr = HWDecodeDVDStream(pPinOut, dwStream, &pPinIn, pStatus) ;
            if (FAILED(hr))  // now we give up
                return hr ;
            else
                dwNewDecFlag = AM_DVD_HWDEC_ONLY ;  // we preferred SW, but got HW
        }
        else
            dwNewDecFlag = AM_DVD_SWDEC_ONLY ;  // we preferred SW and got SW
        break ;

    default:
        DbgLog((LOG_ERROR, 1, TEXT("ERROR: How did dwFlags=0x%lx get passed in?"), *pdwDecFlag)) ;
        return E_INVALIDARG ;
    }  // end of switch(*pdwDecFlag)

    //
    // Now see if the stream has been completely decoded
    //
    ASSERT(pPinIn) ;  // so that otherwise we know
    if (NULL == pPinIn)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ERROR: How can the connected to pin be NULL after connection?"))) ;
        return E_FAIL ;
    }

    IPin  *pPinOut2 ;
    PIN_INFO  pi ;
    pPinIn->QueryPinInfo(&pi) ;
    pPinIn->Release() ;  // don't need the in pin anymore

    DWORD  dw ;			 // temp variable for stream type
    int    iPos = 0 ;    // which instance of pin of the filter
    int    iCount = 0 ;  // how many decoded output pins have we found (expected only 1)
    while (SUCCEEDED(hr = FindMatchingPin(pi.pFilter, 0, PINDIR_OUTPUT, TRUE, iPos, &pPinOut2)) &&
        NULL != pPinOut2)
    {
        if (dwStream != (dw = GetPinStreamType(pPinOut2)))
        {
            //
            // Hack: The mediatype for decoded subpicture is video. So while rendering
            // the subpicture stream, if we don't find a subpicture out pin, look for a
            // video out pin too.
            //
            if (AM_DVD_STREAM_SUBPIC == dwStream)
            {
                DbgLog((LOG_TRACE, 3, TEXT("No open out pin for SP stream"))) ;
                //
                // If the output pin is of type video then it's OK --
                // it's the out pin for decoded SP content.
                //
                if (AM_DVD_STREAM_VIDEO != dw)
                {
                    DbgLog((LOG_TRACE, 3,
                        TEXT("*** Could NOT find open out pin #%d of type 0x%lx for filter of pin %s (SP) ***"),
                        iPos, dw, (LPCTSTR)CDisp(pPinIn))) ;
                    pPinOut2->Release() ;  // otherwise we'll leak!!!
                    iPos++ ;
                    continue ;  // check for other out pins
                }
                DbgLog((LOG_TRACE, 3, TEXT("Found open video out pin %s for the SP stream"),
                    (LPCTSTR)CDisp(pPinOut2))) ;
            }  // end of if (subpic)
            else  // non-subpicture stream
            {
                DbgLog((LOG_TRACE, 1,
                    TEXT("*** Could NOT find open out pin #%d of type 0x%lx for filter of pin %s ***"),
                    iPos, dw, (LPCTSTR)CDisp(pPinIn))) ;
                pPinOut2->Release() ;  // otherwise we'll leak!!!
                iPos++ ;
                continue ;  // check for other out pins
            }
        }
        else
            DbgLog((LOG_TRACE, 3, TEXT("Found open out pin %s of matching type 0x%lx"),
            (LPCTSTR)CDisp(pPinOut2), dwStream)) ;

        // Is the output decoded now?
        if (IsOutputDecoded(pPinOut2))
        {
            DbgLog((LOG_TRACE, 1,
                TEXT("Pin %s is going to be returned as decoded out pin #%ld of stream type %ld"),
                (LPCTSTR)CDisp(pPinOut2), iCount+1, dwStream)) ;
            if (iCount < MAX_DEC_OUT_PINS)
            {
                apPinOutDec[iCount] = pPinOut2 ;
                iCount++ ;

                //
                // This is the right place to update the actually used decoder flag
                //
                // NOTE: There is this bleak chance of having multiple output pins etc.
                // but that's a pathological case and we do this for the SP stream only.
                //
                if (*pdwDecFlag != dwNewDecFlag)
                {
                    DbgLog((LOG_TRACE, 2,
                        TEXT("Decoding option changed from 0x%lx to 0x%lx for stream 0x%lx on out pin %s"),
                        *pdwDecFlag, dwNewDecFlag, dwStream, (LPCTSTR)CDisp(pPinOut2))) ;
                    *pdwDecFlag = dwNewDecFlag ;
                }
            }
            else
            {
                DbgLog((LOG_TRACE, 1, TEXT("WARNING: Way too many out pins to be returned. Ignoring now..."))) ;
            }
        }
        else  // not yet fully decoded -- try more
        {
            hr = DecodeDVDStream(pPinOut2, dwStream, pdwDecFlag, pStatus, apPinOutDec) ;
            if (FAILED(hr))
            {
                DbgLog((LOG_TRACE, 3, TEXT("Decoding of pin %s failed (Error 0x%lx)"),
                    (LPCTSTR)CDisp(pPinOut2), hr)) ;
                pPinOut2->Release() ;
                pi.pFilter->Release() ;  // else we leak!!!
                return hr ;
            }
            pPinOut2->Release() ;  // done with this pin
        }

        iPos++ ;  // look for the next open out pin
        DbgLog((LOG_TRACE, 5, TEXT("Going to look for open out pin #%d..."), iPos)) ;
    }  // end of while (FindMatchingPin()) loop

    pi.pFilter->Release() ;  // else we leak!!!

    return S_OK ;  // success!!!
}


//
// There is an assumption in this function that we don't need to create multiple
// instances of a WDM filter to get a suitable input pin on it.  If we have to
// ever do that there has to be substantial changes in this function and/or
// CreateDVDHWDecoders() function.
//
HRESULT CDvdGraphBuilder::HWDecodeDVDStream(IPin *pPinOut, DWORD dwStream, IPin **ppPinIn,
                                            AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4,
        TEXT("CDvdGraphBuilder::HWDecodeDVDStream(%s, 0x%lx, 0x%lx, 0x%lx)"),
        (LPCTSTR)CDisp(pPinOut), dwStream, ppPinIn, pStatus)) ;

    *ppPinIn = NULL ;  // to start with

    int  iCount = m_ListHWDecs.GetCount() ;
    if (0 == iCount)
        return VFW_E_DVD_DECNOTENOUGH ;

    HRESULT   hr ;
    BOOL      bConnected = FALSE ;  // to start with

    int          i ;
    int          j ;
    BOOL		 bNewlyAdded ;
    LPWSTR       lpszwName ;
    IBaseFilter *pFilter ;
    IPin        *pPinIn ;
    for (i = 0 ; !bConnected  &&  i < iCount ; i++)
    {
        // Get the next HW decoder filter
        if (! m_ListHWDecs.GetFilter(i, &pFilter, &lpszwName) )
        {
            DbgLog((LOG_ERROR, 0, TEXT("ERROR: m_ListHWDecs.GetFilter(%d, ...) failed"), i)) ;
            ASSERT(FALSE) ;  // so we don't ignore itd
            break ;
        }
        DbgLog((LOG_TRACE, 3, TEXT("HW Dec filter %S will be tried."), lpszwName)) ;

        // If this HW decoder filter is already not in the graph, add it
        if (! m_ListFilters.IsInList(pFilter) )
        {
            DbgLog((LOG_TRACE, 5, TEXT("Filter %S is NOT already in use"), lpszwName)) ;
            hr = m_pGB->AddFilter(pFilter, lpszwName) ;
            ASSERT(SUCCEEDED(hr)) ;
            bNewlyAdded = TRUE ;
        }
        else
            bNewlyAdded = FALSE ;

        // Try every input pin of the required mediatype
        j = 0 ;
        while ( //  !bConnected  &&  -- we 'break' out of this loop on connection
            SUCCEEDED(hr = FindMatchingPin(pFilter, dwStream, PINDIR_INPUT,
            TRUE, j, &pPinIn))  &&
            pPinIn)
        {
            // We got an input pin of the required mediatype
            hr = ConnectPins(pPinOut, pPinIn, AM_DVD_CONNECT_DIRECTFIRST) ;
            if (SUCCEEDED(hr))
            {
                if (bNewlyAdded)
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Filter %S added to list of filters"), lpszwName)) ;
                    m_ListFilters.AddFilter(pFilter, lpszwName, NULL) ;  // add to list
                    pFilter->AddRef() ;  // we need an extra AddRef() here
                }
                EnumFiltersBetweenPins(dwStream, pPinOut, pPinIn, pStatus) ;
                *ppPinIn = pPinIn ;  // return this input pin to the caller
                bConnected = TRUE ;
                break ;   // connected -- get out of this loop
                // REMEMBER: release the returned pin in the caller
            }

            pPinIn->Release() ;  // done with this in pin
            j++ ;   // go for the next pin...
        }  // end of while (!bConnected && FindMatchingPin())

        // If we couldn't make any connection in the above while() loop then
        // remove the filter, ONLY IF it was added just before the loop.
        if (!bConnected && bNewlyAdded)
        {
            DbgLog((LOG_TRACE, 5,
                TEXT("Couldn't connect to newly added filter %S. Removing it."), lpszwName)) ;
            hr = m_pGB->RemoveFilter(pFilter) ;
            ASSERT(SUCCEEDED(hr)) ;
        }
    }  // end of for (i)

    if (! bConnected )
        return VFW_E_DVD_DECNOTENOUGH ;

    return S_OK ;  // success!!
}


HRESULT CDvdGraphBuilder::SWDecodeDVDStream(IPin *pPinOut, DWORD dwStream, IPin **ppPinIn,
                                            AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4,
        TEXT("CDvdGraphBuilder::SWDecodeDVDStream(%s, 0x%lx, 0x%lx, 0x%lx)"),
        (LPCTSTR)CDisp(pPinOut), dwStream, ppPinIn, pStatus)) ;

    HRESULT          hr ;
    IBaseFilter     *pFilter ;
    IEnumRegFilters *pEnumFilters ;
    REGFILTER       *pRegFilter ;
    IEnumMediaTypes *pEnumMT ;
    AM_MEDIA_TYPE   *pmt = NULL;
    IPin            *pPinIn ;
    BOOL             bConnected = FALSE ;  // to start with
    BOOL             bNewlyAdded ;
    ULONG            ul ;
    int              iPos ;
    int              j ;
    PIN_INFO         pi ;

    *ppPinIn = NULL ;  // to start with

    pPinOut->EnumMediaTypes(&pEnumMT) ;
    ASSERT(pEnumMT) ;

    // HACK (kind of) to avoid the Duck filter getting picked up for the SP decoding.
    // First try the existing filters in the graph to see if any of those will take
    // this output pin.
    hr = pPinOut->QueryPinInfo(&pi) ;
    ASSERT(SUCCEEDED(hr)) ;
    while (!bConnected  &&
        S_OK == pEnumMT->Next(1, &pmt, &ul)  &&  1 == ul)
    {
        if (pPinIn = GetFilterForMediaType(dwStream, pmt, pi.pFilter))
        {
            hr = ConnectPins(pPinOut, pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;  // .._DIRECTFIRST
            if (SUCCEEDED(hr))
            {
                bConnected = TRUE ;
                *ppPinIn = pPinIn ;  // return this input pin to the caller
            }
            else
                pPinIn->Release() ;  // release interface only if connection failed
        }
        DeleteMediaType(pmt) ;  // done with this mediatype
        pmt = NULL;
    }  // end of while() loop

    if (pi.pFilter)     // just being cautious
        pi.pFilter->Release() ;  // release now; else we leak.
    if (bConnected)     // if succeeded in connecting, we are done here
    {
        pEnumMT->Release() ;     // done with the MT enumerator
        return S_OK ;            // success!!!
    }

    //
    // This output pin does NOT connect to any of the existing filters in the graph.
    // Try to pick one from the regsitry, i.e., the standard process.
    //
    pEnumMT->Reset() ;   // start from the beginning again
    while (!bConnected  &&
        S_OK == pEnumMT->Next(1, &pmt, &ul)  &&  1 == ul)
    {
        hr = m_pMapper->EnumMatchingFilters(&pEnumFilters, MERIT_DO_NOT_USE+1,
            TRUE, pmt->majortype, pmt->subtype,
            FALSE, TRUE, GUID_NULL, GUID_NULL) ;
        if (FAILED(hr) || NULL == pEnumFilters)
        {
            DbgLog((LOG_ERROR, 1, TEXT("ERROR: No matching filter enum found (Error 0x%lx)"), hr)) ;
            DeleteMediaType(pmt) ;
            return VFW_E_DVD_RENDERFAIL ;
        }

        while (!bConnected  &&
            S_OK == pEnumFilters->Next(1, &pRegFilter, &ul)  &&  1 == ul)
        {
            bNewlyAdded = FALSE ;  // to start the loop with...
            iPos = 0 ;

            // Until connected and we can locate an existing (in use) filter from our list
            while (!bConnected  &&
                m_ListFilters.GetFilter(&pRegFilter->Clsid, iPos, &pFilter))  // already in use
            {
                j = 0 ;
                while (SUCCEEDED(hr = FindMatchingPin(pFilter, 0, PINDIR_INPUT, TRUE, j, &pPinIn)) &&
                    pPinIn)  // got an(other) open in pin
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Got in pin %s (%d) of filter %S (old). Try to connect..."),
                        (LPCTSTR)CDisp(pPinIn), j, pRegFilter->Name)) ;
                    hr = ConnectPins(pPinOut, pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;  // .._DIRECTFIRST
                    if (SUCCEEDED(hr))
                    {
                        if (bNewlyAdded)
                            m_ListFilters.AddFilter(pFilter, NULL, &(pRegFilter->Clsid)) ;
                        // Don't need AddRef() here as it has just been CoCreateInstance()-ed above
                        // and is NOT shared between 2 lists.
                        bConnected = TRUE ;
                        // pPinIn->Release() ;  // done with this pin -- release in the caller
                        *ppPinIn = pPinIn ;  // return this input pin to the caller
                        break ;  // connection happened -- out of this loop
                        // REMEMBER: Release the returned pin in the caller function
                    }
                    else       // couldn't connect
                    {
                        pPinIn->Release() ;  // done with this pin
                        j++ ;  // try next in pin of this filter
                    }
                }  // end of while ()
                iPos++ ;     // for next filter in list
            }

            if (bConnected)  // already succeeded -- we are done!!!
            {
                CoTaskMemFree(pRegFilter) ;
                break ;
            }

            DbgLog((LOG_TRACE, 5, TEXT("Instance %d of filter %S is being created"),
                iPos, pRegFilter->Name)) ;
            hr = CreateFilterInGraph(pRegFilter->Clsid, pRegFilter->Name, &pFilter) ;
            if (FAILED(hr))
            {
                DbgLog((LOG_TRACE, 3, TEXT("Failed to create filter %S (Error 0x%lx)"), pRegFilter->Name, hr)) ;
                CoTaskMemFree(pRegFilter) ;  // release this reg filter's info
                continue ;  // try the next one
            }
            bNewlyAdded = TRUE ;

            j = 0 ;
            while (!bConnected  &&    // not connected  AND ...
                SUCCEEDED(hr = FindMatchingPin(pFilter, 0, PINDIR_INPUT, TRUE, j, &pPinIn))  &&
                pPinIn)            // ...got an open in pin
            {
                DbgLog((LOG_TRACE, 5, TEXT("Got in pin %s (%d) of filter %S (new). Try to connect..."),
                    (LPCTSTR)CDisp(pPinIn), j, pRegFilter->Name)) ;
                hr = ConnectPins(pPinOut, pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;  // .._DIRECTFIRST
                if (SUCCEEDED(hr))
                {
                    if (bNewlyAdded)
                        m_ListFilters.AddFilter(pFilter, NULL, &(pRegFilter->Clsid)) ;
                    // Don't need AddRef() here as it has just been CoCreateInstance()-ed above
                    // and is NOT shared between 2 lists.
                    bConnected = TRUE ;
                    *ppPinIn = pPinIn ;  // return this input pin to the caller
                    // REMEMBER: release the returned pin in the caller function
                }
                else  // couldn't connect
                {
                    pPinIn->Release() ;  // done with this pin
                    j++ ;  // try next in pin of this filter
                }

                // pPinIn->Release() ;  // done with this pin
            }  // end of while (FindMatchingPin())

            if (bConnected)  // Nav -> Filter (this) succeeded
            {
                // Video and SP stream: check for VMR compatibility
                if (AM_DVD_STREAM_VIDEO  == dwStream ||
                    AM_DVD_STREAM_SUBPIC == dwStream)
                {
                    // Filter, hopefully decoder, has been connected to the Nav.
                    // Now check if it's VMR ompatible.
                    BOOL  bUseVMR = IsFilterVMRCompatible(pFilter) ;
                    SetVMRUse(GetVMRUse() && bUseVMR) ;
                    DbgLog((LOG_TRACE, 3, TEXT("Filter %S is %s VMR compatible"),
                        pRegFilter->Name, bUseVMR ? TEXT("") : TEXT("*NOT*"))) ;
                }
            }
            else  // connection failed
            {
                // If the failed filter was just added then remove it from
                // graph and release it now.
                if (bNewlyAdded)
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Couldn't connect to filter %S. Removing it."),
                        pRegFilter->Name)) ;
                    m_pGB->RemoveFilter(pFilter) ;  // not in this graph
                    pFilter->Release() ;  // don't need this filter
                }
            }

            CoTaskMemFree(pRegFilter) ;  // done with this registered filter

        }  // end of while (!bConnected && pEnumFilters->Next())

        pEnumFilters->Release() ;  // done with filter enumerator
        // release last media type
        DeleteMediaType(pmt) ;
        pmt = NULL;
    }  // end of while (enum MTs)
    pEnumMT->Release() ;  // done with the MT enumerator

    if (!bConnected)
        return VFW_E_DVD_DECNOTENOUGH ;

    return S_OK ;  // success!!
}


BOOL CDvdGraphBuilder::IsFilterVMRCompatible(IBaseFilter *pFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::IsFilterVMRCompatible(0x%lx)"), pFilter)) ;

    BOOL  bResult = FALSE ;  // assume old decoder

    //
    // Updated DVD decoders implement IAMDecoderCaps interface to indicate their
    // VMR compatibility.
    //
    IAMDecoderCaps  *pDecCaps ;
    HRESULT  hr = pFilter->QueryInterface(IID_IAMDecoderCaps, (LPVOID *) &pDecCaps) ;
    if (SUCCEEDED(hr))
    {
        DWORD  dwCaps = 0 ;
        hr = pDecCaps->GetDecoderCaps(AM_GETDECODERCAP_QUERY_VMR_SUPPORT, &dwCaps) ;
        if (SUCCEEDED(hr))
        {
            bResult = (dwCaps & VMR_SUPPORTED) != 0 ;
        }
        else
            DbgLog((LOG_TRACE, 1, TEXT("IAMDecoderCaps::GetDecoderCaps() failed (error 0x%lx)"), hr)) ;

        pDecCaps->Release() ;  // done with it
    }
    else
        DbgLog((LOG_TRACE, 5, TEXT("(Old) Decoder does NOT support IAMDecoderCaps interface"))) ;


    return bResult ;
}


#if 0
void PrintPinRefCount(LPCSTR lpszStr, IPin *pPin)
{
#pragma message("WARNING: Should we remove PrintPinRefCount()?")
#pragma message("WARNING: or at least #ifdef DEBUG?")
    pPin->AddRef() ;
    LONG l = pPin->Release() ;
    DbgLog((LOG_TRACE, 5, TEXT("Ref Count of %s -- %hs: %ld"),
        (LPCTSTR) CDisp(pPin), lpszStr, l)) ;
}
#endif // #if 0


HRESULT CDvdGraphBuilder::ConnectPins(IPin *pPinOut, IPin *pPinIn, DWORD dwOption)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::ConnectPins(%s, %s, 0x%lx)"),
        (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn), dwOption)) ;

    // #pragma message("WARNING: Should we remove calls to PrintPinRefCount()?")
    //     PrintPinRefCount("Before connection", pPinOut) ;
    //     PrintPinRefCount("Before connection", pPinIn) ;

    HRESULT   hr ;

    switch (dwOption)
    {
    case AM_DVD_CONNECT_DIRECTONLY:
    case AM_DVD_CONNECT_DIRECTFIRST:
        hr = m_pGB->ConnectDirect(pPinOut, pPinIn, NULL) ;
        if (SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE, 3, TEXT("Pin %s *directly* connected to pin %s"),
                (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
            //             PrintPinRefCount("After connection", pPinOut) ;
            //             PrintPinRefCount("After connection", pPinIn) ;
            return hr ;
        }
        else  // couldn't connect directly
        {
            if (AM_DVD_CONNECT_DIRECTONLY == dwOption)
            {
                //                 PrintPinRefCount("After connection failed", pPinOut) ;
                //                 PrintPinRefCount("After connection failed", pPinIn) ;
                return hr ;
            }
            // else let it fall through to try indirect connect next
        }

    case AM_DVD_CONNECT_INDIRECT:
        hr = m_pGB->Connect(pPinOut, pPinIn) ;
        if (SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE, 3, TEXT("Pin %s *indirectly* connected to pin %s"),
                (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("Pin %s did NOT even *indirectly* connect to pin %s"),
                (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
        }
        //         PrintPinRefCount("After connection attempt", pPinOut) ;
        //         PrintPinRefCount("After connection attempt", pPinIn) ;
        return hr ;  // whatever it is

    default:
        return E_UNEXPECTED ;
    }
}


HRESULT CDvdGraphBuilder::RenderVideoUsingOvMixer(IPin **apPinOut,
                                                  AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderVideoUsingOvMixer(0x%lx, 0x%lx)"),
        apPinOut, pStatus)) ;

    HRESULT   hr ;
    IPin     *pPinIn ;
    BOOL      bConnected = FALSE ;  // until connects

    //
    // If VMR has somehow been instantiated, we need to remove and release it now.
    //
    if (m_pVMR)
    {
        DbgLog((LOG_TRACE, 3, TEXT("VMR was somehow created and not in use. Removing it..."))) ;
        // Remove it from graph and release it
        m_pGB->RemoveFilter(m_pVMR) ;
        m_pVMR->Release() ;
        m_pVMR = NULL ;
    }

    // IMPORTANT NOTE:
    // For video stream, any decode/rendering problem has to be flagged here
    // as we just downgrade the final result in the caller, but not set any
    // flag there.  Also in RenderDecodedVideo(), we may try to use VMR, and
    // if that fails, we fall back on OvMixer.  If rendering through OvMixer
    // also fails, then only we set the rendering error status and code.
    //

    hr = EnsureOverlayMixerExists() ;
    if (FAILED(hr))
    {
        // pStatus->hrVPEStatus = hr ; -- actually VPE/Overlay wasn't tried even
        DbgLog((LOG_TRACE, 3, TEXT("Overlay Mixer couldn't be started!!!"))) ;
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return VFW_E_DVD_RENDERFAIL ;
    }

    // Connect given output pin to OverlayMixer's first input pin
    hr = FindMatchingPin(m_pOvM, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: No open input pin found on OverlayMixer (Error 0x%lx)"), hr)) ;
        ASSERT(FALSE) ;  // so that we know of this weird case
        DbgLog((LOG_TRACE, 3, TEXT("No input pin found on Overlay Mixer!!!"))) ;
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return VFW_E_DVD_RENDERFAIL ;
    }

    int  i = 0 ;
    while (!bConnected  &&  i < MAX_DEC_OUT_PINS  &&  apPinOut[i])
    {
        hr = ConnectPins(apPinOut[i], pPinIn, AM_DVD_CONNECT_DIRECTFIRST) ;
        if (FAILED(hr))
        {
            pStatus->hrVPEStatus = hr ;
            i++ ;
            ASSERT(i <= MAX_DEC_OUT_PINS) ;
        }
        else
        {
            bConnected = TRUE ;
            pStatus->hrVPEStatus = S_OK ;  // make sure we don't return any error code
        }
    }

    pPinIn->Release() ;  // done with the pin

    if (!bConnected)  // if connection to OvMixer's in pin failed => no video on screen
    {
        DbgLog((LOG_TRACE, 3, TEXT("None of the %d video output pins could be connected to OvMixer"), i)) ;
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return S_FALSE ;
    }

    // Now see if OverlayMixer has an output pin (no out pin in DDraw excl mode).
    // If it has, connect that to the Video Renderer.
    IPin   *pPinOutOvM ;
    hr = FindMatchingPin(m_pOvM, 0, PINDIR_OUTPUT, TRUE, 0, &pPinOutOvM) ;
    if (FAILED(hr)  ||  NULL == pPinOutOvM)
    {
        DbgLog((LOG_TRACE, 1, TEXT("No output pin of OverlayMixer -- in DDraw excl mode?"))) ;
        //ASSERT(IsDDrawExclMode()) ;
        return S_OK ;  // nothing more to do
    }

    // Create the Video Renderer filter and connect OvMixer's out pin to that
    bConnected = FALSE ;   // until connected
    hr = CreateFilterInGraph(CLSID_VideoRenderer, L"Video Renderer", &m_pVR) ;
    if (SUCCEEDED(hr) && m_pVR)
    {
        hr = FindMatchingPin(m_pVR, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;  // Caution: re-using pPinIn
        if (SUCCEEDED(hr)  &&  pPinIn)
        {
            hr = ConnectPins(pPinOutOvM, pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;
            if (FAILED(hr))  // what?!?
            {
                ASSERT(FALSE) ;  // so that we notice
                DbgLog((LOG_TRACE, 1, TEXT("No video out pin connected to pin %s -- no video on screen"),
                    (LPCTSTR)CDisp(pPinIn))) ;
            }
            else
            {
                bConnected = TRUE ;
            }
            pPinIn->Release() ;      // done with VR's in pin
        }
        else   // what?!?
        {
            DbgLog((LOG_TRACE, 1, TEXT("No input pin of VideoRenderer?!?"))) ;
            // Remove it from graph; else a useless window will pop up
            m_pGB->RemoveFilter(m_pVR) ;
            m_pVR->Release() ;
            m_pVR = NULL ;
        }
    }
    else   // what?!?
    {
        ASSERT(FALSE) ;  // so that we notice
        DbgLog((LOG_TRACE, 1,
            TEXT("WARNING: Can't start Video Renderer (Error 0x%lx) -- no video on screen"),
            hr)) ;
        // bConnected = FALSE ;
    }
    pPinOutOvM->Release() ;  // done with OvMixer's out pin

    if (! bConnected )  // if connection to OvMixer's in pin failed => no video on screen
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Couldn't render Video stream using OvMixer"))) ;
        pStatus->iNumStreamsFailed++ ;
        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return S_FALSE ;
    }

    return S_OK ;
}


HRESULT CDvdGraphBuilder::RenderVideoUsingVMR(IPin **apPinOut,
                                              AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderVideoUsingVMR(0x%lx, 0x%lx)"),
        apPinOut, pStatus)) ;

    HRESULT   hr ;
    IPin     *pPinIn ;
    BOOL      bConnected = FALSE ;  // until connects

    //
    // If OvMixer has somehow been instantiated, we need to remove and release it now.
    //
    if (m_pOvM)
    {
        DbgLog((LOG_TRACE, 3, TEXT("OvMixer was somehow created. Can't use VMR now."))) ;
		return E_FAIL ;

        // DbgLog((LOG_TRACE, 3, TEXT("OvMixer was somehow created and not in use. Removing it..."))) ;
        // Remove it from graph and release it
        // m_pGB->RemoveFilter(m_pOvM) ;
        // m_pOvM->Release() ;
        // m_pOvM = NULL ;
    }

    //
    // Now instantiate VMR and try to render using it
    //
    hr = EnsureVMRExists() ;
    if (S_OK != hr)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Video Mixing Renderer couldn't be started or configured"))) ;
        // pStatus->iNumStreamsFailed++ ;
        // pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return E_FAIL ; // caught by RenderDecodedVideo()
    }

    // Connect given output pin to VMR's first input pin
    hr = FindMatchingPin(m_pVMR, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: No open input pin found on VMR (Error 0x%lx)"), hr)) ;
        ASSERT(FALSE) ;  // so that we know of this weird case
        // Remove it from graph; it's useless now
        m_pGB->RemoveFilter(m_pVMR) ;
        m_pVMR->Release() ;
        m_pVMR = NULL ;
        // pStatus->iNumStreamsFailed++ ;
        // pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return E_UNEXPECTED ;  // caught by RenderDecodedVideo(), but unexpected
    }

    // Try to connect the first out pin of the video decoder to VMR's 1st in pin
    int  i = 0 ;
    while (!bConnected  &&  i < MAX_DEC_OUT_PINS  &&  apPinOut[i])
    {
        hr = ConnectPins(apPinOut[i], pPinIn, AM_DVD_CONNECT_DIRECTFIRST) ;
        if (FAILED(hr))
        {
            pStatus->hrVPEStatus = hr ;
            i++ ;
            ASSERT(i <= MAX_DEC_OUT_PINS) ;
        }
        else
        {
            bConnected = TRUE ;
            pStatus->hrVPEStatus = S_OK ;  // make sure we don't return any error code
        }
    }

    pPinIn->Release() ;  // done with the pin

    if (! bConnected )  // if connection to VMR's in pin failed => no video on screen
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Couldn't render Video stream using VMR"))) ;
        // Remove it from graph; it's useless now
        m_pGB->RemoveFilter(m_pVMR) ;
        m_pVMR->Release() ;
        m_pVMR = NULL ;
        // pStatus->iNumStreamsFailed++ ;
        // pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
        return E_UNEXPECTED ;  // S_FALSE ;
    }

    return S_OK ;
}


HRESULT CDvdGraphBuilder::RenderVideoUsingVPM(IPin **apPinOut,
                                              AM_DVD_RENDERSTATUS *pStatus,
                                              IPin **apPinOutVPM)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderVideoUsingVPM(0x%lx, 0x%lx, 0x%lx)"),
        apPinOut, pStatus, apPinOutVPM)) ;

    HRESULT   hr ;
    IPin     *pPinIn ;
    IPin     *pPinOut ;
    BOOL      bConnected = FALSE ;  // until connects

    // Filter, hopefully decoder, has been connected to the Nav.
    // Now try to connect it to VPM (and later to VMR).
    ASSERT(NULL == m_pVPM) ;
    // *apPinOutVPM = NULL ;  // to start with
    hr = CreateFilterInGraph(CLSID_VideoPortManager, L"Video Port Manager", &m_pVPM) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 3, TEXT("VPM couldn't be started!!!"))) ;
        return E_FAIL ; // caught by RenderDecodedVideo()
    }

    // Connect given output pin to VPM's first input pin
    hr = FindMatchingPin(m_pVPM, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: No open input pin found on VPM (Error 0x%lx)"), hr)) ;
        ASSERT(FALSE) ;  // so that we know of this weird case
        // Remove it from graph; it's useless now
        m_pGB->RemoveFilter(m_pVPM) ;
        m_pVPM->Release() ;
        m_pVPM= NULL ;
        return E_UNEXPECTED ;  // caught by RenderDecodedVideo()
    }

    // Try to connect the first out pin of the HW video decoder to VPM's in pin
    int  i = 0 ;
    while (!bConnected  &&  i < MAX_DEC_OUT_PINS  &&  apPinOut[i])
    {
        hr = ConnectPins(apPinOut[i], pPinIn, AM_DVD_CONNECT_DIRECTFIRST) ;
        if (FAILED(hr))
        {
            pStatus->hrVPEStatus = hr ;
            i++ ;
            ASSERT(i <= MAX_DEC_OUT_PINS) ;
        }
        else
        {
            bConnected = TRUE ;
            pStatus->hrVPEStatus = S_OK ;  // make sure we don't return any error code
        }
    }

    pPinIn->Release() ;  // done with the pin

    if (! bConnected )  // if connection to VPM's in pin failed => no video on screen
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Couldn't render (HW) Video stream using VPM"))) ;
        // Remove it from graph; it's useless now
        m_pGB->RemoveFilter(m_pVPM) ;
        m_pVPM->Release() ;
        m_pVPM = NULL ;
        return E_FAIL ;
    }

    // Connected!! Now find the first out pin of the VPM (to connect to VMR).
    hr = FindMatchingPin(m_pVPM, 0, PINDIR_OUTPUT, TRUE, 0, &pPinOut) ;
    ASSERT(SUCCEEDED(hr)) ;

    apPinOutVPM[0] = pPinOut ;  // only one pin returned; release in the caller

    return hr ;
}


HRESULT CDvdGraphBuilder::RenderDecodedVideo(IPin **apPinOut,
                                             AM_DVD_RENDERSTATUS *pStatus,
                                             DWORD dwDecFlag)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderDecodedVideo(0x%lx, 0x%lx, 0x%lx)"),
        apPinOut, pStatus, dwDecFlag)) ;

    HRESULT  hr = S_OK ;

    // SWDecodeDVDStream() method tried to detect if the video/SP decoder is
    // VMR-compatible. If not, it has set a flag (m_bTryVMR to FALSE), so here
    // we know which renderer to use.
    //
    // For hardware decoders that work with VPE, we don't check the VMR-compatibility.
    // We just try to connect it to VPM and VMR. If that doesn't work, use OvMixer. We
    // avoid trying to connect the non-VPE decoders to VPM, because we know that DXR2,
    // which uses analog overlay, gets completely messed up if it's even attempted to
    // connect to VPM (which fails anyway).
    //

    // We first try to use VMR, if we are supposed to, i.e.,
    //   a) DDraw (non-)exclusive mode is NOT being used
    //   b) the decoder(s) is VMR compatible
    //   c) no one has asked us not to (in some other way)
    // If that succeeds, Great!!!  Otherwise we fall back on using OvMixer, so
    // that we can at least play the DVD.
    // In case we try to use OvMixer, and that for some reason fails to connect,
    // the error flags and code are set in RenderVideoUsingOvMixer() method.
    //
    if (GetVMRUse())  // VMR can be used (so far)
    {
        //
        // We should try to use VMR first....
        //
        // If HW decoder filter is being used, we check if the output type is VPVideo,
        // and then only we'll try to use VPM for VMR first.  If that works, we'll
        // return the out pin of VPM.  If it fails, we'll set a flag so that
        // RenderDecodedVideo() method knows and uses OvMixer as a fallback option.
        // If the output mediatype is non-VPE (e.g., analog overlay), we do NOT even
        // try to connect to VPM, and fall back to OvMixer.
        //
        if (AM_DVD_HWDEC_ONLY == dwDecFlag)  // video decoded in HW
        {
            DbgLog((LOG_TRACE, 5, TEXT("HW decoder used for Video. Is it VMR-compatible?"))) ;
            if (IsOutputTypeVPVideo(apPinOut[0]))  // output type is VPE => use VPM
            {                       // Checking the first out pin should be fine
                // VPVideo stream: Try to use VPM and VMR for rendering
                DbgLog((LOG_TRACE, 5, TEXT("HW decoder with VPE -- connect to VPM+VMR"))) ;
                IPin  *apPinOutVPM[2] ;  // There is only one out pin of VPM (one for NULL)
                ResetPinInterface(apPinOutVPM, NUMELMS(apPinOutVPM)) ;
                hr = RenderVideoUsingVPM(apPinOut, pStatus, apPinOutVPM) ;  // returns VPM's out pin

                // If the success status is still maintained, use the VMR.
                if (SUCCEEDED(hr))
                {
                    DbgLog((LOG_TRACE, 5, TEXT("HW decoder connected to VPM. Now connect to VMR."))) ;
                    hr = RenderVideoUsingVMR(apPinOutVPM, pStatus) ;  // render VPM's out pin via VMR
                    ReleasePinInterface(apPinOutVPM) ;  // done with VPM out pin interface
                    if (FAILED(hr))
                    {
                        DbgLog((LOG_TRACE, 5, TEXT("VPM - VMR connection failed.  Removing VPM..."))) ;
                        if (m_pVPM)
                        {
                            EXECUTE_ASSERT(SUCCEEDED(m_pGB->RemoveFilter(m_pVPM))) ;
                            m_pVPM->Release() ;
                            m_pVPM = NULL ;
                        }
                    }
                }
                else
                {
                    ReleasePinInterface(apPinOutVPM) ;  // shouldn't be needed, but...
                }
            }  // end of if (VPVideo)
            else  // output type is not VPE => use OvMixer (Not VPM+VMR)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Non-VPE HW decoder -- didn't try VPM+VMR"))) ;
                hr = E_FAIL ;  // set failure code so that it's tried with OvMixer below
            }
        }  // end of if (HW decoder used)
        else  // we are using SW video decoder -- render directly using VMR
        {
            DbgLog((LOG_TRACE, 5, TEXT("HW decoder not used. Directly connect to VMR..."))) ;
            hr = RenderVideoUsingVMR(apPinOut, pStatus) ;
        }

        // In case anything above failed, ditch VMR, and go for OvMixer.
        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE, 4, TEXT("Render using VMR failed. Falling back on OvMixer..."))) ;
            //
            // NOTE: If we can't use VMR for video, no point trying it for SP stream
            //
            SetVMRUse(FALSE) ;

            hr = RenderVideoUsingOvMixer(apPinOut, pStatus) ;
        }
    }
    else  // we are not supposed to use VMR; that means use OvMixer
    {
        hr = RenderVideoUsingOvMixer(apPinOut, pStatus) ;
    }

    return hr ;
}


HRESULT CDvdGraphBuilder::RenderDecodedAudio(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderDecodedAudio(0x%lx, 0x%lx)"),
        apPinOut, pStatus)) ;

    HRESULT   hr ;
    HRESULT   hrFinal = S_OK ;
    BOOL      bConnected = FALSE ;   // until connected
    IPin     *pPinIn = NULL ;

    ASSERT(NULL == m_pAR) ;  // so that we know

    // Create the Audio Renderer filter and connect decoder's audio out pin to that
    hr = CreateFilterInGraph(CLSID_DSoundRender, L"DSound Renderer", &m_pAR) ;
    if (SUCCEEDED(hr))
    {
        // Get an input pin to Audio Renderer
        hr = FindMatchingPin(m_pAR, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
        ASSERT(SUCCEEDED(hr) && pPinIn) ;
    }
    else
    {
        ASSERT(! TEXT("Coundn't start Audio Renderer") ) ;  // so that we notice
        DbgLog((LOG_TRACE, 1,
            TEXT("WARNING: Can't start Audio Renderer (Error 0x%lx) -- no audio from speakers"),
            hr)) ;
        hrFinal = S_FALSE ;  // no audio from speakers -- result downgraded
    }

    //
    // We'll try to render all the decoded audio out pins
    //
    for (int i = 0 ; i < MAX_DEC_OUT_PINS  &&  apPinOut[i]; i++)
    {
        if (pPinIn)  // if we have an open input pin of Audio Renderer
        {
            hr = m_pGB->Connect(apPinOut[i], pPinIn) ;
            if (SUCCEEDED(hr))  // decoded audio connected to audio renderer
            {
                DbgLog((LOG_TRACE, 5, TEXT("Pin %s connected to pin %s"),
                    (LPCTSTR)CDisp(apPinOut[i]), (LPCTSTR)CDisp(pPinIn))) ;
                EnumFiltersBetweenPins(AM_DVD_STREAM_AUDIO, apPinOut[i], pPinIn, pStatus) ;

                bConnected = TRUE ;
                pPinIn->Release() ;  // done with this pin interface
                pPinIn = NULL ;

                // Let's try the next out pin, if any...
                continue ;
            }

            ASSERT(!TEXT("Couldn't connect audio pin")) ;  // so that we notice
            DbgLog((LOG_TRACE, 1, TEXT("Pin %s (#%ld) did NOT connect to pin %s"),
                (LPCTSTR)CDisp(apPinOut[i]), i, (LPCTSTR)CDisp(pPinIn))) ;
        }

        //
        //  We could come here, because either
        //  1. DSound Renderer didn't start (no audio device)
        //  2. we couldn't get an in pin to DSound Renderer (impossible, but...)
        //
        //  Couldn't connect the outout pin to a known renderer. Let's try to
        //  just render, and see if any filter (S/PDIF?) connects to it.
        //
        hr = m_pGB->Render(apPinOut[i]) ;
        if (FAILED(hr))
        {
            ASSERT(!TEXT("Audio out pin didn't render at all")) ;  // so that we notice
            DbgLog((LOG_TRACE, 1, TEXT("Pin %s (#%ld) did NOT render at all"),
                (LPCTSTR)CDisp(apPinOut[i]), i)) ;
        }

        // Now onto the next decoded audio out pin, if any...

    }  // end of while (i ...) loop

    if (! bConnected )  // connection to Audio Renderer failed => no audio on speakers
    {
        DbgLog((LOG_TRACE, 1,
            TEXT("No decoded audio pin connect to AudioRenderer -- no audio from speakers"))) ;

        if (m_pAR)  // if we had an Audio Renderer
        {
            if (pPinIn)  // if we had an in pin that we couldn't connect to,
                pPinIn->Release() ;      // let it go now.

            // Remove Audio Renderer from graph
            m_pGB->RemoveFilter(m_pAR) ;
            m_pAR->Release() ;
            m_pAR = NULL ;
        }
        hrFinal = S_FALSE ;
    }

    return hrFinal ;
}


HRESULT CDvdGraphBuilder::RenderSubpicUsingOvMixer(IPin **apPinOut,
                                                   AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderSubpicUsingOvMixer(0x%lx, 0x%lx)"),
        apPinOut, pStatus)) ;

    HRESULT   hr ;
    BOOL      bConnected = FALSE ;   // until connected
    IPin     *pPinIn ;
    int       i = 0 ;

    ASSERT(m_pOvM) ;  // it must be there, if video stream was rendered

    // Now connect the given out pin to the next available in pin of OvMixer
    hr = FindMatchingPin(m_pOvM, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
    if (SUCCEEDED(hr)  &&  pPinIn)
    {
        while (!bConnected  &&  i < MAX_DEC_OUT_PINS  &&  apPinOut[i])
        {
            hr = ConnectPins(apPinOut[i], pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;
            if (FAILED(hr))  // what?!?
            {
                // ASSERT(FALSE) ;  // so that we notice
                DbgLog((LOG_TRACE, 1, TEXT("Pin %s (#%ld) did NOT connect to pin %s -- no SP"),
                    (LPCTSTR)CDisp(apPinOut[i]), i, (LPCTSTR)CDisp(pPinIn))) ;
                i++ ;
                ASSERT(i <= MAX_DEC_OUT_PINS) ;
            }
            else
            {
                DbgLog((LOG_TRACE, 5, TEXT("Pin %s is directly connected to pin %s"),
                    (LPCTSTR)CDisp(apPinOut[i]), (LPCTSTR)CDisp(pPinIn))) ;
                bConnected = TRUE ;
            }
        }
        pPinIn->Release() ;      // done with OvMixer's in pin
    }
    else   // what?!?
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: No more input pin of OverlayMixer?!?"))) ;
    }

    return (bConnected ? S_OK : hr) ;  // this should be the same as "return hr ;"
}


HRESULT CDvdGraphBuilder::RenderSubpicUsingVMR(IPin **apPinOut,
                                               AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderSubpicUsingVMR(0x%lx, 0x%lx)"),
        apPinOut, pStatus)) ;

    HRESULT   hr ;
    BOOL      bConnected = FALSE ;   // until connected
    IPin     *pPinIn ;
    int       i = 0 ;

    ASSERT(m_pVMR) ;  // it must be there, if video stream was rendered

    // Now connect the given out pin to the next available in pin of VMR
    hr = FindMatchingPin(m_pVMR, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
    if (SUCCEEDED(hr)  &&  pPinIn)
    {
        while (!bConnected  &&  i < MAX_DEC_OUT_PINS  &&  apPinOut[i])
        {
            hr = ConnectPins(apPinOut[i], pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;
            if (FAILED(hr))  // what?!?
            {
                // ASSERT(FALSE) ;  // so that we notice
                DbgLog((LOG_TRACE, 1, TEXT("Pin %s (#%ld) did NOT connect to pin %s -- no SP"),
                    (LPCTSTR)CDisp(apPinOut[i]), i, (LPCTSTR)CDisp(pPinIn))) ;
                i++ ;
                ASSERT(i <= MAX_DEC_OUT_PINS) ;
            }
            else
            {
                DbgLog((LOG_TRACE, 5, TEXT("Pin %s is directly connected to pin %s"),
                    (LPCTSTR)CDisp(apPinOut[i]), (LPCTSTR)CDisp(pPinIn))) ;
                bConnected = TRUE ;
            }
        }
        pPinIn->Release() ;      // done with VMR's in pin
    }
    else   // what?!?
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: No more input pin of VMR?!?"))) ;
    }

    return (bConnected ? S_OK : hr) ;  // this should be the same as "return hr ;"
}


HRESULT CDvdGraphBuilder::RenderDecodedSubpic(IPin **apPinOut, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderDecodedSubpic(0x%lx, 0x%lx)"),
        apPinOut, pStatus)) ;

    HRESULT   hr ;

    //
    // Render the decoded subpicture stream ONLY IF the user wants that
    //
    if (!m_bUseVPE  ||  IsDDrawExclMode())
    {
        DbgLog((LOG_TRACE, 1, TEXT("SP Stream: RenderDvdVideoVolume() skipped for %s and %s"),
            m_bUseVPE ? "VPE" : "no VPE", IsDDrawExclMode() ? "DDraw excl mode" : "normal mode")) ;
        return S_OK ;
    }

    // We have already attempted to render the video straem.  If that has failed,
    // there is no point trying to render the subpicture stream -- just indicate
    // that this stream didn't render and return.
    if (pStatus->dwFailedStreamsFlag & AM_DVD_STREAM_VIDEO)
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Video stream didn't render. Skipping SP rendering."))) ;
        return S_FALSE ;
    }

    if (GetVMRUse())  // if VMR is to be used
    {
        DbgLog((LOG_TRACE, 5, TEXT("Rendering SP stream using VMR"))) ;
        hr = RenderSubpicUsingVMR(apPinOut, pStatus) ;
    }
    else  // OvMixer is being used
    {
        DbgLog((LOG_TRACE, 5, TEXT("Rendering SP stream using OvMixer"))) ;
        hr = RenderSubpicUsingOvMixer(apPinOut, pStatus) ;
    }

    //
    // We don't set the following flag and values anymore as part of the hack
    // to ignore failure to connect *some* decoded-SP-ish out pin in the case
    // of HW decoders. The caller of this method knows if the decoder being
    // used is HW or SW and based on that it will ignore any failure or not.
    //
    if (FAILED(hr))  // if connection to OvMixer's in pin failed => no SP (weird!!)
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Subpic pin could NOT connect to renderer"))) ;
        return hr ; // S_FALSE ;
    }

    return S_OK ;  // complete success!!!
}


HRESULT CDvdGraphBuilder::RenderLine21Stream(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderLine21Stream(%s, 0x%lx)"),
        (LPCTSTR)CDisp(pPinOut), pStatus)) ;

    HRESULT   hr ;
    BOOL      bConnected = FALSE ;   // until connected
    IPin     *pPinIn ;

    ASSERT(NULL == m_pL21Dec) ;  // so that we know

    //
    // Create the Line21 Decoder filter and connect given out pin to that
    //
    if (GetVMRUse())  // for VMR use Line21 Decoder2
    {
        hr = CreateFilterInGraph(CLSID_Line21Decoder2, L"Line21 Decoder2", &m_pL21Dec) ;
    }
    else  // for OvMixer, keep using the old one
    {
        hr = CreateFilterInGraph(CLSID_Line21Decoder, L"Line21 Decoder", &m_pL21Dec) ;
    }
    if (SUCCEEDED(hr))
    {
        hr = FindMatchingPin(m_pL21Dec, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
        if (SUCCEEDED(hr)  &&  pPinIn)
        {
            hr = ConnectPins(pPinOut, pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;
            if (FAILED(hr))  // what?!?
            {
                ASSERT(FALSE) ;
                DbgLog((LOG_TRACE, 1, TEXT("Pin %s did NOT connect to pin %s -- no CC"),
                    (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
                pPinIn->Release() ;  // release pin before removing filter
                m_pGB->RemoveFilter(m_pL21Dec) ;
                m_pL21Dec->Release() ;
                m_pL21Dec = NULL ;
            }
            else
            {
                bConnected = TRUE ;
                pPinIn->Release() ;   // because we do so for the failure case
            }
        }
        else   // what?!?
        {
            DbgLog((LOG_TRACE, 1, TEXT("No input pin of Line21 Decoder(2)?!?"))) ;
            // Remove it from graph
            m_pGB->RemoveFilter(m_pL21Dec) ;
            m_pL21Dec->Release() ;
            m_pL21Dec = NULL ;
        }
    }
    else   // what?!?
    {
        // ASSERT(FALSE) ;  // so that we notice -- not until lin21dec2 is done
        DbgLog((LOG_TRACE, 1,
            TEXT("WARNING: Can't start Line21 Decoder(2) (Error 0x%lx) -- no CC"),
            hr)) ;
    }

    if (! bConnected )  // if connection to OvMixer's in pin failed => no video on screen
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Pin %s could NOT connect to Line21 Decoder(2)"),
            (LPCTSTR)CDisp(pPinOut))) ;
        return hr ;
    }

    // Now connect line21 decoder(2)'s output to OvMixer/VMR's in pin
    bConnected = FALSE ;  // until connected again
    IPin   *pPinOutL21 ;
    hr = FindMatchingPin(m_pL21Dec, 0, PINDIR_OUTPUT, TRUE, 0, &pPinOutL21) ;
    ASSERT(SUCCEEDED(hr)) ;

    if (GetVMRUse())  // find VMR's in pin
    {
        hr = FindMatchingPin(m_pVMR, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;  // Caution: reusing pPinIn
    }
    else              // find OvMixer's in pin
    {
        hr = FindMatchingPin(m_pOvM, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;  // Caution: reusing pPinIn
    }
    ASSERT(SUCCEEDED(hr)) ;
    if (pPinOutL21  &&  pPinIn)
    {
        hr = ConnectPins(pPinOutL21, pPinIn, AM_DVD_CONNECT_DIRECTONLY) ;
        if (FAILED(hr))  // what?!?
        {
            ASSERT(FALSE) ;  // so that we notice
            DbgLog((LOG_TRACE, 1, TEXT("Pin %s did NOT connect to pin %s -- no CC"),
                (LPCTSTR)CDisp(pPinOutL21), (LPCTSTR)CDisp(pPinIn))) ;
            pPinOutL21->Release() ;  // release pin before removing filter
            m_pGB->RemoveFilter(m_pL21Dec) ;
            m_pL21Dec->Release() ;
            m_pL21Dec = NULL ;
        }
        else
        {
            bConnected = TRUE ;
            pPinOutL21->Release() ;  // because we do so in the failure case
        }
        pPinIn->Release() ;      // done with OvMixer's in pin
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Couldn't get necessary in/out pin"))) ;
        if (pPinIn)
            pPinIn->Release() ;
        if (pPinOutL21)
            pPinOutL21->Release() ;
        // Remove it from graph
        m_pGB->RemoveFilter(m_pL21Dec) ;
        m_pL21Dec->Release() ;
        m_pL21Dec = NULL ;
    }

    if (! bConnected )  // if connection to OvMixer's in pin failed => no CC
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Line21Dec output could NOT connect to OvMixer/VMR"))) ;
        return hr ;
    }

    return S_OK ;  // complete success!!!
}


BOOL CDvdGraphBuilder::IsOutputDecoded(IPin *pPinOut)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::IsOutputDecoded(%s)"),
        (LPCTSTR)CDisp(pPinOut))) ;

    HRESULT          hr ;
    IEnumMediaTypes *pEnumMT ;
    AM_MEDIA_TYPE   *pmt ;
    ULONG            ul ;
    BOOL             bMTDecoded = FALSE ;  // unless found otherwise

    hr = pPinOut->EnumMediaTypes(&pEnumMT) ;
    ASSERT(SUCCEEDED(hr) && pEnumMT) ;
    while ( !bMTDecoded &&
        S_OK == pEnumMT->Next(1, &pmt, &ul) && 1 == ul)
    {
#if 1  // we'll use the following procedure
        bMTDecoded = (MEDIATYPE_Video == pmt->majortype &&              // major type Video,
            MEDIASUBTYPE_MPEG2_VIDEO != pmt->subtype &&       // subtype is NOT MPEG2Video
            MEDIASUBTYPE_DVD_SUBPICTURE != pmt->subtype) ||   // subtype is NOT DVDSubPicture  OR

            (MEDIATYPE_Audio == pmt->majortype &&              // major type Audio
            MEDIASUBTYPE_MPEG2_AUDIO != pmt->subtype &&       // subtype is NOT MPEG2Audio
            MEDIASUBTYPE_DOLBY_AC3 != pmt->subtype &&         // subtype is NOT Dolby AC3
            MEDIASUBTYPE_DVD_LPCM_AUDIO != pmt->subtype) ||   // subtype is NOT DVD-LPCMAudio

            (MEDIATYPE_AUXLine21Data == pmt->majortype) ;      // majortype is Line21
#else  // not this procedure
        bMTDecoded = (MEDIATYPE_DVD_ENCRYPTED_PACK != pmt->majortype && // majortype is NOT DVD_ENCRYPTED_PACK
            MEDIATYPE_MPEG2_PES != pmt->majortype &&          // majortype is NOT MPEG2_PES

            MEDIASUBTYPE_MPEG2_VIDEO != pmt->subtype &&       // subtype is NOT MPEG2Video

            MEDIASUBTYPE_MPEG2_AUDIO != pmt->subtype &&       // subtype is NOT MPEG2Audio
            MEDIASUBTYPE_DOLBY_AC3 != pmt->subtype &&         // subtype is NOT DolbyAC3
            MEDIASUBTYPE_DVD_LPCM_AUDIO != pmt->subtype &&    // subtype is NOT DVD_LPCMAudio

            MEDIASUBTYPE_DVD_SUBPICTURE != pmt->subtype) ;    // subtype is NOT DVD_SUBPICTURE
#endif // #if 1
        DeleteMediaType(pmt) ;  // otherwise
    }
    pEnumMT->Release() ;

    return bMTDecoded ;
}


BOOL CDvdGraphBuilder::IsOutputTypeVPVideo(IPin *pPinOut)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::IsOutputTypeVPVideo(%s)"),
        (LPCTSTR)CDisp(pPinOut))) ;

    HRESULT          hr ;
    IEnumMediaTypes *pEnumMT ;
    AM_MEDIA_TYPE   *pmt ;
    ULONG            ul ;
    BOOL             bVPVideo = FALSE ;  // unless found otherwise

    hr = pPinOut->EnumMediaTypes(&pEnumMT) ;
    ASSERT(SUCCEEDED(hr) && pEnumMT) ;
    while ( !bVPVideo  &&
           S_OK == pEnumMT->Next(1, &pmt, &ul) && 1 == ul)
    {
        bVPVideo = MEDIATYPE_Video      == pmt->majortype &&  // major type Video,
                   MEDIASUBTYPE_VPVideo == pmt->subtype ;     // subtype is VPVideo
        DeleteMediaType(pmt) ;  // otherwise
    }
    pEnumMT->Release() ;

    return bVPVideo ;
}


//
// Create a filter and add it to the filter graph
//
HRESULT CDvdGraphBuilder::CreateFilterInGraph(CLSID Clsid,
                                              LPCWSTR lpszwFilterName,
                                              IBaseFilter **ppFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateFilterInGraph(%s, %S, 0x%lx)"),
        (LPCTSTR) CDisp(Clsid), lpszwFilterName, ppFilter)) ;

    if (NULL == m_pGB)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Filter graph object hasn't been created yet"))) ;
        return E_FAIL ;
    }

    HRESULT   hr ;
    hr = CoCreateInstance(Clsid, NULL, CLSCTX_INPROC, IID_IBaseFilter,
        (LPVOID *)ppFilter) ;
    if (FAILED(hr) || NULL == *ppFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't create filter %s (Error 0x%lx)"),
            (LPCTSTR)CDisp(Clsid), hr)) ;
        return hr ;
    }

    // Add it to the filter graph
    hr = m_pGB->AddFilter(*ppFilter, lpszwFilterName) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't add filter %s to graph (Error 0x%lx)"),
            (LPCTSTR)CDisp(Clsid), hr)) ;
        (*ppFilter)->Release() ;  // release filter too
        *ppFilter = NULL ;      // and set it to NULL
        return hr ;
    }

    return NOERROR ;
}



//
// Instantiate all the HW decoders registered under DVD Hardware Decoder
// group under the Active Filters category.
//
// Qn: Do we need to also pick up the HW filters under any other category,
// specially for filters like the external AC3 decoder etc.?
//
HRESULT CDvdGraphBuilder::CreateDVDHWDecoders(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateDVDHWDecoders()"))) ;

    HRESULT  hr ;
    ICreateDevEnum *pCreateDevEnum ;
    hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
        IID_ICreateDevEnum, (void**)&pCreateDevEnum) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't create system dev enum (Error 0x%lx)"), hr)) ;
        return hr ;
    }

    IEnumMoniker *pEnumMon ;
    hr = pCreateDevEnum->CreateClassEnumerator(CLSID_DVDHWDecodersCategory,
        &pEnumMon, 0) ;
    pCreateDevEnum->Release() ;

    if (S_OK != hr)
    {
        DbgLog((LOG_ERROR, 0,
            TEXT("WARNING: Couldn't create class enum for DVD HW Dec category (Error 0x%lx)"),
            hr)) ;
        return E_FAIL ;
    }

    hr = pEnumMon->Reset() ;

    ULONG     ul ;
    IMoniker *pMon ;

    while (S_OK == pEnumMon->Next(1, &pMon, &ul) && 1 == ul)
    {
#ifdef DEBUG
        WCHAR   *wszName ;
        pMon->GetDisplayName(0, 0, &wszName) ;
        DbgLog((LOG_TRACE, 5, TEXT("Moniker enum: %S"), wszName)) ;
        CoTaskMemFree(wszName) ;
#endif  // DEBUG

        IBaseFilter *pFilter ;
        hr = pMon->BindToObject(0, 0, IID_IBaseFilter, (void**)&pFilter) ;
        if (FAILED(hr) ||  NULL == pFilter)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't create HW dec filter (Error 0x%lx)"), hr)) ;
            pMon->Release() ;
            continue ;
        }
        DbgLog((LOG_TRACE, 5, TEXT("HW decoder filter found"))) ;

        IPropertyBag *pPropBag ;
        pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag) ;
        if(pPropBag)
        {
#ifdef DEBUG
            {
                VARIANT var ;
                var.vt = VT_EMPTY ;
                hr = pPropBag->Read(L"DevicePath", &var, 0) ;
                ASSERT(SUCCEEDED(hr)) ;
                DbgLog((LOG_TRACE, 5, TEXT("DevicePath: %S"), var.bstrVal)) ;
                VariantClear(&var) ;
            }

            {
                VARIANT var ;
                var.vt = VT_EMPTY ;
                hr = pPropBag->Read(L"CLSID", &var, 0) ;
                ASSERT(SUCCEEDED(hr)) ;
                DbgLog((LOG_TRACE, 5, TEXT("CLSID: %S"), var.bstrVal)) ;
                VariantClear(&var) ;
            }
#endif // DEBUG

            {
                VARIANT var ;
                var.vt = VT_EMPTY ;
                hr = pPropBag->Read(L"FriendlyName", &var, 0) ;
                if (SUCCEEDED(hr))
                {
                    DbgLog((LOG_TRACE, 5, TEXT("FriendlyName: %S"), var.bstrVal)) ;

                    //
                    // We have got a device under the required category. The proxy
                    // for it is already instantiated. So add to the list of HW
                    // decoders to be used for building the graph.
                    //
                    m_ListHWDecs.AddFilter(pFilter, var.bstrVal, NULL) ;
                    VariantClear(&var) ;
                }
                else
                {
                    DbgLog((LOG_ERROR, 1, TEXT("WARNING: Failed to get FriendlyName (Error 0x%lx)"), hr)) ;
                    ASSERT(SUCCEEDED(hr)) ;  // so that we know
                }
            }

            pPropBag->Release() ;
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: BindToStorage failed"))) ;
        }

        pMon->Release() ;
    }  // end of while()

    pEnumMon->Release() ;

    DbgLog((LOG_TRACE, 5, TEXT("Found total %d HW decoders"), m_ListHWDecs.GetCount())) ;

    return NOERROR ;

}



HRESULT CDvdGraphBuilder::FindMatchingPin(IBaseFilter *pFilter, DWORD dwStream, PIN_DIRECTION pdWanted,
                                          BOOL bOpen, int iIndex, IPin **ppPin)
{
    DbgLog((LOG_TRACE, 4,
        TEXT("CDvdGraphBuilder::FindMatchingPin(0x%lx, 0x%lx, %s, %s, %d, 0x%lx)"),
        pFilter, dwStream, pdWanted == PINDIR_INPUT ? "In" : "Out",
        bOpen ? "T" : "F", iIndex, ppPin)) ;

    HRESULT         hr = E_FAIL ;
    IEnumPins      *pEnumPins ;
    IPin           *pPin ;
    IPin           *pPin2 ;
    PIN_DIRECTION   pdFound ;
    ULONG           ul ;

    *ppPin = NULL ;

    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Can't find a pin from NULL filter!!!"))) ;
        return E_INVALIDARG ;
    }

    EXECUTE_ASSERT(SUCCEEDED(pFilter->EnumPins(&pEnumPins))) ;
    ASSERT(pEnumPins) ;

    while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
    {
        EXECUTE_ASSERT(SUCCEEDED(pPin->QueryDirection(&pdFound))) ;
        if (pdWanted != pdFound)
        {
            pPin->Release() ;     // don't need this pin
            continue ;
        }
        HRESULT  hr1 = pPin->ConnectedTo(&pPin2) ;
        ASSERT((SUCCEEDED(hr1) && pPin2) || (FAILED(hr1) && !pPin2)) ;
        if (bOpen)   // we looking for an open pin
        {
            if (SUCCEEDED(hr1) && pPin2)  // pin already connected -- skip it
            {
                pPin2->Release() ; // not interested in this pin actually
                pPin->Release() ;  // this pin is already connected -- skip it
                continue ;         // try next one
            }
            // Otherwise we have got an open pin -- onto the mediatypes...
            // Check mediatype only if a streamtype was specified
            if (0 != dwStream  &&  dwStream != GetPinStreamType(pPin) )  // not a mediatype match
            {
                DbgLog((LOG_TRACE, 5, TEXT("Pin %s is not of stream type 0x%lx"),
                    (LPCTSTR) CDisp(pPin), dwStream)) ;
                pPin->Release() ;     // this pin is already connected -- skip it
                continue ;            // try next one
            }
        }
        else         // we looking for a connected pin
        {
            if (FAILED(hr1) || NULL == pPin2)  // pin NOT connected -- skip it
            {
                pPin->Release() ; // this pin is NOT connected -- skip it
                continue ;        // try next one
            }
            // Otherwise we have got a connected pin
            pPin2->Release() ;  // else we leak!!!

            // Check mediatype only if a streamtype was specified
            if (0 != dwStream)
            {
                AM_MEDIA_TYPE  mt ;
                pPin->ConnectionMediaType(&mt) ;
                if (dwStream != GetStreamFromMediaType(&mt))
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Pin %s is not of stream type 0x%lx"),
                        (LPCTSTR) CDisp(pPin), dwStream)) ;
                    FreeMediaType(mt) ;  // else we leak
                    pPin->Release() ;     // this pin is already connected -- skip it
                    continue ;            // try next one
                }
                FreeMediaType(mt) ;  // anyway have to free this
            }
        }
        if (0 == iIndex)
        {
            // Got the reqd pin in the right direction
            *ppPin = pPin ;
            hr = S_OK ;
            break ;
        }
        else  // some more to go
        {
            iIndex-- ;            // one more down...
            pPin->Release() ;     // this is not the pin we are looking for
        }
    }
    pEnumPins->Release() ;
    return hr ;  // whatever it is

}


DWORD CDvdGraphBuilder::GetStreamFromMediaType(AM_MEDIA_TYPE *pmt)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetStreamFromMediaType(0x%lx)"), pmt)) ;

    DWORD  dwStream = 0 ;

    // Decipher the mediatype
    if (pmt->majortype == MEDIATYPE_MPEG2_PES  ||
        pmt->majortype == MEDIATYPE_DVD_ENCRYPTED_PACK)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Mediatype is MPEG2_PES/DVD_ENCRYPTED_PACK"))) ;

        if (pmt->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_VIDEO"))) ;
            dwStream = AM_DVD_STREAM_VIDEO ;
        }
        else if (pmt->subtype == MEDIASUBTYPE_DOLBY_AC3)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is DOLBY_AC3"))) ;
            dwStream = AM_DVD_STREAM_AUDIO ;
        }
        else if (pmt->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_Subpicture"))) ;
            dwStream = AM_DVD_STREAM_SUBPIC ;
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Unknown subtype %s"),
                (LPCTSTR) CDisp(pmt->subtype))) ;
        }
    }
    else if (pmt->majortype == MEDIATYPE_Video)  // elementary stream
    {
        DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Video elementary"))) ;

        if (pmt->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_SUBPICTURE"))) ;
            dwStream = AM_DVD_STREAM_SUBPIC ;
        }
        else if (pmt->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_VIDEO"))) ;
            dwStream = AM_DVD_STREAM_VIDEO ;
        }
        else if (pmt->subtype == MEDIASUBTYPE_RGB8   ||
            pmt->subtype == MEDIASUBTYPE_RGB565 ||
            pmt->subtype == MEDIASUBTYPE_RGB555 ||
            pmt->subtype == MEDIASUBTYPE_RGB24  ||
            pmt->subtype == MEDIASUBTYPE_RGB32)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is RGB8/16/24/32"))) ;
            dwStream = AM_DVD_STREAM_VIDEO ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("Unknown subtype %s for Video -- assuming decoded video"),
                (LPCTSTR) CDisp(pmt->subtype))) ;
            dwStream = AM_DVD_STREAM_VIDEO ;
        }
    }
    else if (pmt->majortype == MEDIATYPE_Audio)  // elementary stream
    {
        DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Audio elementary"))) ;

        if (pmt->subtype == MEDIASUBTYPE_DOLBY_AC3)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is AC3"))) ;
            dwStream = AM_DVD_STREAM_AUDIO ;
        }
        if (pmt->subtype == MEDIASUBTYPE_MPEG2_AUDIO)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_AUDIO"))) ;
            dwStream = AM_DVD_STREAM_AUDIO ;
        }
        if (pmt->subtype == MEDIASUBTYPE_DVD_LPCM_AUDIO)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_LPCM Audio"))) ;
            dwStream = AM_DVD_STREAM_AUDIO ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("Unknown subtype %s for Audio -- assuming decoded audio"),
                (LPCTSTR) CDisp(pmt->subtype))) ;
            dwStream = AM_DVD_STREAM_AUDIO ;
        }
    }
    else if (pmt->majortype == MEDIATYPE_AUXLine21Data)  // line21 stream
    {
        ASSERT(pmt->subtype == MEDIASUBTYPE_Line21_GOPPacket) ; // just checking
        DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Line21 GOPPacket"))) ;
        dwStream = AM_DVD_STREAM_LINE21 ;
    }
    else if (pmt->majortype == MEDIATYPE_Stream)         // some stream format
    {
        if (pmt->subtype == MEDIASUBTYPE_Asf)  // ASF stream
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ASF stream"))) ;
            dwStream = AM_DVD_STREAM_ASF ;
        }
        else                                   // some other stream format
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is some OTHER stream format"))) ;
            dwStream = AM_DVD_STREAM_ADDITIONAL ;
        }
    }
    //
    // There is a chance that some IHV/ISV creates a private mediatype
    // (major or sub) as in the case of IBM (for CSS filter). We have to
    // search the parts of the mediatype to locate something we recognize.
    //
    else
    {
        DbgLog((LOG_TRACE, 2,
            TEXT("Unknown mediatype %s:%s. But we won't give up..."),
            (LPCTSTR) CDisp(pmt->majortype), (LPCTSTR) CDisp(pmt->subtype))) ;
        if (pmt->subtype == MEDIASUBTYPE_DOLBY_AC3 ||
            pmt->subtype == MEDIASUBTYPE_MPEG2_AUDIO ||
            pmt->subtype == MEDIASUBTYPE_DVD_LPCM_AUDIO)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Audio"))) ;
            dwStream = AM_DVD_STREAM_AUDIO ;
        }
        else if (pmt->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Video"))) ;
            dwStream = AM_DVD_STREAM_VIDEO ;
        }
        else if (pmt->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Subpicture"))) ;
            dwStream = AM_DVD_STREAM_SUBPIC ;
        }
        else
        {
            DbgLog((LOG_TRACE, 2, TEXT("WARNING: Unknown mediatype. Couldn't detect at all."))) ;
        }
    }

    return dwStream ;
}


DWORD CDvdGraphBuilder::GetPinStreamType(IPin *pPin)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetPinStreamType(%s)"),
        (LPCTSTR) CDisp(pPin))) ;

    DWORD             dwStream = 0 ;
    AM_MEDIA_TYPE    *pmt ;
    IEnumMediaTypes  *pEnumMT ;
    ULONG             ul ;

    HRESULT hr = pPin->EnumMediaTypes(&pEnumMT) ;
    ASSERT(SUCCEEDED(hr) && pEnumMT) ;
    while (0 == dwStream  &&
        S_OK == pEnumMT->Next(1, &pmt, &ul) && 1 == ul) // more mediatypes
    {
        dwStream = GetStreamFromMediaType(pmt) ;		
        DeleteMediaType(pmt) ;
    }  // end of while()

    pEnumMT->Release() ;

    return dwStream ;  // whatever we found

}


HRESULT CDvdGraphBuilder::GetFilterCLSID(IBaseFilter *pFilter, DWORD dwStream,
                                         LPCWSTR lpszwName, GUID *pClsid)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetFilterCLSID(0x%lx, 0x%lx, %S, 0x%lx)"),
        pFilter, dwStream, lpszwName, pClsid)) ;

    HRESULT          hr ;
    IEnumRegFilters *pEnumFilters ;
    REGFILTER       *pRegFilter ;
    IEnumMediaTypes *pEnumMT ;
    AM_MEDIA_TYPE    mtIn ;
    AM_MEDIA_TYPE    mtOut ;
    IPin            *pPinIn ;
    IPin            *pPinOut ;
    ULONG            ul ;
    DWORD            dw ;
    int              iPos ;
    BOOL             bInOK  = FALSE ;  // initially
    BOOL             bOutOK = FALSE ;  // initially
    BOOL             bFound = FALSE ;  // initially

    *pClsid = GUID_NULL ;  // to start with

    // First get the in and out pins' mediatypes
    iPos = 0 ;
    do {  // for Input pin
        hr = FindMatchingPin(pFilter, 0, PINDIR_INPUT, FALSE, iPos, &pPinIn) ;   // want connected in pin
        if (FAILED(hr) || NULL == pPinIn)
        {
            DbgLog((LOG_TRACE, 3,
                TEXT("No connected In pin #%d for intermediate filter %S"),
                iPos, lpszwName)) ;
            return E_UNEXPECTED ;  // no point trying anymore
        }
        pPinIn->ConnectionMediaType(&mtIn) ;
        dw = GetStreamFromMediaType(&mtIn) ;
        if (dwStream != dw)
        {
            DbgLog((LOG_TRACE, 3, TEXT("In pin %s is of stream type 0x%lx; looking for 0x%lx"),
                (LPCTSTR) CDisp(pPinIn), dw, dwStream)) ;
            FreeMediaType(mtIn) ;
        }
        else
        {
            DbgLog((LOG_TRACE, 3, TEXT("In pin %s matches required stream type 0x%lx"),
                (LPCTSTR) CDisp(pPinIn), dwStream)) ;
            bInOK = TRUE ;
        }

        pPinIn->Release() ;  // don't need it anymore
        iPos++ ;             // try the next pin
    } while (!bInOK) ;
    // If we come here, we must have got a matching connected input pin

    iPos = 0 ;
    do {  // for Output pin
        hr = FindMatchingPin(pFilter, 0, PINDIR_OUTPUT, FALSE, iPos, &pPinOut) ; // want connected out pin
        if (FAILED(hr) || NULL == pPinOut)
        {
            DbgLog((LOG_TRACE, 3,
                TEXT("No connected Out pin #%d for intermediate filter %S"),
                iPos, lpszwName)) ;
            FreeMediaType(mtIn) ;  // else we leak!!!
            return E_UNEXPECTED ;  // no point trying anymore
        }
        pPinOut->ConnectionMediaType(&mtOut) ;
        dw = GetStreamFromMediaType(&mtOut) ;
        if (dwStream != dw)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Out pin %s is of stream type 0x%lx; looking for 0x%lx"),
                (LPCTSTR) CDisp(pPinOut), dw, dwStream)) ;
            FreeMediaType(mtOut) ;
        }
        else
        {
            DbgLog((LOG_TRACE, 3, TEXT("Out pin %s matches required stream type 0x%lx"),
                (LPCTSTR) CDisp(pPinOut), dwStream)) ;
            bOutOK = TRUE ;
        }

        pPinOut->Release() ;  // don't need it anymore
        iPos++ ;              // try the next pin
    } while (!bOutOK) ;
    // If we come here, we must have got a matching connected output pin

    // Get the filter enumerator based on the in and out mediatypes
    hr = m_pMapper->EnumMatchingFilters(&pEnumFilters, MERIT_DO_NOT_USE+1,
        TRUE, mtIn.majortype, mtIn.subtype,
        FALSE, TRUE, mtOut.majortype, mtOut.subtype) ;
    if (FAILED(hr) || NULL == pEnumFilters)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ERROR: No matching filter enum found (Error 0x%lx)"), hr)) ;
        FreeMediaType(mtIn) ;
        FreeMediaType(mtOut) ;
        return E_UNEXPECTED ;
    }

    // Now pick the right filter (we only have the "Name" to do the matching)
    while (! bFound  &&
        S_OK == pEnumFilters->Next(1, &pRegFilter, &ul)  &&  1 == ul)
    {
        if (0 == lstrcmpW(pRegFilter->Name, lpszwName))  // we got a match!!!
        {
            DbgLog((LOG_TRACE, 3, TEXT("Found a matching registered filter for %S"), lpszwName)) ;
            *pClsid = pRegFilter->Clsid ;
            bFound = TRUE ;
        }
        CoTaskMemFree(pRegFilter) ;  // done with this filter's info
    }

    // Now release everything (whether we got anything or not)
    pEnumFilters->Release() ;
    FreeMediaType(mtIn) ;
    FreeMediaType(mtOut) ;

    return bFound ? S_OK : E_FAIL ;
}


HRESULT CDvdGraphBuilder::RenderIntermediateOutPin(IBaseFilter *pFilter, DWORD dwStream,
                                                   AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderIntermediateOutPin(0x%lx, 0x%lx, 0x%lx)"),
        pFilter, dwStream, pStatus)) ;

    HRESULT   hr ;
    IPin     *pPinOut ;
    IPin     *apPinOutDec[MAX_DEC_OUT_PINS + 1] ;  // 1 for terminating NULL
    IPin     *pPinIn ;
    ULONG     ul ;
    DWORD     dwDecFlag ;
    HRESULT   hrFinal = S_OK ;
    BOOL      bConnected ;

    while (SUCCEEDED(hr = FindMatchingPin(pFilter, dwStream, PINDIR_OUTPUT, TRUE, 0, &pPinOut)))
    {
        DbgLog((LOG_TRACE, 3, TEXT("Open out pin %s found on intermediate filter"),
            (LPCTSTR) CDisp(pPinOut))) ;

        ResetPinInterface(apPinOutDec, NUMELMS(apPinOutDec)) ; // set i/f ptrs to NULL
        dwDecFlag = AM_DVD_SWDEC_PREFER ;  // we intentionally prefer SWDEC here

        hr = DecodeDVDStream(pPinOut, dwStream, &dwDecFlag, pStatus, apPinOutDec) ;
        if (SUCCEEDED(hr) && apPinOutDec[0])  // first element is good enough
        {
            DbgLog((LOG_TRACE, 3, TEXT("Out pin %s is %s decoded (to out pin %s) (stream 0x%lx)"),
                (LPCTSTR) CDisp(pPinOut), AM_DVD_SWDEC_ONLY == dwDecFlag ? TEXT("SW") : TEXT("HW"),
                (LPCTSTR) CDisp(apPinOutDec[0]), dwStream)) ;
            switch (dwStream)
            {
            case AM_DVD_STREAM_VIDEO:
                DbgLog((LOG_TRACE, 5, TEXT("Going to render intermediate filter's additional 'Video' stream"))) ;
                // So far I don't know of anyone coming here.  But IBM's stuff
                // goes to the audio case. So I am not ignoring the video case,
                // just in case someone is that much insane!!!
                //
                // Only if we have been able to render primary video...
                if (0 == (pStatus->dwFailedStreamsFlag & AM_DVD_STREAM_VIDEO))
                {
                    pPinIn = NULL ;
                    hr = E_FAIL ;  // assume we'll fail
                    if (m_pOvM)       // ... using OvMixer
                    {
                        hr = FindMatchingPin(m_pOvM, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
                    }
                    else if (m_pVMR)  // ... using VMR
                    {
                        hr = FindMatchingPin(m_pVMR, 0, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
                    }
                    // ASSERT(SUCCEEDED(hr) && pPinIn) ;
                    if (SUCCEEDED(hr) && pPinIn)
                    {
                        bConnected = FALSE ;  // reset flag every time
                        int  i = 0 ;
                        while (!bConnected  &&  i < MAX_DEC_OUT_PINS  &&  apPinOutDec[i])
                        {
                            hr = ConnectPins(apPinOutDec[i], pPinIn, AM_DVD_CONNECT_DIRECTFIRST) ;
                            if (FAILED(hr))  // what?!?
                            {
                                DbgLog((LOG_TRACE, 1, TEXT("Pin %s (#%ld) did NOT connect to pin %s"),
                                    (LPCTSTR)CDisp(apPinOutDec[i]), i, (LPCTSTR)CDisp(pPinIn))) ;
                                i++ ;
                                ASSERT(i <= MAX_DEC_OUT_PINS) ;
                            }
                            else
                            {
                                DbgLog((LOG_TRACE, 5, TEXT("Pin %s connected to pin %s"),
                                    (LPCTSTR)CDisp(apPinOutDec[i]), (LPCTSTR)CDisp(pPinIn))) ;
                                // Intentionally ignoring any intermediate filters coming in here -- I am tired
                                // EnumFiltersBetweenPins(dwStream, pPinOut, pPinIn, pStatus) ;
                                bConnected = TRUE ;
                            }
                        }  // end of while (!bConnected ...)

                        if (!bConnected)
                        {
                            DbgLog((LOG_TRACE, 3, TEXT("Couldn't connect any of the %d intermediate video out pins"), i)) ;
                            hrFinal = hr ;  // last error is good enough
                        }
                        pPinIn->Release() ;  // done with the pin
                    }
                }  // end of if (0 == (pStatus->dwFailedStreamsFlag ...))
                else
                {
                    ASSERT(FALSE) ;  // so that we know about it
                    DbgLog((LOG_TRACE, 5, TEXT("OvM/VMR is not usable. Will skip rendering this stream."))) ;
                    hrFinal = E_UNEXPECTED ;
                }
                break ;

            case AM_DVD_STREAM_AUDIO:
                DbgLog((LOG_TRACE, 5, TEXT("Going to render intermediate filter's additional 'Audio' stream"))) ;
                hr = RenderDecodedAudio(apPinOutDec, pStatus) ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Couldn't connect the intermediate audio out pin"))) ;
                    hrFinal = hr ;
                }
                else
                    DbgLog((LOG_TRACE, 5, TEXT("XXX's SW AC3 must have been rendered now"))) ; // XXX = IBM
                break ;

            case AM_DVD_STREAM_SUBPIC:
                DbgLog((LOG_TRACE, 5, TEXT("Skip rendering intermediate filter's additional 'Subpicture' stream"))) ;
                // hr = RenderDecodedSubpic(apPinOutDec, pStatus) ;
                ASSERT(FALSE) ;  // not expected here at all
                break ;

            case AM_DVD_STREAM_LINE21:
                DbgLog((LOG_TRACE, 5, TEXT("Skip rendering intermediate filter's additional 'CC' stream"))) ;
                // hr = RenderLine21Stream(apPinOutDec[0], pStatus) ;  -- hopefully only one L21 out pin
                ASSERT(FALSE) ;  // not expected here at all
                break ;
            }  // end of switch()

            ReleasePinInterface(apPinOutDec) ;  // done with the decoded out pin(s)
        }  // end of if (SUCCEEDED(hr) && apPinOutDec[0])
        else
            DbgLog((LOG_TRACE, 1, TEXT("Intermediate out pin %s could NOT decoded (stream 0x%lx)"),
            (LPCTSTR) CDisp(pPinOut), dwStream)) ;

        pPinOut->Release() ;  // done with the pin
    }  // end of while ()

    return hrFinal ;
}


HRESULT CDvdGraphBuilder::EnumFiltersBetweenPins(DWORD dwStream, IPin *pPinOut, IPin *pPinIn,
                                                 AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::EnumFiltersBetweenPins(0x%lx, Out=%s, In=%s, 0x%lx)"),
        dwStream, (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn), pStatus)) ;

    if (NULL == pPinOut || NULL == pPinIn)  // what!!!
        return E_UNEXPECTED ;

    GUID         Clsid ;
    int          iCount = 0 ;
    PIN_INFO     pi ;
    FILTER_INFO  fi ;
    IEnumPins   *pEnumPins ;
    IBaseFilter *pFilter  = NULL ;
    IPin        *pPinIn2  = NULL ;  // init so that we don't have junk
    IPin        *pPinOut2 = NULL ;  // init so that we don't have junk
    HRESULT  hr = pPinIn->ConnectedTo(&pPinOut2) ;
    while (SUCCEEDED(hr)  &&  pPinOut2  &&  !IsEqualObject(pPinOut, pPinOut2))
    {
        pPinOut2->QueryPinInfo(&pi) ;
        pFilter = pi.pFilter ;
        ASSERT(pFilter && PINDIR_OUTPUT == pi.dir) ;
        //
        // We intentionally keep the extra ref count because this is an intermediate
        // filter and other intermediate filters picked up through registry based
        // filter enum (for SW decoding case) will have the extra ref count.  We
        // release the IBaseFilter interface pointer in CListFilters::ClearList() or
        // CListFilters::RemoveAllFromGraph() and if we don't keep this extra ref
        // count here, we'll fault.  On the other hand we must do Release() on
        // CListFilters elements, because SW enum-ed filters will not otherwise be
        // unloaded.
        //
        // if (pi.pFilter)
        //     pi.pFilter->Release() ;  // it has an extra ref count from QueryPinInfo()

        pFilter->QueryFilterInfo(&fi) ;
        if (! m_ListFilters.IsInList(pFilter) )  // not yet in list
        {
            hr = GetFilterCLSID(pFilter, dwStream, fi.achName, &Clsid) ;
            ASSERT(SUCCEEDED(hr)) ;
            m_ListFilters.AddFilter(pFilter, NULL /* fi.achName */, &Clsid) ;  // presumably it's a SW filter
            DbgLog((LOG_TRACE, 5, TEXT("Intermediate filter %S added to our list"), fi.achName)) ;
        }
        else
            DbgLog((LOG_TRACE, 5, TEXT("Intermediate filter %S is already in our list"), fi.achName)) ;

        fi.pGraph->Release() ; // else we leak!!
        pPinOut2->Release() ;  // done with the pin for now
        pPinOut2 = NULL ;
        iCount++ ;

        // Check for any open out pin on the intermediate filter. We may find
        // one such on IBM's CSS filter for the SW AC3 decoder.
        hr = RenderIntermediateOutPin(pFilter, dwStream, pStatus) ;
        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE, 3,
                TEXT("Failed to render intermediate filter's open out pin of type 0x%lx (Error 0x%lx)"),
                dwStream, hr)) ;
            ASSERT(FALSE) ;  // so that we know of this weird case
        }

        // Now get the (stream-matching) input pin of this filter to traverse the chain
        hr = FindMatchingPin(pFilter, dwStream, PINDIR_INPUT, FALSE, 0, &pPinIn2) ; // want connected pin
        if (FAILED(hr) || NULL == pPinIn2)
        {
            DbgLog((LOG_ERROR, 1, TEXT("Filter %S does NOT have any connected pin of type 0x%lx"),
                fi.achName, dwStream)) ;
            ASSERT(pPinIn2) ;
            DbgLog((LOG_TRACE, 5, TEXT("(Incomplete) %d filter(s) found between pin %s and pin %s"),
                iCount, (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
            return hr ;  // we are hopefully not leaking anything
        }

        hr = pPinIn2->ConnectedTo(&pPinOut2) ;
        pPinIn2->Release() ; // done with this in pin
    }  // end of while () loop
    if (pPinOut2)              // if valid IPin interface
        pPinOut2->Release() ;  // release it

    DbgLog((LOG_TRACE, 5, TEXT("Total %d filter(s) found between pin %s and pin %s"),
        iCount, (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
    return S_OK ;  // successfuly done
}


void CDvdGraphBuilder::CheckDDrawExclMode(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CheckDDrawExclMode()"))) ;

    HRESULT  hr ;

#if 0
    hr = EnsureOverlayMixerExists() ;
    if (FAILED(hr))
    {
        return ;
    }
    ASSERT(m_pOvM) ;
#endif // #if 0

    // If OvMixer has already been created, it's most probably by a query for
    // the DDraw (non-)exclusive mode interfaces. Otherwise the app doesn't
    // want to use those interfaces, and hence it does NOT need OvMixer.
    if (NULL == m_pOvM)
    {
        DbgLog((LOG_TRACE, 5,
            TEXT("CheckDDrawExclMode(): OverlayMixer does NOT exist => no excl mode."))) ;
        m_bDDrawExclMode = FALSE ;
        return ;
    }

    // Get the IDDrawExclModeVideo interface
    IDDrawExclModeVideo  *pDDXMV ;
    hr = m_pOvM->QueryInterface(IID_IDDrawExclModeVideo, (LPVOID *) &pDDXMV) ;
    if (FAILED(hr) || NULL == pDDXMV)
    {
        DbgLog((LOG_ERROR, 1,
            TEXT("WARNING: Can't get IDDrawExclModeVideo on OverlayMixer (Error 0x%lx)"), hr)) ;
        return ;
    }

    // Get the DDraw object and surface info from OverlayMixer (and release too)
    IDirectDraw          *pDDObj ;
    IDirectDrawSurface   *pDDSurface ;
    BOOL                  bExtDDObj ;
    BOOL                  bExtDDSurface ;
    hr = pDDXMV->GetDDrawObject(&pDDObj, &bExtDDObj) ;
    ASSERT(SUCCEEDED(hr)) ;
    hr = pDDXMV->GetDDrawSurface(&pDDSurface, &bExtDDSurface) ;
    ASSERT(SUCCEEDED(hr)) ;
    if (pDDObj)
        pDDObj->Release() ;
    if (pDDSurface)
        pDDSurface->Release() ;
    pDDXMV->Release() ;  // release before returning

    // Both true means we are really in excl mode
    m_bDDrawExclMode = bExtDDObj && bExtDDSurface ;
}


IPin * CDvdGraphBuilder::GetFilterForMediaType(DWORD dwStream, AM_MEDIA_TYPE *pmt, IBaseFilter *pOutFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetFilterForMediaType(0x%lx, 0x%lx, 0x%lx)"),
        dwStream, pmt, pOutFilter)) ;

    IBaseFilter *pInFilter ;
    IPin        *pPinIn ;
    LPWSTR       lpszwName ;
    HRESULT      hr ;

    for (int i = 0 ; i < m_ListFilters.GetCount() ; i++)
    {
        // I could have checked if the filter from list is a HW filter, but I decided not to.

        m_ListFilters.GetFilter(i, &pInFilter, &lpszwName) ;
        // Don't want to connect to the out pin's filter's in pin (cyclic graph)
        if (pOutFilter  &&  IsEqualObject(pOutFilter, pInFilter))
            continue ;

        hr = FindMatchingPin(pInFilter, dwStream, PINDIR_INPUT, TRUE, 0, &pPinIn) ;
        if (SUCCEEDED(hr)  &&  pPinIn)
        {
            hr = pPinIn->QueryAccept(pmt) ;
            if (SUCCEEDED(hr))   // input pin seems to accept mediatype
            {
                DbgLog((LOG_TRACE, 5, TEXT("Input pin %s of type %d matches mediatype"),
                    (LPCTSTR)CDisp(pPinIn), dwStream)) ;
                return pPinIn ;  // return matching in pin
            }

            // Otherwise not a matching mediatype -- skip this one.
            DbgLog((LOG_TRACE, 5, TEXT("Input pin %s of type %d didn't like mediatype"),
                (LPCTSTR)CDisp(pPinIn), dwStream)) ;
            pPinIn->Release() ;
            pPinIn = NULL ;
        }
        else
            DbgLog((LOG_TRACE, 5, TEXT("No open input pin of type %d found on %S"),
            dwStream, lpszwName)) ;
    }  // end of for (i)

    return NULL ;  // didn't match any
}




// ---------------------------------------------
//  Implementation of the CListFilters class...
// ---------------------------------------------

CListFilters::CListFilters(int iMax /* = FILTERLIST_DEFAULT_MAX*/ ,
                           int iInc /* = FILTERLIST_DEFAULT_INC */)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::CListFilters(%d, %d)"), iMax, iInc)) ;

    m_iCount   = 0 ;
    m_iMax     = iMax ;
    m_iInc     = iInc ;
    m_pGraph   = NULL ;
    m_pFilters = new CFilterData [m_iMax] ;
    ASSERT(m_pFilters) ;
}


CListFilters::~CListFilters(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::~CListFilters()"))) ;

    if (m_pFilters)
        delete [] m_pFilters ;
    m_iCount   = 0 ;
}


void CListFilters::RemoveAllFromGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::RemoveAllFromGraph()"))) ;

    IBaseFilter  *pFilter ;
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (pFilter = m_pFilters[i].GetInterface())
        {
#ifdef DEBUG
            FILTER_INFO  fi ;
            pFilter->QueryFilterInfo(&fi) ;
            DbgLog((LOG_TRACE, 5, TEXT("Removing filter %S..."), fi.achName)) ;
            if (fi.pGraph)
                fi.pGraph->Release() ;
#endif // DEBUG

            EXECUTE_ASSERT(SUCCEEDED(m_pGraph->RemoveFilter(pFilter))) ;
            // pFilter->Release() ;  -- done in ResetElement() below
            m_pFilters[i].ResetElement() ;
        }
    }
    m_iCount = 0 ;
    m_pGraph = NULL ;  // no filter in list, why have the graph??
}


BOOL CListFilters::AddFilter(IBaseFilter *pFilter, LPCWSTR lpszwName, GUID *pClsid)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::AddFilter(0x%lx, %S, 0x%lx)"),
        pFilter, lpszwName ? lpszwName : L"NULL", pClsid)) ;

    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Internal Error: NULL pFilter param passed to AddFilter()"))) ;
        return FALSE ;
    }
    if (m_iCount >= m_iMax)
    {
        if (! ExpandList() )  // couldn't expand list
        {
            DbgLog((LOG_ERROR, 1, TEXT("INTERNAL ERROR: Too many filters added to CListFilters"))) ;
            return FALSE ;
        }
        DbgLog((LOG_TRACE, 5, TEXT("CListFilters list has been extended"))) ;
    }

    m_pFilters[m_iCount].SetElement(pFilter, lpszwName, pClsid) ;
    m_iCount++ ;

    return TRUE ;
}


BOOL CListFilters::GetFilter(int iIndex, IBaseFilter **ppFilter, LPWSTR *lpszwName)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::GetFilter(%d, 0x%lx, 0x%lx)"),
        iIndex, ppFilter, lpszwName)) ;

    if (iIndex > m_iCount)
    {
        DbgLog((LOG_ERROR, 1,
            TEXT("INTERNAL ERROR: Bad index (%d) for CListDecoders::GetFilter()"), iIndex)) ;
        *ppFilter = NULL ;
        return FALSE ;
    }

    *ppFilter = m_pFilters[iIndex].GetInterface() ;
    *lpszwName = m_pFilters[iIndex].GetName() ;
    return TRUE ;
}


BOOL CListFilters::GetFilter(GUID *pClsid, int iIndex, IBaseFilter **ppFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::GetFilter(0x%lx, %d, 0x%lx)"),
        pClsid, iIndex, ppFilter)) ;

    GUID  *pFilterClsid ;
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if ((pFilterClsid = m_pFilters[i].GetClsid())  &&
            IsEqualGUID(*pClsid, *pFilterClsid))
        {
            if (0 == iIndex)
            {
                *ppFilter = m_pFilters[i].GetInterface() ;
                return TRUE ;
            }
            else  // skip this one -- we want a later one
                iIndex-- ;
        }
    }

    *ppFilter = NULL ;
    return FALSE ;
}


BOOL CListFilters::IsInList(IBaseFilter *pFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::IsInList(0x%lx)"), pFilter)) ;

    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (IsEqualObject(pFilter, m_pFilters[i].GetInterface()))
            return TRUE ;
    }

    return FALSE ;  // didn't match any
}


void CListFilters::ClearList(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListFilters::ClearList()"))) ;

    for (int i = 0 ; i < m_iCount ; i++)
    {
#ifdef DEBUG
        FILTER_INFO  fi ;
        m_pFilters[i].GetInterface()->QueryFilterInfo(&fi) ;
        DbgLog((LOG_TRACE, 5, TEXT("Removing filter %S..."), fi.achName)) ;
        if (fi.pGraph)
            fi.pGraph->Release() ;
#endif // DEBUG

        m_pFilters[i].ResetElement() ;
    }
    m_iCount = 0 ;
}


BOOL CListFilters::ExpandList(void)
{
    return FALSE ;   // not implemented for now
}




// -------------------------------------
//  CFilterData class implementation...
// -------------------------------------

CFilterData::CFilterData(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CFilterData::CFilterData()"))) ;

    m_pFilter   = NULL ;
    m_lpszwName = NULL ;
    m_pClsid    = NULL ;
}


CFilterData::~CFilterData(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CFilterData::~CFilterData()"))) ;

    ResetElement() ;
}


void CFilterData::SetElement(IBaseFilter *pFilter, LPCWSTR lpszwName, GUID *pClsid)
{
    DbgLog((LOG_TRACE, 4, TEXT("CFilterData::SetElement(0x%lx, 0x%lx, 0x%lx)"),
        pFilter, lpszwName, pClsid)) ;

    m_pFilter = pFilter ;  // should we AddRef() too?
    if (lpszwName)
    {
        m_lpszwName = new WCHAR [sizeof(WCHAR) * (lstrlenW(lpszwName) + 1)] ;
        ASSERT(m_lpszwName) ;
        if (NULL == m_lpszwName)    // bad situation...
            return ;                // ...just bail out
        lstrcpyW(m_lpszwName, lpszwName) ;
    }

    if (pClsid)
    {
        m_pClsid = (GUID *) new BYTE[sizeof(GUID)] ;
        ASSERT(m_pClsid) ;
        if (NULL == m_pClsid)       // bad situation...
            return ;                // ...just bail out
        *m_pClsid = *pClsid ;
    }
}


void CFilterData::ResetElement(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CFilterData::ResetElement()"))) ;

    LONG         l ;

    if (m_pFilter)
    {
        l = m_pFilter->Release() ;
        DbgLog((LOG_TRACE, 3, TEXT("post Release() ref count is %ld"), l)) ;
        m_pFilter = NULL ;
    }
    if (m_lpszwName)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Filter %S has just been released"), m_lpszwName)) ;
        delete [] m_lpszwName ;
        m_lpszwName = NULL ;
    }
    if (m_pClsid)
    {
        delete [] ((BYTE *) m_pClsid) ;
        m_pClsid = NULL ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dvdgb2\dvdgb2.h ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// A class managing list of HW and/or SW decoders used to build the DVD
// playback graph.
//
#define DECLIST_MAX        10
#define DECLIST_NOTFOUND  -1

class CListDecoders {

    public:  // class interface

        CListDecoders() ;
        ~CListDecoders() ;

        BOOL AddFilter(IBaseFilter *pFilter, LPTSTR lpszName, BOOL bHW, GUID *pClsid) ;
        BOOL GetFilter(int i, IBaseFilter **ppFilter, LPTSTR *lpszName, BOOL *pbHW) ;
        void CleanAll(void) ;
        void FreeAllMem(void) ;
        int  GetNumFilters(void)   { return m_iCount ; } ;
        int  GetNumSWFilters(void) { return m_iCount - m_iHWCount ; } ;
        int  GetNumHWFilters(void) { return m_iHWCount ; } ;
        int  GetList(IBaseFilter **ppFilter) ;
        int  IsInList(BOOL bHW, LPVOID pDec) ;

    private:  // internal data

        int             m_iCount ;
        int             m_iHWCount ;
        IBaseFilter    *m_apFilters[DECLIST_MAX] ;
        LPTSTR          m_alpszName[DECLIST_MAX] ;
        BOOL            m_abIsHW[DECLIST_MAX] ;
        GUID           *m_apClsid[DECLIST_MAX] ;

} ;


//
// List of intermediate filters, if any (like IBM CSS), used between DVD Nav and decoder(s)
//
#define MAX_INT_FILTERS    3

class CListIntFilters {

    public:  // class interface

        CListIntFilters() ;
        ~CListIntFilters() ;

        BOOL AddFilter(IBaseFilter *pFilter) ;
        void CleanAll(void) ;
        void RemoveAll(void) ;
        int  GetCount(void)   { return m_iCount ; } ;
        BOOL IsInList(IBaseFilter *pFilter) ;
        IBaseFilter * GetFilter(int i) {
            if (i > m_iCount)
            {
                ASSERT(FALSE) ;
                return NULL ;
            }
            return m_apFilters[i] ;
        } ;
        int GetNumInPin(IBaseFilter *pFilter) ;
        int GetNumOutPin(IBaseFilter *pFilter) ;

    private:  // internal data

        int             m_iCount ;
        IBaseFilter    *m_apFilters[MAX_INT_FILTERS] ;
        int             m_aNumInPins[MAX_INT_FILTERS] ;
        int             m_aNumOutPins[MAX_INT_FILTERS] ;

} ;


//
// An internally defined stream flag to check line21 data rendering.
// Leave enough space for future stream flags.
//
#define AM_DVD_STREAM_LINE21  0x80


//
// A set of (internal) flags to track the status of decoded video rendering
//
#define VIDEO_RENDER_NONE     0
#define VIDEO_RENDER_FAILED   1
#define VIDEO_RENDER_VR       2
#define VIDEO_RENDER_MIXER    4


//
// The actual class object implementing IDvdGraphBuilder interface
//
class CDvdGraphBuilder : public CUnknown, public IDvdGraphBuilder2
{

    public:  // methods

        CDvdGraphBuilder(TCHAR *, LPUNKNOWN, HRESULT *) ;
        ~CDvdGraphBuilder() ;

        DECLARE_IUNKNOWN

        // this goes in the factory template table to create new instances
        static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *) ;
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv) ;

        // IDvdGraphBuilder stuff
        STDMETHODIMP GetFiltergraph(IGraphBuilder **ppGB) ;
        STDMETHODIMP GetDvdInterface(REFIID riid, void **ppvIF) ;
        STDMETHODIMP RenderDvdVideoVolume(LPCWSTR lpcwszPathName, DWORD dwFlags,
                                          AM_DVD_RENDERSTATUS *pStatus) ;
        STDMETHODIMP SetFiltergraph(IGraphBuilder *pGB) ;
	    STDMETHODIMP SetDDrawObject(IDirectDraw *pDDrawObject) ;
	    STDMETHODIMP SetDDrawSurface(IDirectDrawSurface *pDDrawSurface) ;
	    STDMETHODIMP GetVideoSize(DWORD *pdwWidth, DWORD *pdwHeight) ;
	    STDMETHODIMP SetVideoRegion(RECT *pSrcRect, RECT *pDestRect) ;
	    STDMETHODIMP GetMixerPinInterface(DWORD dwPinNum, REFIID riid, void **ppvIF) ;

    private:  // internal helper methods

        HRESULT EnsureGraphExists(void) ;
        HRESULT CreateGraph(void) ;
        HRESULT DeleteGraph(void) ;
        HRESULT ClearGraph(void) ;
        void    StopGraph(void) ;
        HRESULT RemoveAllFilters(void) ;
        BOOL    CheckPinMediaTypeMatch(IPin *pPinIn, DWORD dwStreamFlag) ;
        IBaseFilter * GetFilterBetweenPins(IPin *pPinOut, IPin *pPinIn) ;
        BOOL    StartDecAndConnect(IPin *pPinOut, IFilterMapper *pMapper, 
                                   AM_MEDIA_TYPE *pmt) ;
        HRESULT ConnectSrcToHWDec(IBaseFilter *pSrc, 
                                  CListDecoders *pHWDecList, 
                                  AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT ConnectSrcToSWDec(IBaseFilter *pSrc, 
                                  AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT CreateFilterInGraph(CLSID Clsid,
                                    LPCTSTR lpszFilterName, 
                                    IBaseFilter **ppFilter) ;
        HRESULT TryConnect(IPin *pPinOut, IBaseFilter *pFilter,
                           CMediaType *pmt, BOOL bDirect) ;
        HRESULT FindOpenPin(IBaseFilter *pFilter, PIN_DIRECTION pd, 
                            int iIndex, IPin **ppPin) ;
        HRESULT CreateDVDHWDecoders(CListDecoders *pHWDecList) ;
        HRESULT MakeGraphHW(BOOL bHWOnly, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT MakeGraphSW(BOOL bSWOnly, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT CheckSrcPinConnection(IBaseFilter *pSrc, 
                                      AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderDecoderOutput(AM_DVD_RENDERSTATUS *pStatus) ;
		HRESULT RenderAudioOutPin(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
		HRESULT ConnectLine21OutPin(IPin *pPinOut) ;
		void    RenderUnknownPin(IPin *pPinOut) ;
        HRESULT RenderHWOutPin(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RenderSWOutPin(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT CompleteLateRender(AM_DVD_RENDERSTATUS *pStatus) ;
        HRESULT RemoveUnusedFilters(AM_DVD_RENDERSTATUS *pStatus) ;
        BOOL    RemoveFilterIfUnused(IBaseFilter *pFilter, LPCTSTR lpszFilterName) ;
        DWORD   StreamFlagFromSWPin(IPin *pPinOut) ;
		DWORD   StreamFlagForHWPin(IPin *pPin) ;
        DWORD   GetStreamFromMediaType(IPin *pPin) ;
        DWORD   GetInTypeForVideoOutPin(IPin *pPinOut) ;

    private:  // internal data

        IGraphBuilder *m_pGB ;        // the filter graph we are using
        CListDecoders  m_Decoders ;   // list of HW abd SW decoder filters
        IBaseFilter   *m_pDVDSrc ;    // non-default DVD source specified
        IBaseFilter   *m_pDVDNav ;    // our default DVD source -- DVD Nav
        IBaseFilter   *m_pVM ;        // VideoMixer filter
        IBaseFilter   *m_pVR ;        // Video Renderer filter (main)
        IBaseFilter   *m_pAR ;        // Audio Renderer filter
        IBaseFilter   *m_pL21Dec ;    // Line21 decoder filter

        CListIntFilters m_IntFilters ; // Intermediate filter(s) between Nav pin(s) -> Decoder(s)
        BOOL           m_bGraphDone ;  // has DVD graph been already built?
        BOOL           m_bUseVPE ;     // user wants to use VPE output?
        WCHAR          m_achwPathName[MAX_PATH] ;  // volume path name

        // The following two members help us doing rendering of CC after video
        DWORD          m_dwVideoRenderStatus ; // status of video pin rendering
        IPin          *m_pL21PinToRender ; // L21Dec out pin to be rendered after video pin
        IPin          *m_pSPPinToRender ;  // SubPic out pin to be rendered after video pin

        // App specified optional DDraw params that may be used for graph building
        IDirectDraw   *m_pDDrawObject ;         // DDraw object to be shared
        IDirectDrawSurface *m_pDDrawSurface ;   // DDraw surface to show video on
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\h\buildcb.h ===
#ifndef __IAMGraphBuildCB_PRIV_INTERFACE_DEFINED__
#define __IAMGraphBuildCB_PRIV_INTERFACE_DEFINED__

// Internal interface for WMP as we don't have time to do a complete
// graph building solution. Gives WMP a chance to configure filters
// before a connection is attempted.
//
// if this interface is supported by the site passed in to the graph
// via IObjectWithSite::SetSite, the graph will call back with each
// filter it creates as part of the Render or Connect process. Does
// not call back for source filters. Filter may be discarded and not
// used in graph or may be connected and disconnected more than once
//
// The callback occurs with the graph lock held, so do not call into
// the graph again and do not wait on other threads calling into the
// graph.
// 

MIDL_INTERFACE("4995f511-9ddb-4f12-bd3b-f04611807b79")
    IAMGraphBuildCB_PRIV : public IUnknown
{
 public:
    // graph builder selected a filter to create and attempt to
    // connect. failure indicates filter should be rejected.
    virtual HRESULT STDMETHODCALLTYPE SelectedFilter( 
        /* [in] */ IMoniker *pMon) = 0;

    // app configures filter during this call. failure indicates
    // filter should be rejected.
    virtual HRESULT STDMETHODCALLTYPE CreatedFilter( 
        /* [in] */ IBaseFilter *pFil) = 0;
};
    

#endif 	/* __IAMGraphBuildCB_PRIV_INTERFACE_DEFINED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\h\callback.h ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.

#ifndef __CALLBACK_H__
#define __CALLBACK_H__


// Definition of a class that provides asynchronous callbacks at a specific
// reference time.
//
// Objects that do not normally have a worker thread would use this to create
// a worker thread on demand for those occasions when it needs to trigger
// an asynchronous event, or when it wants several pieces to share the
// same worker thread in a controlled way.
//
// Callbacks are synchronised with the caller's critsec (passed in) so that
// cancellation and shutdown can be handled cleanly.
// The critsec passed in will be held across all advise calls and when handling
// the list of advises.
//
// It should not be held during a call to the destructor.

// Simplistic design is based the assumption that there will rarely be more
// than one or two advises on the list.

// Periodic callbacks are supported

// your callback function looks like this
typedef void (*CCallbackAdvise)(DWORD_PTR dwUserToken);



class CCallbackThread
{

public:
    CCallbackThread(CCritSec* pCritSec);
    ~CCallbackThread();

    // please call fnAdvise(dwUserToken) at time rtCallback.
    //
    // Returns:
    // HRESULT == Success
    //              pdwToken will be filled in with the token to pass to Cancel
    //         == FAILURE
    //              pdwToken is unchanged
    HRESULT Advise(
        CCallbackAdvise fnAdvise,
        DWORD_PTR dwUserToken,
        REFERENCE_TIME rtCallbackAt,
        DWORD_PTR* pdwToken
        );

    // please call fnAdvise(dwUserToken) every rtPeriod, or when
    // hEvent is signalled.  (hEvent is optional)
    //
    // WARNING: ONLY one user specified event handle can be active
    // at one time.  Subsequent calls to AdvisePeriodicWithEvent passing a
    // a hEvent will result in E_FAIL while the previous advise with an
    // hEvent is active.  THIS IS AN IMPLEMENTATION RESTRICTION which
    // may be lifted in future.
    //
    // If you do not want to use hEvent, pass NULL.
    //
    // Returns:
    // HRESULT == Success
    //              pdwToken will be filled in with the token to pass to Cancel
    //         == FAILURE
    //              pdwToken is unchanged

    HRESULT AdvisePeriodicWithEvent(
        CCallbackAdvise fnAdvise,
        DWORD_PTR dwUserToken,
        REFERENCE_TIME rtPeriod,
        HANDLE hEvent,
        DWORD_PTR* pdwToken
        );

    HRESULT ServiceClockSchedule(
        CBaseReferenceClock * pClock,
        CAMSchedule * pSchedule,
        DWORD * pdwToken
        );

    // cancel the requested callback. dwToken is a token
    // returned from Advise or AdvisePeriodicWithEvent
    HRESULT Cancel(DWORD_PTR dwToken);

    // pass in the clock to be used. Must call SetSyncSource(NULL) before
    // the clock object goes away (this is a weak reference)
    HRESULT SetSyncSource(IReferenceClock*);

    void CancelAllAdvises();

protected:
    HANDLE m_hThread;
    CCritSec* m_pCritSec;
    CAMEvent m_evSignalThread;
    BOOL     m_fAbort;
    CAMEvent m_evAdvise;
    IReferenceClock* m_pClock;
    DWORD_PTR m_dwAdvise;

    // some special members to deal with timeGetTime (TGT) periodic event.
    DWORD   m_dwTGTCallbackToken ;  // token used to identify TGT callback
    DWORD_PTR m_dwTGTUserToken ;      // token passed in by app.
    DWORD   m_dwNextTGTCallback ;   // next callback time for TGT.
    DWORD   m_dwTGTCallbackPeriod ; // millisecs till next callback
    CCallbackAdvise m_fnTGTCallback;// the TGT callback function


    // m_dwScheduleCookie == 0 <=> none of these are in use
    CBaseReferenceClock * m_pBaseClock;
    CAMSchedule     * m_pSchedule;
    HANDLE        m_hScheduleEvent;
    DWORD         m_dwScheduleCookie;

    class CAdviseItem   {
        CCallbackAdvise m_fnAdvise;
        DWORD_PTR m_dwUserToken;
        REFERENCE_TIME m_rtCallbackAt;
        REFERENCE_TIME m_rtPeriod;
        DWORD   m_dwAdviseFlags ;
    public:

        // Constructor can take a periodic time - or not
        CAdviseItem(CCallbackAdvise, DWORD_PTR, REFERENCE_TIME, REFERENCE_TIME=0, DWORD flags=0);

        REFERENCE_TIME Time() {
            return m_rtCallbackAt;
        };

        REFERENCE_TIME Period() {   
            return m_rtPeriod;
        };

        DWORD AdviseFlags() {   
            return m_dwAdviseFlags;
        };

        void SetTime (REFERENCE_TIME rt) {
            m_rtCallbackAt = rt ;
        } ;


// defines for m_dwAdviseFlags

#define ADVISE_PERIODIC_EXEMPT_FROM_RT 1     // the periodic advise is exempt from


        // If the advise is Periodic, update the time by one interval and return TRUE.
        // If the advise is not periodic, return FALSE
        BOOL UpdateTime(REFERENCE_TIME rtNow) {
            if (0 == m_rtPeriod) {
                return FALSE;
            }
            m_rtCallbackAt = m_rtPeriod + rtNow;
            return TRUE;
        };

        void Dispatch();
    };

    HANDLE m_evUser;

    CGenericList<CAdviseItem> m_Items;

    // make sure the thread is running
    HRESULT EnsureThread();

    // start the thread running (called from EnsureThread)
    HRESULT StartThread();

    // stop the thread and wait for it to exit. should not hold
    // critsec when doing this.
    void CloseThread();

    static DWORD InitialThreadProc(void *);
    DWORD ThreadProc(void);

    // dispatch any ripe advises
    void ProcessRequests(void);

    // dispatch due to user event being signalled
    void ProcessUserSignal(void);

    // get the earliest time in the list
    // returns S_FALSE if nothing in list otherwise S_OK
    HRESULT GetSoonestAdvise(REFERENCE_TIME& rrtFirst);

    // set up an advise on the clock
    HRESULT SetAdvise();

    // cancel any advise on the clock
    void CancelAdvise(void);
};


#endif // __CALLBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\dvdgb2\dvdgb2.cpp ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

#include <streams.h>
#include <vfwmsgs.h>

#ifdef FILTER_DLL
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#endif

#include <dvdmedia.h>
#include <IL21Dec.h>
#include <DDExclus.h>
#include "dvdgb2.h"

// setup data

#ifdef FILTER_DLL
// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = {
    { L"DVD Graph Builder"
		, &CLSID_DvdGraphBuilder
		, CDvdGraphBuilder::CreateInstance
		, NULL
		, NULL }    // self-registering info
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}
#endif


CDvdGraphBuilder::CDvdGraphBuilder(TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr)
: CUnknown(pName, pUnk),
m_pGB(NULL),
m_Decoders(),
m_pDVDSrc(NULL),
m_pDVDNav(NULL),
m_pVR(NULL),
m_pAR(NULL),
m_pVM(NULL),
m_pL21Dec(NULL),
m_bGraphDone(FALSE),
m_bUseVPE(TRUE),
m_dwVideoRenderStatus(0),
m_pL21PinToRender(NULL),
m_pSPPinToRender(NULL),
m_pDDrawObject(NULL),
m_pDDrawSurface(NULL)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::CDvdGraphBuilder()"))) ;

    *phr = CreateGraph() ;
    ZeroMemory(m_achwPathName, MAX_PATH * sizeof(m_achwPathName[0])) ;
}


CDvdGraphBuilder::~CDvdGraphBuilder()
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::~CDvdGraphBuilder() entering"))) ;
	
    // If we have a graph object
    if (m_pGB)
    {
        StopGraph() ;  // make sure the graph is REALYY stopped
		
        // Break the connections and remove all the filters we added from the graph
        ClearGraph() ;

        // If any app-specified DDraw object/surface was specified, release them now
        if (m_pDDrawSurface)
            m_pDDrawSurface->Release() ;
        if (m_pDDrawObject)
            m_pDDrawObject->Release() ;

        m_pGB->Release() ;  // free it
        m_pGB = NULL ;
    }
	
#if 0
    //
    // Get a list of decoders in use in the graph and release them.
    // Then free the memory for the list of decoders.
    //
    IBaseFilter *pDecList ;
    int n = m_Decoders.GetList(&pDecList) ;
    for (int i = 0 ; i < n ; n++)
        (pDecList + i)->Release() ;
    if (pDecList)
        CoTaskMemFree(pDecList) ;
#endif // #if 0
	
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::~CDvdGraphBuilder() ending"))) ;
}


void CDvdGraphBuilder::StopGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::StopGraph()"))) ;
	
    // Just paranoia
    if (NULL == m_pGB)
    {
        ASSERT(FALSE) ;  // so that we know
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: How are we doing a Stop w/o a graph???"))) ;
        return ;
    }
	
    //
    // Check that the graph has stopped; otherwise stop it here. Because a 
    // playing graph can't be cleaned up or rebuilt.
    //
    IMediaControl  *pMC ;
    LONG            lState ;
    HRESULT hr = m_pGB->QueryInterface(IID_IMediaControl, (LPVOID *)&pMC) ;
    ASSERT(SUCCEEDED(hr) && pMC) ;
    pMC->GetState(INFINITE, &lState) ;
    if (State_Stopped != lState)
    {
        hr = pMC->Stop() ;
        ASSERT(SUCCEEDED(hr)) ;
        while (State_Stopped != lState)
        {
            Sleep(10) ;
            hr = pMC->GetState(INFINITE, &lState) ;
            ASSERT(SUCCEEDED(hr)) ;
        }
    }
    pMC->Release() ;
    DbgLog((LOG_TRACE, 4, TEXT("DVD-Video playback graph has stopped"))) ;
}


STDMETHODIMP CDvdGraphBuilder::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::NonDelegatingQueryInterface()"))) ;
    if (ppv)
        *ppv = NULL;
	
    if (riid == IID_IDvdGraphBuilder)
    {
        DbgLog((LOG_TRACE, 5, TEXT("QI for IDvdGraphBuilder"))) ;
        return GetInterface((IDvdGraphBuilder *) this, ppv) ;
    } 
    if (riid == IID_IDvdGraphBuilder2)
    {
        DbgLog((LOG_TRACE, 5, TEXT("QI for IDvdGraphBuilder2"))) ;
        return GetInterface((IDvdGraphBuilder2 *) this, ppv) ;
    } 
    else // more interfaces
    {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv) ;
    }
}


// this goes in the factory template table to create new instances
CUnknown * CDvdGraphBuilder::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CDvdGraphBuilder(TEXT("DVD Graph Builder II"), pUnk, phr) ;
}



///////////////////////
// IDvdGraphBuilder stuff
///////////////////////

//
// Use my filtergraph to build your DVD playback graph
//
HRESULT CDvdGraphBuilder::SetFiltergraph(IGraphBuilder *pGB)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::SetFiltergraph(0x%lx)"), pGB)) ;
	
    if (pGB == NULL)
        return E_POINTER ;
	
    if (m_pGB)    // we already have a graph
    {
        StopGraph() ;  // make sure the graph is REALLY stopped
		
        // Break the connections and remove all the filters we added from the graph
        ClearGraph() ;

        // If any app-specified DDraw object/surface was specified, release them now
        if (m_pDDrawSurface)
            m_pDDrawSurface->Release() ;
        if (m_pDDrawObject)
            m_pDDrawObject->Release() ;

        m_pGB->Release() ;  // release the graph
    }
	
    // Now take the new graph
    m_pGB = pGB ;
    m_pGB->AddRef() ;   // we own a copy now
	
    //
    // If we want to bother about the filters that might have been added to the
    // passed in filter graph, we could enumerated and list them.  But ignore that
    // for now at least.
    //
	
    return NOERROR ;
}


//
// What filtergraph is graph building being done in?
//
HRESULT CDvdGraphBuilder::GetFiltergraph(IGraphBuilder **ppGB)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::GetFiltergraph(0x%lx)"), ppGB)) ;
	
    if (ppGB == NULL)
        return E_POINTER ;
	
// #if 0
    EnsureGraphExists() ;
// #endif // #if 0
	
    *ppGB = m_pGB ;
    if (NULL == m_pGB) 
    {
        return E_UNEXPECTED ;
    }
    m_pGB->AddRef() ;   // app owns a copy now
    return NOERROR ;
}


//
// Get a specified interface off of a filter in the DVD playback graph
//
HRESULT CDvdGraphBuilder::GetDvdInterface(REFIID riid, void **ppvIF)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::GetDvdInterface(%s, 0x%lx)"),
        (LPCSTR)CDisp(riid), ppvIF)) ;
	
    if (IsBadWritePtr(ppvIF, sizeof(LPVOID)))
        return E_INVALIDARG ;
    *ppvIF =  NULL ;
	
    // We can't return any of the internal filter interface pointers before
    // building the whole graph.
    if (! m_bGraphDone )
        return VFW_E_DVD_GRAPHNOTREADY ;
	
    if (IID_IDvdControl == riid)
    {
        if (m_pDVDSrc)  // if user specified DVD source
            return m_pDVDSrc->QueryInterface(IID_IDvdControl, (LPVOID *)ppvIF) ;
        else            // if using default DVD source -- our Nav
            return m_pDVDNav->QueryInterface(IID_IDvdControl, (LPVOID *)ppvIF) ;
    }
    else if (IID_IDvdInfo == riid)
    {
        if (m_pDVDSrc)  // if user specified DVD source
            return m_pDVDSrc->QueryInterface(IID_IDvdInfo, (LPVOID *)ppvIF) ;
        else            // if using default DVD source -- our Nav
            return m_pDVDNav->QueryInterface(IID_IDvdInfo, (LPVOID *)ppvIF) ;
    }
    else if (IID_IVideoWindow == riid)
    {
        if (m_pVR)
            return m_pGB->QueryInterface(IID_IVideoWindow, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else if (IID_IBasicVideo == riid)
    {
        if (m_pVR)
            return m_pVR->QueryInterface(IID_IBasicVideo, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else if (IID_IBasicAudio == riid)
    {
        if (m_pAR)
            return m_pAR->QueryInterface(IID_IBasicAudio, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else if (IID_IAMLine21Decoder == riid)
    {
        if (m_pL21Dec)
            return m_pL21Dec->QueryInterface(IID_IAMLine21Decoder, (LPVOID *)ppvIF) ;
        else
            return E_NOINTERFACE ;
    }
    else
        return E_NOINTERFACE ;
}


#define DVDGRAPH_FLAGSVALIDDEC    0x000000FF

#define DVDMG_HWDEC_NOTFOUND      0x01
#define DVDMG_SWDEC_NOTFOUND      0x02

//
// Build the whole graph for playing back the specifed or default DVD volume
//
HRESULT CDvdGraphBuilder::RenderDvdVideoVolume(LPCWSTR lpcwszPathName, DWORD dwFlags,
                                               AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::RenderDvdVideoVolume(0x%lx, 0x%lx, 0x%lx)"),
		lpcwszPathName, dwFlags, pStatus)) ;
	
    HRESULT    hr ;
	
// #if 0
    hr = EnsureGraphExists() ;  // make sure that a graph exists; if not create one
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't create a filter graph object"))) ;
        return hr ;
    }
// #endif // #if 0
	
    if (m_bGraphDone)  // if graph was built before,
        StopGraph() ;  // just make sure the graph is in Stopped state first
	
    ZeroMemory(pStatus, sizeof(AM_DVD_RENDERSTATUS)) ;  // clear status
    m_bUseVPE = (0 == (dwFlags & AM_DVD_NOVPE)) ;       // is VPE needed?
	
    if (0 == (dwFlags & DVDGRAPH_FLAGSVALIDDEC)) // 0 by default means HW max
    {
        DbgLog((LOG_TRACE, 3, TEXT("dwFlags specified as 0x%lx; added .._HWDEC_PREFER"), dwFlags)) ;
        dwFlags |= AM_DVD_HWDEC_PREFER ;  // use HW Decs maxm
    }
	
    //
    // Now build graph based on flag specified in the call
    //
    switch (dwFlags & DVDGRAPH_FLAGSVALIDDEC)
    {
	case AM_DVD_HWDEC_PREFER:
		hr = MakeGraphHW(FALSE, pStatus) ;
		break ;
		
	case AM_DVD_HWDEC_ONLY:
		hr = MakeGraphHW(TRUE, pStatus) ;
		break ;
		
	case AM_DVD_SWDEC_PREFER:
		// m_bUseVPE = FALSE ;
		hr = MakeGraphSW(FALSE, pStatus) ;
		break ;
		
	case AM_DVD_SWDEC_ONLY:
		// m_bUseVPE = FALSE ;
		hr = MakeGraphSW(TRUE, pStatus) ;
		break ;
		
	default:
		DbgLog((LOG_ERROR, 0, TEXT("WARNING: Got an invalid DVD Render flag"))) ;
		hr = E_INVALIDARG ;
		break ;
    }
	
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Graph building failed (Error 0x%lx)"), hr)) ;
        // m_Decoders.CleanAll() ; -- should be covered by ClearGraph()
        ClearGraph() ;
        return hr ;
    }
	
    HRESULT    hrFinal = hr ;  // as it has been so far
	
    //
    // Now get all the mixers, renderers etc to complete the graph
    //
    hr = RenderDecoderOutput(pStatus) ;
	
    //
    // If we were successful before and the decoder output rendering wasn't
    // then at least set the warning flag.
    //
    if (S_OK == hrFinal && S_OK != hr ||
        SUCCEEDED(hrFinal) && FAILED(hr))
        hrFinal = hr ;
	
    //
    // Do we really need it?
    //
    if (lpcwszPathName)
    {
        lstrcpynW(m_achwPathName, lpcwszPathName, MAX_PATH) ;
    }
	
    //
    // Set the specified root file name/DVD volume name (even NULL because
    // that causes the DVD Nav to search for one)
    //
    IDvdControl  *pDvdC ;
    if (m_pDVDSrc)
        hr = m_pDVDSrc->QueryInterface(IID_IDvdControl, (LPVOID *)&pDvdC) ;
    else
        hr = m_pDVDNav->QueryInterface(IID_IDvdControl, (LPVOID *)&pDvdC) ;
    if (FAILED(hr) || NULL == pDvdC)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't get IDvdControl interface (Error 0x%lx)"), hr)) ;
        return hr ;
    }
	
    //
    // Set the specified DVD volume path
    //
    // Does the SetRoor() function handle the NULL properly?
    //
    hr = pDvdC->SetRoot(lpcwszPathName) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 2, 
            TEXT("IDvdControl::SetRoot() call couldn't use specified volume (Error 0x%lx)"), hr)) ;
        if (lpcwszPathName)
            pStatus->bDvdVolInvalid = TRUE ;
        else
            pStatus->bDvdVolUnknown = TRUE ;
        if (SUCCEEDED(hrFinal))  // if we were so far perfect, ...
            hrFinal = S_FALSE ;  // ...we aren't so anymore
    }
	
    pDvdC->Release() ;  // done with this interface
	
    // Only if we haven't entirely failed, set the graph built flag and 
    // return overall result.
    if (SUCCEEDED(hrFinal))
        m_bGraphDone = TRUE ;
	
    return hrFinal ;
}



HRESULT CDvdGraphBuilder::SetDDrawObject(IDirectDraw *pDDrawObject)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::SetDDrawObject(0x%lx)"),
		    pDDrawObject)) ;

    // If the current pointer and the new one are both NULL, return OK
    if (NULL == m_pDDrawObject  &&  NULL == pDDrawObject)
    {
        DbgLog((LOG_TRACE, 3, TEXT("NULL DDraw object to replace NULL!! Skipping rest."))) ;
        return S_OK ;
    }

    // If it's the same DDraw object, don't do anything
    if (pDDrawObject && m_pDDrawObject &&            // making sure one of them isn't NULL
        IsEqualObject(pDDrawObject, m_pDDrawObject)) // same DDraw object
    {
        DbgLog((LOG_TRACE, 3, TEXT("Same DDraw object specified. Skipping rest."))) ;
        return S_OK ;
    }

    StopGraph() ;  // First stop the graph, because we must!!!

    //
    // The connections of the OverlayMixer pins will be invalid after this. So to avoid
    // any inconsistent state of the graph, we clear all the filters that "we added" 
    // to the graph.
    // It's doc-ed that the graph needs to be rebuilt after this call.
    //
    ClearGraph() ;

    if (m_pDDrawObject)  // if we have been using another DDraw object
        m_pDDrawObject->Release() ;     // release the ref count we had
    m_pDDrawObject = pDDrawObject ; // store new DDraw object pointer
    m_pDDrawObject->AddRef() ;      // we keep our own ref count

    return S_OK ;
}


HRESULT CDvdGraphBuilder::SetDDrawSurface(IDirectDrawSurface *pDDrawSurface)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::SetDDrawSurface(0x%lx)"),
		    pDDrawSurface)) ;

    // If the current pointer and the new one are both NULL, return OK
    if (NULL == m_pDDrawSurface  &&  NULL == pDDrawSurface)
    {
        DbgLog((LOG_TRACE, 3, TEXT("NULL DDraw surface to replace NULL!! Skipping rest."))) ;
        return S_OK ;
    }

    // If it's the same DDraw surface, don't do anything
    if (pDDrawSurface && m_pDDrawSurface &&            // making sure one of them isn't NULL
        IsEqualObject(pDDrawSurface, m_pDDrawSurface)) // same DDraw surface
    {
        DbgLog((LOG_TRACE, 3, TEXT("Same DDraw surface specified. Skipping rest."))) ;
        return S_OK ;
    }

    StopGraph() ;  // First stop the graph, because we must!!!

    //
    // The connections of the OverlayMixer pins will be invalid after this. 
    // So to avoid any inconsistent state of the graph, we clear all the filters 
    // that "we added" to the graph.
    // It's doc-ed that the graph needs to be rebuilt after this call.
    //
    ClearGraph() ;

    if (m_pDDrawSurface)  // if we have been using another DDraw surface
        m_pDDrawSurface->Release() ;       // release our ref count on the old one
    m_pDDrawSurface = pDDrawSurface ; // store the new surface
    m_pDDrawSurface->AddRef() ;       // we keep our own ref count on it

    return S_OK ;
}


HRESULT CDvdGraphBuilder::GetVideoSize(DWORD *pdwWidth, DWORD *pdwHeight)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::GetVideoSize(0x%lx, 0x%lx)"),
		    pdwWidth, pdwHeight)) ;

    if ( IsBadWritePtr(pdwWidth, sizeof(*pdwWidth)) || 
         IsBadWritePtr(pdwHeight, sizeof(*pdwHeight)) )
    {
        return E_INVALIDARG ;
    }

    if (NULL == m_pVM)  // no over,ay mixer => video and hence so video size!!!
    {
        return E_UNEXPECTED ;
    }

    // We can't return the video size before building the whole graph!!!
    if (! m_bGraphDone )
    {
        DbgLog((LOG_TRACE, 3, TEXT("Playback graph hasn't yet been built!!!"))) ;
        return VFW_E_DVD_GRAPHNOTREADY ;
    }

    HRESULT  hr ;
    if (m_pDDrawSurface)  // app specified DDraw params used in graph building
    {
        DbgLog((LOG_TRACE, 1, TEXT("App specified DDraw surface, i.e, windowless playback."))) ;

        // Get IDDrawExclModeVideo interface to get video size
        IDDrawExclModeVideo   *pDDXM ;
        hr = m_pVM->QueryInterface(IID_IDDrawExclModeVideo, (LPVOID *) &pDDXM) ;
        if (SUCCEEDED(hr) && pDDXM)
        {
            hr = pDDXM->GetVideoSize(pdwWidth, pdwHeight) ; // Can it fail? Naah!!
            ASSERT(SUCCEEDED(hr)) ;
            pDDXM->Release() ;
        }
        else
        {
            DbgLog((LOG_ERROR, 0, TEXT("ERROR: IDDrawExclModeVideo not supported on Overlay Mixer."))) ;
            return E_UNEXPECTED ;
        }
    }
    else   // Overlay Mixer allocated all DDraw object, surfaces etc.
    {
        DbgLog((LOG_TRACE, 1, TEXT("OvMixer's DDraw surface, i.e, windowed playback."))) ;

        if (m_pVR)  // if Video Renderer is in the graph
        {
            IBasicVideo   *pBV ;
            hr = m_pVR->QueryInterface(IID_IBasicVideo, (LPVOID *) &pBV) ;
            if (SUCCEEDED(hr) && pBV)
            {
                hr = pBV->GetVideoSize((LONG *)pdwWidth, (LONG *)pdwHeight) ; // Can it fail? Naah!!
                ASSERT(SUCCEEDED(hr)) ;
                pBV->Release() ;
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("ERROR: IBasicVideo not supported on Video Renderer."))) ;
                return E_UNEXPECTED ;
            }
        }
        else
        {
            DbgLog((LOG_ERROR, 0, TEXT("Windowed mode playback, but no Video Renderer!!!"))) ;
            return E_UNEXPECTED ;
        }
    }

    return S_OK ;  // success!!
}


HRESULT CDvdGraphBuilder::SetVideoRegion(RECT *pSrcRect, RECT *pDestRect)
{
    DbgLog((LOG_TRACE, 3, 
            TEXT("CDvdGraphBuilder::SetVideoRegion(0x%lx, 0x%lx)"),
		    pSrcRect, pDestRect)) ;

    if ( IsBadReadPtr(pSrcRect, sizeof(*pSrcRect)) || 
         IsBadReadPtr(pDestRect, sizeof(*pDestRect)) )
    {
        return E_INVALIDARG ;
    }

    if (NULL == m_pVM)  // no over,ay mixer => video and hence so video size!!!
    {
        return E_UNEXPECTED ;
    }

    // We can't return the video size before building the whole graph!!!
    if (! m_bGraphDone )
    {
        DbgLog((LOG_TRACE, 3, TEXT("Playback graph hasn't yet been built!!!"))) ;
        return VFW_E_DVD_GRAPHNOTREADY ;
    }

    HRESULT  hr ;
    if (m_pDDrawSurface)  // app specified DDraw params used in graph building
    {
        DbgLog((LOG_TRACE, 1, TEXT("App specified DDraw surface, i.e, windowless playback."))) ;

        // Get IDDrawExclModeVideo interface to get video size
        IDDrawExclModeVideo   *pDDXM ;
        hr = m_pVM->QueryInterface(IID_IDDrawExclModeVideo, (LPVOID *) &pDDXM) ;
        if (SUCCEEDED(hr) && pDDXM)
        {
            hr = pDDXM->SetDrawParameters(pSrcRect, pDestRect) ; // Can it fail? Naah!!
            ASSERT(SUCCEEDED(hr)) ;
            pDDXM->Release() ;
        }
        else
        {
            DbgLog((LOG_ERROR, 0, TEXT("ERROR: IDDrawExclModeVideo not supported on Overlay Mixer."))) ;
            return E_UNEXPECTED ;
        }
    }
    else   // Overlay Mixer allocated all DDraw object, surfaces etc.
    {
        DbgLog((LOG_TRACE, 1, TEXT("OvMixer's DDraw surface, i.e, windowed playback."))) ;

        if (m_pVR)  // if Video Renderer is in the graph
        {
            IBasicVideo   *pBV ;
            hr = m_pVR->QueryInterface(IID_IBasicVideo, (LPVOID *) &pBV) ;
            if (SUCCEEDED(hr) && pBV)
            {
                hr = pBV->SetSourcePosition(pSrcRect->left, pSrcRect->top,
                                            pSrcRect->right - pSrcRect->left, 
                                            pSrcRect->bottom - pSrcRect->top) ; // Can it fail? Naah!!
                ASSERT(SUCCEEDED(hr)) ;
                pBV->Release() ;
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("ERROR: IBasicVideo not supported on Video Renderer."))) ;
                return E_UNEXPECTED ;
            }
            IVideoWindow   *pVW ;
            hr = m_pVR->QueryInterface(IID_IVideoWindow, (LPVOID *) &pVW) ;
            if (SUCCEEDED(hr) && pVW)
            {
                hr = pVW->SetWindowPosition(pDestRect->left, pDestRect->top,
                                            pDestRect->right - pDestRect->left, 
                                            pDestRect->bottom - pDestRect->top) ; // Can it fail? Naah!!
                ASSERT(SUCCEEDED(hr)) ;
                pVW->Release() ;
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("ERROR: IVideoWindow not supported on Video Renderer."))) ;
                return E_UNEXPECTED ;
            }
        }
        else
        {
            DbgLog((LOG_ERROR, 0, TEXT("Windowed mode playback, but no Video Renderer!!!"))) ;
            return E_UNEXPECTED ;
        }
    }

    return S_OK ;  // success!!
}


HRESULT CDvdGraphBuilder::GetMixerPinInterface(DWORD dwPinNum, REFIID riid, void **ppvIF)
{
    DbgLog((LOG_TRACE, 3, TEXT("CDvdGraphBuilder::GetMixerPinInterface(%lu, %s, 0x%lx)"),
		    dwPinNum, (LPCTSTR) CDisp(riid), ppvIF)) ;

    if (0 != dwPinNum)
    {
        DbgLog((LOG_TRACE, 3, TEXT("IDvdGraphBuilder2::GetMixerPinInterface() takes dwPinNum=0 only"))) ;
        return E_INVALIDARG ;
    }

    if (NULL == ppvIF  ||  IsBadWritePtr(ppvIF, sizeof(*ppvIF)))
        return E_INVALIDARG ;

    if (NULL == m_pVM)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Overlay Mixer is not in the playback graph"))) ;
        return E_NOINTERFACE ;
    }

    // We can't return any of the internal filter interface pointers before
    // building the whole graph.
    if (! m_bGraphDone )
    {
        DbgLog((LOG_TRACE, 3, TEXT("Playback graph hasn't yet been built!!!"))) ;
        return VFW_E_DVD_GRAPHNOTREADY ;
    }

    IEnumPins  *pEnumPins ;
    IPin       *pPin ;
    ULONG       ul ;

    m_pVM->EnumPins(&pEnumPins) ;
    ASSERT(pEnumPins) ;

    PIN_DIRECTION   pd ;
    HRESULT         hr = E_NOINTERFACE ;  // until we find the pin
    while (S_OK == pEnumPins->Next(1, &pPin, &ul)  &&  1 == ul)  // try all pins
    {
        pPin->QueryDirection(&pd) ;
        if (PINDIR_INPUT == pd)  // only the 1st in pin
        {
            hr = pPin->QueryInterface(riid, ppvIF) ;
            pPin->Release() ; // exiting early; release pin
            break ;   // we are done
        }
        pPin->Release() ;
    }
    pEnumPins->Release() ;  // done with pin enum

    return hr ;
}


#if 0
HRESULT CDvdGraphBuilder::GetStatusMessage(AM_DVD_RENDERSTATUS *pStatus,
										   LPTSTR lpszMessage, int *piLength)
{
    return E_NOTIMPL ;  // for now
}
#endif // #if 0


//
// Make sure a filter graph has been created; if not create one here
//
HRESULT CDvdGraphBuilder::EnsureGraphExists(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::EnsureGraphExists()"))) ;
	
    if (m_pGB)
        return S_OK ;
	
    return CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC,
		IID_IGraphBuilder, (LPVOID *)&m_pGB) ;
}


//
// Create a fresh filter graph
//
HRESULT CDvdGraphBuilder::CreateGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateGraph()"))) ;
	
    return CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC,
		IID_IGraphBuilder, (LPVOID *)&m_pGB) ;
}


//
// Delete the existing filter graph's contents
//
HRESULT CDvdGraphBuilder::DeleteGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::DeleteGraph()"))) ;
	
    m_pGB->Release() ;
    return NOERROR ;
}


//
// Clear all the existing filters from the graph
//
HRESULT CDvdGraphBuilder::ClearGraph(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::ClearGraph()"))) ;
	
    // Just paranoia...
    if (NULL == m_pGB)
    {
        ASSERT(FALSE) ;  // so that we know
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: How are we Clearing w/o a graph???"))) ;
        return E_FAIL ;
    }
	
    // Reset state and release interfaces
    m_dwVideoRenderStatus = 0 ;
    if (m_pL21PinToRender)
    {
        m_pL21PinToRender->Release() ;
        m_pL21PinToRender = NULL ;
    }
    if (m_pSPPinToRender)
    {
        m_pSPPinToRender->Release() ;
        m_pSPPinToRender = NULL ;
    }
	
    // Remove all (connected only?) filters from graph
    RemoveAllFilters() ;
	
    // Release all decoders too
    m_Decoders.CleanAll() ;
	
    m_bGraphDone = FALSE ;  // reset the "graph already built" flag

    return NOERROR ;
}


//
// Delete all the non-decoder filters from the current graph.
//
HRESULT CDvdGraphBuilder::RemoveAllFilters(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RemoveAllFilters()"))) ;
	
    if (m_pVR)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Removing Video Renderer from the graph"))) ;
        m_pGB->RemoveFilter(m_pVR) ;
        m_pVR->Release() ;
        m_pVR = NULL ;
    }
    if (m_pAR)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Removing Audio Renderer from the graph"))) ;
        m_pGB->RemoveFilter(m_pAR) ;
        m_pAR->Release() ;
        m_pAR = NULL ;
    }
    // In case we are using any app specified DDraw object/surface, stop using them.
    // BUT don't release the interfaces as they can be used in the next time we 
    // (re)build the graph.
    if ((m_pDDrawSurface || m_pDDrawObject) &&  // DDraw object / surface is being used 
        m_pVM)                                  // OvMixer is being used
    {
        IDDrawExclModeVideo  *pDDXM ;
        HRESULT hr = m_pVM->QueryInterface(IID_IDDrawExclModeVideo, (LPVOID *) &pDDXM) ;
        if (SUCCEEDED(hr))
        {
            if (m_pDDrawSurface)  // if we were using a DDraw surface
                hr = pDDXM->SetDDrawSurface(NULL) ;  // don't use it anymore

            if (m_pDDrawObject)   // if we were using a DDraw object
                hr = pDDXM->SetDDrawObject(NULL) ;  // don't use it anymore

            pDDXM->Release() ;  // done with the interface
        }
        else
        {
            DbgLog((LOG_ERROR, 0, TEXT("ERROR: IDDrawExclModeVideo not supported on Overlay Mixer!!!"))) ;
            ASSERT(FALSE) ;
        }
    }
    if (m_pVM)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Removing Video Mixer from the graph"))) ;
        m_pGB->RemoveFilter(m_pVM) ;
        m_pVM->Release() ;
        m_pVM = NULL ;
    }
    if (m_pL21Dec)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Removing Line21 dec from the graph"))) ;
        m_pGB->RemoveFilter(m_pL21Dec) ;
        m_pL21Dec->Release() ;
        m_pL21Dec = NULL ;
    }
	
    m_IntFilters.RemoveAll() ; // remove intermediate filters, if any
	
    // Now remove the Nav 
    if (m_pDVDNav)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Removing DVD Nav from the graph"))) ;
        m_pGB->RemoveFilter(m_pDVDNav) ;
        m_pDVDNav->Release() ;
        m_pDVDNav = NULL ;
    }
	
    return NOERROR ;
}


//
// Create a filter and add it to the filter graph
//
HRESULT CDvdGraphBuilder::CreateFilterInGraph(CLSID Clsid,
											  LPCTSTR lpszFilterName, IBaseFilter **ppFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateFilterInGraph(%s, %s, 0x%lx)"), 
		(LPCSTR) CDisp(Clsid), lpszFilterName, ppFilter)) ;
	
    if (NULL == m_pGB)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Filter graph object hasn't been created yet"))) ;
        return E_FAIL ;
    }
	
    HRESULT   hr ;
    hr = CoCreateInstance(Clsid, NULL, CLSCTX_INPROC, IID_IBaseFilter,
		(LPVOID *)ppFilter) ;
    if (FAILED(hr) || NULL == *ppFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't create filter %s (Error 0x%lx)"),
			(LPCTSTR)CDisp(Clsid), hr)) ;
        return hr ;
    }
	
    // Add it to the filter graph
    WCHAR   achwFilterName[MAX_FILTER_NAME] ;
#ifdef UNICODE
    lstrcpy(achwFilterName, lpszFilterName) ;
#else
    MultiByteToWideChar(CP_ACP, 0, lpszFilterName, -1, achwFilterName, MAX_FILTER_NAME) ;
#endif // UNICODE
    hr = m_pGB->AddFilter(*ppFilter, achwFilterName) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't add filter %s to graph (Error 0x%lx)"),
			(LPCTSTR)CDisp(Clsid), hr)) ;
        (*ppFilter)->Release() ;  // release filter too
        *ppFilter = NULL ;      // and set it to NULL
        return hr ;
    }
	
    return NOERROR ;
}


//
// Find the nth pin with a specific direction in a filter
//
HRESULT CDvdGraphBuilder::FindOpenPin(IBaseFilter *pFilter, PIN_DIRECTION pd,
                                      int iIndex, IPin **ppPin)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::FindOpenPin(0x%lx, %d, %d, 0x%lx)"),
		pFilter, pd, iIndex, ppPin)) ;
	
    HRESULT    hr ;
    IEnumPins *pEnumPins ;
    IPin      *pPin ;
    IPin      *pPin2 ;
    PIN_DIRECTION  pdFound ;
    ULONG      ul ;
	
    *ppPin = NULL ;
	
    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Can't find a pin from NULL filter!!!"))) ;
        return E_INVALIDARG ;
    }
	
    hr = pFilter->EnumPins(&pEnumPins) ;
    ASSERT(SUCCEEDED(hr) && pEnumPins) ;
	
    while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
    {
        hr = pPin->QueryDirection(&pdFound) ;
        ASSERT(SUCCEEDED(hr)) ;
        if (pd != pdFound)
        {
            pPin->Release() ;  // don't need this pin
            continue ;
        }
        hr = pPin->ConnectedTo(&pPin2) ;
        if (SUCCEEDED(hr) && pPin2)
        {
            pPin2->Release() ;  // we don't want this pin actually
            pPin->Release() ;   // this pin is already connected
            continue ;          // try next one
        }
        if (0 == iIndex)
        {
            // Got the reqd pin in the right direction
            *ppPin = pPin ;
            hr = S_OK ;
            break ;
        }
        else  // some more to go
        {
            iIndex-- ;          // one more down...
            pPin->Release() ;   // this is not the pin we are looking for
        }
    }
    pEnumPins->Release() ;
    return hr ;  // whatever it is
}


BOOL CDvdGraphBuilder::CheckPinMediaTypeMatch(IPin *pPinIn, DWORD dwStreamFlag)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CheckPinMediaTypeMatch(%s, %lu)"),
		(LPCTSTR) CDisp(pPinIn), dwStreamFlag)) ;
	
    BOOL              bResult = FALSE ;
    AM_MEDIA_TYPE    *pmtIn ;
    IEnumMediaTypes  *pEnumMTIn ;
    HRESULT hr = pPinIn->EnumMediaTypes(&pEnumMTIn) ;
    ASSERT(SUCCEEDED(hr) && pEnumMTIn) ;
    ULONG   ul ;
    while (!bResult  &&
		S_OK == pEnumMTIn->Next(1, &pmtIn, &ul) && 1 == ul) // more mediatypes
    {
        // Decipher the mediatype
        if (pmtIn->majortype == MEDIATYPE_MPEG2_PES  ||
            pmtIn->majortype == MEDIATYPE_DVD_ENCRYPTED_PACK)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is MPEG2_PES/DVD_ENCRYPTED_PACK"))) ;
			
            if (pmtIn->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_VIDEO"))) ;
                bResult = dwStreamFlag == AM_DVD_STREAM_VIDEO ;
            }
            else if (pmtIn->subtype == MEDIASUBTYPE_DOLBY_AC3)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is DOLBY_AC3"))) ;
                bResult = dwStreamFlag == AM_DVD_STREAM_AUDIO ;
            }
            else if (pmtIn->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_Subpicture"))) ;
                bResult = dwStreamFlag == AM_DVD_STREAM_SUBPIC ;
            }
            else
            {
                DbgLog((LOG_ERROR, 1, TEXT("WARNING: Unknown subtype %s"),
					(LPCSTR) CDisp(pmtIn->subtype))) ;
            }
        }
        else if (pmtIn->majortype == MEDIATYPE_Video)  // elementary stream
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Video elementary"))) ;
			
            if (pmtIn->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_SUBPICTURE"))) ;
                bResult = dwStreamFlag ==  AM_DVD_STREAM_SUBPIC ;
            }
            else if (pmtIn->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_VIDEO"))) ;
                bResult = dwStreamFlag ==  AM_DVD_STREAM_VIDEO ;
            }
            else
                DbgLog((LOG_TRACE, 5, TEXT("WARNING: Unknown subtype %s"),
				(LPCSTR) CDisp(pmtIn->subtype))) ;
        }
        else if (pmtIn->majortype == MEDIATYPE_Audio)  // elementary stream
        {
            ASSERT(pmtIn->subtype == MEDIASUBTYPE_DOLBY_AC3) ;  // just checking
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Audio elementary"))) ;
            bResult = dwStreamFlag ==  AM_DVD_STREAM_AUDIO ;
        }
        // 
        // There is a chance that some IHV/ISV creates a private mediatype 
        // (major or sub) as in the case of IBM (for CSS filter). We have to
        // search the parts of the mediatype to locate something we recognize.
        // 
        else 
        {
            DbgLog((LOG_TRACE, 2, 
                TEXT("Unknown mediatype %s:%s. But we won't give up..."),
                (LPCSTR) CDisp(pmtIn->majortype), (LPCSTR) CDisp(pmtIn->subtype))) ;
            if (pmtIn->subtype == MEDIASUBTYPE_DOLBY_AC3)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Audio"))) ;
                bResult = dwStreamFlag ==  AM_DVD_STREAM_AUDIO ;
            }
            else if (pmtIn->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Video"))) ;
                bResult = dwStreamFlag ==  AM_DVD_STREAM_VIDEO ;
            }
            else if (pmtIn->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Subpicture"))) ;
                bResult = dwStreamFlag ==  AM_DVD_STREAM_SUBPIC ;
            }
            else
            {
                DbgLog((LOG_TRACE, 2, TEXT("WARNING: Unknown mediatype. Couldn't detect at all."))) ;
            }
        }
		
        DeleteMediaType(pmtIn) ;
    }  // end of while()
	
    pEnumMTIn->Release() ;
	
    return bResult ;  // whatever we found
	
}


IBaseFilter * CDvdGraphBuilder::GetFilterBetweenPins(IPin *pPinOut, IPin *pPinIn)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetFilterBetweenPins(Out=%s, In=%s)"),
		    (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;

    if (NULL == pPinOut || NULL == pPinIn)  // what!!!
        return NULL ;

    IPin  *pPin ;
    PIN_INFO  pi ;
    IBaseFilter  *pFilter = NULL ;
    HRESULT  hr = pPinOut->ConnectedTo(&pPin) ;
    if (pPin && SUCCEEDED(hr))
    {
        pPin->QueryPinInfo(&pi) ;
        pFilter = pi.pFilter ;
        ASSERT(pFilter && PINDIR_INPUT == pi.dir) ;
        //
        // We intentionally keep the extra ref count because this is an intermediate
        // filter and other intermediate filters picked up based on registry based
        // filter enum (for SW decoding case) will have the extra ref count.  We
        // release the IBaseFilter interface pointer in CIntFilters::RemoveAll() and
        // if we don't keep this extra ref count here, we'll fault.  On the other
        // hand we must do Release() on CIntFilters elements, because SW enum-ed 
        // filters will not otherwise be unloaded.
        //
        // if (pi.pFilter)
        //     pi.pFilter->Release() ;  // it has an extra ref count from the Query...

        pPin->Release() ;  // done with the pin for now

        // Just for checking...
#ifdef DEBUG
        hr = pPinIn->ConnectedTo(&pPin) ;
        if (pPin && SUCCEEDED(hr))
        {
            pPin->QueryPinInfo(&pi) ;
            ASSERT(pi.pFilter && PINDIR_OUTPUT == pi.dir) ;
            if (pi.pFilter)
            {
                ASSERT(IsEqualObject(pFilter, pi.pFilter)) ; // we should have got the same filter
                pi.pFilter->Release() ;  // it has an extra ref count from the Query...
            }

            pPin->Release() ;  // done with the pin for now
        }
#endif // DEBUG

    }
    return pFilter ;
}


HRESULT CDvdGraphBuilder::ConnectSrcToHWDec(IBaseFilter *pSrc,
                                            CListDecoders *pHWDecList, 
                                            AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::ConnectSrcToHWDec(0x%lx, 0x%0x, 0x%lx)"),
		pSrc, pHWDecList, pStatus)) ;
	
    ULONG            ul ;
    int              i ;
    IPin            *pPinOut ;
    IPin            *pPinIn ;
    PIN_DIRECTION    pd ;
    BOOL             bConnected ;
    IBaseFilter     *pHWDec ;
    LPTSTR           szName ;
    BOOL             bHW ;
    IEnumPins       *pEnumPinsOut ;
    HRESULT          hr ;
    HRESULT          hrFinal = S_OK ;  // assumed innocent
	
    if (0 == pHWDecList->GetNumHWFilters())  // if there is no HW decoder
        return S_FALSE ;                     // not a failure, but not a full success
	
    if (NULL == pSrc)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: NULL Src passed to ConnectSrcToHWDec()"))) ;
        return E_INVALIDARG ;
    }
	
    hr = pSrc->EnumPins(&pEnumPinsOut) ;
    ASSERT(SUCCEEDED(hr) && pEnumPinsOut) ;
	
    while (S_OK == pEnumPinsOut->Next(1, &pPinOut, &ul)  &&  1 == ul)
    {
        pPinOut->QueryDirection(&pd) ;
        if (PINDIR_INPUT == pd)
        {
            pPinOut->Release() ;
            continue ;
        }
        hr = pPinOut->ConnectedTo(&pPinIn) ;
        if (SUCCEEDED(hr) && pPinIn)
        {
            DbgLog((LOG_TRACE, 5, 
				TEXT("Pin %s is already connected to %s"), 
				(LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
            pPinIn->Release() ;     // we don't want this pin actually
            pPinOut->Release() ;   // this pin is already connected
            continue ;             // try next one
        }
		
        DbgLog((LOG_TRACE, 5, 
			TEXT("Pin %s will be tried for connection to HW decoder"), 
			(LPCTSTR)CDisp(pPinOut))) ;
		
        // Got an unconnected output pin of the DVD source filter
        //
        // We are going to get the successive inpins of the already
        // loaded decoders and see if the outpin can connect directly 
        // to it.
        bConnected = FALSE ;
		
        // Try all HW decoders for mediatype match and then connection
        DbgLog((LOG_TRACE, 5, TEXT("Going to try %d HW decoders..."), 
			pHWDecList->GetNumHWFilters())) ;
        for (i = 0 ; !bConnected && i < pHWDecList->GetNumHWFilters() ; i++)
        {
            pHWDecList->GetFilter(i, &pHWDec, &szName, &bHW) ;
            ASSERT(pHWDec && bHW) ;  // paranoia!!!
            DbgLog((LOG_TRACE, 5, TEXT("HW Decoder: %s"), szName)) ;
			
            BOOL bNotInUse ;
            bNotInUse = (DECLIST_NOTFOUND == m_Decoders.IsInList(TRUE, (LPVOID)pHWDec)) ;
            if (bNotInUse)  // not already in the graph/decoder list
            {
                // First add filter to graph and then try to connect
                WCHAR   achwFilterName[MAX_FILTER_NAME] ;
#ifdef UNICODE
                lstrcpy(achwFilterName, szName) ;
#else
                MultiByteToWideChar(CP_ACP, 0, szName, -1, achwFilterName,
					MAX_FILTER_NAME) ;
#endif // UNICODE
                
                m_pGB->AddFilter(pHWDec, achwFilterName) ;
            }
            else
                DbgLog((LOG_TRACE, 4, TEXT("HW decoder (%s) is already in the graph"), szName)) ;

            //
            // Try all input pins of this HW decoder until we can connect the
            // Nav out pin to one (or all in pins have been tried)
            //
            int  j = 0 ;
            while ( !bConnected  &&
                    SUCCEEDED(hr = FindOpenPin(pHWDec, PINDIR_INPUT, j, &pPinIn))  &&
                    pPinIn)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Open input pin #%d found on HW decoder"), j)) ;

                //
                // Find the mediatype of this input pin of the proxy filter. If
                // it's the same type as the output pin of the Nav, then they
                // are supposed to be connected (may be) -- try it.
                //
                DWORD dwStreamIn = StreamFlagFromSWPin(pPinOut) ;
                if (CheckPinMediaTypeMatch(pPinIn, dwStreamIn))
                {
                    DbgLog((LOG_TRACE, 3, 
                        TEXT("Pin <%s> and Pin <%s> has matching mediatypes (%lu)"), 
                        (LPCTSTR) CDisp(pPinOut), (LPCTSTR) CDisp(pPinIn), dwStreamIn)) ;
					
                    //
                    // First try to do "direct connect" so that no other intermediate
                    // filter gets picked up (which is the most common case).
                    //
                    hr = m_pGB->ConnectDirect(pPinOut, pPinIn, NULL) ;
                    if (SUCCEEDED(hr))
                    {
                        bConnected = TRUE ;
                        // Add it to list, ONLY IF not already in
                        if (bNotInUse)
                            m_Decoders.AddFilter(pHWDec, szName, TRUE, NULL) ;
						
                        DbgLog((LOG_TRACE, 5, 
							TEXT("Pin %s directly connected to pin %s"), 
							(LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
                    }
                    else  // direct connection doesn't work
                    {
                        DbgLog((LOG_TRACE, 5, 
							TEXT("Pin %s did NOT directly connect to pin %s"), 
							(LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;

                        //
                        // Now do an "intelligent connect" so that any required intermediate
                        // filter can get picked up.  This is mainly to accommodate IBM's
                        // separate CSS filter.
                        //
                        hr = m_pGB->Connect(pPinOut, pPinIn) ;
                        if (SUCCEEDED(hr))
                        {
                            bConnected = TRUE ;
                            // Add it to list, ONLY IF not already in
                            if (bNotInUse)
                                m_Decoders.AddFilter(pHWDec, szName, TRUE, NULL) ;
                            
                            //
                            // BUGBUG: We assume that there will be only one intermediate
                            // filter sitting between the Nav's out pin and the decoder,
                            // which is the most likely case, but there IS a chance that
                            // there can be two more such filters. We should rather add
                            // all such filters to the intermediate filters' list inside
                            // GetFilter(s)BetweenPins() method.
                            //
                            m_IntFilters.AddFilter(GetFilterBetweenPins(pPinOut, pPinIn)) ; // add to the list

                            DbgLog((LOG_TRACE, 5, 
                                TEXT("Pin %s *indirectly* connected to pin %s"), 
                                (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
                        }
                        else
                            DbgLog((LOG_TRACE, 5, 
							    TEXT("Pin %s did NOT indirectly connect to pin %s"), 
							    (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
                    }  // end of else of if (connect direct)
                } // end of if (CheckPinMediaTypeMatch())

                pPinIn->Release() ;  // done with this in pin
                j++ ;
            }  // end of while (try all in pins untill connected to one)

            if (0 == j)
                DbgLog((LOG_TRACE, 5, TEXT("No open input pin found on HW decoder"))) ;
			
            // If we didn't connect to it AND we added it to the graph 
            // THIS TIME then ONLY remove it.  I spent almost day debugging
            // for the missing if (bNotInUse) check!!!
            if ( !bConnected  &&  bNotInUse)
                m_pGB->RemoveFilter(pHWDec) ;
			
        }   // end of for (all HW decs)
		
        if (! bConnected )  // if we couldn't connect this pin
        {
            if (NOERROR == hrFinal)  // if it was perfect so far,
                hrFinal = S_FALSE ;  // it's not so anymore
            DbgLog((LOG_TRACE, 5, TEXT("Pin (%s) couldn't be connected to any HW Dec"),
				(LPCTSTR)CDisp(pPinOut))) ;
        }
        pPinOut->Release() ;      // done with this out pin
		
    }   // end of while (out pin enum)
    pEnumPinsOut->Release() ;  // done with pin enum of DVD Src
	
    return hrFinal ;
}


BOOL CDvdGraphBuilder::StartDecAndConnect(IPin *pPinOut, 
                                          IFilterMapper *pMapper, 
                                          AM_MEDIA_TYPE *pmt)
{
    ULONG            ul ;
    IPin            *pPinIn ;
    PIN_DIRECTION    pd ;
    BOOL             bConnected ;
    LPTSTR           szName ;
    IEnumPins       *pEnumPinsOut ;
    IEnumRegFilters *pEnumFilters ;
    IBaseFilter     *pSWDec ;
    REGFILTER       *pRegDec ;
    TCHAR            achName[MAX_FILTER_NAME] ;
    IEnumMediaTypes *pEnumMT ;
    HRESULT          hr ;
    HRESULT          hrFinal = S_OK ;  // assumed innocent
    BOOL             bHW ;
    int              iDecPos ;
	
    hr = pMapper->EnumMatchingFilters(&pEnumFilters, /* MERIT_NORMAL */ 
                        MERIT_DO_NOT_USE+1, TRUE, 
		                pmt->majortype, pmt->subtype, FALSE, TRUE, 
		                GUID_NULL, GUID_NULL) ;
    if (FAILED(hr) || NULL == pEnumFilters)
    {
        DbgLog((LOG_TRACE, 3, TEXT("No matching enum for mediatype (%s:%s)"),
			(LPCSTR) CDisp(pmt->majortype), (LPCSTR) CDisp(pmt->subtype))) ;
        DeleteMediaType(pmt) ;
        return FALSE ;
    }
    DbgLog((LOG_TRACE, 5, TEXT("Got a filter enum for mediatype (%s:%s)"),
		(LPCSTR) CDisp(pmt->majortype), (LPCSTR) CDisp(pmt->subtype))) ;
	
    // Go through all the filters in this enumerator to locate a
    // suitable one to connect to.
    bConnected = FALSE ;  // clear flag at starting
    while ( !bConnected  && 
		    S_OK == pEnumFilters->Next(1, &pRegDec, &ul) && 1 == ul )
    {
        iDecPos = m_Decoders.IsInList(FALSE, (LPVOID)&(pRegDec->Clsid)) ;
        if (DECLIST_NOTFOUND == iDecPos)  // not in list
        {
            DbgLog((LOG_TRACE, 5, TEXT("Not an existing SW decoder-- going to create"))) ;
            hr = CoCreateInstance(pRegDec->Clsid, NULL, CLSCTX_INPROC, 
				        IID_IBaseFilter, (LPVOID *)&pSWDec) ;
            if (FAILED(hr) || NULL == pSWDec)
            {
                DbgLog((LOG_ERROR, 0, TEXT("Couldn't load a matching registered filter (%s) (Error 0x%lx)"),
					(LPCSTR) CDisp(pRegDec->Clsid), hr)) ;
                CoTaskMemFree(pRegDec) ;  // before we try the next
                continue ;  // onto the next matching filter...
            }
            DbgLog((LOG_TRACE, 5, TEXT("Started matching registered filter (%s)"),
				(LPCSTR) CDisp(pRegDec->Clsid))) ;
			
            hr = m_pGB->AddFilter(pSWDec, pRegDec->Name) ;
            ASSERT(SUCCEEDED(hr)) ;
        }
        else // already created; use existing instance
        {
            DbgLog((LOG_TRACE, 5, TEXT("Going to use an existing SW decoder (%d)"), 
				iDecPos)) ;
            m_Decoders.GetFilter(iDecPos, &pSWDec, &szName, &bHW) ;
            ASSERT(pSWDec && !bHW) ;  // want to be sure!!
        }
		
        if (SUCCEEDED(hr = TryConnect(pPinOut, pSWDec, NULL, TRUE)))
        {
            DbgLog((LOG_TRACE, 5, TEXT("One more pin connected (to decoder or 3rd party filter?)"))) ;

            //
            // There is a chance that the filter we just above created and connected
            // Nav's out pin to, "may NOT be" actually a decoder -- it may also be a
            // 3rd party intermediate filter, like IBM's CSS filter.
            //
            IPin            *pPinOut2 ;
            IEnumMediaTypes *pEnumMT2 ;
            AM_MEDIA_TYPE   *pmt2 ;
            BOOL             bMTDecoded = FALSE ;
            hr = FindOpenPin(pSWDec, PINDIR_OUTPUT, 0, &pPinOut2) ;
            if (SUCCEEDED(hr) && pPinOut2)
            {
                hr = pPinOut2->EnumMediaTypes(&pEnumMT2) ;
                ASSERT(SUCCEEDED(hr) && pEnumMT2) ;
                while ( !bMTDecoded && 
                        S_OK == pEnumMT2->Next(1, &pmt2, &ul) && 1 == ul)
                {
                    bMTDecoded = MEDIATYPE_Video == pmt2->majortype ||
						         MEDIATYPE_Audio == pmt2->majortype ;
                    DeleteMediaType(pmt2) ;  // otherwise
                }
                if (bMTDecoded)  // we HAVE connected to a decoder!!!
                {
                    //
                    // Add decoder info to our decoder list and set the success flag
                    //
                    DbgLog((LOG_TRACE, 5, TEXT("Nav pin / 3rd party's pin connected to decoder"))) ;
#ifdef UNICODE
                    lstrcpy(achName, pRegDec->Name) ;
#else
                    WideCharToMultiByte(CP_ACP, 0, pRegDec->Name, -1,
						        achName, MAX_FILTER_NAME, NULL, NULL) ;
#endif // UNICODE
					
                    if (DECLIST_NOTFOUND == iDecPos) // only if not in list
                        m_Decoders.AddFilter(pSWDec, achName, FALSE, &(pRegDec->Clsid)) ;
                    bConnected = TRUE ;  // success!!
                }
                else  // we have connected to an intermediate filter so far
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Nav pin (%s) connected to 3rd party filter with out pin (%s)"),
						(LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinOut2))) ;

                    m_IntFilters.AddFilter(pSWDec) ; // pSWDec is actually the intermediate filter

                    pEnumMT2->Reset() ;  // need to enum mediatypes AGAIN for connection
                    while( !bConnected  && 
						    S_OK == pEnumMT2->Next(1, &pmt2, &ul) && 1 == ul )
                    {
                        bConnected = StartDecAndConnect(pPinOut2, pMapper, pmt2) ;
                        DeleteMediaType(pmt2) ;     // done with this mediatype
                    }   // end of while (!bConnected && pEnumMT2->Next())
					
                    if ( !bConnected )  // connection attempts failed
                        DbgLog((LOG_TRACE, 5, 
						    TEXT("Pin (%s) -> Pin(%s) couldn't be connected to any SW Dec"),
						    (LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinOut2))) ;
                }
                pEnumMT2->Release() ;  // media enum over
            }
            pPinOut2->Release() ; // done with this pin
			
        }
        else  // connection attempt failed
        {
            if (DECLIST_NOTFOUND == iDecPos) // only if we created it in this pass
            {
                hr = m_pGB->RemoveFilter(pSWDec) ; // connection failed; remove it
                ASSERT(SUCCEEDED(hr)) ;
                pSWDec->Release() ;                // don't need it
            }
        }
        CoTaskMemFree(pRegDec) ;   // before we forget
		
    } // end of while (!bConnected && pEnumFilters->Next())
	
    pEnumFilters->Release() ;  // let go of the filter enumerator
	
    return bConnected ;
}


HRESULT CDvdGraphBuilder::ConnectSrcToSWDec(IBaseFilter *pSrc, 
                                            AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::ConnectSrcToSWDec(0x%lx, 0x%lx)"),
		pSrc, pStatus)) ;
	
    ULONG            ul ;
    IPin            *pPinOut ;
    IPin            *pPinIn ;
    PIN_DIRECTION    pd ;
    BOOL             bConnected ;
    IEnumPins       *pEnumPinsOut ;
    AM_MEDIA_TYPE   *pmt ;
    IEnumMediaTypes *pEnumMT ;
    IFilterMapper   *pMapper ;
    HRESULT          hr ;
    HRESULT          hrFinal = S_OK ;  // assumed innocent
	
    if (NULL == pSrc)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: NULL Src passed to ConnectSrcToSWDec()"))) ;
        return E_INVALIDARG ;
    }
	
    hr = CoCreateInstance(CLSID_FilterMapper, NULL, CLSCTX_INPROC, 
		        IID_IFilterMapper, (LPVOID *)&pMapper) ;
    ASSERT(SUCCEEDED(hr)  &&  pMapper) ;
	
    hr = pSrc->EnumPins(&pEnumPinsOut) ;
    ASSERT(SUCCEEDED(hr) && pEnumPinsOut) ;
	
    while (S_OK == pEnumPinsOut->Next(1, &pPinOut, &ul) && 1 == ul)
    {
        pPinOut->QueryDirection(&pd) ;
        if (PINDIR_INPUT == pd)
        {
            pPinOut->Release() ;
            continue ;
        }
        hr = pPinOut->ConnectedTo(&pPinIn) ;
        if (SUCCEEDED(hr) && pPinIn) // already connected out pin of DVD src
        {
            DbgLog((LOG_TRACE, 5, 
				TEXT("Pin %s is already connected to pin %s"), 
				(LPCTSTR)CDisp(pPinOut), (LPCTSTR)CDisp(pPinIn))) ;
            pPinIn->Release() ;   // let the in pin go
            pPinOut->Release() ;  // let the out pin go
            continue ;
        }
		
        // Got an unconnected out pin of DVD src
        DbgLog((LOG_TRACE, 5, TEXT("Found pin %s not yet connected"), 
			(LPCTSTR)CDisp(pPinOut))) ;

        // First check if there is any existing intermediate filter(s).
        // If so, we may be able to connect through it.
        int iCount = m_IntFilters.GetCount() ;
        DbgLog((LOG_TRACE, 5, TEXT("%d intermediate filters in list"), iCount)) ;
        IBaseFilter *pIntFilter ;
        for (int i = 0 ; i < iCount ; i++)
        {
            pIntFilter = m_IntFilters.GetFilter(i) ;
            ASSERT(pIntFilter) ;
            if (SUCCEEDED(hr = TryConnect(pPinOut, pIntFilter, NULL, TRUE)))
            {
                DbgLog((LOG_TRACE, 5, TEXT("Nav's out pin (%s) connected to 3rd party filter"),
                        (LPCTSTR)CDisp(pPinOut))) ;
                pPinOut->Release() ;  // done with Nav's pin; now we need int. filter's pin
                // Next we'll get the out pin of the intermediate filter and release it
                // at the end of the while loop, in place of the above pPinOut.

                hr = FindOpenPin(pIntFilter, PINDIR_OUTPUT, 0, &pPinOut) ;
                if (SUCCEEDED(hr) && pPinOut)
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Got 3rd party filter's out pin %s"),
                        (LPCTSTR)CDisp(pPinOut))) ;
                    break ;  // done for this pin of Nav; next step below.
                }
            }
            else
                DbgLog((LOG_TRACE, 5, TEXT("Nav's pin %s didn't connect to int. filter #%d"),
                        (LPCTSTR)CDisp(pPinOut), i)) ;
        }

        // Now we try to connect to the decoder (or an intermediate filter)
        bConnected = FALSE ;
        hr = pPinOut->EnumMediaTypes(&pEnumMT) ;
        ASSERT(SUCCEEDED(hr) && pEnumMT) ;
        while( !bConnected  && 
			    S_OK == pEnumMT->Next(1, &pmt, &ul) && 1 == ul )
        {
            bConnected = StartDecAndConnect(pPinOut, pMapper, pmt) ;
            DeleteMediaType(pmt) ;     // done with this mediatype
			
        }  // end of while (!bConnected && pEnumMT->Next())
		
        pEnumMT->Release() ;  // done with mediatype enum
		
        if (!bConnected) {  // connection attempts failed
            if (NOERROR == hrFinal)  // if it was perfect so far,
                hrFinal = S_FALSE ;  // it's not so anymore
            DbgLog((LOG_TRACE, 5, TEXT("Pin (%s) couldn't be connected to any SW Dec"),
				(LPCTSTR)CDisp(pPinOut))) ;
        }
        pPinOut->Release() ;  // done with this out pin
		
    }  // end of while (pEnumPinsOut->Next())
	
    pEnumPinsOut->Release() ;  // done with DVD source's pin enum
    pMapper->Release() ;       // done with the filter mapper
	
    return hrFinal ;
}


HRESULT CDvdGraphBuilder::CheckSrcPinConnection(IBaseFilter *pSrc, 
                                                AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CheckSrcPinConnection(0x%lx, 0x%lx)"),
		pSrc, pStatus)) ;
	
    ULONG            ul ;
    IPin            *pPinOut ;
    IPin            *pPinIn ;
    PIN_DIRECTION    pd ;
    IEnumPins       *pEnumSrcPins ;
    DWORD            dwStreamOut ;
    HRESULT          hrFinal = S_OK ;
	
    HRESULT  hr = pSrc->EnumPins(&pEnumSrcPins) ;
    ASSERT(SUCCEEDED(hr) && pEnumSrcPins) ;
	
    while (S_OK == pEnumSrcPins->Next(1, &pPinOut, &ul) && 1 == ul)
    {
        pPinOut->QueryDirection(&pd) ;
        if (PINDIR_INPUT == pd)
        {
            // Huh!!! In pin for DVD Src? Anyway...
            pPinOut->Release() ;
            continue ;
        }
        dwStreamOut = StreamFlagFromSWPin(pPinOut) ;
        pStatus->iNumStreams++ ;  // one more DVD stream found
        pPinIn = NULL ;  // start as NULL

        if (m_IntFilters.GetCount() > 0) // there is indirect connection
        {
            DbgLog((LOG_TRACE, 5, 
                    TEXT("Nav pin %s connection will be checked aginst %d int. filters"),
                    (LPCTSTR)CDisp(pPinOut), m_IntFilters.GetCount())) ;
            hr = pPinOut->ConnectedTo(&pPinIn) ; // get connected filter's in pin
            if (SUCCEEDED(hr) && pPinIn)
            {
                PIN_INFO  pi ;
                pPinIn->QueryPinInfo(&pi) ;
                // pPinIn->Release() ;  // got the intermediate filter ptr, let go of the pin

                if (m_IntFilters.IsInList(pi.pFilter))  // Nav pin is going via one of the intermediate filters
                {
                    DbgLog((LOG_TRACE, 5, 
                        TEXT("Nav pin %s is connected to an int. filter in our list"),
                        (LPCTSTR)CDisp(pPinOut))) ;

                    pPinIn->Release() ;  // got the intermediate filter ptr, let go of the pin
                    pPinIn = NULL ;      // reset the pointer too

                    // Locate the "corresponding" out pin of the intermediate filter.
                    // Use the Nav out pin's mediatype to detect the correspodning out
                    // pin of the intermediate filter.
                    IPin       *pIntFPinOut ;
                    IEnumPins  *pEnumIntFPins ;
                    hr = pi.pFilter->EnumPins(&pEnumIntFPins) ;
                    ASSERT(SUCCEEDED(hr) && pEnumIntFPins) ;
                    while (NULL == pPinIn  &&
                           S_OK == pEnumIntFPins->Next(1, &pIntFPinOut, &ul) && 1 == ul)
                    {
                        pIntFPinOut->QueryDirection(&pd) ;
                        if (PINDIR_OUTPUT == pd)  // we only care about out pins
                        {
                            DbgLog((LOG_TRACE, 5, 
                                TEXT("Int. filter's pin %s mediatype is being determined..."),
                                (LPCTSTR)CDisp(pIntFPinOut))) ;  // pPinOut
                            DWORD  dwStream = StreamFlagFromSWPin(pIntFPinOut) ;
                            if (dwStream == dwStreamOut) // corresponding pin
                            {
                                DbgLog((LOG_TRACE, 5, 
                                    TEXT("Found out pin of int. filter corresponding to %s of Nav (Stream 0x%lx)"),
				                    (LPCTSTR)CDisp(pPinOut), dwStreamOut)) ;
                                hr = pIntFPinOut->ConnectedTo(&pPinIn) ;  // get connection info
                            }
                            else
                            {
                                if (0 == dwStream)
                                {
                                    DbgLog((LOG_TRACE, 5, 
                                        TEXT("Couldn't find which pin of int. filter corresponds to %s of Nav (Stream 0x%lx)"),
				                        (LPCTSTR)CDisp(pPinOut), dwStreamOut)) ;

                                    //
                                    // HACK: (for MediaMatics 3D Audio filter)
                                    // Most probably the 3rd party filters uses a custom
                                    // mediatype on the out pin. We'll see if the out is
                                    // connected at all.  If not, we'll say dwStreamOut 
                                    // is not rendered; else we'll try two methods.
                                    //
                                    hr = pIntFPinOut->ConnectedTo(&pPinIn) ;  // is it connected?
                                    if (SUCCEEDED(hr) && pPinIn)
                                    {
                                        DbgLog((LOG_TRACE, 5, 
                                            TEXT("Out pin (%s) of int. filter corresponding to %s of Nav (Stream 0x%lx) connects to %s"),
				                            (LPCTSTR)CDisp(pPinOut), dwStreamOut, (LPCTSTR)CDisp(pPinIn))) ;

                                        // Method 1: If Int filter has 1 in and 1 out pin
                                        if (m_IntFilters.GetNumInPin(pi.pFilter)  == 1 &&
                                            m_IntFilters.GetNumOutPin(pi.pFilter) == 1) // method 1 worked!!!
                                        {
                                            DbgLog((LOG_TRACE, 5, 
                                                TEXT("Int. filter has 1 in and 1 out pin. No need to try more."))) ;
                                        }
                                        else  // there are more than 1 in/out pin(s).
                                        {
                                            // Try method 2: Check mediatype of out pin of filter
                                            // downstream of int. filter's out pin.
                                            PIN_INFO   pi2 ;
                                            IEnumPins *pEnumPin2 ;
                                            IPin      *pPin2 ;
                                            pPinIn->QueryPinInfo(&pi2) ;
                                            ASSERT(pi2.pFilter) ;
                                            pi2.pFilter->EnumPins(&pEnumPin2) ;
                                            ASSERT(pEnumPin2) ;
                                            dwStream = 0 ;  // just to be sure
                                            while (0 == dwStream  &&
                                                   S_OK == pEnumPin2->Next(1, &pPin2, &ul) && 1 == ul)
                                            {
                                                pPin2->QueryDirection(&pd) ;
                                                if (PINDIR_OUTPUT == pd)  // we only care about out pins
                                                {
                                                    DbgLog((LOG_TRACE, 5, 
                                                        TEXT("Downstream filter's pin %s mediatype is being determined..."),
                                                        (LPCTSTR)CDisp(pPin2))) ;
                                                    DWORD  dwStream = StreamFlagFromSWPin(pPin2) ;
                                                }
                                                pPin2->Release() ;  // done with this pin
                                            } // end of while ()
                                            ASSERT(dwStream) ;        // I hope we didn't have another failure
                                            pEnumPin2->Release() ;    // done enum-ing
                                            pi2.pFilter->Release() ;  // else we leak

                                            // Check if we got the matching in and out pins
                                            if (dwStream == dwStreamOut)
                                            {
                                                DbgLog((LOG_TRACE, 5, 
                                                    TEXT("Downstream filter's out pin %s matches Nav's out pin %s (Stream 0x%lx)"),
                                                    (LPCTSTR)CDisp(pPin2), (LPCTSTR)CDisp(pPinOut), dwStreamOut)) ;
                                            }
                                            else
                                            {
                                                DbgLog((LOG_TRACE, 5, 
                                                    TEXT("Downstream filter's out pin %s DOES NOT match Nav's out pin %s (Stream 0x%lx). Try more..."),
                                                    (LPCTSTR)CDisp(pPin2), (LPCTSTR)CDisp(pPinOut), dwStreamOut)) ;

                                                // We weren't really looking for this pin; 
                                                // keep trying the other out pins.
                                                pPinIn->Release() ;
                                                pPinIn = NULL ;
                                            }
                                        }
                                    }  // end of if (connected?)
                                    else
                                        DbgLog((LOG_TRACE, 5, 
                                            TEXT("NOTE: Unconnected out pin (%s) of int. filter corresponding to %s of Nav (Stream 0x%lx)"),
				                            (LPCTSTR)CDisp(pIntFPinOut), (LPCTSTR)CDisp(pPinOut), dwStreamOut)) ;
                                }
                                else
                                    DbgLog((LOG_TRACE, 5, 
                                        TEXT("Skipping non-matching pin (Stream 0x%lx) of int. filter for %s of Nav (Stream 0x%lx)"),
				                        dwStream, (LPCTSTR)CDisp(pPinOut), dwStreamOut)) ;
                            }
                        }
                        pIntFPinOut->Release() ;

                    }  // end while ()

                    pEnumIntFPins->Release() ; // done with pin enum
                } // end of if (m_IntFilters.IsInList())
                else
                    DbgLog((LOG_TRACE, 5, 
                        TEXT("Nav pin %s is NOT connected to an int. filter in our list"),
                        (LPCTSTR)CDisp(pPinOut))) ;

                pi.pFilter->Release() ;  // else we leak
            }
            // Otherwise pPinIn or hr indicates the "not connected" state which
            // will be tested below to set the approp. flags etc. in the Status 
            // struct.
        }
        else  // Nav connects directly to the decoder(s)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Pin %s is NOT connected indirectly"), 
				(LPCTSTR)CDisp(pPinOut))) ;
            hr = pPinOut->ConnectedTo(&pPinIn) ;
        }

        if (/* SUCCEEDED(hr) && */ pPinIn) // already connected out pin of DVD src
        {
            pPinIn->Release() ;   // let the in pin go
        }
        else
        {
            DbgLog((LOG_ERROR, 4, TEXT("NOTE: Pin %s is not connected"), 
				(LPCTSTR)CDisp(pPinOut))) ;
            if (0 == (dwStreamOut & pStatus->dwFailedStreamsFlag))  // hasn't yet been set
            {
                pStatus->iNumStreamsFailed++ ;
                pStatus->dwFailedStreamsFlag |= dwStreamOut ;
            }
            hrFinal = S_FALSE ;
        }
		
        pPinOut->Release() ;  // let the out pin go
    }  // end of while (S_OK == ...->Next())
	
    pEnumSrcPins->Release() ;  // done with src pin enum
	
    // Check that at least one stream has been rendered right. Otherwise
    // fail the method.
    if (pStatus->iNumStreamsFailed >= pStatus->iNumStreams)
    {
        DbgLog((LOG_ERROR, 0, TEXT("None of the %d DVD streams rendered right (failed %d)"), 
			pStatus->iNumStreams, pStatus->iNumStreamsFailed)) ;
        hrFinal = VFW_E_DVD_RENDERFAIL ;
    }
	
    return hrFinal ;
}


//
// Build the DVD playback graph using all/most HW decoder
//
HRESULT CDvdGraphBuilder::MakeGraphHW(BOOL bHWOnly, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::MakeGraphHW(%d, 0x%lx)"),
		bHWOnly, pStatus)) ;
	
    HRESULT        hr ;
    HRESULT        hrFinal = S_OK ;
    CListDecoders  HWDecs ;
	
    //
    // If graph was previously built and we are rebuilding now (may be with
    // different options) then clear the existing graph.
    //
    if (m_bGraphDone)
        ClearGraph() ;
	
    //
    // Build using as many HW decoders as possible
    //
    hr = CreateDVDHWDecoders(&HWDecs) ;
    if (FAILED(hr)  ||  0 == HWDecs.GetNumHWFilters())
    {
        if (bHWOnly)
        {
            DbgLog((LOG_ERROR, 4, TEXT("No hardware DVD decoder found, but only HW decoding asked"))) ;
            return VFW_E_DVD_DECNOTENOUGH ;
        }
        else
        {
            DbgLog((LOG_TRACE, 4, TEXT("No hardware DVD decoder found, HW decoding was preferred"))) ;
        }
    }
	
    IBaseFilter *pSrc ;
	
    // Instantiate DVD Nav, only if user hasn't specified a DVD source filter
    if (m_pDVDSrc)
        pSrc = m_pDVDSrc ;
    else
    {
        hr = CreateFilterInGraph(CLSID_DVDNavigator, TEXT("DVD Navigator"), &m_pDVDNav) ;
        if (FAILED(hr)  ||  NULL == m_pDVDNav)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: DVD Nav couldn't be instantiated (Error 0x%lx)"), hr)) ;
            return VFW_E_DVD_RENDERFAIL ;
        }
        pSrc = m_pDVDNav ;
    }
	
    //
    //  Connect DVD source filters' output pins (as many as possible) to the
    //  input pins of the HW decoder filters (if any).
    //
    hr = ConnectSrcToHWDec(pSrc, &HWDecs, pStatus) ;
    if (FAILED(hr))
    {
        return VFW_E_DVD_RENDERFAIL ;  // hr ;
    }
	
    if (S_OK != hr  &&  !bHWOnly)  // if some pins are unconnected AND only if not HW-only
    {
        //
        // If we still have any output pin unconnected then try to find some
        // SW decoder to connect to.  So go through the list once more.
        //
        hr = ConnectSrcToSWDec(pSrc, pStatus) ;
        if (FAILED(hr))
        {
            return VFW_E_DVD_RENDERFAIL ;  // hr ;
        }
    }
	
    // Check if all the output pin of DVD source have been connected.  If not
    // set the warning sign for the caller to catch.
    hr = CheckSrcPinConnection(pSrc, pStatus) ;
    if (S_OK != hr && SUCCEEDED(hrFinal))
        hrFinal = hr ;
	
    // The other DVD HW decoders will get unloaded when we exit this function
    // as that will be out of scope for the HWDecs object causing its
    // destructor to be called which frees all unused items in the list.
	
    return hrFinal ;
}


//
// Build the DVD playback graph using all/most SW decoders
//
HRESULT CDvdGraphBuilder::MakeGraphSW(BOOL bSWOnly, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::MakeGraphSW(%d, 0x%lx)"),
		bSWOnly, pStatus)) ;
	
    HRESULT      hr ;
    HRESULT      hrFinal = S_OK ;
    IBaseFilter *pSrc ;
	
    //
    // If graph was previously built and we are rebuilding now (may be with
    // different options) then clear the existing graph.
    //
    if (m_bGraphDone)
        ClearGraph() ;
	
    // Instantiate DVD Nav, only if user hasn't specified a DVD source filter
    if (m_pDVDSrc)
        pSrc = m_pDVDSrc ;
    else
    {
        hr = CreateFilterInGraph(CLSID_DVDNavigator, TEXT("DVD Navigator"), &m_pDVDNav) ;
        if (FAILED(hr)  ||  NULL == m_pDVDNav)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: DVD Nav couldn't be instantiated (Error 0x%lx)"), hr)) ;
            return VFW_E_DVD_RENDERFAIL ;
        }
        pSrc = m_pDVDNav ;
    }
	
    //
    //  Connect DVD source filters' output pins (as many as possible) to the
    //  input pins of the SW decoder filters (if any).
    //
    hr = ConnectSrcToSWDec(pSrc, pStatus) ;
    if (FAILED(hr))
    {
        return VFW_E_DVD_RENDERFAIL ;  // hr ;
    }
	
    if (0 == m_Decoders.GetNumSWFilters())
    {
        if (bSWOnly)
        {
            DbgLog((LOG_ERROR, 4, TEXT("No software DVD decoder found, but only SW decoding asked"))) ;
            return VFW_E_DVD_DECNOTENOUGH ;
        }
        else
        {
            DbgLog((LOG_TRACE, 4, TEXT("No software DVD decoder found, SW decoding was preferred"))) ;
        }
    }
	
    if (S_OK != hr && !bSWOnly)  // if not all pins are connected AND if not SW-only
    {
        //
        // If we still have any output pin unconnected then try to find some
        // HW decoder to connect to.  So go through the list once more.
        //
        CListDecoders HWDecs ;
        hr = CreateDVDHWDecoders(&HWDecs) ;
        if (FAILED(hr) || 0 == HWDecs.GetNumHWFilters())  // no HW decoder found
        {
            DbgLog((LOG_ERROR, 4, TEXT("HW Decoders couldn't be instantiated/found."))) ;
        }
        else  // got some HW decoders; try them
        {
            hr = ConnectSrcToHWDec(pSrc, &HWDecs, pStatus) ;
            if (FAILED(hr))
            {
                return VFW_E_DVD_RENDERFAIL ;  // hr ;
            }
        }
    }
	
    // Check if all the output pin of DVD source have been connected.  If not
    // set the warning sign for the caller to catch.
    hr = CheckSrcPinConnection(pSrc, pStatus) ;
    if (S_OK != hr && SUCCEEDED(hrFinal))
        hrFinal = hr ;
	
    // The other DVD HW decoders will get unloaded when we exit this function
    // as that will be out of scope for the HWDecs object causing its
    // destructor to be called which frees all unused items in the list.
	
    return hrFinal ;
}


#define CLSID_VideoMixer CLSID_OverlayMixer

//
// Complete the DVD playback graph by bringing in renderers etc.
//
HRESULT CDvdGraphBuilder::RenderDecoderOutput(AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderDecoderOutput(0x%lx)"), pStatus)) ;
	
    int           i ;
    BOOL          bHW ;
    IBaseFilter  *pDecFilter ;
    HRESULT       hr ;
    IEnumPins    *pEnumPins ;
    IPin         *pPinOut ;
    ULONG         ul ;
    PIN_DIRECTION pd ;
    LPTSTR        lpszName ;
    int           iAll = m_Decoders.GetNumFilters() ;
    int           iHW  = m_Decoders.GetNumHWFilters() ;
    HRESULT       hrFinal = S_OK ;
	
    //
    // If caller didn't object about VPE, we need to create the 
    // VideoMixer first and then do the Render; otherwise it fails 
    // anyway!!!  If the caller doesn't want VPE, we'll let it
    // fail by not creating VideoMixer and detect the failure using 
    // the DetectFailedHWPin() call.
    //
    // To render the video output pin. We are going to use 
    // overlay mixing for SW decoders
    //
    if (m_bUseVPE)
    {
        // Create VideoMixer, Line21 decoder and Video Renderer here 
        // (just because it's easier)
        hr = CreateFilterInGraph(CLSID_VideoRenderer, TEXT("Video Renderer"), &m_pVR) ;
        ASSERT(SUCCEEDED(hr) && m_pVR) ;
        if (FAILED(hr) || NULL == m_pVR)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't start Video Renderer -- no display on monitor"))) ;
            pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;  // can't show CC or Video
            hrFinal = FALSE ;
        }
        hr = CreateFilterInGraph(CLSID_VideoMixer, TEXT("Overlay Mixer"),
			                     &m_pVM) ;
        if (FAILED(hr) || NULL == m_pVM)
        {
            DbgLog((LOG_ERROR, 1, TEXT("Couldn't start VideoMixer -- no mixing"))) ;
            pStatus->hrVPEStatus = hr ;
            hrFinal = FALSE ;
        }
        // If the app specified any DDraw object AND surface via the IDvdGraphBuilder2
        // interface, pass them to the OverlayMixer now.
        if (m_pDDrawObject && m_pDDrawSurface)
        {
            DbgLog((LOG_TRACE, 0, TEXT("App has specified DDraw object/surface. Use it."))) ;
            IDDrawExclModeVideo  *pDDXM ;
            hr = m_pVM->QueryInterface(IID_IDDrawExclModeVideo, (LPVOID *) &pDDXM) ;
            if (FAILED(hr) || NULL == pDDXM)
            {
                DbgLog((LOG_ERROR, 0, TEXT("ERROR: IDDrawExclModeVideo not supported on Overlay Mixer."))) ;
                return E_UNEXPECTED ;
            }
            hr = pDDXM->SetDDrawObject(m_pDDrawObject) ;
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 0, 
                    TEXT("ERROR: IDDrawExclModeVideo::SetDDrawObject() failed (Error 0x%lx)"), hr)) ;
                pDDXM->Release() ;
                return hr ;
            }
            hr = pDDXM->SetDDrawSurface(m_pDDrawSurface) ;
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 0, 
                    TEXT("ERROR: IDDrawExclModeVideo::SetDDrawSurface() failed (Error 0x%lx)"), hr)) ;
                pDDXM->SetDDrawObject(NULL) ;  // reset the DDraw object on OvMixer
                pDDXM->Release() ;
                return hr ;
            }
            pDDXM->Release() ;
        }
        hr = CreateFilterInGraph(CLSID_Line21Decoder, TEXT("Line21 Decoder"), &m_pL21Dec) ;
        if (FAILED(hr) || NULL == m_pL21Dec)
        {
            DbgLog((LOG_ERROR, 3, TEXT("Couldn't start Line21 Dec -- no CC"))) ;
            hrFinal = FALSE ;
        }
    }
	
    //
    // Assume that video decoder (HW/SW) doesn't produce Line21 data and
    // we don't render it right until we find some proof otherway.
    //
    pStatus->bNoLine21In  = TRUE ;
    pStatus->bNoLine21Out = TRUE ;
	
    //
    // We must not connect the output of any other filter to any pin of the 
    // Video mixer filter (VPMixer/OverlayMixer) until the video decoder's 
    // output pin is connected to its primary input pin.  So if the CC pin
    // or Subpicture pin is enumerated before the video out pin of the decoder,
    // we have to remember to render them later.
    //
    // We should reset these late-rendering-helper-members
    //
    m_dwVideoRenderStatus = 0 ;
    m_pL21PinToRender     = NULL ;
    m_pSPPinToRender      = NULL ;
	
    // render the output pins of all the decoders used
    IPin  *pPinIn ;
    for (i = 0 ; i < iAll ; i++)
    {
        if (! m_Decoders.GetFilter(i, &pDecFilter, &lpszName, &bHW) )
        {
            DbgLog((LOG_ERROR, 0, TEXT("*** INTERNAL ERROR: Can't get filter from decoder list ***"))) ;
			ASSERT(FALSE) ;  // so that we know
            continue ;      // at least avoid faulting
        }
        ASSERT(pDecFilter) ;
        hr = pDecFilter->EnumPins(&pEnumPins) ;
        ASSERT(SUCCEEDED(hr) && pEnumPins) ;
        pEnumPins->Reset() ;
		
        while (S_OK == pEnumPins->Next(1, &pPinOut, &ul) && 1 == ul)
        {
            hr = pPinOut->QueryDirection(&pd) ;
            ASSERT(SUCCEEDED(hr)) ;
            if (PINDIR_INPUT == pd)   // don't want input pin
            {
                pPinOut->Release() ;  // don't need this pin
                continue ;
            }
            hr = pPinOut->ConnectedTo(&pPinIn) ;
            if (SUCCEEDED(hr) && pPinIn)  // don't want connected pin
            { 
                pPinIn->Release() ;      // not interseted in it
                pPinOut->Release() ;     // not this one
                continue ;
            }
			
            //
            // If the decoder is HW based, the proxy doesn't let us enum
            // the supported media types and then connect to a suitable in
            // pin on the other side.
            //
            if (bHW)
                hr = RenderHWOutPin(pPinOut, pStatus) ;
            else
                hr = RenderSWOutPin(pPinOut, pStatus) ;
			
            if (S_OK != hr)       // if not perfect
                hrFinal = hr ;    // use this error code
			
            pPinOut->Release() ;  // done with this pin
			
        }  // end of while (pEnumPins->Next()...)
		
        pEnumPins->Release() ;    // done with this enumerator
    } // end of for (i)
	
    //
    // If the caller didn't object about VPE (i.e, on-screen playback) then connect
    // the video mixer to the video renderer.
    //
    if (m_bUseVPE)
    {
        if (NULL == m_pVM)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Video Mixer didn't start -- no CC at least"))) ;
            // pStatus->bNoLine21Out = TRUE ;  // can't show CC with video
            if (NULL == m_pVR)
            {
                DbgLog((LOG_ERROR, 1, TEXT("WARNING: Video Renderer didn't start!!!"))) ;
                // we have already set the video stream flag in pStatus->dwFailedStreamsFlag
            }
            if (S_OK == hrFinal)  // very unlikely that we didn't know yet
                hrFinal = S_FALSE ;
        }
        else  // we have video mixer and renderer
        {
            //
            // We should connect the VideoMixer and the VideoRenderer ONLY IF
            // connection to OverlayMixer worked. So check for video render flag.
            //
            if (m_dwVideoRenderStatus & VIDEO_RENDER_MIXER)
            {
                hr = FindOpenPin(m_pVM, PINDIR_OUTPUT, 0, &pPinOut) ;
                if (SUCCEEDED(hr) && pPinOut)
                {
                    if (SUCCEEDED(hr = TryConnect(pPinOut, m_pVR, NULL, TRUE)))
                    {
                        DbgLog((LOG_TRACE, 5, TEXT("Connected %s to Video Renderer"),
							(LPCSTR) CDisp(pPinOut))) ;
                    }
                    else  // Extremely unlikely, well impossible. Still...
					{
                        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't connect %s to Video Renderer (Error 0x%lx)"),
							(LPCSTR) CDisp(pPinOut), hr)) ;
                        pStatus->iNumStreamsFailed++ ;
                        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
                        hrFinal = S_FALSE ;
					}
					
                    pPinOut->Release() ;  // let the pin go now
                }
                else  // Extremely unlikely, well impossible. Still...
				{
                    DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't find the output pin of video mixer"))) ;
                    // pStatus->iNumStreamsFailed++ ;
                    // pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
                    // hrFinal = S_FALSE ;

                    // It's OK if we don't get OvMixer's out pin in this case
                    ASSERT(m_pDDrawObject && m_pDDrawSurface) ;
				}
            }
            else
                DbgLog((LOG_TRACE, 1, TEXT("Couldn't connect to OverlayMixer. VM and VR not connected."))) ;
        }
    }
	
    //
    // There is a possibility that the Line21 decoder's out pin was not rendered
    // fully, because the video pin was not connected to the mixer till then. For
    // this case, we have to do the rendering now.
    //
    hr = CompleteLateRender(pStatus) ;
    if (S_OK != hr  &&  SUCCEEDED(hrFinal))
        hrFinal = S_FALSE ;  // hr?
	
    //
    // Remove any unused filters from the graph (is it necessary?)
    //
    RemoveUnusedFilters(pStatus) ;
	
    //
    // If there was some problem with the getting or rendering Line21 data 
    // then indicate the result as partial success (of course if it's not 
    // worse than that already :-).
    //
    if ((pStatus->bNoLine21In || pStatus->bNoLine21Out) && S_OK == hrFinal)
        hrFinal = S_FALSE ;
	
    //
    // Last minute clean-up:
    // 1.  If the "No VPE" flag was specified in the call, don't bother about CC
    // 2.  If there was no line21 data produced by the video decoder then we 
    //     shouldn't feel bad about not being able decode "nothing".
    //
    if (! m_bUseVPE )
    {
        pStatus->bNoLine21In  = FALSE ;
        pStatus->bNoLine21Out = FALSE ;
    }
    else if (pStatus->bNoLine21In)
        pStatus->bNoLine21Out = FALSE ;
	
    return hrFinal ;
}


//
// Check if we have the Line21 decoder and/or the Subpicture decoder's output
// pin unconnected.  If so, AND if the video decoder's output pin has been
// connected already then complete the remaining pending connections.
//
HRESULT CDvdGraphBuilder::CompleteLateRender(AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CompleteLateRender(0x%lx)"),
		pStatus)) ;
	
    HRESULT   hr = NOERROR ;
	
    if (m_dwVideoRenderStatus & VIDEO_RENDER_MIXER)  // only if video connects to OverlayMixer
    {
        if (m_pSPPinToRender)
        {
            if (SUCCEEDED(hr = TryConnect(m_pSPPinToRender, m_pVM, NULL, TRUE)))
            {
                DbgLog((LOG_TRACE, 1, TEXT("Late render of pin %s done"),
					(LPCSTR)(CDisp) m_pSPPinToRender)) ;
            }
            else
            {
                DbgLog((LOG_ERROR, 2, TEXT("WARNING: Pin %s couldn't be late rendered (Error 0x%lx)"),
					(LPCSTR)(CDisp) m_pSPPinToRender, hr)) ;
                hr = E_FAIL ;  // some problem
            }
			
            // We are done with it.  Reset the flag and pointer...
            m_pSPPinToRender->Release() ;
            m_pSPPinToRender = NULL ;
        }
        if (m_pL21PinToRender)
        {
            if (SUCCEEDED(hr = TryConnect(m_pL21PinToRender, m_pVM, NULL, TRUE)))
            {
                DbgLog((LOG_TRACE, 1, TEXT("Late render of pin %s done (Error 0x%lx)"),
					(LPCSTR)(CDisp) m_pL21PinToRender, hr)) ;
                pStatus->bNoLine21Out = FALSE ; // line21 data has been rendered
            }
            else
            {
                DbgLog((LOG_ERROR, 2, TEXT("WARNING: Pin %s couldn't be late rendered"),
					(LPCSTR)(CDisp) m_pL21PinToRender)) ;
                hr = E_FAIL ;  // some problem
            }
			
            // We are done with it.  Reset the flag and pointer...
            m_pL21PinToRender->Release() ;
            m_pL21PinToRender = NULL ;
        }
    }
    else  // video rendering failed somehow -- can't do SP/CC
    {
        if (m_pSPPinToRender)
        {
            // Can't do anything -- release the interface and set SP render failure flag
            m_pSPPinToRender->Release() ;
            m_pSPPinToRender = NULL ;
            if (0 == (pStatus->dwFailedStreamsFlag & AM_DVD_STREAM_SUBPIC)) // if not set yet
            {
                pStatus->iNumStreamsFailed++ ;
                pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_SUBPIC ;
            }
        }
        if (m_pL21PinToRender)
        {
            // Can't do anything -- release the interface and set CC render failure flag
            m_pL21PinToRender->Release() ;
            m_pL21PinToRender = NULL ;
            pStatus->bNoLine21Out = TRUE ;  // couldn't render
        }
    }

    return hr ;
}


BOOL CDvdGraphBuilder::RemoveFilterIfUnused(IBaseFilter *pFilter, 
                                            LPCTSTR lpszFilterName)
{
    IEnumPins  *pEnumPins ;
    HRESULT     hr ;
    IPin       *pPin ;
    IPin       *pPinOther ;
    ULONG       ul ;
    BOOL        bInUse = FALSE ;
	
    if (pFilter)
    {
        hr = pFilter->EnumPins(&pEnumPins) ;
        ASSERT(SUCCEEDED(hr) && pEnumPins) ;
        while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
        {
            pPin->ConnectedTo(&pPinOther) ;
            if (pPinOther)
            {
                pPin->Release() ;
                pPinOther->Release() ;
                bInUse = TRUE ;
                break ;  // done with our search
            }
            pPin->Release() ;
        }
        pEnumPins->Release() ;
        if (!bInUse)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Releasing unncessary filter %s"), lpszFilterName)) ;
            m_pGB->RemoveFilter(pFilter) ;
            pFilter->Release() ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("Filter %s is being used"), lpszFilterName)) ;
        }
    }
	
    return (! bInUse ) ;  // removed / in use
}


HRESULT CDvdGraphBuilder::RemoveUnusedFilters(AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RemoveUnusedFilters(0x%lx)"),
		pStatus)) ;
	
    //
    // Check if Line21 decoder, Video Mixer, Video and Audio Renderer are 
    // unused (and unconnected). If so, remove and free them.
    //
    if (RemoveFilterIfUnused(m_pVM, TEXT("Overlay Mixer")))
        m_pVM = NULL ;
	
    // Line21 decoder is removed if either
    // a) it's not in use, i.e, not connected on either side  or
    // b) it's connected on at least one side, but bLine21In/Out flag is set
    //    indicating the connection wasn't completely successful and CC won't work.
    if (RemoveFilterIfUnused(m_pL21Dec, TEXT("Line21 Decoder")))
        m_pL21Dec = NULL ;
    else if (pStatus->bNoLine21In || pStatus->bNoLine21Out &&  // if somehow CC won't work,
		     m_pL21Dec)                                        // but we have a L21Dec
    {
        DbgLog((LOG_TRACE, 1, TEXT("Line21 decoder was connected, but won't work. Hence removed."))) ;
        m_pGB->RemoveFilter(m_pL21Dec) ;
        m_pL21Dec->Release() ;
        m_pL21Dec = NULL ;
    }
	
    if (RemoveFilterIfUnused(m_pVR, TEXT("VideoRenderer")))
        m_pVR = NULL ;
	
    if (RemoveFilterIfUnused(m_pAR, TEXT("AudioRenderer")))
        m_pAR = NULL ;
	
    return NOERROR ;
}


void CDvdGraphBuilder::RenderUnknownPin(IPin *pPinOut)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderUnknownPin(0x%lx)"),
		pPinOut)) ;
	
	HRESULT   hr = m_pGB->Render(pPinOut) ;
    if (FAILED(hr))
    {
		DbgLog((LOG_TRACE, 3, TEXT("Rendering (%s) failed (Error 0x%lx)"),
			(LPCSTR) CDisp(pPinOut), hr)) ;
    }
    else  // seems to have rendered
    {
        IPin  *pPinIn ;
		pPinOut->ConnectedTo(&pPinIn) ;
        if (pPinIn)
        {
			DbgLog((LOG_TRACE, 3, TEXT("Pin %s with unknown mediatype rendered successfully"),
				(LPCSTR) CDisp(pPinOut))) ;
			pPinIn->Release() ;
        }
        else  // this may be the NTSC out pin
		{
			DbgLog((LOG_TRACE, 3, TEXT("Pin %s with unknown mediatype actually wasn't rendered"),
				(LPCSTR) CDisp(pPinOut))) ;
			// but we don't care anymore about it. So ignore it.
		}
	}
}


HRESULT CDvdGraphBuilder::RenderAudioOutPin(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderAudioOutPin(0x%lx, 0x%lx)"),
			pPinOut, pStatus)) ;
	
	HRESULT   hr ;
	
	if (NULL == m_pAR)
	{
		hr = CreateFilterInGraph(CLSID_DSoundRender, TEXT("DSound Renderer"), &m_pAR) ;
		if (FAILED(hr) || NULL == m_pAR)  // couldn't instantiate audio renderer
        {
		    DbgLog((LOG_ERROR, 0,
			    TEXT("Couldn't instantiate audio renderer (Error 0x%lx)"), hr)) ;
		    pStatus->iNumStreamsFailed++ ;
		    pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_AUDIO ;
			return hr ;
        }
	}
	else	// weird -- who started audio renderer?
		ASSERT(NULL == m_pAR) ;  // so that we know
	
	hr = TryConnect(pPinOut, m_pAR, NULL, FALSE) ;
	if (FAILED(hr))
	{
		DbgLog((LOG_TRACE, 3, 
			TEXT("Couldn't even indirectly connect pin (%s) to audio renderer (Error 0x%lx)"),
			(LPCTSTR) CDisp(pPinOut), hr)) ;
		pStatus->iNumStreamsFailed++ ;
		pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_AUDIO ;
		return hr ;
	}
	
	return NOERROR ;
}


HRESULT CDvdGraphBuilder::ConnectLine21OutPin(IPin *pPinOut)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::ConnectLine21OutPin(0x%lx)"),
			pPinOut)) ;
	
	HRESULT   hr = TryConnect(pPinOut, m_pL21Dec, NULL, TRUE) ;
	if (FAILED(hr))
	{
		DbgLog((LOG_TRACE, 5, 
			TEXT("Couldn't connect Line21 out to Line21Dec (Error 0x%lx)"),
			hr)) ;
		return hr ;
	}

	DbgLog((LOG_TRACE, 5, TEXT("Line21 output connected to Line21 Dec"))) ;
				
	ASSERT(NULL == m_pL21PinToRender) ;
    hr = FindOpenPin(m_pL21Dec, PINDIR_OUTPUT, 0, &m_pL21PinToRender) ;
    ASSERT(SUCCEEDED(hr) && m_pL21PinToRender) ;
				
    //
    // We should connect the Line21 Decoder output to the
    // VideoMixer ONLY IF the decoded video stream has already
    // been connected.
    //
    if (m_dwVideoRenderStatus & VIDEO_RENDER_MIXER)
    {
		DbgLog((LOG_TRACE, 5, TEXT("Going to connect CC output to video mixer..."))) ;
        if (SUCCEEDED(hr = TryConnect(m_pL21PinToRender, m_pVM, NULL, TRUE)))
			DbgLog((LOG_TRACE, 5, TEXT("L21Dec output connected to video mixer"))) ;
        else
			DbgLog((LOG_ERROR, 1, 
				TEXT("WARNING: L21Dec output COULDN'T be connected to Video mixer (Error 0x%lx)"), hr)) ;

        // Don't need to maintain this late rendering info anymore
        m_pL21PinToRender->Release() ;
        m_pL21PinToRender = NULL ;
    }
    else
    {
		DbgLog((LOG_TRACE, 1, TEXT("Video stream not rendered fully. L21Dec render deferred."))) ;
        //
        // There is a chance that we'll be able to do a late render on 
        // this pin after the video pin is rendered. So retain the info 
        // and try at last.
        //
    }

	return hr ;
}


HRESULT CDvdGraphBuilder::RenderHWOutPin(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderHWOutPin(0x%lx, 0x%lx)"),
		pPinOut, pStatus)) ;
	
    HRESULT         hr ;
    HRESULT         hrFinal = S_OK ;
    IPin           *pPinIn ;
    DWORD           dwStream ;
	
    dwStream = StreamFlagForHWPin(pPinOut) ;
	
    if (m_bUseVPE)  // display video (and CC) on screen
    {
        if (AM_DVD_STREAM_VIDEO == dwStream)  // this pin is video (VPE) out
        {
            if (FAILED(hr = TryConnect(pPinOut, m_pVM, NULL, TRUE))) // connect VPE outpin to OverlayMixer
            {
                DbgLog((LOG_TRACE, 1, TEXT("Can't render pin (%s) (Error 0x%lx)"),
					(LPCTSTR) CDisp(pPinOut), hr)) ;
                hrFinal = S_FALSE ;
                pStatus->iNumStreamsFailed++ ;  // video stream not rendered right
                pStatus->dwFailedStreamsFlag |= dwStream ;
                pStatus->hrVPEStatus = hr ;   // TryConnect() returns VPE failure code
            }
            else  // VPE out pin connected !!!
                m_dwVideoRenderStatus = VIDEO_RENDER_MIXER ;
        }
        else if (AM_DVD_STREAM_LINE21 == dwStream)  // this pin is Line21 out
        {
            if (m_pDDrawSurface)  // app's primary surface
            {
                DbgLog((LOG_TRACE, 3, TEXT("Using app's primary surface. No CC shown (ignored)"))) ;
                pStatus->bNoLine21In  = FALSE ;
                pStatus->bNoLine21Out = FALSE ;
            }
            else  // normal case -- using OvMixer's primary surface
            {
                pStatus->bNoLine21In  = FALSE ;  // CC data produced by decoder
                if (FAILED(hr = ConnectLine21OutPin(pPinOut))) // connect to Line21 Decoder
                {
                    hrFinal = S_FALSE ;
                    pStatus->bNoLine21Out = TRUE ;   // line21 couldn't be rendered
                }
                else  // Line21 out pin connected !!!
                    pStatus->bNoLine21Out = FALSE ;
            }
        }  // end of else if (dwStream == .._LINE21)
		else if (AM_DVD_STREAM_AUDIO == dwStream) // audio out pin (very unlikely)
		{
			hr = RenderAudioOutPin(pPinOut, pStatus) ;
			if (FAILED(hr))
				hrFinal = S_FALSE ;
		}
        else  // didn't connect to known filters -- try to just render
        {
			RenderUnknownPin(pPinOut) ;
        }  // end of else of if (AM_DVD_STREAM_... == dwStream)
    }
    else   // w/o using VPE, i.e, on-screen display
    {
        DbgLog((LOG_TRACE, 4, TEXT("User doesn't want VPE - no Video/CC to be rendered"))) ;
		if (AM_DVD_STREAM_VIDEO == dwStream)
			; // just ignore
		else if (AM_DVD_STREAM_LINE21 == dwStream)
		{
			pStatus->bNoLine21In  = FALSE ;
			pStatus->bNoLine21Out = FALSE ;
		}
		else if (AM_DVD_STREAM_AUDIO == dwStream)
		{
			hr = RenderAudioOutPin(pPinOut, pStatus) ;
			if (FAILED(hr))
				hrFinal = S_FALSE ;
		}
        else  // don't know the media type
        {
			RenderUnknownPin(pPinOut) ;
        }
    }
	
    return hrFinal ;
}


HRESULT CDvdGraphBuilder::RenderSWOutPin(IPin *pPinOut, AM_DVD_RENDERSTATUS *pStatus)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::RenderSWOutPin(0x%lx, 0x%lx)"),
		pPinOut, pStatus)) ;
	
    IEnumMediaTypes *pEnumMT ;
    ULONG            ul ;
    AM_MEDIA_TYPE   *pmt ;
    HRESULT          hr ;
    HRESULT          hrFinal = S_OK ;
	
    hr = pPinOut->EnumMediaTypes(&pEnumMT) ;
    ASSERT(SUCCEEDED(hr) && pEnumMT) ;
    pEnumMT->Reset() ;
    hr = pEnumMT->Next(1, &pmt, &ul) ;  // getting 1st media type is fine
    ASSERT(SUCCEEDED(hr) && 1 == ul) ;
    if (pmt->majortype == MEDIATYPE_Video)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Going to render 'video' out pin (%s) of decoder"), 
            (LPCTSTR)CDisp(pPinOut))) ;

        //
        // The SW video and SP decoder both output video majortype samples.
        // So we need to distinguish them before we try to connect them and 
        // act accordingly.
        //
        DWORD dwStream = GetInTypeForVideoOutPin(pPinOut) ;
        if (AM_DVD_STREAM_VIDEO  != dwStream &&
            AM_DVD_STREAM_SUBPIC != dwStream)
        {
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: Video out pin not from video or subpic in pin"))) ;
            goto FinalExit ;  // I hate "goto", but otherwise it's too complex
        }
		
        if (NULL == m_pVM)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't start VideoMixer -- no mixing"))) ;
            pStatus->bNoLine21Out = TRUE ;
            if (AM_DVD_STREAM_SUBPIC == dwStream)
            {
                DbgLog((LOG_TRACE, 1, TEXT("Subpic stream not rendered because no videomixer"))) ;
                pStatus->iNumStreamsFailed++ ;
                pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_SUBPIC ;
            }
            else if (AM_DVD_STREAM_VIDEO == dwStream)
            {
                DbgLog((LOG_TRACE, 1, TEXT("Video stream not rendered because no videomixer"))) ;
                pStatus->iNumStreamsFailed++ ;
                pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
            }
            else
            {
                DbgLog((LOG_TRACE, 1, TEXT("Unknown stream (Id: 0x%x) not rendered"), dwStream)) ;
            }
#if 0
            else if (SUCCEEDED(hr = TryConnect(pPinOut, m_pVR, NULL, TRUE)))
            {
                DbgLog((LOG_TRACE, 5, TEXT("Video decoder's output connected to VR"))) ;
                // Though the Video stream has been rendered here, we don't 
                // go through the VideoMixer and hence can't mix the CC (and SP, if any)
                // stream. So we set the m_dwVideoRenderStatus value to VIDEO_RENDER_VR, 
                // which is checked before Line21 Decoder output is connected.
                // (I know it's kind of hacky, but...).
                m_dwVideoRenderStatus = VIDEO_RENDER_VR ;  // connected to VR directly
            }
            else  // very weird, but...
            {
                DbgLog((LOG_ERROR, 1, 
                    TEXT("WARNING: Video decoder's output COULDN'T be connected to VR (Error 0x%lx)"), hr)) ;
                pStatus->iNumStreamsFailed++ ;
                pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
            }
#endif // #if 0
            hrFinal = S_FALSE ;  // not perfect, but...
        }
        else  // VideoMixer started fine; try to connect
        {
            //
            // We should connect the decoded subpicture stream to the
            // VideoMixer ONLY IF the decoded video stream has already
            // been connected.
            //
            if (AM_DVD_STREAM_SUBPIC == dwStream)
            {
                if (m_dwVideoRenderStatus & VIDEO_RENDER_MIXER)
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Going to connect subpic output to video mixer..."))) ;
                    if (SUCCEEDED(hr = TryConnect(pPinOut, m_pVM, NULL, TRUE)))
                    {
                        DbgLog((LOG_TRACE, 5, TEXT("subpic output connected to video mixer's 2nd+ in pin"))) ;
                    }
                    else
                    {
                        DbgLog((LOG_ERROR, 1, 
                            TEXT("WARNING: Subpic output COULDN'T be connected to Video mixer (Error 0x%lx)"), hr)) ;
                        pStatus->iNumStreamsFailed++ ;
                        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_SUBPIC ;
                    }
                }
                else
                {
                    DbgLog((LOG_TRACE, 1, TEXT("Video stream not rendered fully. Subpic render deferred."))) ;
                    //
                    // We'll do a late render on this pin after the video pin is
                    // rendered. So retain the info and try at last.
                    //
                    m_pSPPinToRender = pPinOut ;  // maintain this out pin as SP out pin
                    m_pSPPinToRender->AddRef() ;  // because we release it after late render
                }
            }
            else  // it's the decoded video output pin
            {
                // Make sure that the video out pin is not already connected,
                // in which case the following connection to VR is unnecessary
                // (and will fail causing a wrong flag to be set).
                if (m_dwVideoRenderStatus & VIDEO_RENDER_MIXER)
                {
                    // We should not hit this code at all.  But if we ever do,
                    // just get out of here.
                    DbgLog((LOG_TRACE, 0, 
                            TEXT("WARNING: Pin <%s> is video? But video is already connected to mixer!!"),
                            (LPCSTR) CDisp(pPinOut))) ;
                }
                else  // let's try to connect video to OverlayMixer
                {
                    if (SUCCEEDED(hr = TryConnect(pPinOut, m_pVM, NULL, TRUE)))  // set video to mixer flag
                    {
                        DbgLog((LOG_TRACE, 5, TEXT("Video Dec output connected to VideoMixer"))) ;
                        m_dwVideoRenderStatus = VIDEO_RENDER_MIXER ;  // video pin connected to mixer
                    }
                    else  // try to connect video to VR as last resort
                    {
                        DbgLog((LOG_ERROR, 1, 
                            TEXT("WARNING: Video Dec output COULDN'T be connected to VideoMixer (Error 0x%lx)"), hr)) ;
                        pStatus->hrVPEStatus = hr ;  // pass the error code up the app
                        pStatus->iNumStreamsFailed++ ;
                        pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
                        m_dwVideoRenderStatus = VIDEO_RENDER_FAILED ;  // just can't render video
                        hrFinal = S_FALSE ;  // not perfect, but...

                        // We won't try connecting to the VR directly in this case.
#if 0
                        if (SUCCEEDED(hr = TryConnect(pPinOut, m_pVR, NULL, TRUE)))  // just try to connect to video renderer
                        {
                            DbgLog((LOG_TRACE, 5, TEXT("Video decoder's output directly connected to VR"))) ;
						    // Though the Video stream has been rendered here, we don't 
						    // go through the VideoMixer and hence can't mix the CC (and SP, if any)
						    // stream. So we set the m_dwVideoRenderStatus value to VIDEO_RENDER_VR
                            // so that we know that we got the video out pin, but CC / SP streams
                            // can't be mixed/rendered.
                            m_dwVideoRenderStatus = VIDEO_RENDER_VR ;  // video is rendered, but....
                        }
                        else  // very very weird
                        {
                            DbgLog((LOG_ERROR, 1, 
                                TEXT("WARNING: Video decoder's output COULDN'T be connected to VR (Error 0x%lx)"), hr)) ;
                            pStatus->iNumStreamsFailed++ ;
                            pStatus->dwFailedStreamsFlag |= AM_DVD_STREAM_VIDEO ;
                            m_dwVideoRenderStatus = VIDEO_RENDER_FAILED ;  // just can't render video
                        }
#endif // #if 0
                    }  // end of else of if (TryConnect(.., VM, ..)
                }  // end of else of if (m_dwVideoRenderStatus & ..MIXER)
            }  // end of else of if (subpicture stream)
        }  // end of else of if (no VideoMixer)
    }  // end of if (mediatype is video)
    else if (pmt->majortype == MEDIATYPE_Audio)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Going to render 'audio' out pin (%s) of decoder"), 
            (LPCTSTR)CDisp(pPinOut))) ;

        hr = RenderAudioOutPin(pPinOut, pStatus) ;
        if (FAILED(hr))
            hrFinal = S_FALSE ;  // not perfect, but...
    }  // end of if (mediatype is audio)
    else if (pmt->majortype == MEDIATYPE_AUXLine21Data)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Going to render 'line21' out pin (%s) of decoder"), 
            (LPCTSTR)CDisp(pPinOut))) ;

        pStatus->bNoLine21In = FALSE ;  // got line21 data input
		
        //
        // When the video is being decoded in SW and the caller doesn't
        // want to use VPE (i.e, not on monitor), we can't show CC too;
        // there is no point trying to render the Line21 output pin.
        //
        if (NULL == m_pVM)
        {
            DbgLog((LOG_TRACE, 1, TEXT("WARNING: not Video Mixer => no CC rendering"))) ;
            hrFinal = S_FALSE ;   // not perfect, but...
            pStatus->bNoLine21Out = TRUE ;  // CC not available
        }
        else
        {
            //
            // There is a Video Mixer. So we should decode Line21 data and mix 
            // it with the video stream.
            //
            if (m_pDDrawSurface)  // app's primary surface
            {
                DbgLog((LOG_TRACE, 3, TEXT("Using app's primary surface. No CC shown (ignored)"))) ;
                pStatus->bNoLine21In  = FALSE ;
                pStatus->bNoLine21Out = FALSE ;
            }
            else  // normal case -- using OvMixer's primary surface
            {
                if (FAILED(hr = ConnectLine21OutPin(pPinOut))) // connect to Line21 Decoder
                {
                    hrFinal = S_FALSE ;
                    pStatus->bNoLine21Out = TRUE ;   // line21 couldn't be rendered
                }
                else  // Line21 out pin connected !!!
                    pStatus->bNoLine21Out = FALSE ;
            }
        }   // end of else of if (NULL == m_pVM)
    }   // end of else if (majortype == AUXLine21Data)
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: a non-audio/video/line21 out pin!!"))) ;
    }
	
FinalExit:
    DeleteMediaType(pmt) ;
    pEnumMT->Release() ;  // done with Media Type enum
	
    return hrFinal ;
}



//
// Helper function to detect a (in) pin from its connection mediatype
//
DWORD CDvdGraphBuilder::GetStreamFromMediaType(IPin *pPin)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetStreamFromMediaType(%s)"), 
        (LPCSTR) CDisp(pPin))) ;

    DWORD           dwStream = 0 ;
    AM_MEDIA_TYPE   mt ;

    HRESULT hr = pPin->ConnectionMediaType(&mt) ;
    ASSERT(SUCCEEDED(hr)) ;
    if ( mt.majortype == MEDIATYPE_MPEG2_PES ||
         mt.majortype == MEDIATYPE_DVD_ENCRYPTED_PACK ||
         mt.majortype == MEDIATYPE_Video )
    {
        if (mt.subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            dwStream = AM_DVD_STREAM_VIDEO ;
        else if (mt.subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            dwStream = AM_DVD_STREAM_SUBPIC ;
        else
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: Non-video/SP subtype for video data!!!"))) ;
    }
    else if ( mt.majortype == MEDIATYPE_MPEG2_PES ||
         mt.majortype == MEDIATYPE_DVD_ENCRYPTED_PACK ||
         mt.majortype == MEDIATYPE_Audio )
    {
        if (mt.subtype == MEDIASUBTYPE_DOLBY_AC3)
            dwStream = AM_DVD_STREAM_AUDIO ;
        else
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: Non-audio subtype for audio data!!!"))) ;
    }
    else
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Unknown media type!!!"))) ;

    FreeMediaType(mt) ;  // release the mediatype

    return dwStream ;
}


//
// Given a video output pin, we try to figure out if the input type is video 
// (and subpic) or if it is subpic only.  Because based on that we'll do 
// immediate or deferred pin connect.
//
DWORD CDvdGraphBuilder::GetInTypeForVideoOutPin(IPin *pPinOut)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::GetInTypeForVideoOutPin(%s)"), (LPCSTR) CDisp(pPinOut))) ;

    if (NULL == pPinOut)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Can't get input type for a NULL out pin"),
                (LPCSTR) CDisp(pPinOut))) ;
        return 0 ;
    }

    HRESULT  hr ;
    DWORD    dwStream = 0 ;

    //
    // See if the decoder has any in pin to out pin internal connection info.
    //
    // NOTE:
    // We only expect that in case the out pin has internal connections to more 
    // than 1 in pins then the real in pin be listed first by 
    // QueryInternalConnection() implementation.
    //
    ULONG  ulNum = 0 ;
    IPin  *apPinIn[5] ; // 5 is way too much here
    hr = pPinOut->QueryInternalConnections(apPinIn, &ulNum) ;
    // I am not sure if we should check for S_FALSE or S_OK return from the 
    // above call. So I am using SUCCEEDED().
    if (SUCCEEDED(hr) && ulNum > 0)  // Yahoo!! QueryInternalConnection is supported!!!
    {
        DbgLog((LOG_TRACE, 3, 
            TEXT("Using QueryInternalConnections() to detect in pin of <%s>"), 
            (LPCTSTR) CDisp(pPinOut))) ;
        ASSERT(ulNum <= 5) ;  // just to be sure
        hr = pPinOut->QueryInternalConnections(apPinIn, &ulNum) ;
        if (S_OK == hr)
        {
            if (ulNum > 1)
                DbgLog((LOG_TRACE, 3, 
                    TEXT("** We expect the real in pin to be listed first **"))) ;

            dwStream = GetStreamFromMediaType(apPinIn[0]) ;  // look at 1st pin only

            // Remember to release the IPin interfaces before leaving
            for (ULONG ul = 0 ; ul < ulNum ; ul++)
                apPinIn[ul]->Release() ;

            if (dwStream)          // if we know what it is...
                return dwStream ;  // ...we are done.
        }
    }

    //
    // The filter doesn't give any in pin to out pin internal connection info.
    // So we have to (kind of hack to) find out what type in pin its filter
    // has; there is a possibility that there will be more than 1 in pin in the 
    // filter (as in MediaMatics case), in which case we have to trust that 
    // the video in pin enumerates first, failing which we'll mistake the video out
    // pin as the SP out pin and connection may fail.
    //
    PIN_INFO  pi ;
    hr = pPinOut->QueryPinInfo(&pi) ;
    ASSERT(SUCCEEDED(hr)) ;
    if (NULL == pi.pFilter)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Out pin's filter pointer is NULL"),
                (LPCSTR) CDisp(pPinOut))) ;
        return 0 ;
    }
    IEnumPins *pEnumPins ;
    hr = pi.pFilter->EnumPins(&pEnumPins) ;
    ASSERT(SUCCEEDED(hr) && pEnumPins) ;
    ULONG  ul ;
    IPin  *pPin ;
    PIN_DIRECTION  pd ;
    DWORD  dw ;
    BOOL   bVideoIgnored = FALSE ;  // a way to remember we found a video in pin
    while ( 0 == dwStream  &&
            S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul)
    {
        hr = pPin->QueryDirection(&pd) ;
        ASSERT(SUCCEEDED(hr)) ;
        if (PINDIR_INPUT == pd)
        {
            dw = GetStreamFromMediaType(pPin) ;
            if (AM_DVD_STREAM_VIDEO == dw)  // We got a video in pin
            {
                // HACK: **
                // We want to make sure we are not mistaking the SP out as 
                // video out, but there is no good way left.
                if (VIDEO_RENDER_NONE != m_dwVideoRenderStatus)  // we already got the video out pin
                {
                    DbgLog((LOG_TRACE, 1, 
                        TEXT("We have already got a video out pin. Try after <%s>..."), 
                        (LPCTSTR) CDisp(pPin))) ;
                    bVideoIgnored = TRUE ;
                }
                else    // this is "most likely" to be the video stream
                    dwStream = AM_DVD_STREAM_VIDEO ;
            }
            else if (AM_DVD_STREAM_AUDIO  == dw ||
                     AM_DVD_STREAM_SUBPIC == dw)
                dwStream = dw ;
            else
                DbgLog((LOG_TRACE, 1, TEXT("WARNING: Unknown stream (%lu) found"), dw)) ;
        } // end of if (pd == INPUT)

        pPin->Release() ;  // let the pin go
    }
    pEnumPins->Release() ;
    pi.pFilter->Release() ;

    // (Corresponding) HACK: **
    // if we ignored the video stream, recognize that here
    if (0 == dwStream && bVideoIgnored)
        dwStream = AM_DVD_STREAM_VIDEO ;

    return dwStream ;
}


//
// Try connecting a given output pin to some input pin of the given filter
// that supports the given mediatype
//
HRESULT CDvdGraphBuilder::TryConnect(IPin *pPinOut, IBaseFilter *pFilter,
                                     CMediaType *pmt, BOOL bDirect)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::TryConnect(0x%lx, 0x%lx, 0x%lx, %d)"),
		pPinOut, pFilter, pmt, bDirect)) ;
	
    HRESULT        hr ;
    HRESULT        hrFinal = E_FAIL ;  // suspected at first
    IEnumPins     *pEnumPins ;
    ULONG          ul ;
    IPin          *pPinIn ;
    IPin          *pPin ;
    PIN_DIRECTION  pd ;
	
    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Can't connect %s to a NULL filter"),
			(LPCSTR) CDisp(pPinOut))) ;
        return E_INVALIDARG ;
    }
    if (NULL == pPinOut)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Can't connect a NULL out pin to a filter"))) ;
        return E_INVALIDARG ;
    }
	
    hr = pFilter->EnumPins(&pEnumPins) ;
    if (FAILED(hr) || NULL == pEnumPins)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: pin enum on filter failed!!"))) ;
        return E_UNEXPECTED ;
    }
	
    while (FAILED(hrFinal)  &&
		S_OK == pEnumPins->Next(1, &pPinIn, &ul) && 1 == ul)
    {
        hr = pPinIn->QueryDirection(&pd) ;
        ASSERT(SUCCEEDED(hr)) ;
        if (PINDIR_INPUT == pd)
        {
            hr = pPinIn->ConnectedTo(&pPin) ; // check if pin is already connected
            if (FAILED(hr) || NULL == pPin)   // only if not yet connected...
            {
                if (bDirect)  // must connect directly
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Connect direct out pin (%s) to (%s)"),
                        (LPCSTR) CDisp(pPinOut), (LPCSTR) CDisp(pPinIn))) ;
                    hr = m_pGB->ConnectDirect(pPinOut, pPinIn, NULL) ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Connect indirect out pin (%s) to (%s)"),
                        (LPCSTR) CDisp(pPinOut), (LPCSTR) CDisp(pPinIn))) ;
                    hr = m_pGB->Connect(pPinOut, pPinIn) ;
                }
                if (SUCCEEDED(hr))
                {             
                    DbgLog((LOG_TRACE, 5, TEXT("Connected out pin to a pin of the given filter"))) ;
                    hrFinal = S_OK ;  // we connected!!!
                }
                else
                    hrFinal = hr ;    // this is the actual error
            }
            else  // in pin already connected, skip it.
                pPin->Release() ;  // we don't need the other pin anyway
        }
        pPinIn->Release() ;  // done with this pin
    }
    pEnumPins->Release() ;
	
    return hrFinal ;
}


//
// Instantiate all the HW decoders registered under DVD Hardware Decoder
// group under the Active Filters category.
//

HRESULT CDvdGraphBuilder::CreateDVDHWDecoders(CListDecoders *pHWDecList)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::CreateDVDHWDecoders(0x%lx)"),
		pHWDecList)) ;
	
    HRESULT  hr ;
    ICreateDevEnum *pCreateDevEnum ;
    hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
		IID_ICreateDevEnum, (void**)&pCreateDevEnum) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't create system dev enum (Error 0x%lx)"), hr)) ;
        return hr ;
    }
	
    IEnumMoniker *pEnumMon ;
    hr = pCreateDevEnum->CreateClassEnumerator(CLSID_DVDHWDecodersCategory, 
		&pEnumMon, 0) ;
    pCreateDevEnum->Release() ;
	
    if (S_OK != hr)
    {
        DbgLog((LOG_ERROR, 0, 
			TEXT("WARNING: Couldn't create class enum for DVD HW Dec category (Error 0x%lx)"), 
			hr)) ;
        return E_FAIL ;
    }
	
    hr = pEnumMon->Reset() ;
    
    ULONG     ul ;
    IMoniker *pMon ;
    TCHAR     achName[50] ;  // big enough??
    TCHAR     achFriendlyName[50] ;
    TCHAR     achClsid[50] ;
    while(S_OK == pEnumMon->Next(1, &pMon, &ul) && 1 == ul)
    {
#if 0
        WCHAR   *wszName ;
        pMon->GetDisplayName(0, 0, &wszName) ;
#ifdef UNICODE
        lstrcpy(achName, wszName) ;
#else
        WideCharToMultiByte(CP_ACP, 0, wszName, -1, achName, 50, NULL, NULL) ;
#endif // #if UNICODE
        DbgLog((LOG_TRACE, 5, TEXT("Moniker enum: %s"), achName)) ;
        CoTaskMemFree(wszName) ;
#endif // #if 0
        
        IBaseFilter *pFilter ;
        hr = pMon->BindToObject(0, 0, IID_IBaseFilter, (void**)&pFilter) ;
        if (FAILED(hr) ||  NULL == pFilter)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Couldn't create HW dec filter (Error 0x%lx)"), hr)) ;
            pMon->Release() ;
            continue ;
        }
        DbgLog((LOG_TRACE, 5, TEXT("HW decoder filter found"))) ;
        
        IPropertyBag *pPropBag ;
        pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag) ;
        if(pPropBag)
        {
            {
                VARIANT var ;
                var.vt = VT_EMPTY ;
                pPropBag->Read(L"DevicePath", &var, 0) ;
#ifdef UNICODE
                lstrcpy(achName, var.bstrVal) ;
#else
                WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, achName, 50, NULL, NULL) ;
#endif // #if UNICODE
                DbgLog((LOG_TRACE, 5, TEXT("DevicePath: %s"), achName)) ;
            }
            
            {
                VARIANT var;
                var.vt = VT_EMPTY;
                pPropBag->Read(L"FriendlyName", &var, 0);
#ifdef UNICODE
                lstrcpy(achName, var.bstrVal) ;
#else
                WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, achFriendlyName, 50, NULL, NULL) ;
#endif // #if UNICODE
                DbgLog((LOG_TRACE, 5, TEXT("FriendlyName: %s"), achFriendlyName)) ;
            }
            
            {
                VARIANT var;
                var.vt = VT_EMPTY;
                pPropBag->Read(L"CLSID", &var, 0);
#ifdef UNICODE
                lstrcpy(achClsid, var.bstrVal) ;
#else
                WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, achClsid, 50, NULL, NULL) ;
#endif // #if UNICODE
                DbgLog((LOG_TRACE, 5, TEXT("CLSID: %s"), achClsid)) ;
            }
            
            //
            // We have got a device under the required category. The proxy
            // for it is already instantiated. So add to the list of HW 
            // decoders to be used for building the graph.
            //
            pHWDecList->AddFilter(pFilter, achFriendlyName, TRUE, NULL) ;
            
            pPropBag->Release() ;
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: BindToStorage failed"))) ;
        }
        
        pMon->Release() ;
    }  // end of while()
    
    pEnumMon->Release() ;
	
    DbgLog((LOG_TRACE, 5, TEXT("Found total %d HW decoders"), pHWDecList->GetNumHWFilters())) ;
	
    return NOERROR ;
	
}



//
// Get the stream mediatype flag from the pin of the SW decoder.
// It's a hack to guess the media stream.
//
DWORD CDvdGraphBuilder::StreamFlagFromSWPin(IPin *pPin)
{
    DbgLog((LOG_TRACE, 4, TEXT("CDvdGraphBuilder::StreamFlagFromSWPin(%s)"), 
            (LPCTSTR)CDisp(pPin))) ;
	
    AM_MEDIA_TYPE    *pmt ;
    IEnumMediaTypes  *pEnumMT ;
    HRESULT hr = pPin->EnumMediaTypes(&pEnumMT) ;
    ASSERT(SUCCEEDED(hr) && pEnumMT) ;
    ULONG   ul ;
    DWORD   dwStream = 0 ;
    while (0 == dwStream  &&  // we haven't got a known mediatype
		S_OK == pEnumMT->Next(1, &pmt, &ul) && 1 == ul) // more mediatypes
    {
        // Decipher the mediatype
        if (pmt->majortype == MEDIATYPE_MPEG2_PES  ||
            pmt->majortype == MEDIATYPE_DVD_ENCRYPTED_PACK)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is MPEG2_PES/DVD_ENCRYPTED_PACK"))) ;
			
            if (pmt->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_VIDEO"))) ;
                dwStream = AM_DVD_STREAM_VIDEO ;
            }
            else if (pmt->subtype == MEDIASUBTYPE_DOLBY_AC3)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is DOLBY_AC3"))) ;
                dwStream = AM_DVD_STREAM_AUDIO ;
            }
            else if (pmt->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_Subpicture"))) ;
                dwStream = AM_DVD_STREAM_SUBPIC ;
            }
            else
            {
                DbgLog((LOG_ERROR, 1, TEXT("WARNING: Unknown subtype %s"),
					(LPCSTR) CDisp(pmt->subtype))) ;
            }
        }
		
#if 0  // NOT needed for now
        else if (pmt->majortype == MEDIATYPE_AUX_Line21Data)
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Line21 data"))) ;
			
            if (pmt->subtype == MEDIASUBTYPE_Line21_GOPPacket ||
                pmt->subtype == MEDIASUBTYPE_Line21_BytePair)
                dwStream =  AM_DVD_STREAM_LINE21 ;
		}
#endif // #if 0
		
        else if (pmt->majortype == MEDIATYPE_Video)  // elementary stream
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Video elementary"))) ;
			
            if (pmt->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is DVD_SUBPICTURE"))) ;
                dwStream =  AM_DVD_STREAM_SUBPIC ;
            }
            else if (pmt->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Subtype is MPEG2_VIDEO"))) ;
                dwStream =  AM_DVD_STREAM_VIDEO ;
            }
            else
                DbgLog((LOG_TRACE, 5, TEXT("WARNING: Unknown subtype %s"),
				(LPCSTR) CDisp(pmt->subtype))) ;
        }
        else if (pmt->majortype == MEDIATYPE_Audio)  // elementary stream
        {
            DbgLog((LOG_TRACE, 5, TEXT("Mediatype is Audio elementary"))) ;
            dwStream =  AM_DVD_STREAM_AUDIO ;
        }
        // 
        // There is a chance that some IHV/ISV creates a private mediatype 
        // (major or sub) as in the case of IBM (for CSS filter). We have to
        // search the parts of the mediatype to locate something we recognize.
        // 
        else 
        {
            DbgLog((LOG_TRACE, 2, 
                TEXT("Unknown mediatype %s:%s -- may be IHV/ISV-specific mediatype"),
                (LPCSTR) CDisp(pmt->majortype), (LPCSTR) CDisp(pmt->subtype))) ;
            if (pmt->subtype == MEDIASUBTYPE_DOLBY_AC3)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Audio"))) ;
                dwStream = AM_DVD_STREAM_AUDIO ;
            }
            else if (pmt->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Video"))) ;
                dwStream = AM_DVD_STREAM_VIDEO ;
            }
            else if (pmt->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            {
                DbgLog((LOG_TRACE, 5, TEXT("Mediatype is ISV/IHV-specific Subpicture"))) ;
                dwStream = AM_DVD_STREAM_SUBPIC ;
            }
            else
            {
                // As of today, we don't know of any other media stream stype.
                // If more becomes known, we'll add them here and create a flag
                // in the AM_DVD_STREAM_FLAGS type.
                DbgLog((LOG_TRACE, 2, TEXT("WARNING: Unknown mediatype. Couldn't detect at all."))) ;
            }
        }
		
        DeleteMediaType(pmt) ;
    }  // end of while()
    pEnumMT->Release() ;
	
    return dwStream ;
}


DWORD CDvdGraphBuilder::StreamFlagForHWPin(IPin *pPin)
{
    DbgLog((LOG_TRACE, 5, TEXT("CDvdGraphBuilder::StreamFlagForHWPin(0x%lx)"), pPin)) ;
	
    ASSERT(pPin) ;  // so that we know
    if (NULL == pPin)
        return 0 ;
	
	DWORD     dwStream = 0 ;
    ULONG   ul ;
	AM_MEDIA_TYPE *pmt ;
	IEnumMediaTypes *pEnumMT ;
    HRESULT hr = pPin->EnumMediaTypes(&pEnumMT) ;
    ASSERT(SUCCEEDED(hr) && pEnumMT) ;
    while (0 == dwStream  &&
		S_OK == pEnumMT->Next(1, &pmt, &ul) && 1 == ul) // more mediatypes
    {
        if (pmt->majortype == MEDIATYPE_Video)
			dwStream = AM_DVD_STREAM_VIDEO ;
		else if (pmt->majortype == MEDIATYPE_Audio)
			dwStream = AM_DVD_STREAM_AUDIO ;
		else if (pmt->majortype == MEDIATYPE_AUXLine21Data)
			dwStream = AM_DVD_STREAM_LINE21 ;
		else
			DbgLog((LOG_TRACE, 3, TEXT("Unknown mediatype (%s:%s) for HW pin (%s)"), 
			    (LPCTSTR) CDisp(pmt->majortype), (LPCTSTR) CDisp(pmt->subtype), 
                (LPCTSTR) CDisp(pPin))) ;
		
		DeleteMediaType(pmt) ; // dne with this MT
	}  // end of while()
	pEnumMT->Release() ; // done with MT enum
	
    return dwStream ;
}



//
//  Implementation of the CListDecoders class...
//

CListDecoders::CListDecoders(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::CListDecoders()"))) ;
	
    m_iCount = 0 ;
    m_iHWCount = 0 ;
    for (int i = 0 ; i < DECLIST_MAX ; i++)
    {
        m_apFilters[i] = NULL ;
        m_alpszName[i] = NULL ;
        m_apClsid[i]   = NULL ;
        m_abIsHW[i]    = FALSE ;
    }
}


CListDecoders::~CListDecoders(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::~CListDecoders()"))) ;
	
    // We don't want to do CleanAll() here to avoid releasing the decoders
    // that might be in use. The decoders are freed in the DVD Graph Builder
    // object's destructor as we don't need the decoders any more.
    FreeAllMem() ;
}


void CListDecoders::CleanAll(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::CleanAll()"))) ;
	
    // don't have a pointer to the graph, so cache it here from the
    // the first filter.
    IFilterGraph *pGraph = 0;
    
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (m_apFilters[i])
        {
            if(pGraph == 0)
            {
                FILTER_INFO fi;
                HRESULT hr = m_apFilters[i]->QueryFilterInfo(&fi);
                pGraph = fi.pGraph;
				
                ASSERT(pGraph || FAILED(hr)); // filter not on our list if not in graph
            }
            if(pGraph) {
                EXECUTE_ASSERT(SUCCEEDED(pGraph->RemoveFilter(m_apFilters[i])));
            }
			
            DbgLog((LOG_TRACE, 5, TEXT("Going to release decoder #%d"), i)) ;
            m_apFilters[i]->Release() ;
            m_apFilters[i] = NULL ;
        }
        if (m_alpszName[i])
        {
            delete m_alpszName[i] ;
            m_alpszName[i] = NULL ;
        }
        if (m_apClsid[i])
        {
            delete m_apClsid[i] ;
            m_apClsid[i] = NULL ;
        }
        m_abIsHW[i] = FALSE ;
    }
	
    if(pGraph) {
        pGraph->Release();
    }
    
    m_iCount = 0 ;
    m_iHWCount = 0 ;
}


void CListDecoders::FreeAllMem(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::FreeAllMem()"))) ;
	
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (m_alpszName[i])
        {
            delete m_alpszName[i] ;
            m_alpszName[i] = NULL ;
        }
        if (m_apClsid[i])
        {
            delete m_apClsid[i] ;
            m_apClsid[i] = NULL ;
        }
        m_abIsHW[i] = FALSE ;
    }
    m_iCount = 0 ;
    m_iHWCount = 0 ;
}

BOOL CListDecoders::AddFilter(IBaseFilter *pFilter, LPTSTR lpszName, BOOL bHW, GUID *pClsid)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::AddFilter(0x%lx, %s, %d, 0x%lx)"),
		pFilter, lpszName, bHW, pClsid)) ;
	
    if (m_iCount >= DECLIST_MAX)
    {
        DbgLog((LOG_ERROR, 1, TEXT("INTERNAL ERROR: Too many filters added to CListDecoders"))) ;
        return FALSE ;
    }
    if (!bHW && NULL == pClsid)
    {
        DbgLog((LOG_ERROR, 1, TEXT("INTERNAL ERROR: NULL Clsid spcified for HW decoder"))) ;
        return FALSE ;
    }
	
    m_alpszName[m_iCount] = new TCHAR [lstrlen(lpszName) + 1] ;
    if (NULL == m_alpszName[m_iCount])
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: CListDecoders::AddFilter() -- Out of memory for filter name"))) ;
        return FALSE ;
    }
    lstrcpy(m_alpszName[m_iCount], lpszName) ;
    //
    // We store Clsid ONLY for SW decs (HW decs get filter pointer thru' DevEnum and we
    // don't instantiate them, so we don't bother about it)
    //
    if (!bHW)  // SW dec
    {
        m_apClsid[m_iCount] = (GUID *) new BYTE[sizeof(GUID)] ;
        if (NULL == m_apClsid[m_iCount])
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: CListDecoders::AddFilter() -- Out of memory for Clsid"))) ;
            delete m_alpszName[m_iCount] ;  // free the name string too
            return FALSE ;
        }
        *m_apClsid[m_iCount] = *pClsid ;
    }
    else
        m_apClsid[m_iCount] = NULL ;
	
    ASSERT(pFilter) ;
    m_apFilters[m_iCount] = pFilter ;
    m_abIsHW[m_iCount] = bHW ;
    m_iCount++ ;
    if (bHW)
        m_iHWCount++ ;
	
    return TRUE ;
}


BOOL CListDecoders::GetFilter(int i, IBaseFilter **ppFilter, LPTSTR *lpszName, BOOL *pbHW)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::GetFilter(%d, 0x%lx, 0x%lx, %d)"),
		i, ppFilter, lpszName, pbHW)) ;
	
    if (i > m_iCount)
    {
        DbgLog((LOG_ERROR, 1, TEXT("INTERNAL ERROR: Bad index (%d) for CListDecoders::GetFilter()"), i)) ;
        *ppFilter = NULL ;
        *pbHW = FALSE ;
        return FALSE ;
    }
	
    *ppFilter = m_apFilters[i] ;
    *lpszName = m_alpszName[i] ;
    *pbHW = m_abIsHW[i] ;
    return TRUE ;
}


int CListDecoders::GetList(IBaseFilter **ppFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::GetList(0x%lx)"), ppFilter)) ;
	
    if (0 == m_iCount)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Empty decoder list"))) ;
        *ppFilter = NULL ;
        return 0 ;
    }
    *ppFilter = (IBaseFilter *) CoTaskMemAlloc(m_iCount * sizeof(IBaseFilter *)) ;
    if (NULL == *ppFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Out of memory for decoder list"))) ;
        return 0 ;
    }
    for (int i = 0 ; i < m_iCount ; i++)
        ppFilter[i] = m_apFilters[i] ;
	
    return m_iCount ;
}


int CListDecoders::IsInList(BOOL bHW, LPVOID pDec)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListDecoders::IsInList(%d, 0x%lx)"), bHW, pDec)) ;
	
    GUID        *pClsid ;
    IBaseFilter *pFilter ;
    if (bHW)
        pFilter = (IBaseFilter *) pDec ;
    else
        pClsid = (GUID *) pDec ;
	
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (bHW != m_abIsHW[i])  // dec type mismatch...
        {
            DbgLog((LOG_TRACE, 5, TEXT("Got a %s decoder looking for a %s decoder (i = %d)"),
				m_abIsHW[i] ? TEXT("HW") : TEXT("SW"),
				bHW ? TEXT("HW") : TEXT("SW"), i)) ;
            continue ;          // ...can't be this one
        }
		
        if (bHW)
        {
            if (pFilter == m_apFilters[i])
                return i ;
        }
        else
        {
            ASSERT(m_apClsid[i]) ;
            if (*pClsid == *m_apClsid[i])
                return i ;
        }
    }
	
    return DECLIST_NOTFOUND ;  // didn't match any
}


//
//  Implementation of the CListIntFilters class...
//
CListIntFilters::CListIntFilters(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::CListIntFilters()"))) ;

    CleanAll() ;  // start clean
}


CListIntFilters::~CListIntFilters(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::~CListIntFilters()"))) ;
	
    RemoveAll() ;  // make sure no such filters remains in graph
}


void CListIntFilters::CleanAll(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::CleanAll()"))) ;
	
    for (int i = 0 ; i < MAX_INT_FILTERS ; i++)
    {
        m_apFilters[i]   = NULL ;
        m_aNumInPins[i]  = 0 ;
        m_aNumOutPins[i] = 0 ;
    }
    m_iCount = 0 ;
}


void CListIntFilters::RemoveAll(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::RemoveAll()"))) ;
	
    // Don't have a pointer to the graph, so cache it here from the
    // the first filter.
    IFilterGraph *pGraph = NULL ;
    
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (m_apFilters[i])
        {
#ifdef DEBUG
            FILTER_INFO  fi ;
            m_apFilters[i]->QueryFilterInfo(&fi) ;
            fi.pGraph->Release() ;
            TCHAR  achName[MAX_FILTER_NAME] ;
#ifdef UNICODE
            lstrcpy(achName, fi.achName) ;
#else
            WideCharToMultiByte(CP_ACP, 0, fi.achName, -1,
						        achName, MAX_FILTER_NAME, NULL, NULL) ;
#endif // UNICODE
            DbgLog((LOG_TRACE, 5, TEXT("Intermediate filter #%d: <%s>"), i, achName)) ;
#endif // DEBUG
            if (NULL == pGraph)
            {
                FILTER_INFO fi ;
                HRESULT hr = m_apFilters[i]->QueryFilterInfo(&fi) ;
                pGraph = fi.pGraph ;
				
                ASSERT(pGraph || FAILED(hr)) ; // filter not on our list if not in graph
            }
            if (pGraph)
                EXECUTE_ASSERT(SUCCEEDED(pGraph->RemoveFilter(m_apFilters[i]))) ;

            DbgLog((LOG_TRACE, 5, TEXT("Going to release intermediate filter #%d"), i)) ;
            m_apFilters[i]->Release() ;
            m_apFilters[i]   = NULL ;
            m_aNumInPins[i]  = 0 ;
            m_aNumOutPins[i] = 0 ;
        }
    }
    if (pGraph)
        pGraph->Release() ;

    m_iCount = 0 ;
}


BOOL CListIntFilters::IsInList(IBaseFilter *pFilter)
{
    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Null filter pointer passed to CListIntFilters::IsInList()"))) ;
        ASSERT(pFilter) ;
        return FALSE ;
    }

    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (IsEqualObject(pFilter, m_apFilters[i]))
            return TRUE ;  // got a match
    }
    return FALSE ;  // no match ==> not in list
}


BOOL CListIntFilters::AddFilter(IBaseFilter *pFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::AddFilter(0x%lx)"), pFilter)) ;
	
    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Null filter pointer passed to CListIntFilters::AddFilter()"))) ;
        ASSERT(pFilter) ;
        return FALSE ;
    }

    if (m_iCount >= MAX_INT_FILTERS)
    {
        DbgLog((LOG_ERROR, 1, TEXT("INTERNAL ERROR: Too many filters added to CListIntFilters"))) ;
        ASSERT(m_iCount < MAX_INT_FILTERS) ;
        return FALSE ;
    }

    // Check if this filter is already in our list -- if so, just return
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (IsEqualObject(pFilter, m_apFilters[i]))
            return TRUE ;  // we are done
    }

    // It's NOT already in our list -- add it now
    m_apFilters[m_iCount] = pFilter ;

    //
    // Now count the # in and out pins of the intermediate filter
    //
    IPin          *pPin ;
    ULONG          ul ;
    PIN_DIRECTION  pd ;
    IEnumPins     *pEnumPin ;
    pFilter->EnumPins(&pEnumPin) ;
    ASSERT(pEnumPin) ;
    if (pEnumPin)
    {
        while (S_OK == pEnumPin->Next(1, &pPin, &ul) && 1 == ul)
        {
            pPin->QueryDirection(&pd) ;
            if (PINDIR_INPUT == pd)
                m_aNumInPins[m_iCount]++ ;
            else if (PINDIR_OUTPUT == pd)
                m_aNumOutPins[m_iCount]++ ;
            else
                ASSERT(PINDIR_INPUT == pd || PINDIR_OUTPUT == pd) ;

            pPin->Release() ;  // done with pin
        }
        pEnumPin->Release() ;  // done Enum-ing
    }
    DbgLog((LOG_TRACE, 5, TEXT("CListIntFilters::AddFilter() -- %d in, %d out pin"), 
            m_aNumInPins[m_iCount], m_aNumOutPins[m_iCount])) ;

    m_iCount++ ;   // increment counter now
	
    return TRUE ;  // added to list
}


int CListIntFilters::GetNumInPin(IBaseFilter *pFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::GetNumInPin(0x%lx)"), pFilter)) ;

    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Null filter pointer passed to CListIntFilters::GetNumInPin()"))) ;
        ASSERT(pFilter) ;
        return 0 ;
    }

    // Check if this filter is already in our list -- if so, just return
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (IsEqualObject(pFilter, m_apFilters[i]))
            return m_aNumInPins[i] ;
    }

    return 0 ;  // no match!!!
}


int CListIntFilters::GetNumOutPin(IBaseFilter *pFilter)
{
    DbgLog((LOG_TRACE, 4, TEXT("CListIntFilters::GetNumOutPin(0x%lx)"), pFilter)) ;

    if (NULL == pFilter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Null filter pointer passed to CListIntFilters::GetNumOutPin()"))) ;
        ASSERT(pFilter) ;
        return 0 ;
    }

    // Check if this filter is already in our list -- if so, just return
    for (int i = 0 ; i < m_iCount ; i++)
    {
        if (IsEqualObject(pFilter, m_apFilters[i]))
            return m_aNumOutPins[i] ;
    }

    return 0 ;  // no match!!!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\h\rdr.h ===
// Copyright (c) Microsoft Corporation 1996. All Rights Reserved
#ifndef __RDR_H__
#define __RDR_H__
/*

    File:  reader.h

    Description:

        Mini file reader class to grovel the mpeg file

*/


/*  Class to pump bytes at ParseBytes

    This aims at the maximum contiguous bytes in a 64K buffer,
    but we can vary the size we read

    Abstract base class.
*/

class CReader
{
public:
    CReader();
    virtual ~CReader();

    virtual HRESULT  Seek(LONGLONG llPos);
    virtual PBYTE    GetCurrent(LONG& lLengthValid, LONGLONG& llPos) const;
    virtual HRESULT  ReadMore();
    virtual void     Advance(LONG lAdvance);
    virtual LONGLONG GetSize(LONGLONG *pllAvailable = NULL);
    virtual HRESULT  Init(
			LONG lBufferSize,
			LONG lReadSize,
			BOOL bSeekable,
			LONGLONG llFileSize
			);
    BOOL IsSeekable() {
	return m_bSeekable;
    };

    // override these functions to provide access to the actual stream
    // or data source
protected:
    virtual HRESULT SeekDevice(
			LONGLONG llPos,
			LONGLONG* llNewPos) PURE;
    virtual HRESULT ReadFromDevice(
			PVOID pBuffer,
			DWORD cbToRead,
			DWORD* cbActual) PURE;

    // derived classes can use this info
    LONGLONG  m_llPosition;		// position at start of buffer
    LONGLONG  m_llSize;			// total file length
    BOOL      m_bSeekable;		// false if not a seekable source

private:
    LONG      m_lBufferSize;
    LONG      m_lReadSize;
    PBYTE     m_pbBuffer;
    LONG      m_lValid;
};

// implementation of CReader that reads from an IStream
class CReaderFromStream : public CReader
{
private:
    IStream * m_pStream;


public:
    CReaderFromStream();
    ~CReaderFromStream();

    HRESULT Init(IStream *pStream, LONG lBufferSize, LONG lReadSize, BOOL bSeekable);

protected:
    HRESULT SeekDevice(LONGLONG llPos, LONGLONG* llNewPos);
    HRESULT ReadFromDevice(PVOID pBuffer, DWORD cbToRead, DWORD* cbActual);
};


// implementation of CReader that reads from an IAsyncReader interface
class CReaderFromAsync : public CReader
{
private:
    IAsyncReader * m_pReader;
    LONGLONG m_llNextRead;

public:
    CReaderFromAsync();
    ~CReaderFromAsync();

    HRESULT Init(IAsyncReader *pReader, LONG lBufferSize, LONG lReadSize, BOOL bSeekable);

protected:
    HRESULT SeekDevice(LONGLONG llPos, LONGLONG* llNewPos);
    HRESULT ReadFromDevice(PVOID pBuffer, DWORD cbToRead, DWORD* cbActual);
    LONGLONG GetSize(LONGLONG *pllAvailable = NULL);
};



#endif //__RDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\h\instrm.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

//
//  CInputStream class
//
//  This class manages a stream object provided by an input pin
//
//  This object MUST be deleted during Disconnect because it holds a
//  reference count to the upstream pin
//

// This class exposes IMediaPosition, and seeks using either IMediaPosition or
// IAsyncReader on the upstream pin. If we are using IAsyncReader, then the
// pulling is done in this class. Override the PURE VIRTUAL OnReceive,
// OnError and OnEndOfStream to handle the delivery of data in this case.


class CInputStream : public CSourcePosition
{
public:
    CInputStream(TCHAR *Name,
                 LPUNKNOWN pUnk,
                 CCritSec *pLock,
                 HRESULT *phr);
    ~CInputStream();

    //
    //  Connect and Disconnect - 2 stage construction
    //
    // pass in preferred allocator for pulling connection (can be null)
    HRESULT Connect(
                IPin *pOutputPin,
                AM_MEDIA_TYPE const *pmt,
                IMemAllocator* pAlloc
                );
    HRESULT Disconnect();

    //
    //  Override NonDelegatingQueryInterface to return IMediaPosition
    //  ONLY if it is supported upstream
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv)
    {
        if (m_bPulling || (m_pPosition != NULL)) {
            return CSourcePosition::NonDelegatingQueryInterface(riid, ppv);
        } else {
            return E_NOINTERFACE;
        }
    };


    // call this when we transition to and from streaming
    // in the pulling (IAsyncReader) case, this will start the worker thread.
    HRESULT StartStreaming();
    HRESULT StopStreaming();


    //
    //  This routine is called by the Connect to determine the
    //  media type of the pin.  It calls the IStream interface of the
    //  connected output pin to determine the type of the stream
    //
    //  If the stream supports IMediaPosition then this object does
    //
    //  pReader - A CReader object that can read from the output we are
    //            connecting to
    //  pmt     - the media type we're looking for (usually of major type
    //            MEDIATYPE_Stream)
    //

    virtual HRESULT CheckStream(CReader *pReader, AM_MEDIA_TYPE const *pmt) = 0;

    // override these to handle data flow from the pulling pin

    // override this to handle data arrival
    // return value other than S_OK will stop data
    virtual HRESULT Receive(IMediaSample*) PURE;

    // override this to handle end-of-stream
    virtual HRESULT EndOfStream(void) PURE;

    // flush this pin and all downstream
    virtual HRESULT BeginFlush() PURE;
    virtual HRESULT EndFlush() PURE;

protected:

    //
    //  IMediaPosition interface of the output pin if it has one -
    //  NULL otherwise
    //

    IMediaPosition * m_pPosition;

    //
    //  Are we connected ?
    //

    BOOL m_Connected;


    // are we pulling using IAsyncReader?
    BOOL m_bPulling;

    // derive a class from CPullPin to override pure virtual functions.
    // We turn them into calls to pure virtual methods of CInputStream.
    class CImplPullPin : public CPullPin {

    protected:
        CInputStream* m_pStream;

    public:
        CImplPullPin(CInputStream*pS)
          : m_pStream(pS)
        {
        };

        // override pure virtuals in CPullPin

        // override this to handle data arrival
        // return value other than S_OK will stop data
        HRESULT Receive(IMediaSample*pSample) {
            return m_pStream->Receive(pSample);
        };

        // override this to handle end-of-stream
        HRESULT EndOfStream(void) {
            return m_pStream->EndOfStream();
        };


        // called on runtime errors that will have caused pulling
        // to stop
        // these errors are all returned from the upstream filter, who
        // will have already reported any errors to the filtergraph.
        void OnError(HRESULT hr) {
            return;
        };


        // flush this pin and all downstream
        HRESULT BeginFlush() {
            return m_pStream->BeginFlush();
        };

        HRESULT EndFlush() {
            return m_pStream->EndFlush();
        };
    };

    CImplPullPin m_puller;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\h\creg.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

/*
    Registry access classes :

    CEnumKey
    CEnumValue
*/

class CKey
{
public:
    CKey(HKEY hKey,
         LPCTSTR lpszKeyName,
         HRESULT *phr,
         BOOL bCreate = FALSE,
         REGSAM Access = MAXIMUM_ALLOWED);
    ~CKey();
    virtual BOOL Next() { return FALSE; };
    HKEY KeyHandle() const { return m_hKey; };
    void Reset() { m_dwIndex = 0; };

protected:
    HKEY  m_hKey;
    DWORD m_dwIndex;
    TCHAR m_szName[30];
    LPTSTR m_lpszName;

    /*  Information from RegQueryInfoKey */
    DWORD m_cSubKeys;
    DWORD m_cbMaxSubkeyLen;
    DWORD m_cValues;
    DWORD m_cbMaxValueNameLen;
    DWORD m_cbMaxValueLen;
};

class CEnumKey : public CKey
{
public:
    CEnumKey(HKEY hKey,
             LPCTSTR lpszKeyName,
             HRESULT *phr,
             BOOL bCreate = FALSE,
             REGSAM Access = KEY_READ);
    ~CEnumKey();
    BOOL Next();
    LPCTSTR KeyName() const { return m_lpszName; };
};

class CEnumValue : public CKey
{
public:
    CEnumValue(HKEY hKey,
               LPCTSTR lpszKeyName,
               HRESULT *phr,
               BOOL bCreate = FALSE,
               REGSAM Access = MAXIMUM_ALLOWED);
    ~CEnumValue();
    BOOL Next();
    BOOL Next(DWORD dwType);                        // Next of this type (skips rest)
    BOOL Read(DWORD dwType, LPCTSTR lpszValueName); // Goto a particular value
    LPCTSTR ValueName() const { return m_lpszName; };
    DWORD ValueType() const { return m_dwType; };
    DWORD ValueLength() const { return m_cbLen; };
    LPBYTE Data() const { return m_lpbData; };

private:
    DWORD  m_dwType;
    DWORD  m_cbLen;
    LPBYTE m_lpbData;
    BYTE   m_bData[30];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\h\ftype.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*
    Find the type of a file based on its check bytes in the registry :

    A set of values : offset, length, mask, checkbyte
    indexed by the major type and subtype.

    To pass ALL the checkbytes must match under mask for at least ONE
    of the checkbyte lists under the subtype key

    A negative offset means an offset from the end of the file

    See GetClassFile for a similar scheme

    HKEY_CLASSES_ROOT
        Media Type
            {Major Type clsid}
                {Subtype clsid}
                    Source Filter = REG_SZ {Source filter clsid}
                    0 = REG_SZ 0, 4, F0FFFFFF, 10345678, 100, 4, , 11110000
                    1 = REG_SZ -4, 4, , 87654321

    URL names (names beginning with a protocol and :) will use the following
    structure: if the extension is found in Extensions, that clsid will be
    used else the Source Filter for that protocol.
    HKEY_CLASSES_ROOT
        <protocol>
            Source Filter = REG_SZ {Source filter clsid}
            Extensions
                <.ext> = REG_SZ {Source filter clsid}
    if no class id is found, we will attempt to open them and parse them
    as for local files.

*/

/*  Define the key name under which we store the data */

#define MEDIATYPE_KEY TEXT("Media Type")

/*  Define the value name for the source filter clsid */

#define SOURCE_VALUE (TEXT("Source Filter"))

// name of the key under which extensions are stored
// each extension is a named value including the . with the value being
// the class id eg
//    .mpg = REG_SZ {e436ebb6-524f-11ce-9f53-0020af0ba770}
#define EXTENSIONS_KEY TEXT("Extensions")

/*  Function to get the media type of a file */

STDAPI GetMediaTypeFile(LPCTSTR lpszFile,     // Name of file
                        GUID   *Type,         // Type (returned)
                        GUID   *Subtype,      // Subtype (returned)
                        CLSID  *clsidSource); // Clsid of source filter

/*  Add a file type entry to the registry */

STDAPI SetMediaTypeFile(const GUID  *Type,         // Media Major Type
                        const GUID  *Subtype,      //
                        const CLSID *clsidSource,  // Source filter
                        LPCTSTR      lpszMaskAndData,
                        DWORD        dwIndex = 0);

/*  Remove all the entries for a particular media type */

STDAPI DeleteMediaTypeFile(const GUID *Type, const GUID *Subtype);

/*  Register a file extension - must include leading "." */
HRESULT RegisterExtension(LPCTSTR lpszExt, const GUID *Subtype);


//  Add a protocol handler
HRESULT AddProtocol(LPCTSTR lpszProtocol, const CLSID *pclsidHandler);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image\colour\makefile.inc ===
# NOTE:
# this directory contains a makefile which contains a single line that
# includes the global build process makefile.def. If the
# NTTARGETFILE1 or NTTARGETFILE0 environment
# variable is set then makefile.def includes makefile.inc from the current
# directory. This makefile.inc creates an extra target for nmake to create
# when it is run. NTTARGETFILE0 is built before everything else, and
# NTTARGETFILE1 is built after everything else.

copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll     \
         $(SDK_ROOT)\bin\*.*
  @if not exist $(QUARTZ)\lib\$(TARGET_DIRECTORY) \
    md $(QUARTZ)\lib\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib     \
         $(QUARTZ)\lib\$(TARGET_DIRECTORY)\*.*


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\h\stats.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//  Stats class stuff
//  This is essentially a collection of stats events

class CStats;

extern CStats g_Stats;

class CStat
{
public:
    LPWSTR m_szName;
    long    m_lCount;
    double m_dTotal;
    double m_dSumSq;
    double m_dMin;
    double m_dMax;
    double m_dLast;
    double m_dMultiplier;
    CStat(LPCWSTR lpszName);
    ~CStat();
    void Reset();
};

typedef CStat *PCSTAT;

// Array of stats
class CStats
{
public:
    CStats();
    ~CStats();

    void Init();

    //  Helper - get QueryPerformanceCounter multiplier for
    //  QPF->milliseconds
    double GetQPFMultiplier();

    long Find(LPCWSTR lpszStatName, bool bCrate = true);
    void Reset();
    bool NewValue(LPCWSTR lpszName, double dValue);
    bool NewValue(LPCWSTR lpszName, LONGLONG dValue);
    bool NewValue(long iStat, double dValue);
    double GetTime();
    void SetMultiplier(long iStat, double dMultiplier);

    //  Use this one to avoid the conversion inline in code
    bool NewValue(long iStat, LONGLONG llValue);
    HRESULT GetValues(
        long iStat,
        BSTR *szName,
        long *lCount,
        double *dLast,
        double *dAverage,
        double *dStdDev,
        double *dMin,
        double *dMax);

    class CAutoLock
    {
    public:
        CAutoLock(CRITICAL_SECTION *cs)
        {
            EnterCriticalSection(cs);
            m_cs = cs;
        }
        ~CAutoLock()
        {
            LeaveCriticalSection(m_cs);
        }
        CRITICAL_SECTION *m_cs;
    };

public:
    CStat **m_ppStats;
    long m_nEntries;
    enum { ALLOCATION_SIZE = 16 };
    CRITICAL_SECTION m_cs;
    double m_QPFMultiplier;
};

class CAutoTimer
{
public:
    CAutoTimer(LPCWSTR lpszStat, LPCWSTR lpszExtra = NULL) :
       m_iStat(-1)
    {
        if (lpszExtra) {
            int iLen = lstrlenWInternal(lpszStat);
            WCHAR *psz = (WCHAR *)_alloca(sizeof(WCHAR) * (iLen + lstrlenWInternal(lpszExtra) + 1));
            CopyMemory(psz, lpszStat, sizeof(WCHAR) * iLen);
            lstrcpyWInternal(psz + iLen, lpszExtra);
            m_iStat = g_Stats.Find(psz);
        } else {
            m_iStat = g_Stats.Find(lpszStat);
        }
        if (m_iStat >= 0) {
            m_dTime = g_Stats.GetTime();
        }
    }
    ~CAutoTimer()
    {
        if (m_iStat >= 0) {
            g_Stats.NewValue(m_iStat, g_Stats.GetTime() - m_dTime);
        }
    }
private:
    long     m_iStat;
    double   m_dTime;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image\colour\colour.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
// This filter implements popular colour space conversions, May 1995

#include <streams.h>
#include <colour.h>
#include <limits.h>
#include <viddbg.h>
#include "stdpal.h"

// This filter converts decompressed images into different colour spaces. We
// support five basic RGB colour space formats so that other filters are able
// to produce their data in its native format. Of course having an additional
// filter to do the colour conversion is less efficient that doing it in band
// during, for example, the video decompression. This filter can be used with
// the video specific output pin to enable simple access to the frame buffer.
// Where appropriate a filter could be handed a YUV decompression surface and
// write directly to the frame buffer, if part of the window becomes occluded
// then the output pin switches to a memory buffer that we'll colour convert
// The list of colour conversions we support (by CLSID) are as follows:
//
// MEDIASUBTYPE_RGB8
// MEDIASUBTYPE_RGB565
// MEDIASUBTYPE_RGB555
// MEDIASUBTYPE_RGB24
// MEDIASUBTYPE_RGB32
// MEDIASUBTYPE_ARGB32
//
// This filter does not have a worker thread so it executes the colour space
// conversion on the calling thread. It is meant to be as lightweight as is
// possible so we do very little type checking on connection over and above
// ensuring we understand the types involved. The assumption is that when the
// type eventually gets through to an end point (probably the video renderer
// supplied) it will do a thorough type checking and reject bad streams.
//
// We have very strict rules on handling palettised formats. If we connect to
// a source filter with a true colour format, then we can provide any output
// format the downstream filter requires. If a format can be provided by the
// source directly then we go into pass through mode.
#if 0	// we can now
// If we connect our input
// with MEDIASUBTYPE_RGB8 then we cannot provide eight bit output. This is to
// avoid having to copy palette changes from input to output formats. In any
// case there is no need to have the colour space convertor in the graph for
// this kind of transform. Also, if we connect our input with eight bit then
// we do not do pass through as our source might change the input palette on
// a true colour format which we would make it hard to update our input with.
#endif


//  NOTE on passthrough mode.  We support a special allocator which
//  can either allocate samples itself and do the convert and copy, or
//  it can allocate samples directly from the downstream filter if the
//  upstream pin can supply the type directly.
//  When the second case is detected the passthrough flag is set and
//  Receive() passes through the samples directly.
//  Passthrough only operates when out special allocator is used.


// MORE NOTES by ehr: This filter has a "special" allocator that's always
// instantiated, but only sometimes used. If the upstream filter asks us
// for an allocator, and we haven't been notified of one yet, we pass back
// a reference to our special one. If the upstream filter just tells us
// what our allocator is, our special one is still instantiated, but never used.

//
// List of CLSIDs and creator functions for class factory

#ifdef FILTER_DLL
CFactoryTemplate g_Templates[1] = {
    {L"", &CLSID_Colour, CColour::CreateInstance}
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif


// This goes in the factory template table to create new instances

CUnknown *CColour::CreateInstance(LPUNKNOWN pUnk,HRESULT *phr)
{
    return new CColour(NAME("Colour space convertor"),pUnk,phr);
}


// Setup data

const AMOVIESETUP_MEDIATYPE
sudColourPinTypes[] =
{
    {
        &MEDIATYPE_Video,           // Major
        &MEDIASUBTYPE_RGB8          // Subtype
    },
    {
        &MEDIATYPE_Video,           // Major
        &MEDIASUBTYPE_RGB555        // Subtype
    },
    {
        &MEDIATYPE_Video,           // Major
        &MEDIASUBTYPE_RGB565        // Subtype
    },
    {
        &MEDIATYPE_Video,           // Major
        &MEDIASUBTYPE_RGB24         // Subtype
    },
    {
        &MEDIATYPE_Video,           // Major
        &MEDIASUBTYPE_RGB32         // Subtype
    },
    {
        &MEDIATYPE_Video,           // Major
        &MEDIASUBTYPE_ARGB32      // Subtype
    }

};

const AMOVIESETUP_PIN
sudColourPin[] =
{
    { L"Input",                 // Name of the pin
      FALSE,                    // Is pin rendered
      FALSE,                    // Is an Output pin
      FALSE,                    // Ok for no pins
      FALSE,                    // Can we have many
      &CLSID_NULL,              // Connects to filter
      NULL,                     // Name of pin connect
      NUMELMS(sudColourPinTypes), // Number of pin types
      sudColourPinTypes },     // Details for pins

    { L"Output",                // Name of the pin
      FALSE,                    // Is pin rendered
      TRUE,                     // Is an Output pin
      FALSE,                    // Ok for no pins
      FALSE,                    // Can we have many
      &CLSID_NULL,              // Connects to filter
      NULL,                     // Name of pin connect
      NUMELMS(sudColourPinTypes), // Number of pin types
      sudColourPinTypes }      // Details for pins
};

const AMOVIESETUP_FILTER
sudColourFilter =
{
    &CLSID_Colour,              // CLSID of filter
    L"Color Space Converter",   // Filter name
    MERIT_UNLIKELY + 1,         // Filter merit
    2,                          // Number of pins
    sudColourPin                // Pin information
};


// Constructor initialises the base transform class. We have our own memory
// allocator that is used to pass through samples so that we can operate in
// a don't copy mode when the source can supply the destination directly. We
// do this by setting the data pointer in our samples to be the destinations.
// This is somewhat like the DirectDraw flipping surfaces where the interface
// remains the same but the memory pointer changes. We also have an input pin
// that needs to cooperate in this pass through operation. The input pin is a
// member variable of the class rather than a dynamically created pin object

#pragma warning(disable:4355)

CColour::CColour(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *phr) :
    CTransformFilter(pName,pUnk,CLSID_Colour),
    m_ColourAllocator(NAME("Allocator"),this,phr,&m_csReceive),
    m_ColourInputPin(NAME("Input Pin"),this,&m_csReceive,phr,L"Input"),
    m_TypeList(NAME("Colour type list"),DEFAULTCACHE,FALSE,FALSE),
    m_pConvertor(NULL),
    m_bPassThrough(FALSE),
    m_bPassThruAllowed(TRUE),
    m_bOutputConnected(FALSE),
    m_TypeIndex(-1),
    m_pOutSample(NULL),
    m_fReconnecting(FALSE)
{
    ASSERT(phr);
}


// Destructor MUST set the transform m_pInput pointer before the base class
// is called because we have the pin as a member variable rather than as a
// dynamically created object (see the main colour space conversion class
// definition) - Fortunately our destructor is called before the base class

CColour::~CColour()
{
    ASSERT(m_mtOut.IsValid() == FALSE);
    ASSERT(m_pOutSample == NULL);
    ASSERT(m_pConvertor == NULL);
    ASSERT(m_bOutputConnected == FALSE);

    InitTypeList( );

    m_pInput = NULL;
}


// If the output type is being changed perhaps to switch to using DirectDraw
// then we create a new one. Creating one of our convertor objects also has
// it committed so it is ready for streaming. Likewise if the input format
// has changed then we also recreate a convertor object. We always create a
// new convertor when the input format is RGB8 because the palette may have
// been changed in which case we will need to build new colour lookup tables

HRESULT CColour::PrepareTransform(IMediaSample *pIn,IMediaSample *pOut)
{
    NOTE("Entering PrepareTransform");
    AM_MEDIA_TYPE *pMediaType;
    CAutoLock cAutoLock(&m_csReceive);
    BOOL bInputConvertor = FALSE;
    BOOL bOutputConvertor = FALSE;

    // Make sure some kipper hasn't called us at the wrong time

    if (m_pConvertor == NULL) {
        NOTE("No converted object");
        return VFW_E_WRONG_STATE;
    }

    // Has the output type changed

    pOut->GetMediaType(&pMediaType);
    if (pMediaType) {
        NOTE("Output format changed");
        SetMediaType(PINDIR_OUTPUT,(CMediaType *)pMediaType);
        DeleteMediaType(pMediaType);
        bOutputConvertor = TRUE;
    }

    // Likewise check the input format

    AM_SAMPLE2_PROPERTIES * const pProps = m_pInput->SampleProps();
    if (pProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED) {
        NOTE("Input format changed");
        m_pInput->SetMediaType((CMediaType *)pProps->pMediaType);
        bInputConvertor = TRUE;
    }

    // Make sure palette changes happen

    if (bInputConvertor == TRUE) {
        if (*m_pInput->CurrentMediaType().Subtype() == MEDIASUBTYPE_RGB8) {
            NOTE("Palette forced");
            DeleteConvertorObject();
        }
    }

    // Do we need a new convertor

    if (bInputConvertor || bOutputConvertor) {
        NOTE("Creating convertor");
        CreateConvertorObject();
    }
    return NOERROR;
}


// Convert this input sample to a different colour space format. On choosing
// a transform for this filter to perform we initialise the m_Convertor field
// to address an object that does the transforms for us. So now that we have
// received a media sample we call the derived object's transform function
// We may be called from our input pin depending whose allocator we're using

HRESULT CColour::Transform(IMediaSample *pIn,IMediaSample *pOut)
{
    NOTE("Entering Transform");
    CAutoLock cAutoLock(&m_csReceive);
    BYTE *pInputImage = NULL;
    BYTE *pOutputImage = NULL;
    HRESULT hr = NOERROR;

    // Manage dynamic format changes

    hr = PrepareTransform(pIn,pOut);
    if (FAILED(hr)) {
        return hr;
    }

    // Retrieve the output image pointer

    hr = pOut->GetPointer(&pOutputImage);
    if (FAILED(hr)) {
        NOTE("No output");
        return hr;
    }

    // And the input image buffer as well

    hr = pIn->GetPointer(&pInputImage);
    if (FAILED(hr)) {
        NOTE("No input");
        return hr;
    }
    return m_pConvertor->Transform(pInputImage,pOutputImage);
}


// Given any source GUID subtype we scan the list of available transforms for
// the conversion at index position iIndex. The number of transforms that are
// available for any given type can be found from CountTransforms. NOTE the
// iIndex parameter is ZERO based so that it fits easily with GetMediaType

const GUID *CColour::FindOutputType(const GUID *pInputType,INT iIndex)
{
    NOTE("Entering FindOutputType");
    ASSERT(pInputType);
    const GUID *pVideoSubtype;
    INT iPosition = 0;

    while (iPosition < TRANSFORMS) {
        pVideoSubtype = TypeMap[iPosition].pInputType;
        if (IsEqualGUID(*pVideoSubtype,*pInputType)) {
            if (iIndex-- == 0) {
                return TypeMap[iPosition].pOutputType;
            }
        }
        iPosition++;
    }
    return NULL;
}


// Check that we can transform from this input to this output subtype, all we
// do is to scan the list of available transforms and look for an entry that
// contains both the input and output type. Most people don't care where in
// list the transform is but some require the table position for use later

INT CColour::FindTransform(const GUID *pInputType,const GUID *pOutputType)
{
    NOTE("Entering FindTransform");
    ASSERT(pOutputType);
    ASSERT(pInputType);
    INT iPosition = TRANSFORMS;

    ASSERT(IsEqualGUID(*pInputType,GUID_NULL) == FALSE);
    ASSERT(IsEqualGUID(*pOutputType,GUID_NULL) == FALSE);

    while (iPosition--) {
        if (IsEqualGUID(*(TypeMap[iPosition].pInputType),*pInputType)) {
            if (IsEqualGUID(*(TypeMap[iPosition].pOutputType),*pOutputType)) {
                return iPosition;
            }
        }
    }
    return (-1);
}


// This function is handed a media type object and it looks after making sure
// that it is superficially correct. This doesn't amount to a whole lot more
// than making sure the type is right and that the media format block exists
// So we delegate full type checking to the downstream filter that uses it

HRESULT CColour::CheckVideoType(const AM_MEDIA_TYPE *pmt)
{
    NOTE("Entering CheckVideoType");

    // Check the major type is digital video

    if (pmt->majortype != MEDIATYPE_Video) {
        NOTE("Major type not MEDIATYPE_Video");
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    // Check this is a VIDEOINFO type

    if (pmt->formattype != FORMAT_VideoInfo) {
        NOTE("Format not a VIDEOINFO");
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    // Quick sanity check on the input format

    if (pmt->cbFormat < SIZE_VIDEOHEADER) {
        NOTE("Format too small for a VIDEOINFO");
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    return NOERROR;
}


// Check if we can support type mtIn which amounts to scanning our available
// list of transforms and seeing if there are any available. The formats we
// can supply is entirely dependent on the formats the source filter is able
// to provide us with. For that reason we cannot unfortunately simply pass
// the source filter's enumerator through to the downstream filter. This can
// be done by simpler in place transform filters and others like the tee

HRESULT CColour::CheckInputType(const CMediaType *pmtIn)
{
    NOTE("Entering CheckInputType");
    ASSERT(pmtIn);

    // Quick sanity check on the input format

    HRESULT hr = CheckVideoType(pmtIn);
    if (FAILED(hr)) {
        NOTE("Type failed");
        return hr;
    }

    DisplayType(TEXT("Input type offered"),pmtIn);

    // See if there is a conversion available

    if (FindOutputType(pmtIn->Subtype(),FALSE) == NULL) {
        NOTE("No conversion available");
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    return NOERROR;
}


// Check if you can support the transform from this input to this output, we
// check we like the output type and then see if we can find a transform for
// this pair. Because we do all conversions between all input and outputs we
// should never need to reconnect our input pin. Therefore having completed
// an input pin connection we only have to check that there's a transform we
// can use from the current input pin format to the proposed output type

HRESULT CColour::CheckTransform(const CMediaType *pmtIn,const CMediaType *pmtOut)
{
    VIDEOINFO *pTargetInfo = (VIDEOINFO *) pmtOut->Format();
    VIDEOINFO *pSourceInfo = (VIDEOINFO *) pmtIn->Format();
    NOTE("Entering CheckTransform");

    // Quick sanity check on the output format

    HRESULT hr = CheckVideoType(pmtOut);
    if (FAILED(hr)) {
        return hr;
    }

#if 0	// we can now
    // We cannot transform between palettised formats
    if (*pmtIn->Subtype() == MEDIASUBTYPE_RGB8) {
        if (*pmtOut->Subtype() == MEDIASUBTYPE_RGB8) {
            NOTE("Can't convert palettised");
            return VFW_E_TYPE_NOT_ACCEPTED;
        }
    }
#endif

    // Is there a transform available from the input to the output. If there
    // is no transform then we might still supply the type if the source can
    // supply it directly. However we only agree to pass through media types
    // once an output connection has been established otherwise we reject it
    if (FindTransform(pmtIn->Subtype(),pmtOut->Subtype()) == (-1)) {
        if (m_ColourInputPin.CanSupplyType(pmtOut) == S_OK) {
            if (m_bOutputConnected == TRUE) {
                NOTE("Source will provide transform");
                return NOERROR;
            }
        }
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    // Create a source rectangle if it's empty

    RECT SourceRect = pTargetInfo->rcSource;
    if (IsRectEmpty(&SourceRect) == TRUE) {
        SourceRect.right = pSourceInfo->bmiHeader.biWidth;
        SourceRect.bottom = ABSOL(pSourceInfo->bmiHeader.biHeight);
        SourceRect.left = SourceRect.top = 0;
        NOTERC("(Expanded) Source",SourceRect);
    } else {
	// Check that source rectange is within source
	if (SourceRect.right > pSourceInfo->bmiHeader.biWidth ||
	    SourceRect.bottom > ABSOL(pSourceInfo->bmiHeader.biHeight)) {

	    NOTERC("Source rect bigger than source bitmap!",SourceRect);

	    return VFW_E_TYPE_NOT_ACCEPTED;
	}
    }

    // Create a destination rectangle if it's empty

    RECT TargetRect = pTargetInfo->rcTarget;
    if (IsRectEmpty(&TargetRect) == TRUE) {
        TargetRect.right = pTargetInfo->bmiHeader.biWidth;
        TargetRect.bottom = ABSOL(pTargetInfo->bmiHeader.biHeight);
        TargetRect.left = TargetRect.top = 0;
        NOTERC("(Expanded) Target",TargetRect);
    } else {
	// Check that source rectange is within source
	if (TargetRect.right > pTargetInfo->bmiHeader.biWidth ||
	    TargetRect.bottom > ABSOL(pTargetInfo->bmiHeader.biHeight)) {

	    NOTERC("Target rect bigger than target bitmap!",TargetRect);
	    return VFW_E_TYPE_NOT_ACCEPTED;
	}
    }

    // Check we are not stretching nor compressing the image

    if (WIDTH(&SourceRect) == WIDTH(&TargetRect)) {
        if (HEIGHT(&SourceRect) == HEIGHT(&TargetRect)) {
            NOTE("No stretch");
            return NOERROR;
        }
    }

    return VFW_E_TYPE_NOT_ACCEPTED;
}


// Return our preferred media types (in order) for the output pin. The input
// pin assumes that since we are a transform we have no preferred types. We
// create an output media type by copying the input format and the adjusting
// it according to the output subtype. Since all inputs can be converted to
// all outputs we know there is a fixed number of different possible outputs
// which in turn means we can simply hard code the subtypes GUIDs for them.
// We also return the non RGB formats that our source filter proposes so when
// we are running we can pass these straight through with a minimal overhead

HRESULT CColour::GetMediaType(int iPosition, CMediaType *pmtOut)
{
    NOTE("Entering GetMediaType");
    ASSERT(pmtOut);
    GUID SubType;

    // Is this asking for a source proposed format

    if (iPosition < m_TypeList.GetCount()) {
        *pmtOut = *(GetListMediaType(iPosition));
        DisplayType(NAME("  Proposing source type"),pmtOut);
        return NOERROR;
    }

    // Quick sanity check on the output type index

    iPosition -= m_TypeList.GetCount();
    if (iPosition >= 6) {
        NOTE("Exceeds types supplied");
        return VFW_S_NO_MORE_ITEMS;
    }

    *pmtOut = m_pInput->CurrentMediaType();

    // Select the appropriate output subtype - this filter also does straight
    // pass through with and without scan line re-ordering. If we are passing
    // through eight bit palettised formats then we keep the source format as
    // we will not be using our dithering code (and therefore not our palette)

    switch (iPosition) {
        case 0: SubType = MEDIASUBTYPE_ARGB32;   break;
        case 1: SubType = MEDIASUBTYPE_RGB32;   break;
        case 2: SubType = MEDIASUBTYPE_RGB24;   break;
        case 3: SubType = MEDIASUBTYPE_RGB565;  break;
        case 4: SubType = MEDIASUBTYPE_RGB555;  break;
        case 5: SubType = MEDIASUBTYPE_RGB8;    break;
    }

    return PrepareMediaType(pmtOut,&SubType);
}


// Given that the input media type did not have a palette we have supply our
// default dithering palette. We can only transform to one specific palette
// because our dithering algorithm uses a known mapping between RGB elements
// and fixed palette positions. The video renderer will look after switching
// us back to DIBs when the palette in the window isn't an identity palette

VIDEOINFO *CColour::PreparePalette(CMediaType *pmtOut)
{
    NOTE("Entering PreparePalette");

    // Allocate enough room for a full colour palette

    pmtOut->ReallocFormatBuffer(SIZE_VIDEOHEADER + SIZE_PALETTE);
    VIDEOINFO *pVideoInfo = (VIDEOINFO *) pmtOut->Format();
    if (pVideoInfo == NULL) {
        NOTE("No format");
        return NULL;
    }

    ASSERT(PALETTISED(pVideoInfo) == TRUE);

    // If we are converting 8 bit to 8 bit, we want to offer on our output,
    // the same palette as the input palette.  If we are converting true
    // colour to 8 bit, we want to offer our stock dither palette

    LPBITMAPINFOHEADER lpbiIn = HEADER(m_pInput->CurrentMediaType().Format());
    LPBITMAPINFOHEADER lpbiOut = HEADER(pVideoInfo);
    ASSERT(lpbiIn);
    if (lpbiIn->biBitCount == 8) {
	//DbgLog((LOG_TRACE,3,TEXT("OFFERING 8 BIT of the SAME PALETTE")));
	int cb = lpbiIn->biClrUsed ? lpbiIn->biClrUsed * sizeof(RGBQUAD) :
						256 * sizeof(RGBQUAD);
	CopyMemory(lpbiOut, lpbiIn, sizeof(BITMAPINFOHEADER) + cb);

    } else {
	//DbgLog((LOG_TRACE,3,TEXT("OFFERING 8 BIT of my DITHER PALETTE")));

        // Initialise the palette entries in the header

        pVideoInfo->bmiHeader.biClrUsed = STDPALCOLOURS;
        pVideoInfo->bmiHeader.biClrImportant = STDPALCOLOURS;
        NOTE("Adding system device colours to dithered");

        // Get the standard system colours

        PALETTEENTRY apeSystem[OFFSET];
        HDC hDC = GetDC(NULL);
        if (NULL == hDC) {
            return NULL;
        }
        GetSystemPaletteEntries(hDC,0,OFFSET,apeSystem);
        ReleaseDC(NULL,hDC);

        // Copy the first ten VGA system colours

        for (LONG Index = 0;Index < OFFSET;Index++) {
            pVideoInfo->bmiColors[Index].rgbRed = apeSystem[Index].peRed;
            pVideoInfo->bmiColors[Index].rgbGreen = apeSystem[Index].peGreen;
            pVideoInfo->bmiColors[Index].rgbBlue = apeSystem[Index].peBlue;
            pVideoInfo->bmiColors[Index].rgbReserved = 0;
        }

        // Copy the palette we dither to one colour at a time

        for (Index = OFFSET;Index < STDPALCOLOURS;Index++) {
            pVideoInfo->bmiColors[Index].rgbRed = StandardPalette[Index].rgbRed;
            pVideoInfo->bmiColors[Index].rgbGreen =
						StandardPalette[Index].rgbGreen;
            pVideoInfo->bmiColors[Index].rgbBlue =
						StandardPalette[Index].rgbBlue;
            pVideoInfo->bmiColors[Index].rgbReserved = 0;
        }
    }
    return pVideoInfo;
}


// The output media type is sixteen bit true colour so we allocate sufficient
// space for the bit masks if not already there and then set them accordingly
// We get the subtype from the media type object to know whether it is RGB555
// or RGB565 representation, RGB555 bit fields are implicit if it's BI_RGB

VIDEOINFO *CColour::PrepareTrueColour(CMediaType *pmtOut)
{
    NOTE("Entering PrepareTrueColour");
    VIDEOINFO *pVideoInfo = (VIDEOINFO *) pmtOut->Format();
    ASSERT(pVideoInfo->bmiHeader.biBitCount == iTRUECOLOR);

    // Make sure the format is long enough, so reallocate the format buffer
    // in place using one of the CMediaType member functions. The pointer
    // that is returned is the new format or NULL if we ran out of memory

    pVideoInfo->bmiHeader.biCompression = BI_BITFIELDS;
    ULONG Length = pmtOut->FormatLength();

    if (Length < SIZE_MASKS + SIZE_VIDEOHEADER) {
        pmtOut->ReallocFormatBuffer(SIZE_MASKS + SIZE_VIDEOHEADER);
        pVideoInfo = (VIDEOINFO *) pmtOut->Format();
        if (pVideoInfo == NULL) {
            NOTE("No format");
            return NULL;
        }
    }

    // Set the new bit fields masks (compression is already BI_RGB)

    const DWORD *pBitMasks = bits555;
    if (IsEqualGUID(*pmtOut->Subtype(),MEDIASUBTYPE_RGB565) == TRUE) {
        NOTE("Setting masks");
        pBitMasks = bits565;
    }

    pVideoInfo->dwBitMasks[iRED] = pBitMasks[iRED];
    pVideoInfo->dwBitMasks[iGREEN] = pBitMasks[iGREEN];
    pVideoInfo->dwBitMasks[iBLUE] = pBitMasks[iBLUE];
    return pVideoInfo;
}


// When we prepare an output media type we take a copy of the input format as
// a point of reference so that image dimensions for example remain constant
// Depending on the type of transform we are doing we must also update the
// headers to keep synchronised with the changing type. We may also have to
// allocate more format memory if the type now requires masks for example

HRESULT CColour::PrepareMediaType(CMediaType *pmtOut,const GUID *pSubtype)
{
    VIDEOINFO *pVideoInfo = (VIDEOINFO *) pmtOut->Format();
    pmtOut->SetSubtype(pSubtype);
    NOTE("Entering PrepareMediaType");

    // Initialise the BITMAPINFOHEADER details

    pVideoInfo->bmiHeader.biCompression = BI_RGB;
    pVideoInfo->bmiHeader.biBitCount = GetBitCount(pSubtype);
    pVideoInfo->bmiHeader.biSizeImage = GetBitmapSize(&pVideoInfo->bmiHeader);
    pVideoInfo->bmiHeader.biClrUsed = 0;
    pVideoInfo->bmiHeader.biClrImportant = 0;
    ASSERT(pVideoInfo->bmiHeader.biBitCount);
    pmtOut->SetSampleSize(pVideoInfo->bmiHeader.biSizeImage);

    // Make any true colour adjustments

    if (pVideoInfo->bmiHeader.biBitCount == 16) {
        pVideoInfo = PrepareTrueColour(pmtOut);
        if (pVideoInfo == NULL) {
            NOTE("No colour type");
            return E_OUTOFMEMORY;
        }
    }

    // First of all we check that the new output type requires a palette and
    // if so then we give it out fixed palette, this is the case even if it
    // comes with a palette attached (as some codecs provide) because we can
    // only dither to our own special fixed palette that we can optimise

    if (pVideoInfo->bmiHeader.biBitCount == 8) {
        pVideoInfo = PreparePalette(pmtOut);
        if (pVideoInfo == NULL) {
            NOTE("No palette type");
            return E_OUTOFMEMORY;
        }
    }

    // The colour convertor filter shows DIB format images by default
    // Do this last