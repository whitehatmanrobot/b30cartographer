D", pKeyValue->pwstrKey))
        {
            pkvDword = pKeyValue;

            LPWSTR *ppwstr = (LPWSTR *)pKeyValue->vaValue.Argv;
            DWORD *pdwCur = (DWORD *)ppwstr;
            for (DWORD loop = 0; loop < pKeyValue->vaValue.dwArgc; ++loop)
            {
                *pdwCur++ = _wtol(*ppwstr++);
            }

            m_ConfigParser.GetLogicalLine(&wstrLine, &iLineCount);
            m_errc.iLine += iLineCount;
            (void)ParseKeyAndValue(m_pBlockMgr, wstrLine, &pKeyValue);
        }
        if (SUCCEEDED(hr) && !WSTRICMP(L"String", pKeyValue->pwstrKey))
        {
            pkvString = pKeyValue;
        }
    }

    DWORD dwInstance;
    if (SUCCEEDED(hr)
        && SUCCEEDED(hr = m_piitdb->CreateObject(clsid, &dwInstance)))
    {
        ITASSERT(dwInstance <= MAX_HELPER_INSTANCE);

        if(dwInstance > m_dwMaxInstance)
            m_dwMaxInstance = dwInstance;

        if(NULL == (m_wstrHelper[dwInstance].pwstrName =
            (LPWSTR)BlockCopy(m_pBlockMgr,
            (LPB)(m_wstrSection + 3),
            (DWORD) WSTRCB(m_wstrSection + 3), 0)))
        {
            SetErrCode(&hr, E_OUTOFMEMORY);
        }
        m_wstrHelper[dwInstance].dwCodePage = dwCodePage;
        m_wstrHelper[dwInstance].lcid = lcid;
        m_wstrHelper[dwInstance].kvDword = pkvDword->vaValue;
        m_wstrHelper[dwInstance].kvString = pkvString->vaValue;
    }
    return hr;
} /* ParseHelperSz */


HRESULT WINAPI CITCmdInt::ParseConfigStream(void)
{
    LPWSTR pwstrLine;
    BOOL fParsingHelper = TRUE;
    PFPARSE2 pfparse;
    int iLineCount;

    for(;;)
    {
        if (S_OK != m_ConfigParser.GetLogicalLine
            (&pwstrLine, &iLineCount))
        {
            if (fParsingHelper)
            {
                m_ConfigParser.Reset();
                m_errc.iLine = 0;
                fParsingHelper = FALSE;
                continue;
            }
            else
                break;
        }
        m_errc.iLine += iLineCount;

        if(S_OK == IsSectionHeading(pwstrLine))
        {
            (void)GetFunctionFromSection(pwstrLine + 1, (void **)&pfparse);
            WSTRCPY(m_wstrSection, pwstrLine + 1);
            continue;
        }

        if (fParsingHelper)
        {
            if (ParseHelperSz == pfparse)
                (void)ParseHelperSz(pwstrLine);
        } else if(ParseIndexSz == pfparse)
            (void)ParseIndexSz(pwstrLine);
    }

    return S_OK;
} /* ParseConfigStream */


struct tagSection
{
    LPCWSTR szName;
    PFPARSE2 pfparse;
};

HRESULT WINAPI CITCmdInt::GetFunctionFromSection
    (LPWSTR pwstrSection, void **ppvoid)
{
    ITASSERT(pwstrSection && ppvoid);
    PFPARSE2 *ppfparse = (PFPARSE2 *)ppvoid;

    const int NUM_RECOGNIZED_SECTIONS = 3;
    const tagSection rgSection[NUM_RECOGNIZED_SECTIONS] =
    {
         { L"OPTIONS",    CITCmdInt::ParseBogusSz    },
         { L"INDEX",      CITCmdInt::ParseIndexSz    },
         { L"HO:",        CITCmdInt::ParseHelperSz   },
    };

    *ppfparse = NULL;
    for (int loop = 0; loop < NUM_RECOGNIZED_SECTIONS; ++loop)
    {
        if (!WSTRNICMP (rgSection[loop].szName, pwstrSection,
            WSTRLEN(rgSection[loop].szName)))
        {
            *ppfparse = rgSection[loop].pfparse;
            break;
        }
    }

    if (NULL == *ppfparse)
        *ppfparse = ParseBogusSz;

    return S_OK;
} /* GetFunctionFromSection */


HRESULT WINAPI CITCmdInt::IsSectionHeading(LPWSTR pwstrLine)
{
    ITASSERT(pwstrLine);
    HRESULT hr = S_FALSE;

    if (*pwstrLine == '[')
    {
        LPWSTR pch = pwstrLine + WSTRLEN(pwstrLine) - 1;

        /*****************************************************
         * IS SECTION HEADING TERMINATED WITH CLOSING BRACKET?
         *****************************************************/
        if (*pch != ']')                // *** NO! ***
        {
            m_errc.errCode = CIERR_SectionHeadingSyntax;
            ReportError (m_piistmLog, m_errc);
        }
        else
        {   // *** YES! ***
            *pch = '\0';
            pch = pwstrLine + 1;
            pch = SkipWhitespace(pch);
            StripTrailingBlanks(pch);
            hr = S_OK;
        }
    }
    return hr;
} /* IsSectionHeading */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\cmdint\cmdint.h ===
// CMDINT.H

#ifndef _CMDINT_H
#define _CMDINT_H

#include <windows.h>
#include <itcc.h>
#include <iterror.h>
#include <atlinc.h>
#include "verinfo.h"
#include "cistream.h"

#define WSTRCB(wstr) (WSTRLEN (wstr) * 2 + sizeof (WCHAR))
#define MAX_HELPER_INSTANCE 50

#define TOKEN_DELIM     L','
#define TOKEN_QUOTE     L'"'
#define TOKEN_SPACE     L'\x20'
#define TOKEN_NULL      L'\0'
#define TOKEN_EQUAL     L'='

struct KEYVAL
{
    LPWSTR pwstrKey;
    VARARG vaValue;
};

// Command Interpreter class
class CITCmdInt : 
	public IITCmdInt,
	public CComObjectRoot,
	public CComCoClass<CITCmdInt,&CLSID_IITCmdInt>
{
public:
    CITCmdInt () : m_fInit(FALSE) {}
    ~CITCmdInt ();

BEGIN_COM_MAP(CITCmdInt)
	COM_INTERFACE_ENTRY(IITCmdInt)
END_COM_MAP()

DECLARE_REGISTRY (CLSID_IITCmdInt,
    "ITIR.CmdInt.4", "ITIR.CmdInt", 0, THREADFLAGS_APARTMENT)

public:
	STDMETHOD(Initiate)(IITSvMgr *piitsvs);
	STDMETHOD(Dispose)(void);
	STDMETHOD(LoadFromStream)(IStream *pMVPStream, IStream *pLogStream);
// Data members
private:
    STDMETHOD(ParseConfigStream)(void);
    STDMETHOD(ParseHelperSz)(LPWSTR);
    STDMETHOD(ParseBogusSz)(LPWSTR);
    STDMETHOD(ParseIndexSz)(LPWSTR);
    STDMETHOD(GetFunctionFromSection)(LPWSTR pwstrLine, void **ppfparse);
    STDMETHOD(IsSectionHeading)(LPWSTR pwstrSection);

    BOOL m_fInit;
    ERRC m_errc;
    IStream *m_piistmLog;
    IITSvMgr *m_piitsv;
    IITDatabase *m_piitdb;
    CStreamParseLine m_ConfigParser;
    WCHAR m_wstrSection[1024];   // Keep DWORD aligned!
    LPVOID m_pBlockMgr;
    DWORD m_dwMaxInstance;
    struct tagHELPERSTUFF
    {
        LPWSTR pwstrName;
        DWORD dwCodePage;
        LCID  lcid;
        VARARG kvDword;
        VARARG kvString;
    } m_wstrHelper[MAX_HELPER_INSTANCE + 1];

}; /* class CITCmdInt */

typedef HRESULT (WINAPI CITCmdInt ::* PFPARSE2) (LPWSTR);

#endif /* _CMDINT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\cmdint\ciutil.cpp ===
/********************************************************************
 TITLE: UTILIB.CPP

 OWNER: johnrush (John C. Rush)

 DATE CREATED: January 29, 1997

 DESCRIPTION:
     This is the source file for the utility library; its
     associated header is utilib.h.  This module will contain
     all sorts of general purpose utility functions.
*********************************************************************/
#include <mvopsys.h>

#ifdef _DEBUG
static char * s_aszModule = __FILE__;   /* For error report */
#endif

#include <orkin.h>
#include <iterror.h>
#include <_mvutil.h>    // BlockCopy

#include "cmdint.h"
#include "cierror.h"
#include "..\svutil.h"

extern HINSTANCE _hInstITCC;

/**************************************************
DESCRIPTION:
     This routine strips the trailing blanks from
     a null-terminated string.  It then returns
     the string so that this routine will have the
     side effect of actually altering its parameter.

     The rationale for the approach used here -- begin
     at the front of the string and count through,
     rather than start at the end and count down until
     a non-blank character is hit, and then back up --
     is that in order to start at the end of the string,
     strlen() must already have counted through it
     once.  This way, we only have to look at the
     characters in the string once.

	MATTSMI 5/21/92 -- ENHANCED TO ALSO STRIP TABS.
***************************************************/
LPWSTR WINAPI StripTrailingBlanks(LPWSTR sz)
{
	LPWSTR pChar;
	LPWSTR pSpace=NULL;

	pChar=sz;

	while (*pChar) {
		if ( *pChar == L' ' || *pChar == L'\t' || *pChar == 0x1A /*CTL_Z*/)
        {
			if (!pSpace)
				pSpace=pChar;
		}
		else
			pSpace=NULL;

		++pChar;
	}

	if (pSpace)
		*pSpace = L'\0';

	return(sz);
}   /* StripTrailingBlanks */


/**************************************************
DATE DOCUMENTED: April 3, 1992


@doc INTERNAL

@api LPWSTR | SkipWhitespace | incrementes the
	  passed-in pointer past all leading blanks.

@parm LPWSTR | pch | pointer to be incremented.

@comm
	MATTSMI 5/21/92 enhanced to also increment past tabs.

***************************************************/
LPWSTR WINAPI SkipWhitespace(LPWSTR lpwstrIn)
{
    while (*lpwstrIn == L' ' || *lpwstrIn == L'\t')
		++lpwstrIn;
	return lpwstrIn;
}   /* SkipWhitespace */


/**************************************************
DESCRIPTION:
	This routine strips all Leading blanks from
	a string and then scoots it over so that it
	begins at the original address.

Note: obviously, a side effect of this routine
is that the original string parameter is altered.

***************************************************/
VOID WINAPI StripLeadingBlanks(LPWSTR pchSource)
{       /*** StripLeadingBlanks ***/
 
	LPWSTR pchSeeker;

	pchSeeker=pchSource;

	/****************************
	 * FIND FIRST NON-BLANK CHAR
	 ****************************/

	while (*pchSeeker == L' ' || *pchSeeker == L'\t')
		++pchSeeker;

	/************************
	IF THE FIRST NON-BLANK IS
	NOT THE FIRST CHARACTER . . .
	*************************/
	if (pchSeeker != pchSource) {

		/********************
		SCOOT ALL BYTES DOWN
		********************/

		for (;;) {
			 if ((*pchSource=*pchSeeker) == 0)
				break;
			 ++pchSource;
			 ++pchSeeker;
		}
	}
}    /* StripLeadingBlanks */


/**************************************************
AUTHOR: Matthew Warren Smith.
January 17, 1992

DESCRIPTION:
     This routine scans a null-terminated string
     attempting to determine if it consists entirely
     of digits -- ie it will be able to be converted
     into a number by atol without error.
***************************************************/
BOOL WINAPI IsStringOfDigits(char *szNumericString)
{

	int i=0;

	while (szNumericString[i])
	{
	     if (!isdigit( (int)(szNumericString[i])))
			return(FALSE);
		else
			i++;
	}

     return(TRUE);

}   /* IsStringOfDigits */



/*--------------------------------------------------------------------------*/
LONG WINAPI StrToLong (LPWSTR lszBuf)
{
	register LONG Result;   // Returned result
	register int i;                 // Scratch variable
	char fGetSign = 1;

	/* Skip all blanks, tabs, <CR> */
	if (*lszBuf == '-') {
		fGetSign = -1;
		lszBuf++;
	}
	else if (*lszBuf == '+')
		lszBuf++;

	Result = 0;


	/* The credit of this piece of code goes to Leon */
	while (i = *lszBuf - '0', i >= 0 && i <= 9) {
		Result = Result * 10 + i;
		lszBuf++;
	}
	return (Result * fGetSign);
}

#if 0
BOOL WINAPI IgnoreWarning (int errCode, PWARNIGNORE pWarnIgnore)
{
    int fRet = FALSE;
    WORD i;
    LPWORD pwWarnings;
    
    if (NULL == pWarnIgnore || NULL == pWarnIgnore->hMem)
        return FALSE;

    if (NULL == (pwWarnings = (LPWORD)_GLOBALLOCK (pWarnIgnore->hMem)))
        return FALSE;

    for (i = 0; i < pWarnIgnore->cbWarning && fRet == FALSE; i++)
        if (*(pwWarnings + i) == (WORD)errCode)
            fRet = TRUE;
    _GLOBALUNLOCK (pWarnIgnore->hMem);
    return fRet;
}
#endif

int WINAPI ReportError (IStream *piistm, ERRC &errc)
{
    if (NULL == piistm)
        return S_OK;

    int errCode = errc.errCode, iLevel;
    ULONG ulCount;
    char rgchLocalBuf[1024];

	/***************************
	MODULO THE ERROR NUMBER WITH
	5 TO GET THE WARNING LEVEL,
	BUT SET FATAL ERRORS TO -1
	SO THAT THEY ALWAYS APPEAR.
	****************************/
    if (errCode > 30000)
        iLevel = -2;    // Status message
    else
    {
    	iLevel = (errCode % 5);

 	    if (iLevel == 4 || (errCode % 1000 == 0))
		    iLevel = -1;    // Error message
    }

    switch (iLevel)
    {
        case -2:
            STRCPY (rgchLocalBuf, "\n");
            break;
        case -1:
            wsprintf (rgchLocalBuf, "\nError %d: ", errCode);
            break;
        default:
            wsprintf (rgchLocalBuf, "\nWarning %d: ", errCode);
            break;
    }

    piistm->Write
        (rgchLocalBuf, (DWORD) STRLEN (rgchLocalBuf), &ulCount);

    if (LoadString (_hInstITCC, errCode, rgchLocalBuf, 1024 * sizeof (char)))
        wsprintf (rgchLocalBuf, rgchLocalBuf, errc.var1, errc.var2, errc.var3);
    else
        STRCPY (rgchLocalBuf,
            "Error string could not be loaded from resource file.");

    piistm->Write (rgchLocalBuf, (DWORD) STRLEN (rgchLocalBuf), &ulCount);
    piistm->Write (".\r\n", (DWORD) STRLEN (".\r\n"), &ulCount);
    return (errCode);
} /* ReportError */


LPWSTR GetNextDelimiter(LPWSTR pwstrStart, WCHAR wcDelimiter)
{
    for (; *pwstrStart; pwstrStart++)
    {
        if(*pwstrStart == wcDelimiter)
            return pwstrStart;
    }
    return NULL;
} /* GetNextDelimiter */


HRESULT ParseKeyAndValue(LPVOID pBlockMgr, LPWSTR pwstrLine, KEYVAL **ppkvOut)
{
    ITASSERT(pwstrLine);

    // Extract key
    LPWSTR pwstrKey = SkipWhitespace(pwstrLine);
    LPWSTR pwstrValue = GetNextDelimiter(pwstrKey, TOKEN_EQUAL);
    if (NULL == pwstrValue)
        // No delimiter!
        return E_FAIL;

    if (NULL == (*ppkvOut = (KEYVAL *)
        BlockCopy(pBlockMgr, NULL, sizeof(KEYVAL), 0)))
        return E_OUTOFMEMORY;
    KEYVAL *pkvOut = *ppkvOut;

    if (NULL == (pkvOut->pwstrKey = (LPWSTR)BlockCopy(pBlockMgr,
        (LPB)pwstrKey, sizeof (WCHAR) * (DWORD)(pwstrValue - pwstrKey + 1), 0)))
        return SetErrReturn(E_OUTOFMEMORY);
    pkvOut->pwstrKey[pwstrValue - pwstrKey] = TOKEN_NULL;
    StripTrailingBlanks(pkvOut->pwstrKey);

    LPWSTR pwstrNextValue;
    LPWSTR *plpv = (LPWSTR *)pkvOut->vaValue.Argv;
    for (DWORD dwArgCount = 1; ;
        dwArgCount++, pwstrValue = pwstrNextValue, plpv++)
    {
        pwstrValue = SkipWhitespace(pwstrValue + 1);
        pwstrNextValue = GetNextDelimiter(pwstrValue, TOKEN_DELIM);
        if (NULL == pwstrNextValue)
            break;

        if (NULL == (*plpv =
            (LPWSTR)BlockCopy(pBlockMgr, (LPB)pwstrValue,
            sizeof (WCHAR) * (DWORD)(pwstrNextValue - pwstrValue + 1), 0)))
            return SetErrReturn(E_OUTOFMEMORY);
        (*plpv)[pwstrNextValue - pwstrValue] = TOKEN_NULL;
        StripTrailingBlanks(*plpv);
    }
    if (NULL == (*plpv = (LPWSTR)BlockCopy
        (pBlockMgr, (LPB)pwstrValue, (DWORD) WSTRCB(pwstrValue), 0)))
        return SetErrReturn(E_OUTOFMEMORY);
    StripTrailingBlanks(*plpv);

    pkvOut->vaValue.dwArgc = dwArgCount;
    return S_OK;
} /* ParseKeyAndValue */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\gpbuild\gpumain.h ===
// GPUMAIN.H:  Definition of CITGroupUpdate

#ifndef __GPUMAIN_H__
#define __GPUMAIN_H__

#include <verinfo.h>
#include <itcc.h>

#include <mvopsys.h>
#include <groups.h>

class CITGroupUpdate : 
	public IITBuildCollect,
    public IPersistStorage,
	public CComObjectRoot,
	public CComCoClass<CITGroupUpdate,&CLSID_IITGroupUpdate>
{
public:
	CITGroupUpdate () : m_fInitialized(FALSE) {}
    ~CITGroupUpdate();

BEGIN_COM_MAP(CITGroupUpdate)
	COM_INTERFACE_ENTRY(IITBuildCollect)
	COM_INTERFACE_ENTRY(IPersistStorage)
END_COM_MAP()

DECLARE_REGISTRY (CLSID_IITGroupUpdate,
    "ITIR.GroupBuild.4", "ITIR.GroupBuild", 0, THREADFLAGS_APARTMENT )

public:
    // IITBuildCollect
    STDMETHOD(SetConfigInfo)(IITDatabase *piitdb, VARARG vaParams);
	STDMETHOD(InitHelperInstance)(DWORD dwHelperObjInstance,
        IITDatabase *pITDatabase, DWORD dwCodePage,
        LCID lcid, VARARG vaDword, VARARG vaString);
	STDMETHOD(SetEntry)(LPCWSTR szDest, IITPropList *pPropList);
	STDMETHOD(Close)(void);
    STDMETHOD(GetTypeString)(LPWSTR pPrefix, DWORD *pLength);
    STDMETHOD(SetBuildStats)(ITBuildObjectControlInfo &itboci);

    // IPersistStorage
    STDMETHOD(GetClassID)(CLSID *pClsID);
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(IStorage *pStg);
    STDMETHOD(Save)(IStorage *pStgSave, BOOL fSameAsLoad);
    STDMETHOD(InitNew)(IStorage *pStg);
    STDMETHOD(SaveCompleted)(IStorage *pStgNew);
    STDMETHOD(HandsOffStorage)(void);

private:
    HANDLE m_hTempFile;
    char m_szTempFile[_MAX_PATH + 1];
    BOOL m_fInitialized, m_fIsDirty, m_fGroupNot;
    IStorage *m_pStorage;
    DWORD m_dwMaxUID, m_dwMaxTitleUID;
}; /* class CITGroupUpdate */

#endif /* __GPUMAIN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\ftbuild\ftumain.h ===
// ftuMain.H:  Definition of CITIndexBuild

#ifndef __FTUMAIN_H__
#define __FTUMAIN_H__

#include <verinfo.h>
#include <itcc.h>
#include <bfnew.h>

class CITIndexBuild : 
	public IITBuildCollect,
    public IPersistStreamInit,
    public IPersistFile,
	public CComObjectRoot,
	public CComCoClass<CITIndexBuild,&CLSID_IITIndexBuild>
{
public:
	CITIndexBuild();
    ~CITIndexBuild();

BEGIN_COM_MAP(CITIndexBuild)
	COM_INTERFACE_ENTRY(IITBuildCollect)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
END_COM_MAP()

DECLARE_REGISTRY (CLSID_IITIndexBuild,
    "ITIR.FTIBuild.4", "ITIR.FTIBuild", 0, THREADFLAGS_APARTMENT )

public:
    STDMETHOD(SetConfigInfo)(IITDatabase *piitdb, VARARG vaParams);
	STDMETHOD(InitHelperInstance)(DWORD dwHelperObjInstance,
        IITDatabase *pITDatabase, DWORD dwCodePage,
        LCID lcid, VARARG vaDword, VARARG vaString);
	STDMETHOD(SetEntry)(LPCWSTR szDest, IITPropList *pPropList);
	STDMETHOD(Close)(void);
    STDMETHOD(GetTypeString)(LPWSTR pPrefix, DWORD *pLength);
    STDMETHOD(SetBuildStats)(ITBuildObjectControlInfo &itboci)
        { return E_NOTIMPL;}

    // IPersistStreamInit methods
    STDMETHOD(GetClassID)(CLSID *pClsID);
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(InitNew)(void);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    // IPersistFile methods
    STDMETHOD(Load)(LPCWSTR pszFileName, DWORD dwMode);
    STDMETHOD(Save)(LPCWSTR pszFileName, BOOL fRemember);
    STDMETHOD(SaveCompleted)(LPCWSTR pszFileName);
    STDMETHOD(GetCurFile)(LPWSTR *ppszFileName);

private:
    STDMETHOD(SendTextToBreaker)(void);

    IWordSink *m_piWordSink;
    IWordBreaker *m_piwb;
    IWordBreakerConfig *m_piwbConfig;
    void *m_lpipb;
    BOOL m_fInitialized, m_fIsDirty;
    DWORD m_dwUID, m_dwVFLD, m_dwDType, m_dwWordCount, m_dwCodePage;
    DWORD m_dwOccFlags;
    LPBF m_lpbfText;    // Index text buffer

}; /* class CITIndexBuild */

// Defines ********************************************************************


// Type Definitions ***********************************************************


// Function Prototypes ********************************************************

#endif /* __FTUMAIN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\gpbuild\gpumain.cpp ===
/****************************************************************
 * @doc SHROOM EXTERNAL API
 *
 *  A Legsdin	added autodoc headers for IITBuildCollect Interface
 *
 ****************************************************************/
#include <mvopsys.h>

// wwbmain.CPP:  Implementation of wordwheel update interface
#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <windows.h>
#include <iterror.h>
#include <itpropl.h>
#include <ccfiles.h>
#include <orkin.h>
#include <atlinc.h>

#include "..\svutil.h"
#include "gpumain.h"

CITGroupUpdate::~CITGroupUpdate()
{
    (void)Close();
}


STDMETHODIMP CITGroupUpdate::GetTypeString(LPWSTR pPrefix, DWORD *pLen)
{
    DWORD dwLen = (DWORD) WSTRLEN (SZ_GP_STORAGE) + 1;

    if (NULL == pPrefix)
    {
        *pLen = dwLen;
        return S_OK;
    }

    if (pLen && *pLen < dwLen)
    {
        *pLen = dwLen;
        return S_OK;
    }

    if (pLen)
        *pLen = dwLen;

    WSTRCPY (pPrefix, SZ_GP_STORAGE);
    return S_OK;
} /* GetTypeString */


STDMETHODIMP CITGroupUpdate::SetConfigInfo
    (IITDatabase *piitdb, VARARG vaParams)
{
    if(vaParams.dwArgc)
        m_fGroupNot = !WSTRICMP(L"GROUP_NOT", (LPWSTR)vaParams.Argv[0]);

    return S_OK;
} /* SetConfigInfo */


STDMETHODIMP CITGroupUpdate::InitHelperInstance(
    DWORD dwHelperObjInstance,
    IITDatabase *pITDatabase, DWORD dwCodePage,
    LCID lcid, VARARG vaDword, VARARG vaString
    )
{
    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    return S_OK;
} /* InitHelperInstance */


STDMETHODIMP CITGroupUpdate::SetEntry(LPCWSTR szDest, IITPropList *pPropList)
{
    
    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    HRESULT hr;

    // The only property we are interested in is STDPROP_UID
    CProperty UidProp;
    if (FAILED(hr = pPropList->Get(STDPROP_UID, UidProp))
        || TYPE_STRING == UidProp.dwType)
        return SetErrReturn(E_INVALIDARG);

    // This could be a pointer to a UID or a DWORD UID
    DWORD dwUID;
    if (TYPE_VALUE == UidProp.dwType)
        dwUID = UidProp.dwValue;
    else if (TYPE_POINTER == UidProp.dwType)
        dwUID = *((LPDWORD&)UidProp.lpvData);

    // Save highest UID
    if (dwUID > m_dwMaxUID)
        m_dwMaxUID = dwUID;
    
    DWORD dwWritten;
    WriteFile (m_hTempFile, &dwUID, sizeof (dwUID), &dwWritten, NULL);
    if (dwWritten != sizeof (dwUID))
        return SetErrReturn(E_FILEWRITE);

    m_fIsDirty = TRUE;

    return S_OK;
} /* SetEntry */


STDMETHODIMP CITGroupUpdate::Close(void)
{
    if (m_pStorage)
    {
        m_pStorage->Release();
        m_pStorage = NULL;
    }

    DeleteFile (m_szTempFile);

    m_dwMaxTitleUID = 0;
    m_fInitialized = FALSE;

    return S_OK;
} /* Close */

/************************************************************************
 *  @method   STDMETHODIMP | IITBuildCollect | SetBuildStats | 
 * Gives the build object information about the title. 
 *	
 * @parm ITBuildObjectControlInfo | &itboci| A structure consisting of
 * a DWORD dwSize set to the size of the structure, and a DWORD dwMaxUID that
 * represents the highest UID authored for the title. 
 * 
 * @rvalue S_OK | The operation completed successfully
 * @rvalue E_NOTINIT | The object has not been initialized
 * @rvalue E_INVALIDARG | dwSize cannot be zero
 *
 * @comm Call this method at the end of the build process before the object
 * is persisted. 
 ************************************************************************/

STDMETHODIMP CITGroupUpdate::SetBuildStats(ITBuildObjectControlInfo &itboci)
{
    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    if (0 == itboci.dwSize)
        return SetErrReturn(E_INVALIDARG);

#ifdef _DEBUG // {
    if(itboci.dwSize != 8)
        ITASSERT(0);
#endif // _DEBUG }

    m_dwMaxTitleUID = itboci.dwMaxUID;
    return S_OK;
} /* SetControlInfo */


STDMETHODIMP CITGroupUpdate::InitNew(IStorage *pStg)
{
    if (NULL == pStg)
        return SetErrReturn(E_INVALIDARG);
    if (m_fInitialized)
        return SetErrReturn(CO_E_ALREADYINITIALIZED);

    // Create the temp file
    char szTempPath [_MAX_PATH + 1];
    if (0 == GetTempPath(_MAX_PATH, szTempPath))
        return SetErrReturn(E_FILECREATE);
    if (0 == GetTempFileName(szTempPath, "GPU", 0, m_szTempFile))
        return SetErrReturn(E_FILECREATE);
    m_hTempFile = CreateFile
       (m_szTempFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
        FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (INVALID_HANDLE_VALUE == m_hTempFile)
        return SetErrReturn(E_FILECREATE);

    m_fGroupNot = FALSE;
    m_dwMaxUID = 0;
    m_pStorage = pStg;
    pStg->AddRef();
    m_fIsDirty = FALSE;

    m_fInitialized = TRUE;
	return S_OK;
} /* InitNew */


STDMETHODIMP CITGroupUpdate::Save(IStorage *pStgSave, BOOL fSameAsLoad)
{
    HRESULT hr;
    LPDWORD pInput, pCur;
    _LPGROUP pGroup = NULL;

    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    if (NULL == pStgSave)
        return SetErrReturn(E_INVALIDARG);

    DWORD dwSize =  GetFileSize(m_hTempFile, NULL);
    if (0 == dwSize)
    {
        HFPB hfpb = NULL;
        pGroup = GroupInitiate (m_dwMaxUID + 1, &hr);
        if (SUCCEEDED(hr))
        {
            // Group code only works if you add at least one item,
            // so we add one and remove it
            GroupAddItem(pGroup, 0);
            GroupRemoveItem(pGroup, 0);
            hfpb = (HFPB)FpbFromHfs (pStgSave, &hr);
        }
        if (SUCCEEDED(hr))
            hr = GroupFileBuild (hfpb, SZ_GROUP_MAIN_A, pGroup);

		if (hfpb != NULL)
			FreeHfpb(hfpb);
        GroupFree(pGroup);
        return S_OK;
    }

    CloseHandle (m_hTempFile);
    pCur = pInput = (LPDWORD)MapSequentialReadFile(m_szTempFile, &dwSize);
    if (NULL == pInput)
    {
        SetErrCode(&hr, E_FILEREAD);
exit0:
        UnmapViewOfFile (pInput);
        // Open a handle to the temp file in case we want to add more
        // items later
        m_hTempFile = CreateFile
            (m_szTempFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING,
            FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        SetFilePointer(m_hTempFile, 0, NULL, FILE_END);

        if (pGroup)
            GroupFree (pGroup);
        return hr;
    }
    LPDWORD pEnd = pInput + (dwSize / sizeof (DWORD));

    // Initialize the group info structure for this group
    if (m_fGroupNot && m_dwMaxTitleUID > m_dwMaxUID)
        // If the group is to be inverted we must grow the size to match
        // the maximum UID for the title not just for this group.
        pGroup = GroupInitiate (m_dwMaxTitleUID + 1, &hr);
    else
        pGroup = GroupInitiate (m_dwMaxUID + 1, &hr);

    if (NULL == pGroup)
        goto exit0;

    while (pEnd != pCur)
    {
	    if (FAILED(hr = GroupAddItem (pGroup,  *pCur++)))
		    goto exit0;
    }

    if (m_fGroupNot)
    {
        _LPGROUP pOldGroup = pGroup;
        pGroup = GroupNot (pGroup, &hr);
        GroupFree (pOldGroup);
    }

    HFPB hfpb;
    if (NULL == (hfpb = (HFPB)FpbFromHfs (pStgSave, &hr)))
	    goto exit0;

    hr = GroupFileBuild (hfpb, SZ_GROUP_MAIN_A, pGroup);
    FreeHfpb(hfpb);

    goto exit0;    
} /* Save */


STDMETHODIMP CITGroupUpdate::GetClassID(CLSID *pClsID)
{
    if (NULL == pClsID
        || IsBadWritePtr(pClsID, sizeof(CLSID)))
        return SetErrReturn(E_INVALIDARG);

    *pClsID = CLSID_IITGroupUpdate;
    return S_OK;
} /* GetClassID */


inline STDMETHODIMP CITGroupUpdate::IsDirty(void)
{
    return m_fIsDirty ? S_OK : S_FALSE;
} /* IsDirty */


inline STDMETHODIMP CITGroupUpdate::Load(IStorage *pStg)
{
    return SetErrReturn(E_NOTIMPL);
} /* Load */


STDMETHODIMP CITGroupUpdate::SaveCompleted(IStorage *pStgNew)
{
    if (pStgNew)
    {
        if (!m_pStorage)
            return SetErrReturn(E_UNEXPECTED);
        m_pStorage->Release();
        (m_pStorage = pStgNew)->AddRef();
    }
    m_fIsDirty = FALSE;
    return S_OK;
} /* SaveCompleted */


inline STDMETHODIMP CITGroupUpdate::HandsOffStorage(void)
{
    return S_OK;
} /* HandsOffStorage */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\gpbuild\wfumain.h ===
// WFUMAIN.H:  Definition of CITWWFilterUpdate

#ifndef __WFUMAIN_H__
#define __WFUMAIN_H__

#include <verinfo.h>
#include <itcc.h>
#include <itdb.h>

//#include <mvopsys.h>
//#include <groups.h>

class CITWWFilterUpdate : 
	public IITBuildCollect,
    public IPersistStorage,
	public CComObjectRoot,
	public CComCoClass<CITWWFilterUpdate, &CLSID_IITWWFilterBuild>
{
public:
	CITWWFilterUpdate () : m_fInitialized(FALSE), m_fConfigured(FALSE) {}
    ~CITWWFilterUpdate();

BEGIN_COM_MAP(CITWWFilterUpdate)
	COM_INTERFACE_ENTRY(IITBuildCollect)
	COM_INTERFACE_ENTRY(IPersistStorage)
END_COM_MAP()

DECLARE_REGISTRY (CLSID_IITWWFilterBuild,
    "ITIR.WWFilterBuild.4", "ITIR.WWFilterBuild",
    0, THREADFLAGS_APARTMENT )

public:
    STDMETHOD(SetConfigInfo)(IITDatabase *piitdb, VARARG vaParams);
	STDMETHOD(InitHelperInstance)(DWORD dwHelperObjInstance,
        IITDatabase *pITDatabase, DWORD dwCodePage,
        LCID lcid, VARARG vaDword, VARARG vaString);
	STDMETHOD(SetEntry)(LPCWSTR szDest, IITPropList *pPropList);
	STDMETHOD(Close)(void);
    STDMETHOD(GetTypeString)(LPWSTR pPrefix, DWORD *pLength);
    STDMETHOD(SetBuildStats)(ITBuildObjectControlInfo &itboci) 
        {return E_NOTIMPL;}

    STDMETHOD(GetClassID)(CLSID *pClsID);
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(IStorage *pStg);
    STDMETHOD(Save)(IStorage *pStgSave, BOOL fSameAsLoad);
    STDMETHOD(InitNew)(IStorage *pStg);
    STDMETHOD(SaveCompleted)(IStorage *pStgNew);
    STDMETHOD(HandsOffStorage)(void);

private:
    BOOL m_fInitialized, m_fIsDirty, m_fGroupNot, m_fConfigured;
    IITDatabase *m_piitdb;
    IStorage *m_pStorage;
    WCHAR m_wstrSrcGroup[1024];
    WCHAR m_wstrSrcWheel[1024];
}; /* class CITWWFilterUpdate */

#endif /* __WFUMAIN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\ftbuild\ftumain.cpp ===
/****************************************************************
 * @doc SHROOM EXTERNAL API
 *
 *  A Legsdin	added autodoc headers for IITBuildCollect Interface
 *
 ****************************************************************/
// ftuMain.CPP:  Implementation of CITIndexBuild

#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <windows.h>

#ifdef IA64
#include <itdfguid.h> 
#endif

#include <iterror.h>
#include <itpropl.h>
#include <ccfiles.h>
#include <atlinc.h>
#include <itwbrk.h>
#include <itwbrkid.h>
#include <mvsearch.h>
#include <_mvutil.h>
#include <msitstg.h>
#include <orkin.h>

#include "..\svWrdSnk.h"
#include "ftuMain.h"

#define ULMAXTOKENSIZE  1024
#define OCCF_DEFAULT    OCCF_TOPICID | OCCF_FIELDID | OCCF_COUNT

HRESULT __stdcall FillText(TEXT_SOURCE * pTextSource)
{
    return E_FAIL;//WBREAK_E_END_OF_TEXT;
}

CITIndexBuild::CITIndexBuild()
{
    m_fInitialized  = FALSE;
    m_fIsDirty      = FALSE;

    m_piWordSink    = NULL;
    m_piwb          = NULL;
    m_piwbConfig    = NULL;
    m_lpipb         = NULL;

    m_dwUID = m_dwVFLD = m_dwDType = m_dwWordCount = m_dwCodePage = 0;

    m_lpbfText = NULL;

    m_dwOccFlags = OCCF_DEFAULT;
}

CITIndexBuild::~CITIndexBuild()
{
    (void)Close();
}
/************************************************************************
 *  @method   STDMETHODIMP | IITBuildCollect | GetTypeString | 
 * Returns a prefix to use when the storage or stream object is created. 
 *	
 * @parm LPWSTR | pPrefix | Pointer to a buffer in which to copy the prefix
 * @parm DWORD | *pLen | Length of the buffer
 *
 * @rvalue S_OK | The operation completed successfully
 *
 *
 *  @comm If you are creating a new build object, you need to decide on a
 * unique prefix to identify that object. Word wheels use $WW, for example. 
 *
 ************************************************************************/

STDMETHODIMP CITIndexBuild::GetTypeString(LPWSTR pPrefix, DWORD *pLen)
{
    DWORD dwLen = (DWORD) WSTRLEN (SZ_GP_STORAGE) + 1;

    if (NULL == pPrefix)
    {
        *pLen = dwLen;
        return S_OK;
    }

    if (pLen && *pLen < dwLen)
    {
        *pLen = dwLen;
        return S_OK;
    }

    if (pLen)
        *pLen = dwLen;

    WSTRCPY (pPrefix, SZ_FI_STREAM);
    return S_OK;
} /* GetTypeString */


/****************************************************************
 * @method STDMETHODIMP | IITBuildCollect | SetConfigInfo | 
 * Passes initialization parameters to a build object. 
 *
 * @parm IITDatabase | *piitdb | Pointer to database
 * @parm VARARG | vaParams | Configuration parameters
 *
 * @rvalue S_OK | The operation completed successfully. 
 * @comm Call this method before calling InitHelperInstance. 
 * 
 ****************************************************************/
// This must be called before InitHelperInstance!
STDMETHODIMP CITIndexBuild::SetConfigInfo
    (IITDatabase *piitdb, VARARG vaParams)
{
    if(vaParams.dwArgc)
    {
        m_dwOccFlags = 0;

        // Work through params backwards
        // If we add more params we may need to scan forward
        for (int loop = vaParams.dwArgc; loop; --loop)
        {
            LPWSTR pwstr = (LPWSTR)vaParams.Argv[loop - 1];
            if(!WSTRICMP(pwstr, L"OCC_VFLD"))
                m_dwOccFlags |= OCCF_FIELDID;
            else if(!WSTRICMP(pwstr, L"OCC_UID"))
                m_dwOccFlags |= OCCF_TOPICID;
            else if(!WSTRICMP(pwstr, L"OCC_COUNT"))
                m_dwOccFlags |= OCCF_COUNT;
            else if(!WSTRICMP(pwstr, L"OCC_LENGTH"))
                m_dwOccFlags |= OCCF_LENGTH;
            else if(!WSTRICMP(pwstr, L"OCC_OFFSET"))
                m_dwOccFlags |= OCCF_OFFSET;
            else if(!WSTRICMP(pwstr, L"OCC_NONE"))
            {
                m_dwOccFlags = 0;
                break;
            }
        }
    }

    return S_OK;
} /* SetConfigInfo */


/********************************************************************
 * @method    HRESULT WINAPI | IITBuildCollect | InitHelperInstance |
 * Allows you to configure a helper object used by a 
 * build object (such as sort objects for a word wheel, or breaker
 * objects for a full-text index).
 *
 * @parm DWORD | dwHelperObjInstance | Helper object instance ID.
 * @parm IITDatabase | *pITDatabase | Pointer to database.
 * @parm DWORD | dwCodePage | Code page identifier.
 * @parm LCID | lcid | Locale identifier.
 * @parm VARARG | vaDword | Flags you want to use to configure the object.
 * @parm VARARG | vaString | String parameters you want to use to 
 * configure the object.
 *
 * @rvalue E_FAIL | The object is already initialized or file create failed
 *
 ********************************************************************/
STDMETHODIMP CITIndexBuild::InitHelperInstance(
    DWORD dwHelperObjInstance,
    IITDatabase *pITDatabase, DWORD dwCodePage,
    LCID lcid, VARARG vaDword, VARARG vaString
    )
{
    if (TRUE == m_fInitialized)
        return SetErrReturn(E_ALREADYINIT);

    HRESULT hr = S_OK;
    BOOL fLicense;
    IPersistStreamInit *piipstm;

    m_dwCodePage = dwCodePage;

    // Open nested indexer
    INDEXINFO IndexInfo;
    IndexInfo.dwMemSize   = 0x100000;       
    IndexInfo.Occf        = m_dwOccFlags;
    IndexInfo.Idxf        = 0;
    IndexInfo.dwBlockSize = 0;  // Use default
    IndexInfo.dwBreakerInstID = dwHelperObjInstance;
    IndexInfo.dwCodePageID = dwCodePage;
    IndexInfo.lcid = lcid;
    if (NULL == (m_lpipb = MVIndexInitiate(&IndexInfo, &hr)))
        SetErrCode(&hr, E_FAIL);

    // Set up the helper (breaker)
    if (SUCCEEDED(hr))
    {
        // Get the Breaker
        hr = pITDatabase->GetObject
            (dwHelperObjInstance, IID_IWordBreaker, (void **)&m_piwb);
    }

    // Config the breaker if it is supported
    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = m_piwb->Init(FALSE, ULMAXTOKENSIZE, &fLicense)))
    {
        if (SUCCEEDED(pITDatabase->GetObject (dwHelperObjInstance,
            IID_IWordBreakerConfig, (void **)&m_piwbConfig)))
        {
            // We don't really care if these fail
            hr = m_piwbConfig->SetLocaleInfo(dwCodePage, lcid);
            hr = m_piwbConfig->SetBreakWordType(IITWBC_BREAKTYPE_TEXT);
            if (vaDword.dwArgc >= 1)
            {
                hr = m_piwbConfig->SetControlInfo(*(LPDWORD)vaDword.Argv, 0);
            }

            IFSStorage *pifsstg = NULL;
            IStream *piistm;
            if (vaString.dwArgc)
            {   // Create ITSS stuff
	            hr = CoCreateInstance(CLSID_IFSStorage, NULL,
                    CLSCTX_INPROC_SERVER, IID_IFSStorage, (VOID **)&pifsstg);
                ITASSERT(SUCCEEDED(hr));
            }

            if(vaString.dwArgc >= 1 && *(LPWSTR)vaString.Argv[0])
            {
                if(SUCCEEDED(pifsstg->FSOpenStream((LPWSTR)vaString.Argv[0],
                    STGM_SHARE_DENY_WRITE | STGM_READWRITE, &piistm)))
                {
                    hr = m_piwbConfig->LoadExternalBreakerData
                        (piistm, IITWBC_EXTDATA_CHARTABLE);
                    piistm->Release();
                }
            }
            if (vaString.dwArgc >= 2 && *(LPWSTR)vaString.Argv[1])
            {
                if (SUCCEEDED(pifsstg->FSOpenStream((LPWSTR)vaString.Argv[1],
                    STGM_SHARE_DENY_WRITE | STGM_READWRITE, &piistm)))
                {
                    hr = m_piwbConfig->LoadExternalBreakerData
                        (piistm, IITWBC_EXTDATA_STOPWORDLIST);
                    piistm->Release();
                }

            }
            if (vaString.dwArgc >= 3 && *(LPWSTR)vaString.Argv[2])
            {
                // Get the CLSID and instantiate the stemmer
                CLSID clsid;
                IStemmer *pStemmer;
                hr = CLSIDFromProgID((LPWSTR)vaString.Argv[2], &clsid);
                if(SUCCEEDED(hr))
                    hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
                    IID_IStemmer, (VOID **)&pStemmer);
                if (SUCCEEDED(hr))
                {
                    if(SUCCEEDED(hr = pStemmer->QueryInterface
                        (IID_IPersistStreamInit, (void **)&piipstm)))
                    {
                        piipstm->InitNew();
                        piipstm->Release();
                    }
                    (void)pStemmer->Init(ULMAXTOKENSIZE, &fLicense);

                    // Check for IStemmerConfig interface
                    IStemmerConfig *pistemConfig;
                    hr = pStemmer->QueryInterface
                        (IID_IStemmerConfig, (void **)&pistemConfig);
                    if (SUCCEEDED(hr))
                    {
                        hr = pistemConfig->SetLocaleInfo(dwCodePage, lcid);
                        pistemConfig->Release();
                    }
                    
                    hr = m_piwbConfig->SetWordStemmer(clsid, pStemmer);
                    pStemmer->Release();
                }
            }

            if (pifsstg)
                pifsstg->Release();

            hr = S_OK;
        }
    }

    if(SUCCEEDED(hr) &&
        SUCCEEDED(hr = CoCreateInstance(CLSID_IITWordSink, NULL,
        CLSCTX_INPROC_SERVER, IID_IWordSink, (LPVOID *)&m_piWordSink)) &&
        SUCCEEDED(hr =
            ((CDefWordSink *)m_piWordSink)->SetLocaleInfo(dwCodePage, lcid))
        && SUCCEEDED(hr = ((CDefWordSink *)m_piWordSink)->SetIPB(m_lpipb)))
    {
        m_fInitialized = TRUE;
    }

    return hr;
} /* InitHelperInstance */


/****************************************************************
 * @method STDMETHODIMP | IITBuildCollect | SetEntry | 
 * Sets properties for a build object. 
 * 
 *
 * @parm LPCWSTR | szDest | Property destination
 * @parm IITPropList | *pPropList | Pointer to property list
 *
 * @comm Like CSvDoc::AddObjectEntry, this method is called 
 * several times for all the properties that you need to set. 
 ****************************************************************/
STDMETHODIMP CITIndexBuild::SetEntry(LPCWSTR szDest, IITPropList *pPropList)
{
	
	if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);
    m_fIsDirty = TRUE;

    CProperty cProp;
    HRESULT hr;
    LPWSTR pwstrIndexText;
    BOOL fTerm = FALSE;

    if(SUCCEEDED(hr = pPropList->Get(STDPROP_INDEX_BREAK, cProp)))
    {
        SendTextToBreaker();
        return S_OK;
    }

    // Check for REQUIRED text (can be either INDEX_TEXT or INDEX_TERM)
    if(FAILED(hr = pPropList->Get(STDPROP_INDEX_TEXT, cProp)))
    {
        if(SUCCEEDED(hr = pPropList->Get(STDPROP_INDEX_TERM, cProp)))
            fTerm = TRUE;
    }

    if(SUCCEEDED(hr))
        pwstrIndexText = (LPWSTR)cProp.lpszwData;

    // Check for REQUIRED UID
    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pPropList->Get(STDPROP_UID, cProp)) &&
        m_dwUID != cProp.dwValue)
    {
        SendTextToBreaker();
        m_dwUID = cProp.dwValue;
        m_dwWordCount = 0;
    }

    // Check for OPTIONAL VFLD
    if (SUCCEEDED(hr) &&
        SUCCEEDED(pPropList->Get(STDPROP_INDEX_VFLD, cProp)) &&
        m_dwVFLD != cProp.dwValue)
    {
        SendTextToBreaker();
        m_dwVFLD = cProp.dwValue;
    }

    // Check for OPTIONAL DTYPE
    if (SUCCEEDED(hr) && m_piwbConfig &&
        SUCCEEDED(pPropList->Get(STDPROP_INDEX_DTYPE, cProp))
        && m_dwDType != cProp.dwValue)
    {
        SendTextToBreaker();
        hr = m_piwbConfig->SetBreakWordType(cProp.dwValue);
    }

    DWORD cchText;
    if (SUCCEEDED(pPropList->Get(STDPROP_INDEX_LENGTH, cProp)))
        cchText = (WORD)cProp.dwValue;
    else 
        cchText = (DWORD) WSTRLEN(pwstrIndexText);

    if (SUCCEEDED(hr))
    {
        if (fTerm)
        {
            // Get actual index term length

            // Fill-ou occurrence info
	        OCC occ;
	        occ.dwFieldId = m_dwVFLD;
	        occ.dwTopicID = m_dwUID;
	        occ.dwCount   = m_dwWordCount++;
            // Is there a diffrerent highlite length?
            if (SUCCEEDED(pPropList->Get(STDPROP_INDEX_TERM_RAW_LENGTH, cProp)))
                occ.wWordLen = (WORD)cProp.dwValue;
            else 
                occ.wWordLen = (WORD)cchText;    

            if (cchText > 255)
                return SetErrReturn(E_UNEXPECTED);

            char strTerm[256 + sizeof(WORD)];
            if(!WideCharToMultiByte(m_dwCodePage, 0, pwstrIndexText, cchText,
                strTerm + sizeof(WORD), 255, NULL, NULL))
            {
                // The conversion failed! -- very bad
                return SetErrReturn(E_UNEXPECTED);
            }
            *(LPWORD)strTerm = (SHORT)cchText;
            hr = MVIndexAddWord(m_lpipb, (LPB)strTerm, &occ);
        }
        else 
        {
            // Accumulate text until we need to send it along
            if (!DynBufferAppend (m_lpbfText,
                (LPBYTE)pwstrIndexText, cchText * sizeof (WCHAR)))
                SetErr(&hr, E_OUTOFMEMORY);
        }
    }

    return hr;
} /* SetEntry */


STDMETHODIMP CITIndexBuild::SendTextToBreaker(void)
{
    HRESULT hr;

    // TODO: Call these only for our own word sink
    hr = ((CDefWordSink *)m_piWordSink)->SetDocID(m_dwUID);
    hr = ((CDefWordSink *)m_piWordSink)->SetVFLD(m_dwVFLD);

    // TODO: We can set TYPE here, so we can use the same breaker instance for
    // multiple FTI and they will not interfere with each other.  This would be
    // different than current behavior, however, so I have left it out for now.

    TEXT_SOURCE tsText;
    tsText.pfnFillTextBuffer = FillText;
    tsText.awcBuffer         = (LPWSTR)DynBufferPtr(m_lpbfText);
    tsText.iEnd              = DynBufferLen(m_lpbfText) / sizeof (WCHAR);
    tsText.iCur              = 0;

    hr = m_piwb->BreakText(&tsText, m_piWordSink, NULL);

    DynBufferReset(m_lpbfText);
    return hr;
} /* SendTextToBreaker */

/*****************************************************************
 * @method STDMETHODIMP | IITBuildCollect | Close | 
 * Closes the build object and frees memory.
 *
 * @Rvalue E_NOTINIT | Object has not been initialized. 
 * @comm Calling this method is optional, but the build object must 
 * implement it. Any object that implements IITBuildCollect interface
 * must support the Close method. 
 *
 ****************************************************************/
STDMETHODIMP CITIndexBuild::Close(void)
{
    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    if(m_piwb)
        m_piwb->Release();
    if(m_piWordSink)
        m_piWordSink->Release();
    if(m_piwbConfig)
        m_piwbConfig->Release();
    if(m_piwbConfig)
        m_piwbConfig = NULL;

    if (m_lpipb)
        MVIndexDispose(m_lpipb);

    m_fInitialized = FALSE;
    m_fIsDirty     = FALSE;

    m_piWordSink = NULL;
    m_piwb       = NULL;
    m_piwbConfig = NULL;
    m_lpipb      = NULL;

    m_dwUID = m_dwVFLD = m_dwDType = m_dwWordCount = m_dwCodePage = 0;

    if (m_lpbfText)
    {
        DynBufferFree (m_lpbfText);
        m_lpbfText = NULL;
    }

    // Reset the occurrence flags to the default
    m_dwOccFlags = OCCF_DEFAULT;

    return S_OK;
} /* Close */

STDMETHODIMP CITIndexBuild::InitNew(void)
{
    if(NULL == (m_lpbfText = DynBufferAlloc (0x4000)))
        return SetErrReturn(E_OUTOFMEMORY);

    return S_OK;
} /* IPersistStreamInit::InitNew */


STDMETHODIMP CITIndexBuild::GetClassID(CLSID *pClsID)
{
    if (NULL == pClsID
        || IsBadWritePtr(pClsID, sizeof(CLSID)))
        return SetErrReturn(E_INVALIDARG);

    *pClsID = CLSID_IITIndexBuild;
    return S_OK;
} /* GetClassID */


inline STDMETHODIMP CITIndexBuild::IsDirty(void)
{
    return m_fIsDirty ? S_OK : S_FALSE;
} /* IsDirty */


STDMETHODIMP CITIndexBuild::Load(IStream *piistm)
{
    return SetErrReturn(E_NOTIMPL);
} /* IPersistStreamInit::Load */


STDMETHODIMP CITIndexBuild::Save(IStream *piistm, BOOL fClearDirty)
{
    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    SendTextToBreaker();

    HRESULT hr;
    HFPB hfpbSave = FpbFromHf(piistm, &hr);

	if (SUCCEEDED(hr))
	{
		hr = MVIndexBuild (0, m_lpipb, hfpbSave, NULL);
		MVIndexDispose (m_lpipb);
		m_lpipb = NULL;

		if (fClearDirty)
			m_fIsDirty = FALSE;

		FreeHfpb(hfpbSave);
	}

    return hr;
} /* IPersistStreamInit::Save */


STDMETHODIMP CITIndexBuild::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    return SetErrReturn(E_NOTIMPL);
} /* GetSizeMax */


// ********************* IPersisFile Methods *********************
STDMETHODIMP CITIndexBuild::Load(LPCWSTR pszFileName, DWORD dwMode)
{
    return SetErrReturn(E_NOTIMPL);
} /* IPersistFile::Load */


STDMETHODIMP CITIndexBuild::Save(LPCWSTR pszFileName, BOOL fRemember)
{
    return SetErrReturn(E_NOTIMPL);
} /* IPersistFile::Save */


STDMETHODIMP CITIndexBuild::SaveCompleted(LPCWSTR pszFileName)
{
    return SetErrReturn(E_NOTIMPL);
} /* IPersistFile::SaveCompleted */


STDMETHODIMP CITIndexBuild::GetCurFile(LPWSTR *ppszFileName)
{
    return SetErrReturn(E_NOTIMPL);
} /* IPersistFile::GetCurFile */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\gpbuild\wfumain.cpp ===
// wfumain.CPP:  Implementation of wordwheel update interface
#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <windows.h>
#include <iterror.h>
#include <itpropl.h>
#include <ccfiles.h>
#include <atlinc.h>
#include <itdb.h>
#include <itgroup.h>
#include <itww.h>
#include <itrs.h>
#include <groups.h>

//#include "..\svutil.h"
#include "wfumain.h"

CITWWFilterUpdate::~CITWWFilterUpdate()
{
    (void)Close();
}

STDMETHODIMP CITWWFilterUpdate::GetTypeString(LPWSTR pPrefix, DWORD *pLen)
{
    DWORD dwLen = (DWORD) WSTRLEN (SZ_GP_STORAGE) + 1;

    if (NULL == pPrefix)
    {
        *pLen = dwLen;
        return S_OK;
    }

    if (pLen && *pLen < dwLen)
    {
        *pLen = dwLen;
        return S_OK;
    }

    if (pLen)
        *pLen = dwLen;

    WSTRCPY (pPrefix, SZ_GP_STORAGE);
    return S_OK;
} /* GetTypeString */


STDMETHODIMP CITWWFilterUpdate::SetConfigInfo
    (IITDatabase *piitdb, VARARG vaParams)
{
    if(m_fConfigured == TRUE)
        return SetErrReturn(E_ALREADYINIT);

    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    if(vaParams.dwArgc < 2 || NULL == piitdb)
        return SetErrReturn(E_INVALIDARG);

    (m_piitdb = piitdb)->AddRef();

    WSTRCPY(m_wstrSrcWheel, (LPWSTR)vaParams.Argv[0]);
    WSTRCPY(m_wstrSrcGroup, (LPWSTR)vaParams.Argv[1]);
    
    if(vaParams.dwArgc == 3)
        m_fGroupNot = !WSTRICMP(L"GROUP_NOT", (LPWSTR)vaParams.Argv[2]);
    else
        m_fGroupNot = FALSE;

    m_fConfigured = TRUE;

    return S_OK;
} /* SetConfigInfo */


/********************************************************************
 * @method    HRESULT WINAPI | CITWWFilterUpdate | InitiateUpdate |
 * Creates and initiates a structure to allow for the creation of word wheels.
 * This method must be called before any others in this object.
 *
 * @rvalue E_FAIL | The object is already initialized or file create failed
 *
 * @xref <om.CancelUpdate>
 * @xref <om.CompleteUpdate>
 * @xref <om.SetEntry>
 *
 * @comm
 ********************************************************************/
STDMETHODIMP CITWWFilterUpdate::InitHelperInstance(
    DWORD dwHelperObjInstance,
    IITDatabase *pITDatabase, DWORD dwCodePage,
    LCID lcid, VARARG vaDword, VARARG vaString
    )
{
    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    return S_OK;
} /* InitHelperInstance */


STDMETHODIMP CITWWFilterUpdate::SetEntry(LPCWSTR szDest, IITPropList *pPropList)
{
    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    return S_OK;
} /* SetEntry */

STDMETHODIMP CITWWFilterUpdate::Close(void)
{
    if(!m_fInitialized)
        return S_OK;

    if(TRUE == m_fConfigured)
        m_piitdb->Release();
    m_fConfigured = FALSE;

    m_fInitialized = FALSE;

    return S_OK;
} /* Close */

STDMETHODIMP CITWWFilterUpdate::InitNew(IStorage *pStg)
{
    m_fIsDirty = FALSE;
    m_fInitialized = TRUE;
    m_fConfigured = FALSE;

	return S_OK;
} /* InitNew */


STDMETHODIMP CITWWFilterUpdate::Save(IStorage *pStgSave, BOOL fSameAsLoad)
{
    HRESULT hr;
    LONG lMaxItems;
    IITGroup *pSrcGroup = NULL, *pGroup = NULL;
    IITWordWheel *pSrcWheel = NULL;
    IITResultSet *pResultSet= NULL;
    _LPGROUP lpGroup;

    if (FALSE == m_fInitialized || FALSE == m_fConfigured)
        return SetErrReturn(E_NOTINIT);

    // Open Source Group
    if (FAILED (hr = CoCreateInstance (CLSID_IITGroupLocal, NULL,
        CLSCTX_INPROC_SERVER, IID_IITGroup, (void**)&pSrcGroup)))
        goto cleanup;
    if (FAILED (hr = pSrcGroup->Open(m_piitdb, m_wstrSrcGroup)))
        goto cleanup;

    // Open Source Wheel
    if (FAILED (hr = CoCreateInstance (CLSID_IITWordWheelLocal, NULL,
        CLSCTX_INPROC_SERVER, IID_IITWordWheel, (void**)&pSrcWheel)))
        goto cleanup;
    if (FAILED (hr = pSrcWheel->Open (m_piitdb, m_wstrSrcWheel, 0)))
        goto cleanup;
    pSrcWheel->Count(&lMaxItems);
    if (!lMaxItems)
    {
        SetErrCode(&hr, E_FAIL);
        goto cleanup;
    }

    // Create destination group
    if (FAILED (hr = CoCreateInstance (CLSID_IITGroupLocal, NULL,
        CLSCTX_INPROC_SERVER, IID_IITGroup, (void**)&pGroup)))
        goto cleanup;
    pGroup->Initiate ((DWORD)lMaxItems);
    lpGroup = (_LPGROUP)pGroup->GetLocalImageOfGroup();

    // Create Result Set
    if (FAILED (hr = CoCreateInstance (CLSID_IITResultSet, NULL,
        CLSCTX_INPROC_SERVER, IID_IITResultSet, (void**)&pResultSet)))
        goto cleanup;
    if (FAILED (hr = pResultSet->Add (STDPROP_UID, (DWORD)0, PRIORITY_NORMAL)))
        goto cleanup;

    // This is the real work.
    // The result group will have a bit set for every entry in the word wheel
    // that has a UID that is set in the source group
    do
    {
        DWORD dwOcc;

        --lMaxItems;

        // Get all occurence info for this entry
        pSrcWheel->GetDataCount(lMaxItems, &dwOcc);
        pResultSet->ClearRows();
        //pResultSet->SetMaxRows (dwOcc);
        pSrcWheel->GetData(lMaxItems, pResultSet);

        for (LONG loop = 0; loop < (LONG)dwOcc; ++loop)
        {
            CProperty prop;

            // Get UID
            if (FAILED (hr = pResultSet->Get(loop, 0, prop)))
                goto cleanup;

            // Lookup UID is source group
            // IsBitSet returns S_OK if bit is set or S_FALSE if not
            if (S_OK == pSrcGroup->IsBitSet (prop.dwValue))
            {
                GroupAddItem (lpGroup, lMaxItems);
                break;
            }
        }
    } while (lMaxItems);

    if (TRUE == m_fGroupNot)
        pGroup->Not();

    HFPB hfpb;
    if (NULL == (hfpb = (HFPB)FpbFromHfs (pStgSave, &hr)))
        goto cleanup;
    hr = GroupFileBuild (hfpb, SZ_GROUP_MAIN_A, lpGroup);
    pStgSave->Commit(STGC_DEFAULT);
    FreeHfpb(hfpb);

cleanup:

    if (pResultSet)
    {
        pResultSet->Free();
        pResultSet->Release();
    }

    if (pSrcGroup)
    {
        pSrcGroup->Free();
        pSrcGroup->Release();
    }

    if (pSrcWheel)
    {
        pSrcWheel->Close();
        pSrcWheel->Release();
    }

    if (pGroup)
    {
        pGroup->Free();
        pGroup->Release();
    }
    return hr;
} /* Save */


STDMETHODIMP CITWWFilterUpdate::GetClassID(CLSID *pClsID)
{
    if (NULL == pClsID
        || IsBadWritePtr(pClsID, sizeof(CLSID)))
        return SetErrReturn(E_INVALIDARG);

    *pClsID = CLSID_IITWWFilterBuild;
    return S_OK;
} /* GetClassID */


inline STDMETHODIMP CITWWFilterUpdate::IsDirty(void)
{
    return m_fIsDirty ? S_OK : S_FALSE;
} /* IsDirty */


inline STDMETHODIMP CITWWFilterUpdate::Load(IStorage *pStg)
{
    return SetErrReturn(E_NOTIMPL);
} /* Load */


STDMETHODIMP CITWWFilterUpdate::SaveCompleted(IStorage *pStgNew)
{
    if (pStgNew)
    {
        if (!m_pStorage)
            return SetErrReturn(E_UNEXPECTED);
        m_pStorage->Release();
        (m_pStorage = pStgNew)->AddRef();
    }
    m_fIsDirty = FALSE;
    return S_OK;
} /* SaveCompleted */


inline STDMETHODIMP CITWWFilterUpdate::HandsOffStorage(void)
{
    return S_OK;
} /* HandsOffStorage */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\local\catalog.cpp ===
/*************************************************************************
*  @doc SHROOM EXTERNAL API                                              *
*																		 *
*  CATALOG.CPP                                                           *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1997                              *
*  All Rights reserved.                                                  *
*                                                                        *
*  This file contains the implementation of the catalog object           *
*  												                         *
*																	     *
**************************************************************************
*                                                                        *
*  Written By   : Erin Foxford                                           *
*  Current Owner: erinfox                                                *
*                                                                        *
**************************************************************************/
// I'd like to get rid of this, but for now we include it so this compiles
#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif


#include <atlinc.h>   // includes for ATL. 

// MediaView (InfoTech) includes
#include <mvopsys.h>
#include <_mvutil.h>
#include <wwheel.h>  

#include <itcc.h>      // needed for STDPROP_UID def.
#include <ITDB.h>
#include <ITPropl.h>
#include <itrs.h>
#include <itww.h>
#include <itgroup.h>
#include <itquery.h>
#include <ccfiles.h>

#include <itcat.h>
#include "catalog.h"

/********************************************************************
 * @method    STDMETHODIMP | IITCatalog | Open |
 *     Opens catalog
 * 
 * @parm IITDatabase* | lpITDB | Pointer to database object
 * @parm LPCWSTR | lpszwName | Name of catalog to open. If NULL, the
 * default catalog will be open. NULL is the default parameter value.
 *
 * @rvalue E_ALREADYOPEN | Catalog is already open 
 * @rvalue STG_E_* | Any of the IStorage errors that could occur 
 *                   while opening a storage
 * @rvalue S_OK | The catalog was successfully opened
 *
 ********************************************************************/
STDMETHODIMP CITCatalogLocal::Open(IITDatabase* lpITDB, LPCWSTR lpszwName)
{
	HRESULT hr;
	DWORD cbSize = 0;
	DWORD cbRead;

    // Open catalog substorage
	if (FAILED(hr = lpITDB->GetObjectPersistence(
						(lpszwName == NULL ? SZ_CATALOG_STORAGE : lpszwName),
						IITDB_OBJINST_NULL, (LPVOID *) &m_pCatalog, FALSE)))
	{
		return (hr);
	}

	// Open catalog B-tree
	if (NULL == (m_hbt = HbtOpenBtreeSz(SZ_BTREE_BTREE, m_pCatalog, 
		                                fFSOpenReadOnly, &hr)))
	{
exit0:
		m_pCatalog->Release();
		m_pCatalog = NULL;
		return hr;
	}

	// Open catalog property header and read it into a buffer
	IStream* pHdr;
	hr = m_pCatalog->OpenStream(SZ_BTREE_HEADER, NULL, STGM_READ, 0, &pHdr);
	if (FAILED(hr))
	{
exit1:
		RcCloseBtreeHbt(m_hbt);
		goto exit0;
	}

	// Read header size
	hr = pHdr->Read(&cbSize, sizeof(DWORD), &cbRead);
	if (FAILED(hr))
	{
exit2:
		pHdr->Release();
		goto exit1;
	}

	// ALLOCATE memory
	if (NULL == (m_pHdr = new BYTE[cbSize]))
	{
		hr = E_OUTOFMEMORY;
		goto exit2;
	}

	// Read in the bytes
	hr = pHdr->Read(m_pHdr, cbSize, &cbRead);
	if (FAILED(hr))
	{
exit3:
		delete m_pHdr;
		goto exit2;
	}
	
	// Open catalog data file 
	hr = m_pCatalog->OpenStream(SZ_BTREE_DATA, NULL, STGM_READ, 0, &m_pDataStr);
	if (FAILED(hr))
		goto exit3;

	// release header stream
	pHdr->Release();

	// Initiate a block of memory 
    if (NULL == (m_pScratchBuffer = BlockInitiate((DWORD)65500, 0, 0, 0)))
		return E_OUTOFMEMORY;


	return hr;
}


/********************************************************************
 * @method    STDMETHODIMP | IITCatalog | Close |
 *      Closes catalog
 *
 ********************************************************************/
STDMETHODIMP CITCatalogLocal::Close()
{
	// close b-tree
	if (m_hbt)
	{
		RcCloseBtreeHbt(m_hbt);
		m_hbt = NULL;
	}

	// free memory
	if (m_pHdr)
	{
		delete m_pHdr;
		m_pHdr = NULL;
	}

	// close data stream
	if (m_pDataStr)
	{
		m_pDataStr->Release();
		m_pDataStr = NULL;
	}

	// close catalog substorage
	if (m_pCatalog)
	{
		m_pCatalog->Release();
		m_pCatalog = NULL;
	}

    // free scratch memory
    if (m_pScratchBuffer)
    {
        BlockFree(m_pScratchBuffer);
        m_pScratchBuffer = NULL;
    }
    return S_OK;
}



/********************************************************************
 * @method    STDMETHODIMP | IITCatalog | Lookup |
 *      Takes an input result set, which contains a set of UIDs, and
 * fills in properties found in the catalog, either in the same result
 * set object or in another.
 * 
 * @parm IITResultSet* | pRSIn | Result set containing UIDs
 * @parm IITResultSet* | pRSOut | Result set to fill with properties
 * stored in catalog. If you pass NULL, which is the default value, the properties
 * will be returned in pRSIn.
 *
 * @rvalue E_INVALIDARG | pRSIn is NULL
 * @rvalue E_OUTOFMEMORY | Internal memory allocation failed
 * @rvalue E_FAIL | The input result set has no rows
 * @rvalue S_FALSE | The catalog does not contain any properties specified in
 * the result set, but no failure occurred
 * @rvalue S_OK | The properties were successfully filled in the result set
 *
 ********************************************************************/
STDMETHODIMP CITCatalogLocal::Lookup(IITResultSet* pRSIn, IITResultSet* pRSOut)
{
	HRESULT hr;
	DWORD dwOffset;
	LONG lColumnIndex;
	LONG lNumberOfRows;
	CProperty Prop;
	LONG iRow;   // Loop index
	LPBYTE pPropBuffer;
	DWORD cbSize;
	DWORD cbRead;

	LARGE_INTEGER dlibMove;   // For seeking
	ULARGE_INTEGER libNewPos;

	if (NULL == pRSIn)
		return E_INVALIDARG;

	// Get column corresponding to UID property. 
	// If it doesn't exist, return
	hr = pRSIn->GetColumnFromPropID(STDPROP_UID, lColumnIndex);
	if (FAILED(hr))
		return hr;

	// There has to be at least one row
	pRSIn->GetRowCount(lNumberOfRows);
	if (0 == lNumberOfRows)
		return E_FAIL;


	// Loop over all rows in result set 
	for (iRow = 0; iRow < lNumberOfRows; iRow++)
	{
		hr = pRSIn->Get(iRow, lColumnIndex, Prop);

		// look up UID in btree and get the offset
		hr = RcLookupByKey(m_hbt, (KEY)&Prop.dwValue, NULL, &dwOffset);
		if (FAILED(hr))
		{
			// not finding the UID in the catalog is OK, we 
			// just don't fill in anything.
			if (hr == E_NOTEXIST)
			{
				hr = S_FALSE;
				continue;
			}
			break;
		}

		// seek to offset in data file
		dlibMove.QuadPart = dwOffset;
		hr = m_pDataStr->Seek(dlibMove, STREAM_SEEK_SET, &libNewPos);
		if (FAILED(hr))
			break;

		// read data into buffer
		hr = m_pDataStr->Read(&cbSize, sizeof(DWORD), &cbRead);
		if (FAILED(hr) || 0 == cbSize)
			break;

        // REVIEW TODO BUGUG - johnrush
        // Remove this stuff.  The Block Manager is not appropriate for
        // this purpose.  We should replace this with some combination
        // of stack buffer and dynamic memory.
		BlockReset(m_pScratchBuffer);
		if (NULL == (pPropBuffer = (LPBYTE) BlockCopy(m_pScratchBuffer, NULL, cbSize, 0)))
			return E_OUTOFMEMORY;
	
		hr = m_pDataStr->Read(pPropBuffer, cbSize, &cbRead);
		if (FAILED(hr))
			break;

		// fill result set
		if (pRSOut)
			hr = pRSOut->Append(m_pHdr, pPropBuffer);
		else
			hr = pRSIn->Set(iRow, m_pHdr, pPropBuffer);

		// Optimization: if ResultSet methods return S_FALSE, that
		// means no columns correspond to properties in header. 
		// Don't even bother trying to set other rows.
		if (S_FALSE == hr)
			break;

	}	
	
	return hr;
}




/********************************************************************
 * @method    STDMETHODIMP | IITCatalog | GetColumns |
 *     Adds columns to given result set for all catalog properties
 * 
 * @parm IITResultSet* | pRSIn | Result set 
 * @rvalue S_OK | The properties were successfully filled in the result set.
 *
 * @comm This method does not add a column for the "key" column.  In the 
 * case of the Catalog, the "key" column is the STDPROP_UID property.  
 * If you intend to use this API in conjunction with the <om .lookup> 
 * API, you must manually add the STDPROP_UID property as an additional column 
 * to the result set after calling GetColumns, and before calling Lookup.
 *
 ********************************************************************/
STDMETHODIMP CITCatalogLocal::GetColumns(IITResultSet* pRS)
{
	return pRS->Add(m_pHdr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\local\atllocal.cpp ===
// ATLLOCAL.CPP: Source file that includes just the standard includes
#ifndef DBG
// We check against DBG instead of _DEBUG since _DEBUG is defined in mvopsys.
// DBG is defined by the ie build environment so watch out for this when
// changing build environments.
//#define _ATL_MIN_CRT
#define _WINDLL
#endif


#include <atlinc.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#ifdef IA64
#include <itdfguid.h> 
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\wwheel.cpp ===
#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <comdef.h>
#include <wwheel.h>
#include <groups.h>

#include <iterror.h>
#include <ccfiles.h>

#include <itww.h>
#include <itdb.h>
#include <itsort.h>
#include <itsortid.h>

BOOL static IsInFilter(_LPGROUP qFilter, LONG lOffset);

/*****************************************************************************
*
*   WordWheelOpen 
*
* @doc EXTERNAL
*
* @api HWHEEL | WordWheelOpen | This function opens a word wheel.
*
*
* @parm LPCSTR | lpszName | Specifies the name of the word wheel. This name
* should match the name used on the left side of the word-wheel entries
* specified in the [WWHEEL] section of the project file.
*
* @parm PHRESULT | phr | Error return value if failed.
*
* @rdesc Returns a handle to the specified word wheel, or NULL if the
* function fails.
*
*
* Keyword indexes are stored as word wheels in the file system. Word wheels
* for keyword indexes are named using the convention "\|c", where "c" is
* the identification character specified in the "key=" entry in the
* KEYINDEX section of the project file. For example, the default keyword
* index is named "\|0".
*
* @xref WordWheelClose 
*
*/

HWHEEL FAR PASCAL EXPORT_API WordWheelOpen(IITDatabase* lpITDB,
										IStorage* pWWStorage, PHRESULT phr)
{
    HWHEEL  hWheel  = NULL;         // handle to the new structure
	PWHEEL  pWheel  = NULL;         // pointer to locked-down structure
	BOOL    fSuccess= FALSE;
	char    szBtreeFormat[wMaxFormat + 1];
	PWHEELINFO pInfo    = NULL;
	WORD    t;
	WORD wCount = 1;
	DWORD cbSize;
	DWORD cbRead;
	LARGE_INTEGER dlibMove;
	ULARGE_INTEGER libNewPos;
	HF pHdr = NULL;
	BTREE_PARAMS btp;

    BOOL fReadOnly = TRUE;

	ERRB errb;

    *phr = S_OK;   // Assume success


	// allocate the structure.  must be 0 initialized
	if ((hWheel = _GLOBALALLOC(GMEM_MOVEABLE|GMEM_ZEROINIT, sizeof(WHEEL)+sizeof(WHEELINFO)*(wCount-1)))==NULL)
	{
		*phr = E_OUTOFMEMORY;
		return NULL;
	}
	pWheel = (PWHEEL)_GLOBALLOCK(hWheel);
	

	pWheel->magic = WHEEL_MAGIC;
    pWheel->pIITGroup = NULL;

	for (t = 0; t < wCount; t++)
	{
		pInfo = pWheel->pInfo + pWheel->wNumWheels;

		// just make sure these are NULL
		pInfo->pKeyHdr = NULL;
		pInfo->pOccHdr = NULL;

		pWheel->wNumWheels++;
		pInfo->magic = WHEEL_INFO_MAGIC;
		
		// open the subfiles
		if ((pInfo->hmapbt=HmapbtOpenHfs(pWWStorage, SZ_WORDWHEEL_MAP, &errb))==NULL)
        {
            SetErrCode(phr, errb);
            goto ignore_wheel;
        }

		if ((pInfo->hbt=HbtOpenBtreeSz(SZ_BTREE_BTREE, pWWStorage, fFSOpenReadOnly, &errb))==NULL)
        {
            SetErrCode(phr, errb);
            goto ignore_wheel;
        }

		GetBtreeParams(pInfo->hbt, &btp);
		if (btp.rgchFormat[0] == KT_EXTSORT)
		{
			IITSortKey *pITSortKey;

			ITASSERT(btp.dwExtSortInstID != IITDB_OBJINST_NULL);
			if (FAILED(*phr = lpITDB->GetObject(btp.dwExtSortInstID, IID_IITSortKey,
												(LPVOID *) &pITSortKey)))
			{
				goto ignore_wheel;
			}

			BtreeSetExtSort(pInfo->hbt, pITSortKey);

			// We release pITSortKey because BtreeSetExtSort
			// should've AddRef'ed it.
			pITSortKey->Release();
		}
		
		// Open header and save out key/occurrence
		if ((pHdr = HfOpenHfs(pWWStorage, SZ_BTREE_HEADER, fFSOpenReadOnly, phr))==hfNil)
			goto ignore_wheel;
		
		// read global size and seek ahead to key header 
		*phr = pHdr->Read(&cbSize, sizeof(DWORD), &cbRead);
		if (FAILED(*phr)) goto cleanup;

		dlibMove.QuadPart = cbSize;
		*phr = pHdr->Seek(dlibMove, STREAM_SEEK_CUR, &libNewPos);
		if (FAILED(*phr)) goto cleanup;


		// read key header size and read in key header info
		*phr = pHdr->Read(&cbSize, sizeof(DWORD), &cbRead);
		if (FAILED(*phr)) goto cleanup;
		
		// ALLOCATE memory
		if (cbSize)
		{
			if (NULL == (pInfo->pKeyHdr = new BYTE[cbSize]))
				goto cleanup;

			*phr = pHdr->Read(pInfo->pKeyHdr, cbSize, &cbRead);
			if (FAILED(*phr)) goto cleanup;
		}

		// read key def. data size and seek ahead to occurrence hdr. size
		*phr = pHdr->Read(&cbSize, sizeof(DWORD), &cbRead);
		if (FAILED(*phr)) goto cleanup;

		dlibMove.QuadPart = cbSize;
		*phr = pHdr->Seek(dlibMove, STREAM_SEEK_CUR, &libNewPos);
		if (FAILED(*phr)) goto cleanup;

		// read occ. header size and read in key header info
		*phr = pHdr->Read(&cbSize, sizeof(DWORD), &cbRead);
		if (FAILED(*phr)) goto cleanup;

		// ALLOCATE memory
		if (cbSize)
		{
			if (NULL == (pInfo->pOccHdr = new BYTE[cbSize]))
				goto cleanup;

			*phr = pHdr->Read(pInfo->pOccHdr, cbSize, &cbRead);
			if (FAILED(*phr)) goto cleanup;
		}

		// close header
		RcCloseHf(pHdr);


		// Open data file
		if ((pInfo->hf = HfOpenHfs(pWWStorage, SZ_BTREE_DATA, fFSOpenReadOnly,phr))==hfNil)
			goto ignore_wheel;


// erinfox: comment out full-text index support temporarily
// REVIEW(billa): If this is re-enabled, then the correct way to open an index
// will be through IITIndex obtained from CoCreateInstance on CLSID_IITIndexLocal.
// Any stop word information will get loaded automatically as part of the breaker
// instance that was associated with the index at build time.
#if 0
		// if the index isn't there, that is okay.
		pInfo->lpIndex = MVIndexOpen(pTitle->hfpbSysFile, pstrI, phr);
        if (pInfo->lpIndex)
        {   // if the stop file isn't there, that is okay.
            pWheel->lpsipb = MVStopListInitiate (0, phr);
            // If lpsipb is NULL MVStopListIndexLoad will
            // simply return ERR_BADARG, so we don't need to check it
            if (S_OK != MVStopListIndexLoad
                (pTitle->hfpbSysFile, pWheel->lpsipb, pstrS))
            {
                MVStopListDispose (pWheel->lpsipb);
                pWheel->lpsipb = NULL;
            }
        }
#endif
		
		// cache the number of keywords
		RcGetBtreeInfo(pInfo->hbt, (unsigned char*)szBtreeFormat, &pInfo->lNumKws, NULL);

		continue;

		ignore_wheel:

		// close the subfiles
		if (pHdr != NULL)
			RcCloseHf(pHdr);
		if (pInfo->hmapbt!=NULL)
			RcCloseHmapbt(pInfo->hmapbt);
		if (pInfo->hbt!=NULL)
			RcCloseBtreeHbt(pInfo->hbt);
		if (pInfo->hf != hfNil)
			RcCloseHf (pInfo->hf);
#if 0
		if (pInfo->lpIndex)
			MVIndexClose(pInfo->lpIndex);  
#endif

		pInfo->magic=0;
		pWheel->wNumWheels--;
	}

	if (!pWheel->wNumWheels)
	{
		// This can happen when we are looking for a-non existing word wheel
		goto cleanup;
	}

	if (pWheel->wNumWheels > 2)
	{
		*phr = E_TOOMANYTITLES;
		warning_abort;
	}
	
	if (pWheel->wNumWheels == 2)
	{

        *phr = E_NOMERGEDDATA;
		warning_abort;

	}
	else if (pWheel->wNumWheels==1)
	{
		// May STILL need to load from merge file!!!!
			pWheel->lNumRealEntries = pWheel->lNumEntries = pWheel->pInfo->lNumKws;
	}   

	fSuccess = TRUE;

cleanup:

	if (pWheel != NULL) 
		_GLOBALUNLOCK(hWheel);

   // if we failed, then cleanup.
	if (!fSuccess && hWheel != NULL) 
	{
		WordWheelClose(hWheel);      
		hWheel = NULL;
	}

	return (hWheel);
}

/*****************************************************************************
*
*       WordWheelClose
*
*
* @doc EXTERNAL
*
* @api void | WordWheelClose | This function closes a word wheel.
*
* @parm HWHEEL | hWheel | Specifies the handle to the word wheel.
*
* @comm After a word wheel is closed, the <p hWheel> handle is invalid and
* should not be used.
*
* @xref WordWheelOpen
*
*
*****************************************************************************/

PUBLIC VOID FAR PASCAL EXPORT_API WordWheelClose(HWHEEL hWheel) 
{

	PWHEEL      pWheel = NULL;          // pointer to locked-down structure
	WORD        t;

	if (hWheel == NULL)
		return;
	  
	// validate the parameters and lock down the structure
	if ((pWheel = (PWHEEL)_GLOBALLOCK(hWheel))==NULL)
		warning_abort;  
	if (!PWHEEL_OK(pWheel))
		warning_abort;

	for (t = 0; t < pWheel->wNumWheels; t++)
	{
		if (pWheel->pInfo[t].magic == WHEEL_INFO_MAGIC)
		{
			if (NULL != pWheel->pInfo[t].pOccHdr)
				delete pWheel->pInfo[t].pOccHdr;
			if (NULL != pWheel->pInfo[t].pKeyHdr)
				delete pWheel->pInfo[t].pKeyHdr;


			// close the subfiles and the file system
			if (pWheel->pInfo[t].hmapbt!=NULL)
				RcCloseHmapbt(pWheel->pInfo[t].hmapbt);
			if (pWheel->pInfo[t].hbt!=NULL)
				RcCloseBtreeHbt(pWheel->pInfo[t].hbt);
			if (pWheel->pInfo[t].hf != hfNil)
				RcCloseHf (pWheel->pInfo[t].hf);
#if 0	
			// REVIEW(billa): If this is re-enabled, then the correct way
			// to close an index will be through IITIndex obtained from
			// CoCreateInstance on CLSID_IITIndexLocal at open time.
			// Any stop word information will get discarded automatically
			// when the index object releases its associated breaker.
			if (pWheel->pInfo[t].lpIndex)
				MVIndexClose(pWheel->pInfo[t].lpIndex); 
#endif
			pWheel->pInfo[t].magic=0;
		}
	}      
	
	if (pWheel->hCacheData)
    	_GLOBALFREE(pWheel->hCacheData);

	if (pWheel->lpszCacheData)
		DisposeMemory(pWheel->lpszCacheData);

	if (pWheel->hMergeData)
		_GLOBALFREE(pWheel->hMergeData);
	pWheel->magic = 0;
    
#if 0
    if (pWheel->lpsipb)
        MVStopListDispose (pWheel->lpsipb);
#endif

   _GLOBALUNLOCK(hWheel);

   // release the memory used for the structure.
   _GLOBALFREE(hWheel);

cleanup:

   return;
}


/*****************************************************************************
*
*       WordWheelLength
*
*
* @doc EXTERNAL
*
* @api long | WordWheelLength | This function returns the number of entries
* in the word wheel.
*
* @parm HWHEEL | hWheel | Specifies the handle to the word wheel.
*
* @parm PHRESULT | lpErrb | Error return value if failed.
*
* @rdesc Returns the number of entries in the word wheel, or -1 if an
* error occurs.
*
* @xref WordWheelOpen
*
*
*****************************************************************************/

PUBLIC long FAR PASCAL EXPORT_API WordWheelLength(HWHEEL hWheel, PHRESULT phr) 
{
	PWHEEL       pWheel  = NULL;         // pointer to locked-down structure.
	long         lRval   = -1L;          // -1 is the error condition.
	PWHEELINFO  pInfo   = NULL; 
   
	// validate the parameters and lock down the structure
	if ((pWheel = (PWHEEL)_GLOBALLOCK(hWheel))==NULL)
	{
        *phr = E_HANDLE;
        warning_abort;
	}
	if (!PWHEEL_OK(pWheel)) 
	{
        *phr = E_INVALIDARG;
        warning_abort;
	}

	lRval = pWheel->lNumEntries;
   	//DPF3("...WordWheelLength returns, %ld\n", lRval);

    *phr = S_OK;

	cleanup:   
	if (pWheel!=NULL)   
		_GLOBALUNLOCK(hWheel);

	return lRval;
}


/*****************************************************************************
*
*       WordWheelLookup
*
*
* @doc EXTERNAL
*
* @api HRESULT | WordWheelLookup | This function gets a string from a word
* wheel.
*
* @parm HWHEEL | hWheel | Specifies the handle to the word wheel.
*
* @parm long | lIndex | Specifies an index to the word-wheel entry. 
*
* @parm LPVOID | lpvKeyBuf | Specifies a far pointer to the buffer to
* receive the text of the word-wheel entry.
*
* @parm DWORD | cbKeyBuf | Specifies the length of the buffer in bytes.
*
* @rdesc Returns S_OK if successful; otherwise returns error code
*
* @comm Word-wheel entries are numbered starting at zero.
*
* @xref WordWheelLength WordWheelOpen
*
*
*****************************************************************************/

PUBLIC HRESULT FAR PASCAL EXPORT_API WordWheelLookup(HWHEEL hWheel, long lIndex,
												LPVOID lpvKeyBuf, DWORD cbKeyBuf) 
{
	PWHEEL	pWheel  = NULL;				// pointer to locked-down structure
	HRESULT	hr   = E_INVALIDARG;		// assume failure
	BYTE	rgbKeyBuf[ITWW_CBKEY_MAX];


	// validate the parameters and lock down the structure
	if ((pWheel = (PWHEEL)_GLOBALLOCK(hWheel))==NULL) warning_abort;
	if (!PWHEEL_OK(pWheel)) warning_abort;

	if (lIndex >= 0 && lIndex < pWheel->lNumEntries)
	{
		PWHEELINFO  pInfo   = NULL;
		LONG lWheelNum = 0;
		IITSortKey *pITSortKey = NULL;
#ifdef MERGE_UPDATE
		VirtualToReal(lIndex,pWheel,&lIndex,&lWheelNum);
#endif
		pInfo = pWheel->pInfo + lWheelNum;

        // If there's a filter, let's get the proper entry in the WW.
        if (pWheel->pIITGroup)
        {
            hr = (pWheel->pIITGroup)->FindTopicNum((DWORD)lIndex, (DWORD*)(&lIndex));
            if (FAILED(hr))
                goto cleanup;
        }

		// lookup the entry in the map file once we know _which_ map file to look in
		if (SUCCEEDED(hr = RcKeyFromIndexHbt(pInfo->hbt, pInfo->hmapbt, 
								(KEY) &rgbKeyBuf[0], ITWW_CBKEY_MAX, lIndex)) &&
			SUCCEEDED(hr = CheckWordWheelKeyType(pInfo->hbt, &pITSortKey)))
		{
			DWORD	cbKey;

			// Check to see if the key we got back will fit in the caller's buffer.
			// If it will fit, copy it, otherwise return an error.
			if ((cbKey = CbKeyWordWheel((LPVOID) &rgbKeyBuf[0], pITSortKey)) <= cbKeyBuf)
				MEMCPY(lpvKeyBuf, (LPVOID) &rgbKeyBuf[0], cbKey);
			else
				hr = E_INVALIDARG;
		}

		if (pITSortKey != NULL)
			pITSortKey->Release();

#ifdef _MAC                                
		StringMapWinToMac (pInfo->hbt, lpBuf);
#endif
	}
	else
		hr = E_OUTOFRANGE;

cleanup:
   if (pWheel!=NULL)
		_GLOBALUNLOCK(hWheel);

   return hr;
}


/*****************************************************************************
*
*       WordWheelPrefix
*
*
* @doc EXTERNAL
*
* @api long | WordWheelPrefix | This function locates a word-wheel entry
* whose text starts with the specified prefix.
*
* @parm HWHEEL | hWheel | Specifies the handle to the word wheel.
*
* @parm LPCSTR | lpszPrefix | Specifies a far pointer to a string
* containing the text of the prefix.
*
* @parm PHRESULT | lpErrb | Error return value if failed.
*
* @rdesc Returns the index of the first entry containing the specified
* prefix. If no entry contains the prefix, the function returns the index 
* of the entry immediately prior to the point where a word with the 
* specified prefix would be found. The lowest index returned is zero.
*
* If an error occurs, the function returns -1.
*
* @comm Word-wheel entries are numbered starting at zero.
*
* @xref WordWheelLength WordWheelLookup WordWheelOpen
*
*
*****************************************************************************/
PUBLIC long FAR PASCAL EXPORT_API WordWheelPrefix(HWHEEL hWheel, LPCVOID lpcvPrefix, 
													BOOL fExactMatch, PHRESULT phr) 
{
    PWHEEL       pWheel  = NULL;         // pointer to locked-down structure
    BTPOS        btpos;                  // position in BTREE for prefix
    BYTE         rgbKeyTemp[ITWW_CBKEY_MAX +1];  // holds key nearest prefix for single or Update
    long         lRval   = -1;           // assume failure
    RC           rc;                     // to catch return codes
    PWHEELINFO   pInfo = NULL;
    BOOL ifOver1 = FALSE;
#ifdef MERGE_UPDATE
    BYTE         rgbKeyTemp2[ITWW_CBKEY_MAX +1]; // holds key nearest prefix for Main
    long         lRval2  = -1;
	BOOL		 ifOver2 = FALSE;
#endif
#ifdef _MAC
    BYTE         szSearchKey[ITWW_CBKEY_MAX+1];
    LPBYTE       lpb;
    LPCMAP       lpCMap;
    LPCHARTAB FAR * lplpCharTab;
#endif
   

    // validate the parameters and lock down the structure
    if ((pWheel = (PWHEEL)_GLOBALLOCK(hWheel))==NULL) 
    {
        *phr = E_HANDLE;
	    warning_abort;
    }

    if (!PWHEEL_OK(pWheel)) 
    {
        *phr = E_INVALIDARG;
	    warning_abort;
    }
	pInfo = pWheel->pInfo;
	

#ifdef _MAC
    if (lplpCharTab = (LPCHARTAB FAR *)BtreeGetCMap (pInfo->hbt))  
    {
	    lpCMap = (LPCMAP)lplpCharTab[0]->lpCMapTab;

	    // Map Mac string back to Windows string
	    for (lpb = szSearchKey; ; lpb++, lpstrPrefix++ ) 
	    {
		    if ((*lpb = *lpstrPrefix) == EMBEDFONT_BYTE_TAG)
		    {
			    /* Load new table */
			    lpstrPrefix++;
			    lpb++;
			    lpCMap = lplpCharTab[*lpb = *lpstrPrefix]->lpCMapTab;
			    lpstrPrefix++;
			    lpb++;
		    }
		    *lpb = lpCMap[*lpstrPrefix].MacToWin;
		    if (*lpstrPrefix == 0)
			    break;
	    }
	    // lookup the entry in the btree file.
	    rc=RcLookupByKey(pInfo->hbt, (KEY)szSearchKey, &btpos, NULL);
    }
    else
#endif
	  // look up the prefix in the btree.
	rc=RcLookupByKey(pInfo->hbt, (KEY)lpcvPrefix, &btpos, NULL);

    // if caller asked for exact match and it didn't happen,
    // return w/ an error
    if (fExactMatch)
    {
        if (rc != S_OK)
        {
            SetErrCode(phr, rc);
            warning_abort;
        }

    }


    if (rc != S_OK && rc != E_NOTEXIST) 
    {
	    SetErrCode(phr, rc);
	    warning_abort;
    }
   
    // If we ran off the end, then position ourselves at the
    // last key in the btree.
    if (!FValidPos(&btpos))
    {
		// maybe this was here for merge update; at any rate,
		// setting lRval to btpos.cKey is wrong
#if 0
        if ((rc = RcLastHbt(pInfo->hbt, (KEY)NULL, NULL, &btpos))!= S_OK)
	    {
		    SetErrCode(phr, rc);
		    warning_abort;
	    }
	    lRval = btpos.cKey; //ericjut: Putting the good value
#endif
	
		
		if ((rc = RcLastHbt(pInfo->hbt, (KEY)NULL, NULL, &btpos)) != S_OK)
			warning_abort;

		lRval = pInfo->lNumKws - 1;

        ifOver1 = TRUE;
    }
    else
    {

	    // We are somewhere in the btree. We have either typed in
	    // a string which is a prefix to a keyword in the btree or not.
	    // See where we landed in the btree and compare the keyword in
	    // the dialog with where we are.

	    rc = RcLookupByPos(pInfo->hbt,&btpos, (KEY)rgbKeyTemp, ITWW_CBKEY_MAX ,NULL);
	    if (rc == S_OK) 
		    rc = RcIndexFromKeyHbt(pInfo->hbt, pInfo->hmapbt, (LPLONG)&lRval,
												(KEY)rgbKeyTemp);
	    if (rc != S_OK)
	    {
		    lRval = -1;
		    SetErrCode(phr, rc);
		    warning_abort;
	    }

	    // If the keyword we looked for is not a prefix of the
	    // string at btpos, then we are positioned at the keyword
	    // that would follow this keyword if it were in fact in the 
	    // btree. Back up one keyword to let him see the previous
	    // one to give enough context so he sees his is not present.
	    // If already at the first keyword, don't back up any farther.

	    if (!FIsPrefix(pInfo->hbt, (KEY)lpcvPrefix, (KEY)rgbKeyTemp))
		    if (lRval > 0) lRval--;
    }

#ifdef MERGE_UPDATE
    if (pWheel->wNumWheels==2)   // Look up in update as well
    {
	    pInfo = pWheel->pInfo+1;

        // Getting rid of the unwanted duplicates.
        if (ifOver1)
            lRval = WWDuplicateRemove(lRval, pWheel);
	
#ifdef _MAC
		if (lplpCharTab = (LPCHARTAB FAR *)BtreeGetCMap (pInfo->hbt))  
		{
			lpCMap = (LPCMAP)lplpCharTab[0]->lpCMapTab;
			for (lpb = szSearchKey; ; lpb++, lpstrPrefix++ ) 
			{
				if ((*lpb = *lpstrPrefix) == EMBEDFONT_BYTE_TAG)
				{
					/* Load new table */
					lpstrPrefix++;
					lpb++;
					lpCMap = lplpCharTab[*lpb = *lpstrPrefix]->lpCMapTab;
					lpstrPrefix++;
					lpb++;
				}
				*lpb = lpCMap[*lpstrPrefix].MacToWin;
				if (*lpstrPrefix == 0)
					break;
			}
			rc=RcLookupByKey(pInfo->hbt, (KEY)szSearchKey, &btpos, NULL);
		}
		else
#endif
		rc=RcLookupByKey(pInfo->hbt, (KEY)lpcvPrefix, &btpos, NULL);


		if (rc != S_OK && rc != ERR_NOTEXIST)
		{
			SetErrCode(phr, rc);
			warning_abort;
		}
   
		if (!FValidPos(&btpos)) 
		{
			if ((rc = RcLastHbt(pInfo->hbt, (KEY)NULL, NULL, &btpos)) != S_OK)
			{
				SetErrCode(phr, rc);
				warning_abort;
			}
			lRval2 =  btpos.cKey; //ericjut: Putting the good value
            ifOver2 = TRUE;
		} 
		else 
		{
			rc = RcLookupByPos(pInfo->hbt,&btpos,(KEY)rgbKeyTemp2,ITWW_CBKEY_MAX,NULL);
			if (rc == S_OK) 
				rc = RcIndexFromKeyHbt(pInfo->hbt, pInfo->hmapbt, (LPLONG)&lRval2,
													(KEY)rgbKeyTemp2);
			if (rc != S_OK)
			{
				lRval2 = -1;
				SetErrCode(phr, rc);
				warning_abort;
			}
			if (!FIsPrefix(pInfo->hbt,(KEY)lpcvPrefix,(KEY)rgbKeyTemp2))
				if (lRval2 > 0) lRval2--;
		}
	
		// Now find lowest virtual index for tree 0, index lRval or tree 1, index lRval2
		lRval=RealToVirtual(lRval, 0, pWheel);
		lRval2=RealToVirtual(lRval2, 1, pWheel);

		if ((lRval2<lRval && !ifOver2) || (!(lRval2<lRval) && ifOver1))
			lRval=lRval2;
	}
	else
	{
		if (pWheel->hMergeData)
            lRval=RealToVirtual(lRval, 0, pWheel);
	}
#endif // MERGE_UPDATE

    if (pWheel->pIITGroup)
    {
        // In a filtered situation, let's find the proper offset.
        *phr = (pWheel->pIITGroup)->FindOffset((DWORD)lRval, (DWORD*)(&lRval));
        if (FAILED(*phr) && (E_NOTEXIST != *phr))
            goto cleanup;    
    }

   *phr = S_OK;

cleanup:
   if (pWheel!=NULL)
		_GLOBALUNLOCK(hWheel);

   return lRval;
}


// Little internal function to figure out if a UID is part of 
BOOL static IsInFilter(_LPGROUP qFilter, LONG lOffset)
{
    LONG lNbBytes = lOffset / 8;
    LONG lNbBits =  lOffset % 8;
    BYTE bMask =    1 << lNbBits;
    
    return ((BYTE)*(qFilter->lpbGrpBitVect+lNbBytes)) & bMask;
}


// Returns S_OK if the btree's key type is a valid one for the word wheel.
// *ppITSortKey is always set based on one of the following cases:
//
//	to NULL :		if any error occurs, which includes an unsupported
//					key type or if the key type is KT_EXTSORT but no
//					pointer to the external sort instance has been specified.
//
//	to non-NULL :	the key type is KT_EXTSORT and a pointer to an
//					external sort instance has been specified.
HRESULT FAR PASCAL CheckWordWheelKeyType(HBT hbt, IITSortKey **ppITSortKey)
{
	BTREE_PARAMS	btp;
	HRESULT			hr = S_OK;

	if (ppITSortKey == NULL)
		return (E_POINTER);

	*ppITSortKey = NULL;

	GetBtreeParams(hbt, &btp);
	switch (btp.rgchFormat[0])
	{
		case KT_EXTSORT:
			BtreeGetExtSort(hbt, ppITSortKey);
			if (*ppITSortKey == NULL)
				hr = E_INVALIDSTATE;

			break;

		case KT_SZ:
		case KT_SZMAP:
			break;

		default:
			// Word wheel doesn't support any other key types.
			hr = E_BADFORMAT;
			break;
	};

	return (hr);
}


DWORD FAR PASCAL CbKeyWordWheel(LPVOID lpvKey, IITSortKey *pITSortKey)
{
	DWORD	cbKey;

	if (pITSortKey == NULL)
	{
		// Btree key type is a KT_SZx which we understand, so we'll determine
		// the key size ourselves.
		cbKey = (DWORD) STRLEN((char *) lpvKey) + 1;
	}
	else
	{
		// Get the key size from the sort object.
		if (FAILED(pITSortKey->GetSize(lpvKey, &cbKey)))
		{
			cbKey = 0;
			ITASSERT(FALSE);
		}
	}

	return (cbKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\local\catalog.h ===
// CATALOG.H:  Definition of CITCatalogLocalLocal
//
//
#ifndef __CATALOG_H__
#define __CATALOG_H__

#include "verinfo.h"


// Implemenation of IITCatalog
class CITCatalogLocal : 
	public IITCatalog,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CITCatalogLocal, &CLSID_IITCatalogLocal>

{


public:
	CITCatalogLocal() : m_pCatalog(NULL), m_hbt(NULL),
		m_pDataStr(NULL), m_pHdr(NULL), m_pScratchBuffer(NULL) {;}

BEGIN_COM_MAP(CITCatalogLocal)
	COM_INTERFACE_ENTRY(IITCatalog)
END_COM_MAP()

DECLARE_REGISTRY(CLSID_IITCatalogLocal, "ITIR.LocalCatalog.4", "ITIR.LocalCatalog", 0, THREADFLAGS_BOTH )

	// IITCatalog methods
	STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszwName = NULL);
	STDMETHOD(Close)(void);
	STDMETHOD(Lookup)(IITResultSet* pRSIn, IITResultSet* pRSOut = NULL);
	STDMETHOD(GetColumns)(IITResultSet* pRS);

    // Private methods and data
private:
	IStorage* m_pCatalog;  // Catalog sub-storage
	HBT m_hbt;             // Handle to b-tree
	LPBYTE m_pHdr;         // Header buffer
	IStream* m_pDataStr;   // Data stream
    LPVOID m_pScratchBuffer;  // Scratch buffer
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\local\dbimp.h ===
// DBIMP.H:  Definition of CDatabase

#ifndef __DBIMP_H__
#define __DBIMP_H__

#include "verinfo.h"
#include "objmngr.h"

// DATABASEINFO now defined in wwheel.h

class CITDatabaseLocal : 
	public IITDatabase,
	public IPersistStorage,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CITDatabaseLocal,&CLSID_IITDatabaseLocal>
{
public:
	CITDatabaseLocal();
	virtual ~CITDatabaseLocal();
 
BEGIN_COM_MAP(CITDatabaseLocal)
	COM_INTERFACE_ENTRY(IITDatabase)
	COM_INTERFACE_ENTRY(IPersistStorage)
END_COM_MAP()

DECLARE_REGISTRY(CLSID_IITDatabaseLocal, "ITIR.LocalDatabase.4", "ITIR.LocalDatabase", 0, THREADFLAGS_BOTH )

	// IITDatabase Methods
	STDMETHOD(Open)(LPCWSTR lpszHost, LPCWSTR lpszMoniker, DWORD dwFlags);
	STDMETHOD(Close)(void);
	STDMETHOD(CreateObject)(REFCLSID rclsid, DWORD *pdwObjInstance);
	STDMETHOD(GetObject)(DWORD dwObjInstance, REFIID riid, LPVOID *ppvObj);
	STDMETHOD(GetObjectPersistence)(LPCWSTR lpwszObject, DWORD dwObjInstance,
									LPVOID *ppvPersistence,
									BOOL fStream);

	// IPersistStorage Methods
	STDMETHOD(GetClassID)(CLSID *pclsid);
	STDMETHOD(InitNew)(IStorage *pStorage);
	STDMETHOD(IsDirty)(void);
	STDMETHOD(Load)(IStorage *pStorage);
	STDMETHOD(Save)(IStorage *pStorage, BOOL fSameAsLoad);
	STDMETHOD(SaveCompleted)(IStorage *pStorageNew);
	STDMETHOD(HandsOffStorage)(void);

private:
    CObjectInstHandler m_ObjInst;

	IStorage*  m_pStorage;
    _ThreadModel::AutoCriticalSection m_cs;      // Critical section obj.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\local\dbimp.cpp ===
/*******************************************************
*   @doc SHROOM EXTERNAL API                           *
*                                                      *
*   DBIMP.CPP                                          *
*                                                      *
*   Copyright (C) Microsoft Corporation 1997           *
*   All rights reserved.                               *
*                                                      *
*   This file contains the local                       *
*   implementation of CDatabase.                       *
*                                                      *
********************************************************
*                                                      *
*   Header section added by Anita Legsdin so that      *
*   comments will appear in Autodoc                    *
*                                                      *
*******************************************************/
// DBIMP.CPP:  Implementation of CDatabase
// I'd like to get rid of this, but for now we include it so this compiles
#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <atlinc.h>

// MediaView (InfoTech) includes
#include <mvopsys.h>
#include <groups.h>
#include <wwheel.h>  
#include <msitstg.h>

#include <ccfiles.h>
#include "itdb.h"
#include "DBImp.h"

// TODO TODO TODO: Replace the blind use of critical sections with a
// better way of ensuring thread-safeness while preserving performance.
// But for now, in the interest of coding time, we just make sure the 
// code is thread-safe.

//---------------------------------------------------------------------------
//						Constructor and Destructor
//---------------------------------------------------------------------------


CITDatabaseLocal::CITDatabaseLocal()
{
	m_pStorage = NULL;
}

CITDatabaseLocal::~CITDatabaseLocal()
{
	Close();
}


//---------------------------------------------------------------------------
//						IITDatabase Method Implemenations
//---------------------------------------------------------------------------


/********************************************************************
 * @method    STDMETHODIMP | IITDatabase | Open |
 *     Opens a database
 * 
 * @parm LPCWSTR | lpszHost | Host name. You can pass NULL if calling Open
 * locally, otherwise this string should contain the host description string, described
 * below.
 *
 * @parm LPCWSTR | lpszMoniker | Name of database file to open. This should include
 * the full path to the file name, if calling locally.  If calling using HTTP, this
 * should contain the ISAPI extension DLL name followed by the relative path to the database
 * file, for example:
 *
 *   isapiext.dll?path1\path2\db.its
 *
 * @parm DWORD | dwFlags | Currently not used
 *
 * @rvalue STG_E* | Any of the IStorage errors that can occur when opening a storage.
 * @rvalue S_OK | The database was successfully opened
 *
 * @comm Current implementation opens all databases using the IT storage system (ITSS).
 * As a consequence, all databases must be built using ITSS.
 *
 * Currently two transport protocols are supported: local in-proc and HTTP.  For the
 * local protocol the host name is NULL.  For HTTP, it must be set to the transport address
 * of the machine which is running the ITIR ISAPI extension.  For example, one possible HTTP 
 * host name string would be "http:\\www.microsoft.com\"
 *
 * This method might attempt to connect to the database in order to load configuration information.
 ********************************************************************/
STDMETHODIMP CITDatabaseLocal::Open(LPCWSTR lpszHost, LPCWSTR lpszMoniker, DWORD dwFlags)
{
	HRESULT hr;
	IITStorage* pITStorage = NULL;
	 
	
	if (NULL == lpszMoniker)
		return SetErrReturn(E_INVALIDARG);

	// For now, we assume we're getting an ITSS file
	// We might want to replace this later with more sophisticated code
	// that parses the given moniker

	m_cs.Lock();

	if (m_pStorage)
		return SetErrReturn(E_ALREADYINIT);

	// Open storage READ-only; we only need one instance
	if (SUCCEEDED(hr = CoCreateInstance(CLSID_ITStorage, NULL,
											CLSCTX_INPROC_SERVER,
											IID_ITStorage,
											(VOID **) &pITStorage)) &&
		SUCCEEDED(hr = pITStorage->StgOpenStorage(lpszMoniker, NULL,
											STGM_READ, NULL, 0, &m_pStorage)))
	{
		hr = Load(m_pStorage);
	}

    // Free ITSS interface no longer needed
	if (pITStorage)
		pITStorage->Release();

	m_cs.Unlock();
	return hr;
}

/********************************************************************
 * @method    STDMETHODIMP | IITDatabase | Close |
 *     Closes a database
 * 
 * @rvalue S_OK | The database was successfully closed
 *
 ********************************************************************/
STDMETHODIMP CITDatabaseLocal::Close()
{
	m_cs.Lock();

    // release storage pointer
    if (m_pStorage)
	{
		m_pStorage->Release();
		m_pStorage = NULL;
	}
	else
		return SetErrReturn(E_NOTINIT);
 
    m_ObjInst.Close();

	m_cs.Unlock();
	return S_OK;
}


/******************************************************************* *
 * @method    STDMETHODIMP WINAPI | IITDatabase | CreateObject |
 * Creates an unnamed object that can be referenced in the future
 * by *pdwObjInstance.  
 *
 * @parm REFCLSID | refclsid | Class ID for object. 
 * @parm DWORD | *pdwObjInstance | Identifier for object. 
 * 
 * @rvalue S_OK | The object was successfully created
 * @rvalue E_INVALIDARG | The argument was not valid
 * @rvalue E_NOTINIT | 
 * @rvalue E_OUTOFMEMORY | 
 *
 * @comm 
 * The value in *pdwObjInstance will be
 * persisted by the database when it is asked to save using 
 * IPersistStorage::Save.
 *
 ********************************************************************/
STDMETHODIMP
CITDatabaseLocal::CreateObject(REFCLSID rclsid, DWORD *pdwObjInstance)
{
    return m_ObjInst.AddObject(rclsid, pdwObjInstance);
}


/******************************************************************* *
 * @method    STDMETHODIMP WINAPI | IITDatabase | GetObject |
 * Retrieves a specified IUnknown-based interface on the object identified
 * by dwObjInstance.
 *
 * @parm DWORD | dwObjInstance | Identifier for object.
 * @parm REFIID | refiid | Interface ID
 * @parm LPVOID | *ppvObj |   
 * 
 * @rvalue S_OK | The operation completed successfully.
 * @rvalue E_INVALIDARG | The argument was not valid.
 * @rvalue E_NOTINIT | 
 * @rvalue E_OUTOFMEMORY | 
 *
 *
 ********************************************************************/
STDMETHODIMP
CITDatabaseLocal::GetObject(DWORD dwObjInstance, REFIID riid, LPVOID *ppvObj)
{
    return m_ObjInst.GetObject(dwObjInstance, riid, ppvObj);
}


/******************************************************************* *
 * @method    STDMETHODIMP WINAPI | IITDatabase | GetObjectPersistence |
 * Retrieves persistence data for a named object. 
 *
 * @parm LPCWSTR | lpwszObject | Name of the object
 * @parm DWORD | dwObjInstance | Object instance ID
 * @parm LPVOID | *ppvPersistence | Pointer to persistence data for the object. 
 * @parm BOOL | fStream | Identifies whether the object is a stream object (true)
 *              or storage object (false). 
 * 
 * @rvalue S_OK | The operation completed successfully.
 * @rvalue E_INVALIDARG | The argument was not valid.
 * @rvalue STG_E_FILENOTFOUND |The specified object's persistence does not
 *         exist, or it is of the wrong type. 
 * @rvalue E_NOTINIT | 
 * @rvalue E_OUTOFMEMORY | 
 *
 * @comm

 * To obtain a pointer to a named object's persistence, specify the 
 * object's full name (including any object-specific type prefix) in
 * lpswszObject.  If *lpwszObject is NULL, then the database's own storage
 * is returned.  If lpwszObject is NULL, then dwObjInstance is
 * used to identify the object and locate its persistence.  On exit,
 * *ppvPersistence is either an IStorage* or an IStream*, depending
 * on what you specified in the fStream param.  Only read operations
 * can be performed on *ppvPersistence.
 *
 ********************************************************************/
STDMETHODIMP
CITDatabaseLocal::GetObjectPersistence(LPCWSTR lpwszObject, DWORD dwObjInstance,
								LPVOID *ppvPersistence, BOOL fStream)
{
	HRESULT	hr = S_OK;

	m_cs.Lock();

	if (m_pStorage != NULL)
	{
		if (lpwszObject != NULL)
		{
			if (fStream)
				hr = m_pStorage->OpenStream(lpwszObject, NULL, STGM_READ,
                    0, (IStream **) ppvPersistence);
			else
			{
				if (*lpwszObject == (WCHAR) NULL)
					{
					m_pStorage->AddRef();
					*ppvPersistence = (LPVOID) m_pStorage;
					}
				else
					hr = m_pStorage->OpenStorage(lpwszObject, NULL,
									STGM_SHARE_DENY_WRITE | STGM_READ,
									NULL, 0, (IStorage **) ppvPersistence);
			}
		}
		else
		{
			if (fStream)
			{
				// REVIEW (billa, johnrush): Need to allocate memory for the
				// object's persistent data and call CreateStreamOnHGlobal.
                hr = E_NOTSUPPORTED;
			}
			else
				hr = STG_E_FILENOTFOUND;
		}
	}
	else
		hr = E_UNEXPECTED;

	m_cs.Unlock();
	return (hr);
}


//---------------------------------------------------------------------------
//						IPersistStorage Method Implementations
//---------------------------------------------------------------------------


STDMETHODIMP
CITDatabaseLocal::GetClassID(CLSID *pclsid)
{
	*pclsid = CLSID_IITDatabaseLocal;
	return (S_OK);
}


STDMETHODIMP
CITDatabaseLocal::InitNew(IStorage *pStorage)
{
	HRESULT	hr = S_OK;

	if (pStorage == NULL)
		return (E_POINTER);

	m_cs.Lock();

	if (m_pStorage == NULL)
	    (m_pStorage = pStorage)->AddRef();
	else
		hr = E_UNEXPECTED;

    m_ObjInst.InitNew();

	m_cs.Unlock();

	return (hr);
}


STDMETHODIMP
CITDatabaseLocal::IsDirty(void)
{
    return m_ObjInst.IsDirty();
}


STDMETHODIMP
CITDatabaseLocal::Load(IStorage *pStorage)
{
	HRESULT hr = S_OK;;

	if (pStorage == NULL)
		return (E_POINTER);

	m_cs.Lock();

    IStream *pistmObjectManager;
    if (FAILED(hr = pStorage->OpenStream
        (SZ_OBJINST_STREAM, STGM_READ, 0, 0, &pistmObjectManager)))
        return (hr);

    hr = m_ObjInst.Load(pistmObjectManager);
    pistmObjectManager->Release();

	m_cs.Unlock();
	return (hr);
}


STDMETHODIMP
CITDatabaseLocal::Save(IStorage *pStorage, BOOL fSameAsLoad)
{
	HRESULT hr = S_OK;;

	if (pStorage == NULL)
		return (E_POINTER);

	m_cs.Lock();

    IStream *pistmObjectManager;
    if (FAILED(hr = pStorage->CreateStream
        (SZ_OBJINST_STREAM, STGM_WRITE, 0, 0, &pistmObjectManager)))
        return (hr);

    hr = m_ObjInst.Save(pistmObjectManager, TRUE);
    pistmObjectManager->Release();

	m_cs.Unlock();
	return (hr);
}


STDMETHODIMP
CITDatabaseLocal::SaveCompleted(IStorage *pStorageNew)
{
	if (pStorageNew != NULL)
	{
		m_cs.Lock();

		if (m_pStorage != NULL)
			m_pStorage->Release();

		(m_pStorage = pStorageNew)->AddRef();

		m_cs.Unlock();
	}

	return (S_OK);
}


STDMETHODIMP
CITDatabaseLocal::HandsOffStorage(void)
{
	// REVIEW (billa): At some point, we should implement IPersistStorage
	// mode tracking so that we explicitly enter/leave the No Scribble and
	// Hands Off Storage modes.
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\local\objmngr.cpp ===
#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <windows.h>
#include <_mvutil.h>
#include <orkin.h>
#include <ITverinfo.h>
#include "objmngr.h"

#ifdef IA64 
#include <itdfguid.h> 
#endif

CObjectInstHandler::CObjectInstHandler()
{
    m_hMemory = NULL;
    m_pObjects = NULL;
    m_fInitNew = FALSE;
    m_fIsDirty = FALSE;
    m_iMaxItem = 0;
    m_iCurItem = 0;
}

CObjectInstHandler::~CObjectInstHandler()
{
    (void)Close();
}

STDMETHODIMP CObjectInstHandler::InitNew()
{
    if(TRUE == m_fInitNew)
        return SetErrReturn(E_UNEXPECTED);

    m_fIsDirty = TRUE; // Set to false after breakers work

    HRESULT hr = S_OK;
    if(NULL == (m_hMemory = _GLOBALALLOC
        (DLLGMEM_ZEROINIT, OBJINST_BASE * sizeof(OBJINSTMEMREC))))
        SetErrCode (&hr, E_OUTOFMEMORY);
    if(SUCCEEDED(hr))
    {
        m_pObjects = (POBJINSTMEMREC)_GLOBALLOCK(m_hMemory);
        ITASSERT(m_pObjects);

        m_iCurItem = 0;
        m_iMaxItem = OBJINST_BASE;
    }
    return hr;
} /* InitNew */


STDMETHODIMP CObjectInstHandler::Close()
{
    if(!m_hMemory)
        return S_OK;

    POBJINSTMEMREC pObjArray = m_pObjects;
    for (DWORD loop = 0; loop < m_iCurItem; loop++, pObjArray++)
        pObjArray->pUnknown->Release();

    _GLOBALUNLOCK(m_hMemory);
    _GLOBALFREE(m_hMemory);

    m_iMaxItem = 0;
    m_iCurItem = 0;
    m_pObjects = NULL;
    m_hMemory = NULL;
    m_fInitNew = FALSE;
    m_fIsDirty = FALSE;

    return S_OK;
} /* Close */

STDMETHODIMP CObjectInstHandler::AddObject(REFCLSID clsid, DWORD *pdwObjInstance)
{
    if (NULL == pdwObjInstance)
        return SetErrReturn(E_INVALIDARG);

    // Can we write the out param?
    if (IsBadWritePtr(pdwObjInstance, sizeof(DWORD)))
    {
        ITASSERT(0);
        return SetErrReturn(E_INVALIDARG);
    }

    IUnknown *pUnknown;
    HRESULT hr = CoCreateInstance
        (clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&pUnknown);
    if (FAILED(hr))
        return hr;

    IPersistStreamInit *pPersist;
    if (SUCCEEDED(hr = pUnknown->QueryInterface
        (IID_IPersistStreamInit, (void **)&pPersist)))
    {
        (void)pPersist->InitNew();
        pPersist->Release();
    }

    if (m_iCurItem == m_iMaxItem)
    {
        HANDLE hNewMem;

        _GLOBALUNLOCK(m_hMemory);
        hNewMem = _GLOBALREALLOC (m_hMemory,
            (m_iMaxItem + OBJINST_INCREMENT) * sizeof(OBJINSTMEMREC), 0);
        if (NULL == hNewMem)
        {
            *pdwObjInstance = 0;
            return SetErrReturn(E_OUTOFMEMORY);
        }
        m_hMemory = hNewMem;
        m_pObjects = (POBJINSTMEMREC)_GLOBALLOCK(m_hMemory);
        m_iMaxItem += OBJINST_INCREMENT;
    }

    (m_pObjects + m_iCurItem)->pUnknown = pUnknown;
    (m_pObjects + m_iCurItem)->clsid = clsid;
    *pdwObjInstance = m_iCurItem++;
    m_fIsDirty = TRUE;

    return S_OK;
} /* CObjectInstHandler::AddObject */


STDMETHODIMP CObjectInstHandler::GetObject
    (DWORD dwObjInstance, REFIID riid, void **ppv)
{
    if (NULL == ppv)
        return SetErrReturn(E_INVALIDARG);

    // Can we write the out param?
    if (IsBadWritePtr(ppv, sizeof(void *)))
    {
        ITASSERT(0);
        return SetErrReturn(E_INVALIDARG);
    }

    *ppv = NULL;

    if (dwObjInstance >= m_iCurItem)
        return SetErrReturn(E_NOTEXIST);

    IUnknown *pUnknown = (m_pObjects + dwObjInstance)->pUnknown;
    if (NULL == pUnknown)
        return SetErrReturn(E_NOTEXIST);

    return pUnknown->QueryInterface(riid, ppv);
} /* CObjectInstHandler::GetObject */


STDMETHODIMP CObjectInstHandler::Save(LPSTREAM pStream, BOOL fClearDirty)
{
    if (NULL == pStream)
        return SetErrReturn(E_INVALIDARG);

    // Build up the header
    OBJ_INSTANCE_CACHE ObjInstCache;
    ObjInstCache.Header.dwVersion =
        MAKELONG(MAKEWORD(0, rapFile), MAKEWORD(rmmFile, rmjFile));
    ObjInstCache.Header.dwEntries = m_iCurItem;
    if (NULL == (ObjInstCache.hRecords = _GLOBALALLOC
        (GMEM_MOVEABLE, sizeof(OBJ_INSTANCE_RECORD) * m_iMaxItem)))
        return SetErrReturn (E_OUTOFMEMORY);
    ObjInstCache.pRecords =
        (POBJ_INSTANCE_RECORD)_GLOBALLOCK(ObjInstCache.hRecords);
    POBJ_INSTANCE_RECORD pRecord = ObjInstCache.pRecords;

    // Save stream start pointer
    LARGE_INTEGER liTemp = {0};
    ULARGE_INTEGER liStart;
    HRESULT hr;
    if (FAILED(hr = pStream->Seek(liTemp, STREAM_SEEK_CUR, &liStart)))
    {
exit0:
        _GLOBALUNLOCK(ObjInstCache.hRecords);
        _GLOBALFREE(ObjInstCache.hRecords);
        return hr;
    }

    // Write dummy header to beginning of file
    DWORD dwOffset =
        sizeof(OBJ_INSTANCE_HEADER) + m_iCurItem * sizeof(OBJ_INSTANCE_RECORD);
    DWORD dwHeaderSize = dwOffset;
    if (FAILED(hr = pStream->Write(&ObjInstCache, dwHeaderSize, NULL)))
        goto exit0;

    POBJINSTMEMREC pObjArray = m_pObjects;
    for (DWORD loop = 0; loop < m_iCurItem; loop++, pObjArray++, pRecord++)
    {
        pRecord->dwOffset = dwOffset;

        // When we loaded this we coulnd't create this object.  It is
        // essentially dead.  In this state we can not save.  This is not
        // an issue for IT40, since we never save the database at run-time
        if (NULL == pObjArray->pUnknown)
        {
            ITASSERT(0);
            SetErrCode(&hr, E_UNEXPECTED);
            goto exit0;
        }

        // Save current stream pointer
        ULARGE_INTEGER liStart; // Local scope - Don't confuse with 
                                // function scoped variable of the same name
        if (FAILED(hr = pStream->Seek(liTemp, STREAM_SEEK_CUR, &liStart)))
            goto exit0;

        // Write CLSID
        if (FAILED(hr = pStream->Write(&pObjArray->clsid, sizeof(CLSID), NULL)))
            goto exit0;

        // Get IPersistStreamInit interface and save persistance data
        IPersistStreamInit *pPersist;
        if (SUCCEEDED(hr = pObjArray->pUnknown->QueryInterface
            (IID_IPersistStreamInit, (void**)&pPersist)))
        {
            // Write persistance data
            hr = pPersist->Save(pStream, fClearDirty);
            pPersist->Release();
            if (FAILED(hr))
                goto exit0;
        }

        // Get current stream pointer
        ULARGE_INTEGER liEnd;
        if (FAILED(hr = pStream->Seek(liTemp, STREAM_SEEK_CUR, &liEnd)))
            goto exit0;

        pRecord->dwSize = (DWORD)(liEnd.QuadPart - liStart.QuadPart);
        dwOffset += pRecord->dwSize;
    }

    // Write completed header
    liTemp.QuadPart = liStart.QuadPart;
    if (FAILED(hr = pStream->Seek(liTemp, STREAM_SEEK_SET, NULL)))
        goto exit0;
    if (FAILED(hr = pStream->Write
        (&ObjInstCache.Header, sizeof (OBJ_INSTANCE_HEADER), NULL)))
        goto exit0;
    hr = pStream->Write(ObjInstCache.pRecords,
        dwHeaderSize - sizeof (OBJ_INSTANCE_HEADER), NULL);

    m_fIsDirty = FALSE;
    goto exit0;
} /* CObjectInstHandler::Save */


STDMETHODIMP CObjectInstHandler::Load(LPSTREAM pStream)
{
    if (TRUE == m_fInitNew)
        return SetErrReturn(E_UNEXPECTED);

    if (NULL == pStream || IsBadReadPtr(pStream, sizeof(void *)))
        return SetErrReturn(E_INVALIDARG);

    HRESULT hr;

    // Read header from stream
    OBJ_INSTANCE_CACHE objCache;
    hr = pStream->Read(&objCache, sizeof(OBJ_INSTANCE_HEADER), NULL);
    if (FAILED(hr))
        return SetErrReturn(hr);

    if (objCache.Header.dwVersion != MAKELONG(MAKEWORD(0, rapFile), MAKEWORD(rmmFile, rmjFile)))
        return SetErrReturn(E_BADVERSION);
    m_iMaxItem = m_iCurItem = objCache.Header.dwEntries;

    // Allocate memory for run-time table
    if (NULL == (m_hMemory = _GLOBALALLOC
        (DLLGMEM_ZEROINIT, m_iCurItem * sizeof(OBJINSTMEMREC))))
        return SetErrReturn(E_OUTOFMEMORY);
    m_pObjects = (POBJINSTMEMREC)_GLOBALLOCK(m_hMemory);
    ITASSERT(m_pObjects);
    
    // Allocate memory for the stream index table
    if (NULL == (objCache.hRecords = _GLOBALALLOC
        (DLLGMEM_ZEROINIT, m_iCurItem * sizeof(OBJ_INSTANCE_RECORD))))
    {
        hr = SetErrCode(&hr, E_OUTOFMEMORY);
exit0:
        if (FAILED(hr))
        {
            _GLOBALUNLOCK(m_hMemory);
            _GLOBALFREE(m_hMemory);
            m_hMemory = NULL;
            m_pObjects = NULL;
        }
        return hr;
    }
    objCache.pRecords = (POBJ_INSTANCE_RECORD)_GLOBALLOCK(objCache.hRecords);
    ITASSERT(objCache.pRecords);

    // Read in the stream index table
    if (FAILED(hr = pStream->Read(objCache.pRecords,
        m_iCurItem * sizeof(OBJ_INSTANCE_RECORD), NULL)))
    {
exit1:
        _GLOBALUNLOCK(objCache.hRecords);
        _GLOBALFREE(objCache.hRecords);
        goto exit0;
    }

    // Proces each object in the table
    POBJINSTMEMREC pObjArray = m_pObjects;
    for (DWORD loop = 0; loop < m_iCurItem; loop++, pObjArray++)
    {
        LARGE_INTEGER liTemp;
        liTemp.QuadPart = objCache.pRecords[loop].dwOffset;
        if (FAILED(hr = pStream->Seek(liTemp, STREAM_SEEK_SET, NULL)))
            goto exit1;

        pStream->Read(&pObjArray->clsid, sizeof(CLSID), NULL);

        // Create COM Object
        hr = CoCreateInstance (pObjArray->clsid, NULL,
            CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&pObjArray->pUnknown);
        if (SUCCEEDED(hr))
        {
            // Check for IPersistStreamInit interface
            IPersistStreamInit *pPersist;
            if (SUCCEEDED(hr = pObjArray->pUnknown->QueryInterface
                (IID_IPersistStreamInit, (void**)&pPersist)))
            {
                // Read persistance data
                if (FAILED(hr = pPersist->Load(pStream)))
				{
                    pObjArray->pUnknown->Release();
                    pObjArray->pUnknown = NULL;
				}

				pPersist->Release();
            }
        }
    }

    m_fIsDirty = FALSE;
    hr = S_OK;
    goto exit1;
} /* CObjectInstHandler::Load */


inline STDMETHODIMP CObjectInstHandler::IsDirty(void)
{
    return (m_fIsDirty ? S_OK : S_FALSE);
} /* IsDirty */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\local\itlocal.cpp ===
// ITLOCAL.CPP : Implementation of DLL Exports.

#include <atlinc.h>    // precompiled header
#include <initguid.h>

// MediaView (InfoTech) includes
#include <mvopsys.h>
#include <_mvutil.h>
#include <groups.h>
#include <wwheel.h>  
#include <stdbrkr.h>

#include "itgroup.h"
#include "itww.h"
#include "itdb.h"
#include "itquery.h"
#include "itcat.h"
#include "itrs.h"
#include "itsortid.h"
#include "itwbrkid.h"

#include "wwimp.h"
#include "dbimp.h"
#include "catalog.h"
#include "indeximp.h"
#include "groupimp.h"
#include "rsimp.h"
#include "queryimp.h"
#include "syssrt.h"
#include "engstem.h"

// The following includes are needed to support runtime wordwheel merging.
#include "itpropl.h"
#include "itcc.h"
#include "prop.h"
#include "plist.h"  
#include "wwumain.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_IITWordWheelLocal, CITWordWheelLocal)
	OBJECT_ENTRY(CLSID_IITDatabaseLocal, CITDatabaseLocal)
	OBJECT_ENTRY(CLSID_IITIndexLocal, CITIndexLocal)
	OBJECT_ENTRY(CLSID_IITCatalogLocal, CITCatalogLocal)
    OBJECT_ENTRY(CLSID_IITGroupLocal, CITGroupLocal) // support for groups
    OBJECT_ENTRY(CLSID_IITGroupArrayLocal, CITGroupArrayLocal) // support for groups
    OBJECT_ENTRY(CLSID_IITResultSet, CITResultSet)
	OBJECT_ENTRY(CLSID_IITQuery, CITQuery)
	OBJECT_ENTRY(CLSID_ITSysSort, CITSysSort)
	OBJECT_ENTRY(CLSID_ITStdBreaker, CITStdBreaker)
	OBJECT_ENTRY(CLSID_ITEngStemmer, CITEngStemmer)
    OBJECT_ENTRY(CLSID_IITPropList, CITPropList) // for runtime wordwheel merging
    OBJECT_ENTRY(CLSID_IITWordWheelUpdate, CITWordWheelUpdate) // for runtime wordwheel merging
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
#ifdef _DEBUG
		MakeGlobalPool();
#endif
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
		_Module.Term();
#ifdef _DEBUG
		FreeGlobalPool();
#endif

    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

STDAPI DllRegisterServer(void)
{
	return _Module.RegisterServer(FALSE);
}

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\local\objmngr.h ===
// OBJMNGR.H:  Definition of help object manager

#ifndef __OBJMNGR_H__
#define __OBJMNGR_H__

#include <windows.h>

#define OBJINST_BASE        10
#define OBJINST_INCREMENT   10

typedef struct tagObjInstMemRec
{
    IUnknown *pUnknown;
    CLSID clsid;
} OBJINSTMEMREC, *POBJINSTMEMREC;

class CObjectInstHandler
{
public:
    CObjectInstHandler();
    ~CObjectInstHandler();

	STDMETHOD(AddObject)(REFCLSID clsid, DWORD *pdwObjInstance);
	STDMETHOD(GetObject)(DWORD dwObjInstance, REFIID riid, void **ppv);
	STDMETHOD(Close)(void);

    // Persistance Methods - IPersistStreamInit
	STDMETHOD(Load)(LPSTREAM pStm);
	STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);
	STDMETHOD(InitNew)(void);
	STDMETHOD(IsDirty)(void);


private:
    POBJINSTMEMREC m_pObjects;
    DWORD m_iMaxItem, m_iCurItem;
    HANDLE m_hMemory;
    BOOL m_fInitNew, m_fIsDirty;;
};

typedef struct tagObjInstRecord
{
    DWORD dwOffset, dwSize;
} OBJ_INSTANCE_RECORD, *POBJ_INSTANCE_RECORD;

typedef struct tagObjInstHeader
{
    DWORD dwVersion;
    DWORD dwEntries;
}OBJ_INSTANCE_HEADER, *POBJ_INSTANCE_HEADER;

typedef struct tagObjInstCache
{
    struct tagObjInstHeader Header;
    HANDLE hRecords;
    struct tagObjInstRecord *pRecords;
} OBJ_INSTANCE_CACHE, *POBJ_INSTANCE_CACHE;

#endif  // __OBJMNGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\local\wwimp.h ===
// WWIMP.H:  Definition of CITWordWheel

#ifndef __WWIMP_H__
#define __WWIMP_H__

#include "verinfo.h"


class CITWordWheelLocal : 
	public IITWordWheel,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CITWordWheelLocal,&CLSID_IITWordWheelLocal>
{
public:
	CITWordWheelLocal() : m_hWheel(NULL), m_pSubStorage(NULL), 
		                  m_cEntries(0), m_pCatalog(NULL), m_pIITGroup(NULL),
                          m_hScratchBuffer(NULL), m_cbScratchBuffer(0) {}

	~CITWordWheelLocal() { if (m_hWheel) Close(); }

BEGIN_COM_MAP(CITWordWheelLocal)
	COM_INTERFACE_ENTRY(IITWordWheel)
END_COM_MAP()

DECLARE_REGISTRY(CLSID_IITWordWheelLocal, "ITIR.LocalWordWheel.4", "ITIR.LocalWordWheel", 0, THREADFLAGS_BOTH )

// ITWordWheel methods go here
public:
	
	STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker, DWORD dwFlags=0L);
	STDMETHOD(Close)(void);

	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid);
	STDMETHOD(GetSorterInstance)(DWORD *pdwObjInstance);

	STDMETHOD(Count)(LONG *pcEntries);

	STDMETHOD(Lookup)(LONG lEntry, LPVOID lpvKeyBuf, DWORD cbKeyBuf);
	STDMETHOD(Lookup)(LONG lEntry, IITResultSet* lpITResult, LONG cEntries);
	STDMETHOD(Lookup)(LPCVOID lpcvPrefix, BOOL fExactMatch, LONG *plEntry);

	STDMETHOD(SetGroup)(IITGroup* pIITGroup);
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup);

	STDMETHOD(GetDataCount)(LONG lEntry, DWORD *pdwCount);
	STDMETHOD(GetData)(LONG lEntry, IITResultSet* lpITResult);
	STDMETHOD(GetDataColumns)(IITResultSet* pRS);

// Data members
private:
	HWHEEL  m_hWheel;			// Word wheel handle
    IStorage* m_pSubStorage;	// Substorage containing WW
	LONG m_cEntries, m_cMaxEntries;
	IITCatalog* m_pCatalog;		// The catalog
	HANDLE m_hScratchBuffer;    // Scratch buffer
    DWORD m_cbScratchBuffer;    // Byte count for scratch buffer
    IITGroup* m_pIITGroup;		// Group filter
    _ThreadModel::AutoCriticalSection m_cs;      // Critical section obj.
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\local\syssrt.h ===
// SYSSRT.H:  Definition of CITSysSort sort object implementation.

#ifndef __SYSSRT_H__
#define __SYSSRT_H__

#include "verinfo.h"


#define VERSION_SYSSORT		(MAKELONG(MAKEWORD(0, rapFile), MAKEWORD(rmmFile, rmjFile)))


// Sort control structure that contains all the information that can
// vary how keys are compared.
typedef struct _srtctl
{
	DWORD	dwCodePageID;
	LCID	lcid;
	DWORD	dwKeyType;
	DWORD	grfSortFlags;
} SRTCTL;


class CITSysSort : 
	public IITSortKey,
	public IITSortKeyConfig,
	public IPersistStreamInit,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CITSysSort,&CLSID_ITSysSort>
{
public:
    CITSysSort();
	virtual ~CITSysSort();


BEGIN_COM_MAP(CITSysSort)
	COM_INTERFACE_ENTRY(IITSortKey)
	COM_INTERFACE_ENTRY(IITSortKeyConfig)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
END_COM_MAP()

DECLARE_REGISTRY(CLSID_ITSysSort, "ITIR.SystemSort.4", "ITIR.SystemSort", 0, THREADFLAGS_BOTH )

	// IITSortKey methods
	STDMETHOD(GetSize)(LPCVOID lpcvKey, DWORD *pcbSize);
	STDMETHOD(Compare)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						LONG *plResult, DWORD *pgrfReason);
	STDMETHOD(IsRelated)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						 DWORD dwKeyRelation, DWORD *pgrfReason);
	STDMETHOD(Convert)(DWORD dwKeyTypeIn, LPCVOID lpcvKeyIn,
						DWORD dwKeyTypeOut, LPVOID lpvKeyOut,
						DWORD *pcbSizeOut);
	STDMETHOD(ResolveDuplicates)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						LPCVOID lpvKeyOut, DWORD *pcbSizeOut);

	// IITSortKeyConfig methods
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid);
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid);
	STDMETHOD(SetKeyType)(DWORD dwKeyType);
	STDMETHOD(GetKeyType)(DWORD *pdwKeyType);
	STDMETHOD(SetControlInfo)(DWORD grfSortFlags, DWORD dwReserved);
	STDMETHOD(GetControlInfo)(DWORD *pgrfSortFlags, DWORD *pdwReserved);
	STDMETHOD(LoadExternalSortData)(IStream *pStream, DWORD dwExtDataType);
	
	// IPersistStreamInit methods
	STDMETHOD(GetClassID)(CLSID *pclsid);
	STDMETHOD(IsDirty)(void);
	STDMETHOD(Load)(IStream *pStream);
	STDMETHOD(Save)(IStream *pStream, BOOL fClearDirty);
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSizeMax);
	STDMETHOD(InitNew)(void);

private:
	// Private methods
	void	Close(void);
	HRESULT	ReallocBuffer(HGLOBAL *phmemBuf, DWORD *cbBufCur, DWORD cbBufNew);
	HRESULT CompareSz(LPCVOID lpvSz1, LONG cch1, LPCVOID lpvSz2, LONG cch2,
												LONG *plResult, BOOL fUnicode);

	// Private data members
	BOOL	m_fInitialized;
	BOOL	m_fDirty;
	BOOL	m_fWinNT;
	SRTCTL	m_srtctl;
	HGLOBAL	m_hmemAnsi1, m_hmemAnsi2;
	DWORD	m_cbBufAnsi1Cur, m_cbBufAnsi2Cur;
    _ThreadModel::AutoCriticalSection m_cs;      // Critical section obj.
};


// Initial size of Ansi string buffers.
#define	cbAnsiBufInit	256


#endif	// __SYSSRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\local\wwimp.cpp ===
/*************************************************************************
*  @doc SHROOM EXTERNAL API                                              *
*																		 *
*  WWIMP.CPP                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1997                              *
*  All Rights reserved.                                                  *
*                                                                        *
*  This file contains CITWordWheelLocal, the local implementation        *
*  of IITWordWheel				                                         *
*																	     *
**************************************************************************
*                                                                        *
*  Written By   : Erin Foxford                                           *
*  Current Owner: erinfox                                                *
*                                                                        *
*
* TODO TODO TODO: Replace the blind use of critical sections with a
* better way of ensuring thread-safeness while preserving performance.
* But for now, in the interest of coding time, we just make sure the 
* code is thread-safe.
*
**************************************************************************/
#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif


#include <atlinc.h>	    // includes for ATL. 

// MediaView (InfoTech) includes
#include <groups.h>
#include <wwheel.h>  

#include "itcat.h"		// catalog
#include "itcc.h"		// needed for STDPROP_SORTKEY def.
#include "ITPropl.h"	// property list
#include "itrs.h"		// result set
#include "itquery.h"    // query and index
#include <ccfiles.h>

#include "ITDB.h"
#include "DBImp.h"
#include "itww.h"
#include "WWImp.h"

#include "itgroup.h"

										
/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | Open |
 *     Opens a word wheel
 * @parm IITDatabase* | lpITDB | Pointer to database object
 * @parm LPCWSTR | lpszMoniker | Name of word wheel
 * @parm DWORD | dwFlags | One or more of the following values:
 *		@flag ITWW_OPEN_CONNECT | If the wordwheel resides on a remote machine,
 * connect to the machine during this call to retrieve initialization data.  Otherwise
 * the connection is delayed until the first API call which requires this data.
 *
 * @rvalue E_INVALIDARG | IITDatabase* or lpszMoniker was NULL
 * @rvalue E_ALREADYOPEN | Word wheel is already open 
 * @rvalue E_GETLASTERROR | An I/O or transport operation failed.  Call the Win32
 * GetLastError function to retrieve the error code.
 * @rvalue STG_E_* | Any of the IStorage errors that could while opening a storage
 * @rvalue S_OK | The word wheel was successfully opened
 *
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::Open(IITDatabase* lpITDB, LPCWSTR lpszMoniker, DWORD dwFlags)
{
	HRESULT hr;
    LPWSTR szStorageName;


	if (NULL == lpITDB || NULL == lpszMoniker)
		return E_POINTER;

    // TODO: Report error or close word wheel if it's already open ?
    if (m_hWheel || m_pSubStorage)
        return E_ALREADYOPEN;

	m_cs.Lock();

    // Open substorage and pass to word wheel
    szStorageName = new WCHAR [CCH_MAX_OBJ_NAME + CCH_MAX_OBJ_STORAGE + 1];
    WSTRCPY (szStorageName, SZ_WW_STORAGE);
    if (WSTRLEN (lpszMoniker) <= CCH_MAX_OBJ_NAME)
        WSTRCAT (szStorageName, lpszMoniker);
    else
    {
        MEMCPY (szStorageName, lpszMoniker, CCH_MAX_OBJ_NAME * sizeof (WCHAR));
        szStorageName [CCH_MAX_OBJ_NAME + CCH_MAX_OBJ_STORAGE] = (WCHAR)'\0';
    }

	if (SUCCEEDED(hr = lpITDB->GetObjectPersistence(szStorageName,
											IITDB_OBJINST_NULL,
											(LPVOID *) &m_pSubStorage, FALSE)))
	{
		// Open word wheel
		m_hWheel = WordWheelOpen(lpITDB, m_pSubStorage, &hr);
	}

    delete szStorageName;

    if (m_hWheel == NULL || FAILED(hr))
	{
exit0:
		if (m_pSubStorage != NULL)
		{
			m_pSubStorage->Release();
			m_pSubStorage = NULL;
		}

		m_cs.Unlock();
		return hr;
	}

    // NOTE:
    // If the client wants to load a group into the word wheel for filtering,
    // s/he must first call the "Open" method of ITWordWheel, then create
    // a group (these two steps may be interchanged), then call the "SetGroup"
    // method of ITWordWheel.

	// Store count
	m_cEntries = m_cMaxEntries = WordWheelLength(m_hWheel, &hr);


	// Open catalog object - we only need one instance
	hr = CoCreateInstance(CLSID_IITCatalogLocal, NULL, CLSCTX_INPROC_SERVER, IID_IITCatalog, 
		                  (VOID **) &m_pCatalog);

	if (FAILED(hr))
		goto exit0;

	// If we can't open the catalog hat's OK because we can run
	// without it.
	if (FAILED(m_pCatalog->Open(lpITDB)))
	{
		m_pCatalog->Release();
		m_pCatalog = NULL;
	}

	m_cs.Unlock();	
	return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | Close |
 *     Closes a word wheel
 *
 * @rvalue S_OK | The word wheel was successfully closed     
 *
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::Close(void)
{
	m_cs.Lock();

    if (m_hWheel)
    {
        WordWheelClose(m_hWheel);
        m_hWheel = NULL;
    }
	else
		return E_NOTINIT;

	if (m_pSubStorage)
	{
		m_pSubStorage->Release();
		m_pSubStorage = NULL;
	}

	if (m_pCatalog)
	{
		m_pCatalog->Close();
		m_pCatalog->Release();
		m_pCatalog = NULL;
	}

	if (m_hScratchBuffer)
    {
		_GLOBALFREE(m_hScratchBuffer);
		m_hScratchBuffer = NULL;
	}
    m_cbScratchBuffer = 0;

	if (m_pIITGroup != NULL)
	{
		m_pIITGroup->Release();
		m_pIITGroup = NULL;
	}

	m_cs.Unlock();

    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | GetLocaleInfo |
 *     Gets locale info that the word wheel was built with.
 * @parm DWORD* | pdwCodePageID | On exit, pointer to code page ID.
 * @parm LCID* | plcid | On exit, pointer to locale ID.
 *
 * @rvalue S_OK | The locale info was successfully retrieved.   
 *
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::GetLocaleInfo(DWORD *pdwCodePageID, LCID *plcid)
{
	HRESULT			hr = S_OK;
	PWHEEL			pwheel = NULL;

	if (pdwCodePageID == NULL || plcid == NULL)
		return (SetErrReturn(E_POINTER));

	if (m_hWheel == NULL)
		return (E_NOTOPEN);

	m_cs.Lock();

    // validate the parameters and lock down the structure
	if ((pwheel = (PWHEEL)_GLOBALLOCK(m_hWheel)) != NULL && 
		PWHEEL_OK(pwheel))
	{ 
		BTREE_PARAMS	btp;

		GetBtreeParams(pwheel->pInfo->hbt, &btp);
		*pdwCodePageID = btp.dwCodePageID;
		*plcid = btp.lcid;
	}
	else
		hr = E_UNEXPECTED;

	if (pwheel != NULL)   
	   _GLOBALUNLOCK(m_hWheel);

	m_cs.Unlock();
			
	return (hr);
}


/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | GetSorterInstance |
 *     Get the ID of the sorter instance being used by the
 *     word wheel
 *
 * @parm DWORD* | pdwObjInstance | Pointer to sorter instance ID
 *
 * @rvalue E_NOTOPEN | The word wheel has not been opened
 * @rvalue E_POINTER | pdwObjInstance was an invalid pointer
 * @rvalue S_OK | The sorter instance ID was successfully obtained   
 *
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::GetSorterInstance(DWORD *pdwObjInstance)
{
	HRESULT			hr = S_OK;
	PWHEEL			pwheel = NULL;

	if (m_hWheel == NULL)
		return (E_NOTOPEN);

	if (pdwObjInstance == NULL)
		return (E_POINTER);

	m_cs.Lock();

    // validate the parameters and lock down the structure
	if ((pwheel = (PWHEEL)_GLOBALLOCK(m_hWheel)) != NULL && 
		PWHEEL_OK(pwheel))
	{ 
		BTREE_PARAMS	btp;

		GetBtreeParams(pwheel->pInfo->hbt, &btp);
		*pdwObjInstance =
			(btp.rgchFormat[0] == KT_EXTSORT ? btp.dwExtSortInstID :
												IITDB_OBJINST_NULL);
	}
	else
		hr = E_UNEXPECTED;

	if (pwheel != NULL)   
	   _GLOBALUNLOCK(m_hWheel);

	m_cs.Unlock();
			
	return (hr);
}


/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | Count |
 *     Returns number of entries in word wheel through pcEntries
 *
 * @parm LONG* | pcEntries | Number of entries in word wheel
 *
 * @rvalue E_NOTOPEN | The word wheel has not been opened
 * @rvalue E_POINTER | pcEntries was an invalid pointer
 * @rvalue S_OK | The count was successfully returned   
 *
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::Count(LONG *pcEntries)
{
	if (NULL == m_hWheel)
		return E_NOTOPEN;

	if (NULL == pcEntries)
		return E_POINTER;

	*pcEntries = m_cEntries;
	return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | Lookup |
 *     Looks up an entry and returns contents in a buffer
 *
 * @parm LONG | lEntry | Entry to look up
 * @parm LPVOID | lpvKeyBuf | Buffer to return entry 
 * @parm DWORD | cbKeyBuf | Buffer size in number of bytes
 *
 * @rvalue E_OUTOFRANGE | Entry number is out of range
 * @rvalue S_OK | The word wheel entry was successfully returned   
 *
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::Lookup(LONG lEntry, LPVOID lpvKeyBuf, DWORD cbKeyBuf)
{
	if (NULL == m_hWheel)
		return E_NOTOPEN;

	if (NULL == lpvKeyBuf)
		return E_POINTER;

	m_cs.Lock();

	HRESULT hr = WordWheelLookup(m_hWheel, lEntry, lpvKeyBuf, cbKeyBuf);

	m_cs.Unlock();
    return hr;
}


/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | Lookup |
 *     Looks up an entry and returns contents as a result set
 *
 * @parm LONG | lEntry | Entry to look up
 * @parm IITResultList* | lpITResult | Pointer to result set to fill
 * @parm LONG | cEntries | Number of entries to fill result set
 *
 * @rvalue E_INVALIDARG | Invalid argument was passed (cEntries <lt>= 0 or lpITResult
 *          is NULL)
 * @rvalue E_OUTOFRANGE | The entry does not exist in the word wheel
 * @rvalue S_OK | The word wheel entry was successfully returned   
 *
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::Lookup(LONG lEntry, IITResultSet* lpITResult, LONG cEntries)
{

    PWHEEL  pWheel  = NULL;        // pointer to locked-down structure
	PWHEELINFO  pInfo   = NULL;
	BYTE Key[ITWW_CBKEY_MAX];
	BYTE DataBuffer[8];
	DWORD dwOffset;   // Offset into data file
	DWORD cbRead;
	LPBYTE pPropBuffer = NULL;         
	LARGE_INTEGER dlibMove;   // For seeking
	ULARGE_INTEGER libNewPos;
	IITSortKey	*pITSortKey = NULL;

	LONG iRow;
	LONG iColumn;
	LONG iEntry;  // Loop index
	LONG lMaxEntry;

	HRESULT hr;

	if (NULL == m_hWheel)
		return E_NOTOPEN;

	if (NULL == lpITResult)
		return E_POINTER;

	m_cs.Lock();

    // validate the parameters and lock down the structure
	if ((pWheel = (PWHEEL)_GLOBALLOCK(m_hWheel))==NULL ||
		!PWHEEL_OK(pWheel))
	{ 
		hr = E_INVALIDSTATE;
        warning_abort;
	}

	pInfo = pWheel->pInfo;

	// if result set is empty, add columns based on header
	lpITResult->GetColumnCount(iColumn);
	if (0 == iColumn)
	{
		lpITResult->Add(STDPROP_SORTKEY, (LPWSTR) NULL, PRIORITY_NORMAL);
		if (pInfo->pKeyHdr)
			lpITResult->Add(pInfo->pKeyHdr);
	}

	// Check for a btree key type that the word wheel supports and set
	// pITSortKey.
	if (FAILED(hr = CheckWordWheelKeyType(pInfo->hbt, &pITSortKey)))
		assert_abort;

	lMaxEntry = lEntry + cEntries;

	for (iEntry = lEntry; iEntry < lMaxEntry ; iEntry++)
	{
		DWORD cbKeyData = 0L;  // Amount of data in key property

		// exceeded entries in word wheel
		if (iEntry >= m_cEntries)
			break;

		// If there's a filter, let's get the proper entry in the WW.
        if (!m_pIITGroup)
            lEntry = iEntry;
        else
        {
            hr = m_pIITGroup->FindTopicNum((DWORD)iEntry, (DWORD*)(&lEntry));
            if (FAILED(hr))
                goto cleanup;
            else if (S_FALSE == hr) // not found
                break;
        }

		// lookup the entry in the map file 
		hr = RcKeyFromIndexHbt(pInfo->hbt, pInfo->hmapbt, 
								(KEY)Key, ITWW_CBKEY_MAX, lEntry);
		if (FAILED(hr))
			goto cleanup;

		// lookup data associated w/ key
		hr = RcLookupByKey(pInfo->hbt, (KEY)Key, NULL, DataBuffer);
		if (FAILED(hr))
			goto cleanup;

		dwOffset = *(LPDWORD) &DataBuffer[4];

		// get data from data file

		// seek to get offset into data file where key
		// properties reside 
		dlibMove.QuadPart = dwOffset;
		hr = (pInfo->hf)->Seek(dlibMove, STREAM_SEEK_SET, &libNewPos);
		if (FAILED(hr))
			goto cleanup;

		// read in amount of key data
		hr = (pInfo->hf)->Read(&cbKeyData, sizeof(DWORD), &cbRead);
		if (FAILED(hr))
			goto cleanup;

		// get current last row so we can set the data there
		lpITResult->GetRowCount(iRow);

		// Set key. Note that GetColumnFromPropID might return error
		// if caller didn't specify STDPROP_SORTKEY. 
		if (SUCCEEDED(hr = lpITResult->GetColumnFromPropID(STDPROP_SORTKEY, iColumn)))
			lpITResult->Set(iRow, iColumn, (LPVOID) Key,
								CbKeyWordWheel((LPVOID) Key, pITSortKey));

		if (cbKeyData)
		{
			// read the data
            hr = ReallocBufferHmem
                (&m_hScratchBuffer, &m_cbScratchBuffer, cbKeyData);
            if (FAILED(hr))
                goto cleanup;

            if(NULL == (pPropBuffer = (BYTE *)_GLOBALLOCK(m_hScratchBuffer)))
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

			hr = (pInfo->hf)->Read(pPropBuffer, cbKeyData, &cbRead);

		    // Even if Set(iRow...) fails, set other properties, if there are any
		    // TODO: This function may need optimization
			lpITResult->Set(iRow, pInfo->pKeyHdr, pPropBuffer);

            _GLOBALUNLOCK(m_hScratchBuffer);
        }
	}
	
cleanup:
	if (NULL != pWheel)   
	   _GLOBALUNLOCK(m_hWheel);

	if (pITSortKey != NULL)
		pITSortKey->Release();

	m_cs.Unlock();		
	return hr;
}


/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | Lookup |
 *     Returns word wheel entry closest to given prefix
 *
 * @parm LPCVOID | lpcvPrefix | Prefix to look up
 * @parm BOOL | fExactMatch | TRUE if prefix must have exact match; FALSE otherwise
 * @parm LONG* | plEntry | Entry into word wheel with closest match
 *
 * @rvalue E_NOTEXIST | The prefix doesn't exist; returned when fExactMatch is set
 * to TRUE and there is no match.
 * @rvalue E_POINTER | Either lpcvPrefix or pcEntries was an invalid pointer
 * @rvalue S_OK | The entry was successfully returned   
 *
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::Lookup(LPCVOID lpcvPrefix, BOOL fExactMatch,
                                       LONG *plEntry)
{
    HRESULT hr;
    
	if (NULL == m_hWheel)
		return E_NOTOPEN;

	if (NULL == lpcvPrefix || NULL == plEntry)
		return E_POINTER;

	m_cs.Lock();
	
	*plEntry = WordWheelPrefix(m_hWheel, lpcvPrefix, fExactMatch, &hr);

	m_cs.Unlock();
	return hr;
}


/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | GetDataCount |
 *     Returns number of occurrences associated with given word wheel entry
 *
 * @parm LONG | lEntry | Entry into word wheel
 * @parm DWORD* | pdwCount | Number of occurrences
 *
 * @rvalue E_NOTEXIST | Entry number is not in the valid range
 * @rvalue S_OK | The entry was successfully returned   
 *
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::GetDataCount(LONG lEntry, DWORD *pdwCount)
{
	HRESULT hr = S_OK;
	BYTE Key[ITWW_CBKEY_MAX];
	BYTE DataBuffer[8];

	if (NULL == m_hWheel)
		return E_NOTOPEN;

	if (NULL == pdwCount)
		return E_POINTER;

	m_cs.Lock();

	PWHEEL pWheel = (PWHEEL)_GLOBALLOCK(m_hWheel);
	PWHEELINFO pInfo = pWheel->pInfo;

    if (pWheel->pIITGroup)
    {
        hr = (pWheel->pIITGroup)->FindTopicNum((DWORD)lEntry, (DWORD*)(&lEntry));
        if (FAILED(hr))
            goto cleanup;
    }

	// lookup the entry in the map file 
	hr = RcKeyFromIndexHbt(pInfo->hbt, pInfo->hmapbt, 
							(KEY)Key, ITWW_CBKEY_MAX, lEntry);
	if (FAILED(hr))
		goto cleanup;

	// lookup some data (count) associated w/ key
	hr = RcLookupByKey(pInfo->hbt, (KEY)Key, NULL, DataBuffer);
	if (FAILED(hr))
		goto cleanup;

	*pdwCount = *(LPDWORD) DataBuffer;

cleanup:
	if (NULL != pWheel) 
		_GLOBALUNLOCK(m_hWheel);
	
	m_cs.Unlock();
	return hr;
}


/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | GetData |
 *     Fills given result set with rows corresponding to user data
 *
 * @parm LONG | lEntry | Entry
 * @parm IITResultSet* | lpITResult | Pointer to result set object to fill
 *
 * @rvalue E_INVALIDARG | Result set pointer cannot be NULL
 * @rvalue E_NOTEXIST | Entry number is not in the valid range
 * @rvalue E_OUTOFMEMORY | Memory allocation failed
 * @rvalue S_OK | The entry was successfully returned   
 *
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::GetData(LONG lEntry, IITResultSet* lpITResult)
{
	BYTE Key[ITWW_CBKEY_MAX];
	BYTE DataBuffer[8];
	DWORD dwCount;       // Number of occurrences
	DWORD dwOffset;      // Offset into data file

	LARGE_INTEGER dlibMove;   // For seeking
	ULARGE_INTEGER libNewPos;
	DWORD cbPropSize;
	LPBYTE pPropBuffer = NULL;         
	DWORD cbRead;
	LONG iColumn;
	DWORD iRow;   // Loop index

	HRESULT hr = S_OK;

	if (NULL == m_hWheel)
		return E_NOTOPEN;

	if (NULL == lpITResult)
		return E_POINTER;

	m_cs.Lock();

	PWHEEL pWheel = (PWHEEL)_GLOBALLOCK(m_hWheel);
	PWHEELINFO pInfo = pWheel->pInfo;

	// if result set is empty, add columns based on header
	// also add columns passed on catalog header
	lpITResult->GetColumnCount(iColumn);
	if (0 == iColumn)
	{
		lpITResult->Add(pInfo->pOccHdr);
		if (m_pCatalog)
			m_pCatalog->GetColumns(lpITResult);
	}

    if (pWheel->pIITGroup)
    {
        hr = (pWheel->pIITGroup)->FindTopicNum((DWORD)lEntry, (DWORD*)(&lEntry));
        if (FAILED(hr))
            goto cleanup;
    }

	// lookup the entry in the map file 
	hr = RcKeyFromIndexHbt(pInfo->hbt, pInfo->hmapbt, 
							(KEY)Key, ITWW_CBKEY_MAX, lEntry);
	if (FAILED(hr))
		goto cleanup;

	// lookup some data (count and offset into data file) associated w/ key
	hr = RcLookupByKey(pInfo->hbt, (KEY)Key, NULL, DataBuffer);
	if (FAILED(hr))
		goto cleanup;

	dwCount = *(LPDWORD) DataBuffer;
	dwOffset = *(LPDWORD) &DataBuffer[4];

	// get data from data file

	// seek to get offset into data file where key
	// properties reside and find out how much to skip
	dlibMove.QuadPart = dwOffset;
	hr = (pInfo->hf)->Seek(dlibMove, STREAM_SEEK_SET, &libNewPos);
	if (FAILED(hr))
		goto cleanup;

	DWORD dwDataOffset;
	hr = (pInfo->hf)->Read(&dwDataOffset, sizeof(DWORD), &cbRead);
	if (FAILED(hr))
		goto cleanup;

	// Seek to where data properties start
	dlibMove.QuadPart = dwDataOffset;
	hr = (pInfo->hf)->Seek(dlibMove, STREAM_SEEK_CUR, &libNewPos);
	if (FAILED(hr))
		goto cleanup;

	// Loop over all properties - get size, then read in property info into
	// memory block
	for (iRow = 0; iRow < dwCount; iRow++)
	{
		hr = (pInfo->hf)->Read(&cbPropSize, sizeof(DWORD), &cbRead);
		if (FAILED(hr))
			goto cleanup;

        hr = ReallocBufferHmem
            (&m_hScratchBuffer, &m_cbScratchBuffer, cbPropSize);
        if (FAILED(hr))
            goto cleanup;

        if(NULL == (pPropBuffer = (BYTE *)_GLOBALLOCK(m_hScratchBuffer)))
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

		hr = (pInfo->hf)->Read(pPropBuffer, cbPropSize, &cbRead);
        if(SUCCEEDED(hr))
    		// pass header and data to append to result set
		    // TODO: This function may need optimization
		    hr = lpITResult->Append(pInfo->pOccHdr, pPropBuffer);

        _GLOBALUNLOCK(m_hScratchBuffer);

        if (FAILED(hr))
			goto cleanup;
	}

	// Then fill result set w/ any properties that might be in catalog
	if (m_pCatalog)
		hr = m_pCatalog->Lookup(lpITResult);
//	if (S_FALSE == hr)
		hr = S_OK;         // don't report S_FALSE
		
cleanup:
	if (NULL != pWheel) 
		_GLOBALUNLOCK(m_hWheel);

	m_cs.Unlock();
	return hr;
}


/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | GetDataColumns |
 *     Adds columns to given result set for all data properties
 *
 * @parm IITResultSet* | pRS | Pointer to result set
 *
 * @rvalue S_OK | The columns were successfully added   
 *
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::GetDataColumns(IITResultSet* pRS)
{
	PWHEEL pWheel = (PWHEEL)_GLOBALLOCK(m_hWheel);
	PWHEELINFO pInfo = pWheel->pInfo;

	if (pRS == NULL)
		return E_POINTER;

	pRS->Add(pInfo->pOccHdr);

	if (NULL != pWheel) 
		_GLOBALUNLOCK(m_hWheel);

	return S_OK;
}



/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | SetGroup |
 *     Associates a group with a word wheel, used for filtering.
 *
 * @parm IITGroup* | pIITGroup | pointer to a pre-loaded group interface
 *
 * @rvalue S_OK | interface pointer not NULL--successfully assigned
 * @rvalue E_INVALIDARG | received a NULL pointer for the interface
 * @rvalue E_NOTOPEN | the word wheel was not found to be open
 * @rvalue E_OUTOFMEMORY | unable to lock the wordwheel's memory
 * @rvalue E_BADFILTERSIZE | the filter group and wordwheel have different sizes
 *
 * @comm This method does not verify that the group behind the
 *          interface has been loaded, or that the group is not empty.
 *          If the client assigns the group interface pointer any random
 *          positive value other than zero, without properly instantiating
 *          the group object, this method returns S_OK.
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::SetGroup(IITGroup* pIITGroup)
{
    if (NULL == m_hWheel)
		return E_NOTOPEN;

    m_cs.Lock();

    PWHEEL pWheel;
    if (NULL == (pWheel = (PWHEEL)_GLOBALLOCK(m_hWheel)))
	{
	    m_cs.Unlock();
        return E_OUTOFMEMORY;
	}

    // NULL is a valid argument--client is attempting to free the group
    if (pIITGroup)
    {
        // We need to access the group's maxItemAllGroup and lcItem fields.
        // We can make two function calls, or locally store the output of a single call.
        _LPGROUP localImage = (_LPGROUP)(pIITGroup->GetLocalImageOfGroup());

        if ((DWORD)(m_cMaxEntries) != localImage->maxItemAllGroup)
        {
            _GLOBALUNLOCK(m_hWheel);
            m_cs.Unlock();
            return E_BADFILTERSIZE;
        }
        pWheel->lNumEntries = m_cEntries = (LONG)(localImage->lcItem);
    }
    else
    {
        pWheel->lNumEntries = m_cEntries = m_cMaxEntries;
    }

    if (pIITGroup)
        pIITGroup->AddRef();
	if (m_pIITGroup != NULL)
		m_pIITGroup->Release();

    pWheel->pIITGroup = m_pIITGroup = pIITGroup;		

    _GLOBALUNLOCK(m_hWheel);
	m_cs.Unlock();
    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITWordWheel | GetGroup |
 *     Retrieves the group associated with the word wheel. 
 *
 * @parm IITGroup** | ppIITGroup | (out) Pointer to the group interface.
 *
 * @rvalue S_OK | private member variable m_pIITGroup != NULL
 * @rvalue E_NOTINIT | private member variable m_pIITGroup == NULL
 * @rvalue E_BADPARAM | ppIITGroup was NULL
 ********************************************************************/
STDMETHODIMP CITWordWheelLocal::GetGroup(IITGroup** ppiitGroup)
{
	if (NULL == ppiitGroup)
		return E_POINTER;

    if (m_pIITGroup == NULL)
		return E_NOTINIT;

	(*ppiitGroup = m_pIITGroup)->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\wwbuild\wwumain.cpp ===
// wwumain.cpp:  Implementation of wordwheel update interface
#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif


#include <windows.h>
#include <itcc.h>
#include <iterror.h>
#include <ccfiles.h>
#include <atlinc.h>
#include <mvopsys.h>
#include <_mvutil.h>
#include <itdb.h>
#include <itsortid.h>
#include "wwumain.h"

CITWordWheelUpdate::CITWordWheelUpdate()
{
    m_fInitialized = FALSE;
    m_piitskSortKey = NULL;
    m_pStorage = NULL;
}

CITWordWheelUpdate::~CITWordWheelUpdate()
{
    (void)Close();
} /* Destructor */


HRESULT CITWordWheelUpdate::Close(void)
{
    if (FALSE == m_fInitialized)
        return S_OK;

    if (m_hTempFile)
    {
        CloseHandle(m_hTempFile);
        DeleteFile(m_szTempFile);
        m_hTempFile = NULL;
    }

    if (m_hGlobalPropTempFile)
    {
        CloseHandle(m_hGlobalPropTempFile);
        DeleteFile(m_szGlobalPropTempFile);
        m_hGlobalPropTempFile = NULL;
    }

    if (m_lpbOccHeader)
        delete m_lpbOccHeader;
    if (m_lpbKeyHeader)
        delete m_lpbKeyHeader;

    if (m_pStorage)
    {
        m_pStorage->Release();
        m_pStorage = NULL;
    }

    if(m_piitskSortKey)
    {
        m_piitskSortKey->Release();
        m_piitskSortKey = NULL;
    }

    m_fInitialized = FALSE;

    return S_OK;
} /* Close */


STDMETHODIMP CITWordWheelUpdate::GetTypeString(LPWSTR pPrefix, DWORD *pLen)
{
    DWORD dwLen = (DWORD) WSTRLEN (SZ_WW_STORAGE) + 1;

    if (NULL == pPrefix)
    {
        *pLen = dwLen;
        return S_OK;
    }

    if (pLen && *pLen < dwLen)
    {
        *pLen = dwLen;
        return S_OK;
    }

    if (pLen)
        *pLen = dwLen;

    WSTRCPY (pPrefix, SZ_WW_STORAGE);
    return S_OK;
}

STDMETHODIMP CITWordWheelUpdate::SetConfigInfo
    (IITDatabase *piitdb, VARARG vaParams)
{
    return S_OK;
}

/********************************************************************
 * @method    HRESULT WINAPI | CITWordWheelUpdate | InitHelperInstance |
 * Creates and initiates a structure to allow for the creation of word wheels.
 * This method must be called before any others in this object.
 *
 * @rvalue E_FAIL | The object is already initialized or file create failed
 *
 * @xref <om.CancelUpdate>
 * @xref <om.CompleteUpdate>
 * @xref <om.SetEntry>
 *
 * @comm
 ********************************************************************/

STDMETHODIMP CITWordWheelUpdate::InitHelperInstance
	(DWORD dwHelperObjInstance,
    IITDatabase *pITDatabase,
    DWORD dwCodePage,
    LCID lcid,
    VARARG vaDword,
    VARARG vaString)
{
    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    HRESULT hr;

    // Get the Sorter Object
    if (FAILED(hr = pITDatabase->GetObject
        (dwHelperObjInstance, IID_IITSortKey, (void **)&m_piitskSortKey)))
        return hr;

    IITSortKeyConfig *pSortKeyConfig;
    if (FAILED(hr = pITDatabase->GetObject (dwHelperObjInstance,
        IID_IITSortKeyConfig, (void **)&pSortKeyConfig)))
        // This object doesn't support IITSortKeyConfig.
        return S_OK;

    // We should have at least 1 param (key type) specified
    if (!vaDword.dwArgc)
        SetErrCode(&hr, E_INVALIDARG);

    // Configure the sort key object
    if(SUCCEEDED(hr))
        hr = pSortKeyConfig->SetLocaleInfo(dwCodePage, lcid);
    
    if (SUCCEEDED(hr) || hr == E_NOTIMPL)
        hr = pSortKeyConfig->SetKeyType(*(LPDWORD)vaDword.Argv);

    if ((SUCCEEDED(hr) || hr == E_NOTIMPL)
        && vaDword.dwArgc >= 2)
        hr = pSortKeyConfig->SetControlInfo(*(LPDWORD)(vaDword.Argv + 1), 0);

    pSortKeyConfig->Release();
    
    if (SUCCEEDED(hr) || hr == E_NOTIMPL)
    {
        // Fill out BTREE structure
        MEMSET(&m_btParams, 0, sizeof (BTREE_PARAMS));
	    m_btParams.cbBlock = CBKWBLOCKSIZE;
	    m_btParams.bFlags = fFSReadWrite;

        m_btParams.dwCodePageID       = dwCodePage;
        m_btParams.lcid               = lcid;
        m_btParams.dwExtSortInstID    = dwHelperObjInstance;
        m_btParams.dwExtSortKeyType   = *(LPDWORD)(vaDword.Argv);

	    m_btParams.rgchFormat[0] = KT_EXTSORT;
	    m_btParams.rgchFormat[1] = '4';
	    m_btParams.rgchFormat[2] = '4';
	    m_btParams.rgchFormat[3] = '\0';
    }

    return (hr == E_NOTIMPL ? S_OK : hr);
} /* InitHelperInstance */


STDMETHODIMP CITWordWheelUpdate::SetEntry
   (LPCWSTR szDest, IITPropList *pPropList)
{

    HRESULT hr;
    CProperty KeyProp;
    DWORD dwWritten, dwSize;
    LPBYTE pHeader;
    DWORD cbHeader, *pMaxPropData;
	// UNDONE: fix this!!!!!!!!!!!!!!
    char pUserBuffer[4*1024]; // see COUNT_WWDATASIZE in wwbuild 

    if (FALSE == m_fInitialized || NULL == m_piitskSortKey)
        return SetErrReturn(E_NOTINIT);

    m_fIsDirty = TRUE;
    
    if (NULL == szDest)
        szDest = SZ_WWDEST_OCC;
	
    // Is this a global property list?
    if (!WSTRICMP(szDest, SZ_WWDEST_GLOBAL))
    {
        ULARGE_INTEGER ulSize;

        // Write to global temp file
        pPropList->GetSizeMax(&ulSize);
        if (ulSize.QuadPart > 4*1024)
            return SetErrReturn(E_OUTOFMEMORY);

        // Write property list
        pPropList->SaveToMem(pUserBuffer, ulSize.LowPart);
        WriteFile(m_hGlobalPropTempFile, 
            pUserBuffer, ulSize.LowPart, &dwWritten, NULL);
        if (ulSize.LowPart != dwWritten)
            return SetErrReturn(E_FILEWRITE);

        m_dwGlobalPropSize += ulSize.LowPart;
        return S_OK;
    }

    if (FAILED(hr = pPropList->Get(STDPROP_SORTKEY, KeyProp)))
        return SetErrReturn(E_NOKEYPROP);

    // Don't save the KEY in the property list
    pPropList->SetPersist(STDPROP_SORTKEY, FALSE);

    // Determine property destination
    char wcType;
    if (!WSTRICMP(szDest, SZ_WWDEST_KEY))
    {
        wcType = C_PROPDEST_KEY;
        // Is this the first entry?
        if (NULL == m_lpbKeyHeader)
        {
            pPropList->GetHeaderSize (m_cbKeyHeader);
            m_lpbKeyHeader = new BYTE[m_cbKeyHeader];
            pPropList->SaveHeader (m_lpbKeyHeader, m_cbKeyHeader);
        }
        pHeader = m_lpbKeyHeader;
        cbHeader = m_cbKeyHeader;
        pMaxPropData = &m_cbMaxKeyData;
    }
    else
    {
        wcType = C_PROPDEST_OCC;
        // Is this the first entry?
        if (NULL == m_lpbOccHeader)
        {
            pPropList->GetHeaderSize (m_cbOccHeader);
            m_lpbOccHeader = new BYTE[m_cbOccHeader];
            pPropList->SaveHeader (m_lpbOccHeader, m_cbOccHeader);
        }
        pHeader = m_lpbOccHeader;
        cbHeader = m_cbOccHeader;
        pMaxPropData = &m_cbMaxOccData;
    }

    pPropList->GetDataSize(pHeader, cbHeader, dwSize);
    if (dwSize > 4 * 1024)
        return SetErrReturn(E_OUTOFMEMORY);

    // Write key
    WriteFile(m_hTempFile, &KeyProp.cbData, sizeof (DWORD), &dwWritten, NULL);
    if (dwWritten != sizeof (DWORD))
        return SetErrReturn(E_FILEWRITE);
    WriteFile(m_hTempFile, KeyProp.lpvData, KeyProp.cbData, &dwWritten, NULL);
    if (dwWritten != KeyProp.cbData)
        return SetErrReturn(E_FILEWRITE);

    // Write Type char
    WriteFile(m_hTempFile, &wcType, sizeof (char), &dwWritten, NULL);
    if (dwWritten != sizeof (char))
        return SetErrReturn(E_FILEWRITE);

    // Write (tertiary) sort order value
    ++m_dwEntryCount;
    WriteFile(m_hTempFile, &m_dwEntryCount, sizeof (DWORD), &dwWritten, NULL);
    if (dwWritten != sizeof (DWORD))
        return SetErrReturn(E_FILEWRITE);

    // Write property list size
    WriteFile(m_hTempFile, &dwSize, sizeof (DWORD), &dwWritten, NULL);
    if (dwWritten != sizeof (DWORD))
        return SetErrReturn(E_FILEWRITE);

    // Write property list if it exists
    if (dwSize)
    {
        if (dwSize > *pMaxPropData)
            *pMaxPropData = dwSize;
        // Write out custom properties
        pPropList->SaveData(pHeader, cbHeader, pUserBuffer, dwSize);
        WriteFile(m_hTempFile, pUserBuffer, dwSize, &dwWritten, NULL);
        if (dwSize != dwWritten)
            return SetErrReturn(E_FILEWRITE);
    }
#if 0
    WriteFile(m_hTempFile, "\n", strlen("\n"), &dwWritten, NULL);
    if (STRLEN("\n") != dwWritten)
        return SetErrReturn(E_FILEWRITE);
#endif
	return S_OK;
} /* SetEntry */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\local\syssrt.cpp ===
/*************************************************************************
*  @doc SHROOM EXTERNAL API                                              *
*																		 *
*  SYSSRT.CPP                                                            *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1997                              *
*  All Rights reserved.                                                  *
*                                                                        *
*  This file contains the implementation of CITSysSort methods.	         *
*  CITSysSort is a pluggable sort object that uses the system's          *
*  CompareString function to do comparisons.  CITSysSort supports		 *
*  NULL terminated strings that are either Unicode or ANSI.				 *
*																	     *
**************************************************************************
*                                                                        *
*  Written By   : Bill Aloof	                                         *
*  Current Owner: billa		                                             *
*                                                                        *
**************************************************************************/

#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <atlinc.h>	    // includes for ATL. 
#include <_mvutil.h>
#include <mem.h>
#include <orkin.h>
#include <iterror.h>
#include <itsort.h>
#include <itsortid.h>
#include "syssrt.h"

										
//---------------------------------------------------------------------------
//						Constructor and Destructor
//---------------------------------------------------------------------------


CITSysSort::CITSysSort()
{
	OSVERSIONINFO	osvi;

	m_fInitialized = m_fDirty = FALSE;
	MEMSET(&m_srtctl, NULL, sizeof(SRTCTL));
	m_hmemAnsi1 = m_hmemAnsi2 = NULL;
	m_cbBufAnsi1Cur = m_cbBufAnsi2Cur = 0;

	// See if we're running on NT; if GetVersionEx fails, we'll assume
	// we're not since that's causes us do take the more conservative route
	// when doing comparisons.
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	m_fWinNT = (GetVersionEx(&osvi) ?
					(osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) : FALSE);
}


CITSysSort::~CITSysSort()
{
	Close();
}


//---------------------------------------------------------------------------
//						IITSortKey Method Implementations
//---------------------------------------------------------------------------


/********************************************************************
 * @method    STDMETHODIMP | IITSortKey | GetSize |
 *     Determines the size of a key.
 * @parm LPCVOID* | lpcvKey | Pointer to key
 * @parm DWORD* | pcbSize | Out param containing key size.
 *
 * @rvalue E_POINTER | lpcvKey or pcbSize was NULL
 *
 ********************************************************************/
STDMETHODIMP
CITSysSort::GetSize(LPCVOID lpcvKey, DWORD *pcbSize)
{
	if (lpcvKey == NULL || pcbSize == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	if (m_srtctl.dwKeyType == IITSK_KEYTYPE_UNICODE_SZ)
		*pcbSize = (DWORD) (sizeof(WCHAR) * (WSTRLEN((WCHAR *)lpcvKey) + 1));
	else
		*pcbSize = (DWORD) (STRLEN((char *)lpcvKey) + 1);

	return (S_OK);
}


/********************************************************************
 * @method    STDMETHODIMP | IITSortKey | Compare |
 * Compares two keys and returns information about their sort order. 
 *     
 * @parm LPCVOID | lpcvKey1 | Pointer to a key. 
 * @parm LPCVOID | lpcvKey2 | Pointer to a key.
 * @parm LONG | *plResult | (out) Indicates whether lpcvKey1 is less than, equal to, or
 * greater than lpcvKey2.
 * @parm DWORD | *pgrfReason | (out) Provides additional information about
 *  the comparison (see comments below). 
 *
 * @rvalue E_POINTER | Either lpcvKey1, lpcvKey2, or *plResult was NULL
 *
 * @comm
 * On exit, *plResult is set according to strcmp conventions:
 *	<lt> 0, = 0, <gt> 0, depending on whether lpcvKey1 is less than, equal to, or
 * greater than lpcvKey2.  If pgrfReason is not NULL, *pgrfReason may be
 * filled in on exit with one or more bit flags giving more information about
 * the result of the comparison, if the result was affected by something other
 * than raw lexical comparison (such as special character mappings).  If
 * *pgrfReason contains 0 on exit, that means the comparison result
 * was purely lexical; if *pgrfReason contains IITSK_COMPREASON_UNKNOWN,
 * then the sort object implementation wasn't able to provide additional
 * information about the comparison result.
 *
 ********************************************************************/
STDMETHODIMP
CITSysSort::Compare(LPCVOID lpcvKey1, LPCVOID lpcvKey2, LONG *plResult,
					DWORD *pgrfReason)
{
	HRESULT	hr = S_OK;
	LONG	lResult;

	if (lpcvKey1 == NULL || lpcvKey2 == NULL || plResult == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	if (SUCCEEDED(hr = CompareSz(lpcvKey1, -1, lpcvKey2, -1, &lResult,
							m_srtctl.dwKeyType == IITSK_KEYTYPE_UNICODE_SZ)))
	{
		// We can set the out params now that we know no error occurred.
		*plResult = lResult;
		if (pgrfReason != NULL)
			*pgrfReason = IITSK_COMPREASON_UNKNOWN;
	}
	else
	{
		// Some kind of unexpected error occurred.
		SetErrCode(&hr, E_UNEXPECTED);
	}

	return (hr);
}


/********************************************************************
 * @method    STDMETHODIMP | IITSortKey | IsRelated |
 * Compares two keys and returns information about their sort order. 
 *     
 * @parm LPCVOID | lpcvKey1 | Pointer to a key. 
 * @parm LPCVOID | lpcvKey2 | Pointer to a key.
 * @parm DWORD | dwKeyRelation | Specifies the relationship to check.
 * Valid parameters are:  <nl>
 *         IITSK_KEYRELATION_PREFIX		((DWORD) 0) <nl>
 *         IITSK_KEYRELATION_INFIX		((DWORD) 1) <nl>
 *         IITSK_KEYRELATION_SUFFIX		((DWORD) 2) <nl>
 * @parm DWORD | *pgrfReason | (out) Provides additional information about
 *  the comparison. 
 *
 * @rvalue S_OK | Indicates that lpcvKey1 is related to lpcvKey2 according to
 *  dwKeyRelation.
 * @rvalue S_FALSE | lpcvKey1 is not related to lpcvKey2. 
 * @rvalue E_INVALIDARG | The value specified for dwKeyRelation is not supported. 
 *
 * @comm
 *   If pgrfReason is not NULL, *pgrfReason will be filled in
 *   just as it would be by IITSortKey::Compare.
 *   
 *
 ********************************************************************/
STDMETHODIMP
CITSysSort::IsRelated(LPCVOID lpcvKey1, LPCVOID lpcvKey2, DWORD dwKeyRelation,
						DWORD *pgrfReason)
{
	HRESULT	hr;
	LONG	lResult;

	// We will let the first call to Compare catch any entry error
	// conditions because it checks for everything we would, except for
	// the type of key relation the caller is testing for.
	if (dwKeyRelation != IITSK_KEYRELATION_PREFIX)
		return (SetErrReturn(E_INVALIDARG));

	if (SUCCEEDED(hr = Compare(lpcvKey1, lpcvKey2, &lResult, NULL)))
	{
		if (lResult < 0)
		{
			LONG	cchKey1;
			BOOL	fUnicode;

			if (fUnicode = (m_srtctl.dwKeyType == IITSK_KEYTYPE_UNICODE_SZ))
				cchKey1 = (LONG) WSTRLEN((WCHAR *) lpcvKey1);
			else
				cchKey1 = (LONG) STRLEN((char *) lpcvKey1);

			if (SUCCEEDED(hr = CompareSz(lpcvKey1, cchKey1,
										lpcvKey2, cchKey1,
										&lResult, fUnicode)))
			{
				hr = (lResult == 0 ? S_OK : S_FALSE);
			}
		}
		else
			hr = (lResult == 0 ? S_OK : S_FALSE);
	}

	if (SUCCEEDED(hr) && pgrfReason != NULL)
		*pgrfReason = IITSK_COMPREASON_UNKNOWN;

	return (hr);
}


/*****************************************************************
 * @method    STDMETHODIMP | IITSortKey | Convert |
 * Converts a key of one type into a key of another type.  
 *
 * @parm DWORD | dwKeyTypeIn | Type of input key.
 * @parm LPCVOID | lpcvKeyIn | Pointer to input key.
 * @parm DWORD | dwKeyTypeOut | Type to convert key to.
 * @parm LPCVOID | lpvKeyOut | Pointer to buffer for output key. 
 * @parm DWORD | *pcbSizeOut | Size of output buffer. 
 * 
 * @rvalue S_OK | The operation completed successfully. 
 * @rvalue E_INVALIDARG | the specified conversion is not supported,
 *    for example, one or both of the REFGUID parameters is invalid.
 * @rvalue E_FAIL | the buffer pointed to by lpvKeyOut was too small
 *  to hold the converted key.
 * @comm
 *	 This is intended mainly for converting an uncompressed key
 *   into a compressed key, but a sort object is free to provide 
 *   whatever conversion combinations it wants to.  
 *   *pcbSizeOut should contain the size of the buffer pointed
 *   to by lpvKeyOut.  To make sure the buffer size specified in
 *   *pcbSizeOut is adequate, pass 0 on entry.
 * 
 *  @comm 
 *  Not implemented yet. 				
 ****************************************************************/
STDMETHODIMP
CITSysSort::Convert(DWORD dwKeyTypeIn, LPCVOID lpcvKeyIn,
					DWORD dwKeyTypeOut, LPVOID lpvKeyOut, DWORD *pcbSizeOut)
{
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	return (E_NOTIMPL);
}


/*****************************************************************
 * @method    STDMETHODIMP | IITSortKey | ResolveDuplicates |
 * .  
 *
 * @parm LPCVOID | lpcvSz1 | Pointer to the first input key.
 * @parm LPCVOID | lpcvSz2 | Pointer to the second input key.
 * @parm LPCVOID | lpcvNewSz | Pointer to the new key.
 * 
 * @rvalue S_OK | the operation completed successfully. 
 * @rvalue E_INVALIDARG | the specified keys are invalid.
 * @rvalue E_NOTOPEN | the sort object is not open.
 * @rvalue E_FAIL | the buffer pointed to by lpvKeyOut was too small
 *  to hold the converted key.
 * @comm
 *	 If duplicate keys are found (as specified in ::Compare), this
 *   method provides the oppurtunity to specify a new key.  lpcvNewSz
 *   must compare as equal to lpcvSz1.  lpvcNewSz will be allocated in
 *   this function by CoTaskMemAlloc.  It is the callers resposibility
 *   to free lpcvNewSz when finished with it.
 *   *pcbSizeOut should contain the size of the buffer pointed
 *   to by lpvKeyOut.  To make sure the buffer size specified in
 *   *pcbSizeOut is adequate, pass 0 on entry.
 * 
 *  @comm 
 *  Not implemented yet. 				
 ****************************************************************/
STDMETHODIMP
CITSysSort::ResolveDuplicates
    (LPCVOID lpcvSz1, LPCVOID lpcvSz2,
    LPCVOID lpvKeyOut, DWORD *pcbSizeOut)
{
    if (!m_fInitialized)
        return (SetErrReturn(E_NOTOPEN));

    return (E_NOTIMPL);
}

//---------------------------------------------------------------------------
//						IITSortKeyConfig Method Implementations
//---------------------------------------------------------------------------


/*******************************************************************
 * @method    STDMETHODIMP | IITSortKeyConfig | SetLocaleInfo |
 * Sets locale information to be used by the sort key interface. 
 *
 * @parm DWORD | dwCodePageID | ANSI code page no. specified at build time.
 * @parm LCID | lcid | Win32 locale identifier specified at build time. 
 *
 * @rvalue S_OK | The operation completed successfully. 
 *
 ********************************************************************/
STDMETHODIMP
CITSysSort::SetLocaleInfo(DWORD dwCodePageID, LCID lcid)
{
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	m_cs.Lock();

	m_srtctl.dwCodePageID = dwCodePageID;
	m_srtctl.lcid = lcid;
	
	m_fDirty = TRUE;

	m_cs.Unlock();

	return (S_OK);
}


/*******************************************************************
 * @method    STDMETHODIMP | IITSortKeyConfig | GetLocaleInfo |
 * Retrieves locale information used by the sort key interface. 
 *
 * @parm DWORD | dwCodePageID | ANSI code page no. specified at build time.
 * @parm LCID | lcid | Win32 locale identifier specified at build time. 
 *
 * @rvalue E_POINTER | Either pdwCodePageID or plcid is NULL.
 * @rvalue E_NOTOPEN | (?) is not initialized. 
 * @rvalue S_OK | The operation completed successfully. 
 *
 ********************************************************************/
STDMETHODIMP
CITSysSort::GetLocaleInfo(DWORD *pdwCodePageID, LCID *plcid)
{
	if (pdwCodePageID == NULL || plcid == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	m_cs.Lock();

	*pdwCodePageID = m_srtctl.dwCodePageID;
	*plcid = m_srtctl.lcid;

	m_cs.Unlock();

	return (S_OK);
}


/*******************************************************************
 * @method    STDMETHODIMP | IITSortKeyConfig | SetKeyType |
 * Sets the sort key type that the sort object expects to see in calls
 * that take keys as parameters (IITSortKey::GetSize, Compare, IsRelated).
 *
 * @parm DWORD | dwKeyType | Sort key type. Possible values are: 
 *   		IITSK_KEYTYPE_UNICODE_SZ or IITSK_KEYTYPE_ANSI_SZ
 *
 * @rvalue S_OK | The sort key type was understood by the sort object.
 * @rvalue E_INVALIDARG | Invalid sort key type.
 *
 ********************************************************************/
STDMETHODIMP
CITSysSort::SetKeyType(DWORD dwKeyType)
{
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	switch (dwKeyType)
	{
		case IITSK_KEYTYPE_UNICODE_SZ:
		case IITSK_KEYTYPE_ANSI_SZ:
			break;

		default:
			return (SetErrReturn(E_INVALIDARG));
	};

	m_cs.Lock();

	m_srtctl.dwKeyType = dwKeyType;
	m_fDirty = TRUE;

	m_cs.Unlock();

	return (S_OK);
}


/*******************************************************************
 * @method    STDMETHODIMP | IITSortKeyConfig | GetKeyType |
 * Retrieves the sort key type that the sort object expects to see in calls
 * that take keys as parameters (IITSortKey::GetSize, Compare, IsRelated).
 *
 * @parm DWORD | *pdwKeyType | Pointer to the sort key type.
 *
 * @rvalue S_OK | The operation completed successfully. 
 * @rvalue E_POINTER | The key type is null.
 *
 ********************************************************************/
STDMETHODIMP
CITSysSort::GetKeyType(DWORD *pdwKeyType)
{
	if (pdwKeyType == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	*pdwKeyType = m_srtctl.dwKeyType;

	return (S_OK);
}


/*******************************************************************
 * @method    STDMETHODIMP | IITSortKeyConfig | SetControlInfo |
 * Sets data that controls how sort key comparisons are made.
 *
 * @parm DWORD | grfSortFlags | One or more of the following sort flags:<nl>
 * IITSKC_SORT_STRINGSORT           0x00001000   use string sort method  <nl>
 * IITSKC_NORM_IGNORECASE           0x00000001   ignore case  <nl>
 * IITSKC_NORM_IGNORENONSPACE       0x00000002   ignore nonspacing chars  <nl>
 * IITSKC_NORM_IGNORESYMBOLS        0x00000004   ignore symbols  <nl>
 * IITSKC_NORM_IGNOREKANATYPE       0x00010000   ignore kanatype  <nl>
 * IITSKC_NORM_IGNOREWIDTH          0x00020000   ignore width  <nl>
 *
 * @parm DWORD | dwReserved | Reserved for future use. 
 * 
 * 
 ********************************************************************/
STDMETHODIMP
CITSysSort::SetControlInfo(DWORD grfSortFlags, DWORD dwReserved)
{
	DWORD	grfFlagsUnsupported;

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	grfFlagsUnsupported = ~(IITSKC_SORT_STRINGSORT |
							IITSKC_NORM_IGNORECASE |
							IITSKC_NORM_IGNORENONSPACE |
							IITSKC_NORM_IGNORESYMBOLS |
							IITSKC_NORM_IGNORESYMBOLS |
							IITSKC_NORM_IGNOREKANATYPE |
							IITSKC_NORM_IGNOREWIDTH);

	if ((grfSortFlags & grfFlagsUnsupported) != 0)
		return (SetErrReturn(E_INVALIDARG));

	m_cs.Lock();

	m_srtctl.grfSortFlags = grfSortFlags;
	m_fDirty = TRUE;

	m_cs.Unlock();

	return (S_OK);
}


/*******************************************************************
 * @method    STDMETHODIMP | IITSortKeyConfig | GetControlInfo |
 * Retrieves data that controls how sort key comparisons are made.
 *
 * @parm DWORD | *pgrfSortFlags | Pointer to the sort key flags. See 
 *   <om .SetControlInfo> for a list of valid flags. 
 *
 * @parm DWORD | *pdwReserved | Reserved for future use. 
 * 
 *
 * @rvalue E_POINTER | The value pgrfSortFlags is NULL. 
 * @rvalue S_OK | The operation completed successfully. 
 *
 ********************************************************************/
STDMETHODIMP
CITSysSort::GetControlInfo(DWORD *pgrfSortFlags, DWORD *pdwReserved)
{
	if (pgrfSortFlags == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	*pgrfSortFlags = m_srtctl.grfSortFlags;

	return (S_OK);
}


/*******************************************************************
 * @method    STDMETHODIMP | IITSortKeyConfig | LoadExternalSortData |
 * 	Loads external sort data such as tables containing the relative
 *  sort order of specific characters for a textual key type, from the
 *  specified stream.  
 *
 * @parm IStream | *pStream | Pointer to the external stream object
 *   from which to load data. 
 * @parm DWORD | dwExtDataType | Describes the format of sort data. 
 * 
 * @comm
 * Although the format of the external sort data is entirely 
 * implementation-specific, this interface provides a general type for
 * data that can be passed in dwExtDataType: IITWBC_EXTDATA_SORTTABLE	((DWORD) 2). 	
 *  
 * @comm
 * Not implemented yet. 
 ********************************************************************/
STDMETHODIMP
CITSysSort::LoadExternalSortData(IStream *pStream, DWORD dwExtDataType)
{
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	return (E_NOTIMPL);
}


//---------------------------------------------------------------------------
//						IPersistStreamInit Method Implementations
//---------------------------------------------------------------------------


STDMETHODIMP
CITSysSort::GetClassID(CLSID *pclsid)
{
	if (pclsid == NULL)
		return (SetErrReturn(E_POINTER));

	*pclsid = CLSID_ITSysSort;
	return (S_OK);
}


STDMETHODIMP
CITSysSort::IsDirty(void)
{
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	return (m_fDirty ? S_OK : S_FALSE);
}


STDMETHODIMP
CITSysSort::Load(IStream *pStream)
{
	HRESULT	hr;
	DWORD	dwVersion;
	DWORD	cbRead;

	if (pStream == NULL)
		return (SetErrReturn(E_POINTER));

	// Lock before checking m_fInitialized to make sure we don't compete
	// with a call to ::InitNew.
	m_cs.Lock();

	if (m_fInitialized)
		return (SetErrReturn(E_ALREADYOPEN));

	if (SUCCEEDED(hr = pStream->Read((LPVOID) &dwVersion, sizeof(DWORD),
																&cbRead)) &&
		SUCCEEDED(hr = ((cbRead == sizeof(DWORD)) ? S_OK : E_BADFORMAT)) &&
		SUCCEEDED(hr = ((dwVersion == VERSION_SYSSORT) ? S_OK :
															E_BADVERSION)) &&
		SUCCEEDED(hr = pStream->Read((LPVOID) &m_srtctl, sizeof(SRTCTL),
																	&cbRead)) &&
		SUCCEEDED(hr = ((cbRead == sizeof(SRTCTL)) ? S_OK : E_BADFORMAT)))
	{ 
		m_fInitialized = TRUE;
	}

	m_cs.Unlock();
	return (hr);
}


STDMETHODIMP
CITSysSort::Save(IStream *pStream, BOOL fClearDirty)
{
	HRESULT	hr;
	DWORD	dwVersion;
	DWORD	cbWritten;

	if (pStream == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	m_cs.Lock();

	dwVersion = VERSION_SYSSORT;
	if (SUCCEEDED(hr = pStream->Write((LPVOID) &dwVersion, sizeof(DWORD),
																&cbWritten)) &&
		SUCCEEDED(hr = pStream->Write((LPVOID) &m_srtctl, sizeof(SRTCTL),
																&cbWritten)) &&
		fClearDirty)
	{
		m_fDirty = FALSE;
	}

	m_cs.Unlock();

	return (hr);
}


STDMETHODIMP
CITSysSort::GetSizeMax(ULARGE_INTEGER *pcbSizeMax)
{
	return (E_NOTIMPL);
}


STDMETHODIMP
CITSysSort::InitNew(void)
{
	// Lock before checking m_fInitialized to make sure we don't compete
	// with a call to ::Load.
	m_cs.Lock();

	if (m_fInitialized)
		return (SetErrReturn(E_ALREADYOPEN));

	m_srtctl.dwCodePageID = GetACP();
	m_srtctl.lcid = GetUserDefaultLCID();
	m_srtctl.dwKeyType = IITSK_KEYTYPE_UNICODE_SZ;

	// CompareString does word sort by default, but we have to
	// tell it to ignore case.
	m_srtctl.grfSortFlags = IITSKC_NORM_IGNORECASE;

	m_fInitialized = TRUE;

	m_cs.Unlock();
	return (S_OK);
}


//---------------------------------------------------------------------------
//						Private Method Implementations
//---------------------------------------------------------------------------


// Compares either two Unicode strings or two Ansi strings, calling the
// appropriate variant of CompareString.  The cch params should denote
// count of characters, NOT bytes, not including a NULL terminator. -1
// is a valid value for the cch params, which means compare the strings
// until a NULL terminator is found.  If fUnicode is TRUE, this routine
// may decide to convert the string to Ansi before doing the compare if
// the system doesn't support CompareStringW.  The result of the
// comparison is returned in *plResult in strcmp-compatible form.
HRESULT
CITSysSort::CompareSz(LPCVOID lpcvSz1, LONG cch1, LPCVOID lpcvSz2, LONG cch2,
						LONG *plResult, BOOL fUnicode)
{
	HRESULT	hr = S_OK;
	LONG	lResult;
	BOOL	fAnsiCompare;
	SRTCTL	srtctl;
	LPSTR	lpstr1 = NULL;
	LPSTR	lpstr2 = NULL;


	m_cs.Lock();
	srtctl = m_srtctl;
	m_cs.Unlock();

	fAnsiCompare = !fUnicode || !m_fWinNT;

	// See if we need to convert from Unicode to ANSI.
	if (fAnsiCompare && fUnicode)
	{
		DWORD	cbAnsi1;
		DWORD	cbAnsi2;

		m_cs.Lock();
		
		if (cch1 < 0)
			hr = GetSize(lpcvSz1, &cbAnsi1);
		else
			// leave enough space for double byte chars in MBCS.
			cbAnsi1 = (cch1 + 1) * sizeof(WCHAR);

		if (cch2 < 0)
			hr = GetSize(lpcvSz2, &cbAnsi2);
		else
			// leave enough space for double byte chars in MBCS.
			cbAnsi2 = (cch2 + 1) * sizeof(WCHAR);

		if (SUCCEEDED(hr) &&
			SUCCEEDED(hr = ReallocBuffer(&m_hmemAnsi1, &m_cbBufAnsi1Cur,
																cbAnsi1)) &&
			SUCCEEDED(hr = ReallocBuffer(&m_hmemAnsi2, &m_cbBufAnsi2Cur,
																cbAnsi2)))
		{
			// We lock the ansi buffers here, but we won't unlock them
			// until the end of this routine so that we can pass them
			// to compare string.
			lpstr1 = (LPSTR) _GLOBALLOCK(m_hmemAnsi1);
			lpstr2 = (LPSTR) _GLOBALLOCK(m_hmemAnsi2);

			if ((cch1 = WideCharToMultiByte(srtctl.dwCodePageID, NULL, 
							(LPCWSTR) lpcvSz1, cch1, lpstr1, m_cbBufAnsi1Cur,
														NULL, NULL)) != 0 &&
				(cch2 = WideCharToMultiByte(srtctl.dwCodePageID, NULL, 
							(LPCWSTR) lpcvSz2, cch2, lpstr2, m_cbBufAnsi2Cur,
														NULL, NULL)) != 0)
			{
				// Set up for call to CompareStringA.
				lpcvSz1 = (LPCVOID) lpstr1;
				lpcvSz2 = (LPCVOID) lpstr2;
			}
			else
				hr = E_UNEXPECTED;
		}

	}

	if (SUCCEEDED(hr))
	{
		if (fAnsiCompare)
			lResult = CompareStringA(srtctl.lcid, srtctl.grfSortFlags,
							(LPCSTR) lpcvSz1, cch1, (LPCSTR) lpcvSz2, cch2);
		else
			lResult = CompareStringW(srtctl.lcid, srtctl.grfSortFlags,
							(LPCWSTR) lpcvSz1, cch1, (LPCWSTR) lpcvSz2, cch2);

		if (lResult == 0)
			// Some kind of unexpected error occurred.
			SetErrCode(&hr, E_UNEXPECTED);
		else
			// We need to subtract 2 from the lResult to convert
			// it into a strcmp-compatible form.
			*plResult = lResult - 2;
	}

	if (lpstr1 != NULL)
		_GLOBALUNLOCK(m_hmemAnsi1);

	if (lpstr2 != NULL)
		_GLOBALUNLOCK(m_hmemAnsi2);

	if (fAnsiCompare && fUnicode)
		m_cs.Unlock();

	return (hr);
}


HRESULT
CITSysSort::ReallocBuffer(HGLOBAL *phmemBuf, DWORD *pcbBufCur, DWORD cbBufNew)
{
	HRESULT hr = S_OK;

	m_cs.Lock();

	hr = ReallocBufferHmem(phmemBuf, pcbBufCur, max(cbBufNew, cbAnsiBufInit));

	m_cs.Unlock();

	return (hr);
}


void
CITSysSort::Close(void)
{
	if (m_hmemAnsi1 != NULL)
	{
		_GLOBALFREE(m_hmemAnsi1);
		m_hmemAnsi1 = NULL;
		m_cbBufAnsi1Cur = 0;
	}

	if (m_hmemAnsi2 != NULL)
	{
		_GLOBALFREE(m_hmemAnsi2);
		m_hmemAnsi2 = NULL;
		m_cbBufAnsi2Cur = 0;
	}

	MEMSET(&m_srtctl, NULL, sizeof(SRTCTL));
	m_fInitialized = m_fDirty = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\wwbuild\wwupdate.cpp ===
#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <windows.h>
#include <itpropl.h>
#include <atlinc.h>

#include "wwumain.h"


// CompareKeys ****************************************************************
HRESULT PASCAL ScanTempFile(LPFBI lpfbi, LPB lpbOut, LPV lpv)
{
    LPB lpbLimit = lpfbi->lrgbBuf + lpfbi->cbBuf;
    LPB lpbIn = lpfbi->lrgbBuf + lpfbi->ibBuf;

#define STATE_KEYSIZE   1
#define STATE_KEY       2
#define STATE_DATATYPE  3
#define STATE_SORTORDER 4
#define STATE_PROPSIZE  5
#define STATE_PROPLIST  6

    DWORD dwState = STATE_KEYSIZE;
    DWORD dwSize;
    DWORD dwTemp = sizeof (DWORD);

    LPB lpbSaved = lpbOut;
    *(LPW)lpbOut = 0;
    lpbOut += sizeof (WORD);

    for (;; dwState++)
    {
        if (STATE_KEY == dwState || STATE_PROPLIST == dwState)
            dwTemp = dwSize;

        if (lpbIn + dwTemp >= lpbLimit)
        {
            HRESULT hResult;
            lpfbi->ibBuf = (WORD)(lpbIn - lpfbi->lrgbBuf);
            if (FileBufFill (lpfbi, &hResult) == cbIO_ERROR)
                return hResult;

            lpfbi->ibBuf = 0;
            lpbIn = lpfbi->lrgbBuf;
            lpbLimit = lpfbi->lrgbBuf + lpfbi->cbBuf;

            /* EOF */
            if (lpfbi->ibBuf == lpfbi->cbBuf)
            {
                break;
            }
        }

        if (STATE_DATATYPE == dwState)
        {
            *lpbOut = *lpbIn;
            lpbIn++;
            lpbOut++;
        } else if (STATE_KEY != dwState && STATE_PROPLIST != dwState)
        {
            MEMCPY(lpbOut, lpbIn, sizeof (DWORD));
            dwSize = *(DWORD UNALIGNED *)lpbIn;
            lpbIn += sizeof(DWORD);
            lpbOut += sizeof(DWORD);
        }
        else
        {
            MEMCPY(lpbOut, lpbIn, dwSize);
            lpbIn += dwSize;
            lpbOut += dwSize;
            if (STATE_PROPLIST == dwState)
                break;
            dwTemp = sizeof (DWORD);
        }
    }

    *(LPW)lpbSaved = (WORD)(lpbOut - lpbSaved - sizeof(WORD));
    lpfbi->ibBuf = (WORD)(lpbIn - lpfbi->lrgbBuf);
    return S_OK;
}

// CompareKeys ****************************************************************
int PASCAL CompareKeys(LPSTR pWord1, LPSTR pWord2, LPV pSortInfo)
{
    // Format:
    //  <dwSize><Key><Data Type><2nd Sort Order><prop size><prop list>
    //    DWORD   n     CHAR        DWORD         DWORD       n
    IITSortKey *piitsk = (IITSortKey *)pSortInfo;
    ITASSERT(piitsk);

    // Compare keys    
    pWord1 += sizeof (WORD);
    pWord2 += sizeof (WORD);

    CHAR cKey1[2084], cKey2[2048];
    ITASSERT(*(DWORD UNALIGNED *)pWord1 <= 2048);
    ITASSERT(*(DWORD UNALIGNED *)pWord2 <= 2048);
    MEMCPY(cKey1, pWord1 + sizeof (DWORD), *(DWORD UNALIGNED *)pWord1);
    MEMCPY(cKey2, pWord2 + sizeof (DWORD), *(DWORD UNALIGNED *)pWord2);

    LONG lResult;
    if (FAILED(piitsk->Compare(cKey1, cKey2, &lResult, NULL))) {
        ITASSERT(0);
    }

    if (lResult)
        return lResult;

    // Keys are equal - Compare data type
    pWord1 += sizeof(DWORD) + *(DWORD UNALIGNED *)pWord1;
    pWord2 += sizeof(DWORD) + *(DWORD UNALIGNED *)pWord2;

    if (lResult = *(BYTE UNALIGNED *)pWord1 - *(BYTE UNALIGNED *)pWord2)
        return lResult;
    pWord1++;
    pWord2++;

    // Data types are equal - Compare secondary sort ordinal
    lResult = *(DWORD UNALIGNED *)pWord1 - *(DWORD UNALIGNED *)pWord2;
    return lResult;
} /* CompareKeys */


// PackBytes ******************************************************************
int PASCAL PackBytes(LPB lpbOut, DWORD dwIn)
{
	LPB     lpbOldOut;

	/* Save the old offset */
	lpbOldOut = lpbOut;

	do
    {
		*lpbOut =(BYTE)(dwIn & 0x7F);  /* Get 7 bits. */
		dwIn >>= 7;
		if (dwIn)
			*lpbOut |= 0x80;        /* To be continued... */
		lpbOut++;
	} while (dwIn);
	return (int)(lpbOut - lpbOldOut);              /* Return compressed width */
} /* PackBytes */

/***************************************************************************
 *
 *  Name        FWriteData
 *
 *  Purpose
 *    Writes the extra data to the keyword data file.
 *
 *  Arguments
 *    IStorage* pStream:     Destination stream
 *    PLKW      pKW:         Pointer to keyword info structure
 *    LPDWORD   pdwWritten:  Pointer to return number of bytes written
 *
 *  Returns
 *    S_OK on success or
 *    ERR_FAILED, indicating compilation should be aborted.
 *
 *  Notes:
 *      DWORD       : Extra data byte count
 *      n           : Extra data
 *
 **************************************************************************/
HRESULT FWriteData(IStream *pStream,
    const PLKW pKW, LPDWORD pdwWritten, LPBYTE pTempBuffer)
{
    HRESULT hr;
    DWORD dwTemp;
    DWORD dwDataSize = pKW->cbPropData;
    // Encode data size byte count
    if (FAILED(hr = pStream->Write(&dwDataSize, sizeof(DWORD), &dwTemp)))
		return hr;

    if (FAILED(hr = pStream->Write(pKW->pPropData, dwDataSize, &dwTemp)))
        return hr;

    *pdwWritten += sizeof (DWORD) + dwDataSize;
    return S_OK;
}


/* ParseKeywordLine ***********************************************************
*   @comm
*       Input file format:
*       DWORD : Key byte length
*       BINARY: Key
*       %c   : PropDest ID
*       %08X : Entry order
*       %lu  : Property List size %c : DELIMITER(\x0E)
*       %s   : Property List      %c : "\n"
*
******************************************************************************/

LPSTR WINAPI ParseKeywordLine(LPSTR pBuffer, PLKW pKw)
{ 
	// Extract the keyword size
    DWORD dwKeySize = *(DWORD UNALIGNED *)pBuffer;
    pBuffer += sizeof(DWORD);
    *(DWORD UNALIGNED *UNALIGNED)pKw->szKeyword = dwKeySize;

	// Extract the keyword string
    ITASSERT(dwKeySize <= CBMAX_KWENTRY);
	MEMCPY(pKw->szKeyword + sizeof(DWORD), pBuffer, dwKeySize);
    pBuffer += dwKeySize;

	// Extract the property destination
    pKw->bPropDest= *pBuffer++;
    ITASSERT(pKw->bPropDest == C_PROPDEST_KEY
        || pKw->bPropDest == C_PROPDEST_OCC);

    // Skip the Entry Order (it's only used to manipulate sorting)
    pBuffer += sizeof(DWORD);

	// Extract the property list size
    pKw->cbPropData = *(DWORD UNALIGNED *UNALIGNED)pBuffer;
    pBuffer += sizeof(DWORD);

    // Make sure we don't read past the end of buffer
    ITASSERT(!IsBadReadPtr(pBuffer, pKw->cbPropData));

    pKw->pPropData = pBuffer;
    pBuffer += pKw->cbPropData;

	return pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\assert.cpp ===
// ASSERT.cpp -- Assertion support code

#include  "StdAfx.h"

#ifdef _DEBUG

void STDCALL RonM_AssertionFailure(PSZ pszFileName, int nLine)
{
    char abMessage[513];

    wsprintf(abMessage, "Assertion Failure on line %d of %s!", nLine, pszFileName);

    int iResult= ::MessageBox(NULL, abMessage, "Assertion Failure!", 
                              MB_ABORTRETRYIGNORE | MB_APPLMODAL | MB_ICONSTOP
                             );

    switch(iResult)
    {
    case IDABORT:

        ExitProcess(-nLine);
        
    case IDRETRY:

        DebugBreak();
        break;

    case IDIGNORE:

        break;
    }
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\assert.h ===
// ASSERT.h -- Support for assertions...
#ifndef __ASSERT_H__

#define __ASSERT_H__

#ifdef _DEBUG

void STDCALL RonM_AssertionFailure(PSZ pszFileName, int nLine);

#define RonM_ASSERT(fTest)   ((fTest) ? (void)0 : RonM_AssertionFailure(__FILE__, __LINE__))
#define DEBUGDEF(D)		D;
#define DEBUGCODE(X)    { X }

#else

#define RonM_ASSERT(fTest)   ((void) 0)
#define DEBUGDEF(D)
#define DEBUGCODE(X)

#endif

#endif // __ASSERT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\wwbuild\wwumain.h ===
// WWUMAIN.H:  Definition of CITWordWheelUpdate

#ifndef __WWUMAIN_H__
#define __WWUMAIN_H__

#include <windows.h>
#include <mvopsys.h>
#include <_mvutil.h>
#include <wrapstor.h>
#include <common.h>
#include <wwheel.h>
#include <verinfo.h>

#include <itcc.h>   // IITBuildCollect defined

class CITWordWheelUpdate : 
	public IITBuildCollect,
    public IPersistStorage,
	public CComObjectRoot,
	public CComCoClass<CITWordWheelUpdate,&CLSID_IITWordWheelUpdate>
{
public:
	CITWordWheelUpdate();
    ~CITWordWheelUpdate();

BEGIN_COM_MAP(CITWordWheelUpdate)
	COM_INTERFACE_ENTRY(IITBuildCollect)
	COM_INTERFACE_ENTRY(IPersistStorage)
END_COM_MAP()

DECLARE_REGISTRY (CLSID_IITWordWheelUpdate,
    "ITIR.WordWheelBuild.4", "ITIR.WordWheelBuild",
    0, THREADFLAGS_APARTMENT)

public:
    STDMETHOD(SetConfigInfo)(IITDatabase *piitdb, VARARG vaParams);
	STDMETHOD(InitHelperInstance)(DWORD dwHelperObjInstance,
        IITDatabase *pITDatabase, DWORD dwCodePage,
        LCID lcid, VARARG vaDword, VARARG vaString);
	STDMETHOD(SetEntry)(LPCWSTR szDest, IITPropList *pPropList);
	STDMETHOD(Close)(void);
    STDMETHOD(GetTypeString)(LPWSTR pPrefix, DWORD *pLength);
    STDMETHOD(SetBuildStats)(ITBuildObjectControlInfo &itboci)
        { return E_NOTIMPL;}

    STDMETHOD(GetClassID)(CLSID *pClsID);
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(IStorage *pStg);
    STDMETHOD(Save)(IStorage *pStgSave, BOOL fSameAsLoad);
    STDMETHOD(InitNew)(IStorage *pStg);
    STDMETHOD(SaveCompleted)(IStorage *pStgNew);
    STDMETHOD(HandsOffStorage)(void);

private:
    STDMETHOD(BuildPermanentFiles)
        (IStorage *pIStorage, IStream *pHeaderStream);
    STDMETHOD(ResolveGlobalProperties)(IStream *pHeaderStream);

    BOOL m_fInitialized, m_fIsDirty;
    DWORD m_dwEntryCount;
    HANDLE m_hTempFile, m_hGlobalPropTempFile;
    char m_szTempFile [_MAX_PATH + 1];
    char m_szGlobalPropTempFile[_MAX_PATH + 1];
    IStorage *m_pStorage;
    DWORD m_dwGlobalPropSize;
    LPBYTE m_lpbKeyHeader, m_lpbOccHeader;
    DWORD m_cbKeyHeader, m_cbOccHeader;
    DWORD m_cbMaxKeyData, m_cbMaxOccData;
    IITSortKey *m_piitskSortKey;
    BTREE_PARAMS m_btParams;
}; /* CITWordWheelUpdate */


// Defines ********************************************************************
#define CBKWBLOCKSIZE       2048
#define CBMAX_KWENTRY       1024

#define C_PROPDEST_KEY  '1'
#define C_PROPDEST_OCC  '2'

// Type Definitions ***********************************************************
typedef struct tagSortInfo
{
    int iSortFlags;
    LPCHARTAB   *CharTabArray;
} SORTINFO, FAR *PSORTINFO;

typedef struct tagKeyword
{
    LPSTR pPropData;
    DWORD cbPropData;
	char  szKeyword[CBMAX_KWENTRY + 1];
    char  bPropDest;
} LKW, FAR *PLKW;


// Function Prototypes ********************************************************
HRESULT PASCAL ScanTempFile(LPFBI lpfbi, LPB lpbOut, LPV lpv);
int PASCAL CompareKeys (LPSTR pWord1, LPSTR pWord2, LPV);
HRESULT FWriteData (IStream *pStream,
    PLKW pKw, LPDWORD pdwWritten, LPBYTE pTempBuffer);
LPSTR WINAPI ParseKeywordLine (LPSTR pBuffer, PLKW pKw);

#ifdef BUILD_INDEX
RC PASCAL AddToFtsIndex(LPFTSII lpftsii);
#endif

#endif /* __WWUMAIN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\wrdwheel\wwbuild\wwuperst.cpp ===
// wwuperst.cpp:  Implementation of wordwheel update persistance interface
#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <windows.h>
#include <iterror.h>
#include <atlinc.h>
#include <itpropl.h>
#include <ccfiles.h>
#include <itsortid.h>
#include "wwumain.h"


// Type Definitions ***********************************************************
typedef struct
{
	DWORD cKeys;
	DWORD ilOffset;
} RECKW, FAR * PRECKW;


STDMETHODIMP CITWordWheelUpdate::Save(IStorage *pStgSave, BOOL fSameAsLoad)
{
    if (FALSE == m_fInitialized || NULL == m_piitskSortKey)
        return SetErrReturn(E_NOTINIT);

    // Create the permanent header stream
    HRESULT hr;
    IStream *pHeaderStream;
    if (FAILED(hr = pStgSave->CreateStream
        (SZ_BTREE_HEADER, STGM_WRITE, 0, 0, &pHeaderStream)))
        return hr;

    ResolveGlobalProperties (pHeaderStream);

    // Handle occurence/term data
    DWORD dwSize = GetFileSize(m_hTempFile, NULL);
    CloseHandle(m_hTempFile);
    m_hTempFile = NULL;
    if (dwSize)
    {
        if (FAILED(hr = BuildPermanentFiles(pStgSave, pHeaderStream)))
        {
            pHeaderStream->Release();
            return hr;
        }
    }
    DeleteFile(m_szTempFile);

    pHeaderStream->Release();
    return S_OK;
} /* Save */


/***************************************************************
*   @doc INTERNAL
*
*   @api HRESULT FAR PASCAL | BuildKeywordFiles | This routine is called
*       at the end of compilation to generate the appropriate
*       .MVB subfiles to support runtime keyword stuff.
*
****************************************************************/

HRESULT WINAPI CITWordWheelUpdate::BuildPermanentFiles
    (IStorage *pIStorage, IStream *pHeaderStream)
{
	RECKW   reckw;
	HBT     hbt;
    IStream *pDataStream = NULL;
	HRESULT hr;             // Return code

	LKW     kwCur, kwNext;
	LPSTR   pCur, pEnd;
	char    fEOF;
	DWORD   dwWritten, dwTemp;
	LPSTR   pInput;         // Input buffer
    void *  pvNewKey;                   // Used to resolve duplicate keys
    DWORD dwBufferSize = CBMAX_KWENTRY; // Used to resolve duplicate keys

    LPBYTE  pKeyDataBuffer = NULL, pOccDataBuffer = NULL;

    // Allocate temp buffers
    pvNewKey = (void *)new BYTE[dwBufferSize];
    if(NULL == pvNewKey)
        return SetErrReturn(E_OUTOFMEMORY);

    pKeyDataBuffer = new BYTE[m_cbMaxKeyData];
    if (pKeyDataBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit0;
    }

    pOccDataBuffer = new BYTE[m_cbMaxOccData];
    if (pOccDataBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit0;
    }
 
	// Sort the input file using our own sort function
    if (S_OK !=(hr = FileSort(NULL,(LPB)m_szTempFile,
        NULL, NULL, 0, CompareKeys, m_piitskSortKey, ScanTempFile, NULL)))
	{
exit0:
        delete pvNewKey;
        if(pKeyDataBuffer)
            delete pKeyDataBuffer;
        if(pOccDataBuffer)
            delete pOccDataBuffer;

        return hr;
	}

	m_btParams.hfs = pIStorage;

	// *****************************
	// Map the input file to memory 
	// *****************************
    pInput = MapSequentialReadFile(m_szTempFile, &dwTemp);
    if (!pInput)
    {
        SetErrCode(&hr, E_FAIL);
        goto exit0;
    }
    pCur = pInput;
    pEnd = pInput + dwTemp;

	hbt = HbtInitFill(SZ_BTREE_BTREE_A, &m_btParams, &hr);
	if (hbt == hNil)
	{
exit2:
		UnmapViewOfFile(pInput);
		goto exit0;
	}

    BtreeSetExtSort(hbt, m_piitskSortKey);

	// **************************************
	// CREATE KEYWORD FILE IN MVB FILE SYSTEM
	// **************************************

    if (FAILED(hr = pIStorage->CreateStream
       (SZ_BTREE_DATA, STGM_WRITE, 0, 0, &pDataStream)))
	{
exit4:
        if (pDataStream)
	        pDataStream->Release();
		RcAbandonHbt(hbt);
		goto exit2;
	}

	// Process keywords until we get to the next set
    reckw.ilOffset = dwWritten = 0;
    fEOF = 0;
	pCur = ParseKeywordLine(pCur, &kwCur); // Load first record

    // Process occurence information
	while (!fEOF)
    {
        LARGE_INTEGER liNull = {0};
        DWORD cbKeyProp;    // Size of the Key data block
    
    	reckw.cKeys = 1;
        dwWritten = 0;

        // Handle properties for the key
        BOOL fNotDup = TRUE;
        cbKeyProp = 0;
        while (!fEOF && kwCur.bPropDest == C_PROPDEST_KEY)
        {
            if (fNotDup)
            {
                hr = FWriteData
                    (pDataStream, &kwCur, &cbKeyProp, pKeyDataBuffer);
                if (FAILED(hr))
                    goto exit4;
                fNotDup = FALSE;
            }
            if (pCur == pEnd)
                fEOF = TRUE;
            else
                pCur = ParseKeywordLine(pCur, &kwCur);
        }
        // cbKeyProp is an accumulated total for all previous writes
        // if we didin't write anything we must at least write a
        // record size of zero to the stream.
        if (0 == cbKeyProp)
        {
            dwTemp = 0;
            pDataStream->Write (&dwTemp, sizeof (DWORD), &cbKeyProp);
        }

        // You must have occurrence information -- not just key data
        if (fEOF)
        {
            SetErrCode(&hr, E_FAIL);
            goto exit4;
        }

		if (FAILED(hr = FWriteData
            (pDataStream, &kwCur, &dwWritten, pOccDataBuffer)))
            goto exit4;

		if (pEnd != pCur)
			pCur = ParseKeywordLine(pCur, &kwNext);
		else
			fEOF = 1;

		// ********************************************************
		// *********    PROCESS ALL IDENTICAL ENTRIES    **********
		// ********************************************************
		while (!fEOF)
		{
            LONG lResult;
            hr = m_piitskSortKey->Compare(kwCur.szKeyword + sizeof(DWORD),
                kwNext.szKeyword + sizeof(DWORD), &lResult, NULL);
            ITASSERT(SUCCEEDED(hr));
            if(lResult)
                break;

            // These keys are identical, but the user may want to calapse
            // them for some reason.  Maybe he has custom data embedded in
            // the keys.
            hr = m_piitskSortKey->ResolveDuplicates(
                kwCur.szKeyword + sizeof(DWORD),
                kwNext.szKeyword + sizeof(DWORD),
                pvNewKey, &dwBufferSize);
            if(SUCCEEDED(hr))
            {
                // Verify that the user didn't alter the sort order!
                hr = m_piitskSortKey->Compare(
                    kwCur.szKeyword + sizeof(DWORD),
                    pvNewKey, &lResult, NULL);
                ITASSERT(SUCCEEDED(hr));
                if(lResult)
                {
                    ITASSERT(FALSE);
                    SetErrCode(&hr, E_UNEXPECTED);
                    goto exit4;
                }

                // Copy the key to our local buffer
                MEMCPY(kwCur.szKeyword
                    + sizeof(DWORD), pvNewKey, CBMAX_KWENTRY);
            }
            else if(hr != E_NOTIMPL)
            {
                ITASSERT(FALSE);
                goto exit4;
            }
			if (FAILED(hr = FWriteData
                (pDataStream, &kwNext, &dwWritten, pOccDataBuffer)))
                goto exit4;

			if (pEnd == pCur)
				fEOF = 1;
			else
				pCur = ParseKeywordLine(pCur, &kwNext);
            reckw.cKeys++;
		}

        // Add record into B-Tree
		if (FAILED (hr = RcFillHbt(hbt,
            (KEY)kwCur.szKeyword + sizeof(DWORD),(QV)&reckw)))
			goto exit4;

        reckw.ilOffset += dwWritten + cbKeyProp;

        LKW kwTemp = kwCur;
		kwCur = kwNext;
        kwNext = kwTemp;
	}

	// ***********************************************
	// CLOSE THE BTREE FOR THIS KEYWORD SET, CLOSE THE 
	// .MVB SUBFILE, AND DISPOSE OF THE TEMPORARY FILE
	// ***********************************************
    pDataStream->Release();
    pDataStream = NULL;

	hr = RcFiniFillHbt(hbt);
    if (FAILED(hr))
		goto exit4;
							
	// ***********************************************
	// NOW, BUILD THE APPROPRIATE MAP FILE FOR EACH 
	// KEYWORD SET USED BY THE THUMB ON THE SCROLL BOX
	// ***********************************************
	if (FAILED (hr = RcCreateBTMapHfs(pIStorage, hbt, SZ_WORDWHEEL_MAP_A)))
		goto exit4;
	
	if (FAILED (hr = RcCloseBtreeHbt(hbt)))
		goto exit4;

    // Write PROPERTY file (contains property headers)
    DWORD dwSize;
    if (m_lpbKeyHeader)
    {
        pHeaderStream->Write (&m_cbKeyHeader, sizeof (DWORD), &dwWritten);
        pHeaderStream->Write (m_lpbKeyHeader, m_cbKeyHeader, &dwWritten);
    }
    else
    {
        dwSize = 0;
        pHeaderStream->Write (&dwSize, sizeof (DWORD), &dwWritten);
    }
	// For now, we have no default data
	dwSize = 0;
    pHeaderStream->Write (&dwSize, sizeof (DWORD), &dwWritten);

    if (m_lpbOccHeader)
    {
        pHeaderStream->Write (&m_cbOccHeader, sizeof (DWORD), &dwWritten);
        pHeaderStream->Write (m_lpbOccHeader, m_cbOccHeader, &dwWritten);
    }
    else
    {
        dwSize = 0;
        pHeaderStream->Write (&dwSize, sizeof (DWORD), &dwWritten);
    }
	// For now, we have no default data
	dwSize = 0;
    pHeaderStream->Write (&dwSize, sizeof (DWORD), &dwWritten);
    
	// *****************
	// TIDY UP AND LEAVE
	// *****************
	hr = S_OK;
	goto exit2;
} /* BuildPermanentFiles */


STDMETHODIMP CITWordWheelUpdate::ResolveGlobalProperties
    (IStream *pHeaderStream)
{
    DWORD dwSize, dwWritten;

    CloseHandle(m_hGlobalPropTempFile);
    m_hGlobalPropTempFile = NULL;
    if (!m_dwGlobalPropSize)
    {
        dwSize = 0;
	    pHeaderStream->Write (&dwSize, sizeof (DWORD), &dwWritten);
		
        DeleteFile(m_szGlobalPropTempFile);
        return S_OK;
    }

    HRESULT hr;
    IITPropList *plTemp = NULL;
    LPSTR pInput = NULL;
    ULARGE_INTEGER ulSize;

    // Map the temp file to memory
    pInput = MapSequentialReadFile(m_szGlobalPropTempFile, &dwSize);
    if (NULL == pInput)
    {
        SetErrCode(&hr, E_FAIL);
GlobalExit0:
        if (plTemp)
            plTemp->Release();
        if (pInput)
            UnmapViewOfFile (pInput);
        return hr;
    }

    // Create property list
    hr = CoCreateInstance(CLSID_IITPropList, NULL,
        CLSCTX_INPROC_SERVER, IID_IITPropList,(LPVOID *)&plTemp);
    if (FAILED(hr))
        goto GlobalExit0;

    // Load list from temp file
    if (FAILED (hr = plTemp->LoadFromMem (pInput, dwSize)))
        goto GlobalExit0;

    // Get list size
    plTemp->GetSizeMax(&ulSize);

    // Write the property list size
    hr = pHeaderStream->Write
        (&ulSize.LowPart, sizeof(ulSize.LowPart), &dwSize);
    if (FAILED(hr))
        goto GlobalExit0;

    // Write the property list
    if (FAILED(hr = plTemp->Save(pHeaderStream, TRUE)))
        goto GlobalExit0;

    plTemp->Release();
    UnmapViewOfFile (pInput);

    DeleteFile(m_szGlobalPropTempFile);
    return S_OK;
} /* ResolveGlobalProperties */


STDMETHODIMP CITWordWheelUpdate::GetClassID(CLSID *pClsID)
{
    if (NULL == pClsID
        || IsBadWritePtr(pClsID, sizeof(CLSID)))
        return SetErrReturn(E_INVALIDARG);

    *pClsID = CLSID_IITWordWheelUpdate;
    return S_OK;
} /* GetClassID */


STDMETHODIMP CITWordWheelUpdate::IsDirty(void)
{
    if (m_fIsDirty)
        return S_OK;
    return S_FALSE;
} /* IsDirty */


STDMETHODIMP CITWordWheelUpdate::Load(IStorage *pStg)
{
    return SetErrReturn(E_NOTIMPL);
} /* Load */


STDMETHODIMP CITWordWheelUpdate::InitNew(IStorage *pStg)
{
    if (m_pStorage)
        return SetErrReturn(CO_E_ALREADYINITIALIZED);

    if (NULL == pStg)
        return SetErrReturn(E_INVALIDARG);

    m_pStorage = pStg;
    pStg->AddRef();

    m_fIsDirty = FALSE;

    // Create a temp file
    char szTempPath [_MAX_PATH + 1];
    if (0 == GetTempPath(_MAX_PATH, szTempPath))
        return SetErrReturn(E_FILECREATE);
    if (0 == GetTempFileName(szTempPath, "WWU", 0, m_szTempFile))
        return SetErrReturn(E_FILECREATE);
    m_hTempFile = CreateFile
       (m_szTempFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
        FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (INVALID_HANDLE_VALUE == m_hTempFile)
        return SetErrReturn(E_FILECREATE);

    if (0 == GetTempFileName(szTempPath, "WWU", 0, m_szGlobalPropTempFile))
        return SetErrReturn(E_FILECREATE);
    m_hGlobalPropTempFile = CreateFile(m_szGlobalPropTempFile,
        GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
        FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (INVALID_HANDLE_VALUE == m_hGlobalPropTempFile)
        return SetErrReturn(E_FILECREATE);
    
    // Reset member variables
    m_dwEntryCount = 0;
    m_dwGlobalPropSize = 0;

    m_lpbKeyHeader = m_lpbOccHeader = NULL;
    m_cbMaxKeyData = m_cbMaxOccData = 0;

    m_fInitialized = TRUE;

    return S_OK;
} /* InitNew */

STDMETHODIMP CITWordWheelUpdate::SaveCompleted(IStorage *pStgNew)
{
    if (pStgNew)
    {
        if (!m_pStorage)
            return SetErrReturn(E_UNEXPECTED);
        m_pStorage->Release();
        (m_pStorage = pStgNew)->AddRef();
    }
    m_fIsDirty = FALSE;
    return S_OK;
} /* SaveCompleted */


STDMETHODIMP CITWordWheelUpdate::HandsOffStorage(void)
{
    return S_OK;
} /* HandsOffStorage */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\bscb.cpp ===
// BSCB.cpp -- Implementation for the CBindStatusCallBack class

#include "stdafx.h"

HRESULT STDMETHODCALLTYPE CBindStatusCallBack::CreateHook(IBindCtx pBC, IMoniker pMK)
{
    CBindStatusCallBack *pBSCB     = New CBindStatusCallBack(NULL);
    IBindStatusCallback *pCallBack = NULL;

    HRESULT hr = FinishSetup(pBSCB? pBSCB->m_Implementation.Init(pBC, pMK)
                                  : STG_E_INSUFFICIENTMEMORY,
                             pBSCB, IID_IBindStatusCallback, (PPVOID) &pCallBack
                            );

    if (pCallBack) pCallBack->Release();
}

CBindStatusCallBack::Implementation::Implementation
    (CBindStatusCallBack *pBackObj, IUnknown *punkOuter)
    : ITBindStatusCallback(pBackObj, punkOuter)

{
    m_pBCHooked   = NULL;
    m_pBSCBClient = NULL;
    m_pStream     = NULL;
    m_grfBINDF    = 0;
    m_awcsFile[0] = 0;
    m_fTempFile   = FALSE;

    m_bindinfo.cbSize = sizeof(BINDINFO);
}

CBindStatusCallBack::Implementation::~Implementation()
{
    if (m_pStream) m_pStream->Release();

    if (m_fTempFile)
    {
        RonM_ASSERT(m_awcsFile[0]);

        UINT cwc = wcsLen(m_awcsFile) + 1;
        UINT cb  = cwc * sizeof(WCHAR);
        
        char *pszFile = PCHAR(_alloca(cb));

        RonM_ASSERT(pszFile);

        if (pchr)
        {
            UINT c = WideCharToMultiByte(GetACP(), WC_COMPOSITECHECK, m_awcsFile, cwc, 
                                         pszFile, cb, NULL, NULL
                                        );
            
            RonM_ASSERT(c);

            if (c) DeleteFile(pszFile);
        }
    }

    if (m_pBC)
        RevokeBindStatusCallback(m_pBC, this); 
    
    if (m_pBSCBClient) m_pBSCBClient->Release();
}

HRESULT STDMETHODCALLTYPE CBindStatusCallBack::Implementation::Init(IBindCtx pBC, IMoniker pMK)
{
    RonM_ASSERT(pBC);
    RonM_ASSERT(pMK);

    if (!SUCCEEDED(hr)) return hr;

    HRESULT hr = pMK->BindToStorage(pBC, NULL, IID_IStream, (PPVOID) &pStrm1);

    if (!SUCCEEDED(hr)) return hr;
    
    IUnknown *pUnk = NULL;

    hr = pBC->GetObjectParam(L"_BSCB_HOLDER_", &pUnk);

    if (!SUCCEEDED(hr)) return hr;
    
    hr = pUnk->QueryInterface(IID_IBindStatusCallback, &m_pBSCBClient);

    pUnk->Release();

    if (!SUCCEEDED(hr)) return hr;

    hr = RegisterBindStatusCallback(pBC, this, &m_pBSCBClient, 0);

    if (!SUCCEEDED(hr)) return hr;

    m_pBC = pBC;

    m_pBC->AddRef();

    RonM_ASSERT(statstg.cbSize.HighPart == 0);

    m_pBSCBClient->GetBindInfo(&m_grfBINDF, &m_bindinfo);

    if (!SUCCEEDED(hr)) return hr;

    IStream *pStrmITS = NULL;

    hr = GetStreamFromMoniker(pBC, pMK, m_grfBINDF, m_awcsFile, &m_pStream);

    if (hr == S_FALSE) m_fTempFile = TRUE;

    if (!SUCCEEDED(hr)) return hr;

    STATSTG statstg;

    hr = m_pStream->Stat(&statstg, STATFLAG_NONAME);

    if (!SUCCEEDED(hr)) return hr;

    hr = m_pBSCBClient->OnProgress(0, statstg.cbSize.LowPart, 
                                   BINDSTATUS_SENDINGREQUEST, L""
                                  ); 

    if (!SUCCEEDED(hr)) return hr;

    hr = m_pBSCBClient->OnProgress(0, statstg.cbSize.LowPart, 
                                   BINDSTATUS_BEGINDOWNLOADDATA, L""
                                  ); 

    if (!SUCCEEDED(hr)) return hr;

    if (m_awcsFile[0])
    {
        hr = m_pBSCBClient->OnProgress(0, statstg.cbSize.LowPart, 
                                       BINDSTATUS_CACHEFILENAMEAVAILABLE, m_awcsFile
                                      ); 

        if (!SUCCEEDED(hr)) return hr;
    }

    hr = m_pBSCBClient->OnProgress(0, statstg.cbSize.LowPart, 
                                   BINDSTATUS_DOWNLOADINGDATA, L""
                                  ); 

    if (!SUCCEEDED(hr)) return hr;

    hr = m_pBSCBClient->OnProgress(statstg.cbSize.LowPart, statstg.cbSize.LowPart, 
                                   ENDDOWNLOADDATA, L""
                                  ); 

    if (!SUCCEEDED(hr)) return hr;

    FORMATETC fmetc;
    STGMEDIUM stgmed;

    hr = m_pBSCBClient->OnDataAvailable(BSCF_FIRSTDATANOTIFICATION | BSCF_LASTDATANOTIFICATION
                                                                   | BSCF_DATAFULLYAVAILABLE, 
                                        statstg.cbSize.LowPart, 
                                        FORMATETC *pfmtetc, 
                                        STGMEDIUM *pstgmed
                                       );

    return hr;
}

HRESULT STDMETHODCALLTYPE CopyStreamToFile(IStream *ppStreamSrc, const WCHAR *pwcsFilePath)
{            
    IStream *pStream;
    IStream *pStreamSrc = *ppStreamSrc;

    IFSStorage *pFSS = NULL;

    HRESULT hr = CFileSystemStorage::Create(NULL, IID_IFSStorage, (VOID **) &pFSS);

    if (!SUCCEEDED(hr)) return hr;

    hr = pFSS->FSOpenStream((const WCHAR *) pwcsFilePath, 
                            STGM_READWRITE | STGM_SHARE_DENY_NONE,
                            &pStream
                           );

    pFSS->Release();

    if (!SUCCEEDED(hr)) return hr;

    RonM_ASSERT(pStreamSrc);

    STATSTG statstg;

    hr = pStreamSrc->Stat(&statstg, STATFLAG_NONAME);

    if (!SUCCEEDED(hr)) return hr;

#ifdef _DEBUG    
    hr = 
#endif // _DEBUG
        pStreamSrc->Seek(CLINT(0).Li(), STREAM_SEEK_SET, NULL); 

    RonM_ASSERT(hr == S_OK);

    hr = pStreamSrc->CopyTo(pStream, statstg.cbSize, NULL, NULL);

    pStream->Release();

    if (!SUCCEEDED(hr)) return hr;

#ifdef _DEBUG    
    hr = 
#endif // _DEBUG
        pStream->Seek(CLINT(0).Li(), STREAM_SEEK_SET, NULL); 

#ifdef _DEBUG    
    hr = 
#endif // _DEBUG
        pStreamSrc->Seek(CLINT(0).Li(), STREAM_SEEK_SET, NULL); 

    RonM_ASSERT(hr == S_OK);

    *ppStreamSrc->Release();
    *ppStreamSrc = pStream;

    return hr;
}

HRESULT STDMETHODCALLTYPE GetStreamFromMoniker
    (IBindCtx *pBC, IMoniker *pMK, DWORD grfBINDF, PSZ pwcsFile, IStream **ppStrm)
{
    BOOL fNoFile = m_grfBINDF & (BINDF_PULLDATA | BINDF_DIRECT_READ);

    BOOL fNoReadCache = m_grfBINDF & (BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE
                                                             | BINDF_PULLDATA
                                                             | BINDF_PRAGMA_NO_CACHE
                                                             | BINDF_DIRECT_READ
                                     );

    BOOL fNoWriteCache = m_grfBINDF & (BINDF_NOWRITECACHE | BINDF_PULLDATA
                                                          | BINDF_PRAGMA_NO_CACHE
                                                          | BINDF_DIRECT_READ
                                      );

    BOOL fTempFile = FALSE;
    
    WCHAR   *pwcsDisplayName = NULL;
    char    *pcsDisplayName  = NULL;
    WCHAR   *pwcsExtension   = NULL;
    WCHAR   *pwcsName        = NULL;
    IStream *pStrmITS        = NULL;

    HRESULT hr = pMK->GetDisplayName(pBCtx, NULL, &pwcsDisplayName);
    
    if (!SUCCEEDED(hr)) return hr;

    UINT cwc = wcsLen(pwcsDisplayName);
    UINT cb  = sizeof(WCHAR) * (cwc + 1);
    
    *pcsDisplayName = PCHAR(_alloca(cb));

    if (!pcsDisplayName)
    {
        hr = E_OUTOFMEMORY;
        goto exit_GetStreamFromMoniker;
    }

    cb = WideCharToMultiByte(GetACP(),	WC_COMPOSITECHECK, pwcsDisplayName, cwc + 1, 
                             pcsDisplayName, cb, NULL, NULL
                            );

    if (!cb)
    {
        hr = INET_E_DOWNLOAD_FAILURE;
        goto exit_GetStreamFromMoniker;
    }

    {
        UINT cwc = wcsLen(pwcsURL);

        WCHAR *pwc = pwcsURL + cwc;

        for (;;)
        {
            WCHAR wc = *--pwc;

            if (wc == L'.')
                pwcsExtension = pwc + 1;

            if (wc == L':' || wc == L'/' || wc == L'\\')
            {
                pwcsName = ++pwc; 

                break;
            }

            RonM_ASSERT(--cwc);
        }
    }    

    hr = pMK->BindToStorage(pBC, NULL, IID_IStream, (VOID **) &pStrmITS);

    if (!SUCCEEDED(hr)) goto exit_GetStreamFromMoniker;

    STATSTG statstg;

    hr = pStrmITS->Stat(&statstg, STATFLAG_NONAME);

    if (!SUCCEEDED(hr)) goto exit_GetStreamFromMoniker;

    FILETIME ftLastModified;

    ftLastModified.dwLowDateTime  = 0;
    ftLastModified.dwHighDateTime = 0;
    
    // pMK->GetTimeOfLastChange(pBCtx, NULL, &ftLastModified); 

    RonM_ASSERT(statstg.cbSize.HighPart == 0);

    *pszFile = 0; // In case we don't get the stream into a file.

    if (!fNoFile)
    {
        CHAR   acsFilePath[MAX_PATH];
        WCHAR awcsFilePath[MAX_PATH];
        char    szTempPath[MAX_PATH];

        szTempPath[0] = 0;

        PCHAR pcsExtension = "";

        if (pwcsExtension && pwcsExtension[1])
        {
            UINT cwc = wcsLen(pwcsExtension);
            UINT cb  = sizeof(WCHAR) * (cwc + 1);

            pcsExtension = PCHAR(_alloca(cb));

            if (!pcsExtension)
            {
                hr = E_OUTOFMEMORY;
                goto exit_GetStreamFromMoniker;
            }

            cb = WideCharToMultiByte(GetACP(),	WC_COMPOSITECHECK, pwcsExtension, cwc + 1, 
                                     pcsExtension, cb, NULL, NULL
                                    );

            if (!cb)
            {
                hr = INET_E_DOWNLOAD_FAILURE;
                goto exit_GetStreamFromMoniker;
            }
        }

        if (fNoWriteCache)
        {
            DWORD cbPath= GetTempPath(MAX_PATH, szTempPath);

            if (!cbPath)
                lstrcpyA(szTempPath, ".\\");

            char szPrefix[4] = "IMT"; // BugBug! May need to make this a random string.

            char szFullPath[MAX_PATH];

            if (!GetTempFileName(szTempPath, szPrefix, 0, szFullPath))
            {
                hr = CFSLockBytes::CImpILockBytes::STGErrorFromFSError(GetLastError());
                szTempPath[0] = 0;
                goto exit_GetStreamFromMoniker;
            }

            lstrcpyA(szTempPath, szFullPath);

            char *pch = szTempPath + lstrlenA(szTempPath);

            for (;;)
            {
                if (pch == szTempPath)
                {
                    RonM_ASSERT(FALSE);
                    
                    hr = E_UNEXPECTED;
                    
                    DeleteFile(szTempPath);
                    szTempPath[0] = 0;
                    goto exit_GetStreamFromMoniker;
                }

                if ('.' == *--pch)
                {
                    ++pch;
                    break;
                }
            }

            UINT cbExtension = lstrlenA(pcsExtension);

            if (pch + cbExtension - szTempPath >= MAX_PATH)
            {
                hr = E_UNEXPECTED;
                
                DeleteFile(szTempPath);
                szTempPath[0] = 0;
                goto exit_GetStreamFromMoniker;
            }

            CopyMemory(pch, pcsExtension, cbExtension + 1);

            if (!MoveFileEx(szFullPath, szTempPath, MOVEFILE_REPLACE_EXISTING))
            {
                hr = E_UNEXPECTED;
                
                DeleteFile(szFullPath);
                szTempPath[0] = 0;
                goto exit_GetStreamFromMoniker;
            }

            UINT cwc = MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, szTempPath,
                                           1 + lstrlenA(szTempPath), awcsFilePath, MAX_PATH
                                          );

            if (cwc)
                 hr = CopyStreamToFile(&pStrmITS, (const WCHAR *)awcsFilePath);
            else hr = E_UNEXPECTED;
        
            if (SUCCEEDED(hr))
            {
                fTempFile = TRUE;
                CopyMemory(pwcsFile, awcsFilePath, cwc * sizeof(WCHAR));
            }
            else
            {
                DeleteFile(szTempPath);
                goto exit_GetStreamFromMoniker;
            }
        }
        else
        {
            DWORD dwCEISize = 0;

            BOOL fResult = RetrieveUrlCacheEntryFile(pcsDisplayName, NULL, &dwCEISize, 0);
            
            RonM_ASSERT(!fResult);

            ULONG ulErr= GetLastError();

            if (ulErr == ERROR_INSUFFICIENT_BUFFER)
            {
                INTERNET_CACHE_ENTRY_INFOA *pCEI = (INTERNET_CACHE_ENTRY_INFOA *) _alloca(dwCEISize);
            
                if (!pCEI)
                {
                    hr = E_OUTOFMEMORY;

                    goto exit_GetStreamFromMoniker;
                }
            
                pCEI->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFOA);

                fResult = RetrieveUrlCacheEntryFile(pcsDisplayName, pCEI, &dwCEISize, 0);

                ulErr = GetLastError();

                if (fResult)
                    if (   pCEI->LastModifiedTime.dwLowDateTime  == ftLastModified.dwLowDateTime
                        && pCEI->LastModifiedTime.dwHighDateTime == ftLastModified.dwHighDateTime
                        && pCEI->dwSizeLow  == statstg.cbSize.LowPart
                        && pCEI->dwSizeHigh == statstg.cbSize.HighPart
                       )
                    {
                        lstrcpyA(acsFilePath, pCEI->lpszLocalFileName);
                        cwc = MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, 
                                                  acsFilePath, 1 + lstrlenA(acsFilePath), 
                                                  awcsFilePath, MAX_PATH
                                                 );

                        RonM_ASSERT(cwc != 0);
                    }
                    else 
                    {    
                        UnlockUrlCacheEntryFile(pcsDisplayName, 0);
                        fResult = FALSE;
                    }
            }

            if (!fResult)
            {
                fResult = CreateUrlCacheEntryA(pcsDisplayName, statstg.cbSize.LowPart, 
                                               pcsExtension, acsFilePath, 0
                                              );

                if (!fResult)
                {
                    hr = INET_E_CANNOT_INSTANTIATE_OBJECT;
                    goto exit_GetStreamFromMoniker;
                }

                cwc = MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, acsFilePath,
                                          1 + lstrlenA(acsFilePath), awcsFilePath, MAX_PATH
                                         );

                hr = CopyStreamToFile(&pStrmITS, (const WCHAR *) awcsFilePath);

                if (!fResult)
                {
                    hr = INET_E_CANNOT_INSTANTIATE_OBJECT;
                    goto exit_GetStreamFromMoniker;
                }

                FILETIME ftExpire;

                ftExpire.dwLowDateTime  = 0;
                ftExpire.dwHighDateTime = 0;

                fResult = CommitUrlCacheEntryA(pcsDisplayName, acsFilePath, ftExpire,
                                               ftLastModified, NORMAL_CACHE_ENTRY, NULL, 
                                               0, pcsExtension, 0
                                              );

                if (!fResult)
                {
                    ulErr= GetLastError();
                    hr = INET_E_CANNOT_INSTANTIATE_OBJECT;
                    goto exit_GetStreamFromMoniker;
                }

                fResult = RetrieveUrlCacheEntryFile(pcsDisplayName, NULL, &dwCEISize, 0);
        
                RonM_ASSERT(!fResult);

                ulErr= GetLastError();

                if (ulErr == ERROR_INSUFFICIENT_BUFFER)
                {
                    INTERNET_CACHE_ENTRY_INFOA *pCEI = (INTERNET_CACHE_ENTRY_INFOA *) _alloca(dwCEISize);
        
                    if (!pCEI)
                    {
                        hr = E_OUTOFMEMORY;
                        goto exit_GetStreamFromMoniker;
                    }
        
                    pCEI->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFOA);

                    fResult = RetrieveUrlCacheEntryFile(pcsDisplayName, pCEI, &dwCEISize, 0);

                    if (!fResult)
                    {
                        ulErr= GetLastError();
                        hr = INET_E_CANNOT_INSTANTIATE_OBJECT;
                        goto exit_GetStreamFromMoniker;
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr)) && awcsFilePath[0])
        CopyMemory(pwcsFile, awcsFilePath, (wcsLen(awcsFilePath) + 1) * sizeof(WCHAR));
    
    *ppStrm = pStrmITS;  pStrmITS = NULL;

    hr = fTempFile? S_FALSE : S_OK;

exit_GetStreamFromMoniker:

    if (pStrmITS       ) pStrmITS->Release();
    if (pwcsDisplayName) OLEHeap()->Free(pwcsDisplayName);
        
    return hr;    
}

// IBindStatusCallback methods:

HRESULT STDMETHODCALLTYPE CBindStatusCallBack::Implementation::OnStartBinding( 
/* [in] */ DWORD dwReserved,
/* [in] */ IBinding __RPC_FAR *pib)
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CBindStatusCallBack::Implementation::GetPriority( 
	/* [out] */ LONG __RPC_FAR *pnPriority)
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CBindStatusCallBack::Implementation::OnLowResource( 
	/* [in] */ DWORD reserved)
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CBindStatusCallBack::Implementation::OnProgress( 
	/* [in] */ ULONG ulProgress,
	/* [in] */ ULONG ulProgressMax,
	/* [in] */ ULONG ulStatusCode,
	/* [in] */ LPCWSTR szStatusText)
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CBindStatusCallBack::Implementation::OnStopBinding( 
	/* [in] */ HRESULT hresult,
	/* [unique][in] */ LPCWSTR szError)
{
    return S_OK;
}

/* [local] */ HRESULT STDMETHODCALLTYPE CBindStatusCallBack::Implementation::GetBindInfo( 
	/* [out] */ DWORD __RPC_FAR *grfBINDF,
	/* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo)
{
    return S_OK;
}

/* [local] */ HRESULT STDMETHODCALLTYPE CBindStatusCallBack::Implementation::OnDataAvailable( 
	/* [in] */ DWORD grfBSCF,
	/* [in] */ DWORD dwSize,
	/* [in] */ FORMATETC __RPC_FAR *pformatetc,
	/* [in] */ STGMEDIUM __RPC_FAR *pstgmed)
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CBindStatusCallBack::Implementation::OnObjectAvailable( 
	/* [in] */ REFIID riid,
	/* [iid_is][in] */ IUnknown __RPC_FAR *punk)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\buffer.h ===
// Buffer.h -- Declaration for CBuffer, a shared buffer object

#ifndef __BUFFER_H__

#define __BUFFER_H__

class CBufferRef;

class CBuffer 
{

    friend class CBufferRef;

public:

	CBuffer(UINT cbInitial = 0);
	~CBuffer();

private:

    void Resize(UINT cbRequired);
	
	BYTE *m_pb;
	UINT  m_cb;
	
	CITCriticalSection m_cs;	
};

class CBufferRef
{
public:
	
	 CBufferRef(CBuffer &Buff, UINT cbRequired);
	~CBufferRef();

	PBYTE StartAddress();

private:

    CBuffer *m_pBuff;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\buffer.cpp ===
// buffer.cpp

#include <stdafx.h>

CBuffer::CBuffer(UINT cbInitial)
{
    m_pb = NULL;
	m_cb = 0;

    if (cbInitial) 
    {
        m_cs.Enter();
            Resize(cbInitial);
        m_cs.Leave();
    }
}

CBuffer::~CBuffer()
{
    RonM_ASSERT(m_cs.LockCount() == 0);

    if (m_pb) delete [] m_pb;
}

void CBuffer::Resize(UINT cbRequired)
{
    RonM_ASSERT(m_cs.LockCount());
    RonM_ASSERT(cbRequired > m_cb);

    if (m_pb) { delete [] m_pb;  m_pb = NULL;  m_cb = 0; }

    PBYTE pb = New BYTE[cbRequired];

    if (!pb) return; // Failures here will become apparent 
                     // when CBufferRef::StartAddress is called.

    m_pb = pb;
    m_cb = cbRequired;
}

CBufferRef::CBufferRef(CBuffer &Buff, UINT cbRequired)
{
    m_pBuff = &Buff;

    m_pBuff->m_cs.Enter();

    if (cbRequired > m_pBuff->m_cb) m_pBuff->Resize(cbRequired);
}

CBufferRef::~CBufferRef()
{
    m_pBuff->m_cs.Leave();
}

PBYTE CBufferRef::StartAddress()
{
    return m_pBuff->m_pb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\casemap.h ===
// CaseMap.h -- Header for the unicode case mapping routines for locale 0x0409

#ifndef __CASEMAP_H__

#define __CASEMAP_H__

/* 

  These routines implement the case mapping defined for Unicode in the 
US English locale. The implementation does not rely on operating system
facilities and is therefore portable. We use these interfaces to do case
insensitive comparisons in our file-system B-Trees.

 */

WCHAR WC_To_0x0409_Upper(WCHAR wc); // Maps one Unicode code point to upper case.
WCHAR WC_To_0x0409_Lower(WCHAR wc); // Maps one Unicode code point to lower case.

inline BOOL Is_WC_Letter(WCHAR wc)
{
    return (wc != WC_To_0x0409_Upper(wc) || wc != WC_To_0x0409_Lower(wc));
}

// wcsicmp_0x0409 is a case insensitive Unicode string comparison routine.

INT wcsicmp_0x0409(const WCHAR * pwcLeft, const WCHAR *pwcRight);

#endif // __CASEMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\casemap.cpp ===
// CaseMap.cpp -- Unicode case mapping routines for locale 0x0409
#include "stdafx.h"

/*

  The data constants and code below implement case mapping for the US English
locale. The primary goal here was to make the size of code plus data as small
as possible while keeping reasonable run-time speed. 

  The easiest implmentation would have been to simply define a 65,536 entry
table of USHORT values. Then the case mapping would be just an array indexing
operation. However the data size to upper and lower case mapping would be
256 K bytes. That clearly unacceptable -- especially since there are only 736
letter characters in the Unicode set.

  The next approach is to make a short list of the letter positions together
with the corresponding case-mapped positions. That gives us a data size of
5,888 bytes (8 x 736). Then we also need code to binary-search the list of
letter positions to see if a particular code point has a case mapping and,
if so, to locate the corresponding mapped value.

  This is good, but we can do better by noticing that the case mapping is not
random. Quite often a continguous block of Unicode code points map to positions
with the same relative offset. In the Ascii section, for example the 26 lower
case letters all map down by 0x20 positions, while the 26 upper case letters 
map up by 0x20 positions. In other areas of Unicode we find that quite often
every other position uses the same relative offset. 

  That observation together with some simple methods to pack information 
efficiently leads to the current implementation which uses 840 bytes of data
and a look-up algorithm which is just a little bit more complicated than a
binary search.

  We could probably make the data smaller still by using a more complicated
data structure and a more complicated algorithm, but it isn't clear that the
additional effort would be worthwhile. That is, the additional code space may
well be larger than the data-space savings.
 
 */

#include "CaseTab.h"

// The code below does case mapping using a binary search to find the appropriate
// code map block and then applying that block. For the case insensitive string
// comparison, we keep the most recently used block around so that we can avoid
// the binary search in many cases.

static CodeMapBlock Find_0x0409_Map_Block(WCHAR wc, 
                                          const CodeMapBlock *pCMB,
                                          UINT  cBlocks
                                         )
{
    UINT iBlockLow  = 0;

    if (wc < pCMB[iBlockLow].iwcFirst) 
        return UCMB_NULL.cmb; // Map block with zero entries based at zero offset.

    UINT iBlockHigh = cBlocks;

    for (;;)
    {
        UINT iBlockMid = (iBlockLow + iBlockHigh) >> 1;
         
        CodeMapBlock mblk = pCMB[iBlockMid];

        if (iBlockMid == iBlockLow) 
            return mblk; // iBlockHigh must have been iBlockLow + 1.

        if (wc >= mblk.iwcFirst)
             iBlockLow  = iBlockMid;
        else iBlockHigh = iBlockMid;
    }
}

static WCHAR Map_from_0x0409_Block(WCHAR wc, 
                                   CodeMapBlock mblk, 
                                   const short *paiDeltaValues
                                  )
{
    UINT iBaseNew = mblk.iwcFirst;

    if (wc >= iBaseNew + mblk.cwcSpan)
        return wc;

    if (mblk.fGapIs2 && UINT(wc & 1) != (iBaseNew & 1))
        return wc;

    return wc + paiDeltaValues[mblk.iDelta]; 
}

static WCHAR Map_to_0x0409_Case(WCHAR wc, 
                                const short *paiDeltaValues, 
                                const CodeMapBlock *pCMB,
                                UINT cBlocks
                               )
{
    return Map_from_0x0409_Block
               (wc, 
                Find_0x0409_Map_Block(wc, pCMB, cBlocks), 
                paiDeltaValues
               );
}

static WCHAR Map_to_0x0409_Lower_with_History(WCHAR wc, 
                                              CodeMapBlock &mblkLower, 
                                              CodeMapBlock &mblkUpper
                                             )
{
    // This routine does a lower case mapping optimized for text which is mostly
    // letters. It also looks for characters which commonly occur in file and
    // stream paths. 
    //
    // The main trick here is to keep track of the last letter mapping we used
    // because it is probably still valid. If it isn't we adjust the mappings
    // to match the kind of letter character we're processing.
    
    if (   wc <  L'A'   // Below the first letter?
        || wc == L'\\'  // Path separator?
       ) 
        return wc;

    if (wc >= mblkLower.iwcFirst && wc < mblkLower.iwcFirst + mblkLower.cwcSpan)
        return Map_from_0x0409_Block(wc, mblkLower, aiDeltaValues_Lower);

    if (wc >= mblkUpper.iwcFirst && wc < mblkUpper.iwcFirst + mblkUpper.cwcSpan)
    {
        if (wc != Map_from_0x0409_Block(wc, mblkUpper, aiDeltaValues_Upper))
            return wc; // WC was a lower case letter already!
    }

    CodeMapBlock mblkLC = Find_0x0409_Map_Block
                              (wc, 
                               &(UCMB_Lower->cmb), 
                               sizeof(UCMB_Lower) / sizeof(UCodeMapBlock)
                              );

    CodeMapBlock mblkUC = Find_0x0409_Map_Block
                              (wc, 
                               &(UCMB_Upper->cmb), 
                               sizeof(UCMB_Upper) / sizeof(UCodeMapBlock)
                              );

    WCHAR wcLC = Map_from_0x0409_Block(wc, mblkLC, aiDeltaValues_Lower);
    WCHAR wcUC = Map_from_0x0409_Block(wc, mblkUC, aiDeltaValues_Upper);

    if (wcLC != wc || wcUC != wc) // Was wc a letter? 
    {
        mblkLower = mblkLC; 
        mblkUpper = mblkUC;
    }    
    
    return wcLC;
}

INT wcsicmp_0x0409(const WCHAR * pwcLeft, const WCHAR *pwcRight)
{
    CodeMapBlock mblkUC = UCMB_NULL.cmb;    
    CodeMapBlock mblkLC = UCMB_NULL.cmb;
    
    const WCHAR *pwcLeftBase  = pwcLeft;
    const WCHAR *pwcRightBase = pwcRight;
    
    // The code below returns zero when the two strings differ only by case.
    // Otherwise the value it returns will order strings by their Unicode character
    // values. This is important for later path manager implementations which use
    // Trie structures.

    for (;;)
    {
        WCHAR wcLeft  = Map_to_0x0409_Lower_with_History(*pwcLeft ++, mblkLC, mblkUC);
        WCHAR wcRight = Map_to_0x0409_Lower_with_History(*pwcRight++, mblkLC, mblkUC);

        INT diff= wcLeft - wcRight;

        if (diff || !wcLeft) 
            return diff; 
    }
}

WCHAR WC_To_0x0409_Upper(WCHAR wc)
{
    return Map_to_0x0409_Case(wc, (const short*) &aiDeltaValues_Upper, &(UCMB_Upper->cmb), 
                             sizeof(UCMB_Upper) / sizeof(UCodeMapBlock)
                            );
}

WCHAR WC_To_0x0409_Lower(WCHAR wc)
{
    return Map_to_0x0409_Case(wc, (const short *) &aiDeltaValues_Lower, &(UCMB_Lower->cmb), 
                             sizeof(UCMB_Lower) / sizeof(UCodeMapBlock)
                            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\bscb.h ===
// BSCB.h -- Class definition for an IBindStatusCallback hook

#ifndef __BSCB_H__

#define __BSCB_H__

class CBindStatusCallBack : public ITBindStatusCallBack
{
public:

	static HRESULT STDMETHODCALLTYPE CreateHook(IBindCtx pBC, IMoniker pMK);

	~CBindStatusCallBack();

private:

	CBindStatusCallBack(IUnknown *pUnkOuter);

	class Implementation : ITBindStatusCallback
	{
		Implementation(CBindStatusCallBack *pBackObj, IUnknown *punkOuter);
		~Implementation();

        HRESULT STDMETHODCALLTYPE Init(IBindCtx pBC, IMoniker pMK);

		// IBindStatusCallback methods:
    
		HRESULT STDMETHODCALLTYPE OnStartBinding( 
        /* [in] */ DWORD dwReserved,
        /* [in] */ IBinding __RPC_FAR *pib);

		HRESULT STDMETHODCALLTYPE GetPriority( 
			/* [out] */ LONG __RPC_FAR *pnPriority);
    
		HRESULT STDMETHODCALLTYPE OnLowResource( 
			/* [in] */ DWORD reserved);
    
		HRESULT STDMETHODCALLTYPE OnProgress( 
			/* [in] */ ULONG ulProgress,
			/* [in] */ ULONG ulProgressMax,
			/* [in] */ ULONG ulStatusCode,
			/* [in] */ LPCWSTR szStatusText);
    
		HRESULT STDMETHODCALLTYPE OnStopBinding( 
			/* [in] */ HRESULT hresult,
			/* [unique][in] */ LPCWSTR szError);
    
		/* [local] */ HRESULT STDMETHODCALLTYPE GetBindInfo( 
			/* [out] */ DWORD __RPC_FAR *grfBINDF,
			/* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);
    
		/* [local] */ HRESULT STDMETHODCALLTYPE OnDataAvailable( 
			/* [in] */ DWORD grfBSCF,
			/* [in] */ DWORD dwSize,
			/* [in] */ FORMATETC __RPC_FAR *pformatetc,
			/* [in] */ STGMEDIUM __RPC_FAR *pstgmed);
    
		HRESULT STDMETHODCALLTYPE OnObjectAvailable( 
			/* [in] */ REFIID riid,
			/* [iid_is][in] */ IUnknown __RPC_FAR *punk);

    private:

        IBindCtx            *m_pBCHooked;
        IBindStatusCallback *m_pBSCBClient;
        IStream             *m_pStream;
        DWORD                m_grfBINDF;
        BINDINFO             m_bindinfo;
        char                 m_awcsFile[MAX_PATH];
        BOOL                 m_fTempFile;
	};

	Implementation m_Implementation;	
};

inline CBindStatusCallBack::CBindStatusCallBack(IUnknown *pUnkOuter)
    : m_Implementation(this, pUnkOuter), 
      CITUnknown(&IID_IBindStatusCallback, 1, &m_Implementation)
{
}

inline CBindStatusCallBack::~CBindStatusCallBack()
{
}

HRESULT STDMETHODCALLTYPE CopyStreamToFile(IStream **ppStreamSrc, const WCHAR *pwcsFilePath);

HRESULT STDMETHODCALLTYPE GetStreamFromMoniker
    (IBindCtx *pBC, IMoniker *pMK, DWORD grfBINDF, PWCHAR pwcsFile, IStream **ppStrm);

#endif // __BSCB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\comdll.cpp ===
// COMDLL.CPP -- Component Object Model plumbing for this DLL.

#include  "stdafx.h"

/* 

This module implements the lowest level of COM interface. It defines
DllMain, DllRegisterServer, DllUnregisterServer, DllCanUnloadNow, and
DllGetClassObject.    

DllMain initials the DLL and creates the CServerState object which
is used to keep counts for the active objects and locks.

DllRegisterServer adjusts the system registry to insert a mapping from 
our Class ID to the DLL's path and file name.

DllUnregisterServer removes that mapping from the registry.

DllCanUnloadNow tells the OLE environment whether this DLL can safely
be unloaded.

DllGetClassObject returns the Class Factory for the MVStorage class.

 */

UINT cInterfaces_CStorageMoniker ;  // = 0; // Not necessary in Win32
UINT cInterfaces_CPathManager    ;  // = 0; // Not necessary in Win32
UINT cInterfaces_CIOITnetProtocol;  // = 0; // Not necessary in Win32
UINT cInterfaces_CStorage        ;  // = 0; // Not necessary in Win32
UINT cInterfaces_CStream         ;  // = 0; // Not necessary in Win32
UINT cInterfaces_CFreeList       ;  // = 0; // Not necessary in Win32
UINT cInterfaces_CITStorage      ;

GUID aIID_CStorageMoniker[3];
GUID aIID_CPathManager[2];
GUID aIID_CIOITnetProtocol[3];
GUID aIID_CStorage[2];
GUID aIID_CStream[3];
GUID aIID_CFreeList[4];
GUID aIID_CITStorage[2];

void Init_IID_Arrays()
{
    aIID_CStorageMoniker[cInterfaces_CStorageMoniker++] = IID_IMoniker;
    aIID_CStorageMoniker[cInterfaces_CStorageMoniker++] = IID_IPersist;
    aIID_CStorageMoniker[cInterfaces_CStorageMoniker++] = IID_IPersistStream;

    RonM_ASSERT(sizeof(aIID_CStorageMoniker) / sizeof(GUID) == cInterfaces_CStorageMoniker);

    aIID_CPathManager[cInterfaces_CPathManager++] = IID_IPersist;
    aIID_CPathManager[cInterfaces_CPathManager++] = IID_PathManager;

    RonM_ASSERT(sizeof(aIID_CPathManager) / sizeof(GUID) == cInterfaces_CPathManager);

    aIID_CIOITnetProtocol[cInterfaces_CIOITnetProtocol++] = IID_IOInetProtocolRoot;
    aIID_CIOITnetProtocol[cInterfaces_CIOITnetProtocol++] = IID_IOInetProtocol;
    aIID_CIOITnetProtocol[cInterfaces_CIOITnetProtocol++] = IID_IOInetProtocolInfo;

    RonM_ASSERT(sizeof(aIID_CIOITnetProtocol) / sizeof(GUID) == cInterfaces_CIOITnetProtocol);

    aIID_CStorage[cInterfaces_CStorage++] = IID_IStorageITEx;
    aIID_CStorage[cInterfaces_CStorage++] = IID_IStorage;

    RonM_ASSERT(sizeof(aIID_CStorage) / sizeof(GUID) == cInterfaces_CStorage);

    aIID_CStream[cInterfaces_CStream++] = IID_ISequentialStream;
    aIID_CStream[cInterfaces_CStream++] = IID_IStream;
    aIID_CStream[cInterfaces_CStream++] = IID_IStreamITEx;

    RonM_ASSERT(sizeof(aIID_CStream) / sizeof(GUID) == cInterfaces_CStream);
    
    aIID_CFreeList[cInterfaces_CFreeList++] = IID_IFreeListManager;
    aIID_CFreeList[cInterfaces_CFreeList++] = IID_IPersistStreamInit;
    aIID_CFreeList[cInterfaces_CFreeList++] = IID_IPersistStream;
    aIID_CFreeList[cInterfaces_CFreeList++] = IID_IPersist;

    RonM_ASSERT(sizeof(aIID_CFreeList) / sizeof(GUID) == cInterfaces_CFreeList);

    aIID_CITStorage[cInterfaces_CITStorage++] = IID_ITStorage;
    aIID_CITStorage[cInterfaces_CITStorage++] = IID_ITStorageEx;

    RonM_ASSERT(sizeof(aIID_CITStorage) / sizeof(GUID) == cInterfaces_CITStorage);
}




CImpITUnknown *g_pImpITFileSystemList     ;  // = NULL; // Not necessary in Win32
CImpITUnknown *g_pFSLockBytesFirstActive  ;  // = NULL; // Not necessary in Win32
CImpITUnknown *g_pStrmLockBytesFirstActive;  // = NULL; // Not necessary in Win32
CImpITUnknown *g_pImpIFSStorageList       ;  // = NULL; // Not necessary in Win32

CITCriticalSection g_csITFS;

CServerState *pDLLServerState;  // = NULL; // Not necessary in Win32

UINT iSystemType = Unknown_System;
static int g_cProcessAttatches;

UINT cp_Default; // Defaults to NULL in Win32.
BOOL g_fDBCSSystem;

void InitLocaleInfo()
{
    g_fDBCSSystem = (BOOL) GetSystemMetrics(SM_DBCSENABLED);

    char szCP[20];

    LCID lcid = GetUserDefaultLCID();

    GetLocaleInfo(lcid, LOCALE_IDEFAULTANSICODEPAGE, szCP, sizeof(szCP));

    char *pch;

    for (cp_Default = 0, pch = szCP; ;)
    {
        char ch = *pch++;

        if (!ch) break;

        RonM_ASSERT(ch >= '0' && ch <= '9');

        cp_Default = (cp_Default * 10) + (ch - '0');
    }
}

HMODULE           hmodUrlMon        = NULL;
PFindMimeFromData pFindMimeFromData = NULL;

void SetUpIE4APIs()
{
    hmodUrlMon = LoadLibrary("UrlMon.dll");

    if (hmodUrlMon)
        pFindMimeFromData = (PFindMimeFromData) GetProcAddress(hmodUrlMon, "FindMimeFromData");
}

extern "C" BOOL WINAPI DllMain(HMODULE hModule, ULONG ul_reason_for_call, LPVOID lpReserved)
{
    switch(ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
		g_cProcessAttatches++;
        if (!pDLLServerState) // We can get several attach calls for the same process.
                              // One for each LoadLibrary call.
        {
            Init_IID_Arrays();

            InitLocaleInfo();

            SetUpIE4APIs();

			pDLLServerState = CServerState::CreateServerState(hModule);
            iSystemType     = (GetVersion() >> 30) & 3;

            pBufferForCompressedData = New CBuffer;

            RonM_ASSERT(pBufferForCompressedData);
        }
        
#ifdef _DEBUG
        CITUnknown::OpenReferee(); // Set up concurrency control
#endif // _DEBUG
        
        if (!pDLLServerState) return FALSE;

        return TRUE;

    case DLL_THREAD_ATTACH: // BugBug: Need to mark the DLL so that the
                            //         thread attach/detach calls aren't made.
        return TRUE;

    case DLL_THREAD_DETACH:

        return TRUE;

    case DLL_PROCESS_DETACH:
		RonM_ASSERT(g_cProcessAttatches > 0);
		if (--g_cProcessAttatches > 0)
			return TRUE;
#ifdef _DEBUG
        CITUnknown::CloseReferee(); // Delete concurrency resources
#endif // _DEBUG

		if (pDLLServerState)
		{
			CITUnknown::CloseActiveObjects();

            delete pDLLServerState;

			pDLLServerState = NULL;
		}

#ifdef _DEBUG
        DumpLZXCounts();
#endif // _DEBUG

        if (pBufferForCompressedData) delete pBufferForCompressedData;

		LiberateHeap();

        if (hmodUrlMon)
            FreeLibrary(hmodUrlMon);

        return TRUE;

    default:

        return FALSE;
    }
}

LONG SetRegClassKeyValue(LPSTR pszKey, LPSTR pszSubkey, LPSTR pszValueName, LPSTR pszValue)
{
    // This routine creates a registry key and sets its value. 
    // The key is created relative to HKEY_CLASSES_ROOT. The name
    // of the new key is constructed by combining the names denoted
    // by pszKey and pszSubkey. The pszSubkey parameter can be null.
    // If pszValue is non-null, the value which it denotes will 
    // bound to the key
    
    LONG  ec;
    HKEY  hKey;
    
    RonM_ASSERT(pszKey != NULL);

    // The lines below allocate a stack buffer large enough to construct
    // the complete key string. It is automatically discarded at function exit
    // time.
    
    UINT  cbKey = lstrlenA(pszKey) + (pszSubkey? lstrlenA(pszSubkey) + 1 : 0);

    RonM_ASSERT(cbKey < 0x1000); // To catch outlandishly big strings.

    PCHAR pacKeyBuffer = PCHAR(_alloca(cbKey + 1));
    
    lstrcpyA(pacKeyBuffer, pszKey);

    if (pszSubkey)
    {
        lstrcatA(pacKeyBuffer, "\\");
        lstrcatA(pacKeyBuffer, pszSubkey);
    }

    ec = RegCreateKeyEx(HKEY_CLASSES_ROOT, pacKeyBuffer, 0, NULL, 
                        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKey, NULL
                       );

    if (ec != ERROR_SUCCESS) return ec;

    if (pszValue)
        ec = RegSetValueEx(hKey, (const char *) pszValueName, 0, REG_SZ, 
		                   PBYTE(pszValue), lstrlenA(pszValue)+1
						  );

    RegCloseKey(hKey);

    return ec;
}

const UINT CBMAX_SUBKEY = 128;

BOOL DeleteKey(HKEY hkey, LPSTR pszSubkey)
{
    // This routine deletes a key heirarchy from the registry. The base of the
    // heirarchy is a key denoted by pszSubkey relative to the key denoted by
    // hkey. Since the NT registry implementation does not allow a key to be
    // deleted when it has subkeys, this routine will look for subkeys and 
    // recursively delete them before attempting to delete the key at the
    // base of the heirarchy.

    LONG ec;
    HKEY hkeyBase;

    ec= RegOpenKeyEx(hkey, pszSubkey, 0, KEY_ALL_ACCESS, &hkeyBase);
    if (ec != ERROR_SUCCESS) return FALSE;

    char  szSubkey[CBMAX_SUBKEY + 1];

    for (; ; )
    {
        DWORD cbSubkey= CBMAX_SUBKEY + 1;
        
        ec= RegEnumKeyEx(hkeyBase, 0, szSubkey, &cbSubkey, NULL, NULL, NULL, NULL); 
        
        if (ec != ERROR_SUCCESS)
        {
            if (ec == ERROR_NO_MORE_ITEMS) break;
        
            RonM_ASSERT(FALSE);
            
            RegCloseKey(hkeyBase);
            return FALSE;
        }

        if (!DeleteKey(hkeyBase, szSubkey)) 
        {
            RegCloseKey(hkeyBase);

            return FALSE;
        }
    }

    RegCloseKey(hkeyBase);

    ec= RegDeleteKey(hkey, pszSubkey);
    
    return (ec == ERROR_SUCCESS);
}

LONG RegisterClass(CHAR *szClassKey, CHAR *szTitle, CHAR *szModulePath, 
                   CHAR *szVersion, CHAR *szClass, BOOL fForceApartment
                  )
{
    LONG ec;
    
    ec= SetRegClassKeyValue(szClassKey, NULL, NULL, szTitle);
    if (ec != ERROR_SUCCESS) return ec;
    
    ec= SetRegClassKeyValue(szClassKey, "ProgID", NULL, CURRENT_VERSION);
    if (ec != ERROR_SUCCESS) return ec;
    
    ec= SetRegClassKeyValue(szClassKey, "VersionIndependentProgID", NULL, CLASS_NAME);
    if (ec != ERROR_SUCCESS) return ec;
    
    ec= SetRegClassKeyValue(szClassKey, "NotInsertable", NULL, NULL);
    if (ec != ERROR_SUCCESS) return ec;
    
    ec= SetRegClassKeyValue(szClassKey, "InprocServer32", NULL, szModulePath);
    if (ec != ERROR_SUCCESS) return ec;
    
    ec= SetRegClassKeyValue(szClassKey, "InprocServer32", "ThreadingModel", "Both");
    if (ec != ERROR_SUCCESS) return ec;

    return ERROR_SUCCESS;
}

const UINT GUID_SIZE = 38;

void CopyClassGuidString(REFGUID rguid, CHAR *pchBuff)
{
    WCHAR  wszCLSID[GUID_SIZE + 1];

    INT cchResult= 
        StringFromGUID2(rguid, wszCLSID, GUID_SIZE + 1);

    RonM_ASSERT(cchResult && cchResult == GUID_SIZE + 1);

#ifdef _DEBUG   
    cchResult= 
#endif // _DEBUG
        WideCharToMultiByte(CP_ACP,	WC_COMPOSITECHECK, wszCLSID, cchResult, 
                            pchBuff, GUID_SIZE + 1, NULL, NULL
                           );

    RonM_ASSERT(cchResult && cchResult == GUID_SIZE + 1);
}

extern "C" STDAPI DllRegisterServer(void)
{
    LONG ec;
    HKEY hKey = NULL;

    // First we turn on the MK protocol by installing the variable "MkEnabled"
    // in the registry options for Internet Explorer.
    
    ec = RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Explorer", 0, NULL, 
                        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKey, NULL
                       );

    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;

    ec = RegSetValueEx(hKey, (const char *)"MkEnabled", 0, REG_SZ, 
                       (const unsigned char *)"Yes", 4
                      );

    RegCloseKey(hKey);  hKey = NULL;

    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;

    CHAR *pszPrefix = "CLSID";

    const UINT cbPrefix = 5;

    RonM_ASSERT(cbPrefix == lstrlenA(pszPrefix));

    CHAR szModulePath[MAX_PATH + 2];
    GetModuleFileName(pDLLServerState->ModuleInstance(), szModulePath, MAX_PATH);

    /* Note: We're going to use the szKeyCLSID buffer to hold two overlapping
             strings. One is an embedded class id string. The other is a key
             string of the form CLSID/{ class-id string }.
     */
    
    CHAR szKeyCLSID[GUID_SIZE + cbPrefix + 2];

    lstrcpyA(szKeyCLSID, pszPrefix);
    szKeyCLSID[cbPrefix] = '\\';
    
    PCHAR pszCLSID = szKeyCLSID + cbPrefix + 1;

    CopyClassGuidString(CLSID_ITStorage, pszCLSID);

    ec= SetRegClassKeyValue(CLASS_NAME, NULL, NULL, "Microsoft InfoTech IStorage System");
    
    ec= SetRegClassKeyValue(CLASS_NAME, "CurVer", NULL, CURRENT_VERSION);
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
    
    ec= SetRegClassKeyValue(CLASS_NAME, pszPrefix, NULL, pszCLSID);
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
    
    ec = RegisterClass(szKeyCLSID, "Microsoft InfoTech IStorage System", 
                       szModulePath, CURRENT_VERSION, CLASS_NAME, FALSE
                      );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
    
    CopyClassGuidString(CLSID_IFSStorage, pszCLSID);

    ec= SetRegClassKeyValue(CLASS_NAME_FS, NULL, NULL, 
                            "Microsoft InfoTech IStorage for Win32 Files"
                           );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
    
    ec= SetRegClassKeyValue(CLASS_NAME_FS, "CurVer", NULL, CURRENT_VERSION_FS);
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
    
    ec= SetRegClassKeyValue(CLASS_NAME_FS, pszPrefix, NULL, pszCLSID);
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
    
    ec = RegisterClass(szKeyCLSID, "Microsoft InfoTech IStorage for Win32 Files", 
                       szModulePath, CURRENT_VERSION_FS, CLASS_NAME_FS, FALSE
                      );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
        
    CopyClassGuidString(CLSID_PARSE_URL, pszCLSID);

    ec= SetRegClassKeyValue(CLASS_NAME_MK, NULL, NULL, 
                            "Microsoft InfoTech Protocol for IE 3.0"
                           );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
    
    ec= SetRegClassKeyValue(CLASS_NAME_MK, "CurVer", NULL, CURRENT_VERSION_MK);
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
    
    ec= SetRegClassKeyValue(CLASS_NAME_MK, pszPrefix, NULL, pszCLSID);
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
    
    ec = RegisterClass(szKeyCLSID, "Microsoft InfoTech Protocol for IE 3.0", 
                       szModulePath, CURRENT_VERSION_MK, CLASS_NAME_MK, TRUE
                      );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;

    CopyClassGuidString(CLSID_IE4_PROTOCOLS, pszCLSID);

    ec= SetRegClassKeyValue(CLASS_NAME_ITS, NULL, NULL, 
                            "Microsoft InfoTech Protocols for IE 4.0"
                           );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
    
    ec= SetRegClassKeyValue(CLASS_NAME_ITS, "CurVer", NULL, CURRENT_VERSION_ITS);
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
    
    ec= SetRegClassKeyValue(CLASS_NAME_ITS, pszPrefix, NULL, pszCLSID);
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;
    
    ec = RegisterClass(szKeyCLSID, "Microsoft InfoTech Protocols for IE 4.0", 
                       szModulePath, CURRENT_VERSION_ITS, CLASS_NAME_ITS, TRUE
                      );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;

	ec= SetRegClassKeyValue("PROTOCOLS\\Name-Space Handler\\mk", NULL, NULL, 
							"NameSpace Filter for MK:@MSITStore:..."
						   );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;

	ec= SetRegClassKeyValue("PROTOCOLS\\Handler\\its",
		                    NULL, NULL, "its: Asychronous Pluggable Protocol Handler"
						   );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;

	ec= SetRegClassKeyValue("PROTOCOLS\\Handler\\its",
		                    NULL, "CLSID", pszCLSID
						   );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;

	ec= SetRegClassKeyValue("PROTOCOLS\\Handler\\ms-its",
		                    NULL, NULL, "ms-its: Asychronous Pluggable Protocol Handler"
						   );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;

	ec= SetRegClassKeyValue("PROTOCOLS\\Handler\\ms-its",
		                    NULL, "CLSID", pszCLSID
						   );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;

	ec= SetRegClassKeyValue("PROTOCOLS\\Name-Space Handler\\mk\\*",
		                    NULL, "CLSID", pszCLSID
						   );
    if (ec != ERROR_SUCCESS) return SELFREG_E_CLASS;

    {
        HKEY  hkeyIEPATH = NULL;
        DWORD dwType;
        PCHAR pchData = NULL;
        DWORD cchData = 0;
        PSZ   pszSuffix = IS_IE4()? " ms-its:%1::/" : " mk:@MSITStore:%1::/";
        DWORD cbSuffix = lstrlen(pszSuffix);

        if (   ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, 
                                             "htmlfile\\shell\\open\\command", 
                                             0, KEY_QUERY_VALUE, &hkeyIEPATH
                                            )
            && ERROR_SUCCESS == RegQueryValueEx(hkeyIEPATH, "", NULL, &dwType, NULL, &cchData)
            && (pchData = PCHAR(_alloca(cchData += cbSuffix+1)))
            && ERROR_SUCCESS == RegQueryValueEx(hkeyIEPATH, "", NULL, &dwType, 
                                                PBYTE(pchData), &cchData
                                               )
           )
        {
            RegCloseKey(hkeyIEPATH);

            lstrcat(pchData, pszSuffix);
            lstrcat(szModulePath, ",0");

            if (   ERROR_SUCCESS == SetRegClassKeyValue("ITS FILE", NULL, NULL, 
                                                        "Internet Document Set"
                                                       )
                && ERROR_SUCCESS == SetRegClassKeyValue("ITS File\\shell\\open\\command", 
                                                        NULL, NULL, pchData
                                                       )
                && ERROR_SUCCESS == SetRegClassKeyValue("ITS FILE\\DefaultIcon", NULL,
                                                        NULL, szModulePath
                                                       )
                && ERROR_SUCCESS == SetRegClassKeyValue(".its", NULL, NULL, "ITS File")
               ) return S_OK;
        }
    }

    return S_OK; 
}

extern "C" STDAPI DllUnregisterServer(void)
{
    {
        DeleteKey(HKEY_CLASSES_ROOT, ".its");
        DeleteKey(HKEY_CLASSES_ROOT, "ITS File");
    }
    
    CHAR *pszPrefix = "CLSID";

    const UINT cbPrefix = 5;

    RonM_ASSERT(cbPrefix == lstrlenA(pszPrefix));

    CHAR szKeyCLSID[GUID_SIZE + cbPrefix + 2];

    lstrcpyA(szKeyCLSID, pszPrefix);
    szKeyCLSID[5] = '\\';
    
    PCHAR pszCLSID = szKeyCLSID + cbPrefix + 1;

    CopyClassGuidString(CLSID_ITStorage, pszCLSID);        
        
    if (!DeleteKey(HKEY_CLASSES_ROOT, CLASS_NAME)) return SELFREG_E_CLASS;
    
    if (!DeleteKey(HKEY_CLASSES_ROOT, szKeyCLSID)) return SELFREG_E_CLASS;
    
    CopyClassGuidString(CLSID_IFSStorage, pszCLSID);        
        
    if (!DeleteKey(HKEY_CLASSES_ROOT, CLASS_NAME_FS)) return SELFREG_E_CLASS;
    
    if (!DeleteKey(HKEY_CLASSES_ROOT, szKeyCLSID)) return SELFREG_E_CLASS;
    
    CopyClassGuidString(CLSID_PARSE_URL, pszCLSID);        
        
    if (!DeleteKey(HKEY_CLASSES_ROOT, CLASS_NAME_MK)) return SELFREG_E_CLASS;
    
    if (!DeleteKey(HKEY_CLASSES_ROOT, szKeyCLSID)) return SELFREG_E_CLASS;
    
    CopyClassGuidString(CLSID_IE4_PROTOCOLS, pszCLSID);        
        
    if (!DeleteKey(HKEY_CLASSES_ROOT, CLASS_NAME_ITS)) return SELFREG_E_CLASS;
    
    if (!DeleteKey(HKEY_CLASSES_ROOT, szKeyCLSID)) return SELFREG_E_CLASS;
    
    if (!DeleteKey(HKEY_CLASSES_ROOT, "PROTOCOLS\\Handler\\its")) 
        return SELFREG_E_CLASS;
    
    if (!DeleteKey(HKEY_CLASSES_ROOT, "PROTOCOLS\\Handler\\ms-its")) 
        return SELFREG_E_CLASS;
    
    if (!DeleteKey(HKEY_CLASSES_ROOT, "PROTOCOLS\\Name-Space Handler\\mk")) 
        return SELFREG_E_CLASS;
    
    return NOERROR; 
}

extern "C" STDAPI DllCanUnloadNow()
{
	if (!pDLLServerState)
		return S_OK;	// we're already unloaded
    return pDLLServerState->CanUnloadNow()? S_OK : S_FALSE;
}

#ifndef PathMgrOnly

extern "C" STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    return CFactory::Create(rclsid, riid, ppv);
}

#endif // ndef PathMgrOnly

// Member functions for the CServerState class:

CServerState *CServerState::CreateServerState(HMODULE hModule)
{
    CServerState *pss = New CServerState(hModule);

    if (!pss || pss->InitServerState()) 
        return pss;

    delete pss;
    
    return NULL;
}

BOOL CServerState::InitServerState()
{
    RonM_ASSERT(!m_pIMalloc);

    return SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &m_pIMalloc));
}

BOOL CServerState::CanUnloadNow()
{
    // BugBug: Does the critical section below do anything useful?
    // The issue is that CanUnloadNow is called by the OLE system to find
    // out whether it can unload this DLL. Immediately after we return
    // a thread could call into DllGetClassObject before OLE makes the
    // call to FreeLibrary. So either Ole prevents that situation by 
    // single threading all calls to DllGetClassObject, or the DetachProcess
    // call to DllMain ought to fail.
    
	CSyncWith sw(m_cs);
		
	BOOL fResult = (!m_cObjectsActive) && (!m_cLocksActive);

	return fResult;
}

INT CServerState::ObjectAdded()
{
	return InterlockedIncrement(PLONG(&m_cObjectsActive));
}

INT CServerState::ObjectReleased()
{
    INT uResult= InterlockedDecrement(PLONG(&m_cObjectsActive));

    RonM_ASSERT(uResult >= 0);

    return uResult;
}

INT CServerState::LockServer()
{
    return InterlockedIncrement(PLONG(&m_cLocksActive));
}

INT CServerState::UnlockServer()
{
    INT uResult= InterlockedDecrement(PLONG(&m_cLocksActive));

    RonM_ASSERT(uResult >= 0);

    return uResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\casetab.h ===
typedef struct _CodedMapBlock
{
    UINT iwcFirst : 16;
    UINT cwcSpan  :  8;
    UINT iDelta   :  6;
    UINT fUnused  :  1;
    UINT fGapIs2  :  1;

} CodeMapBlock, *PCodedMapBlock;

typedef union
{
	UINT         uCode;
	CodeMapBlock cmb;

} UCodeMapBlock;

const UCodeMapBlock UCMB_NULL = { 0 }; // Special block with zero entries
                                       // with base == 0.

// Upper case maps:

const SHORT aiDeltaValues_Upper[34] = 
    { -219, -218, -217, -214, -213, -211, -210, -209, -207, -206, -205,
      -203, -202, -80, -79, -64, -63, -48, -38, -37, -32, -26, -16, -2,
      -1, 7, 8, 74, 86, 100, 112, 121, 126, 128
    };


const UCodeMapBlock UCMB_Upper[88] =
    { 0x141a0061, 0x141700e0, 0x140700f8, 0x1f0100ff, 0x982f0101, 0x98050133,
      0x980f013a, 0x982d014b, 0x9805017a, 0x98030183, 0x18010188, 0x1801018c,
      0x18010192, 0x18010199, 0x980501a1, 0x180101a8, 0x180101ad, 0x180101b0,
      0x980301b4, 0x180101b9, 0x180101bd, 0x170101c6, 0x170101c9, 0x170101cc,
      0x980f01ce, 0x0e0101dd, 0x981101df, 0x170101f3, 0x180101f5, 0x981d01fb,
      0x06010253, 0x09010254, 0x0a020256, 0x0c010259, 0x0b01025b, 0x0a010260,
      0x08010263, 0x07010268, 0x05010269, 0x0501026f, 0x04010272, 0x03010275,
      0x01010283, 0x01010288, 0x0202028a, 0x00010292, 0x120103ac, 0x130303ad,
      0x141103b1, 0x140903c3, 0x0f0103cc, 0x100203cd, 0x980d03e3, 0x14200430,
      0x0d0c0451, 0x0d02045e, 0x98210461, 0x982f0491, 0x980304c2, 0x180104c8,
      0x180104cc, 0x981b04d1, 0x980704ef, 0x180104f9, 0x11260561, 0x112610d0,
      0x98951e01, 0x98591ea1, 0x1a081f00, 0x1a061f10, 0x1a081f20, 0x1a081f30,
      0x1a061f40, 0x9a071f51, 0x1a081f60, 0x1b021f70, 0x1c041f72, 0x1d021f76,
      0x21021f78, 0x1e021f7a, 0x20021f7c, 0x1a021fb0, 0x1a021fd0, 0x1a021fe0,
      0x19011fe5, 0x16102170, 0x151a24d0, 0x141aff41
    };


// Lower case maps:

const SHORT aiDeltaValues_Lower[34] = 
    { -128, -126, -121, -112, -100, -86, -74, -8, -7, 1, 2, 16, 26, 32,
      37, 38, 48, 63, 64, 79, 80, 202, 203, 205, 206, 207, 209, 210, 211,
      213, 214, 217, 218, 219
    };


const UCodeMapBlock UCMB_Lower[88] =
    { 0x0d1a0041, 0x0d1700c0, 0x0d0700d8, 0x892f0100, 0x89050132, 0x890f0139,
      0x892d014a, 0x02010178, 0x89050179, 0x1b010181, 0x89030182, 0x18010186,
      0x09010187, 0x17020189, 0x0901018b, 0x1301018e, 0x1501018f, 0x16010190,
      0x09010191, 0x17010193, 0x19010194, 0x1c010196, 0x1a010197, 0x09010198,
      0x1c01019c, 0x1d01019d, 0x1e01019f, 0x890501a0, 0x090101a7, 0x200101a9,
      0x090101ac, 0x200101ae, 0x090101af, 0x1f0201b1, 0x890301b3, 0x210101b7,
      0x090101b8, 0x090101bc, 0x0a0101c4, 0x0a0101c7, 0x0a0101ca, 0x890f01cd,
      0x891101de, 0x0a0101f1, 0x090101f4, 0x891d01fa, 0x0f010386, 0x0e030388,
      0x1201038c, 0x1102038e, 0x0d110391, 0x0d0903a3, 0x890d03e2, 0x140c0401,
      0x1402040e, 0x0d200410, 0x89210460, 0x892f0490, 0x890304c1, 0x090104c7,
      0x090104cb, 0x891b04d0, 0x890704ee, 0x090104f8, 0x10260531, 0x102610a0,
      0x89951e00, 0x89591ea0, 0x07081f08, 0x07061f18, 0x07081f28, 0x07081f38,
      0x07061f48, 0x87071f59, 0x07081f68, 0x07021fb8, 0x06021fba, 0x05041fc8,
      0x07021fd8, 0x04021fda, 0x07021fe8, 0x03021fea, 0x08011fec, 0x00021ff8,
      0x01021ffa, 0x0b102160, 0x0c1a24b6, 0x0d1aff21
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\crtfns.h ===
// crtfns.h -- Smaller paraphrases of the C runtime APIs we use

#ifndef __CRTFNS_H__

#define __CRTFNS_H__

#undef CopyMemory
#undef FillMemory
#undef ZeroMemory

#define CopyMemory memCpy
#define FillMemory memSet
#define ZeroMemory(dest,count) memSet(dest, 0, count)

void *  __stdcall memSet(void *dest, int chr, size_t count);
void *  __stdcall memCpy(void *dest, const void *src, size_t count);

wchar_t * __stdcall wcsCpy(wchar_t *wcsDest, const wchar_t *wcsSrc);
wchar_t * __stdcall wcsCat(wchar_t *wcsDest, const wchar_t *wcsSrc);

#define wcsLen lstrlenW

wchar_t * __stdcall wcsChr(const wchar_t *src, wchar_t chr);

#endif // __CRTFNS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\enum.cpp ===
// Enum.cpp -- Implementation for class CEnumStorage

#include "stdafx.h"

HRESULT CEnumStorage::NewEnumStorage
                     (IUnknown *pUnkOuter,
                      IITFileSystem *pITFS, PathInfo *pPI, 
                      IEnumSTATSTG **ppEnumSTATSTG
                     )
{
    CSyncWith sw(pITFS->CriticalSection());

    CEnumStorage *pEnumStorage= New CEnumStorage(pUnkOuter);

    return FinishSetup(pEnumStorage? pEnumStorage->m_ImpIEnumStorage.Initial(pITFS, pPI)
                                   : STG_E_INSUFFICIENTMEMORY,
                       pEnumStorage, IID_IEnumSTATSTG, (PPVOID)ppEnumSTATSTG
                      );
}

HRESULT CEnumStorage::NewClone(IUnknown *pUnkOuter, CImpIEnumStorage *pEnum,
                               IEnumSTATSTG **ppEnumSTATSTG
                              )
{
    CEnumStorage *pEnumStorage= New CEnumStorage(pUnkOuter);

    return FinishSetup(pEnumStorage? pEnumStorage->m_ImpIEnumStorage.InitClone(pEnum)
                                   : STG_E_INSUFFICIENTMEMORY,
                       pEnumStorage, IID_IEnumSTATSTG, (PPVOID)ppEnumSTATSTG
                      );
}

CEnumStorage::CImpIEnumStorage::CImpIEnumStorage
                (CEnumStorage *pBackObj, IUnknown *pUnkOuter)
      : IITEnumSTATSTG(pBackObj, pUnkOuter)
{
    m_pEnumPaths      = NULL;
    m_cwcBasePath     = 0;
    m_awszBasePath[0] = 0;
    m_awcKeyBuffer[0] = 0;
    m_State           = Before;
}

CEnumStorage::CImpIEnumStorage::~CImpIEnumStorage(void)
{
    if (m_pEnumPaths)
        m_pEnumPaths->Release();
}

HRESULT CEnumStorage::CImpIEnumStorage::Initial(IITFileSystem *pITFS, PathInfo *pPI)
{
    m_cwcBasePath = pPI->cwcStreamPath;
    
    CopyMemory(m_awszBasePath, pPI->awszStreamPath, sizeof(WCHAR) * (m_cwcBasePath + 1));

    HRESULT hr = pITFS->EnumeratePaths((const WCHAR *) m_awszBasePath, &m_pEnumPaths);

    if (SUCCEEDED(hr))
        ((IITEnumSTATSTG *) m_pEnumPaths)->Container()->MarkSecondary();
    
    RonM_ASSERT(m_State == Before);

    return hr;
}

HRESULT CEnumStorage::CImpIEnumStorage::InitClone(CImpIEnumStorage *pEnum)
{
    HRESULT hr = pEnum->m_pEnumPaths->Clone(&m_pEnumPaths);
    
    if (hr == S_OK)
    {
        m_cwcBasePath  = pEnum->m_cwcBasePath ;
        m_State        = pEnum->m_State       ;
        
        CopyMemory(m_awszBasePath, pEnum->m_awszBasePath, sizeof(m_awszBasePath));
        CopyMemory(m_awcKeyBuffer, pEnum->m_awcKeyBuffer, sizeof(m_awcKeyBuffer));
    }
    
    return hr;
}

HRESULT __stdcall CEnumStorage::CImpIEnumStorage::NextPathEntry
                    (STATSTG *pStatStg)
{
    // This functions advances the B-Tree pointer in the enumeration
    // object and returns the item name and record for the new position.
    //
    // By convention storage item names end with L'/' and stream item names
    // do not.

    if (m_State == After)
        return S_FALSE;

    STATSTG statstg;
    ULONG   cEltsFetched;

    HRESULT hr = m_pEnumPaths->Next(1, &statstg, &cEltsFetched);
        
    for (; ;)
    {
        // This loop scans through a sequence of keys. We stop if we find
        // a key that doesn't begin with the base path. That indicates that
        // we've finished the enumeration for this storage.
        //
        // Otherwise we compare the key against the last element we enumerated
        // to filter out multiple references to a nested substorage.

        if (hr != S_OK)
            if (hr == S_FALSE)
            {
                 m_State= After;

                 return S_FALSE; // This means we've come to the 
                                 // end of the path entries. 
            }
            else return hr;

        UINT cwcPath = wcsLen(statstg.pwcsName);

        if (cwcPath < m_cwcBasePath)
        {
            OLEHeap()->Free(statstg.pwcsName);
            m_State= After;
            return S_FALSE;
        }

        PWCHAR pwcBase = m_awszBasePath;
        PWCHAR pwcPath = statstg.pwcsName;

        UINT c= m_cwcBasePath;

        for (; c--; )
            if (WC_To_0x0409_Lower(*pwcBase++) != WC_To_0x0409_Lower(*pwcPath++)) 
            {
                OLEHeap()->Free(statstg.pwcsName);
                m_State= After;
                return S_FALSE;
            }

        if (cwcPath == m_cwcBasePath) 
        {
            // This entry contains state information for this storage.
            // So we need to advance to the next path.

            OLEHeap()->Free(statstg.pwcsName);

            hr = m_pEnumPaths->Next(1, &statstg, &cEltsFetched);

            continue;
        }

        PWCHAR pwc = pwcPath;

        BOOL fGotNextItem= FALSE;

        for (pwcBase= m_awcKeyBuffer; ;)
        {
            WCHAR wcLast = *pwcBase++;
            WCHAR wcCurr = *pwc++;

            if (wcLast == 0)
            {
                RonM_ASSERT(wcCurr != 0); // Otherwise we've got duplicate keys

                if (wcCurr == L'/')
                {
                    // Current item is a storage, and last item was either empty
                    // or was a stream.

                    fGotNextItem= TRUE;

                    break;
                }

                // Otherwise we've got a new item. Now we just have to find
                // the end of the item name. That will be either '/' or NULL.

                for (; ;)
                {
                    wcCurr= *pwc++;

                    if (!wcCurr || wcCurr == L'/')
                        break;
                }

                fGotNextItem= TRUE;

                break;
            }
            
            if (wcLast == L'/')
            {
                RonM_ASSERT(wcCurr != 0); // Stream key always precedes storage synonym.

                if (wcCurr == L'/')
                    break; // This key refers to the same substorage as the 
                           // last item.
            
                // Otherwise we've got a new item. 

                for (; ;)
                {
                    wcCurr= *pwc++;

                    if (!wcCurr || wcCurr == L'/')
                        break;
                }

                fGotNextItem= TRUE;
            
                break;
            }

            if (WC_To_0x0409_Lower(wcLast) == WC_To_0x0409_Lower(wcCurr)) 
                continue;

            // Otherwise we've got a new item. 

            for (; ;wcCurr = *pwc++)
                if (!wcCurr || wcCurr == L'/')
                    break;
            
            fGotNextItem= TRUE;

            break;
        }

        if (fGotNextItem)
        {
            UINT cwc = UINT(pwc - pwcPath - 1);

            CopyMemory(m_awcKeyBuffer  , pwcPath, cwc * sizeof(WCHAR));
            MoveMemory(statstg.pwcsName, pwcPath, cwc * sizeof(WCHAR));
            
            statstg.pwcsName[cwc] = 0;

            if (pwc[-1] == L'/') // Item is a Storage
            {
                statstg.type  = STGTY_STORAGE;
                
                m_awcKeyBuffer[cwc  ] = L'/';
                m_awcKeyBuffer[cwc+1] = 0;

                if (pwc[0])     // Did we get Stat information for that storage?
                {
                    // No, we got information for the first stream within that storage.
                    // So we need to adjust the statstg info a little bit.
                    
                    statstg.cbSize.LowPart    = 0;
                    statstg.cbSize.HighPart   = 0;
                    statstg.grfMode           = 0;
                    statstg.grfLocksSupported = 0;
                    statstg.clsid             = CLSID_NULL;
                    statstg.grfStateBits      = 0;
                }
            }
            else
            {        
                RonM_ASSERT(statstg.type == STGTY_STREAM);
            
                m_awcKeyBuffer[cwc] = 0;
            }

            *pStatStg = statstg;

            break;
        }
        
        OLEHeap()->Free(statstg.pwcsName);

        hr = m_pEnumPaths->Next(1, &statstg, &cEltsFetched);
    }

    return NOERROR;
}

HRESULT __stdcall CEnumStorage::CImpIEnumStorage::Next
                      (ULONG celt, STATSTG __RPC_FAR *rgelt,
                       ULONG __RPC_FAR *pceltFetched
                      )
{
    RonM_ASSERT(rgelt); // Null pointers not allowed!
    
    HRESULT hr             = NOERROR;
    ULONG   cElts          = celt;
    ULONG   cEltsProcessed = 0;

    for (; cElts--; rgelt++, cEltsProcessed++)
    {
        hr= NextPathEntry(rgelt);

        if (hr != S_OK) break;
    }

    if (pceltFetched)
        *pceltFetched= cEltsProcessed;

    return hr;
}

HRESULT __stdcall CEnumStorage::CImpIEnumStorage::Skip(ULONG celt)
{
    HRESULT hr = NOERROR;

    STATSTG statstg;

    for (; celt--; )
    {
        hr= NextPathEntry(&statstg);

        if (hr != S_OK) break;

        OLEHeap()->Free(statstg.pwcsName);
    }

    return hr;
}

HRESULT __stdcall CEnumStorage::CImpIEnumStorage::Reset(void)
{
    m_State = Before;

    m_awcKeyBuffer[0]= 0;
    m_pEnumPaths->Reset();
    
    return NOERROR;
}

HRESULT __stdcall CEnumStorage::CImpIEnumStorage::Clone
                    (IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum)
{
    return CEnumStorage::NewClone(NULL, this, ppenum);
}

HRESULT STDMETHODCALLTYPE CEnumStorage::CImpIEnumStorage::GetNextEntryInSeq
                              (ULONG celt, PathInfo *rgelt, ULONG *pceltFetched)
{
	return E_NOTIMPL;  
}

HRESULT STDMETHODCALLTYPE CEnumStorage::CImpIEnumStorage::GetFirstEntryInSeq
                              (PathInfo *rgelt)
{
   return E_NOTIMPL;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\comdll.h ===
// COMDLL.h -- Component Object Model plumbing for the Storage DLL
//
// ------------------------------
// History:
//
//   96/10/08; RonM; Created
// ------------------------------


// DLL Exports
//
// Note the { extern "C" } qualifiers. They're necessary to mark these as C declarations
// rather than C++ declarations.

extern "C" BOOL WINAPI DllMain(HMODULE hInst, ULONG ul_reason_for_call, LPVOID lpReserved);
extern "C" STDAPI DllRegisterServer(void);
extern "C" STDAPI DllUnregisterServer(void);
extern "C" STDAPI DllCanUnloadNow();
extern "C" STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv);

extern CImpITUnknown *g_pImpITFileSystemList;
extern CImpITUnknown *g_pFSLockBytesFirstActive;
extern CImpITUnknown *g_pStrmLockBytesFirstActive;
extern CImpITUnknown *g_pImpIFSStorageList;

/* GUID formats for the MVStorage class ID:

{5D02926A-212E-11d0-9DF9-00A0C922E6EC}

// {5D02926A-212E-11d0-9DF9-00A0C922E6EC}
static const GUID <<name>> = 
{ 0x5d02926a, 0x212e, 0x11d0, { 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec } };

// {5D02926A-212E-11d0-9DF9-00A0C922E6EC}
DEFINE_GUID(<<name>>, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// {5D02926A-212E-11d0-9DF9-00A0C922E6EC}
IMPLEMENT_OLECREATE(<<class>>, <<external_name>>, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

 */

#define CLASS_NAME          "MSITFS"
#define CLASS_NAMEW        L"MSITFS"
#define CURRENT_VERSION     "MSITFS1.0"
#define CLASS_NAME_MK       "MSITStore"
#define CLASS_NAMEW_MK     L"MSITStore"
#define CURRENT_VERSION_MK  "MSITStore1.0"
#define CLASS_NAME_ITS      "ITSProtocol"
#define CLASS_NAMEW_ITS    L"ITSProtocol"
#define CURRENT_VERSION_ITS "ITSProtocol1.0"
#define CLASS_NAME_FS       "MSFSStore"
#define CLASS_NAMEW_FS     L"MSFSStore"
#define CURRENT_VERSION_FS  "MSFSStore1.0"

extern CITCriticalSection g_csITFS;

class CServerState
{
public:
	static CServerState *CreateServerState(HMODULE hInst);
	
    ~CServerState();

	INT  ObjectAdded();
	INT  ObjectReleased();
	INT  LockServer();
	INT  UnlockServer();
	BOOL CanUnloadNow();
    
    HMODULE ModuleInstance();
    IMalloc *OLEAllocator();
    
private:	
	
    CServerState(HANDLE hInst);

    BOOL InitServerState();

	INT      m_cObjectsActive;
	INT      m_cLocksActive;
    HMODULE  m_hModule;
    IMalloc *m_pIMalloc;

	CITCriticalSection m_cs;
};

inline CServerState::CServerState(HANDLE hModule)
{
	m_cObjectsActive = 0;
	  m_cLocksActive = 0;

    m_pIMalloc = NULL;
	m_hModule  = (HMODULE) hModule;

    DEBUGCODE(CITUnknown::OpenReferee();)
}

inline CServerState::~CServerState()
{
    RonM_ASSERT(CanUnloadNow());

    if (m_pIMalloc)
        m_pIMalloc->Release();
}

inline IMalloc *CServerState::OLEAllocator()
{
    return m_pIMalloc;
}


inline HMODULE CServerState::ModuleInstance()
{
    return m_hModule;
}

extern CServerState *pDLLServerState;

inline IMalloc *OLEHeap()
{  
    RonM_ASSERT(pDLLServerState);
    RonM_ASSERT(pDLLServerState->OLEAllocator());
    
    return pDLLServerState->OLEAllocator();
}

// Typedefs and global pointers for IE 4.0 APIs which we use.

typedef HRESULT (STDAPICALLTYPE *PFindMimeFromData)
    (LPBC pBC,                // bind context - can be NULL
     LPCWSTR pwzUrl,          // url - can be null
     LPVOID pBuffer,          // buffer with data to sniff - can be null (pwzUrl must be valid)
     DWORD cbSize,            // size of buffer
     LPCWSTR pwzMimeProposed, // proposed mime if - can be null
     DWORD dwMimeFlags,       // will be determined
     LPWSTR *ppwzMimeOut,     // the suggested mime
     DWORD dwReserved         // must be 0
    );

extern PFindMimeFromData pFindMimeFromData;
extern BOOL              g_fDBCSSystem;

inline BOOL IS_IE4     () { return (pFindMimeFromData != NULL); }
inline BOOL DBCS_SYSTEM() { return g_fDBCSSystem;               }

#define      NT_System  0
#define Unknown_System  1
#define  Win32s_System  2
#define   Win95_System  3

extern UINT iSystemType;

inline BOOL Is_NT_System    () { return (iSystemType ==     NT_System); }
inline BOOL Is_Win32s_System() { return (iSystemType == Win32s_System); }
inline BOOL Is_Win95_System () { return (iSystemType ==  Win95_System); }

extern UINT cp_Default;

inline UINT CP_USER_DEFAULT() { return cp_Default; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\crtfns.cpp ===
// crtfns.cpp -- Smaller implementations of the C runtime routines we use.

#include "StdAfx.h"

int __cdecl _purecall(void)
{
	RonM_ASSERT(FALSE);

	return -1;
}

typedef void (__cdecl *_PVFV)(void);

#ifdef i386 // To keep the alpha build working
#pragma intrinsic(memset,memcpy)
#endif // i386

void *  __stdcall memSet(void *dest, int chr, size_t count)
{
	return memset(dest, chr, count);
}

void *  __stdcall memCpy(void *dest, const void *src, size_t count)
{
	return memcpy(dest, src, count);
}

wchar_t * __stdcall wcsCpy(wchar_t *wcsDest, const wchar_t *wcsSrc)
{
	*wcsDest = 0;

	return wcsCat(wcsDest, wcsSrc);
}

wchar_t * __stdcall wcsCat(wchar_t *wcsDest, const wchar_t *wcsSrc)
{
	wchar_t *pwcs = wcsDest;

	for (--wcsDest; *++wcsDest; );

	for (;;)
		if (!(*wcsDest++ = *wcsSrc++)) break;

	return pwcs;
}

wchar_t * __stdcall wcsChr(const wchar_t *src, wchar_t chr)
{
	for (--src;;)
	{
		wchar_t wc = *++src;

		if (!wc) return NULL;

		if (wc == chr) return (wchar_t *) src;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\enum.h ===
// Enum.h -- Definition of class CEnumStorage

#ifndef __ENUM_H__

#define __ENUM_H__

class CEnumStorage : public CITUnknown
{

public:

    static HRESULT NewEnumStorage
                     (IUnknown *pUnkOuter,
                      IITFileSystem *pITFS, PathInfo *pPI, 
                      IEnumSTATSTG **ppEnumSTATSTG
                     );

    ~CEnumStorage(void);

private:

    CEnumStorage(IUnknown *pUnkOuter);

    class CImpIEnumStorage : public IITEnumSTATSTG
    {
    
    public:

        CImpIEnumStorage(CEnumStorage *pBackObj, IUnknown *punkOuter);
        ~CImpIEnumStorage(void);

        HRESULT Initial(IITFileSystem *pITFS, PathInfo *pPI);
        HRESULT InitClone(CImpIEnumStorage *pEnum);

        // IEnumSTATSTG methods:
		HRESULT	STDMETHODCALLTYPE GetNextEntryInSeq(ULONG celt, PathInfo *rgelt, ULONG  *pceltFetched);
		HRESULT	STDMETHODCALLTYPE GetFirstEntryInSeq(PathInfo *rgelt);
				
        /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [in] */ STATSTG __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt);
        
        HRESULT __stdcall Reset( void);
        
        HRESULT __stdcall Clone( 
            /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);

    private:

        HRESULT __stdcall NextPathEntry(STATSTG *pStatStg);

        enum  EnumState { Before, During, After };
        
        IEnumSTATSTG  *m_pEnumPaths;
        UINT           m_cwcBasePath;
        WCHAR          m_awszBasePath[MAX_PATH];
        WCHAR          m_awcKeyBuffer[MAX_PATH];

        enum EnumState m_State;
    };

    friend CImpIEnumStorage;
    
    CImpIEnumStorage  m_ImpIEnumStorage;

public:    
    
    static HRESULT NewClone(IUnknown *pUnkOuter, CImpIEnumStorage *pEnum, 
                            IEnumSTATSTG **ppEnumSTATSTG);
};

typedef CEnumStorage *PCEnumStorage;

inline CEnumStorage::CEnumStorage(IUnknown *pUnkOuter) 
   : m_ImpIEnumStorage(this, pUnkOuter),
     CITUnknown(&IID_IEnumSTATSTG, 1, &m_ImpIEnumStorage)
{
}

inline CEnumStorage::~CEnumStorage(void)
{
}

#endif // __ENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\factory.cpp ===
// factory.cpp -- Class factory for this COM DLL

#include "stdafx.h"

STDMETHODIMP CFactory::Create(REFCLSID rclsid, REFIID riid, PVOID *ppv)
{
    CFactory *pFactory = New CFactory(NULL);

    if (!pFactory)
        return STG_E_INSUFFICIENTMEMORY;

    HRESULT hr = pFactory->m_ImpIClassFactory.Init(rclsid);

    if (hr == S_OK)
        hr = pFactory->m_ImpIClassFactory.QueryInterface(riid, ppv);

    if (hr != S_OK)
        delete pFactory;

    return hr;
}

STDMETHODIMP CFactory::CImpIClassFactory::Init(REFCLSID rclsid)
{
    if (rclsid == CLSID_ITStorage || rclsid == CLSID_IFSStorage
                                  || rclsid == CLSID_PARSE_URL
                                  || rclsid == CLSID_IE4_PROTOCOLS
       )
    {
        m_clsid = rclsid;
        return NO_ERROR;
    }

    return CLASS_E_CLASSNOTAVAILABLE;
}

STDMETHODIMP CFactory::CImpIClassFactory::CreateInstance
               (IUnknown* pUnkOuter,REFIID riid, PPVOID ppv)
{
    *ppv = NULL;

    if (NULL != pUnkOuter && riid != IID_IUnknown)
        return CLASS_E_NOAGGREGATION;
    
    if (m_clsid == CLSID_IFSStorage)
        return CFileSystemStorage::Create(pUnkOuter, riid, ppv);
    
    if (m_clsid == CLSID_ITStorage)
        return CWarehouse::Create(pUnkOuter, riid, ppv);

    if (m_clsid == CLSID_PARSE_URL)
        return CParser::Create(pUnkOuter, riid, ppv);

    if (m_clsid == CLSID_IE4_PROTOCOLS)
        return CIOITnetProtocol::Create(pUnkOuter, riid, ppv);

    RonM_ASSERT(FALSE);

    return E_NOINTERFACE;
}

STDMETHODIMP CFactory::CImpIClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        pDLLServerState->LockServer();
    else
        pDLLServerState->UnlockServer();

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\freelist.cpp ===
// FreeList.cpp -- Implementation for class CFreeList and interface IFreelist

#include "StdAfx.h"

HRESULT CFreeList::CreateFreeList
    (IITFileSystem *pITFS, CULINT cbPreallocated, IITFreeList **ppITFreeList)
{
    CFreeList *pfl = New CFreeList(NULL);

    return FinishSetup(pfl? pfl->m_ImpIFreeList.InitNew(pITFS, cbPreallocated)
                          : STG_E_INSUFFICIENTMEMORY,
                       pfl, IID_IFreeListManager, (PPVOID)ppITFreeList
                      );
}

HRESULT CFreeList::CreateAndSizeFreeList
    (IITFileSystem *pITFS, CULINT cbPreallocated, UINT cSlots, IITFreeList **ppITFreeList)
{
    CFreeList *pfl = New CFreeList(NULL);

    return FinishSetup(pfl? pfl->m_ImpIFreeList.InitNew(pITFS, cbPreallocated, cSlots)
                          : STG_E_INSUFFICIENTMEMORY,
                       pfl, IID_IFreeListManager, (PPVOID)ppITFreeList
                      );
}

HRESULT CFreeList::LoadFreeList(IITFileSystem *pITFS, IITFreeList **ppITFreeList)
{
    CFreeList *pfl = New CFreeList(NULL);

    return FinishSetup(pfl? pfl->m_ImpIFreeList.InitLoad(pITFS)
                          : STG_E_INSUFFICIENTMEMORY,
                       pfl, IID_IFreeListManager, (PPVOID) ppITFreeList
                      );
}

HRESULT CFreeList::AttachFreeList(IITFileSystem *pITFS, IITFreeList **ppITFreeList)
{
    CFreeList *pfl = New CFreeList(NULL);

    return FinishSetup(pfl? pfl->m_ImpIFreeList.LazyInitNew(pITFS)
                          : STG_E_INSUFFICIENTMEMORY,
                       pfl, IID_IFreeListManager, (PPVOID) ppITFreeList
                      );
}



CFreeList::CImpIFreeList::CImpIFreeList(CFreeList *pBackObj, IUnknown *punkOuter)
          :IITFreeList(pBackObj, punkOuter)
{
    m_fInitialed  = FALSE;
    m_fIsDirty    = FALSE;
	m_cBlocks     = 0;
	m_cBlocksMax  = 0;
    m_cbSpace     = 0;
	m_cbLost      = 0;
    m_paFreeItems = NULL;
    m_pITFS       = NULL;

    DEBUGCODE(m_cbPreallocated = 0; )
}

CFreeList::CImpIFreeList::~CImpIFreeList(void)
{
    if (!m_fInitialed)
    {
        RonM_ASSERT(!m_paFreeItems);
        RonM_ASSERT(!m_cBlocksMax);
        RonM_ASSERT(!m_cBlocks);
        RonM_ASSERT(!m_cbSpace.NonZero());
        RonM_ASSERT(!m_cbLost.NonZero());
        RonM_ASSERT(!m_fIsDirty);
        RonM_ASSERT(!m_pITFS);

        return; 
    }

    if (m_fIsDirty)
    {
        if (m_pITFS) RonM_ASSERT(m_paFreeItems);
        else RonM_ASSERT(FALSE);
    }

    if (m_paFreeItems) delete [] m_paFreeItems;

    if (m_pITFS) m_pITFS->Release();
}

// IPersist Method:

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::GetClassID( 
    /* [out] */ CLSID __RPC_FAR *pClassID)
{
    *pClassID = CLSID_IFreeListManager_1;
    
    return NO_ERROR;
}


// IPersistStreamInit Methods:

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::IsDirty(void)
{
    return m_fIsDirty? S_OK : S_FALSE;
}


HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::Load( 
    /* [in] */ LPSTREAM pStm)
{
    // This routine sets the initial state for the free list from
    // a stream. It assumes that we've previously called 
    // Save on this stream at the current seek position.
    // We assume we'll find:
    //
    //    --  m_cBlocksMax
    //    --  m_cBlocks
    //    --  m_cbSpace
    //    --  m_cbLost
    //    --  The first m_cBlocks items from m_paFreeItems
    //
    // Note: This ordering is part of the interface spec!
    
    RonM_ASSERT(!m_fInitialed);
    
    if (m_fInitialed)
        return E_UNEXPECTED;

    ULONG  cItemsMax, cItemsActual;
    CULINT cbSpace, cbLost;

    CSyncWith sw(m_cs);

    HRESULT hr = ReadIn(pStm, &cItemsMax, sizeof(cItemsMax));

    if (SUCCEEDED(hr) && !cItemsMax)
        hr = STG_E_DOCFILECORRUPT;
    
    if (SUCCEEDED(hr))
        hr = ReadIn(pStm, &cItemsActual, sizeof(cItemsActual));
    
    if (SUCCEEDED(hr))
        hr = ReadIn(pStm, &cbSpace, sizeof(cbSpace));
    
    if (SUCCEEDED(hr))
        hr = ReadIn(pStm, &cbLost, sizeof(cbLost));

    if (SUCCEEDED(hr))
    {
        RonM_ASSERT(!m_paFreeItems);

        m_paFreeItems = New FREEITEM[cItemsMax]; 

        if (!m_paFreeItems)
            hr = E_OUTOFMEMORY;
        else
            if (cItemsActual)
            {
                UINT cbActual = sizeof(FREEITEM) * cItemsActual;

                hr = ReadIn(pStm, m_paFreeItems, cbActual);
    
                if (!SUCCEEDED(hr))
                {
                    delete [] m_paFreeItems;

                    m_paFreeItems = NULL;
        
                    return hr;
                }
            }
    }

    if (SUCCEEDED(hr))
    {    
        m_cBlocks    = cItemsActual;
        m_cBlocksMax = cItemsMax;
        m_cbSpace    = cbSpace;
        m_cbLost     = cbLost;
        m_fIsDirty   = FALSE;
        m_fInitialed = TRUE;
    }

    return hr;
}

HRESULT CFreeList::CImpIFreeList::ReadIn(LPSTREAM pStm, PVOID pv, ULONG cb)
{
    ULONG cbRead;
    
    HRESULT hr = pStm->Read(pv, cb, &cbRead);
    
    if (!SUCCEEDED(hr))
        return hr;

    // In the context of the ITSS files the following
    // assert ought to be true.

    RonM_ASSERT(cbRead == cb);

    return (cbRead != cb)? STG_E_READFAULT : NO_ERROR;
}

HRESULT CFreeList::CImpIFreeList::WriteOut(LPSTREAM pStm, PVOID pv, ULONG cb)
{
    ULONG cbWritten;
    
    HRESULT hr = pStm->Write(pv, cb, &cbWritten);
    
    if (!SUCCEEDED(hr))
        return hr;

    // In the context of the ITSS files the following
    // assert ought to be true.

    RonM_ASSERT(cbWritten == cb);

    return (cbWritten != cb)? STG_E_WRITEFAULT : NO_ERROR;
}


HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::Save( 
    /* [in] */ LPSTREAM pStm,
    /* [in] */ BOOL fClearDirty)
{
    // This routine stores the state of the free list in a stream.
    // Here's the order in which we write our state:
    //
    //    --  m_cBlocksMax
    //    --  m_cBlocks
    //    --  m_cbSpace
    //    --  m_cbLost
    //    --  The first m_cBlocks items from m_paFreeItems
    //
    // Note: This ordering is part of the interface spec!

    RonM_ASSERT(m_fInitialed);
    RonM_ASSERT(!m_cBlocks || m_paFreeItems);
    RonM_ASSERT(m_cBlocksMax);

    RonM_ASSERT(m_fIsDirty);

    CSyncWith sw(m_cs);

    if (fClearDirty)
        m_fIsDirty = FALSE;

    HRESULT hr = WriteOut(pStm, &m_cBlocksMax, sizeof(m_cBlocksMax));
    
    if (SUCCEEDED(hr))
        hr = WriteOut(pStm, &m_cBlocks, sizeof(m_cBlocks));
    
    if (SUCCEEDED(hr))
        hr = WriteOut(pStm, &m_cbSpace, sizeof(m_cbSpace));
    
    if (SUCCEEDED(hr))
        hr = WriteOut(pStm, &m_cbLost, sizeof(m_cbLost));

    if (SUCCEEDED(hr) && m_cBlocks)
    {
        UINT cbActual = sizeof(FREEITEM) * m_cBlocks;

        hr = WriteOut(pStm, m_paFreeItems, cbActual);
    }

    if (FAILED(hr))
        m_fIsDirty = TRUE;
    
    return hr;
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::GetSizeMax( 
    /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize)
{
    RonM_ASSERT(m_fInitialed);

    if (!m_fInitialed)
        return E_UNEXPECTED;

    pCbSize->QuadPart = sizeof(m_cBlocksMax) + sizeof(m_cBlocks)
                                             + sizeof(m_cbSpace)
                                             + sizeof(m_cbLost)
                                             + sizeof(FREEITEM) * m_cBlocks;

    return NO_ERROR;
}


HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::InitNew()
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}


// IFreeList Methods:


HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::InitNew
    (IITFileSystem *pITFS, CULINT cbPreallocated)
{
    return InitNew(pITFS, cbPreallocated, DEFAULT_ENTRIES_MAX);
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::InitNew
    (IITFileSystem *pITFS, CULINT cbPreallocated, UINT cEntriesMax)
{
    RonM_ASSERT(!m_fInitialed);
    RonM_ASSERT(!m_paFreeItems);
    RonM_ASSERT(pITFS);
    
    m_pITFS = pITFS;

    m_pITFS->AddRef();

    if (m_fInitialed)
        return E_UNEXPECTED;

    if (!cEntriesMax) 
        return E_INVALIDARG;

    m_paFreeItems = New FREEITEM[cEntriesMax];

    if (!m_paFreeItems)
        return E_OUTOFMEMORY;

    RonM_ASSERT(!m_fIsDirty);
    RonM_ASSERT(!m_cBlocks);
    RonM_ASSERT(!m_cbLost.NonZero());

    m_fInitialed = TRUE;
    m_cBlocksMax = cEntriesMax;
    m_cbSpace    = cbPreallocated;
    m_fIsDirty   = TRUE;

    DEBUGCODE( m_cbPreallocated = cbPreallocated; )

    return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::InitLoad(IITFileSystem *pITFS)
{
    m_pITFS = pITFS;

    m_pITFS->AddRef();

    return ConnectToStream();
}

UINT CFreeList::CImpIFreeList::HighestEntryLEQ(CULINT &ullBase)
{
    // BugBug(Optimize):   97/01/30
    //
    // The code below is a close paraphrase of the original free list code from the
    // MV file system. It's a lot more complicated than it needs to be. For now I've
    // resisted the temptation to rewrite it completely because that might introduce
    // bugs. However when the dust settles a bit, I'm going to clean up this code.

    INT iLo=0;
	INT iHi=m_cBlocks-1;
	INT iSpan=iHi-iLo+1;
	INT iFound=-1;
	
	while (iSpan>0)
	{	
		INT iMid=(iLo+iHi)/2;

        if (ullBase > m_paFreeItems[iMid].ullOffset)
		{	
			if (iSpan==1)
			{	
				iFound=iLo;
				break;
			}

			iLo=min(iHi,iMid+1);
		}
		else
		{	if (iSpan==1)
			{	
				iFound=iLo-1;
				break;
			}

			iHi=max(iLo,iMid-1);
		}
	
		iSpan=iHi-iLo+1;		
	}

    return iFound;
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::PutFreeSpace
    (CULINT ullBase, CULINT ullCB)
{
    RonM_ASSERT(m_fInitialed);

    if (!m_fInitialed) 
        return E_UNEXPECTED;

    HRESULT hr = S_OK;

    if (!m_paFreeItems && m_pITFS) 
        hr = ConnectToStream();

    if (hr != S_OK) return hr;

    RonM_ASSERT(m_paFreeItems);

    if (!ullCB.NonZero())
        return NO_ERROR;

    RonM_ASSERT(ullBase >= m_cbPreallocated);
    
    CSyncWith sw(m_cs);

    RonM_ASSERT(ullCB <= m_cbSpace);

    UINT cItems = m_cBlocks;

    BOOL fFullList = cItems == m_cBlocksMax;

	if (!cItems)
	{
        // The list is empty. 

        m_paFreeItems->ullOffset = ullBase;
        m_paFreeItems->ullCB     = ullCB;

        m_cBlocks++;

        m_fIsDirty = TRUE;

        return NO_ERROR;
	}

    INT iFound = HighestEntryLEQ(ullBase);

    cItems = m_cBlocks - iFound - 1;
	// wFound == -1, insert at beginning,
	// else insert _after_ wFound

    PFREEITEM pfi     = m_paFreeItems + (iFound+1);
    PFREEITEM pfiPrev = NULL;

    if (iFound!=-1)
		pfiPrev = pfi - 1;
		
	if (   pfiPrev
        && ullBase == (pfiPrev->ullOffset + pfiPrev->ullCB)
       )
	{	// Merge with previous
		pfiPrev->ullCB += ullCB;

		if (pfiPrev->ullOffset + pfiPrev->ullCB == pfi->ullOffset)
		{	
			// it fills a hole, merge with next
			
            pfiPrev->ullCB += pfi->ullCB;
            
			// Scoot all next blocks back by one if any
			if (cItems)
			{
				MoveMemory(pfi, pfi+1, sizeof(FREEITEM) * cItems);

                m_cBlocks--;
			}
		}

        m_fIsDirty = TRUE;

        return NO_ERROR;
	}

    // Can we merge with the following block?

    if (cItems && (ullBase + ullCB) == pfi->ullOffset)
    {
        pfi->ullOffset  = ullBase;
        pfi->ullCB     += ullCB;

        m_fIsDirty = TRUE;

        return NO_ERROR;
    }

    // Can't merge with an existing block. 
    // So we have to insert this block into the list.

	if (fFullList)
	{	
        // The list is already full. So before we add a new
        // entry, we've got to remove something. The space
        // represented by the item we discard will be lost 
        // forever. So we first look for the smallest item
        // in the list.

		ULARGE_INTEGER uli;

        uli. LowPart = 0xFFFFFFFF;
        uli.HighPart = 0xFFFFFFFF;

        CULINT ullSmallest = CULINT(uli);

		WORD wSmallestBlock = (WORD)-1;

        PFREEITEM pfiTemp    = m_paFreeItems;
		WORD      wBlockTemp = 0;
		
		for (wBlockTemp=0; wBlockTemp < m_cBlocks; wBlockTemp++, pfiTemp++)
		{	
			if (ullSmallest > pfiTemp->ullCB)
            {
                ullSmallest = pfiTemp->ullCB;
           
                wSmallestBlock=wBlockTemp;
            } 
		}

		// If our new block is smaller than the smallest block in the list,
        // just discard the new block.

        if (ullCB < ullSmallest)
		{
			m_cbLost += ullCB;

            m_fIsDirty = TRUE;

            return NO_ERROR;
		}

		m_cbLost += ullSmallest;
        
		// Now we're going to remove the smallest block. If that
        // block is at the end of the list, we just decrement the
        // count of active blocks.

        if (wSmallestBlock != m_cBlocksMax - 1)
        {
            // When it isn't at the end, we've got to slide subsequent
            // list items down by one position.

            MoveMemory(m_paFreeItems + wSmallestBlock,
                       m_paFreeItems + wSmallestBlock + 1,
                       sizeof(FREEITEM) * (m_cBlocksMax - wSmallestBlock - 1)
                      );
        }

        m_cBlocks--;
		cItems--;

        // If the block we removed was lower than our insertion position, 
        // we must adjust our insertion postion down by one.

		if ((int)wSmallestBlock <= iFound) 
		{	
            pfi = pfiPrev;
			cItems++;
		}					
	}

	// Insert Item

	if (cItems)
        MoveMemory(pfi + 1, pfi, sizeof(FREEITEM) * cItems);
		
	pfi->ullOffset = ullBase;
    pfi->ullCB     = ullCB;

    m_cBlocks++;
	
    m_fIsDirty = TRUE;

    return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::GetFreeSpace
    (CULINT *pullBase, CULINT *pullcb)
{
    CSyncWith sw(m_cs);

    RonM_ASSERT(m_fInitialed);
    
    HRESULT hr = S_OK;

    if (!m_paFreeItems && m_pITFS) 
        hr = ConnectToStream();

    if (hr != S_OK) return hr;

    RonM_ASSERT(m_paFreeItems);

    CULINT ullCB = *pullcb;

    ULARGE_INTEGER uli;
    
    uli. LowPart = DWORD(-1);
    uli.HighPart = DWORD(-1);

    CULINT ullMinDiff(uli);

    UINT cBlocks  = m_cBlocks;
    PFREEITEM pfi = m_paFreeItems;

    UINT iBlock;
    UINT iBlockBest = UINT(-1);

    // The loop below does a best-fit sweep through the
    // blocks in the list. 

    // BugBug(Optimize):   97/01/30
    //
    // Best-fit space management tends toward maximum fragmentation. So we
    // might do better with an different selection rule. Such a change would
    // mean that the return value of *pullcb will sometimes be larger than its 
    // entry value. That means that all the clients of this interface must
    // keep track of both the offset and the size returned!

    for (iBlock= 0; iBlock < m_cBlocks; iBlock++, pfi++)
        if (ullCB <= pfi->ullCB)
        {
            CULINT ullDiff;
            
            ullDiff= pfi->ullCB - ullCB;

            if (ullMinDiff > ullDiff)
            {
                ullMinDiff = ullDiff;
                iBlockBest = iBlock;
            }
        }

    if (iBlockBest == UINT(-1)) // Did we find any items that were big enough?
    {
        // If not, we'll try to allocate from the end of the active space.

        CULINT ullSpaceMax;

        ullSpaceMax = 0 - *pullcb;

        if (ullSpaceMax < *pullcb)
            return S_FALSE;

        *pullBase = m_cbSpace;
        
        m_cbSpace += *pullcb;

        m_fIsDirty = TRUE;

        return S_OK;
    }

    pfi= m_paFreeItems + iBlockBest;

    *pullBase = pfi->ullOffset;

    // Note that we don't overwrite *pullcb in this code. However that may change in
    // a future implementation. For now we return exactly the space requested. 
    // That means we must record any trailing space left over from this item.
    //
    // The spec rule is that *pullcb's return value will be >= it's entry value.

    pfi->ullOffset += ullCB;
    pfi->ullCB     -= ullCB;

    if (!(pfi->ullCB.NonZero()))
    {
        // We matched the item size exactly. 

        if (iBlockBest < m_cBlocks - 1) // Was it the last entry?
        {
            // If not, we've got to slide down the entries which followed it.
            
            MoveMemory(pfi, pfi+1, sizeof(FREEITEM) * (m_cBlocks - iBlockBest - 1));
        }

        m_cBlocks--;
    }

    m_fIsDirty = TRUE;

    return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::GetFreeSpaceAt
    (CULINT ullBase, CULINT *pullcb)
{
    CSyncWith sw(m_cs);

    HRESULT hr = S_OK;

    if (!m_paFreeItems && m_pITFS) 
        hr = ConnectToStream();

    if (hr != S_OK) return hr;

    CULINT ullcbReq;

    ullcbReq = *pullcb;

    if (ullBase == m_cbSpace)
    {
        CULINT ullcbAvailable;
        
        ullcbAvailable = 0 - m_cbSpace;

        HRESULT hr = S_OK;

        if (ullcbAvailable >= ullcbReq)
            m_cbSpace += ullcbReq;
        else hr = S_FALSE;

        m_fIsDirty = TRUE;

        return hr;
    }
    
    UINT iFound = HighestEntryLEQ(ullBase);

    if (iFound == UINT(-1))
        return S_FALSE;

    PFREEITEM pfi= m_paFreeItems + iFound;

    CULINT ullLimit;

    ullLimit = pfi->ullOffset + pfi->ullCB;

    if (ullLimit <= ullBase)
        return S_FALSE;

    CULINT ullChunk;

    ullChunk = ullLimit - ullBase;

    if (ullChunk < ullcbReq)
    {
        HRESULT hr = S_OK;

        if (ullLimit == m_cbSpace)
        {
            CULINT ullcbAvailable;
            
            ullcbAvailable = 0 - m_cbSpace;

            if (ullcbAvailable >= ullcbReq - ullChunk)
                m_cbSpace += ullcbReq - ullChunk;
            else hr = S_FALSE;
        }
        else hr = S_FALSE;

        if (hr == S_FALSE)
            return S_FALSE;
    }

    pfi->ullCB = ullBase - pfi->ullOffset; // Record the prefix space.

    if (!(pfi->ullCB).NonZero())
    {
        // We've used up the entire block. 
        // Now we need to remove it from the list.

        if (iFound < m_cBlocks - 1)
            MoveMemory(pfi, pfi + 1, sizeof(FREEITEM) * (m_cBlocks - iFound - 1));

        m_cBlocks--;
    }
    
    if (ullChunk > ullcbReq) // Check for trailing space in the block
    {
        CULINT ullBaseTrailing, ullcbTrailing;

        ullBaseTrailing = ullBase + ullcbReq;
        ullcbTrailing   = ullChunk - ullcbReq;
        
        HRESULT hr =
            PutFreeSpace(ullBaseTrailing, ullcbTrailing);

        RonM_ASSERT(SUCCEEDED(hr));
    }

    m_fIsDirty = TRUE;

    return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::GetEndingFreeSpace
    (CULINT *pullBase, CULINT *pullcb)
{
    HRESULT hr = S_OK;

    if (!m_paFreeItems && m_pITFS) 
        hr = ConnectToStream();

    if (hr != S_OK) return hr;

    CULINT ullcbReq;

    ullcbReq = *pullcb;

    CSyncWith sw(m_cs);

    if (m_cBlocks)
    {
        PFREEITEM pfi = m_paFreeItems + m_cBlocks - 1;
    
        CULINT ullBase, ullcb;

        ullBase = pfi->ullOffset;
        ullcb   = pfi->ullCB;

        if (m_cbSpace == ullBase + ullcb)
        {
            if (ullcbReq > ullcb)
            {
                CULINT ullcbAvailable;

                ullcbAvailable = 0 - ullBase;

                if (ullcbAvailable < ullcbReq)
                    return S_FALSE;
                
                m_cbSpace += ullcbReq - ullcb;
            }

            m_cBlocks--;

            *pullBase = ullBase;

            if (ullcb > ullcbReq)
            {
                CULINT ullBaseResidue, ullcbResidue;

                ullBaseResidue = ullBase + ullcbReq;
                ullcbResidue   = ullcb - ullcbReq;

#ifdef _DEBUG
                HRESULT hr =
#endif // _DEBUG
                    PutFreeSpace(ullBaseResidue, ullcbResidue);

                RonM_ASSERT(SUCCEEDED(hr));
            }

            m_fIsDirty = TRUE;

            return NO_ERROR;
        }
    }

    CULINT ullcbAvailable;

    ullcbAvailable = 0 - m_cbSpace;

    if (ullcbAvailable < ullcbReq)
        return S_FALSE;

    *pullBase = m_cbSpace;
    
    m_cbSpace += ullcbReq;

    m_fIsDirty = TRUE;

    return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::GetStatistics
                              (CULINT *pcbLost, CULINT *pcbSpace)
{
    HRESULT hr = S_OK;

    if (!m_paFreeItems && m_pITFS) 
        hr = ConnectToStream();

    if (hr != S_OK) return hr;

    *pcbLost  = m_cbLost;
    *pcbSpace = m_cbSpace;

    return hr;
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::SetFreeListEmpty()
{
    RonM_ASSERT(m_fInitialed);
    RonM_ASSERT(m_pITFS);

    HRESULT hr = S_OK;
    
    if (!m_cBlocksMax) hr = ConnectToStream();

    if (SUCCEEDED(hr))
    {
	    m_cBlocks  = 0;
        m_fIsDirty = TRUE;
    }

	return hr;
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::SetSpaceSize(ULARGE_INTEGER uliCbSpace)
{
    RonM_ASSERT(m_fInitialed);
    RonM_ASSERT(m_pITFS);
    
	m_cbSpace  = CULINT(uliCbSpace);
    m_fIsDirty = TRUE;
	
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::LazyInitNew(IITFileSystem *pITFS)
{
    RonM_ASSERT(!m_fInitialed);
    RonM_ASSERT(!m_paFreeItems);
    RonM_ASSERT(pITFS);
    
    pITFS->AddRef();

    m_pITFS      = pITFS;
    m_fIsDirty   = FALSE;
    m_fInitialed = TRUE;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::RecordFreeList()
{
    RonM_ASSERT(m_fInitialed);
    RonM_ASSERT(!m_cBlocks || m_paFreeItems);
    RonM_ASSERT(m_pITFS);

    if (!m_pITFS) return E_FAIL;

    HRESULT hr = S_OK;

    if (m_fIsDirty)
    {
        /* 

        One of the complications here is that the act of recording the free
        list may alter the free list. That's because we may need to allocate
        or reallocate space within the file system to do the write operations.
        The best case, of course, is the situation where the Free List stream 
        is already exactly the right size to hold the free list information.

        In the other possible situations the stream may be empty, or larger than
        or smaller than the free list image. Those situations cause allocations 
        and thus affect the free list. We deal with those possibilities by 

        1. Only allowing the stream to grow from its initial size.
        2. Allowing a few iterations to take care of cases where the allocation
           operation may grow the free list or change some of its entries and 
           thus make it "dirty" again.

        To catch flaws in this logic we trigger an assertion and return E_FAIL
        if the iteration count goes beyond four. If the interactions between the
        file system and the free list changes substantially, we may need to
        change the iteration limit upward.

         */
        
        CULINT ullSizeMax;
        CULINT ullSizeCurrent;

        ULARGE_INTEGER cbFreeList;

        hr = GetSizeMax(&cbFreeList);

        RonM_ASSERT(SUCCEEDED(hr));

        ullSizeMax     = cbFreeList;
        ullSizeCurrent = 0;

        IStreamITEx *pStrmFreeList = NULL;

        hr = m_pITFS->OpenStream(NULL, L"F", STGM_READWRITE, &pStrmFreeList);

        if (!SUCCEEDED(hr)) return hr;

        UINT iterations = 0;

        while (m_fIsDirty)  // m_fIsDirty is set TRUE when the free list changes size or content.
                            // It is set FALSE by the Save call below.
        {
            hr = GetSizeMax(&cbFreeList);

            RonM_ASSERT(SUCCEEDED(hr));

            if (ullSizeMax < cbFreeList)
                ullSizeMax = cbFreeList;

            if (ullSizeCurrent < ullSizeMax)
            {            
                ullSizeCurrent = ullSizeMax;
                hr = pStrmFreeList->SetSize(ullSizeMax.Uli());

                if (!SUCCEEDED(hr)) break;
            }

            LARGE_INTEGER uli;

            uli.LowPart  = 0;
            uli.HighPart = 0;

            hr = pStrmFreeList->Seek(uli, STREAM_SEEK_SET, NULL);

            if (!SUCCEEDED(hr)) break;

            hr = Save(pStrmFreeList, TRUE);  // TRUE ==> Reset the dirty flag
    
            if (!SUCCEEDED(hr)) break;

            hr = GetSizeMax(&cbFreeList);

            RonM_ASSERT(SUCCEEDED(hr));

            if (ullSizeMax < cbFreeList)
                ullSizeMax = cbFreeList;

            hr = pStrmFreeList->Flush();
    
            if (!SUCCEEDED(hr)) break;

            hr = GetSizeMax(&cbFreeList);

            RonM_ASSERT(SUCCEEDED(hr));

            if (ullSizeMax < cbFreeList)
                ullSizeMax = cbFreeList;

            if (++iterations > 4) 
            {
                RonM_ASSERT(FALSE); // This has become an infinite loop.

                return E_FAIL;
            }
        }

        pStrmFreeList->Release();
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFreeList::CImpIFreeList::ConnectToStream()
{
    IStreamITEx *pStrmFreeList = NULL;

    HRESULT hr = m_pITFS->OpenStream(NULL, L"F", STGM_READWRITE, &pStrmFreeList);

    if (!SUCCEEDED(hr)) return hr;

    LARGE_INTEGER uli;

    uli.LowPart  = 0;
    uli.HighPart = 0;

    hr = pStrmFreeList->Seek(uli, STREAM_SEEK_SET, NULL);

    if (SUCCEEDED(hr))
    {
        m_fInitialed = FALSE; // To satisfy the Load routine...

        hr = Load(pStrmFreeList);
    }

    pStrmFreeList->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\freelist.h ===
// FreeList.h -- Definition of CFreeList class and IFreeList interface.

#ifndef __FREELIST_H__

#define __FREELIST_H__

/*

This file defines the interface to the free-space manager for the Tome file. It's
done as a subclass of IPersistStreamInit so that different free list implementations
can be bound to particular Tome files automatically.

Its public methods allow you to:

  1. Add a segment of LockBytes address space to the free space
  
  2. Allocate address space from available free space

  3. Attempt an allocation beginning at a particular address

  4. Allocate address space at the end of the LockBytes container.

 */

#undef GetFreeSpace // kill the obsolete Win16 macro before we 
                    // encounter the IFreeList definition...

class CFreeList : public CITUnknown
{
public:

    ~CFreeList(); 
    
    static HRESULT CreateFreeList(IITFileSystem *pITFS, CULINT cbPreallocated, IITFreeList **ppITFreeList);
    static HRESULT CreateAndSizeFreeList(IITFileSystem *pITFS, CULINT cbPreallocated, UINT cSlots, IITFreeList **ppITFreeList);
    static HRESULT LoadFreeList(IITFileSystem *pITFS, IITFreeList **ppITFreeList);
    static HRESULT AttachFreeList(IITFileSystem *pITFS, IITFreeList **ppITFreeList);

private:

    CFreeList(IUnknown *punkOuter);

    class CImpIFreeList : public IITFreeList
    {
    public:

        CImpIFreeList(CFreeList *pBackObj, IUnknown *punkOuter);
        ~CImpIFreeList(void);

        HRESULT ReadIn  (LPSTREAM pStm, PVOID pv, ULONG cb);
        HRESULT WriteOut(LPSTREAM pStm, PVOID pv, ULONG cb);

    // IPersist Method:

        HRESULT STDMETHODCALLTYPE GetClassID( 
            /* [out] */ CLSID __RPC_FAR *pClassID);
        
    // IPersistStreamInit Methods:

        HRESULT STDMETHODCALLTYPE IsDirty( void);
    
        HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ LPSTREAM pStm);
    
        HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ LPSTREAM pStm,
            /* [in] */ BOOL fClearDirty);
    
        HRESULT STDMETHODCALLTYPE GetSizeMax( 
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize);
    
        HRESULT STDMETHODCALLTYPE InitNew( void);
    
    // IFreeList Methods:

        HRESULT STDMETHODCALLTYPE InitNew(IITFileSystem *pITFS, CULINT cbPreallocated);
        HRESULT STDMETHODCALLTYPE InitNew(IITFileSystem *pITFS, CULINT cbPreallocated, UINT cEntriesMax);
        HRESULT STDMETHODCALLTYPE InitLoad(IITFileSystem *pITFS);
        HRESULT STDMETHODCALLTYPE LazyInitNew(IITFileSystem *pITFS);
        HRESULT STDMETHODCALLTYPE RecordFreeList(); 

        HRESULT STDMETHODCALLTYPE PutFreeSpace(CULINT   ullBase, CULINT   ullCB);
        HRESULT STDMETHODCALLTYPE GetFreeSpace(CULINT *pullBase, CULINT *pullcb);
        HRESULT STDMETHODCALLTYPE GetFreeSpaceAt(CULINT ullBase, CULINT *pullcb);
        HRESULT STDMETHODCALLTYPE GetEndingFreeSpace
                          (CULINT *pullBase, CULINT *pullcb);
        HRESULT STDMETHODCALLTYPE GetStatistics
                          (CULINT *pcbLost, CULINT *pcbSpace);

		HRESULT STDMETHODCALLTYPE SetFreeListEmpty();
		HRESULT STDMETHODCALLTYPE SetSpaceSize(ULARGE_INTEGER uliCbSpace);
		
    private:

        UINT HighestEntryLEQ(CULINT &ullBase);

        HRESULT STDMETHODCALLTYPE ConnectToStream();

        typedef struct _freeitem
        {
	        CULINT ullOffset; // Start of free block
	        CULINT ullCB;     // Size  of free block in bytes
        
        } FREEITEM, *PFREEITEM;

        enum { DEFAULT_ENTRIES_MAX = 510 };

        CITCriticalSection m_cs;

        BOOL           m_fInitialed;
        BOOL           m_fIsDirty;

	    UINT           m_cBlocks;    // Number of blocks in list
	    UINT           m_cBlocksMax; // Max number of blocks in list	
	    CULINT         m_cbLost;     // Number of bytes totally lost forever
        CULINT         m_cbSpace;

        BOOL           m_fDirty;
        IITFileSystem *m_pITFS; 

        DEBUGDEF(CULINT m_cbPreallocated)

        PFREEITEM m_paFreeItems;
    };

    friend CImpIFreeList;

    CImpIFreeList m_ImpIFreeList;
};

typedef CFreeList *PCFreelist;

extern GUID aIID_CFreeList[4];
extern UINT cInterfaces_CFreeList;

inline CFreeList::CFreeList(IUnknown * punkOuter)
    : m_ImpIFreeList(this, punkOuter), 
      CITUnknown(aIID_CFreeList, cInterfaces_CFreeList, (IUnknown *)&m_ImpIFreeList)
{
}


inline CFreeList::~CFreeList

()
{
}

#endif // __FREELIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\factory.h ===
// Factory.h -- Header file for this COM dll's class factory 

#ifndef __FACTORY_H__

#define __FACTORY_H__

class CFactory : public CITUnknown
{
  public:
    // Main Object Constructor & Destructor.
    ~CFactory(void);

    static STDMETHODIMP Create(REFCLSID rclsid, REFIID riid, PVOID *ppv);

  private:
    
    CFactory(IUnknown* pUnkOuter);
    
    // We declare nested class interface implementations here.

    // We implement the IClassFactory interface (ofcourse) in this class
    // factory COM object class.
    class CImpIClassFactory : public IITClassFactory
    {
      public:
        // Interface Implementation Constructor & Destructor.
        CImpIClassFactory(CFactory* pBackObj, IUnknown* pUnkOuter);
        ~CImpIClassFactory(void);

        STDMETHODIMP Init(REFCLSID rclsid);

        // IClassFactory methods.
        STDMETHODIMP         CreateInstance(IUnknown*, REFIID, PPVOID);
        STDMETHODIMP         LockServer(BOOL);

      private:

        CLSID   m_clsid;
    };

    CImpIClassFactory m_ImpIClassFactory;
};

typedef CFactory* PCFactory;

inline CFactory::CFactory(IUnknown *pUnkOuter)
    : m_ImpIClassFactory(this, pUnkOuter), 
      CITUnknown(&IID_IClassFactory, 1, &m_ImpIClassFactory)
{

}

inline CFactory::~CFactory(void)
{
}

inline CFactory::CImpIClassFactory::CImpIClassFactory
    (CFactory *pBackObj, IUnknown *punkOuter)
    : IITClassFactory(pBackObj, punkOuter)
{
    m_clsid = CLSID_NULL;
}

inline CFactory::CImpIClassFactory::~CImpIClassFactory(void)
{
}


#endif // __FACTORY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\guid.cpp ===
// GUID.CPP -- Code file where the DLL's guid structures are instantiated.

// Note: Do not use precompiled headers with this file! They can cause problems
// because we need to change the interpretation of DEFINE_GUID by defining the
// symbol INITGUID. In some cases using precompiled headers generates incorrect
// code for that case.

#define INITGUID

#include <windows.h>
#include <basetyps.h>
#include   <OLECTL.h>
#include  <WinINet.h>
#include "MemAlloc.h"
#include   <malloc.h>
#include <intshcut.h>
#include   <urlmon.h>
#include    "Types.h"

#include  "MSITStg.h"
#include     "guid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\fsstg.cpp ===
// FSStg.cpp -- Implementation for the FileSystemStorage class

#include "stdafx.h"

HRESULT STDMETHODCALLTYPE CFileSystemStorage::Create
    (IUnknown *punkOuter, REFIID riid, PPVOID ppv)
{
    if (punkOuter && riid != IID_IUnknown)
		return CLASS_E_NOAGGREGATION;
	
	CFileSystemStorage *pFSStg = New CFileSystemStorage(punkOuter);

    if (!pFSStg)
        return STG_E_INSUFFICIENTMEMORY;

    HRESULT hr = pFSStg->m_ImpIFileSystemStorage.Init();

	if (hr == S_OK)
		hr = pFSStg->QueryInterface(riid, ppv);

    if (hr != S_OK)
        delete pFSStg;

	return hr;
}


// Initialing routines:

HRESULT STDMETHODCALLTYPE CFileSystemStorage::CImpIFileSystemStorage::Init()
{
	return NO_ERROR;
}


// IFSStorage methods

HRESULT STDMETHODCALLTYPE CFileSystemStorage::CImpIFileSystemStorage::FSCreateStorage
    (const WCHAR * pwcsName, DWORD grfMode, IStorage ** ppstgOpen)
{
    return CFSStorage::CreateStorage(NULL, pwcsName, grfMode, ppstgOpen);
}

HRESULT STDMETHODCALLTYPE CFileSystemStorage::CImpIFileSystemStorage::FSOpenStorage
    (const WCHAR * pwcsName, DWORD grfMode, IStorage ** ppstgOpen)
{
    return CFSStorage:: OpenStorage(NULL, pwcsName, grfMode, ppstgOpen);
}

HRESULT STDMETHODCALLTYPE CFileSystemStorage::CImpIFileSystemStorage::FSCreateStream
    (const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm)
{
    ILockBytes *pLKB = NULL;

    HRESULT hr = CFSLockBytes::Create(NULL, pwcsName, grfMode, &pLKB);

    if (hr == S_OK)
    {
        hr = CStream::OpenStream(NULL, pLKB, grfMode, (IStreamITEx **) ppStrm);

        if (hr != S_OK) 
            pLKB->Release();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CFileSystemStorage::CImpIFileSystemStorage
                                            ::FSCreateTemporaryStream(IStream **ppStrm)
{
    ILockBytes *pLKB = NULL;

    HRESULT hr = CFSLockBytes::CreateTemp(NULL, &pLKB);

    if (hr == S_OK)
    {
        hr = CStream::OpenStream(NULL, pLKB, STGM_READWRITE, (IStreamITEx **) ppStrm);

        if (hr != S_OK) 
            pLKB->Release();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CFileSystemStorage::CImpIFileSystemStorage::FSOpenStream
    (const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm)
{
    ILockBytes *pLKB = NULL;

    HRESULT hr = CFSLockBytes::Open(NULL, pwcsName, grfMode, &pLKB);

    if (hr == S_OK)
    {
        hr = CStream::OpenStream(NULL, pLKB, grfMode, (IStreamITEx **) ppStrm);

        if (hr != S_OK) 
            pLKB->Release();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CFileSystemStorage::CImpIFileSystemStorage::FSCreateLockBytes
    (const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb)
{
	return CFSLockBytes::Create(NULL, pwcsName, grfMode, ppLkb);
}

HRESULT STDMETHODCALLTYPE CFileSystemStorage::CImpIFileSystemStorage
                                            ::FSCreateTemporaryLockBytes(ILockBytes **ppLkb)
{
    return CFSLockBytes::CreateTemp(NULL, ppLkb);
}

HRESULT STDMETHODCALLTYPE CFileSystemStorage::CImpIFileSystemStorage::FSOpenLockBytes
    (const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb)
{
	return CFSLockBytes::Open(NULL, pwcsName, grfMode, ppLkb);
}


HRESULT STDMETHODCALLTYPE CFileSystemStorage::CImpIFileSystemStorage::FSStgSetTimes
    (WCHAR const * lpszName,  FILETIME const * pctime, 
     FILETIME const * patime, FILETIME const * pmtime
    )
{
	RonM_ASSERT(FALSE);

	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\fsort.h ===
typedef enum ESortField{SORT_BY_ENTRYID, SORT_BY_OFFSET};

class CITSortRecords
{
public:
    CITSortRecords();
    
	~CITSortRecords();
    
HRESULT FileSort(int pfnCompareEntries(SEntry, SEntry, ESortField));

void Initialize(IStreamITEx *pRecStrm, 
				 ESortField eSField,
				 int		cTableRecsTotal,
				 int		cEntriesInBlk,
				 int		cbEntry);

HRESULT RecFileSort(ULONG		ulStart, 
				   ULONG		ulEnd, 
				   LPBYTE		lpSortBuf1, 
				   LPBYTE		lpSortBuf2,
				   int			*piIndexChain,
				   int		pfnCompareEntries(SEntry, SEntry, ESortField));

HRESULT FileMerge(ULONG		ulStart, 
				 ULONG		ulMid, 
				 ULONG		ulEnd,
				 LPBYTE		lpSortBuf1, 
				 LPBYTE		lpSortBuf2,
				 int		*piIndexChain,
				 int		pfnCompareEntries(SEntry, SEntry, ESortField));

void QSort(LPBYTE	lpSortBuf,
		  ULONG		ulStart, 
		  ULONG     ulEnd,
		  int		pfnCompareEntries(SEntry, SEntry, ESortField));

int Partition(LPBYTE	lpSortBuf,
			 ULONG		ulStart, 
			 ULONG      ulEnd,
			 int		pfnCompareEntries(SEntry, SEntry, ESortField));
	
void QSort2(LPBYTE		lpSortBuf1, 
			 LPBYTE		lpSortBuf2,
			 ULONG		ulStart, 
			 ULONG      ulEnd,
			 int		pfnCompareEntries(SEntry, SEntry, ESortField));;

int Partition2(LPBYTE	lpSortBuf1, 
			 PBYTE		lpSortBuf2, 
			 ULONG		ulStart, 
			 ULONG      ulEnd,
			 int		pfnCompareEntries(SEntry, SEntry, ESortField));

void Merge(LPBYTE	lpSortBuf1, 
		 LPBYTE		lpSortBuf2,
		 ULONG		*pcEntriesInBlk1, 
		 ULONG		*pcEntriesInBlk2,
		 int		pfnCompareEntries(SEntry, SEntry, ESortField));


HRESULT ReadBlk(ULONG ulBlk, 
			   LPBYTE lpSortBuf, 
			   ULONG *pcEntriesInBlk);

HRESULT WriteBlk(ULONG ulBlk, 
				  LPBYTE lpSortBuf, 
				  ULONG cEntriesInBlk);

void GetFirstAndLastEntries(ULONG ulBlk, 
							 LPBYTE lpSortBuf,
							 SEntry *psMergeFirst, 
							 SEntry *psMergeLast);

void GetEntry(LPBYTE lpSortBuf, 
			 ULONG iEntry, 
			 SEntry *psEntry);

void SetEntry(LPBYTE lpSortBuf, 
			 ULONG iEntry, 
			 SEntry *psEntry);


void ExchangeEntry(LPBYTE lpSortBuf, 
					 ULONG iEntry1, 
					 ULONG iEntry2);

void GetEntry2(LPBYTE lpSortBuf1, 
				LPBYTE  lpSortBuf2, 
				ULONG   iEntry, 
				SEntry *psEntry);

void SetEntry2(LPBYTE lpSortBuf1, 
				LPBYTE  lpSortBuf2, 
				ULONG   iEntry, 
				SEntry  *psEntry);

void ExchangeEntry2(LPBYTE lpSortBuf1, 
				  LPBYTE lpSortBuf2, 
				  ULONG  iEntry1, 
				  ULONG  iEntry2);

HRESULT ReadNextSortedBlk(int *piBlk, 
							   LPBYTE lpSortBuf, 
							   ULONG *pcEntriesInBlk,
							   BOOL	 *pfEnd);

int  GetLastBlk(int *piIndexChain, int start);
BOOL FVerifyMerge(LPBYTE lpBuf1, LPBYTE lpBuf2, ULONG cEntry1, ULONG cEntry2, BOOL fReset);
BOOL FVerifySort(int *piIndexChain, int cBlks, int start);

BOOL FVerifyData(int *piIndexChain, int cBlks, int start, LPBYTE lpBuf, BOOL fReset);


private:
    IStreamITEx		*m_pSortStrm;
    ULONG			m_cEntriesInLastBlk;
	ULONG			m_iLastBlk;
	ULONG			m_cTableRecsTotal; 
	ULONG			m_cEntriesInBlk;
	ULONG			m_cbEntry;
	int				*m_pfnCompareEntries(SEntry, SEntry, ESortField);
	ESortField		m_eSField;
	int				*m_piIndexChain;
	int				m_cNumBlks;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\fsstg.h ===
// FSStg.h -- Declaration of the FileSystemStorage class which wraps directories in
//            the Win32 file system as IStorage objects.

#ifndef __FSSTG_H__

#define __FSSTG_H__

class CFileSystemStorage : public CITUnknown
{
public:

    // Destructor:

    ~CFileSystemStorage(void);

    // Creation:

    static HRESULT STDMETHODCALLTYPE Create(IUnknown *punkOuter, REFIID riid, PPVOID ppv);

private:

    CFileSystemStorage(IUnknown *pUnkOuter);

    class CImpIFileSystemStorage : public IITFSStorage
    {
    public:

        // Constructor and Destructor:

        CImpIFileSystemStorage(CFileSystemStorage *pBackObj, IUnknown *punkOuter);
        ~CImpIFileSystemStorage(void);

        // Initialing routines:

        HRESULT STDMETHODCALLTYPE Init();

        // IFSStorage methods

        HRESULT STDMETHODCALLTYPE FSCreateStorage
            (const WCHAR * pwcsName, DWORD grfMode, IStorage ** ppstgOpen);
        HRESULT STDMETHODCALLTYPE FSCreateTemporaryStream(IStream **ppStrm);
        HRESULT STDMETHODCALLTYPE FSOpenStorage
            (const WCHAR * pwcsName, DWORD grfMode, IStorage ** ppstgOpen);
        HRESULT STDMETHODCALLTYPE FSCreateStream
            (const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm);
        HRESULT STDMETHODCALLTYPE FSOpenStream
            (const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm);
        HRESULT STDMETHODCALLTYPE FSCreateLockBytes
            (const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb);
        HRESULT STDMETHODCALLTYPE FSCreateTemporaryLockBytes(ILockBytes **ppLkb);
        HRESULT STDMETHODCALLTYPE FSOpenLockBytes
            (const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb);

        HRESULT STDMETHODCALLTYPE FSStgSetTimes
            (WCHAR const * lpszName,  FILETIME const * pctime, 
             FILETIME const * patime, FILETIME const * pmtime
            );
    };
    
    CImpIFileSystemStorage m_ImpIFileSystemStorage;
};

inline CFileSystemStorage::CFileSystemStorage(IUnknown *pUnkOuter)
    : m_ImpIFileSystemStorage(this, pUnkOuter),
      CITUnknown(&IID_IFSStorage, 1, &m_ImpIFileSystemStorage)
{
}

inline CFileSystemStorage::~CFileSystemStorage()
{
}

inline CFileSystemStorage::CImpIFileSystemStorage::CImpIFileSystemStorage
    (CFileSystemStorage *pBackObj, IUnknown *punkOuter)
    : IITFSStorage(pBackObj, punkOuter)

{
}

inline CFileSystemStorage::CImpIFileSystemStorage::~CImpIFileSystemStorage(void)
{
}


#endif // __FSSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\fsort.cpp ===
// FSORT.cpp -- Implementation for the CITSortRecords class

#include "stdafx.h"
#ifdef _DEBUG
//#include <stdio.h>
#endif


CITSortRecords::CITSortRecords()
{
	m_cEntriesInLastBlk = 0;
	m_iLastBlk = -1;
	m_pSortStrm = NULL;
	m_cTableRecsTotal = 0; 
	m_cEntriesInBlk = 0;
	m_cbEntry   = 0;
	m_eSField  = SORT_BY_OFFSET;
	m_piIndexChain = NULL;
	m_cNumBlks = 0;
}

CITSortRecords::~CITSortRecords(void)
{
	if (m_piIndexChain)
		delete m_piIndexChain;
}

void CITSortRecords::Initialize(IStreamITEx *pRecStrm, 
								 ESortField eSField,
								 int		cTableRecsTotal,
								 int		cEntriesInBlk,
								 int		cbEntry)
{
	m_pSortStrm = pRecStrm;
	m_cTableRecsTotal = cTableRecsTotal; 
	m_cEntriesInBlk	  = cEntriesInBlk;
	m_cbEntry		  = cbEntry;
	m_eSField		  = eSField;
}

HRESULT CITSortRecords::FileSort(int pfnCompareEntries(SEntry, SEntry, ESortField))
{
	HRESULT hr = NO_ERROR;

	m_cNumBlks = m_cTableRecsTotal / m_cEntriesInBlk;
	
	if (m_cEntriesInLastBlk = m_cTableRecsTotal % m_cEntriesInBlk)
	{
		if (m_iLastBlk == -1)
			m_iLastBlk = m_cNumBlks;
		
		m_cNumBlks ++; 
	}
	else
		m_cEntriesInLastBlk =  m_cEntriesInBlk;

	//allocate 2 internal buffers
	LPBYTE lpSortBuf1 = New BYTE[m_cbEntry * m_cEntriesInBlk];
	LPBYTE lpSortBuf2 = New BYTE[m_cbEntry * m_cEntriesInBlk];

	if ((lpSortBuf1 == NULL) || (lpSortBuf2 == NULL))
		return STG_E_INSUFFICIENTMEMORY;

	if (m_piIndexChain)
	{
		delete m_piIndexChain;
		m_piIndexChain = NULL;
	}

	m_piIndexChain = (int *) New BYTE[(m_cNumBlks) * sizeof(int)];
	
	if (m_piIndexChain == NULL)
		return STG_E_INSUFFICIENTMEMORY;
	
	int *pi = m_piIndexChain;
	
	for (int i = 0; i < m_cNumBlks; i++)
		*pi++ = i;

	hr = RecFileSort(0, m_cNumBlks-1,
					lpSortBuf1, lpSortBuf2, m_piIndexChain, pfnCompareEntries);

	RonM_ASSERT(FVerifySort(m_piIndexChain, m_cNumBlks, 0));

	RonM_ASSERT(FVerifyData(m_piIndexChain, m_cNumBlks, 0, lpSortBuf1, TRUE));

	delete lpSortBuf1;
	delete lpSortBuf2;

	return hr;
}


HRESULT CITSortRecords::RecFileSort(ULONG		ulStart, 
									ULONG		ulEnd, 
									LPBYTE		lpSortBuf1, 
									LPBYTE		lpSortBuf2,
									int			*piIndexChain,
									int			pfnCompareEntries(SEntry, SEntry, ESortField))
{
	HRESULT hr = NO_ERROR;

	if (ulStart == ulEnd)
	{
		ULONG cEntriesInBlk;
		if (SUCCEEDED(hr = ReadBlk(ulStart, lpSortBuf1, &cEntriesInBlk)))
		{
			QSort(lpSortBuf1, 0, cEntriesInBlk-1, pfnCompareEntries); 
			hr = WriteBlk(ulStart, lpSortBuf1, cEntriesInBlk);
		}
	}
	else
	{
		ULONG ulMid = (ulStart + ulEnd)/2;
		if (SUCCEEDED(hr = RecFileSort(ulStart, ulMid, lpSortBuf1, lpSortBuf2, piIndexChain, pfnCompareEntries)))
			if (SUCCEEDED(hr = RecFileSort(ulMid + 1, ulEnd, lpSortBuf1, lpSortBuf2, piIndexChain, pfnCompareEntries)))
				hr = FileMerge(ulStart, ulMid, ulEnd, lpSortBuf1, lpSortBuf2, piIndexChain, pfnCompareEntries);
	}
	RonM_ASSERT(SUCCEEDED(hr));
	return hr;
}

HRESULT CITSortRecords::FileMerge(ULONG		ulStart, 
								 ULONG		ulMid, 
								 ULONG		ulEnd, 
								 LPBYTE		lpSortBuf1, 
								 LPBYTE		lpSortBuf2,
								 int		*piIndexChain,
								 int		pfnCompareEntries(SEntry, SEntry, ESortField)
								 )
{
	RonM_ASSERT(ulEnd > ulStart);

	ULONG ulReadANext = ulStart;
	ULONG ulReadBNext = ulMid + 1;
	ULONG ulReadNext;
	ULONG ulReadLast;
	ULONG ulFreeList;
	ULONG ulMergeList = ulReadANext;

	ULONG cEntriesInBlk1, cEntriesInBlk2;

	cEntriesInBlk1 = cEntriesInBlk2 = m_cEntriesInBlk;

	BOOL fListMerged, fALastSeen, fBLastSeen;
	fListMerged = fALastSeen = fBLastSeen = FALSE;
	
#ifdef _DEBUG
 int 	cMerged  = 0;
#endif
	
	HRESULT hr = NO_ERROR;
	SEntry sMergeAFirst, sMergeALast, sMergeBFirst, sMergeBLast;

	ulReadNext = ulReadANext;
	
	if (SUCCEEDED(hr = ReadBlk(ulReadANext, lpSortBuf2, &cEntriesInBlk2)))
	{
		GetFirstAndLastEntries(ulReadANext, lpSortBuf2, &sMergeAFirst, &sMergeALast);
		
		ulReadLast = ulReadANext;		
		ulReadNext = ulReadBNext;

		//First node from list A
		if (ulReadLast == piIndexChain[ulReadLast])
			fALastSeen = TRUE;

		//First node from list B
		if (ulReadNext == piIndexChain[ulReadNext])
			fBLastSeen = TRUE;

		ulFreeList = ulReadANext;
		
		
		ulReadANext = piIndexChain[ulReadANext];
		//piIndexChain[ulFreeList] = ulFreeList;
	}
		
	//First node from both the lists to be merged are read unconditionally.
	//setting flags for last node seen to take care of the case where either of list
	//has one node only.

	
	while (SUCCEEDED(hr) && !fListMerged)
	{
		if (SUCCEEDED(hr = ReadBlk(ulReadNext, lpSortBuf1, &cEntriesInBlk1)))
		{
 			if (ulReadNext == ulReadANext)
			{
				GetFirstAndLastEntries(ulReadNext, lpSortBuf1, &sMergeAFirst, &sMergeALast);
				ulReadANext = piIndexChain[ulReadANext];
			}
			else
			{
				GetFirstAndLastEntries(ulReadNext, lpSortBuf1, &sMergeBFirst, &sMergeBLast);
				ulReadBNext = piIndexChain[ulReadBNext];
			}
		
			ulReadLast = ulReadNext;
				
			RonM_ASSERT(ulReadNext != ulFreeList);
	
			//decide which block to read next?
			if (pfnCompareEntries(sMergeALast , sMergeBLast, m_eSField) < 0)
			{	
				ulReadNext = ulReadANext;
				
				//If last node is hit more than once, exit loop
				if (fALastSeen)
					fListMerged = TRUE;
				
				//If last node is hit once, mark it
				if  ((!fALastSeen) && (ulReadANext == piIndexChain[ulReadANext]))
				{
					fALastSeen = TRUE;
				}
			}
			else
			{
				ulReadNext = ulReadBNext;
				
				//If last node is hit more than once, exit loop
				if (fBLastSeen)
					fListMerged = TRUE;
				
				//If last node is hit once, mark it
				if  ((!fBLastSeen) && (ulReadBNext == piIndexChain[ulReadBNext]))
				{
					fBLastSeen = TRUE;
				}
			}
				
			piIndexChain[ulFreeList] = ulReadLast;
		
			//merge these 2 buffers and put sorted records first half in
			//lpSortBuf1 and second half in lpSortBuf2
			Merge(lpSortBuf1, lpSortBuf2, &cEntriesInBlk1, &cEntriesInBlk2, pfnCompareEntries);

			RonM_ASSERT(FVerifyMerge(lpSortBuf1, lpSortBuf2, cEntriesInBlk1, cEntriesInBlk2, TRUE));

			//write first top to the free block 
			if (SUCCEEDED(hr = WriteBlk(ulFreeList, lpSortBuf1, cEntriesInBlk1)))
			{
				RonM_ASSERT(ulFreeList != piIndexChain[ulFreeList]);
				
				//add one new block to merged list
				if (ulMergeList != ulFreeList)
				{
					piIndexChain[ulMergeList] = ulFreeList;
					ulMergeList = ulFreeList;
				}
				
				//remove one block from free list
				ulFreeList = piIndexChain[ulFreeList];

				//terminate merged list
				piIndexChain[ulMergeList] = ulMergeList;
						
			}//if (SUCCEEDED(hr = .write
		}//if (SUCCEEDED(hr = .read

#ifdef _DEBUG
	cMerged ++;
#endif
	//RonM_ASSERT(FVerifyData(piIndexChain, cMerged, ulStart, lpSortBuf1, FALSE));
	}//while
	
	if (SUCCEEDED(hr))
	{
		//write second half to the free block 
		hr = WriteBlk(ulFreeList, lpSortBuf2, cEntriesInBlk2); 

		//Add one new block to merged list
		piIndexChain[ulMergeList] = ulFreeList;
		ulMergeList = ulFreeList;
	
		
		//add rest of remainning list in A or B to merged list
		if (!fALastSeen)
			piIndexChain[ulMergeList] = ulReadANext;
		else if (!fBLastSeen)
			piIndexChain[ulMergeList] = ulReadBNext;
		else
			piIndexChain[ulMergeList] = ulMergeList;
	}
	
	RonM_ASSERT(FVerifySort(piIndexChain, ulEnd - ulStart + 1, ulStart));
	
	//RonM_ASSERT(FVerifyData(piIndexChain, ulEnd - ulStart + 1, ulStart, lpSortBuf1, FALSE));
	return hr;
}

void CITSortRecords::QSort(LPBYTE	lpSortBuf,
						 ULONG		ulStart, 
						 ULONG      ulEnd,
						 int		pfnCompareEntries(SEntry, SEntry, ESortField))
{
	if (ulStart < ulEnd)
	{
		ULONG ulPartition = Partition(lpSortBuf, ulStart, ulEnd, pfnCompareEntries);
		QSort(lpSortBuf, ulStart, ulPartition, pfnCompareEntries);
		QSort(lpSortBuf, ulPartition + 1, ulEnd, pfnCompareEntries);
	}
}

int CITSortRecords::Partition(LPBYTE	lpSortBuf,
							 ULONG		ulStart, 
							 ULONG      ulEnd,
							 int		pfnCompareEntries(SEntry, SEntry, ESortField))
{
	SEntry key;
	SEntry highEntry;
	SEntry lowEntry;

	GetEntry(lpSortBuf, ulStart, &key);
	
	int iLow = ulStart - 1;
	int iHigh = ulEnd + 1;
	
	while (TRUE)
	{
		do
		{
			iHigh--;
			GetEntry(lpSortBuf, iHigh, &highEntry);
		}
		while ((pfnCompareEntries(highEntry, key, m_eSField) >= 0) && (iHigh > (int)ulStart));
		
		do
		{
			iLow++;
			GetEntry(lpSortBuf, iLow, &lowEntry);
		}
		while ((pfnCompareEntries(lowEntry, key, m_eSField) < 0) && (iLow < iHigh));

		if (iLow < iHigh)
			ExchangeEntry(lpSortBuf, iHigh, iLow);
		else 
			return iHigh;
	}
}

void CITSortRecords::QSort2(LPBYTE		lpSortBuf1, 
							 LPBYTE		lpSortBuf2, 
							 ULONG		ulStart, 
							 ULONG      ulEnd,
							 int		pfnCompareEntries(SEntry, SEntry, ESortField))
{
	if (ulStart < ulEnd)
	{
		ULONG ulPartition = Partition2(lpSortBuf1, lpSortBuf2, ulStart, ulEnd, pfnCompareEntries);
		QSort2(lpSortBuf1, lpSortBuf2, ulStart, ulPartition, pfnCompareEntries);
		QSort2(lpSortBuf1, lpSortBuf2, ulPartition + 1, ulEnd, pfnCompareEntries);
	}
}

int CITSortRecords::Partition2(LPBYTE	lpSortBuf1, 
							 PBYTE		lpSortBuf2,
							 ULONG		ulStart, 
							 ULONG      ulEnd,
							 int		pfnCompareEntries(SEntry, SEntry, ESortField))
{
	SEntry key;
	SEntry highEntry;
	SEntry lowEntry;

	GetEntry2(lpSortBuf1, lpSortBuf2, ulStart, &key);
	
	int iLow = ulStart - 1;
	int iHigh = ulEnd + 1;
	
	while (TRUE)
	{
		do
		{
			iHigh--;
			GetEntry2(lpSortBuf1, lpSortBuf2, iHigh, &highEntry);
		}
		while ((pfnCompareEntries(highEntry, key, m_eSField) >= 0) && (iHigh > (int)ulStart));
		
		do
		{
			iLow++;
			GetEntry2(lpSortBuf1, lpSortBuf2, iLow, &lowEntry);
		}
		while ((pfnCompareEntries(lowEntry, key, m_eSField) < 0) && (iLow < iHigh));

		if (iLow < iHigh)
			ExchangeEntry2(lpSortBuf1, lpSortBuf2, iHigh, iLow);
		else 
			return iHigh;
	}
}

void CITSortRecords::Merge(LPBYTE	lpSortBuf1, 
						 LPBYTE		lpSortBuf2,
						 ULONG		*pcEntriesInBlk1, 
						 ULONG		*pcEntriesInBlk2,
						 int		pfnCompareEntries(SEntry, SEntry, ESortField))
{
	ULONG bytesToCopy;
	ULONG bytesToMove;

	if (*pcEntriesInBlk1 < *pcEntriesInBlk2)
	{
		bytesToCopy = (*pcEntriesInBlk2 - *pcEntriesInBlk1) * m_cbEntry;
		bytesToMove = *pcEntriesInBlk2 * m_cbEntry - bytesToCopy;

		memCpy(lpSortBuf1 + *pcEntriesInBlk1 * m_cbEntry, lpSortBuf2, bytesToCopy);
		memmove(lpSortBuf2, lpSortBuf2 + bytesToCopy, bytesToMove);
	}
	
	QSort2( lpSortBuf1, 
			lpSortBuf2, 
			0, 
			*pcEntriesInBlk1 + *pcEntriesInBlk2 - 1,
			pfnCompareEntries);

	
	if (*pcEntriesInBlk1 < *pcEntriesInBlk2)
	{
		memmove(lpSortBuf2 + bytesToCopy, lpSortBuf2, bytesToMove);
		memCpy(lpSortBuf2, lpSortBuf1 + *pcEntriesInBlk1 * m_cbEntry, bytesToCopy);
	}
}

HRESULT CITSortRecords::ReadBlk(ULONG ulBlk, 
							   LPBYTE lpSortBuf, 
							   ULONG *pcEntriesInBlk)
{
	HRESULT hr;
	ULONG cbRead;
	LARGE_INTEGER uli;

	uli = CLINT(ulBlk * m_cEntriesInBlk * m_cbEntry).Li();
	
    if (ulBlk == m_iLastBlk) 
		*pcEntriesInBlk = m_cEntriesInLastBlk ;
	else
		*pcEntriesInBlk = m_cEntriesInBlk;
	
	
	if (SUCCEEDED(hr = m_pSortStrm->Seek(uli, STREAM_SEEK_SET, NULL)))
	{
		if (SUCCEEDED(hr = m_pSortStrm->Read(lpSortBuf, (*pcEntriesInBlk) * m_cbEntry, &cbRead)))
		{
			RonM_ASSERT(cbRead == (*pcEntriesInBlk) * m_cbEntry);
		}
	}
 	RonM_ASSERT(SUCCEEDED(hr));
	return hr;
}



HRESULT CITSortRecords::ReadNextSortedBlk(int *piBlk, 
							   LPBYTE lpSortBuf, 
							   ULONG *pcEntriesInBlk,
							   BOOL	 *pfEnd)
{
	HRESULT hr = NO_ERROR;
	RonM_ASSERT((*piBlk >= -1) && (*piBlk < m_cNumBlks));
	
	
	if (*piBlk >= 0)
	{
		if (*piBlk == m_piIndexChain[*piBlk])
		{
			*pfEnd = TRUE;
			return hr;
		}
		else
		{
			*pfEnd = FALSE;
			*piBlk = m_piIndexChain[*piBlk];
		}
	}
	else
		*piBlk = 0;

	hr = ReadBlk(*piBlk, lpSortBuf, pcEntriesInBlk);
	return hr;
}

HRESULT CITSortRecords::WriteBlk(ULONG ulBlk, 
							   LPBYTE lpSortBuf,
							   ULONG cEntriesInBlk)
{
	LARGE_INTEGER uli;
	HRESULT hr;
	ULONG cbWritten;

	uli = CLINT(ulBlk * m_cEntriesInBlk * m_cbEntry).Li();
	
	if (SUCCEEDED(hr = m_pSortStrm->Seek(uli, STREAM_SEEK_SET, NULL)))
	{
		if (SUCCEEDED(hr = m_pSortStrm->Write(lpSortBuf, cEntriesInBlk * m_cbEntry, &cbWritten)))
		{
			RonM_ASSERT(cbWritten == cEntriesInBlk * m_cbEntry);
			if (cEntriesInBlk < m_cEntriesInBlk)
					m_iLastBlk = ulBlk;
		}
	}
	return hr;
}

void CITSortRecords::GetFirstAndLastEntries(ULONG ulBlk, 
											 LPBYTE lpSortBuf, 
											 SEntry *psMergeFirst, 
											 SEntry *psMergeLast)
{
	GetEntry(lpSortBuf, 0, psMergeFirst);
	
	int cEntriesInBlk;

	if (ulBlk == m_iLastBlk) 
		cEntriesInBlk = m_cEntriesInLastBlk ;
	else
		cEntriesInBlk = m_cEntriesInBlk;

	GetEntry(lpSortBuf, (cEntriesInBlk - 1), psMergeLast);
}

void CITSortRecords::GetEntry(LPBYTE lpSortBuf, 
							 ULONG iEntry,
							 SEntry *psEntry)
{
	memCpy(psEntry,  lpSortBuf + iEntry * m_cbEntry, m_cbEntry);
}

void CITSortRecords::SetEntry(LPBYTE lpSortBuf, 
							 ULONG iEntry, 
							 SEntry *psEntry)
{
	memCpy(lpSortBuf + iEntry * m_cbEntry, psEntry, m_cbEntry);
}

void CITSortRecords::ExchangeEntry(LPBYTE lpSortBuf, 
								 ULONG iEntry1, 
								 ULONG iEntry2) 
{
	SEntry sTemp1;
	SEntry sTemp2;
	GetEntry(lpSortBuf, iEntry1, &sTemp1);
	GetEntry(lpSortBuf, iEntry2, &sTemp2);
	SetEntry(lpSortBuf, iEntry1, &sTemp2);
	SetEntry(lpSortBuf, iEntry2, &sTemp1);
}

void CITSortRecords::GetEntry2(LPBYTE lpSortBuf1, 
								LPBYTE  lpSortBuf2,
								ULONG   iEntry, 
								SEntry *psEntry)
{
	if (iEntry < m_cEntriesInBlk)
		memCpy(psEntry,  lpSortBuf1 + iEntry * m_cbEntry, m_cbEntry);
	else
	{
		iEntry = iEntry - m_cEntriesInBlk;
		memCpy(psEntry,  lpSortBuf2 + iEntry * m_cbEntry, m_cbEntry);
	}
}
void CITSortRecords::SetEntry2(LPBYTE lpSortBuf1, 
								LPBYTE  lpSortBuf2, 
								ULONG   iEntry, 
								SEntry  *psEntry)
{
	if (iEntry < m_cEntriesInBlk)
		memCpy(lpSortBuf1 + iEntry * m_cbEntry, psEntry, m_cbEntry);
	else
	{
		iEntry = iEntry - m_cEntriesInBlk;
		memCpy(lpSortBuf2 + iEntry * m_cbEntry, psEntry, m_cbEntry);
	}
}

void CITSortRecords::ExchangeEntry2(LPBYTE lpSortBuf1, 
								  LPBYTE lpSortBuf2, 
								  ULONG  iEntry1, 
								  ULONG  iEntry2) 
{
	SEntry sTemp1;
	SEntry sTemp2;

	GetEntry2(lpSortBuf1, lpSortBuf2, iEntry1, &sTemp1);
	GetEntry2(lpSortBuf1, lpSortBuf2, iEntry2, &sTemp2);
	SetEntry2(lpSortBuf1, lpSortBuf2, iEntry1, &sTemp2);
	SetEntry2(lpSortBuf1, lpSortBuf2, iEntry2, &sTemp1);
}

int CITSortRecords::GetLastBlk(int *piIndexChain, int start)
{
	int index = start;
	while( piIndexChain[index] != index)
		index = piIndexChain[index];
		
	return index;
}


BOOL CITSortRecords::FVerifySort(int *piIndexChain, int cBlks, int start)
{
	int index = start;
	int cBlksCovered = 1;
	while( piIndexChain[index] != index)
	{
		index = piIndexChain[index];
		cBlksCovered++;
	}
	return (cBlks == cBlksCovered);
}

BOOL CITSortRecords::FVerifyData(int *piIndexChain, int cNumBlks, int start, LPBYTE lpBuf, BOOL fFinal)
{
	static int cEntry;
	static CULINT ullLastEntryOffset = CULINT(0);
	static UINT ulLastEntryID = 0;
	static CULINT ulLastSize = CULINT(0);

	ullLastEntryOffset = CULINT(0);
	
	if (fFinal)
	{
		ulLastEntryID = start * m_cEntriesInBlk;
		cEntry = start * m_cEntriesInBlk;
		ulLastSize = CULINT(0);
	}
	else
	{
		ulLastEntryID = 0;
		cEntry = 0;
  	    ulLastSize = CULINT(0);
	}

	int *pi = piIndexChain;
	int iCurBlk = start;
	int cnt = 0;
	BOOL fEndLoop = FALSE;
	HRESULT hr = S_OK;

	while (!fEndLoop && SUCCEEDED(hr))
	{
		cnt++;
	
		//read block in sorted sequence
		ULONG cRecsToRead = m_cEntriesInBlk;

		if (SUCCEEDED(hr = ReadBlk(iCurBlk, (LPBYTE)lpBuf, &cRecsToRead)))
		{
			for (int iEntry = 0; iEntry < cRecsToRead; iEntry++, cEntry++)
			{
				SEntry *pe = (SEntry *)(lpBuf + iEntry * sizeof(SEntry));
				//printf("Entry%d offset= %d, entryid = %d, size = %d\n", 
				//	cEntry, (int)pe->ullcbOffset.Ull(), (int)pe->ulEntryID, (int)pe->ullcbData.Ull());
				
				if (m_eSField == SORT_BY_OFFSET)
				{
					RonM_ASSERT(pe->ullcbOffset >= ullLastEntryOffset);
					if (pe->ullcbOffset < ullLastEntryOffset)
						return FALSE;
				}
				else
				{
					if (fFinal)
					{
						//RonM_ASSERT(cEntry == pe->ulEntryID);
					}

					RonM_ASSERT(pe->ulEntryID >= ulLastEntryID);

					if (pe->ulEntryID < ulLastEntryID)
						return FALSE;
				}
				ullLastEntryOffset = pe->ullcbOffset;
				ulLastEntryID = pe->ulEntryID;
				ulLastSize =  pe->ullcbData;
			}

		}//read next file block in sorted sequence
		
		if (iCurBlk == piIndexChain[iCurBlk])
			fEndLoop = TRUE;

		iCurBlk = piIndexChain[iCurBlk];
	
	}//while

	//printf("****************************************\n"); 
	//printf("Total entries verified = %d\n", cEntry);
					
	return (cnt == cNumBlks);
}

BOOL CITSortRecords::FVerifyMerge(LPBYTE lpBuf1, LPBYTE lpBuf2, ULONG cEntry1, ULONG cEntry2, BOOL fReset)
{
	static CULINT ullLastEntryOffset = CULINT(0);
	static UINT ulLastEntryID = 0;

//	printf("Verifying Merge start ####################\n");
	if (fReset)
	{
		ullLastEntryOffset = CULINT(0);
		ulLastEntryID = 0;
	}

	for (int iEntry = 0; iEntry < cEntry1; iEntry++)
	{
		SEntry *pe = (SEntry *)(lpBuf1 + iEntry * sizeof(SEntry));
	//	printf("entryid = %d, size = %d\n", 
	//		(int)pe->ullcbOffset.Ull(), (int)pe->ulEntryID, (int)pe->ullcbData.Ull());
		
		if (m_eSField == SORT_BY_OFFSET)
		{
			if (pe->ullcbOffset < ullLastEntryOffset)
				return FALSE;
		}
		else
		{
			if (pe->ulEntryID < ulLastEntryID)
				return FALSE;
		}
		ullLastEntryOffset = pe->ullcbOffset;
		ulLastEntryID = pe->ulEntryID;
	}

	for (iEntry = 0; iEntry < cEntry2; iEntry++)
	{
		SEntry *pe = (SEntry *)(lpBuf2 + iEntry * sizeof(SEntry));
		//printf("offset= %d, entryid = %d, size = %d\n", 
		//	 (int)pe->ullcbOffset.Ull(), (int)pe->ulEntryID, (int)pe->ullcbData.Ull());
		
		if (m_eSField == SORT_BY_OFFSET)
		{
			if (pe->ullcbOffset < ullLastEntryOffset)
				return FALSE;
		}
		else
		{
			if (pe->ulEntryID < ulLastEntryID)
				return FALSE;
		}

		ullLastEntryOffset = pe->ullcbOffset;
		ulLastEntryID = pe->ulEntryID;
	}
//printf("Verifying Merge End ####################\n\n");
return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\guid.h ===
// Guid.h -- Private class and interface GUIDs

#define CWC_GUID_STRING_BUFFER 39

// We expose IParseDisplayName via the CLSID_PARSE_URL class id:

// {9D148290-B9C8-11d0-A4CC-0000F80149F6}
DEFINE_GUID(CLSID_PARSE_URL, 
0x9d148290, 0xb9c8, 0x11d0, 0xa4, 0xcc, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

// We expose our protocol interfaces via the CLSID_IE4_PROTOCOLS class id

// {9D148291-B9C8-11d0-A4CC-0000F80149F6}
DEFINE_GUID(CLSID_IE4_PROTOCOLS, 
0x9d148291, 0xb9c8, 0x11d0, 0xa4, 0xcc, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);


// Within the ITSS code we use these interface id's to allow for 
// plug-in components:

// {FEBFD076-8395-11d0-9E13-00A0C922E6EC}
DEFINE_GUID(IID_IFreeListManager, 
0xfebfd076, 0x8395, 0x11d0, 0x9e, 0x13, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// {FEBFD077-8395-11d0-9E13-00A0C922E6EC}
DEFINE_GUID(IID_PathManager, 
0xfebfd077, 0x8395, 0x11d0, 0x9e, 0x13, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// {EB19B682-9360-11d0-9E16-00A0C922E6EC}
DEFINE_GUID(IID_IEntryHandler, 
0xeb19b682, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Class IDs for the disk space managers used within an ITStorage object:

DEFINE_GUID(CLSID_IFreeListManager_1, 
0x7c01fd10, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Class IDs for the directory services used within an ITStorage object:

DEFINE_GUID(CLSID_PathManager_1, 
0x7c01fd11, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// {A55895FD-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(CLSID_SystemPathManager, 
0xa55895fd, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// {4B6E47A4-8EC2-11d0-9E15-00A0C922E6EC}
DEFINE_GUID(IID_ITFileSystem, 
0x4b6e47a4, 0x8ec2, 0x11d0, 0x9e, 0x15, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ISequentialStream,
0x0c733a30, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x0, 0xaa, 0x0, 0x44, 0x77, 0x3d);

// {7FC28940-9D31-11d0-9B27-00A0C91E9C7C}
DEFINE_GUID(CLSID_LZX_Transform, 
0x7fc28940, 0x9d31, 0x11d0, 0x9b, 0x27, 0x0, 0xa0, 0xc9, 0x1e, 0x9c, 0x7c);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\ie4int.h ===
// IE4Int.h -- IE 4.0 interfaces which we use or implement

#ifndef __IE4INT_H__

#define __IE4INT_H__

#ifndef __IOInetProtocolRoot_INTERFACE_DEFINED__
#define __IOInetProtocolRoot_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetProtocolRoot
 * at Wed Apr 30 05:28:51 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetProtocolRoot __RPC_FAR *LPOINETPROTOCOLROOT;

typedef 
enum _tagPI_FLAGS
    {	PI_PARSE_URL	= 0x1,
	PI_FILTER_MODE	= 0x2,
	PI_FORCE_ASYNC	= 0x4,
	PI_USE_WORKERTHREAD	= 0x8,
	PI_MIMEVERIFICATION	= 0x10,
	PI_DOCFILECLSIDLOOKUP	= 0x20,
	PI_DATAPROGRESS	= 0x40,
	PI_SYNCHRONOUS	= 0x80,
	PI_APARTMENTTHREADED	= 0x100
    }	PI_FLAGS;

typedef struct  _tagPROTOCOLDATA
    {
    DWORD grfFlags;
    DWORD dwState;
    LPVOID pData;
    ULONG cbData;
    }	PROTOCOLDATA;


EXTERN_C const IID IID_IOInetProtocolRoot;

    interface DECLSPEC_UUID("79eac9e3-baf9-11ce-8c82-00aa004ba90b")
    IOInetProtocolRoot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IOInetProtocolSink __RPC_FAR *pOIProtSink,
            /* [in] */ IOInetBindInfo __RPC_FAR *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( 
            /* [in] */ PROTOCOLDATA __RPC_FAR *pProtocolData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#endif // __IOInetProtocolRoot_INTERFACE_DEFINED__

#ifndef _LPOINETPROTOCOL_DEFINED
#define _LPOINETPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0098_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0098_v0_0_s_ifspec;

#ifndef __IOInetProtocol_INTERFACE_DEFINED__
#define __IOInetProtocol_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetProtocol
 * at Wed Apr 30 05:28:51 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IOInetProtocol;

interface DECLSPEC_UUID("79eac9e4-baf9-11ce-8c82-00aa004ba90b")
IOInetProtocol : public IOInetProtocolRoot
{
public:
    virtual HRESULT STDMETHODCALLTYPE Read( 
        /* [length_is][size_is][out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Seek( 
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE LockRequest( 
        /* [in] */ DWORD dwOptions) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRequest( void) = 0;
    
};
    
#endif // __IOInetProtocol_INTERFACE_DEFINED__

#endif // _LPOINETPROTOCOL_DEFINED

#ifndef _LPOINETPROTOCOLSINK_DEFINED
#define _LPOINETPROTOCOLSINK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0099_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0099_v0_0_s_ifspec;

#ifndef __IOInetProtocolSink_INTERFACE_DEFINED__
#define __IOInetProtocolSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetProtocolSink
 * at Wed Apr 30 05:28:51 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetProtocolSink __RPC_FAR *LPOINETPROTOCOLSINK;


EXTERN_C const IID IID_IOInetProtocolSink;

interface DECLSPEC_UUID("79eac9e5-baf9-11ce-8c82-00aa004ba90b")
IOInetProtocolSink : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Switch( 
        /* [in] */ PROTOCOLDATA __RPC_FAR *pProtocolData) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE ReportProgress( 
        /* [in] */ ULONG ulStatusCode,
        /* [in] */ LPCWSTR szStatusText) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE ReportData( 
        /* [in] */ DWORD grfBSCF,
        /* [in] */ ULONG ulProgress,
        /* [in] */ ULONG ulProgressMax) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE ReportResult( 
        /* [in] */ HRESULT hrResult,
        /* [in] */ DWORD dwError,
        /* [in] */ LPCWSTR szResult) = 0;
    
};
    
#endif // __IOInetProtocolSink_INTERFACE_DEFINED__

#endif // _LPOINETPROTOCOLSINK_DEFINED

#ifndef __IOInetProtocolInfo_INTERFACE_DEFINED__
#define __IOInetProtocolInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetProtocolInfo
 * at Wed Apr 30 05:28:51 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef 
enum _tagPARSEACTION
    {	PARSE_CANONICALIZE	= 1,
	PARSE_FRIENDLY	= PARSE_CANONICALIZE + 1,
	PARSE_SECURITY_DOMAIN	= PARSE_FRIENDLY + 1,
	PARSE_ROOTDOCUMENT	= PARSE_SECURITY_DOMAIN + 1,
	PARSE_DOCUMENT	= PARSE_ROOTDOCUMENT + 1,
	PARSE_ANCHOR	= PARSE_DOCUMENT + 1,
	PARSE_ENCODE	= PARSE_ANCHOR + 1,
	PARSE_DECODE	= PARSE_ENCODE + 1,
	PARSE_PATH_FROM_URL	= PARSE_DECODE + 1,
	PARSE_URL_FROM_PATH	= PARSE_PATH_FROM_URL + 1,
	PARSE_MIME	= PARSE_URL_FROM_PATH + 1,
	PARSE_SERVER	= PARSE_MIME + 1
    }	PARSEACTION;

typedef 
enum _tagQUERYOPTION
    {	QUERY_EXPIRATION_DATE	= 1,
	QUERY_TIME_OF_LAST_CHANGE	= QUERY_EXPIRATION_DATE + 1,
	QUERY_CONTENT_ENCODING	= QUERY_TIME_OF_LAST_CHANGE + 1
    }	QUERYOPTION;


EXTERN_C const IID IID_IOInetProtocolInfo;

interface DECLSPEC_UUID("79eac9ec-baf9-11ce-8c82-00aa004ba90b")
IOInetProtocolInfo : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE ParseUrl( 
        /* [in] */ LPCWSTR pwzUrl,
        /* [in] */ PARSEACTION ParseAction,
        /* [in] */ DWORD dwParseFlags,
        /* [out] */ LPWSTR pwzResult,
        /* [in] */ DWORD cchResult,
        /* [out] */ DWORD __RPC_FAR *pcchResult,
        /* [in] */ DWORD dwReserved) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE CombineUrl( 
        /* [in] */ LPCWSTR pwzBaseUrl,
        /* [in] */ LPCWSTR pwzRelativeUrl,
        /* [in] */ DWORD dwCombineFlags,
        /* [out] */ LPWSTR pwzResult,
        /* [in] */ DWORD cchResult,
        /* [out] */ DWORD __RPC_FAR *pcchResult,
        /* [in] */ DWORD dwReserved) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE CompareUrl( 
        /* [in] */ LPCWSTR pwzUrl1,
        /* [in] */ LPCWSTR pwzUrl2,
        /* [in] */ DWORD dwCompareFlags) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE QueryInfo( 
        /* [in] */ LPCWSTR pwzUrl,
        /* [in] */ QUERYOPTION OueryOption,
        /* [in] */ DWORD dwQueryFlags,
        /* [size_is][out][in] */ LPVOID pBuffer,
        /* [in] */ DWORD cbBuffer,
        /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
        /* [in] */ DWORD dwReserved) = 0;
    
};

typedef /* [unique] */ IOInetProtocolInfo *LPOINETPROTOCOLINFO;

#endif // __IOInetProtocolInfo_INTERFACE_DEFINED__






#endif // __IE4INT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\ieverp.h ===
// DO NOT Edit this file w/o consulting with the IE build lab (mailto:iebld)

// Change VER_PRODUCTBUILD and VER_PRODUCTBUILD_QFE as appropriate.

#define VER_MAJOR_PRODUCTVER		5
#define VER_MINOR_PRODUCTVER		00
#define VER_PRODUCTBUILD		/* Win9x */  2920
#define VER_PRODUCTBUILD_QFE		/* Win9x */  0000

#define VER_PRODUCTVERSION		VER_MAJOR_PRODUCTVER,VER_MINOR_PRODUCTVER,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W		(0x0500)
#define VER_PRODUCTVERSION_DW		(0x05000000 | VER_PRODUCTBUILD)


// READ THIS

// Do not change VER_PRODUCTVERSION_STRING.
//
//       Again
//
// Do not change VER_PRODUCTVERSION_STRING.
//
//       One more time
//
// Do not change VER_PRODUCTVERSION_STRING.
//
// ntverp.h will do the right thing wrt the minor version #'s by stringizing
// the VER_PRODUCTBUILD and VER_PRODUCTBUILD_QFE values and concatenating them to
// the end of VER_PRODUCTVERSION_STRING.  VER_PRODUCTVERSION_STRING only needs
// is the major product version #'s. (currently, 5.00)

#define VER_PRODUCTBETA_STR		/* Win9x */  ""
#define VER_PRODUCTVERSION_STRING	"5.00"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\itparse.cpp ===
// ITParse.cpp -- Implementation for the CParser class

#include "stdafx.h"

HRESULT STDMETHODCALLTYPE CParser::Create(IUnknown *punkOuter, REFIID riid, PPVOID ppv)
{
    if (punkOuter && riid != IID_IUnknown)
		return CLASS_E_NOAGGREGATION;
	
	CParser *pParser = New CParser(punkOuter);

    if (!pParser)
        return STG_E_INSUFFICIENTMEMORY;

    HRESULT hr = pParser->m_ImpIParser.Init();

	if (hr == S_OK)
		hr = pParser->QueryInterface(riid, ppv);

    if (hr != S_OK)
        delete pParser;

	return hr;
}

HRESULT STDMETHODCALLTYPE CParser::CImpIParser::ParseDisplayName( 
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ LPOLESTR pszDisplayName,
    /* [out] */ ULONG __RPC_FAR *pchEaten,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut)
{
    return CStorageMoniker::CreateStorageMoniker
             (NULL, pbc, pszDisplayName, pchEaten, ppmkOut); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\itifaces.h ===
// ITIFaces.h -- Interface definitions within the ITSS DLL

#ifndef __ITIFACES_H__

#define __ITIFACES_H__

interface IITClassFactory : public CImpITUnknown
{
public:

    IITClassFactory(CITUnknown *pBackObj, IUnknown *punkOuter);

    // IClassFactory methods:

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
        /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE LockServer( 
        /* [in] */ BOOL fLock) = 0;
    
};

inline IITClassFactory::IITClassFactory(CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}

interface IITITStorage : public CImpITUnknown
{
public:

    IITITStorage(CITUnknown *pBackObj, IUnknown *punkOuter);

    // ITStorage methods:

    STDMETHOD(StgCreateDocfile)(const WCHAR * pwcsName, DWORD grfMode, 
                                DWORD reserved, IStorage ** ppstgOpen
                               ) PURE;

    STDMETHOD(StgCreateDocfileOnILockBytes)(ILockBytes * plkbyt, DWORD grfMode,
                                            DWORD reserved, IStorage ** ppstgOpen
                                           ) PURE;

    STDMETHOD(StgIsStorageFile)(const WCHAR * pwcsName) PURE;

    STDMETHOD(StgIsStorageILockBytes)(ILockBytes * plkbyt) PURE;

    STDMETHOD(StgOpenStorage)(const WCHAR * pwcsName, IStorage * pstgPriority, 
                              DWORD grfMode, SNB snbExclude, DWORD reserved, 
                              IStorage ** ppstgOpen
                             ) PURE;

    STDMETHOD(StgOpenStorageOnILockBytes)
                  (ILockBytes * plkbyt, IStorage * pStgPriority, DWORD grfMode, 
                   SNB snbExclude, DWORD reserved, IStorage ** ppstgOpen
                  ) PURE;

    STDMETHOD(StgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                           FILETIME const * patime, FILETIME const * pmtime
                          ) PURE;

    STDMETHOD(SetControlData)(PITS_Control_Data pControlData) PURE;

    STDMETHOD(DefaultControlData)(PITS_Control_Data *ppControlData) PURE;
	STDMETHOD(Compact)(const WCHAR * pwcsName, ECompactionLev iLev) PURE;
};

inline IITITStorage::IITITStorage(CITUnknown *pBackObj, IUnknown *punkOuter)
    : CImpITUnknown(pBackObj, punkOuter)
{
}

interface IITITStorageEx : public IITITStorage
{
public:

    IITITStorageEx(CITUnknown *pBackObj, IUnknown *punkOuter);

    // ITStorageEx methods:
    
    STDMETHOD(StgCreateDocfileForLocale)
        (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(StgCreateDocfileForLocaleOnILockBytes)
        (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(QueryFileStampAndLocale)(const WCHAR *pwcsName, DWORD *pFileStamp, 
                                                              DWORD *pFileLocale) PURE;
    
    STDMETHOD(QueryLockByteStampAndLocale)(ILockBytes * plkbyt, DWORD *pFileStamp, 
                                                                DWORD *pFileLocale) PURE;
};

inline IITITStorageEx::IITITStorageEx(CITUnknown *pBackObj, IUnknown *punkOuter)
    : IITITStorage(pBackObj, punkOuter)
{
}

interface IITParseDisplayName : public CImpITUnknown
{
public:

    IITParseDisplayName(CITUnknown *pBackObj, IUnknown *punkOuter);
    
    // IParseDisplayName methods:

    virtual HRESULT STDMETHODCALLTYPE ParseDisplayName( 
        /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
        /* [in] */ LPOLESTR pszDisplayName,
        /* [out] */ ULONG __RPC_FAR *pchEaten,
        /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut) = 0;
};

inline IITParseDisplayName::IITParseDisplayName(CITUnknown *pBackObj, IUnknown *punkOuter)
    : CImpITUnknown(pBackObj, punkOuter)
{
}

interface IITFSStorage : public CImpITUnknown
{
public:

    IITFSStorage(CITUnknown *pBackObj, IUnknown *punkOuter);
    
    // IFSStorage methods

    virtual HRESULT STDMETHODCALLTYPE FSCreateStorage
        (const WCHAR * pwcsName, DWORD grfMode, IStorage ** ppstgOpen) = 0;

    virtual HRESULT STDMETHODCALLTYPE FSOpenStorage
        (const WCHAR * pwcsName, DWORD grfMode, IStorage ** ppstgOpen) = 0;

    virtual HRESULT STDMETHODCALLTYPE FSCreateStream
        (const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) = 0;
    virtual HRESULT STDMETHODCALLTYPE FSCreateTemporaryStream(IStream **ppStrm) = 0;
    virtual HRESULT STDMETHODCALLTYPE FSOpenStream
        (const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) = 0;
    virtual HRESULT STDMETHODCALLTYPE FSCreateLockBytes
        (const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) = 0;
    virtual HRESULT STDMETHODCALLTYPE FSCreateTemporaryLockBytes(ILockBytes **ppLkb) = 0;
    virtual HRESULT STDMETHODCALLTYPE FSOpenLockBytes
        (const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) = 0;

    virtual HRESULT STDMETHODCALLTYPE FSStgSetTimes
        (WCHAR const * lpszName,  FILETIME const * pctime, 
                             FILETIME const * patime, FILETIME const * pmtime
                            ) = 0;
};

inline IITFSStorage::IITFSStorage
    (CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}

typedef struct _PathInfo
{
    union
    {
        struct 
        {
            CULINT ullcbOffset;      // Byte offset location of stream within lockbyte segment
            CULINT ullcbData;        // Length of the stream in bytes
        };
        
        CLSID clsidStorage;          // Class ID for a Storage object
    };                               // NB: Storage paths end with '/'

    UINT        uStateBits;          // State bits for storages
    UINT        iLockedBytesSegment; // Index to the containing lockbyte segment
    UINT        cUnrecordedChanges;
    ULONG        cwcStreamPath;      // Length of path string name
    WCHAR       awszStreamPath[MAX_PATH]; // Path string

} PathInfo, *PPathInfo;

interface IITLockBytes : public CImpITUnknown
{
public:

    IITLockBytes(CITUnknown *pBackObj, IUnknown *punkOuter, WCHAR *pwcsName);

    static HRESULT CopyLockBytes
        (ILockBytes *pilbSrc,  CULINT ullBaseSrc, CULINT ullLimitSrc,
         ILockBytes *pilbDest, CULINT ullBaseDest
        );

    BOOL IsNamed(const WCHAR *pwszFileName);
    
    enum { CB_COPY_BUFFER = 8192 };
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE ReadAt( 
        /* [in] */ ULARGE_INTEGER ulOffset,
        /* [length_is][size_is][out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead) = 0;
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE WriteAt( 
        /* [in] */ ULARGE_INTEGER ulOffset,
        /* [size_is][in] */ const void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbWritten) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE SetSize( 
        /* [in] */ ULARGE_INTEGER cb) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        /* [out] */ STATSTG __RPC_FAR *pstatstg,
        /* [in] */ DWORD grfStatFlag) = 0;

private:

        WCHAR *m_pwcsName;
};

inline IITLockBytes::IITLockBytes(CITUnknown *pBackObj, IUnknown *punkOuter, WCHAR *pwcsName)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
    m_pwcsName = pwcsName;
}
    
inline BOOL IITLockBytes::IsNamed(const WCHAR *pwszFileName)
{
    return !wcsicmp_0x0409(pwszFileName, m_pwcsName);
}

interface IITPersist : public CImpITUnknown
{
public:

    IITPersist(CITUnknown *pBackObj, IUnknown *punkOuter);
    
    virtual HRESULT STDMETHODCALLTYPE GetClassID( 
        /* [out] */ CLSID __RPC_FAR *pClassID) = 0;
    
};

inline IITPersist::IITPersist(CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}
    
interface IITPersistStream : public IITPersist
{
public:

    IITPersistStream(CITUnknown *pBackObj, IUnknown *punkOuter);
    
    virtual HRESULT STDMETHODCALLTYPE IsDirty( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Load( 
        /* [unique][in] */ IStream __RPC_FAR *pStm) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Save( 
        /* [unique][in] */ IStream __RPC_FAR *pStm,
        /* [in] */ BOOL fClearDirty) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE GetSizeMax( 
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize) = 0;
};

inline IITPersistStream::IITPersistStream(CITUnknown *pBackObj, IUnknown *punkOuter)
    : IITPersist(pBackObj, punkOuter)
{ 
}

interface IITMoniker : public IITPersistStream
{
public:
    
    IITMoniker(CITUnknown *pBackObj, IUnknown *punkOuter);

    // IMoniker methods:

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE BindToObject( 
        /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
        /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
        /* [in] */ REFIID riidResult,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult) = 0;
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE BindToStorage( 
        /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
        /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObj) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Reduce( 
        /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
        /* [in] */ DWORD dwReduceHowFar,
        /* [unique][out][in] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkToLeft,
        /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkReduced) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE ComposeWith( 
        /* [unique][in] */ IMoniker __RPC_FAR *pmkRight,
        /* [in] */ BOOL fOnlyIfNotGeneric,
        /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkComposite) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Enum( 
        /* [in] */ BOOL fForward,
        /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE IsEqual( 
        /* [unique][in] */ IMoniker __RPC_FAR *pmkOtherMoniker) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Hash( 
        /* [out] */ DWORD __RPC_FAR *pdwHash) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE IsRunning( 
        /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
        /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
        /* [unique][in] */ IMoniker __RPC_FAR *pmkNewlyRunning) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE GetTimeOfLastChange( 
        /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
        /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
        /* [out] */ FILETIME __RPC_FAR *pFileTime) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Inverse( 
        /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE CommonPrefixWith( 
        /* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
        /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkPrefix) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE RelativePathTo( 
        /* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
        /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkRelPath) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
        /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
        /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
        /* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE ParseDisplayName( 
        /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
        /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
        /* [in] */ LPOLESTR pszDisplayName,
        /* [out] */ ULONG __RPC_FAR *pchEaten,
        /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE IsSystemMoniker( 
        /* [out] */ DWORD __RPC_FAR *pdwMksys) = 0;
    
};

inline IITMoniker::IITMoniker(CITUnknown *pBackObj, IUnknown *punkOuter)
    : IITPersistStream(pBackObj, punkOuter)
{ 
}

interface IITPersistStreamInit : public IITPersist
{
public:

    IITPersistStreamInit(CITUnknown *pBackObj, IUnknown *punkOuter);
    
    virtual HRESULT STDMETHODCALLTYPE IsDirty( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Load( 
        /* [in] */ LPSTREAM pStm) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Save( 
        /* [in] */ LPSTREAM pStm,
        /* [in] */ BOOL fClearDirty) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE GetSizeMax( 
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE InitNew( void) = 0;
    
};

inline IITPersistStreamInit::IITPersistStreamInit(CITUnknown *pBackObj, IUnknown *punkOuter)
    : IITPersist(pBackObj, punkOuter)
{ 
}

interface IITSequentialStream : public CImpITUnknown
{
public:

    IITSequentialStream(CITUnknown *pBackObj, IUnknown *punkOuter);

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read( 
        /* [length_is][size_is][out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead) = 0;
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write( 
        /* [size_is][in] */ const void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbWritten) = 0;
    
};

inline IITSequentialStream::IITSequentialStream(CITUnknown *pBackObj, IUnknown *punkOuter)
    : CImpITUnknown(pBackObj, punkOuter)
{ 
}

interface IITStream : public IITSequentialStream
{
public:

    IITStream(CITUnknown *pBackObj, IUnknown *punkOuter);

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek( 
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE SetSize( 
        /* [in] */ ULARGE_INTEGER libNewSize) = 0;
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo( 
        /* [unique][in] */ IStream __RPC_FAR *pstm,
        /* [in] */ ULARGE_INTEGER cb,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        /* [in] */ DWORD grfCommitFlags) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Revert( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        /* [out] */ STATSTG __RPC_FAR *pstatstg,
        /* [in] */ DWORD grfStatFlag) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm) = 0;
    
};

inline IITStream::IITStream(CITUnknown *pBackObj, IUnknown *punkOuter)
    : IITSequentialStream(pBackObj, punkOuter)
{ 
}

interface IITStreamITEx : public IITStream
{
public:

    IITStreamITEx(CITUnknown *pBackObj, IUnknown *punkOuter);

    virtual HRESULT STDMETHODCALLTYPE SetDataSpaceName(const WCHAR  * pwcsDataSpaceName) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetDataSpaceName(      WCHAR **ppwcsDataSpaceName) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

};

inline IITStreamITEx::IITStreamITEx(CITUnknown *pBackObj, IUnknown *punkOuter)
    : IITStream(pBackObj, punkOuter)
{ 
}

interface IIT_IStorage : public CImpITUnknown
{
public:

    IIT_IStorage(CITUnknown *pBackObj, IUnknown *punkOuter, WCHAR *pwcsName);

    BOOL IsNamed(const WCHAR *pwszFileName);

    virtual HRESULT STDMETHODCALLTYPE CreateStream( 
        /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
        /* [in] */ DWORD grfMode,
        /* [in] */ DWORD reserved1,
        /* [in] */ DWORD reserved2,
        /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm) = 0;
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE OpenStream( 
        /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
        /* [unique][in] */ void __RPC_FAR *reserved1,
        /* [in] */ DWORD grfMode,
        /* [in] */ DWORD reserved2,
        /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE CreateStorage( 
        /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
        /* [in] */ DWORD grfMode,
        /* [in] */ DWORD dwStgFmt,
        /* [in] */ DWORD reserved2,
        /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE OpenStorage( 
        /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
        /* [unique][in] */ IStorage __RPC_FAR *pstgPriority,
        /* [in] */ DWORD grfMode,
        /* [unique][in] */ SNB snbExclude,
        /* [in] */ DWORD reserved,
        /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE CopyTo( 
        /* [in] */ DWORD ciidExclude,
        /* [size_is][unique][in] */ const IID __RPC_FAR *rgiidExclude,
        /* [unique][in] */ SNB snbExclude,
        /* [unique][in] */ IStorage __RPC_FAR *pstgDest) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE MoveElementTo( 
        /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
        /* [unique][in] */ IStorage __RPC_FAR *pstgDest,
        /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName,
        /* [in] */ DWORD grfFlags) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        /* [in] */ DWORD grfCommitFlags) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Revert( void) = 0;
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumElements( 
        /* [in] */ DWORD reserved1,
        /* [size_is][unique][in] */ void __RPC_FAR *reserved2,
        /* [in] */ DWORD reserved3,
        /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DestroyElement( 
        /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE RenameElement( 
        /* [string][in] */ const OLECHAR __RPC_FAR *pwcsOldName,
        /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE SetElementTimes( 
        /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
        /* [in] */ const FILETIME __RPC_FAR *pctime,
        /* [in] */ const FILETIME __RPC_FAR *patime,
        /* [in] */ const FILETIME __RPC_FAR *pmtime) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE SetClass( 
        /* [in] */ REFCLSID clsid) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE SetStateBits( 
        /* [in] */ DWORD grfStateBits,
        /* [in] */ DWORD grfMask) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        /* [out] */ STATSTG __RPC_FAR *pstatstg,
        /* [in] */ DWORD grfStatFlag) = 0;

private:

    WCHAR *m_pwcsName;
};
    
inline IIT_IStorage::IIT_IStorage(CITUnknown *pBackObj, IUnknown *punkOuter, WCHAR *pwcsName)
    : CImpITUnknown(pBackObj, punkOuter)
{
    m_pwcsName = pwcsName;
}

inline BOOL IIT_IStorage::IsNamed(const WCHAR *pwszFileName)
{
    return !wcsicmp_0x0409(pwszFileName, m_pwcsName);
}

interface IIT_IStorageITEx : public IIT_IStorage
{
public:

    IIT_IStorageITEx(CITUnknown *pBackObj, IUnknown *punkOuter, WCHAR *pwcsName);

    virtual HRESULT STDMETHODCALLTYPE GetCheckSum(ULARGE_INTEGER *puli) = 0;
    virtual HRESULT STDMETHODCALLTYPE CreateStreamITEx
                (const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
                 DWORD grfMode, DWORD reserved1, DWORD reserved2, 
                 IStreamITEx ** ppstm
                ) = 0;
    virtual HRESULT STDMETHODCALLTYPE OpenStreamITEx
                (const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
                 DWORD reserved2, IStreamITEx ** ppstm) = 0;
};

inline IIT_IStorageITEx::IIT_IStorageITEx(CITUnknown *pBackObj, IUnknown *punkOuter, WCHAR *pwcsName)
    : IIT_IStorage(pBackObj, punkOuter, pwcsName)
{
}

#undef GetFreeSpace // To avoid a collision with the GetFreeSpace function below

interface IITFileSystem; // A forward declaration

interface IFreeList : public IPersistStreamInit
{
    virtual HRESULT STDMETHODCALLTYPE InitNew(IITFileSystem *pITFS, CULINT cbBias) = 0;
    virtual HRESULT STDMETHODCALLTYPE InitNew(IITFileSystem *pITFS, CULINT cbBias, UINT cEntriesMax) = 0;
    virtual HRESULT STDMETHODCALLTYPE InitLoad(IITFileSystem *pITFS) = 0;
    virtual HRESULT STDMETHODCALLTYPE LazyInitNew(IITFileSystem *pITFS) = 0;
    virtual HRESULT STDMETHODCALLTYPE RecordFreeList() = 0; 

    virtual HRESULT STDMETHODCALLTYPE PutFreeSpace(CULINT   ullBase, CULINT   ullCB) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetFreeSpace(CULINT *pullBase, CULINT *pullcb) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetFreeSpaceAt(CULINT ullBase, CULINT *pullcb) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetEndingFreeSpace
                          (CULINT *pullBase, CULINT *pullcb) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetStatistics
                          (CULINT *pcbLost, CULINT *pcbSpace) = 0;
	
};

DECLARE_INTERFACE_(IITFreeList, IITPersistStreamInit)
{
public:

    IITFreeList(CITUnknown *pBackObj, IUnknown *punkOuter);

    BEGIN_INTERFACE

    virtual HRESULT STDMETHODCALLTYPE InitNew(IITFileSystem *pITFS, CULINT cbBias) = 0;
    virtual HRESULT STDMETHODCALLTYPE InitNew(IITFileSystem *pITFS, CULINT cbBias, UINT cEntriesMax) = 0;
    virtual HRESULT STDMETHODCALLTYPE InitLoad(IITFileSystem *pITFS) = 0;
    virtual HRESULT STDMETHODCALLTYPE LazyInitNew(IITFileSystem *pITFS) = 0;
    virtual HRESULT STDMETHODCALLTYPE RecordFreeList() = 0; 

    virtual HRESULT STDMETHODCALLTYPE PutFreeSpace(CULINT   ullBase, CULINT   ullCB) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetFreeSpace(CULINT *pullBase, CULINT *pullcb) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetFreeSpaceAt(CULINT ullBase, CULINT *pullcb) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetEndingFreeSpace
                          (CULINT *pullBase, CULINT *pullcb) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetStatistics
                          (CULINT *pcbLost, CULINT *pcbSpace) = 0;

    virtual	HRESULT STDMETHODCALLTYPE SetFreeListEmpty() = 0;
	virtual	HRESULT STDMETHODCALLTYPE SetSpaceSize(ULARGE_INTEGER uliCbSpace) = 0;

	END_INTERFACE
};

typedef IITFreeList *PIFreeList;

inline IITFreeList::IITFreeList(CITUnknown *pBackObj, IUnknown *punkOuter)
                   :IITPersistStreamInit(pBackObj, punkOuter)
{

}

interface IEntryHandler : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE BindInstanceData(LCID lcidInstance, IStream *pStrmInstance) = 0;
    virtual HRESULT STDMETHODCALLTYPE SkipEncodedKey  (const BYTE **ppbEncodedKey) = 0;
    virtual HRESULT STDMETHODCALLTYPE SkipEncodedEntry(const BYTE **ppbEncodedRecord) = 0;
    virtual HRESULT STDMETHODCALLTYPE EncodeEntry(PVOID pvEntry, PBYTE pbEncodeBuffer,
                                                  UINT cbEncodeBuffer, PUINT pcbEncodedEntry
                                                 ) = 0;
    virtual HRESULT STDMETHODCALLTYPE DecodeEntry(PVOID pvEntry, const BYTE **ppbEncodedEntry) = 0;
    virtual HRESULT STDMETHODCALLTYPE ScanLeafSet(PVOID pvKey, const BYTE *pbStart, 
                                                               const BYTE *pbLimit,
                                                                     BYTE **pbEntry, 
                                                                     BYTE **pbEntryLimit
                                                 ) = 0;
    virtual HRESULT STDMETHODCALLTYPE ScanInternalSet(PVOID pvKey, const BYTE *pbStart, 
                                                                   const BYTE *pbLimit,
                                                                         BYTE **pbKey, 
                                                                         BYTE **pbKeyLimit
                                                     ) = 0;
};

interface IITEntryHandler : public CImpITUnknown
{
    IITEntryHandler(CITUnknown *pBackObj, IUnknown *punkOuter);
    
    virtual HRESULT STDMETHODCALLTYPE BindInstanceData(IStream *pStrmInstance) = 0;
    virtual HRESULT STDMETHODCALLTYPE SkipEncodedKey  (const BYTE **ppbEncodedKey) = 0;
    virtual HRESULT STDMETHODCALLTYPE SkipEncodedEntry(const BYTE **ppbEncodedRecord) = 0;
    virtual HRESULT STDMETHODCALLTYPE EncodeEntry(PVOID pvEntry, PBYTE pbEncodeBuffer,
                                                  UINT cbEncodeBuffer, PUINT pcbEncodedEntry
                                                 ) = 0;
    virtual HRESULT STDMETHODCALLTYPE DecodeEntry(PVOID pvEntry, const BYTE **ppbEncodedEntry);
    virtual HRESULT STDMETHODCALLTYPE ScanLeafSet(PVOID pvKey, const BYTE *pbStart, 
                                                               const BYTE *pbLimit,
                                                                     BYTE **pbEntry, 
                                                                     BYTE **pbEntryLimit
                                                 ) = 0;
    virtual HRESULT STDMETHODCALLTYPE ScanInternalSet(PVOID pvKey, const BYTE *pbStart, 
                                                                   const BYTE *pbLimit,
                                                                         BYTE **pbKey, 
                                                                         BYTE **pbKeyLimit
                                                     ) = 0;
};

inline IITEntryHandler::IITEntryHandler(CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}

interface IPathManger : public IPersist
{
public:

    virtual HRESULT STDMETHODCALLTYPE FlushToLockBytes() = 0;
    virtual HRESULT STDMETHODCALLTYPE FindEntry  (PPathInfo pSI   ) = 0;
    virtual HRESULT STDMETHODCALLTYPE CreateEntry(PPathInfo pSINew, 
                                                  PPathInfo pSIOld, 
                                                  BOOL fReplace     ) = 0;
    virtual HRESULT STDMETHODCALLTYPE DeleteEntry(PPathInfo pSI   ) = 0;
    virtual HRESULT STDMETHODCALLTYPE UpdateEntry(PPathInfo pSI   ) = 0;
	virtual HRESULT STDMETHODCALLTYPE EnumFromObject
            (IUnknown *punkOuter, const WCHAR *pwszPrefix, UINT cwcPrefix, 
			 REFIID riid, PVOID *ppv
			) = 0;
	};

interface IITPathManager : public IITPersist
{
public:

    IITPathManager(CITUnknown *pBackObj, IUnknown *punkOuter);

    virtual HRESULT STDMETHODCALLTYPE FlushToLockBytes() = 0;
    virtual HRESULT STDMETHODCALLTYPE FindEntry  (PPathInfo pSI   ) = 0;
    virtual HRESULT STDMETHODCALLTYPE CreateEntry(PPathInfo pSINew, 
                                                  PPathInfo pSIOld, 
                                                  BOOL fReplace     ) = 0;
    virtual HRESULT STDMETHODCALLTYPE DeleteEntry(PPathInfo pSI   ) = 0;
    virtual HRESULT STDMETHODCALLTYPE UpdateEntry(PPathInfo pSI   ) = 0;
	virtual HRESULT STDMETHODCALLTYPE EnumFromObject
            (IUnknown *punkOuter, const WCHAR *pwszPrefix, UINT cwcPrefix, 
			 REFIID riid, PVOID *ppv
			) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetPathDB(IStreamITEx *pTempPDBStrm, BOOL fCompact) = 0;
	virtual HRESULT STDMETHODCALLTYPE ForceClearDirty() = 0;
};

inline IITPathManager::IITPathManager(CITUnknown *pBackObj, IUnknown *punkOuter)
        : IITPersist(pBackObj, punkOuter) 
{ 
}

interface IITEnumSTATSTG : public CImpITUnknown
{
public:

    IITEnumSTATSTG(CITUnknown *pBackObj, IUnknown *punkOuter);

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
        /* [in] */ ULONG celt,
        /* [in] */ STATSTG __RPC_FAR *rgelt,
        /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Skip( 
        /* [in] */ ULONG celt) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum) = 0;

	
#if 1
	virtual	HRESULT	STDMETHODCALLTYPE GetNextEntryInSeq(/* [in] */ULONG celt,
					 /* [out] */ PathInfo *rgelt, 
					 /* [out] */ ULONG   *pceltFetched) = 0;
	virtual	HRESULT	STDMETHODCALLTYPE GetFirstEntryInSeq(
	 /* [out] */ PathInfo *rgelt) = 0;
#endif
};

inline IITEnumSTATSTG::IITEnumSTATSTG(CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}

class CImpITUnknown;

interface IITFileSystem : public CImpITUnknown
{
public:

    IITFileSystem(CITUnknown *pBackObj, IUnknown *punkOuter);

    // Interface methods

    virtual HRESULT __stdcall DeactivateSpace(UINT iSpace) = 0;

    virtual CITCriticalSection& CriticalSection() = 0;

    virtual HRESULT __stdcall FlushToLockBytes() = 0; 

    virtual HRESULT __stdcall CreateStorage  (IUnknown *pUnkOuter, const WCHAR *pwcsPathPrefix, 
                                              DWORD grfMode, IStorageITEx **ppStg) = 0;
    virtual HRESULT __stdcall   OpenStorage  (IUnknown *pUnkOuter, const WCHAR *pwcsPath, 
                                              DWORD grfMode, IStorageITEx **ppstg) = 0;  
    
    virtual HRESULT __stdcall CreateLockBytes(IUnknown *pUnkOuter, const WCHAR *pwcsPath,
                                              const WCHAR *pwcsDataSpaceName,
                                              BOOL fOverwrite, ILockBytes **ppLKB) = 0;

    virtual HRESULT __stdcall   OpenLockBytes(IUnknown *pUnkOuter, const WCHAR *pwcsPath, 
                                                                   ILockBytes **ppLKB) = 0;
    
    virtual HRESULT __stdcall CreateStream(IUnknown *pUnkOuter, const WCHAR *pwcsPath, 
                                           DWORD grfMode, IStreamITEx **ppStrm) = 0;

    virtual HRESULT __stdcall CreateStream
        (IUnknown *pUnkOuter, const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
         DWORD grfMode, IStreamITEx ** ppstm
        ) = 0;


    virtual HRESULT __stdcall   OpenStream(IUnknown *pUnkOuter, const WCHAR *pwcsPath, 
                                           DWORD grfMode, IStreamITEx **ppStream) = 0;

    virtual HRESULT __stdcall ConnectStorage(CImpITUnknown *pStg) = 0;

    virtual HRESULT __stdcall ConnectLockBytes(CImpITUnknown *pStg) = 0;
    
    virtual HRESULT __stdcall DeleteItem(WCHAR const *pwcsName) = 0;

    virtual HRESULT __stdcall RenameItem(WCHAR const *pwcsOldName, WCHAR const *pwcsNewName) = 0;

    virtual HRESULT __stdcall UpdatePathInfo(PathInfo *pPathInfo) = 0;

    virtual HRESULT __stdcall SetITFSTimes(FILETIME const * pctime, 
                                           FILETIME const * patime, 
                                           FILETIME const * pmtime
                                          ) = 0;

    virtual HRESULT __stdcall GetITFSTimes(FILETIME * pctime, 
                                           FILETIME * patime, 
                                           FILETIME * pmtime
                                          ) = 0;

    virtual HRESULT __stdcall ReallocEntry(PathInfo *pPathInfo, CULINT ullcbNew, 
                                           BOOL fCopyContent 
                                          ) = 0;

    virtual HRESULT __stdcall ReallocInPlace(PathInfo *pPathInfo, CULINT ullcbNew) = 0;


    virtual HRESULT __stdcall EnumeratePaths(WCHAR const *pwcsPathPrefix, 
                                             IEnumSTATSTG **ppEnumStatStg
                                            ) = 0;

    virtual HRESULT __stdcall IsWriteable() = 0;

    virtual HRESULT __stdcall FSObjectReleased() = 0;
	virtual BOOL __stdcall IsCompacting() = 0;

    virtual HRESULT __stdcall QueryFileStampAndLocale(DWORD *pFileStamp, 
                                                      DWORD *pFileLocale
                                                     ) = 0;
    virtual HRESULT __stdcall CountWrites() = 0;
};

inline IITFileSystem::IITFileSystem(CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}

// Need to fix the interface declarations below to reflect the
// revised design for managing transforms and data spaces.

/*
// {A55895FC-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IITTransformServices : public CImpITUnknown
{
public:

    IITTransformServices(CITUnknown *pBackObj, IUnknown *punkOuter);
    
    virtual HRESULT STDMETHODCALLTYPE PerTransformStorage
        (REFCLSID rclsidXForm, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetKeys
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
         PBYTE pbReadKey,  UINT cbReadKey, 
         PBYTE pbWriteKey, UINT cbWriteKey
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm) = 0;
};


inline IITTransformServices::IITTransformServices(CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}


/*
// {7C01FD0C-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransform, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */
interface IITTransformFactory : public CImpITUnknown
{
public:

    IITTransformFactory(CITUnknown *pBackObj, IUnknown *punkOuter);
    
    virtual HRESULT STDMETHODCALLTYPE DefaultControlData
        (XformControlData **ppXFCD) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance *pXFormMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) = 0;
};

inline IITTransformFactory::IITTransformFactory(CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}

interface IITTransformInstance : public CImpITUnknown
{
public:

    IITTransformInstance(CITUnknown *pBackObj, IUnknown *punkOuter);

	virtual HRESULT STDMETHODCALLTYPE ReadAt 
	                    (ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
						 ImageSpan *pSpan
                        ) = 0;

	virtual HRESULT STDMETHODCALLTYPE WriteAt
	                    (ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
						 ImageSpan *pSpan
                        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

	virtual HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize) = 0;

	// Note: SpaceSize returns the high water mark for the space. That is, the largest
	//       limit value (uliOffset + uliSize) for any transformed lockbytes created within
	//       the base (*pXLKB).
};

inline IITTransformInstance::IITTransformInstance(CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}

/*
// {7C01FD0E-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformedStream, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IITTransformedStream : public CImpITUnknown
{
public:

    IITTransformedStream(CITUnknown *pBackObj, IUnknown *punkOuter);
    
    virtual HRESULT STDMETHODCALLTYPE GetXFormInfo
        (PUINT pcbSyncInterval, PUINT pcXforms, PUINT pcdwXformControlData, 
         CLSID *paclsid, PXformControlData pxfcd, CLSID *pclsidCipher
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Import
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE Export
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE ImportSpace(IStorage *pStg) = 0;
};

inline IITTransformedStream::IITTransformedStream(CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}

/*
// {7C01FD0F-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IITTransformManager : public CImpITUnknown
{
public:

    IITTransformManager(CITUnknown *pBackObj, IUnknown *punkOuter);
    
    virtual HRESULT STDMETHODCALLTYPE CreateTransformedStream
        (const WCHAR *pwszTransformedStream, UINT cbSyncInterval, UINT cXforms,
         const CLSID *paclsidXform, PXformControlData pxfcd,
         REFCLSID rclsidCipher, 
         PBYTE pbEncipherKey, UINT cbEncipherKey,
         PBYTE pbDecipherKey, UINT cbDecipherKey,
         IITTransformedStream *pITCmpStrm
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenTransformedStream
        (const WCHAR *pwszTransformedStream, 
         PBYTE pbEncipherKey, UINT cbEncipherKey,
         PBYTE pbDecipherKey, UINT cbDecipherKey,
         IITTransformedStream *pITCmpStrm
        ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DiscardTransformedStream
        (const WCHAR *pwszTransformedStream) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumTransformedStreams
        (IEnumSTATSTG ** ppenum) = 0;
};

inline IITTransformManager::IITTransformManager(CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}

interface IOITnetProtocolRoot : public CImpITUnknown
{
public:
    IOITnetProtocolRoot(CITUnknown *pBackObj, IUnknown *punkOuter);
    
    virtual HRESULT STDMETHODCALLTYPE Start( 
        /* [in] */ LPCWSTR szUrl,
        /* [in] */ IOInetProtocolSink __RPC_FAR *pOIProtSink,
        /* [in] */ IOInetBindInfo __RPC_FAR *pOIBindInfo,
        /* [in] */ DWORD grfSTI,
        /* [in] */ DWORD dwReserved) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Continue( 
        /* [in] */ PROTOCOLDATA __RPC_FAR *pProtocolData) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Abort( 
        /* [in] */ HRESULT hrReason,
        /* [in] */ DWORD dwOptions) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Terminate( 
        /* [in] */ DWORD dwOptions) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
    
};

inline IOITnetProtocolRoot::IOITnetProtocolRoot
           (CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}

interface IOITnetProtocol : public IOITnetProtocolRoot
{
public:
    IOITnetProtocol(CITUnknown *pBackObj, IUnknown *punkOuter);

    virtual HRESULT STDMETHODCALLTYPE Read( 
        /* [length_is][size_is][out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Seek( 
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE LockRequest( 
        /* [in] */ DWORD dwOptions) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRequest( void) = 0;
    
};

inline IOITnetProtocol::IOITnetProtocol
           (CITUnknown *pBackObj, IUnknown *punkOuter)
        : IOITnetProtocolRoot(pBackObj, punkOuter) 
{ 
}

interface IOITnetProtocolInfo : public CImpITUnknown
{
public:
    IOITnetProtocolInfo(CITUnknown *pBackObj, IUnknown *punkOuter);

    virtual HRESULT STDMETHODCALLTYPE ParseUrl( 
        /* [in] */ LPCWSTR pwzUrl,
        /* [in] */ PARSEACTION ParseAction,
        /* [in] */ DWORD dwParseFlags,
        /* [out] */ LPWSTR pwzResult,
        /* [in] */ DWORD cchResult,
        /* [out] */ DWORD __RPC_FAR *pcchResult,
        /* [in] */ DWORD dwReserved) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE CombineUrl( 
        /* [in] */ LPCWSTR pwzBaseUrl,
        /* [in] */ LPCWSTR pwzRelativeUrl,
        /* [in] */ DWORD dwCombineFlags,
        /* [out] */ LPWSTR pwzResult,
        /* [in] */ DWORD cchResult,
        /* [out] */ DWORD __RPC_FAR *pcchResult,
        /* [in] */ DWORD dwReserved) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE CompareUrl( 
        /* [in] */ LPCWSTR pwzUrl1,
        /* [in] */ LPCWSTR pwzUrl2,
        /* [in] */ DWORD dwCompareFlags) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE QueryInfo( 
        /* [in] */ LPCWSTR pwzUrl,
        /* [in] */ QUERYOPTION OueryOption,
        /* [in] */ DWORD dwQueryFlags,
        /* [size_is][out][in] */ LPVOID pBuffer,
        /* [in] */ DWORD cbBuffer,
        /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
        /* [in] */ DWORD dwReserved) = 0;
    
};

inline IOITnetProtocolInfo::IOITnetProtocolInfo
           (CITUnknown *pBackObj, IUnknown *punkOuter)
        : CImpITUnknown(pBackObj, punkOuter) 
{ 
}


#endif // __ITIFACES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\itparse.h ===
// ITParse.h -- Class definition for CParser based on IParseDisplayName

#ifndef __ITPARSE_H__

#define __ITPARSE_H__

class CParser : public CITUnknown
{
public:
    
    // Creator:
    
    static HRESULT STDMETHODCALLTYPE Create(IUnknown *punkOuter, REFIID riid, PPVOID ppv);
    
    // Destructor:

    ~CParser(void);

private:

    // Constructor:

    CParser(IUnknown *punkOuter);
    
    class CImpIParser : public IITParseDisplayName
    {
    public:

        CImpIParser(CParser *pBackObj, IUnknown *punkOuter);
        ~CImpIParser(void);

        // Initialing method:

        STDMETHODIMP Init();

        HRESULT STDMETHODCALLTYPE ParseDisplayName( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG __RPC_FAR *pchEaten,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut);

    private:

    };

    CImpIParser   m_ImpIParser;
};

typedef CParser *PCParser;

inline CParser::CParser(IUnknown *pUnkOuter)
    : m_ImpIParser(this, pUnkOuter), 
      CITUnknown(&IID_IParseDisplayName, 1, &m_ImpIParser)
{

}

inline CParser::~CParser(void)
{
}

inline CParser::CImpIParser::CImpIParser(CParser *pBackObj, IUnknown *punkOuter)
    : IITParseDisplayName(pBackObj, punkOuter)
{
}

inline CParser::CImpIParser::~CImpIParser(void)
{
}

inline STDMETHODIMP CParser::CImpIParser::Init()
{
    return NO_ERROR;
}

#endif // __ITPARSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\itsfs.cpp ===
// ITSFS.CPP -- Implementation for the class CITFileSystem

#include "StdAfx.h"
//#include <stdio.h>

const WCHAR *pwscSpaceNameListStream = L"::DataSpace/NameList";
const WCHAR *pwcsSpaceNameStorage    = L"::DataSpace/Storage/";
const WCHAR *pwcsSpaceContentSuffix  = L"/Content";
const WCHAR *pwcsTransformListSuffix = L"/Transform/List";
const WCHAR *pwcsSpanInfoSuffix      = L"/SpanInfo";
const WCHAR *pwcsTransformSubStorage = L"/Transform/";
const WCHAR *pwcsControlDataSuffix   = L"/ControlData";
const WCHAR *pwcsInstanceSubStorage  = L"/InstanceData/";
const WCHAR *pwcsTransformStorage    = L"::Transform/";

const WCHAR *pwcsUncompressedSpace   = L"Uncompressed";
const WCHAR *pwcsLZXSpace            = L"MSCompressed";

// Creators:

HRESULT __stdcall CITFileSystem::CreateITFileSystem
                      (IUnknown *punkOuter, const WCHAR * pwcsName, DWORD grfMode,
                       PITS_Control_Data pControlData,
                       LCID lcid,
                       IStorage ** ppstgOpen
                      )
{
    CSyncWith sw(g_csITFS);

    ILockBytes *pLKB = NULL;
    
    HRESULT hr = CFSLockBytes::Create(NULL, pwcsName,
                                      (grfMode & (~SHARE_MASK) & (~RW_ACCESS_MASK))
                                         | STGM_READWRITE 
                                         | STGM_CREATE
                                         | STGM_SHARE_EXCLUSIVE,
                                      &pLKB
                                     );

    if (SUCCEEDED(hr)) 
    {
        hr = CreateITFSOnLockBytes(punkOuter, pLKB, grfMode, pControlData, lcid, ppstgOpen);

        pLKB->Release(); // if the Create on LockBytes succeeded, it AddRef'd pLKB.
    }

    return hr;
}


HRESULT __stdcall CITFileSystem::CreateITFSOnLockBytes
                      (IUnknown *punkOuter, ILockBytes * pLKB, DWORD grfMode,
                       PITS_Control_Data pControlData,
                       LCID lcid,
                       IStorage **ppstgOpen
                      )
{
    CSyncWith sw(g_csITFS);

    CITFileSystem *pITFS = New CITFileSystem(punkOuter);

    if (!pITFS)
    {
        pLKB->Release();

        return STG_E_INSUFFICIENTMEMORY;
    }

    IITFileSystem *pIITFileSystem = NULL;
    IStorageITEx  *pStorage       = NULL;

    pITFS->AddRef(); // Because of the reference counting tricks
                     // within InitCreateOnLockBytes.

    HRESULT hr = pITFS->m_ImpITFileSystem.InitCreateOnLockBytes
                     (pLKB, grfMode, pControlData, lcid);

    if (SUCCEEDED(hr))
    {
        pIITFileSystem = (IITFileSystem *) &pITFS->m_ImpITFileSystem;

        // If the OpenStorage call below succeeds, it will AddRef pITFS.

        hr = pIITFileSystem->OpenStorage(NULL, L"/", grfMode, &pStorage);

        pITFS->Release(); // To match the AddRef call above.
    }
    else delete pITFS;

    *ppstgOpen = pStorage;

    return hr;
}

IITFileSystem *CITFileSystem::CImpITFileSystem::FindFileSystem(const WCHAR *pwcsPath)
{
    CSyncWith sw(g_csITFS);

    CImpITFileSystem *pITFS = (CImpITFileSystem *) g_pImpITFileSystemList;

    for (; pITFS; pITFS = (CImpITFileSystem *) pITFS->NextObject())
        if (!wcsicmp_0x0409(pwcsPath, pITFS->m_awszFileName))
        {
            pITFS->AddRef();

            return pITFS;
        }

    return NULL;
}


HRESULT __stdcall CITFileSystem::IsITFile(const WCHAR * pwcsName)
{
    CSyncWith sw(g_csITFS);
    
    IITFileSystem *pITFS = CImpITFileSystem::FindFileSystem(pwcsName);

    if (pITFS)
    {
        pITFS->Release();

        return S_OK;
    }

    ILockBytes   *pLKB = NULL;
    ITSFileHeader ITFH;

    HRESULT hr = CFSLockBytes::Open(NULL, pwcsName, STGM_READ | STGM_SHARE_DENY_NONE, &pLKB);
    
    if (SUCCEEDED(hr))
         hr = IsITLockBytes(pLKB); 
    else hr = S_FALSE;

    if (pLKB)
        pLKB->Release();

    return hr;
}
  

HRESULT __stdcall CITFileSystem::IsITLockBytes(ILockBytes * pLKB)
{
    CSyncWith sw(g_csITFS);

    ITSFileHeader ITFH;
    ULONG         cbRead = 0;

    HRESULT hr = pLKB->ReadAt(CULINT(0).Uli(), &ITFH, sizeof(ITFH), &cbRead);
    
    if (   hr != S_OK   
        || cbRead < sizeof(ITSFileHeaderV2)
        || ITFH.uMagic != MAGIC_ITS_FILE
        || ITFH.uFormatVersion < FirstReleasedVersion
        || ITFH.uFormatVersion > CurrentFileFormatVersion
       )
        hr = S_FALSE;
    else
        if (   ITFH.uFormatVersion == CurrentFileFormatVersion
            && cbRead == sizeof(ITSFileHeader)
           )
            hr = S_OK;
        else 
            if (ITFH.uFormatVersion == FirstReleasedVersion)
            {
                ITFH.offPathMgrOrigin = 0;
                hr = S_OK;
            }
            else
            {
                RonM_ASSERT(FALSE); // If this assert fires, we have a old version 
                                    // that isn't being handled.
                hr = S_FALSE;
            }

    return hr;
}

HRESULT __stdcall CITFileSystem::QueryFileStampAndLocale
    (const WCHAR *pwcsName, DWORD *pFileStamp, DWORD *pFileLocale)
{
    CSyncWith sw(g_csITFS);
    
    IITFileSystem *pITFS = CImpITFileSystem::FindFileSystem(pwcsName);

    if (pITFS)
    {
        HRESULT hr = pITFS->QueryFileStampAndLocale(pFileStamp, pFileLocale);

        pITFS->Release();

        return hr;
    }

    ILockBytes   *pLKB = NULL;
    ITSFileHeader ITFH;

    HRESULT hr = CFSLockBytes::Open(NULL, pwcsName, STGM_READ | STGM_SHARE_DENY_NONE, &pLKB);
    
    if (SUCCEEDED(hr))
    {
        hr = QueryLockByteStampAndLocale(pLKB, pFileStamp, pFileLocale);

        pLKB->Release();
    }

    return hr;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::QueryFileStampAndLocale
    (DWORD *pFileStamp, DWORD *pFileLocale)
{
    if (pFileStamp)
       *pFileStamp  = m_itfsh.dwStamp;
    if (pFileLocale)
       *pFileLocale = m_itfsh.lcid;

    return S_OK;    
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::CountWrites()
{
    InterlockedIncrement((long *) &m_itfsh.dwStamp);

    return S_OK;
}

HRESULT __stdcall CITFileSystem::QueryLockByteStampAndLocale
    (ILockBytes * plkbyt, DWORD *pFileStamp, DWORD *pFileLocale)
{
    CSyncWith sw(g_csITFS);

    ITSFileHeader ITFH;
    ULONG         cbRead = 0;

    HRESULT hr = plkbyt->ReadAt(CULINT(0).Uli(), &ITFH, sizeof(ITFH), &cbRead);

    if (!SUCCEEDED(hr))
        return hr;

    if (   cbRead < sizeof(ITSFileHeaderV2)
        || ITFH.uMagic != MAGIC_ITS_FILE
        || ITFH.uFormatVersion < FirstReleasedVersion
        || ITFH.uFormatVersion > CurrentFileFormatVersion
       )
        return STG_E_INVALIDHEADER;
    else
        if (   ITFH.uFormatVersion == CurrentFileFormatVersion
            && cbRead == sizeof(ITSFileHeader)
           )
        {
        }
        else 
            if (ITFH.uFormatVersion == FirstReleasedVersion)
            {
            }
            else
            {
                RonM_ASSERT(FALSE); // If this assert fires, we have a old version 
                                    // that isn't being handled.
                return STG_E_INVALIDHEADER;
            }

    if (pFileStamp)
       *pFileStamp  = ITFH.dwStamp;
    if (pFileLocale)
       *pFileLocale = ITFH.lcid;

    return S_OK;
}

HRESULT __stdcall CITFileSystem::OpenITFileSystem(IUnknown *punkOuter, 
                                                  const WCHAR * pwcsName, 
                                                  DWORD grfMode,
                                                  IStorageITEx ** ppstgOpen
                                                 )
{
    HRESULT   hr;
    IStorage *pStorage = NULL;
    
    CSyncWith sw(g_csITFS);

    IITFileSystem *pIITFS = CImpITFileSystem::FindFileSystem(pwcsName);

    if (pIITFS)
    {
		if (!pIITFS->IsCompacting())
		{
			hr = pIITFS->OpenStorage(punkOuter, L"/", grfMode, ppstgOpen);
		}
		else
		{
			hr = E_FAIL;
		}

        pIITFS->Release();

        return hr;
    }

    ILockBytes *pLKB = NULL;
    
    hr = CFSLockBytes::Open(NULL, pwcsName, grfMode, &pLKB);

    if (SUCCEEDED(hr))
    {    
        hr = OpenITFSOnLockBytes(punkOuter, pLKB, grfMode, ppstgOpen);

        pLKB->Release(); // If OpenITFSOnLockBytes succeeds, it will AddRef pLKB.
    }

    return hr;
}


HRESULT __stdcall CITFileSystem::OpenITFSOnLockBytes
                      (IUnknown *punkOuter, ILockBytes * plkbyt, DWORD grfMode,
                       IStorageITEx ** ppstgOpen
                      )
{
    CSyncWith sw(g_csITFS);

    CITFileSystem *pITFS = New CITFileSystem(punkOuter);

    if (!pITFS) return STG_E_INSUFFICIENTMEMORY;

    IStorage *pStorage = NULL;

    pITFS->AddRef(); // Because of the reference counting tricks
                     // within InitCreateOnLockBytes.

    HRESULT hr = pITFS->m_ImpITFileSystem.InitOpenOnLockBytes(plkbyt, grfMode);

    if (SUCCEEDED(hr))
    {
        // If the OpenStorage call below succeeds, it will AddRef pITFS.
        
        hr = pITFS->m_ImpITFileSystem.OpenStorage(NULL, L"/", grfMode, ppstgOpen);
        
        pITFS->Release(); // To match the AddRef above
    }
    else delete pITFS;

    return hr;
}

HRESULT __stdcall CITFileSystem::SetITFSTimes
                      (WCHAR const * pwcsName,  FILETIME const * pctime, 
                       FILETIME const * patime, FILETIME const * pmtime
                      )
{
    CSyncWith sw(g_csITFS);
    
    IITFileSystem *pITFS = CImpITFileSystem::FindFileSystem(pwcsName);

    if (pITFS)
    {
        HRESULT hr = pITFS->SetITFSTimes(pctime, patime, pmtime);
        
        pITFS->Release();

        return S_OK;
    } 

    ILockBytes *pLKB = NULL;

    HRESULT hr = CFSLockBytes::Open(NULL, pwcsName, STGM_READ, &pLKB);
    
    if (SUCCEEDED(hr))
        if (S_OK == IsITLockBytes(pLKB))
            hr = ((CFSLockBytes::CImpILockBytes *)pLKB)->SetTimes(pctime, patime, pmtime);
        else hr = STG_E_FILENOTFOUND;

    if (pLKB)
        pLKB->Release();

    return hr;
}

HRESULT __stdcall CITFileSystem::DefaultControlData(PITS_Control_Data *ppControlData)
{
    *ppControlData = NULL;
	
	PITSFS_Control_Data pCD = PITSFS_Control_Data(OLEHeap()->Alloc(sizeof(ITSFS_Control_Data)));

	if (!pCD) return STG_E_INSUFFICIENTMEMORY;

	pCD->cdwFollowing     = 6;
	pCD->cdwITFS_Control  = 5;
	pCD->dwMagic          = MAGIC_ITSFS_CONTROL;
	pCD->dwVersion        = 1;
	pCD->cbDirectoryBlock = 8192;
	pCD->cMinCacheEntries = 20;
	pCD->fFlags           = fDefaultIsCompression;

	*ppControlData = PITS_Control_Data(pCD);

	return NO_ERROR;
}

// Constructor:

CITFileSystem::CImpITFileSystem::CImpITFileSystem
               (CITFileSystem *pITFileSystem, IUnknown *punkOuter)
             : IITFileSystem(pITFileSystem, punkOuter)

{
    ZeroMemory(&m_itfsh, sizeof(m_itfsh));

    m_itfsh.cbHeaderSize  = sizeof(m_itfsh);
    m_itfsh.clsidFreeList = CLSID_NULL;
    m_itfsh.clsidPathMgr  = CLSID_NULL;

    m_pLKBMedium              = NULL;
    m_pPathManager            = NULL;
    m_pSysPathManager         = NULL;
    m_pFreeListManager        = NULL;
    m_pTransformServices      = NULL;
    m_pActiveStorageList      = NULL;
    m_pActiveLockBytesList    = NULL;
    m_fHeaderIsDirty          = FALSE;
    m_fInitialed              = FALSE;
    m_fReadOnly               = FALSE;
    m_pwscDataSpaceNames      = NULL;
    m_papTransformDescriptors = NULL;
    m_pStrmSpaceNames         = NULL;
    m_cFSObjectRefs           = 0;
    m_cwcFileName             = 0;
    m_awszFileName[0]         = 0;
}


// Destructor:

CITFileSystem::CImpITFileSystem::~CImpITFileSystem(void)
{
    // The code below is necessary to balance calls we've made to this->Release()
    // to hide circular references. The current set of circular references are:
    //
    // **  The free list Stream
    // **  The path manager LockBytes
    // **  The transform services object
    // **  Each storage whose name begins with ":"
    // **  Each stream whose name begins with ":"
    // **  Each active data space

    RonM_ASSERT(m_cFSObjectRefs != UINT(~0));

    if (!~m_cFSObjectRefs) return;

#ifdef _DEBUG
    LONG cRefs = 
#endif // _DEBUG
        AddRef(); // To avoid recursive destruction when we eliminate the last
                  // circular reference to this file system.

    RonM_ASSERT(cRefs == 1);
        
    for (; m_cFSObjectRefs--;) // Accounting for the hidden circular references.
        this->AddRef(); 

//    RonM_ASSERT(!m_pActiveStorageList);
//    RonM_ASSERT(!m_pActiveLockBytesList);

    DEBUGDEF(HRESULT hr)
    DEBUGDEF(ULONG    c);

    if (m_papTransformDescriptors)
    {
        RonM_ASSERT(m_pStrmSpaceNames);
        RonM_ASSERT(m_pwscDataSpaceNames);
        
        UINT cSpaces = m_pwscDataSpaceNames[1];

        for (UINT iSpace = 0; iSpace < cSpaces; iSpace++)
            if (m_papTransformDescriptors[iSpace])
                DeactivateDataSpace(iSpace);

        delete [] m_papTransformDescriptors;
    }

    if (m_pwscDataSpaceNames)
        delete [] m_pwscDataSpaceNames;

    if (m_pStrmSpaceNames)
        m_pStrmSpaceNames->Release();

    if (m_fInitialed)
    {
        RonM_ASSERT(m_pLKBMedium);
        RonM_ASSERT(m_pPathManager);
        RonM_ASSERT(m_pFreeListManager);
        RonM_ASSERT(m_pTransformServices);

#ifdef _DEBUG
        hr =
#endif // _DEBUG            
        m_pPathManager->FlushToLockBytes(); 

        RonM_ASSERT(SUCCEEDED(hr));

#ifdef _DEBUG
        hr =
#endif // _DEBUG            
        FlushToLockBytes(); 

        RonM_ASSERT(SUCCEEDED(hr));
    }

    if (m_pTransformServices)
        m_pTransformServices->Release();

    if (m_pFreeListManager)
    {
#ifdef _DEBUG
        c =
#endif // _DEBUG            
        m_pFreeListManager->Release();

        RonM_ASSERT(!c);
    }

    if (m_pPathManager)
    {
#ifdef _DEBUG
        c =
#endif // _DEBUG            
        m_pPathManager->Release();

        RonM_ASSERT(!c);
    }

    if (m_pSysPathManager)
    {
#ifdef _DEBUG
        c =
#endif // _DEBUG            
        m_pSysPathManager->Release();

        RonM_ASSERT(!c);
    }

    if (m_pLKBMedium)
        m_pLKBMedium->Release();
}

IStorageITEx   *CITFileSystem::CImpITFileSystem::FindActiveStorage  (const WCHAR *pwcsPath)
{
    for (CImpITUnknown *pStg = m_pActiveStorageList;
         pStg;
         pStg = pStg->NextObject()
        )
        if (((IIT_IStorageITEx *)pStg)->IsNamed(pwcsPath))
        {
             pStg->AddRef();

             return (IStorageITEx *) pStg;
        }
        
    return NULL;     
}

ILockBytes *CITFileSystem::CImpITFileSystem::FindActiveLockBytes(const WCHAR *pwcsPath)
{
    return ::FindMatchingLockBytes(pwcsPath, (CImpITUnknown *) m_pActiveLockBytesList);
}

// Initialers:

HRESULT __stdcall CITFileSystem::CImpITFileSystem::InitCreateOnLockBytes
    (ILockBytes * plkbyt, DWORD grfMode, PITS_Control_Data pControlData, LCID lcid)
{
    // First we bind to the lockbyte object passed to us.
    // If this call fails, the containing create function will delete this
    // object instance, and that will cause the lockbyte object to be released.
    
    if (!plkbyt)
        return STG_E_INVALIDPOINTER;

    ITSFS_Control_Data *pITCD = (ITSFS_Control_Data *) pControlData;

    if (!pITCD)
    {
        // We use _alloca here because it allocates memory on the stack,
        // and those allocations automatically get cleaned up when we 
        // exit this function. So no explicit deallocation is necessary.
        // That's important given that sometimes we have control data
        // passed in to us, and sometimes we create it dynamically.
        
        pITCD = PITSFS_Control_Data(_alloca(sizeof(ITSFS_Control_Data)));

        if (!pITCD) 
            return STG_E_INSUFFICIENTMEMORY;

        pITCD->cdwFollowing     = 6;
        pITCD->cdwITFS_Control  = 5;
        pITCD->dwMagic          = MAGIC_ITSFS_CONTROL;
        pITCD->dwVersion        = ITSFS_CONTROL_VERSION;
        pITCD->cbDirectoryBlock = DEFAULT_DIR_BLOCK_SIZE;
        pITCD->cMinCacheEntries = DEFAULT_MIN_CACHE_ENTRIES;
        pITCD->fFlags           = fDefaultIsCompression;
    }
    else
        if (pITCD->cdwFollowing < 6 || pITCD->cdwITFS_Control < 5 
                                    || pITCD->dwMagic   != MAGIC_ITSFS_CONTROL 
                                    || pITCD->dwVersion != ITSFS_CONTROL_VERSION
           )
            return STG_E_INVALIDPARAMETER;

    m_pLKBMedium = plkbyt;

    m_pLKBMedium->AddRef();

    // We pick up the name of the file which contains this file system from 
    // the LockBytes object.
    
    STATSTG statstg;

    ZeroMemory(&statstg, sizeof(statstg));

    HRESULT hr = plkbyt->Stat(&statstg, STATFLAG_DEFAULT);

    RonM_ASSERT(hr == S_OK);

    if (hr != S_OK)
        return hr;

    // Now we must set initial values for the header structure.
    // This structure will be stored at offset zero in m_pLKBMedium.

    m_itfsh.uMagic           = MAGIC_ITS_FILE;
    m_itfsh.cbHeaderSize     = sizeof(ITSFileHeader);
    m_itfsh.uFormatVersion   = CurrentFileFormatVersion;
    m_itfsh.fFlags           = pITCD->fFlags & fDefaultIsCompression;
    m_itfsh.dwStamp          = m_StartingFileStamp = statstg.mtime.dwLowDateTime;
    m_itfsh.lcid             = lcid;
    m_itfsh.offFreeListData  = 0;
    m_itfsh.cbFreeListData   = 0;
    m_itfsh.offPathMgrData   = 0;
    m_itfsh.cbPathMgrData    = 0;
    m_itfsh.offPathMgrOrigin = 0;

    m_cwcFileName = wcsLen(statstg.pwcsName);

    if (m_cwcFileName >= MAX_PATH) // Note that an empty name is valid.
    {
        OLEHeap()->Free(statstg.pwcsName);
        return STG_E_INVALIDNAME;
    }

    CopyMemory(m_awszFileName, statstg.pwcsName, (m_cwcFileName + 1) * sizeof(WCHAR));

    m_fHeaderIsDirty = TRUE;

    OLEHeap()->Free(statstg.pwcsName);

    // At this point we haven't created a Path Manager for this file system.
    // The Path Manager is the mechanism we used to keep track of the items 
    // in the file system. However when we create the Path Manager, we must
    // record its location in the file system header instead. To keep the 
    // program logic clean we're going to create a special variation on the
    // Path Manager interface called SysPathManager. The SysPathManager
    // object uses the file system header to keep track of two objects --
    // the Path Manager and the Free List Manager.

    hr = CSystemPathManager::Create(NULL, this, &m_pSysPathManager);
    
    RonM_ASSERT(SUCCEEDED(hr));

    if (!SUCCEEDED(hr)) 
        return hr;

    // SysPathManager works exactly like the PathManager object except
    // that it recognizes only the names L"F" and L"P", respectively,
    // to denote the Free List object and the Path Database object. 

    // Now we must create a FreeList manager for this file system.

    hr = CFreeList::CreateFreeList(this,  m_itfsh.cbHeaderSize, &m_pFreeListManager);

    RonM_ASSERT(SUCCEEDED(hr));

    if (!SUCCEEDED(hr)) 
        return hr;

    // Since we want to support multiple free list managers in the future,
    // we record the class id of the current free list manager in the 
    // header for the file system. Then when we open this file system
    // sometime later, we can be assured of connecting it to the correct
    // free list manager implementation.

    hr = m_pFreeListManager->GetClassID(&m_itfsh.clsidFreeList);

    RonM_ASSERT(SUCCEEDED(hr));

    if (!SUCCEEDED(hr)) 
        return hr;

   ILockBytes *pLKB_PathDataBase = NULL;

    hr = OpenLockBytes(NULL, L"P", &pLKB_PathDataBase);

    RonM_ASSERT(SUCCEEDED(hr));

    if (!SUCCEEDED(hr)) 
        return hr;

    // The call to NewPathDatabase will either bind pLKB_PathDataBase to the new
    // Path Manager, or Release it if it fails.

    hr = CPathManager1::NewPathDatabase(NULL, pLKB_PathDataBase,
                                        pITCD->cbDirectoryBlock,
                                        pITCD->cMinCacheEntries,
                                        &m_pPathManager
                                       );

    RonM_ASSERT(SUCCEEDED(hr));

    if (!SUCCEEDED(hr)) 
        return hr;

    hr = m_pPathManager->GetClassID(&m_itfsh.clsidPathMgr);

    if (!SUCCEEDED(hr)) 
        return hr;

    m_fInitialed = TRUE;

    PathInfo PI;

    ZeroMemory(&PI, sizeof(PI));

    wcsCpy(PI.awszStreamPath, L"/");
    
    PI.cwcStreamPath = 1;
    PI.clsidStorage  = CLSID_NULL;

    MarkActive(g_pImpITFileSystemList);

    hr = m_pPathManager->CreateEntry(&PI, NULL, FALSE);

    RonM_ASSERT(SUCCEEDED(hr));

    if (!SUCCEEDED(hr)) 
        return hr;

    wcsCpy(PI.awszStreamPath, pwcsSpaceNameStorage);
    wcsCat(PI.awszStreamPath, pwcsLZXSpace);
    wcsCat(PI.awszStreamPath, pwcsSpaceContentSuffix);

    ILockBytes *pLKBDefault = NULL;

    hr = CreateLockBytes(NULL, (const WCHAR *)PI.awszStreamPath, pwcsUncompressedSpace, 
                         FALSE, &pLKBDefault
                        );
    
    if (!SUCCEEDED(hr))
        return hr;

    pLKBDefault->Release();  pLKBDefault = NULL;

    hr = CreateSpaceNameList();

    if (!SUCCEEDED(hr))
        return hr;

    hr = CreateDefaultDataSpace(pITCD);

    if (!SUCCEEDED(hr))
        return hr;

    hr = CTransformServices::Create(NULL, this, &m_pTransformServices);

    if (hr == S_OK)
    {
        Release(); // To compensate for the circular ref from FreeList Stream
        Release(); // To compensate for the circular ref from m_pTransformServices

        m_cFSObjectRefs += 2;

        // Note: The destructor for the file system will do m_cFSObjectRefs AddRef 
        //       calls to compensate for these Release calls. We do the release calls
        //       here so that the file system won't be kept alive forever by its 
        //       circular references.
    }

    hr = ActivateDataSpace(1); // To flush out any errors in the control data
                               // we've created for the default LZX data space.    
    Container()->MoveInFrontOf(NULL); 
    
    // BugBug: This put the current object list in clean order
    //         for deallocation at process detach time. However
    //         we'll need further adjustments as we add more
    //         data spaces.

    return hr;
}

HRESULT CITFileSystem::CImpITFileSystem::CreateDefaultDataSpace(PITSFS_Control_Data pITCD)
{
    XformControlData  *pXFCD = NULL;

    if (pITCD->cdwFollowing > pITCD->cdwITFS_Control + 1)
    {
        // We have some trailing data. Let's assume that it's
        // control data for the LZX transform.

        pXFCD = PXformControlData(pITCD + 1);
    }
    else
    {
        // We don't have any LZX control data in *pITCD. So we
        // must get default control data from the transform 
        // factory.

        XformControlData  *pCD  = NULL;
        ITransformFactory *pXFF = NULL;

        HRESULT hr = CLZX_TransformFactory::Create(NULL, IID_ITransformFactory, (void **)&pXFF);

        if (!SUCCEEDED(hr)) 
            return hr;

        hr = pXFF->DefaultControlData(&pCD);

        pXFF->Release();

        if (!SUCCEEDED(hr))
            return hr;

        // Now that we've got the default control data, we must
        // copy into a local stack buffer. The use of _alloca means
        // that we do not have to explicitly deallocate pXFCD. That's
        // important given that sometimes the control data will be 
        // passed in as part of *pITCD and sometimes it will be 
        // created dynamically.

        UINT cbData = sizeof(DWORD) * (1 + pCD->cdwControlData);

        pXFCD = PXformControlData(_alloca(cbData));

        if (!pXFCD)
        {
            OLEHeap()->Free(pCD);

            return STG_E_INSUFFICIENTMEMORY;
        }

        CopyMemory(pXFCD, pCD, cbData);

        OLEHeap()->Free(pCD);
    }

    WCHAR awcsPath[MAX_PATH];

    wcsCpy(awcsPath, pwcsSpaceNameStorage);
    wcsCat(awcsPath, pwcsLZXSpace);

    UINT cbPrefix = wcsLen(awcsPath);

    wcsCat(awcsPath, pwcsTransformListSuffix);

    IStream *pStrm     = NULL;
    ULONG    cbWritten = 0;

    WCHAR awcsClassID[CWC_GUID_STRING_BUFFER];

    UINT cbResult = StringFromGUID2(CLSID_LZX_Transform, awcsClassID, CWC_GUID_STRING_BUFFER); 

    if (cbResult == 0)
        return STG_E_UNKNOWN;

    HRESULT hr = WriteToStream((const WCHAR *) awcsPath, awcsClassID, wcsLen(awcsClassID));

    if (hr == S_OK)
    {
        awcsPath[cbPrefix] = 0;

        wcsCat(awcsPath, pwcsSpanInfoSuffix);

        ULARGE_INTEGER uli;

        uli.LowPart  = 0;
        uli.HighPart = 0;
        
        hr = WriteToStream((const WCHAR *) awcsPath, &uli, sizeof(uli));
    }

    if (hr == S_OK)
    {   
        awcsPath[cbPrefix] = 0;

        wcsCat(awcsPath, pwcsControlDataSuffix); 

        hr = WriteToStream((const WCHAR *) awcsPath, pXFCD, 
                           sizeof(XformControlData) + sizeof(DWORD) * pXFCD->cdwControlData
                          );
    }

    return hr;
}

HRESULT CITFileSystem::CImpITFileSystem::WriteToStream
            (const WCHAR *pwcsStreamPath, PVOID pvData, ULONG cbData)
{
    IStreamITEx *pStrm = NULL;

    HRESULT hr = CreateStream(NULL, pwcsStreamPath, STGM_READWRITE, &pStrm);

    if (hr != S_OK) 
        return hr;

    ULONG cbWritten = 0;

    hr = pStrm->Write(pvData, cbData, &cbWritten);

    pStrm->Release();  pStrm = FALSE;

    if (hr == S_FALSE || cbWritten != cbData)
        hr = STG_E_WRITEFAULT;

    return hr;
}

HRESULT CITFileSystem::CImpITFileSystem::CreateSpaceNameList()
{

    USHORT cwcUncompressedSpace = (USHORT) wcsLen(pwcsUncompressedSpace);
    USHORT cwcDefaultSpace      = (USHORT) wcsLen(pwcsLZXSpace);

    RonM_ASSERT(sizeof(USHORT) == 2 && sizeof(WCHAR) == 2);

    USHORT cwcNameListSize = cwcUncompressedSpace + cwcDefaultSpace + 6;

    m_pwscDataSpaceNames      = New WCHAR[cwcNameListSize];
    m_papTransformDescriptors = New PTransformDescriptor[2];

    if (m_papTransformDescriptors)
    {
        m_papTransformDescriptors[0] = NULL; // To make the destructor code
        m_papTransformDescriptors[1] = NULL; // operate correctly.
    }

    if (!m_pwscDataSpaceNames || !m_papTransformDescriptors)
        return STG_E_INSUFFICIENTMEMORY;

    /* 
    
    The m_pwscDataSpaceNames array has a prefix consisting of:

        USHORT cwcTotal;    -- Total length of *m_pwscDataSpaceNames
        USHORT cDataSpaces; -- Number of names in *m_pwscDataSpaceNames

    Then each name has this format:

        USHORT cwcDataSpaceName;  
        WCHAR  awcDataSpaceName[cwcDataSpaceName];
        WCHAR  wcNULL == NULL;

    The position of a name in the sequence determines its ordinal value.

     */
        
    m_pwscDataSpaceNames[0] = cwcNameListSize;
    m_pwscDataSpaceNames[1] = 2;
    m_pwscDataSpaceNames[2] = cwcUncompressedSpace;
    m_pwscDataSpaceNames[3 + cwcUncompressedSpace] = 0;
    m_pwscDataSpaceNames[4 + cwcUncompressedSpace] = cwcDefaultSpace;
    m_pwscDataSpaceNames[5 + cwcUncompressedSpace + cwcDefaultSpace] = 0;

    CopyMemory(m_pwscDataSpaceNames + 3, pwcsUncompressedSpace, cwcUncompressedSpace * sizeof(WCHAR));

    CopyMemory(m_pwscDataSpaceNames + cwcUncompressedSpace + 5, 
               pwcsLZXSpace, cwcDefaultSpace * sizeof(WCHAR)
              );

    HRESULT hr = CreateStream(NULL, pwscSpaceNameListStream, STGM_READWRITE, &m_pStrmSpaceNames);
                      
    if (!SUCCEEDED(hr)) 
        return hr;
    
    return FlushSpaceNameList();
}

HRESULT CITFileSystem::CImpITFileSystem::FlushSpaceNameList()
{
    ULONG cb        = m_pwscDataSpaceNames[0] * sizeof(WCHAR);
    ULONG cbWritten = 0;

    HRESULT hr = m_pStrmSpaceNames->Write(m_pwscDataSpaceNames, cb, &cbWritten); 

    if (!SUCCEEDED(hr)) 
        return hr;

    if (cbWritten != cb)
        return STG_E_WRITEFAULT;

    return NO_ERROR;
}

HRESULT CITFileSystem::CImpITFileSystem::OpenSpaceNameList()
{
    HRESULT hr = OpenStream(NULL, pwscSpaceNameListStream, STGM_READWRITE, &m_pStrmSpaceNames);
                      
    if (!SUCCEEDED(hr)) 
        return hr;
    
    USHORT cwc;
    
    ULONG cbRead;
    ULONG cb = sizeof(cwc);

    RonM_ASSERT(sizeof(USHORT) == sizeof(WCHAR));

    hr= m_pStrmSpaceNames->Read(&cwc, cb, &cbRead);

    if (!SUCCEEDED(hr)) 
        return hr;
    
    if (cbRead != cb)
        return STG_E_READFAULT;

    m_pwscDataSpaceNames = New WCHAR[cwc];

    m_pwscDataSpaceNames[0] = cwc;

    cb = sizeof(WCHAR) * (cwc - 1);

    hr = m_pStrmSpaceNames->Read(m_pwscDataSpaceNames + 1, cb, &cbRead);

    if (!SUCCEEDED(hr)) 
        return hr;
    
    if (cbRead != cb)
        return STG_E_READFAULT;

    m_papTransformDescriptors = New PTransformDescriptor[m_pwscDataSpaceNames[1]];

    if (!m_papTransformDescriptors)
        return STG_E_INSUFFICIENTMEMORY;

    ZeroMemory(m_papTransformDescriptors, sizeof(PTransformDescriptor) * m_pwscDataSpaceNames[1]);

    return NO_ERROR;
}

HRESULT CITFileSystem::CImpITFileSystem::FindSpaceName(const WCHAR *pwcsSpaceName)
{
    RonM_ASSERT(m_pwscDataSpaceNames);

    DEBUGDEF(const WCHAR *pwcLimit = m_pwscDataSpaceNames + m_pwscDataSpaceNames[0])

    const WCHAR *pwcNext = m_pwscDataSpaceNames + 2;

    USHORT cSpaces = m_pwscDataSpaceNames[1];
    USHORT iSpace  = 0;

    for (; iSpace < cSpaces; iSpace++)
    {
        RonM_ASSERT(pwcNext < pwcLimit);
        
        USHORT cwc = *pwcNext++;

        RonM_ASSERT(pwcNext < pwcLimit);

        if (!wcsicmp_0x0409(pwcNext, pwcsSpaceName))
            return iSpace;

        pwcNext += cwc + 1;
        
        RonM_ASSERT(pwcNext <= pwcLimit);
    }
    
    return STG_E_INVALIDNAME;
}

HRESULT CITFileSystem::CImpITFileSystem::AddSpaceName(const WCHAR *pwcsSpaceName)
{
    if (!CStorage::ValidStreamName(pwcsSpaceName))
        return STG_E_INVALIDNAME;
    
    HRESULT hr = FindSpaceName(pwcsSpaceName);

    if (SUCCEEDED(hr))
        return STG_E_INVALIDNAME;
    
    UINT cwcNewSpace = wcsLen(pwcsSpaceName);

    USHORT cwcOld  = m_pwscDataSpaceNames[0];
    WCHAR *pwcNext = m_pwscDataSpaceNames + 2;

    USHORT cSpaces = m_pwscDataSpaceNames[1];
    USHORT iSpace  = 0;

    if (cSpaces == MAX_SPACES)
        return STG_E_INSUFFICIENTMEMORY;

    for (; iSpace < cSpaces; iSpace++)
    {
        USHORT cwc = *pwcNext++;

        if (!cwc) 
        {
            WCHAR *pwcsNew = New WCHAR[cwcNewSpace + cwcOld];

            if (!pwcsNew)
                return STG_E_INSUFFICIENTMEMORY;

            pwcNext[-1] = (WCHAR)cwcNewSpace;

            UINT offset = UINT(pwcNext - m_pwscDataSpaceNames);

            CopyMemory(pwcsNew, m_pwscDataSpaceNames, offset * sizeof(WCHAR));
            CopyMemory(pwcsNew + offset, pwcsSpaceName, cwcNewSpace * sizeof(WCHAR));
            CopyMemory(pwcsNew + offset + cwcNewSpace, pwcNext, 
                       sizeof(WCHAR) * (cwcOld - offset)
                      );

            delete [] m_pwscDataSpaceNames;

            m_pwscDataSpaceNames = pwcsNew;

            HRESULT hr = FlushSpaceNameList();

            if (!SUCCEEDED(hr)) 
                return hr;  // BugBug: Should also delete the space name here
            
            RonM_ASSERT(m_papTransformDescriptors[iSpace] == NULL);

            return iSpace;
        }

        pwcNext += cwc + 1;
    }

    WCHAR *pwcsNew = New WCHAR[2 + cwcNewSpace + cwcOld];

    if (!pwcsNew) 
        return STG_E_INSUFFICIENTMEMORY;

    TransformDescriptor **ppTXDNew = New PTransformDescriptor[cSpaces + 1];

    if (!ppTXDNew)
    {
        delete [] pwcsNew;

        return STG_E_INSUFFICIENTMEMORY;
    }

    CopyMemory(ppTXDNew, m_papTransformDescriptors, cSpaces * sizeof(PTransformDescriptor));

    m_papTransformDescriptors[cSpaces] = NULL;

    CopyMemory(pwcsNew,              m_pwscDataSpaceNames, cwcOld      * sizeof(WCHAR));
    CopyMemory(pwcsNew + cwcOld + 1, pwcsSpaceName,        cwcNewSpace * sizeof(WCHAR));

    pwcsNew[cwcOld                  ] = (WCHAR)cwcNewSpace;
    pwcsNew[cwcOld + cwcNewSpace + 1] = 0;
    pwcsNew[1                       ] = cSpaces + 1;

    delete m_papTransformDescriptors;

    m_papTransformDescriptors = ppTXDNew;

    delete [] m_pwscDataSpaceNames;

    m_pwscDataSpaceNames = pwcsNew;

    hr = FlushSpaceNameList();

    if (!SUCCEEDED(hr)) 
        return hr;  // BugBug: Should also delete the space name here
    
    return cSpaces;
}

HRESULT CITFileSystem::CImpITFileSystem::DeleteSpaceName(const WCHAR *pwcsSpaceName)
{
    HRESULT hr = FindSpaceName(pwcsSpaceName);

    if (!SUCCEEDED(hr))
        return hr;

    ULONG iSpace = hr;

    if (iSpace < 2)
        return STG_E_INVALIDNAME;

    RonM_ASSERT(hr < m_pwscDataSpaceNames[1]);

    TransformDescriptor *pTD = m_papTransformDescriptors[iSpace];

    RonM_ASSERT(!pTD || (pTD->pLockBytesChain == NULL && pTD->apTransformInstance[0] == NULL));

    if (pTD)
        delete [] PBYTE(pTD);

    pTD = NULL;

    m_papTransformDescriptors[iSpace] = NULL;
    
    USHORT cwcName  = (USHORT) wcsLen(pwcsSpaceName);
    WCHAR *pwcLimit = m_pwscDataSpaceNames + m_pwscDataSpaceNames[0];
    WCHAR *pwcNext  = m_pwscDataSpaceNames + 2;

    for (;hr--;)
    {
        USHORT cwc = *pwcNext++;

        pwcNext += cwc + 1;
    }

    *pwcNext++ = 0;

    WCHAR *pwcTrailing = pwcNext + cwcName;

    CopyMemory(pwcNext, pwcNext + cwcName, DWORD((pwcLimit - pwcTrailing) * sizeof(WCHAR)));

    return FlushSpaceNameList();
}


HRESULT __stdcall CITFileSystem::CImpITFileSystem::InitOpenOnLockBytes
                      (ILockBytes * plkbyt, DWORD grfMode)
{
    m_pLKBMedium = plkbyt;

    plkbyt->AddRef();

    // We pick up the name of the file which contains this file system from 
    // the LockBytes object.
    
    STATSTG statstg;

    ZeroMemory(&statstg, sizeof(statstg));

    HRESULT hr = plkbyt->Stat(&statstg, STATFLAG_DEFAULT);

    RonM_ASSERT(hr == S_OK);

    if (hr != S_OK) return hr;

    m_cwcFileName = wcsLen(statstg.pwcsName);

    if (m_cwcFileName >= MAX_PATH) // Note that an empty name is valid.
    {
        OLEHeap()->Free(statstg.pwcsName);
        return STG_E_INVALIDNAME;
    }

    CopyMemory(m_awszFileName, statstg.pwcsName, (m_cwcFileName + 1) * sizeof(WCHAR));
    
    OLEHeap()->Free(statstg.pwcsName);
                                                
    m_fReadOnly = (statstg.grfMode & RW_ACCESS_MASK) == STGM_READ;

    ULONG cbRead = 0;

    hr = m_pLKBMedium->ReadAt(CULINT(0).Uli(), &m_itfsh, sizeof(m_itfsh), &cbRead);

    if (!SUCCEEDED(hr))
        return hr;

    if (   cbRead < sizeof(ITSFileHeaderV2)
        || m_itfsh.uMagic != MAGIC_ITS_FILE
        || m_itfsh.uFormatVersion < FirstReleasedVersion
        || m_itfsh.uFormatVersion > CurrentFileFormatVersion
		||(m_itfsh.fFlags & ~VALID_OPEN_FLAGS)
       )
        return STG_E_INVALIDHEADER;
    else
        if (   m_itfsh.uFormatVersion == CurrentFileFormatVersion
            && cbRead == sizeof(ITSFileHeader)
           )
        {
        }
        else 
            if (m_itfsh.uFormatVersion == FirstReleasedVersion)
            {
                m_itfsh.offPathMgrOrigin = 0;
            }
            else
            {
                RonM_ASSERT(FALSE); // If this assert fires, we have a old version 
                                    // that isn't being handled.
                return STG_E_INVALIDHEADER;
            }

    m_StartingFileStamp = m_itfsh.dwStamp;

    hr = CSystemPathManager::Create(NULL, this, &m_pSysPathManager);
    
    RonM_ASSERT(SUCCEEDED(hr));

    if (!SUCCEEDED(hr))
        return hr;

    RonM_ASSERT(m_itfsh.clsidFreeList == CLSID_IFreeListManager_1);

    hr = CFreeList::AttachFreeList(this, &m_pFreeListManager);

    RonM_ASSERT(SUCCEEDED(hr));

    if (!SUCCEEDED(hr))
        return hr;

    ILockBytes *pLKB_PathDatabase = NULL;

    hr = OpenLockBytes(NULL, L"P", &pLKB_PathDatabase);

    RonM_ASSERT(SUCCEEDED(hr));

    if (!SUCCEEDED(hr))
        return hr;

    hr = CPathManager1::LoadPathDatabase(NULL, pLKB_PathDatabase, &m_pPathManager);

    RonM_ASSERT(SUCCEEDED(hr));

    if (hr == S_OK)
    {    
        m_fInitialed = TRUE;
        
        MarkActive(g_pImpITFileSystemList);
    }

    hr = OpenSpaceNameList();

    if (!SUCCEEDED(hr))
        return hr;

    hr = CTransformServices::Create(NULL, this, &m_pTransformServices);

    if (hr == S_OK)
    {
        Release(); // To compensate for the circular ref from FreeList Stream
        Release(); // To compensate for the circular ref from m_pTransformServices

        m_cFSObjectRefs += 2;

        // Note: The destructor for the file system will do m_cFSObjectRefs AddRef 
        //       calls to compensate for these Release calls. We do the release calls
        //       here so that the file system won't be kept alive forever by its 
        //       circular references.
    }

    Container()->MoveInFrontOf(((IITTransformServices *) m_pTransformServices)->Container()); 
    
    return hr;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::SetITFSTimes
                      (FILETIME const * pctime, 
                       FILETIME const * patime, 
                       FILETIME const * pmtime
                      )
{
    return ((CFSLockBytes::CImpILockBytes *) m_pLKBMedium)
           ->SetTimes(pctime, patime, pmtime);
}

// IUnknown methods:

STDMETHODIMP_(ULONG) CITFileSystem::CImpITFileSystem::Release(void)
{
    // The actual work for the Release function is done by 
    // CImpITUnknown::Release() and ~CImpITFileSystem.
    //
    // We bracket that work as a critical section active file systems
    // are kept in a linked list. A release operation may remove
    // this file system from that list, and we need to guard against
    // having someone find a reference to this storage just before
    // we destroy it.
    
	CSyncWith sw(g_csITFS);

    ULONG ulCnt = CImpITUnknown::Release();

    return ulCnt;
}

// IITFileSystem methods:

CITCriticalSection& CITFileSystem::CImpITFileSystem::CriticalSection()
{
    return m_cs;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::FlushToLockBytes()
{
    // This routine copies the free list and the file header to the 
    // lockbyte medium. It does not flush the path database. We expect
    // most calls to this interface will come from the Path Manager.
    
    RonM_ASSERT(m_fInitialed);

    RonM_ASSERT(m_pStrmSpaceNames);

    if (m_pFreeListManager->IsDirty() == S_OK)
    {
        HRESULT hr = m_pFreeListManager->RecordFreeList();

        if (!SUCCEEDED(hr)) return hr;
    }

    if (m_fHeaderIsDirty || m_itfsh.dwStamp != m_StartingFileStamp)
    {
        ULONG cbWritten = 0;

        HRESULT hr = S_FALSE;

        switch (m_itfsh.uFormatVersion)
        {
        case RelativeOffsetVersion:

            

            hr = m_pLKBMedium->WriteAt(CULINT(0).Uli(), &m_itfsh, sizeof(m_itfsh), &cbWritten);

            if (hr == S_OK && cbWritten != sizeof(m_itfsh))
                hr = STG_E_WRITEFAULT;

            break;

        case FirstReleasedVersion:

			RonM_ASSERT(m_itfsh.offPathMgrOrigin == 0);
            hr = m_pLKBMedium->WriteAt(CULINT(0).Uli(), &m_itfsh, sizeof(ITSFileHeaderV2), &cbWritten);

            if (hr == S_OK && cbWritten != sizeof(ITSFileHeaderV2))
                hr = STG_E_WRITEFAULT;

            break;

        default:

            RonM_ASSERT(FALSE); // We have an old format version number that
                                // isn't being handled!
        }
            
            
        if (!SUCCEEDED(hr)) return hr;

        m_fHeaderIsDirty = FALSE;
    }
    return NO_ERROR;
}

void CITFileSystem::CImpITFileSystem::CopyPath(PathInfo &PI, const WCHAR *pwcsPath)
{
    PI.cwcStreamPath = wcsLen(pwcsPath);

    RonM_ASSERT(PI.cwcStreamPath < MAX_PATH);

    CopyMemory(PI.awszStreamPath, pwcsPath, sizeof(WCHAR) * (1 + PI.cwcStreamPath));
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::CreateStorage
                      (IUnknown *pUnkOuter, const WCHAR *pwcsPathPrefix, 
                       DWORD grfMode, IStorageITEx **ppStg
                      )
{
    CSyncWith sw(g_csITFS); 

    PathInfo PI, PIPrev;

    CopyPath(PI, pwcsPathPrefix);
    
    PI.uStateBits          = 0;
    PI.iLockedBytesSegment = 0;
    PI.clsidStorage        = CLSID_NULL;
    PI.cUnrecordedChanges  = 0;

    RonM_ASSERT(PI.awszStreamPath[PI.cwcStreamPath - 1] == L'/');

    HRESULT hr = m_pPathManager->CreateEntry(&PI, &PIPrev, FALSE);

    if (!SUCCEEDED(hr))
        return hr;

    hr = CStorage::OpenStorage(pUnkOuter, this, &PI, grfMode, ppStg);

    if (!SUCCEEDED(hr))
        m_pPathManager->DeleteEntry(&PI);
    else
        if (pwcsPathPrefix[0] != L'/')
        {
            ((IIT_IStorageITEx *) *ppStg)->Container()->MarkSecondary();

            if (m_cFSObjectRefs!= UINT(~0))
            {
                m_cFSObjectRefs++;
                this->Release(); // To account for circular refs through ":" storages.
            }
        }

    return hr;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::OpenStorage  
                      (IUnknown *pUnkOuter, const WCHAR *pwcsPathPrefix, 
                       DWORD grfMode, IStorageITEx **ppstg
                      )
{
    CSyncWith sw(g_csITFS);

    IStorageITEx *pStorage = FindActiveStorage(pwcsPathPrefix);

    if (pStorage)
    {
        *ppstg = pStorage;

        return NO_ERROR;
    }
    
    PathInfo PI, PIPrev;

    CopyPath(PI, pwcsPathPrefix);

    RonM_ASSERT(PI.awszStreamPath[PI.cwcStreamPath - 1] == L'/');

    HRESULT hr = m_pPathManager->FindEntry(&PI);

    if (hr == S_OK)
        hr = CStorage::OpenStorage(pUnkOuter, this, &PI, grfMode, ppstg);
    else
    {
        // Some storages don't have explicit entries in the path database.
        // So we'll look to see if anything has a prefix which matches
        // pwcsPathPrefix.

        HRESULT hr2      = NO_ERROR;
        BOOL    fStorage = FALSE;

        IEnumSTATSTG *pEnum = NULL;

        hr2 = m_pPathManager->EnumFromObject(NULL, pwcsPathPrefix, wcsLen(pwcsPathPrefix), 
			                                 IID_IEnumSTATSTG, (PVOID *) &pEnum
			                                );
        
        if (hr2 == S_OK)
        {
            STATSTG statstg;

            hr2 = pEnum->Next(1, &statstg, NULL);

            if (hr2 == S_OK)
            {
                const WCHAR *pwcPrefix = pwcsPathPrefix;
                const WCHAR *pwcEnum   = statstg.pwcsName;

                for (; ; )
                {
                    WCHAR wcPrefix = WC_To_0x0409_Lower(*pwcPrefix++);
                    WCHAR wcEnum   = WC_To_0x0409_Lower(*pwcEnum++);

                    if (wcPrefix == wcEnum && wcPrefix) 
                        continue;

                    fStorage = wcPrefix == 0;

                    RonM_ASSERT(wcEnum || wcPrefix);

                    break;
                }
                
                OLEHeap()->Free(statstg.pwcsName);
            }

            pEnum->Release();
        }

        if (fStorage)
        {
            PI.clsidStorage = CLSID_NULL;
            PI.uStateBits   = 0;

            // BugBug: We don't yet set iLockedBytesSegment for this storage.
            //         The problem is finding a prefix storage which has an
            //         entry in the path database.

            hr = CStorage::OpenStorage(pUnkOuter, this, &PI, grfMode, ppstg);;
        }
        else hr = STG_E_FILENOTFOUND;
    }

    if (hr == S_OK && pwcsPathPrefix[0] != L'/')
    {
        ((IIT_IStorageITEx *) *ppstg)->Container()->MarkSecondary();

        if (m_cFSObjectRefs!= UINT(~0))
        {
            m_cFSObjectRefs++;
            this->Release();  // To account for circular references through ":" storages.
        }
    }

    return hr;
}
  
HRESULT CITFileSystem::CImpITFileSystem::CreateTransformedLockBytes
                      (IUnknown *pUnkOuter, const WCHAR *pwcsPath,
                       const WCHAR *pwcsDataSpaceName,
                       BOOL fOverwrite, ILockBytes **ppLKB
                      )
{
    RonM_ASSERT(pwcsPath[0] != L':');

    HRESULT hr = FindSpaceName(pwcsDataSpaceName);

    if (!SUCCEEDED(hr))
        return hr;

    ULONG iSpace = hr;
    
    BOOL fNewActivation = (m_papTransformDescriptors[iSpace] == NULL);

    if (fNewActivation)
    {
        hr = ActivateDataSpace(iSpace);

        if (!SUCCEEDED(hr))
            return hr;
    }

    TransformDescriptor *pTD = m_papTransformDescriptors[iSpace];

    RonM_ASSERT(pTD);

    ILockBytes *pLKB = CTransformedLockBytes::FindTransformedLockBytes(pwcsPath, pTD);

    if (pLKB)
    {
        RonM_ASSERT(!fNewActivation);
        
        pLKB->Release();

        return STG_E_INUSE;
    }
    
    PathInfo PI, PIPrev;

    CopyPath(PI, pwcsPath);

    PI.ullcbOffset         = 0;
    PI.ullcbData           = 0;
    PI.uStateBits          = 0;
    PI.iLockedBytesSegment = iSpace;
    PI.cUnrecordedChanges  = 0;

    RonM_ASSERT(PI.awszStreamPath[PI.cwcStreamPath - 1] != L'/');

    PIPrev.cwcStreamPath = 0; // Setup to detect overwrite condition.

    hr = m_pPathManager->CreateEntry(&PI, &PIPrev, fOverwrite);

    if (SUCCEEDED(hr))
    {
#if 0 // BugBug: Need to add a method handle this for transforms
        if (PIPrev.cwcStreamPath) // Did we overwrite an existing file?
            m_pFreeListManager->PutFreeSpace(PIPrev.ullcbOffset, PIPrev.ullcbData);
#endif // 0

        hr = CTransformedLockBytes::Open(NULL, &PI, pTD, this, ppLKB);
    }

    return hr;
}

HRESULT CITFileSystem::CImpITFileSystem::ActivateDataSpace(ULONG iSpace)
{
    RonM_ASSERT(iSpace == 1); // Since we have only the default space implemented
                    
    // BugBug: The code below only supports the default data space.    

    RonM_ASSERT(iSpace < m_pwscDataSpaceNames[1]);

    RonM_ASSERT(m_papTransformDescriptors[iSpace] == NULL);

    WCHAR awszPath[MAX_PATH];
    
    wcsCpy(awszPath, pwcsSpaceNameStorage);
    wcsCat(awszPath, pwcsLZXSpace);

    UINT cwcPrefix = wcsLen(awszPath);

    wcsCat(awszPath, pwcsSpanInfoSuffix);

    IStreamITEx *pStrm = NULL;

    HRESULT hr = OpenStream(NULL, (const WCHAR *) awszPath, STGM_READ, &pStrm);

    if (!SUCCEEDED(hr))
        return hr;

    ULARGE_INTEGER ulicbSpan;
    ULONG cbRead = 0;

    hr = pStrm->Read(&ulicbSpan, sizeof(ulicbSpan), &cbRead);

    pStrm->Release();  pStrm = NULL;

    if (hr == S_FALSE || cbRead != sizeof(ulicbSpan))
        hr = STG_E_READFAULT;

    if (!SUCCEEDED(hr))
        return hr;

    awszPath[cwcPrefix] = 0;

    wcsCat(awszPath, pwcsControlDataSuffix);

    hr = OpenStream(NULL, (const WCHAR *) awszPath, STGM_READ, &pStrm);

    if (!SUCCEEDED(hr))
        return hr;

    UINT cdwData = 0;

    hr = pStrm->Read(&cdwData, sizeof(cdwData), &cbRead);
    
    if (hr == S_FALSE || cbRead != sizeof(cdwData))
        hr = STG_E_READFAULT;

    if (!SUCCEEDED(hr))
        return hr;
    
    PXformControlData pXFCD = PXformControlData(_alloca(sizeof(DWORD) * (cdwData + 1)));
    
    if (!pXFCD)
    {
        pStrm->Release();

        return STG_E_INSUFFICIENTMEMORY;
    }

    pXFCD->cdwControlData = cdwData;

    hr = pStrm->Read(&(pXFCD->adwControlData), cdwData * sizeof(DWORD), &cbRead);

    pStrm->Release();  pStrm = NULL;

    if (hr == S_FALSE || cbRead != cdwData * sizeof(DWORD))
        hr = STG_E_READFAULT;

    if (!SUCCEEDED(hr))
        return hr;

    awszPath[cwcPrefix] = 0;

    wcsCat(awszPath, pwcsSpaceContentSuffix);

    ILockBytes *pLKB = NULL;

    hr = OpenLockBytes(NULL, (const WCHAR *) awszPath, &pLKB);

    if (!SUCCEEDED(hr))
        return hr;

    ITransformInstance *pITxInst;

    if (!SUCCEEDED(hr = CNull_TransformInstance::CreateFromILockBytes
                            (NULL, pLKB, &pITxInst)))

        return hr;

    ((IITTransformInstance *) pITxInst)->Container()->MarkSecondary();
	
	ITransformFactory *pITxFactory;

    hr = CLZX_TransformFactory::Create(NULL, IID_ITransformFactory, (void **)&pITxFactory);

	if (SUCCEEDED(hr))
	{
        m_pTransformServices->AddRef();  // Because we're passing the Transform services 
                                         // object to the transform factory.

        UINT cTransforms = 1; // Really should get this from transform list.

        TransformDescriptor *pTD = TransformDescriptor::Create(iSpace, cTransforms);

        if (pTD)
        {
		    CLSID clsid = CLSID_LZX_Transform;

		    hr = pITxFactory->CreateTransformInstance
                     (pITxInst,			           // Container data span for transformed data		
				      ulicbSpan,		           // Untransformed size of data
				      pXFCD,					   // Control data for this instance
				      &clsid,				       // Transform Class ID
				      pwcsLZXSpace,			       // Data space name for this instance
				      m_pTransformServices,		   // Utility routines
				      NULL,						   // Interface to get enciphering keys
				      &pTD->apTransformInstance[0] // Out: Instance transform interface
                     );
		            
            pITxFactory->Release();

            if (SUCCEEDED(hr))
                 m_papTransformDescriptors[iSpace] = pTD;
            else delete pTD;
        }
        else hr = STG_E_INSUFFICIENTMEMORY;
	}
    else pITxInst->Release();

    return hr;
}

HRESULT CITFileSystem::CImpITFileSystem::DeactivateDataSpace(ULONG iSpace)
{
    RonM_ASSERT(iSpace < m_pwscDataSpaceNames[1]);
    RonM_ASSERT(m_papTransformDescriptors[iSpace]);
    RonM_ASSERT(iSpace == 1); // While we have just the "MSCompressed" space.
    
    TransformDescriptor *pTD = m_papTransformDescriptors[iSpace];

    RonM_ASSERT(pTD->iSpace != 0);
    RonM_ASSERT(pTD->pLockBytesChain == NULL);

    if (IsWriteable() == S_OK)
    {
        UINT cTransforms = pTD->cTransformLayers;
    
        ULARGE_INTEGER *pacbSpans = (ULARGE_INTEGER *) _alloca(cTransforms * sizeof(ULARGE_INTEGER));

        if (!pacbSpans)
            return STG_E_INSUFFICIENTMEMORY;

        HRESULT hr = NO_ERROR;

        for (UINT i = 0; i < cTransforms; i++)
        {
            hr = pTD->apTransformInstance[i]->SpaceSize(pacbSpans + i);

            if (!SUCCEEDED(hr))
                return hr;
        }

        WCHAR awcsPath[MAX_PATH];

        wcsCpy(awcsPath, pwcsSpaceNameStorage);
        wcsCat(awcsPath, pwcsLZXSpace);
        wcsCat(awcsPath, pwcsSpanInfoSuffix);

        IStreamITEx *pStrm = NULL;

        hr = OpenStream(NULL, awcsPath, STGM_READWRITE, &pStrm);

        if (!SUCCEEDED(hr))
            return hr;

        ULONG cbSpanSizes = cTransforms * sizeof(ULARGE_INTEGER);
        ULONG cbWritten = 0;

        hr = pStrm->Write(pacbSpans, cbSpanSizes, &cbWritten);

        pStrm->Release();  pStrm = NULL;
    
        if (hr == S_FALSE || cbWritten != cbSpanSizes)
            hr = STG_E_WRITEFAULT;

        if (!SUCCEEDED(hr))
            return hr;
    }
    
    pTD->apTransformInstance[0]->Release();

    delete pTD;

    m_papTransformDescriptors[iSpace] = NULL;

    return NO_ERROR;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::CreateLockBytes
                      (IUnknown *pUnkOuter, const WCHAR *pwcsPath,
                       const WCHAR *pwcsDataSpaceName,
                       BOOL fOverwrite, ILockBytes **ppLKB
                      )
{
    CSyncWith sw(m_cs);

    if (wcsicmp_0x0409(pwcsDataSpaceName, pwcsUncompressedSpace))
    {
        RonM_ASSERT(pwcsPath[0] != L':');

        HRESULT hr = CreateTransformedLockBytes(pUnkOuter, pwcsPath, pwcsDataSpaceName, 
                                                fOverwrite, ppLKB
                                               );
    
        return hr;
    }

    ILockBytes *pLKB = FindActiveLockBytes(pwcsPath);

    if (pLKB)
    {
        pLKB->Release();

        return STG_E_INUSE;
    }
    
    PathInfo PI, PIPrev;

    CopyPath(PI, pwcsPath);

    PI.ullcbOffset         = 0;
    PI.ullcbData           = 0;
    PI.uStateBits          = 0;
    PI.iLockedBytesSegment = 0;
    PI.cUnrecordedChanges  = 0;

    RonM_ASSERT(PI.awszStreamPath[PI.cwcStreamPath - 1] != L'/');

    PIPrev.cwcStreamPath = 0; // Setup to detect overwrite condition.

    HRESULT hr = m_pPathManager->CreateEntry(&PI, &PIPrev, fOverwrite);

    if (SUCCEEDED(hr))
    {
        if (PIPrev.cwcStreamPath) // Did we overwrite an existing file?
            m_pFreeListManager->PutFreeSpace(PIPrev.ullcbOffset, PIPrev.ullcbData);

        hr = CSegmentLockBytes::OpenSegment(pUnkOuter, this, m_pLKBMedium, &PI, ppLKB); 
    }

    if (hr == S_OK && pwcsPath[0] != L'/')
    {
        ((IITLockBytes *) *ppLKB)->Container()->MarkSecondary();

        if (m_cFSObjectRefs!= UINT(~0))
        {
            m_cFSObjectRefs++;
            this->Release(); // To account for circular references through ":" streams
        }
    }

    return hr;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::OpenLockBytes
                      (IUnknown *pUnkOuter, const WCHAR *pwcsPath, ILockBytes **ppLKB)
{
    CSyncWith sw(m_cs);

    ILockBytes *pLKB = FindActiveLockBytes(pwcsPath);

    if (pLKB)
    {
        *ppLKB = pLKB;

        return NO_ERROR;
    }
    
    PathInfo PI;

    CopyPath(PI, pwcsPath);

    RonM_ASSERT(PI.awszStreamPath[PI.cwcStreamPath - 1] != L'/');

	IITPathManager *pPathManager = PathMgr(&PI);

    HRESULT hr = pPathManager->FindEntry(&PI);

    if (hr == S_OK)
    {
        RonM_ASSERT(pwcsPath[0] != L':' || PI.iLockedBytesSegment == 0);

        if (PI.iLockedBytesSegment != 0)
             hr = OpenTransformedLockbytes(&PI, ppLKB);
        else
        {   
            if (PI.ullcbData.NonZero() && (pPathManager == m_pPathManager))
                PI.ullcbOffset += m_itfsh.offPathMgrOrigin;

            hr = CSegmentLockBytes::OpenSegment(pUnkOuter, this, m_pLKBMedium, &PI, ppLKB);
        }

        if (hr == S_OK && pwcsPath[0] != L'/')
        {
            ((IITLockBytes *) *ppLKB)->Container()->MarkSecondary();

            if (m_cFSObjectRefs!= UINT(~0))
            {
                m_cFSObjectRefs++;
                this->Release(); // To account for circular reference 
                                 // through "F", "P", or a stream whose
                                 // path begins with ":".
            }
        }
    }
    else
        if (hr == S_FALSE)
            hr = STG_E_FILENOTFOUND;

    return hr;
}

HRESULT CITFileSystem::CImpITFileSystem::OpenTransformedLockbytes
            (PathInfo *pPI, ILockBytes **ppLKB)
{
    RonM_ASSERT(pPI->cwcStreamPath > 0 && pPI->awszStreamPath[0] != L':');
    
    UINT iSpace = pPI->iLockedBytesSegment;
    
    RonM_ASSERT(iSpace < m_pwscDataSpaceNames[1]);
    
    BOOL fNewActivation = !m_papTransformDescriptors[iSpace];

    if (fNewActivation)
    {
        HRESULT hr = ActivateDataSpace(iSpace);

        if (!SUCCEEDED(hr))
            return hr;
    }

    TransformDescriptor *pTD = m_papTransformDescriptors[iSpace];
    
    RonM_ASSERT(pTD);
    
    ILockBytes *pLKB = CTransformedLockBytes::FindTransformedLockBytes(pPI->awszStreamPath, pTD);

    if (pLKB)
    {
        RonM_ASSERT(!fNewActivation);

        *ppLKB = pLKB;

        return NO_ERROR;
    }
    
    return CTransformedLockBytes::Open(NULL, pPI, pTD, this, ppLKB);
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::CreateStream
                      (IUnknown *pUnkOuter, const WCHAR *pwcsPath, 
                       DWORD grfMode, IStreamITEx **ppStrm
                      )
{
    return CreateStream(pUnkOuter, pwcsPath,
                        (m_itfsh.fFlags & fDefaultIsCompression)
                            ? (pwcsPath[0] == L':'? pwcsUncompressedSpace : pwcsLZXSpace)
                            : pwcsUncompressedSpace, 
                        grfMode, ppStrm
                       );
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::CreateStream
    (IUnknown *pUnkOuter, const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
     DWORD grfMode, IStreamITEx ** ppstm
    )
{
    CSyncWith sw(m_cs);

    ILockBytes *pLKB;
    
    HRESULT hr = CreateLockBytes(NULL, pwcsName, pwcsDataSpaceName, 
                                 !(grfMode & STGM_FAILIFTHERE), &pLKB
                                );

    if (SUCCEEDED(hr))
    {
        hr = CStream::OpenStream(pUnkOuter, pLKB, grfMode, ppstm);

        if (!SUCCEEDED(hr))
            pLKB->Release();
        else
            if (((IITLockBytes *) pLKB)->Container()->IsSecondary())
                ((IITStreamITEx *) *ppstm)->Container()->MarkSecondary();
    }

    return hr;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::OpenStream
                      (IUnknown *pUnkOuter, const WCHAR *pwcsPath, 
                       DWORD grfMode, IStreamITEx **ppStream
                      )
{
    CSyncWith sw(m_cs);

    ILockBytes *pLKB;
    
    HRESULT hr = OpenLockBytes(NULL, pwcsPath, &pLKB);

    if (SUCCEEDED(hr))
    {
        hr = CStream::OpenStream(pUnkOuter, pLKB, grfMode, ppStream);

        if (!SUCCEEDED(hr))
            pLKB->Release();
        else
            if (((IITLockBytes *) pLKB)->Container()->IsSecondary())
                ((IITStreamITEx *) *ppStream)->Container()->MarkSecondary();
    }

    return hr;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::ConnectStorage(CImpITUnknown *pStg)
{
    CSyncWith sw(m_cs);

    pStg->MarkActive(m_pActiveStorageList);
    
    return NO_ERROR;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::ConnectLockBytes(CImpITUnknown *pStg)
{
    CSyncWith sw(m_cs);

    pStg->MarkActive(m_pActiveLockBytesList);
    
    return NO_ERROR;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::LookForActivity
    (WCHAR const *pwcsName, IEnumSTATSTG *pEnum)
{
	HRESULT hr        = S_OK;
    BOOL    fFinished = FALSE;
	BOOL    fInUse    = FALSE;

	// The strategy we use is to enumerate paths until we find one that doesn't
	// have a prefix which matches pwcsName. 

	for (;;)
	{
        STATSTG statstg;

		statstg.pwcsName = NULL;

        HRESULT hr2 = pEnum->Next(1, &statstg, NULL);

		if (hr2 != S_OK)
		{
			RonM_ASSERT(statstg.pwcsName == NULL);

			if (hr2 != S_FALSE) hr = hr2;

			break;
		} 

		RonM_ASSERT(statstg.pwcsName);

		// Now we'll compare the two paths to see if we still have a prefix match.

		const WCHAR *pwcPrefix = pwcsName;
		const WCHAR *pwcEnum   = statstg.pwcsName;

		for (; ; )
		{
			WCHAR wcPrefix = WC_To_0x0409_Lower(*pwcPrefix++);
			WCHAR wcEnum   = WC_To_0x0409_Lower(*pwcEnum++);

			if (wcPrefix == wcEnum && wcPrefix) 
				continue;

			// We've either found a mismatch or we've exhausted the
			// prefix string.

			if(wcPrefix || (wcEnum && wcEnum != L'/'))
			{
				fFinished = TRUE; // Not a storage prefix

				break;
			}

			// Next we look to see if this path is currently being used.
			// We can't delete storages or streams that are active.

			if (statstg.pwcsName[lstrlenW(statstg.pwcsName)-1] == L'/')
			{
				IStorageITEx *pStorage = FindActiveStorage(statstg.pwcsName);

				if (pStorage)
				{
					pStorage->Release();

					fInUse    = TRUE;
					fFinished = TRUE;
			   }
			}
			else
			{
                // For lockbyte objects we need to check the
                // chain of uncompressed lockbyte objects and 
                // then perhaps the chain for each active data space.

				ILockBytes *pLKB = FindActiveLockBytes(statstg.pwcsName);

                if (!pLKB)
                {
                    // Not found as an uncompressed lockbyte.
                    // So we iterate through the data spaces.

                    // BugBug: Need to abstract the space count and hide the
                    //         way that we store this information.

                    UINT cSpaces = m_pwscDataSpaceNames[1];

                    for (; cSpaces--; )
                    {
                        TransformDescriptor *pTD = m_papTransformDescriptors[cSpaces];

                        if (!pTD) continue;

                        pLKB = FindMatchingLockBytes
                                   (statstg.pwcsName, 
                                    (CImpITUnknown *) pTD->pLockBytesChain
                                   );

                        if (pLKB) break;
                    }
                }

				if (pLKB)
				{
					pLKB->Release();

					fInUse    = TRUE;
					fFinished = TRUE;
				}
			}

			break;
        }

		OLEHeap()->Free(statstg.pwcsName);

		if (fFinished) break;
    }

	if (fInUse) hr = STG_E_INUSE;

    return hr;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::DeleteItem(WCHAR const *pwcsName)
{
    // For a stream we remove one item.
    // For a storage we'll remove the storage and everything it contains!
	
	CSyncWith sw(m_cs); // To avoid race conditions...

	IEnumSTATSTG *pEnum = NULL;
	
	HRESULT hr = m_pPathManager->EnumFromObject(NULL, pwcsName, wcsLen(pwcsName), 
			                                    IID_IEnumSTATSTG, (PVOID *) &pEnum
			                                   );
    
	if (!SUCCEEDED(hr)) return hr;

    // First we look to see if this item or one of its descendants are being used.
    // We can't delete an item that's in use.

    hr = LookForActivity(pwcsName, pEnum);

    if (!SUCCEEDED(hr))
    {
        pEnum->Release();

        return hr;
    }

    // The strategy we use is to enumerate paths until we find one that doesn't
	// have a prefix which matches pwcsName. 

	pEnum->Reset();

	BOOL fFinished = FALSE;

	for (;;)
	{
        STATSTG statstg;

		statstg.pwcsName = NULL;

        HRESULT hr2 = pEnum->Next(1, &statstg, NULL);

		if (hr2 != S_OK)
		{
			RonM_ASSERT(statstg.pwcsName == NULL);

			if (hr2 != S_FALSE) hr = hr2;

			break;
		} 

		RonM_ASSERT(statstg.pwcsName);

		// Now we'll compare the two paths to see if we still have a prefix match.

		const WCHAR *pwcPrefix = pwcsName;
		const WCHAR *pwcEnum   = statstg.pwcsName;

		for (; ; )
		{
			WCHAR wcPrefix = WC_To_0x0409_Lower(*pwcPrefix++);
			WCHAR wcEnum   = WC_To_0x0409_Lower(*pwcEnum++);

			if (wcPrefix == wcEnum && wcPrefix) 
				continue;

			// We've either found a mismatch or we've exhausted the
			// prefix string.

			if(wcPrefix || (wcEnum && wcEnum != L'/'))
			{
				fFinished = TRUE; // Not a storage prefix

				break;
			}

			// At this point we know that we've got a prefix match and that the
			// matching path is not being used by anybody.

			// Now we can delete the corresponding path manager entry.

			PathInfo PI;
			CopyPath(PI, statstg.pwcsName);
			
			hr = m_pPathManager->DeleteEntry(&PI);

			if (!SUCCEEDED(hr)) 
			{
				fFinished = TRUE;

				break;
			}

			// If this path was for a uncompressed stream, we need to tell the
			// free list manager about the data space we've just released for reuse.

			if (PI.awszStreamPath[PI.cwcStreamPath-1] != L'/')
				if (PI.iLockedBytesSegment == 0)
				{
					hr = m_pFreeListManager->PutFreeSpace(PI.ullcbOffset, PI.ullcbData);
			        
                    if (!SUCCEEDED(hr)) fFinished = TRUE;
                }
			    // BugBug Need to make a similar call to the transformed space...

			break;
		}
        
		OLEHeap()->Free(statstg.pwcsName);

		if (fFinished) break;
    }
    
    pEnum->Release();

	return hr;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::RenameItem(WCHAR const *pwcsOldName, WCHAR const *pwcsNewName)
{
    // For a stream we remove one item.
    // For a storage we'll remove the storage and everything it contains!
	
	CSyncWith sw(m_cs); // To avoid race conditions...

	IEnumSTATSTG *pEnum = NULL;
	
	HRESULT hr = m_pPathManager->EnumFromObject(NULL, pwcsOldName, wcsLen(pwcsOldName), 
			                                    IID_IEnumSTATSTG, (PVOID *) &pEnum
			                                   );
    
	if (!SUCCEEDED(hr)) return hr;

    // First we look to see if this item or one of its descendants are being used.
    // We can't delete an item that's in use.

    hr = LookForActivity(pwcsOldName, pEnum);

    if (!SUCCEEDED(hr))
    {
        pEnum->Release();

        return hr;
    }

    // The strategy we use is to enumerate paths until we find one that doesn't
	// have a prefix which matches pwcsName. 

	pEnum->Reset();

	BOOL fFinished = FALSE;

    UINT cwcOldName = lstrlenW(pwcsOldName);
    UINT cwcNewName = lstrlenW(pwcsNewName);

    WCHAR awcsBuffer[MAX_PATH];

	for (;;)
	{
        STATSTG statstg;

		statstg.pwcsName = NULL;

        HRESULT hr2 = pEnum->Next(1, &statstg, NULL);

		if (hr2 != S_OK)
		{
			RonM_ASSERT(statstg.pwcsName == NULL);

			if (hr2 != S_FALSE) hr = hr2;

			break;
		} 

		RonM_ASSERT(statstg.pwcsName);

		// Now we'll compare the two paths to see if we still have a prefix match.

		const WCHAR *pwcPrefix = pwcsOldName;
		const WCHAR *pwcEnum   = statstg.pwcsName;

		for (; ; )
		{
			WCHAR wcPrefix = WC_To_0x0409_Lower(*pwcPrefix++);
			WCHAR wcEnum   = WC_To_0x0409_Lower(*pwcEnum++);

			if (wcPrefix == wcEnum && wcPrefix) 
				continue;

			// We've either found a mismatch or we've exhausted the
			// prefix string.

			if(wcPrefix || (wcEnum && wcEnum != L'/'))
			{
				fFinished = TRUE; // Not a storage prefix

				break;
			}

			// At this point we know that we've got a prefix match and that the
			// matching path is not being used by anybody.

			// Now we look to see if the new name would be too long.

            PWCHAR pwcsSuffix = statstg.pwcsName + cwcOldName;
			UINT cwcSuffix    = lstrlenW(pwcsSuffix);
            
            if (cwcSuffix + cwcNewName >= MAX_PATH)
            {
                hr = STG_E_INVALIDNAME;

                fFinished = TRUE;

                break;
            }

            // Now we construct the new name and look to see if it already exists.
            // We don't allow rename operations to destroy any existing items.

            wcsCpy(awcsBuffer, pwcsNewName);
            wcsCat(awcsBuffer, pwcsSuffix);

            PathInfo PI;
			CopyPath(PI, awcsBuffer);
			
            hr2 = m_pPathManager->FindEntry(&PI);

            if (hr2 == S_OK)
            {
                hr = STG_E_FILEALREADYEXISTS;

                fFinished = TRUE;

                break;
            }
            
			CopyPath(PI, statstg.pwcsName);
			
			hr = m_pPathManager->DeleteEntry(&PI);

			if (!SUCCEEDED(hr)) 
			{
				fFinished = TRUE;

				break;
			}

            CopyPath(PI, awcsBuffer);

            hr = m_pPathManager->CreateEntry(&PI, NULL, FALSE);

			if (!SUCCEEDED(hr)) 
			{
			    // This is bad. We've removed the old entry, but we haven't been
                // able to create the new entry. So we've lost a item. The best
                // we can do in this situation is to reclaim the space occupied
                // by the item.
                
                if (PI.awszStreamPath[PI.cwcStreamPath-1] != L'/')
				    if (PI.iLockedBytesSegment == 0)
					    m_pFreeListManager->PutFreeSpace(PI.ullcbOffset, PI.ullcbData);			            
			        // BugBug Need to make a similar call to the transformed space...				
                
                fFinished = TRUE;

				break;
			}

			break;
		}
        
		OLEHeap()->Free(statstg.pwcsName);

		if (fFinished) break;
    }
    
    pEnum->Release();

	return hr;


    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::UpdatePathInfo(PathInfo *pPathInfo)
{
    CSyncWith sw(m_cs);
    
    RonM_ASSERT(pPathInfo->cwcStreamPath); // No empty paths allowed!

    PathInfo pi = *pPathInfo;

    if (   pi.awszStreamPath[pPathInfo->cwcStreamPath - 1] != L'/'
        && pi.awszStreamPath[pPathInfo->cwcStreamPath - 1] != L'\\'
        && pi.iLockedBytesSegment == 0 // Uncompressed dataspace.
        && pi.ullcbData.NonZero()
       )
    {
        // This is a stream in the L"Uncompressed" dataspace. 
        // So we've got to adjust for our offset origin.

        pi.ullcbOffset -= m_itfsh.offPathMgrOrigin;
    }
    
    HRESULT hr = PathMgr(pPathInfo)->UpdateEntry(&pi);

    if (   hr != S_OK 
        && pPathInfo->cwcStreamPath 
        && pPathInfo->awszStreamPath[pPathInfo->cwcStreamPath - 1] == L'/'
       )
    {
        // Since some storage entries don't have explicit entries in
        // the path database, we must be prepared to add them when
        // get an update request for a storage path.

        PathInfo PI;

        hr = PathMgr(pPathInfo)->CreateEntry(pPathInfo, &PI, FALSE);
    }

    if (hr == S_OK)
        pPathInfo->cUnrecordedChanges = 0;

    return hr;
}

IITPathManager *CITFileSystem::CImpITFileSystem::PathMgr(PathInfo *pPathInfo)
{
    return (   pPathInfo->cwcStreamPath == 1 
            && (pPathInfo->awszStreamPath[0] == L'F' || pPathInfo->awszStreamPath[0] == L'P')
           )? m_pSysPathManager : m_pPathManager;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::GetITFSTimes
                      (FILETIME *pctime, FILETIME *patime, 
                                         FILETIME *pmtime
                      )
{
    STATSTG statstg;

    HRESULT hr = m_pLKBMedium->Stat(&statstg, STATFLAG_NONAME);

    if (!SUCCEEDED(hr)) return hr;

    if (pctime) 
    {
        pctime->dwLowDateTime  = statstg.ctime.dwLowDateTime;
        pctime->dwHighDateTime = statstg.ctime.dwHighDateTime;
    }
    
    if (patime)
    {
        patime->dwLowDateTime  = statstg.atime.dwLowDateTime;
        patime->dwHighDateTime = statstg.atime.dwHighDateTime;
    }
    
    if (pmtime)
    {
        pmtime->dwLowDateTime  = statstg.mtime.dwLowDateTime;
        pmtime->dwHighDateTime = statstg.mtime.dwHighDateTime;
    }
    
    return NO_ERROR;
}


HRESULT __stdcall CITFileSystem::CImpITFileSystem::ReallocEntry
                      (PathInfo *pPathInfo, CULINT ullcbNew, BOOL fCopyContent)
{
    CSyncWith sw(m_cs);

    CULINT ullBaseNew;
    
    HRESULT hr = m_pFreeListManager->GetFreeSpace(&ullBaseNew, &ullcbNew);

    if (SUCCEEDED(hr) & fCopyContent)
    {
        CULINT ullcb;
        
        ullcb = pPathInfo->ullcbData;

        if (ullcb > ullcbNew)
            ullcb = ullcbNew;

        hr = IITLockBytes::CopyLockBytes(m_pLKBMedium, pPathInfo->ullcbOffset, 
                                         pPathInfo->ullcbOffset + ullcb, 
                                         m_pLKBMedium, ullBaseNew
                                        );
    }
    
    if (SUCCEEDED(hr))
    {
        hr = m_pFreeListManager->PutFreeSpace(pPathInfo->ullcbOffset, pPathInfo->ullcbData);

        RonM_ASSERT(SUCCEEDED(hr));

        pPathInfo->ullcbOffset = ullBaseNew;
        pPathInfo->ullcbData   = ullcbNew;
    }
    else
    {
        HRESULT hr = m_pFreeListManager->PutFreeSpace(ullBaseNew, ullcbNew);

        RonM_ASSERT(SUCCEEDED(hr));
    }

    IITPathManager *pPathManager = PathMgr(pPathInfo);

    if (SUCCEEDED(hr))
        if (m_pSysPathManager == pPathManager)
            m_pSysPathManager->UpdateEntry(pPathInfo);
        else
        if (++(pPathInfo->cUnrecordedChanges) > PENDING_CHANGE_LIMIT)
            UpdatePathInfo(pPathInfo);

    return hr;
}


HRESULT __stdcall CITFileSystem::CImpITFileSystem::ReallocInPlace
                      (PathInfo *pPathInfo, CULINT ullcbNew)
{
    CSyncWith sw(m_cs);

    HRESULT hr = NO_ERROR;

    if (!(pPathInfo->ullcbData.NonZero())) // Currently empty?
    {
        if (ullcbNew.NonZero())
             hr = ReallocEntry(pPathInfo, ullcbNew, FALSE);

        return hr;
    }

    if (pPathInfo->ullcbData == ullcbNew)
        return hr;

    IITPathManager *pPathManager = PathMgr(pPathInfo);

    if (pPathInfo->ullcbData > ullcbNew) 
    {
        CULINT ullBaseTrailing, ullcbTrailing;

        ullBaseTrailing = pPathInfo->ullcbOffset + ullcbNew;
        ullcbTrailing   = pPathInfo->ullcbData   - ullcbNew;
        
        // Shrinking always works...
        
        hr = m_pFreeListManager->PutFreeSpace(ullBaseTrailing, ullcbTrailing);

        RonM_ASSERT(SUCCEEDED(hr));

        if (SUCCEEDED(hr))
        {
            pPathInfo->ullcbData = ullcbNew;

            if (m_pSysPathManager == pPathManager)
                m_pSysPathManager->UpdateEntry(pPathInfo);
            else
            if (++(pPathInfo->cUnrecordedChanges) > PENDING_CHANGE_LIMIT)
                UpdatePathInfo(pPathInfo);
        }

        return hr;
    }

    ullcbNew -= pPathInfo->ullcbData;
    
    hr = m_pFreeListManager->GetFreeSpaceAt
             (pPathInfo->ullcbOffset + pPathInfo->ullcbData, &ullcbNew);

    if (hr == S_OK)
    {
        pPathInfo->ullcbData += ullcbNew;

        if (m_pSysPathManager == pPathManager)
            m_pSysPathManager->UpdateEntry(pPathInfo);
        else
        if (++(pPathInfo->cUnrecordedChanges) > PENDING_CHANGE_LIMIT)
            UpdatePathInfo(pPathInfo);
    }

    return hr;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::EnumeratePaths
                      (WCHAR const *pwcsPathPrefix, IEnumSTATSTG **ppEnumStatStg)
{
    CSyncWith sw(m_cs);

    HRESULT hr = CEnumFSItems::NewFSEnumerator
                     (this, pwcsPathPrefix, wcsLen(pwcsPathPrefix), ppEnumStatStg);

    return hr;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::IsWriteable()
{
    return m_fReadOnly? S_FALSE : S_OK;
}

HRESULT __stdcall CITFileSystem::CImpITFileSystem::FSObjectReleased()
{
    if (m_cFSObjectRefs != UINT(-1))
    {
        RonM_ASSERT(m_cFSObjectRefs);

        AddRef(); // Because this object is about to disappear.

        m_cFSObjectRefs--;
    }

    return NO_ERROR;
}


HRESULT CITFileSystem::CImpITFileSystem::CSystemPathManager::Create
            (IUnknown *punkOuter, CImpITFileSystem *pITFileSystem, IITPathManager **ppPathMgr)
{
    CSystemPathManager *pSysPathMgr = New CSystemPathManager(punkOuter);

    return FinishSetup(pSysPathMgr? pSysPathMgr->m_PathManager.Init(pITFileSystem)
                                  : STG_E_INSUFFICIENTMEMORY,
                       pSysPathMgr, IID_PathManager, (PPVOID)ppPathMgr
                      );
}

CITFileSystem::CImpITFileSystem::CSystemPathManager::
          CImpIPathManager::CImpIPathManager(CSystemPathManager *pBackObj, IUnknown *punkOuter)
        : IITPathManager(pBackObj, punkOuter)
{
    m_pIITFS = NULL;    
}

HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CSystemPathManager::
            CImpIPathManager::Init(CImpITFileSystem *pITFileSystem)
{
    m_pIITFS = pITFileSystem;

    return NO_ERROR;
}

// IPersist Method:

HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CSystemPathManager::
            CImpIPathManager::GetClassID(CLSID __RPC_FAR *pClassID)
{
    *pClassID = CLSID_SystemPathManager;

    return NO_ERROR;
}

// IITPathManager interfaces:

HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CSystemPathManager::
            CImpIPathManager::FlushToLockBytes()
{
    RonM_ASSERT(FALSE); // To detect unexpected calls to this interface.

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CSystemPathManager::
            CImpIPathManager::FindEntry  (PPathInfo pPI   )
{
    RonM_ASSERT(pPI->cwcStreamPath       == 1);
    
    pPI->uStateBits          = 0;
    pPI->iLockedBytesSegment = 0;
    pPI->cUnrecordedChanges  = 0;

    switch(pPI->awszStreamPath[0])
    {
    case L'F':

        pPI->ullcbOffset = m_pIITFS->m_itfsh.offFreeListData;
        pPI->ullcbData   = m_pIITFS->m_itfsh. cbFreeListData;

        return NO_ERROR;

    case L'P':

        pPI->ullcbOffset = m_pIITFS->m_itfsh.offPathMgrData;
        pPI->ullcbData   = m_pIITFS->m_itfsh. cbPathMgrData;
        
        return NO_ERROR;

    default:

        RonM_ASSERT(FALSE);
        
        return STG_E_DOCFILECORRUPT;
    }
}

HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CSystemPathManager::
            CImpIPathManager::CreateEntry(PPathInfo pPINew, 
                                      PPathInfo pPIOld, 
                                      BOOL fReplace     )
{
    RonM_ASSERT(FALSE); // To detect unexpected calls to this interface.

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CSystemPathManager::
            CImpIPathManager::DeleteEntry(PPathInfo pPI   )
{
    RonM_ASSERT(FALSE); // To detect unexpected calls to this interface.

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CSystemPathManager::
            CImpIPathManager::UpdateEntry(PPathInfo pPI   )
{
    RonM_ASSERT(pPI->cwcStreamPath       == 1);
    RonM_ASSERT(pPI->iLockedBytesSegment == 0);
    
    switch(pPI->awszStreamPath[0])
    {
    case L'F':

        m_pIITFS->m_itfsh.offFreeListData = pPI->ullcbOffset;
        m_pIITFS->m_itfsh. cbFreeListData = pPI->ullcbData;
        pPI->cUnrecordedChanges = 0;

        m_pIITFS->m_fHeaderIsDirty = TRUE;

        return NO_ERROR;

    case L'P':

        m_pIITFS->m_itfsh.offPathMgrData = pPI->ullcbOffset;
        m_pIITFS->m_itfsh. cbPathMgrData = pPI->ullcbData;
        pPI->cUnrecordedChanges = 0;
        
        m_pIITFS->m_fHeaderIsDirty = TRUE;

        return NO_ERROR;

    default:

        RonM_ASSERT(FALSE);
        
        return STG_E_DOCFILECORRUPT;
    }
}

HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CSystemPathManager::
            CImpIPathManager::EnumFromObject(IUnknown *punkOuter, 
                                             const WCHAR *pwszPrefix, 
                                             UINT cwcPrefix, 
			                                 REFIID riid, 
                                             PVOID *ppv
			                                )
{
    RonM_ASSERT(FALSE); // To detect unexpected calls to this interface.

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CSystemPathManager::
            CImpIPathManager::GetPathDB(IStreamITEx *pTempPDBStrm, BOOL fCompact)            
{
    RonM_ASSERT(FALSE); // To detect unexpected calls to this interface.

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CSystemPathManager::
            CImpIPathManager::ForceClearDirty()            
{
    RonM_ASSERT(FALSE); // To detect unexpected calls to this interface.

    return E_NOTIMPL;
}

CITFileSystem::CImpITFileSystem::CEnumFSItems::CImpIEnumSTATSTG::CImpIEnumSTATSTG
    (CEnumFSItems *pBackObj, IUnknown *punkOuter)
             : IITEnumSTATSTG(pBackObj, punkOuter)
{
    m_pEnumPathMgr = NULL;
    m_pITFS        = NULL;
}

CITFileSystem::CImpITFileSystem::CEnumFSItems::CImpIEnumSTATSTG::~CImpIEnumSTATSTG()
{
    if (m_pEnumPathMgr)
        m_pEnumPathMgr->Release();

    if (m_pITFS)
        m_pITFS->Release();
}

HRESULT CITFileSystem::CImpITFileSystem::CEnumFSItems::NewFSEnumerator
            (CImpITFileSystem *pITFS, 
             const WCHAR *pwszPathPrefix, 
             UINT cwcPathPrefix,
             IEnumSTATSTG **ppEnumSTATSTG
            )
{
    CEnumFSItems *pEnumFS = New CEnumFSItems(NULL);

    CSyncWith sw(pITFS->m_cs);

    return FinishSetup(pEnumFS? pEnumFS->m_ImpEnumSTATSTG.InitFSEnumerator
                                    (pITFS, pwszPathPrefix, cwcPathPrefix)
                              : STG_E_INSUFFICIENTMEMORY,
                       pEnumFS, IID_IEnumSTATSTG, (PPVOID) ppEnumSTATSTG
                      );
}

HRESULT CITFileSystem::CImpITFileSystem::CEnumFSItems::NewCloneOf
            (CImpIEnumSTATSTG *pImpEnumFS, 
             IEnumSTATSTG **ppEnumSTATSTG
            )
{
    CEnumFSItems *pEnumFS = New CEnumFSItems(NULL);

    CSyncWith sw(pImpEnumFS->m_pITFS->m_cs);

    return FinishSetup(pEnumFS? pEnumFS->m_ImpEnumSTATSTG.InitNewCloneOf(pImpEnumFS)
                              : STG_E_INSUFFICIENTMEMORY,
                       pEnumFS, IID_IEnumSTATSTG, (PPVOID) ppEnumSTATSTG
                      );
}

HRESULT CITFileSystem::CImpITFileSystem::CEnumFSItems::CImpIEnumSTATSTG::InitNewCloneOf            (CImpIEnumSTATSTG *pImpEnumFS)
{
    m_pITFS = pImpEnumFS->m_pITFS;

    m_pITFS->AddRef();

    return pImpEnumFS->m_pEnumPathMgr->Clone(&m_pEnumPathMgr);
}

HRESULT CITFileSystem::CImpITFileSystem::CEnumFSItems::CImpIEnumSTATSTG::InitFSEnumerator
            (CImpITFileSystem *pITFS, const WCHAR *pwszPathPrefix, UINT cwcPathPrefix)
{
    m_pITFS = pITFS;

    m_pITFS->AddRef();

    HRESULT hr = m_pITFS->m_pPathManager->EnumFromObject
                     (NULL, pwszPathPrefix, cwcPathPrefix, IID_IEnumSTATSTG, 
                      (PVOID *) &m_pEnumPathMgr
			         );

    if (SUCCEEDED(hr))
        ((IITEnumSTATSTG *) m_pEnumPathMgr)->Container()->MarkSecondary();

    return hr;
}


HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CEnumFSItems::CImpIEnumSTATSTG::Next( 
    /* [in] */ ULONG celt,
    /* [in] */ STATSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched)
{
    return m_pEnumPathMgr->Next(celt, rgelt, pceltFetched);
}


HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CEnumFSItems::CImpIEnumSTATSTG::Skip( 
    /* [in] */ ULONG celt)
{
    return m_pEnumPathMgr->Skip(celt);
}


HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CEnumFSItems::CImpIEnumSTATSTG::Reset( 
    void)
{
    return m_pEnumPathMgr->Reset();
}

HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CEnumFSItems::CImpIEnumSTATSTG::Clone( 
    /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum)
{
    return CEnumFSItems::NewCloneOf(this, ppenum);
}

HRESULT CITFileSystem::CImpITFileSystem::DeactivateSpace(UINT iSpace)
{
    return DeactivateDataSpace(iSpace);
}

HRESULT CITFileSystem::CImpITFileSystem::GetFirstRecord(SEntry		*prec,
													   IStreamITEx	*pRecTblStrm,
	 												   int			cTblRecsInCache,
													   int			cTblRecsTotal,
													   SEntry		*pRecTblCache)
{
	HRESULT hr = NO_ERROR;

	RonM_ASSERT(cTblRecsTotal > 0);
 
	if (cTblRecsTotal == cTblRecsInCache)
	{
		CopyMemory(prec, (LPVOID)&pRecTblCache[0], sizeof(SEntry));
	}
	else
	{
		LARGE_INTEGER li = CLINT(0).Li();
		ULONG cbRead;

        if (SUCCEEDED(hr = pRecTblStrm->Seek(li, STREAM_SEEK_SET, NULL)))
		{
			if (SUCCEEDED(hr = pRecTblStrm->Read(prec, sizeof(SEntry), &cbRead)))
			{
				RonM_ASSERT(cbRead == sizeof(SEntry));
			}
		}
	}
	return hr;
}

HRESULT CITFileSystem::CImpITFileSystem::GetNextRecord(ULONG ulCurRec, SEntry *prec,
													   IStreamITEx		*pRecTblStrm,
	 												   int				cTblRecsInCache,
													   int				cTblRecsTotal,
													   SEntry			*pRecTblCache)
{
	RonM_ASSERT(cTblRecsTotal > 0);
	HRESULT hr = NO_ERROR;

	if (cTblRecsTotal == cTblRecsInCache)
	{
		if (ulCurRec == cTblRecsInCache)
			return S_FALSE;

		CopyMemory(prec, (LPVOID)&pRecTblCache[ulCurRec + 1], sizeof(SEntry));
	}
	else
	{
		ULONG cbRead;

        if (SUCCEEDED(hr = pRecTblStrm->Read(prec, sizeof(SEntry), &cbRead)))
		{
			RonM_ASSERT(cbRead == sizeof(SEntry));
		}
	}
	return S_OK;
}



HRESULT CITFileSystem::CImpITFileSystem::UpdatePathDB(IStreamITEx *pRecTblStrm, int cTblRecsInCache, 
														int cTblRecsTotal, SEntry *pRecTblCache,
														CITSortRecords *pSort)
{
	HRESULT hr = NO_ERROR;
	
	if (cTblRecsTotal == 0)
		return hr;

	IITEnumSTATSTG *pEnumPathMgr = NULL;
    ULONG ulCurEnumIndex;
	ULONG celtFetched = 1;
	UINT iDataSpace = FindSpaceName(pwcsUncompressedSpace);
	PathInfo pathInfo;

	if (SUCCEEDED(hr = m_pPathManager->EnumFromObject(NULL, L"//", 1, 
			           IID_IEnumSTATSTG, (PVOID *) &pEnumPathMgr)))
	{
		hr = pEnumPathMgr->GetFirstEntryInSeq(&pathInfo);
		ulCurEnumIndex = 0;
	}
	
	if (cTblRecsTotal == cTblRecsInCache)
	{
		for (int iRec = 0; SUCCEEDED(hr) && (iRec <  cTblRecsInCache); iRec++)
		{
			SEntry *pe = pRecTblCache + iRec;
			RonM_ASSERT(pe->ulEntryID > ulCurEnumIndex);
		
			ULONG cEntriesToSkip = (pe->ulEntryID - ulCurEnumIndex);
			
			for (int iEnum = 0; SUCCEEDED(hr) && (celtFetched > 0) && (iEnum < cEntriesToSkip); iEnum++)
			{
				hr = pEnumPathMgr->GetNextEntryInSeq(1, &pathInfo, &celtFetched);
				ulCurEnumIndex += 1;
			}//for
			
			RonM_ASSERT(pe->ulEntryID == ulCurEnumIndex);
			
			RonM_ASSERT (pathInfo.awszStreamPath[pathInfo.cwcStreamPath - 1] != L'/'
						&& pathInfo.awszStreamPath[pathInfo.cwcStreamPath - 1] != L'\\'
						&& pathInfo.iLockedBytesSegment == 0 // Uncompressed dataspace.
						&& pathInfo.ullcbData.NonZero());
						

			RonM_ASSERT(pathInfo.ullcbOffset >= pe->ullcbOffset);
						
			if (pathInfo.ullcbOffset != pe->ullcbOffset)
			{
				//wprintf(L"Name = %s, offset=%d newOffset =%d size= %d entryid= %d\n", pathInfo.awszStreamPath, (int)pathInfo.ullcbOffset.Ull(), (int)pe->ullcbOffset.Ull(), (int)pathInfo.ullcbData.Ull(), (int)pe->ulEntryID);
				pathInfo.ullcbOffset = pe->ullcbOffset;
				
				if (SUCCEEDED(hr = PathMgr(&pathInfo)->UpdateEntry(&pathInfo)))
					pathInfo.cUnrecordedChanges = 0;
			}
		
		}// update all records
	}
	else
	{
		BOOL fEndLoop = FALSE;
		int iCurBlk = -1;
		ULONG cRecsToRead;

		while (!fEndLoop && SUCCEEDED(hr))
		{
			if (SUCCEEDED(hr = pSort->ReadNextSortedBlk(&iCurBlk, (LPBYTE)pRecTblCache, &cRecsToRead, &fEndLoop)) && !fEndLoop)
			{
				for (int iRec = 0; SUCCEEDED(hr) && (iRec <  cRecsToRead); iRec++)
				{
					SEntry *pe = pRecTblCache + iRec;
					RonM_ASSERT(pe->ulEntryID > ulCurEnumIndex);
				
					ULONG cEntriesToSkip = (pe->ulEntryID - ulCurEnumIndex);

					for (int iEnum = 0; SUCCEEDED(hr) && (iEnum < cEntriesToSkip); iEnum++)
					{
						hr = pEnumPathMgr->GetNextEntryInSeq(1, &pathInfo, &celtFetched);
						ulCurEnumIndex += 1;
					}//for
					
					RonM_ASSERT(pe->ulEntryID == ulCurEnumIndex);
					
					RonM_ASSERT (pathInfo.awszStreamPath[pathInfo.cwcStreamPath - 1] != L'/'
						&& pathInfo.awszStreamPath[pathInfo.cwcStreamPath - 1] != L'\\'
						&& pathInfo.iLockedBytesSegment == 0 // Uncompressed dataspace.
						&& pathInfo.ullcbData.NonZero());

					RonM_ASSERT(pathInfo.ullcbOffset >= pe->ullcbOffset);
					
									
					if (pathInfo.ullcbOffset != pe->ullcbOffset)
					{
						//wprintf(L"Name = %s, offset=%d newOffset =%d size= %d entryid= %d\n", pathInfo.awszStreamPath, (int)pathInfo.ullcbOffset.Ull(), (int)pe->ullcbOffset.Ull(), (int)pathInfo.ullcbData.Ull(), (int)pe->ulEntryID);
						pathInfo.ullcbOffset = pe->ullcbOffset;

						if (SUCCEEDED(hr = PathMgr(&pathInfo)->UpdateEntry(&pathInfo)))
							pathInfo.cUnrecordedChanges = 0;
					}
				}// update all records
			}//read next file block in sorted sequence
		}//while
	}//else

	if (pEnumPathMgr)				
		pEnumPathMgr->Release();

	return hr;
}

HRESULT CITFileSystem::CImpITFileSystem::SortRecTable(ESortField eSField,
													  IStreamITEx *pRecTblStrm,
													  int		 cTblRecsInCache,
													  int		 cTblRecsTotal,
													  SEntry	 *pRecTblCache,
													  CITSortRecords **ppSort)
{
	HRESULT hr = NO_ERROR;
	
	if (*ppSort == NULL)
	{
		*ppSort = (CITSortRecords *)New CITSortRecords;
		if (*ppSort == NULL)
			return STG_E_INSUFFICIENTMEMORY;
	}
	
	(*ppSort)->Initialize(pRecTblStrm, eSField, cTblRecsTotal, MAX_TABLE_RECS_INCACHE, sizeof(SEntry));
	

	if (*ppSort && cTblRecsTotal)
	{
		if (cTblRecsTotal == cTblRecsInCache)
		{
			(*ppSort)->QSort((LPBYTE)pRecTblCache, 0, cTblRecsInCache - 1, &CompareEntries); 
			VerifyData((LPBYTE)pRecTblCache, cTblRecsTotal, eSField, TRUE);
		}
		else
		{
			hr = (*ppSort)->FileSort(&CompareEntries);
		}
	}
	return hr;
}

int CITFileSystem::CImpITFileSystem::CompareEntries(SEntry e1, SEntry e2, ESortField eSField)
{
	if (eSField == SORT_BY_ENTRYID)
	{
		if (e1.ulEntryID < e2.ulEntryID)
			return -1;
		else if (e1.ulEntryID > e2.ulEntryID)
			return 1;
		else 
			return 0;
		//return ((long)e1.ulEntryID - (long)e2.ulEntryID);
	}
	else
	{
		if (e1.ullcbOffset < e2.ullcbOffset)
			return -1;
		else if (e1.ullcbOffset > e2.ullcbOffset)
			return 1;
		else return 0;
	}
}

HRESULT CITFileSystem::CImpITFileSystem::AppendToRecTbl(SEntry		*prec,
														IStreamITEx *pRecTblStrm,
														int			*pcTblRecsInCache,
														int			*pcTblRecsTotal,
													  	SEntry		*pRecTblCache)
{
	HRESULT hr = NO_ERROR;

	//printf("Entry[%d] offset= %d, entryid = %d, size = %d\n", 
	//				prec->ulEntryID, (int)prec->ullcbOffset.Ull(), 
	//				(int)prec->ulEntryID, (int)prec->ullcbData.Ull());
	
	if (*pcTblRecsInCache >= MAX_TABLE_RECS_INCACHE)
	{
		ULONG cbWritten;
		if (SUCCEEDED(hr = pRecTblStrm->Write((LPVOID)pRecTblCache, sizeof(SEntry)* (*pcTblRecsInCache), &cbWritten)))
		{
			RonM_ASSERT(cbWritten == sizeof(SEntry)*(*pcTblRecsInCache));
			*pcTblRecsInCache = 0;
		}
	}

	CopyMemory(&pRecTblCache[(*pcTblRecsInCache)++], prec, sizeof(SEntry));
	(*pcTblRecsTotal)++;
	return hr;
}

HRESULT CITFileSystem::CImpITFileSystem::InitRecTable(IStreamITEx **ppRecTblStrm,
													  int *pcTblRecsInCache,
													  int *pcTblRecsTotal,
													  SEntry **ppRecTblCache)
{

	*pcTblRecsInCache	 = 0;
	*pcTblRecsTotal		 = 0;
	*ppRecTblCache		 = NULL;
	*ppRecTblStrm		 = NULL;

	*ppRecTblCache = (SEntry *) New BYTE[sizeof(SEntry) * MAX_TABLE_RECS_INCACHE];

	if (*ppRecTblCache == NULL)
		return STG_E_INSUFFICIENTMEMORY;

	HRESULT hr = CreateTempStm(ppRecTblStrm);
	
	return hr;
}

HRESULT CITFileSystem::CImpITFileSystem::CreateTempStm(IStreamITEx **ppRecTblStrm)
{
	ILockBytes *pLKB = NULL;
	*ppRecTblStrm    = NULL;

    HRESULT hr = CFSLockBytes::CreateTemp(NULL, &pLKB);

    if (hr == S_OK)
    {
        hr = CStream::OpenStream(NULL,pLKB, STGM_READWRITE, (IStreamITEx **) ppRecTblStrm);

        if (hr != S_OK) 
            pLKB->Release();
		else
		{
			//(*ppRecTblStrm)->AddRef();
			LARGE_INTEGER uli = CLINT(0).Li();
			
			hr = (*ppRecTblStrm)->Seek(uli, STREAM_SEEK_SET, NULL);
		}
    }
	return hr;
}


HRESULT CITFileSystem::CImpITFileSystem::BuildUpEntryTable(ULONG	 *pulRecNum,
														 IStreamITEx *pRecTblStrm,
														 int		 *pcTblRecsInCache,
														 int		 *pcTblRecsTotal,
													  	 SEntry		 *pRecTblCache,
														 BOOL		 *pfNeedFileSort)
{
	//init out param
	*pcTblRecsTotal = *pcTblRecsInCache = 0;
	*pulRecNum = 0;

	IITEnumSTATSTG *pEnumPathMgr;
    HRESULT hr = NO_ERROR;
	
	if (SUCCEEDED(hr = m_pPathManager->EnumFromObject(NULL, L"//", 1, 
			           IID_IEnumSTATSTG, (PVOID *) &pEnumPathMgr)))
	{
		SEntry srec;
		ULONG celtFetched = 1;
		PathInfo pathInfo;
		UINT iDataSpace = FindSpaceName(pwcsUncompressedSpace);
		
		if (SUCCEEDED(hr = pEnumPathMgr->GetFirstEntryInSeq(&pathInfo)))
		{
		   if (pathInfo.awszStreamPath[pathInfo.cwcStreamPath - 1] != L'/'
				&& pathInfo.awszStreamPath[pathInfo.cwcStreamPath - 1] != L'\\'
				&& pathInfo.iLockedBytesSegment == 0 // Uncompressed dataspace.
				&& pathInfo.ullcbData.NonZero()
				)
			{
				srec.ullcbOffset = pathInfo.ullcbOffset;
				srec.ullcbData  = pathInfo.ullcbData ;
				srec.ulEntryID  = 0;
			
				AppendToRecTbl(&srec, pRecTblStrm, pcTblRecsInCache, 
							pcTblRecsTotal, pRecTblCache);
			}
			(*pulRecNum) += 1;
			
	
			while (SUCCEEDED(hr) && (celtFetched > 0))
			{
				if (SUCCEEDED(hr = pEnumPathMgr->GetNextEntryInSeq(1, &pathInfo, &celtFetched)) 
					&& (celtFetched > 0))
				{
					 if (pathInfo.awszStreamPath[pathInfo.cwcStreamPath - 1] != L'/'
						&& pathInfo.awszStreamPath[pathInfo.cwcStreamPath - 1] != L'\\'
						&& pathInfo.iLockedBytesSegment == 0 // Uncompressed dataspace.
						&& pathInfo.ullcbData.NonZero())
					{
						srec.ullcbOffset = pathInfo.ullcbOffset;
						srec.ullcbData  = pathInfo.ullcbData ;
						srec.ulEntryID = *pulRecNum;

						AppendToRecTbl(&srec, pRecTblStrm, pcTblRecsInCache, 
							pcTblRecsTotal, pRecTblCache);
					}
					(*pulRecNum) += 1;
				}
			}
		}
		
	
		*pfNeedFileSort = (*pcTblRecsTotal > *pcTblRecsInCache);
	
		pEnumPathMgr->Release();
	}
	return hr;
}

void CITFileSystem::CImpITFileSystem::SetCompaction(BOOL fSet)
{
	if (fSet)
		m_itfsh.fFlags |= Compacting;
	else
		m_itfsh.fFlags &= ~Compacting;

    m_fHeaderIsDirty = TRUE;
}

HRESULT CITFileSystem::CImpITFileSystem::Compact(ECompactionLev iLev)
{
	IStreamITEx		*pRecTblStrm  = NULL;
	SEntry			*pRecTblCache = NULL;
	CITSortRecords  *pSort		  = NULL;

	int			cTblRecsInCache;
	int			cTblRecsTotal;
	BOOL		fNeedFileSort;
	ULONG		cRecsToRead;
	ULONG		ulRecNum;
	HRESULT		hr;


	if(SUCCEEDED(hr = InitRecTable(&pRecTblStrm, &cTblRecsInCache, &cTblRecsTotal, &pRecTblCache)))
	{
		if(SUCCEEDED(hr = BuildUpEntryTable(&ulRecNum, pRecTblStrm, &cTblRecsInCache, 
								&cTblRecsTotal, pRecTblCache, &fNeedFileSort)))
		{
			//write the remaining buffer to the stream
			if (fNeedFileSort)
			{
				ULONG cbWritten;
				if (SUCCEEDED(hr) && SUCCEEDED(hr = pRecTblStrm->Write((LPVOID)pRecTblCache, 
					sizeof(SEntry)*cTblRecsInCache, &cbWritten)))
				{
					RonM_ASSERT(cbWritten == (sizeof(SEntry) * cTblRecsInCache));
					cTblRecsInCache = 0;
				}
			}
#if 1
		//test code
			if (!fNeedFileSort)
				VerifyData((LPBYTE)pRecTblCache, cTblRecsTotal, SORT_BY_ENTRYID, TRUE);
			else
			{
				int cNumBlks = cTblRecsTotal/MAX_TABLE_RECS_INCACHE;
				int cEntriesInLastBlk;
				
				if (cEntriesInLastBlk = cTblRecsTotal % MAX_TABLE_RECS_INCACHE)
				{
					cNumBlks ++; 
				}
				
				ULONG cbToRead, cbRead;
				LARGE_INTEGER uli = CLINT(0).Li();
				hr = pRecTblStrm->Seek(uli, STREAM_SEEK_SET, NULL);

				for (int iCurBlk = 0; (iCurBlk < cNumBlks) && SUCCEEDED(hr); iCurBlk++)
				{
					//read block in sorted sequence
					if (iCurBlk == (cNumBlks -1))
						cbToRead = cEntriesInLastBlk * sizeof(SEntry);
					else
						cbToRead = MAX_TABLE_RECS_INCACHE * sizeof(SEntry);

					if (SUCCEEDED(hr = pRecTblStrm->Read((LPBYTE)pRecTblCache, cbToRead, &cbRead)))
					{
						RonM_ASSERT(cbRead == cbToRead);

						VerifyData((LPBYTE)pRecTblCache, cbToRead/sizeof(SEntry), SORT_BY_ENTRYID, iCurBlk == 0);
						
					}			
				}//for
			}
	//end test code

#endif
			ESortField eSortType = SORT_BY_OFFSET;
			
			if (cTblRecsTotal && SUCCEEDED(hr = SortRecTable(eSortType, pRecTblStrm, 
								cTblRecsInCache, cTblRecsTotal, pRecTblCache, &pSort)))
			{	
				IStreamITEx *pTempDataStrm, *pTempPDBStrm;
 				if (SUCCEEDED(hr = CreateTempStm(&pTempDataStrm)) 
					&& SUCCEEDED(hr = CreateTempStm(&pTempPDBStrm)))
				{
					cRecsToRead = MAX_TABLE_RECS_INCACHE;
					CULINT ullCompactedOffset = CULINT(0);
					
					if (fNeedFileSort)
					{
						BOOL fEndLoop = FALSE;
						int iCurBlk = -1;
						
						while (!fEndLoop && SUCCEEDED(hr))
						{
							if (SUCCEEDED(hr = pSort->ReadNextSortedBlk(&iCurBlk, (LPBYTE)pRecTblCache, &cRecsToRead, &fEndLoop)))
							{
								//compact data pointed by read block and update block
								if (!fEndLoop && SUCCEEDED(hr = CompactData((LPBYTE)pRecTblCache, cRecsToRead, &ullCompactedOffset, pTempDataStrm)))
								{
									VerifyData((LPBYTE)pRecTblCache, cRecsToRead, SORT_BY_OFFSET, TRUE);
									hr = pSort->WriteBlk(iCurBlk, (LPBYTE)pRecTblCache, cRecsToRead);
								}
							}//read next file block in sorted sequence
						}//while
					}
					else if (SUCCEEDED(hr))
					{
						//compact data pointed by path entries in cached block
						hr = CompactData((LPBYTE)pRecTblCache, cTblRecsInCache, &ullCompactedOffset, pTempDataStrm);
						VerifyData((LPBYTE)pRecTblCache, cTblRecsInCache, SORT_BY_OFFSET, TRUE);
					}
									
					if (SUCCEEDED(hr))
					{
						eSortType = SORT_BY_ENTRYID;
						if (SUCCEEDED(hr = SortRecTable(eSortType, pRecTblStrm, 
								cTblRecsInCache, cTblRecsTotal, pRecTblCache, &pSort)))
						{
							if (SUCCEEDED(hr = UpdatePathDB(pRecTblStrm, cTblRecsInCache,
								cTblRecsTotal, pRecTblCache, pSort)))
							{
								//commit all the updates to the disk and reload m_pPathManager
								hr = m_pPathManager->FlushToLockBytes(); 
							
								//get a copy of updated path DB with or without compaction
								if (SUCCEEDED(hr) && SUCCEEDED(hr = GetPathDB(pTempPDBStrm, iLev == COMPACT_DATA_AND_PATH)))
								{
									//putting all pieces together
									
									//updated header, empty free list, updated path DB and compacted data
									hr = CompactFileSystem(pTempPDBStrm, pTempDataStrm);
								}
							}
						}
					}
					
					pTempDataStrm->Release();

					pTempPDBStrm->Release();
					
				}//CreateTmpStrm
			}//SortRecTable
		}//BuildUpEntryTable
	}//InitRecTable

	if (pSort)
		delete pSort;
			
	if (pRecTblStrm)
		pRecTblStrm->Release();

	if (pRecTblCache)
		delete pRecTblCache;

	return hr;
}

HRESULT __stdcall CITFileSystem::Compact(const WCHAR * pwcsName, ECompactionLev iLev)
{
	CSyncWith sw(g_csITFS);
	
	HRESULT hr;
	
    CImpITFileSystem *pITFS = (CImpITFileSystem *)CImpITFileSystem::FindFileSystem(pwcsName);
	if(!pITFS)
	{
		ILockBytes *pLKB = NULL;
    
		if (SUCCEEDED(hr = CFSLockBytes::Open(NULL, pwcsName, 
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            &pLKB
                           )))
		{
			
			CITFileSystem *pITFSout = New CITFileSystem(NULL);

			if (!pITFSout)
			{
				return STG_E_INSUFFICIENTMEMORY;
			}
			
			pITFS = &(pITFSout->m_ImpITFileSystem);
			
			pITFS->AddRef();
			pITFS->AddRef();
			
			//To match reference count trick in InitOpenOnLockBytes
			pITFSout->AddRef();
					
			hr = pITFS->InitOpenOnLockBytes(pLKB, STGM_READWRITE | STGM_SHARE_EXCLUSIVE);
		
			pLKB->Release();
			pITFSout->Release();

			pITFS->SetCompaction(TRUE);
		}
	}
    else
	{
		pITFS->Release();
		return E_FAIL;
	}

	if (SUCCEEDED(hr))
	{
		hr = pITFS->Compact(iLev);
	}
	
	if (pITFS)
	{
		pITFS->SetCompaction(FALSE);
		pITFS->Release();
		pITFS->Release();
	}	

	return hr;
}
/*

HRESULT  CITFileSystem::CImpITFileSystem::SaveTransformedSpace(IStreamITEx **ppTempStrm, ULARGE_INTEGER *pcbSaved)
{
    HRESULT	hr = NO_ERROR;
	WCHAR   awszStreamPath[256];
	
	//Copy tranformed space to a temporary stream
	wcsCpy(awszStreamPath, pwcsSpaceNameStorage);
    wcsCat(awszStreamPath, pwcsLZXSpace);
    wcsCat(awszStreamPath, pwcsSpaceContentSuffix);

	*pcbSaved = CULINT(0).Uli();
	*ppTempStrm = NULL;

	IStreamITEx *pXStream; 

	if (SUCCEEDED(hr = OpenStream(NULL, awszStreamPath, 0, &pXStream)))
	{
		STATSTG statstg;
		if (SUCCEEDED(hr = pXStream->Stat(&statstg, STATFLAG_NONAME)))
		{
			*pcbSaved = statstg.cbSize;
			if (SUCCEEDED(hr = CreateTempStm(ppTempStrm)))
			{
				ULARGE_INTEGER cbRead, cbWritten;
				if (SUCCEEDED(hr = pXStream->CopyTo(*ppTempStrm, statstg.cbSize, &cbRead, &cbWritten)))
				{
					RonM_ASSERT(CULINT(cbRead) == CULINT(cbWritten));
				}//CopyTo
			}//CreateTempStm
		}//Stat
		pXStream->Release();
	}//OpenStream

	return hr;
}
*/

HRESULT  CITFileSystem::CImpITFileSystem::DumpStream(IStreamITEx *pTempStrm, LPSTR pFileName)
{
	HRESULT hr = NO_ERROR;
#if 0 //test code
	FILE *file = fopen(pFileName, "w" );

	if (file != NULL)
	{
		RonM_ASSERT(pTempStrm != NULL);
		HRESULT	hr = NO_ERROR;
		BYTE	lpBuf[2048];

		if (SUCCEEDED(hr = pTempStrm->Seek(CLINT(0).Li(), STREAM_SEEK_SET, 0)))
		{
			ULONG		   cbToRead = sizeof(lpBuf);
			ULONG		   cbWritten;
			ULONG		   cbRead = cbToRead;
				
			while (SUCCEEDED(hr) && (cbRead == cbToRead))
			{
				if (SUCCEEDED(hr = pTempStrm->Read(lpBuf, cbToRead, &cbRead)))
				{
					cbWritten = fwrite(lpBuf, sizeof(BYTE), cbRead, file);
					RonM_ASSERT(cbRead == cbWritten);
					if (cbRead != cbWritten)
						hr = E_FAIL;
				}//ReadAt
			}//while

		}//seek
 
		fclose(file);
	}
	else
		hr = E_FAIL;

#endif //end test code
return hr;
}


HRESULT  CITFileSystem::CImpITFileSystem::CopyStream(IStreamITEx *pTempStrm, CULINT *pullCompactedOffset)
{
	RonM_ASSERT(pTempStrm != NULL);

	HRESULT	hr = NO_ERROR;
	BYTE	lpBuf[2048];

	if (SUCCEEDED(hr = pTempStrm->Seek(CLINT(0).Li(), STREAM_SEEK_SET, 0)))
	{
		ULONG		   cbToRead = sizeof(lpBuf);
		ULONG		   cbWritten;
		ULONG		   cbRead = cbToRead;
			
		while (SUCCEEDED(hr) && (cbRead == cbToRead))
		{
			if (SUCCEEDED(hr = pTempStrm->Read(lpBuf, cbToRead, &cbRead)))
			{
				if (SUCCEEDED(hr = m_pLKBMedium->WriteAt((*pullCompactedOffset).Uli(), lpBuf, cbRead, &cbWritten)))
				{
					RonM_ASSERT(cbRead == cbWritten);
					*pullCompactedOffset += cbWritten;						
				}//WriteAt
			}//ReadAt
		}//while

	}//seek

	return hr;
}

HRESULT  CITFileSystem::CImpITFileSystem:: CompactFileSystem(IStreamITEx *pTempPDBStrm, IStreamITEx *pTempDataStrm)
{
	STATSTG statstg1, statstg2;
	HRESULT hr;

	if (SUCCEEDED(hr = pTempPDBStrm->Stat(&statstg1, STATFLAG_NONAME))
		&& SUCCEEDED(hr = pTempDataStrm->Stat(&statstg2, STATFLAG_NONAME)))
	{
		ULONG         cbRead = 0;
		ULARGE_INTEGER cbFreeListSize;

		m_pFreeListManager->SetFreeListEmpty();
		m_pFreeListManager->GetSizeMax(&cbFreeListSize);

		//upgrade the version no.
		m_itfsh.uFormatVersion = CurrentFileFormatVersion;
		m_itfsh.cbHeaderSize = sizeof(m_itfsh);
		m_itfsh.offFreeListData = m_itfsh.cbHeaderSize; 
		m_itfsh.cbFreeListData = cbFreeListSize;
		m_itfsh.offPathMgrData = m_itfsh.offFreeListData + m_itfsh.cbFreeListData; 
		m_itfsh.cbPathMgrData = CULINT(statstg1.cbSize); 
		m_itfsh.offPathMgrOrigin = m_itfsh.offPathMgrData + m_itfsh.cbPathMgrData;

		if (SUCCEEDED(hr = m_pLKBMedium->WriteAt(CULINT(0).Uli(), &m_itfsh, sizeof(m_itfsh), &cbRead)))
		{
			//write free list
			ULARGE_INTEGER cbSpaceSize = (m_itfsh.cbHeaderSize + CULINT(cbFreeListSize)
										 + CULINT(statstg1.cbSize) + CULINT(statstg2.cbSize)).Uli();
			
			m_pFreeListManager->SetSpaceSize(cbSpaceSize);

            hr = m_pFreeListManager->RecordFreeList();

            RonM_ASSERT(hr == S_OK);
			
			if (SUCCEEDED(hr))
			{
				m_pPathManager->ForceClearDirty();
			
#if 0 //test code
				hr = DumpStream(pTempPDBStrm, "c:\\test.PDB");
				
				hr = DumpStream(pTempDataStrm, "c:\\test.DAT");
#endif//end test code

				CULINT ullOffset = m_itfsh.offPathMgrData;

				if (SUCCEEDED(hr = CopyStream(pTempPDBStrm, &ullOffset)))
				{
					RonM_ASSERT((ullOffset - m_itfsh.offPathMgrData) == CULINT(statstg1.cbSize));
				
					ullOffset = m_itfsh.offPathMgrOrigin;

					if (SUCCEEDED(hr = CopyStream(pTempDataStrm, &ullOffset)))
					{
						RonM_ASSERT((ullOffset - m_itfsh.offPathMgrOrigin) == CULINT(statstg2.cbSize));
						hr = m_pLKBMedium->SetSize(cbSpaceSize);
					}
				}//copying temp path DB stream
			}//copying free list
		}//copying header
	}//getting size of path database
	return hr;
}
										
HRESULT  CITFileSystem::CImpITFileSystem::GetPathDB(IStreamITEx *pTempPDBStrm, BOOL fCompact)
{
	return m_pPathManager->GetPathDB(pTempPDBStrm, fCompact);
}


HRESULT CITFileSystem::CImpITFileSystem::ForceClearDirty()
{
	return m_pPathManager->ForceClearDirty();
}


HRESULT  CITFileSystem::CImpITFileSystem::CompactData(LPBYTE pRecTableCache, ULONG cEntries, CULINT *pullCompactedOffset, IStreamITEx *pTempDataStrm)
{
	SEntry	 *pe;
	BYTE	 lpBuf[4096];
	HRESULT	 hr = NO_ERROR;
	ULONG	 cEntriesCompacted = 0, iEntry = 0;
	CULINT    cbToReadTotal;
	ULONG    ceFollowing;
	ULARGE_INTEGER uli;
	SEntry	 *pe1, *pe2;

 	while (iEntry < cEntries)
	{
		//Finding all the consequtive compacted entries
		BOOL	fDone		= FALSE;
		ceFollowing = 0;
		
		pe1 = (SEntry *)(pRecTableCache + iEntry * sizeof(SEntry));
		cbToReadTotal = pe1->ullcbData;

		while (!fDone)
		{
			pe2 = (SEntry *)(pRecTableCache + (iEntry + ceFollowing + 1) * sizeof(SEntry));
			if (pe2->ullcbOffset == (pe1->ullcbOffset + pe1->ullcbData))
			{
				ceFollowing++;
				cbToReadTotal += pe2->ullcbData;
				pe1 = pe2;
			}
			else 
				fDone = TRUE;
		}
		
		pe = (SEntry *)(pRecTableCache + iEntry * sizeof(SEntry));
		uli				= (pe->ullcbOffset + m_itfsh.offPathMgrOrigin).Uli();
		
		RonM_ASSERT(*pullCompactedOffset <= CULINT(uli));

		ULONG		   cbToRead;
		ULONG		   cbReadTotal  = 0;
		ULONG		   cbWritten;
		ULONG		   cbRead;
			
		while ((cbReadTotal != cbToReadTotal) && SUCCEEDED(hr))
		{
			cbToRead = (long)(cbToReadTotal - CULINT(cbReadTotal)).Ull();
			
			if (cbToRead >= sizeof(lpBuf))
				cbToRead = sizeof(lpBuf);

			if (SUCCEEDED(hr = m_pLKBMedium->ReadAt(uli, lpBuf, cbToRead, &cbRead)))
			{
				RonM_ASSERT(cbRead == cbToRead);

				if (SUCCEEDED(hr = pTempDataStrm->Write(lpBuf, cbRead, &cbWritten)))
				{
					RonM_ASSERT(cbRead == cbWritten);
					cbReadTotal += cbToRead;
					uli = (CULINT(uli) + cbWritten).Uli();
					
				}//WriteAt
			}//ReadAt
		}//while

		RonM_ASSERT(cbReadTotal == cbToReadTotal);
			
		pe->ullcbOffset = *pullCompactedOffset;
		
		memCpy(pRecTableCache + iEntry * sizeof(SEntry), pe, sizeof(SEntry));
		*pullCompactedOffset += cbToReadTotal;
			
		SEntry *pePrev = pe;
		
		//modify the path info for following compacted entries
		for (int i = iEntry + 1; i < (iEntry + ceFollowing + 1); i++)
		{
			pe = (SEntry *)(pRecTableCache + i * sizeof(SEntry));
			pe->ullcbOffset = pePrev->ullcbOffset + pePrev->ullcbData;
			memCpy(pRecTableCache + i * sizeof(SEntry), pe, sizeof(SEntry));
			pePrev = pe;
		}
		
		iEntry += (ceFollowing + 1);
	}//while


	return hr;
}

void  CITFileSystem::CImpITFileSystem::VerifyData(LPBYTE pRecTableCache, ULONG cEntries, ESortField eSType, BOOL fReset)
{
#ifdef _DEBUG
	
	static int cEntry;
	static CULINT ullLastEntryOffset = CULINT(0);
	static UINT ulLastEntryID = 0;

	if (fReset)
	{
		cEntry = 0;
		ullLastEntryOffset = CULINT(0);
		ulLastEntryID = 0;
	}

	//printf("Verifying original entries from file After Sort\n");
	for (int iEntry = 0; iEntry < cEntries; iEntry++, cEntry++)
	{
		SEntry *pe = (SEntry *)(pRecTableCache + iEntry * sizeof(SEntry));
		//printf("Entry[%d] offset= %d, entryid = %d, size = %d\n", 
		//	cEntry, (int)pe->ullcbOffset.Ull(), (int)pe->ulEntryID, (int)pe->ullcbData.Ull());
		
		//RonM_ASSERT(cEntry == pe->ulEntryID);
		if (eSType == SORT_BY_OFFSET)
			RonM_ASSERT(pe->ullcbOffset >= ullLastEntryOffset);
		else
			RonM_ASSERT(pe->ulEntryID >= ulLastEntryID);

		ullLastEntryOffset = pe->ullcbOffset;
		ulLastEntryID = pe->ulEntryID;

	}
	//printf("** End Verifying original entries **\n");
#endif
}


HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CEnumFSItems::CImpIEnumSTATSTG::GetNextEntryInSeq
                              (ULONG celt, PathInfo *rgelt, ULONG *pceltFetched)
{
	return E_NOTIMPL;  
}

HRESULT STDMETHODCALLTYPE CITFileSystem::CImpITFileSystem::CEnumFSItems::CImpIEnumSTATSTG::GetFirstEntryInSeq
                              (PathInfo *rgelt)
{
   return E_NOTIMPL;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\itunk.cpp ===
// ITUnk.cpp -- Implementation for our base level IUnknown interface

#include "stdafx.h"

CITCriticalSection CITUnknown::s_csUnk;
CITUnknown        *CITUnknown::s_pitunkActive; // = NULL;

void CITUnknown::CloseActiveObjects()
{
    while (s_pitunkActive)
    {
        CITUnknown *pitNext = s_pitunkActive;

        for (; pitNext; pitNext = pitNext->m_pitunkNext)
            if (!(pitNext->IsSecondary())) 
                break;

        RonM_ASSERT(pitNext);

        if (!pitNext) break;

        while (pitNext->Release() > 0);
    }
}

#ifdef _DEBUG

BOOL               CITUnknown::s_fCSInitialed; // = FALSE;

void CITUnknown::OpenReferee(void)
{
    // RonM_ASSERT(!s_fCSInitialed);

    if (s_fCSInitialed) // We can be called repeatedly because LoadLibrary                        
        return;         // causes a Process_Attach!

    s_fCSInitialed= TRUE;
}

void CITUnknown::CloseReferee(void)
{
    RonM_ASSERT(s_fCSInitialed); // BugBug: Can UnloadLibrary cause a Process_Detach?

    s_fCSInitialed = FALSE;
}

#endif // _DEBUG

CITUnknown::CITUnknown(const IID *paIID, UINT cIID, IUnknown **papIFace)
{
    m_paIID    = paIID;
     m_cIID    =  cIID;
    m_papIFace = papIFace;
    m_pIFace   = NULL;

    CommonInitialing();
}

CITUnknown::CITUnknown(const IID *paIID, UINT cIID, IUnknown *pIFace)
{
    m_paIID    = paIID;
     m_cIID    =  cIID;
    m_pIFace   = pIFace;
    m_papIFace = NULL;

    CommonInitialing();
}
#if 0
CITUnknown::CITUnknown()
{
    m_paIID    = NULL;
     m_cIID    = 0;
    m_pIFace   = NULL;
    m_papIFace = NULL;

    CommonInitialing();
}
#endif // 0

void CITUnknown::Uncouple()
{
	CSyncWith sw(s_csUnk);

#ifdef _DEBUG

    BOOL fFoundThis = FALSE;
    
    CITUnknown *pITUnkNext = s_pitunkActive;

    for (;pITUnkNext; pITUnkNext = pITUnkNext->m_pitunkNext)
    {
        if (pITUnkNext == this)
        {
            RonM_ASSERT(!fFoundThis);

            fFoundThis = TRUE;
        }
    }

    RonM_ASSERT(fFoundThis);

#endif // _DEBUG

    if (m_pitunkPrev)
         m_pitunkPrev->m_pitunkNext = m_pitunkNext;
    else s_pitunkActive             = m_pitunkNext;

    if (m_pitunkNext)
        m_pitunkNext->m_pitunkPrev = m_pitunkPrev;
}

void CITUnknown::MoveInFrontOf(CITUnknown *pITUnk)
{
    if (!pITUnk) 
        pITUnk = s_pitunkActive;
    
    CSyncWith sw(s_csUnk);

	RonM_ASSERT(pITUnk);
    RonM_ASSERT(pITUnk != this);

#ifdef _DEBUG

    BOOL fFoundThis = FALSE;
    BOOL fFoundThat = FALSE;
    
    CITUnknown *pITUnkNext = s_pitunkActive;

    for (;pITUnkNext; pITUnkNext = pITUnkNext->m_pitunkNext)
    {
        if (pITUnkNext == this)
        {
            RonM_ASSERT(!fFoundThis);

            fFoundThis = TRUE;
        }

        if (pITUnkNext == pITUnk)
        {
            RonM_ASSERT(!fFoundThat);

            fFoundThat = TRUE;
        }
    }

    RonM_ASSERT(fFoundThis && fFoundThat);
#endif // _DEBUG

    Uncouple();

    m_pitunkNext = pITUnk;
    m_pitunkPrev = pITUnk->m_pitunkPrev;

    pITUnk->m_pitunkPrev = this;

    if (m_pitunkPrev)
         m_pitunkPrev->m_pitunkNext = this;
    else s_pitunkActive             = this;
}

void CITUnknown::CommonInitialing()
{
    m_cRefs        = 0;
    m_fSecondary   = FALSE;
    m_fAlreadyDead = FALSE;

    pDLLServerState->ObjectAdded();

// #ifdef _DEBUG
	{
		CSyncWith sw(s_csUnk);

        m_pitunkPrev = NULL;
		m_pitunkNext = s_pitunkActive;

        if (m_pitunkNext) 
            m_pitunkNext->m_pitunkPrev = this;

		s_pitunkActive = this;
    }
// #endif // _DEBUG

#if 0 // #ifdef _DEBUG 
    
    // The loop below inserts this object at the head of the s_pitunkActive list.
    // This works correctly when multiple threads are simultaneously altering
    // the list. 

    for (;;)
    {

        // Note! InterlockedCompareExchange is an NT-only API.

        if (PVOID(m_pitunkNext) == InterlockedCompareExchange
                                     ((PVOID *)&s_pitunkActive, PVOID(this), 
                                       PVOID(m_pitunkNext)
                                     )
           )
            break;
    }
#endif // _DEBUG
}
  
STDMETHODIMP_(ULONG) CITUnknown::AddRef (void)
{
    return InterlockedIncrement(&m_cRefs);
}

STDMETHODIMP_(ULONG) CITUnknown::Release(void)
{
  /*
  
    Each COM object is reference counted and their destructor is
    invoked when the reference count goes from 1 to zero. 

    There are several often forgotten assumptions which go along
    with reference counting. For example each increment of the count
    is supposed to correspond to a pointer variable somewhere
    which points to the object. So whenever you call Release,
    you're also promising that the corresponding pointer variable
    no longer points to the released object. 

    If the calling code isn't disciplined about nulling out pointers
    when they're released, we can get subsequent calls to release an
    object that's already dead. One way to avoid that problem is to 
    use the DetachRef define (See ITUnk.h) to disconnect pointers 
    for objects derived from PCImpITUnknown. 

    However that still leaves the possibility of concurrent threads 
    simultaneously racing to detach the same pointer variable. In
    practice the way to deal with that problem is to put the call 
    to Release in one place in the calling code and to protect it
    with a critical section. 

    The other design issue with reference counts is circular references.
    For example if you create object A with one external reference and
    its constructor creates object B in turn which refers to A, we have
    two references -- one reference to A from the outside environment
    and one internal circular reference from A to B to A.

    If you let a circular reference come into being and take no further
    action, your object can never be destroyed. The way that we solve
    this problem in the ITSS code is to have the containing object ("A"
    in the example above) follow this discipline:

    1. In its contructor after the circular references have been
       created, it must first call AddRef to account for the external
       reference and then call Release once for each circular reference.

    2. In its destructor it must first call AddRef for each circular
       reference. 

    The code below makes that discipline work and also detects undisciplined
    situations. In particular it enforces the rule that an object is destroyed
    only once no matter how many times its reference count goes from one to
    zero.

   */

    RonM_ASSERT(m_cRefs > 0); 

    LONG cRefs= InterlockedDecrement(&m_cRefs);
    
    if (!cRefs)
    {
        RonM_ASSERT(!m_fAlreadyDead);

        if (!m_fAlreadyDead)       // No double jeopardy for zombies!
        {
            m_fAlreadyDead = TRUE; // To keep objects from dying more than once.

            delete this;
        }
    }

    return cRefs;
}

STDMETHODIMP CITUnknown::QueryInterface(REFIID riid, PPVOID ppv)
{
    IUnknown *pUnkResult = NULL;

    if (riid == IID_IUnknown) pUnkResult = this;
    else
    {
        RonM_ASSERT(!m_pIFace || !m_papIFace); // Can't use both...
        RonM_ASSERT( m_pIFace ||  m_papIFace); // Must have at least one. 
        
        IUnknown **ppUnk = m_papIFace;
        const IID *pIID  = m_paIID;
        
        for (UINT c = m_cIID; c--; pIID++)
        {
            IUnknown *pUnk = ppUnk? *ppUnk++ : m_pIFace;

            if (riid == *pIID)
            {
                pUnkResult = pUnk;
                break;
            }
        }    
        
        if (!pUnkResult) 
            return E_NOINTERFACE;
    }

    pUnkResult->AddRef();

    *ppv = pUnkResult;
    
    return NOERROR;
}

CITUnknown::~CITUnknown()
{
    pDLLServerState->ObjectReleased();

// #ifdef _DEBUG
//    RonM_ASSERT(s_fCSInitialed);

    Uncouple();

// #endif // _DEBUG

#if 0 // #ifdef _DEBUG 
    
    // The loop below removes this object from the s_pitunkActive list.
    // This works correctly when multiple threads are simultaneously altering
    // the list. 

    for (;;)
    {
        // We always make at least two passes through the list.
        // First we scan to locate our object and remove it from the list.
        // Then we scan the list again to verify that our object has been
        // removed. The verification scan is necessary given that other
        // threads may be modifying the list at the same time.
        
        BOOL fFound = FALSE;

        for (CITUnknown **ppitunk= &s_pitunkActive; *ppitunk; 
             ppitunk= &((*ppitunk)->m_pitunkNext)
            )
        {
            if (this != *ppitunk) continue;

            fFound= TRUE;

            // Note! InterlockedCompareExchange is an NT-only API.

            InterlockedCompareExchange((PVOID *) ppitunk, PVOID(m_pitunkNext), PVOID(this));
            
            break;
        }

        if (!fFound) break;
    }
#endif // _DEBUG
}

HRESULT CITUnknown::FinishSetup(HRESULT hr, CITUnknown *pUnk, REFIID riid, PPVOID ppv)
{
	if (SUCCEEDED(hr))
    {
        pUnk->AddRef();

        CImpITUnknown *pImp;
        
        hr = pUnk->QueryInterface(riid, (PPVOID) &pImp);

        if (SUCCEEDED(hr)) 
        {
            if (riid != IID_IUnknown && pImp->HasControllingUnknown())
            {
                hr = CLASS_E_NOAGGREGATION;

                pImp->Release();  pImp = NULL;
            }
        }

        *ppv = (PVOID) pImp;

        pUnk->Release();
    }
    else
        if (pUnk) delete pUnk;

    return hr;
}

CImpITUnknown::CImpITUnknown(CITUnknown *pBackObj, IUnknown *punkOuter)
{
    m_fControlled        = punkOuter != NULL;
    m_pUnkOuter          = m_fControlled? punkOuter : pBackObj;
    m_pBackObj           = pBackObj;
    m_fActive            = FALSE;
    m_pImpITUnknownNext  = NULL;
    m_ppImpITUnknownList = NULL;
}

CImpITUnknown::~CImpITUnknown()
{
    if (m_fActive)
        MarkInactive();
}

STDMETHODIMP_(ULONG) CImpITUnknown::AddRef (void)
{
    return m_pUnkOuter->AddRef();
}

void CImpITUnknown::DetachReference(PCImpITUnknown &pITUnk)
{
    PCImpITUnknown pITUnkTmp = pITUnk;

    pITUnk = NULL;

    pITUnkTmp->Release();
}

STDMETHODIMP_(ULONG) CImpITUnknown::Release(void)
{
    return m_pUnkOuter->Release();
}

STDMETHODIMP CImpITUnknown::QueryInterface(REFIID riid, PPVOID ppv)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);
}

void CImpITUnknown::MarkActive(PCImpITUnknown &pListStart)
{
    RonM_ASSERT(!m_fActive);
    RonM_ASSERT(!m_ppImpITUnknownList);

    m_ppImpITUnknownList = &pListStart;
    m_pImpITUnknownNext  =  pListStart;
    pListStart           =  this;
    m_fActive            =  TRUE;
}

void CImpITUnknown::MarkInactive()
{
    RonM_ASSERT(m_fActive);
    RonM_ASSERT(m_ppImpITUnknownList);

    PCImpITUnknown *ppImpITUnk = m_ppImpITUnknownList;

    RonM_ASSERT(*ppImpITUnk);

    for (;;)
    {
        CImpITUnknown *pImpITUnk = *ppImpITUnk;

        if (pImpITUnk == this)
        {
            *ppImpITUnk          = m_pImpITUnknownNext;
            m_ppImpITUnknownList = NULL;
            m_fActive            = FALSE;

            return;
        }

        RonM_ASSERT(pImpITUnk->m_pImpITUnknownNext);

        ppImpITUnk = &(pImpITUnk->m_pImpITUnknownNext);
    }
    
    RonM_ASSERT(FALSE);  // Should have found this object in the chain.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\itsfs.h ===
// ITSFS.H -- Declaration of the CITFileSystem class

#ifndef __ITSFS_H__

#define __ITSFS_H__

const UINT MAGIC_ITS_FILE = 'I' | ('T' << 8) | ('S' << 16) | ('F' << 24);
const UINT FirstReleasedVersion     = 2;
const UINT RelativeOffsetVersion    = 3;
const UINT CurrentFileFormatVersion = 3;

#define MAX_TABLE_RECS_INCACHE 1024

typedef struct _ITSFileHeaderV2
{
    UINT     uMagic;          // Should be set to MAGIC_ITS_FILE;
    UINT     uFormatVersion;  // Version number for file format
    UINT     cbHeaderSize;    // Size of this header in bytes.
    UINT     fFlags;          // State flag bits for the ITS file.
    DWORD    dwStamp;         // Content Version stamp; changes on every write.
    LCID     lcid;            // Locale Id for file.
    CLSID    clsidFreeList;   // Class id for the free list manager interface used in the file
    CLSID    clsidPathMgr;    // Class id for the path manager interface used in the file
    CULINT   offFreeListData; // Offset in bytes to free list data
    CULINT    cbFreeListData; // Size of free list data in bytes
    CULINT   offPathMgrData;  // Offset in bytes to Path Manager data
    CULINT    cbPathMgrData;  // Size of Path Manager data in bytes

} ITSFileHeaderV2, *PITSFileHeaderV2;


// In the ITSFileHeader structure each items is aligned on a natural boundary.
// That is WCHARs are on 2-byte boundarides, UINTs are on 4-byte boundaries, 
// CULINTs are on 8-byte boundaries, and CLSIDs are on 16-byte boundaries.
// Keeping them that way will avoid any alignment problems on RISC machines.

typedef struct _ITSFileHeader
{
    UINT     uMagic;          // Should be set to MAGIC_ITS_FILE;
    UINT     uFormatVersion;  // Version number for file format
    UINT     cbHeaderSize;    // Size of this header in bytes.
    UINT     fFlags;          // State flag bits for the ITS file.
    DWORD    dwStamp;         // Content Version stamp; changes on every write.
    LCID     lcid;            // Locale Id for file.
    CLSID    clsidFreeList;   // Class id for the free list manager interface used in the file
    CLSID    clsidPathMgr;    // Class id for the path manager interface used in the file
    CULINT   offFreeListData; // Offset in bytes to free list data
    CULINT    cbFreeListData; // Size of free list data in bytes
    CULINT   offPathMgrData;  // Offset in bytes to Path Manager data
    CULINT    cbPathMgrData;  // Size of Path Manager data in bytes
    CULINT   offPathMgrOrigin;// Coordinate origin offset wrapped around path manager offsets

} ITSFileHeader, *PITSFileHeader;

const DWORD ITSFS_CONTROL_VERSION     = 1;
const DWORD DEFAULT_DIR_BLOCK_SIZE    = 8192;
const DWORD DEFAULT_MIN_CACHE_ENTRIES = 20;

 // Bit flag definitions for ITSFileHeader::fFlags

 enum { Compacting       = 0x80,                   // file is being compacted
        VALID_OPEN_FLAGS = fDefaultIsCompression   // valid flag set when opening a file.  
 };

class CITFileSystem : public CITUnknown
{
public:

    // Creators:

    static HRESULT __stdcall CreateITFileSystem(IUnknown *punkOuter, const WCHAR * pwcsName, 
                                                DWORD grfMode,
                                                PITS_Control_Data pControlData,
                                                LCID lcid,
                                                IStorage ** ppstgOpen
                                               );

    static HRESULT __stdcall CreateITFSOnLockBytes(IUnknown *punkOuter, ILockBytes * pLKB, 
                                                    DWORD grfMode,
                                                    PITS_Control_Data pControlData,
                                                    LCID lcid,
                                                    IStorage ** ppstgOpen
                                                   );

    static HRESULT __stdcall QueryFileStampAndLocale
                                (const WCHAR *pwcsName, DWORD *pFileStamp, DWORD *pFileLocale);

    static HRESULT __stdcall QueryLockByteStampAndLocale
                                (ILockBytes * plkbyt, DWORD *pFileStamp, DWORD *pFileLocale);

    static HRESULT __stdcall IsITFile(const WCHAR * pwcsName);  
    
    static HRESULT __stdcall IsITLockBytes(ILockBytes * plkbyt);

    static HRESULT __stdcall OpenITFileSystem(IUnknown *punkOuter, const WCHAR * pwcsName, 
                                              DWORD grfMode,
                                              IStorageITEx ** ppstgOpen
                                             );

    static HRESULT __stdcall OpenITFSOnLockBytes(IUnknown *punkOuter, ILockBytes * pLKB, 
                                                 DWORD grfMode,
                                                 IStorageITEx ** ppstgOpen
                                                );

    static HRESULT __stdcall SetITFSTimes(WCHAR const * pwcsName,  FILETIME const * pctime, 
                                          FILETIME const * patime, FILETIME const * pmtime
                                         );


    static HRESULT __stdcall DefaultControlData(PITS_Control_Data *ppControlData);
	
    
	static HRESULT __stdcall Compact(const WCHAR * pwcsName, ECompactionLev iLev);

    // Destructor:

    ~CITFileSystem();

private:

    CITFileSystem(IUnknown *pUnkOuter);

    class CImpITFileSystem : public IITFileSystem
    {
    public:

        // Constructor:

        CImpITFileSystem(CITFileSystem *pITFileSystem, IUnknown *punkOuter);
        
        // Destructor:
        
        ~CImpITFileSystem(void);

        // Finding an active file system:

        static IITFileSystem *FindFileSystem(const WCHAR *pwcsPath);

        IStorageITEx   *FindActiveStorage  (const WCHAR *pwcsPath);
        ILockBytes *FindActiveLockBytes(const WCHAR *pwcsPath);

        // Initialers:

        HRESULT __stdcall InitCreateOnLockBytes(ILockBytes * pLKB, DWORD grfMode,
                                                PITS_Control_Data pControlData, LCID lcid
                                               );

        HRESULT __stdcall InitOpenOnLockBytes(ILockBytes * pLKB, DWORD grfMode);

        //garbage collection routines
		
		HRESULT GetFirstRecord(SEntry		*prec, 
								IStreamITEx *pRecTblStrm, 
								int 		cTblRecsInCache,
							    int			cTblRecsTotal,
							    SEntry		*pRecTblCache);
		
		HRESULT GetNextRecord(ULONG			ulCurRec, 
							  SEntry		*prec,
							  IStreamITEx   *pRecTblStrm, 
							  int 		    cTblRecsInCache,
							  int			cTblRecsTotal,
							  SEntry		*pRecTblCache);
		
		HRESULT SortRecTable(ESortField eSField,
							 IStreamITEx   *pRecTblStrm, 
							 int 		    cTblRecsInCache,
							 int			cTblRecsTotal,
							 SEntry		*pRecTblCache,
							 CITSortRecords **ppSort);
		
		HRESULT AppendToRecTbl(SEntry *prec,
							  IStreamITEx   *pRecTblStrm, 
							  int 		    *pcTblRecsInCache,
							  int			*pcTblRecsTotal,
							  SEntry		*pRecTblCache);
		
		static int		CompareEntries(SEntry e1, SEntry e2, ESortField eSField);
		
		HRESULT CreateTempStm(IStreamITEx **ppRecTblStrm);

		HRESULT InitRecTable( IStreamITEx   **ppRecTblStrm, 
							  int 		    *pcTblRecsInCache,
							  int			*pcTblRecsTotal,
							  SEntry		**ppRecTblCache);
		
		HRESULT BuildUpEntryTable(ULONG *pulRecNum,
								IStreamITEx *pRecTblStrm, 
							    int 		*pcTblRecsInCache,
							    int			*pcTblRecsTotal,
							    SEntry		*pRecTblCache,
								BOOL		*pfNeedFileSort);
		
		HRESULT CompactData(LPBYTE pRecTableCache, ULONG cEntries, CULINT *pullCompactedOffset, IStreamITEx *pTempDataStrm);
		HRESULT UpdatePathDB(IStreamITEx *pRecTblStrm, int cTblRecsInCache, 
								int cTblRecsTotal, SEntry *pRecTblCache, CITSortRecords *pSort);
		HRESULT GetPathDB(IStreamITEx *pTempPDBStrm, BOOL fCompact);
		HRESULT ForceClearDirty();
		void    SetCompaction(BOOL fSet);
		HRESULT Compact(ECompactionLev iLev);
		HRESULT CompactFileSystem(IStreamITEx *pTempPDBStrm, IStreamITEx *pTempDataStrm);
		HRESULT CopyStream(IStreamITEx *pTempStrm, CULINT *pullCompactedOffset);
		void VerifyData(LPBYTE pRecTableCache, ULONG cEntries, ESortField eSType, BOOL fReset);
		                                                                                                                                                                                                                                               HRESULT DumpStream(IStreamITEx *pTempStrm, LPSTR pFileName);

		// IUnknown methods:
        
        STDMETHODIMP_(ULONG) Release(void);

        // IITFileSystem methods:

        HRESULT __stdcall DeactivateSpace(UINT iSpace);

        CITCriticalSection& CriticalSection();

        HRESULT __stdcall FlushToLockBytes(); 
        
        HRESULT __stdcall CreateStorage  (IUnknown *pUnkOuter, const WCHAR *pwcsPathPrefix, 
                                          DWORD grfMode, IStorageITEx **ppStg);
        HRESULT __stdcall   OpenStorage  (IUnknown *pUnkOuter, const WCHAR *pwcsPath, 
                                          DWORD grfMode, IStorageITEx **ppstg);  
        HRESULT __stdcall CreateLockBytes(IUnknown *pUnkOuter, const WCHAR *pwcsPath,
                                          const WCHAR *pwcsDataSpaceName,
                                          BOOL fOverwrite, ILockBytes **ppLKB);
        HRESULT __stdcall   OpenLockBytes(IUnknown *pUnkOuter, const WCHAR *pwcsPath, 
                                                               ILockBytes **ppLKB);

        HRESULT __stdcall CreateStream(IUnknown *pUnkOuter, const WCHAR *pwcsPath, 
                                       DWORD grfMode, IStreamITEx **ppStrm);

        HRESULT __stdcall CreateStream
            (IUnknown *pUnkOuter, const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
             DWORD grfMode, IStreamITEx ** ppstm
            );
        
        HRESULT __stdcall   OpenStream(IUnknown *pUnkOuter, const WCHAR *pwcsPath, 
                                       DWORD grfMode, IStreamITEx **ppStream);

        HRESULT __stdcall ConnectStorage(CImpITUnknown *pStg);

        HRESULT __stdcall ConnectLockBytes(CImpITUnknown *pStg);
        
        HRESULT __stdcall DeleteItem(WCHAR const *pwcsName);

        HRESULT __stdcall RenameItem(WCHAR const *pwcsOldName, WCHAR const *pwcsNewName);

        HRESULT __stdcall UpdatePathInfo(PathInfo *pPathInfo);

        HRESULT __stdcall SetITFSTimes(FILETIME const * pctime, 
                                       FILETIME const * patime, 
                                       FILETIME const * pmtime
                                      );

        HRESULT __stdcall GetITFSTimes(FILETIME * pctime, 
                                       FILETIME * patime, 
                                       FILETIME * pmtime
                                      );

        HRESULT __stdcall ReallocEntry(PathInfo *pPathInfo, CULINT ullcbNew, 
                                       BOOL fCopyContent 
                                      );

        HRESULT __stdcall ReallocInPlace(PathInfo *pPathInfo, CULINT ullcbNew);


        HRESULT __stdcall EnumeratePaths(WCHAR const *pwcsPathPrefix, 
                                         IEnumSTATSTG **ppEnumStatStg
                                        );

        HRESULT __stdcall IsWriteable();

        HRESULT __stdcall FSObjectReleased();
		
		BOOL __stdcall IsCompacting() {	return (m_itfsh.fFlags & Compacting);};

        HRESULT __stdcall QueryFileStampAndLocale(DWORD *pFileStamp, DWORD *pFileLocale);
        
        HRESULT __stdcall CountWrites();

    private:

        class CSystemPathManager : public CITUnknown
        {
        public:

            static HRESULT Create(IUnknown *punkOuter, CImpITFileSystem *pITFS, 
                                  IITPathManager **ppPathMgr
                                 );

            ~CSystemPathManager();

            class CImpIPathManager : public IITPathManager
            {
            public:

                 CImpIPathManager(CSystemPathManager *pBackObj, IUnknown *punkOuter);
                ~CImpIPathManager();

                HRESULT STDMETHODCALLTYPE Init(CImpITFileSystem *pITFS);

                // IPersist Method:

                HRESULT STDMETHODCALLTYPE GetClassID( 
                    /* [out] */ CLSID __RPC_FAR *pClassID);
        
                // IITPathManager interfaces:
    
                HRESULT STDMETHODCALLTYPE FlushToLockBytes();
                HRESULT STDMETHODCALLTYPE FindEntry  (PPathInfo pPI   );
                HRESULT STDMETHODCALLTYPE CreateEntry(PPathInfo pPINew, 
                                                      PPathInfo pPIOld, 
                                                      BOOL fReplace     );
                HRESULT STDMETHODCALLTYPE DeleteEntry(PPathInfo pPI   );
                HRESULT STDMETHODCALLTYPE UpdateEntry(PPathInfo pPI   );
                HRESULT STDMETHODCALLTYPE EnumFromObject(IUnknown *punkOuter, 
                                                         const WCHAR *pwszPrefix, 
                                                         UINT cwcPrefix, 
			                                             REFIID riid, 
                                                         PVOID *ppv
			                                            );
				HRESULT STDMETHODCALLTYPE GetPathDB(IStreamITEx *pTempPDBStrm, BOOL fCompact);
				HRESULT STDMETHODCALLTYPE ForceClearDirty();


            private:

               CImpITFileSystem *m_pIITFS;
            };

        private:

            CSystemPathManager(IUnknown *pUnkOuter);

            CImpIPathManager m_PathManager;
        };
        
        friend CSystemPathManager::CImpIPathManager;

        class CEnumFSItems : public CITUnknown
        {
        public:

            static HRESULT NewFSEnumerator(CImpITFileSystem *pITFS, 
                                           const WCHAR *pwszPathPrefix, 
                                           UINT cwcPathPrefix,
                                           IEnumSTATSTG **ppEnumSTATSTG
                                          );

            ~CEnumFSItems();

            class CImpIEnumSTATSTG : public IITEnumSTATSTG 
            {
                friend CEnumFSItems;

            public:

                 CImpIEnumSTATSTG(CEnumFSItems *pBackObj, IUnknown *punkOuter);
                ~CImpIEnumSTATSTG();

                HRESULT InitFSEnumerator(CImpITFileSystem *pITFS, 
                                         const WCHAR *pwszPathPrefix, 
                                         UINT cwcPathPrefix
                                        );

                HRESULT InitNewCloneOf(CImpIEnumSTATSTG *pImpEnumFS);

                HRESULT	STDMETHODCALLTYPE GetNextEntryInSeq(ULONG celt, PathInfo *rgelt, ULONG  *pceltFetched);
				HRESULT	STDMETHODCALLTYPE GetFirstEntryInSeq(PathInfo *rgelt);
		
				HRESULT STDMETHODCALLTYPE Next( 
                    /* [in] */ ULONG celt,
                    /* [in] */ STATSTG __RPC_FAR *rgelt,
                    /* [out] */ ULONG __RPC_FAR *pceltFetched);

                HRESULT STDMETHODCALLTYPE Skip( 
                    /* [in] */ ULONG celt);

                HRESULT STDMETHODCALLTYPE Reset( void);

                HRESULT STDMETHODCALLTYPE Clone( 
                    /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);
            
            private:

                IEnumSTATSTG     *m_pEnumPathMgr;
                CImpITFileSystem *m_pITFS;
            };

            static HRESULT NewCloneOf(CImpIEnumSTATSTG *pImpEnumFS, 
                                      IEnumSTATSTG **ppEnumSTATSTG
                                     );

        private:

            CEnumFSItems(IUnknown *pUnkOuter);

            CImpIEnumSTATSTG m_ImpEnumSTATSTG;
        };

        friend CEnumFSItems;
        friend CEnumFSItems::CImpIEnumSTATSTG;

        enum { PENDING_CHANGE_LIMIT = 100 };

        void CopyPath(PathInfo &PI, const WCHAR *pwcsPath);
        IITPathManager *PathMgr(PathInfo *pPathInfo);

        HRESULT CreateSpaceNameList();
        HRESULT   OpenSpaceNameList();
        HRESULT  FlushSpaceNameList();

        HRESULT   FindSpaceName(const WCHAR *pwcsSpaceName);
        HRESULT    AddSpaceName(const WCHAR *pwcsSpaceName);
        HRESULT DeleteSpaceName(const WCHAR *pwcsSpaceName);

        HRESULT   ActivateDataSpace(ULONG iSpace);
        HRESULT DeactivateDataSpace(ULONG iSpace);

        HRESULT CreateDefaultDataSpace(PITSFS_Control_Data pITCD);
        HRESULT WriteToStream(const WCHAR *pwcsStreamPath, PVOID pvData, ULONG cbData);
        HRESULT CreateTransformedLockBytes
                      (IUnknown *pUnkOuter, const WCHAR *pwcsPath,
                       const WCHAR *pwcsDataSpaceName,
                       BOOL fOverwrite, ILockBytes **ppLKB
                      );

        HRESULT OpenTransformedLockbytes(PathInfo *pPI, ILockBytes **ppLKB);

        HRESULT __stdcall LookForActivity(WCHAR const *pwcsName, IEnumSTATSTG *pEnum);
	
        enum { MAX_SPACES = 256 };

        ITSFileHeader         m_itfsh;
        CITCriticalSection    m_cs;
        UINT                  m_StartingFileStamp;
        ILockBytes           *m_pLKBMedium;
        IITPathManager       *m_pPathManager;
        IITPathManager       *m_pSysPathManager;
        IITFreeList          *m_pFreeListManager;
        ITransformServices   *m_pTransformServices;
        CImpITUnknown        *m_pActiveStorageList;
        CImpITUnknown        *m_pActiveLockBytesList;
        BOOL                  m_fHeaderIsDirty;
        BOOL                  m_fInitialed;
        BOOL                  m_fReadOnly;
        BOOL                  m_fDefaultIsCompression;
        WCHAR                *m_pwscDataSpaceNames;
        TransformDescriptor **m_papTransformDescriptors;
        IStreamITEx          *m_pStrmSpaceNames;
        UINT                  m_cFSObjectRefs;   // Count of circular refs through
                                                 // ":" storages and streams.
        UINT                  m_cwcFileName;
        WCHAR                 m_awszFileName[MAX_PATH];
	};

    CImpITFileSystem m_ImpITFileSystem;
};

inline CITFileSystem::CITFileSystem(IUnknown *pUnkOuter)
    : m_ImpITFileSystem(this, pUnkOuter),
      CITUnknown(&IID_ITFileSystem, 1, &m_ImpITFileSystem)
{
}

inline CITFileSystem::~CITFileSystem() { }

inline CITFileSystem::CImpITFileSystem::CSystemPathManager::CSystemPathManager(IUnknown *pUnkOuter)
    : m_PathManager(this, pUnkOuter), 
      CITUnknown(aIID_CPathManager, cInterfaces_CPathManager, &m_PathManager)
{

}

inline CITFileSystem::CImpITFileSystem::CSystemPathManager::~CSystemPathManager(void)
{

}

inline CITFileSystem::CImpITFileSystem::CSystemPathManager::CImpIPathManager::~CImpIPathManager()
{
}

inline CITFileSystem::CImpITFileSystem::CEnumFSItems::CEnumFSItems(IUnknown *pUnkOuter)
    : m_ImpEnumSTATSTG(this, pUnkOuter), 
      CITUnknown(&IID_IEnumSTATSTG, 1, &m_ImpEnumSTATSTG)
{

}

inline CITFileSystem::CImpITFileSystem::CEnumFSItems::~CEnumFSItems(void)
{

}

extern const WCHAR *pwscSpaceNameListStream;
extern const WCHAR *pwcsSpaceNameStorage;
extern const WCHAR *pwcsSpaceContentSuffix;
extern const WCHAR *pwcsTransformListSuffix;
extern const WCHAR *pwcsSpanInfoSuffix;
extern const WCHAR *pwcsTransformSubStorage;
extern const WCHAR *pwcsControlDataSuffix;
extern const WCHAR *pwcsInstanceSubStorage;
extern const WCHAR *pwcsTransformStorage;

extern const WCHAR *pwcsUncompressedSpace;
extern const WCHAR *pwcsLZXSpace;

#endif // __ITSFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lci.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1996
 *  All Rights Reserved.
 *
 *  LCI.H - Diamond Memory Compression Interface (LCI)
 *
 *  History:
 *      03-Jul-1996     jforbes     Created from QCI.H
 *
 *  Functions:
 *      LCICreateCompression    - Create and reset an LCI compression context
 *      LCICompress             - Compress a block of data
 *      LCIResetCompression     - Reset compression context
 *      LCIDestroyCompression   - Destroy LCI compression context
 *      LCISetTranslationSize   - Set file translation size
 *
 *  Types:
 *      LCI_CONTEXT_HANDLE      - Handle to an LCI compression context
 *      PFNALLOC                - Memory allocation function for LCI
 *      PFNFREE                 - Free memory function for LCI
 */

/* --- types -------------------------------------------------------------- */
#include <basetsd.h>
extern "C"
{

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif

#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef unsigned char  BYTE;
#endif

#ifndef _UINT_DEFINED
#define _UINT_DEFINED
typedef unsigned int  UINT;
#endif

#ifndef _ULONG_DEFINED
#define _ULONG_DEFINED
typedef unsigned long  ULONG;
#endif

#ifndef FAR
#ifdef BIT16
#define FAR far
#else
#define FAR
#endif
#endif

#ifndef HUGE
#ifdef BIT16
#define HUGE huge
#else
#define HUGE
#endif
#endif

#ifndef _MI_MEMORY_DEFINED
#define _MI_MEMORY_DEFINED
typedef void HUGE *  MI_MEMORY;
#endif

#ifndef _MHANDLE_DEFINED
#define _MHANDLE_DEFINED
#ifdef IA64
typedef ULONG_PTR MHANDLE;
#else
typedef unsigned long  MHANDLE;
#endif
#endif

/* --- LCI-defined types -------------------------------------------------- */

/* LCI_CONTEXT_HANDLE - Handle to an LCI compression context */

typedef MHANDLE LCI_CONTEXT_HANDLE;      /* hmc */


/***    PFNALLOC - Memory allocation function for LCI
 *
 *  Entry:
 *      cb - Size in bytes of memory block to allocate
 *
 *  Exit-Success:
 *      Returns !NULL pointer to memory block
 *
 *  Exit-Failure:
 *      Returns NULL; insufficient memory
 */
#ifndef _PFNALLOC_DEFINED
#define _PFNALLOC_DEFINED
typedef MI_MEMORY (FAR DIAMONDAPI *PFNALLOC)(ULONG cb);       /* pfnma */
#endif


/***    PFNFREE - Free memory function for LCI
 *
 *  Entry:
 *      pv - Memory block allocated by matching PFNALLOC function
 *
 *  Exit:
 *      Memory block freed.
 */
#ifndef _PFNFREE_DEFINED
#define _PFNFREE_DEFINED
typedef void (FAR DIAMONDAPI *PFNFREE)(MI_MEMORY pv);          /* pfnmf */
#endif

/* --- prototypes --------------------------------------------------------- */

/***    LCICreateCompression - Create LCI compression context
 *
 *  Entry:
 *      pcbDataBlockMax     *largest uncompressed data block size desired,
 *                          gets largest uncompressed data block allowed
 *      pvConfiguration     passes implementation-specific info to compressor.
 *      pfnma               memory allocation function pointer
 *      pfnmf               memory free function pointer
 *      pcbDstBufferMin     gets required compressed data buffer size
 *      pmchHandle          gets newly-created context's handle
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      *pcbDataBlockMax, *pcbDstBufferMin, *pmchHandle filled in.
 *
 *  Exit-Failure:
 *      MCI_ERROR_NOT_ENOUGH_MEMORY, could not allocate enough memory.
 *      MCI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 */
int FAR DIAMONDAPI LCICreateCompression(
        UINT FAR *      pcbDataBlockMax,  /* max uncompressed data block size */
        void FAR *      pvConfiguration,  /* See LZXCONFIGURATION */
        PFNALLOC        pfnma,            /* Memory allocation function ptr */
        PFNFREE         pfnmf,            /* Memory free function ptr */
        UINT FAR *      pcbDstBufferMin,  /* gets required output buffer size */
        LCI_CONTEXT_HANDLE FAR *pmchHandle, /* gets newly-created handle */
		int FAR	(DIAMONDAPI *pfnlzx_output_callback)(
			void *			pfol,
			unsigned char *	compressed_data,
			long			compressed_size,
			long			uncompressed_size
        ),
        void FAR *      fci_pv // not the same as the FCI client's pv
);  


/***    LCICompress - Compress a block of data
 *
 *  Entry:
 *      hmc                 handle to compression context
 *      pbSrc               source buffer (uncompressed data)
 *      cbSrc               size of data to be compressed
 *      pbDst               destination buffer (for compressed data)
 *      cbDst               size of destination buffer
 *      pcbResult           receives compressed size of data
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      *pcbResult has size of compressed data in pbDst.
 *      Compression context possibly updated.
 *
 *  Exit-Failure:
 *      MCI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 */
int FAR DIAMONDAPI LCICompress(
        LCI_CONTEXT_HANDLE  hmc,         /* compression context */
        void FAR *          pbSrc,       /* source buffer */
        UINT                cbSrc,       /* source buffer size */
        void FAR *          pbDst,       /* target buffer */
        UINT                cbDst,       /* target buffer size */
        ULONG FAR *         pcbResult);  /* gets target data size */


/***    LCIResetCompression - Reset compression history (if any)
 *
 *  De-compression can only be started on a block which was compressed
 *  immediately following a LCICreateCompression() or LCIResetCompression()
 *  call.  This function forces such a new "compression boundary" to be
 *  created (only by causing the compressor to ignore history, can the data
 *  output be decompressed without history.)
 *
 *  Entry:
 *      hmc - handle to compression context
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      Compression context reset.
 *
 *  Exit-Failure:
 *      Returns MCI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI LCIResetCompression(LCI_CONTEXT_HANDLE hmc);


/***    LCIDestroyCompression - Destroy LCI compression context
 *
 *  Entry:
 *      hmc - handle to compression context
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      Compression context destroyed.
 *
 *  Exit-Failure:
 *      Returns MCI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI LCIDestroyCompression(LCI_CONTEXT_HANDLE hmc);


/*
 * Forces encoder to flush remaining output
 */
int FAR DIAMONDAPI LCIFlushCompressorOutput(LCI_CONTEXT_HANDLE hmc);


/*
 * Set the file translation size
 * (this must be done immediately after a reset, or an LCICreateCompression)
 */
int FAR DIAMONDAPI LCISetTranslationSize(LCI_CONTEXT_HANDLE hmc, unsigned long size);


/*
 * Returns a pointer to the input data present in LZX's buffers.
 *
 * input_position is the offset of the data from the beginning of the file
 * bytes_available is the number of bytes available from that offset
 */
unsigned char * FAR DIAMONDAPI LCIGetInputData(
    LCI_CONTEXT_HANDLE hmc,
    unsigned long *input_position,
    unsigned long *bytes_available
);



/* --- constants ---------------------------------------------------------- */

/* return codes */

#define     MCI_ERROR_NO_ERROR              0
#define     MCI_ERROR_NOT_ENOUGH_MEMORY     1
#define     MCI_ERROR_BAD_PARAMETERS        2
#define     MCI_ERROR_BUFFER_OVERFLOW       3
#define     MCI_ERROR_FAILED                4
#define     MCI_ERROR_CONFIGURATION         5

/* --- LZX configuration details ------------------------------------- */

/***    LZX pvConfiguration structure
 *
 * The SecondPartitionSize must be >= 32K.  It is the amount of
 * data which LZX compresses before copymem'ing the window and
 * tree contents around.
 */

#pragma pack (2)

typedef struct {
    int WindowSize;           // buffer size
    int SecondPartitionSize;  
} LZXCONFIGURATION; /* lcfg */

#pragma pack ()

typedef LZXCONFIGURATION *PLZXCONFIGURATION; /* plcfg */

/* ----------------------------------------------------------------------- */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\ldi.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1993,1994
 *  All Rights Reserved.
 *
 *  LDI.H - Diamond Memory Decompression Interface (LDI)
 *
 *  History:
 *      03-Jul-1994     jforbes      Initial version.
 *
 *  Functions:
 *      LDICreateDecompression  - Create and reset an LDI decompression context
 *      LDIDecompress           - Decompress a block of data
 *      LDIResetDecompression   - Reset LDI decompression context
 *      LDIDestroyDecompression - Destroy LDI Decompression context
 *
 *  Types:
 *      LDI_CONTEXT_HANDLE      - Handle to an LDI decompression context
 *      PFNALLOC                - Memory allocation function for LDI
 *      PFNFREE                 - Free memory function for LDI
 */

/* --- types -------------------------------------------------------------- */

#include <basetsd.h>

extern "C"
{
#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif

#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef unsigned char  BYTE;
#endif

#ifndef _UINT_DEFINED
#define _UINT_DEFINED
typedef unsigned int  UINT;
#endif

#ifndef _ULONG_DEFINED
#define _ULONG_DEFINED
typedef unsigned long  ULONG;
#endif

#ifndef NEAR
#  ifdef BIT16
#     define NEAR __near
#  else
#     define NEAR
#  endif
#endif

#ifndef FAR
#ifdef BIT16
#define FAR __far
#else
#define FAR
#endif
#endif

#ifndef HUGE
#ifdef BIT16
#define HUGE __huge
#else
#define HUGE
#endif
#endif

#ifndef _MI_MEMORY_DEFINED
#define _MI_MEMORY_DEFINED
typedef void HUGE *  MI_MEMORY;
#endif

#ifndef _MHANDLE_DEFINED
#define _MHANDLE_DEFINED
#ifdef IA64
typedef ULONG_PTR MHANDLE;
#else
typedef unsigned long  MHANDLE;
#endif
#endif

#ifndef UNALIGNED
#ifndef NEEDS_ALIGNMENT
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif


/*
 *  LDI will try to create a virtual ring buffer on disk if the pfnalloc call
 *  to create the buffer fails.  These functions provide LDI the disk access
 *  features needed.
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNOPEN oflag
 *  and pmode calls are those defined for _open.  LDI expects error
 *  handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *  For PFNOPEN, the pszFile parameter will take on a special form for LDI's
 *  temporary file.  The special form appears as a file named "*".  Such a
 *  name field should be cast into the struct below, which contains the
 *  required file's size as shown in the RINGNAME structure below.
 *
 *  Example open and close callbacks are provided.  It is assumed that the
 *  client will provide more adaptive code for determining the temporary
 *  file's name and drive location, based on environment variables and the
 *  amount of free disk space.  This sample code has hard-coded the actual
 *  path and fails if there is not enough free space.  This code creates the
 *  file, then attempts to expand it to the requested size by writing a byte
 *  (any byte) at the requested size - 1.  (This approach is not suitable for
 *  a file system which can support sparse files.)
 *
 *  The callback routine may create this file on any path, and with any name,
 *  as appropriate.  If the file cannot be created with the requested size,
 *  the PFNOPEN should fail.  The file really should be placed on a local
 *  fixed disk.  It would not be appropriate for the file to be placed on a
 *  compressed drive or a floppy disk.  If the client has access to alternate
 *  memory, such as XMS or EMS, these operations could be emuluated.
 *
 *  static int tempHandle = -1;
 *
 *  int FAR DIAMONDAPI MyOpen(char FAR *pszFile,int oflag,int pmode)
 *  {
 *      if (*pszFile == '*')
 *      {
 *          PRINGNAME pringDescriptor;
 *
 *          pringDescriptor = (PRINGNAME) pszFile;
 *
 *          tempHandle = _open("C:\\ldi_temp.$$$",oflag,pmode);
 *
 *          if (tempHandle != -1)
 *          {
 *              _lseek(tempHandle,(pringDescriptor->fileSize - 1),SEEK_SET);
 *
 *              if (_write(tempHandle,&tempHandle,1) != 1)
 *              {
 *                  _close(tempHandle);
 *                  remove("C:\\ldi_temp.$$$");
 *                  tempHandle = -1;
 *              }
 *          }
 *
 *          return(tempHandle);
 *      }
 *      else
 *      {
 *          * LDI only will call with *pszFile == '*' *
 *      }
 *  }
 *
 *  The callback provider must watch for the corresponding PFNCLOSE call on
 *  the returned handle, and delete the created file after closing.  (The
 *  file handle and file name assigned to the temporary file must be tracked;
 *  a close operation on that handle must be trapped, so the temporary file
 *  can be deleted as well.)
 *
 *  The client does not need to worry about multiple concurrent opens of the
 *  temporary file, or more than a single temporary file (from LDI).
 *
 *  int FAR DIAMONDAPI MyClose(int handle)
 *  {
 *      int result;
 *  
 *      result = _close(handle);
 *  
 *      if (handle == tempHandle)
 *      {
 *          remove("C:\\ldi_temp.$$$");
 *          tempHandle = -1;
 *      }
 *  
 *      return(result);
 *  }
 */
typedef int  (FAR DIAMONDAPI *PFNOPEN) (char FAR *pszFile,int oflag,int pmode);
typedef UINT (FAR DIAMONDAPI *PFNREAD) (int hf, void FAR *pv, UINT cb);
typedef UINT (FAR DIAMONDAPI *PFNWRITE)(int hf, void FAR *pv, UINT cb);
typedef int  (FAR DIAMONDAPI *PFNCLOSE)(int hf);
typedef long (FAR DIAMONDAPI *PFNSEEK) (int hf, long dist, int seektype);


/* --- LDI-defined types -------------------------------------------------- */

/* LDI_CONTEXT_HANDLE - Handle to a LDI decompression context */

typedef MHANDLE LDI_CONTEXT_HANDLE;      /* hmd */


/***    PFNALLOC - Memory allocation function for LDI
 *
 *  Entry:
 *      cb - Size in bytes of memory block to allocate
 *
 *  Exit-Success:
 *      Returns !NULL pointer to memory block
 *
 *  Exit-Failure:
 *      Returns NULL; insufficient memory
 */
#ifndef _PFNALLOC_DEFINED
#define _PFNALLOC_DEFINED
typedef MI_MEMORY (FAR DIAMONDAPI *PFNALLOC)(ULONG cb);       /* pfnma */
#endif


/***    PFNFREE - Free memory function for LDI
 *
 *  Entry:
 *      pv - Memory block allocated by matching PFNALLOC function
 *
 *  Exit:
 *      Memory block freed.
 */
#ifndef _PFNFREE_DEFINED
#define _PFNFREE_DEFINED
typedef void (FAR DIAMONDAPI *PFNFREE)(MI_MEMORY pv);          /* pfnmf */
#endif

/* --- prototypes --------------------------------------------------------- */

/***    LDICreateDecompression - Create LDI decompression context
 *
 *  Entry:
 *      pcbDataBlockMax     *largest uncompressed data block size expected,
 *                          gets largest uncompressed data block allowed
 *      pvConfiguration     passes implementation-specific info to decompressor.
 *      pfnma               memory allocation function pointer
 *      pfnmf               memory free function pointer
 *      pcbSrcBufferMin     gets max compressed buffer size
 *      pmdhHandle          gets newly-created context's handle
 *      pfnopen             file open function pointer (or NULL)
 *      pfnread             file read function pointer (or don't care)
 *      pfnwrite            file write function pointer (or don't care)
 *      pfnclose            file close function pointer (or don't care)
 *      pfnseek             file seek function pointer (or don't care)
 *
 *      If NULL is provided for pfnopen, and the ring buffer cannot be
 *      created via pfnma, LDICreateDecompression will fail.
 *
 *      If pmdhHandle==NULL, *pcbDataBlockMax and *pcbSrcBufferMin will be
 *      filled in, but no context will be created.  This query will allow
 *      the caller to determine required buffer sizes before creating a
 *      context.
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      *pcbDataBlockMax, *pcbSrcBufferMin, *pmdhHandle filled in.
 *
 *  Exit-Failure:
 *      MDI_ERROR_NOT_ENOUGH_MEMORY, could not allocate enough memory.
 *      MDI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 *      *pcbDataBlockMax, *pcbSrcBufferMin, *pmdhHandle undefined.
 */
int FAR DIAMONDAPI LDICreateDecompression(
        UINT FAR *      pcbDataBlockMax,  /* max uncompressed data block size */
        void FAR *      pvConfiguration,  /* implementation-defined */
        PFNALLOC        pfnma,            /* Memory allocation function ptr */
        PFNFREE         pfnmf,            /* Memory free function ptr */
        UINT FAR *      pcbSrcBufferMin,  /* gets max. comp. buffer size */
        LDI_CONTEXT_HANDLE FAR * pmdhHandle, /* gets newly-created handle */
        PFNOPEN         pfnopen,          /* open a file callback */
        PFNREAD         pfnread,          /* read a file callback */
        PFNWRITE        pfnwrite,         /* write a file callback */
        PFNCLOSE        pfnclose,         /* close a file callback */
        PFNSEEK         pfnseek);         /* seek in file callback */


/***    LDIDecompress - Decompress a block of data
 *
 *  Entry:
 *      hmd                 handle to decompression context
 *      pbSrc               source buffer (compressed data)
 *      cbSrc               compressed size of data to be decompressed
 *      pbDst               destination buffer (for decompressed data)
 *      *pcbDecompressed    (ptr to UINT) the expected de-compressed size
 *                          of this data block.  (same as cbSrc from the
 *                          LCICompress() call.).
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      *pcbDecompressed has size of decompressed data in pbDst.
 *      Decompression context updated.
 *
 *  Exit-Failure:
 *      MDI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 *      MDI_ERROR_BUFFER_OVERFLOW, cbSrc is too small to yield the
 *          requested *pcbDecompressed count.  cbSrc before LDIDecompressed
 *          should always equal *pcbResult after QCICompress(), and
 *          *pcbDecompressed before LDIDecompress should always equal the
 *          cbSrc before QCICompress().
 *      MDI_ERROR_FAILED, either cbSrc is too small, *pcbDecompressed is too
 *          large, or *pbSrc is corrupt.
 *
 *  Note:
 *      Set your cbDecompressed to the expected de-compressed size of this
 *      data block, then call LDIDecompress() with the address of your
 *      cbDecompressed.
 */
int FAR DIAMONDAPI LDIDecompress(
        LDI_CONTEXT_HANDLE  hmd,         /* decompression context */
        void FAR *          pbSrc,       /* source buffer */
        UINT                cbSrc,       /* source data size */
        void FAR *          pbDst,       /* target buffer */
        UINT FAR *          pcbDecompressed);  /* target data size */


/***    LDIResetDecompression - Reset decompression history (if any)
 *
 *  De-compression can only be started on a block which was compressed
 *  immediately following a MCICreateCompression() or MCIResetCompression()
 *  call.  This function provides notification to the decompressor that the
 *  next compressed block begins on a compression boundary.
 *
 *  Entry:
 *      hmd - handle to decompression context
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      Decompression context reset.
 *
 *  Exit-Failure:
 *      Returns MDI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI LDIResetDecompression(LDI_CONTEXT_HANDLE hmd);


/***    LDIDestroyDecompression - Destroy LDI decompression context
 *
 *  Entry:
 *      hmd - handle to decompression context
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      Decompression context destroyed.
 *
 *  Exit-Failure:
 *      Returns MDI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI LDIDestroyDecompression(LDI_CONTEXT_HANDLE hmd);


#ifndef BIT16
int FAR DIAMONDAPI LDIGetWindow(
        LDI_CONTEXT_HANDLE  hmd,            /* decompression context */
        BYTE FAR **         ppWindow,       /* pointer to window start */
        long *              pFileOffset,    /* offset in folder */
        long *              pWindowOffset,  /* offset in window */
        long *              pcbBytesAvail);   /* bytes avail from window start */
#endif


/* --- constants ---------------------------------------------------------- */

/* return codes */

#define     MDI_ERROR_NO_ERROR              0
#define     MDI_ERROR_NOT_ENOUGH_MEMORY     1
#define     MDI_ERROR_BAD_PARAMETERS        2
#define     MDI_ERROR_BUFFER_OVERFLOW       3
#define     MDI_ERROR_FAILED                4
#define     MDI_ERROR_CONFIGURATION         5

/* --- LZX configuration details ------------------------------------- */

/***    LZX pvConfiguration structure
 *
 *  For the LZX decompressor, two parameters are configurable, the
 *  "window bits", which defines the size of the buffer needed by the
 *  the decompressor (must match the value used to compress), and the CPU
 *  type, which controls whether 386 opcodes will be used or not.  If
 *  "unknown" is provided for the fCPUtype, LDI will attempt to determine
 *  the CPU type itself, which could fail or produce system faults on
 *  non-DOS platforms (like Windows.)  Windows apps should use GetWinFlags()
 *  or a similiar method, and never pass "unknown".
 *
 *  pvConfiguration points to this structure.
 */

#pragma pack (1)

typedef struct {
    long	WindowSize;         /* buffersize */
    long	fCPUtype;           /* controls internal code selection */
} LZXDECOMPRESS; /* qdec */

#pragma pack ()

typedef LZXDECOMPRESS *PLZXDECOMPRESS; /* pldec */
typedef LZXDECOMPRESS FAR *PFLZXDECOMPRESS; /* pfldec */

/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 *
 *   LDI_CPU_UNKNOWN detection does *not* work when running under Windows
 *                   in 286 protected mode!  Call GetWinFlags() to determine
 *                   the CPU type and pass it explicitly!
 */

#define     LDI_CPU_UNKNOWN         (-1)    /* internally determined */

/*
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 */

#define     LDI_CPU_80286           (0)     /* '286 opcodes only */
#define     LDI_CPU_80386           (1)     /* '386 opcodes used */
#define     LDI_CPU_CONSERVATIVE    (LDI_CPU_80286)

/* ----------------------------------------------------------------------- */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lockbyte.h ===
// LockBytes.h -- Class declaration for IFSLockBytes

#ifndef __LOCKBYTE_H__

#define __LOCKBYTE_H__

/*

This file defines three implementations of the ILockBytes interface:

  1. CFSLockBytes -- which represents a file as a LockBytes object.

  2. CSegmentLockBytes -- which manages a LockBytes object as a sub-span of a
                          containing LockBytes object.

  3. CTransformedLockBytes -- which manages a LockBytes object above a set of
                              data transformations. See MSITStg for a complete
                              discussion of data transformations. In general
                              you'd use transforms to apply data compression
                              methods and enciphering algorithms.

LockBytes segments and LockBytes transforms use CStorage and CXStorage objects,
respectively, to manage their name and data space bindings within the Tome file.

 */

ILockBytes *STDMETHODCALLTYPE FindMatchingLockBytes(const WCHAR *pwcsPath, CImpITUnknown *pLkb);

class CSegmentLockBytes;

class CFSLockBytes : public CITUnknown
{
public:

    // Destructor:

    ~CFSLockBytes(void);

    // Creation:

    static HRESULT Create(IUnknown *punkOuter, const WCHAR * pwszFileName, 
                          DWORD grfMode, ILockBytes **pplkb
                         );

    static HRESULT CreateTemp(IUnknown *punkOuter, ILockBytes **pplkb);

    static HRESULT Open(IUnknown *punkOuter, const WCHAR * pwszFileName,
                        DWORD grfMode, ILockBytes **pplkb
                       );

    CFSLockBytes(IUnknown *pUnkOuter);

    class CImpILockBytes : public IITLockBytes
    {
    public:

        // Constructor and Destructor:

        CImpILockBytes(CFSLockBytes *pBackObj, IUnknown *punkOuter);
        ~CImpILockBytes(void);

        // Initialing routines:

        HRESULT InitCreateLockBytesOnFS(const WCHAR * pwszFileName, 
                                        DWORD grfMode
                                       );

        HRESULT InitOpenLockBytesOnFS(const WCHAR * pwszFileName,
                                      DWORD grfMode
                                     );

        static DWORD STGErrorFromFSError(DWORD fsError);
        
        static ILockBytes *FindFSLockBytes(const WCHAR * pwszFileName);

        HRESULT __stdcall SetTimes
                              (FILETIME const * pctime, 
                               FILETIME const * patime, 
                               FILETIME const * pmtime
                              );
        
        // ILockBytes methods:
    
        HRESULT STDMETHODCALLTYPE ReadAt( 
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead);
    
        HRESULT STDMETHODCALLTYPE WriteAt( 
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten);
    
        HRESULT STDMETHODCALLTYPE Flush( void);
    
        HRESULT STDMETHODCALLTYPE SetSize( 
            /* [in] */ ULARGE_INTEGER cb);
    
        HRESULT STDMETHODCALLTYPE LockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
    
        HRESULT STDMETHODCALLTYPE UnlockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
    
        HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);

    private:

        HRESULT OpenOrCreateLockBytesOnFS
                  (const WCHAR * pwszFileName, 
                   DWORD grfMode,
                   BOOL  fCreate
                  );

        DEBUGDEF(static LONG s_cInCriticalSection)      // Lock count
           
        HANDLE        m_hFile;        // Containing file -- not use for lockbyte segment
        BOOL          m_fFlushed;     // Is the data different from on-disk version.
        DWORD         m_grfMode;      // Permissions, Sharing rules

        WCHAR m_awszFileName[MAX_PATH]; // Path name for this lockbyte object
        UINT  m_cwcFileName;            // Length of path name
    };

private:

    friend CImpILockBytes;

    CImpILockBytes  m_ImpILockBytes;
};

inline CFSLockBytes::CFSLockBytes(IUnknown *pUnkOuter)
    : m_ImpILockBytes(this, pUnkOuter), 
      CITUnknown(&IID_ILockBytes, 1, &m_ImpILockBytes)
{

}

inline CFSLockBytes::~CFSLockBytes(void)
{
}

class CSegmentLockBytes : public CITUnknown
{
public:

    // Destructor:

    ~CSegmentLockBytes(void);

    // Creation:

    static HRESULT OpenSegment(IUnknown *punkOuter, IITFileSystem *pITFS, 
                               ILockBytes *pLKBMedium, PathInfo *pPI,  
                               ILockBytes **pplkb
                              );

    class CImpILockBytes : public IITLockBytes
    {
    public:

        // Constructor and Destructor:

        CImpILockBytes(CSegmentLockBytes *pBackObj, IUnknown *punkOuter);
        ~CImpILockBytes(void);

        // Initialing routines:

        HRESULT InitOpenSegment(IITFileSystem *pITFS, ILockBytes *pLKBMedium, PathInfo *pPI);

        // ILockBytes methods:
    
        HRESULT STDMETHODCALLTYPE ReadAt( 
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead);
    
        HRESULT STDMETHODCALLTYPE WriteAt( 
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten);
    
        HRESULT STDMETHODCALLTYPE Flush( void);
    
        HRESULT STDMETHODCALLTYPE SetSize( 
            /* [in] */ ULARGE_INTEGER cb);
    
        HRESULT STDMETHODCALLTYPE LockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
    
        HRESULT STDMETHODCALLTYPE UnlockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
    
        HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);

    private:

        DEBUGDEF(static LONG s_cInCriticalSection)      // Lock count
           
        BOOL             m_fFlushed;  // Is the data different from on-disk version.
        IITFileSystem   *m_pITFS;     // File system in which this lockbytes exists.
        ILockBytes      *m_plbMedium; // Container for this lockbytes segment
        ILockBytes      *m_plbTemp;   // Used when we overflow a lockbytes segment
        ILockBytes      *m_plbLockMgr;// Used to process Lock/Unlock region requests
        PathInfo         m_PathInfo;  // ITFS record for this LockBytes segment
    };                 

private:

    CSegmentLockBytes(IUnknown *pUnkOuter);

    CImpILockBytes  m_ImpILockBytes;
};

inline CSegmentLockBytes::CSegmentLockBytes(IUnknown *pUnkOuter)
    : m_ImpILockBytes(this, pUnkOuter), 
      CITUnknown(&IID_ILockBytes, 1, &m_ImpILockBytes)
{

}

inline CSegmentLockBytes::~CSegmentLockBytes(void)
{

}

#define RW_ACCESS_MASK   0x3
#define SHARE_MASK       0x70
#define SHARE_BIT_SHIFT  4

typedef ITransformInstance *PITransformInstance;

class TransformDescriptor
{
public:

	static TransformDescriptor *Create(UINT iDataSpace, UINT cLayers);

	~TransformDescriptor();

    UINT                iSpace;
    CImpITUnknown      *pLockBytesChain;
    CITCriticalSection  cs;
    UINT                cTransformLayers;
    PITransformInstance *apTransformInstance;
private:	
	TransformDescriptor();
};

typedef TransformDescriptor *PTransformDescriptor;

class CTransformedLockBytes : public CITUnknown
{
public:

    // Destructor:

    ~CTransformedLockBytes(void);

    // Creation:

    static HRESULT Open(IUnknown *punkOuter, PathInfo *pPathInfo, 
                        TransformDescriptor *pTransformDescriptor,
                        IITFileSystem *pITFS,
                        ILockBytes **ppLockBytes
                       );

    static ILockBytes *FindTransformedLockBytes
               (const WCHAR * pwszFileName,
                TransformDescriptor *pTransformDescriptor                                          
               );

private:

    CTransformedLockBytes(IUnknown *pUnkOuter);

    class CImpILockBytes : public IITLockBytes
    {
    public:

        // Constructor and Destructor:

        CImpILockBytes(CTransformedLockBytes *pBackObj, IUnknown *punkOuter);
        ~CImpILockBytes(void);

        // Initialing routines:

        HRESULT InitOpen(PathInfo *pPathInfo, 
                         TransformDescriptor *pTransformDescriptor,
                         IITFileSystem *pITFS
                        );

        static ILockBytes *FindTransformedLockBytes
            (const WCHAR * pwszFileName,
             TransformDescriptor *pTransformDescriptor                                          
            );

        // ILockBytes methods:
    
        HRESULT STDMETHODCALLTYPE ReadAt( 
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead);
    
        HRESULT STDMETHODCALLTYPE WriteAt( 
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten);
    
        HRESULT STDMETHODCALLTYPE Flush( void);
    
        HRESULT STDMETHODCALLTYPE SetSize( 
            /* [in] */ ULARGE_INTEGER cb);
    
        HRESULT STDMETHODCALLTYPE LockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
    
        HRESULT STDMETHODCALLTYPE UnlockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
    
        HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);

    private:

        DEBUGDEF(static LONG s_cInCriticalSection)      // Lock count
           
        ITransformInstance  *m_pTransformInstance;
        IITFileSystem       *m_pITFS; 
        TransformDescriptor *m_pTransformDescriptor;
        ILockBytes          *m_plbLockMgr;
            
        BOOL      m_fFlushed;     // Is the data different from on-disk version.
        DWORD     m_grfMode;      // Permissions, Sharing rules
        PathInfo  m_PathInfo;
    };

    CImpILockBytes  m_ImpILockBytes;
};


inline CTransformedLockBytes::CTransformedLockBytes(IUnknown *pUnkOuter)
    : m_ImpILockBytes(this, pUnkOuter), 
      CITUnknown(&IID_ILockBytes, 1, &m_ImpILockBytes)
{

}

inline CTransformedLockBytes::~CTransformedLockBytes(void)
{
}

inline ILockBytes *CTransformedLockBytes::FindTransformedLockBytes
           (const WCHAR * pwszFileName,
            TransformDescriptor *pTransformDescriptor                                          
           )
{
    return CImpILockBytes::FindTransformedLockBytes(pwszFileName, pTransformDescriptor);
}

class CStrmLockBytes : public CITUnknown
{
public:

    // Destructor:

    ~CStrmLockBytes(void);

    // Creation:

	static HRESULT OpenUrlStream(const WCHAR *pwszURL, ILockBytes **pplkb);
    static HRESULT Create(IUnknown *punkOuter, IStream *pStrm, ILockBytes **pplkb);

private:

    CStrmLockBytes(IUnknown *pUnkOuter);

    class CImpILockBytes : public IITLockBytes
    {
    public:

        // Constructor and Destructor:

        CImpILockBytes(CStrmLockBytes *pBackObj, IUnknown *punkOuter);
        ~CImpILockBytes(void);

        // Initialing routines:

        HRESULT InitUrlStream(const WCHAR *pwszURL);
		HRESULT Init(IStream *pStrm);

        // Search routine

        static ILockBytes *FindStrmLockBytes(const WCHAR * pwszFileName);

        // ILockBytes methods:
    
        HRESULT STDMETHODCALLTYPE ReadAt( 
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead);
    
        HRESULT STDMETHODCALLTYPE WriteAt( 
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten);
    
        HRESULT STDMETHODCALLTYPE Flush( void);
    
        HRESULT STDMETHODCALLTYPE SetSize( 
            /* [in] */ ULARGE_INTEGER cb);
    
        HRESULT STDMETHODCALLTYPE LockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
    
        HRESULT STDMETHODCALLTYPE UnlockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
    
        HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);

    private:

        DEBUGDEF(static LONG s_cInCriticalSection)      // Lock count
        
        IStream           *m_pStream; 
        CITCriticalSection m_cs;
        WCHAR m_awszLkBName[MAX_PATH]; // Path name for this lockbyte object
    };

    CImpILockBytes  m_ImpILockBytes;
};

inline CStrmLockBytes::CStrmLockBytes(IUnknown *pUnkOuter)
    : m_ImpILockBytes(this, pUnkOuter), 
      CITUnknown(&IID_ILockBytes, 1, &m_ImpILockBytes)
{

}

inline CStrmLockBytes::~CStrmLockBytes(void)
{
}


#endif // __LOCKBYTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\itunk.h ===
// ITUnk.h -- Base level IUnknown interface used by objects in this DLL

#ifndef __ITUNK_H__

#define __ITUNK_H__

// The CITUnknown class takes care of object reference counting for all
// the objects we create in this DLL. This means that all of our base
// level IUnknown interfaces must inherit from this class. 
//
// Since we don't define an implementation for QueryInterface, this class
// cannot be used by itself.
//
// This class does nothing for standard interfaces derrived indirectly
// from IUnknown (IStorage, IStream, ...).

// The Guid_Parts define is a tool for building constant arrays of IID's.

#define Guid_Parts(guid) guid.Data1, guid.Data2, guid.Data3, \
                         guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3], \
                         guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7] 

typedef IUnknown *PUnknown;

class CITUnknown : public IUnknown
{
public:

 //   CITUnknown();
    CITUnknown(const IID *paIID, UINT cIID, IUnknown  *  pIFace);
    CITUnknown(const IID *paIID, UINT cIID, IUnknown **papIFace);
    static void CloseActiveObjects();
    void MoveInFrontOf(CITUnknown *pITUnk);
    void MarkSecondary();
    BOOL IsSecondary();
    
    virtual ~CITUnknown() = 0; // The destructor has to be virtual so that the 
                               // proper destructor is called for each subclass
                               // of CITUnknown.

    STDMETHODIMP_(ULONG) AddRef (void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, PPVOID ppv);

#ifdef _DEBUG
    static void  OpenReferee(void);
    static void CloseReferee(void);
#endif // _DEBUG

	static HRESULT FinishSetup(HRESULT hr, CITUnknown *pUnk, REFIID riid, PPVOID ppv);

    static CITCriticalSection s_csUnk;
    // DEBUGDEF(static CITCriticalSection s_csUnk)

private:

    void CommonInitialing();
    void Uncouple();

    LONG       m_cRefs;
    const IID *m_paIID;
    UINT       m_cIID;
    IUnknown  *m_pIFace;
    IUnknown **m_papIFace;

    BOOL        m_fAlreadyDead;
    BOOL        m_fSecondary;
    CITUnknown *m_pitunkPrev;
    CITUnknown *m_pitunkNext;
    // DEBUGDEF(CITUnknown *m_pitunkNext)

    DEBUGDEF(static BOOL             s_fCSInitialed)
    static CITUnknown      *s_pitunkActive;
    // DEBUGDEF(static CITUnknown      *s_pitunkActive)
};

typedef CITUnknown *PITUnknown;

inline void CITUnknown::MarkSecondary()
{
    m_fSecondary = TRUE;
}

inline BOOL CITUnknown::IsSecondary()
{
    return m_fSecondary;
}

// DEBUGDEF(extern PITUnknown CITUnknown::m_pitunkActive)

// The class CImpITUnknown will be used as one of the base classes defining
// the imbedded implementation which rely on CITUnknown for aggregation logic.
//
// The pattern here is that the outer class derived from CITUnknown will have
// a constructor of the form:
//
//     CMyObject::CMyObject(IUnknown *punkOuter) :
//          m_ImpIObject(this, punkOuter)
//     {
//        // Initialing code for CMyObject goes here...
//     }
//
// Where m_ImpIObject is a member variable of CMyObject which has been derived 
// from CImpITUnknown where CImpITUnknown has a constructor of the form:
//
//     CMyObject::CImpIMyObject::CImpIMyObject(CITUnknown *pBackObj, IUnknown *punkOuter)
//          : CImpITUnknown(pBackObj, punkOuter)
//     {
//         // Initialing code for CImpIMyObject goes here...
//     }
//
// If the derrivation is indirect, you must define constructors for every class in the
// derivation chain to pass the pBackObj and punkOuter parameters down to CImpITUnknown.

class CImpITUnknown;

typedef CImpITUnknown *PCImpITUnknown;

class CImpITUnknown : public IUnknown
{
public:

    CImpITUnknown(void);

    CImpITUnknown(CITUnknown *pBackObj, IUnknown *punkOuter);

    ~CImpITUnknown();
    
    STDMETHODIMP_(ULONG) AddRef (void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv);

    CITUnknown *Container();
    BOOL HasControllingUnknown();
    IUnknown * ControllingIUnknown();
    BOOL ActiveMark();

    void MarkActive  (PCImpITUnknown &pListStart);
    void MarkInactive();
    
    static void DetachReference(PCImpITUnknown &pITUnk);

    CImpITUnknown *NextObject();

private:

    IUnknown       *m_pUnkOuter;
    CITUnknown     *m_pBackObj;
    BOOL            m_fControlled;
    CImpITUnknown  *m_pImpITUnknownNext;
    CImpITUnknown **m_ppImpITUnknownList;
    BOOL           m_fActive;
};

// The DetachRef define verifies that the target pointer variable has
// a type derived from PCImpITUnknown and then call DetachReference
// to safely disconnect the variable and decrement our reference count.
// Note that you still have to worry about multithreading cases. That
// is, you must avoid race conditions between two threads which try 
// release the same pointer simultaneously. In practice the way to
// deal with that problem is to have all objects owned by a single
// thread and avoid the race condition.

#define DetachRef(p) {                                                     \
                       DEBUGDEF(PCImpITUnknown pUnk = p);                  \
                       CImpITUnknown::DetachReference((PCImpITUnknown) p); \
                     }

inline BOOL CImpITUnknown::HasControllingUnknown()
{
    return m_fControlled;
}

inline CImpITUnknown::CImpITUnknown(void) { RonM_ASSERT(FALSE); }

inline IUnknown *CImpITUnknown::ControllingIUnknown()
{
    return m_pUnkOuter;
}

inline BOOL CImpITUnknown::ActiveMark() { return m_fActive; }

inline CImpITUnknown *CImpITUnknown::NextObject()
{
    RonM_ASSERT(m_fActive);

    return m_pImpITUnknownNext;
}

inline CITUnknown *CImpITUnknown::Container()
{
    return m_pBackObj;
}

#endif // __ITUNK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lockbyte.cpp ===
// LockBytes.cpp -- Implementation for class CFSLockBytes

#include "StdAfx.h"

typedef PITransformInstance * PPITI;
DEBUGDEF(LONG          CFSLockBytes::CImpILockBytes::s_cInCriticalSection) // = 0)
DEBUGDEF(LONG     CSegmentLockBytes::CImpILockBytes::s_cInCriticalSection) // = 0)
DEBUGDEF(LONG CTransformedLockBytes::CImpILockBytes::s_cInCriticalSection) // = 0)

HRESULT IITLockBytes::CopyLockBytes
    (ILockBytes *pilbSrc,  CULINT ullBaseSrc, CULINT ullLimitSrc,
     ILockBytes *pilbDest, CULINT ullBaseDest
    )
{
    CULINT ullLimitDest;

    ullLimitDest = ullBaseDest + (ullLimitSrc - ullBaseSrc);

    if (ullLimitDest.NonZero() && ullLimitDest < ullBaseDest)
        return STG_E_MEDIUMFULL;

    PBYTE pbBuffer = PBYTE(_alloca(CB_COPY_BUFFER));

    if (!pbBuffer) 
        return STG_E_INSUFFICIENTMEMORY;

    for (; (ullLimitSrc.NonZero()? ullBaseSrc < ullLimitSrc : ullBaseSrc.NonZero()); )
    {
        CULINT ullLimit;
        
        ullLimit = ullBaseSrc + CB_COPY_BUFFER;

        UINT cb = (ullLimit <= ullLimitSrc)? CB_COPY_BUFFER
                                           : (ullLimitSrc - ullBaseSrc).Uli().LowPart;

        ULONG cbRead;

        HRESULT hr= pilbSrc->ReadAt(ullBaseSrc.Uli(), pbBuffer, cb, &cbRead);

        if (!SUCCEEDED(hr))
            return hr;

        if (cb != cbRead)
            return STG_E_READFAULT;

        ULONG cbWritten;

        hr= pilbDest->WriteAt(ullBaseDest.Uli(), pbBuffer, cb, &cbWritten);

        if (!SUCCEEDED(hr))
            return hr;

        if (cb != cbWritten)
            return STG_E_WRITEFAULT;

        ullBaseSrc  += cb;
        ullBaseDest += cb;
    }

    return NO_ERROR;
}
        
ILockBytes *STDMETHODCALLTYPE FindMatchingLockBytes(const WCHAR *pwcsPath, CImpITUnknown *pLkb)
{
    for (; pLkb; pLkb = pLkb->NextObject())
        if (((IITLockBytes *)pLkb)->IsNamed(pwcsPath))
        {
             pLkb->AddRef();

             return (ILockBytes *) pLkb;
        }
        
    return NULL;     
}

HRESULT CFSLockBytes::Create(IUnknown *punkOuter, const WCHAR * pwszFileName, 
                             DWORD grfMode, ILockBytes **pplkb
                            )
{
	CFSLockBytes *pfslkb = New CFSLockBytes(punkOuter);
	
    return FinishSetup(pfslkb? pfslkb->m_ImpILockBytes.InitCreateLockBytesOnFS
                                   (pwszFileName, grfMode)
                             : STG_E_INSUFFICIENTMEMORY,
                       pfslkb,IID_ILockBytes , (PPVOID) pplkb
                      );
}

HRESULT CFSLockBytes::CreateTemp(IUnknown *punkOuter, ILockBytes **pplkb)
{
    char szTempPath[MAX_PATH];
    
    DWORD cbPath= GetTempPath(MAX_PATH, szTempPath);

    if (!cbPath)
        lstrcpyA(szTempPath, ".\\");

    char szPrefix[4] = "IMT"; // BugBug! May need to make this a random string.

    char szFullPath[MAX_PATH];

    if (!GetTempFileName(szTempPath, szPrefix, 0, szFullPath))
        return CFSLockBytes::CImpILockBytes::STGErrorFromFSError(GetLastError());

    WCHAR wszFullPath[MAX_PATH];

    UINT cwc = MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, szFullPath,
                                   1 + lstrlenA(szFullPath), wszFullPath, MAX_PATH
                                  );

    if (!cwc)
        return GetLastError(); 
        
    return Open(punkOuter, wszFullPath, STGM_READWRITE | STGM_SHARE_EXCLUSIVE 
                                                       | STGM_DELETEONRELEASE,
                  pplkb 
                 );
}

HRESULT CFSLockBytes::Open(IUnknown *punkOuter, const WCHAR * pwszFileName,
                           DWORD grfMode, ILockBytes **pplkb
                          )
{
    ILockBytes *pLockBytes = NULL;

    if (!punkOuter)
    {
        pLockBytes = CFSLockBytes::CImpILockBytes::FindFSLockBytes(pwszFileName);

        if (pLockBytes)
        {
            *pplkb = pLockBytes;

            return NO_ERROR;
        }
    }

    CFSLockBytes *pfslkb = New CFSLockBytes(punkOuter);

    return FinishSetup(pfslkb? pfslkb->m_ImpILockBytes.InitOpenLockBytesOnFS
                                   (pwszFileName, grfMode)
                             : STG_E_INSUFFICIENTMEMORY,
                       pfslkb, IID_ILockBytes, (PPVOID) pplkb
                      );
}

CFSLockBytes::CImpILockBytes::CImpILockBytes
    (CFSLockBytes *pBackObj, IUnknown *punkOuter)
    : IITLockBytes(pBackObj, punkOuter, this->m_awszFileName)
{
    m_hFile            = NULL;
    m_fFlushed         = TRUE;
    m_grfMode          = 0;
    m_cwcFileName      = 0;
    m_awszFileName[0]  = 0;
}

CFSLockBytes::CImpILockBytes::~CImpILockBytes(void)
{
    CSyncWith sw(g_csITFS);

    if (m_hFile)
    {
        // RonM_ASSERT(m_fFlushed);

        // The above assert is here because we want to avoid
        // relying on the release operation to flush out pending
        // disk I/O. The reason is that neither the destructor
        // nor the Release function can return an error code.
        // Thus you'd never know whether the flush succeeded.

        if (!m_fFlushed)
            Flush();

        if (ActiveMark())
            MarkInactive();

//        if (m_grfMode & STGM_DELETE_ON_RELEASE)
//            ...

        CloseHandle(m_hFile);
    }
}

// Initialing routines:

#define INVALID_MODE 0xFFFFFFFF

DWORD adwAccessModes[4] = { GENERIC_READ, GENERIC_WRITE, GENERIC_READ | GENERIC_WRITE, INVALID_MODE };

DWORD adwShareModes[8] = { INVALID_MODE, 0, FILE_SHARE_READ, FILE_SHARE_WRITE, 
                                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            INVALID_MODE, INVALID_MODE, INVALID_MODE
                         };

// The tables adwFileCreateErrors and adwSTGMappedErrors define a mapping from the 
// Win32 file system errors to the STG_E_xxx errors. 

// BugBug: Can we do this by simple bit fiddling?

static LONG adwFileCreateErrors[] =
{
    ERROR_FILE_NOT_FOUND,      ERROR_PATH_NOT_FOUND, ERROR_TOO_MANY_OPEN_FILES,
    ERROR_ACCESS_DENIED,       ERROR_INVALID_HANDLE, ERROR_NOT_ENOUGH_MEMORY,
    ERROR_OUTOFMEMORY,         ERROR_INVALID_DRIVE,  ERROR_NO_MORE_FILES,
    ERROR_WRITE_PROTECT,       ERROR_BAD_UNIT,       ERROR_CRC,
    ERROR_SEEK,                ERROR_WRITE_FAULT,    ERROR_READ_FAULT,
    ERROR_SHARING_VIOLATION,   ERROR_LOCK_VIOLATION, ERROR_FILE_EXISTS,
    ERROR_INVALID_PARAMETER,   ERROR_DISK_FULL,      ERROR_NOACCESS,
    ERROR_INVALID_USER_BUFFER, ERROR_ALREADY_EXISTS, ERROR_INVALID_NAME

};                 
  
static LONG adwSTGMappedErrors[] =
{
    STG_E_FILENOTFOUND,         STG_E_PATHNOTFOUND,      STG_E_TOOMANYOPENFILES,
    STG_E_ACCESSDENIED,         STG_E_INVALIDHANDLE,     STG_E_INSUFFICIENTMEMORY,
    STG_E_INSUFFICIENTMEMORY,   STG_E_PATHNOTFOUND,      STG_E_NOMOREFILES,
    STG_E_DISKISWRITEPROTECTED, STG_E_PATHNOTFOUND,      STG_E_READFAULT,
    STG_E_SEEKERROR,            STG_E_WRITEFAULT,        STG_E_READFAULT,
    STG_E_SHAREVIOLATION,       STG_E_LOCKVIOLATION,     STG_E_FILEALREADYEXISTS,
    STG_E_INVALIDPARAMETER,     STG_E_MEDIUMFULL,        STG_E_INVALIDPOINTER,
    STG_E_INVALIDPOINTER,       STG_E_FILEALREADYEXISTS, STG_E_PATHNOTFOUND
};

DWORD CFSLockBytes::CImpILockBytes::STGErrorFromFSError(DWORD fsError)
{
    // This routine maps Win32 file system errors into STG_E_xxxx errors.
    
    UINT cErrs = sizeof(adwFileCreateErrors) / sizeof(DWORD);

    RonM_ASSERT(cErrs == sizeof(adwSTGMappedErrors)/sizeof(DWORD));

    DWORD *pdw = (DWORD *) adwFileCreateErrors;

    for (; cErrs--; pdw++)
    {
        DWORD dw = *pdw;

        if (dw == fsError)
            return (DWORD) adwSTGMappedErrors[pdw - (DWORD *) adwFileCreateErrors];
    }

    RonM_ASSERT(FALSE); // We're supposed to map all errors!

    return STG_E_UNKNOWN; // For when we don't find a match.
}
       

HRESULT CFSLockBytes::CImpILockBytes::InitCreateLockBytesOnFS
          (const WCHAR * pwszFileName, 
           DWORD grfMode
          )
{
    return OpenOrCreateLockBytesOnFS(pwszFileName, grfMode, TRUE);
}

HRESULT CFSLockBytes::CImpILockBytes::OpenOrCreateLockBytesOnFS
          (const WCHAR * pwszFileName, 
           DWORD grfMode,
           BOOL  fCreate
          )
{
    RonM_ASSERT(!m_hFile);

    if (grfMode & STGM_TRANSACTED) 
        return STG_E_UNIMPLEMENTEDFUNCTION;

    // The following assert verifies that RW_ACCESS_MASK is correct.
    
    RonM_ASSERT(STGM_READ == 0 && STGM_WRITE == 1 && STGM_READWRITE == 2);

    DWORD dwAccessMode = adwAccessModes[grfMode & RW_ACCESS_MASK];

    if (dwAccessMode == INVALID_MODE)
        return STG_E_INVALIDFLAG;    

    // The following ASSERT verifies that SHARE_MASK and SHARE_BIT_SHIFT are correct.

    RonM_ASSERT(   STGM_SHARE_DENY_NONE  == 0x40 
                && STGM_SHARE_DENY_READ  == 0x30
                && STGM_SHARE_DENY_WRITE == 0x20
                && STGM_SHARE_EXCLUSIVE  == 0x10
               );

    DWORD dwShareMode = adwShareModes[(grfMode & SHARE_MASK) >> SHARE_BIT_SHIFT];

    if (dwShareMode == INVALID_MODE)
        dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE; // default is STGM_SHARE_DENY_NONE
//        return STG_E_INVALIDFLAG;    

    m_grfMode = grfMode;

    char aszFileName[MAX_PATH+1];

    INT cwc= wcsLen(pwszFileName);

    if (cwc >= MAX_PATH)
        return STG_E_INVALIDNAME;
    
    INT cb = WideCharToMultiByte(CP_USER_DEFAULT(), WC_COMPOSITECHECK | WC_SEPCHARS,
                                 pwszFileName, cwc+1,aszFileName, MAX_PATH, NULL, NULL);  

    if (!cb) 
        return STG_E_INVALIDNAME;

    DWORD dwCreationMode = fCreate? (grfMode & STGM_CREATE)? CREATE_ALWAYS : CREATE_NEW
                                  : OPEN_EXISTING;
    
    m_hFile = CreateFile(aszFileName, dwAccessMode, dwShareMode, NULL, dwCreationMode,   
                         (grfMode & STGM_DELETEONRELEASE)? FILE_FLAG_DELETE_ON_CLOSE 
                                                         : FILE_ATTRIBUTE_NORMAL, 
                         NULL 
                        );

    if (m_hFile == INVALID_HANDLE_VALUE)
        return STGErrorFromFSError(GetLastError());
    
    CopyMemory(m_awszFileName, pwszFileName, sizeof(WCHAR) * (cwc + 1));
    m_cwcFileName = cwc;

    MarkActive(g_pFSLockBytesFirstActive);

    return NO_ERROR;
}


HRESULT CFSLockBytes::CImpILockBytes::InitOpenLockBytesOnFS
          (const WCHAR * pwszFileName,
           DWORD grfMode
          )
{
    return OpenOrCreateLockBytesOnFS(pwszFileName, grfMode, FALSE);
}

// ILockBytes methods:

HRESULT STDMETHODCALLTYPE CFSLockBytes::CImpILockBytes::ReadAt( 
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [length_is][size_is][out] */ void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbRead)
{
    /* 
        This routine reads data synchronously. This means that multiple accesses
        to the file from different threads are forced into a strict sequence with no
        overlap. This could be a serious bottleneck in a multi-threaded environment.
        
        We can relax this constraint by using multiple read threads in Win95 or  
        overlapped I/O in WinNT.

     */
    
    RonM_ASSERT(m_hFile);

    CSyncWith sw(g_csITFS);

    UINT ulResult = SetFilePointer(m_hFile, ulOffset.LowPart, (LONG *) &(ulOffset.HighPart), FILE_BEGIN);
    
    if (ulResult == UINT(~0))
    {
        DWORD dwErr= GetLastError();

        if (dwErr != NO_ERROR) 
            return STGErrorFromFSError(dwErr);
    }

    ULONG cbRead = 0;

    BOOL fSucceeded = ReadFile(m_hFile, pv, cb, &cbRead, NULL);

    if (pcbRead)
        *pcbRead = cbRead;

    if (fSucceeded) 
        return NO_ERROR;

    DWORD dwErr= GetLastError();

    RonM_ASSERT(cb);

    if (dwErr == ERROR_HANDLE_EOF) 
        return (!cbRead)? S_FALSE : S_OK;

    return STGErrorFromFSError(dwErr);
}


HRESULT STDMETHODCALLTYPE CFSLockBytes::CImpILockBytes::WriteAt( 
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [size_is][in] */ const void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbWritten)
{
    RonM_ASSERT(m_hFile);

    m_fFlushed = FALSE;

    /* 
        This routine writes data synchronously. This means that multiple accesses
        to the file from different threads are forced into a strict sequence with no
        overlap. This could be a serious bottleneck in a multi-threaded environment.
        
        We can relax this constraint by using multiple read threads in Win95 or  
        overlapped I/O in WinNT.

     */
    
    CSyncWith sw(g_csITFS);

    DWORD ulResult = SetFilePointer(m_hFile, ulOffset.LowPart, (LONG *) &(ulOffset.HighPart), FILE_BEGIN);
    
    if (ulResult == UINT(~0))
    {
        DWORD dwErr= GetLastError();

        if (dwErr != NO_ERROR) 
            return STGErrorFromFSError(dwErr);
    }

    ULONG cbWritten = 0;
    
    BOOL fSucceeded = WriteFile(m_hFile, pv, cb, &cbWritten, NULL);

    if (pcbWritten) 
        *pcbWritten = cbWritten;

    if (fSucceeded) 
        return NO_ERROR;

    return STGErrorFromFSError(GetLastError());
}

HRESULT STDMETHODCALLTYPE CFSLockBytes::CImpILockBytes::Flush( void)
{
    RonM_ASSERT(m_hFile);

    CSyncWith sw(g_csITFS);

    BOOL fSucceeded = FlushFileBuffers(m_hFile);
    
    HRESULT hr;

    if (fSucceeded)
    {
        m_fFlushed = TRUE;

        hr = NO_ERROR;
    }
    else hr = STGErrorFromFSError(GetLastError());
    
    return hr;
}


HRESULT STDMETHODCALLTYPE CFSLockBytes::CImpILockBytes::SetSize( 
    /* [in] */ ULARGE_INTEGER cb)
{
    RonM_ASSERT(m_hFile);

    m_fFlushed = FALSE; // Is this necessary?

    CSyncWith sw(g_csITFS);

    DWORD dwDistLow= SetFilePointer(m_hFile, cb.LowPart, (LONG *) &(cb.HighPart),
                                    FILE_BEGIN
                                   );
    
    if (!~dwDistLow) // Seek operation failed
        return STGErrorFromFSError(GetLastError());

    BOOL fSucceeded= SetEndOfFile(m_hFile);
    
    if (fSucceeded)
        return NO_ERROR;

    return STGErrorFromFSError(GetLastError());
}


HRESULT STDMETHODCALLTYPE CFSLockBytes::CImpILockBytes::LockRegion( 
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType)
{
    RonM_ASSERT(m_hFile);

    if (dwLockType != LOCK_EXCLUSIVE)
        return STG_E_UNIMPLEMENTEDFUNCTION;
    
    if (LockFile(m_hFile, libOffset.LowPart, libOffset.HighPart,
                 cb.LowPart, cb.HighPart
                )
       )
        return NO_ERROR;

    return STGErrorFromFSError(GetLastError());
}


HRESULT STDMETHODCALLTYPE CFSLockBytes::CImpILockBytes::UnlockRegion( 
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType)
{
    RonM_ASSERT(m_hFile);

    if (dwLockType != LOCK_EXCLUSIVE)
        return STG_E_UNIMPLEMENTEDFUNCTION;
    
    if (UnlockFile(m_hFile, libOffset.LowPart, libOffset.HighPart,
                   cb.LowPart, cb.HighPart
                  )
       )
        return NO_ERROR;

    return STGErrorFromFSError(GetLastError());
}


HRESULT STDMETHODCALLTYPE CFSLockBytes::CImpILockBytes::Stat( 
    /* [out] */ STATSTG __RPC_FAR *pstatstg,
    /* [in] */ DWORD grfStatFlag)
{
    RonM_ASSERT(m_hFile);

    pstatstg->cbSize.LowPart = GetFileSize(m_hFile, &(pstatstg->cbSize.HighPart));

    DWORD dwErr= GetLastError();

    if (pstatstg->cbSize.LowPart == 0xFFFFFFFF && dwErr != NO_ERROR) 
        return STGErrorFromFSError(dwErr);

    if (!GetFileTime(m_hFile, &(pstatstg->ctime), &(pstatstg->atime), &(pstatstg->mtime)))
        return STGErrorFromFSError(GetLastError());

    pstatstg->type              = STGTY_LOCKBYTES;
    pstatstg->grfMode           = m_grfMode;
    pstatstg->grfLocksSupported = LOCK_EXCLUSIVE;
    pstatstg->clsid             = CLSID_NULL;
    pstatstg->grfStateBits      = 0;
    pstatstg->reserved          = 0;

    // The code for setting pstatstg->pwcsName must go last because we don't want
    // to allocate memory for the name and then report an error. If we did, our
    // caller would not realize that they needed to deallocate that name memory.
    
    if (grfStatFlag == STATFLAG_DEFAULT)
    {
        PWCHAR pwcName= PWCHAR(OLEHeap()->Alloc(sizeof(WCHAR) * (m_cwcFileName+1)));

        if (!pwcName)
            return STG_E_INSUFFICIENTMEMORY;

        CopyMemory(pwcName, m_awszFileName, sizeof(WCHAR) * (m_cwcFileName+1));

        pstatstg->pwcsName= pwcName;
    }
    else pstatstg->pwcsName = NULL;

    return NO_ERROR;
}

ILockBytes *CFSLockBytes::CImpILockBytes::FindFSLockBytes(const WCHAR * pwszFileName)
{
    CSyncWith sw(g_csITFS);

	return FindMatchingLockBytes(pwszFileName, (CImpITUnknown *) g_pFSLockBytesFirstActive);
}

HRESULT __stdcall CFSLockBytes::CImpILockBytes::SetTimes
                      (FILETIME const * pctime, 
                       FILETIME const * patime, 
                       FILETIME const * pmtime
                      )
{
    BOOL fSuccess = SetFileTime(m_hFile, pctime, patime, pmtime);

    if (fSuccess) 
        return NO_ERROR;

    return STGErrorFromFSError(GetLastError());
}


CSegmentLockBytes::CImpILockBytes::CImpILockBytes
    (CSegmentLockBytes *pBackObj, IUnknown *punkOuter)
    : IITLockBytes(pBackObj, punkOuter, m_PathInfo.awszStreamPath)
{
    m_fFlushed        = TRUE;
    m_pITFS           = NULL;
    m_plbMedium       = NULL;
    m_plbTemp         = NULL;
    m_plbLockMgr      = NULL;
    
    ZeroMemory(&m_PathInfo, sizeof(m_PathInfo));
}

CSegmentLockBytes::CImpILockBytes::~CImpILockBytes(void)
{
    CSyncWith sw(g_csITFS);
    
    if (m_plbMedium)
    {
        // RonM_ASSERT(m_fFlushed);
        
        // The above assert is here because we want to avoid
        // relying on the release operation to flush out pending
        // disk I/O. The reason is that neither the destructor
        // nor the Release function can return an error code.
        // Thus you'd never know whether the flush succeeded.

        if (!m_fFlushed)
            Flush();

        if (m_PathInfo.cUnrecordedChanges)
            m_pITFS->UpdatePathInfo(&m_PathInfo);
        
        if (m_plbTemp)            // Should have been discarded by Flush. 
            m_plbTemp->Release(); // However this can happen if we're low on disk space.

        if (m_plbLockMgr)         // Will exit if we've had a LockRegion call.
            m_plbLockMgr->Release();

        MarkInactive();        // Take this LockBytes out of the active chain.

        RonM_ASSERT(m_pITFS);  // Because we've got m_plbMedium.

        if (m_PathInfo.awszStreamPath[0] != L'/')
            m_pITFS->FSObjectReleased();

        m_plbMedium->Release();
        m_pITFS    ->Release();
    }
    else
    {
        RonM_ASSERT(!m_pITFS);
        RonM_ASSERT(!m_plbTemp);    // Won't exist if we don't have a lockbyte medium.
        RonM_ASSERT(!m_plbLockMgr); // Won't exist if we don't have a lockbyte medium.
    }
}

HRESULT CSegmentLockBytes::OpenSegment
            (IUnknown *punkOuter, IITFileSystem *pITFS, ILockBytes *pLKBMedium, 
             PathInfo *pPI, ILockBytes **pplkb
            )
{
	CSegmentLockBytes *pSegLKB = New CSegmentLockBytes(punkOuter);

    return FinishSetup(pSegLKB? pSegLKB->m_ImpILockBytes.InitOpenSegment
                                    (pITFS, pLKBMedium, pPI)
                              : STG_E_INSUFFICIENTMEMORY,
                       pSegLKB, IID_ILockBytes, (PPVOID) pplkb
                      );
}

HRESULT CSegmentLockBytes::CImpILockBytes::InitOpenSegment
            (IITFileSystem *pITFS, ILockBytes *pLKBMedium, PathInfo *pPI)
{
    m_pITFS     = pITFS;
    m_plbMedium =  pLKBMedium;
    m_PathInfo  = *pPI;
#if 0
    m_grfMode   = (m_pITFS->IsWriteable())? STGM_READWRITE | STGM_SHARE_DENY_NONE
                                          : STGM_READ      | STGM_SHARE_DENY_NONE;
#endif // 0
    m_pITFS    ->AddRef();
    m_plbMedium->AddRef();

    m_pITFS->ConnectLockBytes(this);

    return NO_ERROR;
}

// ILockBytes methods:

HRESULT STDMETHODCALLTYPE CSegmentLockBytes::CImpILockBytes::ReadAt( 
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [length_is][size_is][out] */ void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbRead)
{
    RonM_ASSERT(m_plbMedium);

    // Since a particular segmented lockbyte may be shared among
    // several different stream objects with varying grfMode settings,
    // we don't validate read access permission at runtime. Instead
    // lockbyte segments are always opened with the maximum permissions
    // available for the medium, and we rely on the client stream object 
    // not to ask us to violate the available medium permissions.

#if 0
    RonM_ASSERT(   (m_grfMode & RW_ACCESS_MASK) == STGM_READ
                || (m_grfMode & RW_ACCESS_MASK) == STGM_READWRITE
               );
// #else     
    if (   (m_grfMode & RW_ACCESS_MASK) != STGM_READ
        && (m_grfMode & RW_ACCESS_MASK) != STGM_READWRITE
       )
        return STG_E_INVALID_FLAG;
#endif
    
    if (!cb)
    {
        if (pcbRead)
            *pcbRead = 0;

        return NO_ERROR;
    }

    /*
    
    The rest of the code runs in a critical section because a concurrent
    write operation could move the data into a temporary lockbytes object,
    or it could change the segment boundaries.

     */

    CSyncWith sw(g_csITFS);

    HRESULT hr = NO_ERROR;

    if (m_plbTemp)
        return m_plbTemp->ReadAt(ulOffset, pv, cb, pcbRead);

    CULINT ullBase, ullLimit;
    
    ullBase  = m_PathInfo.ullcbOffset + ulOffset;
    ullLimit = ullBase + cb;

    CULINT ullLimitSegment = m_PathInfo.ullcbOffset + m_PathInfo.ullcbData;

    if (ullBase > ullLimitSegment) // Beyond the end of the segment? 
    {
        if (pcbRead)
            *pcbRead = 0;

        return S_FALSE;
    }

    BOOL fEOS = FALSE;

    if (   ullLimit < ullBase         // Wrapped at 2**64 bytes?
        || ullLimit > ullLimitSegment // Trying to read past end of segment?
       )
    {
        fEOS     = TRUE;
        ullLimit = ullLimitSegment;
    }

    ULONG cbRead = 0;
    
    hr= m_plbMedium->ReadAt(ullBase.Uli(), pv, (ullLimit - ullBase).Uli().LowPart, 
                            &cbRead
                           );
    
    if (pcbRead)
        *pcbRead = cbRead;

    RonM_ASSERT(cb);

    if (fEOS && hr == NO_ERROR && !cbRead)
        hr = S_FALSE;

    return hr;
}

HRESULT STDMETHODCALLTYPE CSegmentLockBytes::CImpILockBytes::WriteAt( 
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [size_is][in] */ const void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbWritten)
{
    RonM_ASSERT(m_plbMedium);

    // Since a particular segmented lockbyte may be shared among
    // several different stream objects with varying grfMode settings,
    // we don't validate write access permission at runtime. Instead
    // lockbyte segments are always opened with the maximum permissions
    // available for the medium, and we rely on the client stream object 
    // not to ask us to violate the available medium permissions.

#if 0
    RonM_ASSERT(   (m_grfMode & RW_ACCESS_MASK) == STGM_WRITE
                || (m_grfMode & RW_ACCESS_MASK) == STGM_READWRITE
               );
// #else     
    if (   (m_grfMode & RW_ACCESS_MASK) != STGM_WRITE
        && (m_grfMode & RW_ACCESS_MASK) != STGM_READWRITE
       )
        return STG_E_INVALID_FLAG;
#endif
    
    if (!cb)
    {
        if (pcbWritten)
            *pcbWritten = 0;

        return NO_ERROR;
    }

    /* 
    
    The rest of the code runs in a critical section. That's necessary because a 
    particular write operation may change the underlying medium from a lockbyte
    segment to a temporary lockbyte object or it may do a realloc which changes
    the segment boundaries.
    
     */

    CSyncWith sw(g_csITFS);

    HRESULT hr = NO_ERROR;

    hr = m_pITFS->CountWrites();

    if (m_plbTemp)
        return m_plbTemp->WriteAt(ulOffset, pv, cb, pcbWritten);
    
    CULINT ullBase, ullLimit;
    
    ullBase  = m_PathInfo.ullcbOffset + ulOffset;
    ullLimit = ullBase + cb;

    CULINT ullLimitSegment = m_PathInfo.ullcbOffset + m_PathInfo.ullcbData;

    // The assert below verifies that the segment doesn't wrap around
    // through the beginning of the 64-bit address space.
    
    RonM_ASSERT(   m_PathInfo.ullcbOffset <= ullLimitSegment 
                || !(ullLimitSegment.NonZero())
               );

    if (    ullBase < m_PathInfo.ullcbOffset
        || (ullBase > ullLimit && ullLimit.NonZero())
       )
    {
        // The write would wrap around.
        // This is very unlikely -- at least for the next few years.

        if (pcbWritten)
            *pcbWritten = 0;

        return STG_E_WRITEFAULT;
    }
    
    m_fFlushed = FALSE; // Because we know we're going to write something.

    // Here we check to see if the write is completely contained within
    // the segment.

    if (   m_PathInfo.ullcbData.NonZero()
        && ullBase >= m_PathInfo.ullcbOffset 
        && (ullLimitSegment.NonZero()?  ullLimit <= ullLimitSegment
                                     : (   ullLimit >  m_PathInfo.ullcbOffset 
                                        || !ullLimit.NonZero()
                                       )
           )
       )
        return m_plbMedium->WriteAt(ullBase.Uli(), pv, cb, pcbWritten);

    // The write doesn't fit in the segment.
    // Let's see if we can reallocate the segment without moving it.
    //
    // Note that we pass in pointers to both the segment base and the segment limit.
    // You might think that we don't need to pass in the base since the storage
    // manager already knows where the segment is located. However when the segment's
    // size is zero, it really doesn't have a location. So we let the storage manager
    // put it at the end of the medium. This takes care of the case where several 
    // lockbyte segments are created and then they are written in some random order.

    CULINT ullcbNew;
        
    ullcbNew = ullLimit - m_PathInfo.ullcbOffset;

    hr = m_pITFS->ReallocInPlace(&m_PathInfo, ullcbNew);

    if (hr == S_OK)
    {
        ullBase = m_PathInfo.ullcbOffset + ulOffset;

        return m_plbMedium->WriteAt(ullBase.Uli(), pv, cb, pcbWritten);
    }

    // We couldn't do an in-place reallocation.
    //
    // So we move the data into a temporary ILockbytes object
    // and then do the write operation there.

    hr= CFSLockBytes::CreateTemp(NULL, &m_plbTemp);

    if (!SUCCEEDED(hr)) 
        return hr;

    ((IITLockBytes *) m_plbTemp)->Container()->MarkSecondary();

    hr = IITLockBytes::CopyLockBytes(m_plbMedium, m_PathInfo.ullcbOffset, ullLimitSegment,
                                     m_plbTemp, 0
                                    );

    if (!SUCCEEDED(hr))
    {
        m_plbTemp->Release();
        m_plbTemp = NULL;

        return hr;
    }

    hr = m_pITFS->ReallocInPlace(&m_PathInfo, 0);

    RonM_ASSERT(SUCCEEDED(hr)); // In place shrinking should always work!

    if (!SUCCEEDED(hr))
        return hr;

    return m_plbTemp->WriteAt(ulOffset, pv, cb, pcbWritten);
}

HRESULT STDMETHODCALLTYPE CSegmentLockBytes::CImpILockBytes::Flush( void)
{
    RonM_ASSERT(m_plbMedium);

    CSyncWith sw(g_csITFS);

    HRESULT hr = NO_ERROR;

    if (m_fFlushed) 
        return hr;

    if (m_plbTemp)
    {
        // At some point we moved the data into a temporary file. That's 
        // usually because we needed to write beyond the segment boundaries.
        // Now we must move the data back into the lockbyte medium.
        
        // First we must reallocate the segment to the current data size

        STATSTG statstg;

        hr = m_plbTemp->Stat(&statstg, STATFLAG_NONAME);

        if (!SUCCEEDED(hr))
            return hr;

        hr = m_pITFS->ReallocEntry(&m_PathInfo, CULINT(statstg.cbSize), FALSE); 

        if (!SUCCEEDED(hr))
            return hr;

        // Then we must copy the data back into the lockbyte medium.

        hr = IITLockBytes::CopyLockBytes(m_plbTemp, CULINT(0), CULINT(statstg.cbSize),
                                         m_plbMedium, m_PathInfo.ullcbOffset
                                        );
        if (!SUCCEEDED(hr))
            return hr;

        // At this point we don't need the temporary lockbyte any more.
        // At least not until the next append operation...

        m_plbTemp->Release();

        m_plbTemp = NULL;
    }
    
    hr = m_plbMedium->Flush(); // Flush in-memory data to disk.
    
    m_fFlushed = TRUE;

    return hr;
}


HRESULT STDMETHODCALLTYPE CSegmentLockBytes::CImpILockBytes::SetSize( 
    /* [in] */ ULARGE_INTEGER cb)
{
    RonM_ASSERT(m_plbMedium);

    CSyncWith sw(g_csITFS);

    HRESULT hr = NO_ERROR;

    if (m_PathInfo.ullcbData == CULINT(cb))
        return hr;

    m_fFlushed = FALSE;

    if (m_plbTemp)
        hr = m_plbTemp->SetSize(cb);
    else
    {
        hr = m_pITFS->ReallocInPlace(&m_PathInfo, CULINT(cb));

        if (hr != S_OK)
        {
            // Couldn't grow the segment in place. So now we must move the data
            // into a temp lockbyte object. We know it's a grow operation and not
            // a shrinkage because the storage manager can always do an in-place
            // shrink operation.

            hr = CFSLockBytes::CreateTemp(NULL, &m_plbTemp);

            if (SUCCEEDED(hr))
            {
                CULINT ullLimitSegment = m_PathInfo.ullcbOffset + m_PathInfo.ullcbData;
                
                hr = m_plbTemp->SetSize(cb);

                if (SUCCEEDED(hr))
                    hr = IITLockBytes::CopyLockBytes
                             (m_plbMedium, m_PathInfo.ullcbOffset, 
                              ullLimitSegment, m_plbTemp, 0
                             );

                if (!SUCCEEDED(hr))
                {
                    m_plbTemp->Release();

                    m_plbTemp = NULL;
                }
            }
        }
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE CSegmentLockBytes::CImpILockBytes::LockRegion( 
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType)
{
    RonM_ASSERT(m_plbMedium);

    /*
    
    LockRegion operations on lockbyte segments are little tricky because
    the data may exist in two places -- *m_plbMedium and *m_plbTemp.

    You might think we could just keep compare the lock span against the
    boundaries of the segment to determine which underlying lockbyte object
    should do the lock operation. In many situations that would work correctly.
    However if a Flush operation occurs when we have a temporary lockbytes object
    active, the segment boundaries will change. In addition the temporary 
    object will be discarded. 

    The solution then is to always use a third temporary lockbytes object
    to handle lock/unlock operations. Hence the need for m_plbLockMgr.

     */

    CSyncWith sw(g_csITFS);

    HRESULT hr = NO_ERROR;

    if (!m_plbLockMgr)
    {
        hr = CFSLockBytes::CreateTemp(NULL, &m_plbLockMgr);

        if (!SUCCEEDED(hr))
            return hr;
    }

    hr = m_plbLockMgr->LockRegion(libOffset, cb, dwLockType);

    return hr;
}


HRESULT STDMETHODCALLTYPE CSegmentLockBytes::CImpILockBytes::UnlockRegion( 
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType)
{
    RonM_ASSERT(m_plbMedium);

    CSyncWith sw(g_csITFS);

    HRESULT hr = NO_ERROR;

    if (!m_plbLockMgr)
         hr = STG_E_LOCKVIOLATION;
    else hr = m_plbLockMgr->UnlockRegion(libOffset, cb, dwLockType);

    return hr;
}


HRESULT STDMETHODCALLTYPE CSegmentLockBytes::CImpILockBytes::Stat( 
    /* [out] */ STATSTG __RPC_FAR *pstatstg,
    /* [in] */ DWORD grfStatFlag)
{
    RonM_ASSERT(m_plbMedium);

    CSyncWith sw(g_csITFS);

    HRESULT hr = NO_ERROR;

    hr= m_plbMedium->Stat(pstatstg, STATFLAG_NONAME);

    if (SUCCEEDED(hr))
    {
        if (m_plbTemp)
        {
            STATSTG statstgTmp;

            hr= m_plbTemp->Stat(&statstgTmp, STATFLAG_NONAME);
        
            if (SUCCEEDED(hr))
                pstatstg->cbSize = statstgTmp.cbSize;
        }
        else pstatstg->cbSize = m_PathInfo.ullcbData.Uli();

        if (grfStatFlag != STATFLAG_NONAME)   
        {
            UINT cb = sizeof(WCHAR) * (m_PathInfo.cwcStreamPath + 1);

            pstatstg->pwcsName = PWCHAR(OLEHeap()->Alloc(cb));

            if (pstatstg->pwcsName)
                CopyMemory(pstatstg->pwcsName, m_PathInfo.awszStreamPath, cb);
            else hr = STG_E_INSUFFICIENTMEMORY;
        }
    }

    return hr;
}

TransformDescriptor::TransformDescriptor()
{
	iSpace              = ~0;
	pLockBytesChain     = NULL;
	cTransformLayers    = 0;
	apTransformInstance = NULL;
}

TransformDescriptor::~TransformDescriptor()
{
	RonM_ASSERT(cs.LockCount() == 0);

	if (apTransformInstance)
		delete [] (PPITI)apTransformInstance;
}

TransformDescriptor *TransformDescriptor::Create(UINT iDataSpace, UINT cLayers)
{
	TransformDescriptor *pTD = New TransformDescriptor();
	if (pTD)
	{
		pTD->cTransformLayers = cLayers;

		pTD->apTransformInstance = (PITransformInstance *)(New PPITI[cLayers]);
		
		if (pTD->apTransformInstance)
			ZeroMemory(pTD->apTransformInstance, cLayers * sizeof(PPITI));
		else
		{
			delete pTD;  pTD = NULL;
		}
	}

	return pTD;	
}

HRESULT CTransformedLockBytes::Open(IUnknown *punkOuter, PathInfo *pPathInfo, 
                                    TransformDescriptor *pTransformDescriptor,
                                    IITFileSystem *pITFS,
                                    ILockBytes **ppLockBytes
                                   )
{
    CSyncWith sw(g_csITFS);

    CTransformedLockBytes *pTLKB = New CTransformedLockBytes(punkOuter);

    return FinishSetup(pTLKB? pTLKB->m_ImpILockBytes.InitOpen
                                  (pPathInfo, pTransformDescriptor, pITFS)
                            : STG_E_INSUFFICIENTMEMORY,
                       pTLKB, IID_ILockBytes, (PPVOID) ppLockBytes
                      );
}


// Constructor and Destructor:

CTransformedLockBytes::CImpILockBytes::CImpILockBytes
    (CTransformedLockBytes *pBackObj, IUnknown *punkOuter)
    : IITLockBytes(pBackObj, punkOuter, m_PathInfo.awszStreamPath)
{
    m_pTransformDescriptor = NULL;
    m_pTransformInstance   = NULL;
    m_pITFS                = NULL;
    m_plbLockMgr           = NULL;
    m_fFlushed             = TRUE;
    m_grfMode              = 0;

    ZeroMemory(&m_PathInfo, sizeof(m_PathInfo));
}

CTransformedLockBytes::CImpILockBytes::~CImpILockBytes(void)
{
    if (m_pTransformInstance)
    {
        if (!m_fFlushed)
            m_pTransformInstance->Flush();

        m_pTransformInstance->Release();

        if (m_plbLockMgr)
            m_plbLockMgr->Release();

        if (ActiveMark())
            MarkInactive();
    }
    
    if (m_pITFS)
        m_pITFS->Release();
}

// Initialing routines:

HRESULT CTransformedLockBytes::CImpILockBytes::InitOpen(PathInfo *pPathInfo, 
                   TransformDescriptor *pTransformDescriptor,
                   IITFileSystem *pITFS
                  )
{
    m_PathInfo = *pPathInfo;

    m_pTransformDescriptor = pTransformDescriptor;
    m_pTransformInstance   = pTransformDescriptor->apTransformInstance[0];
    m_pITFS                = pITFS;

    m_pTransformInstance->AddRef();
    m_pITFS             ->AddRef();
    
    MarkActive(pTransformDescriptor->pLockBytesChain);

    return NO_ERROR;
}


ILockBytes *CTransformedLockBytes::CImpILockBytes::FindTransformedLockBytes
    (const WCHAR * pwszFileName,
     TransformDescriptor *pTransformDescriptor                                          
    )
{
	return FindMatchingLockBytes(pwszFileName, (CImpITUnknown *) pTransformDescriptor->pLockBytesChain);
}


// ILockBytes methods:

HRESULT STDMETHODCALLTYPE CTransformedLockBytes::CImpILockBytes::ReadAt( 
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [length_is][size_is][out] */ void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbRead)
{
    ImageSpan SpanInfo;

    SpanInfo.uliHandle = m_PathInfo.ullcbOffset.Uli();
    SpanInfo.uliSize   = m_PathInfo.ullcbData  .Uli();

    CSyncWith sw(m_pTransformDescriptor->cs);
  
    ULONG cbRead = 0;

    HRESULT hr = m_pTransformInstance->ReadAt(ulOffset, pv, cb, &cbRead, &SpanInfo);
    
    if (pcbRead) 
        *pcbRead = cbRead;

    return hr;
}


HRESULT STDMETHODCALLTYPE CTransformedLockBytes::CImpILockBytes::WriteAt( 
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [size_is][in] */ const void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbWritten)
{
    ImageSpan SpanInfo;

    SpanInfo.uliHandle = m_PathInfo.ullcbOffset.Uli();
    SpanInfo.uliSize   = m_PathInfo.ullcbData  .Uli();
    
    CSyncWith(m_pTransformDescriptor->cs);

    ULONG cbWritten = 0;

    HRESULT hr = m_pTransformInstance->WriteAt(ulOffset, pv, cb, &cbWritten, &SpanInfo);

    if (pcbWritten)
        *pcbWritten = cbWritten;

    if (   m_PathInfo.ullcbOffset != SpanInfo.uliHandle
        || m_PathInfo.ullcbData   != SpanInfo.uliSize
       )
    {
        m_PathInfo.ullcbOffset = SpanInfo.uliHandle;
        m_PathInfo.ullcbData   = SpanInfo.uliSize;

		CSyncWith sw(g_csITFS);

        HRESULT hr2 = m_pITFS->UpdatePathInfo(&m_PathInfo);

        if (!SUCCEEDED(hr2))
            return hr2;
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE CTransformedLockBytes::CImpILockBytes::Flush( void)
{
    CSyncWith sw(g_csITFS);

    HRESULT hr = m_pTransformInstance->Flush();

    return hr;
}

HRESULT STDMETHODCALLTYPE CTransformedLockBytes::CImpILockBytes::SetSize( 
    /* [in] */ ULARGE_INTEGER cb)
{
    return NO_ERROR;
}


HRESULT STDMETHODCALLTYPE CTransformedLockBytes::CImpILockBytes::LockRegion( 
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType)
{
    CSyncWith sw(m_pTransformDescriptor->cs);

    HRESULT hr = NO_ERROR;

    if (!m_plbLockMgr)
    {
        hr = CFSLockBytes::CreateTemp(NULL, &m_plbLockMgr);

        if (!SUCCEEDED(hr))
            return hr;
    }

    return m_plbLockMgr->LockRegion(libOffset, cb, dwLockType);
}


HRESULT STDMETHODCALLTYPE CTransformedLockBytes::CImpILockBytes::UnlockRegion( 
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType)
{
    CSyncWith(m_pTransformDescriptor->cs);

    HRESULT hr = NO_ERROR;

    if (!m_plbLockMgr)
         hr = STG_E_LOCKVIOLATION;
    else hr = m_plbLockMgr->UnlockRegion(libOffset, cb, dwLockType);

    return hr;
}


HRESULT STDMETHODCALLTYPE CTransformedLockBytes::CImpILockBytes::Stat( 
    /* [out] */ STATSTG __RPC_FAR *pstatstg,
    /* [in] */ DWORD grfStatFlag)
{
    CSyncWith(m_pTransformDescriptor->cs);

    pstatstg->type                 = STGTY_LOCKBYTES;
    pstatstg->cbSize               = m_PathInfo.ullcbData.Uli();
    pstatstg->grfMode              = m_grfMode;
    pstatstg->grfLocksSupported    = LOCK_EXCLUSIVE;
    pstatstg->clsid                = CLSID_NULL;
    pstatstg->grfStateBits         = 0;
    pstatstg->reserved             = 0;
    pstatstg->mtime.dwLowDateTime  = 0;
    pstatstg->mtime.dwHighDateTime = 0;
    pstatstg->ctime.dwLowDateTime  = 0;
    pstatstg->ctime.dwHighDateTime = 0;
    pstatstg->atime.dwLowDateTime  = 0;
    pstatstg->atime.dwHighDateTime = 0;

    HRESULT hr = NO_ERROR;

    if (grfStatFlag != STATFLAG_NONAME)   
    {
        UINT cb = sizeof(WCHAR) * (m_PathInfo.cwcStreamPath + 1);

        pstatstg->pwcsName = PWCHAR(OLEHeap()->Alloc(cb));

        if (pstatstg->pwcsName)
            CopyMemory(pstatstg->pwcsName, m_PathInfo.awszStreamPath, cb);
        else hr = STG_E_INSUFFICIENTMEMORY;
    }

    return hr;
}

CStrmLockBytes::CImpILockBytes::CImpILockBytes
    (CStrmLockBytes *pBackObj, IUnknown *punkOuter)
    : IITLockBytes(pBackObj, punkOuter, this->m_awszLkBName)
{
    m_pStream = NULL;
}

CStrmLockBytes::CImpILockBytes::~CImpILockBytes(void)
{
    if (m_pStream)
        m_pStream->Release();
}

HRESULT CStrmLockBytes::OpenUrlStream
    (const WCHAR *pwszURL, ILockBytes **pplkb)
{
    CSyncWith sw(g_csITFS);

	ILockBytes *pLkb = CStrmLockBytes::CImpILockBytes::FindStrmLockBytes(pwszURL);

	if (pLkb)
	{
		*pplkb = pLkb;

		return NO_ERROR;
	}

	CStrmLockBytes *pLkbStream = New CStrmLockBytes(NULL);

    return FinishSetup(pLkbStream? pLkbStream->m_ImpILockBytes.InitUrlStream(pwszURL)
                                 : STG_E_INSUFFICIENTMEMORY,
                       pLkbStream, IID_ILockBytes, (PPVOID) pplkb
                      );
}


HRESULT CStrmLockBytes::Create(IUnknown *punkOuter, IStream *pStrm, ILockBytes **pplkb)
{
    CStrmLockBytes *pLkbStream = New CStrmLockBytes(punkOuter);

    return FinishSetup(pLkbStream? pLkbStream->m_ImpILockBytes.Init(pStrm)
                                 : STG_E_INSUFFICIENTMEMORY,
                       pLkbStream, IID_ILockBytes, (PPVOID) pplkb
                      );
}

// Initialing routines:

HRESULT CStrmLockBytes::CImpILockBytes::InitUrlStream(const WCHAR *pwszURL)
{
	UINT cwc = wcsLen(pwszURL);

	if (cwc >= MAX_PATH)
		return STG_E_INVALIDNAME;

	CopyMemory(m_awszLkBName, pwszURL, sizeof(WCHAR) * (cwc + 1));

	IStream *pstrmRoot = NULL;

	HRESULT hr = URLOpenBlockingStreamW(NULL, pwszURL, &pstrmRoot, 0, NULL);

	if (!SUCCEEDED(hr)) return hr;

    m_pStream = pstrmRoot;  pstrmRoot = NULL;

    MarkActive(g_pStrmLockBytesFirstActive);

    return NO_ERROR;
}

HRESULT CStrmLockBytes::CImpILockBytes::Init(IStream *pStrm)
{
    STATSTG statstg;

    HRESULT hr = pStrm->Stat(&statstg, STATFLAG_DEFAULT);

    if (!SUCCEEDED(hr)) return hr;

    UINT cwc = wcsLen(statstg.pwcsName);

    if (cwc >= MAX_PATH)
    {
        OLEHeap()->Free(statstg.pwcsName);

        return STG_E_INVALIDNAME;
    }

    CopyMemory(m_awszLkBName, statstg.pwcsName, sizeof(WCHAR) * (cwc + 1));

    OLEHeap()->Free(statstg.pwcsName);

    m_pStream = pStrm;

    m_pStream->AddRef();

    MarkActive(g_pStrmLockBytesFirstActive);

    return NO_ERROR;
}


// Search routine

ILockBytes *CStrmLockBytes::CImpILockBytes::FindStrmLockBytes(const WCHAR * pwszFileName)
{
	return FindMatchingLockBytes(pwszFileName, (CImpITUnknown *) g_pStrmLockBytesFirstActive);
}


// ILockBytes methods:

HRESULT STDMETHODCALLTYPE CStrmLockBytes::CImpILockBytes::ReadAt( 
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [length_is][size_is][out] */ void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbRead)
{
    CSyncWith sw(m_cs);

    HRESULT hr = m_pStream->Seek(*(LARGE_INTEGER *)&ulOffset, STREAM_SEEK_SET, NULL);

    if (!SUCCEEDED(hr)) return hr;

    hr = m_pStream->Read(pv, cb, pcbRead);

    return hr;
}


HRESULT STDMETHODCALLTYPE CStrmLockBytes::CImpILockBytes::WriteAt( 
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [size_is][in] */ const void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbWritten)
{
    CSyncWith sw(m_cs);

    HRESULT hr = m_pStream->Seek(*(LARGE_INTEGER *)&ulOffset, STREAM_SEEK_SET, NULL);

    if (!SUCCEEDED(hr)) return hr;

    hr = m_pStream->Write(pv, cb, pcbWritten);

    return hr;
}


HRESULT STDMETHODCALLTYPE CStrmLockBytes::CImpILockBytes::Flush( void)
{
    return NO_ERROR;
}


HRESULT STDMETHODCALLTYPE CStrmLockBytes::CImpILockBytes::SetSize( 
    /* [in] */ ULARGE_INTEGER cb)
{
    return m_pStream->SetSize(cb);
}


HRESULT STDMETHODCALLTYPE CStrmLockBytes::CImpILockBytes::LockRegion( 
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType)
{
    return m_pStream->LockRegion(libOffset, cb, dwLockType);
}


HRESULT STDMETHODCALLTYPE CStrmLockBytes::CImpILockBytes::UnlockRegion( 
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType)
{
    return m_pStream->UnlockRegion(libOffset, cb, dwLockType);
}


HRESULT STDMETHODCALLTYPE CStrmLockBytes::CImpILockBytes::Stat( 
    /* [out] */ STATSTG __RPC_FAR *pstatstg,
    /* [in] */ DWORD grfStatFlag)
{
    HRESULT hr = m_pStream->Stat(pstatstg, grfStatFlag);

    if (SUCCEEDED(hr))
        pstatstg->type = STGTY_LOCKBYTES;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx1.c ===
#include "lzx\encoder\blkinit.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx11.c ===
#include "lzx\encoder\optenc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx10.c ===
#include "lzx\encoder\lci.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx12.c ===
#include "lzx\encoder\tree.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx13.c ===
#include "lzx\decoder\decalign.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx15.c ===
#include "lzx\decoder\decblk.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx14.c ===
#include "lzx\decoder\decapi.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx19.c ===
#include "lzx\decoder\dectree.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx17.c ===
#include "lzx\decoder\decinit.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx2.c ===
#include "lzx\encoder\block.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx20.c ===
#include "lzx\decoder\decuncmp.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx18.c ===
#include "lzx\decoder\decout.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx16.c ===
#include "lzx\decoder\decin.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx22.c ===
#include "lzx\decoder\decxlat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx21.c ===
#include "lzx\decoder\decverb.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx23.c ===
#include "lzx\decoder\ldi.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx24.c ===
#include "lzx\decoder\maketbl.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx3.c ===
#include "lzx\encoder\bsearch.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx6.c ===
#include "lzx\encoder\encstats.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx5.c ===
#include "lzx\encoder\encdata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx4.c ===
#include "lzx\encoder\encapi.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx8.c ===
#include "lzx\encoder\init.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx7.c ===
#include "lzx\encoder\enctree.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx9.c ===
#include "lzx\encoder\io.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\memalloc.h ===
// MemAlloc.h -- Memory allocation routines used by the Tome code

#ifndef __MEMALLOC_H__

#define __MEMALLOC_H__

void ValidateHeap();

PVOID AllocateMemory(UINT cb, BOOL fZeroMemory, BOOL fExceptions,
                              PSZ pszWhichFile, UINT iWhichLine);
PVOID AllocateMemory(UINT cb, BOOL fZeroMemory, BOOL fExceptions);

void * __cdecl operator new(size_t nSize, PSZ pszWhichFile, UINT iWhichLine);

#ifdef _DEBUG
#define New     new(__FILE__, __LINE__)
#else
#define New     new
#endif

 void * __cdecl operator new   (size_t nSize);
 void   __cdecl operator delete(void *pbData);

 void  ReleaseMemory(PVOID pv);

 void LiberateHeap();

#endif // __MEMALLOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\memalloc.cpp ===
// MemAlloc.cpp -- Implementations for the memory allocation routines used within Tome

#include "StdAfx.h"

static HANDLE hheap       = NULL;
static UINT   cAllocs     = 0;
static UINT   cbAllocated = 0;
static UINT   cFrees      = 0;
static UINT   cbFreed     = 0;


// static SYSTEM_INFO si;

static PVOID pvTrap= NULL;

#define HEAP_SIZE_LIMIT 500000

typedef struct _HeapHeader
        {
            struct _HeapHeader *phhNext;
            struct _HeapHeader *phhPrev;

            PSZ   pszFileWhereAllocated;
            UINT  iLineWhereAllocated;
            UINT  cbAllocated;
            PVOID pvAllocated;

        } HeapHeader, *PHeapHeader;


void * __cdecl operator new(size_t nSize, PSZ pszWhichFile, UINT iWhichLine)
{
    return AllocateMemory((UINT) nSize, FALSE, FALSE, pszWhichFile, iWhichLine);
}

void * __cdecl operator new(size_t nSize)
{
     RonM_ASSERT(FALSE);  // This routine should not be called by the debugging version
                     // so long as everyone uses the New macro instead of the new
                     // operator.
     
     return AllocateMemory((UINT) nSize, FALSE, FALSE);
}

void __cdecl operator delete(void *pbData)
{
    ReleaseMemory(pbData);
}

#define BOOLEVAL(f) ((f) ? "TRUE" : "FALSE")

static PHeapHeader phhAllocatedChain= NULL;

PVOID AllocateMemory(UINT cb, BOOL fZeroMemory, BOOL fExceptions, PSZ pszWhichFile, UINT iWhichLine)
{
    if (hheap == NULL)
    { 
        hheap = GetProcessHeap();

		RonM_ASSERT(hheap != NULL);

		if (hheap == NULL) return NULL;
	//	GetSystemInfo(&si);
    }

    PVOID       pv  = NULL;
    PHeapHeader phh = NULL;

    fZeroMemory= TRUE; // for now...

    do
    {
        if (cb <= HEAP_SIZE_LIMIT)
        {

            UINT fHeapOptions= 0;

            if (fZeroMemory) fHeapOptions |= HEAP_ZERO_MEMORY;

            RonM_ASSERT(HeapValidate(hheap, 0, NULL));
            
            pv= (PVOID) HeapAlloc(hheap, fHeapOptions, cb + sizeof(HeapHeader));

        }
        else
            pv= VirtualAlloc(NULL, cb + sizeof(HeapHeader), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

        if (pv)
        {
            phh= (PHeapHeader) pv;

            pv= PVOID(phh + 1);
        }
        else 
        {
            if (fExceptions)
                RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
            else return NULL;
        }
    } while (pv == NULL);  // Don't leave unhappy

#ifdef _DEBUG

    phh->pszFileWhereAllocated = pszWhichFile;
    phh->  iLineWhereAllocated = iWhichLine;
    phh->          cbAllocated = cb;
    phh->          pvAllocated = pv;
    phh->              phhNext = phhAllocatedChain;
    phh->              phhPrev = NULL;
    
    if (phhAllocatedChain) phhAllocatedChain->phhPrev= phh;
    
    phhAllocatedChain= phh;

    ++cAllocs;
    cbAllocated += cb;

    if (pvTrap) RonM_ASSERT(pv != pvTrap);

#else // _DEBUG

    phh->cbAllocated= cb;

#endif // _DEBUG 

    return pv;
}

PVOID AllocateMemory(UINT cb, BOOL fZeroMemory, BOOL fExceptions)
{
    if (hheap == NULL)
    { 
        hheap = GetProcessHeap();

		RonM_ASSERT(hheap != NULL);

		if (hheap == NULL) return NULL;
    }

    PVOID       pv  = NULL;
    PHeapHeader phh = NULL;

    fZeroMemory= TRUE; // for now...

    do
    {
        if (cb <= HEAP_SIZE_LIMIT)
        {

            UINT fHeapOptions= 0;

            if (fZeroMemory) fHeapOptions |= HEAP_ZERO_MEMORY;

            RonM_ASSERT(HeapValidate(hheap, 0, NULL));
            
            pv= (PVOID) HeapAlloc(hheap, fHeapOptions, cb + sizeof(HeapHeader));

        }
        else
            pv= VirtualAlloc(NULL, cb + sizeof(HeapHeader), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

        if (pv)
        {
            phh= (PHeapHeader) pv;

            pv= PVOID(phh + 1);
        }
        else 
        {
            if (fExceptions)
                RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
            else return NULL;
        }
    } while (pv == NULL);  // Don't leave unhappy

    phh->cbAllocated= cb;

    return pv;
}

#ifdef _DEBUG 

void ValidateHeap()
{
    RonM_ASSERT(HeapValidate(hheap, 0, NULL));
}

#endif // _DEBUG

void ReleaseMemory(PVOID pv)
{
    RonM_ASSERT(HeapValidate(hheap, 0, NULL));
    
    PHeapHeader phh= PHeapHeader(pv) - 1;

    RonM_ASSERT(phh->pvAllocated == pv);

#ifdef _DEBUG

    if (phh->phhNext) phh->phhNext->phhPrev = phh->phhPrev;
    if (phh->phhPrev) phh->phhPrev->phhNext = phh->phhNext;
    else                  phhAllocatedChain = phh->phhNext;

#endif // _DEBUG

    pv= PVOID(phh);

    UINT cb= phh->cbAllocated;

    cbFreed+= cb;
    
    ++cFrees;

    if (cb <= HEAP_SIZE_LIMIT)    HeapFree(hheap, 0, pv);
    else                       VirtualFree(pv, 0, MEM_RELEASE);

    RonM_ASSERT(HeapValidate(hheap, 0, NULL));
}

#ifdef _DEBUG

void DumpResidualAllocations()
{
    char acDebugBuff[256];

    wsprintf(acDebugBuff, "%u Orphan Allocations (%u byte total):\n", cAllocs - cFrees, cbAllocated - cbFreed);
    
    OutputDebugString(acDebugBuff);
    
    UINT iOrphan= 0;
    
    for (PHeapHeader phh= phhAllocatedChain; phh; phh= phh->phhNext)
    {
        wsprintf(acDebugBuff, 
                 "  [%u]: %10u Bytes @ 0x%08x Allocated in %s[%u]\n", iOrphan++,
                 phh->cbAllocated, UINT_PTR(phh->pvAllocated),
                 phh->pszFileWhereAllocated,
                 phh->iLineWhereAllocated
                );        
                                                                     
        OutputDebugString(acDebugBuff);
    }
}

#endif _DEBUG

void LiberateHeap()
{
    if (hheap == NULL) return;
    
#ifdef _DEBUG

    if (phhAllocatedChain) DumpResidualAllocations();
    
#endif // _DEBUG

    // BOOL fDone= HeapDestroy(hheap);
    
#ifdef _DEBUG

    UINT iReason= GetLastError();

#endif // _DEBUG

    // RonM_ASSERT(fDone);
    
    hheap = NULL;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\moniker.h ===
// Moniker.h  -- IMoniker interface for ITSS objects

#ifndef __MONIKER_H__

#define __MONIKER_H__

class CStorageMoniker : public CITUnknown
{
public:
    
    // Creator:

    static HRESULT CreateStorageMoniker(IUnknown *punkOuter, 
                                        IBindCtx __RPC_FAR *pbc, 
                                        LPOLESTR pszDisplayName,
                                        ULONG __RPC_FAR *pchEaten, 
                                        IMoniker __RPC_FAR *__RPC_FAR *ppmkOut
                                       );

    // Destructor:

    ~CStorageMoniker(void);

private:

    // Constructor:

    CStorageMoniker(IUnknown *punkOuter);
    
    class CImpIStorageMoniker : public IITMoniker
    {
    public:

        CImpIStorageMoniker(CStorageMoniker *pBackObj, IUnknown *punkOuter);
        ~CImpIStorageMoniker(void);

        HRESULT InitCreateStorageMoniker(IBindCtx __RPC_FAR *pbc,
                                         LPOLESTR pszDisplayName,
                                         ULONG __RPC_FAR *pchEaten 
                                        );

        // IPersist methods

        HRESULT STDMETHODCALLTYPE GetClassID( 
            /* [out] */ CLSID __RPC_FAR *pClassID);

        // IPersistStream methods

        HRESULT STDMETHODCALLTYPE IsDirty( void);
        
        HRESULT STDMETHODCALLTYPE Load( 
            /* [unique][in] */ IStream __RPC_FAR *pStm);
        
        HRESULT STDMETHODCALLTYPE Save( 
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ BOOL fClearDirty);
        
        HRESULT STDMETHODCALLTYPE GetSizeMax( 
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);
            
        // IMoniker methods

        /* [local] */ HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [in] */ REFIID riidResult,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvResult);
        
        /* [local] */ HRESULT STDMETHODCALLTYPE BindToStorage( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);
        
        HRESULT STDMETHODCALLTYPE Reduce( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ DWORD dwReduceHowFar,
            /* [unique][out][in] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkToLeft,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkReduced);
        
        HRESULT STDMETHODCALLTYPE ComposeWith( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmkRight,
            /* [in] */ BOOL fOnlyIfNotGeneric,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkComposite);
        
        HRESULT STDMETHODCALLTYPE Enum( 
            /* [in] */ BOOL fForward,
            /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker);
        
        HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmkOtherMoniker);
        
        HRESULT STDMETHODCALLTYPE Hash( 
            /* [out] */ DWORD __RPC_FAR *pdwHash);
        
        HRESULT STDMETHODCALLTYPE IsRunning( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkNewlyRunning);
        
        HRESULT STDMETHODCALLTYPE GetTimeOfLastChange( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [out] */ FILETIME __RPC_FAR *pFileTime);
        
        HRESULT STDMETHODCALLTYPE Inverse( 
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk);
        
        HRESULT STDMETHODCALLTYPE CommonPrefixWith( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkPrefix);
        
        HRESULT STDMETHODCALLTYPE RelativePathTo( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkRelPath);
        
        HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName);
        
        HRESULT STDMETHODCALLTYPE ParseDisplayName( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG __RPC_FAR *pchEaten,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut);
        
        HRESULT STDMETHODCALLTYPE IsSystemMoniker( 
            /* [out] */ DWORD __RPC_FAR *pdwMksys);

    private:

        HRESULT STDMETHODCALLTYPE OpenRootStorage(DWORD grfMode);

		IStorage         *m_pStorageRoot; // Initially Null; Set when we instantiate
                                          // the storage corresponding to the moniker
        WCHAR             m_awszStorageFile[MAX_PATH]; // Path to root storage object  
        WCHAR             m_awszStoragePath[MAX_PATH]; // Path within storage object
#ifdef IE30Hack
        CHAR              m_acsTempFile[MAX_PATH];
        CHAR             *m_pcsDisplayName;
#endif // IE30Hack
    };

    CImpIStorageMoniker  m_ImpIStorageMoniker;
};

typedef CStorageMoniker *PCStorageMoniker;

extern GUID aIID_CStorageMoniker[];

extern UINT cInterfaces_CStorageMoniker;

inline CStorageMoniker::CStorageMoniker(IUnknown *pUnkOuter)
    : m_ImpIStorageMoniker(this, pUnkOuter), 
      CITUnknown(aIID_CStorageMoniker, cInterfaces_CStorageMoniker, &m_ImpIStorageMoniker)
{

}

inline CStorageMoniker::~CStorageMoniker(void)
{
}

HRESULT STDMETHODCALLTYPE FindRootStorageFile(WCHAR * pwszStorageFile);

#endif // __MONIKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\moniker.cpp ===
// Moniker.cpp -- Implementation for the CStorageMoniker class

#include "stdafx.h"


HRESULT CStorageMoniker::CreateStorageMoniker
                         (IUnknown *punkOuter, 
                          IBindCtx __RPC_FAR *pbc, 
                          LPOLESTR pszDisplayName,
                          ULONG __RPC_FAR *pchEaten,
                          IMoniker __RPC_FAR *__RPC_FAR *ppmkOut
                         )
{
    CStorageMoniker *pstmk = New CStorageMoniker(punkOuter);

    return FinishSetup(pstmk? pstmk->m_ImpIStorageMoniker.InitCreateStorageMoniker
                                  (pbc, pszDisplayName, pchEaten)
                            : STG_E_INSUFFICIENTMEMORY,
                       pstmk, IID_IMoniker, (PPVOID) ppmkOut
                      );
}

CStorageMoniker::CImpIStorageMoniker::CImpIStorageMoniker
    (CStorageMoniker *pBackObj, IUnknown *punkOuter)
    : IITMoniker(pBackObj, punkOuter)
{
    m_pStorageRoot       = NULL;
    m_awszStorageFile[0] = 0;
    m_awszStoragePath[0] = 0;
#ifdef IE30Hack
    m_acsTempFile    [0] = 0;
    m_pcsDisplayName     = NULL;
#endif // IE30Hack
}

CStorageMoniker::CImpIStorageMoniker::~CImpIStorageMoniker(void)
{
    if (m_pStorageRoot)
        m_pStorageRoot->Release();

#ifdef IE30Hack
    if (m_pcsDisplayName)
    {
        UnlockUrlCacheEntryFile(m_pcsDisplayName, 0);

        delete [] m_pcsDisplayName;
    }
    
    if (m_acsTempFile[0])
        DeleteFile(m_acsTempFile);
#endif // IE30Hack
}

HRESULT CStorageMoniker::CImpIStorageMoniker::InitCreateStorageMoniker
                          (IBindCtx __RPC_FAR *pbc,
                           LPOLESTR pszDisplayName,
                           ULONG __RPC_FAR *pchEaten 
                          )
{
    DWORD cwc = wcsLen(pszDisplayName) + 1;
    DWORD cb  = cwc * sizeof(WCHAR);

    PWCHAR pwcsCopy = PWCHAR(_alloca(cwc * sizeof(WCHAR)));

    if (!pwcsCopy) return E_OUTOFMEMORY;

    memCpy(pwcsCopy, pszDisplayName, cb);

    PWCHAR pwcsExternal = NULL;
    PWCHAR pwcsInternal = NULL;
    PWCHAR pwcsProtocol = NULL;

    HRESULT hr = DisectUrl(pwcsCopy, &pwcsProtocol, &pwcsExternal, &pwcsInternal);

    if (!SUCCEEDED(hr))
        return (hr == INET_E_DEFAULT_ACTION)? INET_E_INVALID_URL : hr;

    wcsCpy(m_awszStorageFile, pwcsExternal);
    wcsCpy(m_awszStoragePath, pwcsInternal);

    cwc = wcsLen(m_awszStoragePath);

    if (m_awszStoragePath[cwc-1] == L'/') 
        m_awszStoragePath[cwc-1] =  0;
    
    *pchEaten = cwc - 1;

    return NO_ERROR;
}

// IPersist methods

HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::GetClassID( 
    /* [out] */ CLSID __RPC_FAR *pClassID)
{
    *pClassID = CLSID_ITStorage;

    return NOERROR;
}


// IPersistStream methods

HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::IsDirty( void)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::Load( 
    /* [unique][in] */ IStream __RPC_FAR *pStm)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::Save( 
    /* [unique][in] */ IStream __RPC_FAR *pStm,
    /* [in] */ BOOL fClearDirty)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::GetSizeMax( 
    /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}

    
// IMoniker methods

/* [local] */ HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::BindToObject( 
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [in] */ REFIID riidResult,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvResult)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}

#pragma data_seg(".text", "CODE")
static const char txtTomeMapKey   [] = ITSS_MAP;
static const char txtTomeFinderKey[] = ITSS_FINDER;
#pragma data_seg()

HRESULT STDMETHODCALLTYPE FileExists(WCHAR *pwszStorageFile, const CHAR *pcsFullPath)
{
    if (GetFileAttributes(pcsFullPath) == (DWORD) -1)
        return STG_E_FILENOTFOUND;

    // File exists!  Now we need to convert the path to Unicode and store it.

    WCHAR awcsPath[MAX_PATH];

    UINT cwc = MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, pcsFullPath, -1, 
                                   awcsPath, MAX_PATH
                                  );

    if (cwc == 0 || cwc > MAX_PATH) 
        return STG_E_FILENOTFOUND;

    wcsCpy(pwszStorageFile, awcsPath);

    return S_OK;
}

char * __stdcall FindMBCSExtension(char *pcsFileName)
{
    char *pchLastPeriod = NULL;
    
    for (;; pcsFileName = DBCS_SYSTEM()? CharNext(pcsFileName) : pcsFileName + 1)
    {
        char ch = *pcsFileName;

        if (!ch) break;

        if (ch != '.') continue;

        pchLastPeriod = pcsFileName;
    }

    return pchLastPeriod;
}

HRESULT STDMETHODCALLTYPE FindRootStorageFile(WCHAR * pwszStorageFile)
{
    char csRoot  [MAX_PATH * 2];  // * 2 for DBCS locales
    char csBuffer[MAX_PATH * 2];

    UINT cb = WideCharToMultiByte(CP_USER_DEFAULT(), WC_COMPOSITECHECK | WC_SEPCHARS,
                                  pwszStorageFile, 1 + wcsLen(pwszStorageFile), 
                                  csRoot, sizeof(csRoot), NULL, NULL
                                 );

    if (cb == 0)
        return STG_E_INVALIDNAME;

    LPSTR pcsFileName = NULL;

    UINT cbFull = GetFullPathName(csRoot, sizeof(csBuffer), csBuffer, &pcsFileName); 

    if (!cbFull || !pcsFileName) 
        return STG_E_INVALIDNAME;

    HRESULT hr = FileExists(pwszStorageFile, (const char *) csBuffer);
    
    if (hr == S_OK) return hr;

    HKEY  hkey;
    DWORD type;
	DWORD cbPath = MAX_PATH;

    LONG result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, txtTomeMapKey, 0, KEY_READ, &hkey);
    
    if (result == ERROR_SUCCESS) 
    {
		result = RegQueryValueEx(hkey, (const char *) pcsFileName, 0, &type, 
                                 (PBYTE) csRoot, &cbPath
                                );
		RegCloseKey(hkey);
    }

    if (result == ERROR_SUCCESS)
    {
        hr = FileExists(pwszStorageFile, (const char *) csRoot);

        if (hr == S_OK) return hr;
    }

    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, txtTomeFinderKey, 0, KEY_READ, &hkey);
    
    if (result == ERROR_SUCCESS) 
    {
		result = RegQueryValueEx(hkey, (const char *) pcsFileName, 0, &type, 
                                 (PBYTE) csRoot, &cbPath
                                );

        if (result != ERROR_SUCCESS)
        {
            char *pcsFileExtension = FindMBCSExtension(pcsFileName);

            if (pcsFileExtension)
                result = RegQueryValueEx(hkey, pcsFileExtension, 0, &type, 
                                         (PBYTE) csRoot, &cbPath
                                        );
        }

		RegCloseKey(hkey);
    }

    hr = STG_E_FILENOTFOUND;

    if (result == ERROR_SUCCESS)
    {
        CLSID clsid;

        WCHAR wcsFileName[MAX_PATH];

        UINT cwc = MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, csRoot, -1, 
                                       wcsFileName, MAX_PATH
                                      );

        if (cwc != 0)
        {    
            HRESULT hr2 = CLSIDFromString(wcsFileName, &clsid);

            if (hr2 == S_OK) 
            {
                IITFileFinder *pFileFinder = NULL;

                cwc = MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, pcsFileName, -1, 
                                          wcsFileName, MAX_PATH
                                         );
                if (cwc != 0)
                {
                    hr2 = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IITFileFinder, 
                                          (void **) &pFileFinder
                                         );
    
                    if (hr2 == S_OK)
                        __try
                        {
                            WCHAR *pwcsFullPath = NULL;
                            BOOL   fRecord      = FALSE;

                            hr2 = pFileFinder->FindThisFile((const WCHAR *) wcsFileName, &pwcsFullPath, &fRecord);

// REMOVE THIS
OutputDebugString("Moniker.cpp Find This File\n");
OutputDebugStringW(wcsFileName);
OutputDebugString("\n");
// REMOVE THIS
                            pFileFinder->Release();  pFileFinder = NULL;

                            if (hr2 == S_OK)
                            {
                                RonM_ASSERT(pwcsFullPath);

                                cb = WideCharToMultiByte(CP_USER_DEFAULT(), WC_COMPOSITECHECK | WC_SEPCHARS,
                                                         pwcsFullPath, 1 + wcsLen(pwcsFullPath), 
                                                         csRoot, sizeof(csRoot), NULL, NULL
                                                        );

                                OLEHeap()->Free(pwcsFullPath);

                                hr = (cb == 0)? STG_E_FILENOTFOUND
                                              : FileExists(pwszStorageFile, (const char *) csRoot);

                                if (hr == S_OK && fRecord)
                                {
                                    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, txtTomeMapKey, 0, KEY_READ, &hkey);
    
                                    if (result == ERROR_SUCCESS) 
                                    {
                                        result = RegSetValueEx(hkey, (const char *) pcsFileName, 0, REG_SZ, 
                                                                 (PBYTE) csRoot, lstrlen(csRoot)
                                                                );
		                                RegCloseKey(hkey);
                                    }
                                }
                            }
                        }
                        __except (TRUE) 
                        {
                            if (pFileFinder)
                                pFileFinder->Release();
                        };
                }
            }
        }
    }
    
    return hr;    
}

HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::OpenRootStorage
    (DWORD grfMode)
{
    PWCHAR pwc = wcsChr((const WCHAR *) m_awszStorageFile, L':');

    if (pwc && pwc[1] == L':') // Ignore a "::" separator 
        pwc = NULL;

    // Here we're special casing non-protocol references to a file.
    // We recognize those situations by looking for a protocol prefix.
    // Protocol prefixes have the form <Protocol Name> :
    // where <Protocol Name> is always longer than one character.

    if (!pwc || (pwc - m_awszStorageFile == 1))
    {
        HRESULT hr = FindRootStorageFile(m_awszStorageFile);

        if (hr != S_OK) return hr;
        
        return  CITFileSystem::OpenITFileSystem(NULL, (const WCHAR *) m_awszStorageFile, 
                                                grfMode, (IStorageITEx **)&m_pStorageRoot
                                               );
    }

	ILockBytes * plkbRoot = NULL;

	HRESULT hr = CStrmLockBytes::OpenUrlStream((const WCHAR *) m_awszStorageFile, 
				                               &plkbRoot
											  );
	
	if (hr == S_OK)
		hr = CITFileSystem::OpenITFSOnLockBytes(NULL, plkbRoot, grfMode, 
												(IStorageITEx **)&m_pStorageRoot
											   );

	if (plkbRoot)
		plkbRoot->Release();

	return hr;
}

const PWCHAR apwcsDefaultPages[5] = {  L"/default.htm", L"/default.html", 
                                         L"/index.htm",   L"/index.html",
                                         NULL
                                    };


/* [local] */ HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::BindToStorage( 
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr = NOERROR;
    
    BIND_OPTS bo;

    bo.cbStruct = sizeof(bo);

    hr = pbc->GetBindOptions(&bo);

    // Streams and storages are always opened read-only with share deny-none
    // in the context of a URL.

    bo.grfMode &= ~(STGM_WRITE | STGM_READWRITE); 
    bo.grfMode &= ~(STGM_SHARE_DENY_NONE | STGM_SHARE_DENY_READ 
                                         | STGM_SHARE_DENY_WRITE
                                         | STGM_SHARE_EXCLUSIVE
                   );
    bo.grfMode |= STGM_SHARE_DENY_NONE;
   
    if (hr != S_OK) return hr;

    if (!m_pStorageRoot)
    {
		hr = OpenRootStorage(bo.grfMode);

        if (hr != S_OK) return hr;
    }

    if (riid == IID_IStorage)
        hr = m_pStorageRoot->OpenStorage(m_awszStoragePath, NULL, bo.grfMode, 
                                         NULL, 0, (IStorage **) ppvObj
                                        );
    else
        if (riid == IID_IStream)
        {
            hr = m_pStorageRoot->OpenStream(m_awszStoragePath, NULL, bo.grfMode,
                                            0, (IStream **) ppvObj
                                           );
            
            if (!SUCCEEDED(hr))
            {
                const PWCHAR *ppwcsDefPages = apwcsDefaultPages;

                for (;;)
                {
                    const PWCHAR pwcsDefPage = *ppwcsDefPages++;

                    if (!pwcsDefPage) break;

                    WCHAR awszDefault[MAX_PATH];

                    wcsCpy(awszDefault, m_awszStoragePath);

                    UINT cwc= wcsLen(m_awszStoragePath) + wcsLen(pwcsDefPage);

                    if (cwc < MAX_PATH)
                    {
                        wcsCat(awszDefault, pwcsDefPage);

                        hr = m_pStorageRoot->OpenStream(awszDefault, NULL, bo.grfMode,
                                                        0, (IStream **) ppvObj
                                                       );

                        if (SUCCEEDED(hr)) 
                        {
                            wcsCpy(m_awszStoragePath, awszDefault);

                            break;
                        }
                    }
                }
            }
        }
        else return E_NOINTERFACE;

#ifdef IE30Hack
        // The following code is a slimey hack to work around a defect in the IE 3.0x
        // URLMon code. The problem is that IE 3.0 treats the trailing part of our URL
        // as if it were a file name, and that makes many things break. 
        //
        // The code below crawls up the stack and follows several pointers to locate the
        // incorrect file name and fix it to point to a file which a copy of the stream
        // we've just opened.

        if (SUCCEEDED(hr) && !IS_IE4()) // Running in IE 3.0x ???
        {
            PWCHAR pwcsDisplayName = NULL;

            // We use a try/except bracket to recover from crawl failures.

            __try
            {
                // First we compute stack frame pointers for BindToStorage 
                // and the next higher frame.
        
                DWORD *pdwFrame     = ((DWORD *) &pbc) - 3;
                DWORD *pdwFrameNext =  (DWORD *) *pdwFrame; 
                DWORD *pdwCINet;

                // We're looking for a pointer to a CINetStream object. That pointer
                // is located at different places in the retail and debug builds
                // of URLMon.

                if (pdwFrameNext - pdwFrame > 0x1b6)
                     pdwCINet = (DWORD *) pdwFrameNext[5]; // Debug  build
                else pdwCINet = (DWORD *) pdwFrame    [8]; // Retail build
        
                // From there we can get the pointer to the transaction object.

                PBYTE pbTransData = (PBYTE) pdwCINet[0x8de];

                // Then the transaction object contains the erroneous 
                // file paths.

                PWCHAR pwcsFilePath = (PWCHAR) (pbTransData + 0xC  );
                 PCHAR  pcsFilePath = ( PCHAR) (pbTransData + 0x284);

                hr = GetDisplayName(pbc, NULL, &pwcsDisplayName);
        
                if (   SUCCEEDED(hr) 
                    && !wcsicmp_0x0409((const WCHAR *) pwcsDisplayName + 14, (const WCHAR *)pwcsFilePath)
                   )
                {
#ifdef _DEBUG
                    HRESULT hr2 = 
#endif // _DEBUG
                         StreamToIEFile((IStream *) *ppvObj, pwcsDisplayName, m_pcsDisplayName,
                                        pcsFilePath, pwcsFilePath, m_acsTempFile,
                                        (IMoniker *) this, FALSE, FALSE
                                       );

                    RonM_ASSERT(SUCCEEDED(hr2));

                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
            }
            
            if (pwcsDisplayName)
                OLEHeap()->Free(pwcsDisplayName);
        }
#endif // IE30Hack    
    return hr;
}

HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::Reduce( 
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ DWORD dwReduceHowFar,
    /* [unique][out][in] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkToLeft,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkReduced)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::ComposeWith( 
    /* [unique][in] */ IMoniker __RPC_FAR *pmkRight,
    /* [in] */ BOOL fOnlyIfNotGeneric,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkComposite)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::Enum( 
    /* [in] */ BOOL fForward,
    /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::IsEqual( 
    /* [unique][in] */ IMoniker __RPC_FAR *pmkOtherMoniker)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::Hash( 
    /* [out] */ DWORD __RPC_FAR *pdwHash)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::IsRunning( 
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkNewlyRunning)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::GetTimeOfLastChange( 
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [out] */ FILETIME __RPC_FAR *pFileTime)
{
    STATSTG statstg;

    HRESULT hr = m_pStorageRoot->Stat(&statstg, STATFLAG_NONAME);

    if (!SUCCEEDED(hr))
        return hr;

    if (pFileTime)
        *pFileTime = statstg.mtime;

    return NO_ERROR;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::Inverse( 
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::CommonPrefixWith( 
    /* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkPrefix)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::RelativePathTo( 
    /* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkRelPath)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::GetDisplayName( 
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName)
{
    UINT cwcExternalPath = wcsLen(m_awszStorageFile);
    UINT cwcInternalPath = wcsLen(m_awszStoragePath);
    UINT cwcDisplayName  = (IS_IE4()? 9 : 16) + cwcExternalPath + cwcInternalPath;
    
    PWCHAR pwcsDisplayName = PWCHAR(OLEHeap()->Alloc(sizeof(WCHAR) * (cwcDisplayName + 1)));
    
    if (!pwcsDisplayName)
        return E_OUTOFMEMORY;

    wcsCpy(pwcsDisplayName, IS_IE4()? L"ms-its:"  :L"mk:@msitstore:");
    wcsCat(pwcsDisplayName, m_awszStorageFile);
    wcsCat(pwcsDisplayName, L"::");
    wcsCat(pwcsDisplayName, m_awszStoragePath);

    *ppszDisplayName = pwcsDisplayName;

    return NO_ERROR;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::ParseDisplayName( 
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [in] */ LPOLESTR pszDisplayName,
    /* [out] */ ULONG __RPC_FAR *pchEaten,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorageMoniker::CImpIStorageMoniker::IsSystemMoniker( 
    /* [out] */ DWORD __RPC_FAR *pdwMksys)
{
    return MKSYS_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\msitstg.h ===
// MSITStg.h -- Interface declaration for IMSITStorage

#ifndef __MSITSTG_H__

#define __MSITSTG_H__

// Class ID for the ITSS File System:

DEFINE_GUID(CLSID_ITStorage, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Inteface ID for the IITStorage interface:

DEFINE_GUID(IID_ITStorage, 
0x88cc31de, 0x27ab, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IITStorageEx interface:

DEFINE_GUID(IID_ITStorageEx, 
0xe74097b0, 0x292d, 0x11d1, 0xb6, 0x7e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

// Class ID for the FSStorage wrapper for the Win32 file system:

// {D54EEE56-AAAB-11d0-9E1D-00A0C922E6EC}
DEFINE_GUID(CLSID_IFSStorage, 
0xd54eee56, 0xaaab, 0x11d0, 0x9e, 0x1d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IFSStorage interface:

// {8BB2438A-A70C-11d0-9E1C-00A0C922E6EC}
DEFINE_GUID(IID_IFSStorage, 
0x8bb2438a, 0xa70c, 0x11d0, 0x9e, 0x1c, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStream interface

DEFINE_GUID(IID_IStreamITEx, 
0xeb19b681, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStorage interface

DEFINE_GUID(IID_IStorageITEx, 
0xeb19b680, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the Data Space Manager used within an ITStorage object:

DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the plug-in data transforms:

DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the File Finder interface (used with URLs):

DEFINE_GUID(IID_IITFileFinder, 
0x77231260, 0x19c0, 0x11d1, 0xb6, 0x6e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

/*

The IITStorage interface parallels the API's defined for creating and
opening Docfiles. So if you have code that currently uses Docfiles for 
your storage mechanism, you can easily convert over to using ITS files 
instead. 

ITS files use a different on-disk structure to optimize them for very 
fast stream access and very low overhead. ITS files can manage thousands 
or millions of streams with very good access performance and very small 
directory space requirements. This makes ITS files ideal for CD-Roms and
for data collections that you'll download across the Internet. 

To make the conversion to ITS files you'll need to call CoCreateInstance 
with the class-id CLSID_ITStorage and the interface-id IID_ITStorage. You'll 
get back an interface pointer, say pItStg. Then you'll need to adjust the
places where your code creates or opens Docfiles. Instead of StgCreateDocfile
you'll call pItStg->StgCreateDocfile, and instead of StgOpenStorage, you'll
call pItStg->StgOpenStorage. In both cases you'll get back an IStorage 
interface pointer, say pIStg, which you can use just as you did before.

That's it. In general the rest of your code shouldn't have to change. There 
are some functional difference between ITS files and Docfiles -- ITS files
don't support STGM_TRANSACTED, for example. So if you have to have transacted 
file operations, you can't use ITS files -- at least for now. However in
almost all other respects ITS files interfaces can directly replace Docfile
interfaces.

Converting your data is also easy. Just open one of  your Docfiles using
StgOpenStorage, create a new ITS file via pItStg->StgCreateDocfile, and then
use the CopyTo interface to copy your data objects and their storage heirarchy
over to the ITS file:
    
    pStgDocfile->CopyTo(0, NULL, NULL, pStgITS);

In some cases you may want to exercise some control over the internal parameters
kept in an ITS file. You do this by calling SetControlData to give the IITStorage
interface a block of ITS control data. Then each subsequent call to StgCreateDocfile
will use that control data. The ITS control data determines, among other things,
the tradeoff between efficient random access to the stream data and minimizing the
size of an ITS file.  

The actual structure and interpretation of ITS control data is documented below.
(See the ITSFS_Control_Data data type). You can get default control data via the
DefaultControlData fuction. Note that DefaultControlData allocates the control
structure using IMalloc::Alloc as provided by CoGetMalloc and expects that your code will
deallocate the structure using the IMalloc::Free.

 */

// IID_IStreamITEx interface declaration:

DECLARE_INTERFACE_(IStreamITEx, IStream)
{
    // IStreamITEx methods
    
    STDMETHOD(SetDataSpaceName)(const WCHAR   * pwcsDataSpaceName) PURE;
    STDMETHOD(GetDataSpaceName)(       WCHAR **ppwcsDataSpaceName) PURE;

    STDMETHOD(Flush)() = 0;
};

// IID_IStorageITEx interface declaration:

DECLARE_INTERFACE_(IStorageITEx, IStorage)
{
    // IStorageITEx methods:

    STDMETHOD(GetCheckSum)(ULARGE_INTEGER *puli) PURE;
    STDMETHOD(CreateStreamITEx)(const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
                            DWORD grfMode, DWORD reserved1, DWORD reserved2, 
                            IStreamITEx ** ppstm
                           ) PURE;
    STDMETHOD(OpenStreamITEx)(const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
                          DWORD reserved2, IStreamITEx ** ppstm) PURE;
};

// IStorageITEx::CreateStream lets you specify the data space in which a stream
// is to be created. Currently two dataspaces are supported:
//
//    L"Uncompressed" -- This dataspace applies no compression.
//    L"MSCompressed" -- This dataspace applies a default compression transform.


#pragma warning( disable : 4200)

// ITS_Control_Data is the generic structure of control data passed to the 
// IITStorage::SetControlData method or returned by the IITStorage::DefaultControlData
// method.

typedef struct _ITS_Control_Data
{
    UINT cdwControlData;     // Number of DWords to follow.
    UINT adwControlData[0];  // Actually this will be adwControlData[cdwControlData]

} ITS_Control_Data, *PITS_Control_Data;  


// ITSFS_Control_Data is the actual prefix structure of control data for IITStorage. 

typedef struct _ITSFS_Control_Data
{
    UINT cdwFollowing;     // Must be 6 or 13

    DWORD cdwITFS_Control; // Must be 5
    DWORD dwMagic;         // Must be MAGIC_ITSFS_CONTROL (see below)
    DWORD dwVersion;       // Must be 1
    DWORD cbDirectoryBlock;// Size in bytes of directory blocks (Default is 8192)
    DWORD cMinCacheEntries;// Least upper bound on the number of directory blocks
	                       // which we'll cache in memory. (Default is 20)
    DWORD fFlags;          // Control bit flags (see below). 
	                       // Default value is fDefaultIsCompression.

} ITSFS_Control_Data, *PITSFS_Control_Data;

// Signature value for ITSFS_Control_Data

const DWORD MAGIC_ITSFS_CONTROL    = 'I' | ('T' << 8) | ('S' << 16) | ('C' << 24);

// Bit flag definitions for ITSFS_Control_Data::fFlags

const DWORD fDefaultIsCompression  = 0x00000001;
const DWORD fDefaultIsUncompressed = 0x00000000;

// Note all other fFlags bits positions are reserved for future releases and should be 
// set to zero.

// When ITSFS_Control_Data::cdwFollowing is > 6, we assume that LZX_Control_Data follows
// immediately after. (See the XformControlData type below) LZX_Control_Data defines
// parameters which control the default compressed data space. 
//
// If ITSFS_Control_Data::cdwFollowing is 6, we use default values for the LZX
// control data.

typedef struct _LZX_Control_Data
{
    UINT  cdwControlData; // Must be 6

    DWORD dwLZXMagic;     // Must be LZX_MAGIC (see below)
    DWORD dwVersion;      // Must be 2
    DWORD dwMulResetBlock;// Number of blocks between compression resets.  (Default: 4)
    DWORD dwMulWindowSize;// Maximum number of blocks kept in data history (Default: 4)
    DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
    DWORD dwOptions;  // Option flags (Default: fOptimizeCodeStreams)

} LZX_Control_Data, *PLZX_Control_Data;

// Note: The block size for LZX compression is 32768 bytes.

const DWORD LZX_MAGIC           = 'L' | ('Z' << 8 ) | ('X' << 16) | ('C' << 24);

// Values for LZX_Control_Data::dwOptions

const DWORD fOptimizeCodeStreams = 0x00000001;

// Note that all other flag bit positions are reserved for future releases and should be
// set to zero.


// The second parameter for the IITStorage::Compact method below is an enueration
// which defines the level of compaction to do.

typedef enum ECompactionLev {COMPACT_DATA=0, COMPACT_DATA_AND_PATH} ;

DECLARE_INTERFACE_(IITStorage, IUnknown)
{
    // IITStorage methods

    STDMETHOD(StgCreateDocfile)(const WCHAR * pwcsName, DWORD grfMode, 
                                DWORD reserved, IStorage ** ppstgOpen
                               ) PURE;

    STDMETHOD(StgCreateDocfileOnILockBytes)(ILockBytes * plkbyt, DWORD grfMode,
                                            DWORD reserved, IStorage ** ppstgOpen
                                           ) PURE;

    STDMETHOD(StgIsStorageFile)(const WCHAR * pwcsName) PURE;

    STDMETHOD(StgIsStorageILockBytes)(ILockBytes * plkbyt) PURE;

    STDMETHOD(StgOpenStorage)(const WCHAR * pwcsName, IStorage * pstgPriority, 
                              DWORD grfMode, SNB snbExclude, DWORD reserved, 
                              IStorage ** ppstgOpen
                             ) PURE;

    STDMETHOD(StgOpenStorageOnILockBytes)
                  (ILockBytes * plkbyt, IStorage * pStgPriority, DWORD grfMode, 
                   SNB snbExclude, DWORD reserved, IStorage ** ppstgOpen
                  ) PURE;

    STDMETHOD(StgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                           FILETIME const * patime, FILETIME const * pmtime
                          ) PURE;

    STDMETHOD(SetControlData)(PITS_Control_Data pControlData) PURE;

    STDMETHOD(DefaultControlData)(PITS_Control_Data *ppControlData) PURE;
		
    STDMETHOD(Compact)(const WCHAR * pwcsName, ECompactionLev iLev) PURE;
};

DECLARE_INTERFACE_(IITStorageEx, IITStorage)
{
    STDMETHOD(StgCreateDocfileForLocale)
        (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(StgCreateDocfileForLocaleOnILockBytes)
        (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(QueryFileStampAndLocale)(const WCHAR *pwcsName, DWORD *pFileStamp, 
                                                              DWORD *pFileLocale) PURE;
    
    STDMETHOD(QueryLockByteStampAndLocale)(ILockBytes * plkbyt, DWORD *pFileStamp, 
                                                                DWORD *pFileLocale) PURE;
};

typedef IITStorage *PIITStorage;

DECLARE_INTERFACE_(IFSStorage, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)  (THIS_ REFIID, VOID **) PURE;
    STDMETHOD_(ULONG, AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IFSStorage methods

    STDMETHOD(FSCreateStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSOpenStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSCreateStream)(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateTemporaryStream)(IStream **ppStrm) PURE;
    STDMETHOD(FSOpenStream  )(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateLockBytes)(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;
    STDMETHOD(FSCreateTemporaryLockBytes)(ILockBytes **ppLkb) PURE;
    STDMETHOD(FSOpenLockBytes  )(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;

    STDMETHOD(FSStgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                             FILETIME const * patime, FILETIME const * pmtime
                            ) PURE;
};

typedef IFSStorage *PIFSStorage;

/*
**   Data Spaces -- What they are.

Within an ITS file we store information in one or more data spaces. A data space
is a container which holds the bits which represent a collection of streams. Each
data space has a name and an associated collection of transforms.

Those transforms take the raw data which you write to an ITS stream and map it into
a representation stream. When you read from an ITS stream they do the reverse mapping
to reconstruct your original data from the representation. 

When you first create an ITS file, it contains one data space named "Default_Space"
which applies the LZX data compression transform. By default all of the streams you
create will have their data representations stored in the default data space.

If LZX compression meets your needs, and you're not concerned about data enciphering,
you can skip over the following discussion. If, on the other hand, you want to 
create additional data spaces or transforms, read on.

To create a data space, you must first get a pointer to the IDataSpaceManager interface.
Just do a QueryInterface for IID_DataSpaceManager from any storage created by the 
IITStorage interface. Then you can call the CreateDataSpace function to define a new
data space. 

When you're defining a collection of data spaces, be sure that their names are distinct.
Defining two data spaces with the same name is an error. Data space names follow the
rules for stream names. That is, they must be less than 260 characters long, and may
not contain the characters '/'. '\', '|', ':', or any character less than 0x0020.

Data spaces are kept in a separate name space. So you don't have to worry about
colliding with a stream name or a storage name. As noted above, we have defined one
special data space ("Default_Space") where all data resides if you take no action.

You can redefine that default space simply by creating a new data space with the
name "Default_Space". This is the one case where a name collision is allowed. If 
you do redefine the default data space, any data in the old space will automatically
be transformed appropriately and moved into the new default data space.  

**   Importing Items

If you have defined additional data spaces, the next step is to define which streams
and storages you want to move into the new data spaces. You do that by means of the 
IDataSpace::Import function. For example suppose you've defined the dataspace 
*pMyDataSpace and you want to import the stream "Alpha" contained in the storage 
*pThatStorage:

    pMyDataSpace->Import(pThatStorage, "Alpha");

Similarly if you want to import the storage "HTML_Pages" from pThisStorage:

    pMyDataSpace->Import(pThisStorage, "HTML_Pages");

That will recursively import the "HTML_Pages" storage and all of the streams and 
storages contained within it. It also conditions those storages so that anything
you create within them will be automatically imported into pMyDataSpace. Note that
subsequent Import operations may alter that conditioning.

If you later decide that you want to move "Alpha" back into the default data
space:

    hr = pDataSpaceManager->OpenDataSpace(L"Default_Space", &pDefaultDataSpace);

    pDefaultDataSpace->Import(pThatStorage, "Alpha");

**  Data Space Transform Sets 

When you define a data space, you must specify a set of transforms to apply to 
the items you import into the space. A transform is an interface that converts
data to some other representation. For example the LZX transform converts your 
imported data into a more compact, compressed representation. Other transforms
might implement word or phrase based dictionary compression, or they might encipher 
your data, or they might just convert from one data format to another. You could, 
for example, construct a transform to store HTML data as a Rich Text stream.

When you define a data space with more than one transform, they are applied in 
order. For example let's suppose that your transform set consists of these three:

  1. A Dictionary compression transform

  2. The LXZ transform

  3. An data encryption transform

Whenever you write data into this space, it will first be compressed using the
dictionary compression methods, then LZX compression will be applied, and finally
your information will be encrypted. When you read data the process is reversed so
that the encryption transform supplies data to the LZX transform which in turn 
provides data for the dictionary compression transform.

You define the transform set via a vector of class ids (paclsidXform). Each class id
defines a location where an implementation of IID_Transform can be found. In addition
you'll supply corresponding control data for each transform (papxfcd). The number of 
transforms is defined by the cXforms parameter.

Note that it is legal to define a space with zero transforms. This is useful when
you've got items which are already compressed and which won't benefit from an
additional layer of compression overhead.

The control data for a transform defines how it will operate in a particular
data space. For example the control data for the LZX transform defines how
aggressively it will pursue compression, and it controls the tradeoff between
random access performance and the level of compression.

The actual structure and content of the control data is documented above.
(See the LZX_Control_Data data type.)

**  Transform Factories -- How they are organized; What they do

Transforms have two functional capabilities. They can return default
control data (DefaultControlData), and they can create
transform instances (CreateTransformInstance). When the ITSS code calls your 
CreateTransformInstance function, it will supply a storage medium (pXFSpan_Base)
where transformed data is to be stored along with the control data for the
instance and several other useful pieces of information. 

The CreateTransformInstance function has several parameters that you can use 
when you need to access global and/or instance data streams. They also support
the construction of encryption transforms. You can ignore those parameters if your
transform doesn't do encryption, uses only a single pass over the data, and doesn't
rely on any data beyond the data in the stream being transformed.

  -- The rclsidXForm and pwszDataSpace parameters, respectively, tell you the Class ID
  by which your code was located, and the name of the data space in which your instance
  will be working. These values are used with the ITransformServices interface.

  -- The pXformServices parameter points to an instance of the ITranformServices interface. 
  That interface gives you access to a couple of storages where you can keep global and
  instance data for your transform. It also gives you a way to contruct a temporary
  stream that is automatically deleted when you release it. That's very handy when 
  you get a seek operation into the middle of the transformed data followed by a write 
  operation.

  If you're implementing a multipass strategy, you can get access to those storages
  from code outside the transform by doing a QueryInterface from any ITS storage for 
  the interface IID_ITransformServices. You identify the storage in question by the
  transform's class id and possibly the name of the data space instance. 

  The per-transform-instance storage is also a convenient place to put the navigation
  data necessary to support fast seek operations.

  -- The pKeyManager parameter is an interface pointer used with encryption transforms.
  It supplies the read and write keys to use with your encryption transform. Those keys
  are set by the SetKeys interface of the ITransformServices interface. This allows you
  to separate your user interface code where people will enter passwords from the 
  transform implementations. This can be useful when you want the same keys to be used 
  for several different data spaces.  

**  Transform Instances -- How they are organized; What they do

A Transform Instance is an object which simulates a data medium which can be 
suballocated. Suballocated items are managed as data spans (ITransformedSpan).
You must supply a function to create a data span (CreateTransformedSpan), and
a function to open a data span (OpenTransformedSpan). Both of those functions 
return an ITransformedSpan interface when they succeed. In addition you must
supply the function SpaceSize to return the size of the entire untransformed
data image. That is, SpaceSize returns the highest limit offset (offset + size)
of any data span created within the instance. 

A span is identified by an ImageSpan structure which defines an offset and a size 
for the span. Both values are defined in untransformed space. For the Create function
this is an output parameter, while it is an input parameter for the Open function.
Note the interaction between the ImageSpan and the WriteAt member function of the
ITransformedSpan interface.

**  Transformed Data Spans -- How they are organized; What they do

A transformed Data Span (ITransformedSpan) has two member functions -- ReadAt and 
WriteAt. Those functions are very similar to the ReadAt and WriteAt functions of
the ILockBytes interface. The difference is that WriteAt includes an extra output
parameter (pImageSpan) for recording the current span parameters. The ReadAt function
doesn't include that parameter because read operations can never change the span's
size or move it to a different offset.

**  Implementation Strategies

This section describes a few scenarios that you may encounter as you construct a 
transform along with strategies for those situations. This is an open ended list 
which will expand as we gain more experience with transforms.

Many compression and encryption transforms are designed around sequential I/O. That is,
they expect to get the raw data from a sequence of write opeations with no intervening
seek operations. In many cases such transforms also write out the transformed data to 
the base stream in ascending order. Similarly they expect read requests to come to them
with no intervening seek operations. 

The key issue for those transforms is how do you implement random access and interleaved
read, write, and seek operations. 

Leaving aside write operations for the moment, let's consider a random sequence of reads
interleaved with seek operations. One solution might be to construct a table to map from
raw data offsets to transformed data offsets. You can store such a table in the instance
storage for the current data space. 

One complication is that many compression transforms use the raw data as a dictionary. 
That is, you can only start reading from the beginning of the transformed data. You can
deal with those transforms telling them to reset themselves periodically. That gives
you a collection of starting points spread fairly evenly throught the transformed 
data. When you do this you'll need to supply a control data parameter to control the
frequency of those reset points so that your clients can make an appropriate tradeoff
between compression efficiency and random access performance.

Now what about adding random write operations to the mix? The short answer here is that
you can't do this in the middle of transformed data. One strategy would be to reconstruct
the entire raw data into a temporary stream and do all your I/O to that stream until
release time. Then at release time you can transform the revised data sequentially.

A variation on that strategy is to keep track of which reset spans are modified and 
write the modified versions of those transformed spans to the end of the base stream.
This leaves a certain amount of dead space in your transformed data, but it allows
you to defer the sequential reconstruction work to a more convenient time. The down 
side  is that it requires you to manage yet more navigation data in the instance 
storage for the data space.

 */

interface IDataSpaceManager;
interface IDataSpace;
interface ITransformServices;
interface IKeyInstance;
interface ITransformFactory;
interface ITransformInstance;

typedef struct _XformControlData
{
    UINT  cdwControlData;    // Size of this structure in DWords
    UINT  adwControlData[0]; // Actually this will be UINT adwData[cdwData];

} XformControlData, *PXformControlData;

/*
// {7C01FD0F-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpaceManager : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE CreateDataSpace
        (const WCHAR *pwszDataSpace, UINT cXforms,
         const CLSID *paclsidXform, PXformControlData paxfcd,
         IDataSpace *pITDataSpace
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenDataSpace
        (const WCHAR *pwszDataSpace, 
         IDataSpace *pITDataSpace
        ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DiscardDataSpace
        (const WCHAR *pwszDataSpace) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumDataSpaces
        (IEnumSTATSTG ** ppenum) = 0;
};


/*
// {7C01FD0E-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpace : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetTransformInfo
        (PUINT pcXforms, PUINT pcdwXformControlData, 
         CLSID *paclsid, PXformControlData pxfcd
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Import
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE ImportSpace(IStorage **ppStg) = 0;
};

/*
// {7C01FD0C-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformFactory : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE DefaultControlData
        (XformControlData **ppXFCD) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance *pXFormMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) = 0;
};

typedef struct _ImageSpan
{
	ULARGE_INTEGER	uliHandle;
	ULARGE_INTEGER  uliSize;

} ImageSpan;

/*
// {EB19B67E-9360-11d0-9E16-00A0C922E6EC}
DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformInstance : public IUnknown
{
public:

	virtual HRESULT STDMETHODCALLTYPE ReadAt 
	                    (ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
						 ImageSpan *pSpan
                        ) = 0;

	virtual HRESULT STDMETHODCALLTYPE WriteAt
	                    (ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
						 ImageSpan *pSpan
                        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

	virtual HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize) = 0;

	// Note: SpaceSize returns the high water mark for the space. That is, the largest
	//       limit value (uliOffset + uliSize) for any transformed lockbytes created within
	//       the base (*pXLKB).
};

/*
// {A55895FC-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformServices : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE PerTransformStorage
        (REFCLSID rclsidXForm, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetKeys
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
         PBYTE pbReadKey,  UINT cbReadKey, 
         PBYTE pbWriteKey, UINT cbWriteKey
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm) = 0;
};

/*
// {96AF35CE-88EC-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IKeyInstance : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetKeys
        (PBYTE *pbReadKey,  PUINT pcbReadKey,
         PBYTE *pbWriteKey, PUINT pcbWriteKey
        ) = 0;
};

/* 

  Streams stored in an ITS file may be accessed through URLs with
  the form:

      its: <File Path> :: <Stream Path>

  where <File Path> may be either a Win32 file path or a URL, and
  <Stream Path> is the path to a stream stored in the ITS file. 
  Each <Stream Path> must begin with '/'. 

  This means that you can copy a Win32 directory tree of HTML files
  and associated files into an ITS file and get to them through ITS
  URLs. If all the URL references within those HTML files are 
  relative, they will be resolved within the containing ITS file.

  The <File Path> portion of the URL may either be a complete path
  to the ITS file, or it may be just the file name. In the later case
  you may need to install auxillary information in the registry to
  help the ITSS code locate the file. Here are the rules:

  1. If you don't supply a complete path, ITSS looks in the current
     working directory for the file. 

  2. If the file isn't found in step 1. ITSS looks for a registry
     value in the ITSS_MAP section of HKEY_LOCAL_MACHINE. The value
     name must match the file name, and the value will be a string
     giving the complete file path to be used.

  3. If the file isn't found in steps 1 and 2, ITSS isolates the file's 
     extension (beginning with the last '.' character) and looks
     for a corresponding class id value in the ITSS_FINDER section 
     of HKEY_LOCAL_MACHINE. The name for the value will match the
     extension, and the value will be the class id for an object
     which implements the IID_IITFileFinder interface.

  4. If the file isn't found in steps 1 through 3, the URL reference
     fails.

 */

#define ITSS_MAP     "Software\\Microsoft\\Windows\\ITStorage\\Maps"
#define ITSS_FINDER  "Software\\Microsoft\\Windows\\ITStorage\\Finders"

interface IITFileFinder : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE FindThisFile(const WCHAR *pFileName, WCHAR **ppFullPath,
                                                   BOOL *pfRecordPathInRegistry
                                                  ) = 0;

// The FindThisFile method maps a file name into a complete file path. The file name
// is defined by *pFileName, and a pointer to the complete path is returned in 
// *ppFullPath. The returned path will be a string allocated in the IMalloc heap.
// The *pfRecordPathInRegistry result should be TRUE when we should record this mapping
// in the ITSS_MAP registry section and FALSE otherwise.

    
};


#endif // __MSITSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\nilxform.cpp ===
// NilXForm.cpp -- Implementation of the Null Transform Instance

#include "stdafx.h"

HRESULT CNull_TransformInstance::CreateFromILockBytes
            (IUnknown *pUnkOuter, ILockBytes *pLKB, ITransformInstance **ppTransformInstance)
{
	CNull_TransformInstance *pNT = New CNull_TransformInstance(pUnkOuter);

    return FinishSetup(pNT? pNT->m_ImpITransformInstance.InitFromLockBytes(pLKB)
                          : STG_E_INSUFFICIENTMEMORY,
                       pNT, IID_ITransformInstance, (PPVOID) ppTransformInstance
                      );
}


CNull_TransformInstance::CImpITransformInstance::CImpITransformInstance
    (CNull_TransformInstance *pBackObj, IUnknown *punkOuter)
    : IITTransformInstance(pBackObj, punkOuter)
{
	m_pLKB        = NULL;
    m_cbSpaceSize = 0;
}

CNull_TransformInstance::CImpITransformInstance::~CImpITransformInstance()
{
    if (m_pLKB)
    {
	    m_pLKB->Flush();
        m_pLKB->Release();
    }
}


HRESULT CNull_TransformInstance::CImpITransformInstance::InitFromLockBytes(ILockBytes *pLKB)
{
	m_pLKB = pLKB;

    STATSTG statstg;

    HRESULT hr = m_pLKB->Stat(&statstg, STATFLAG_NONAME);

    if (SUCCEEDED(hr))
        m_cbSpaceSize = statstg.cbSize;
        
    return hr;    
}

// ITransformInstance interfaces:

HRESULT STDMETHODCALLTYPE CNull_TransformInstance::CImpITransformInstance::ReadAt 
					(ULARGE_INTEGER uliOffset, void *pv, ULONG cb, ULONG *pcbRead,
                     ImageSpan *pSpan
                    )
{
    HRESULT hr = m_pLKB->ReadAt((CULINT(uliOffset) + CULINT(pSpan->uliHandle)).Uli(), 
                                pv,cb, pcbRead
                               );

    return hr;
}


HRESULT STDMETHODCALLTYPE CNull_TransformInstance::CImpITransformInstance::WriteAt
					(ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
					 ImageSpan *pSpan
					)
{
    RonM_ASSERT(m_pLKB);
    
	CULINT ullOffset, ullSize, ullWriteOffset, ullWriteLimit, ullReadEOS;

    ullOffset  = pSpan->uliHandle;
    ullSize    = pSpan->uliSize;
    ullReadEOS = ullOffset + ullSize;

    ullWriteOffset = ullOffset + ulOffset;
    ullWriteLimit  = ullWriteOffset + cb;
    
    CSyncWith sw(g_csITFS);

    if (ullWriteOffset != ullReadEOS || (ullReadEOS.NonZero() && ullWriteOffset > ullReadEOS))
        return STG_E_INVALIDPARAMETER;

    if (ullWriteLimit < ullWriteOffset) // Wrapped around 64-bit address space?
        ullWriteLimit = 0;

    HRESULT hr = m_pLKB->WriteAt(ullWriteOffset.Uli(), pv, 
                                 (ullWriteLimit - ullWriteOffset).Uli().LowPart,
                                 pcbWritten
                                );

    ullWriteLimit = ullWriteOffset + *pcbWritten;

    if (m_cbSpaceSize < ullWriteLimit)
        m_cbSpaceSize = ullWriteLimit;

    CULINT ullSizeNew;

    ullSizeNew = ullWriteLimit - ullWriteOffset;

    if (SUCCEEDED(hr))
		pSpan->uliSize = (CULINT(pSpan->uliSize) + CULINT(*pcbWritten)).Uli();

    return hr;
}


HRESULT STDMETHODCALLTYPE CNull_TransformInstance::CImpITransformInstance::Flush()
{
    RonM_ASSERT(m_pLKB);
    
	return m_pLKB->Flush();
}


HRESULT CNull_TransformInstance::CImpITransformInstance::SpaceSize(ULARGE_INTEGER *puliSize)
{
    RonM_ASSERT(m_pLKB);
    
    *puliSize = m_cbSpaceSize.Uli();

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\nilxform.h ===
// NILXForm.h -- Declarations for the Null TransformInstance object

#ifndef __NILXFORM_H__

#define __NILXFORM_H__

class CNull_TransformInstance : public CITUnknown
{
public:
	
	~CNull_TransformInstance();

	static HRESULT CreateFromILockBytes
        (IUnknown *pUnkOuter, ILockBytes *pLKB, 
         ITransformInstance **ppTransformInstance
        );

private:

	CNull_TransformInstance(IUnknown *pUnkOuter);

	class CImpITransformInstance : public IITTransformInstance
	{
	public:

		CImpITransformInstance(CNull_TransformInstance *pBackObj, IUnknown *punkOuter);
		~CImpITransformInstance();

		HRESULT InitFromLockBytes(ILockBytes *pLKB);

		// ITransformInstance interfaces:

		HRESULT STDMETHODCALLTYPE ReadAt 
							(ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
                             ImageSpan *pSpan
                            );

		HRESULT STDMETHODCALLTYPE WriteAt
							(ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
							 ImageSpan *pSpan
							);

		HRESULT STDMETHODCALLTYPE Flush();

		HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize);
	
	private:

		ILockBytes *m_pLKB;
		CULINT      m_cbSpaceSize;	
	};

	CImpITransformInstance m_ImpITransformInstance;
};

inline CNull_TransformInstance::CNull_TransformInstance(IUnknown *pUnkOuter)
    : m_ImpITransformInstance(this, pUnkOuter), 
      CITUnknown(&IID_ITransformInstance, 1, &m_ImpITransformInstance)
{

}

inline CNull_TransformInstance::~CNull_TransformInstance(void)
{
}

#endif // __NILXFORM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\rmassert.h ===
// ASSERT.h -- Support for assertions...
#ifndef __ASSERT_H__

#define __ASSERT_H__

#ifdef _DEBUG

void STDCALL RonM_AssertionFailure(PSZ pszFileName, int nLine);

#define RonM_ASSERT(fTest)   ((fTest) ? (void)0 : RonM_AssertionFailure(__FILE__, __LINE__))
#define DEBUGDEF(D)		D;
#define DEBUGCODE(X)    { X }

#else

#define RonM_ASSERT(fTest)   ((void) 0)
#define DEBUGDEF(D)
#define DEBUGCODE(X)

#endif

#endif // __ASSERT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\num64.h ===
// Num64.h -- Classes for 64-bit integers and unsigned numbers

// We define two classes here which provide arithmetic and bit shifting functions
// for 64-bit signed and unsigned numbers. We use these classes instead of the 
// LONGLONG and DWORDLONG types so this code can be ported to environments which
// don't have direct support for 64-bit data. In this implmentation we use inline
// functions as a thin layer around the 64-bit support available in the Win32 
// environment.

class CULINT;

class CLINT
{
public:

    CLINT();
    CLINT(CLINT& cli);
    CLINT(LARGE_INTEGER li);
    CLINT(ULARGE_INTEGER uli);
    CLINT(LONGLONG ll);
    CLINT(CULINT culi);

    BOOL NonZero();

    friend CLINT  operator-  (const CLINT& cliRight);
    friend CLINT  operator+  (const CLINT& cliLeft, const CLINT& cliRight);
    friend CLINT  operator-  (const CLINT& cliLeft, const CLINT& cliRight);
    friend CLINT  operator*  (const CLINT& cliLeft, const CLINT& cliRight);
    friend CLINT  operator/  (const CLINT& cliLeft, const CLINT& cliRight);
    friend CLINT  operator|  (const CLINT& cliLeft, const CLINT& cliRight);
    friend CLINT  operator<< (const CLINT& cliLeft, UINT  cbits);
    friend CLINT  operator>> (const CLINT& cliLeft, UINT  cbits);
    friend BOOL   operator<  (const CLINT& cliLeft, const CLINT& cliRight);
    friend BOOL   operator<= (const CLINT& cliLeft, const CLINT& cliRight);
    friend BOOL   operator== (const CLINT& cliLeft, const CLINT& cliRight);
    friend BOOL   operator>= (const CLINT& cliLeft, const CLINT& cliRight);
    friend BOOL   operator>  (const CLINT& cliLeft, const CLINT& cliRight);
    friend BOOL   operator!= (const CLINT& cliLeft, const CLINT& cliRight);
    
    CLINT& operator=  (const CLINT& cliRight);
    CLINT& operator+= (const CLINT& cliRight);
    CLINT& operator-= (const CLINT& cliRight);
    CLINT& operator*= (const CLINT& cliRight);
    CLINT& operator/= (const CLINT& cliRight);
    CLINT& operator|= (const CLINT& cliRight);
    CLINT& operator<<=(UINT  cbits);
    CLINT& operator>>=(UINT  cbits);

    LARGE_INTEGER Li();
    LONGLONG Ll();

private:
    LONGLONG QuadPart;
};

typedef CLINT *PCLINT;

class CULINT
{
public:

    CULINT();
    CULINT(CULINT& cli);
    CULINT(LARGE_INTEGER li);
    CULINT(ULARGE_INTEGER uli);
    CULINT(DWORDLONG dwl);
    CULINT(CLINT cli);

    BOOL NonZero();

    friend CULINT  operator-  (const CULINT& culiRight);
    friend CULINT  operator+  (const CULINT& culiLeft, const CULINT& culiRight);
    friend CULINT  operator-  (const CULINT& culiLeft, const CULINT& culiRight);
    friend CULINT  operator*  (const CULINT& culiLeft, const CULINT& culiRight);
    friend CULINT  operator/  (const CULINT& culiLeft, const CULINT& culiRight);
    friend CULINT  operator|  (const CULINT& culiLeft, const CULINT& culiRight);
    friend CULINT  operator<< (const CULINT& culiLeft, UINT  cbits);
    friend CULINT  operator>> (const CULINT& culiLeft, UINT  cbits);
    friend BOOL    operator<  (const CULINT& culiLeft, const CULINT& culiRight);
    friend BOOL    operator<= (const CULINT& culiLeft, const CULINT& culiRight);
    friend BOOL    operator== (const CULINT& culiLeft, const CULINT& culiRight);
    friend BOOL    operator>= (const CULINT& culiLeft, const CULINT& culiRight);
    friend BOOL    operator>  (const CULINT& culiLeft, const CULINT& culiRight);
    friend BOOL    operator!= (const CULINT& culiLeft, const CULINT& culiRight);
    
    CULINT& operator=  (const CULINT& culiRight);
    CULINT& operator+= (const CULINT& culiRight);
    CULINT& operator-= (const CULINT& culiRight);
    CULINT& operator*= (const CULINT& culiRight);
    CULINT& operator/= (const CULINT& culiRight);
    CULINT& operator|= (const CULINT& culiRight);
    CULINT& operator<<=(UINT  cbits);
    CULINT& operator>>=(UINT  cbits);

    ULARGE_INTEGER Uli();
    DWORDLONG      Ull();

private:
    DWORDLONG QuadPart;
};

typedef CULINT *PCULINT;

inline CLINT::CLINT()
{
}

inline CLINT::CLINT(CLINT& cli)
{
    QuadPart = cli.QuadPart;
}

inline CLINT::CLINT(LARGE_INTEGER li)
{
    QuadPart = li.QuadPart;
}

inline CLINT::CLINT(ULARGE_INTEGER uli)
{
    QuadPart = (LONGLONG) uli.QuadPart;
}

inline CLINT::CLINT(CULINT culi)
{
    QuadPart = (LONGLONG) culi.Uli().QuadPart;
}

inline CLINT::CLINT(LONGLONG ll)
{
    QuadPart = ll;
}

inline BOOL CLINT::NonZero()
{
    return QuadPart != 0;
}

inline CLINT  operator-  (const CLINT& cliRight)
{
    CLINT cliResult(-cliRight.QuadPart);

    return cliResult;
}

inline CLINT  operator+  (const CLINT& cliLeft, const CLINT& cliRight)
{
    CLINT cliResult(cliLeft.QuadPart + cliRight.QuadPart);

    return cliResult;
}

inline CLINT  operator-  (const CLINT& cliLeft, const CLINT& cliRight)
{
    CLINT cliResult(cliLeft.QuadPart - cliRight.QuadPart);

    return cliResult;
}

inline CLINT  operator*  (const CLINT& cliLeft, const CLINT& cliRight)
{
    CLINT cliResult(cliLeft.QuadPart * cliRight.QuadPart);

    return cliResult;
}

inline CLINT  operator/  (const CLINT& cliLeft, const CLINT& cliRight)
{
    CLINT cliResult(cliLeft.QuadPart / cliRight.QuadPart);

    return cliResult;
}

inline CLINT  operator|  (const CLINT& cliLeft, const CLINT& cliRight)
{
    CLINT cliResult(cliLeft.QuadPart | cliRight.QuadPart);

    return cliResult;
}

inline CLINT  operator<< (const CLINT& cliLeft, UINT  cbits)
{
    CLINT cliResult(cliLeft.QuadPart << cbits);

    return cliResult;
}

inline CLINT  operator>> (const CLINT& cliLeft, UINT  cbits)
{
    CLINT cliResult(cliLeft.QuadPart >> cbits);

    return cliResult;
}

inline BOOL operator<  (const CLINT& cliLeft, const CLINT& cliRight)
{
    return cliLeft.QuadPart < cliLeft.QuadPart;
}

inline BOOL operator<= (const CLINT& cliLeft, const CLINT& cliRight)
{
    return cliLeft.QuadPart <= cliLeft.QuadPart;
}

inline BOOL operator== (const CLINT& cliLeft, const CLINT& cliRight)
{
    return cliLeft.QuadPart == cliLeft.QuadPart;
}

inline BOOL operator>= (const CLINT& cliLeft, const CLINT& cliRight)
{
    return cliLeft.QuadPart >= cliLeft.QuadPart;
}

inline BOOL operator>  (const CLINT& cliLeft, const CLINT& cliRight)
{
    return cliLeft.QuadPart > cliLeft.QuadPart;
}

inline BOOL operator!= (const CLINT& cliLeft, const CLINT& cliRight)
{
    return cliLeft.QuadPart != cliLeft.QuadPart;
}


inline CLINT& CLINT::operator=  (const CLINT& cliRight)
{
    QuadPart = cliRight.QuadPart;

    return *this;
}

inline CLINT& CLINT::operator+= (const CLINT& cliRight)
{
    QuadPart += cliRight.QuadPart;

    return *this;
}

inline CLINT& CLINT::operator-= (const CLINT& cliRight)
{
    QuadPart -= cliRight.QuadPart;

    return *this;
}

inline CLINT& CLINT::operator*= (const CLINT& cliRight)
{
    QuadPart *= cliRight.QuadPart;

    return *this;
}

inline CLINT& CLINT::operator/= (const CLINT& cliRight)
{
    QuadPart /= cliRight.QuadPart;

    return *this;
}

inline CLINT& CLINT::operator|= (const CLINT& cliRight)
{
    QuadPart |= cliRight.QuadPart;

    return *this;
}

inline CLINT& CLINT::operator<<=(UINT  cbits)
{
    QuadPart <<= cbits;

    return *this;
}

inline CLINT& CLINT::operator>>=(UINT  cbits)
{
    QuadPart >>= cbits;

    return *this;
}

inline LARGE_INTEGER CLINT::Li()
{
    LARGE_INTEGER li;

    li.QuadPart = QuadPart;

    return li;
}

inline LONGLONG CLINT::Ll()
{
    return QuadPart;
}

inline CULINT::CULINT()
{
}

inline CULINT::CULINT(CULINT& culi)
{
    QuadPart = culi.QuadPart;
}

inline CULINT::CULINT(LARGE_INTEGER li)
{
    QuadPart = (DWORDLONG) li.QuadPart;
}

inline CULINT::CULINT(ULARGE_INTEGER uli)
{
    QuadPart = uli.QuadPart;
}
    
inline CULINT::CULINT(DWORDLONG dwl)
{
    QuadPart = dwl;   
}

inline CULINT::CULINT(CLINT cli)
{
    QuadPart = (DWORDLONG) cli.Li().QuadPart;
}

inline BOOL CULINT::NonZero()
{
    return QuadPart != 0;
}

inline CULINT  operator-  (const CULINT& culiRight)
{
#pragma warning( disable : 4146 )

    CULINT ulint(-culiRight.QuadPart);

    return ulint;
}

inline CULINT  operator+  (const CULINT& culiLeft, const CULINT& culiRight)
{
    CULINT ulint(culiLeft.QuadPart + culiRight.QuadPart);

    return ulint;
}

inline CULINT  operator-  (const CULINT& culiLeft, const CULINT& culiRight)
{
    CULINT ulint(culiLeft.QuadPart - culiRight.QuadPart);

    return ulint;
}

inline CULINT  operator*  (const CULINT& culiLeft, const CULINT& culiRight)
{
    CULINT ulint(culiLeft.QuadPart * culiRight.QuadPart);

    return ulint;
}

inline CULINT  operator/  (const CULINT& culiLeft, const CULINT& culiRight)
{
    CULINT ulint(culiLeft.QuadPart / culiRight.QuadPart);

    return ulint;
}

inline CULINT  operator|  (const CULINT& culiLeft, const CULINT& culiRight)
{
    CULINT ulint(culiLeft.QuadPart | culiRight.QuadPart);

    return ulint;
}

inline CULINT  operator<< (const CULINT& culiLeft, UINT  cbits)
{
    CULINT ulint(culiLeft.QuadPart << cbits);

    return ulint;
}

inline CULINT  operator>> (const CULINT& culiLeft, UINT  cbits)
{
    CULINT ulint(culiLeft.QuadPart >> cbits);

    return ulint;
}

inline CULINT& CULINT::operator=  (const CULINT& culiRight)
{
    QuadPart = culiRight.QuadPart;

    return *this;
}

inline CULINT& CULINT::operator+= (const CULINT& culiRight)
{
    QuadPart += culiRight.QuadPart;

    return *this;
}

inline CULINT& CULINT::operator-= (const CULINT& culiRight)
{
    QuadPart -= culiRight.QuadPart;

    return *this;
}

inline CULINT& CULINT::operator*= (const CULINT& culiRight)
{
    QuadPart *= culiRight.QuadPart;

    return *this;
}

inline CULINT& CULINT::operator/= (const CULINT& culiRight)
{
    QuadPart /= culiRight.QuadPart;

    return *this;
}

inline CULINT& CULINT::operator|= (const CULINT& culiRight)
{
    QuadPart |= culiRight.QuadPart;

    return *this;
}

inline CULINT& CULINT::operator<<=(UINT  cbits)
{
    QuadPart <<= cbits;

    return *this;
}

inline CULINT& CULINT::operator>>=(UINT  cbits)
{
    QuadPart >>= cbits;

    return *this;
}

inline BOOL operator<  (const CULINT& culiLeft, const CULINT& culiRight)
{
    return culiLeft.QuadPart < culiRight.QuadPart;
}

inline BOOL operator<= (const CULINT& culiLeft, const CULINT& culiRight)
{
    return culiLeft.QuadPart <= culiRight.QuadPart;
}

inline BOOL operator== (const CULINT& culiLeft, const CULINT& culiRight)
{
    return culiLeft.QuadPart == culiRight.QuadPart;
}

inline BOOL operator>= (const CULINT& culiLeft, const CULINT& culiRight)
{
    return culiLeft.QuadPart >= culiRight.QuadPart;
}

inline BOOL operator>  (const CULINT& culiLeft, const CULINT& culiRight)
{
    return culiLeft.QuadPart > culiRight.QuadPart;
}

inline BOOL operator!= (const CULINT& culiLeft, const CULINT& culiRight)
{
    return culiLeft.QuadPart != culiRight.QuadPart;
}

inline ULARGE_INTEGER CULINT::Uli()
{
    ULARGE_INTEGER uli;

    uli.QuadPart = QuadPart;

    return uli;
}

inline DWORDLONG CULINT::Ull()
{
    return QuadPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\pathmgr.h ===
// PathMgr.h -- Declarations for the Path Manager classes and interfaces

#ifndef __PATHMGR_H__

#define __PATHMGR_H__

/*

The path manager interface maintains a database of PathInfo entries. Entries
are keyed by a Unicode path name. They may be enumerated in Unicode lexical order
starting from a given path name. The path manager interfaces support retrieving, 
adding, deleting and modifying entries. 

Each entry in the database has a unique path name. Name comparisons are case
insensitive according the rules for the U.S. English locale (0x0409). Path strings
are stored in the database exactly as given on whenever a new record is inserted.

Path names may be up to 259 characters long.

 */

#if 0

// StreamState defines a collection of bit flags which define the
// access and permission states for a stream or storage.

enum StreamState { Readable   = 0x00000001, // Stream may be read
                   Writeable  = 0x00000002, // Stream may be written
                   ShareRead  = 0x00000004, // Multiple readers allowed
                   ShareWrite = 0x00000008, // Multiple writers allowed
                   TempStream = 0x00000010, // Stream will be deleted when released
                   Transacted = 0x00000020  // Stream supports Commit and Revert
                 };

#endif // 0


//Record stucture for garbage collection
typedef struct _SEntry{
	CULINT ullcbOffset;
	CULINT ullcbData;
	UINT   ulEntryID;
}SEntry;

typedef SEntry *PSEntry;

class CPathManager1 : public CITUnknown
{

public:

    // Destructor:

    ~CPathManager1(void);

    // Creation:

    static HRESULT NewPathDatabase(IUnknown *punkOuter, ILockBytes *plb, 
                                   UINT cbDirectoryBlock, UINT cCacheBlocksMax, 
                                   IITPathManager **pplkb
                                  );

    static HRESULT LoadPathDatabase(IUnknown *punkOuter, ILockBytes *plb,
                                    IITPathManager **pplkb
                                   );

private:

    CPathManager1(IUnknown *pUnkOuter);

    class CImpIPathManager : public IITPathManager
    {
    public:

        // Constructor and Destructor:

        CImpIPathManager(CPathManager1 *pBackObj, IUnknown *punkOuter);
        ~CImpIPathManager(void);

        // Initialing routines:

        HRESULT InitNewPathDatabase(ILockBytes *plb, UINT cbDirectoryBlock, 
                                                     UINT cCacheBlocksMax);
        HRESULT InitLoadPathDatabase(ILockBytes *plb);

        // IPersist Method:

        HRESULT STDMETHODCALLTYPE GetClassID( 
            /* [out] */ CLSID __RPC_FAR *pClassID);
        
        // IITPathManager interfaces:
    
        HRESULT STDMETHODCALLTYPE FlushToLockBytes();
        HRESULT STDMETHODCALLTYPE FindEntry  (PPathInfo pSI   );
        HRESULT STDMETHODCALLTYPE CreateEntry(PPathInfo pSINew, 
                                              PPathInfo pSIOld, 
                                              BOOL fReplace     );
        HRESULT STDMETHODCALLTYPE DeleteEntry(PPathInfo pSI   );
        HRESULT STDMETHODCALLTYPE UpdateEntry(PPathInfo pSI   );
		HRESULT STDMETHODCALLTYPE EnumFromObject
            (IUnknown *punkOuter, const WCHAR *pwszPrefix, UINT cwcPrefix, 
			 REFIID riid, PVOID *ppv
			);
	    HRESULT STDMETHODCALLTYPE GetPathDB(IStreamITEx *pTempPDBStrm, BOOL fCompact);
		HRESULT STDMETHODCALLTYPE ForceClearDirty();

private:

// The PathInfo data type is used to pass stream information through function
// interfaces within the Path Manager. It is not used as the on-disk layout.
// The on-disk information is kept as follows:
//
//     cbPath              // Byte length of abPath; Stored as VL32
//     abPath              // UTF-8 representation of awszStreamPath  
//     uStateBits          // Stored as high order dword of VL64
//     iLockedBytesSegment // Stored as low  order dword of VL64
//     ullcbOffset         // Stored as VL64 // Used with ullcbData 
//     ullcbData           // Stored as VL64 // to store storage guids
// 
// VL32 and VL64 storage formats, respectively, are 32 and 64 bit variable length
// storage formats. The use the convention that the last byte in the representation
// is less than 0x80. That is, each byte contains seven bits of information.

        typedef struct _TaggedPathInfo
        {
            UINT       iDirectoryBlock; // Index of dir block containing this info
            UINT       cbEntryOffset;   // Offset of info within dir block
            UINT       cbEncoded;       // Size of entry within dir block

            PathInfo SI;

        } TaggedPathInfo, *PTaggedPathInfo;

        // The structures below define the on-disk structure of leaf nodes
        // and internal nodes. Leaf nodes are the bottom of the B-Tree heirarchy.
        // Internal nodes are in the levels above the leaf nodes.

        // First we define two type tags for the nodes:
        
        enum { uiMagicLeaf     = ('L' << 24 ) | ('G' << 16) | ('M' << 8) | 'P',
               uiMagicInternal = ('I' << 24 ) | ('G' << 16) | ('M' << 8) | 'P',
               uiMagicUnused   = ('U' << 24 ) | ('G' << 16) | ('M' << 8) | 'P'
             };

        // All nodes begin with a node header:

        typedef struct _NodeHeader
        {
            UINT uiMagic;  // A type tag to mark leafs and internal nodes.
            UINT cbSlack;  // Free space in the trailing portion of the node.
        //    UINT cEntries; // Now kept at end of node.
        
        } NodeHeader, *PNodeHeader;

        // Leaf nodes have additional header information to maintain a chain
        // through all the leaf nodes:

        typedef struct _LeafChainLinks
        {
            UINT iLeafSerial;    // Serial number for this leaf. Changed when an
                                 // enumeration offset might become invalid.
            UINT iLeafPrevious;  // Leaf nodes are placed in a lexically ordered chain. 
            UINT iLeafNext;      // These are the links for that double linked chain.

        } LeafChainLinks, *PLeafChainLinks;

        // Now we can define the structures for leaf nodes and internal nodes. 
        // Note the use of ab[0]. That's because our nodes size is defined when 
        // the B-Tree is created. That size includes both the ab space for key
        // entries and the header for the node. Since all nodes must be the same
        // size than means the ab space for internal nodes is eight-bytes bigger
        // than the ab space in leaf nodes. We keep all nodes the same size
        // to make the free list mechanism work cleanly. That is, when a leaf
        // node is discarded and added to the free list, it may be resurrected
        // later and taken out of the free list to become either an internal node
        // or a leaf node.

        typedef struct _LeafNode
        {
            NodeHeader     nh;
            LeafChainLinks lcl;

            BYTE ab[0];

        } LeafNode, *PLeafNode;

        typedef struct _InternalNode
        {
            NodeHeader nh;
            
            BYTE ab[0];

        } InternalNode, *PInternalNode;

        // When we read nodes into memory, we embed them in a cache block
        // structure so we can add extra state information.

        typedef struct _CacheBlock
        {
            UINT fFlags;       // Type and state bits (Defined below).

            struct _CacheBlock *pCBPrev; // Previous block in LRU chain.
            struct _CacheBlock *pCBNext; // Next block in LRU chain or
                                         //   Next block in free chain.
            
            UINT iBlock;       // Index of the disk slot corresponding to this node.

            UINT cbKeyOffset;  // Set by the key scanning routines to mark where
                               // a key was found or where a new key may be inserted.
            UINT cbEntry;      // Size in bytes of key plus record.

            union
            {
                LeafNode     ldb;
                InternalNode idb;
            };

        } CacheBlock, *PCacheBlock;

        enum { FreeBlock      = 0x00000001, // Cache block is not in use
               InternalBlock  = 0x00000002, // Block holds an internal directory
               LeafBlock      = 0x00000004, // Block holds a  leaf     directory
               BlockTypeMask  = 0x00000007, // Bits which define block type
               DirtyBlock     = 0x00000008, // Block does not match on-disk data.
               LockedBlock    = 0x00000010, // Block is locked in memory
               ReadingIn      = 0x00000020, // Block is being read from disk
               WritingOut     = 0x00000040  // Block is being written to disk
             };
        
        typedef struct _SInternalNodeLev{
			PInternalNode pINode;
			ULONG cbFirstKey;
			ULONG cEntries;
		}SInternalNodeLev;
			
															
		HRESULT STDMETHODCALLTYPE CompactPathDB(IStreamITEx *pTempPDBStrm);
		
		HRESULT UpdateHigherLev(IStreamITEx *pTempPDBStrm, 
							   UINT iCurILev, 
							   UINT *piNodeNext, 
							   SInternalNodeLev *rgINode,
							   PBYTE pbFirstKey,
							   ULONG cbFirstKey);

		UINT PredictNodeID(UINT iCurILev, 
						   UINT iNodeNext, 
                           SInternalNodeLev *rgINode,
                           PBYTE pbFirstKey,
                           ULONG cbFirstKey);
		
		HRESULT BinarySearch(UINT	        uiStart,
							UINT		    uiEnd,
							PBYTE			pauAccess,
							UINT			cbAccess,
							PTaggedPathInfo ptsi,
							PBYTE           ab,
							PBYTE			*ppbOut,
							BOOL			fSmall);
							
		// These routines manage a key count field at the end of a node.
        // The count may be absent if cbSlack is too small. It may be zero
        // when the access vector doesn't exist.

        void  KillKeyCount(LeafNode *pln);

        // These routines manage cache block allocation and deallocation. 
        // When there are no unused blocks, the GetCacheBlocks routine will 
        // free the oldest unlocked block, writing its content to disk if
        // necessary.

        HRESULT GetCacheBlock (PCacheBlock *ppCB, UINT fTypeMask);
        HRESULT FreeCacheBlock(PCacheBlock   pCB);
        
        HRESULT GetFreeBlock(PCacheBlock &pCB);
        HRESULT GetActiveBlock(PCacheBlock &pCB, BOOL fIgnoreLocks = FALSE);

        void MarkAsMostRecent(PCacheBlock pCB);
        void RemoveFromUse   (PCacheBlock pCB);

        // These routines handle disk I/O for cache blocks.

        HRESULT  ReadCacheBlock(PCacheBlock pCB, UINT iBlock);
        HRESULT WriteCacheBlock(PCacheBlock pCB);
        HRESULT FlushToDisk();

        // The FindCacheBlock routine finds a cache block which contains 
        // the image of a particular node block. If that data doesn't 
        // exist in the cache, it will read it from disk.

        HRESULT FindCacheBlock(PCacheBlock *ppCB, UINT iBlock);
        
        // This routine allocate a new node on disk and in the cache blocks.

        HRESULT AllocateNode(PCacheBlock *ppCB, UINT fTypeMask);

        // This routine adds a node to the free list.

        HRESULT  DiscardNode(PCacheBlock pCB);

        // These routines search through the B-Tree nodes looking for a key
        // or a place to insert a new key.

        HRESULT FindKeyAndLockBlockSet
                 (PTaggedPathInfo ptsi, PCacheBlock *papCBSet, 
                  UINT iLevel, UINT cLevels = UINT(~0)
                 );

        HRESULT ScanInternalForKey(PCacheBlock pCacheBlock, PTaggedPathInfo ptsi, 
                                   PUINT piChild
                                  );
        
        HRESULT ScanLeafForKey(PCacheBlock pCacheBlock, PTaggedPathInfo ptsi);

        
        // ClearLockFlags turns off lock flags for all cache entries.

        void ClearLockFlags(PCacheBlock *papCBSet);

        // ClearLockFlagsAbove turns off lock flags for levels above iLevel.

        void ClearLockFlagsAbove(PCacheBlock *papCBSet, UINT iLevel);

        // These routines insert, delete, and modify entries in a leaf node.

        HRESULT InsertEntryIntoLeaf(PTaggedPathInfo ptsi, PCacheBlock *papCBSet);
        HRESULT UpdateEntryInLeaf  (PTaggedPathInfo ptsi, PCacheBlock *papCBSet);

        // These routines insert, delete, and modify entries in any node
        
        HRESULT InsertEntryIntoNode(PTaggedPathInfo ptsi, PBYTE pb, UINT cb, PCacheBlock *papCBSet, UINT iLevel, BOOL fAfter);
        HRESULT RemoveEntryFromNode(PTaggedPathInfo ptsi,                    PCacheBlock *papCBSet, UINT iLevel);
        HRESULT ModifyEntryInNode  (PTaggedPathInfo ptsi, PBYTE pb, UINT cb, PCacheBlock *papCBSet, UINT iLevel);

        // These routines insert a key, remove a key, or modify the information for
        // an existing key. The iLevel parameter indicates the level of the tree
        // being modified. Level numbers start at the leaves and go upward.

        HRESULT InsertAKey   (UINT iLevel, PCacheBlock pCacheBlock, PTaggedPathInfo ptsi);
        HRESULT RemoveAKey   (UINT iLevel, PPathInfo pSI);
        HRESULT ModifyKeyData(UINT iLevel, PCacheBlock pCacheBlock, PTaggedPathInfo ptsi);
        
        // This routine splits a node to create more slack space.
        
        HRESULT SplitANode(PCacheBlock *papCBSet, UINT iLevel); 

        // Routines for encoding and decoding on-disk representations of stream information:

        HRESULT DecodePathKey(const BYTE **ppb,      PWCHAR  pwszPath, PUINT pcwcPath);
        PBYTE   EncodePathKey(     PBYTE    pb, const WCHAR *pwszPath,  UINT  cwcPath);
        HRESULT DecodeKeyInfo(const BYTE **ppb,      PPathInfo  pSI);
        PBYTE   EncodeKeyInfo(     PBYTE    pb, const PathInfo *pSI);
        PBYTE     SkipKeyInfo(PBYTE pb);


        HRESULT DecodePathInfo(const BYTE **ppb,       PPathInfo pSI);
        PBYTE   EncodePathInfo(     PBYTE    pb, const PathInfo *pSI);

        BOOL ValidBlockIndex(UINT iBlock);

        HRESULT SaveHeader();

        enum
        {   
            INVALID_INDEX = UINT(~0),
            CB_STREAM_INFO_MAX = MAX_UTF8_PATH + 2 * 10 + 2 * 5 + 2,
            PathMagicID   = ('P' << 24) | ('S' << 16) | ('T' << 8) | 'I',
            PathVersion   = 1
        };

        class CEnumPathMgr1 : public CITUnknown
        {
        public:

            ~CEnumPathMgr1();

			static HRESULT NewPathEnumeratorObject
            (IUnknown *punkOuter, CImpIPathManager *pPM, 
             const WCHAR *pwszPathPrefix,
             UINT cwcPathPrefix,
			 REFIID riid,
             PVOID *ppv
            );
			
			static HRESULT NewPathEnumerator(IUnknown *punkOuter, CImpIPathManager *pPM, 
                                             const WCHAR *pwszPathPrefix,
                                             UINT cwcPathPrefix,
                                             IEnumSTATSTG **ppEnumSTATSTG
                                            );

        private:

            CEnumPathMgr1(IUnknown *pUnkOuter);

            class CImpIEnumSTATSTG : public IITEnumSTATSTG
            {
            public:
    
                CImpIEnumSTATSTG(CITUnknown *pBackObj, IUnknown *punkOuter);
                ~CImpIEnumSTATSTG();

                HRESULT STDMETHODCALLTYPE InitPathEnumerator(CImpIPathManager *pPM, 
                                                             const WCHAR *pwszPathPrefix,
                                                             UINT cwcPathPrefix
                                                            );

              
				//IITEnumSTATSTG interface methods
				HRESULT	STDMETHODCALLTYPE GetNextEntryInSeq(ULONG celt, PathInfo *rgelt, ULONG  *pceltFetched);
				HRESULT	STDMETHODCALLTYPE GetFirstEntryInSeq(PathInfo *rgelt);
				
				HRESULT STDMETHODCALLTYPE Next( 
                    /* [in] */ ULONG celt,
                    /* [in] */ STATSTG __RPC_FAR *rgelt,
                    /* [out] */ ULONG __RPC_FAR *pceltFetched);
    
                HRESULT STDMETHODCALLTYPE Skip( 
                    /* [in] */ ULONG celt);
    
                HRESULT STDMETHODCALLTYPE Reset( void);
    
                HRESULT STDMETHODCALLTYPE Clone( 
                    /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);

            private:

                HRESULT STDMETHODCALLTYPE FindEntry();
                HRESULT STDMETHODCALLTYPE NextEntry();
				
                              
                CImpIPathManager *m_pPM;              // Context of this enumeration
                PathInfo          m_SI;               // Last entry returned
                UINT              m_iLeafBlock;       // Index for leaf containing last entry
                UINT              m_cbOffsetLastEntry;// Position of prev entry in that leaf
                UINT              m_cbLastEntry;      // Size of prev entry.
                UINT              m_iSerialNode;      // Leaf Serial number
                UINT              m_iSerialDatabase;  // Database serial number
                UINT              m_cwcPathPrefix;            // Length of starting prefix
                WCHAR             m_pwszPathPrefix[MAX_PATH]; // Starting prefix

                // We use leaf and database serial numbers to determine whether our position
                // information is still valid. The serial number for a leaf changes whenever
                // a change would invalidate our offset into the leaf. This includes cases
                // where the node is split and also cases where an entry changes shape. That
                // is, we increment the leaf serial number when we delete an entry or modify
                // it so that its content is larger or smaller. Inserting an entry also
                // increments the leaf's serial number. However appending an entry to the
                // end of the leaf won't change its serial number because that change would
                // not invalidate any enumeration offset.
                //
                // The serial number for the database is incremented whenever we delete a
                // leaf node. This may indicate that our recorded m_iLeafBlock is no longer
                // valid. 
                //
                // Whenever we have a mismatch with either the leaf serial or the database
                // serial, we search for a match rather than relying on our position
                // information.
                //
                // Note also the initial condition where m_iSerialNode and m_iSerialDatabase
                // are zero. By convention the serial number sequence skips the value zero.                
            };

            CImpIEnumSTATSTG m_ImpEnumSTATSTG;
        };

        friend CEnumPathMgr1;
        friend CEnumPathMgr1::CImpIEnumSTATSTG;

        // We set the minimum directory block size so that we'll always be able
        // to handle the longest possible path together with the worst case 
        // encoding for path information. In the worst case a leaf node can just
        // barely accomodate a single item.

        // The MIN_CACHE_ENTRIES constant controls the number of directory blocks
        // which we will cache in memory. We may actually cache more blocks for
        // a deep B-Tree. 

        enum { MIN_DIRECTORY_BLOCK_SIZE = MAX_UTF8_PATH + 30 + sizeof(LeafNode), 
               MIN_CACHE_ENTRIES = 2 
             };

        // The database header is a meta directory for the node blocks.
        // It is the first thing in the on-disk data stream.

        typedef struct _DatabaseHeader
        {
            ULONG uiMagic;             // ID value "ITSP" 
            ULONG uiVersion;           // Revision # for this structure
            ULONG cbHeader;            // sizeof(DatabaseHeader);
            ULONG cCacheBlocksMax;     // Number of cache blocks allowed 
            ULONG cbDirectoryBlock;    // Size of a directory block
            ULONG cEntryAccessShift;   // Base 2 log of Gap in entry access vector
            ULONG cDirectoryLevels;    // Nesting depth from root to leaf
            ULONG iRootDirectory;      // The top most internal directory
            ULONG iLeafFirst;          // Lexically first leaf block
            ULONG iLeafLast;           // Lexically last  leaf block
            ULONG iBlockFirstFree;     // First block in unused block chain
            ULONG cBlocks;             // Number of directory blocks in use
            LCID  lcid;                // Locale (sorting conventions, comparision rules)
            CLSID clsidEntryHandler;   // Interface which understands node entries
            UINT  cbPrefix;            // Size of fixed portion of data base
            ULONG iOrdinalMapRoot;     // Ordinal map root for when they don't fit in a block
            ULONG iOrdinalMapFirst;    // First and last Ordinal map for leaf blocks. 
            ULONG iOrdinalMapLast;     // These are linked like the leaf blocks.

            // Note instance data for the Entry handler immediately follows the 
            // database header. That data is counted by cbPrefix.

        } DatabaseHeader, PDatabaseHeader;

        CITCriticalSection m_cs;

        ILockBytes    *m_plbPathDatabase; // Disk image of the path database header.

        DatabaseHeader m_dbh;             // Header info for the path database.
        BOOL           m_fHeaderIsDirty;  // Header doesn't match disk version.

        UINT           m_cCacheBlocks;    // Number of active cache blocks
        PCacheBlock    m_pCBLeastRecent;  // LRU end of the in-use chain
        PCacheBlock    m_pCBMostRecent;   // MRU end of the in-use chain
        PCacheBlock    m_pCBFreeList;     // Chain of unused cache blocks

        UINT m_PathSetSerial; // Serial number for the path set data base. 
                              // Incremented whenever we delete a leaf node.
    };

    CImpIPathManager m_PathManager;

};

typedef CPathManager1 *PCPathManager1;

extern GUID aIID_CPathManager[];

extern UINT cInterfaces_CPathManager;

#pragma warning( disable : 4355 )

inline CPathManager1::CPathManager1(IUnknown *pUnkOuter)
    : m_PathManager(this, pUnkOuter), 
      CITUnknown(aIID_CPathManager, cInterfaces_CPathManager, &m_PathManager)
{

}

inline CPathManager1::~CPathManager1(void)
{

}

 
inline BOOL CPathManager1::CImpIPathManager::ValidBlockIndex(UINT iBlock)
{
    // We use all-ones as an invalid index value.

    return ~iBlock;
}

inline CPathManager1::CImpIPathManager::CEnumPathMgr1::CEnumPathMgr1(IUnknown *pUnkOuter)
    : m_ImpEnumSTATSTG(this, pUnkOuter), 
      CITUnknown(&IID_IEnumSTATSTG, 1, &m_ImpEnumSTATSTG)
{

}

inline CPathManager1::CImpIPathManager::CEnumPathMgr1::~CEnumPathMgr1(void)
{

}

// Routines for encoding and decoding variable length 
// representations for 32 and 64 bit values:

ULONG  DecodeVL32(const BYTE **ppb);
CULINT DecodeVL64(const BYTE **ppb);

ULONG CodeSizeVL32(ULONG ul);

PBYTE EncodeVL32(PBYTE pb, ULONG   ul);
PBYTE EncodeVL64(PBYTE pb, CULINT *ull);

PBYTE SkipVL(PBYTE pb);

#endif // __PATHMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\stdafx.cpp ===
// stdafx.cpp -- Used to build precompiled headers for this module

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\pathmgr.cpp ===
// PathMgr.cpp -- Implmentation for the Path Manager classes and interfaces

#include "StdAfx.h"
//#include <stdio.h>

HRESULT CPathManager1::NewPathDatabase
            (IUnknown *punkOuter, ILockBytes *plb, 
             UINT cbDirectoryBlock, UINT cCacheBlocksMax, 
             IITPathManager **ppPM
            )
{
    CPathManager1  *pPM1 = New CPathManager1(punkOuter);

    return FinishSetup(pPM1? pPM1->m_PathManager.InitNewPathDatabase
                                 (plb, cbDirectoryBlock, cCacheBlocksMax)
                           : STG_E_INSUFFICIENTMEMORY,
                       pPM1, IID_PathManager, (PPVOID) ppPM
                      );
}

HRESULT CPathManager1::LoadPathDatabase
            (IUnknown *punkOuter, ILockBytes *plb, IITPathManager **ppPM)
{
    CPathManager1  *pPM1 = New CPathManager1(punkOuter);

    return FinishSetup(pPM1? pPM1->m_PathManager.InitLoadPathDatabase(plb)
                           : STG_E_INSUFFICIENTMEMORY,
                       pPM1, IID_PathManager, (PPVOID) ppPM
                      );
}


CPathManager1::CImpIPathManager::CImpIPathManager
    (CPathManager1 *pBackObj, IUnknown *punkOuter)
    : IITPathManager(pBackObj, punkOuter)
{
    ZeroMemory(&m_dbh, sizeof(m_dbh));

    m_plbPathDatabase  = NULL;
    m_cCacheBlocks     = 0;  
    m_fHeaderIsDirty   = FALSE;
    m_pCBLeastRecent   = NULL;
    m_pCBMostRecent    = NULL;
    m_pCBFreeList      = NULL;
    m_PathSetSerial    = 1;

    ZeroMemory(&m_dbh, sizeof(m_dbh));

    m_dbh.iRootDirectory = INVALID_INDEX;
    m_dbh.iLeafFirst     = INVALID_INDEX;
    m_dbh.iLeafLast      = INVALID_INDEX;
}


CPathManager1::CImpIPathManager::~CImpIPathManager()
{

    if (m_plbPathDatabase)
    {
        // We've got a path database open.

        // The code below flushes any pending database
        // changes out to disk. This will usually work,
        // but it's not good practice. The problem is 
        // that a Destructor has no return value. So 
        // you won't be notified if something went wrong.
        //
        // A better approach is to do the flush before 
        // releasing the interface.

        RonM_ASSERT(m_PathSetSerial != 0);

#ifdef _DEBUG
        HRESULT hr = 
#endif // _DEBUG
            FlushToLockBytes();

        RonM_ASSERT(SUCCEEDED(hr));

        // The code below deallocates the cache blocks.
        // First the free blocks:

        PCacheBlock pCB;

        for (; S_OK == GetFreeBlock(pCB); m_cCacheBlocks--)
            delete [] (PBYTE) pCB;

        // Then the active blocks:

        for (; S_OK == GetActiveBlock(pCB, TRUE); m_cCacheBlocks--)
        {
            RonM_ASSERT(!(pCB->fFlags & LockedBlock)); 

            delete [] (PBYTE) pCB;
        }

        RonM_ASSERT(m_cCacheBlocks == 0); // That should be all the cache blocks.

        m_plbPathDatabase->Release();
    }
}

HRESULT CPathManager1::CImpIPathManager::InitNewPathDatabase
            (ILockBytes *plb, UINT cbDirectoryBlock, UINT cCacheBlocksMax)
{
    RonM_ASSERT(!m_plbPathDatabase);

    m_plbPathDatabase = plb;

    if (cbDirectoryBlock < MIN_DIRECTORY_BLOCK_SIZE)
        cbDirectoryBlock = MIN_DIRECTORY_BLOCK_SIZE;

    if (cCacheBlocksMax  < MIN_CACHE_ENTRIES)
        cCacheBlocksMax  = MIN_CACHE_ENTRIES;

    m_dbh.uiMagic           = PathMagicID;
    m_dbh.uiVersion         = PathVersion;
    m_dbh.cbHeader          = sizeof(m_dbh);
    m_dbh.cbDirectoryBlock  = cbDirectoryBlock;
    m_dbh.cEntryAccessShift = 2;
    m_dbh.cCacheBlocksMax   = cCacheBlocksMax;
    m_dbh.cDirectoryLevels  = 0;
    m_dbh.iRootDirectory    = INVALID_INDEX;
    m_dbh.iLeafFirst        = INVALID_INDEX;
    m_dbh.iLeafLast         = INVALID_INDEX;
    m_dbh.iBlockFirstFree   = INVALID_INDEX;
    m_dbh.cBlocks           = 0;
    m_dbh.lcid              = 0x0409;          // CLSID_ITStorage uses US English case map rules
    m_dbh.clsidEntryHandler = CLSID_ITStorage; // Default entry handler
    m_dbh.cbPrefix          = sizeof(m_dbh);   // CLSID_ITStorage has no instance data
    m_dbh.iOrdinalMapRoot   = INVALID_INDEX;   // Used when the ordinal map doesn't fit in a block
    m_dbh.iOrdinalMapFirst  = INVALID_INDEX;   // First ordinal block (treated like a leaf block)
    m_dbh.iOrdinalMapLast   = INVALID_INDEX;   // Last  ordinal block (treated like a leaf block)

    m_fHeaderIsDirty        = TRUE;

    return SaveHeader();
}
    
HRESULT CPathManager1::CImpIPathManager::InitLoadPathDatabase(ILockBytes *plb)
{
    RonM_ASSERT(!m_plbPathDatabase);

    m_plbPathDatabase = plb;

    ULONG cbRead = 0;

    HRESULT hr = m_plbPathDatabase->ReadAt(CULINT(0).Uli(), &m_dbh, 
                                           sizeof(m_dbh), &cbRead
                                          );

    if (SUCCEEDED(hr) && cbRead != sizeof(m_dbh))
        hr = STG_E_WRITEFAULT;

    if (SUCCEEDED(hr) && m_dbh.uiMagic != PathMagicID)
        hr = STG_E_INVALIDHEADER;

    if (SUCCEEDED(hr) && m_dbh.uiVersion > PathVersion)
        hr = STG_E_INVALIDHEADER;

    if (SUCCEEDED(hr))
    {
        if (m_dbh.cCacheBlocksMax < 2 * m_dbh.cDirectoryLevels)
            m_dbh.cCacheBlocksMax = 2 * m_dbh.cDirectoryLevels;
        
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::GetClassID
            (CLSID __RPC_FAR *pClassID)
{
    *pClassID = CLSID_PathManager_1;

    return NO_ERROR;
}


HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::FlushToLockBytes()
{
    CSyncWith sw(m_cs);

    RonM_ASSERT(m_plbPathDatabase);

    HRESULT hr = NO_ERROR;

    for (PCacheBlock pCB = m_pCBLeastRecent; pCB; pCB = pCB->pCBNext)
    {
        UINT fFlags = pCB->fFlags;

        if (pCB->fFlags & DirtyBlock)
        {    
            HRESULT hr = WriteCacheBlock(pCB);

            if (!SUCCEEDED(hr))
                break;
        }
    }

    if (SUCCEEDED(hr) && m_fHeaderIsDirty)
        hr = SaveHeader();

    if (SUCCEEDED(hr))
        hr = m_plbPathDatabase->Flush();

    return hr;
}

HRESULT CPathManager1::CImpIPathManager::SaveHeader()
{
    ULONG cbWritten = 0;

    HRESULT hr = m_plbPathDatabase->WriteAt(CULINT(0).Uli(), &m_dbh, 
                                            sizeof(m_dbh), &cbWritten
                                           );

    if (SUCCEEDED(hr) && cbWritten != sizeof(m_dbh))
        hr = STG_E_WRITEFAULT;

    return hr;
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::FindEntry(PPathInfo pSI)
{
    HRESULT hr = NO_ERROR;

    // LockBytes entries (Paths that don't end with '/') must have uStateBits
    // set to zero. Actually letting them go non-zero would be harmless, but it
    // does increase the size of the B-Tree entries.

    TaggedPathInfo tsi;

    tsi.SI = *pSI;

    PCacheBlock *papCBSet 
        = (PCacheBlock *) _alloca(sizeof(PCacheBlock) * m_dbh.cDirectoryLevels);
    
    CSyncWith sw(m_cs);

    hr = FindKeyAndLockBlockSet(&tsi, papCBSet, 0);
                 
    ClearLockFlags(papCBSet);

	if (SUCCEEDED(hr))
        *pSI = tsi.SI;

    return hr;     
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::CreateEntry
                              (PPathInfo pSINew, 
                               PPathInfo pSIOld, 
                               BOOL fReplace
                              )
{
    HRESULT hr = NO_ERROR;

    // LockBytes entries (Paths that don't end with '/') must have uStateBits
    // set to zero. Actually letting them go non-zero would be harmless, but it
    // does increase the size of the B-Tree entries.

    RonM_ASSERT((   pSINew->cwcStreamPath 
                 && pSINew->awszStreamPath[pSINew->cwcStreamPath - 1] == L'/'
                ) || pSINew->uStateBits == 0
               );

    TaggedPathInfo tsi;

    tsi.SI = *pSINew;

    // The allocation below includes slots for two levels beyond m_dbh.cDirectoryLevels.
    // That's because insert/delete/modify actions may cause a new root node to be
    // created twice in the worst case. An insert or modify transaction can cause
    // a leaf split which may propagate up through the root node. In addition when
    // any of those three actions changes the tag for a node, that tag change may
    // propagate back to the root node and cause a split there.

    PCacheBlock *papCBSet 
        = (PCacheBlock *) _alloca(sizeof(PCacheBlock) * (m_dbh.cDirectoryLevels + 2));
    
    CSyncWith sw(m_cs);

    hr = FindKeyAndLockBlockSet(&tsi, papCBSet, 0);

    if (hr == S_OK) // Does the file already exist?
    {
        *pSIOld = tsi.SI;

        if (fReplace)
        {
            hr = DeleteEntry(&tsi.SI);

            ClearLockFlags(papCBSet);

            if (SUCCEEDED(hr))
                hr = CreateEntry(pSINew, &tsi.SI, TRUE);
        }
        else hr = STG_E_FILEALREADYEXISTS;
    }
    else
        if (hr == S_FALSE) 
            hr = InsertEntryIntoLeaf(&tsi, papCBSet);
                 
    ClearLockFlags(papCBSet);

    return hr;     
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::DeleteEntry(PPathInfo pSI)
{
    HRESULT hr = NO_ERROR;

    TaggedPathInfo tsi;

    tsi.SI = *pSI;

    // The allocation below includes slots for two levels beyond m_dbh.cDirectoryLevels.
    // That's because insert/delete/modify actions may cause a new root node to be
    // created twice in the worst case. An insert or modify transaction can cause
    // a leaf split which may propagate up through the root node. In addition when
    // any of those three actions changes the tag for a node, that tag change may
    // propagate back to the root node and cause a split there.

    PCacheBlock *papCBSet 
        = (PCacheBlock *) _alloca(sizeof(PCacheBlock) * (m_dbh.cDirectoryLevels + 2));
    
    CSyncWith sw(m_cs);

    hr = FindKeyAndLockBlockSet(&tsi, papCBSet, 0);

    if (hr == S_OK)
    {
        *pSI = tsi.SI;

        hr = RemoveEntryFromNode(&tsi, papCBSet, 0);
    }
                
    ClearLockFlags(papCBSet);

	return hr;
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::UpdateEntry(PPathInfo pSI)
{
    HRESULT hr = NO_ERROR;

    // LockBytes entries (Paths that don't end with '/') must have uStateBits
    // set to zero. Actually letting them go non-zero would be harmless, but it
    // does increase the size of the B-Tree entries.

    RonM_ASSERT((   pSI->cwcStreamPath 
                 && pSI->awszStreamPath[pSI->cwcStreamPath - 1] == L'/'
                ) || pSI->uStateBits == 0
               );
    
    TaggedPathInfo tsi;
          PathInfo  si = *pSI;

    tsi.SI = *pSI;

    // The allocation below includes slots for two levels beyond m_dbh.cDirectoryLevels.
    // That's because insert/delete/modify actions may cause a new root node to be
    // created twice in the worst case. An insert or modify transaction can cause
    // a leaf split which may propagate up through the root node. In addition when
    // any of those three actions changes the tag for a node, that tag change may
    // propagate back to the root node and cause a split there.

    PCacheBlock *papCBSet 
        = (PCacheBlock *) _alloca(sizeof(PCacheBlock) * (m_dbh.cDirectoryLevels + 2));
    
    CSyncWith sw(m_cs);

    hr = FindKeyAndLockBlockSet(&tsi, papCBSet, 0);

    if (hr == S_OK)
    {
        tsi.SI = si;  // FindKeyAndLockBlockSet overwrote tsi.SI.
                      // We're restoring its values.

        hr = UpdateEntryInLeaf(&tsi, papCBSet);
    }
                
    ClearLockFlags(papCBSet);

    return hr;
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::EnumFromObject
            (IUnknown *punkOuter, const WCHAR *pwszPrefix, UINT cwcPrefix, 
			 REFIID riid, PVOID *ppv
			)
{
    CSyncWith sw(m_cs);

    AddRef(); // Because we pass this object to NewPathEnumeratorObject
    
    HRESULT hr  = CEnumPathMgr1::NewPathEnumeratorObject
		              (punkOuter, this, pwszPrefix, cwcPrefix, riid, ppv);

    return hr;
}


HRESULT CPathManager1::CImpIPathManager::InsertEntryIntoLeaf
    (PTaggedPathInfo ptsi, PCacheBlock *papCBSet)
{
    BYTE abEntry[CB_STREAM_INFO_MAX];

    PBYTE pb = EncodePathInfo(abEntry, &ptsi->SI);
    UINT  cb = UINT(pb - abEntry);

    return InsertEntryIntoNode(ptsi, abEntry, cb, papCBSet, 0, FALSE);
}

HRESULT CPathManager1::CImpIPathManager::UpdateEntryInLeaf  
    (PTaggedPathInfo ptsi, PCacheBlock *papCBSet)
{
    BYTE abEntry[CB_STREAM_INFO_MAX];

    PBYTE pb = EncodePathInfo(abEntry, &ptsi->SI);
    UINT  cb = UINT(pb - abEntry);

    return ModifyEntryInNode(ptsi, abEntry, cb, papCBSet, 0);
}

void  CPathManager1::CImpIPathManager::KillKeyCount(LeafNode *pln)
{
    if (m_dbh.cbDirectoryBlock <= 0x10000 && pln->nh.cbSlack >= sizeof(USHORT))
        PUSHORT(PBYTE(pln) + m_dbh.cbDirectoryBlock)[-1] = 0;
    else
        if (m_dbh.cbDirectoryBlock > 0x10000 && pln->nh.cbSlack >= sizeof(UINT))
            PUINT(PBYTE(pln) + m_dbh.cbDirectoryBlock)[-1] = 0;
}

HRESULT CPathManager1::CImpIPathManager::InsertEntryIntoNode
    (PTaggedPathInfo ptsi, PBYTE pb, UINT cb, PCacheBlock *papCBSet, UINT iLevel, BOOL fAfter)
{    
    if (iLevel >= m_dbh.cDirectoryLevels) 
        return NO_ERROR;
    
    PCacheBlock pCBNode = papCBSet[iLevel];

    PLeafNode pln = &(pCBNode->ldb);

    //invalidate the binary search index
	BOOL fSmall = m_dbh.cbDirectoryBlock <= 0x10000;
	
	if (fSmall && (pln->nh.cbSlack >= sizeof(USHORT)))
	{
		((PUSHORT)(PBYTE(pln) + m_dbh.cbDirectoryBlock))[-1] = 0;
	}
	else if (!fSmall && (pln->nh.cbSlack >= sizeof(UINT)))
	{
		((PUINT)(PBYTE(pln) + m_dbh.cbDirectoryBlock))[-1] = 0;
	}
	
	
	UINT  offKey  = pCBNode->cbKeyOffset;
    UINT  cbSlack = pln->nh.cbSlack;

    UINT  cbTotal = m_dbh.cbDirectoryBlock - sizeof(NodeHeader);
    PBYTE pbInfo  = PBYTE(pln) + offKey    + sizeof(NodeHeader);

    if (iLevel == 0) // Leaf nodes have link pointers in their header. 
    {
        cbTotal -= sizeof(LeafChainLinks);
        pbInfo  += sizeof(LeafChainLinks);
    }
    else 
        if (fAfter) 
        {
            // Insertion point follows the node at pbInfo. So we need
            // to adjust pbInfo and offKey.

            UINT cbEntry = pCBNode->cbEntry;

            offKey += cbEntry;
            pbInfo += cbEntry;
        }

    // UINT cbEntry    = ptsi->cbEncoded;

    if (cb <= cbSlack) // Do we have enough space in this node?
    {
        // If so, we just slide down the trailing content and
        // copy in the  entry.

        UINT cbTrailing = cbTotal - cbSlack - offKey;

        if (cbTrailing) // > 0 => Insert; == 0 => append
        {
            MoveMemory(pbInfo + cb, pbInfo, cbTrailing);

            if (iLevel == 0) // Insertions into leaf nodes increment the leaf serial.                           
                while (!++(pln->lcl.iLeafSerial)); // Zero isn't a valid serial number.
        }
        
        CopyMemory(pbInfo, pb, cb);
        
        // Then we adjust the header info to account for the new
        // entry.

        pln->nh.cbSlack  -= cb;

        KillKeyCount(pln);

        pCBNode->fFlags  |= DirtyBlock;

        HRESULT hr = NO_ERROR;

        if (offKey == 0 && ++iLevel < m_dbh.cDirectoryLevels) 
        {
            // This key has become the tag for this node.
            // Need to fix up nodes higher in the tree.

            // First we construct the entry we'll use in the parent node

            UINT cbOld = cb;
            PBYTE pb2  = pb;  
            UINT cbKey = DecodeVL32((const BYTE **)&pb2);
            cb         = UINT(EncodeVL32(pb2 + cbKey, pCBNode->iBlock) - pb);

            // We've finished modifying this node. So we don't need to keep it 
            // locked anymore,

            pCBNode->fFlags &= ~LockedBlock;

            if (cbSlack == cbTotal) // Was the node originally empty?
                InsertEntryIntoNode(ptsi, pb, cb, papCBSet, iLevel, FALSE);
            else
            {
                // The node wasn't empty. The old tag follows our data.
                
                ClearLockFlags(papCBSet);

                PBYTE pbOldKey = pbInfo + cbOld;

                hr = DecodePathKey((const BYTE **)&pbOldKey, ptsi->SI.awszStreamPath, 
                                                   (PUINT) &(ptsi->SI. cwcStreamPath)
                                  );

                ClearLockFlags(papCBSet);
                
                if (SUCCEEDED(hr))
                    hr = FindKeyAndLockBlockSet(ptsi, papCBSet, iLevel);
                
                if (SUCCEEDED(hr))
                    hr = ModifyEntryInNode(ptsi, pb, cb, papCBSet, iLevel);
            }
        }

        return hr;
    }

    HRESULT hr = SplitANode(papCBSet, iLevel);
    
    if (SUCCEEDED(hr))
        hr = FindKeyAndLockBlockSet(ptsi, papCBSet, iLevel);
    
    if (SUCCEEDED(hr))
        hr = InsertEntryIntoNode(ptsi, pb, cb, papCBSet, iLevel, fAfter);

    return hr;
}

HRESULT CPathManager1::CImpIPathManager::RemoveEntryFromNode
    (PTaggedPathInfo ptsi, PCacheBlock *papCBSet, UINT iLevel)
{
    PCacheBlock pCBNode = papCBSet[iLevel];

    PLeafNode pln = &(pCBNode->ldb);

    UINT  offKey  = pCBNode->cbKeyOffset;
    UINT  cbSlack = pln->nh.cbSlack;

    UINT  cbTotal = m_dbh.cbDirectoryBlock - sizeof(NodeHeader);
    PBYTE pbInfo  = PBYTE(pln) + offKey    + sizeof(NodeHeader);

    if (iLevel == 0) 
    {
        cbTotal -= sizeof(LeafChainLinks);
        pbInfo  += sizeof(LeafChainLinks);
    }

    UINT cbEntry = pCBNode->cbEntry;

    MoveMemory(pbInfo, pbInfo + cbEntry, cbTotal - cbSlack - offKey - cbEntry);

    cbSlack = 
    pln->nh.cbSlack += cbEntry;

    KillKeyCount(pln);

    if (iLevel == 0)
        while (!++(pln->lcl.iLeafSerial)); // Zero isn't a valid serial number.

    pCBNode->fFlags |= DirtyBlock;

    if (cbSlack == cbTotal)
    {
        // We've removed the last key in this node. This means
        // we need to fix up nodes higher in the tree.

        DEBUGDEF(UINT iBlockRoot = pCBNode->iBlock)

        // First we'll discard the current node.

        if (iLevel == 0)
        {
            while (!++m_PathSetSerial); // Zero isn't a valid serial number!
            
            // If this is a leaf node, we must take it out
            // of the leaf chain.

            UINT iLeafPrev = pln->lcl.iLeafPrevious;
            UINT iLeafNext = pln->lcl.iLeafNext;

            if (ValidBlockIndex(iLeafPrev))
            {
                PCacheBlock pCBPrev = NULL;

                HRESULT hr = FindCacheBlock(&pCBPrev, iLeafPrev);

                if (!SUCCEEDED(hr))
                    return hr;

                RonM_ASSERT(pCBPrev->ldb.lcl.iLeafNext == pCBNode->iBlock);

                pCBPrev->ldb.lcl.iLeafNext = iLeafNext;
                pCBPrev->fFlags |= DirtyBlock;
            }
            else
            {
                RonM_ASSERT(m_dbh.iLeafFirst == iBlockRoot);

                m_dbh.iLeafFirst = iLeafNext;
            }

            if (ValidBlockIndex(iLeafNext))
            {
                PCacheBlock pCBNext = NULL;

                HRESULT hr = FindCacheBlock(&pCBNext, iLeafNext);

                if (!SUCCEEDED(hr))
                    return hr;

                RonM_ASSERT(pCBNext->ldb.lcl.iLeafPrevious == pCBNode->iBlock);

                pCBNext->ldb.lcl.iLeafPrevious = iLeafPrev;
                pCBNext->fFlags |= DirtyBlock;
            }
            else
            {
                RonM_ASSERT(m_dbh.iLeafLast == iBlockRoot);

                m_dbh.iLeafLast = iLeafPrev;
            }
        }

        HRESULT hr = DiscardNode(pCBNode);

        // Then we'll remove its tag from the parent node.

        if (SUCCEEDED(hr))
            if (m_dbh.cDirectoryLevels > 1)
                if (m_dbh.cDirectoryLevels == iLevel + 1)
                {
                    RonM_ASSERT(m_dbh.iRootDirectory == iBlockRoot);

                    m_dbh.cDirectoryLevels = 0; 
                    m_dbh.iRootDirectory   = INVALID_INDEX;            
                }
                else 
                    hr = RemoveEntryFromNode(ptsi, papCBSet, iLevel + 1);

        return hr;
    }
    else 
        if (offKey == 0 && m_dbh.cDirectoryLevels > iLevel + 1)
        {
            // The node isn't empty, but we've removed its original tag.
            // So we must construct a new tag and visit our parent node to
            // modify the old tag entry there.

            BYTE abNewTag[MAX_UTF8_PATH + 6];

            PBYTE pbNewTag  = pbInfo;        
            UINT  cbNewTag  = DecodeVL32((const BYTE **) &pbNewTag);
                  cbNewTag += UINT(pbNewTag - pbInfo);
            
            RonM_ASSERT(cbNewTag <= MAX_UTF8_PATH + 1); // To catch buffer overflow 
                                                        

            // We use the existing pb buffer to construct the new tag.
                  
            CopyMemory(abNewTag, pbInfo, cbNewTag);

            cbNewTag = UINT(EncodeVL32(abNewTag + cbNewTag, pCBNode->iBlock) - abNewTag);

            RonM_ASSERT(cbNewTag <= MAX_UTF8_PATH + 6); // To catch buffer overflow
                                                        // problems in logic

            return ModifyEntryInNode(ptsi, abNewTag, cbNewTag, papCBSet, iLevel + 1);
        }
        else return NO_ERROR;
}

HRESULT CPathManager1::CImpIPathManager::ModifyEntryInNode
    (PTaggedPathInfo ptsi, PBYTE pb, UINT cb, PCacheBlock *papCBSet, UINT iLevel)
{
    if (iLevel >= m_dbh.cDirectoryLevels) 
        return NO_ERROR;
    
    PCacheBlock pCBNode = papCBSet[iLevel];

    PLeafNode pln = &(pCBNode->ldb);

	//invalidate the binary search index
	BOOL fSmall = m_dbh.cbDirectoryBlock <= 0x10000;
	
	if (fSmall && (pln->nh.cbSlack >= sizeof(USHORT)))
	{
		((PUSHORT)(PBYTE(pln) + m_dbh.cbDirectoryBlock))[-1] = 0;
	}
	else if (!fSmall && (pln->nh.cbSlack >= sizeof(UINT)))
	{
		((PUINT)(PBYTE(pln) + m_dbh.cbDirectoryBlock))[-1] = 0;
	}

    
	UINT  offKey  = pCBNode->cbKeyOffset;
    UINT  cbSlack = pln->nh.cbSlack;

    UINT  cbTotal = m_dbh.cbDirectoryBlock - sizeof(NodeHeader);
    PBYTE pbInfo  = PBYTE(pln) + offKey    + sizeof(NodeHeader);

    if (iLevel == 0) 
    {
        cbTotal -= sizeof(LeafChainLinks);
        pbInfo  += sizeof(LeafChainLinks);
    }

    UINT cbOld = pCBNode->cbEntry;
    
    if (cbOld > cb || cbSlack >= cb - cbOld)
    {
        UINT cbTrailing = cbTotal - cbSlack - offKey - cbOld;

        if (cbTrailing)
        {
            MoveMemory(pbInfo + cb, pbInfo + cbOld, cbTrailing);

            if (iLevel == 0)
                while(!++(pln->lcl.iLeafSerial)); // Zero isn't a valid serial number!
        }
        
        CopyMemory(pbInfo, pb, cb);

        pln->nh.cbSlack -= cb - cbOld;

        pCBNode->fFlags |= DirtyBlock;

        return NO_ERROR;
    }

    ClearLockFlags(papCBSet);

    HRESULT hr = SplitANode(papCBSet, iLevel);
    
    if (SUCCEEDED(hr))
        hr = FindKeyAndLockBlockSet(ptsi, papCBSet, iLevel);
    
    if (SUCCEEDED(hr))
        hr = ModifyEntryInNode(ptsi, pb, cb, papCBSet, iLevel);

    return hr;
}

HRESULT CPathManager1::CImpIPathManager::SplitANode(PCacheBlock *papCBSet, UINT iLevel)
{
    RonM_ASSERT(iLevel < m_dbh.cDirectoryLevels);
    
    PCacheBlock pCBNode = papCBSet[iLevel];

    PLeafNode pln = &(pCBNode->ldb);
    UINT  cbSlack = pln->nh.cbSlack;
    UINT  cbTotal = m_dbh.cbDirectoryBlock - sizeof(NodeHeader);
    PBYTE pbBase  = PBYTE(pln)             + sizeof(NodeHeader);

    // Now we scan entries looking for the halfway mark

    PBYTE pb;
    PBYTE pbGoal;
    PBYTE pbLimit = PBYTE(pln) + m_dbh.cbDirectoryBlock - pln->nh.cbSlack;

    TaggedPathInfo tsi;
    if (iLevel == 0) 
    {
        cbTotal -= sizeof(LeafChainLinks);
        pbBase  += sizeof(LeafChainLinks);

        pb     = pbBase;
        pbGoal = pbBase + (cbTotal+1)/2;

        for ( ; pb < pbLimit; )
        {
            UINT cbKey = DecodeVL32((const BYTE **) &pb);
            pb         = SkipKeyInfo(pb + cbKey); 

            if (pb >= pbGoal) 
                break;
        }
    }
    else
    {
        pb     = pbBase;
        pbGoal = pbBase + (cbTotal+1)/2;

        for ( ; pb <= pbLimit; )
        {
            UINT cbKey = DecodeVL32((const BYTE **) &pb);
            pb         = SkipVL(pb + cbKey); 

            if (pb >= pbGoal) 
                break;
        }
    }

    RonM_ASSERT(pb <= pbLimit);

    UINT cbPrefix = UINT(pb - pbBase);
    PCacheBlock pCBNode2;

    HRESULT hr = AllocateNode(&pCBNode2, (iLevel == 0)? LeafBlock : InternalBlock);

    if (S_OK !=hr)
        return hr;

    PLeafNode pln2 = &(pCBNode2->ldb);

    PBYTE pbDest = PBYTE(pln2) + sizeof(NodeHeader);

    if (iLevel == 0)
        pbDest += sizeof(LeafChainLinks);

    CopyMemory(pbDest, pb, UINT(pbLimit - pb));

    pln2->nh.cbSlack   = cbSlack + cbPrefix;
    pln ->nh.cbSlack   = cbTotal - cbPrefix;

    KillKeyCount(pln );
    KillKeyCount(pln2);

    // Both of these blocks have changed. So we set the dirty
    // flags to ensure they will get written to disk.

    pCBNode ->fFlags |= DirtyBlock;
    pCBNode2->fFlags |= DirtyBlock;

    if (iLevel == 0) // Have we split a leaf node?
    {
        // If so, we've got to insert the new node into the chain of leaf nodes.

        while (!++(pln->lcl.iLeafSerial)); // Zero isn't a valid serial number.

        UINT iLeafNew  = pCBNode2->iBlock;
        UINT iLeafOld  = pCBNode ->iBlock;
        UINT iLeafNext = pln->lcl.iLeafNext;

        pln ->lcl.iLeafNext     = iLeafNew;
        pln2->lcl.iLeafNext     = iLeafNext;
        pln2->lcl.iLeafPrevious = iLeafOld;
        
        if (ValidBlockIndex(iLeafNext))
        {
            PCacheBlock pCBLeafNext;

            hr = FindCacheBlock(&pCBLeafNext, iLeafNext);

            if (!SUCCEEDED(hr)) 
                return hr;

            RonM_ASSERT(pCBLeafNext->ldb.lcl.iLeafPrevious == iLeafOld);

            pCBLeafNext->ldb.lcl.iLeafPrevious = iLeafNew;

            pCBLeafNext->fFlags |= DirtyBlock;
        }
        else
        {
            RonM_ASSERT(m_dbh.iLeafLast == iLeafOld);
            
            m_dbh.iLeafLast =  iLeafNew;

            m_fHeaderIsDirty = TRUE;
        }
    }

    hr = DecodePathKey((const BYTE **) &pbDest, tsi.SI.awszStreamPath, (PUINT) &tsi.SI.cwcStreamPath);

    if (!SUCCEEDED(hr))
        return hr;

    BYTE abEntry[CB_STREAM_INFO_MAX];

    pb = EncodePathKey(abEntry, tsi.SI.awszStreamPath, (UINT) tsi.SI.cwcStreamPath);

    pb = EncodeVL32(pb, pCBNode2->iBlock);

    UINT cb = UINT(pb - abEntry);

    // We've  finished with the bottom blocks. So we can
    // unlock their cache blocks for reuse.

    pCBNode ->fFlags &= ~LockedBlock;
    pCBNode2->fFlags &= ~LockedBlock;

    RonM_ASSERT(iLevel <= m_dbh.cDirectoryLevels);

    if (iLevel == m_dbh.cDirectoryLevels - 1)
    {
        // Parent node doesn't exist!
        // We have to add a new level to the B-Tree.

        BYTE abEntryLeft[CB_STREAM_INFO_MAX];

        PBYTE pbLeft = pbBase;

        UINT cbKeyLeft = DecodeVL32((const BYTE **) &pbLeft);

        cbKeyLeft += UINT(pbLeft - pbBase);

        CopyMemory(abEntryLeft, pbBase, cbKeyLeft);

        pbLeft = EncodeVL32(abEntryLeft + cbKeyLeft, pCBNode->iBlock);

        UINT cbEntryLeft = UINT(pbLeft - abEntryLeft);

        PCacheBlock pCBNodeR;

        HRESULT hr = AllocateNode(&pCBNodeR, InternalBlock);

        if (!SUCCEEDED(hr))
            return hr;

        PInternalNode plnR = &(pCBNodeR->idb);
        plnR->nh.cbSlack   = m_dbh.cbDirectoryBlock - sizeof(NodeHeader) - cbEntryLeft;

        KillKeyCount(PLeafNode(plnR));

        CopyMemory(PBYTE(plnR) + sizeof(NodeHeader), abEntryLeft, cbEntryLeft);

        pCBNodeR->cbKeyOffset  = 0;
        pCBNodeR->cbEntry      = cbEntryLeft;
        pCBNodeR->fFlags      |= (DirtyBlock | LockedBlock);

        papCBSet[m_dbh.cDirectoryLevels++] = pCBNodeR;

        m_dbh.iRootDirectory = pCBNodeR->iBlock;

        m_fHeaderIsDirty = TRUE;
    }
    
    RonM_ASSERT(iLevel + 1 < m_dbh.cDirectoryLevels); // Parent node exists.

    hr = InsertEntryIntoNode(&tsi, abEntry, cb, papCBSet, iLevel + 1, TRUE);

    return hr;     
}

HRESULT CPathManager1::CImpIPathManager::GetFreeBlock(PCacheBlock &pCB)
{
    if (m_pCBFreeList) // Do we have any unused cache blocks?
    {
        pCB           = m_pCBFreeList;   // Pull the first item from the list
        m_pCBFreeList = pCB->pCBNext;
        pCB->pCBNext  = NULL;

        return S_OK;
    }
    else return S_FALSE;
}

HRESULT CPathManager1::CImpIPathManager::GetActiveBlock(PCacheBlock &pCB, BOOL fIgnoreLocks)
{
    if (m_pCBLeastRecent) // Do we have any allocated cache blocks
    {
        // If so, scan the list to find one we can use.

        for (PCacheBlock pCBNext = m_pCBLeastRecent; pCBNext; pCBNext = pCBNext->pCBNext)
        {
            // In general locked blocks are unavailable to us.
            // However during the destructor for CPathManager1::CImpIPathManager,
            // fIgnoreLocks will be set true. Of course we should not have any
            // lock bits set when the destructor is called. So the destructor 
            // will Assert if it sees any locked cache blocks.

            if (fIgnoreLocks || !(pCBNext->fFlags & LockedBlock)) 
            {
                if (pCBNext->fFlags & DirtyBlock) // Write contents to disk 
				{
                    HRESULT hr = WriteCacheBlock(pCBNext);     // when necesary

					if (!SUCCEEDED(hr)) continue;
				}

                RemoveFromUse(pCBNext);

                pCB = pCBNext;
                
                return S_OK;
            }
        }
    }
    
    return S_FALSE;
}

void CPathManager1::CImpIPathManager::MarkAsMostRecent(PCacheBlock pCB)
{
    // This routine inserts a cache block into the MRU end of the chain
    // of in-use cache blocks.

    RonM_ASSERT((pCB->fFlags & BlockTypeMask) != 0);         // Must have a type
    RonM_ASSERT((pCB->fFlags & BlockTypeMask) != FreeBlock); // Can't be a free block

    RonM_ASSERT(pCB->pCBPrev == NULL);
    RonM_ASSERT(pCB->pCBNext == NULL);
    RonM_ASSERT(pCB != m_pCBMostRecent);

    pCB->pCBPrev    = m_pCBMostRecent;

    if (m_pCBMostRecent)
    {
        RonM_ASSERT(m_pCBLeastRecent);
        m_pCBMostRecent->pCBNext = pCB;
    }
    else
    {    
        RonM_ASSERT(!m_pCBLeastRecent);
        m_pCBLeastRecent = pCB;
    }

    pCB->pCBNext    = NULL;
    m_pCBMostRecent = pCB;
}

void CPathManager1::CImpIPathManager::RemoveFromUse(PCacheBlock pCB)
{
    // This routine removes a cache block from the chain of in-use blocks.
    
    RonM_ASSERT((pCB->fFlags & BlockTypeMask) != 0);         // Must have a type
    RonM_ASSERT((pCB->fFlags & BlockTypeMask) != FreeBlock); // Can't be a free block

    PCacheBlock pCBNext = pCB->pCBNext;
    PCacheBlock pCBPrev = pCB->pCBPrev;

    if  (pCBNext) 
         pCBNext->pCBPrev = pCBPrev;
    else m_pCBMostRecent  = pCBPrev;

    if  (pCBPrev)
         pCBPrev->pCBNext = pCBNext;
    else m_pCBLeastRecent = pCBNext;

    pCB->pCBNext = NULL;
    pCB->pCBPrev = NULL;
}

HRESULT CPathManager1::CImpIPathManager::GetCacheBlock(PCacheBlock *ppCB, UINT fTypeMask)
{
    PCacheBlock pCB = NULL;
    
    HRESULT hr = GetFreeBlock(pCB);
    
    if (hr == S_FALSE) // If we couldn't get a free block
    {                  // We first try to allocate a new block.

        // The number of blocks we can allocate is set a creation time.
        // However we always require space for two blocks per level in the
        // tree. That's because in the worst case we could split a node at
        // each level of the tree. Actually we can probably do better than 
        // that with careful management of the lock bits on the cache blocks.

        if (m_dbh.cCacheBlocksMax < 2 * m_dbh.cDirectoryLevels)
            m_dbh.cCacheBlocksMax = 2 * m_dbh.cDirectoryLevels;

        if (m_cCacheBlocks < m_dbh.cCacheBlocksMax) // Can we create another cache block?
        {
            // The size of cache block depends on the on-disk block size chosen when the
            // path manager object was created. This works because the variable sized 
            // portion is a trailing byte array in each case. So we allocate each cache
            // block as a byte array and then cast its address.

            // Note that when we delete a CacheBlock, we must do the cast in the opposite
            // direction to keep the object allocator clued in about the real size of this
            // object.
        
            RonM_ASSERT(sizeof(LeafNode) >= sizeof(InternalNode));
        
            pCB = (CacheBlock *) New BYTE[sizeof(CacheBlock) + m_dbh.cbDirectoryBlock
                                                             - sizeof(LeafNode)                                                                            
                                         ];
        
            m_cCacheBlocks++;

            pCB->pCBNext = NULL;
            pCB->pCBPrev = NULL;

            hr = NO_ERROR;
        }
        else hr = GetActiveBlock(pCB); // Finally we look for an active block that we
                                       // take over. 
    }

    if (S_OK != hr) // Did we get a block?
        return hr;

    pCB->fFlags   = fTypeMask;       // Set the type flag; clear all other states
    pCB->iBlock   = INVALID_INDEX;   // Mark the on-disk index invalid

    MarkAsMostRecent(pCB);           // Move to the end of the LRU list.
    
    *ppCB = pCB;

    return NO_ERROR;
}

HRESULT CPathManager1::CImpIPathManager::FreeCacheBlock(PCacheBlock pCB)
{
    RonM_ASSERT((pCB->fFlags & BlockTypeMask) == FreeBlock);
    
//    pCB->fFlags   = FreeBlock;
    pCB->pCBNext  = m_pCBFreeList;
    m_pCBFreeList = pCB;

    return NO_ERROR;
}

HRESULT CPathManager1::CImpIPathManager:: ReadCacheBlock(PCacheBlock pCB, UINT iBlock)
{
 
    RonM_ASSERT(!ValidBlockIndex(pCB->iBlock));

    pCB->fFlags |= ReadingIn;  // For when we put in asynchronous I/O

    CULINT ullBase(sizeof(m_dbh)), ullSpan(m_dbh.cbDirectoryBlock), ullOffset;

    ullOffset = ullBase + ullSpan * iBlock;

    ULONG cbRead = 0;

    HRESULT hr = m_plbPathDatabase->ReadAt(ullOffset.Uli(), &(pCB->ldb), 
                                           m_dbh.cbDirectoryBlock, &cbRead
                                          );

    RonM_ASSERT(SUCCEEDED(hr));
	
	pCB->fFlags &= ~ReadingIn; // For when we put in asynchronous I/O

    if (SUCCEEDED(hr) && cbRead != m_dbh.cbDirectoryBlock)
        hr = STG_E_READFAULT;

    RonM_ASSERT(SUCCEEDED(hr));
	
    if (SUCCEEDED(hr))
    {
        UINT uiMagic = pCB->ldb.nh.uiMagic;

        if (uiMagic == uiMagicLeaf)
            pCB->fFlags = LeafBlock;
        else
            if (uiMagic == uiMagicInternal)
                pCB->fFlags = InternalBlock;
            else
                if (uiMagic == uiMagicUnused)
                    pCB->fFlags = InternalBlock | LeafBlock;
                else return STG_E_DOCFILECORRUPT;

        pCB->iBlock = iBlock;
    }

    RonM_ASSERT(SUCCEEDED(hr));
	
    return hr;    
}

HRESULT CPathManager1::CImpIPathManager::WriteCacheBlock
            (PCacheBlock   pCB)
{
 
    RonM_ASSERT((pCB->fFlags & DirtyBlock));
    RonM_ASSERT((pCB->fFlags & (InternalBlock | LeafBlock | FreeBlock)));
    RonM_ASSERT(!(pCB->fFlags & (LockedBlock | ReadingIn | WritingOut)));
    RonM_ASSERT(ValidBlockIndex(pCB->iBlock) && pCB->iBlock < m_dbh.cBlocks);

    UINT fType = pCB->fFlags & BlockTypeMask;
	HRESULT hr = NO_ERROR;

    if (fType == InternalBlock || fType == LeafBlock)
    {
        // For these node types we attempt to build an access vector 

        PLeafNode pln = &(pCB->ldb);

        PBYTE pauAccess = PBYTE(pln) + m_dbh.cbDirectoryBlock;
        
        BOOL  fSmall = m_dbh.cbDirectoryBlock <= 0x10000;
        
        if (   (   fSmall 
                && pln->nh.cbSlack >= sizeof(USHORT)
                && !((PUSHORT)pauAccess)[-1]
               )
            || (   !fSmall 
                && pln->nh.cbSlack >= sizeof(UINT)
                && !((PUINT)pauAccess)[-1]
               )
           )
        {
            PBYTE pbLimit = PBYTE(pauAccess) - pln->nh.cbSlack;
            PBYTE pbEntry = pln->ab;
			PBYTE pbStartOffset;

            if (fType == InternalBlock)
                pbEntry -= sizeof(LeafChainLinks);

			UINT		cbSlack = pln->nh.cbSlack - (fSmall ? sizeof(USHORT) : sizeof(UINT));
            UINT		cEntries = 0;
	        UINT		cSearchVEntries = 0;
			UINT		cChunkSize = (1 << m_dbh.cEntryAccessShift)+ 1;
			PathInfo	SI;
			BOOL		fEnoughSpace = TRUE;
			UINT		cb;

			pauAccess -= (fSmall ? sizeof(USHORT) : sizeof(UINT));
			
			pbStartOffset = pbEntry;

			for (;(pbEntry < pbLimit) && fEnoughSpace; )
            {
				if (cEntries && ((cEntries % cChunkSize) == 0))
				{
					cb = (fSmall ? sizeof(USHORT) : sizeof(UINT));
				}
				else 
				{
					cb = 0;
				}
			
				if (cb && (cbSlack >= cb))
				{
					cSearchVEntries++;
					
					if (fSmall)
					{
						((PUSHORT)pauAccess)[-1] = USHORT(pbEntry - pbStartOffset);
					}
					else
					{
						((PUINT)pauAccess)[-1] = UINT(pbEntry - pbStartOffset);
					}
					cbSlack -= cb;
					pauAccess -= cb;
				}
				else if (cb)
					fEnoughSpace = FALSE;

				//advance to the next entry				
				if (fType == LeafBlock)
				{
					hr = DecodePathInfo((const BYTE **) &pbEntry, &SI);
				}
				else
				{
					hr = DecodePathKey((const BYTE **) &pbEntry, SI.awszStreamPath, 
									(PUINT) &(SI.cwcStreamPath));
					DecodeVL32((const BYTE **) &pbEntry);
				}

				cEntries++;
            } //for
			
			if (fEnoughSpace)
			{
				if (fSmall)
				{
					((PUSHORT)(PBYTE(pln) + m_dbh.cbDirectoryBlock))[-1] = USHORT(cEntries);
				}
				else
				{
					((PUINT)(PBYTE(pln) + m_dbh.cbDirectoryBlock))[-1] = cEntries;
				}
				RonM_ASSERT(cSearchVEntries == (cEntries/cChunkSize - 1 + ((cEntries%cChunkSize)?1 : 0)));
			}
        }//access vector not already there
    }//for internal and leaf blocks only


 
    CULINT ullBase(sizeof(m_dbh)), ullSpan(m_dbh.cbDirectoryBlock), ullOffset;

    ullOffset = ullBase + ullSpan * pCB->iBlock;

    ULONG cbWritten = 0;

    pCB->fFlags |= WritingOut;  // For when we do Asynch I/O

    hr = m_plbPathDatabase->WriteAt(ullOffset.Uli(), &(pCB->ldb), 
                                            m_dbh.cbDirectoryBlock, &cbWritten
                                           );

 
    RonM_ASSERT(SUCCEEDED(hr));
	
	pCB->fFlags &= ~WritingOut;  // For when we do Asynch I/O

    if (SUCCEEDED(hr) && cbWritten != m_dbh.cbDirectoryBlock)
        hr = STG_E_WRITEFAULT;

    if (SUCCEEDED(hr))
        pCB->fFlags &= ~DirtyBlock;

    RonM_ASSERT(SUCCEEDED(hr));
	
    return hr;
}

HRESULT CPathManager1::CImpIPathManager::FindCacheBlock(PCacheBlock *ppCB, UINT iBlock)
{
    RonM_ASSERT(ValidBlockIndex(iBlock) && iBlock < m_dbh.cBlocks);

    PCacheBlock pCB;

    for (pCB = m_pCBLeastRecent; pCB; pCB = pCB->pCBNext)
    {
        if (pCB->iBlock == iBlock)
        {
            // Found it!

            RemoveFromUse(pCB);
            MarkAsMostRecent(pCB);

            *ppCB = pCB;

            return NO_ERROR;
        }
    }

    // Didn't find the block in the cache. We need to read it in.
    // First we must find a cache block we can use.

    pCB = NULL;

    HRESULT hr = GetCacheBlock(&pCB, LeafBlock);

    if (hr == S_OK)
    {
        if (SUCCEEDED(hr))
            hr = ReadCacheBlock(pCB, iBlock);
    
        if (!SUCCEEDED(hr))
        {    
            RemoveFromUse(pCB);

            pCB->fFlags = FreeBlock;

            FreeCacheBlock(pCB);  pCB = NULL;
        }
    }
    else
        if (hr == S_FALSE)
            hr = STG_E_INSUFFICIENTMEMORY;

    *ppCB = pCB;

    return hr;
}

HRESULT CPathManager1::CImpIPathManager::AllocateNode(PCacheBlock *ppCB, UINT fTypeMask)
{
    HRESULT     hr = NO_ERROR;
    PCacheBlock pCB;

    RonM_ASSERT(fTypeMask == InternalBlock || fTypeMask == LeafBlock);

    if (ValidBlockIndex(m_dbh.iBlockFirstFree))
    {
        hr = FindCacheBlock(&pCB, m_dbh.iBlockFirstFree);

        if (!SUCCEEDED(hr))
            return hr;
            
        m_dbh.iBlockFirstFree  = pCB->ldb.lcl.iLeafNext;
        pCB->ldb.lcl.iLeafNext = INVALID_INDEX;
        pCB->fFlags            = fTypeMask;
        m_fHeaderIsDirty       = TRUE;
    }
    else
    {    
        hr = GetCacheBlock(&pCB, fTypeMask);

        if (S_OK != hr)
            return hr;
        
        pCB->iBlock      = m_dbh.cBlocks++;
        m_fHeaderIsDirty = TRUE;
    }

    pCB->ldb.lcl.iLeafPrevious = INVALID_INDEX; 

    pCB->idb.nh.uiMagic = (fTypeMask == InternalBlock)? uiMagicInternal : uiMagicLeaf;

    *ppCB = pCB;

    return hr;
}

HRESULT CPathManager1::CImpIPathManager::DiscardNode(PCacheBlock pCB)
{
    // This routine adds a node block to the free list for later use.

    RemoveFromUse(pCB);
    
    pCB->ldb.lcl.iLeafNext = m_dbh.iBlockFirstFree;
    m_dbh.iBlockFirstFree  = pCB->iBlock;
    pCB->fFlags            = DirtyBlock | FreeBlock;
    pCB->ldb.nh.uiMagic    = uiMagicUnused;
    m_fHeaderIsDirty       = TRUE;

    HRESULT hr= WriteCacheBlock(pCB);

    if (SUCCEEDED(hr))
        hr = FreeCacheBlock(pCB);

    return hr;
}


ULONG DecodeVL32(const BYTE **ppb)
{
    const BYTE *pb = *ppb;

    ULONG ul = 0;

    for (;;)
    {
        BYTE b= *pb++;
        
        ul = (ul << 7) | (b & 0x7f);

        if (b < 0x80)
            break;
    }

    *ppb = pb;

    return ul;
}

ULONG CodeSizeVL32(ULONG ul)
{
    ULONG cb = 1;

    for (; ul >>= 7; cb++);

    return cb;
}

PBYTE EncodeVL32(PBYTE pb, ULONG ul)
{
    BYTE  abBuff[8]; // We're only going to use 5 bytes. The 8 is for alignment.
    PBYTE pbNext = abBuff;

    do
    {
        *pbNext++ = 0x80 + (BYTE(ul) & 0x7F);
        ul >>= 7;
    }
    while (ul);

    abBuff[0] &= 0x7F;

    for (UINT  c = UINT(pbNext - abBuff); c--; )
        *pb++ = *--pbNext;

    return pb;
}

CULINT DecodeVL64(const BYTE **ppb)
{
    const BYTE *pb = *ppb;

    CULINT ull(0);

    for (;;)
    {
        BYTE b= *pb++;

        ull <<=  7;
        ull |=  UINT(b & 0x7f);

        if (b < 0x80)
            break;
    }

    *ppb = pb;

    return ull;
}

PBYTE EncodeVL64(PBYTE pb, CULINT *ullValue)
{
    CULINT ull(*ullValue);
    
    BYTE abBuff[16]; // We'll use just 10 bytes. The 16 is for alignment.
    PBYTE pbNext = abBuff;

    do
    {
        *pbNext++ = 0x80 + (BYTE(ull.Uli().LowPart) & 0x7F);
        ull >>= 7;
    }
    while (ull.NonZero());

    abBuff[0] &= 0x7F;

    for (UINT  c = UINT(pbNext - abBuff); c--; )
        *pb++ = *--pbNext;

    return pb;
}

PBYTE SkipVL(PBYTE pb)
{
    while (0x80 <= *pb++);

    return pb;
}

HRESULT CPathManager1::CImpIPathManager::DecodePathKey
            (const BYTE **ppb, PWCHAR pwszPath, PUINT pcwcPath)
{
    const BYTE *pb = *ppb;
    
    ULONG cbPath = DecodeVL32(&pb);

    ULONG cwc = UTF8ToWideChar((const char *) pb, INT(cbPath), pwszPath, MAX_PATH - 1);

    RonM_ASSERT(cwc);

    if (!cwc) 
        return GetLastError();

    pwszPath[cwc] = 0;

    *pcwcPath = cwc;
    *ppb      = pb + cbPath;

    return NO_ERROR;
}

PBYTE   CPathManager1::CImpIPathManager::EncodePathKey
            (PBYTE pb, const WCHAR *pwszPath, UINT  cwcPath)
{
    BYTE abFileName[MAX_UTF8_PATH];

    INT cb = WideCharToUTF8(pwszPath, cwcPath, PCHAR(abFileName), MAX_UTF8_PATH);

    RonM_ASSERT(cb);

    pb = EncodeVL32(pb, cb);

    CopyMemory(pb, abFileName, cb);

    return pb + cb;
}

HRESULT CPathManager1::CImpIPathManager::DecodeKeyInfo
            (const BYTE **ppb, PPathInfo pSI)
{
    const BYTE *pb = *ppb;

    CULINT ullStateAndSegment;

    ullStateAndSegment       = DecodeVL64(&pb);
    pSI->uStateBits          = ullStateAndSegment.Uli().HighPart;
    pSI->iLockedBytesSegment = ullStateAndSegment.Uli(). LowPart;
    pSI->ullcbOffset         = DecodeVL64(&pb);
    pSI->ullcbData           = DecodeVL64(&pb);

    *ppb = pb;

    return NO_ERROR;
}

PBYTE CPathManager1::CImpIPathManager::SkipKeyInfo(PBYTE pb)
{
    for (UINT c= 3; c--; )
        while (0x80 <= *pb++);

    return pb;
}

PBYTE CPathManager1::CImpIPathManager::EncodeKeyInfo
          (PBYTE pb, const PathInfo *pSI)
{
    CULINT ullcbOffset;
    ullcbOffset = pSI->ullcbOffset;
    CULINT ullcbData;
    ullcbData = pSI->ullcbData;


    ULARGE_INTEGER uliStateAndSegment;

    uliStateAndSegment.HighPart = pSI->uStateBits;
    uliStateAndSegment. LowPart = pSI->iLockedBytesSegment;

    CULINT ullStateAndSegment;

    ullStateAndSegment = uliStateAndSegment;
    
    pb = EncodeVL64(pb, &ullStateAndSegment);
    pb = EncodeVL64(pb, &ullcbOffset);
    pb = EncodeVL64(pb, &ullcbData);

    return pb;
}

HRESULT CPathManager1::CImpIPathManager::DecodePathInfo
            (const BYTE **ppb, PPathInfo pSI)
{
    const BYTE *pb = *ppb;
    
    HRESULT hr = DecodePathKey(&pb, pSI->awszStreamPath, (PUINT) &(pSI->cwcStreamPath));
    
    if (!SUCCEEDED(hr)) 
        return hr;

    hr = DecodeKeyInfo(&pb, pSI);

    if (!SUCCEEDED(hr))
        return hr;

    *ppb = pb;

    return NO_ERROR;
}

PBYTE   CPathManager1::CImpIPathManager::EncodePathInfo
            (PBYTE pb, const PathInfo *pSI)
{
    pb = EncodePathKey(pb, pSI->awszStreamPath, pSI->cwcStreamPath);
    pb = EncodeKeyInfo(pb, pSI);

    return pb;   
}

void CPathManager1::CImpIPathManager::ClearLockFlags(PCacheBlock *papCBSet)
{
    for (UINT c = m_dbh.cDirectoryLevels; c--; )
        papCBSet[c]->fFlags &= ~LockedBlock;        
}

void CPathManager1::CImpIPathManager::ClearLockFlagsAbove
         (PCacheBlock *papCBSet, UINT iLevel)
{
    for (UINT c = m_dbh.cDirectoryLevels; c-- > iLevel; )
        papCBSet[c]->fFlags &= ~LockedBlock;        
}


HRESULT CPathManager1::CImpIPathManager::FindKeyAndLockBlockSet
     (PTaggedPathInfo ptsi, PCacheBlock *papCBSet, UINT iLevel, UINT cLevels)
{
    // This routine searches for an instances of a particular key within the
    // B-Tree nodes. It uses a recursive algorithm which loads the nodes
    // in the key path into cache blocks, locks them in memory, and records 
    // the sequence of cache blocks in papCBSet. 
    //
    // The entries in papCBSet are ordered from leaf node to root node. That
    // is, papCBSet[0] denotes the cache block which contains the leaf node
    // that either contains the key in question or is the correct place to
    // insert a new key. Then papCBSet[1] refers to the internal node which
    // points to the leaf node, papCBSet[2] describes the grandparent node
    // for the leaf, and so on. As you can see, *papCBSet must contain one 
    // entry for each level of the B-Tree.
    //
    // If you're just looking up an existing key and retrieving its 
    // information record, recording that information in papCBSet and locking
    // the cache blocks is unnecessary. You can prevent that by passing NULL
    // for the papCBSet parameter.
    //
    // However if you need to insert a key, delete a key, or changes its 
    // information record, papCBSet gives you a mechanism to follow the 
    // key's access path back toward the root. 
    //
    // In many cases your changes will affect only the leaf node in the
    // set. There are three situations in which your change may cause changes
    // beyond the leaf node:
    //
    // 1. You've changed the tag key for the leaf node. 
    //
    //    The tag key is the first key in the leaf. It can change when you're 
    //    inserting or deleting a key entry. The leaf's tag key is recorded in 
    //    its parent node. Thus changes to a tag key will propagate to the 
    //    parent node. If the key is also a tag for the parent node, the
    //    change will continue to propagate up the tree.
    //    
    // 2. You've deleted the last key entry in the leaf and collapsed its
    //    content to nothing. 
    //
    //    In that case you must add the leaf node to the list of free blocks 
    //    and remove its tag from its parent node. If that tag happens to
    //    be the only entry in the parent node, it too will collapse, and the
    //    collapse will propagate up the tree.
    //
    // 3. The leaf nodes doesn't have enough room for your change. 
    //
    //    This can happen when you're inserting a new key. It can also happen 
    //    when you're changing the information for an existing key. That's
    //    because we're using variable length encodings in the information 
    //    record. Thus changing a value can change the length of the 
    //    information.
    //
    //    In this case you must split the leaf node. That is, you must allocate 
    //    a new leaf node and move the trailing half of its key entries into 
    //    the new node. When you split a leaf node, you have to insert its tag
    //    into the tree heirarchy above the leaf. 
    //
    // Each of these three scenarios can also occur when you're modifying
    // a tag in one of the internal tree nodes. Thus in the most complicated
    // scenarios changes can proliferate and propagate recursively throughout
    // the tree heirarchy.
    //
    // The *papCBSet information is meant to handle relatively simple cases of
    // change propagation. Whenever a change forks into two side-effects, the
    // correct strategy is to unlock all the cache blocks in the set and then
    // make each change as a separate transaction at the appropriate level within
    // the tree. The important thing to node here is that you must number levels
    // relative to the leaf level. That's because changes propagating through
    // the B-Tree may add or subtract levels above the level where you're working.       
    
    // Note: This function must be executed within a critical section.

    
    HRESULT hr = NO_ERROR;

    PCacheBlock pCB = NULL;

    if (cLevels == UINT(~0))
        cLevels  = m_dbh.cDirectoryLevels;

    RonM_ASSERT(cLevels >= iLevel);
    
    if (!cLevels)
    {
        // Nothing defined yet. Create the first leaf block.

        RonM_ASSERT(!ValidBlockIndex(m_dbh.iRootDirectory));
        RonM_ASSERT(!ValidBlockIndex(m_dbh.iLeafFirst    ));
        RonM_ASSERT(!ValidBlockIndex(m_dbh.iLeafLast     ));

        hr = AllocateNode(&pCB, LeafBlock); // To force creation of a node.
            
        if (!SUCCEEDED(hr)) 
            return hr;
        
        if (papCBSet)
        {
            papCBSet[0] = pCB; 
            
            pCB->fFlags |= LockedBlock;
        }

        RonM_ASSERT(m_dbh.cDirectoryLevels == 0);

        // Now we must adjust the database header because we've gone 
        // from zero levels to one level -- the leaf level.

        m_dbh.cDirectoryLevels++;
        m_dbh.iLeafFirst = 0;     // The leaf change exists now and this
        m_dbh.iLeafLast  = 0;     // is the only node in the sequence.

        m_fHeaderIsDirty = TRUE;  // So our header changes will get copied to
                                  // disk eventually.

        pCB->fFlags |= LeafBlock;   

        RonM_ASSERT(pCB->fFlags & LockedBlock);

        // Here we're setting up the header for the new leaf node.

        pCB->ldb.nh.uiMagic        = uiMagicLeaf;   // So we can recognize bogus nodes
        pCB->ldb.lcl.iLeafSerial   = 1;             // Initial version serial number
        pCB->ldb.lcl.iLeafPrevious = INVALID_INDEX; // Nothing else in the leaf chain
        pCB->ldb.lcl.iLeafNext     = INVALID_INDEX; // Nothing else in the leaf chain
        pCB->ldb.nh.cbSlack        = m_dbh.cbDirectoryBlock - sizeof(NodeHeader)
                                                            - sizeof(LeafChainLinks);
        KillKeyCount(&(pCB->ldb));

        return ScanLeafForKey(pCB, ptsi);
    }

    RonM_ASSERT(cLevels > iLevel);

    if (cLevels == m_dbh.cDirectoryLevels)
    {
        // This is the beginning of the recursive search. We're at the root of
        // the B-Tree.

        if (cLevels > 1)
        {
            // We have at least one internal node.

            RonM_ASSERT(ValidBlockIndex(m_dbh.iRootDirectory)); 

            hr = FindCacheBlock(&pCB, m_dbh.iRootDirectory); // Get the root node.
        
            RonM_ASSERT(SUCCEEDED(hr)); // We're in big trouble if this doesn't work!
            
            RonM_ASSERT(pCB->fFlags & InternalBlock); // Verify that it isn't a leaf
                                                      // or a free node.
        }
        else 
        {
            // Must have just a single leaf node.

            RonM_ASSERT(cLevels == 1);
            RonM_ASSERT(ValidBlockIndex(m_dbh.iLeafFirst));
            RonM_ASSERT(ValidBlockIndex(m_dbh.iLeafLast ));
            RonM_ASSERT(m_dbh.iLeafFirst == m_dbh.iLeafLast);

            hr = FindCacheBlock(&pCB, m_dbh.iLeafFirst);
        
            RonM_ASSERT(SUCCEEDED(hr)); // We're in big trouble if this doesn't work!
            
            RonM_ASSERT(pCB->fFlags & LeafBlock); // Verify that it isn't an internal
                                                  // node or a free node.
        }
        
        pCB->fFlags |= LockedBlock;

        papCBSet[--cLevels] = pCB;
    }
    else --cLevels;

    pCB = papCBSet[cLevels];

    if (cLevels == 0)
    {
        // We've gotten to the leaf level.
        
        RonM_ASSERT(iLevel == 0);

        return ScanLeafForKey(pCB, ptsi);
    }
    else
    {
        UINT iChild;
        
        hr = ScanInternalForKey(pCB, ptsi, &iChild);

        if (!SUCCEEDED(hr))
            return hr;

        if (cLevels == iLevel) // Stop when we get down to the requested level.
            return hr;

        hr = FindCacheBlock(&pCB, iChild);

        if (!SUCCEEDED(hr))
            return hr;
        
        RonM_ASSERT(SUCCEEDED(hr)); // We're in big trouble if this doesn't work!

        pCB->fFlags |= LockedBlock;

        papCBSet[cLevels - 1] = pCB;

        hr = FindKeyAndLockBlockSet(ptsi, papCBSet, iLevel, cLevels);
    }

    return hr;
}

HRESULT CPathManager1::CImpIPathManager::ScanInternalForKey
     (PCacheBlock pCacheBlock, PTaggedPathInfo ptsi, PUINT piChild)
{
    RonM_ASSERT((pCacheBlock->fFlags & BlockTypeMask) == InternalBlock);
    
    PInternalNode pidb = &(pCacheBlock->idb);
    
    TaggedPathInfo tsi;
	
    HRESULT hr;
	UINT cEntries = 0;

     if (m_dbh.cbDirectoryBlock <= 0x10000 && pidb->nh.cbSlack >= sizeof(USHORT))
        cEntries = (UINT)(PUSHORT(PBYTE(pidb) + m_dbh.cbDirectoryBlock))[-1];
     else if (m_dbh.cbDirectoryBlock > 0x10000 && pidb->nh.cbSlack >= sizeof(UINT))
		cEntries = (PUINT(PBYTE(pidb) + m_dbh.cbDirectoryBlock))[-1];
	
	 ZeroMemory(&tsi, sizeof(tsi));

	BOOL fSmall = m_dbh.cbDirectoryBlock <= 0x10000;
	PBYTE   pauAccess = PBYTE(pidb) + m_dbh.cbDirectoryBlock;
	pauAccess -= (fSmall ? sizeof(USHORT) : sizeof(UINT));

	PBYTE pb = pidb->ab;
	UINT  cSeqSearch = 0;
	UINT cSearchVEntries = 0;
	UINT cChunkSize = (1 << m_dbh.cEntryAccessShift)+ 1;

	//Binary search in search index array to get to the closed entry from where
	//sequential search can be started.
	if (cEntries > 0)
	{
		if (cEntries > cChunkSize) 
		{
			cSearchVEntries = (cEntries - cChunkSize) / cChunkSize;
		
			cSearchVEntries += (((cEntries - cChunkSize) % cChunkSize) ? 1 : 0);
		}

		if (cSearchVEntries)
		{
			hr = BinarySearch(0, cSearchVEntries, pauAccess, 
				fSmall ?  sizeof(USHORT) : sizeof(UINT), ptsi, pidb->ab, &pb, fSmall); 
		}
	}

    //start sequential search from here
	RonM_ASSERT(pb      >= pidb->ab);
    
	PBYTE pbLimit = PBYTE(pidb) + m_dbh.cbDirectoryBlock - pidb->nh.cbSlack;


	PBYTE pbLast     = pb;
    PBYTE pbKey      = pb;
    UINT  iChildLast = UINT(~0);
	
	cSeqSearch = 0; 

    for ( ; pb < pbLimit; )
    {
		cSeqSearch++;
        pbLast = pbKey; 
        pbKey  = pb;

        HRESULT hr = DecodePathKey((const BYTE **) &pb, tsi.SI.awszStreamPath, (UINT *) &tsi.SI.cwcStreamPath);
        
        if (!SUCCEEDED(hr))
            return hr;

        int icmp = wcsicmp_0x0409(ptsi->SI.awszStreamPath, tsi.SI.awszStreamPath);

        if (icmp > 0)
        {
            iChildLast = DecodeVL32((const BYTE **) &pb);

            if (cEntries)
				RonM_ASSERT(cSeqSearch <= (cChunkSize + 1));
			
			continue;
        }
            
        if (icmp == 0)
        {
			cSeqSearch = 0;
            // Found it!
            
            *piChild = DecodeVL32((const BYTE **) &pb);

            pCacheBlock->cbKeyOffset = UINT(pbKey - pidb->ab);
            pCacheBlock->cbEntry     = UINT(pb    - pbKey);

            return S_OK;
        }

        // Found the place to insert key data

        if (ValidBlockIndex(iChildLast))
        {
            *piChild = iChildLast;
            pCacheBlock->cbEntry = UINT(pbKey - pbLast);
        }
        else
        {
            *piChild = DecodeVL32((const BYTE **) &pb);
            pCacheBlock->cbEntry = UINT(pb - pbKey);
        }

        pCacheBlock->cbKeyOffset = UINT(pbLast - pidb->ab);

        return S_FALSE;
    }
    
    RonM_ASSERT(pb == pbLimit); // Verifying that cbSlack is correct.
    
    RonM_ASSERT(ValidBlockIndex(iChildLast)); // Because we don't keep empty 
                                              // internal empty nodes around.

    *piChild = iChildLast;

    pCacheBlock->cbKeyOffset = UINT(pbKey - pidb->ab);
    pCacheBlock->cbEntry     = UINT(pb    - pbKey);

    return S_FALSE;
}
    


HRESULT CPathManager1::CImpIPathManager::BinarySearch(
                        UINT	        uiStart,
                        UINT		    uiEnd,
						PBYTE			pauAccess,
						UINT			cbAccess,
						PTaggedPathInfo ptsi,
						PBYTE           ab,
						PBYTE			*ppbOut,
						BOOL			fSmall)
{
	TaggedPathInfo tsi;
    ZeroMemory(&tsi, sizeof(tsi));
	PBYTE pbKey;
	HRESULT hr = NO_ERROR;
	int icmp;
	ULONG offset;

#ifdef _DEBUG
    static int cLoop;  // BugBug! This will fail in multithreaded situations!
    cLoop++;
    RonM_ASSERT(cLoop < 100);
#endif

	if (uiStart == uiEnd)
	{
		if (uiEnd)
		{
			offset = fSmall ? *PUSHORT(pauAccess - uiEnd * cbAccess) 
							: *PUINT(pauAccess - uiEnd * cbAccess);
			*ppbOut = ab + offset;
		}
		else
			*ppbOut = ab;
		
		#ifdef _DEBUG
		cLoop = 0;
		#endif	
		
		return NO_ERROR;
	}
	else
    if (uiStart == (uiEnd -1))
	{
		#ifdef _DEBUG
		cLoop = 0;
		#endif	
		
		offset = fSmall ? *PUSHORT(pauAccess - uiEnd * cbAccess) 
						: *PUINT(pauAccess - uiEnd * cbAccess);
		pbKey = ab + offset;

		if (SUCCEEDED(hr = DecodePathKey((const BYTE **) &pbKey, tsi.SI.awszStreamPath, (UINT *) &tsi.SI.cwcStreamPath)))
		{
			icmp = wcsicmp_0x0409(ptsi->SI.awszStreamPath, tsi.SI.awszStreamPath);

			if (icmp >= 0)
			{
				*ppbOut = ab + offset;
			}
			else 
			{
				if (uiStart)
				{
					offset = fSmall ? *PUSHORT(pauAccess - uiStart * cbAccess) 
								    : *PUINT(pauAccess - uiStart * cbAccess);
					*ppbOut = ab + offset;
				}
				else
				{
					*ppbOut = ab;	
				}
			}
		}
		
		return hr;
	}
	
    UINT uiMid = (uiEnd + uiStart) / 2;

	offset = fSmall ? *PUSHORT(pauAccess - uiMid * cbAccess) 
					: *PUINT(pauAccess - uiMid * cbAccess);
	pbKey = ab + offset;

    if (SUCCEEDED(hr = DecodePathKey((const BYTE **) &pbKey, tsi.SI.awszStreamPath, (UINT *) &tsi.SI.cwcStreamPath)))
	{
	    icmp = wcsicmp_0x0409(ptsi->SI.awszStreamPath, tsi.SI.awszStreamPath);

		if (icmp < 0)
		{
			return BinarySearch(uiStart, uiMid - 1, pauAccess, cbAccess, 
								ptsi, ab, ppbOut, fSmall); 
		}
		else
		{
			return BinarySearch(uiMid, uiEnd, pauAccess, cbAccess, 
								ptsi, ab, ppbOut, fSmall); 
		}
	}
	return hr;
}

HRESULT CPathManager1::CImpIPathManager::ScanLeafForKey
         (PCacheBlock pCacheBlock, PTaggedPathInfo ptsi)
{
    RonM_ASSERT((pCacheBlock->fFlags & BlockTypeMask) == LeafBlock);
    
    PLeafNode pldb = &(pCacheBlock->ldb);
    
	UINT cEntries = 0;

     if (m_dbh.cbDirectoryBlock <= 0x10000 && pldb->nh.cbSlack >= sizeof(USHORT))
		cEntries = (UINT)(PUSHORT(PBYTE(pldb) + m_dbh.cbDirectoryBlock))[-1];
     else if (m_dbh.cbDirectoryBlock > 0x10000 && pldb->nh.cbSlack >= sizeof(UINT))
		cEntries = PUINT(PBYTE(pldb) + m_dbh.cbDirectoryBlock)[-1];
	 
	 pCacheBlock->cbEntry = 0; // For when the insertion point is at the end.

    TaggedPathInfo tsi;
	HRESULT hr;

    ZeroMemory(&tsi, sizeof(tsi));


	BOOL fSmall = m_dbh.cbDirectoryBlock <= 0x10000;
	PBYTE   pauAccess = PBYTE(pldb) + m_dbh.cbDirectoryBlock;
	pauAccess -= (fSmall ? sizeof(USHORT) : sizeof(UINT));
    
	PBYTE pb = pldb->ab;
	UINT  cSeqSearch = 0;
	UINT cChunkSize = (1 << m_dbh.cEntryAccessShift) + 1;

	//Binary search in search index array to get to the closed entry from where
	//sequential search can be started.
	if (cEntries > 0)
	{
		UINT cSearchVEntries = 0;
		
		if (cEntries > cChunkSize) 
		{
			cSearchVEntries = (cEntries - cChunkSize) / cChunkSize;
		
			cSearchVEntries += (((cEntries - cChunkSize) % cChunkSize) ? 1 : 0);
		}

		if (cSearchVEntries)
		{
			hr = BinarySearch(0, cSearchVEntries, pauAccess, 
				fSmall ?  sizeof(USHORT) : sizeof(UINT), ptsi, pldb->ab, &pb, fSmall); 
		}
	}

	//start sequential search from here
	RonM_ASSERT(pb      >= pldb->ab);
    PBYTE pbLimit = PBYTE(pldb) + m_dbh.cbDirectoryBlock - pldb->nh.cbSlack;

    for ( ; pb < pbLimit; )
    {
        cSeqSearch++;
		
		PBYTE pbKey = pb;

        HRESULT hr = DecodePathKey((const BYTE **) &pb, tsi.SI.awszStreamPath, (UINT *) &tsi.SI.cwcStreamPath);
        
        if (!SUCCEEDED(hr))
            return hr;

        int icmp = wcsicmp_0x0409(ptsi->SI.awszStreamPath, tsi.SI.awszStreamPath);

        if (icmp > 0)
        {
            pb = SkipKeyInfo(pb); 
			
			if (cEntries)
				RonM_ASSERT(cSeqSearch <= (cChunkSize + 1));
            continue;
        }
            
        if (icmp == 0)
        {
            // Found it!
            PBYTE pbInfo = pb;

            CopyMemory(ptsi->SI.awszStreamPath, tsi.SI.awszStreamPath, 
                       sizeof(WCHAR) * (tsi.SI.cwcStreamPath + 1)
                      );

            RonM_ASSERT(tsi.SI.cwcStreamPath == ptsi->SI.cwcStreamPath);
            
            HRESULT hr = DecodeKeyInfo((const BYTE **) &pb, &tsi.SI);
            
            if (!SUCCEEDED(hr)) return hr;

            pCacheBlock->cbEntry     = UINT(pb - pbKey);
            pCacheBlock->cbKeyOffset =
            tsi.cbEntryOffset   = UINT(pbKey - pldb->ab);
            tsi.cbEncoded       = UINT(pb - pbKey);
            tsi.iDirectoryBlock = pCacheBlock->iBlock;

            *ptsi = tsi;

            return S_OK;
        }

        // Found the place to insert key data

        pCacheBlock->cbEntry = UINT(SkipKeyInfo(pb) - pbKey); 

        pb = pbKey;

        break;
    }

    RonM_ASSERT(pb <= pbLimit); 

    pCacheBlock->cbEntry     = 0;
    pCacheBlock->cbKeyOffset =
    ptsi->cbEntryOffset      = UINT(pb - pldb->ab);
    ptsi->cbEncoded          = 0;
    ptsi->iDirectoryBlock    = pCacheBlock->iBlock;

    return S_FALSE;
}


HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::ForceClearDirty()
{
	m_fHeaderIsDirty   = FALSE;
    
	for (PCacheBlock pCB = m_pCBLeastRecent; pCB; pCB = pCB->pCBNext)
    {
        UINT fFlags = pCB->fFlags;

        if (pCB->fFlags & DirtyBlock)
        {    
			pCB->fFlags = ~(DirtyBlock | LockedBlock | ReadingIn | WritingOut); 
		}
    }
	return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::GetPathDB(IStreamITEx *pTempPDBStrm, BOOL fCompact)
{
	if (fCompact)
		return CompactPathDB(pTempPDBStrm);

	//copy m_plbPathDatabase to temp file
	STATSTG statstg;

    HRESULT hr;
	if (SUCCEEDED(hr = m_plbPathDatabase->Stat(&statstg, STATFLAG_NONAME)))
	{
		RonM_ASSERT(pTempPDBStrm != NULL);
		BYTE	lpBuf[2048];
		CULINT ullOffset(0);

		if (SUCCEEDED(hr = pTempPDBStrm->Seek(CLINT(0).Li(), STREAM_SEEK_SET, 0)))
		{
			ULONG		   cbToRead = sizeof(lpBuf);
			ULONG		   cbWritten;
			ULONG		   cbRead = cbToRead;
				
			while (SUCCEEDED(hr) && (cbRead == cbToRead))
			{
				if (SUCCEEDED(hr = m_plbPathDatabase->ReadAt((ullOffset).Uli(), lpBuf, cbToRead, &cbRead)))
				{
					if (SUCCEEDED(hr = pTempPDBStrm->Write(lpBuf, cbRead, &cbWritten)))
					{
						RonM_ASSERT(cbRead == cbWritten);
						ullOffset += cbWritten;						
					}//Write
				}//ReadAt
			}//while
		}//seek to the beggining of the stream
	}//get the size of copy operation
	return  hr;
}

UINT CPathManager1::CImpIPathManager::PredictNodeID(UINT iCurILev, 
													UINT iNodeNext, 
													SInternalNodeLev *rgINode,
													PBYTE pbKey,
													ULONG cbKey)
{
 /*
    
    This routine is called when we can't store an entry in a node within a tree level.
    It's result is a prediction of the node ID which will be assigned to the next node
    in that level. The way that we make that prediction is to traverse the current list
    of higher level nodes to see how many of them will need to be written out before 
    the target node.

    The key for the entry in question is denoted by pbKey and cbKey.

  */ 
    
    int		cChunkSize = (1 << m_dbh.cEntryAccessShift) + 1;
	int		cSearchVEntries = 0;;
	ULONG   cbTotal;
	PBYTE	pbNext, pbLimit;

    for (;iCurILev < 32; iCurILev++, iNodeNext++)
    {	
        // At each level we look to see if we have room enough to store
        // a reference to the new target node. If so, need go no further.
        // Otherwise we will need to create a new node at this level and
        // then look to see what will happen when that node is recorded
        // in the next level up.
        
        SInternalNodeLev *pLevelCurrent = rgINode + iCurILev;
        PInternalNode     pNodeCurrent  = pLevelCurrent->pINode;

        // When a level is empty we know that we will be able to create
        // a node here and store the key reference because we were able
        // to store it at the level below.

        if (!pNodeCurrent) return iNodeNext;
    
	    if (pLevelCurrent->cEntries > 0) // BugBug: Is this always true?
	    {
		    UINT cChunkSize = (1 << m_dbh.cEntryAccessShift)+ 1;
		    
		    if (pLevelCurrent->cEntries > cChunkSize) 
		    {
			    cSearchVEntries = (pLevelCurrent->cEntries - cChunkSize) / cChunkSize;
	    
			    cSearchVEntries += (((pLevelCurrent->cEntries - cChunkSize) % cChunkSize) ? 1 : 0);
		    }
	    }

        UINT cbBinSearchEntries = (m_dbh.cbDirectoryBlock <= 0x10000)? sizeof(USHORT) 
                                                                     : sizeof(UINT);

        pbLimit = PBYTE(pNodeCurrent) + m_dbh.cbDirectoryBlock 
                                      - cbBinSearchEntries * (cSearchVEntries + 1);
		    
	    pbNext = PBYTE(pNodeCurrent) + m_dbh.cbDirectoryBlock - pNodeCurrent->nh.cbSlack;

        BYTE abEncodedNodeId[5]; // Big enough to encode all 32-bit values.

	    PBYTE pb = abEncodedNodeId;

	    UINT cb = UINT(EncodeVL32(pb, iNodeNext) - pb);
	    
	    cbTotal = (cb + cbKey);
	    
	    if (pLevelCurrent->cEntries && !(pLevelCurrent->cEntries % cChunkSize))
		    cbTotal += cbBinSearchEntries;

	    if ((pbLimit - pbNext) >= cbTotal)
            return iNodeNext;
    }

    RonM_ASSERT(FALSE); // We only get here when we've exhausted through all 32 levels.

    return INVALID_INDEX;
}

HRESULT  CPathManager1::CImpIPathManager::UpdateHigherLev(IStreamITEx *pTempPDBStrm, 
														   UINT iCurILev, 
														   UINT *piNodeNext, 
														   SInternalNodeLev *rgINode,
														   PBYTE pbKey,
														   ULONG cbKey)
{
	RonM_ASSERT(iCurILev < 32);
    
    RonM_ASSERT((rgINode + iCurILev)->cEntries <= m_dbh.cbDirectoryBlock);

	PBYTE   pbNext, pbLimit;
	HRESULT hr = NO_ERROR;
	UINT	cChunkSize = (1 << m_dbh.cEntryAccessShift) + 1;
	int		cSearchVEntries = 0;
	BOOL	fAddSearchV = FALSE;
	UINT	cEntries = 0;
	ULONG   cbTotal;
//	static UINT cSearchV = 0; // BugBug: Doesn't work with more than one level of
                              //         internal nodes!

    SInternalNodeLev *pLevelCurrent = rgINode + iCurILev;
    PInternalNode     pNodeCurrent  = pLevelCurrent->pINode;

    BOOL fSmallBlk          = m_dbh.cbDirectoryBlock <= 0x10000;
    UINT cbBinsearchEntries = fSmallBlk? sizeof(USHORT) : sizeof(UINT);

    if (!pNodeCurrent)
	{
		pNodeCurrent = (PInternalNode) New BYTE[m_dbh.cbDirectoryBlock];

        if (pNodeCurrent) 
            pLevelCurrent->pINode = pNodeCurrent;
        else 
            return STG_E_INSUFFICIENTMEMORY;

		pNodeCurrent->nh.cbSlack = m_dbh.cbDirectoryBlock - sizeof(InternalNode);
		pNodeCurrent->nh.uiMagic = uiMagicInternal;
		pLevelCurrent->cEntries = 0;
			
		if (fSmallBlk)
			 PUSHORT(PBYTE(pNodeCurrent) + m_dbh.cbDirectoryBlock)[-1] = 0;
		else PUINT  (PBYTE(pNodeCurrent) + m_dbh.cbDirectoryBlock)[-1] = 0;
	}
 
	if (pLevelCurrent->cEntries > 0)
	{
		cChunkSize = (1 << m_dbh.cEntryAccessShift)+ 1;
		
		if (pLevelCurrent->cEntries > cChunkSize) 
		{
			cSearchVEntries = (pLevelCurrent->cEntries - cChunkSize) / cChunkSize;
	
			cSearchVEntries += (((pLevelCurrent->cEntries - cChunkSize) % cChunkSize) ? 1 : 0);
		}
	}
	
	pbLimit = PBYTE(pNodeCurrent) + m_dbh.cbDirectoryBlock 
                                  - cbBinsearchEntries * (cSearchVEntries + 1);

	pbNext  = PBYTE(pNodeCurrent) + m_dbh.cbDirectoryBlock 
                                  - pNodeCurrent->nh.cbSlack;

    BYTE abEncodedNodeId[5]; // Big enough to encode all 32-bit values.

	ULONG nodeId = *piNodeNext - 1;
	ULONG cb     =  UINT(EncodeVL32(abEncodedNodeId, nodeId) - abEncodedNodeId);

	cbTotal     = (cb + cbKey);
	fAddSearchV = FALSE;

	RonM_ASSERT(pbLimit >= pNodeCurrent->ab);

	if (pLevelCurrent->cEntries && !(pLevelCurrent->cEntries % cChunkSize))
	{
		cbTotal += cbBinsearchEntries;
		fAddSearchV = TRUE;
	}
					
	if ((pbLimit - pbNext) < cbTotal)
	{
		ULONG cbWritten;
		
		fAddSearchV = FALSE;

		//create new internal node at this level after writing the current one
		if (fSmallBlk)
			 PUSHORT((PBYTE)pNodeCurrent + m_dbh.cbDirectoryBlock)[-1] = (USHORT)pLevelCurrent->cEntries;
		else PUINT  ((PBYTE)pNodeCurrent + m_dbh.cbDirectoryBlock)[-1] =         pLevelCurrent->cEntries;
        
        hr = pTempPDBStrm->Write((PBYTE)pNodeCurrent, m_dbh.cbDirectoryBlock, &cbWritten);

        if (!SUCCEEDED(hr)) return hr;

        if (cbWritten != m_dbh.cbDirectoryBlock)
            return STG_E_WRITEFAULT;

//		RonM_ASSERT(cSearchV == (pLevelCurrent->cEntries/cChunkSize 
//					- 1 + ((pLevelCurrent->cEntries % cChunkSize) ? 1 : 0)));
		
//		cSearchV = 0;
		pLevelCurrent->cEntries = 0;
		
		pNodeCurrent->nh.cbSlack = m_dbh.cbDirectoryBlock - sizeof(InternalNode);

		pbNext = (PBYTE)pNodeCurrent + sizeof(InternalNode);

		pbLimit = (PBYTE)pNodeCurrent + m_dbh.cbDirectoryBlock - cbBinsearchEntries;

		if (fSmallBlk)
			 PUSHORT((PBYTE)pNodeCurrent + m_dbh.cbDirectoryBlock)[-1] = 0;
		else PUINT  ((PBYTE)pNodeCurrent + m_dbh.cbDirectoryBlock)[-1] = 0;
		
		(*piNodeNext)++;

		RonM_ASSERT(pLevelCurrent->cEntries <= m_dbh.cbDirectoryBlock);

		hr = UpdateHigherLev(pTempPDBStrm, iCurILev+1, piNodeNext, rgINode, 
			                 pNodeCurrent->ab, pLevelCurrent->cbFirstKey);

        if (!SUCCEEDED(hr)) return hr;

		RonM_ASSERT(pLevelCurrent->cEntries <= m_dbh.cbDirectoryBlock);
	}//if current block full
	
	pLevelCurrent->cEntries++;
	
	if (pNodeCurrent->nh.cbSlack == (m_dbh.cbDirectoryBlock - sizeof(InternalNode)))
		pLevelCurrent->cbFirstKey = cbKey;
		
	if (fAddSearchV)
	{
//		cSearchV++;

		if (fSmallBlk)
			 ((PUSHORT)pbLimit)[-1] = USHORT(pbNext - pNodeCurrent->ab);
		else ((PUINT  )pbLimit)[-1] = UINT(pbNext - pNodeCurrent->ab);
		
        pbLimit -= cbBinsearchEntries;
	}
	
	memCpy(pbNext, pbKey, cbKey);

#if 0//test code
	PathInfo PI;
	PBYTE pKey = pbNext;
	DecodePathKey((const BYTE **)&pKey, (unsigned short *)&PI.awszStreamPath, (unsigned int *)&PI.cwcStreamPath);
	wprintf(L"Lev= %d Adding to internal node key = %s\n", iCurILev, PI.awszStreamPath);
#endif//end test code

	pbNext += cbKey;

	memCpy(pbNext, abEncodedNodeId, cb);

	pbNext += cb;

	pNodeCurrent->nh.cbSlack -= (cb + cbKey);

	RonM_ASSERT(pNodeCurrent->nh.cbSlack < m_dbh.cbDirectoryBlock);
	RonM_ASSERT(pLevelCurrent->cEntries <= m_dbh.cbDirectoryBlock);

	return S_OK;
}


HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::CompactPathDB(IStreamITEx *pTempPDBStrm)
{
	BYTE    abEntry[CB_STREAM_INFO_MAX];
	PBYTE   pb;
	UINT    cb;
	PBYTE   pbLimit;
	PBYTE   pbNext;
	ULONG   cbWritten;
	UINT	iNextNodeId = 0; // Next available node block index.
	ULONG	cbPathKey, cbFirstKey;
	int		cnt = 0;
	BOOL	fAddSearchV = FALSE;
	UINT	cEntries = 0;
	ULONG   cbTotal;
	DatabaseHeader	 dbh;
	SInternalNodeLev rgINodeLev[32];
	SInternalNodeLev *rgINode = rgINodeLev;
	UINT     cSearchV = 0;
	UINT	 cChunkSize = (1 << m_dbh.cEntryAccessShift)+ 1;
	PLeafNode plNode = NULL;
	ULONG    celtFetched = 1;
	PathInfo pathInfo;

    BOOL fSmallBlk = m_dbh.cbDirectoryBlock <= 0x10000;

    UINT cbBinSearchEntries = fSmallBlk? sizeof(USHORT) : sizeof(UINT);
 	
	ZeroMemory(rgINodeLev, 32 * sizeof(SInternalNodeLev));

	IITEnumSTATSTG *pEnumPathMgr = NULL;

    HRESULT hr = EnumFromObject(NULL, L"//", 1, IID_IEnumSTATSTG, (PVOID *) &pEnumPathMgr);

    if (!SUCCEEDED(hr)) goto exit_CompactPathDB;
   
    hr = pEnumPathMgr->GetFirstEntryInSeq(&pathInfo);
	
    if (!SUCCEEDED(hr)) goto exit_CompactPathDB;

	plNode = (PLeafNode)New BYTE[m_dbh.cbDirectoryBlock];
 
	if (!plNode)
    {
        hr = STG_E_INSUFFICIENTMEMORY;
        goto exit_CompactPathDB;
    }

	//reserve space for the header

	CopyMemory(&dbh, &m_dbh, sizeof(DatabaseHeader));
	
	dbh.iRootDirectory  = INVALID_INDEX;
    dbh.iLeafLast       = INVALID_INDEX;
    dbh.iLeafFirst      = INVALID_INDEX;
    dbh.iBlockFirstFree = INVALID_INDEX;
    dbh.cBlocks         = 0;

    hr = pTempPDBStrm->Write(&dbh, sizeof(m_dbh), &cbWritten);

    RonM_ASSERT(cbWritten == sizeof(dbh));
 
    plNode->nh.cbSlack        = m_dbh.cbDirectoryBlock - sizeof(LeafNode);
    plNode->nh.uiMagic        = uiMagicLeaf;
    plNode->lcl.iLeafPrevious = INVALID_INDEX;
    plNode->lcl.iLeafNext     = INVALID_INDEX;
    plNode->lcl.iLeafSerial   = 0;

	pbLimit = (PBYTE)plNode + m_dbh.cbDirectoryBlock - cbBinSearchEntries;

	if (fSmallBlk)
         PUSHORT(PBYTE(plNode) + m_dbh.cbDirectoryBlock)[-1] = 0;
    else PUINT  (PBYTE(plNode) + m_dbh.cbDirectoryBlock)[-1] = 0;
	
	pbNext = PBYTE(plNode) + sizeof(LeafNode);
    
	cnt++;
	cEntries++;

    pb         = EncodePathKey(abEntry, pathInfo.awszStreamPath, pathInfo.cwcStreamPath);
	cbFirstKey = cbPathKey = ULONG(pb - abEntry);
	 
	pb = EncodeKeyInfo(pb, &pathInfo);
	cb = UINT(pb - abEntry);
	//pb = EncodePathInfo(abEntry, &pathInfo);
	 
	if ((pbLimit - pbNext) >= cb)
	{
		CopyMemory(pbNext, abEntry, cb);
#if 0
		//************* test code ******************
		PathInfo SI;
		cnt = 0;
		PBYTE pbKey = pbNext;
		hr = DecodePathInfo((const BYTE **) &pbKey, &SI);
		wprintf(L"key %d = %s\n", cnt, SI.awszStreamPath);
		//************* end test code **************
#endif
		pbNext += cb;
		plNode->nh.cbSlack = UINT((PBYTE)plNode + m_dbh.cbDirectoryBlock - pbNext);
	}
    else
    {
        hr = E_FAIL;
        goto exit_CompactPathDB;
    }

	for (;;)
	{
		celtFetched = 1;

        hr = pEnumPathMgr->GetNextEntryInSeq(1, &pathInfo, &celtFetched);

        if (!SUCCEEDED(hr)) goto exit_CompactPathDB;

        if (hr == S_FALSE) break;

        RonM_ASSERT(celtFetched == 1);
        
		cnt++;
		pb = EncodePathKey(abEntry, pathInfo.awszStreamPath, pathInfo.cwcStreamPath);
		cbPathKey = ULONG(pb - abEntry);
 
		pb = EncodeKeyInfo(pb, &pathInfo);
		cb = UINT(pb - abEntry);
 
		cbTotal = cb;
		fAddSearchV = FALSE;

		if ((cEntries % cChunkSize) == 0)
		{
			cbTotal += cbBinSearchEntries;
			fAddSearchV = TRUE;
		}
	
		if ((pbLimit - pbNext) < cbTotal)
		{
			fAddSearchV = FALSE;

            UINT iCurrentLeafId = iNextNodeId++;
			
            plNode->lcl.iLeafNext = PredictNodeID
                                        (0, iNextNodeId, rgINode, plNode->ab, cbFirstKey);

			RonM_ASSERT((pbLimit >= plNode->ab) && (pbLimit < ((PBYTE)plNode + m_dbh.cbDirectoryBlock)) );
		
			if (fSmallBlk)
				 PUSHORT(PBYTE(plNode) + m_dbh.cbDirectoryBlock)[-1] = (USHORT)cEntries;
			else PUINT  (PBYTE(plNode) + m_dbh.cbDirectoryBlock)[-1] = cEntries;
			
			hr = pTempPDBStrm->Write((PBYTE)plNode, m_dbh.cbDirectoryBlock, &cbWritten);

            if (!SUCCEEDED(hr)) goto exit_CompactPathDB;

			RonM_ASSERT(cSearchV == (cEntries/cChunkSize - 1 + ((cEntries % cChunkSize) ? 1 : 0)));
			
			cSearchV = 0;

			RonM_ASSERT(cbWritten == m_dbh.cbDirectoryBlock);

			plNode->lcl.iLeafPrevious = iCurrentLeafId;
			plNode->lcl.iLeafSerial   = 0;
			plNode->lcl.iLeafNext     = INVALID_INDEX;

			pbNext  = PBYTE(plNode) + sizeof(LeafNode);
			plNode->nh.cbSlack =  UINT((PBYTE)plNode + m_dbh.cbDirectoryBlock - pbNext);

			cEntries = 0;

			pbLimit = (PBYTE)plNode + m_dbh.cbDirectoryBlock - cbBinSearchEntries;

			if (fSmallBlk)
				 PUSHORT(PBYTE(plNode) + m_dbh.cbDirectoryBlock)[-1] = 0;
			else PUINT  (PBYTE(plNode) + m_dbh.cbDirectoryBlock)[-1] = 0;
			
			RonM_ASSERT((pbLimit >= plNode->ab) && (pbLimit < ((PBYTE)plNode + m_dbh.cbDirectoryBlock)) );
	
			hr = UpdateHigherLev(pTempPDBStrm, 0, &iNextNodeId, rgINode, plNode->ab, cbFirstKey);

			RonM_ASSERT((pbLimit >= plNode->ab) && (pbLimit < ((PBYTE)plNode + m_dbh.cbDirectoryBlock)) );
		}//if current block full

							
		cEntries++;
		
		if (pbNext  == (PBYTE(plNode) + sizeof(LeafNode)))
			cbFirstKey = cbPathKey;
			
		if (fAddSearchV)
		{
			cSearchV++;
			if (fSmallBlk)
				 ((PUSHORT)pbLimit)[-1] = USHORT(pbNext - plNode->ab);
			else ((PUINT  )pbLimit)[-1] = UINT(pbNext - plNode->ab);

			pbLimit -= cbBinSearchEntries;
		}
		
		RonM_ASSERT((pbLimit >= plNode->ab) && (pbLimit < ((PBYTE)plNode + m_dbh.cbDirectoryBlock)) );
		
		memCpy(pbNext, abEntry, cb);
#if 0
		//************* test code ******************
		PathInfo SI;
		cnt++;
		PBYTE pbKey = pbNext;
		hr = DecodePathInfo((const BYTE **) &pbKey, &SI);
		wprintf(L"key %d = %s\n", cnt, SI.awszStreamPath);
		//************* end test code **************
#endif
		pbNext += cb;
							
		plNode->nh.cbSlack -= cb;
	}//while
	
	//write last leaf node

	if (pbNext == (PBYTE(plNode) + sizeof(LeafNode)))
    {
        // This condition should never happen because we always start with at least
        // an entry for the path "/", and we never start a new leaf unless we have
        // a path which would not fit in the previous leaf node.

        RonM_ASSERT(FALSE);
        
        hr = E_FAIL;
        goto exit_CompactPathDB;
    }

    RonM_ASSERT(plNode->lcl.iLeafNext == INVALID_INDEX);
	
	if (fSmallBlk)
		 PUSHORT(PBYTE(plNode) + m_dbh.cbDirectoryBlock)[-1] = (USHORT)cEntries;
	else PUINT  (PBYTE(plNode) + m_dbh.cbDirectoryBlock)[-1] = cEntries;

	hr = pTempPDBStrm->Write((PBYTE)plNode, m_dbh.cbDirectoryBlock, &cbWritten);

    if (!SUCCEEDED(hr)) goto exit_CompactPathDB;

    if (cbWritten != m_dbh.cbDirectoryBlock)
    {
        hr = STG_E_WRITEFAULT;

        goto exit_CompactPathDB;
    }

	RonM_ASSERT(cbWritten == m_dbh.cbDirectoryBlock);
							
	RonM_ASSERT(cSearchV == (cEntries/cChunkSize - 1 + ((cEntries % cChunkSize) ? 1 : 0)));
	
	dbh.iLeafLast = iNextNodeId++; // To account for the last leaf.

    if (plNode->lcl.iLeafPrevious == INVALID_INDEX) // Do we have any internal nodes?
    {
        dbh.cDirectoryLevels = 1;
        dbh.cBlocks          = 1;

        RonM_ASSERT(dbh.iRootDirectory == INVALID_INDEX);
    }
    else
    {
        hr = UpdateHigherLev(pTempPDBStrm, 0, &iNextNodeId, rgINode, plNode->ab, cbFirstKey);

        if (!SUCCEEDED(hr)) goto exit_CompactPathDB;

	    //write all unwritten internal nodes
	    SInternalNodeLev *ppINode = &rgINodeLev[0];

	    int iLev = 0;

	    for (; ppINode->pINode != NULL; ppINode++, iLev++)
	    {
		    RonM_ASSERT((ppINode->pINode)->nh.cbSlack < (m_dbh.cbDirectoryBlock - sizeof(InternalNode)));

            // The above assertion is true because we only create a node level when we
            // need to put a path entry into it.

            if (fSmallBlk)
				 PUSHORT(PBYTE(ppINode->pINode) + m_dbh.cbDirectoryBlock)[-1] = USHORT(ppINode->cEntries);
			else PUINT  (PBYTE(ppINode->pINode) + m_dbh.cbDirectoryBlock)[-1] =        ppINode->cEntries;

			hr = pTempPDBStrm->Write((PBYTE)(ppINode->pINode), 
                                     m_dbh.cbDirectoryBlock, 
                                     &cbWritten
                                    );

            if (!SUCCEEDED(hr)) goto exit_CompactPathDB;

            if (cbWritten != m_dbh.cbDirectoryBlock) 
            {
                hr = STG_E_WRITEFAULT;
                goto exit_CompactPathDB;
            }

			//printf("Last most I nodeid = %d   cEntries = %d\n", iNextNodeId, ppINode->cEntries);
			
			iNextNodeId++; // To account for this internal node
		
			if (rgINodeLev[iLev + 1].pINode == NULL)
				dbh.iRootDirectory = iNextNodeId - 1;
            else
				hr = UpdateHigherLev(pTempPDBStrm, iLev+1, &iNextNodeId, rgINode, 
                                     ppINode->pINode->ab, ppINode->cbFirstKey
                                    );

		    delete ppINode->pINode;
            ppINode->pINode = NULL;
	    }
        
        dbh.cDirectoryLevels = iLev + 1;
        dbh.cBlocks          = iNextNodeId;
    }
	
	hr = pTempPDBStrm->Seek(CLINT(0).Li(), STREAM_SEEK_SET, 0);

    if (!SUCCEEDED(hr)) goto exit_CompactPathDB;
    
    //update the header again with correct last leaf node

    dbh.iLeafFirst = 0;

    RonM_ASSERT(dbh.iLeafLast       != INVALID_INDEX);
    RonM_ASSERT(dbh.iBlockFirstFree == INVALID_INDEX);
    RonM_ASSERT(   (dbh.cDirectoryLevels == 1 && dbh.cBlocks        == 1 
                                              && dbh.iLeafLast      == 0 
                                              && dbh.iRootDirectory == INVALID_INDEX
                   )
                || (dbh.cDirectoryLevels > 1 && dbh.cBlocks         > 2
                                             && dbh.iLeafLast      != 0
                                             && dbh.iRootDirectory != INVALID_INDEX
                   )
               );

	hr = pTempPDBStrm->Write(&dbh, sizeof(dbh), &cbWritten);

    if (SUCCEEDED(hr) && cbWritten != sizeof(dbh))
        hr = STG_E_WRITEFAULT;

exit_CompactPathDB:

    for (UINT iLevel = 32; iLevel--; )
    {
        PInternalNode pNode = rgINodeLev[iLevel].pINode;

        RonM_ASSERT(!SUCCEEDED(hr) || !pNode);  // Should not have any left over nodes
                                                // if everything work correctly.

        if (pNode) { delete pNode;  rgINodeLev[iLevel].pINode = NULL; }
    }

    if (plNode      ) { delete plNode; plNode = NULL; }
    if (pEnumPathMgr) pEnumPathMgr->Release();

    return hr;
}


HRESULT CPathManager1::CImpIPathManager::CEnumPathMgr1::NewPathEnumeratorObject
            (IUnknown *punkOuter, CImpIPathManager *pPM, 
             const WCHAR *pwszPathPrefix,
             UINT cwcPathPrefix,
			 REFIID riid,
             PVOID *ppv
            )
{ if (punkOuter && riid != IID_IUnknown)
		return CLASS_E_NOAGGREGATION;
	
	CEnumPathMgr1 *pEPM1 = New CEnumPathMgr1(punkOuter);

    if (!pEPM1)
    {
        pPM->Release();

        return STG_E_INSUFFICIENTMEMORY;
    }
   

    HRESULT hr = pEPM1->m_ImpEnumSTATSTG.InitPathEnumerator
                     (pPM, pwszPathPrefix, cwcPathPrefix);

	if (hr == S_OK)
		hr = pEPM1->QueryInterface(riid, ppv);

    if (hr != S_OK)
        delete pEPM1;

	return hr;
}


HRESULT CPathManager1::CImpIPathManager::CEnumPathMgr1::NewPathEnumerator
            (IUnknown *punkOuter, CImpIPathManager *pPM, 
             const WCHAR *pwszPathPrefix,
             UINT cwcPathPrefix,
             IEnumSTATSTG **ppEnumSTATSTG
            )
{
    CEnumPathMgr1 *pEPM1 = New CEnumPathMgr1(punkOuter);

    return FinishSetup(pEPM1? pEPM1->m_ImpEnumSTATSTG.InitPathEnumerator
                                  (pPM, pwszPathPrefix, cwcPathPrefix)
                            : STG_E_INSUFFICIENTMEMORY,
                       pEPM1, IID_IEnumSTATSTG, (PPVOID) ppEnumSTATSTG
                      );
}

CPathManager1::CImpIPathManager::CEnumPathMgr1::CImpIEnumSTATSTG::CImpIEnumSTATSTG
    (CITUnknown *pBackObj, IUnknown *punkOuter) : IITEnumSTATSTG(pBackObj, punkOuter)
{
    m_pPM               = NULL;
    m_iLeafBlock        = INVALID_INDEX;
    m_cbOffsetLastEntry = 0;
    m_cbLastEntry       = 0;
    m_iSerialNode       = 0;
    m_iSerialDatabase   = 0;
    m_cwcPathPrefix     = 0;
    m_pwszPathPrefix[0] = 0;
}

CPathManager1::CImpIPathManager::CEnumPathMgr1::CImpIEnumSTATSTG::~CImpIEnumSTATSTG()
{
    if (m_pPM)
        m_pPM->Release();
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::CEnumPathMgr1
                                       ::CImpIEnumSTATSTG::InitPathEnumerator
                              (CImpIPathManager *pPM, 
                               const WCHAR *pwszPathPrefix,
                               UINT cwcPathPrefix
                              )
{
    m_pPM = pPM;

    if (cwcPathPrefix >= MAX_PATH)
        return STG_E_INVALIDPARAMETER;

    m_cwcPathPrefix = cwcPathPrefix;

    CopyMemory(m_pwszPathPrefix, pwszPathPrefix, sizeof(WCHAR) * cwcPathPrefix);

    m_pwszPathPrefix[cwcPathPrefix] = 0;

    return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::CEnumPathMgr1
                                       ::CImpIEnumSTATSTG::FindEntry()
{
    HRESULT hr = NO_ERROR;

    TaggedPathInfo tsi;

    tsi.SI = m_SI;

    PCacheBlock *papCBSet 
        = (PCacheBlock *) _alloca(sizeof(PCacheBlock) * m_pPM->m_dbh.cDirectoryLevels);
    
    hr = m_pPM->FindKeyAndLockBlockSet(&tsi, papCBSet, 0);
                 
    m_pPM->ClearLockFlags(papCBSet);

    PCacheBlock pCBLeaf = papCBSet[0];

    if (SUCCEEDED(hr))
    {
        if (hr == S_FALSE)
            pCBLeaf->cbEntry = 0;
        
        m_SI                = tsi.SI;
        m_iLeafBlock        = pCBLeaf->iBlock;
        m_cbOffsetLastEntry = pCBLeaf->cbKeyOffset;
        m_cbLastEntry       = pCBLeaf->cbEntry;
        m_iSerialNode       = pCBLeaf->ldb.lcl.iLeafSerial;
        m_iSerialDatabase   = m_pPM->m_PathSetSerial;
    }

    return hr;     
}



HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::CEnumPathMgr1
                                       ::CImpIEnumSTATSTG::GetNextEntryInSeq
                              (ULONG celt, PathInfo *rgelt, ULONG *pceltFetched)
{
    ULONG celtFetched = 0;

    HRESULT hr = NO_ERROR;

    CSyncWith sw(m_pPM->m_cs);

	//readjust enumerator index in case last entry it has seen has
	// changed.
    PCacheBlock pCBLeaf = NULL;
    if (SUCCEEDED(hr = m_pPM->FindCacheBlock(&pCBLeaf, m_iLeafBlock)))
	{
		PBYTE pbKey = pCBLeaf->ldb.ab + m_cbOffsetLastEntry;
		PathInfo SI;
		if (SUCCEEDED(hr = m_pPM->DecodePathInfo((const BYTE **) &pbKey, &SI)))
    		m_cbLastEntry       = UINT(pbKey - (pCBLeaf->ldb.ab + m_cbOffsetLastEntry));
	}

	for (; celt--; rgelt++)
    {
        hr = NextEntry();
        
        if (hr == S_FALSE || !SUCCEEDED(hr))
            break;

		memCpy(rgelt, &m_SI, sizeof(PathInfo));
        celtFetched++;
    }

    if (pceltFetched)
        *pceltFetched = celtFetched;

    return hr;
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::CEnumPathMgr1
                                       ::CImpIEnumSTATSTG::GetFirstEntryInSeq
                              (PathInfo *rgelt)
{
	HRESULT hr = NO_ERROR;

    CSyncWith sw(m_pPM->m_cs);
	
	PCacheBlock pCBLeaf = NULL;
    
    if (!SUCCEEDED(hr = m_pPM->FindCacheBlock(&pCBLeaf, m_pPM->m_dbh.iLeafFirst)))
        return hr;
    
    PBYTE pbEntry = pCBLeaf->ldb.ab;
	PathInfo SI;
	PBYTE pbKey = pbEntry;

    hr = m_pPM->DecodePathInfo((const BYTE **) &pbEntry, &SI);

    if (SUCCEEDED(hr))
    {
        m_SI = SI;

        m_cbOffsetLastEntry = UINT(pbKey   - pCBLeaf->ldb.ab);
        m_cbLastEntry       = UINT(pbEntry - pbKey);
        m_iLeafBlock        = m_pPM->m_dbh.iLeafFirst;
        m_iSerialNode       = pCBLeaf->ldb.lcl.iLeafSerial;
    
        memCpy(rgelt, &m_SI, sizeof(PathInfo));
	}
    
	return hr;
}


HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::CEnumPathMgr1
                                       ::CImpIEnumSTATSTG::NextEntry()
{
    if (m_iSerialDatabase == 0) // Initial call?
    {
        CopyMemory(m_SI.awszStreamPath, m_pwszPathPrefix, 
                   sizeof(WCHAR) * (m_cwcPathPrefix + 1)
                  );

        m_SI.cwcStreamPath = m_cwcPathPrefix;

        HRESULT hr = FindEntry();
 
        if (!SUCCEEDED(hr)) 
            return hr;

		RonM_ASSERT(m_cwcPathPrefix > 0);

		// If the prefix ends with '/', we're enumerating a storage
		// and should skip over any exact match. Otherwise we don't skip
		// anything. This behavior is necessary for IStorage::DestroyElement
		// to work correctly.

		if (m_pwszPathPrefix[m_cwcPathPrefix-1] != L'/')
			m_cbLastEntry = 0;
   }
    
    if (m_iSerialDatabase != m_pPM->m_PathSetSerial)
    {
        // Database has deleted a leaf node. So m_iLeafBlock may be invalid.

        HRESULT hr = FindEntry();
    }
    
    PCacheBlock pCBLeaf = NULL;
    
    HRESULT hr = m_pPM->FindCacheBlock(&pCBLeaf, m_iLeafBlock);

    if (!SUCCEEDED(hr))
        return hr;
    
    if (m_iSerialNode != pCBLeaf->ldb.lcl.iLeafSerial)
    {
        // Node content has changed in a way that invalidated either
        // m_cbOffsetLastEntry or m_cbLastEntry.

        hr = FindEntry();

        if (!SUCCEEDED(hr))
            return hr;
    }
    
    RonM_ASSERT(m_pPM->m_PathSetSerial == m_iSerialDatabase);

    UINT iLeafBlock = m_iLeafBlock;

    hr = m_pPM->FindCacheBlock(&pCBLeaf, m_iLeafBlock);

    if (!SUCCEEDED(hr))
        return hr;
    
    RonM_ASSERT(pCBLeaf->ldb.nh.uiMagic      == uiMagicLeaf);
    RonM_ASSERT(pCBLeaf->ldb.lcl.iLeafSerial == m_iSerialNode);

    PBYTE pbLimit = PBYTE(&pCBLeaf->ldb) + m_pPM->m_dbh.cbDirectoryBlock 
                                         - pCBLeaf->ldb.nh.cbSlack;
    PBYTE pbEntry = pCBLeaf->ldb.ab + m_cbOffsetLastEntry + m_cbLastEntry;

    RonM_ASSERT(pbEntry <= pbLimit);

    if (pbEntry == pbLimit) // Are we at the end of this leaf node?
    {
        UINT iNodeNext = pCBLeaf->ldb.lcl.iLeafNext;

        if (m_pPM->ValidBlockIndex(iNodeNext))
        {
            HRESULT hr = m_pPM->FindCacheBlock(&pCBLeaf, iNodeNext);

            if (!SUCCEEDED(hr))
                return hr;

            RonM_ASSERT(pCBLeaf->ldb.nh.uiMagic == uiMagicLeaf);

            // Note that we defer changing m_iLeafBlock until the decode stream operation
            // succeeds. That is, we don't change our state if we fail anywhere.
            
            iLeafBlock = iNodeNext;

            pbLimit = PBYTE(&pCBLeaf->ldb) + m_pPM->m_dbh.cbDirectoryBlock 
                                           - pCBLeaf->ldb.nh.cbSlack;
            pbEntry = pCBLeaf->ldb.ab;

            RonM_ASSERT(pbEntry < pbLimit); // We don't keep empty leaf nodes around.
        }
        else return S_FALSE; // We've gone through all the leaf entries.
    }

    PBYTE pbKey = pbEntry;

    PathInfo SI;

    hr = m_pPM->DecodePathInfo((const BYTE **) &pbEntry, &SI);

    if (SUCCEEDED(hr))
    {
        m_SI = SI;

        m_cbOffsetLastEntry = UINT(pbKey   - pCBLeaf->ldb.ab);
        m_cbLastEntry       = UINT(pbEntry - pbKey);
        m_iLeafBlock        = iLeafBlock;
        m_iSerialNode       = pCBLeaf->ldb.lcl.iLeafSerial;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::CEnumPathMgr1
                                       ::CImpIEnumSTATSTG::Next
                              (ULONG celt, STATSTG __RPC_FAR *rgelt,
                               ULONG __RPC_FAR *pceltFetched
                              )
{
    ULONG celtFetched = 0;

    HRESULT hr = NO_ERROR;

    CSyncWith sw(m_pPM->m_cs);

    for (; celt--; rgelt++)
    {
        hr = NextEntry();
        
        if (hr == S_FALSE || !SUCCEEDED(hr))
            break;

        rgelt->pwcsName= PWCHAR(OLEHeap()->Alloc((m_SI.cwcStreamPath+1) * sizeof(WCHAR)));

        if (!(rgelt->pwcsName))
        {
            hr = STG_E_INSUFFICIENTMEMORY;

            break;
        }

        CopyMemory(rgelt->pwcsName, m_SI.awszStreamPath, 
                   sizeof(WCHAR) * (m_SI.cwcStreamPath+1)
                  );

        if (m_SI.awszStreamPath[m_SI.cwcStreamPath - 1] == L'/') // Is this a storage?
        {
            rgelt->type = STGTY_STORAGE;

            ULARGE_INTEGER *puli = (ULARGE_INTEGER *) &(rgelt->clsid);

            puli[0] = m_SI.ullcbOffset.Uli();
            puli[1] = m_SI.ullcbData  .Uli();

            rgelt->grfStateBits      = m_SI.uStateBits;  
            rgelt->grfLocksSupported = 0;  // We don't support locking with storages.
        }
        else
        {
            rgelt->type              = STGTY_STREAM;
            rgelt->cbSize            = m_SI.ullcbData.Uli();
            rgelt->grfStateBits      = 0;             // Not meaningful for streams
            rgelt->grfLocksSupported = LOCK_EXCLUSIVE;
        }

        rgelt->grfMode  = 0; // Not meaningful in an enumeration result.
        rgelt->reserved = 0; // All reserved fields must be zero.
#if 0
        rgelt->mtime    = m_pPM->m_ftLastModified;  // Need to add these member
        rgelt->ctime    = m_pPM->m_ftCreation;      // variables to path manager!!!
        rgelt->atime    = m_pPM->m_ftLastAccess;
#else // 0
        rgelt->mtime.dwLowDateTime  = 0; 
        rgelt->mtime.dwHighDateTime = 0; 
        rgelt->ctime.dwLowDateTime  = 0; 
        rgelt->ctime.dwHighDateTime = 0; 
        rgelt->atime.dwLowDateTime  = 0; 
        rgelt->atime.dwHighDateTime = 0; 
#endif // 0
        celtFetched++;
    }

    if (pceltFetched)
        *pceltFetched = celtFetched;

    return hr;
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::CEnumPathMgr1
                                       ::CImpIEnumSTATSTG::Skip(ULONG celt)
{
    HRESULT hr = NO_ERROR;

    CSyncWith sw(m_pPM->m_cs);

    for (; celt--; )
    {
        hr= NextEntry();
        
        if (hr == S_FALSE || !SUCCEEDED(hr))
            break;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::CEnumPathMgr1
                                       ::CImpIEnumSTATSTG::Reset(void)
{
    CSyncWith sw(m_pPM->m_cs);

    m_iSerialDatabase = 0;

    return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CPathManager1::CImpIPathManager::CEnumPathMgr1
                                       ::CImpIEnumSTATSTG::Clone
                              (IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum)
{
    CImpIEnumSTATSTG *pEnumSTATSTG = NULL;

    CSyncWith sw(m_pPM->m_cs);

    HRESULT hr = m_pPM->EnumFromObject(NULL, (const WCHAR *) m_pwszPathPrefix, 
                                             m_cwcPathPrefix,
                                             IID_IEnumSTATSTG,
                                             (PVOID *) &pEnumSTATSTG
                                      );
    
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    pEnumSTATSTG->m_SI                = m_SI;
    pEnumSTATSTG->m_iLeafBlock        = m_iLeafBlock;
    pEnumSTATSTG->m_cbOffsetLastEntry = m_cbOffsetLastEntry;
    pEnumSTATSTG->m_cbLastEntry       = m_cbLastEntry;
    pEnumSTATSTG->m_iSerialNode       = m_iSerialNode;
    pEnumSTATSTG->m_iSerialDatabase   = m_iSerialDatabase;

    *ppenum = (IEnumSTATSTG *) pEnumSTATSTG;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ITSS.rc
//
#define IDI_ICON_ITS                    1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\protocol.cpp ===
// Protocol.cpp -- Implementation for class CIOITnetProtocol

#include "StdAfx.h"

// Creation:

HRESULT CIOITnetProtocol::Create
    (IUnknown *punkOuter, REFIID riid, PPVOID ppv)
{
    CIOITnetProtocol *pNP = New CIOITnetProtocol(punkOuter);

    return FinishSetup(pNP? pNP->m_ImpIOITnetProtocol.Init()
                          : STG_E_INSUFFICIENTMEMORY,
                       pNP, riid, (PPVOID) ppv
                      );
}

// Constructor and Destructor:

CIOITnetProtocol::CImpIOITnetProtocol::CImpIOITnetProtocol
    (CIOITnetProtocol *pBackObj, IUnknown *pUnkOuter)
    : IOITnetProtocol(pBackObj, pUnkOuter) ,
      IOITnetProtocolInfo(pBackObj, pUnkOuter)
{
    m_grfSTI           = 0;
    m_grfBINDF         = 0;
    m_szTempPath[0]    = 0;

    ZeroMemory(&m_BindInfo, sizeof(m_BindInfo));

    m_pwcsURL        = NULL;
    m_pcsDisplayName = NULL;
    m_pOIProtSink    = NULL;
    m_pOIBindInfo    = NULL;
    m_pStream        = NULL;
}

CIOITnetProtocol::CImpIOITnetProtocol::~CImpIOITnetProtocol(void)
{
    if (m_pcsDisplayName)
    {
        UnlockUrlCacheEntryFile(m_pcsDisplayName, 0);

        delete [] m_pcsDisplayName;
    }
    
    if (m_pwcsURL)
        delete [] m_pwcsURL;
    
    if (m_pOIProtSink) 
        m_pOIProtSink->Release();

    if (m_pOIBindInfo)
        m_pOIBindInfo->Release();

    if (m_pStream)
        m_pStream->Release();

    if (m_szTempPath[0])
        DeleteFile(m_szTempPath);
}

// Initialing routine:

HRESULT CIOITnetProtocol::CImpIOITnetProtocol::Init()
{
    return NO_ERROR; 
}


// IOITnetProtocolRoot interfaces:

void STDMETHODCALLTYPE MapSurrogateCharacters
    (PWCHAR pwcsBuffer)
{
    PWCHAR pwcsDest = pwcsBuffer;

    for (;;)
    {
        WCHAR wc = *pwcsBuffer++;
        
        *pwcsDest++ = wc;

        if (!wc) break;

        if (wc == L'%' && pwcsBuffer[0] && pwcsBuffer[1])
        {
            WCHAR wcSurrogate = 0;
            WCHAR wcFirst  = pwcsBuffer[0];
            WCHAR wcSecond = pwcsBuffer[1];
            
            if (wcFirst >= L'0' && wcFirst <= L'9') 
                wcSurrogate = wcFirst - L'0';
            else
                if (wcFirst >= L'A' && wcFirst <= L'F')
                    wcSurrogate = 10 + wcFirst - L'A';
                else
                    if (wcFirst >= L'a' && wcFirst <= L'f')
                        wcSurrogate = 10 + wcFirst - L'a';
                    else continue;

            wcSurrogate <<= 4;

            if (wcSecond >= L'0' && wcSecond <= L'9') 
                wcSurrogate |= wcSecond - L'0';
            else
                if (wcSecond >= L'A' && wcSecond <= L'F')
                    wcSurrogate |= 10 + wcSecond - L'A';
                else
                    if (wcSecond >= L'a' && wcSecond <= L'f')
                        wcSurrogate |= 10 + wcSecond - L'a';
                    else continue;

            pwcsDest[-1] = wcSurrogate;
            pwcsBuffer  += 2;
        }
    }
}


HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::Start
    ( 
	/* [in] */ LPCWSTR szUrl,
	/* [in] */ IOInetProtocolSink __RPC_FAR *pOIProtSink,
	/* [in] */ IOInetBindInfo __RPC_FAR *pOIBindInfo,
	/* [in] */ DWORD grfSTI,
	/* [in] */ DWORD dwReserved
    )
{
    DWORD cwc  = wcsLen(szUrl);

    PWCHAR pwcsBuffer = PWCHAR(_alloca((cwc + 1) * sizeof(WCHAR)));

    if (!pwcsBuffer) return E_OUTOFMEMORY;

    CopyMemory(pwcsBuffer, szUrl, sizeof(WCHAR) * (cwc + 1));

    PWCHAR pwcsExternalPath = NULL;
    PWCHAR pwcsInternalPath = NULL;

    HRESULT hr = DisectUrl(pwcsBuffer, NULL, &pwcsExternalPath, &pwcsInternalPath);
    
    if (!SUCCEEDED(hr)) 
    {
        if (hr != INET_E_DEFAULT_ACTION && (grfSTI & PI_PARSE_URL)) return S_FALSE;
        else return hr;
    }

    hr = AssembleUrl(NULL, 0, &cwc, L"ms-its", pwcsExternalPath, pwcsInternalPath);
    
    RonM_ASSERT(hr == E_OUTOFMEMORY);

    m_pwcsURL = New WCHAR[cwc];

    if (!m_pwcsURL)
        return E_OUTOFMEMORY;

    DWORD cwcRequired = 0;

    hr = AssembleUrl(m_pwcsURL, cwc, &cwcRequired, L"ms-its", pwcsExternalPath, pwcsInternalPath);

    RonM_ASSERT(hr == S_OK);
    
    m_pOIProtSink = pOIProtSink;
    m_pOIBindInfo = pOIBindInfo;
    m_grfSTI      = grfSTI;

    m_pOIProtSink->AddRef();
    m_pOIBindInfo->AddRef();

    m_BindInfo.cbSize = sizeof(BINDINFO);

    hr = GetBindInfo(&m_grfBINDF, &m_BindInfo);

    if (!SUCCEEDED(hr)) return hr;

    if (grfSTI & PI_PARSE_URL)
        return ParseAndBind(FALSE);

    if (!(grfSTI & PI_FORCE_ASYNC))
        return ParseAndBind(TRUE);

    PROTOCOLDATA protdata;

    protdata.grfFlags = PI_FORCE_ASYNC;
    protdata.dwState  = ITS_BIND_DATA;
    protdata.pData    = NULL;
    protdata.cbData   = 0;

    Switch(&protdata);

    return E_PENDING;
}

HRESULT STDMETHODCALLTYPE CopyStreamToFile(const WCHAR *pwcsFilePath, IStream *pStreamSrc)
{            

    IStream *pStream;

    IFSStorage *pFSS = NULL;

    HRESULT hr = CFileSystemStorage::Create(NULL, IID_IFSStorage, (VOID **) &pFSS);

    if (!SUCCEEDED(hr)) return hr;

    hr = pFSS->FSOpenStream((const WCHAR *) pwcsFilePath, 
                            STGM_READWRITE | STGM_SHARE_DENY_NONE,
                            &pStream
                           );

    pFSS->Release();

    if (!SUCCEEDED(hr)) return hr;

    RonM_ASSERT(pStreamSrc);

    STATSTG statstg;

    hr = pStreamSrc->Stat(&statstg, STATFLAG_NONAME);

    if (!SUCCEEDED(hr)) return hr;

#ifdef _DEBUG    
    hr = 
#endif // _DEBUG
        pStreamSrc->Seek(CLINT(0).Li(), STREAM_SEEK_SET, NULL); 

    RonM_ASSERT(hr == S_OK);

    hr = pStreamSrc->CopyTo(pStream, statstg.cbSize, NULL, NULL);

    pStream->Release();

    if (!SUCCEEDED(hr)) return hr;

#ifdef _DEBUG    
    hr = 
#endif // _DEBUG
        pStreamSrc->Seek(CLINT(0).Li(), STREAM_SEEK_SET, NULL); 

    RonM_ASSERT(hr == S_OK);

    return hr;
}

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::ParseAndBind(BOOL fBind)
{
    WCHAR *pwcsURL       = m_pwcsURL;
    WCHAR *pwcsURLActual = NULL;

    BOOL fNoFile = (m_grfBINDF & BINDF_NEEDFILE) == 0; // FALSE;

    BOOL fNoReadCache = m_grfBINDF & (BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE
                                                             | BINDF_PRAGMA_NO_CACHE
                                                             | BINDF_DIRECT_READ
                                     );

    BOOL fNoWriteCache = m_grfBINDF & (BINDF_NOWRITECACHE | BINDF_PRAGMA_NO_CACHE
                                                          | BINDF_DIRECT_READ
                                      );
    
    IBindCtx *pBCtx           = NULL;
    IMoniker *pMK             = NULL;
    PWCHAR    pwcsExtension   = NULL;
    PWCHAR    pwcsMimeType    = NULL;
    PWCHAR    pwcsStreamName  = NULL;
    ULONG     chEaten         = 0;
    DWORD     cbSample        = 0;

    HRESULT hr = CreateBindCtx(0, &pBCtx);

    if (!SUCCEEDED(hr)) goto exit_ParseAndBind;

    hr = CStorageMoniker::CreateStorageMoniker(NULL, pBCtx, pwcsURL, &chEaten, &pMK);

    if (!fBind)
    {
        if (hr != S_OK) 
            hr =  S_FALSE;

        goto exit_ParseAndBind;
    }
    
    if (!SUCCEEDED(hr)) goto exit_ParseAndBind;
    
    hr = pMK->BindToStorage(pBCtx, NULL, IID_IStream, (VOID **) &m_pStream);

    if (!SUCCEEDED(hr)) goto exit_ParseAndBind;

    hr = pMK->GetDisplayName(NULL, NULL, &pwcsURLActual);

    RonM_ASSERT(hr == S_OK);

    {
        UINT cwc = wcsLen(pwcsURLActual);

        WCHAR *pwc = pwcsURLActual + cwc;

        for (;;)
        {
            WCHAR wc = *--pwc;

            if (!pwcsExtension && wc == L'.')
                pwcsExtension = pwc + 1;

            if (wc == L':' || wc == L'/' || wc == L'\\')
            {
                pwc++; 

                break;
            }

            RonM_ASSERT(--cwc);
        }

        pwcsStreamName = pwc;

        ReportProgress(BINDSTATUS_SENDINGREQUEST, (const WCHAR *) pwc);
    }    

    STATSTG statstg;

    hr = m_pStream->Stat(&statstg, STATFLAG_NONAME);

    if (!SUCCEEDED(hr)) goto exit_ParseAndBind;

    RonM_ASSERT(statstg.cbSize.HighPart == 0);

    BYTE  abSample[CB_SAMPLE];

    if (pwcsExtension && pwcsExtension[0])
    {
        UINT cwc = wcsLen(pwcsExtension-1);
        UINT cb  = sizeof(WCHAR) * (cwc + 1);

        char *pcsExtension = PCHAR(_alloca(cb));

        if (!pcsExtension)
        {
            hr = E_OUTOFMEMORY;
            goto exit_ParseAndBind;
        }

        cb = WideCharToMultiByte(GetACP(),	WC_COMPOSITECHECK, pwcsExtension-1, cwc + 1, 
                                 pcsExtension, cb, NULL, NULL
                                );

        if (!cb)
        {
            hr = E_FAIL;
            goto exit_ParseAndBind;
        }

        HKEY hkeyMime;
        
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pcsExtension, 0, KEY_QUERY_VALUE, &hkeyMime)
             == ERROR_SUCCESS
           )
        {
            cb = CB_SAMPLE;
            
            if (RegQueryValueEx(hkeyMime, "Content Type", NULL, NULL, abSample, (DWORD *) &cb)
                  == ERROR_SUCCESS
                && cb > 0
               )
            {
                PWCHAR pwc = (PWCHAR) (OLEHeap()->Alloc(cb * sizeof(WCHAR)));

                if (pwc) 
                {
                    UINT cwc = MultiByteToWideChar
                                   (GetACP(), MB_PRECOMPOSED, (const char *) abSample,
                                    cb, pwc, cb
                                   );
                    
                    if (cwc) pwcsMimeType = pwc;
                    else OLEHeap()->Free(pwc);
                }
            }

            RegCloseKey(hkeyMime);
        }
    }
        
    if (!pwcsMimeType)
    {    
        DWORD cbRead;

        cbSample = statstg.cbSize.LowPart < CB_SAMPLE? statstg.cbSize.LowPart : CB_SAMPLE;

        hr = m_pStream->Read(abSample, cbSample, &cbRead);

        if (!SUCCEEDED(hr)) goto exit_ParseAndBind;

        if (cbRead != cbSample)
        {
            hr = E_FAIL;

            goto exit_ParseAndBind;
        }

        m_pStream->Seek(CLINT(0).Li(), STREAM_SEEK_SET, NULL);

        hr = pFindMimeFromData(NULL, pwcsStreamName, abSample, cbSample, NULL, 0, &pwcsMimeType, 0);

        if (!SUCCEEDED(hr)) goto exit_ParseAndBind;
    }

    if (pwcsMimeType)
    {
        // The test below is a hack to get around a bug in UrlMon.
        // UrlMon incorrectly tells us we need to copy HTML files into the cache.

        if (!wcsicmp_0x0409(pwcsMimeType, L"text/html")) fNoFile = TRUE;
        
        ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwcsMimeType);
    }
    
    if (!fNoFile)
    {
        CHAR   acsFilePath[MAX_PATH];
        WCHAR awcsFilePath[MAX_PATH];

        hr = StreamToIEFile(m_pStream, m_pwcsURL, m_pcsDisplayName, 
                            acsFilePath, awcsFilePath, m_szTempPath, 
                            pMK, fNoWriteCache, fNoReadCache
                           );

        if (!SUCCEEDED(hr))
            goto exit_ParseAndBind;

        hr = ReportProgress(BINDSTATUS_CACHEFILENAMEAVAILABLE, awcsFilePath);

        if (!SUCCEEDED(hr)) goto exit_ParseAndBind;
    }

    hr = ReportData(BSCF_FIRSTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE,
                                   statstg.cbSize.LowPart, statstg.cbSize.LowPart
                                  );

    // The call to ReportData may indirectly call the Terminate method. So we have
    // to be very careful about references to m_pOIProtSink afterwards.

    if (SUCCEEDED(hr) && m_pOIProtSink)
        hr = ReportProgress(BSCF_LASTDATANOTIFICATION, NULL);

    if (SUCCEEDED(hr) && m_pOIProtSink)
        ReportResult(hr, 0, 0);

exit_ParseAndBind:

    if (pwcsURLActual)
        OLEHeap()->Free(pwcsURLActual);
    
    if (pMK) 
        pMK->Release();
    if (pBCtx) 
        pBCtx->Release();

    if (hr != NO_ERROR)
        ReportResult(hr, 0, 0);
    
    return hr;
}

HRESULT STDMETHODCALLTYPE StreamToIEFile
    (IStream *pStreamSrc, PWCHAR pwcsDisplayName, PCHAR &pcsDisplayName,
     PCHAR pcsFileName, PWCHAR pwcsFileName, PCHAR pcsTempFile, 
     IMoniker *pmk, BOOL fNoWriteCache, BOOL fNoReadCache
    )
{
    HRESULT hr = NO_ERROR;
    PWCHAR pwcsExtension = NULL;
    PWCHAR pwc           = NULL;
    PCHAR pcsExtension = "";

    STATSTG statstg;

    hr = pStreamSrc->Stat(&statstg, STATFLAG_NONAME);

    if (!SUCCEEDED(hr)) goto exit_StreamToIEFile;

    RonM_ASSERT(statstg.cbSize.HighPart == 0);

    FILETIME ftLastModified;

    ftLastModified.dwLowDateTime  = 0;
    ftLastModified.dwHighDateTime = 0;

    // pmk->GetTimeOfLastChange(pBCtx, NULL, &ftLastModified); 

    pwc = pwcsDisplayName + wcsLen(pwcsDisplayName);

    for (;;)
    {
        WCHAR wc = *--pwc;

        if (!pwcsExtension && wc == L'.')
            pwcsExtension = pwc + 1;

        if (wc == L':' || wc == L'/' || wc == L'\\')
        {
            pwc++; 

            break;
        }

        RonM_ASSERT(pwc > pwcsDisplayName);
    }
        
    if (pwcsExtension && pwcsExtension[0])
    {
        UINT cwc = wcsLen(pwcsExtension);
        UINT cb  = sizeof(WCHAR) * (cwc + 1);

        pcsExtension = PCHAR(_alloca(cb));

        if (!pcsExtension)
        {
            hr = E_OUTOFMEMORY;
            goto exit_StreamToIEFile;
        }

        cb = WideCharToMultiByte(GetACP(),	WC_COMPOSITECHECK, pwcsExtension, cwc + 1, 
                                 pcsExtension, cb, NULL, NULL
                                );

        if (!cb)
        {
            hr = E_FAIL;
            goto exit_StreamToIEFile;
        }
    }

    if (fNoWriteCache)
    {
        DWORD cbPath= GetTempPath(MAX_PATH, pcsTempFile);

        if (!cbPath)
            lstrcpyA(pcsTempFile, ".\\");

        char szPrefix[4] = "IMT"; // BugBug! May need to make this a random string.

        char szFullPath[MAX_PATH];

        if (!GetTempFileName(pcsTempFile, szPrefix, 0, szFullPath))
        {
            hr = CFSLockBytes::CImpILockBytes::STGErrorFromFSError(GetLastError());
            pcsTempFile[0] = 0;
            goto exit_StreamToIEFile;
        }

        lstrcpyA(pcsTempFile, szFullPath);

        char *pch = pcsTempFile + lstrlenA(pcsTempFile);

        for (;;)
        {
            if (pch == pcsTempFile)
            {
                RonM_ASSERT(FALSE);
                
                hr = E_UNEXPECTED;
                
                DeleteFile(pcsTempFile);
                pcsTempFile[0] = 0;
                goto exit_StreamToIEFile;
            }

            if ('.' == *--pch)
            {
                ++pch;
                break;
            }
        }

        UINT cbExtension = lstrlenA(pcsExtension);

        if (pch + cbExtension - pcsTempFile >= MAX_PATH)
        {
            hr = E_UNEXPECTED;
            
            DeleteFile(pcsTempFile);
            pcsTempFile[0] = 0;
            goto exit_StreamToIEFile;
        }

        CopyMemory(pch, pcsExtension, cbExtension + 1);

        if (!MoveFileEx(szFullPath, pcsTempFile, MOVEFILE_REPLACE_EXISTING))
        {
            hr = E_UNEXPECTED;
            
            DeleteFile(szFullPath);
            pcsTempFile[0] = 0;
            goto exit_StreamToIEFile;
        }

        UINT cwc = MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, pcsTempFile,
                                       1 + lstrlenA(pcsTempFile), pwcsFileName, MAX_PATH
                                      );

        if (cwc == 0)
        {
            hr = E_FAIL;

            DeleteFile(pcsTempFile);
            pcsTempFile [0] = 0;
            pwcsFileName[0] = 0;

            goto exit_StreamToIEFile;
        }

        hr = CopyStreamToFile((const WCHAR *)pwcsFileName, pStreamSrc);
    
        if (!SUCCEEDED(hr)) 
        {
            DeleteFile(pcsTempFile);
            pcsTempFile[0] = 0;
            pwcsFileName[0] = 0;
            
            goto exit_StreamToIEFile;
        }

        lstrcpyA(pcsFileName, pcsTempFile);
    }
    else
    {
        UINT cwc = wcsLen(pwcsDisplayName);
        UINT cb  = sizeof(WCHAR) * (cwc + 1);
        
        pcsDisplayName = New char[cb];

        if (!pcsDisplayName)
        {
            hr = E_OUTOFMEMORY;
            goto exit_StreamToIEFile;
        }

        cb = WideCharToMultiByte(GetACP(),	WC_COMPOSITECHECK, pwcsDisplayName, cwc + 1, 
                                 pcsDisplayName, cb, NULL, NULL
                                );

        if (!cb)
        {
            hr = INET_E_DOWNLOAD_FAILURE;
            delete [] pcsDisplayName;  pcsDisplayName = NULL;
            goto exit_StreamToIEFile;
        }

        BOOL  fResult   = FALSE;
        DWORD dwCEISize = 0;
        ULONG ulErr     = 0;

        if (!fNoReadCache)
        {
            RonM_ASSERT(dwCEISize == 0);
            
            fResult = RetrieveUrlCacheEntryFile(pcsDisplayName, NULL, &dwCEISize, 0);
        
            RonM_ASSERT(!fResult);

            ulErr= GetLastError();

            if (ulErr == ERROR_INSUFFICIENT_BUFFER)
            {
                dwCEISize += 4; // To work around a bug in the RetrieveUrlCacheEntryFile;
                                // It sometimes gives an incorrect size immediately after
                                // data has been copied to the cache.

                INTERNET_CACHE_ENTRY_INFOA *pCEI = (INTERNET_CACHE_ENTRY_INFOA *) _alloca(dwCEISize);
        
                if (!pCEI)
                {
                    hr = E_OUTOFMEMORY;

                    goto exit_StreamToIEFile;
                }
        
                pCEI->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFOA);

                fResult = RetrieveUrlCacheEntryFile(pcsDisplayName, pCEI, &dwCEISize, 0);

                ulErr = GetLastError();

                if (fResult)
                    if (   pCEI->LastModifiedTime.dwLowDateTime  == ftLastModified.dwLowDateTime
                        && pCEI->LastModifiedTime.dwHighDateTime == ftLastModified.dwHighDateTime
                        && pCEI->dwSizeLow  == statstg.cbSize.LowPart
                        && pCEI->dwSizeHigh == statstg.cbSize.HighPart
                       )
                    {
                        lstrcpyA(pcsFileName, pCEI->lpszLocalFileName);
                        cwc = MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, 
                                                  pcsFileName, 1 + lstrlenA(pcsFileName), 
                                                  pwcsFileName, MAX_PATH
                                                 );

                        RonM_ASSERT(cwc != 0);
                    }
                    else 
                    {    
                        UnlockUrlCacheEntryFile(pcsDisplayName, 0);
                        fResult = FALSE;
                    }
            }
        }

        if (!fResult)
        {
            fResult = CreateUrlCacheEntryA(pcsDisplayName, statstg.cbSize.LowPart, 
                                           pcsExtension, pcsFileName, 0
                                          );

            if (!fResult)
            {
                hr = INET_E_CANNOT_INSTANTIATE_OBJECT;
                delete [] pcsDisplayName;  pcsDisplayName = NULL;
                goto exit_StreamToIEFile;
            }

            cwc = MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, pcsFileName,
                                      1 + lstrlenA(pcsFileName), pwcsFileName, MAX_PATH
                                     );

            hr = CopyStreamToFile((const WCHAR *) pwcsFileName, pStreamSrc);

            if (!fResult)
            {
                hr = INET_E_CANNOT_INSTANTIATE_OBJECT;
                delete [] pcsDisplayName;  pcsDisplayName = NULL;
                 pcsFileName[0] = 0;
                pwcsFileName[0] = 0;
                goto exit_StreamToIEFile;
            }

            FILETIME ftExpire;

            ftExpire.dwLowDateTime  = 0;
            ftExpire.dwHighDateTime = 0;

            fResult = CommitUrlCacheEntryA(pcsDisplayName, pcsFileName, ftExpire,
                                           ftLastModified, NORMAL_CACHE_ENTRY, NULL, 
                                           0, pcsExtension, 0
                                          );

            if (!fResult)
            {
                ulErr= GetLastError();
                hr = INET_E_CANNOT_INSTANTIATE_OBJECT;
                delete [] pcsDisplayName;  pcsDisplayName = NULL;
                 pcsFileName[0] = 0;
                pwcsFileName[0] = 0;
                goto exit_StreamToIEFile;
            }

            dwCEISize = 0;

            fResult = RetrieveUrlCacheEntryFile(pcsDisplayName, NULL, &dwCEISize, 0);
    
            RonM_ASSERT(!fResult);

            ulErr= GetLastError();

            if (ulErr == ERROR_INSUFFICIENT_BUFFER)
            {
                dwCEISize += 4; // To work around a bug in the RetrieveUrlCacheEntryFile;
                                // It sometimes gives an incorrect size immediately after
                                // data has been copied to the cache.
                
                INTERNET_CACHE_ENTRY_INFOA *pCEI = (INTERNET_CACHE_ENTRY_INFOA *) _alloca(dwCEISize);
    
                if (!pCEI)
                {
                    hr = E_OUTOFMEMORY;
                    delete [] pcsDisplayName;  pcsDisplayName = NULL;
                     pcsFileName[0] = 0;
                    pwcsFileName[0] = 0;
                    goto exit_StreamToIEFile;
                }
    
                pCEI->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFOA);

                fResult = RetrieveUrlCacheEntryFile(pcsDisplayName, pCEI, &dwCEISize, 0);

                if (!fResult)
                {
                    ulErr= GetLastError();

                    RonM_ASSERT(FALSE); 

                    hr = INET_E_CANNOT_INSTANTIATE_OBJECT;

                    delete [] pcsDisplayName;  pcsDisplayName = NULL;
                     pcsFileName[0] = 0;
                    pwcsFileName[0] = 0;
                    goto exit_StreamToIEFile;
                }
            }
        }
    }

    return NO_ERROR;

exit_StreamToIEFile:

    return hr;
}

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::Continue
    (/* [in] */ PROTOCOLDATA __RPC_FAR *pProtocolData)
{
    switch (pProtocolData->dwState)
    {
    case ITS_BIND_DATA:
        
        return ParseAndBind(TRUE);

    default:
        
        RonM_ASSERT(FALSE);

        return INET_E_INVALID_REQUEST;
    }
}


HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::Abort
    ( 
	/* [in] */ HRESULT hrReason,
	/* [in] */ DWORD dwOptions
    )
{
    return ReportResult(E_ABORT, 0, 0);
}


HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::Terminate
    (/* [in] */ DWORD dwOptions)
{
    if (m_pwcsURL)
    {
        delete [] m_pwcsURL;  m_pwcsURL = NULL;
    }

    if (m_pOIProtSink)
    {
        m_pOIProtSink->Release();  m_pOIProtSink = NULL;
    }

    if (m_pOIBindInfo)
    {
        m_pOIBindInfo->Release();  m_pOIBindInfo = NULL;
    }

    return NO_ERROR;
}


HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::Suspend(void)
{
    return NO_ERROR; 
}


HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::Resume(void)
{
    return NO_ERROR; 
}


// IOITnetProtocol interfaces:

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::Read
    ( 
	/* [length_is][size_is][out] */ void __RPC_FAR *pv,
	/* [in] */ ULONG cb,
	/* [out] */ ULONG __RPC_FAR *pcbRead
    )
{
    if (m_pStream)
         return m_pStream->Read(pv, cb, pcbRead); 
    else return INET_E_DATA_NOT_AVAILABLE;
}


HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::Seek
    ( 
	/* [in] */ LARGE_INTEGER dlibMove,
	/* [in] */ DWORD dwOrigin,
	/* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition
    )
{
    if (m_pStream)
         return m_pStream->Seek(dlibMove, dwOrigin, plibNewPosition); 
    else return INET_E_DATA_NOT_AVAILABLE;
}


HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::LockRequest
    (/* [in] */ DWORD dwOptions)
{
    return NO_ERROR; 
}


HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::UnlockRequest(void)
{
    return NO_ERROR; 
}

HRESULT STDMETHODCALLTYPE DisectUrl
    (PWCHAR pwcsUrlBuffer, PWCHAR *ppwcProtocolName, 
                           PWCHAR *ppwcExternalPath,
                           PWCHAR *ppwcInternalPath
    )
{
    PWCHAR pwcProtocolName = NULL,
           pwcExternalPath = NULL,
           pwcInternalPath = NULL;

    MapSurrogateCharacters(pwcsUrlBuffer);
    
    PWCHAR pwc = wcsChr((const WCHAR *) pwcsUrlBuffer, L':');

    if (!pwc)
        return URL_E_INVALID_SYNTAX;

    *pwc++ = 0;

    pwcProtocolName = pwcsUrlBuffer;

    if (   L'@' == *pwcProtocolName 
        && !wcsicmp_0x0409((const WCHAR *) (pwcProtocolName+1), L"msitstore")
       )
    {
        pwcProtocolName = L"mk:@msitstore";
    }
    else if (!wcsicmp_0x0409((const WCHAR *)pwcProtocolName, L"mk"))
    {
        // This URL begins with "mk:". We handle entries which
        // begin with "mk:@MSITStore:"
        
        // We treat the @<classid> as part of the protocol name.
        // So we must first put the colon separator back.
        
        pwc[-1] = L':';
        
        if (L'@' != *pwc) return URL_E_INVALID_SYNTAX;

        PWCHAR pwcClassName = pwc + 1;

        pwc = wcsChr((const WCHAR *) pwcClassName, L':');

        if (!pwc) return URL_E_INVALID_SYNTAX;

        *pwc++ = 0;

        if (wcsicmp_0x0409((const WCHAR *)pwcClassName, L"msitstore"))
            return INET_E_DEFAULT_ACTION;
    }
    else if (!wcsicmp_0x0409((const WCHAR *)pwcsUrlBuffer, L"its"))
    {
    }
        else if (!wcsicmp_0x0409((const WCHAR *)pwcsUrlBuffer, L"ms-its"))
        {
        }
        else return INET_E_DEFAULT_ACTION;

    pwcExternalPath = pwc;

    pwc += wcsLen(pwc);

    for (; pwc > pwcExternalPath; )
    {
        WCHAR wc = *--pwc;

        if (wc == L':')
            if (pwc > pwcExternalPath && L':' == *--pwc)
            {
                *pwc = 0;
                pwc += 2;

                break;
            }
    }

    if (pwc == pwcExternalPath)
        pwc += wcsLen(pwc);

    if (!*pwcExternalPath || wcsLen(pwcExternalPath) >= MAX_PATH) return URL_E_INVALID_SYNTAX;

    pwcInternalPath = pwc;

    for (;*pwc; pwc++);

    if (pwcInternalPath == pwc) 
        pwcInternalPath = L"/";

    if (wcsLen(pwcInternalPath) >= MAX_PATH) return URL_E_INVALID_SYNTAX;

    if (ppwcProtocolName) *ppwcProtocolName = pwcProtocolName; 
    if (ppwcExternalPath) *ppwcExternalPath = pwcExternalPath;
    if (ppwcInternalPath) *ppwcInternalPath = pwcInternalPath;

    return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE AssembleUrl
    (PWCHAR pwcsResult, DWORD cwcBuffer, DWORD *pcwcRequired,
     PWCHAR pwcsProtocolName, PWCHAR pwcsExternalPath, PWCHAR pwcsInternalPath
    )
{
    UINT cwc = wcsLen(pwcsProtocolName) + wcsLen(pwcsExternalPath) 
                                        + wcsLen(pwcsInternalPath) 
                                        + 4;

    *pcwcRequired = cwc;
    
    if (cwc > cwcBuffer)
        return E_OUTOFMEMORY;

    wcsCpy(pwcsResult, pwcsProtocolName);
    wcsCat(pwcsResult, L":");
    wcsCat(pwcsResult, pwcsExternalPath);
    wcsCat(pwcsResult, L"::");
    wcsCat(pwcsResult, pwcsInternalPath);
    
    return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::ParseUrl
    ( 
    /* [in] */ LPCWSTR pwzUrl,
    /* [in] */ PARSEACTION ParseAction,
    /* [in] */ DWORD dwParseFlags,
    /* [out] */ LPWSTR pwzResult,
    /* [in] */ DWORD cchResult,
    /* [out] */ DWORD __RPC_FAR *pcchResult,
    /* [in] */ DWORD dwReserved
    )
{
    switch (ParseAction)
    {
    case PARSE_CANONICALIZE:
    case PARSE_SECURITY_URL:

        {
            // First we make a working copy of the URL.
            UINT cwc = wcsLen(pwzUrl);
            UINT cb  = sizeof(WCHAR) * (cwc + 1);

            PWCHAR pwcsUrl = PWCHAR(_alloca(cb));

            if (!pwcsUrl)
                return E_OUTOFMEMORY;

            CopyMemory(pwcsUrl, pwzUrl, cb);

            PWCHAR pwcProtocolName = NULL,
                   pwcExternalPath = NULL,
                   pwcInternalPath = NULL;

            BOOL   fLocalFilePath  = FALSE;

            HRESULT hr = DisectUrl(pwcsUrl, &pwcProtocolName, &pwcExternalPath, &pwcInternalPath);

            if (!SUCCEEDED(hr)) return hr;

            // Here we copy the external path string to a buffer because
            // it may be a partial local path which needs to be mapped into
            // a full path.

            WCHAR awcsExternalPath[MAX_PATH];

            RonM_ASSERT(wcsLen(pwcExternalPath) < MAX_PATH);

            wcsCpy(awcsExternalPath, pwcExternalPath);
            
            PWCHAR pwc = wcsChr((const WCHAR *) awcsExternalPath, L':');

            if (pwc && pwc[1] == L':') // Ignore a "::" separator 
                pwc = NULL;

            // Here we're special casing non-protocol references to a file.
            // We recognize those situations by looking for a protocol prefix.
            // Protocol prefixes have the form <Protocol Name> :
            // where <Protocol Name> is always longer than one character.

            if (!pwc || (pwc - awcsExternalPath == 1))
            {
                fLocalFilePath = TRUE;

                if (FindRootStorageFile(awcsExternalPath) == S_OK)
                    pwcExternalPath = awcsExternalPath;
            }

            if (ParseAction == PARSE_SECURITY_URL)
            {

                UINT cwcExt = 1 + wcsLen(pwcExternalPath);

                if (fLocalFilePath)
                {
                    // It's a local file. Got to prefix the result with
                    // "File://".
                    
                    RonM_ASSERT(7 == wcsLen(L"File://"));

                    *pcchResult = cwcExt + 7;

                    if (cchResult < (cwcExt + 7))
                        return E_OUTOFMEMORY;

                    CopyMemory(pwzResult, L"File://", 7 * sizeof(WCHAR));

                    pwzResult += 7;
                }
                else
                {
                    *pcchResult = cwcExt;

                    if (cwcExt > cchResult)
                        return E_OUTOFMEMORY;
                }

                CopyMemory(pwzResult, pwcExternalPath, cwcExt * sizeof(WCHAR));

                return NO_ERROR;
            }

            cwc = wcsLen(pwcInternalPath);

            BOOL fStorage = pwcInternalPath[cwc-1] == L'/' || pwcInternalPath[cwc-1] == L'\\';

            WCHAR awcsInternalPath[MAX_PATH];

            hr = ResolvePath(awcsInternalPath, L"/", (const WCHAR *) pwcInternalPath, fStorage);

            if (!SUCCEEDED(hr)) return hr;

            hr = AssembleUrl(pwzResult, cchResult, pcchResult, 
                             pwcProtocolName, pwcExternalPath, awcsInternalPath
                            );

            return hr;
        }

    case PARSE_FRIENDLY:

    case PARSE_ROOTDOCUMENT:

    case PARSE_DOCUMENT:

    case PARSE_ANCHOR:

    case PARSE_ENCODE:
    case PARSE_DECODE:
    case PARSE_PATH_FROM_URL:
    case PARSE_URL_FROM_PATH:
    case PARSE_LOCATION:
    case PARSE_MIME:
    case PARSE_SECURITY_DOMAIN:

    default:
        return INET_E_DEFAULT_ACTION;
    }
}

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::CombineUrl
    ( 
    /* [in] */ LPCWSTR pwzBaseUrl,
    /* [in] */ LPCWSTR pwzRelativeUrl,
    /* [in] */ DWORD dwCombineFlags,
    /* [out] */ LPWSTR pwzResult,
    /* [in] */ DWORD cchResult,
    /* [out] */ DWORD __RPC_FAR *pcchResult,
    /* [in] */ DWORD dwReserved
    )
{
    // First we make a working copy of the URL.

    UINT cwc = wcsLen(pwzBaseUrl);
    UINT cb  = sizeof(WCHAR) * (cwc + 1);

    PWCHAR pwcsUrl = PWCHAR(_alloca(cb));

    if (!pwcsUrl)
        return E_OUTOFMEMORY;

    CopyMemory(pwcsUrl, pwzBaseUrl, cb);

    PWCHAR pwcProtocolName = NULL,
           pwcExternalPath = NULL,
           pwcInternalPath = NULL;

    HRESULT hr = DisectUrl(pwcsUrl, &pwcProtocolName, &pwcExternalPath, &pwcInternalPath);

    if (!SUCCEEDED(hr)) return hr;

    WCHAR awcsInternalPath[MAX_PATH];

    if (*pwzRelativeUrl == L'#')
    {
        // Special case for intra page relative URLs.

        // BugBug! How many other special case do we need to add to match
        // the behavior of file:// and html:// ??

        if (wcsLen(pwcInternalPath) + wcsLen(pwzRelativeUrl) >= MAX_PATH)
            return INET_E_INVALID_URL;
        
        wcsCpy(awcsInternalPath, pwcInternalPath);
        wcsCat(awcsInternalPath, pwzRelativeUrl);
    }
    else
    {
        // Here we assume that the relative url is a stream path suffix.
        // Since we'll be combining with pwzRelativeUrl we must first 
        // truncate the internal path at the last storage name separator.

        PWCHAR pwc = pwcInternalPath + wcsLen(pwcInternalPath);

        for (;;)
        {
            WCHAR wc = *--pwc;
    
            if (wc == L'/' || wc == L'\\') break;
        }

        *++pwc = 0;

        cwc = wcsLen(pwzRelativeUrl);

        if (!cwc) return URL_E_INVALID_SYNTAX;

        WCHAR wc = pwzRelativeUrl[cwc - 1];

        hr = ResolvePath(awcsInternalPath, (const WCHAR *) pwcInternalPath, 
                                           (const WCHAR *) pwzRelativeUrl, 
                                           (wc == L'/' || wc == L'\\')
                        );

        if (!SUCCEEDED(hr)) return hr;
    }

    hr = AssembleUrl(pwzResult, cchResult, pcchResult, 
                     pwcProtocolName, pwcExternalPath, awcsInternalPath
                    );

    return hr;
}

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::CompareUrl
    ( 
    /* [in] */ LPCWSTR pwzUrl1,
    /* [in] */ LPCWSTR pwzUrl2,
    /* [in] */ DWORD dwCompareFlags
    )
{
    DWORD cwc1  = wcsLen(pwzUrl1);

    PWCHAR pwcsBuffer1 = PWCHAR(_alloca((cwc1 + 1) * sizeof(WCHAR)));

    if (!pwcsBuffer1) return E_OUTOFMEMORY;

    CopyMemory(pwcsBuffer1, pwzUrl1, sizeof(WCHAR) * (cwc1 + 1));

    PWCHAR pwcsExternalPath1 = NULL;
    PWCHAR pwcsInternalPath1 = NULL;

    HRESULT hr = DisectUrl(pwcsBuffer1, NULL, &pwcsExternalPath1, &pwcsInternalPath1);
    
    if (!SUCCEEDED(hr)) 
        return hr;

    WCHAR awcsExternalPath1[MAX_PATH];

    if (wcsLen(pwcsExternalPath1) < MAX_PATH)
    {
        wcsCpy(awcsExternalPath1, pwcsExternalPath1);
        
        PWCHAR pwc = wcsChr((const WCHAR *) awcsExternalPath1, L':');

        if (pwc && pwc[1] == L':') // Ignore a "::" separator 
            pwc = NULL;

        // Here we're special casing non-protocol references to a file.
        // We recognize those situations by looking for a protocol prefix.
        // Protocol prefixes have the form <Protocol Name> :
        // where <Protocol Name> is always longer than one character.

        if (!pwc || (pwc - awcsExternalPath1 == 1))
        {
            if (FindRootStorageFile(awcsExternalPath1) == S_OK)
                pwcsExternalPath1 = awcsExternalPath1;
        }
    }
    
    DWORD cwc2  = wcsLen(pwzUrl2);

    PWCHAR pwcsBuffer2 = PWCHAR(_alloca((cwc2 + 1) * sizeof(WCHAR)));

    if (!pwcsBuffer2) return E_OUTOFMEMORY;

    CopyMemory(pwcsBuffer2, pwzUrl2, sizeof(WCHAR) * (cwc2 + 1));

    PWCHAR pwcsExternalPath2 = NULL;
    PWCHAR pwcsInternalPath2 = NULL;

    hr = DisectUrl(pwcsBuffer2, NULL, &pwcsExternalPath2, &pwcsInternalPath2);
    
    if (!SUCCEEDED(hr)) 
        return hr;

    WCHAR awcsExternalPath2[MAX_PATH];

    if (wcsLen(pwcsExternalPath2) < MAX_PATH)
    {
        wcsCpy(awcsExternalPath2, pwcsExternalPath2);
        
        PWCHAR pwc = wcsChr((const WCHAR *) awcsExternalPath2, L':');

        if (pwc && pwc[1] == L':') // Ignore a "::" separator 
            pwc = NULL;

        // Here we're special casing non-protocol references to a file.
        // We recognize those situations by looking for a protocol prefix.
        // Protocol prefixes have the form <Protocol Name> :
        // where <Protocol Name> is always longer than one character.

        if (!pwc || (pwc - awcsExternalPath2 == 1))
        {
            if (FindRootStorageFile(awcsExternalPath2) == S_OK)
                pwcsExternalPath2 = awcsExternalPath2;
        }
    }

    if (wcsicmp_0x0409((const WCHAR *)  pwcsExternalPath1, (const WCHAR *) pwcsExternalPath2))
        return S_FALSE;

    if (wcsicmp_0x0409((const WCHAR *)  pwcsInternalPath1, (const WCHAR *) pwcsInternalPath2))
        return S_FALSE;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::QueryInfo
    ( 
    /* [in] */ LPCWSTR pwzUrl,
    /* [in] */ QUERYOPTION QueryOption,
    /* [in] */ DWORD dwQueryFlags,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [in] */ DWORD cbBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
    /* [in] */ DWORD dwReserved
    )
{
    switch (QueryOption)
    {
    case QUERY_CAN_NAVIGATE: // What does this really mean?

        if (pcbBuf) *pcbBuf = sizeof(DWORD);
        
        if (cbBuffer < sizeof(DWORD)) return E_FAIL;

        *(DWORD *) pBuffer = TRUE;

        return NO_ERROR;

    case QUERY_EXPIRATION_DATE:
    case QUERY_TIME_OF_LAST_CHANGE:
    // case QUERY_CONTEXT_ENCODING:
    case QUERY_REFRESH:
    case QUERY_RECOMBINE:

    default:
    
//        RonM_ASSERT(FALSE);

        return E_NOTIMPL;
    }
}

#ifdef PROFILING

// These wrapper functions are defined for the profiling version
// of the code so that we can measure how much time is consumed 
// by callbacks into URLMON.

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::Switch
    (PROTOCOLDATA __RPC_FAR *pProtocolData)
{
    return m_pOIProtSink->Switch(pProtocolData);
}

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::ReportProgress
    (ULONG ulStatusCode, LPCWSTR szStatusText)
{
    return m_pOIProtSink->ReportProgress(ulStatusCode, szStatusText);
}

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::ReportData
    (DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    return m_pOIProtSink->ReportData(grfBSCF, ulProgress, ulProgressMax);
}

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::ReportResult
    (HRESULT hrResult, DWORD dwError, LPCWSTR szResult)
{
    return m_pOIProtSink->ReportResult(hrResult, dwError, szResult);
}

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::GetBindInfo
    (DWORD __RPC_FAR *grfBINDF, 
                                      BINDINFO __RPC_FAR *pbindinfo
                                     )
{
    return m_pOIBindInfo->GetBindInfo(grfBINDF, pbindinfo);
}

HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::GetBindString
    (ULONG ulStringType, LPOLESTR __RPC_FAR *ppwzStr,
                                        ULONG cEl, ULONG __RPC_FAR *pcElFetched
                                       )
{
    return m_pOIBindInfo->GetBindString(ulStringType, ppwzStr, cEl, pcElFetched);
}

#endif // PROFILING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\protocol.h ===
// Protocol.h -- Declaration for CProtocol object

#ifndef __PROTOCOL_H__

#define __PROTOCOL_H__

class CIOITnetProtocol : public CITUnknown
{
public:
	
    // Destructor:

	~CIOITnetProtocol();

    // Creation:

    static HRESULT Create(IUnknown *punkOuter, REFIID riid, PPVOID ppv);

private:

    // Constructor:

	CIOITnetProtocol(IUnknown *pUnkOuter);
	
	class CImpIOITnetProtocol : public IOITnetProtocol, public IOITnetProtocolInfo
	{
    public:

        // Constructor and Destructor:

        CImpIOITnetProtocol(CIOITnetProtocol *pBackObj, IUnknown *punkOuter);
        ~CImpIOITnetProtocol(void);

        // Initialing routine:

        HRESULT Init();
		
		// IOITnetProtocolRoot interfaces:

		HRESULT STDMETHODCALLTYPE Start( 
			/* [in] */ LPCWSTR szUrl,
			/* [in] */ IOInetProtocolSink __RPC_FAR *pOIProtSink,
			/* [in] */ IOInetBindInfo __RPC_FAR *pOIBindInfo,
			/* [in] */ DWORD grfSTI,
			/* [in] */ DWORD dwReserved);
    
		HRESULT STDMETHODCALLTYPE Continue( 
			/* [in] */ PROTOCOLDATA __RPC_FAR *pProtocolData);
    
		HRESULT STDMETHODCALLTYPE Abort( 
			/* [in] */ HRESULT hrReason,
			/* [in] */ DWORD dwOptions);
    
		HRESULT STDMETHODCALLTYPE Terminate( 
			/* [in] */ DWORD dwOptions);
    
		HRESULT STDMETHODCALLTYPE Suspend( void);
    
		HRESULT STDMETHODCALLTYPE Resume( void);

		// IOITnetProtocol interfaces:

		HRESULT STDMETHODCALLTYPE Read( 
			/* [length_is][size_is][out] */ void __RPC_FAR *pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG __RPC_FAR *pcbRead);
    
		HRESULT STDMETHODCALLTYPE Seek( 
			/* [in] */ LARGE_INTEGER dlibMove,
			/* [in] */ DWORD dwOrigin,
			/* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition);
    
		HRESULT STDMETHODCALLTYPE LockRequest( 
			/* [in] */ DWORD dwOptions);
    
		HRESULT STDMETHODCALLTYPE UnlockRequest( void);

        // IOITnetProtocolInfo interfaces:

        HRESULT STDMETHODCALLTYPE ParseUrl( 
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ PARSEACTION ParseAction,
            /* [in] */ DWORD dwParseFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD __RPC_FAR *pcchResult,
            /* [in] */ DWORD dwReserved);
    
        HRESULT STDMETHODCALLTYPE CombineUrl( 
            /* [in] */ LPCWSTR pwzBaseUrl,
            /* [in] */ LPCWSTR pwzRelativeUrl,
            /* [in] */ DWORD dwCombineFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD __RPC_FAR *pcchResult,
            /* [in] */ DWORD dwReserved);
    
        HRESULT STDMETHODCALLTYPE CompareUrl( 
            /* [in] */ LPCWSTR pwzUrl1,
            /* [in] */ LPCWSTR pwzUrl2,
            /* [in] */ DWORD dwCompareFlags);
    
        HRESULT STDMETHODCALLTYPE QueryInfo( 
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ QUERYOPTION OueryOption,
            /* [in] */ DWORD dwQueryFlags,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
            /* [in] */ DWORD dwReserved);
    
    private:

        // Wrapprers for IOINetProtocolSink:

        HRESULT STDMETHODCALLTYPE Switch(PROTOCOLDATA __RPC_FAR *pProtocolData);
        
        HRESULT STDMETHODCALLTYPE ReportProgress(ULONG ulStatusCode, LPCWSTR szStatusText);
        
        HRESULT STDMETHODCALLTYPE ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax);
        
        HRESULT STDMETHODCALLTYPE ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR szResult);

        // Wrappers for IOINetBindInfo:

        HRESULT STDMETHODCALLTYPE GetBindInfo(DWORD __RPC_FAR *grfBINDF, 
                                              BINDINFO __RPC_FAR *pbindinfo
                                             );
        
        HRESULT STDMETHODCALLTYPE GetBindString(ULONG ulStringType, LPOLESTR __RPC_FAR *ppwzStr,
                                                ULONG cEl, ULONG __RPC_FAR *pcElFetched
                                               );

        enum { ITS_BIND_DATA = 0, CB_SAMPLE = 256};

        HRESULT STDMETHODCALLTYPE ParseAndBind(BOOL fBind);

        WCHAR              *m_pwcsURL;
        IOInetProtocolSink *m_pOIProtSink;
        IOInetBindInfo     *m_pOIBindInfo;
        IStream            *m_pStream;
        DWORD               m_grfSTI;
        DWORD               m_grfBINDF;
        BINDINFO            m_BindInfo;
        char               *m_pcsDisplayName;
        char                m_szTempPath[MAX_PATH];
    };

    CImpIOITnetProtocol m_ImpIOITnetProtocol;
    IUnknown            *m_apIUnknown[3];
};

extern GUID aIID_CIOITnetProtocol[];

extern UINT cInterfaces_CIOITnetProtocol;

inline CIOITnetProtocol::CIOITnetProtocol(IUnknown *pUnkOuter)
    : m_ImpIOITnetProtocol(this, pUnkOuter), 
      CITUnknown(aIID_CIOITnetProtocol, 
	             cInterfaces_CIOITnetProtocol, 
	             m_apIUnknown
				)
{
    RonM_ASSERT(cInterfaces_CIOITnetProtocol == 3);
    
    m_apIUnknown[0] = (IUnknown *) (IOITnetProtocolRoot *) &m_ImpIOITnetProtocol;
    m_apIUnknown[1] = (IUnknown *) (IOITnetProtocol     *) &m_ImpIOITnetProtocol;
    m_apIUnknown[2] = (IUnknown *) (IOITnetProtocolInfo *) &m_ImpIOITnetProtocol;
}

inline CIOITnetProtocol::~CIOITnetProtocol(void)
{
}

#ifndef PROFILING

// When we're not profiling the code we want these wrappers to be 
// vanish a separate functions. When we're makeing profile runs we want
// to see how much time is consumed by these callbacks.

inline HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::Switch
    (PROTOCOLDATA __RPC_FAR *pProtocolData)
{
    return m_pOIProtSink->Switch(pProtocolData);
}

inline HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::ReportProgress
    (ULONG ulStatusCode, LPCWSTR szStatusText)
{
    return m_pOIProtSink->ReportProgress(ulStatusCode, szStatusText);
}

inline HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::ReportData
    (DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    return m_pOIProtSink->ReportData(grfBSCF, ulProgress, ulProgressMax);
}

inline HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::ReportResult
    (HRESULT hrResult, DWORD dwError, LPCWSTR szResult)
{
    return m_pOIProtSink->ReportResult(hrResult, dwError, szResult);
}

inline HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::GetBindInfo
    (DWORD __RPC_FAR *grfBINDF, BINDINFO __RPC_FAR *pbindinfo)
{
    return m_pOIBindInfo->GetBindInfo(grfBINDF, pbindinfo);
}

inline HRESULT STDMETHODCALLTYPE CIOITnetProtocol::CImpIOITnetProtocol::GetBindString
    (ULONG ulStringType, LPOLESTR __RPC_FAR *ppwzStr,
                                        ULONG cEl, ULONG __RPC_FAR *pcElFetched
                                       )
{
    return m_pOIBindInfo->GetBindString(ulStringType, ppwzStr, cEl, pcElFetched);
}

#endif // PROFILING
        
void STDMETHODCALLTYPE MapSurrogateCharacters(PWCHAR pwcsBuffer);

HRESULT STDMETHODCALLTYPE DisectUrl
    (PWCHAR pwcsUrlBuffer, PWCHAR *ppwcProtocolName, 
                           PWCHAR *ppwcExternalPath,
                           PWCHAR *ppwcInternalPath
    );
HRESULT STDMETHODCALLTYPE AssembleUrl
    (PWCHAR pwcsResult, DWORD cwcBuffer, DWORD *pcwcRequired,
     PWCHAR pwcsProtocolName, PWCHAR pwcsExternalPath, PWCHAR pwcsInternalPath
    );
    
HRESULT STDMETHODCALLTYPE CopyStreamToFile(const WCHAR *pwcsFilePath, IStream *pStreamSrc);
HRESULT STDMETHODCALLTYPE StreamToIEFile
    (IStream *pStreamSrc, PWCHAR pwcsDisplayName, PCHAR &pcsDisplayName,
     PCHAR pcsFileName, PWCHAR pwcsFileName, PCHAR pcsTempFile, 
     IMoniker *pmk, BOOL fNoWriteCache, BOOL fNoReadCache
    );

#endif // __PROTOCOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\stdafx.h ===
// STDAFX.h -- Standard includes for this module

#define strict

#include  <Windows.h>

#ifdef i386
// #define IE30Hack // Turns on a stack-crawling hack to get docfile URLs
                    // working in IE 3.0x
#endif // i386

#ifdef DBG
#define _DEBUG
#endif // DBG

#pragma intrinsic(memcmp)

#include   <OLECTL.h>

#define INITGUID
#include <guiddef.h>
// #include <coguid.h>
// #include <oleguid.h>

#pragma section(".rdata")
#define RDATA_SECTION __declspec(allocate(".rdata"))

EXTERN_C RDATA_SECTION const GUID IID_IInternetProtocol;
EXTERN_C RDATA_SECTION const GUID IID_IInternetProtocolRoot;
EXTERN_C RDATA_SECTION const GUID IID_IInternetProtocolInfo;
EXTERN_C RDATA_SECTION const GUID IID_IPersistStreamInit;



// #include   <URLMKI.h>
#include  <WinINet.h>
#include "MemAlloc.h"
#include   <malloc.h>
#include <intshcut.h>
#include   <urlmon.h>
#include    "Types.h"
#include "RMAssert.h"
#include   "CRTFns.h"
#include     "Sync.h"
#include  "MSITStg.h"
#include    "num64.h"
#include    "ITUnk.h"
#include   "ComDLL.h"
#include     "utf8.h"
#include  "CaseMap.h"
#include "ITIFaces.h"
#include     "guid.h"
#include  "PathMgr.h"
#include "FreeList.h"
#include "NilXForm.h"
#include "LockByte.h"
#include  "Factory.h"
#include  "Warehse.h"
#include  "Storage.h"
#include   "Stream.h"
#include     "Enum.h"
#include  "Moniker.h"
#include  "ITParse.h"
#include "xfrmserv.h"
#include  "fsort.h"
#include    "ITSFS.H"
#include      "lci.H"
#include      "ldi.H"
#include   "Buffer.h"
#include   "txInst.H"
#include   "txData.H"
#include    "txFac.H"
#include "resource.h"
#include    "FSStg.h"
#include "Protocol.h"
#ifdef _DEBUG
#define SPEW_DEBUG(x) {\
						char acTemp_Debug[256];\
						wsprintf(acTemp_Debug,"Spew: %s Function: %s Line %d\n",__FILE__,x,__LINE__);\
						OutputDebugString(acTemp_Debug); }								
#endif

#ifndef CP_UTF8

#define CP_UTF8		65001 

#endif // CP_UTF8
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\storage.cpp ===
// Storage.cpp -- Implementation of class CStorage

#include "stdafx.h"


DEBUGDEF(LONG   CStorage::  CImpIStorage::s_cInCriticalSection = 0)
DEBUGDEF(LONG CFSStorage::CImpIFSStorage::s_cInCriticalSection = 0)

HRESULT STDMETHODCALLTYPE CopyStorage(IStorage *pStgDest, IStorage *pStgSrc, 
                                      BOOL fCopyStorages, BOOL fCopyStreams
                                     )
{
    HRESULT hr = NO_ERROR;

    IEnumSTATSTG *pEnumStatStg = NULL;
    
    hr = pStgSrc->EnumElements(0, NULL, 0, &pEnumStatStg);

    if (hr != S_OK) return hr;

    typedef struct _NameList
    {
        struct _NameList *pNextName;
        const  WCHAR     *pStorageName;
    
    } NameList, *PNameList;

    NameList *pNLHead = NULL;

    const WCHAR *pwcsItem = NULL;

    for (; ;)
    {
        STATSTG statstg;
        ULONG cElts;

        hr = pEnumStatStg->Next(1, &statstg, &cElts);

        if (hr == S_FALSE) break;

        if (hr == S_OK && cElts != 1)
            hr = STG_E_UNKNOWN;

        if (hr != S_OK) break;

        IStream *pStrmDest = NULL,
                *pStrmSrc  = NULL;

        pwcsItem = (const WCHAR *) statstg.pwcsName;
        
        switch(statstg.type)
        {
        case STGTY_STORAGE:
            
            if (!fCopyStorages) break;
            
            {
                PNameList pNL = New NameList;

                pNL->pNextName = pNLHead;
                pNL->pStorageName = pwcsItem;

                pwcsItem = NULL;

                pNLHead = pNL;
            }

            break;

        case STGTY_STREAM:

            if (!fCopyStreams) break;
            
            hr = pStgDest->CreateStream(pwcsItem, 
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE 
                                                       | STGM_CREATE,
                                        0, 0, &pStrmDest
                                       );

            if (hr != S_OK) break;

            hr = pStgSrc->OpenStream(pwcsItem, NULL, STGM_READ | STGM_SHARE_DENY_NONE,
                                     0, &pStrmSrc
                                    );

            if (hr != S_OK) break;

            hr = pStrmSrc->CopyTo(pStrmDest, statstg.cbSize, NULL, NULL);

            break;

        case STGTY_LOCKBYTES:
        case STGTY_PROPERTY:
        default: 
            hr = STG_E_UNKNOWN;

            break;
        }

        if (pwcsItem)
        {
            OLEHeap()->Free((void *) pwcsItem);
            pwcsItem = NULL;
        }

        if (pStrmDest)
        {
            pStrmDest->Release();
            pStrmDest = NULL;
        }

        if (pStrmSrc)
        {
            pStrmSrc->Release();
            pStrmSrc = NULL;
        }

        if (hr != S_OK) break;
    }

    pEnumStatStg->Release();
    pEnumStatStg = NULL;
    
    RonM_ASSERT(hr != S_OK);

    if (hr == S_FALSE)
        hr = S_OK;

    for (;;)
    {
        PNameList pNL = pNLHead;

        if (!pNL) break;

        pNLHead = pNL->pNextName;

        if (hr == S_OK)
        {
            IStorage *pStgChildDest = NULL,
                     *pStgChildSrc  = NULL;

            hr = pStgDest->CreateStorage(pNL->pStorageName, 
                                         STGM_READWRITE | STGM_SHARE_EXCLUSIVE 
                                                        | STGM_CREATE,
                                         0, 0, &pStgChildDest
                                        );

            if (hr == S_OK)
                hr = pStgSrc->OpenStorage(pNL->pStorageName, NULL, 
                                          STGM_READ | STGM_SHARE_DENY_NONE,
                                          NULL, 0, &pStgChildSrc
                                         );

            if (hr == S_OK)
                hr = CopyStorage(pStgChildDest, pStgChildSrc, fCopyStorages, fCopyStreams);

            if (pStgChildDest)
                pStgChildDest->Release();

            if (pStgChildSrc)
                pStgChildSrc->Release();
        }
        
        OLEHeap()->Free((void *) pNL->pStorageName);

        delete pNL;
    }

    return hr;
}

HRESULT __stdcall CStorage::OpenStorage(IUnknown *pUnkOuter, 
                                        IITFileSystem *pITFS,
                                        PathInfo *pPathInfo,
                                        DWORD grfMode,
                                        IStorageITEx **ppStg
                                       )
{
    CStorage *pstg = New CStorage(pUnkOuter);

    return FinishSetup(pstg? pstg->m_ImpIStorage.InitOpenStorage(pITFS, pPathInfo, grfMode)
                           : STG_E_INSUFFICIENTMEMORY,
                       pstg, IID_IStorageITEx, (PPVOID) ppStg
                      );
}


CStorage::CImpIStorage::CImpIStorage(CStorage *pBackObj, IUnknown *pUnkOuter)
        : IIT_IStorageITEx(pBackObj, pUnkOuter, this->m_PathInfo.awszStreamPath)
{
    m_pITFS       = NULL;
    m_grfMode     = 0;
    m_fWritable   = FALSE;

    ZeroMemory(&m_PathInfo, sizeof m_PathInfo);
}

HRESULT __stdcall CStorage::CImpIStorage::InitOpenStorage
                      (IITFileSystem *pITFS, PathInfo *pPathInfo, DWORD grfMode)
{
    pITFS->AddRef();

    m_pITFS     =  pITFS;
    m_PathInfo  = *pPathInfo;
    m_grfMode   =  grfMode;
    m_fWritable =  S_OK == m_pITFS->IsWriteable();

    m_pITFS->ConnectStorage(this);

    return NO_ERROR;
}


CStorage::CImpIStorage::~CImpIStorage(void)
{
    if (ActiveMark())
        MarkInactive();

    if (m_PathInfo.awszStreamPath[0] != L'/')
        m_pITFS->FSObjectReleased();

    m_pITFS->Release();   
}

// IUnknown methods:

STDMETHODIMP_(ULONG) CStorage::CImpIStorage::Release(void)
{
    // The actual work for the Release function is done by 
    // CImpITUnknown::Release() and ~CImpIStorage.
    //
    // We bracket that work as a critical section active storages
    // are kept in a linked list. A release operation may remove
    // this storage from that list, and we need to guard against
    // having someone find a reference to this storage just before
    // we destroy it.
    
    CSyncWith sw(g_csITFS);

    ULONG ulCnt = CImpITUnknown::Release();

    return ulCnt;
}

// IStorage methods:

HRESULT __stdcall CStorage::CImpIStorage::CreateStream( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved1,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    WCHAR awszNewBasePath[MAX_PATH];

    HRESULT hr= ResolvePath(awszNewBasePath, m_PathInfo.awszStreamPath, pwcsName, FALSE);

    if (SUCCEEDED(hr)) 
        hr = m_pITFS->CreateStream(NULL, awszNewBasePath, grfMode, (IStreamITEx **) ppstm);
	
    return hr;
}


/* [local] */ HRESULT __stdcall CStorage::CImpIStorage::OpenStream( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [unique][in] */ void __RPC_FAR *reserved1,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    return OpenStreamITEx(pwcsName, reserved1, grfMode, reserved2, (IStreamITEx **)ppstm);
}

HRESULT __stdcall CStorage::CImpIStorage::CreateStorage( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD dwStgFmt,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg)
{
    WCHAR awszNewBasePath[MAX_PATH];

    HRESULT hr= ResolvePath(awszNewBasePath, m_PathInfo.awszStreamPath, pwcsName, TRUE);

    if (SUCCEEDED(hr)) 
        hr = m_pITFS->CreateStorage(NULL, awszNewBasePath, grfMode, (IStorageITEx **) ppstg);
	
	RonM_ASSERT(IsUnlocked(g_csITFS));

    return hr;
}

HRESULT __stdcall CStorage::CImpIStorage::OpenStorage( 
    /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [unique][in] */ IStorage __RPC_FAR *pstgPriority,
    /* [in] */ DWORD grfMode,
    /* [unique][in] */ SNB snbExclude,
    /* [in] */ DWORD reserved,
    /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg)
{
    WCHAR awszNewBasePath[MAX_PATH];

    HRESULT hr= ResolvePath(awszNewBasePath, m_PathInfo.awszStreamPath, pwcsName, TRUE);

    if (SUCCEEDED(hr)) 
        hr = m_pITFS->OpenStorage(NULL, awszNewBasePath, grfMode, (IStorageITEx **) ppstg);

    RonM_ASSERT(IsUnlocked(g_csITFS));

	return hr;
}

BOOL CStorage::ValidStreamName(const WCHAR *pwcsName)
{
    UINT cwcName = wcsLen(pwcsName);

    if (!cwcName) 
        return FALSE;

    for (; cwcName--; )
    {
        WCHAR wc = *pwcsName++;

        if (wc < 0x20 || wc == L'<' 
                      || wc == L'>' 
                      || wc == L':' 
                      || wc == L'"'
                      || wc == L'|'
                      || wc == L'/'
                      || wc == L'\\'
           )
           return FALSE;  
    }

    return TRUE;
}


HRESULT __stdcall ResolvePath(PWCHAR pwcFullPath, const WCHAR *pwcBasePath,
                                                  const WCHAR *pwcRelativePath,
                                                  BOOL fStoragePath
                             )
{
    if (pwcBasePath[0] != 0)
        wcsCpy(pwcFullPath, pwcBasePath);
    else
        if (   (pwcRelativePath[0] == L'/' || pwcRelativePath[0] == L'\\')
            && (pwcRelativePath[1] == L'/' || pwcRelativePath[1] == L'\\')
           )
        {
            // This is a UNC path. We expect the syntax pattern //ServerName/
            
            wcsCpy(pwcFullPath, L"//");

            pwcRelativePath += 2;

            PWCHAR pwcDest = pwcFullPath + 2;

            // The code below copies across the server name.

            for (;;)
            {
                WCHAR wc = *pwcRelativePath++;

                if (wc == L'\\')
                    wc =  L'/';
                
                if (wc < 0x20 || wc == L'<' 
                              || wc == L'>' 
                              || wc == L':' 
                              || wc == L'"'
                              || wc == L'|'
                   )
                   return STG_E_INVALIDNAME;  // Invalid path character
                
                if (pwcDest - pwcFullPath > MAX_PATH - 2)
                    return STG_E_INVALIDNAME;
                
                *pwcDest++ = wc;
                
                // The code below rejects server names "." and ".."

                if (wc == L'/') 
                {
                    if (pwcDest[-2] == L'.')
                        if (    pwcDest[-3] == L'/' 
                            || (pwcDest[-3] == L'.' && pwcDest[-4] == L'/')
                           ) return STG_E_INVALIDNAME;
                    
                    break;
                }
            }

            *pwcDest= 0;
        }
        else
            if (    pwcRelativePath[0] 
                && Is_WC_Letter(pwcRelativePath[0]) 
                &&  pwcRelativePath[1] == L':'
                && (pwcRelativePath[2] == L'/' || pwcRelativePath[2] == L'\\')
               )
            {
                pwcFullPath[0] = pwcRelativePath[0];
                pwcFullPath[1] = L':';
                pwcFullPath[2] = L'/';
                pwcFullPath[3] = 0;

                pwcRelativePath += 3;
            }
            else
            {
                char aszCurrentDir[MAX_PATH];

                UINT cch = GetCurrentDirectory(MAX_PATH, aszCurrentDir);
            
                if (!cch)
                    return CFSLockBytes::CImpILockBytes::STGErrorFromFSError(GetLastError());

                UINT cwc = MultiByteToWideChar(GetACP(), MB_PRECOMPOSED | MB_ERR_INVALID_CHARS, 
                                               aszCurrentDir, lstrlenA(aszCurrentDir) + 1, 
                                               pwcFullPath, MAX_PATH
                                              );

                if (!cwc || cwc == MAX_PATH) 
                    return STG_E_INVALIDNAME;

                RonM_ASSERT(cwc >= 2 && pwcFullPath[cwc - 2] != L'/' 
                                     && pwcFullPath[cwc - 2] != L'\\');

                pwcFullPath[cwc - 1] = L'/';
                pwcFullPath[cwc    ] = 0;
            
                PWCHAR pwc = pwcFullPath + --cwc;
            
                for (; cwc--; )
                {
                    WCHAR wc = *--pwc;

                    if (wc == L'\\') 
                        *pwc = L'/';
                }
            }

    RonM_ASSERT(pwcFullPath[0] != 0);

    PWCHAR pwcBase = pwcFullPath;

    if (   (pwcBase[0] == L'/' && pwcBase[1] == L'/')
        || (pwcBase[0] == L':' && pwcBase[1] == L':')
       )
        for (pwcBase += 2; L'/' != *pwcBase++; )
            RonM_ASSERT(pwcBase[-1]);
    else
        if (Is_WC_Letter(pwcBase[0]) && pwcBase[1] == L':' && pwcBase[2] == L'/')
            pwcBase += 3;
        else pwcBase++;

    RonM_ASSERT(pwcBase[-1] == L'/');
    
    WCHAR wcFirst = *pwcRelativePath;

    if (wcFirst == L'/' || wcFirst == L'\\')
    {
        if (*pwcFullPath == L':')
            return STG_E_INVALIDNAME;
        
        *pwcBase = 0; 
        ++pwcRelativePath;
    }

    PWCHAR pwcNext= pwcFullPath + wcsLen(pwcFullPath);

    for (;;)
    {
        WCHAR wc= *pwcRelativePath++;

        if (wc == L'\\')
            wc =  L'/';

        if (!wc || wc == L'/')
        {
            RonM_ASSERT(pwcNext >= pwcBase); // We start with at least "/" and
                                             // never go shorter than that.
            WCHAR wcLast = pwcNext[-1];
            
            if (wcLast == L'/')
            {
                if (!wc)
                    break;

                else return STG_E_INVALIDNAME;  // Empty storage name
            }

            if (wcLast == L'.')
            {
                RonM_ASSERT(pwcNext > pwcBase); // Must be at least "/."

                WCHAR wcNextToLast= pwcNext[-2];

                if (wcNextToLast == L'/')
                {
                    // We've found the pattern "<prefix>/./" which we convert to
                    // "<prefix>/".
                    
                    pwcNext--; 

                    continue;
                }

                if (wcNextToLast == L'.')
                {
                    RonM_ASSERT(pwcNext > pwcBase + 1); // Must be at least "/.."

                    if (pwcNext[-3] == L'/')
                    {
                        // We've found the pattern "<prefix>/<StorageName>/../"
                        // which we convert to "<prefix>/".

                        // We don't allow this for paths beginning with ":".
                        // Those are system paths. For example --
                        //
                        // ::Transform/{200EAF82-9006-11d0-9E15-00A0C922E6EC}/InstanceData/

                        if (*pwcFullPath == L':')
                            return STG_E_INVALIDNAME;

                        // We must verify that we don't have "/../"

                        if (pwcNext == pwcBase + 2) // Can't back up beyond root!
                            return STG_E_INVALIDNAME;

                        for (pwcNext-= 4; *pwcNext != L'/'; pwcNext--);

                        ++pwcNext;

                        continue;
                    }
                }
            }
        
            if (wc || fStoragePath)  // Trailing null adds a "/" only when we're
                *pwcNext++ = L'/';  // constructing a directory path.

            if (pwcNext - pwcFullPath >= MAX_PATH) 
                return STG_E_INVALIDNAME; // BugBug: Really should be "path too long".

            if (!wc) 
                break;
            else continue;
        }

        if (wc < 0x20 || wc == L'<' 
                      || wc == L'>' 
                      || wc == L':' 
                      || wc == L'"'
                      || wc == L'|'
           )
           return STG_E_INVALIDNAME;  // Invalid path character

        *pwcNext++ = wc;

        if (pwcNext - pwcFullPath >= MAX_PATH) 
            return STG_E_INVALIDNAME; // BugBug: Really should be "path too long".
    }

    RonM_ASSERT(pwcNext > pwcFullPath);

    if (!fStoragePath && pwcNext[-1] == L'/')
        return STG_E_INVALIDNAME; // BugBug: Really should be "Not a valid stream name"

    *pwcNext= 0;

    return NOERROR;
}

HRESULT STGCopyTo(IStorage *pStgSrc, DWORD ciidExclude, const IID __RPC_FAR *rgiidExclude,
                  SNB snbExclude, IStorage __RPC_FAR *pstgDest
                 )
{
    if (snbExclude)
        return STG_E_UNIMPLEMENTEDFUNCTION;
    
    BOOL fCopyStorages = TRUE,
         fCopyStreams  = TRUE;

    for (; ciidExclude--; rgiidExclude++)
    {
        if (*rgiidExclude == IID_IStorage)
            fCopyStorages = FALSE;

        if (*rgiidExclude == IID_IStream)
            fCopyStreams = FALSE;
    }

    return CopyStorage(pstgDest, pStgSrc, fCopyStorages, fCopyStreams);
}

HRESULT __stdcall CStorage::CImpIStorage::CopyTo( 
    /* [in] */ DWORD ciidExclude,
    /* [size_is][unique][in] */ const IID __RPC_FAR *rgiidExclude,
    /* [unique][in] */ SNB snbExclude,
    /* [unique][in] */ IStorage __RPC_FAR *pstgDest)
{
    return STGCopyTo((IStorage *) this, ciidExclude, rgiidExclude, snbExclude, pstgDest);
}


HRESULT __stdcall CStorage::CImpIStorage::MoveElementTo( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [unique][in] */ IStorage __RPC_FAR *pstgDest,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName,
    /* [in] */ DWORD grfFlags)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT __stdcall CStorage::CImpIStorage::Commit( 
    /* [in] */ DWORD grfCommitFlags)
{
    return S_OK;
}


HRESULT __stdcall CStorage::CImpIStorage::Revert( void)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT __stdcall CStorage::CImpIStorage::EnumElements
                    (DWORD reserved1, void __RPC_FAR *reserved2,
                     DWORD reserved3, 
                     IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum
                    )
{
    return CEnumStorage::NewEnumStorage(NULL, m_pITFS, &m_PathInfo, ppenum);
}


HRESULT __stdcall CStorage::CImpIStorage::DestroyElement( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName)
{
    WCHAR awszNewBasePath[MAX_PATH];

	// The call to ResolvePath combines pwcsName with the base path string
	// associated with this storage. It will also force a trailing L'/' character.

    HRESULT hr= ResolvePath(awszNewBasePath, m_PathInfo.awszStreamPath, pwcsName, TRUE);

    if (SUCCEEDED(hr))
	{
		UINT cwc = lstrlenW(awszNewBasePath);

		// Now we're going to delete the trailing '/' character to meet
		// the needs of the DeleteItem method.
		
		RonM_ASSERT(cwc > 0);
		RonM_ASSERT(awszNewBasePath[cwc-1] == L'/');
		awszNewBasePath[cwc-1] = 0;

		hr = m_pITFS->DeleteItem(awszNewBasePath);
	}

	return hr;
}

HRESULT __stdcall CStorage::CImpIStorage::RenameElement( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsOldName,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName)
{
    WCHAR awszOldBasePath[MAX_PATH];
    WCHAR awszNewBasePath[MAX_PATH];

	// The calls to ResolvePath combine pwcsOldName and pwcsNewName with the base path string
	// associated with this storage. It will also force a trailing L'/' character.

    HRESULT hr = ResolvePath(awszOldBasePath, m_PathInfo.awszStreamPath, pwcsOldName, TRUE);

    if (SUCCEEDED(hr))
        hr = ResolvePath(awszNewBasePath, m_PathInfo.awszStreamPath, pwcsNewName, TRUE);

    if (SUCCEEDED(hr))
	{
		// Now we're going to delete the trailing '/' characters to meet
		// the needs of the RenameItem method.
		
		UINT cwc = lstrlenW(awszOldBasePath);

		RonM_ASSERT(cwc > 0);
		RonM_ASSERT(awszOldBasePath[cwc-1] == L'/');

		awszOldBasePath[cwc-1] = 0;

		cwc = lstrlenW(awszNewBasePath);

		RonM_ASSERT(cwc > 0);
		RonM_ASSERT(awszNewBasePath[cwc-1] == L'/');

		awszNewBasePath[cwc-1] = 0;

        hr = m_pITFS->RenameItem(awszOldBasePath, awszNewBasePath);
    }

    return hr;
}


HRESULT __stdcall CStorage::CImpIStorage::SetElementTimes( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ const FILETIME __RPC_FAR *pctime,
    /* [in] */ const FILETIME __RPC_FAR *patime,
    /* [in] */ const FILETIME __RPC_FAR *pmtime)
{
    if (   m_PathInfo.cwcStreamPath     != 1 
        && m_PathInfo.awszStreamPath[0] != L'/'
        && S_OK != m_pITFS->SetITFSTimes(pctime, patime, pmtime)
       ) 
        return NO_ERROR;

    return STG_E_UNIMPLEMENTEDFUNCTION;
}


HRESULT __stdcall CStorage::CImpIStorage::SetClass( 
    /* [in] */ REFCLSID clsid)
{
    m_PathInfo.clsidStorage = clsid;

    return m_pITFS->UpdatePathInfo(&m_PathInfo);
}


HRESULT __stdcall CStorage::CImpIStorage::SetStateBits( 
    /* [in] */ DWORD grfStateBits,
    /* [in] */ DWORD grfMask)
{
    m_PathInfo.uStateBits = (m_PathInfo.uStateBits & ~grfMask) | grfStateBits;
    
    return m_pITFS->UpdatePathInfo(&m_PathInfo);
}


HRESULT __stdcall CStorage::CImpIStorage::Stat( 
    /* [out] */ STATSTG __RPC_FAR *pstatstg,
    /* [in] */ DWORD grfStatFlag)
{
    pstatstg->type              = STGTY_STORAGE;
    pstatstg->cbSize.LowPart    = 0;
    pstatstg->cbSize.HighPart   = 0;
    pstatstg->grfMode           = m_grfMode;
    pstatstg->grfLocksSupported = 0;
    pstatstg->clsid             = m_PathInfo.clsidStorage;
    pstatstg->grfStateBits      = m_PathInfo.uStateBits;
    pstatstg->reserved          = 0;

    if (   m_PathInfo.cwcStreamPath     != 1 
        || m_PathInfo.awszStreamPath[0] != L'/'
        || S_OK != m_pITFS->GetITFSTimes(&(pstatstg->ctime), 
                                         &(pstatstg->atime), 
                                         &(pstatstg->mtime)
                                        )
       )
    {
        pstatstg->mtime.dwLowDateTime = 0;
        pstatstg->ctime.dwLowDateTime = 0;
        pstatstg->atime.dwLowDateTime = 0;

        pstatstg->mtime.dwHighDateTime = 0;
        pstatstg->ctime.dwHighDateTime = 0;
        pstatstg->atime.dwHighDateTime = 0;
    }

    if (grfStatFlag == STATFLAG_NONAME)
        pstatstg->pwcsName = NULL;
    else
    {
        UINT cb = sizeof(WCHAR) * (m_PathInfo.cwcStreamPath + 1);

        pstatstg->pwcsName = PWCHAR(OLEHeap()->Alloc(cb));

        if (!pstatstg->pwcsName)
            return STG_E_INSUFFICIENTMEMORY;

        CopyMemory(pstatstg->pwcsName, m_PathInfo.awszStreamPath, cb); 
    }

    return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CStorage::CImpIStorage::GetCheckSum(ULARGE_INTEGER *puli)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CStorage::CImpIStorage::CreateStreamITEx
    (const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
     DWORD grfMode, DWORD reserved1, DWORD reserved2, 
     IStreamITEx ** ppstm
    )
{
    WCHAR awszNewBasePath[MAX_PATH];

    HRESULT hr= ResolvePath(awszNewBasePath, m_PathInfo.awszStreamPath, pwcsName, FALSE);

    if (SUCCEEDED(hr)) 
        hr = m_pITFS->CreateStream(NULL, awszNewBasePath, pwcsDataSpaceName, grfMode, ppstm);

    return hr;
}


HRESULT STDMETHODCALLTYPE CStorage::CImpIStorage::OpenStreamITEx
    (const OLECHAR * pwcsName, void * reserved1, DWORD grfMode, 
     DWORD reserved2, IStreamITEx ** ppstm
    )
{
    WCHAR awszNewBasePath[MAX_PATH];

    HRESULT hr= ResolvePath(awszNewBasePath, m_PathInfo.awszStreamPath, pwcsName, FALSE);

    if (SUCCEEDED(hr)) 
        hr = m_pITFS->OpenStream(NULL, awszNewBasePath, grfMode, ppstm);
    
    return hr;
}

HRESULT __stdcall CFSStorage::CreateStorage
        (IUnknown *pUnkOuter, const WCHAR *pwcsPath, DWORD grfMode,
         IStorage **ppStg
        )
{
    CSyncWith sw(g_csITFS);
    
    IStorage *pStorage = (IStorage *) CImpIFSStorage::FindStorage(pwcsPath, grfMode);

    if (pStorage) 
    {
        pStorage->Release();

        return STG_E_INUSE;
    }

    CFSStorage *pstg = New CFSStorage(pUnkOuter);

    return FinishSetup(pstg? pstg->m_ImpIFSStorage.InitCreateStorage(pwcsPath, grfMode)
                           : STG_E_INSUFFICIENTMEMORY,
                       pstg, IID_IStorage, (PPVOID) ppStg
                      );
}


HRESULT __stdcall CFSStorage::OpenStorage
        (IUnknown *pUnkOuter, const WCHAR *pwcsPath, DWORD grfMode,
         IStorage **ppStg
        )
{
    CSyncWith sw(g_csITFS);

    IStorage *pStorage = CImpIFSStorage::FindStorage(pwcsPath, grfMode);

    if (pStorage) 
    {
        *ppStg = pStorage;

        return NO_ERROR;
    }

    CFSStorage *pstg = New CFSStorage(pUnkOuter);

    return FinishSetup(pstg? pstg->m_ImpIFSStorage.InitOpenStorage(pwcsPath, grfMode)
                           : STG_E_INSUFFICIENTMEMORY,
                       pstg, IID_IStorage, (PPVOID) ppStg
                      );
}


CFSStorage::CImpIFSStorage::CImpIFSStorage(CFSStorage *pBackObj, IUnknown *punkOuter)
        : IIT_IStorage(pBackObj, punkOuter, this->m_awcsPath)
{
    m_awcsPath[0] = 0;

    m_CP = GetACP();
}

CFSStorage::CImpIFSStorage::~CImpIFSStorage(void)
{
    if (ActiveMark())
        MarkInactive();
}


IStorage *CFSStorage::CImpIFSStorage::FindStorage(const WCHAR * pwszFileName, DWORD grfMode)
{
    for (CImpITUnknown *pStg = g_pImpIFSStorageList;
         pStg;
         pStg = pStg->NextObject()
        )
        if (((CImpIFSStorage *)pStg)->IsNamed(pwszFileName))
        {
             pStg->AddRef();

             return (IStorage *) pStg;
        }
        
    return NULL;     
}

HRESULT __stdcall BuildMultiBytePath(UINT codepage, PCHAR pszPath, PWCHAR pwcsPath)
{
    UINT cb = WideCharToMultiByte(codepage, WC_COMPOSITECHECK, pwcsPath, 
                                  wcsLen(pwcsPath) + 1, pszPath, MAX_PATH * 2, 
                                  NULL, NULL
                                 );

    if (cb == 0)
    {
        UINT uLastError = GetLastError();

        switch(uLastError)
        {
        case ERROR_INSUFFICIENT_BUFFER:
        case ERROR_INVALID_FLAGS:
        case ERROR_INVALID_PARAMETER:

            return STG_E_INVALIDPARAMETER;
        
        default:

            return STG_E_UNKNOWN;
        }
    }

    return NO_ERROR;
}    

HRESULT __stdcall CFSStorage::CImpIFSStorage::InitCreateStorage(const WCHAR *pwcsPath, DWORD grfMode)
{
    HRESULT hr = ResolvePath(m_awcsPath, m_awcsPath, pwcsPath, TRUE);

    if (!SUCCEEDED(hr)) 
        return hr;

    char achFullPath[MAX_PATH * 2];

    hr = BuildMultiBytePath(m_CP, achFullPath, m_awcsPath);

    if (!SUCCEEDED(hr)) 
        return hr;

    if (CreateDirectory(achFullPath, NULL))
        hr = NO_ERROR; 
    else
        hr = CFSLockBytes::CImpILockBytes::STGErrorFromFSError(GetLastError());

    if (hr == S_OK)
        MarkActive(g_pImpIFSStorageList);

    return hr;
}

HRESULT __stdcall CFSStorage::CImpIFSStorage::InitOpenStorage  (const WCHAR *pwcsPath, DWORD grfMode)
{
    HRESULT hr = ResolvePath(m_awcsPath, m_awcsPath, pwcsPath, TRUE);

    if (!SUCCEEDED(hr)) 
        return hr;

    char achFullPath[MAX_PATH * 2];

    hr = BuildMultiBytePath(m_CP, achFullPath, m_awcsPath);

    if (!SUCCEEDED(hr)) 
        return hr;

    WIN32_FIND_DATA fd;
    
    HANDLE hFind = FindFirstFile(achFullPath, &fd);
    
    if (hFind == INVALID_HANDLE_VALUE)
        return CFSLockBytes::CImpILockBytes::STGErrorFromFSError(GetLastError());

    FindClose(hFind);

    if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        MarkActive(g_pImpIFSStorageList);

        return NO_ERROR;
    }
    else 
        return STG_E_INVALIDNAME;
}


// IUnknown methods:

STDMETHODIMP_(ULONG) CFSStorage::CImpIFSStorage::Release(void)
{
    // The actual work for the Release function is done by 
    // CImpITUnknown::Release() and ~CImpIStorage.
    //
    // We bracket that work as a critical section active storages
    // are kept in a linked list. A release operation may remove
    // this storage from that list, and we need to guard against
    // having someone find a reference to this storage just before
    // we destroy it.
    
    CSyncWith sw(g_csITFS);

    ULONG ulCnt = CImpITUnknown::Release();

    return ulCnt;
}


// IStorage methods:

HRESULT __stdcall CFSStorage::CImpIFSStorage::CreateStream( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved1,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    WCHAR awcsStreamPath[MAX_PATH];
    
    wcsCpy(awcsStreamPath, m_awcsPath);

    HRESULT hr = ResolvePath(awcsStreamPath, m_awcsPath, pwcsName, FALSE);

    if (!SUCCEEDED(hr)) 
        return hr;
    
    ILockBytes *pLKB = NULL;

    hr = CFSLockBytes::Create(NULL, awcsStreamPath, grfMode, &pLKB);

    if (hr == S_OK)
    {
        hr = CStream::OpenStream(NULL, pLKB, grfMode, (IStreamITEx **) ppstm);

        if (hr != S_OK) 
            pLKB->Release();
    }

	RonM_ASSERT(IsUnlocked(g_csITFS));

    return hr;
}


/* [local] */ HRESULT __stdcall CFSStorage::CImpIFSStorage::OpenStream( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [unique][in] */ void __RPC_FAR *reserved1,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    WCHAR awcsStreamPath[MAX_PATH];
    
    wcsCpy(awcsStreamPath, m_awcsPath);

    HRESULT hr = ResolvePath(awcsStreamPath, m_awcsPath, pwcsName, FALSE);

    if (!SUCCEEDED(hr)) 
        return hr;
    
    ILockBytes *pLKB = NULL;

    hr = CFSLockBytes::Open(NULL, awcsStreamPath, grfMode, &pLKB);

    if (hr == S_OK)
    {
        hr = CStream::OpenStream(NULL, pLKB, grfMode, (IStreamITEx **) ppstm);

        if (hr != S_OK) 
            pLKB->Release();
    }

	RonM_ASSERT(IsUnlocked(g_csITFS));

    return hr;
}


HRESULT __stdcall CFSStorage::CImpIFSStorage::CreateStorage( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD dwStgFmt,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg)
{
    WCHAR awcsStreamPath[MAX_PATH];
    
    wcsCpy(awcsStreamPath, m_awcsPath);

    HRESULT hr = ResolvePath(awcsStreamPath, m_awcsPath, pwcsName, TRUE);

    if (!SUCCEEDED(hr)) 
        return hr;
    
    hr = CFSStorage::CreateStorage(NULL, (const WCHAR *)awcsStreamPath, grfMode, ppstg);

	RonM_ASSERT(IsUnlocked(g_csITFS));

	return hr;
}


HRESULT __stdcall CFSStorage::CImpIFSStorage::OpenStorage( 
    /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [unique][in] */ IStorage __RPC_FAR *pstgPriority,
    /* [in] */ DWORD grfMode,
    /* [unique][in] */ SNB snbExclude,
    /* [in] */ DWORD reserved,
    /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg)
{
    WCHAR awcsStreamPath[MAX_PATH];
    
    wcsCpy(awcsStreamPath, m_awcsPath);

    HRESULT hr = ResolvePath(awcsStreamPath, m_awcsPath, pwcsName, TRUE);

    if (!SUCCEEDED(hr)) 
        return hr;
    
    hr = CFSStorage::OpenStorage(NULL, (const WCHAR *)awcsStreamPath, grfMode, ppstg);

	RonM_ASSERT(IsUnlocked(g_csITFS));

	return hr;
}


HRESULT __stdcall CFSStorage::CImpIFSStorage::CopyTo( 
    /* [in] */ DWORD ciidExclude,
    /* [size_is][unique][in] */ const IID __RPC_FAR *rgiidExclude,
    /* [unique][in] */ SNB snbExclude,
    /* [unique][in] */ IStorage __RPC_FAR *pstgDest)
{
    return STGCopyTo((IStorage *) this, ciidExclude, rgiidExclude, snbExclude, pstgDest);
}


HRESULT __stdcall CFSStorage::CImpIFSStorage::MoveElementTo( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [unique][in] */ IStorage __RPC_FAR *pstgDest,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName,
    /* [in] */ DWORD grfFlags)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}


HRESULT __stdcall CFSStorage::CImpIFSStorage::Commit( 
    /* [in] */ DWORD grfCommitFlags)
{
    return NO_ERROR;
}


HRESULT __stdcall CFSStorage::CImpIFSStorage::Revert( void)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}


/* [local] */ HRESULT __stdcall CFSStorage::CImpIFSStorage::EnumElements( 
    /* [in] */ DWORD reserved1,
    /* [size_is][unique][in] */ void __RPC_FAR *reserved2,
    /* [in] */ DWORD reserved3,
    /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum)
{
    return CFSEnumStorage::NewEnumStorage(NULL, (CONST WCHAR *) m_awcsPath, ppenum);
}


HRESULT __stdcall CFSStorage::CImpIFSStorage::DestroyElement( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}


HRESULT __stdcall CFSStorage::CImpIFSStorage::RenameElement( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsOldName,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}


HRESULT __stdcall CFSStorage::CImpIFSStorage::SetElementTimes( 
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ const FILETIME __RPC_FAR *pctime,
    /* [in] */ const FILETIME __RPC_FAR *patime,
    /* [in] */ const FILETIME __RPC_FAR *pmtime)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}


HRESULT __stdcall CFSStorage::CImpIFSStorage::SetClass( 
    /* [in] */ REFCLSID clsid)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}


HRESULT __stdcall CFSStorage::CImpIFSStorage::SetStateBits( 
    /* [in] */ DWORD grfStateBits,
    /* [in] */ DWORD grfMask)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}


HRESULT __stdcall CFSStorage::CImpIFSStorage::Stat( 
    /* [out] */ STATSTG __RPC_FAR *pstatstg,
    /* [in] */ DWORD grfStatFlag)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}

HRESULT CFSStorage::CImpIFSStorage::CFSEnumStorage::NewEnumStorage
    (IUnknown *pUnkOuter, CONST WCHAR *pwcsPath, IEnumSTATSTG **ppEnumSTATSTG)
{
    CFSEnumStorage *pEnumContainer = New CFSEnumStorage(pUnkOuter);
    
    return FinishSetup(pEnumContainer? pEnumContainer->m_ImpIEnumStorage.Initial(pwcsPath)
                                     : STG_E_INSUFFICIENTMEMORY,
                       pEnumContainer, IID_IEnumSTATSTG, (PPVOID) ppEnumSTATSTG
                      );
}

CFSStorage::CImpIFSStorage::CFSEnumStorage::CImpIEnumStorage::CImpIEnumStorage
    (CFSEnumStorage *pBackObj, IUnknown *punkOuter)
    : IITEnumSTATSTG(pBackObj, punkOuter)
{
    m_State = Before;
    m_hEnum = INVALID_HANDLE_VALUE;
}

CFSStorage::CImpIFSStorage::CFSEnumStorage::CImpIEnumStorage::~CImpIEnumStorage(void)
{
    if (m_hEnum != INVALID_HANDLE_VALUE)
        FindClose(m_hEnum);
}

HRESULT CFSStorage::CImpIFSStorage::CFSEnumStorage::CImpIEnumStorage::Initial(CONST WCHAR *pwcsPath)
{
    RonM_ASSERT(m_State == Before);
    RonM_ASSERT(m_hEnum == INVALID_HANDLE_VALUE);
    
    UINT cwc = lstrlenW(pwcsPath);
    
    if (!cwc || pwcsPath[cwc-1] != L'/' || cwc + 1 >= MAX_PATH)
        return STG_E_INVALIDNAME;

    wcsCpy(m_awszBasePath, pwcsPath);
    wcsCat(m_awszBasePath, L"*");

    return NO_ERROR;
}

// IEnumSTATSTG methods:
		
/* [local] */ HRESULT __stdcall CFSStorage::CImpIFSStorage::CFSEnumStorage::CImpIEnumStorage::Next
    ( 
    /* [in] */ ULONG celt,
    /* [in] */ STATSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr = S_OK;

    UINT celtFetched = 0;

    for (; celt--; rgelt++)
    {
        hr = NextEntry();

        if (hr != S_OK) break;

        WCHAR awcsBuffer[MAX_PATH];

        UINT cwc = MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, 
                                       m_w32fd.cFileName, lstrlen(m_w32fd.cFileName) + 1, 
                                       awcsBuffer, MAX_PATH
                                      );

        if (!cwc) 
        {
            hr = STG_E_UNKNOWN;

            break;
        }

        PWCHAR pwcDest = PWCHAR(OLEHeap()->Alloc(cwc * sizeof(WCHAR)));

        if (!pwcDest)
        {
            hr = STG_E_INSUFFICIENTMEMORY;

            break;
        }

        CopyMemory(pwcDest, awcsBuffer, cwc * sizeof(WCHAR));

        BOOL fStorage = (m_w32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);

        rgelt->pwcsName             = pwcDest;  pwcDest = NULL;
        rgelt->type                 = fStorage? STGTY_STORAGE : STGTY_STREAM;
        rgelt->cbSize.LowPart       = m_w32fd.nFileSizeLow;
        rgelt->cbSize.HighPart      = m_w32fd.nFileSizeHigh;
        rgelt->mtime.dwLowDateTime  = m_w32fd.ftLastWriteTime.dwLowDateTime;
        rgelt->mtime.dwHighDateTime = m_w32fd.ftLastWriteTime.dwHighDateTime;
        rgelt->ctime.dwLowDateTime  = m_w32fd.ftCreationTime.dwLowDateTime;
        rgelt->ctime.dwHighDateTime = m_w32fd.ftCreationTime.dwHighDateTime;
        rgelt->atime.dwLowDateTime  = m_w32fd.ftLastAccessTime.dwLowDateTime;
        rgelt->atime.dwHighDateTime = m_w32fd.ftLastAccessTime.dwHighDateTime;
        rgelt->grfMode              = 0;
        rgelt->grfLocksSupported    = 0;
        rgelt->clsid                = CLSID_NULL;
        rgelt->grfStateBits         = 0;
        rgelt->reserved             = 0;

        celtFetched++;
    }

    if (pceltFetched)
       *pceltFetched = celtFetched;

    return hr;
}

HRESULT __stdcall CFSStorage::CImpIFSStorage::CFSEnumStorage::CImpIEnumStorage::Skip(ULONG celt)
{
    HRESULT hr = S_OK;

    for (; celt--; )
    {
        hr = NextEntry();

        if (hr != S_OK) break;
    }

    return hr;
}

HRESULT __stdcall CFSStorage::CImpIFSStorage::CFSEnumStorage::CImpIEnumStorage::Reset( void)
{
    if (m_hEnum != INVALID_HANDLE_VALUE)
    {
        FindClose(m_hEnum);
        m_hEnum = INVALID_HANDLE_VALUE;
    }

    m_State = Before;

    return NO_ERROR;
}

HRESULT __stdcall CFSStorage::CImpIFSStorage::CFSEnumStorage::CImpIEnumStorage::Clone
    ( 
    /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}

HRESULT	STDMETHODCALLTYPE CFSStorage::CImpIFSStorage::CFSEnumStorage::CImpIEnumStorage::GetNextEntryInSeq
    (ULONG celt, PathInfo *rgelt, ULONG   *pceltFetched)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}

HRESULT	STDMETHODCALLTYPE CFSStorage::CImpIFSStorage::CFSEnumStorage::CImpIEnumStorage::GetFirstEntryInSeq
    (PathInfo *rgelt)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CFSStorage::CImpIFSStorage::CFSEnumStorage::CImpIEnumStorage::NextEntry()
{
    HRESULT hr = S_OK;

    switch(m_State)
    {
    case Before:

        {
            char aszBuffer[MAX_PATH * 2];

            UINT cb = WideCharToMultiByte(GetACP(), WC_COMPOSITECHECK | WC_DEFAULTCHAR, 
                                          m_awszBasePath, lstrlenW(m_awszBasePath) + 1,
                                          aszBuffer, MAX_PATH * 2, NULL, NULL
                                         );

            if (!cb) return STG_E_UNKNOWN;

            m_hEnum = FindFirstFile(aszBuffer, &m_w32fd);

            if (m_hEnum == INVALID_HANDLE_VALUE)
                return STG_E_INVALIDNAME;

            m_State = During;

            // For the Win32 file system the first two entries returned by
            // FindFirstFile/FindNextFile will always be "." and "..". So we
            // must skip over those items.

            RonM_ASSERT(!lstrcmp(m_w32fd.cFileName, "."));

            NextEntry();
            
            RonM_ASSERT(!lstrcmp(m_w32fd.cFileName, ".."));

            return NextEntry(); // To get the first real enumeration name.
        }

    case During:

        RonM_ASSERT(m_hEnum != INVALID_HANDLE_VALUE);

        if (FindNextFile(m_hEnum, &m_w32fd))
            return NO_ERROR;
        
        if (GetLastError() == ERROR_NO_MORE_FILES)
        {
            m_State = After;

            return S_FALSE;
        }

    case After:
        return S_FALSE;

    default:
        return STG_E_UNKNOWN;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\storage.h ===
// Storage.h -- Definition of class CStorage

#ifndef __STORAGE_H__

#define __STORAGE_H__

class CStorage : public CITUnknown
{

public:

    static HRESULT __stdcall OpenStorage(IUnknown *pUnkOuter, 
                                         IITFileSystem *pITFS,
                                         PathInfo *pPathInfo,
                                         DWORD grfMode,
                                         IStorageITEx **ppStg
                                        );

    static BOOL ValidStreamName(const WCHAR *pwcsName);

    ~CStorage(void);

    class CImpIStorage : public IIT_IStorageITEx
    {
    
    public:

        CImpIStorage(CStorage *pBackObj, IUnknown *punkOuter);
        ~CImpIStorage(void);

        static IStorage *FindStorage(const WCHAR * pwszFileName, DWORD grfMode);
    
        HRESULT __stdcall InitOpenStorage(IITFileSystem *pITFS, PathInfo *pPathInfo, 
                                                                DWORD grfMode);

        // IUnknown methods:

        STDMETHODIMP_(ULONG) Release(void);

        // IStorage methods:

        HRESULT __stdcall CreateStream( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved1,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);
        
        HRESULT __stdcall CreateStreamITEx( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [string][in] */  const WCHAR *pwcsDataSpaceName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved1,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStreamITEx __RPC_FAR *__RPC_FAR *ppstm);
        
        /* [local] */ HRESULT __stdcall OpenStream( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ void __RPC_FAR *reserved1,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);
        
        /* [local] */ HRESULT __stdcall OpenStreamITEx( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ void __RPC_FAR *reserved1,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStreamITEx __RPC_FAR *__RPC_FAR *ppstm);
        
        HRESULT __stdcall CreateStorage( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD dwStgFmt,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg);
        
        HRESULT __stdcall OpenStorage( 
            /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgPriority,
            /* [in] */ DWORD grfMode,
            /* [unique][in] */ SNB snbExclude,
            /* [in] */ DWORD reserved,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg);
        
        HRESULT __stdcall CopyTo( 
            /* [in] */ DWORD ciidExclude,
            /* [size_is][unique][in] */ const IID __RPC_FAR *rgiidExclude,
            /* [unique][in] */ SNB snbExclude,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest);
        
        HRESULT __stdcall MoveElementTo( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName,
            /* [in] */ DWORD grfFlags);
        
        HRESULT __stdcall Commit( 
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT __stdcall Revert( void);
        
        /* [local] */ HRESULT __stdcall EnumElements( 
            /* [in] */ DWORD reserved1,
            /* [size_is][unique][in] */ void __RPC_FAR *reserved2,
            /* [in] */ DWORD reserved3,
            /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT __stdcall DestroyElement( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName);
        
        HRESULT __stdcall RenameElement( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsOldName,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName);
        
        HRESULT __stdcall SetElementTimes( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ const FILETIME __RPC_FAR *pctime,
            /* [in] */ const FILETIME __RPC_FAR *patime,
            /* [in] */ const FILETIME __RPC_FAR *pmtime);
        
        HRESULT __stdcall SetClass( 
            /* [in] */ REFCLSID clsid);
        
        HRESULT __stdcall SetStateBits( 
            /* [in] */ DWORD grfStateBits,
            /* [in] */ DWORD grfMask);
        
        HRESULT __stdcall Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);

        // IStorageITEx methods

        HRESULT STDMETHODCALLTYPE GetCheckSum(ULARGE_INTEGER *puli);

        HRESULT STDMETHODCALLTYPE CreateStream
            (const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
             DWORD grfMode, DWORD reserved1, DWORD reserved2, 
             IStreamITEx ** ppstm
            );

        HRESULT STDMETHODCALLTYPE OpenStream
            (const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
             DWORD reserved2, IStreamITEx ** ppstm
            );

   private:

        enum  { MAX_KEY = MAX_UTF8_PATH + 5 };  // Extra bytes for leading pack-32  
                                                // name length value.
        IITFileSystem  *m_pITFS;     // File system which contains this storage
        PathInfo        m_PathInfo;  // Path for this storage together with location info
        DWORD           m_grfMode;   // Access permissions for this storage.
        BOOL            m_fWritable; // Can we write to this file system?

        DEBUGDEF(static LONG s_cInCriticalSection)
    };

private:

    CStorage(IUnknown *pUnkOuter);

    CImpIStorage  m_ImpIStorage;

};

extern GUID  aIID_CStorage[];
extern UINT cInterfaces_CStorage;

inline CStorage::CStorage(IUnknown *pUnkOuter)
               : m_ImpIStorage(this, pUnkOuter), 
                 CITUnknown(aIID_CStorage, cInterfaces_CStorage, (IUnknown *) &m_ImpIStorage)
{
}

inline CStorage::~CStorage(void)
{
}

typedef CStorage *PCStorage;

class CFSStorage : public CITUnknown
{

public:

    static HRESULT __stdcall CreateStorage
        (IUnknown *pUnkOuter, const WCHAR *pwcsPath, DWORD grfMode,
         IStorage **ppStg
        );

    static HRESULT __stdcall OpenStorage
        (IUnknown *pUnkOuter, const WCHAR *pwcsPath, DWORD grfMode,
         IStorage **ppStg
        );

    ~CFSStorage(void);

    class CImpIFSStorage : public IIT_IStorage
    {
    
    public:

        CImpIFSStorage(CFSStorage *pBackObj, IUnknown *punkOuter);
        ~CImpIFSStorage(void);

        static IStorage *FindStorage(const WCHAR * pwszFileName, DWORD grfMode);
    
        HRESULT __stdcall InitCreateStorage(const WCHAR *pwcsPath, DWORD grfMode);
        HRESULT __stdcall InitOpenStorage  (const WCHAR *pwcsPath, DWORD grfMode);

        // IUnknown methods:

        STDMETHODIMP_(ULONG) Release(void);

        // IStorage methods:

        HRESULT __stdcall CreateStream( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved1,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);
        
        /* [local] */ HRESULT __stdcall OpenStream( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ void __RPC_FAR *reserved1,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);
        
        HRESULT __stdcall CreateStorage( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD dwStgFmt,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg);
        
        HRESULT __stdcall OpenStorage( 
            /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgPriority,
            /* [in] */ DWORD grfMode,
            /* [unique][in] */ SNB snbExclude,
            /* [in] */ DWORD reserved,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg);
        
        HRESULT __stdcall CopyTo( 
            /* [in] */ DWORD ciidExclude,
            /* [size_is][unique][in] */ const IID __RPC_FAR *rgiidExclude,
            /* [unique][in] */ SNB snbExclude,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest);
        
        HRESULT __stdcall MoveElementTo( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName,
            /* [in] */ DWORD grfFlags);
        
        HRESULT __stdcall Commit( 
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT __stdcall Revert( void);
        
        /* [local] */ HRESULT __stdcall EnumElements( 
            /* [in] */ DWORD reserved1,
            /* [size_is][unique][in] */ void __RPC_FAR *reserved2,
            /* [in] */ DWORD reserved3,
            /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT __stdcall DestroyElement( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName);
        
        HRESULT __stdcall RenameElement( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsOldName,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName);
        
        HRESULT __stdcall SetElementTimes( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ const FILETIME __RPC_FAR *pctime,
            /* [in] */ const FILETIME __RPC_FAR *patime,
            /* [in] */ const FILETIME __RPC_FAR *pmtime);
        
        HRESULT __stdcall SetClass( 
            /* [in] */ REFCLSID clsid);
        
        HRESULT __stdcall SetStateBits( 
            /* [in] */ DWORD grfStateBits,
            /* [in] */ DWORD grfMask);
        
        HRESULT __stdcall Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);

   private:

        class CFSEnumStorage : public CITUnknown
        {

        public:

            static HRESULT NewEnumStorage
                             (IUnknown *pUnkOuter,
                              CONST WCHAR *pwcsPath, 
                              IEnumSTATSTG **ppEnumSTATSTG
                             );

            ~CFSEnumStorage(void);

        private:

            CFSEnumStorage(IUnknown *pUnkOuter);

            class CImpIEnumStorage : public IITEnumSTATSTG
            {
    
            public:

                CImpIEnumStorage(CFSEnumStorage *pBackObj, IUnknown *punkOuter);
                ~CImpIEnumStorage(void);

                HRESULT Initial(CONST WCHAR *pwcsPath);

                // IEnumSTATSTG methods:
				        
                /* [local] */ HRESULT __stdcall Next( 
                    /* [in] */ ULONG celt,
                    /* [in] */ STATSTG __RPC_FAR *rgelt,
                    /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
                HRESULT __stdcall Skip( 
                    /* [in] */ ULONG celt);
        
                HRESULT __stdcall Reset( void);
        
                HRESULT __stdcall Clone( 
                    /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);

	            HRESULT STDMETHODCALLTYPE GetNextEntryInSeq(/* [in] */ULONG celt,
					             /* [out] */ PathInfo *rgelt, 
					             /* [out] */ ULONG   *pceltFetched);
	            HRESULT	STDMETHODCALLTYPE GetFirstEntryInSeq(
	             /* [out] */ PathInfo *rgelt);

            private:

                HRESULT STDMETHODCALLTYPE NextEntry();

                enum  EnumState { Before, During, After };
        
                WCHAR           m_awszBasePath[MAX_PATH];
                HANDLE          m_hEnum;
                enum EnumState  m_State;
                WIN32_FIND_DATA m_w32fd;
            };

            CImpIEnumStorage  m_ImpIEnumStorage;
        };

        WCHAR    m_awcsPath[MAX_PATH]; // Path for this storage
        UINT     m_CP;                 // Default code page
        DWORD    m_grfMode;            // Access permissions for this storage.
        BOOL     m_fWritable;          // Can we write to this file system?

        DEBUGDEF(static LONG s_cInCriticalSection)
    };

private:

    CFSStorage(IUnknown *pUnkOuter);

    CImpIFSStorage  m_ImpIFSStorage;
};

inline CFSStorage::CFSStorage(IUnknown *pUnkOuter)
               : m_ImpIFSStorage(this, pUnkOuter), 
                 CITUnknown(&IID_IStorage, 1, (IUnknown *) &m_ImpIFSStorage)
{
}

inline CFSStorage::~CFSStorage(void)
{
}

inline CFSStorage::CImpIFSStorage::CFSEnumStorage::CFSEnumStorage(IUnknown *pUnkOuter) 
   : m_ImpIEnumStorage(this, pUnkOuter),
     CITUnknown(&IID_IEnumSTATSTG, 1, &m_ImpIEnumStorage)
{
}

inline CFSStorage::CImpIFSStorage::CFSEnumStorage::~CFSEnumStorage(void)
{
}

HRESULT __stdcall ResolvePath(PWCHAR pwcFullPath, const WCHAR *pwcBasePath,
                                                  const WCHAR *pwcRelativePath,
                                                  BOOL fStoragePath
                             );


HRESULT __stdcall BuildMultiBytePath(UINT codepage, PCHAR pszPath, PWCHAR pwcsPath);

typedef CFSStorage *PCFSStorage;

#endif // __STORAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\stream.cpp ===
// Stream.cpp -- Implementation for class CStream

#include "stdafx.h"


HRESULT CStream::OpenStream(IUnknown *punkOuter, ILockBytes *pLockBytes, DWORD grfMode,
                            IStreamITEx **ppStream
                           )
{
    CStream *pStream= New CStream(punkOuter);

    if (!pStream) 
    {
        pLockBytes->Release();
        
        return STG_E_INSUFFICIENTMEMORY;
    }

    IStreamITEx *pIStream = NULL;
    
    HRESULT hr= pStream->m_ImpIStream.InitOpenStream(pLockBytes, grfMode);

    if (hr == NOERROR) 
    {
        pIStream = (IStreamITEx *) &pStream->m_ImpIStream;
        pStream->AddRef();
    }
    else 
        delete pStream;

    *ppStream= pIStream;

    return hr;
}

HRESULT CStream::CImpIStream::InitOpenStream(ILockBytes *pLockBytes, DWORD grfMode)
{
    m_pLockBytes = pLockBytes;
    m_grfMode    = grfMode;

    // Note: We assume that pLockBytes was AddRef'd before it was given to us.

    return NO_ERROR;
}

// ISequentialStream methods:

HRESULT __stdcall CStream::CImpIStream::Read
                    (void __RPC_FAR *pv,ULONG cb,ULONG __RPC_FAR *pcbRead)
{
    DWORD grfAccess = m_grfMode & RW_ACCESS_MASK;

    if (grfAccess != STGM_READ && grfAccess != STGM_READWRITE)
        return STG_E_ACCESSDENIED;
    
    CSyncWith sw(m_cs);

    ULONG cbRead = 0;

    HRESULT hr = m_pLockBytes->ReadAt(m_ullStreamPosition.Uli(), pv, cb, &cbRead); 

    m_ullStreamPosition += cbRead;

    if (pcbRead)
        *pcbRead = cbRead;

    return hr;
}


HRESULT __stdcall CStream::CImpIStream::Write
                    (const void __RPC_FAR *pv, ULONG cb, 
                     ULONG __RPC_FAR *pcbWritten
                    )
{
    DWORD grfAccess = m_grfMode & RW_ACCESS_MASK;

    if (grfAccess != STGM_WRITE && grfAccess != STGM_READWRITE)
        return STG_E_ACCESSDENIED;
    
    CSyncWith sw(m_cs);

    ULONG cbWritten = 0;
    
    HRESULT hr = m_pLockBytes->WriteAt(m_ullStreamPosition.Uli(), pv, cb, &cbWritten); 

    m_ullStreamPosition += cbWritten;

    if (pcbWritten)
        *pcbWritten = cbWritten;

    return hr;
}

// IStream methods:

HRESULT __stdcall CStream::CImpIStream::Seek
                     (LARGE_INTEGER dlibMove, DWORD dwOrigin, 
                      ULARGE_INTEGER __RPC_FAR *plibNewPosition
                     )
{
    HRESULT hr = NO_ERROR;
    
    CSyncWith sw(m_cs);

    STATSTG statstg;

    hr = m_pLockBytes->Stat(&statstg, STATFLAG_NONAME);

    if (!SUCCEEDED(hr))
        return hr;

    CULINT ullNewPosition;

    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:

        ullNewPosition = *(ULARGE_INTEGER *) &dlibMove;

        break;

    case STREAM_SEEK_CUR:

        ullNewPosition = m_ullStreamPosition + *(ULARGE_INTEGER *) &dlibMove;

        break;

    case STREAM_SEEK_END:

        ullNewPosition = statstg.cbSize;
        ullNewPosition += *(ULARGE_INTEGER *) &dlibMove;
   
        break;

    default:

        return STG_E_INVALIDFUNCTION;
    }

    if (ullNewPosition > statstg.cbSize)
        return STG_E_INVALIDPOINTER;

    m_ullStreamPosition = ullNewPosition;

    if (plibNewPosition)
       *plibNewPosition = ullNewPosition.Uli();

    return hr;
}

HRESULT __stdcall CStream::CImpIStream::SetSize(ULARGE_INTEGER libNewSize)
{
    DWORD grfAccess = m_grfMode & RW_ACCESS_MASK;

    if (grfAccess != STGM_WRITE && grfAccess != STGM_READWRITE)
        return STG_E_ACCESSDENIED;
    
    return m_pLockBytes->SetSize(libNewSize);
}


HRESULT __stdcall CStream::CImpIStream::CopyTo
                     (IStream __RPC_FAR *pstm, ULARGE_INTEGER cb, 
                      ULARGE_INTEGER __RPC_FAR *pcbRead, 
                      ULARGE_INTEGER __RPC_FAR *pcbWritten
                     )
{
    BYTE abBuffer[CB_MAX_COPY_SEGMENT];

    CULINT ullRequested, ullRead(0), ullWritten(0);

    ullRequested = cb;

    HRESULT hr = NO_ERROR;

    CSyncWith sw(m_cs);

    ULONG ulSegment;

    for (; ullRequested.NonZero(); ullRequested -= ulSegment)
    {
        ulSegment = CB_MAX_COPY_SEGMENT;

        if (ulSegment > ullRequested)
            ulSegment = ullRequested.Uli().LowPart;

        ULONG cbRead = 0;

        hr = Read(abBuffer, ulSegment, &cbRead);

        ullRead += cbRead;

        if (!SUCCEEDED(hr))
            break;

        ULONG cbWritten = 0;

        hr = pstm->Write(abBuffer, ulSegment, &cbWritten);
        
        ullWritten += cbWritten;

        if (!SUCCEEDED(hr))
            break;
    }

    if (pcbRead)
        *pcbRead = ullRead.Uli();

    if (pcbWritten)
        *pcbWritten = ullWritten.Uli();

    return hr;
}


HRESULT __stdcall CStream::CImpIStream::Commit(DWORD grfCommitFlags)
{
    return NO_ERROR;
}


HRESULT __stdcall CStream::CImpIStream::Revert(void)
{
    RonM_ASSERT(FALSE); // To catch unexpected uses of this interface...
    
    return E_NOTIMPL;
}


HRESULT __stdcall CStream::CImpIStream::LockRegion
                    (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, 
                     DWORD dwLockType
                    )
{
    return m_pLockBytes->LockRegion(libOffset, cb, dwLockType);
}


HRESULT __stdcall CStream::CImpIStream::UnlockRegion
                    (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, 
                     DWORD dwLockType
                    )
{
    return m_pLockBytes->UnlockRegion(libOffset, cb, dwLockType);
}


HRESULT __stdcall CStream::CImpIStream::Stat
                    (STATSTG __RPC_FAR *pstatstg, DWORD grfStatFlag)
{
    HRESULT hr = m_pLockBytes->Stat(pstatstg, grfStatFlag);

    if (SUCCEEDED(hr))
        pstatstg->type = STGTY_STREAM;

    return hr;
}


HRESULT __stdcall CStream::CImpIStream::Clone
                    (IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    CImpIStream *pStreamNew = NULL;

    m_pLockBytes->AddRef();
    
    HRESULT hr = CStream::OpenStream(NULL, m_pLockBytes, m_grfMode, 
                                     (IStreamITEx **)&pStreamNew
                                    );

    if (SUCCEEDED(hr))
    {
        pStreamNew->m_ullStreamPosition = m_ullStreamPosition;

        *ppstm = (IStream *) pStreamNew;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CStream::CImpIStream::SetDataSpaceName
            (const WCHAR *pwcsDataSpaceName)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CStream::CImpIStream::GetDataSpaceName
            (WCHAR **ppwcsDataSpaceName)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CStream::CImpIStream::Flush()
{
    return m_pLockBytes->Flush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\stream.h ===
// Stream.h -- Definition for the class CStream

#ifndef __STREAM_H__

#define __STREAM_H__

class CStream : public CITUnknown
{

public:

    static HRESULT OpenStream(IUnknown *punkOuter, ILockBytes *pLockBytes, 
                              DWORD grfMode, IStreamITEx **ppStream
                             );

    ~CStream(void);

    // IUnknown methods:

private:

    CStream(IUnknown *pUnkOuter);

    class CImpIStream : public IITStreamITEx
    {
    
    public:

        CImpIStream(CStream *pBackObj, IUnknown *punkOuter);
        ~CImpIStream(void);

        HRESULT InitOpenStream(ILockBytes *pLockBytes, DWORD grfMode);

        // ISequentialStream methods

        /* [local] */ HRESULT __stdcall Read( 
            /* [out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead);
        
        /* [local] */ HRESULT __stdcall Write( 
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten);
        
        // IStream methods:

        /* [local] */ HRESULT __stdcall Seek( 
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition) ;
        
        HRESULT __stdcall SetSize( 
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT __stdcall CopyTo( 
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten);
        
        HRESULT __stdcall Commit( 
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT __stdcall Revert( void);
        
        HRESULT __stdcall LockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT __stdcall UnlockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT __stdcall Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT __stdcall Clone( 
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);

        // IStreamITEx methods:

        HRESULT STDMETHODCALLTYPE SetDataSpaceName(const WCHAR  * pwcsDataSpaceName);
        HRESULT STDMETHODCALLTYPE GetDataSpaceName(      WCHAR **ppwcsDataSpaceName);
        HRESULT STDMETHODCALLTYPE Flush();

    private:

        enum { CB_MAX_COPY_SEGMENT = 8192 };

        ILockBytes *m_pLockBytes;
        CULINT      m_ullStreamPosition;
        DWORD       m_grfMode;

        CITCriticalSection m_cs;
    };

    CImpIStream   m_ImpIStream;
};

typedef CStream *PCStream;

extern GUID aIID_CStream[];

extern UINT cInterfaces_CStream;

inline CStream::CStream(IUnknown *pUnkOuter)
    : m_ImpIStream(this, pUnkOuter),
      CITUnknown(aIID_CStream, cInterfaces_CStream, &m_ImpIStream)
{
}

inline CStream::~CStream(void)
{
}

inline CStream::CImpIStream::CImpIStream(CStream *pBackObj, IUnknown *pUnkOuter)
              : IITStreamITEx(pBackObj, pUnkOuter)

{
    m_ullStreamPosition = 0;
    m_pLockBytes        = NULL;
}

inline CStream::CImpIStream::~CImpIStream(void)
{
    if (m_pLockBytes) 
        m_pLockBytes->Release();
}


#endif // __STREAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\sync.h ===
// sync.h -- defines the CSyncWith class

#ifndef __SYNC_H__

#define __SYNC_H__

class CITCriticalSection
{
public:

	CITCriticalSection();
	~CITCriticalSection();

	void Enter();
	void Leave();

#ifdef _DEBUG

	LONG LockCount();

#endif // _DEBUG

private:
	
	void Start();
	void Stop();

	CRITICAL_SECTION m_cs;

#ifdef _DEBUG

	LONG m_ulOwningThread;
	LONG m_cLockRecursion;

#endif // _DEBUG
};

inline CITCriticalSection::CITCriticalSection()
{
	Start();
}

inline void CITCriticalSection::Start()
{
	InitializeCriticalSection(&m_cs);

#ifdef _DEBUG

	m_ulOwningThread = ~0;
	m_cLockRecursion =  0;

#endif // _DEBUG
}

inline void CITCriticalSection::Stop()
{
	DeleteCriticalSection(&m_cs);
	
	RonM_ASSERT(m_ulOwningThread == ~0);
	RonM_ASSERT(m_cLockRecursion ==  0);
}

inline CITCriticalSection::~CITCriticalSection()
{
	Stop();
}

inline void CITCriticalSection::Enter()
{
	::EnterCriticalSection(&m_cs);

#ifdef _DEBUG

	RonM_ASSERT(m_cLockRecursion || m_ulOwningThread == ~0);

	if (!m_cLockRecursion++)
		m_ulOwningThread = GetCurrentThreadId();

#endif // _DEBUG
}

#ifdef _DEBUG
inline LONG CITCriticalSection::LockCount()
{
	return (m_ulOwningThread == GetCurrentThreadId())? m_cLockRecursion : 0;
}
#endif // _DEBUG

inline void CITCriticalSection::Leave()
{
#ifdef _DEBUG
	RonM_ASSERT(m_cLockRecursion > 0);

	if (!--m_cLockRecursion)
		m_ulOwningThread = ~0;
#endif // _DEBUG

	::LeaveCriticalSection(&m_cs);
}

class CSyncWith 
{
public:

	CSyncWith(CITCriticalSection &refcs);
	~CSyncWith();
	
private:

	CITCriticalSection *m_pcs;

#ifdef _DEBUG
	LONG m_cLocksPrevious;
#endif // _DEBUG
};

inline CSyncWith::CSyncWith(CITCriticalSection &refcs)
{
	m_pcs = &refcs;

#ifdef _DEBUG	
	m_cLocksPrevious = m_pcs->LockCount();	 
#endif // _DEBUG

	m_pcs->Enter();
}

inline CSyncWith::~CSyncWith()
{
	m_pcs->Leave();

#ifdef _DEBUG
	LONG cLocks = m_pcs->LockCount(); 

	RonM_ASSERT(cLocks == m_cLocksPrevious);
#endif // _DEBUG
}

#ifdef _DEBUG

inline BOOL IsUnlocked(CITCriticalSection &refcs)
{
	return refcs.LockCount() == 0;
}

#endif // _DEBUG;

#endif // __SYNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\txdata.h ===
typedef struct _sResetRecord{
    ULARGE_INTEGER  uliXOffset;
} sResetRec;

typedef struct _sResetRecordV1{
    ULARGE_INTEGER  uliVOffset;
	ULARGE_INTEGER  uliXOffset;
} sResetRecV1;

typedef sResetRec * LPRESETREC;

typedef struct _sHeaderInfo{
    DWORD			dwVerInfo;
    ULONG			cRecs;
	ULONG			cbRecSize;
    ULONG			cbSize;
	ULARGE_INTEGER  uliVSpaceSize;
	ULARGE_INTEGER  uliTxSpaceSize;
	ULONG			ulBlockSize;
	ULONG			unused;
} sHeader;

typedef sHeader * LPSHEADER;


class CXResetData
{
public:
	ULONG GetRecordNum(){ return m_cFillRecs;};
    
	ULONG FindRecord(ULARGE_INTEGER   uliOffset, 
                     ULARGE_INTEGER   *puliXOffset, 
                     BOOL			  *pfLastRecord);
    
	BOOL FGetRecord(ULONG		   iRecNum, 
                   ULARGE_INTEGER  *puliOffset, 
                   ULARGE_INTEGER  *puliXOffset, 
                   BOOL			   *pfLastRecord);
    
	HRESULT AddRecord(ULARGE_INTEGER  uliOffset, ULARGE_INTEGER  uliXOffset);
	HRESULT DeleteRecord(ULONG ulRecNum);

    CXResetData();
    
	~CXResetData();
    
	HRESULT InitResetTable(IStorage			*pStg,
						  ULARGE_INTEGER	*puliVSpaceSize,
						  ULARGE_INTEGER    *puliTxSpaceSize,
						  ULONG				ulBlockSize);
    
	HRESULT CommitResetTable(ULARGE_INTEGER   uliVSpaceSize,
				      	     ULARGE_INTEGER   uliTxSpaceSize);

	HRESULT GetResetTblStream(IStorage *pStg, IStream **ppStm);

private:
    HFILE			m_hFile;
    LPRESETREC		m_pSyncTbl;
    ULONG			m_cFillRecs;
    ULONG			m_cEmptyRecs;
    BOOL			m_fDirty;
	IStream			*m_pStm;
	IStorage		*m_pStg;
	ULONG			m_ulBlockSize;
	
	HRESULT DumpStream(IStream *pTempStrm, LPSTR pFileName);
    ULONG BinarySearch(
                    LPRESETREC	   pTbl,
                    ULONG		   ulStart,
                    ULONG	       ulEnd,
                    ULARGE_INTEGER ulKey
                    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\teststg.cpp ===
// TestStg.cpp -- A simple text program for the IITStorage interface wrapper.

#include <Windows.h>
#include <malloc.h>
#include <stdio.h>
#include <wchar.h>
#include <objbase.h>
#include <urlmon.h>
#include "MSITSTG.h"

typedef IUnknown *PIUnknown;

#define ReleaseObjPtr(pObj)			\
{									\
	if (pObj)						\
    {								\
        IUnknown *pUnk= pObj;		\
                  pObj= NULL;		\
                  pUnk->Release();	\
    }								\
}

#define StorageName     L".\\test.df"


const char aItemTypes[] = "?\\:#@!";

// ITControlData defines the current structure of the control data
// used by ITS at the moment. Don't count on it being correct forever.
// Instead you should use IITStorage::EditControlData to set up control
// data. [Real soon now...]

typedef struct _ITControlData
{
    UINT  cdwFollowing;

    DWORD cdwITFS_Control;
    DWORD dwMagicITS;
    DWORD dwVersionITS;
    DWORD cbDirectoryBlock;
    DWORD cMinCacheEntries;
    DWORD fFlags;

    UINT  cdwLZXData;

    DWORD dwLZXMagic;
    DWORD dwVersionLZX;
    DWORD cbResetBlock;
    DWORD cbWindowSize;
    DWORD cbSecondPartition;
    DWORD cbExeOpt;

} ITControlData, *PITControlData;

#define Buff_Cnt  (200)

void main(int cArgs, char **ppchArgs)
{
#define SHUTDOWN    { DebugBreak(); goto shutdown; }
#define BAILOUT     { DebugBreak(); goto bail_out; }    
    
    IITStorage   *pITStorage  = NULL;
    IStorage     *pStorage    = NULL;
    
    IStorage     *rgpstg[100];
    IStream      *pstm = NULL;
    

	WCHAR StmName[1024];
	WCHAR StgName[1024];
  
	int i,j;
    ULONG ulData[Buff_Cnt];
    ULONG iData;
    ULONG cbWritten= 0;
    ULONG ulDataRead[Buff_Cnt];
    ULONG cbRead = 0;
	WCHAR suffix[10];
    ITControlData itcd;
	PITControlData pitcd = &itcd;

    itcd.cdwFollowing      = 13;
    itcd.cdwITFS_Control   = 5;
    itcd.dwMagicITS        = 'I' | ('T' << 8) | ('S' << 16) | ('C' << 24);
    itcd.dwVersionITS      = 1;
    itcd.cbDirectoryBlock  = 512;
    itcd.cMinCacheEntries  = 20;
    itcd.fFlags            = 0x00000000; // Make compression the default.
    itcd.cdwLZXData        = 6;
    itcd.dwLZXMagic        = 'L' | ('Z' << 8 ) | ('X' << 16) | ('C' << 24);
    itcd.dwVersionLZX      = 2;
    itcd.cbResetBlock      = 2;//32*1024; // 0x40000;
    itcd.cbWindowSize      = 2;//28*1024; //0x20000;
    itcd.cbSecondPartition = 1;//64*1024; //0x10000;
    itcd.cbExeOpt      =  FALSE;

    if (!SUCCEEDED(CoInitialize(NULL))) 
        return;

    IClassFactory *pICFITStorage = NULL;

    HRESULT hr= CoGetClassObject(CLSID_ITStorage, CLSCTX_INPROC_SERVER, NULL, 
                                 IID_IClassFactory, (VOID **)&pICFITStorage
                                );

    if (!SUCCEEDED(hr)) 
        SHUTDOWN

    hr= pICFITStorage->CreateInstance(NULL, IID_ITStorage, 
                                      (VOID **)&pITStorage
                                     );

    ReleaseObjPtr(pICFITStorage);

    if (!SUCCEEDED(hr)) 
        SHUTDOWN

	hr = pITStorage->EditControlData((PITS_Control_Data *)&pitcd, 0);
    hr = pITStorage->SetControlData(PITS_Control_Data(&itcd));

    hr= pITStorage->StgCreateDocfile(StorageName, 
                                     STGM_READWRITE | STGM_SHARE_EXCLUSIVE 
                                                    | STGM_DIRECT
                                                    | STGM_CREATE,
                                     0, &pStorage
                                    );

    if (!SUCCEEDED(hr)) 
        BAILOUT

	 for (iData= Buff_Cnt; iData--; ) 
		 ulData[iData] = iData;

	 for (i = 0; SUCCEEDED(hr) && (i < 100); i++)
	 {
		_itow(i, suffix, 10);
		wcscpy(StgName, L"stg");
		wcscat(StgName, suffix);

		hr= pStorage->CreateStorage(StgName, STGM_READWRITE, 0, 0, &rgpstg[i]);
			
		for (j = 0; SUCCEEDED(hr) && (j < 100); j++)
		{
			_itow(j, suffix, 10);
			wcscpy(StmName, L"stm");
			wcscat(StmName, suffix);

			hr= rgpstg[i]->CreateStream(StmName, STGM_READWRITE, 0, 0, &pstm);
			hr= pstm->Write(ulData, Buff_Cnt * sizeof(ULONG), &cbWritten);
			pstm->Release();
		}
	}

	
   	 for (i = 0; SUCCEEDED(hr) && (i < 100); i++)
	 {
		for (j = 0; SUCCEEDED(hr) && (j < 100); j++)
		{
			_itow(j, suffix, 10);
			wcscpy(StmName, L"stm");
			wcscat(StmName, suffix);

			hr= rgpstg[i]->OpenStream(StmName, 0, STGM_WRITE, 0, &pstm);
			hr= pstm->Write(ulData, Buff_Cnt * sizeof(ULONG), &cbWritten);
			pstm->Release();
		}
		ReleaseObjPtr(rgpstg[i]);
	} 
   
	printf("Everything worked!\n");


bail_out:
    ReleaseObjPtr(pStorage);
    ReleaseObjPtr(pITStorage);

    ReleaseObjPtr(pICFITStorage);

shutdown:

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\txfac.cpp ===
// txfac.cpp -- Class factory for LZX transform instances

#include "stdafx.h"

STDMETHODIMP CLZX_TransformFactory::Create(IUnknown *punkOuter, REFIID riid, PVOID *ppv)
{
	PCLZX_TransformFactory pTxFac = New CLZX_TransformFactory(punkOuter);
	
	if (pTxFac == NULL)
		return STG_E_INSUFFICIENTMEMORY;

    HRESULT hr = pTxFac->m_ImpITXFactory.Init();

    if (hr == S_OK)
        hr = pTxFac->QueryInterface(riid, ppv);

    if (hr != S_OK)
        delete pTxFac;

    return hr;
}

HRESULT STDMETHODCALLTYPE CLZX_TransformFactory::CImpITransformFactory::DefaultControlData
            (XformControlData **ppXFCD)
{
	  LZX_Control_Data *pXFCD = PLZX_Control_Data(OLEHeap()->Alloc(sizeof(LZX_Control_Data)));

      if (!pXFCD)
          return E_OUTOFMEMORY;

      pXFCD->cdwControlData			= 6;
      pXFCD->dwLZXMagic				= LZX_MAGIC;
      pXFCD->dwVersion				= LZX_Current_Version;
      pXFCD->dwMulResetBlock		= RESET_BLOCK_SIZE;
      pXFCD->dwMulWindowSize		= WINDOW_SIZE;
      pXFCD->dwMulSecondPartition	= SECOND_PARTITION_SIZE;
      pXFCD->dwOptions				= LXZ_DEF_OPT_FLAGS;

      *ppXFCD = PXformControlData(pXFCD);

      return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CLZX_TransformFactory::CImpITransformFactory::CreateTransformInstance
		(ITransformInstance   *pITxInstMedium,        // Container data span for transformed data
		 ULARGE_INTEGER       cbUntransformedSize, // Untransformed size of data
		 PXformControlData    pXFCD,               // Control data for this instance
		 const CLSID          *rclsidXForm,         // Transform Class ID
		 const WCHAR          *pwszDataSpaceName,   // Data space name for this instance
		 ITransformServices   *pXformServices,      // Utility routines
		 IKeyInstance         *pKeyManager,         // Interface to get enciphering keys
		 ITransformInstance   **ppTransformInstance // Out: Instance transform interface
		) 
{
    return CTransformInstance::Create
               (pITxInstMedium, cbUntransformedSize, pXFCD,              
				rclsidXForm, pwszDataSpaceName,  
				pXformServices, pKeyManager, ppTransformInstance
               );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\txdata.cpp ===
#include "stdafx.h"
//#include <stdio.h>

#define StreamName           L"ResetTable"


ULONG CXResetData::BinarySearch(
                        LPRESETREC	   pTbl,
                        ULONG		   ulStart,
                        ULONG		   ulEnd,
                        ULARGE_INTEGER uliKey
                        )
{
#ifdef _DEBUG
    static int cLoop;  // BugBug! This will fail in multithreaded situations!
    cLoop++;
    RonM_ASSERT(cLoop < 20);
#endif

	if (ulStart == ulEnd)
	{
		DEBUGCODE(cLoop = 0;)
		return ulStart;
	}
	else
    if (ulStart == (ulEnd -1))
	{
		#ifdef _DEBUG
		cLoop = 0;
		#endif	
		
		if (CULINT(uliKey) >= CULINT(ulEnd * m_ulBlockSize))
			return ulEnd;
		else
			return ulStart;
	}
	
    ULONG ulMid = (ulEnd + ulStart) / 2;

    if (CULINT(uliKey) <= CULINT(ulMid * m_ulBlockSize))
    {
        return BinarySearch(pTbl, ulStart, ulMid, uliKey);
    }
    else
    {
        return BinarySearch(pTbl, ulMid, ulEnd, uliKey);
    }
}

ULONG CXResetData::FindRecord(
                              ULARGE_INTEGER uliOffset, 
                              ULARGE_INTEGER *puliXOffset, 
                              BOOL  *pfLastRecord
)
{
	ULONG ulRecNum;
	
	if (m_cFillRecs)
	{
		ulRecNum = BinarySearch(m_pSyncTbl, 0, m_cFillRecs - 1, uliOffset);
		*puliXOffset = (m_pSyncTbl + ulRecNum)->uliXOffset;
		*pfLastRecord = (ulRecNum == (m_cFillRecs - 1));
	}
    return ulRecNum;
}

BOOL CXResetData::FGetRecord(
                       ULONG			ulRecNum, 
                       ULARGE_INTEGER   *puliOffset, 
                       ULARGE_INTEGER   *puliXOffset, 
                       BOOL				*pfLastRecord 
)
{
    if (ulRecNum >= m_cFillRecs)
        return FALSE;

    *puliOffset =  CULINT(ulRecNum * m_ulBlockSize).Uli();
    *puliXOffset = (m_pSyncTbl + ulRecNum)->uliXOffset;
    *pfLastRecord = (ulRecNum == (m_cFillRecs - 1));
    return TRUE;
}

HRESULT CXResetData::DeleteRecord(ULONG ulRecNum)
{
	HRESULT hr = NO_ERROR;

	//Verify we are deleting valid record
    if (ulRecNum < m_cFillRecs)
    {
		m_cFillRecs--;   
		m_cEmptyRecs++;
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;
}

HRESULT CXResetData::AddRecord(ULARGE_INTEGER  uliOffset, ULARGE_INTEGER  uliXOffset)
{
    if (m_cEmptyRecs <= 0)
    {
        //double the size of reset table for future use
        LPRESETREC prec		  = m_pSyncTbl;

        ULONG	   nTotalRecs = (m_cFillRecs ? m_cFillRecs : 64) * 2;
        
		if (m_pSyncTbl = New sResetRec[nTotalRecs])
        {
			//copy old table to newly created table with bigger size
			if (prec)
			{
				memCpy((LPBYTE)m_pSyncTbl, (LPBYTE)prec, m_cFillRecs * sizeof(sResetRec));
				delete prec;
			}
			m_cEmptyRecs = nTotalRecs - m_cFillRecs;
        }
        else
        {
			m_pSyncTbl = prec;
            return STG_E_INSUFFICIENTMEMORY;
        }
    }
    
    LPRESETREC prec  = m_pSyncTbl + m_cFillRecs;
    prec->uliXOffset = uliXOffset;

    m_cFillRecs++;
    m_cEmptyRecs--;

    m_fDirty = TRUE;

    return NO_ERROR;
}

CXResetData::CXResetData(
                         /*IStorage *pstg*/
                         )
{
    m_fDirty		= FALSE;
    m_pStm			= NULL;
	m_pStg			= NULL;
    m_cFillRecs		= 0;
    m_cEmptyRecs	=0;
    m_pSyncTbl		= NULL;

}

CXResetData::~CXResetData()
{
    if (m_pSyncTbl)
    {
        delete m_pSyncTbl;
        m_pSyncTbl = NULL;
    }
    
    if (m_pStm)
        m_pStm->Release();
	
	if (m_pStg)
		m_pStg->Release();
}

HRESULT CXResetData::InitResetTable(IStorage		*pStg,
								    ULARGE_INTEGER *puliVSpaceSize,
								    ULARGE_INTEGER *puliTxSpaceSize,
									ULONG			ulBlockSize)
{
	m_pStg = pStg;
	m_pStg->AddRef();
	
	HRESULT hr = NO_ERROR;

	*puliVSpaceSize  = CULINT(0).Uli();
	*puliTxSpaceSize = CULINT(0).Uli();
	m_ulBlockSize = ulBlockSize;

    if (SUCCEEDED(hr = GetResetTblStream(pStg, &m_pStm)))
    {
        sHeader header;
		ULONG	cbBytesRead = 0;

		int hr = m_pStm->Read((LPVOID)&header, sizeof(sHeader), &cbBytesRead);
       
		if (SUCCEEDED(hr) && (cbBytesRead == sizeof(sHeader)))
        {
			*puliVSpaceSize = header.uliVSpaceSize;
			*puliTxSpaceSize = header.uliTxSpaceSize;
			
		    m_cFillRecs = header.cRecs;
            if (m_cFillRecs > 0)
            {
                //allocate reset table with record 
                //count which is double of m_cFillRecs.
                ULONG nTotalRecs = m_cFillRecs * 2;
                if (m_pSyncTbl = New sResetRec[nTotalRecs])
                {
                    m_cEmptyRecs = nTotalRecs - m_cFillRecs;
    
					LARGE_INTEGER dliB;
					ULARGE_INTEGER dliBFinal;

					dliB.HighPart = 0;
					dliB. LowPart = header.cbSize;

					dliBFinal.HighPart = 0;
					dliBFinal. LowPart = 0;
  			
					if (SUCCEEDED(hr = m_pStm->Seek(dliB, STREAM_SEEK_SET, &dliBFinal)))
					{
						if (header.dwVerInfo == 1) 
						{
							sResetRecV1 sRecV1;
							ULONG cb;
							for (int iRec = 0; SUCCEEDED(hr) && (iRec < m_cFillRecs); iRec++)
							{
								hr = m_pStm->Read((LPVOID)&sRecV1, 
												sizeof(sResetRecV1), 
												&cb);
								cbBytesRead += cb;
								(m_pSyncTbl + iRec)->uliXOffset = sRecV1.uliXOffset;
							}
						}
						else if (header.dwVerInfo == LZX_Current_Version) 
						{
							hr = m_pStm->Read((LPVOID)(m_pSyncTbl), 
											m_cFillRecs * sizeof(sResetRec), 
											&cbBytesRead);
						}//read
                    }//seek
                }// new
				else
				{
					hr = STG_E_INSUFFICIENTMEMORY;
				}
            }//no. of entries in table > 0
        }//read header
    }//open reset table stream
	
	return hr;
}

HRESULT CXResetData::DumpStream(IStream *pTempStrm, LPSTR pFileName)
{
	HRESULT hr = NO_ERROR;
#if 0 //test code
	FILE *file = fopen(pFileName, "w" );

	if (file != NULL)
	{
		RonM_ASSERT(pTempStrm != NULL);
		HRESULT	hr = NO_ERROR;
		BYTE	lpBuf[2048];

		if (SUCCEEDED(hr = pTempStrm->Seek(CLINT(0).Li(), STREAM_SEEK_SET, 0)))
		{
			ULONG		   cbToRead = sizeof(lpBuf);
			ULONG		   cbWritten;
			ULONG		   cbRead = cbToRead;
				
			while (SUCCEEDED(hr) && (cbRead == cbToRead))
			{
				if (SUCCEEDED(hr = pTempStrm->Read(lpBuf, cbToRead, &cbRead)))
				{
					cbWritten = fwrite(lpBuf, sizeof(BYTE), cbRead, file);
					RonM_ASSERT(cbRead == cbWritten);
					if (cbRead != cbWritten)
						hr = E_FAIL;
				}//ReadAt
			}//while

		}//seek
 
		fclose(file);
	}
	else
		hr = E_FAIL;

#endif //end test code
return hr;
}

HRESULT CXResetData::CommitResetTable(ULARGE_INTEGER uliVSpaceSize,
								   ULARGE_INTEGER  uliTxSpaceSize)
{
    RonM_ASSERT(m_pStm);
	HRESULT hr = NO_ERROR;

	if (m_fDirty)
    {
		sHeader header;
        
        //latest version
        header.dwVerInfo			= LZX_Current_Version;
        header.cRecs				= m_cFillRecs;
        header.cbSize				= sizeof(sHeader);
		header.cbRecSize			= sizeof(sResetRec);
		header.uliVSpaceSize		= uliVSpaceSize;
		header.uliTxSpaceSize		= uliTxSpaceSize;
		header.ulBlockSize			= m_ulBlockSize;
		header.unused				= 0;
        
		ULONG cbWritten;
		
		LARGE_INTEGER dliB;
		ULARGE_INTEGER dliBFinal;
        
		dliB.HighPart = 0;
		dliB. LowPart = 0;

		dliBFinal.HighPart = 0;
		dliBFinal. LowPart = 0;

		if (SUCCEEDED(hr = m_pStm->Seek(dliB, STREAM_SEEK_SET, &dliBFinal)))
		{
			hr = m_pStm->Write((LPVOID)&header, sizeof(header), &cbWritten);
			if (SUCCEEDED(hr) && (cbWritten == sizeof(header)))
			{
				if (SUCCEEDED(hr = m_pStm->Write((LPVOID)m_pSyncTbl, 
									sizeof(sResetRec) * m_cFillRecs, 
									&cbWritten)))
				{
					if (cbWritten != sizeof(sResetRec) * m_cFillRecs)
						hr = E_FAIL;
					else
						m_fDirty = FALSE;

				}//write table
			}//write header
		}//seek
    }//if table dirty
    
	//test code
#ifdef _DEBUG
	DumpStream(m_pStm, "c:\\dbg.tbl");
#else
	DumpStream(m_pStm, "c:\\rel.tbl");
#endif
	return hr;
}

HRESULT CXResetData::GetResetTblStream(IStorage *pStg, IStream **ppStm)
{
	HRESULT hr;
	if (STG_E_FILENOTFOUND == (hr = pStg->OpenStream(StreamName, 
										0, 
										STGM_READWRITE | STGM_SHARE_EXCLUSIVE| STGM_DIRECT, 
										0, 
										ppStm)))
	{
		hr = pStg->CreateStream(StreamName, 
								STGM_READWRITE | STGM_SHARE_EXCLUSIVE 
                                                    | STGM_DIRECT
                                                    | STGM_CREATE, 
								0, 
								0, 
								ppStm);
	}//open stream

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\txfac.h ===
// txfac.h -- Header file for this transform

#ifndef __TXFAC_H__

#define __TXFAC_H__

class CLZX_TransformFactory : public CITUnknown
{
  public:
    // Main Object Destructor.
    ~CLZX_TransformFactory(void);

    // Creator:

    static STDMETHODIMP Create(IUnknown *punkOuter, REFIID riid, PVOID *ppv);
  
  private:
    // Main Object Constructor
    CLZX_TransformFactory(IUnknown* pUnkOuter);
    
    // We declare nested class interface implementations here.

    // We implement the IClassFactory interface (ofcourse) in this class
    // factory COM object class.
    class CImpITransformFactory : public IITTransformFactory
    {
      public:
        // Interface Implementation Constructor & Destructor.
        CImpITransformFactory(CLZX_TransformFactory* pBackObj,
							  IUnknown* pUnkOuter);
        ~CImpITransformFactory(void);

        STDMETHODIMP Init();

        // ITransformFactory methods.
        
		HRESULT STDMETHODCALLTYPE DefaultControlData(XformControlData **ppXFCD);

		HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance  *pTxInstMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) ;


      private:
        // Data private to this interface implementation of IClassFactory.
        CLZX_TransformFactory*     m_pBackObj;    // Parent Object back pointer.
        IUnknown*     m_pUnkOuter;   // Outer unknown for Delegation.
		UINT		  m_uiMulResetFactor;
    };

    // Make the otherwise private and nested IClassFactory interface
    // implementation a friend to COM object instantiations of this
    // selfsame CFCar COM object class.
    friend CImpITransformFactory;

    // Private data of CFCar COM objects.

    // Nested IClassFactory implementation instantiation.
    CImpITransformFactory m_ImpITXFactory;
};

typedef CLZX_TransformFactory* PCLZX_TransformFactory;

inline CLZX_TransformFactory::CLZX_TransformFactory(IUnknown* pUnkOuter)
    : m_ImpITXFactory(this, pUnkOuter),
      CITUnknown(&IID_ITransformFactory, 1, &m_ImpITXFactory)
{
}

inline CLZX_TransformFactory::~CLZX_TransformFactory()
{
}

inline CLZX_TransformFactory::CImpITransformFactory::CImpITransformFactory
    (CLZX_TransformFactory* pBackObj,IUnknown* pUnkOuter)
    : IITTransformFactory(pBackObj, pUnkOuter)
{
}

inline CLZX_TransformFactory::CImpITransformFactory::~CImpITransformFactory(void)
{
}

inline STDMETHODIMP CLZX_TransformFactory::CImpITransformFactory::Init()
{
    return NO_ERROR;
}

#endif // __TXFAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\txinst.h ===
// TXINST.h -- Class definition for CTransformInstance based on ITransformInstance
//#include <stdio.h>

#ifndef __TXINST_H__

#define __TXINST_H__

const DWORD LZX_Current_Version = 2;

#define SOURCE_CHUNK (32*1024)

// Defaults for the control parameters:

#define WINDOW_SIZE            4 //128*1024
#define SECOND_PARTITION_SIZE  2 //64*1024
#define RESET_BLOCK_SIZE       4 //32*1024
#define SOURCE_SIZE            (32*1024)
#define LXZ_DEF_OPT_FLAGS	   0 // See OPT_FLAG_XXX series below	

#define OPT_FLAG_EXE           0x00000001 // Optimizes x86 machine code, but adds overhead

// These counters are reported at the end of debug runs.

extern ULONG cLZXResetDecompressor;   // Number of times the decompression state has been reset
extern ULONG cLZXReadFromBuffer;      // Number of times we got data from this history window or
                                      // the decoding buffer.
extern ULONG cLZXReadFromCurrentSpan; // Number of times we could continue decoding the current
                                      // reset interval.
extern ULONG cLZXReadFromOtherSpan;   // Number of times we had to abandon the current reset
                                      // interval.

#ifdef _DEBUG
void DumpLZXCounts();
#endif // _DEBUG

class CXResetData;

extern CBuffer *pBufferForCompressedData;   // Used to read compressed data from next transform

class CTransformInstance : public CITUnknown
{
public:
    
    // Destructor:

    ~CTransformInstance(void);

    // Creator:

	static HRESULT Create(ITransformInstance *pITxInst,
                          ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
                          PXformControlData   pXFCD,               // Control data for this instance
                          const CLSID        *rclsidXForm,         // Transform Class ID
                          const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
                          ITransformServices *pXformServices,      // Utility routines
                          IKeyInstance       *pKeyManager,         // Interface to get encipheri);
	                      ITransformInstance **ppTransformInstance // Where to return interface pointer
                         );

private:

    CTransformInstance(IUnknown *punkOuter);
    
    class CImpITransformInstance : public IITTransformInstance
    {
    public:

        CImpITransformInstance(CTransformInstance *pBackObj, IUnknown *punkOuter);
        ~CImpITransformInstance(void);

		//Intialization methods
		HRESULT InitTransformInstance(ITransformInstance *pITxInst,
									 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
									 PXformControlData   pXFCD,               // Control data for this instance
									 const CLSID        *rclsidXForm,         // Transform Class ID
									 const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
									 ITransformServices *pXformServices,      // Utility routines
									 IKeyInstance       *pKeyManager);         // Interface to get encipheri
		
		//static transform specific methods
		static MI_MEMORY __cdecl MyAlloc(ULONG);
		static void __cdecl		 MyFree(MI_MEMORY);
		static int __cdecl       lzx_output_callback(
									void            *pfol,
									unsigned char   *compressed_data,
									long            compressed_size,
									long            uncompressed_size
								);					 
               	
		//ITransformInstance methods

		HRESULT STDMETHODCALLTYPE ReadAt( 
				/* [in] */ ULARGE_INTEGER ulOffset,
				/* [length_is][size_is][out] */ void *pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG  *pcbRead,
                /* [in] */ ImageSpan *pSpan);

		HRESULT STDMETHODCALLTYPE WriteAt( 
				/* [in] */ ULARGE_INTEGER ulOffset,
				/* [size_is][in] */ const void  *pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG *pcbWritten,
				/* [out] */ImageSpan *pSpan);

		STDMETHODIMP SpaceSize(ULARGE_INTEGER *puliSize);
		STDMETHODIMP Flush(void);

    private:

        typedef struct _t_context
        {
	        LCI_CONTEXT_HANDLE cHandle;  /* compression context handle */
            LDI_CONTEXT_HANDLE dHandle;  /* decompression context handle */
            LZXCONFIGURATION   lcfg;
            LZXDECOMPRESS	   ldec;
            ULONG			   cbResetBlkSize;
	        UINT			   cbMaxUncomBufSize;
	        UINT			   cbMaxComBufSize;
	        HRESULT			   hr;
        #if 0 //test code
	        FILE              *m_file;
        #endif
        } t_context;

		HRESULT DeInitTransform();
		int		GetMulFactor()
        { 
            return (m_context.cbResetBlkSize + m_context.cbMaxUncomBufSize - 1) 
                   / m_context.cbMaxUncomBufSize;

            // int N = m_context.cbResetBlkSize / m_context.cbMaxUncomBufSize;
			// if (N == 0) 
			// 	N = 1; 
			// return N;
        }

		HRESULT Commit(void);
		HRESULT Write(LPBYTE pbunXBuf, ULONG cbunXBuf);
		HRESULT ReconstructCompressionState(PBYTE pbWriteQueueBuffer);
		
        void CopyFromWindow(PBYTE pbDest, ULONG offStart, ULONG cb);

        HRESULT HandleReadResidue(PBYTE pb, ULONG *pcbRead, BOOL fEOS, ImageSpan *pSpan, 
                                  CULINT ullBase,     CULINT ullLimit, 
                                  CULINT ullXferBase, CULINT ullXferLimit
                                 );
        HRESULT FlushQueuedOutput();

		ITransformInstance  *m_pITxNextInst;

		LZX_Control_Data     m_ControlData;		
		const CLSID         *m_rclsidXForm;		
		const WCHAR         *m_pwszDataSpaceName;
		ITransformServices  *m_pXformServices;	
		IKeyInstance        *m_pKeyManager;		
	
		ImageSpan			m_ImageSpan;
		ImageSpan			m_ImageSpanX;
		
		ULONG               m_cbUnFlushedBuf;  //number of bytes in unflushed buffer
		ULONG               m_cbResetSpan;  //number of bytes in Reset span (X+Unx - not written to disk)

        
        CBuffer             m_buffReadCache; // Used when X86 machine code decompression is active.
        CBuffer             m_buffWriteQueue; // Used to queue up full write blocks for compression.
		
        IStreamITEx        *m_pStrmReconstruction; // Stream used to reconstruct the compression
                                                   // state for a file we've reloaded.
		t_context			m_context;
        CXResetData        *m_pResetData;
		BOOL				m_fDirty;
		BOOL				m_fCompressionInitialed;
		BOOL                m_fInitialed;   // True => Initialing completed
        BOOL                m_fCompressionActive;
        BOOL                m_fDecompressionActive;
        CULINT              m_ullResetBase;
        CULINT              m_ullResetLimit;
        CULINT              m_ullBuffBase;
        CULINT				m_ullReadCursor;
        CULINT              m_ullWindowBase;
        PBYTE               m_pbHistoryWindow;
        LONG                m_cbHistoryWindow;
    };

    CImpITransformInstance   m_ImpITxInst;
};

typedef CTransformInstance *PCTransformInstance;

inline CTransformInstance::CTransformInstance(IUnknown *pUnkOuter)
    : m_ImpITxInst(this, pUnkOuter), 
      CITUnknown(&IID_ITransformInstance, 1, &m_ImpITxInst)
{

}

inline CTransformInstance::~CTransformInstance(void)
{
}

#endif // __TXINST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\types.h ===
// Types.h -- Defines for the procedure call conventions

#ifndef __TYPE_H__

#define __TYPE_H__

#pragma warning( disable : 4018 4200 4355 )

#define STDCALL __stdcall

typedef PVOID *PPVOID;

inline BOOL operator!=(FILETIME ftL, FILETIME ftR)
{
    return (ftL.dwLowDateTime == ftR.dwLowDateTime && ftL.dwHighDateTime == ftR.dwHighDateTime);
}

#endif // __TYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\txinst.cpp ===
// TXINST.cpp -- Implementation for the CTransformInstance class

#include "stdafx.h"

// The following buffer is shared among all instances of active ITS files. All access to it
// must be via a CBufferRef object.

CBuffer *pBufferForCompressedData = NULL;   // Used to read compressed data from next transform

// The following counters are used to gather statistics about the behavior of
// the decompression code. They are reported at the end of a debugging run.

// BugBug: Maybe we should probably add an interface to retrieve these stats
//         at any time.

ULONG cLZXResetDecompressor   = 0;
ULONG cLZXReadFromBuffer      = 0;
ULONG cLZXReadFromCurrentSpan = 0;
ULONG cLZXReadFromOtherSpan   = 0; 


#ifdef _DEBUG

void DumpLZXCounts()
{
    char acDebugBuff[256];

    wsprintf(acDebugBuff, "Count of decompressor resets:     %u\n", cLZXResetDecompressor);   
    OutputDebugString(acDebugBuff);
    wsprintf(acDebugBuff, "Count of reads from buffer:       %u\n", cLZXReadFromBuffer);      
    OutputDebugString(acDebugBuff);
    wsprintf(acDebugBuff, "Count of reads from current span: %u\n", cLZXReadFromCurrentSpan); 
    OutputDebugString(acDebugBuff);
    wsprintf(acDebugBuff, "Count of abandoned spans:         %u\n", cLZXReadFromOtherSpan);   
    OutputDebugString(acDebugBuff);
}

#endif _DEBUG


    

/* --- MyAlloc() ---------------------------------------------------------- */

// This routine does memory allocation for the LZX libraries.

MI_MEMORY __cdecl CTransformInstance::CImpITransformInstance::MyAlloc(ULONG amount)
{
	void * pv = (void *) (New BYTE[amount]);
	RonM_ASSERT(pv != NULL);
	return(pv);
}

/* --- MyFree() ----------------------------------------------------------- */

// This routine does memory deallocations for the LZX libraries.

void __cdecl CTransformInstance::CImpITransformInstance::MyFree(MI_MEMORY pointer)
{
	delete [] (BYTE *) pointer;
}

/* ---- lzx_output_callback) ------------------------------------------------*/ 

// This routine is called by the LZX compression routines to process the 
// compressed data output. 

int __cdecl CTransformInstance::CImpITransformInstance::lzx_output_callback(
	void            *pfol,
	unsigned char   *compressed_data,
	long            compressed_size,
	long            uncompressed_size
)
{
    CImpITransformInstance* pTxInst = (CImpITransformInstance *) pfol;
	
	ULONG cbBytesWritten;
	ULONG cbDestBufSize = compressed_size;

	RonM_ASSERT(SUCCEEDED(pTxInst->m_context.hr));
	//We got this fixed in LZX libraries
	//if (uncompressed_size == 0)
	//	 return 0;

	RonM_ASSERT(uncompressed_size == (32*1024));

    ImageSpan is = pTxInst->m_ImageSpanX;
	
	//Tell next transform where to start and how much to write
	ULARGE_INTEGER ulWriteOffset =  is.uliSize;

	if (   cbDestBufSize 
        && SUCCEEDED(pTxInst->m_context.hr = pTxInst->m_pITxNextInst->WriteAt
                                                 (ulWriteOffset,
												  (LPBYTE)compressed_data,
                                                  cbDestBufSize,
                                                  &cbBytesWritten,
                                                  &is
                                                 )
                    )
       )
	{
		RonM_ASSERT(cbBytesWritten == cbDestBufSize);
        RonM_ASSERT(cbDestBufSize 
                    == (CULINT(is.uliSize) - CULINT(pTxInst->m_ImageSpanX.uliSize)).Uli().LowPart
                   );

		#if 0 //test code
			LPSTR szSection = "Start Section";
			cbBytesWritten= fwrite((LPBYTE)szSection, 1, lstrlenA(szSection), pTxInst->m_context.m_file);
			cbBytesWritten= fwrite((LPBYTE)compressed_data, 1, cbDestBufSize, pTxInst->m_context.m_file);
			RonM_ASSERT(cbBytesWritten == cbDestBufSize);
		#endif

	#ifdef TXDEBUG
	#ifdef _DEBUG
			BYTE XBuf[6];
			memCpy(XBuf, compressed_data, 6);
			int cNum = pTxInst->m_pResetData->GetRecordNum();
			int adr = (int)CULINT(pTxInst->m_ImageSpanX.uliSize).Ull();

			printf("At adr = %d Added Entry %d  size = %d Blk=%x %x %x %x %x %x\n",
				adr,
				cNum, (int)compressed_size,
				XBuf[0], XBuf[1],XBuf[2],XBuf[3],XBuf[4], XBuf[5]);
	#endif
	#endif
		
        //add new ssync point

		if (SUCCEEDED(pTxInst->m_context.hr = pTxInst->m_pResetData->AddRecord
                                                  (pTxInst->m_ImageSpan.uliSize, 
							                       pTxInst->m_ImageSpanX.uliSize
                                                  )
                     )
           )
		{
			pTxInst->m_ImageSpanX.uliSize = is.uliSize;
			pTxInst->m_ImageSpan .uliSize = (CULINT(pTxInst->m_ImageSpan.uliSize)  
											 + uncompressed_size
                                            ).Uli();

            pTxInst->m_cbUnFlushedBuf -= uncompressed_size;
		}
		else pTxInst->m_context.hr = STG_E_INSUFFICIENTMEMORY;
	}
	
	return  0;
}

HRESULT CTransformInstance::Create(
		ITransformInstance  *pITxInst,
		ULARGE_INTEGER      cbUntransformedSize,  // Untransformed size of data
		 PXformControlData  pXFCD,                // Control data for this instance
		 const CLSID        *rclsidXForm,         // Transform Class ID
		 const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
		 ITransformServices *pXformServices,      // Utility routines
		 IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance
)
{
	CTransformInstance *pTxInst = New CTransformInstance(NULL);

    if (!pTxInst)
        return E_OUTOFMEMORY;
	
    HRESULT hr = pTxInst->m_ImpITxInst.InitTransformInstance
                     (pITxInst, cbUntransformedSize, pXFCD,              
                      rclsidXForm, pwszDataSpaceName, 
                      pXformServices, pKeyManager
                     );

    if (hr == S_OK)
        hr = pTxInst->QueryInterface(IID_ITransformInstance, (void **) ppTransformInstance);

    if (hr != S_OK)
        delete pTxInst;
    else ((IITTransformInstance *) *ppTransformInstance)->Container()->MarkSecondary();

    return hr;
}

////////////////// non static methods ///////////////////////////

CTransformInstance::CImpITransformInstance::CImpITransformInstance
    (CTransformInstance *pBackObj, IUnknown *punkOuter)
    : IITTransformInstance(pBackObj, punkOuter)
{
	m_pITxNextInst			= NULL;
	m_fDirty				= NULL;
	m_pResetData			= NULL;
    m_cbUnFlushedBuf		= 0;
	m_cbResetSpan			= 0;
    m_ImageSpan.uliHandle	= CULINT(0).Uli();
	m_ImageSpan.uliSize		= CULINT(0).Uli();
	m_ImageSpanX.uliHandle	= CULINT(0).Uli();
	m_ImageSpanX.uliSize	= CULINT(0).Uli();
	m_pKeyManager			= NULL;
	m_pXformServices		= NULL;
	m_fCompressionInitialed = FALSE;
    m_fInitialed            = FALSE;
    m_fCompressionActive    = FALSE;
    m_fDecompressionActive  = FALSE;
    m_pStrmReconstruction   = NULL;

	ZeroMemory((LPVOID)&m_context,  sizeof(m_context));
}

CTransformInstance::CImpITransformInstance::~CImpITransformInstance(void)
{
    if (m_fInitialed)
        DeInitTransform();

    if (m_pStrmReconstruction)
        m_pStrmReconstruction->Release();

	if (m_pKeyManager)
		m_pKeyManager->Release();

	if (m_pXformServices)
		m_pXformServices->Release();
	
	//release next transform
    if (m_pITxNextInst)
	    m_pITxNextInst->Release();
}

HRESULT STDMETHODCALLTYPE CTransformInstance::CImpITransformInstance::SpaceSize
    (ULARGE_INTEGER *puliSize)
{
	*puliSize = (CULINT(m_ImageSpan.uliSize) 
				+ CULINT(m_cbUnFlushedBuf)).Uli();
	return NO_ERROR;
}

HRESULT CTransformInstance::CImpITransformInstance::DeInitTransform()
{
	//Save everything to disk
	HRESULT hr = Flush();

#if 0 //test code
	fclose(m_context.m_file);
#endif

			
	//destroy compressor and decompressor
	if (m_fCompressionActive && m_context.cHandle)
		LCIDestroyCompression(m_context.cHandle);

	if (m_fDecompressionActive && m_context.dHandle)
		LDIDestroyDecompression(m_context.dHandle);

   //destroy reset table
   if (m_pResetData)
	   delete m_pResetData;

    return hr;
}

   
HRESULT CTransformInstance::CImpITransformInstance::InitTransformInstance(
									 ITransformInstance *pITxInst,
									 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
									 PXformControlData   pXFCD,               // Control data for this instance
									 const CLSID        *rclsidXForm,         // Transform Class ID
									 const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
									 ITransformServices *pXformServices,      // Utility routines
									 IKeyInstance       *pKeyManager         // Interface to get encipheri
									)
{
    m_ControlData = *(LZX_Control_Data *) pXFCD; 
	 
	if (   (m_ControlData.dwVersion == LZX_Current_Version) 
	    && (pXFCD->cdwControlData != ((sizeof(LZX_Control_Data) - sizeof(UINT))) 
                                     / sizeof(DWORD)
           )
       ) return STG_E_INVALIDPARAMETER;

     if (m_ControlData.dwLZXMagic != LZX_MAGIC || m_ControlData.dwVersion > LZX_Current_Version)
         return STG_E_INVALIDPARAMETER;

	m_rclsidXForm       = rclsidXForm;      
	m_pwszDataSpaceName = pwszDataSpaceName; 
	m_pXformServices    = pXformServices;    
	m_pKeyManager       = pKeyManager;
	m_pITxNextInst      = pITxInst;
    m_pResetData        = New CXResetData;
    
	if (!m_pResetData) 
	{
		return STG_E_INSUFFICIENTMEMORY;
	}

	ZeroMemory(&(m_context.lcfg), sizeof(m_context.lcfg));

    if (m_ControlData.dwMulSecondPartition < 1)
        m_ControlData.dwMulSecondPartition = 1;

	m_context.cbMaxUncomBufSize = SOURCE_CHUNK; // m_ControlData.cbSourceSize;
	m_context.cbMaxComBufSize   = SOURCE_CHUNK; // as an initial guess...

	if (m_ControlData.dwVersion == LZX_Current_Version)
	{
		m_context.lcfg.WindowSize          = SOURCE_CHUNK * m_ControlData.dwMulWindowSize;
		m_context.lcfg.SecondPartitionSize = SOURCE_CHUNK * m_ControlData.dwMulSecondPartition;
		m_context.cbResetBlkSize           = SOURCE_CHUNK * m_ControlData.dwMulResetBlock;
	}
	else  if (m_ControlData.dwVersion == 1)
	{
		//In older version we used actual size rather than muliplier of 32K.

		m_context.lcfg.WindowSize             = m_ControlData.dwMulWindowSize;
		m_context.lcfg.SecondPartitionSize    = m_ControlData.dwMulSecondPartition;
		m_context.cbResetBlkSize			  =	m_ControlData.dwMulResetBlock;
	
		RonM_ASSERT(m_context.lcfg.WindowSize          >= (32*1024));
		RonM_ASSERT(m_context.lcfg.SecondPartitionSize >= (32*1024));
		RonM_ASSERT(m_context.cbResetBlkSize           >= (32*1024));
	}
	
	m_ullReadCursor   = -CULINT(1);
    m_ullResetBase    = -CULINT(1);
    m_ullResetLimit   = -CULINT(1);
    m_ullBuffBase     = -CULINT(1);
    m_ullWindowBase   = -CULINT(1);
    m_cbHistoryWindow = 0;
    m_pbHistoryWindow = NULL;

	HRESULT  hr    = NO_ERROR;
	IStorage *pstg = NULL;

	if (SUCCEEDED(hr = m_pXformServices->PerTransformInstanceStorage
                           (*m_rclsidXForm, m_pwszDataSpaceName, &pstg)
                 )
       )
	{
      	hr = m_pResetData->InitResetTable(pstg, 
									      &m_ImageSpan.uliSize, 
									      &m_ImageSpanX.uliSize,
									      m_context.cbMaxUncomBufSize
                                         );

		pstg->Release();
	}
	
	if (!SUCCEEDED(hr))
		return hr;
    
#if 0
		//test code
		char szLogFile[100];

		#ifdef _DEBUG
		lstrcpyA(szLogFile, "c:\\dbgData");
		#else
		lstrcpyA(szLogFile, "c:\\relData");
		#endif
		m_context.m_file = fopen(szLogFile, "a" );
		//end test code

#endif
	
    m_fInitialed = TRUE;

	return hr;
}

HRESULT CTransformInstance::CImpITransformInstance::ReconstructCompressionState
            (PBYTE pbWriteQueueBuffer)
{
	// This routine reconstructs the compression state when we've opened an 
    // ITS which already contains compressed data. When it's finished the
    // compression state will match the situation just after the most recent
    // write to the ITS file.
    //
    // There are two aspects to this reconstruction work. The first is simply
    // to pass data through the LZX compressor to build up the correct state 
    // there. The other issue is reconstructing the last partial block of 
    // write data. The pbWriteQueueBuffer points to the buffer we use for queuing 
    // write data until we have a full block.
    
	RonM_ASSERT(m_pResetData);
    RonM_ASSERT(!m_fCompressionInitialed);

	ULONG cNumRecs = m_pResetData->GetRecordNum();

    // Have we got any compressed data at all?
	
	if (cNumRecs == 0)
    {
	    m_fCompressionInitialed = TRUE;

	    return S_OK;
    }

	ULARGE_INTEGER uliVOffset, uliXOffset;
	BOOL           fLastRec;
	
#ifdef _DEBUG
    BOOL fGotaRecord = 
#endif // _DEBUG        
    m_pResetData->FGetRecord(cNumRecs - 1, &uliVOffset, &uliXOffset, &fLastRec);

    RonM_ASSERT(fGotaRecord);
	RonM_ASSERT(fLastRec); 

	ULONG ulLastRec       = cNumRecs - 1;
	ULONG cBytesToReadunX = (CULINT(m_ImageSpan .uliSize) - CULINT(uliVOffset)).Uli().LowPart;
	ULONG cBytesToReadX   = (CULINT(m_ImageSpanX.uliSize) - CULINT(uliXOffset)).Uli().LowPart;

    BOOL fLastBlockIsFull = cBytesToReadunX == m_context.cbMaxUncomBufSize;

    // Now we need to back up to the nearest previous reset point.

	int N = GetMulFactor(); // Number of blocks in a reset span.

	int mod = ulLastRec % N;

    if (mod == N-1 && fLastBlockIsFull)
    {
        // The next write will start at exactly on a reset boundary.

		m_cbUnFlushedBuf = 0;
		m_cbResetSpan    = 0;
        
        return NO_ERROR;
    }

    UINT cBlocksLastSpan = mod + 1;

	if (mod != 0)
	{
		// Reconstruction always starts at the first block in a reset span.
        
        ulLastRec       -= mod;
		cBytesToReadunX += mod * m_context.cbMaxUncomBufSize;
		uliVOffset		 = (CULINT(uliVOffset) - CULINT(mod * m_context.cbMaxUncomBufSize)
                           ).Uli();
	}

    RonM_ASSERT(cBytesToReadunX < m_context.cbResetBlkSize);

    m_cbResetSpan = cBytesToReadunX;

    LONG  lCurRec          = ulLastRec;
	ULONG cbBytesReadTotal = 0;

    HRESULT hr            = NO_ERROR;
	ULONG   cbBytesRead   = 0;
	ULONG   cbBytesToRead = 0;

    // The code below recreates the compression state for appending data
    // to this ITS file. It does this by running the last partial reset
    // span through the compressor. We first copy the partial span to a 
    // temporary file. Then we remove the entries for that data from m_pResetData.
    // Finally we copy the span from the temp file back through the compressor.
    // Note that we don't write the last partial block because it will become
    // the content of the queued-write buffer.

    ILockBytes *pLKB = NULL;

    hr = CFSLockBytes::CreateTemp(NULL, &pLKB);

    if (!SUCCEEDED(hr)) return hr;

    hr = CStream::OpenStream(NULL, pLKB, STGM_READWRITE, &m_pStrmReconstruction);

    if (!SUCCEEDED(hr)) 
    {    
        pLKB->Release();  pLKB = NULL;

        return hr;
    }

    // Here we're reading the last partial span into the temporary file.

	while (cbBytesReadTotal < cBytesToReadunX)
	{
#ifdef _DEBUG
        BOOL fGotaRecord = 
#endif // _DEBUG        
        m_pResetData->FGetRecord(lCurRec++, &uliVOffset, &uliXOffset, &fLastRec);

        RonM_ASSERT(fGotaRecord);
		
		cbBytesToRead = cBytesToReadunX - cbBytesReadTotal;
		
		if (cbBytesToRead > m_context.cbMaxUncomBufSize)
			cbBytesToRead = m_context.cbMaxUncomBufSize;

		hr = ReadAt(uliVOffset, pbWriteQueueBuffer, cbBytesToRead, &cbBytesRead, &m_ImageSpan);
        
        if (!SUCCEEDED(hr)) return hr;

        if (cbBytesRead != cbBytesToRead) return STG_E_READFAULT;

        ULONG cbWritten;
        
        hr = m_pStrmReconstruction->Write(pbWriteQueueBuffer, cbBytesToRead, &cbWritten);

        if (!SUCCEEDED(hr)) return hr;

        if (cbWritten != cbBytesToRead) return STG_E_WRITEFAULT;
        
        cbBytesReadTotal += cbBytesRead;
	}

	RonM_ASSERT(cbBytesReadTotal == cBytesToReadunX);

    // The next several lines invalidate any cached data. We have to do this because
    // the last block in the ITS file is usually a partial block padded out to 32K
    // with zeroes. If we don't invalidate the cache, this can cause problems if we
    // write out a new stream, close it, and then try to read it. The problem is that
    // the cacheing mechanism thinks it has valid data in multiples of 32K. So it 
    // copies result data from the cache instead of falling through to the code that
    // would pick it out of the queued-write buffer.

    m_ullBuffBase   = -CULINT(1);
    m_ullWindowBase = m_ullBuffBase;
    m_ullReadCursor = m_ullBuffBase;
    m_ullResetBase  = m_ullBuffBase;
    m_ullResetLimit = m_ullBuffBase;

    // This code deletes all the reset data records for the last reset span.
    // This is necessary because compression coordinates information and
    // assumptions across multiple blocks. Thus later uncompressed data can
    // influence the content of early compressed blocks. So we always have
    // to start writing at a reset block boundary.

    for (ulLastRec = cNumRecs - 1; cBlocksLastSpan--; ulLastRec--)
    {
#ifdef _DEBUG
        BOOL fResult = 
#endif // _DEBUG        
        m_pResetData->FGetRecord(ulLastRec, &uliVOffset, &uliXOffset, &fLastRec);

        RonM_ASSERT(fResult);
        
        m_pResetData->DeleteRecord(ulLastRec);

        RonM_ASSERT(ulLastRec == m_pResetData->GetRecordNum());
    }

    m_cbUnFlushedBuf = (CULINT(m_ImageSpan.uliSize) - CULINT(uliVOffset)).Uli().LowPart;

    RonM_ASSERT(m_cbUnFlushedBuf == cbBytesReadTotal);

	m_ImageSpan .uliSize = uliVOffset;
	m_ImageSpanX.uliSize = uliXOffset;

    hr= m_pStrmReconstruction->Seek(CLINT(0).Li(), STREAM_SEEK_SET, NULL);

    if (!SUCCEEDED(hr)) return hr;

    // Now we have to copy the temp file data through the compressor.

    for (;cbBytesReadTotal; cbBytesReadTotal-= cbBytesToRead)
    {
		cbBytesToRead = cbBytesReadTotal;

        if (cbBytesToRead > m_context.cbMaxUncomBufSize)
			cbBytesToRead = m_context.cbMaxUncomBufSize;

        hr = m_pStrmReconstruction->Read(pbWriteQueueBuffer, cbBytesToRead, &cbBytesRead);

        if (!SUCCEEDED(hr)) return hr;

        if (cbBytesToRead != cbBytesRead) return STG_E_READFAULT;

		if (cbBytesRead == m_context.cbMaxUncomBufSize)
			hr = Write(pbWriteQueueBuffer, cbBytesRead);

        if (!SUCCEEDED(hr)) return hr;
    }

    m_pStrmReconstruction->Release();  m_pStrmReconstruction = NULL;

    m_fCompressionInitialed = TRUE;

	return S_OK;
}

void CTransformInstance::CImpITransformInstance::CopyFromWindow
    (PBYTE pbDest, ULONG offStart, ULONG cb)
{
    // This method copies a span of data from the history window. 
    // The history window is a circular buffer. So the copy span
    // may wrap around from the end of the buffer through the 
    // leading portion of the buffer.

    RonM_ASSERT(m_pbHistoryWindow);
    RonM_ASSERT(cb);
    RonM_ASSERT(cb       <= m_cbHistoryWindow);
    RonM_ASSERT(offStart <= m_cbHistoryWindow);

    // Note that offStart can be == m_cbHistoryWindow and will be mapped 
    // into a zero offset.
    
    ULONG cbTrailing = m_cbHistoryWindow - offStart;

    if (cbTrailing > cb) cbTrailing = cb;

    if (cbTrailing)
    {
        CopyMemory(pbDest, m_pbHistoryWindow + offStart, cbTrailing);
        pbDest += cbTrailing;
        cb     -= cbTrailing;
    }

    if (cb) CopyMemory(pbDest, m_pbHistoryWindow, cb);
}

HRESULT CTransformInstance::CImpITransformInstance::HandleReadResidue
    (PBYTE pb, ULONG *pcbRead, BOOL fEOS, ImageSpan *pSpan, 
     CULINT ullBase,     CULINT ullLimit, 
     CULINT ullXferBase, CULINT ullXferLimit
    )
{
    HRESULT hr = S_OK;

    ULONG cbRead = (ullXferLimit - ullXferBase).Uli().LowPart;

    if (pcbRead) *pcbRead = cbRead;

    // Then we recursively handle the remainder of the read span (if any).
    // First we look to see if the span extends beyond the current
    // window. If so we can simply continue decompressing forward.

    if (ullXferLimit < ullLimit)
    {
        hr = ReadAt((ullXferLimit - pSpan->uliHandle).Uli(), 
                    pb + (ullXferLimit - ullBase).Uli().LowPart,
                    (ullLimit - ullXferLimit).Uli().LowPart,
                    &cbRead, pSpan
                   );

        if (SUCCEEDED(hr) && pcbRead) *pcbRead += cbRead;
    }

    if (SUCCEEDED(hr))
    {
        // Then we look to see if part of the read span precedes
        // our history span. This is a harsh condition which requires
        // that we discard the current history and restart at the next
        // lower resync point.

        if (ullXferBase > ullBase)
        {
            hr = ReadAt((ullBase - pSpan->uliHandle).Uli(), pb, 
                        (ullXferBase - ullBase).Uli().LowPart,
                        &cbRead, pSpan
                       );

            if (pcbRead && SUCCEEDED(hr)) *pcbRead += cbRead;
        }
    }

    if (!SUCCEEDED(hr) && pcbRead) *pcbRead = 0;

    if (fEOS && hr == NO_ERROR && !*pcbRead)
	    hr = S_FALSE;

    return hr;
}

HRESULT STDMETHODCALLTYPE CTransformInstance::CImpITransformInstance::ReadAt( 
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [length_is][size_is][out] */ void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbRead,
    /* [in] */ ImageSpan *pSpan)
{
/*
    This routine reads data from the MSCompressed data space. It hides all the details 
    of how data is actually stored and how it is cached to optimized performance.
    
    The *pSpan parameter identifies a logical segment of data which corresponds 
    to a stream in our caller's environment. This span value consists of a handle
    value which we assign, and a size value. By convention the handle value is
    a simple offset into the uncompressed linear data space which we simulate.

    The ulOffset parameter identifies where the read operation is to begin. It is
    given relative to the segment identified by *pSpan.

    The pv parameter defines where the read data is to be stored.

    The cb parameter defines how many bytes of data are requested.

    The *pcbRead value will indicate how many bytes were actually read.
 */

	if (cb == 0) // Empty reads always succeed.
    {
        *pcbRead = cb;

        return NO_ERROR;
    }
		
    ULONG cbDestBufSize = 0,
          ulEntry       = 0, 
          ulEntryNext   = 0, 
          ulEntryLast   = 0;

	HRESULT hr = NO_ERROR;

    if (!m_fDecompressionActive)
    {
	    // We don't fire up the decompression code until we
        // know we need it. We follow a similar strategy with
        // the compression code.

        int err;

 	    //create decompressor
        UINT  destSize2 = (UINT)m_context.cbMaxComBufSize;

        err= LDICreateDecompression(&m_context.cbMaxUncomBufSize,
                                    &m_context.lcfg,
                                    MyAlloc,
                                    MyFree,
                                    &destSize2,
                                    &(m_context.dHandle),
                                    NULL,NULL,NULL,NULL,NULL
                                   );

        if (err == 0) m_fDecompressionActive= TRUE;
        else return E_FAIL;
 
        if (m_context.cbMaxComBufSize < destSize2)
            m_context.cbMaxComBufSize = destSize2;
    }
    
    // Now we need a synchronous reference to the buffer we used
    // to read compressed data. This prevents other threads from
    // altering the read state, and it gives us access to the buffer
    // for read operations.
	
    CBufferRef refReadBuffer(*pBufferForCompressedData, m_context.cbMaxComBufSize);

    // Here we're converting the read parameters from stream-relative to
    // space-relative. Initially ulOffset and cb describe the read operation
    // relative to the corresponding ILockBytes object denoted by *pSpan.
    // In the following code ullBase and ullLimit will denote the same data
    // relative to the entire uncompressed data sequence.

    // pSpan->uliHandle gives the starting offset for the ILockBytes object.

    CULINT ullBase  = CULINT(pSpan->uliHandle) + CULINT(ulOffset);
    CULINT ullLimit = ullBase + cb;
    
    // ullLimitLockBytes marks the end point of the lockbyte object.

    CULINT ullLimitLockBytes = CULINT(pSpan->uliHandle) + CULINT(pSpan->uliSize);

    // Now we'll see whether the requested span lies within the ILockBytes segment.
    // This is where we detect end-of-stream conditions.

    if (ullBase > ullLimitLockBytes) // Starting beyond the end of the segment? 
    {
        *pcbRead = 0;
		return S_FALSE;
    }

    BOOL fEOS = FALSE;

    if (   ullLimit < ullBase           // Wrapped at 2**64 bytes?
        || ullLimit > ullLimitLockBytes // Trying to read past end of segment?
       )
    {
        fEOS     = TRUE;
        ullLimit = ullLimitLockBytes;
    }
    	
	ulOffset = ullBase.Uli();
	cb       = (ullLimit - ullBase).Uli().LowPart;
    
    // Here we're getting a synchronous reference to the write-queue buffer.
    // This prevents any other thread from writing while we're trying to read.

    CBufferRef refBuffWriteQueue(m_buffWriteQueue, 0);

	int N = GetMulFactor();

    // Here we look aside to see if we need to flush out any queued write data.
    // Note that we don't force all queued data. We leave the last partial block
    // alone and handle reads from the partial block in the code below.

    if (m_cbUnFlushedBuf / m_context.cbMaxUncomBufSize)
	{
		m_context.hr = NO_ERROR;
		
        ImageSpan span;

        span.uliHandle = CULINT(0).Uli();
        span.uliSize   = CULINT(0).Uli();

        RonM_ASSERT(m_fCompressionActive);
        
		int err = LCIFlushCompressorOutput(m_context.cHandle);

        hr = (err != 0)? E_FAIL : m_context.hr;

		RonM_ASSERT(SUCCEEDED(hr));

        if (!SUCCEEDED(hr)) return hr;
	
		m_cbUnFlushedBuf = m_cbUnFlushedBuf % m_context.cbMaxUncomBufSize;
	}
	
	RonM_ASSERT(m_cbUnFlushedBuf < m_context.cbMaxUncomBufSize);

	if (CULINT(ulOffset) < (CULINT(m_ImageSpan.uliSize))) // Has the data been written out?  
    { 
		// If so, we may be able to get it out of the history window
		// or the read cache buffer.

		// Are we not doing X86 machine code decompression?

		if (!(m_ControlData.dwOptions & OPT_FLAG_EXE)) 
		{
			// The code in this block determines whether some or all of the data
			// we need to return exists within the LZX history window.
        
			// We can do this only when we aren't doing X86 machine code decompression. 
			// The LZX code does that work in an external buffer which we supply.
        
			long  cbOffsetUncompressed = 0;
			long  cbOffsetWindow       = 0;
			int   errCode              = 0;

			errCode = LDIGetWindow(m_context.dHandle, &m_pbHistoryWindow, 
													  &cbOffsetUncompressed, 
													  &cbOffsetWindow, 
													  &m_cbHistoryWindow
								  );

			if (errCode != 0)
			{
				hr = E_FAIL;
				RonM_ASSERT(FALSE);
			}

			if (m_cbHistoryWindow) // Do we have any history data?
			{
				// If so, we first must calculate the intersection between
				// the history span and the requested read span.
            
				CULINT ullWindowBase = m_ullWindowBase + cbOffsetUncompressed;
				CULINT ullXferBase   = ullWindowBase;
				CULINT ullXferLimit  = ullWindowBase + CULINT(m_cbHistoryWindow);

				if (ullXferBase < ullBase) 
					ullXferBase = ullBase;

				if (ullXferLimit > ullLimit)
					ullXferLimit = ullLimit;

				if (ullXferBase < ullXferLimit) // Is the intersection non-empty?
				{
					// If so, we need to copy the corresponding history data
					// span into the result area.

					++cLZXReadFromBuffer;

					cbOffsetWindow = (cbOffsetWindow 
										+ (ullXferBase - ullWindowBase).Uli().LowPart
									 ) % m_context.lcfg.WindowSize;

					CopyFromWindow(PBYTE(pv) + (ullXferBase - ullBase).Uli().LowPart,
								   cbOffsetWindow, 
								   (ullXferLimit - ullXferBase).Uli().LowPart
								  );
                
					return HandleReadResidue(PBYTE(pv), pcbRead, fEOS, pSpan,
											 ullBase,     ullLimit,
											 ullXferBase, ullXferLimit
											);
				}    
			}
		}
		else
		{
			// The X86 code option is active. This means that we've
			// got a dedicated buffer of decompressed data. So let's 
			// see if it contains the data span we need.

			// Get a synchronous reference to the buffer

			CBufferRef refbuffRead(m_buffReadCache, m_context.cbMaxUncomBufSize);

			PBYTE pbBuff = refbuffRead.StartAddress();

			CULINT ullXferBase  = m_ullBuffBase;
			CULINT ullXferLimit = ullXferBase + m_context.cbMaxUncomBufSize;

			if (ullXferBase  < ullBase ) ullXferBase  = ullBase;
			if (ullXferLimit > ullLimit) ullXferLimit = ullLimit;

			if (ullXferBase < ullXferLimit)
			{
				++cLZXReadFromBuffer;

				CopyMemory(PBYTE(pv) + (ullXferBase - ullBase      ).Uli().LowPart,
						   pbBuff    + (ullXferBase - m_ullBuffBase).Uli().LowPart,
						   (ullXferLimit - ullXferBase).Uli().LowPart
						  );

				return HandleReadResidue(PBYTE(pv), pcbRead, fEOS, pSpan, 
										 ullBase,     ullLimit,
										 ullXferBase, ullXferLimit
										);
			}
		}
	}

    // At this point we know that the data does not exist in RAM. So we will
    // need to read and decompress data. The key question now is whether we
    // must reset the state of the decompression engine.

    ULARGE_INTEGER  uliVOffset,     uliXOffset, 
					uliVNextOffset, uliXNextOffset, 
					uliEndOffset,   uliXEndOffset;

    BOOL			fLastRec;

	if (CULINT(ulOffset) < (CULINT(m_ImageSpan.uliSize))) // Has the data been written out?  
	{
		ulEntryNext = m_pResetData->FindRecord(ulOffset, &uliXOffset, &fLastRec);
	    
		uliEndOffset = (CULINT(ulOffset) + cb - 1).Uli();

        if (CULINT(uliEndOffset) > CULINT(m_ImageSpan.uliSize))
             ulEntryLast = m_pResetData->GetRecordNum() - 1;
        else ulEntryLast = m_pResetData->FindRecord(uliEndOffset, &uliXEndOffset, &fLastRec);

        // Now we must decide where we have to start decompressing.
        // The best situation would be to continue decompressing from
        // the current read cursor position. However we can only do
        // that when the read starts after the cursor position within 
        // the current reset span.

        if (   m_ullReadCursor < m_ImageSpan.uliSize // Do we have a read state?
            && ullBase >= m_ullReadCursor            // Beyond current read cursor?
            && ullBase >= m_ullResetBase             // Within current reset span?
            && ullBase <  m_ullResetLimit
           )
        {
            ++cLZXReadFromCurrentSpan;

            ulEntryNext  = m_pResetData->FindRecord(m_ullReadCursor.Uli(), &uliXOffset, &fLastRec);
        }
		else
        {   
            ++cLZXReadFromOtherSpan;
            ulEntryNext -= ulEntryNext % N;
        }
	}
	else
	{  
        // The compressed data hasn't been written out yet. Instead it's in
        // m_buffWriteQueue. So we set the block index boundaries to avoid
        // the read-and-decompress loop entirely.

        ulEntryNext = 1;
		ulEntryLast = 0;
	}
	
	ULONG ulEntrySkipChk = ulEntryNext;
	
	ULONG TotalBytesRead   = 0;
    ULONG TotalBytesToRead = cb;

	for (; ulEntryNext <= ulEntryLast && SUCCEEDED(hr); ulEntryNext++)
    {
#ifdef _DEBUG
        BOOL fResult = 
#endif // _DEBUG        
        m_pResetData->FGetRecord(ulEntryNext, &uliVOffset, &uliXOffset, &fLastRec);

        RonM_ASSERT(fResult);

        if (fLastRec)
        {
            uliXNextOffset = CULINT(m_ImageSpanX.uliSize).Uli();
			uliVNextOffset = CULINT(m_ImageSpan .uliSize).Uli();
        }
        else
        {
#ifdef _DEBUG
            BOOL fResult = 
#endif // _DEBUG        
            m_pResetData->FGetRecord(ulEntryNext + 1, &uliVNextOffset, &uliXNextOffset, 
									 &fLastRec
                                    );

            RonM_ASSERT(fResult);
        }
        
        ULONG cBytesToReadX   = (CULINT(uliXNextOffset) - CULINT(uliXOffset)).Uli().LowPart;
	    ULONG cBytesToReadUnX = (CULINT(uliVNextOffset) - CULINT(uliVOffset)).Uli().LowPart;

        ULONG cbBytesRead;

		CBufferRef *prefOutput 
                      = (m_ControlData.dwOptions & OPT_FLAG_EXE) 
                             ? New CBufferRef(m_buffReadCache, m_context.cbMaxUncomBufSize) 
                             : NULL;

        if (cBytesToReadX)
        {
            hr = m_pITxNextInst->ReadAt(uliXOffset, refReadBuffer.StartAddress(),
										cBytesToReadX, &cbBytesRead, &m_ImageSpanX
                                       );

            if (SUCCEEDED(hr))
            {
                RonM_ASSERT(cbBytesRead == cBytesToReadX);

			    //We might have been appending zeros for last most block which could be 
			    //less than m_context.cbMaxUncomBufSize.

			    cbDestBufSize = cBytesToReadUnX;

                RonM_ASSERT(cbDestBufSize <= SOURCE_CHUNK);

			    if (m_ControlData.dwVersion == LZX_Current_Version)
				    cbDestBufSize = m_context.cbMaxUncomBufSize; 

                RonM_ASSERT(m_fDecompressionActive);

			    if (ulEntryNext % N == 0)
                {
				    ++cLZXResetDecompressor;

                    LDIResetDecompression(m_context.dHandle);
                    m_ullWindowBase = CULINT(ulEntryNext) 
                                      * CULINT(m_context.cbMaxUncomBufSize);
                    m_ullResetBase  = m_ullWindowBase;
                    m_ullResetLimit = m_ullResetBase + m_context.cbResetBlkSize;
                }

			    int err = LDIDecompress(m_context.dHandle, refReadBuffer.StartAddress(), 
						                cbBytesRead, prefOutput? prefOutput->StartAddress() 
                                                               : NULL,
						                (UINT *) &cbDestBufSize
                                       );

			    if (err != 0)
			    {
                    m_ullBuffBase   = -CULINT(1);
                    m_ullReadCursor = -CULINT(1);
				    hr = E_FAIL;
				    RonM_ASSERT(FALSE);
			    }
                else
                {
                    m_ullBuffBase   = uliVOffset;
                    m_ullReadCursor = m_ullBuffBase + cBytesToReadUnX;
                }

                PBYTE pbUncompressed = NULL;

                if (prefOutput) 
                    pbUncompressed = prefOutput->StartAddress();
                else
                {
                    long  cbOffsetUncompressed = 0;
                    long  cbOffsetWindow       = 0;
                    int   errCode              = 0;

                    errCode = LDIGetWindow(m_context.dHandle, &m_pbHistoryWindow, 
                                                              &cbOffsetUncompressed, 
                                                              &cbOffsetWindow, 
                                                              &m_cbHistoryWindow
                                          );
        
                    if (errCode != 0)
				    {
					    hr = E_FAIL;
					    RonM_ASSERT(FALSE);
				    }

                    // Since the history window is a ring buffer, we need
                    // to do some modulo arithmetic to find the last block
                    // image.

                    cbOffsetWindow = (cbOffsetWindow 
                                          + m_cbHistoryWindow
                                          - cbDestBufSize
                                     ) % m_context.lcfg.WindowSize;

                    pbUncompressed = m_pbHistoryWindow + cbOffsetWindow;
                }
		    
			    RonM_ASSERT(cBytesToReadUnX <= m_context.cbMaxUncomBufSize);
			    RonM_ASSERT(cbDestBufSize   <= m_context.cbMaxUncomBufSize);
                
               // if (cBytesToReadUnX < m_context.cbMaxUncomBufSize)
			   //	  cbDestBufSize = cBytesToReadUnX;

                RonM_ASSERT(cbDestBufSize >= (CULINT(uliVNextOffset) - CULINT(uliVOffset)));
			    
                if (ullBase < m_ullReadCursor) // Is our starting point in this buffer?
                {
                    RonM_ASSERT(ullBase >= m_ullBuffBase);
                
                    ULONG BytesToSkip = (ullBase - m_ullBuffBase).Uli().LowPart;

                    pbUncompressed += BytesToSkip;
                    cbDestBufSize  -= BytesToSkip;

                    ULONG cBytesToCopy = cbDestBufSize;

                    if (cBytesToCopy > (TotalBytesToRead-TotalBytesRead))
                        cBytesToCopy = (TotalBytesToRead-TotalBytesRead);

				    memCpy((LPBYTE)pv + TotalBytesRead, pbUncompressed, cBytesToCopy);
				    
				    TotalBytesRead += cBytesToCopy;

                    ullBase = m_ullReadCursor;  
			    }
            }//ReadAt
        }
    
        if (prefOutput) delete prefOutput;
	} //End for

    if (!SUCCEEDED(hr))
    {
        *pcbRead = 0;

        return hr;
    }

    if (ullBase < ullLimit) // Still have data to read?
    {
        // Then it must be in the write queue.

        RonM_ASSERT(m_cbUnFlushedBuf > 0);
        RonM_ASSERT(m_cbUnFlushedBuf < SOURCE_CHUNK);
        RonM_ASSERT(m_cbUnFlushedBuf >= (ullLimit - ullBase).Uli().LowPart);
        RonM_ASSERT(ullBase >= m_ImageSpan.uliSize);

        // We actually need to put some of these assertion tests into the
        // retail code to catch cases of ITS file corruption or errors in
        // the Win32 file system.

        if (   m_cbUnFlushedBuf == 0
            || ullBase < m_ImageSpan.uliSize
            || m_cbUnFlushedBuf < (ullLimit - ullBase).Uli().LowPart
           )
        {
            *pcbRead = 0;

            return STG_E_READFAULT; 
        }
        
        PBYTE pbWriteQueue = refBuffWriteQueue.StartAddress();

        DWORD cb = (ullLimit - ullBase).Uli().LowPart;

        CopyMemory(pv, pbWriteQueue + (ullBase - m_ImageSpan.uliSize).Uli().LowPart, cb);
        
        TotalBytesRead += cb;
    }

    RonM_ASSERT(!SUCCEEDED(hr) || TotalBytesToRead == TotalBytesRead);

    *pcbRead = TotalBytesRead;
    
    if (fEOS && hr == NO_ERROR && !*pcbRead)
	    hr = S_FALSE;

	return hr;
}

HRESULT STDMETHODCALLTYPE CTransformInstance::CImpITransformInstance::WriteAt( 
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [size_is][in] */ const void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbWritten,
	/* [out] */ImageSpan *pSpan)
{
/*
    This routine writes data into the MSCompressed data space. It hides all the details 
    of how data is actually stored and how it is cached and queued to optimized 
    performance.
    
    The *pSpan parameter identifies a logical segment of data which corresponds 
    to a stream in our caller's environment. This span value consists of a handle
    value which we assign, and a size value. By convention the handle value is
    a simple offset into the uncompressed linear data space which we simulate. If
    we get a WriteAt transaction where pSpan->uliSize is zero and cb is not, that's
    our signal to assign a handle value.

    The ulOffset parameter identifies where the write operation is to begin. It is
    given relative to the segment identified by *pSpan.

    The pv parameter defines where the write data is.

    The cb parameter defines how many bytes of data are to be written.

    The *pcbWritten value will indicate how many bytes were actually written.
 */
    	
	if (!cb)
    {
        *pcbWritten = 0;

        return NO_ERROR;
    }

    if (!m_fCompressionActive)
    {
        UINT  destSize2 = (UINT)m_context.cbMaxComBufSize;

	    int err= LCICreateCompression(&(m_context.cbMaxUncomBufSize),
                                      &(m_context.lcfg),
                                      MyAlloc,
                                      MyFree,
                                      &destSize2,
                                      &(m_context.cHandle),
		                              lzx_output_callback, (LPVOID)this
                                     );

        if (err == 0)
        {
            if (m_context.cbMaxComBufSize < destSize2)
                m_context.cbMaxComBufSize = destSize2;
            
            m_fCompressionActive = TRUE;
			
            //Making 10% faster decoding for nonexe data
	        if (!(m_ControlData.dwOptions & OPT_FLAG_EXE))
		        LCISetTranslationSize(m_context.cHandle, 0);
        }
        else return E_FAIL;
    }

    CBufferRef refLastBlock(m_buffWriteQueue, m_context.cbMaxUncomBufSize);

    PBYTE pbWriteQueueBuffer = refLastBlock.StartAddress();
	 
	if (!CULINT(pSpan->uliSize).NonZero())
		pSpan->uliHandle = (CULINT(m_ImageSpan.uliSize) + m_cbUnFlushedBuf).Uli();
	
	CULINT ullBase, ullLimit;
    
    ullBase  = CULINT(pSpan->uliHandle) + CULINT(ulOffset);
    ullLimit = ullBase + cb;

    CULINT ullLimitSegment = CULINT(pSpan->uliHandle) + CULINT(pSpan->uliSize);

    // The assert below verifies that the segment doesn't wrap around
    // through the beginning of the 64-bit address space.
    
    RonM_ASSERT(CULINT(pSpan->uliHandle) <= ullLimitSegment 
                || !(ullLimitSegment.NonZero())
               );

    if (    ullBase < CULINT(pSpan->uliHandle)
        || (ullBase > ullLimit && ullLimit.NonZero())
       )
    {
        // The write would wrap around.
        // This is very unlikely -- at least for the next few years.

        *pcbWritten = 0;

		return STG_E_WRITEFAULT;
    }
   	
	ulOffset = ullBase.Uli();

	//initialize out params
	*pcbWritten     = 0;

	HRESULT		hr	= NO_ERROR;
	
	 //writing in the middle not supported for now

    if (ullBase < (CULINT(m_ImageSpan.uliSize) + m_cbUnFlushedBuf))
    {
        RonM_ASSERT(FALSE);
        return E_FAIL;
    }

	if (!m_fCompressionInitialed)
    {
        // The first time we write to an ITS file, we must set up
        // the initial state of the LZX compressor. 

        hr = ReconstructCompressionState(pbWriteQueueBuffer);

        RonM_ASSERT(SUCCEEDED(hr));

        if (!SUCCEEDED(hr)) return E_FAIL;
    }
    
    ULONG cbWritten = 0;

    for (; cb;)
    {
        ULONG offNextWrite = m_cbUnFlushedBuf % SOURCE_CHUNK;

        ULONG cbToCopy = cb;
        ULONG cbAvail  = SOURCE_CHUNK - offNextWrite;

        RonM_ASSERT(cbAvail != 0);

        if (cbToCopy > cbAvail) 
            cbToCopy = cbAvail;

        CopyMemory(pbWriteQueueBuffer + offNextWrite, pv, cbToCopy);

        cb               -= cbToCopy;
        cbAvail          -= cbToCopy;
        m_cbUnFlushedBuf += cbToCopy;
        m_cbResetSpan    += cbToCopy;
        cbWritten        += cbToCopy;
        pv                = PBYTE(pv) + cbToCopy;

        if (cbAvail == 0)
        {
            hr = Write(pbWriteQueueBuffer, SOURCE_CHUNK);

            if (m_cbResetSpan == m_context.cbResetBlkSize) 
                FlushQueuedOutput();

            if (!SUCCEEDED(hr)) break;
        }
    }

	RonM_ASSERT(m_cbUnFlushedBuf < m_context.cbResetBlkSize);
	RonM_ASSERT(m_cbResetSpan    < m_context.cbResetBlkSize);
	
	*pcbWritten = cbWritten;

	pSpan->uliSize = (CULINT(pSpan->uliSize) + cbWritten).Uli();

	m_fDirty = TRUE;
    return hr;
}


HRESULT STDMETHODCALLTYPE CTransformInstance::CImpITransformInstance::Flush(void)
{
    // This routine gets all queued ITS data written out to the containing ILockBytes object.
    
    if (!m_fDirty) return NO_ERROR;

    HRESULT hr = Commit();

	if (SUCCEEDED(hr))
	{
		//Save reset table to disk

        hr = m_pResetData->CommitResetTable(m_ImageSpan.uliSize, m_ImageSpanX.uliSize);

		if (SUCCEEDED(hr))
		{
			m_fDirty = FALSE;

			hr = m_pITxNextInst->Flush();
		}
	}
	
	return hr;
}

HRESULT  CTransformInstance::CImpITransformInstance::Commit(void)
{
	// This routine forces all the queued write data to be written out.

    HRESULT hr = NO_ERROR;

	ULONG cbBytesToX = m_cbUnFlushedBuf % m_context.cbMaxUncomBufSize;

    if (cbBytesToX)
	{
        CBufferRef refQueuedData(m_buffWriteQueue, m_context.cbMaxUncomBufSize);

        PBYTE pbQueueData = refQueuedData.StartAddress();

		RonM_ASSERT(cbBytesToX < m_context.cbMaxUncomBufSize);

        ULONG cbPadding = m_context.cbMaxUncomBufSize - cbBytesToX;

		ZeroMemory(pbQueueData + cbBytesToX, cbPadding);
        
        m_cbUnFlushedBuf += cbPadding;

        hr = Write(pbQueueData, m_context.cbMaxUncomBufSize);

        if (SUCCEEDED(hr))
            hr = FlushQueuedOutput();

		if (SUCCEEDED(hr))
		{	
			// Pretend we didn't write those trailing zeroes.

			m_ImageSpan.uliSize  = (CULINT(m_ImageSpan.uliSize) - CULINT(cbPadding)).Uli();
		}//write compressed bytes to disk
	}//something remains to be transformed
    
    if (SUCCEEDED(hr))
        hr = FlushQueuedOutput();

	return hr;	
}

//This write takes care of the write request <= reset block size
HRESULT  CTransformInstance::CImpITransformInstance::Write(LPBYTE pbData, ULONG cbData)
{
    int     err           = 0;
	ULONG   cbDestBufSize = 0;
	HRESULT hr            = NO_ERROR;

	// BugBug: If we we're really always writing out a full block
    //         we should change the name of this routine and get
    //         rid of the cbData parameter.

    RonM_ASSERT(cbData == m_context.cbMaxUncomBufSize);

	m_context.hr = NO_ERROR;

#ifdef TXDEBUG
#ifdef _DEBUG
		BYTE XBuf[6];
		memCpy(XBuf, pbData + cbTotalBytesX, 6);
		printf("size = %d Blk=%x %x %x %x %x %x\n",
			cbBytesToBeX,
			XBuf[0], XBuf[1],XBuf[2],XBuf[3],XBuf[4], XBuf[5]);
#endif
#endif

	RonM_ASSERT(m_fCompressionActive);

    err = LCICompress(m_context.cHandle, pbData, cbData,
				      NULL, m_context.cbMaxComBufSize, &cbDestBufSize
                     );
    if (err == 0)
	{
     	hr = m_context.hr;
	}
	else hr = E_FAIL;

	return hr;
}

HRESULT CTransformInstance::CImpITransformInstance::FlushQueuedOutput()
{
    // This routine flushes output which is queued within the compressor.

    RonM_ASSERT(m_fCompressionActive);
    
	int err = LCIFlushCompressorOutput(m_context.cHandle);

    HRESULT hr = (err != 0)? E_FAIL : m_context.hr;	

	RonM_ASSERT(SUCCEEDED(hr));

    if (!SUCCEEDED(hr)) return hr;
	
	int mod = m_pResetData->GetRecordNum() % GetMulFactor();

	if (mod == 0)
	{
#ifdef TXDEBUG
#ifdef _DEBUG
		printf("resetting before %d\n", m_pResetData->GetRecordNum());
#endif
#endif
        RonM_ASSERT(m_fCompressionActive);

		err = LCIResetCompression(m_context.cHandle);
        
        if (err != 0) return E_FAIL;

        m_cbResetSpan -= m_context.cbResetBlkSize;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\urlmki.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Thu Apr 10 06:35:30 1997
 */
/* Compiler settings for urlmki.idl:
    Oic (OptLev=i1), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __urlmki_h__
#define __urlmki_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IPersistMoniker_FWD_DEFINED__
#define __IPersistMoniker_FWD_DEFINED__
typedef interface IPersistMoniker IPersistMoniker;
#endif 	/* __IPersistMoniker_FWD_DEFINED__ */


#ifndef __IBindProtocol_FWD_DEFINED__
#define __IBindProtocol_FWD_DEFINED__
typedef interface IBindProtocol IBindProtocol;
#endif 	/* __IBindProtocol_FWD_DEFINED__ */


#ifndef __IBinding_FWD_DEFINED__
#define __IBinding_FWD_DEFINED__
typedef interface IBinding IBinding;
#endif 	/* __IBinding_FWD_DEFINED__ */


#ifndef __IBindStatusCallback_FWD_DEFINED__
#define __IBindStatusCallback_FWD_DEFINED__
typedef interface IBindStatusCallback IBindStatusCallback;
#endif 	/* __IBindStatusCallback_FWD_DEFINED__ */


#ifndef __IAuthenticate_FWD_DEFINED__
#define __IAuthenticate_FWD_DEFINED__
typedef interface IAuthenticate IAuthenticate;
#endif 	/* __IAuthenticate_FWD_DEFINED__ */


#ifndef __IHttpNegotiate_FWD_DEFINED__
#define __IHttpNegotiate_FWD_DEFINED__
typedef interface IHttpNegotiate IHttpNegotiate;
#endif 	/* __IHttpNegotiate_FWD_DEFINED__ */


#ifndef __IWindowForBindingUI_FWD_DEFINED__
#define __IWindowForBindingUI_FWD_DEFINED__
typedef interface IWindowForBindingUI IWindowForBindingUI;
#endif 	/* __IWindowForBindingUI_FWD_DEFINED__ */


#ifndef __ICodeInstall_FWD_DEFINED__
#define __ICodeInstall_FWD_DEFINED__
typedef interface ICodeInstall ICodeInstall;
#endif 	/* __ICodeInstall_FWD_DEFINED__ */


#ifndef __IWinInetInfo_FWD_DEFINED__
#define __IWinInetInfo_FWD_DEFINED__
typedef interface IWinInetInfo IWinInetInfo;
#endif 	/* __IWinInetInfo_FWD_DEFINED__ */


#ifndef __IHttpSecurity_FWD_DEFINED__
#define __IHttpSecurity_FWD_DEFINED__
typedef interface IHttpSecurity IHttpSecurity;
#endif 	/* __IHttpSecurity_FWD_DEFINED__ */


#ifndef __IWinInetHttpInfo_FWD_DEFINED__
#define __IWinInetHttpInfo_FWD_DEFINED__
typedef interface IWinInetHttpInfo IWinInetHttpInfo;
#endif 	/* __IWinInetHttpInfo_FWD_DEFINED__ */


#ifndef __IBindHost_FWD_DEFINED__
#define __IBindHost_FWD_DEFINED__
typedef interface IBindHost IBindHost;
#endif 	/* __IBindHost_FWD_DEFINED__ */


#ifndef __IOInet_FWD_DEFINED__
#define __IOInet_FWD_DEFINED__
typedef interface IOInet IOInet;
#endif 	/* __IOInet_FWD_DEFINED__ */


#ifndef __IOInetBindInfo_FWD_DEFINED__
#define __IOInetBindInfo_FWD_DEFINED__
typedef interface IOInetBindInfo IOInetBindInfo;
#endif 	/* __IOInetBindInfo_FWD_DEFINED__ */


#ifndef __IOInetBindClient_FWD_DEFINED__
#define __IOInetBindClient_FWD_DEFINED__
typedef interface IOInetBindClient IOInetBindClient;
#endif 	/* __IOInetBindClient_FWD_DEFINED__ */


#ifndef __IOInetProtocolRoot_FWD_DEFINED__
#define __IOInetProtocolRoot_FWD_DEFINED__
typedef interface IOInetProtocolRoot IOInetProtocolRoot;
#endif 	/* __IOInetProtocolRoot_FWD_DEFINED__ */


#ifndef __IOInetProtocol_FWD_DEFINED__
#define __IOInetProtocol_FWD_DEFINED__
typedef interface IOInetProtocol IOInetProtocol;
#endif 	/* __IOInetProtocol_FWD_DEFINED__ */


#ifndef __IOInetProtocolSink_FWD_DEFINED__
#define __IOInetProtocolSink_FWD_DEFINED__
typedef interface IOInetProtocolSink IOInetProtocolSink;
#endif 	/* __IOInetProtocolSink_FWD_DEFINED__ */


#ifndef __IOInetBinding_FWD_DEFINED__
#define __IOInetBinding_FWD_DEFINED__
typedef interface IOInetBinding IOInetBinding;
#endif 	/* __IOInetBinding_FWD_DEFINED__ */


#ifndef __IOInetSession_FWD_DEFINED__
#define __IOInetSession_FWD_DEFINED__
typedef interface IOInetSession IOInetSession;
#endif 	/* __IOInetSession_FWD_DEFINED__ */


#ifndef __IOInetThreadSwitch_FWD_DEFINED__
#define __IOInetThreadSwitch_FWD_DEFINED__
typedef interface IOInetThreadSwitch IOInetThreadSwitch;
#endif 	/* __IOInetThreadSwitch_FWD_DEFINED__ */


#ifndef __IOInetBindSink_FWD_DEFINED__
#define __IOInetBindSink_FWD_DEFINED__
typedef interface IOInetBindSink IOInetBindSink;
#endif 	/* __IOInetBindSink_FWD_DEFINED__ */


#ifndef __IOInetCache_FWD_DEFINED__
#define __IOInetCache_FWD_DEFINED__
typedef interface IOInetCache IOInetCache;
#endif 	/* __IOInetCache_FWD_DEFINED__ */


#ifndef __IOInetPriority_FWD_DEFINED__
#define __IOInetPriority_FWD_DEFINED__
typedef interface IOInetPriority IOInetPriority;
#endif 	/* __IOInetPriority_FWD_DEFINED__ */


#ifndef __IOInetParse_FWD_DEFINED__
#define __IOInetParse_FWD_DEFINED__
typedef interface IOInetParse IOInetParse;
#endif 	/* __IOInetParse_FWD_DEFINED__ */


#ifndef __IBindStatusCallbackMsg_FWD_DEFINED__
#define __IBindStatusCallbackMsg_FWD_DEFINED__
typedef interface IBindStatusCallbackMsg IBindStatusCallbackMsg;
#endif 	/* __IBindStatusCallbackMsg_FWD_DEFINED__ */


#ifndef __IBindStatusCallbackHolder_FWD_DEFINED__
#define __IBindStatusCallbackHolder_FWD_DEFINED__
typedef interface IBindStatusCallbackHolder IBindStatusCallbackHolder;
#endif 	/* __IBindStatusCallbackHolder_FWD_DEFINED__ */


#ifndef __IMediaHolder_FWD_DEFINED__
#define __IMediaHolder_FWD_DEFINED__
typedef interface IMediaHolder IMediaHolder;
#endif 	/* __IMediaHolder_FWD_DEFINED__ */


#ifndef __ITransactionData_FWD_DEFINED__
#define __ITransactionData_FWD_DEFINED__
typedef interface ITransactionData ITransactionData;
#endif 	/* __ITransactionData_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "servprov.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0000
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// UrlMon.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// URL Moniker Interfaces.











// These are for backwards compatibility with previous URLMON versions
#define BINDF_DONTUSECACHE BINDF_GETNEWESTVERSION
#define BINDF_DONTPUTINCACHE BINDF_NOWRITECACHE
#define BINDF_NOCOPYDATA BINDF_PULLDATA
EXTERN_C const IID IID_IAsyncMoniker;    
EXTERN_C const IID CLSID_StdURLMoniker;  
EXTERN_C const IID CLSID_HttpProtocol;   
EXTERN_C const IID CLSID_FtpProtocol;    
EXTERN_C const IID CLSID_GopherProtocol; 
EXTERN_C const IID CLSID_HttpSProtocol;  
EXTERN_C const IID CLSID_FileProtocol;   
EXTERN_C const IID CLSID_MkProtocol;     
EXTERN_C const IID CLSID_StdURLProtocol; 
EXTERN_C const IID CLSID_UrlMkBindCtx;   
EXTERN_C const IID IID_IAsyncBindCtx;    
 
#define SZ_URLCONTEXT           OLESTR("URL Context")
#define SZ_ASYNC_CALLEE         OLESTR("AsyncCallee")
#define MKSYS_URLMONIKER    6                 
 
STDAPI CreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk);             
STDAPI GetClassURL(LPCWSTR szURL, CLSID *pClsID);                                           
STDAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb,                       
                                IEnumFORMATETC *pEFetc, IBindCtx **ppBC);                   
STDAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum,   
                            IBindCtx **ppBC, DWORD reserved);                                                     
STDAPI MkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten,          
                                LPMONIKER *ppmk);                                           
STDAPI RegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb,                     
                                IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved);       
STDAPI RevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb);                      
STDAPI GetClassFileOrMime(LPBC pBC, LPCWSTR szFilename, LPVOID pBuffer, DWORD cbSize, LPCWSTR szMime, DWORD dwReserved, CLSID *pclsid); 
STDAPI IsValidURL(LPBC pBC, LPCWSTR szURL, DWORD dwReserved);                               
STDAPI CoGetClassObjectFromURL( REFCLSID rCLASSID,
            LPCWSTR szCODE, DWORD dwFileVersionMS, 
            DWORD dwFileVersionLS, LPCWSTR szTYPE,
            LPBINDCTX pBindCtx, DWORD dwClsContext,
            LPVOID pvReserved, REFIID riid, LPVOID * ppv);
 
//helper apis                                                                               
STDAPI IsAsyncMoniker(IMoniker* pmk);                                                       
STDAPI CreateURLBinding(LPCWSTR lpszUrl, IBindCtx *pbc, IBinding **ppBdg);                  
 
STDAPI RegisterMediaTypesW(UINT ctypes, const LPCWSTR* rgszTypes, CLIPFORMAT* rgcfTypes);          
STDAPI RegisterMediaTypes(UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes);            
STDAPI FindMediaType(LPCSTR rgszTypes, CLIPFORMAT* rgcfTypes);                                       
STDAPI CreateFormatEnumerator( UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc); 
STDAPI RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc, DWORD reserved);          
STDAPI RevokeFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc);                            
STDAPI RegisterMediaTypeClass(LPBC pBC,UINT ctypes, const LPCSTR* rgszTypes, CLSID *rgclsID, DWORD reserved);    
STDAPI FindMediaTypeClass(LPBC pBC, LPCSTR szType, CLSID *pclsID, DWORD reserved);                          
STDAPI UrlMkSetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD dwReserved);       
STDAPI FindMimeFromData(                                                                                                                  
                        LPBC pBC,                           // bind context - can be NULL                                                 
                        LPCWSTR pwzUrl,                     // url - can be null                                                          
                        LPVOID pBuffer,                     // buffer with data to sniff - can be null (pwzUrl must be valid)             
                        DWORD cbSize,                       // size of buffer                                                             
                        LPCWSTR pwzMimeProposed,            // proposed mime if - can be null                                             
                        DWORD dwMimeFlags,                  // will be defined                                                            
                        LPWSTR *ppwzMimeOut,                // the suggested mime                                                         
                        DWORD dwReserved);                  // must be 0                                                                  
 
// URLMON-specific defines for UrlMkSetSessionOption() above
#define URLMON_OPTION_USERAGENT  0x10000001
 
#define CF_NULL                 0                                  
#define CFSTR_MIME_NULL         NULL                               
#define CFSTR_MIME_TEXT         (TEXT("text/plain"))             
#define CFSTR_MIME_RICHTEXT     (TEXT("text/richtext"))          
#define CFSTR_MIME_X_BITMAP     (TEXT("image/x-xbitmap"))        
#define CFSTR_MIME_POSTSCRIPT   (TEXT("application/postscript")) 
#define CFSTR_MIME_AIFF         (TEXT("audio/aiff"))             
#define CFSTR_MIME_BASICAUDIO   (TEXT("audio/basic"))            
#define CFSTR_MIME_WAV          (TEXT("audio/wav"))              
#define CFSTR_MIME_X_WAV        (TEXT("audio/x-wav"))            
#define CFSTR_MIME_GIF          (TEXT("image/gif"))              
#define CFSTR_MIME_PJPEG        (TEXT("image/pjpeg"))            
#define CFSTR_MIME_JPEG         (TEXT("image/jpeg"))             
#define CFSTR_MIME_TIFF         (TEXT("image/tiff"))             
#define CFSTR_MIME_X_PNG        (TEXT("image/x-png"))            
#define CFSTR_MIME_BMP          (TEXT("image/bmp"))              
#define CFSTR_MIME_X_ART        (TEXT("image/x-jg"))             
#define CFSTR_MIME_X_EMF        (TEXT("image/x-emf"))            
#define CFSTR_MIME_X_WMF        (TEXT("image/x-wmf"))            
#define CFSTR_MIME_AVI          (TEXT("video/avi"))              
#define CFSTR_MIME_MPEG         (TEXT("video/mpeg"))             
#define CFSTR_MIME_FRACTALS     (TEXT("application/fractals"))   
#define CFSTR_MIME_RAWDATA      (TEXT("application/octet-stream"))
#define CFSTR_MIME_RAWDATASTRM  (TEXT("application/octet-stream"))
#define CFSTR_MIME_PDF          (TEXT("application/pdf"))        
#define CFSTR_MIME_X_AIFF       (TEXT("audio/x-aiff"))           
#define CFSTR_MIME_X_REALAUDIO  (TEXT("audio/x-pn-realaudio"))   
#define CFSTR_MIME_XBM          (TEXT("image/xbm"))              
#define CFSTR_MIME_QUICKTIME    (TEXT("video/quicktime"))        
#define CFSTR_MIME_X_MSVIDEO    (TEXT("video/x-msvideo"))        
#define CFSTR_MIME_X_SGI_MOVIE  (TEXT("video/x-sgi-movie"))      
#define CFSTR_MIME_HTML         (TEXT("text/html"))              
 
// MessageId: MK_S_ASYNCHRONOUS                                              
// MessageText: Operation is successful, but will complete asynchronously.   
//                                                                           
#define MK_S_ASYNCHRONOUS    _HRESULT_TYPEDEF_(0x000401E8L)                  
#define S_ASYNCHRONOUS       MK_S_ASYNCHRONOUS                               
                                                                             
#ifndef E_PENDING                                                            
#define E_PENDING _HRESULT_TYPEDEF_(0x8000000AL)                             
#endif                                                                       
                                                                             
//                                                                           
//                                                                           
// WinINet and protocol specific errors are mapped to one of the following   
// error which are returned in IBSC::OnStopBinding                           
//                                                                           
//                                                                           
#define INET_E_INVALID_URL               _HRESULT_TYPEDEF_(0x800C0002L)      
#define INET_E_NO_SESSION                _HRESULT_TYPEDEF_(0x800C0003L)      
#define INET_E_CANNOT_CONNECT            _HRESULT_TYPEDEF_(0x800C0004L)      
#define INET_E_RESOURCE_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0005L)      
#define INET_E_OBJECT_NOT_FOUND          _HRESULT_TYPEDEF_(0x800C0006L)      
#define INET_E_DATA_NOT_AVAILABLE        _HRESULT_TYPEDEF_(0x800C0007L)      
#define INET_E_DOWNLOAD_FAILURE          _HRESULT_TYPEDEF_(0x800C0008L)      
#define INET_E_AUTHENTICATION_REQUIRED   _HRESULT_TYPEDEF_(0x800C0009L)      
#define INET_E_NO_VALID_MEDIA            _HRESULT_TYPEDEF_(0x800C000AL)      
#define INET_E_CONNECTION_TIMEOUT        _HRESULT_TYPEDEF_(0x800C000BL)      
#define INET_E_INVALID_REQUEST           _HRESULT_TYPEDEF_(0x800C000CL)      
#define INET_E_UNKNOWN_PROTOCOL          _HRESULT_TYPEDEF_(0x800C000DL)      
#define INET_E_SECURITY_PROBLEM          _HRESULT_TYPEDEF_(0x800C000EL)      
#define INET_E_CANNOT_LOAD_DATA          _HRESULT_TYPEDEF_(0x800C000FL)      
#define INET_E_CANNOT_INSTANTIATE_OBJECT _HRESULT_TYPEDEF_(0x800C0010L)      
#define INET_E_ERROR_FIRST               _HRESULT_TYPEDEF_(0x800C0002L)      
#define INET_E_ERROR_LAST                INET_E_CANNOT_INSTANTIATE_OBJECT    
#ifndef _LPPERSISTMONIKER_DEFINED
#define _LPPERSISTMONIKER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0000_v0_0_s_ifspec;

#ifndef __IPersistMoniker_INTERFACE_DEFINED__
#define __IPersistMoniker_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPersistMoniker
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IPersistMoniker __RPC_FAR *LPPERSISTMONIKER;


EXTERN_C const IID IID_IPersistMoniker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9c9-baf9-11ce-8c82-00aa004ba90b")
    IPersistMoniker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassID( 
            /* [out] */ CLSID __RPC_FAR *pClassID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pbc,
            /* [in] */ BOOL fRemember) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveCompleted( 
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurMoniker( 
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppimkName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistMonikerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPersistMoniker __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPersistMoniker __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPersistMoniker __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )( 
            IPersistMoniker __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )( 
            IPersistMoniker __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IPersistMoniker __RPC_FAR * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IPersistMoniker __RPC_FAR * This,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pbc,
            /* [in] */ BOOL fRemember);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveCompleted )( 
            IPersistMoniker __RPC_FAR * This,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurMoniker )( 
            IPersistMoniker __RPC_FAR * This,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppimkName);
        
        END_INTERFACE
    } IPersistMonikerVtbl;

    interface IPersistMoniker
    {
        CONST_VTBL struct IPersistMonikerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistMoniker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistMoniker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistMoniker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistMoniker_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)

#define IPersistMoniker_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IPersistMoniker_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode)

#define IPersistMoniker_Save(This,pimkName,pbc,fRemember)	\
    (This)->lpVtbl -> Save(This,pimkName,pbc,fRemember)

#define IPersistMoniker_SaveCompleted(This,pimkName,pibc)	\
    (This)->lpVtbl -> SaveCompleted(This,pimkName,pibc)

#define IPersistMoniker_GetCurMoniker(This,ppimkName)	\
    (This)->lpVtbl -> GetCurMoniker(This,ppimkName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPersistMoniker_GetClassID_Proxy( 
    IPersistMoniker __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pClassID);


void __RPC_STUB IPersistMoniker_GetClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistMoniker_IsDirty_Proxy( 
    IPersistMoniker __RPC_FAR * This);


void __RPC_STUB IPersistMoniker_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistMoniker_Load_Proxy( 
    IPersistMoniker __RPC_FAR * This,
    /* [in] */ BOOL fFullyAvailable,
    /* [in] */ IMoniker __RPC_FAR *pimkName,
    /* [in] */ LPBC pibc,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IPersistMoniker_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistMoniker_Save_Proxy( 
    IPersistMoniker __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pimkName,
    /* [in] */ LPBC pbc,
    /* [in] */ BOOL fRemember);


void __RPC_STUB IPersistMoniker_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistMoniker_SaveCompleted_Proxy( 
    IPersistMoniker __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pimkName,
    /* [in] */ LPBC pibc);


void __RPC_STUB IPersistMoniker_SaveCompleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistMoniker_GetCurMoniker_Proxy( 
    IPersistMoniker __RPC_FAR * This,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppimkName);


void __RPC_STUB IPersistMoniker_GetCurMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersistMoniker_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0084
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPBINDPROTOCOL_DEFINED
#define _LPBINDPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0084_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0084_v0_0_s_ifspec;

#ifndef __IBindProtocol_INTERFACE_DEFINED__
#define __IBindProtocol_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBindProtocol
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IBindProtocol __RPC_FAR *LPBINDPROTOCOL;


EXTERN_C const IID IID_IBindProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9cd-baf9-11ce-8c82-00aa004ba90b")
    IBindProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateBinding( 
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IBindCtx __RPC_FAR *pbc,
            /* [out] */ IBinding __RPC_FAR *__RPC_FAR *ppb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBindProtocol __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBindProtocol __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBindProtocol __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateBinding )( 
            IBindProtocol __RPC_FAR * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IBindCtx __RPC_FAR *pbc,
            /* [out] */ IBinding __RPC_FAR *__RPC_FAR *ppb);
        
        END_INTERFACE
    } IBindProtocolVtbl;

    interface IBindProtocol
    {
        CONST_VTBL struct IBindProtocolVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindProtocol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindProtocol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindProtocol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindProtocol_CreateBinding(This,szUrl,pbc,ppb)	\
    (This)->lpVtbl -> CreateBinding(This,szUrl,pbc,ppb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBindProtocol_CreateBinding_Proxy( 
    IBindProtocol __RPC_FAR * This,
    /* [in] */ LPCWSTR szUrl,
    /* [in] */ IBindCtx __RPC_FAR *pbc,
    /* [out] */ IBinding __RPC_FAR *__RPC_FAR *ppb);


void __RPC_STUB IBindProtocol_CreateBinding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindProtocol_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0085
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPBINDING_DEFINED
#define _LPBINDING_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0085_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0085_v0_0_s_ifspec;

#ifndef __IBinding_INTERFACE_DEFINED__
#define __IBinding_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBinding
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IBinding __RPC_FAR *LPBINDING;


EXTERN_C const IID IID_IBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9c0-baf9-11ce-8c82-00aa004ba90b")
    IBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ LONG nPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ LONG __RPC_FAR *pnPriority) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindResult( 
            /* [out] */ CLSID __RPC_FAR *pclsidProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwResult,
            /* [out] */ LPOLESTR __RPC_FAR *pszResult,
            /* [out][in] */ DWORD __RPC_FAR *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBinding __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBinding __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBinding __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IBinding __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IBinding __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IBinding __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPriority )( 
            IBinding __RPC_FAR * This,
            /* [in] */ LONG nPriority);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPriority )( 
            IBinding __RPC_FAR * This,
            /* [out] */ LONG __RPC_FAR *pnPriority);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBindResult )( 
            IBinding __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pclsidProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwResult,
            /* [out] */ LPOLESTR __RPC_FAR *pszResult,
            /* [out][in] */ DWORD __RPC_FAR *pdwReserved);
        
        END_INTERFACE
    } IBindingVtbl;

    interface IBinding
    {
        CONST_VTBL struct IBindingVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBinding_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define IBinding_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IBinding_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IBinding_SetPriority(This,nPriority)	\
    (This)->lpVtbl -> SetPriority(This,nPriority)

#define IBinding_GetPriority(This,pnPriority)	\
    (This)->lpVtbl -> GetPriority(This,pnPriority)

#define IBinding_GetBindResult(This,pclsidProtocol,pdwResult,pszResult,pdwReserved)	\
    (This)->lpVtbl -> GetBindResult(This,pclsidProtocol,pdwResult,pszResult,pdwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBinding_Abort_Proxy( 
    IBinding __RPC_FAR * This);


void __RPC_STUB IBinding_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBinding_Suspend_Proxy( 
    IBinding __RPC_FAR * This);


void __RPC_STUB IBinding_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBinding_Resume_Proxy( 
    IBinding __RPC_FAR * This);


void __RPC_STUB IBinding_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBinding_SetPriority_Proxy( 
    IBinding __RPC_FAR * This,
    /* [in] */ LONG nPriority);


void __RPC_STUB IBinding_SetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBinding_GetPriority_Proxy( 
    IBinding __RPC_FAR * This,
    /* [out] */ LONG __RPC_FAR *pnPriority);


void __RPC_STUB IBinding_GetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBinding_RemoteGetBindResult_Proxy( 
    IBinding __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pclsidProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwResult,
    /* [out] */ LPOLESTR __RPC_FAR *pszResult,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IBinding_RemoteGetBindResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBinding_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0086
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPBINDSTATUSCALLBACK_DEFINED
#define _LPBINDSTATUSCALLBACK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0086_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0086_v0_0_s_ifspec;

#ifndef __IBindStatusCallback_INTERFACE_DEFINED__
#define __IBindStatusCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBindStatusCallback
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IBindStatusCallback __RPC_FAR *LPBINDSTATUSCALLBACK;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0001
    {	BINDVERB_GET	= 0,
	BINDVERB_POST	= 0x1,
	BINDVERB_PUT	= 0x2,
	BINDVERB_CUSTOM	= 0x3
    }	BINDVERB;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0002
    {	BINDINFOF_URLENCODESTGMEDDATA	= 0x1,
	BINDINFOF_URLENCODEDEXTRAINFO	= 0x2
    }	BINDINFOF;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0003
    {	BINDF_ASYNCHRONOUS	= 0x1,
	BINDF_ASYNCSTORAGE	= 0x2,
	BINDF_NOPROGRESSIVERENDERING	= 0x4,
	BINDF_OFFLINEOPERATION	= 0x8,
	BINDF_GETNEWESTVERSION	= 0x10,
	BINDF_NOWRITECACHE	= 0x20,
	BINDF_NEEDFILE	= 0x40,
	BINDF_PULLDATA	= 0x80,
	BINDF_IGNORESECURITYPROBLEM	= 0x100,
	BINDF_RESYNCHRONIZE	= 0x200,
	BINDF_HYPERLINK	= 0x400,
	BINDF_NO_UI	= 0x800,
	BINDF_SILENTOPERATION	= 0x1000,
	BINDF_PRAGMA_NO_CACHE	= 0x2000
    }	BINDF;

typedef struct  _tagBINDINFO
    {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    STGMEDIUM stgmedData;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
    }	BINDINFO;

typedef struct  _tagRemBINDINFO
    {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
    }	RemBINDINFO;

typedef struct  tagRemFORMATETC
    {
    DWORD cfFormat;
    DWORD ptd;
    DWORD dwAspect;
    LONG lindex;
    DWORD tymed;
    }	RemFORMATETC;

typedef struct tagRemFORMATETC __RPC_FAR *LPREMFORMATETC;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0004
    {	BSCF_FIRSTDATANOTIFICATION	= 0x1,
	BSCF_INTERMEDIATEDATANOTIFICATION	= 0x2,
	BSCF_LASTDATANOTIFICATION	= 0x4,
	BSCF_DATAFULLYAVAILABLE	= 0x8
    }	BSCF;

typedef 
enum tagBINDSTATUS
    {	BINDSTATUS_FINDINGRESOURCE	= 1,
	BINDSTATUS_CONNECTING	= BINDSTATUS_FINDINGRESOURCE + 1,
	BINDSTATUS_REDIRECTING	= BINDSTATUS_CONNECTING + 1,
	BINDSTATUS_BEGINDOWNLOADDATA	= BINDSTATUS_REDIRECTING + 1,
	BINDSTATUS_DOWNLOADINGDATA	= BINDSTATUS_BEGINDOWNLOADDATA + 1,
	BINDSTATUS_ENDDOWNLOADDATA	= BINDSTATUS_DOWNLOADINGDATA + 1,
	BINDSTATUS_BEGINDOWNLOADCOMPONENTS	= BINDSTATUS_ENDDOWNLOADDATA + 1,
	BINDSTATUS_INSTALLINGCOMPONENTS	= BINDSTATUS_BEGINDOWNLOADCOMPONENTS + 1,
	BINDSTATUS_ENDDOWNLOADCOMPONENTS	= BINDSTATUS_INSTALLINGCOMPONENTS + 1,
	BINDSTATUS_USINGCACHEDCOPY	= BINDSTATUS_ENDDOWNLOADCOMPONENTS + 1,
	BINDSTATUS_SENDINGREQUEST	= BINDSTATUS_USINGCACHEDCOPY + 1,
	BINDSTATUS_CLASSIDAVAILABLE	= BINDSTATUS_SENDINGREQUEST + 1,
	BINDSTATUS_MIMETYPEAVAILABLE	= BINDSTATUS_CLASSIDAVAILABLE + 1,
	BINDSTATUS_CACHEFILENAMEAVAILABLE	= BINDSTATUS_MIMETYPEAVAILABLE + 1,
	BINDSTATUS_BEGINSYNCOPERATION	= BINDSTATUS_CACHEFILENAMEAVAILABLE + 1,
	BINDSTATUS_ENDSYNCOPERATION	= BINDSTATUS_BEGINSYNCOPERATION + 1
    }	BINDSTATUS;


EXTERN_C const IID IID_IBindStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9c1-baf9-11ce-8c82-00aa004ba90b")
    IBindStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartBinding( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding __RPC_FAR *pib) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ LONG __RPC_FAR *pnPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLowResource( 
            /* [in] */ DWORD reserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStopBinding( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindInfo( 
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnDataAvailable( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ STGMEDIUM __RPC_FAR *pstgmed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjectAvailable( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown __RPC_FAR *punk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBindStatusCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBindStatusCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBindStatusCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartBinding )( 
            IBindStatusCallback __RPC_FAR * This,
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding __RPC_FAR *pib);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPriority )( 
            IBindStatusCallback __RPC_FAR * This,
            /* [out] */ LONG __RPC_FAR *pnPriority);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLowResource )( 
            IBindStatusCallback __RPC_FAR * This,
            /* [in] */ DWORD reserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnProgress )( 
            IBindStatusCallback __RPC_FAR * This,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStopBinding )( 
            IBindStatusCallback __RPC_FAR * This,
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBindInfo )( 
            IBindStatusCallback __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataAvailable )( 
            IBindStatusCallback __RPC_FAR * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ STGMEDIUM __RPC_FAR *pstgmed);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnObjectAvailable )( 
            IBindStatusCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown __RPC_FAR *punk);
        
        END_INTERFACE
    } IBindStatusCallbackVtbl;

    interface IBindStatusCallback
    {
        CONST_VTBL struct IBindStatusCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindStatusCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindStatusCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindStatusCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindStatusCallback_OnStartBinding(This,dwReserved,pib)	\
    (This)->lpVtbl -> OnStartBinding(This,dwReserved,pib)

#define IBindStatusCallback_GetPriority(This,pnPriority)	\
    (This)->lpVtbl -> GetPriority(This,pnPriority)

#define IBindStatusCallback_OnLowResource(This,reserved)	\
    (This)->lpVtbl -> OnLowResource(This,reserved)

#define IBindStatusCallback_OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)	\
    (This)->lpVtbl -> OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)

#define IBindStatusCallback_OnStopBinding(This,hresult,szError)	\
    (This)->lpVtbl -> OnStopBinding(This,hresult,szError)

#define IBindStatusCallback_GetBindInfo(This,grfBINDF,pbindinfo)	\
    (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo)

#define IBindStatusCallback_OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed)	\
    (This)->lpVtbl -> OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed)

#define IBindStatusCallback_OnObjectAvailable(This,riid,punk)	\
    (This)->lpVtbl -> OnObjectAvailable(This,riid,punk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnStartBinding_Proxy( 
    IBindStatusCallback __RPC_FAR * This,
    /* [in] */ DWORD dwReserved,
    /* [in] */ IBinding __RPC_FAR *pib);


void __RPC_STUB IBindStatusCallback_OnStartBinding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetPriority_Proxy( 
    IBindStatusCallback __RPC_FAR * This,
    /* [out] */ LONG __RPC_FAR *pnPriority);


void __RPC_STUB IBindStatusCallback_GetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnLowResource_Proxy( 
    IBindStatusCallback __RPC_FAR * This,
    /* [in] */ DWORD reserved);


void __RPC_STUB IBindStatusCallback_OnLowResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnProgress_Proxy( 
    IBindStatusCallback __RPC_FAR * This,
    /* [in] */ ULONG ulProgress,
    /* [in] */ ULONG ulProgressMax,
    /* [in] */ ULONG ulStatusCode,
    /* [in] */ LPCWSTR szStatusText);


void __RPC_STUB IBindStatusCallback_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnStopBinding_Proxy( 
    IBindStatusCallback __RPC_FAR * This,
    /* [in] */ HRESULT hresult,
    /* [unique][in] */ LPCWSTR szError);


void __RPC_STUB IBindStatusCallback_OnStopBinding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_RemoteGetBindInfo_Proxy( 
    IBindStatusCallback __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *grfBINDF,
    /* [unique][out][in] */ RemBINDINFO __RPC_FAR *pbindinfo,
    /* [unique][out][in] */ RemSTGMEDIUM __RPC_FAR *pstgmed);


void __RPC_STUB IBindStatusCallback_RemoteGetBindInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_RemoteOnDataAvailable_Proxy( 
    IBindStatusCallback __RPC_FAR * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ RemFORMATETC __RPC_FAR *pformatetc,
    /* [in] */ RemSTGMEDIUM __RPC_FAR *pstgmed);


void __RPC_STUB IBindStatusCallback_RemoteOnDataAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnObjectAvailable_Proxy( 
    IBindStatusCallback __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IBindStatusCallback_OnObjectAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindStatusCallback_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0087
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPAUTHENTICATION_DEFINED
#define _LPAUTHENTICATION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0087_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0087_v0_0_s_ifspec;

#ifndef __IAuthenticate_INTERFACE_DEFINED__
#define __IAuthenticate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAuthenticate
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IAuthenticate __RPC_FAR *LPAUTHENTICATION;


EXTERN_C const IID IID_IAuthenticate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9d0-baf9-11ce-8c82-00aa004ba90b")
    IAuthenticate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Authenticate( 
            /* [out] */ HWND __RPC_FAR *phwnd,
            /* [out] */ LPWSTR __RPC_FAR *pszUsername,
            /* [out] */ LPWSTR __RPC_FAR *pszPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuthenticateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAuthenticate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAuthenticate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAuthenticate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Authenticate )( 
            IAuthenticate __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd,
            /* [out] */ LPWSTR __RPC_FAR *pszUsername,
            /* [out] */ LPWSTR __RPC_FAR *pszPassword);
        
        END_INTERFACE
    } IAuthenticateVtbl;

    interface IAuthenticate
    {
        CONST_VTBL struct IAuthenticateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthenticate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAuthenticate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAuthenticate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAuthenticate_Authenticate(This,phwnd,pszUsername,pszPassword)	\
    (This)->lpVtbl -> Authenticate(This,phwnd,pszUsername,pszPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAuthenticate_Authenticate_Proxy( 
    IAuthenticate __RPC_FAR * This,
    /* [out] */ HWND __RPC_FAR *phwnd,
    /* [out] */ LPWSTR __RPC_FAR *pszUsername,
    /* [out] */ LPWSTR __RPC_FAR *pszPassword);


void __RPC_STUB IAuthenticate_Authenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAuthenticate_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0088
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPHTTPNEGOTIATE_DEFINED
#define _LPHTTPNEGOTIATE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0088_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0088_v0_0_s_ifspec;

#ifndef __IHttpNegotiate_INTERFACE_DEFINED__
#define __IHttpNegotiate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHttpNegotiate
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IHttpNegotiate __RPC_FAR *LPHTTPNEGOTIATE;


EXTERN_C const IID IID_IHttpNegotiate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9d2-baf9-11ce-8c82-00aa004ba90b")
    IHttpNegotiate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginningTransaction( 
            /* [in] */ LPCWSTR szURL,
            /* [unique][in] */ LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LPWSTR __RPC_FAR *pszAdditionalHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResponse( 
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ LPCWSTR szResponseHeaders,
            /* [unique][in] */ LPCWSTR szRequestHeaders,
            /* [out] */ LPWSTR __RPC_FAR *pszAdditionalRequestHeaders) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpNegotiateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHttpNegotiate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHttpNegotiate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHttpNegotiate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginningTransaction )( 
            IHttpNegotiate __RPC_FAR * This,
            /* [in] */ LPCWSTR szURL,
            /* [unique][in] */ LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LPWSTR __RPC_FAR *pszAdditionalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnResponse )( 
            IHttpNegotiate __RPC_FAR * This,
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ LPCWSTR szResponseHeaders,
            /* [unique][in] */ LPCWSTR szRequestHeaders,
            /* [out] */ LPWSTR __RPC_FAR *pszAdditionalRequestHeaders);
        
        END_INTERFACE
    } IHttpNegotiateVtbl;

    interface IHttpNegotiate
    {
        CONST_VTBL struct IHttpNegotiateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpNegotiate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHttpNegotiate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHttpNegotiate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHttpNegotiate_BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)	\
    (This)->lpVtbl -> BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)

#define IHttpNegotiate_OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)	\
    (This)->lpVtbl -> OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHttpNegotiate_BeginningTransaction_Proxy( 
    IHttpNegotiate __RPC_FAR * This,
    /* [in] */ LPCWSTR szURL,
    /* [unique][in] */ LPCWSTR szHeaders,
    /* [in] */ DWORD dwReserved,
    /* [out] */ LPWSTR __RPC_FAR *pszAdditionalHeaders);


void __RPC_STUB IHttpNegotiate_BeginningTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHttpNegotiate_OnResponse_Proxy( 
    IHttpNegotiate __RPC_FAR * This,
    /* [in] */ DWORD dwResponseCode,
    /* [unique][in] */ LPCWSTR szResponseHeaders,
    /* [unique][in] */ LPCWSTR szRequestHeaders,
    /* [out] */ LPWSTR __RPC_FAR *pszAdditionalRequestHeaders);


void __RPC_STUB IHttpNegotiate_OnResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHttpNegotiate_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0089
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPWINDOWFORBINDINGUI_DEFINED
#define _LPWINDOWFORBINDINGUI_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0089_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0089_v0_0_s_ifspec;

#ifndef __IWindowForBindingUI_INTERFACE_DEFINED__
#define __IWindowForBindingUI_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWindowForBindingUI
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IWindowForBindingUI __RPC_FAR *LPWINDOWFORBINDINGUI;


EXTERN_C const IID IID_IWindowForBindingUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9d5-bafa-11ce-8c82-00aa004ba90b")
    IWindowForBindingUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND __RPC_FAR *phwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWindowForBindingUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWindowForBindingUI __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWindowForBindingUI __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWindowForBindingUI __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWindow )( 
            IWindowForBindingUI __RPC_FAR * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        END_INTERFACE
    } IWindowForBindingUIVtbl;

    interface IWindowForBindingUI
    {
        CONST_VTBL struct IWindowForBindingUIVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowForBindingUI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWindowForBindingUI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWindowForBindingUI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWindowForBindingUI_GetWindow(This,rguidReason,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWindowForBindingUI_GetWindow_Proxy( 
    IWindowForBindingUI __RPC_FAR * This,
    /* [in] */ REFGUID rguidReason,
    /* [out] */ HWND __RPC_FAR *phwnd);


void __RPC_STUB IWindowForBindingUI_GetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWindowForBindingUI_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0090
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCODEINSTALL_DEFINED
#define _LPCODEINSTALL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0090_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0090_v0_0_s_ifspec;

#ifndef __ICodeInstall_INTERFACE_DEFINED__
#define __ICodeInstall_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICodeInstall
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ ICodeInstall __RPC_FAR *LPCODEINSTALL;

typedef /* [public] */ 
enum __MIDL_ICodeInstall_0001
    {	CIP_DISK_FULL	= 0,
	CIP_ACCESS_DENIED	= CIP_DISK_FULL + 1,
	CIP_NEWER_VERSION_EXISTS	= CIP_ACCESS_DENIED + 1,
	CIP_OLDER_VERSION_EXISTS	= CIP_NEWER_VERSION_EXISTS + 1,
	CIP_NAME_CONFLICT	= CIP_OLDER_VERSION_EXISTS + 1,
	CIP_TRUST_VERIFICATION_COMPONENT_MISSING	= CIP_NAME_CONFLICT + 1,
	CIP_EXE_SELF_REGISTERATION_TIMEOUT	= CIP_TRUST_VERIFICATION_COMPONENT_MISSING + 1,
	CIP_UNSAFE_TO_ABORT	= CIP_EXE_SELF_REGISTERATION_TIMEOUT + 1,
	CIP_NEED_REBOOT	= CIP_UNSAFE_TO_ABORT + 1
    }	CIP_STATUS;


EXTERN_C const IID IID_ICodeInstall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9d1-baf9-11ce-8c82-00aa004ba90b")
    ICodeInstall : public IWindowForBindingUI
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCodeInstallProblem( 
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ LPCWSTR szDestination,
            /* [unique][in] */ LPCWSTR szSource,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeInstallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICodeInstall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICodeInstall __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICodeInstall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWindow )( 
            ICodeInstall __RPC_FAR * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCodeInstallProblem )( 
            ICodeInstall __RPC_FAR * This,
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ LPCWSTR szDestination,
            /* [unique][in] */ LPCWSTR szSource,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } ICodeInstallVtbl;

    interface ICodeInstall
    {
        CONST_VTBL struct ICodeInstallVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeInstall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICodeInstall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICodeInstall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICodeInstall_GetWindow(This,rguidReason,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd)


#define ICodeInstall_OnCodeInstallProblem(This,ulStatusCode,szDestination,szSource,dwReserved)	\
    (This)->lpVtbl -> OnCodeInstallProblem(This,ulStatusCode,szDestination,szSource,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICodeInstall_OnCodeInstallProblem_Proxy( 
    ICodeInstall __RPC_FAR * This,
    /* [in] */ ULONG ulStatusCode,
    /* [unique][in] */ LPCWSTR szDestination,
    /* [unique][in] */ LPCWSTR szSource,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB ICodeInstall_OnCodeInstallProblem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICodeInstall_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0091
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPWININETINFO_DEFINED
#define _LPWININETINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0091_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0091_v0_0_s_ifspec;

#ifndef __IWinInetInfo_INTERFACE_DEFINED__
#define __IWinInetInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWinInetInfo
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IWinInetInfo __RPC_FAR *LPWININETINFO;


EXTERN_C const IID IID_IWinInetInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9d6-bafa-11ce-8c82-00aa004ba90b")
    IWinInetInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryOption( 
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD __RPC_FAR *pcbBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWinInetInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWinInetInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWinInetInfo __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryOption )( 
            IWinInetInfo __RPC_FAR * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD __RPC_FAR *pcbBuf);
        
        END_INTERFACE
    } IWinInetInfoVtbl;

    interface IWinInetInfo
    {
        CONST_VTBL struct IWinInetInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWinInetInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWinInetInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWinInetInfo_QueryOption(This,dwOption,pBuffer,pcbBuf)	\
    (This)->lpVtbl -> QueryOption(This,dwOption,pBuffer,pcbBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_RemoteQueryOption_Proxy( 
    IWinInetInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE __RPC_FAR *pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf);


void __RPC_STUB IWinInetInfo_RemoteQueryOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWinInetInfo_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0092
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPHTTPSECURITY_DEFINED
#define _LPHTTPSECURITY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0092_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0092_v0_0_s_ifspec;

#ifndef __IHttpSecurity_INTERFACE_DEFINED__
#define __IHttpSecurity_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHttpSecurity
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IHttpSecurity __RPC_FAR *LPHTTPSECURITY;


EXTERN_C const IID IID_IHttpSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9d7-bafa-11ce-8c82-00aa004ba90b")
    IHttpSecurity : public IWindowForBindingUI
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSecurityProblem( 
            /* [in] */ DWORD dwProblem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpSecurityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHttpSecurity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHttpSecurity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHttpSecurity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWindow )( 
            IHttpSecurity __RPC_FAR * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSecurityProblem )( 
            IHttpSecurity __RPC_FAR * This,
            /* [in] */ DWORD dwProblem);
        
        END_INTERFACE
    } IHttpSecurityVtbl;

    interface IHttpSecurity
    {
        CONST_VTBL struct IHttpSecurityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpSecurity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHttpSecurity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHttpSecurity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHttpSecurity_GetWindow(This,rguidReason,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd)


#define IHttpSecurity_OnSecurityProblem(This,dwProblem)	\
    (This)->lpVtbl -> OnSecurityProblem(This,dwProblem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHttpSecurity_OnSecurityProblem_Proxy( 
    IHttpSecurity __RPC_FAR * This,
    /* [in] */ DWORD dwProblem);


void __RPC_STUB IHttpSecurity_OnSecurityProblem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHttpSecurity_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0093
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPWININETHTTPINFO_DEFINED
#define _LPWININETHTTPINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0093_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0093_v0_0_s_ifspec;

#ifndef __IWinInetHttpInfo_INTERFACE_DEFINED__
#define __IWinInetHttpInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWinInetHttpInfo
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IWinInetHttpInfo __RPC_FAR *LPWININETHTTPINFO;


EXTERN_C const IID IID_IWinInetHttpInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9d8-bafa-11ce-8c82-00aa004ba90b")
    IWinInetHttpInfo : public IWinInetInfo
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryInfo( 
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
            /* [out][in] */ DWORD __RPC_FAR *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetHttpInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWinInetHttpInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWinInetHttpInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWinInetHttpInfo __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryOption )( 
            IWinInetHttpInfo __RPC_FAR * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD __RPC_FAR *pcbBuf);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInfo )( 
            IWinInetHttpInfo __RPC_FAR * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
            /* [out][in] */ DWORD __RPC_FAR *pdwReserved);
        
        END_INTERFACE
    } IWinInetHttpInfoVtbl;

    interface IWinInetHttpInfo
    {
        CONST_VTBL struct IWinInetHttpInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetHttpInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWinInetHttpInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWinInetHttpInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWinInetHttpInfo_QueryOption(This,dwOption,pBuffer,pcbBuf)	\
    (This)->lpVtbl -> QueryOption(This,dwOption,pBuffer,pcbBuf)


#define IWinInetHttpInfo_QueryInfo(This,dwOption,pBuffer,pcbBuf,pdwFlags,pdwReserved)	\
    (This)->lpVtbl -> QueryInfo(This,dwOption,pBuffer,pcbBuf,pdwFlags,pdwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_RemoteQueryInfo_Proxy( 
    IWinInetHttpInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE __RPC_FAR *pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
    /* [out][in] */ DWORD __RPC_FAR *pdwReserved);


void __RPC_STUB IWinInetHttpInfo_RemoteQueryInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWinInetHttpInfo_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0094
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#define SID_IBindHost IID_IBindHost
#define SID_SBindHost IID_IBindHost
#ifndef _LPBINDHOST_DEFINED
#define _LPBINDHOST_DEFINED
EXTERN_C const GUID SID_BindHost;


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0094_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0094_v0_0_s_ifspec;

#ifndef __IBindHost_INTERFACE_DEFINED__
#define __IBindHost_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBindHost
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IBindHost __RPC_FAR *LPBINDHOST;


EXTERN_C const IID IID_IBindHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("fc4801a1-2ba9-11cf-a229-00aa003d7352")
    IBindHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateMoniker( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MonikerBindToStorage( 
            /* [in] */ IMoniker __RPC_FAR *pMk,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MonikerBindToObject( 
            /* [in] */ IMoniker __RPC_FAR *pMk,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBindHost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBindHost __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBindHost __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateMoniker )( 
            IBindHost __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk,
            /* [in] */ DWORD dwReserved);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MonikerBindToStorage )( 
            IBindHost __RPC_FAR * This,
            /* [in] */ IMoniker __RPC_FAR *pMk,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MonikerBindToObject )( 
            IBindHost __RPC_FAR * This,
            /* [in] */ IMoniker __RPC_FAR *pMk,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);
        
        END_INTERFACE
    } IBindHostVtbl;

    interface IBindHost
    {
        CONST_VTBL struct IBindHostVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindHost_CreateMoniker(This,szName,pBC,ppmk,dwReserved)	\
    (This)->lpVtbl -> CreateMoniker(This,szName,pBC,ppmk,dwReserved)

#define IBindHost_MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj)	\
    (This)->lpVtbl -> MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj)

#define IBindHost_MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj)	\
    (This)->lpVtbl -> MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBindHost_CreateMoniker_Proxy( 
    IBindHost __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IBindHost_CreateMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_RemoteMonikerBindToStorage_Proxy( 
    IBindHost __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pMk,
    /* [unique][in] */ IBindCtx __RPC_FAR *pBC,
    /* [unique][in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObj);


void __RPC_STUB IBindHost_RemoteMonikerBindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_RemoteMonikerBindToObject_Proxy( 
    IBindHost __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pMk,
    /* [unique][in] */ IBindCtx __RPC_FAR *pBC,
    /* [unique][in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObj);


void __RPC_STUB IBindHost_RemoteMonikerBindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindHost_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0095
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
                                                                                                           
// These are for backwards compatibility with previous URLMON versions
// Flags for the UrlDownloadToCacheFile                                                                    
#define URLOSTRM_USECACHEDCOPY_ONLY             0x1      // Only get from cache                            
#define URLOSTRM_USECACHEDCOPY                  0x2      // Get from cache if available else download      
#define URLOSTRM_GETNEWESTVERSION               0x3      // Get new version only. But put it in cache too  
                                                                                                           
                                                                                                           
struct IBindStatusCallback;                                                                                
STDAPI HlinkSimpleNavigateToString(                                                                        
    /* [in] */ LPCWSTR szTarget,         // required - target document - null if local jump w/in doc       
    /* [in] */ LPCWSTR szLocation,       // optional, for navigation into middle of a doc                  
    /* [in] */ LPCWSTR szTargetFrameName,// optional, for targeting frame-sets                             
    /* [in] */ IUnknown *pUnk,           // required - we'll search this for other necessary interfaces    
    /* [in] */ IBindCtx *pbc,            // optional. caller may register an IBSC in this                  
    /* [in] */ IBindStatusCallback *,                                                                      
    /* [in] */ DWORD grfHLNF,            // flags                                                          
    /* [in] */ DWORD dwReserved          // for future use, must be NULL                                   
);                                                                                                         
                                                                                                           
STDAPI HlinkSimpleNavigateToMoniker(                                                                       
    /* [in] */ IMoniker *pmkTarget,      // required - target document - (may be null                      
    /* [in] */ LPCWSTR szLocation,       // optional, for navigation into middle of a doc                  
    /* [in] */ LPCWSTR szTargetFrameName,// optional, for targeting frame-sets                             
    /* [in] */ IUnknown *pUnk,           // required - we'll search this for other necessary interfaces    
    /* [in] */ IBindCtx *pbc,            // optional. caller may register an IBSC in this                  
    /* [in] */ IBindStatusCallback *,                                                                      
    /* [in] */ DWORD grfHLNF,            // flags                                                          
    /* [in] */ DWORD dwReserved          // for future use, must be NULL                                   
);                                                                                                         
                                                                                                           
STDAPI URLOpenStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                                        
STDAPI URLOpenStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                                       
STDAPI URLOpenPullStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                                    
STDAPI URLOpenPullStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                                   
STDAPI URLDownloadToFileA(LPUNKNOWN,LPCSTR,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                             
STDAPI URLDownloadToFileW(LPUNKNOWN,LPCWSTR,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                           
STDAPI URLDownloadToCacheFileA(LPUNKNOWN,LPCSTR,LPTSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);                  
STDAPI URLDownloadToCacheFileW(LPUNKNOWN,LPCWSTR,LPWSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);                 
STDAPI URLOpenBlockingStreamA(LPUNKNOWN,LPCSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);                      
STDAPI URLOpenBlockingStreamW(LPUNKNOWN,LPCWSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);                     
                                                                                                           
#ifdef UNICODE                                                                                             
#define URLOpenStream            URLOpenStreamW                                                            
#define URLOpenPullStream        URLOpenPullStreamW                                                        
#define URLDownloadToFile        URLDownloadToFileW                                                        
#define URLDownloadToCacheFile   URLDownloadToCacheFileW                                                   
#define URLOpenBlockingStream    URLOpenBlockingStreamW                                                    
#else                                                                                                      
#define URLOpenStream            URLOpenStreamA                                                            
#define URLOpenPullStream        URLOpenPullStreamA                                                        
#define URLDownloadToFile        URLDownloadToFileA                                                        
#define URLDownloadToCacheFile   URLDownloadToCacheFileA                                                   
#define URLOpenBlockingStream    URLOpenBlockingStreamA                                                    
#endif // !UNICODE                                                                                         
                                                                                                           
                                                                                                           
STDAPI HlinkGoBack(IUnknown *pUnk);                                                                        
STDAPI HlinkGoForward(IUnknown *pUnk);                                                                     
STDAPI HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget);                                              
STDAPI HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget);                                          
                                                                                                           
#ifndef  _URLMON_NO_ASYNC_PLUGABLE_PROTOCOLS_   










#ifndef _LPOINET
#define _LPOINET


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0095_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0095_v0_0_s_ifspec;

#ifndef __IOInet_INTERFACE_DEFINED__
#define __IOInet_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInet
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInet __RPC_FAR *LPOINET;


EXTERN_C const IID IID_IOInet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9e0-baf9-11ce-8c82-00aa004ba90b")
    IOInet : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IOInetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInet __RPC_FAR * This);
        
        END_INTERFACE
    } IOInetVtbl;

    interface IOInet
    {
        CONST_VTBL struct IOInetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOInet_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0096
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOINETBINDINFO
#define _LPOINETBINDINFO


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0096_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0096_v0_0_s_ifspec;

#ifndef __IOInetBindInfo_INTERFACE_DEFINED__
#define __IOInetBindInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetBindInfo
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetBindInfo __RPC_FAR *LPOINETBINDINFO;

typedef 
enum tagBINDSTRING
    {	BINDSTRING_HEADERS	= 1,
	BINDSTRING_ACCEPT_MIMES	= BINDSTRING_HEADERS + 1,
	BINDSTRING_EXTRA_URL	= BINDSTRING_ACCEPT_MIMES + 1,
	BINDSTRING_LANGUAGE	= BINDSTRING_EXTRA_URL + 1,
	BINDSTRING_USERNAME	= BINDSTRING_LANGUAGE + 1,
	BINDSTRING_PASSWORD	= BINDSTRING_USERNAME + 1,
	BINDSTRING_UA_PIXELS	= BINDSTRING_PASSWORD + 1,
	BINDSTRING_UA_COLOR	= BINDSTRING_UA_PIXELS + 1,
	BINDSTRING_OS	= BINDSTRING_UA_COLOR + 1
    }	BINDSTRING;


EXTERN_C const IID IID_IOInetBindInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9e1-baf9-11ce-8c82-00aa004ba90b")
    IOInetBindInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBindInfo( 
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindString( 
            /* [in] */ ULONG ulStringType,
            /* [out][in] */ LPOLESTR __RPC_FAR *ppwzStr,
            /* [in] */ ULONG cEl,
            /* [out][in] */ ULONG __RPC_FAR *pcElFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOInetBindInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInetBindInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInetBindInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInetBindInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBindInfo )( 
            IOInetBindInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBindString )( 
            IOInetBindInfo __RPC_FAR * This,
            /* [in] */ ULONG ulStringType,
            /* [out][in] */ LPOLESTR __RPC_FAR *ppwzStr,
            /* [in] */ ULONG cEl,
            /* [out][in] */ ULONG __RPC_FAR *pcElFetched);
        
        END_INTERFACE
    } IOInetBindInfoVtbl;

    interface IOInetBindInfo
    {
        CONST_VTBL struct IOInetBindInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInetBindInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInetBindInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInetBindInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOInetBindInfo_GetBindInfo(This,grfBINDF,pbindinfo)	\
    (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo)

#define IOInetBindInfo_GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched)	\
    (This)->lpVtbl -> GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOInetBindInfo_GetBindInfo_Proxy( 
    IOInetBindInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *grfBINDF,
    /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);


void __RPC_STUB IOInetBindInfo_GetBindInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetBindInfo_GetBindString_Proxy( 
    IOInetBindInfo __RPC_FAR * This,
    /* [in] */ ULONG ulStringType,
    /* [out][in] */ LPOLESTR __RPC_FAR *ppwzStr,
    /* [in] */ ULONG cEl,
    /* [out][in] */ ULONG __RPC_FAR *pcElFetched);


void __RPC_STUB IOInetBindInfo_GetBindString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOInetBindInfo_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0097
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOINETBINDCLIENT
#define _LPOINETBINDCLIENT


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0097_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0097_v0_0_s_ifspec;

#ifndef __IOInetBindClient_INTERFACE_DEFINED__
#define __IOInetBindClient_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetBindClient
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetBindClient __RPC_FAR *LPOINETBINDCLIENT;


EXTERN_C const IID IID_IOInetBindClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9e2-baf9-11ce-8c82-00aa004ba90b")
    IOInetBindClient : public IOInetBindInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassFileOrMime( 
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR szFilename,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbSize,
            /* [in] */ LPCWSTR szMime,
            /* [in] */ DWORD dwReserved,
            /* [out][in] */ LPCLSID pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindMimeFromData( 
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR szFilename,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbSize,
            /* [in] */ LPCWSTR szMime,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LPOLESTR __RPC_FAR *pwzNewMime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOInetBindClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInetBindClient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInetBindClient __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInetBindClient __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBindInfo )( 
            IOInetBindClient __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBindString )( 
            IOInetBindClient __RPC_FAR * This,
            /* [in] */ ULONG ulStringType,
            /* [out][in] */ LPOLESTR __RPC_FAR *ppwzStr,
            /* [in] */ ULONG cEl,
            /* [out][in] */ ULONG __RPC_FAR *pcElFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassFileOrMime )( 
            IOInetBindClient __RPC_FAR * This,
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR szFilename,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbSize,
            /* [in] */ LPCWSTR szMime,
            /* [in] */ DWORD dwReserved,
            /* [out][in] */ LPCLSID pclsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindMimeFromData )( 
            IOInetBindClient __RPC_FAR * This,
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR szFilename,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbSize,
            /* [in] */ LPCWSTR szMime,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LPOLESTR __RPC_FAR *pwzNewMime);
        
        END_INTERFACE
    } IOInetBindClientVtbl;

    interface IOInetBindClient
    {
        CONST_VTBL struct IOInetBindClientVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInetBindClient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInetBindClient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInetBindClient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOInetBindClient_GetBindInfo(This,grfBINDF,pbindinfo)	\
    (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo)

#define IOInetBindClient_GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched)	\
    (This)->lpVtbl -> GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched)


#define IOInetBindClient_GetClassFileOrMime(This,pBC,szFilename,pBuffer,cbSize,szMime,dwReserved,pclsid)	\
    (This)->lpVtbl -> GetClassFileOrMime(This,pBC,szFilename,pBuffer,cbSize,szMime,dwReserved,pclsid)

#define IOInetBindClient_FindMimeFromData(This,pBC,szFilename,pBuffer,cbSize,szMime,dwReserved,pwzNewMime)	\
    (This)->lpVtbl -> FindMimeFromData(This,pBC,szFilename,pBuffer,cbSize,szMime,dwReserved,pwzNewMime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOInetBindClient_GetClassFileOrMime_Proxy( 
    IOInetBindClient __RPC_FAR * This,
    /* [in] */ LPBC pBC,
    /* [in] */ LPCWSTR szFilename,
    /* [in] */ LPVOID pBuffer,
    /* [in] */ DWORD cbSize,
    /* [in] */ LPCWSTR szMime,
    /* [in] */ DWORD dwReserved,
    /* [out][in] */ LPCLSID pclsid);


void __RPC_STUB IOInetBindClient_GetClassFileOrMime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetBindClient_FindMimeFromData_Proxy( 
    IOInetBindClient __RPC_FAR * This,
    /* [in] */ LPBC pBC,
    /* [in] */ LPCWSTR szFilename,
    /* [in] */ LPVOID pBuffer,
    /* [in] */ DWORD cbSize,
    /* [in] */ LPCWSTR szMime,
    /* [in] */ DWORD dwReserved,
    /* [out] */ LPOLESTR __RPC_FAR *pwzNewMime);


void __RPC_STUB IOInetBindClient_FindMimeFromData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOInetBindClient_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0098
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOINETPROTOCOLROOT_DEFINED
#define _LPOINETPROTOCOLROOT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0098_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0098_v0_0_s_ifspec;

#ifndef __IOInetProtocolRoot_INTERFACE_DEFINED__
#define __IOInetProtocolRoot_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetProtocolRoot
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetProtocolRoot __RPC_FAR *LPOINETPROTOCOLROOT;

typedef 
enum _tagPI_FLAGS
    {	PI_PARSE_URL	= 0x1,
	PI_FILTER_MODE	= 0x2,
	PI_FORCE_ASYNC	= 0x4,
	PI_USE_WORKERTHREAD	= 0x8
    }	PI_FLAGS;

typedef struct  _tagPROTOCOLDATA
    {
    DWORD grfFlags;
    DWORD dwState;
    LPVOID pData;
    ULONG cbData;
    }	PROTOCOLDATA;


EXTERN_C const IID IID_IOInetProtocolRoot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9e3-baf9-11ce-8c82-00aa004ba90b")
    IOInetProtocolRoot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IOInetProtocolSink __RPC_FAR *pOIProtSink,
            /* [in] */ IOInetBindInfo __RPC_FAR *pOIBindInfo,
            /* [in] */ DWORD grfSTI,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( 
            /* [in] */ PROTOCOLDATA __RPC_FAR *pProtocolData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOInetProtocolRootVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInetProtocolRoot __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInetProtocolRoot __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInetProtocolRoot __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IOInetProtocolRoot __RPC_FAR * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IOInetProtocolSink __RPC_FAR *pOIProtSink,
            /* [in] */ IOInetBindInfo __RPC_FAR *pOIBindInfo,
            /* [in] */ DWORD grfSTI,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Continue )( 
            IOInetProtocolRoot __RPC_FAR * This,
            /* [in] */ PROTOCOLDATA __RPC_FAR *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IOInetProtocolRoot __RPC_FAR * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Terminate )( 
            IOInetProtocolRoot __RPC_FAR * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IOInetProtocolRoot __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IOInetProtocolRoot __RPC_FAR * This);
        
        END_INTERFACE
    } IOInetProtocolRootVtbl;

    interface IOInetProtocolRoot
    {
        CONST_VTBL struct IOInetProtocolRootVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInetProtocolRoot_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInetProtocolRoot_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInetProtocolRoot_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOInetProtocolRoot_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfSTI,dwReserved)	\
    (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfSTI,dwReserved)

#define IOInetProtocolRoot_Continue(This,pProtocolData)	\
    (This)->lpVtbl -> Continue(This,pProtocolData)

#define IOInetProtocolRoot_Abort(This,hrReason,dwOptions)	\
    (This)->lpVtbl -> Abort(This,hrReason,dwOptions)

#define IOInetProtocolRoot_Terminate(This,dwOptions)	\
    (This)->lpVtbl -> Terminate(This,dwOptions)

#define IOInetProtocolRoot_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IOInetProtocolRoot_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOInetProtocolRoot_Start_Proxy( 
    IOInetProtocolRoot __RPC_FAR * This,
    /* [in] */ LPCWSTR szUrl,
    /* [in] */ IOInetProtocolSink __RPC_FAR *pOIProtSink,
    /* [in] */ IOInetBindInfo __RPC_FAR *pOIBindInfo,
    /* [in] */ DWORD grfSTI,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IOInetProtocolRoot_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetProtocolRoot_Continue_Proxy( 
    IOInetProtocolRoot __RPC_FAR * This,
    /* [in] */ PROTOCOLDATA __RPC_FAR *pProtocolData);


void __RPC_STUB IOInetProtocolRoot_Continue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetProtocolRoot_Abort_Proxy( 
    IOInetProtocolRoot __RPC_FAR * This,
    /* [in] */ HRESULT hrReason,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IOInetProtocolRoot_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetProtocolRoot_Terminate_Proxy( 
    IOInetProtocolRoot __RPC_FAR * This,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IOInetProtocolRoot_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetProtocolRoot_Suspend_Proxy( 
    IOInetProtocolRoot __RPC_FAR * This);


void __RPC_STUB IOInetProtocolRoot_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetProtocolRoot_Resume_Proxy( 
    IOInetProtocolRoot __RPC_FAR * This);


void __RPC_STUB IOInetProtocolRoot_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOInetProtocolRoot_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0099
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOINETPROTOCOL_DEFINED
#define _LPOINETPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0099_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0099_v0_0_s_ifspec;

#ifndef __IOInetProtocol_INTERFACE_DEFINED__
#define __IOInetProtocol_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetProtocol
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IOInetProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9e4-baf9-11ce-8c82-00aa004ba90b")
    IOInetProtocol : public IOInetProtocolRoot
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockRequest( 
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockRequest( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOInetProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInetProtocol __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInetProtocol __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInetProtocol __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IOInetProtocol __RPC_FAR * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IOInetProtocolSink __RPC_FAR *pOIProtSink,
            /* [in] */ IOInetBindInfo __RPC_FAR *pOIBindInfo,
            /* [in] */ DWORD grfSTI,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Continue )( 
            IOInetProtocol __RPC_FAR * This,
            /* [in] */ PROTOCOLDATA __RPC_FAR *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IOInetProtocol __RPC_FAR * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Terminate )( 
            IOInetProtocol __RPC_FAR * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IOInetProtocol __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IOInetProtocol __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IOInetProtocol __RPC_FAR * This,
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek )( 
            IOInetProtocol __RPC_FAR * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockRequest )( 
            IOInetProtocol __RPC_FAR * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockRequest )( 
            IOInetProtocol __RPC_FAR * This);
        
        END_INTERFACE
    } IOInetProtocolVtbl;

    interface IOInetProtocol
    {
        CONST_VTBL struct IOInetProtocolVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInetProtocol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInetProtocol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInetProtocol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOInetProtocol_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfSTI,dwReserved)	\
    (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfSTI,dwReserved)

#define IOInetProtocol_Continue(This,pProtocolData)	\
    (This)->lpVtbl -> Continue(This,pProtocolData)

#define IOInetProtocol_Abort(This,hrReason,dwOptions)	\
    (This)->lpVtbl -> Abort(This,hrReason,dwOptions)

#define IOInetProtocol_Terminate(This,dwOptions)	\
    (This)->lpVtbl -> Terminate(This,dwOptions)

#define IOInetProtocol_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IOInetProtocol_Resume(This)	\
    (This)->lpVtbl -> Resume(This)


#define IOInetProtocol_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define IOInetProtocol_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define IOInetProtocol_LockRequest(This,dwOptions)	\
    (This)->lpVtbl -> LockRequest(This,dwOptions)

#define IOInetProtocol_UnlockRequest(This)	\
    (This)->lpVtbl -> UnlockRequest(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOInetProtocol_Read_Proxy( 
    IOInetProtocol __RPC_FAR * This,
    /* [length_is][size_is][out] */ void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbRead);


void __RPC_STUB IOInetProtocol_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetProtocol_Seek_Proxy( 
    IOInetProtocol __RPC_FAR * This,
    /* [in] */ LARGE_INTEGER dlibMove,
    /* [in] */ DWORD dwOrigin,
    /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition);


void __RPC_STUB IOInetProtocol_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetProtocol_LockRequest_Proxy( 
    IOInetProtocol __RPC_FAR * This,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IOInetProtocol_LockRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetProtocol_UnlockRequest_Proxy( 
    IOInetProtocol __RPC_FAR * This);


void __RPC_STUB IOInetProtocol_UnlockRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOInetProtocol_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0100
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOINETPROTOCOLSINK_DEFINED
#define _LPOINETPROTOCOLSINK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0100_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0100_v0_0_s_ifspec;

#ifndef __IOInetProtocolSink_INTERFACE_DEFINED__
#define __IOInetProtocolSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetProtocolSink
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetProtocolSink __RPC_FAR *LPOINETPROTOCOLSINK;


EXTERN_C const IID IID_IOInetProtocolSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9e5-baf9-11ce-8c82-00aa004ba90b")
    IOInetProtocolSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Switch( 
            /* [in] */ PROTOCOLDATA __RPC_FAR *pProtocolData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportProgress( 
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportData( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportResult( 
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwError,
            /* [in] */ LPCWSTR szResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOInetProtocolSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInetProtocolSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInetProtocolSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInetProtocolSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Switch )( 
            IOInetProtocolSink __RPC_FAR * This,
            /* [in] */ PROTOCOLDATA __RPC_FAR *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReportProgress )( 
            IOInetProtocolSink __RPC_FAR * This,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReportData )( 
            IOInetProtocolSink __RPC_FAR * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReportResult )( 
            IOInetProtocolSink __RPC_FAR * This,
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwError,
            /* [in] */ LPCWSTR szResult);
        
        END_INTERFACE
    } IOInetProtocolSinkVtbl;

    interface IOInetProtocolSink
    {
        CONST_VTBL struct IOInetProtocolSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInetProtocolSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInetProtocolSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInetProtocolSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOInetProtocolSink_Switch(This,pProtocolData)	\
    (This)->lpVtbl -> Switch(This,pProtocolData)

#define IOInetProtocolSink_ReportProgress(This,ulStatusCode,szStatusText)	\
    (This)->lpVtbl -> ReportProgress(This,ulStatusCode,szStatusText)

#define IOInetProtocolSink_ReportData(This,grfBSCF,ulProgress,ulProgressMax)	\
    (This)->lpVtbl -> ReportData(This,grfBSCF,ulProgress,ulProgressMax)

#define IOInetProtocolSink_ReportResult(This,hrResult,dwError,szResult)	\
    (This)->lpVtbl -> ReportResult(This,hrResult,dwError,szResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOInetProtocolSink_Switch_Proxy( 
    IOInetProtocolSink __RPC_FAR * This,
    /* [in] */ PROTOCOLDATA __RPC_FAR *pProtocolData);


void __RPC_STUB IOInetProtocolSink_Switch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetProtocolSink_ReportProgress_Proxy( 
    IOInetProtocolSink __RPC_FAR * This,
    /* [in] */ ULONG ulStatusCode,
    /* [in] */ LPCWSTR szStatusText);


void __RPC_STUB IOInetProtocolSink_ReportProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetProtocolSink_ReportData_Proxy( 
    IOInetProtocolSink __RPC_FAR * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ ULONG ulProgress,
    /* [in] */ ULONG ulProgressMax);


void __RPC_STUB IOInetProtocolSink_ReportData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetProtocolSink_ReportResult_Proxy( 
    IOInetProtocolSink __RPC_FAR * This,
    /* [in] */ HRESULT hrResult,
    /* [in] */ DWORD dwError,
    /* [in] */ LPCWSTR szResult);


void __RPC_STUB IOInetProtocolSink_ReportResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOInetProtocolSink_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0101
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOINETBINDING
#define _LPOINETBINDING


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0101_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0101_v0_0_s_ifspec;

#ifndef __IOInetBinding_INTERFACE_DEFINED__
#define __IOInetBinding_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetBinding
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetBinding __RPC_FAR *LPOINETBINDING;


EXTERN_C const IID IID_IOInetBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9e6-baf9-11ce-8c82-00aa004ba90b")
    IOInetBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Bind( 
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR wzUrl,
            /* [in] */ IOInetBindInfo __RPC_FAR *pOInetBindInfo,
            /* [in] */ IOInetBindSink __RPC_FAR *pOInetBindSink,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD grfOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindResult( 
            /* [out] */ CLSID __RPC_FAR *pclsidProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwResult,
            /* [out] */ LPOLESTR __RPC_FAR *pszResult,
            /* [out][in] */ DWORD __RPC_FAR *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOInetBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInetBinding __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInetBinding __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInetBinding __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Bind )( 
            IOInetBinding __RPC_FAR * This,
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR wzUrl,
            /* [in] */ IOInetBindInfo __RPC_FAR *pOInetBindInfo,
            /* [in] */ IOInetBindSink __RPC_FAR *pOInetBindSink,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD grfOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IOInetBinding __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBindResult )( 
            IOInetBinding __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pclsidProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwResult,
            /* [out] */ LPOLESTR __RPC_FAR *pszResult,
            /* [out][in] */ DWORD __RPC_FAR *pdwReserved);
        
        END_INTERFACE
    } IOInetBindingVtbl;

    interface IOInetBinding
    {
        CONST_VTBL struct IOInetBindingVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInetBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInetBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInetBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOInetBinding_Bind(This,pBC,wzUrl,pOInetBindInfo,pOInetBindSink,riid,grfOptions)	\
    (This)->lpVtbl -> Bind(This,pBC,wzUrl,pOInetBindInfo,pOInetBindSink,riid,grfOptions)

#define IOInetBinding_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define IOInetBinding_GetBindResult(This,pclsidProtocol,pdwResult,pszResult,pdwReserved)	\
    (This)->lpVtbl -> GetBindResult(This,pclsidProtocol,pdwResult,pszResult,pdwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOInetBinding_Bind_Proxy( 
    IOInetBinding __RPC_FAR * This,
    /* [in] */ LPBC pBC,
    /* [in] */ LPCWSTR wzUrl,
    /* [in] */ IOInetBindInfo __RPC_FAR *pOInetBindInfo,
    /* [in] */ IOInetBindSink __RPC_FAR *pOInetBindSink,
    /* [in] */ REFIID riid,
    /* [in] */ DWORD grfOptions);


void __RPC_STUB IOInetBinding_Bind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetBinding_Abort_Proxy( 
    IOInetBinding __RPC_FAR * This);


void __RPC_STUB IOInetBinding_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IOInetBinding_RemoteGetBindResult_Proxy( 
    IOInetBinding __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pclsidProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwResult,
    /* [out] */ LPOLESTR __RPC_FAR *pszResult,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IOInetBinding_RemoteGetBindResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOInetBinding_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0102
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOINETSESSION_DEFINED
#define _LPOINETSESSION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0102_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0102_v0_0_s_ifspec;

#ifndef __IOInetSession_INTERFACE_DEFINED__
#define __IOInetSession_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetSession
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetSession __RPC_FAR *LPOINETSESSION;


EXTERN_C const IID IID_IOInetSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9e7-baf9-11ce-8c82-00aa004ba90b")
    IOInetSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterNameSpace( 
            /* [in] */ IClassFactory __RPC_FAR *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzProtocol,
            /* [in] */ ULONG cPatterns,
            /* [in] */ const LPCWSTR __RPC_FAR *ppwzPatterns,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterNameSpace( 
            /* [in] */ IClassFactory __RPC_FAR *pCF,
            /* [in] */ LPCWSTR pszProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterMimeFilter( 
            /* [in] */ IClassFactory __RPC_FAR *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterMimeFilter( 
            /* [in] */ IClassFactory __RPC_FAR *pCF,
            /* [in] */ LPCWSTR pwzType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBinding( 
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [unique][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk,
            /* [unique][out] */ IOInetBinding __RPC_FAR *__RPC_FAR *ppOInetBdg,
            /* [in] */ DWORD dwOption) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSessionOption( 
            /* [in] */ DWORD dwOption,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD dwBufferLength,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionOption( 
            /* [in] */ DWORD dwOption,
            /* [out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD __RPC_FAR *pdwBufferLength,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCache( 
            /* [in] */ IOInetCache __RPC_FAR *pOInetCache,
            /* [in] */ DWORD dwOption) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCache( 
            /* [unique][out] */ IOInetCache __RPC_FAR *__RPC_FAR *ppOInetCache,
            /* [in] */ DWORD dwOption) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOInetSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInetSession __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInetSession __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInetSession __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterNameSpace )( 
            IOInetSession __RPC_FAR * This,
            /* [in] */ IClassFactory __RPC_FAR *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzProtocol,
            /* [in] */ ULONG cPatterns,
            /* [in] */ const LPCWSTR __RPC_FAR *ppwzPatterns,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterNameSpace )( 
            IOInetSession __RPC_FAR * This,
            /* [in] */ IClassFactory __RPC_FAR *pCF,
            /* [in] */ LPCWSTR pszProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterMimeFilter )( 
            IOInetSession __RPC_FAR * This,
            /* [in] */ IClassFactory __RPC_FAR *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterMimeFilter )( 
            IOInetSession __RPC_FAR * This,
            /* [in] */ IClassFactory __RPC_FAR *pCF,
            /* [in] */ LPCWSTR pwzType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateBinding )( 
            IOInetSession __RPC_FAR * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [unique][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk,
            /* [unique][out] */ IOInetBinding __RPC_FAR *__RPC_FAR *ppOInetBdg,
            /* [in] */ DWORD dwOption);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSessionOption )( 
            IOInetSession __RPC_FAR * This,
            /* [in] */ DWORD dwOption,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD dwBufferLength,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSessionOption )( 
            IOInetSession __RPC_FAR * This,
            /* [in] */ DWORD dwOption,
            /* [out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD __RPC_FAR *pdwBufferLength,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCache )( 
            IOInetSession __RPC_FAR * This,
            /* [in] */ IOInetCache __RPC_FAR *pOInetCache,
            /* [in] */ DWORD dwOption);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCache )( 
            IOInetSession __RPC_FAR * This,
            /* [unique][out] */ IOInetCache __RPC_FAR *__RPC_FAR *ppOInetCache,
            /* [in] */ DWORD dwOption);
        
        END_INTERFACE
    } IOInetSessionVtbl;

    interface IOInetSession
    {
        CONST_VTBL struct IOInetSessionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInetSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInetSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInetSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOInetSession_RegisterNameSpace(This,pCF,rclsid,pwzProtocol,cPatterns,ppwzPatterns,dwReserved)	\
    (This)->lpVtbl -> RegisterNameSpace(This,pCF,rclsid,pwzProtocol,cPatterns,ppwzPatterns,dwReserved)

#define IOInetSession_UnregisterNameSpace(This,pCF,pszProtocol)	\
    (This)->lpVtbl -> UnregisterNameSpace(This,pCF,pszProtocol)

#define IOInetSession_RegisterMimeFilter(This,pCF,rclsid,pwzType)	\
    (This)->lpVtbl -> RegisterMimeFilter(This,pCF,rclsid,pwzType)

#define IOInetSession_UnregisterMimeFilter(This,pCF,pwzType)	\
    (This)->lpVtbl -> UnregisterMimeFilter(This,pCF,pwzType)

#define IOInetSession_CreateBinding(This,szUrl,pUnkOuter,riid,ppUnk,ppOInetBdg,dwOption)	\
    (This)->lpVtbl -> CreateBinding(This,szUrl,pUnkOuter,riid,ppUnk,ppOInetBdg,dwOption)

#define IOInetSession_SetSessionOption(This,dwOption,pBuffer,dwBufferLength,dwReserved)	\
    (This)->lpVtbl -> SetSessionOption(This,dwOption,pBuffer,dwBufferLength,dwReserved)

#define IOInetSession_GetSessionOption(This,dwOption,pBuffer,pdwBufferLength,dwReserved)	\
    (This)->lpVtbl -> GetSessionOption(This,dwOption,pBuffer,pdwBufferLength,dwReserved)

#define IOInetSession_SetCache(This,pOInetCache,dwOption)	\
    (This)->lpVtbl -> SetCache(This,pOInetCache,dwOption)

#define IOInetSession_GetCache(This,ppOInetCache,dwOption)	\
    (This)->lpVtbl -> GetCache(This,ppOInetCache,dwOption)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOInetSession_RegisterNameSpace_Proxy( 
    IOInetSession __RPC_FAR * This,
    /* [in] */ IClassFactory __RPC_FAR *pCF,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LPCWSTR pwzProtocol,
    /* [in] */ ULONG cPatterns,
    /* [in] */ const LPCWSTR __RPC_FAR *ppwzPatterns,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IOInetSession_RegisterNameSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetSession_UnregisterNameSpace_Proxy( 
    IOInetSession __RPC_FAR * This,
    /* [in] */ IClassFactory __RPC_FAR *pCF,
    /* [in] */ LPCWSTR pszProtocol);


void __RPC_STUB IOInetSession_UnregisterNameSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetSession_RegisterMimeFilter_Proxy( 
    IOInetSession __RPC_FAR * This,
    /* [in] */ IClassFactory __RPC_FAR *pCF,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LPCWSTR pwzType);


void __RPC_STUB IOInetSession_RegisterMimeFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetSession_UnregisterMimeFilter_Proxy( 
    IOInetSession __RPC_FAR * This,
    /* [in] */ IClassFactory __RPC_FAR *pCF,
    /* [in] */ LPCWSTR pwzType);


void __RPC_STUB IOInetSession_UnregisterMimeFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetSession_CreateBinding_Proxy( 
    IOInetSession __RPC_FAR * This,
    /* [in] */ LPCWSTR szUrl,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [unique][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk,
    /* [unique][out] */ IOInetBinding __RPC_FAR *__RPC_FAR *ppOInetBdg,
    /* [in] */ DWORD dwOption);


void __RPC_STUB IOInetSession_CreateBinding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetSession_SetSessionOption_Proxy( 
    IOInetSession __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [in] */ LPVOID pBuffer,
    /* [in] */ DWORD dwBufferLength,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IOInetSession_SetSessionOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetSession_GetSessionOption_Proxy( 
    IOInetSession __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pdwBufferLength,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IOInetSession_GetSessionOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetSession_SetCache_Proxy( 
    IOInetSession __RPC_FAR * This,
    /* [in] */ IOInetCache __RPC_FAR *pOInetCache,
    /* [in] */ DWORD dwOption);


void __RPC_STUB IOInetSession_SetCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetSession_GetCache_Proxy( 
    IOInetSession __RPC_FAR * This,
    /* [unique][out] */ IOInetCache __RPC_FAR *__RPC_FAR *ppOInetCache,
    /* [in] */ DWORD dwOption);


void __RPC_STUB IOInetSession_GetCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOInetSession_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0103
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOINETTHREADSWITCH_DEFINED
#define _LPOINETTHREADSWITCH_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0103_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0103_v0_0_s_ifspec;

#ifndef __IOInetThreadSwitch_INTERFACE_DEFINED__
#define __IOInetThreadSwitch_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetThreadSwitch
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetThreadSwitch __RPC_FAR *LPOINETTHREADSWITCH;


EXTERN_C const IID IID_IOInetThreadSwitch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9e8-baf9-11ce-8c82-00aa004ba90b")
    IOInetThreadSwitch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Prepare( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOInetThreadSwitchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInetThreadSwitch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInetThreadSwitch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInetThreadSwitch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Prepare )( 
            IOInetThreadSwitch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Continue )( 
            IOInetThreadSwitch __RPC_FAR * This);
        
        END_INTERFACE
    } IOInetThreadSwitchVtbl;

    interface IOInetThreadSwitch
    {
        CONST_VTBL struct IOInetThreadSwitchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInetThreadSwitch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInetThreadSwitch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInetThreadSwitch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOInetThreadSwitch_Prepare(This)	\
    (This)->lpVtbl -> Prepare(This)

#define IOInetThreadSwitch_Continue(This)	\
    (This)->lpVtbl -> Continue(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOInetThreadSwitch_Prepare_Proxy( 
    IOInetThreadSwitch __RPC_FAR * This);


void __RPC_STUB IOInetThreadSwitch_Prepare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetThreadSwitch_Continue_Proxy( 
    IOInetThreadSwitch __RPC_FAR * This);


void __RPC_STUB IOInetThreadSwitch_Continue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOInetThreadSwitch_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0104
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOINETBINDSINK_DEFINED
#define _LPOINETBINDSINK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0104_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0104_v0_0_s_ifspec;

#ifndef __IOInetBindSink_INTERFACE_DEFINED__
#define __IOInetBindSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetBindSink
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetBindSink __RPC_FAR *LPOINETBINDSINK;


EXTERN_C const IID IID_IOInetBindSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9e9-baf9-11ce-8c82-00aa004ba90b")
    IOInetBindSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObject( 
            /* [in] */ HRESULT hresult,
            /* [in] */ REFIID riid,
            /* [in] */ IUnknown __RPC_FAR *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOInetBindSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInetBindSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInetBindSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInetBindSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnProgress )( 
            IOInetBindSink __RPC_FAR * This,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnObject )( 
            IOInetBindSink __RPC_FAR * This,
            /* [in] */ HRESULT hresult,
            /* [in] */ REFIID riid,
            /* [in] */ IUnknown __RPC_FAR *pUnk);
        
        END_INTERFACE
    } IOInetBindSinkVtbl;

    interface IOInetBindSink
    {
        CONST_VTBL struct IOInetBindSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInetBindSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInetBindSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInetBindSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOInetBindSink_OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)	\
    (This)->lpVtbl -> OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)

#define IOInetBindSink_OnObject(This,hresult,riid,pUnk)	\
    (This)->lpVtbl -> OnObject(This,hresult,riid,pUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOInetBindSink_OnProgress_Proxy( 
    IOInetBindSink __RPC_FAR * This,
    /* [in] */ ULONG ulProgress,
    /* [in] */ ULONG ulProgressMax,
    /* [in] */ ULONG ulStatusCode,
    /* [in] */ LPCWSTR szStatusText);


void __RPC_STUB IOInetBindSink_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetBindSink_OnObject_Proxy( 
    IOInetBindSink __RPC_FAR * This,
    /* [in] */ HRESULT hresult,
    /* [in] */ REFIID riid,
    /* [in] */ IUnknown __RPC_FAR *pUnk);


void __RPC_STUB IOInetBindSink_OnObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOInetBindSink_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0105
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOINETCACHE_DEFINED
#define _LPOINETCACHE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0105_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0105_v0_0_s_ifspec;

#ifndef __IOInetCache_INTERFACE_DEFINED__
#define __IOInetCache_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetCache
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetCache __RPC_FAR *LPOINETCACHE;


EXTERN_C const IID IID_IOInetCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9ea-baf9-11ce-8c82-00aa004ba90b")
    IOInetCache : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IOInetCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInetCache __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInetCache __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInetCache __RPC_FAR * This);
        
        END_INTERFACE
    } IOInetCacheVtbl;

    interface IOInetCache
    {
        CONST_VTBL struct IOInetCacheVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInetCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInetCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInetCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOInetCache_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0106
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOINETPRIORITY_DEFINED
#define _LPOINETPRIORITY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0106_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0106_v0_0_s_ifspec;

#ifndef __IOInetPriority_INTERFACE_DEFINED__
#define __IOInetPriority_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetPriority
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetPriority __RPC_FAR *LPOINETPRIORITY;


EXTERN_C const IID IID_IOInetPriority;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9eb-baf9-11ce-8c82-00aa004ba90b")
    IOInetPriority : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ LONG nPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ LONG __RPC_FAR *pnPriority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOInetPriorityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInetPriority __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInetPriority __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInetPriority __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPriority )( 
            IOInetPriority __RPC_FAR * This,
            /* [in] */ LONG nPriority);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPriority )( 
            IOInetPriority __RPC_FAR * This,
            /* [out] */ LONG __RPC_FAR *pnPriority);
        
        END_INTERFACE
    } IOInetPriorityVtbl;

    interface IOInetPriority
    {
        CONST_VTBL struct IOInetPriorityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInetPriority_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInetPriority_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInetPriority_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOInetPriority_SetPriority(This,nPriority)	\
    (This)->lpVtbl -> SetPriority(This,nPriority)

#define IOInetPriority_GetPriority(This,pnPriority)	\
    (This)->lpVtbl -> GetPriority(This,pnPriority)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOInetPriority_SetPriority_Proxy( 
    IOInetPriority __RPC_FAR * This,
    /* [in] */ LONG nPriority);


void __RPC_STUB IOInetPriority_SetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetPriority_GetPriority_Proxy( 
    IOInetPriority __RPC_FAR * This,
    /* [out] */ LONG __RPC_FAR *pnPriority);


void __RPC_STUB IOInetPriority_GetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOInetPriority_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0107
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPOINETPARSE_DEFINED
#define _LPOINETPARSE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0107_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0107_v0_0_s_ifspec;

#ifndef __IOInetParse_INTERFACE_DEFINED__
#define __IOInetParse_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOInetParse
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IOInetParse __RPC_FAR *LPOINETPARSE;


EXTERN_C const IID IID_IOInetParse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9ec-baf9-11ce-8c82-00aa004ba90b")
    IOInetParse : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CanonicalizeUrl( 
            /* [in] */ LPCWSTR pwzUrl,
            /* [out] */ LPWSTR __RPC_FAR *ppwzBuffer,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CombineUrl( 
            /* [in] */ LPCWSTR pwwzBaseUrl,
            /* [in] */ LPCWSTR pwzRelativeUrl,
            /* [out] */ LPWSTR __RPC_FAR *ppwzBuffer,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOInetParseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOInetParse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOInetParse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOInetParse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanonicalizeUrl )( 
            IOInetParse __RPC_FAR * This,
            /* [in] */ LPCWSTR pwzUrl,
            /* [out] */ LPWSTR __RPC_FAR *ppwzBuffer,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CombineUrl )( 
            IOInetParse __RPC_FAR * This,
            /* [in] */ LPCWSTR pwwzBaseUrl,
            /* [in] */ LPCWSTR pwzRelativeUrl,
            /* [out] */ LPWSTR __RPC_FAR *ppwzBuffer,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IOInetParseVtbl;

    interface IOInetParse
    {
        CONST_VTBL struct IOInetParseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOInetParse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOInetParse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOInetParse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOInetParse_CanonicalizeUrl(This,pwzUrl,ppwzBuffer,dwFlags)	\
    (This)->lpVtbl -> CanonicalizeUrl(This,pwzUrl,ppwzBuffer,dwFlags)

#define IOInetParse_CombineUrl(This,pwwzBaseUrl,pwzRelativeUrl,ppwzBuffer,dwFlags)	\
    (This)->lpVtbl -> CombineUrl(This,pwwzBaseUrl,pwzRelativeUrl,ppwzBuffer,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOInetParse_CanonicalizeUrl_Proxy( 
    IOInetParse __RPC_FAR * This,
    /* [in] */ LPCWSTR pwzUrl,
    /* [out] */ LPWSTR __RPC_FAR *ppwzBuffer,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IOInetParse_CanonicalizeUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOInetParse_CombineUrl_Proxy( 
    IOInetParse __RPC_FAR * This,
    /* [in] */ LPCWSTR pwwzBaseUrl,
    /* [in] */ LPCWSTR pwzRelativeUrl,
    /* [out] */ LPWSTR __RPC_FAR *ppwzBuffer,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IOInetParse_CombineUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOInetParse_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0108
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
STDAPI GetOInetSession(DWORD dwMode, IOInetSession **ppOInetSession, DWORD dwReserved);       
#define INET_E_USE_DEFAULT_PROTOCOLHANDLER _HRESULT_TYPEDEF_(0x800C0011L)      
#define INET_E_USE_DEFAULT_SETTING         _HRESULT_TYPEDEF_(0x800C0012L)      
#endif // !_URLMON_NO_ASYNC_PLUGABLE_PROTOCOLS_ 
#ifndef _LPBINDSTATUSCALLBACKMSG_DEFINED
#define _LPBINDSTATUSCALLBACKMSG_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0108_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0108_v0_0_s_ifspec;

#ifndef __IBindStatusCallbackMsg_INTERFACE_DEFINED__
#define __IBindStatusCallbackMsg_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBindStatusCallbackMsg
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IBindStatusCallbackMsg __RPC_FAR *LPBINDSTATUSCALLBACKMSG;

typedef 
enum tagMSGCALLTYPE
    {	IBSCLEVEL_TOPLEVEL	= 1,
	IBSCLEVEL_NESTED	= 2
    }	IBSCLEVEL;

typedef 
enum tagIBSCPENDINGMSG
    {	IBSCPENDINGMSG_WAITDEFPROCESS	= 0,
	IBSCPENDINGMSG_WAITNOPROCESS	= 1,
	IBSCPENDINGMSG_CANCELCALL	= 2
    }	IBSCPENDINGMSG;


EXTERN_C const IID IID_IBindStatusCallbackMsg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9cb-baf9-11ce-8c82-00aa004ba90b")
    IBindStatusCallbackMsg : public IBindStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MessagePending( 
            /* [in] */ DWORD dwPendingType,
            /* [in] */ DWORD dwPendingRecursion,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindStatusCallbackMsgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBindStatusCallbackMsg __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBindStatusCallbackMsg __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBindStatusCallbackMsg __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartBinding )( 
            IBindStatusCallbackMsg __RPC_FAR * This,
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding __RPC_FAR *pib);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPriority )( 
            IBindStatusCallbackMsg __RPC_FAR * This,
            /* [out] */ LONG __RPC_FAR *pnPriority);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLowResource )( 
            IBindStatusCallbackMsg __RPC_FAR * This,
            /* [in] */ DWORD reserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnProgress )( 
            IBindStatusCallbackMsg __RPC_FAR * This,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStopBinding )( 
            IBindStatusCallbackMsg __RPC_FAR * This,
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBindInfo )( 
            IBindStatusCallbackMsg __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataAvailable )( 
            IBindStatusCallbackMsg __RPC_FAR * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ STGMEDIUM __RPC_FAR *pstgmed);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnObjectAvailable )( 
            IBindStatusCallbackMsg __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown __RPC_FAR *punk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MessagePending )( 
            IBindStatusCallbackMsg __RPC_FAR * This,
            /* [in] */ DWORD dwPendingType,
            /* [in] */ DWORD dwPendingRecursion,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IBindStatusCallbackMsgVtbl;

    interface IBindStatusCallbackMsg
    {
        CONST_VTBL struct IBindStatusCallbackMsgVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindStatusCallbackMsg_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindStatusCallbackMsg_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindStatusCallbackMsg_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindStatusCallbackMsg_OnStartBinding(This,dwReserved,pib)	\
    (This)->lpVtbl -> OnStartBinding(This,dwReserved,pib)

#define IBindStatusCallbackMsg_GetPriority(This,pnPriority)	\
    (This)->lpVtbl -> GetPriority(This,pnPriority)

#define IBindStatusCallbackMsg_OnLowResource(This,reserved)	\
    (This)->lpVtbl -> OnLowResource(This,reserved)

#define IBindStatusCallbackMsg_OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)	\
    (This)->lpVtbl -> OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)

#define IBindStatusCallbackMsg_OnStopBinding(This,hresult,szError)	\
    (This)->lpVtbl -> OnStopBinding(This,hresult,szError)

#define IBindStatusCallbackMsg_GetBindInfo(This,grfBINDF,pbindinfo)	\
    (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo)

#define IBindStatusCallbackMsg_OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed)	\
    (This)->lpVtbl -> OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed)

#define IBindStatusCallbackMsg_OnObjectAvailable(This,riid,punk)	\
    (This)->lpVtbl -> OnObjectAvailable(This,riid,punk)


#define IBindStatusCallbackMsg_MessagePending(This,dwPendingType,dwPendingRecursion,dwReserved)	\
    (This)->lpVtbl -> MessagePending(This,dwPendingType,dwPendingRecursion,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBindStatusCallbackMsg_MessagePending_Proxy( 
    IBindStatusCallbackMsg __RPC_FAR * This,
    /* [in] */ DWORD dwPendingType,
    /* [in] */ DWORD dwPendingRecursion,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IBindStatusCallbackMsg_MessagePending_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindStatusCallbackMsg_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0109
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPBINDSTATUSCALLBACKHOLDER_DEFINED
#define _LPBINDSTATUSCALLBACKHOLDER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0109_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0109_v0_0_s_ifspec;

#ifndef __IBindStatusCallbackHolder_INTERFACE_DEFINED__
#define __IBindStatusCallbackHolder_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBindStatusCallbackHolder
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IBindStatusCallbackHolder __RPC_FAR *LPBINDSTATUSCALLBACKHOLDER;


EXTERN_C const IID IID_IBindStatusCallbackHolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9cc-baf9-11ce-8c82-00aa004ba90b")
    IBindStatusCallbackHolder : public IBindStatusCallback
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IBindStatusCallbackHolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBindStatusCallbackHolder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBindStatusCallbackHolder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBindStatusCallbackHolder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartBinding )( 
            IBindStatusCallbackHolder __RPC_FAR * This,
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding __RPC_FAR *pib);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPriority )( 
            IBindStatusCallbackHolder __RPC_FAR * This,
            /* [out] */ LONG __RPC_FAR *pnPriority);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLowResource )( 
            IBindStatusCallbackHolder __RPC_FAR * This,
            /* [in] */ DWORD reserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnProgress )( 
            IBindStatusCallbackHolder __RPC_FAR * This,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStopBinding )( 
            IBindStatusCallbackHolder __RPC_FAR * This,
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBindInfo )( 
            IBindStatusCallbackHolder __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataAvailable )( 
            IBindStatusCallbackHolder __RPC_FAR * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ STGMEDIUM __RPC_FAR *pstgmed);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnObjectAvailable )( 
            IBindStatusCallbackHolder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown __RPC_FAR *punk);
        
        END_INTERFACE
    } IBindStatusCallbackHolderVtbl;

    interface IBindStatusCallbackHolder
    {
        CONST_VTBL struct IBindStatusCallbackHolderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindStatusCallbackHolder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindStatusCallbackHolder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindStatusCallbackHolder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindStatusCallbackHolder_OnStartBinding(This,dwReserved,pib)	\
    (This)->lpVtbl -> OnStartBinding(This,dwReserved,pib)

#define IBindStatusCallbackHolder_GetPriority(This,pnPriority)	\
    (This)->lpVtbl -> GetPriority(This,pnPriority)

#define IBindStatusCallbackHolder_OnLowResource(This,reserved)	\
    (This)->lpVtbl -> OnLowResource(This,reserved)

#define IBindStatusCallbackHolder_OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)	\
    (This)->lpVtbl -> OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)

#define IBindStatusCallbackHolder_OnStopBinding(This,hresult,szError)	\
    (This)->lpVtbl -> OnStopBinding(This,hresult,szError)

#define IBindStatusCallbackHolder_GetBindInfo(This,grfBINDF,pbindinfo)	\
    (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo)

#define IBindStatusCallbackHolder_OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed)	\
    (This)->lpVtbl -> OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed)

#define IBindStatusCallbackHolder_OnObjectAvailable(This,riid,punk)	\
    (This)->lpVtbl -> OnObjectAvailable(This,riid,punk)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBindStatusCallbackHolder_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0110
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPMEDIAHOLDER_DEFINED
#define _LPMEDIAHOLDER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0110_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0110_v0_0_s_ifspec;

#ifndef __IMediaHolder_INTERFACE_DEFINED__
#define __IMediaHolder_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMediaHolder
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IMediaHolder __RPC_FAR *LPMEDIAHOLDER;


EXTERN_C const IID IID_IMediaHolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9ce-baf9-11ce-8c82-00aa004ba90b")
    IMediaHolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterClassMapping( 
            /* [in] */ DWORD ctypes,
            /* [size_is][in] */ LPCSTR __RPC_FAR rgszNames[  ],
            /* [size_is][in] */ CLSID __RPC_FAR rgClsIDs[  ],
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClassMapping( 
            /* [in] */ LPCSTR szMime,
            /* [out] */ CLSID __RPC_FAR *pClassID,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaHolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMediaHolder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMediaHolder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMediaHolder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterClassMapping )( 
            IMediaHolder __RPC_FAR * This,
            /* [in] */ DWORD ctypes,
            /* [size_is][in] */ LPCSTR __RPC_FAR rgszNames[  ],
            /* [size_is][in] */ CLSID __RPC_FAR rgClsIDs[  ],
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindClassMapping )( 
            IMediaHolder __RPC_FAR * This,
            /* [in] */ LPCSTR szMime,
            /* [out] */ CLSID __RPC_FAR *pClassID,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IMediaHolderVtbl;

    interface IMediaHolder
    {
        CONST_VTBL struct IMediaHolderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaHolder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaHolder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaHolder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaHolder_RegisterClassMapping(This,ctypes,rgszNames,rgClsIDs,dwReserved)	\
    (This)->lpVtbl -> RegisterClassMapping(This,ctypes,rgszNames,rgClsIDs,dwReserved)

#define IMediaHolder_FindClassMapping(This,szMime,pClassID,dwReserved)	\
    (This)->lpVtbl -> FindClassMapping(This,szMime,pClassID,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaHolder_RegisterClassMapping_Proxy( 
    IMediaHolder __RPC_FAR * This,
    /* [in] */ DWORD ctypes,
    /* [size_is][in] */ LPCSTR __RPC_FAR rgszNames[  ],
    /* [size_is][in] */ CLSID __RPC_FAR rgClsIDs[  ],
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IMediaHolder_RegisterClassMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaHolder_FindClassMapping_Proxy( 
    IMediaHolder __RPC_FAR * This,
    /* [in] */ LPCSTR szMime,
    /* [out] */ CLSID __RPC_FAR *pClassID,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IMediaHolder_FindClassMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaHolder_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0111
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPTRANSACTIONDATA_DEFINED
#define _LPTRANSACTIONDATA_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0111_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0111_v0_0_s_ifspec;

#ifndef __ITransactionData_INTERFACE_DEFINED__
#define __ITransactionData_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionData
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ITransactionData __RPC_FAR *LPTRANSACTIONDATA;


EXTERN_C const IID IID_ITransactionData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79eac9cf-baf9-11ce-8c82-00aa004ba90b")
    ITransactionData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTransactionData( 
            /* [in] */ LPCWSTR szUrl,
            /* [out] */ LPOLESTR __RPC_FAR *pszFilename,
            /* [out] */ LPOLESTR __RPC_FAR *pszMime,
            /* [out] */ DWORD __RPC_FAR *pdwSizeTotal,
            /* [out] */ DWORD __RPC_FAR *pdwSizeAvailable,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransactionData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransactionData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransactionData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransactionData )( 
            ITransactionData __RPC_FAR * This,
            /* [in] */ LPCWSTR szUrl,
            /* [out] */ LPOLESTR __RPC_FAR *pszFilename,
            /* [out] */ LPOLESTR __RPC_FAR *pszMime,
            /* [out] */ DWORD __RPC_FAR *pdwSizeTotal,
            /* [out] */ DWORD __RPC_FAR *pdwSizeAvailable,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } ITransactionDataVtbl;

    interface ITransactionData
    {
        CONST_VTBL struct ITransactionDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionData_GetTransactionData(This,szUrl,pszFilename,pszMime,pdwSizeTotal,pdwSizeAvailable,dwReserved)	\
    (This)->lpVtbl -> GetTransactionData(This,szUrl,pszFilename,pszMime,pdwSizeTotal,pdwSizeAvailable,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionData_GetTransactionData_Proxy( 
    ITransactionData __RPC_FAR * This,
    /* [in] */ LPCWSTR szUrl,
    /* [out] */ LPOLESTR __RPC_FAR *pszFilename,
    /* [out] */ LPOLESTR __RPC_FAR *pszMime,
    /* [out] */ DWORD __RPC_FAR *pdwSizeTotal,
    /* [out] */ DWORD __RPC_FAR *pdwSizeAvailable,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB ITransactionData_GetTransactionData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionData_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_urlmki_0112
 * at Thu Apr 10 06:35:30 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif
#define BINDF_IGNOREMIMECLSID           0x80000000     
#define BINDF_COMPLETEDOWNLOAD          0x01000000     


extern RPC_IF_HANDLE __MIDL_itf_urlmki_0112_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmki_0112_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Proxy( 
    IBinding __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pclsidProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwResult,
    /* [out] */ LPOLESTR __RPC_FAR *pszResult,
    /* [out][in] */ DWORD __RPC_FAR *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Stub( 
    IBinding __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pclsidProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwResult,
    /* [out] */ LPOLESTR __RPC_FAR *pszResult,
    /* [in] */ DWORD dwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Proxy( 
    IBindStatusCallback __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *grfBINDF,
    /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Stub( 
    IBindStatusCallback __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *grfBINDF,
    /* [unique][out][in] */ RemBINDINFO __RPC_FAR *pbindinfo,
    /* [unique][out][in] */ RemSTGMEDIUM __RPC_FAR *pstgmed);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Proxy( 
    IBindStatusCallback __RPC_FAR * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ FORMATETC __RPC_FAR *pformatetc,
    /* [in] */ STGMEDIUM __RPC_FAR *pstgmed);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Stub( 
    IBindStatusCallback __RPC_FAR * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ RemFORMATETC __RPC_FAR *pformatetc,
    /* [in] */ RemSTGMEDIUM __RPC_FAR *pstgmed);

/* [local] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Proxy( 
    IWinInetInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Stub( 
    IWinInetInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE __RPC_FAR *pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf);

/* [local] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Proxy( 
    IWinInetHttpInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
    /* [out][in] */ DWORD __RPC_FAR *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Stub( 
    IWinInetHttpInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE __RPC_FAR *pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
    /* [out][in] */ DWORD __RPC_FAR *pdwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Proxy( 
    IBindHost __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pMk,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Stub( 
    IBindHost __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pMk,
    /* [unique][in] */ IBindCtx __RPC_FAR *pBC,
    /* [unique][in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObj);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Proxy( 
    IBindHost __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pMk,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Stub( 
    IBindHost __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pMk,
    /* [unique][in] */ IBindCtx __RPC_FAR *pBC,
    /* [unique][in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObj);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\utf8.cpp ===
// UTF8.CPP -- Implementation of the Unicode to/from UTF8 conversion routines

#include "stdafx.h"

inline INT FailWith(INT iError)
{                          
    SetLastError(iError);    
                            
    return 0;               
}

int WideCharToUTF8(LPCWSTR lpWideCharStr, int cchWideChar, 
				    LPSTR lpMultiByteStr, int cchMultiByte
				  )
{
    if (   PBYTE(lpWideCharStr) == PBYTE(lpMultiByteStr)
        || cchWideChar  < -1
        || cchMultiByte <  0
       )
        return FailWith(ERROR_INVALID_PARAMETER);
    
    if (cchWideChar == -1) // -1 means lpWideCharStr is null terminated.
        cchWideChar = wcsLen(lpWideCharStr) + 1;

    int cbNecessary = 0; // Number of UTF8 bytes necessary
                         // to represent the Unicode string

    BOOL fStoring = cchMultiByte > 0;

    for (; cchWideChar--; )
    {
        WCHAR wc= *lpWideCharStr++;

        if (wc < 0x0080) // ASCII characters
        {
            cbNecessary++;

            if (fStoring)
                if (cchMultiByte > 0)
                {
                    *lpMultiByteStr++ = BYTE(wc);
                    --cchMultiByte;
                }
                else 
                    return FailWith(ERROR_INSUFFICIENT_BUFFER);
        }
        else
            if (wc < 0x0800) // 0x0080 - 0x07FF
            {
                cbNecessary += 2;

                if (fStoring)
                    if (cchMultiByte > 1)
                    {
                        cchMultiByte -= 2;

                        *lpMultiByteStr++ = 0xC0 | (wc >> 6);
                        *lpMultiByteStr++ = 0x80 | (wc & 0x3F);
                    }
                    else
                        return FailWith(ERROR_INSUFFICIENT_BUFFER);
            }
            else // 0x0800 - 0xFFFF
            {
                cbNecessary += 3;

                if (fStoring)
                    if (cchMultiByte > 2)
                    {
                        cchMultiByte -= 3;

                        *lpMultiByteStr++ = 0xE0 | ( wc >> 12);
                        *lpMultiByteStr++ = 0x80 | ((wc >> 6) & 0x3F);
                        *lpMultiByteStr++ = 0x80 | ( wc       & 0x3F);
                    }
                    else
                        return FailWith(ERROR_INSUFFICIENT_BUFFER);
            }
    }

    return cbNecessary;
}

int UTF8ToWideChar(LPCSTR lpMultiByteStr, int cchMultiByte, 
				    LPWSTR lpWideCharStr, int cchWideChar
				  )
{
    if (   PBYTE(lpWideCharStr) == PBYTE(lpMultiByteStr)
        || cchMultiByte < -1
        || cchWideChar  <  0
       )
        return FailWith(ERROR_INVALID_PARAMETER);

    if (cchMultiByte == -1) // -1 means lpMultiByteStr is null terminated
        cchMultiByte = lstrlenA(lpMultiByteStr) + 1;
    
    int cwcNecessary = 0; // Number of Unicode characters necessary to
                          // represent the UTF8 sequence.

    BOOL fStoring = cchWideChar > 0;
    
    for (; cchMultiByte--; cwcNecessary++)
    {
        BYTE b= *lpMultiByteStr++;

        if (b < 0x80)  // An ASCII character
        {
            if (fStoring)
                if (cchWideChar > 0)
                {
                    cchWideChar--;

                    *lpWideCharStr++ = WCHAR(b);
                }
                else
                    return FailWith(ERROR_INSUFFICIENT_BUFFER);
        }
        else
            if (b < 0xC0) // Trailing character in a multibyte code
                return FailWith(ERROR_NO_UNICODE_TRANSLATION);
            else
                if (b < 0xE0)  // First character of a two-byte code
                {
                    if (cchMultiByte <= 0) // Do we have a second byte?
                        return FailWith(ERROR_NO_UNICODE_TRANSLATION);

                    cchMultiByte--;

                    BYTE b2 = *lpMultiByteStr++;

                    if ((b2 & 0xC0) != 0x80) // Trailing byte must 
                                             // have the form 10xxxxxx
                        return FailWith(ERROR_NO_UNICODE_TRANSLATION);

                    if (fStoring)
                        if (cchWideChar > 0)
                        {
                            cchWideChar--;

                            *lpWideCharStr++ = ((b & 0x1F) << 6) | (b2 & 0x3F);
                        }
                        else
                            return FailWith(ERROR_INSUFFICIENT_BUFFER);                    
                }
                else  // First character of a three-byte code
                {
                    if (cchMultiByte <= 1) // Do we have two more bytes?
                        return FailWith(ERROR_NO_UNICODE_TRANSLATION);

                    cchMultiByte -= 2;

                    BYTE b2 = *lpMultiByteStr++;
                    BYTE b3 = *lpMultiByteStr++;

                    if (   (b2 & 0xC0) != 0x80 // Trailing bytes must
                        || (b3 & 0xC0) != 0x80 // have the form 10xxxxxx
                       )
                        return FailWith(ERROR_NO_UNICODE_TRANSLATION);

                    if (fStoring)
                        if (cchWideChar > 0)
                        {
                            cchWideChar--;

                            *lpWideCharStr++ = ((b & 0x0F) << 12) | ((b2 & 0x3F) << 6) 
                                                                  |  (b3 & 0x3F);
                        }
                        else
                            return FailWith(ERROR_INSUFFICIENT_BUFFER);                    
                }
    }

    return cwcNecessary;
}

UINT BuildAKey(const WCHAR *pwcImage, UINT cwcImage, PCHAR pchKeyBuffer, UINT cchKeyBuffer)
{
    // This routine constructs a key from a sequence of Unicode characters. 
    // A key consists of a packed-32 length value followed by a UTF-8 representation
    // of the Unicode characters. The resulting key will be stored in the buffer 
    // denoted by pchKeyBuffer and cchKeyBuffer. The cchKeyBuffer parameter defines
    // the size of the key buffer in bytes. 
    //
    // The result value will always be the number of byte required to hold the key.
    // So you can dyamically allocate the key buffer by first calling this routine
    // with pchKeyBuffer set to NULL, allocating from the heap, and calling a second
    // time to record the key string.
    
    UINT cbKeyName = WideCharToUTF8(pwcImage, cwcImage, NULL, 0);
    
    PCHAR pchCursor= pchKeyBuffer;

    UINT cbSize= 0;

    for (UINT c= cbKeyName; ; )
    {
        cbSize++;

        if (pchCursor)
        {
            if (c < 0x80) 
            {
                if (cbSize < cchKeyBuffer)
                    *pchCursor++ = CHAR(c);

                break;
            }

            if (cbSize < cchKeyBuffer)
                *pchCursor++ = CHAR(c & 0x7F) | 0x10;
        }

        c >>= 7;
    }
    
    if (pchCursor)
        WideCharToUTF8(pwcImage, cwcImage, pchCursor, cchKeyBuffer - cbSize);

    return cbSize + cbKeyName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\ver.h ===
#ifndef RC_INVOKED
#pragma message ("VER.H obsolete, including WINVER.H instead")
#endif
#include <winver.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\utf8.h ===
// UTF8.h -- Interface definition for conversions between Unicode and the UTF8 representation

#ifndef __UTF8_H__

#define __UTF8_H__

// UTF8 is a multibyte encoding of 16-bit Unicode characters. Its primary purpose
// is to provide a transmission form to take Unicode text through host environments
// that assume all text is ASCII text.In particular many of those environments will
// interpret a zero byte as marking the end of a text string. 
//
// The UTF8 encoding guarantees that the ASCII section of Unicode (0x0000 - 0x007F)
// is represented by 8-bit ASCII codes (0x00 - 0x7F). Thus any environment which 
// expects to see ASCII characters will see no difference when those ASCII characters
// appear in a UTF8 stream.  
//
// Those are the only single-byte encodings in UTF8. All other Unicode values are
// represented with two or three byte codes. In those encodings all the byte values 
// values have their high bit set. Thus the appearance of a byte in the range 
// 0x00-0x7F always represents an ASCII character. 
//
// Values in the range 0x0080 through 0x07FF are encoded in two bytes, while values
// in the range 0x0x0800 through 0xFFFF are encoded with three bytes. The first byte
// in an encoding defines the length of the encoding by the number of high order bits
// set to one. Thus a two byte code has a first byte value of the form 110xxxxx and
// the first byte of a three byte code has the form 1110xxxx. Trailing bytes always
// have the form 10xxxxxx so they won't be mistaken for ASCII characters. 
//
// Note that two byte codes represent values that have zeroes in the five high-order
// bit positions. That means they can be represented in 11 bits. So we store those
// eleven bits with the high order five bits in the first encoding byte, and we store
// the low order six bits in the second byte of the code.
//
// Similarly for a three-byte code we store the high-order four-bits in the first byte,
// we put the next six bits in the second code, and we store the low order six bits
// in the third code.

#define MAX_UTF8_PATH   (MAX_PATH*3 - 2)  // Worst case expansion from Unicode 
                                          // path to UTF-8 encoded path.
int WideCharToUTF8
    (LPCWSTR lpWideCharStr,	// address of wide-character string 
     int cchWideChar,	    // number of characters in string 
     LPSTR lpMultiByteStr,	// address of buffer for new string 
     int cchMultiByte 	    // size of buffer 
    );

int UTF8ToWideChar
    (LPCSTR lpMultiByteStr,	// address of string to map 
     int cchMultiByte,	    // number of characters in string 
     LPWSTR lpWideCharStr,	// address of wide-character buffer 
     int cchWideChar    	// size of buffer 
    );

UINT BuildAKey(const WCHAR *pwcImage, UINT cwcImage, PCHAR pchKeyBuffer, UINT cchKeyBuffer);

#endif // __UTF8_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\verinfo.h ===
/*****************************************************************************
*
*  VERINFO.H
*
*  Copyright (C) Microsoft Corporation 1996-1997
*  All Rights reserved.
*
******************************************************************************
*
*  Module Intent: Version specific constant definitions
* 
*****************************************************************************/

// InfoTech version number:  major, minor, update, application.
#define rmj             4
#define rmm             72
#define rup             8084
#define rap             0

#define szVerName       ""
#define szVerUser       ""

// NT build environment defines DBG instead of _DEBUG
#ifdef DBG
#define _DEBUG
#endif

#ifdef _DEBUG
#define VERSIONSTR		"Debug Version 4.72\0"
#define VERSIONFLAGS            VS_FF_DEBUG
#else
#define VERSIONSTR		"4.72\0"
#define VERSIONFLAGS            0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\xfrmserv.cpp ===
// xfrmserv.cpp -- Implementation for the Transform Services class

#include "stdafx.h"

HRESULT CTransformServices::Create
    (IUnknown *punkOuter, IITFileSystem *pITSFS, ITransformServices **ppTransformServices)
{
    CTransformServices *pTS = New CTransformServices(punkOuter);

    return FinishSetup(pTS? pTS->m_ImpITransformServices.Initial(pITSFS)
                          : STG_E_INSUFFICIENTMEMORY,
                       pTS, IID_ITransformServices, (PPVOID) ppTransformServices
                      );
}


CTransformServices::CImpITransformServices::CImpITransformServices
    (CTransformServices *pBackObj, IUnknown *punkOuter)
    : IITTransformServices(pBackObj, punkOuter)
{
    m_pITSFS = NULL;
}

CTransformServices::CImpITransformServices::~CImpITransformServices()
{
    if (m_pITSFS)
        m_pITSFS->Release();
}

HRESULT CTransformServices::CImpITransformServices::Initial(IITFileSystem *pITSFS)
{
    m_pITSFS = pITSFS;

    m_pITSFS->AddRef();

    return NO_ERROR;
}

// ITransformServices methods

HRESULT STDMETHODCALLTYPE CTransformServices::CImpITransformServices::PerTransformStorage
	(REFCLSID rclsidXForm, IStorage **ppStg)
{
    WCHAR awcsClassID[CWC_GUID_STRING_BUFFER];

    UINT cbResult = StringFromGUID2(rclsidXForm, awcsClassID, CWC_GUID_STRING_BUFFER); 

    if (cbResult == 0)
        return STG_E_UNKNOWN;

    RonM_ASSERT(wcsLen(pwcsTransformStorage) + wcsLen(awcsClassID) + 1 < MAX_PATH);

    WCHAR awcsPath[MAX_PATH];

    wcsCpy(awcsPath, pwcsTransformStorage);
    wcsCat(awcsPath, awcsClassID);
    wcsCat(awcsPath, L"/");

    return m_pITSFS->CreateStorage(NULL, awcsPath, STGM_READWRITE, (IStorageITEx **) ppStg);
}


HRESULT STDMETHODCALLTYPE CTransformServices::CImpITransformServices::PerTransformInstanceStorage
	(REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg)
{
    WCHAR awcsClassID[CWC_GUID_STRING_BUFFER];

    UINT cbResult = StringFromGUID2(rclsidXForm, awcsClassID, CWC_GUID_STRING_BUFFER); 

    if (cbResult == 0)
        return STG_E_UNKNOWN;

    UINT cwc = wcsLen(pwcsSpaceNameStorage) + wcsLen(pwszDataSpace)
                                            + wcsLen(pwcsTransformSubStorage)
                                            + wcsLen(awcsClassID)
                                            + wcsLen(pwcsInstanceSubStorage);

    if (cwc >= MAX_PATH)
        return STG_E_INVALIDNAME;

    WCHAR awcsPath[MAX_PATH];

    wcsCpy(awcsPath, pwcsSpaceNameStorage);
    wcsCat(awcsPath, pwszDataSpace);
    wcsCat(awcsPath, pwcsTransformSubStorage);
    wcsCat(awcsPath, awcsClassID);
    wcsCat(awcsPath, pwcsInstanceSubStorage);

    HRESULT hr = m_pITSFS->OpenStorage(NULL, awcsPath, STGM_READWRITE, (IStorageITEx **) ppStg);

    if (hr == STG_E_FILENOTFOUND)
        hr = m_pITSFS->CreateStorage(NULL, awcsPath, STGM_READWRITE, (IStorageITEx **) ppStg);

    return hr;
}


HRESULT STDMETHODCALLTYPE CTransformServices::CImpITransformServices::SetKeys
	(REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
	 PBYTE pbReadKey,  UINT cbReadKey, 
	 PBYTE pbWriteKey, UINT cbWriteKey
	)
{
    RonM_ASSERT(FALSE);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTransformServices::CImpITransformServices::CreateTemporaryStream
    (IStream **ppStrm)
{
    ILockBytes *pLockBytes = NULL;
    
    HRESULT hr = CFSLockBytes::CreateTemp(NULL, &pLockBytes);

    if (SUCCEEDED(hr))
    {
        hr = CStream::OpenStream(NULL, pLockBytes, STGM_READWRITE, (IStreamITEx **) ppStrm);

        if (!SUCCEEDED(hr))
            pLockBytes->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\warehse.cpp ===
// Warehse.cpp -- Implementation for the class CWarehouse
#include "stdafx.h"


CWarehouse::CImpIWarehouse::CImpIWarehouse(CWarehouse *pBackObj, IUnknown *punkOuter)
    : IITITStorageEx(pBackObj, punkOuter)
{
    m_pITSCD = NULL;
}

CWarehouse::CImpIWarehouse::~CImpIWarehouse(void)
{
    if (m_pITSCD)
        delete [] (DWORD *) m_pITSCD;
}

HRESULT STDMETHODCALLTYPE CWarehouse::Create
    (IUnknown *punkOuter, REFIID riid, PPVOID ppv)
{
    if (punkOuter && riid != IID_IUnknown)
		return CLASS_E_NOAGGREGATION;
	
	CWarehouse *pWarehouse = New CWarehouse(punkOuter);

    if (!pWarehouse)
        return STG_E_INSUFFICIENTMEMORY;

    HRESULT hr = pWarehouse->m_ImpIWarehouse.Init();

	if (hr == S_OK)
		hr = pWarehouse->QueryInterface(riid, ppv);

    if (hr != S_OK)
        delete pWarehouse;

	return hr;
}

STDMETHODIMP CWarehouse::CImpIWarehouse::StgCreateDocfile
                 (const WCHAR * pwcsName, DWORD grfMode, 
                  DWORD reserved, IStorage ** ppstgOpen
                 )
{
    return CITFileSystem::CreateITFileSystem
               (NULL, pwcsName, grfMode, m_pITSCD, GetUserDefaultLCID(), ppstgOpen);
}

STDMETHODIMP CWarehouse::CImpIWarehouse::StgCreateDocfileOnILockBytes
                 (ILockBytes * plkbyt, DWORD grfMode,
                  DWORD reserved, IStorage ** ppstgOpen
                 )
{
    return CITFileSystem::CreateITFSOnLockBytes
               (NULL, plkbyt, grfMode, m_pITSCD, GetUserDefaultLCID(), ppstgOpen);
}


STDMETHODIMP CWarehouse::CImpIWarehouse::StgCreateDocfileForLocale
    (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, IStorage ** ppstgOpen)
{
    return CITFileSystem::CreateITFileSystem
               (NULL, pwcsName, grfMode, m_pITSCD, lcid, ppstgOpen);
}

STDMETHODIMP CWarehouse::CImpIWarehouse::StgCreateDocfileForLocaleOnILockBytes
    (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, IStorage ** ppstgOpen)
{
    return CITFileSystem::CreateITFSOnLockBytes
               (NULL, plkbyt, grfMode, m_pITSCD, lcid, ppstgOpen);
}

STDMETHODIMP CWarehouse::CImpIWarehouse::QueryFileStampAndLocale
    (const WCHAR *pwcsName, DWORD *pFileStamp, DWORD *pFileLocale)
{
    return CITFileSystem::QueryFileStampAndLocale(pwcsName, pFileStamp, pFileLocale);
}

STDMETHODIMP CWarehouse::CImpIWarehouse::QueryLockByteStampAndLocale
    (ILockBytes * plkbyt, DWORD *pFileStamp, DWORD *pFileLocale)
{
    return CITFileSystem::QueryLockByteStampAndLocale(plkbyt, pFileStamp, pFileLocale);
}

STDMETHODIMP CWarehouse::CImpIWarehouse::StgIsStorageFile(const WCHAR * pwcsName)
{
    return CITFileSystem::IsITFile(pwcsName);
}

STDMETHODIMP CWarehouse::CImpIWarehouse::StgIsStorageILockBytes(ILockBytes * plkbyt)
{
    return CITFileSystem::IsITLockBytes(plkbyt);
}

STDMETHODIMP CWarehouse::CImpIWarehouse::StgOpenStorage
                 (const WCHAR * pwcsName, IStorage * pstgPriority, 
                  DWORD grfMode, SNB snbExclude, DWORD reserved, 
                  IStorage ** ppstgOpen
                 )
{
    return CITFileSystem::OpenITFileSystem(NULL, pwcsName, grfMode, (IStorageITEx **)ppstgOpen);
}

STDMETHODIMP CWarehouse::CImpIWarehouse::StgOpenStorageOnILockBytes
              (ILockBytes * plkbyt, IStorage * pStgPriority, 
               DWORD grfMode, SNB snbExclude, DWORD reserved,
               IStorage ** ppstgOpen
              )
{
    return CITFileSystem::OpenITFSOnLockBytes(NULL, plkbyt, grfMode, (IStorageITEx **)ppstgOpen);
}

STDMETHODIMP CWarehouse::CImpIWarehouse::StgSetTimes
                 (WCHAR const * lpszName,  FILETIME const * pctime, 
                  FILETIME const * patime, FILETIME const * pmtime
                 )
{
    return CITFileSystem::SetITFSTimes(lpszName,  pctime, patime, pmtime);
}

STDMETHODIMP CWarehouse::CImpIWarehouse::SetControlData(PITS_Control_Data pControlData)
{
    UINT cdw = pControlData->cdwControlData + 1; 

    ITS_Control_Data *pITSCD = (ITS_Control_Data *) New DWORD[cdw];

    if (!pITSCD)
        return STG_E_INSUFFICIENTMEMORY;

    CopyMemory(pITSCD, pControlData, cdw * sizeof(DWORD));

     if (m_pITSCD)
        delete [] (DWORD *) m_pITSCD;
	 
	 m_pITSCD = pITSCD;

    return NO_ERROR;
}

STDMETHODIMP CWarehouse::CImpIWarehouse::DefaultControlData(PITS_Control_Data *ppControlData)
{
	return CITFileSystem::DefaultControlData(ppControlData);
}

STDMETHODIMP CWarehouse::CImpIWarehouse::Compact(const WCHAR * pwcsName, ECompactionLev iLev)
{
    return CITFileSystem::Compact(pwcsName, iLev);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\warehse.h ===
// Warehse.h -- Header information for the CWarehouse class

#ifndef __WAREHSE_H__

#define __WAREHSE_H__

class CWarehouse : public CITUnknown
{

public:
    
    // Creator:
    
    static HRESULT STDMETHODCALLTYPE Create(IUnknown *punkOuter, REFIID riid, PPVOID ppv);
    
    // Destructor:

    ~CWarehouse(void);

private:

    // Constructor:

    CWarehouse(IUnknown *punkOuter);
    
    class CImpIWarehouse : public IITITStorageEx
    {
    
    public:

        CImpIWarehouse(CWarehouse *pBackObj, IUnknown *punkOuter);
        ~CImpIWarehouse(void);

        // Initialing method:

        STDMETHODIMP Init();

        // IITStorage methods:

        STDMETHODIMP StgCreateDocfile
                         (const WCHAR * pwcsName, DWORD grfMode, 
                          DWORD reserved, IStorage ** ppstgOpen
                         );

        STDMETHODIMP StgCreateDocfileOnILockBytes
                         (ILockBytes * plkbyt, DWORD grfMode,
                          DWORD reserved, IStorage ** ppstgOpen
                         );

        STDMETHODIMP StgIsStorageFile(const WCHAR * pwcsName);

        STDMETHODIMP StgIsStorageILockBytes(ILockBytes * plkbyt);

        STDMETHODIMP StgOpenStorage
                         (const WCHAR * pwcsName, IStorage * pstgPriority, 
                          DWORD grfMode, SNB snbExclude, DWORD reserved, 
                          IStorage ** ppstgOpen
                         );

        STDMETHODIMP StgOpenStorageOnILockBytes
                      (ILockBytes * plkbyt, IStorage * pStgPriority, 
                       DWORD grfMode, SNB snbExclude, DWORD reserved,
                       IStorage ** ppstgOpen
                      );

        STDMETHODIMP StgSetTimes
                         (WCHAR const * lpszName,  FILETIME const * pctime, 
                          FILETIME const * patime, FILETIME const * pmtime
                         );

        STDMETHODIMP SetControlData(PITS_Control_Data pControlData);

        STDMETHODIMP DefaultControlData(PITS_Control_Data *ppControlData);

		STDMETHODIMP Compact(const WCHAR * pwcsName, ECompactionLev iLev);

        // ITStorageEx methods:
    
        STDMETHODIMP StgCreateDocfileForLocale
            (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, 
             IStorage ** ppstgOpen
            );

        STDMETHODIMP StgCreateDocfileForLocaleOnILockBytes
            (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, 
             IStorage ** ppstgOpen
            );

        STDMETHODIMP QueryFileStampAndLocale(const WCHAR *pwcsName, DWORD *pFileStamp, 
                                                                    DWORD *pFileLocale);
    
        STDMETHODIMP QueryLockByteStampAndLocale(ILockBytes * plkbyt, DWORD *pFileStamp, 
                                                                      DWORD *pFileLocale);

    private:

        ITS_Control_Data *m_pITSCD;
    };

    CImpIWarehouse m_ImpIWarehouse;
};

typedef CWarehouse *PCWarehouse;

extern GUID  aIID_CITStorage[];
extern UINT cInterfaces_CITStorage;

inline CWarehouse::CWarehouse(IUnknown *pUnkOuter)
    : m_ImpIWarehouse(this, pUnkOuter), 
      CITUnknown(aIID_CITStorage, cInterfaces_CITStorage, (IUnknown *) &m_ImpIWarehouse)
{
}

inline CWarehouse::~CWarehouse(void)
{
}

inline STDMETHODIMP CWarehouse::CImpIWarehouse::Init()
{
    return NO_ERROR;
}

#endif // __WAREHSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\common\typedefs.h ===
/*
 * typedefs.h
 *
 * Type definitions for LZX
 */
#ifndef _TYPEDEFS_H

#define _TYPEDEFS_H

/*
 * Definitions for LZX
 */
typedef unsigned char	byte;
typedef unsigned short	ushort;
typedef unsigned long	ulong;
typedef unsigned int    uint;

typedef enum
{
	false = 0,
	true = 1
} bool;


/*
 * Definitions for Diamond/CAB memory allocation
 */
typedef unsigned char   BYTE;
typedef unsigned short	USHORT;
typedef unsigned long	ULONG;
typedef unsigned int    UINT;


#ifdef BIT16

//** 16-bit build
#ifndef HUGE
#   define HUGE huge
#endif

#ifndef FAR
#   define FAR far
#endif

#ifndef NEAR
#   define NEAR near
#endif

#else // !BIT16

//** Define away for 32-bit (NT/Chicago) build
#ifndef HUGE
#	define HUGE
#endif

#ifndef FAR
#	define FAR
#endif

#ifndef NEAR
#   define NEAR
#endif

#endif // !BIT16

#ifndef DIAMONDAPI
#	define DIAMONDAPI __cdecl
#endif

typedef void HUGE * (FAR DIAMONDAPI *PFNALLOC)(ULONG cb); /* pfna */
#define FNALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb)

typedef void (FAR DIAMONDAPI *PFNFREE)(void HUGE *pv); /* pfnf */
#define FNFREE(fn) void FAR DIAMONDAPI fn(void HUGE *pv)

typedef int  (FAR DIAMONDAPI *PFNOPEN) (char FAR *pszFile,int oflag,int pmode);
typedef UINT (FAR DIAMONDAPI *PFNREAD) (int hf, void FAR *pv, UINT cb);
typedef UINT (FAR DIAMONDAPI *PFNWRITE)(int hf, void FAR *pv, UINT cb);
typedef int  (FAR DIAMONDAPI *PFNCLOSE)(int hf);
typedef long (FAR DIAMONDAPI *PFNSEEK) (int hf, long dist, int seektype);

#endif /* _TYPEDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\d16out.c ===
/*
 * d16out.c
 *
 * Outputting for 16-bit decoder
 */

#include "decoder.h"


void NEAR copy_data_to_output(
    t_decoder_context * context,
    long                amount,
    const byte *        data
)
{
    /*
     * Save pages before we transform
     *
     * Don't save pages if amount < CHUNK_SIZE, because that
     * means that this is our last chunk of data ever.
     * This will save a few page writes at the end.
     */
    if (amount >= CHUNK_SIZE)
        DComp_Save_Output_Pages(context, (uint) amount);

    /* perform jump translation */
    if (context->dec_current_file_size)
    {
        decoder_translate_e8(
            context,
            context->dec_output_buffer,
            amount
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\xfrmserv.h ===
// xfrmserv.h -- Declaration for the Transform Services class

#ifndef __XFRMSERV_H__

#define __XFRMSERV_H__

class CTransformServices : public CITUnknown
{
public:
	
	~CTransformServices();

	static HRESULT Create(IUnknown *punkOuter, IITFileSystem *pITSFS, 
                          ITransformServices **ppTransformServices
                         );

private:

	CTransformServices(IUnknown *punkOuter);

	class CImpITransformServices : public IITTransformServices
	{
	public:
		
		CImpITransformServices(CTransformServices *pBackObj, IUnknown *punkOuter);
		~CImpITransformServices();

        HRESULT Initial(IITFileSystem *pITSFS);

		// ITransformServices methods

		HRESULT STDMETHODCALLTYPE PerTransformStorage
			(REFCLSID rclsidXForm, IStorage **ppStg);

		HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
			(REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg);

		HRESULT STDMETHODCALLTYPE SetKeys
			(REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
			 PBYTE pbReadKey,  UINT cbReadKey, 
			 PBYTE pbWriteKey, UINT cbWriteKey
			);

		HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm);

	private:

        IITFileSystem *m_pITSFS;
	};

	CImpITransformServices m_ImpITransformServices;
};

inline CTransformServices::CTransformServices(IUnknown *pUnkOuter)
    : m_ImpITransformServices(this, pUnkOuter), 
      CITUnknown(&IID_ITransformServices, 1, &m_ImpITransformServices)
{

}

inline CTransformServices::~CTransformServices(void)
{
}

#endif // __XFRMSERV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\d16uncmp.c ===
/*
 * d16uncmp.c
 *
 * Decoding uncompressed blocks
 */
#include "decoder.h"


int NEAR decode_uncompressed_block(
    t_decoder_context * context,
    long                bufpos,
    int                 amount_to_decode /* yes, it will equal 32768 */
)
{
    byte *p;

    p = context->dec_input_curpos;

    /*
     * Since this is a DO loop, we predecrement amount_to_decode,
     * so it's ok for it to come in with a value of 32768
     */
    do
	{
        if (p >= context->dec_end_input_pos)
            return -1;

        context->DComp_Token_Literal(
            context,
            *p++
        );
    } while (--amount_to_decode > 0);

    context->dec_input_curpos = p;

    return 0;
}


bool NEAR handle_beginning_of_uncompressed_block(t_decoder_context *context)
{
    int i;

    /*
     * we want to read the 16 bits already in bitbuf, so backtrack
     * the input pointer by 2 bytes
     */
    context->dec_input_curpos -= 2;

    if (context->dec_input_curpos + 4 >= context->dec_end_input_pos)
        return false;

	/*
	 * update LRU repeated offset list
	 */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
    {
        context->dec_last_matchpos_offset[i] =
            ((ulong) *(  (byte *) context->dec_input_curpos)    )        |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 1) << 8)  |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 2) << 16) |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 3) << 24);

        context->dec_input_curpos += 4; /* increment by 4 bytes */
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\common\compdefs.h ===
/*
 * common/compdefs.h
 *
 * Definitions for both encoder and decoder
 */

/*
 * Smallest allowable match length 
 */
#define MIN_MATCH 2

/* 
 * Maximum match length 
 */
#define MAX_MATCH (MIN_MATCH+255)

/*
 * Number of uncompressed symbols 
 */
#define NUM_CHARS 256

/*
 * Number of match lengths which are correlated with match positions 
 */
#define NUM_PRIMARY_LENGTHS     7

/*
 * Primary lengths plus the extension code
 */
#define NUM_LENGTHS             (NUM_PRIMARY_LENGTHS+1)

/*
 * Equals number of different possible match lengths minus primary lengths 
 */
#define NUM_SECONDARY_LENGTHS   ((MAX_MATCH-MIN_MATCH+1)-NUM_PRIMARY_LENGTHS)

/* NL_SHIFT = log2(NUM_LENGTHS) */
#define NL_SHIFT                3

/*
 * Number of repeated offsets 
 */
#define NUM_REPEATED_OFFSETS    3

/*
 * Number of elements in the aligned offset tree
 */
#define ALIGNED_NUM_ELEMENTS 8


/*
 * Repeat codes for outputting trees
 */

/* Minimum number of repetitions of anything we're interested in */
#define TREE_ENC_REP_MIN                4

/* Maximum repetitions for "type A" repetition of zeroes */
/* (min...min+REP_ZERO_FIRST) */
#define TREE_ENC_REP_ZERO_FIRST        16

/* Maximum repetitions for "type B" repetition of zeroes */
/* (min+REP_ZERO_FIRST...min+REP_ZERO_FIRST+REP_ZERO_SECOND) */
#define TREE_ENC_REP_ZERO_SECOND       32

/* Maximum repetitions for "type C" repetition of anything */
/* (min...min_REP_SAME_FIRST) */
#define TREE_ENC_REP_SAME_FIRST         2

/* Bits required to output the above numbers */
#define TREE_ENC_REPZ_FIRST_EXTRA_BITS  4
#define TREE_ENC_REPZ_SECOND_EXTRA_BITS 5
#define TREE_ENC_REP_SAME_EXTRA_BITS    1

/* Number of cfdata frames before E8's are turned off automatically */
#define E8_CFDATA_FRAME_THRESHOLD       32768


/*
 * Block types 
 */
typedef enum
{
		BLOCKTYPE_INVALID       = 0,
		BLOCKTYPE_VERBATIM      = 1, /* normal block */
		BLOCKTYPE_ALIGNED       = 2, /* aligned offset block */
		BLOCKTYPE_UNCOMPRESSED  = 3  /* uncompressed block */
} lzx_block_type;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\d16verb.c ===
/*
 * d16verb.c
 *
 * Decoding verbatim-bit blocks
 */
#include "decoder.h"


int NEAR decode_verbatim_block(
    t_decoder_context * context,
    long                BufPos,
    int                 amount_to_decode /* yes, it will equal 32768 */
)
{
	ulong	match_pos;
	ulong	dec_bitbuf;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
	int		match_length;
	int		c;
	char	dec_bitcount;
	char	m;
    MATCH   match_info;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;

    /*
     * amount_to_decode must never be > 32768
     *
     * As it stands, we do the (amount_to_decode >= 0) check
     * at the bottom of the DO loop, rather than at the top of
     * a WHILE loop, so that we can used a signed int; this way,
     * we decrement it by at least 1 by the time we check against
     * zero.
     */

    do
	{
		/* decode an item from the main tree */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
	 		/*	it's a character */
			/* note: c - 256 == c if c is a byte */
            context->DComp_Token_Literal(context, (int) ((byte) c));
            amount_to_decode--;
		}
		else
		{
	 		/* get match length header */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				/* get match length footer if necessary */
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

			/* get match position slot */
			m = c >> NL_SHIFT;

	  		/* read any extra bits for the match position */
			if (m > 2) 
			{
				if (m > 3) /* dec_extra_bits[m] != 0 */
				{
	    			GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
					match_pos += MP_POS_minus2[m];
				}
				else
				{
					match_pos = MP_POS_minus2[3];
				}

				/*
				 * Add match base to "extra bits".  Our match base
				 * table has 2 subtracted from all the elements.
				 *
				 * This is because encoded positions 0,1,2 denote
				 * repeated offsets.  Encoded position 3 denotes
				 * a match 1 character away, 4 encodes 2 away, etc.  
				 * Hence the subtraction of 2, which has been
				 * incorporated into the table.
				 */

				/* update LRU repeated offset list */
				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				/* positions 0, 1, 2 denote repeated offsets */
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			/* match lengths range from 2...257 */
			match_length += MIN_MATCH; 

            match_info.Len = match_length;
            match_info.Dist = match_pos;
            context->DComp_Token_Match(context, match_info);

            amount_to_decode -= match_length;
		}
    } while (amount_to_decode > 0);

    context->dec_bitcount = dec_bitcount;
    context->dec_bitbuf   = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\d16align.c ===
/*
 * d16align.c
 *
 * Decoding aligned offset block
 */
#include "decoder.h"


int NEAR decode_aligned_offset_block(
    t_decoder_context * context,
    long                bufpos,
    int                 amount_to_decode /* yes, it will equal 32768 */
)
{
	ulong	match_pos;
	ulong	temp_pos;
	ulong	dec_bitbuf;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
    MATCH   match_info;
	int		match_length;
	int		c;
	char	m;
	char	dec_bitcount;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;

    /*
     * see comment in d16verb.c about why this is a DO loop,
     * and why we allow a signed int to hold the value 32768.
     */
    do
	{
		/*
		 * Decode an item
		 */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
            context->DComp_Token_Literal(context, (byte) c);
            amount_to_decode--;
		}
		else
		{
	 		/*
	  		 * Get match length slot
	  		 */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

	 		/*
	  		 * Get match position slot
	  		 */
			m = c >> NL_SHIFT;

			if (m > 2)
			{
				if (dec_extra_bits[ m ] >= 3)
				{
					if (dec_extra_bits[m]-3)
					{
						/* no need to getbits17 */
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
					}
					else
					{
						temp_pos = 0;
					}

	    			match_pos = MP_POS_minus2[m] + (temp_pos << 3);

	    			DECODE_ALIGNED_NOEOFCHECK(temp_pos);
	    			match_pos += temp_pos;
				}
				else
				{
					if (dec_extra_bits[m])
					{
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

						match_pos += MP_POS_minus2[m];
					}
					else
					{
						match_pos = MP_POS_minus2[m];
					}
				}

				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

            match_length += MIN_MATCH;

            match_info.Len = match_length;
            match_info.Dist = match_pos;
            context->DComp_Token_Match(context, match_info);

            amount_to_decode -= match_length;
		}
    } while (amount_to_decode > 0);

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decalign.c ===
/*
 * decalign.c
 *
 * Decoding aligned offset block
 */
#include "decoder.h"


static long special_decode_aligned_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
	ulong	match_pos;
	ulong	temp_pos;
	long	bufpos_end;
	int		match_length;
	int		c;
	ulong	dec_bitbuf;
	char	dec_bitcount;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
	byte   *dec_mem_window;
	char	m;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;
	dec_mem_window	  = context->dec_mem_window;

	bufpos_end = bufpos + amount_to_decode;

	while (bufpos < bufpos_end)
	{
		/*
		 * Decode an item
		 */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
			dec_mem_window[bufpos] = (byte) c;
			dec_mem_window[context->dec_window_size + bufpos] = (byte) c;
			bufpos++;
		}
		else
		{
	 		/*
	  		 * Get match length slot
	  		 */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

	 		/*
	  		 * Get match position slot
	  		 */
			m = c >> NL_SHIFT;

			if (m > 2)
			{
				if (dec_extra_bits[ m ] >= 3)
				{
					if (dec_extra_bits[m]-3)
					{
						/* no need to getbits17 */
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
					}
					else
					{
						temp_pos = 0;
					}

	    			match_pos = MP_POS_minus2[m] + (temp_pos << 3);

	    			DECODE_ALIGNED_NOEOFCHECK(temp_pos);
	    			match_pos += temp_pos;
				}
				else
				{
					if (dec_extra_bits[m])
					{
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

						match_pos += MP_POS_minus2[m];
					}
					else
					{
                        match_pos = 1; // MP_POS_minus2[m==3];
					}
				}

				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			match_length += MIN_MATCH;

			do
			{
                dec_mem_window[bufpos] = dec_mem_window[(bufpos-match_pos) & context->dec_window_mask];

				if (bufpos < MAX_MATCH)
					dec_mem_window[context->dec_window_size+bufpos] = dec_mem_window[bufpos];

				bufpos++;
			} while (--match_length > 0);
		}
	}

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

    return bufpos;
}


#ifndef ASM_DECODE_ALIGNED_OFFSET_BLOCK
long fast_decode_aligned_offset_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
	ulong	match_pos;
	ulong	temp_pos;
	long	bufpos_end;
	long	decode_residue;
	int		match_length;
	int		c;
	ulong	dec_bitbuf;
	char	dec_bitcount;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
	byte   *dec_mem_window;
	ulong	match_ptr;
	char	m;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;
	dec_mem_window	  = context->dec_mem_window;

	bufpos_end = bufpos + amount_to_decode;

	while (bufpos < bufpos_end)
	{
		/*
		 * Decode an item
		 */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
			dec_mem_window[bufpos++] = (byte) c;
		}
		else
		{
	 		/*
	  		 * Get match length slot
	  		 */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

	 		/*
	  		 * Get match position slot
	  		 */
			m = c >> NL_SHIFT;

			if (m > 2)
			{
				if (dec_extra_bits[ m ] >= 3)
				{
					if (dec_extra_bits[m]-3)
					{
						/* no need to getbits17 */
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
					}
					else
					{
						temp_pos = 0;
					}

	    			match_pos = MP_POS_minus2[m] + (temp_pos << 3);

	    			DECODE_ALIGNED_NOEOFCHECK(temp_pos);
	    			match_pos += temp_pos;
				}
				else
				{
					if (dec_extra_bits[m])
					{
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

						match_pos += MP_POS_minus2[m];
					}
					else
					{
						match_pos = MP_POS_minus2[m];
					}
				}

				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			match_length += MIN_MATCH;
			match_ptr = (bufpos - match_pos) & context->dec_window_mask;

			do
			{
				dec_mem_window[bufpos++] = dec_mem_window[match_ptr++];
			} while (--match_length > 0);
		}
	}

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

	/* should be zero */
	decode_residue = bufpos - bufpos_end;

    bufpos &= context->dec_window_mask;
	context->dec_bufpos = bufpos;

	return decode_residue;
}
#endif


int decode_aligned_offset_block(
    t_decoder_context * context, 
    long                BufPos, 
    int                 amount_to_decode
)
{
    /*
     * Special case code when BufPos is near the beginning of the window;
     * we must properly update our MAX_MATCH wrapper bytes.
     */
    if (BufPos < MAX_MATCH)
    {
        long    new_bufpos;
        long    amount_to_slowly_decode;

        amount_to_slowly_decode = (((MAX_MATCH-BufPos) < (amount_to_decode)) ? (MAX_MATCH-BufPos) : (amount_to_decode));

        /*
         * It's ok to end up decoding more than we wanted if we
         * restricted it to decoding only MAX_MATCH; there's
         * no guarantee a match doesn't straddle MAX_MATCH
         */
        new_bufpos = special_decode_aligned_block(
            context,
            BufPos,
            amount_to_slowly_decode
        );

        amount_to_decode -= (new_bufpos-BufPos);

        context->dec_bufpos = BufPos = new_bufpos;

        /*
         * Note: if amount_to_decode < 0 then we're in trouble
         */
        if (amount_to_decode <= 0)
            return amount_to_decode;
    }

    return fast_decode_aligned_offset_block(context, BufPos, amount_to_decode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decapi.h ===
/*
 * decapi.h
 * 
 * Decoder API definitions
 */

bool LZX_DecodeInit(
	t_decoder_context *context,
	long		compression_window_size,
	PFNALLOC	pfnma,
    PFNFREE     pfnmf,
    PFNOPEN     pfnopen,
    PFNREAD     pfnread,
    PFNWRITE    pfnwrite,
    PFNCLOSE    pfnclose,
    PFNSEEK     pfnseek
);

void LZX_DecodeFree(t_decoder_context *context);

void LZX_DecodeNewGroup(t_decoder_context *context);

int LZX_Decode(
	t_decoder_context *context,
	long	bytes_to_decode,
	byte *	compressed_input_buffer,
	long	compressed_input_size,
	byte *	uncompressed_output_buffer,
	long	uncompressed_output_size,
	long *	bytes_decoded
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decin.c ===
/*
 * decin.c
 *
 * Decoder inputting of compressed data
 */
#include "decoder.h"


/*
 * Initialises the bit buffer state
 */
void NEAR initialise_decoder_bitbuf(t_decoder_context *context)
{
	byte *p;

    /*
     * If we're decoding an uncompressed block, don't use the
     * bit buffer; we're reading directly out of the input.
     */
    if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
        return;

    p = context->dec_input_curpos;

	context->dec_bitbuf =
        ((ulong) p[2] | (((ulong) p[3]) << 8)) |
        ((((ulong) p[0] | (((ulong) p[1]) << 8))) << 16);

	context->dec_bitcount = 16;
    context->dec_input_curpos += 4;
}


/*
 * Initialise input buffer and bitwise i/o
 */
void NEAR init_decoder_input(t_decoder_context *context)
{
   initialise_decoder_bitbuf(context);
}


void NEAR fillbuf(t_decoder_context *context, int n)
{
	context->dec_bitbuf <<= n;            					
	context->dec_bitcount -= (char) n; 
	
	if (context->dec_bitcount <= 0)      					
	{                                 				
		if (context->dec_input_curpos >= context->dec_end_input_pos)	
        {
            context->dec_error_condition = true;
            return;
        }

        context->dec_bitbuf |= ((((ulong) *context->dec_input_curpos | (((ulong) *(context->dec_input_curpos+1)) << 8))) << (-context->dec_bitcount));
        context->dec_input_curpos += 2;
        context->dec_bitcount += 16;

		if (context->dec_bitcount <= 0)							
		{                                 				
            if (context->dec_input_curpos >= context->dec_end_input_pos) 
            {
                context->dec_error_condition = true;
                return;
            }

            context->dec_bitbuf |= ((((ulong) *context->dec_input_curpos | (((ulong) *(context->dec_input_curpos+1)) << 8))) << (-context->dec_bitcount));
            context->dec_input_curpos += 2;
			context->dec_bitcount += 16;               			
		}												
   }                                    				
}


ulong NEAR getbits(t_decoder_context *context, int n)
{
	ulong value;

	value = context->dec_bitbuf >> (32-(n));			
	fillbuf(context, n);

	return value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decdefs.h ===
/*
 * decdefs.h
 *
 * Structures and definitions used by the decoder
 */


typedef enum
{
	DEC_STATE_UNKNOWN,
	DEC_STATE_START_NEW_BLOCK,
	DEC_STATE_DECODING_DATA
} decoder_state;


/*
 * Size of uncompressed data chunks
 */
#define CHUNK_SIZE  32768


/*
 * Main tree decoding table parameters 
 */

/* # elements in main tree */
#define MAIN_TREE_ELEMENTS			(NUM_CHARS+(context->dec_num_position_slots<<NL_SHIFT))

/*
 * Decoding table size allows a direct lookup on the first 
 * MAIN_TREE_TABLE_BITS bits of the code (max len 16).
 * Any potential remaining bits are decoded using left/right.
 */
#define MAIN_TREE_TABLE_BITS		10 

/*
 * Secondary length tree decoding table parameters
 * Decoding table size allows a direct lookup on the first
 * SECONDARY_LEN_TREE_TABLE_BITS of the code (max len 16).
 * Any potential remaining bits are decoded using left/right.
 */
#define SECONDARY_LEN_TREE_TABLE_BITS	8 

/* 
 * Aligned offset tree decoding table parameters 
 */
#define ALIGNED_NUM_ELEMENTS	8

/*
 * Must be 7, since we do not use left/right for this tree;
 * everything is decoded in one lookup.
 */
#define ALIGNED_TABLE_BITS		7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decapi.c ===
/*
 * decapi.c
 *
 * API entry points.
 */

#define ALLOC_VARS
#include "decoder.h"
#include <stdio.h>


bool LZX_DecodeInit(
	t_decoder_context *	context,
	long				compression_window_size,
	PFNALLOC			pfnma,
    PFNFREE             pfnmf,
    PFNOPEN             pfnopen,
    PFNREAD             pfnread,
    PFNWRITE            pfnwrite,
    PFNCLOSE            pfnclose,
    PFNSEEK             pfnseek
)
{
	context->dec_malloc	= pfnma;
	context->dec_free	= pfnmf;

    /* used for 16-bit swap file only */
    context->dec_open   = pfnopen;
    context->dec_read   = pfnread;
    context->dec_write  = pfnwrite;
    context->dec_close  = pfnclose;
    context->dec_seek   = pfnseek;

	context->dec_window_size = compression_window_size;
	context->dec_window_mask = context->dec_window_size - 1;

	/*
	 * Window size must be a power of 2
	 */
	if (context->dec_window_size & context->dec_window_mask)
		return false;

	if (allocate_decompression_memory(context) == false)
		return false;

	LZX_DecodeNewGroup(context);

	return true;
}


void LZX_DecodeFree(t_decoder_context *context)
{
	free_decompression_memory(context);
}


void LZX_DecodeNewGroup(t_decoder_context *context)
{
	reset_decoder_trees(context);
	decoder_misc_init(context);
	init_decoder_translation(context);
    context->dec_num_cfdata_frames = 0;

#ifdef BIT16
    DComp_Reset(context);
#endif
}


int LZX_Decode(
	t_decoder_context *context,
	long	bytes_to_decode,
	byte *	compressed_input_buffer,
	long	compressed_input_size,
	byte *	uncompressed_output_buffer,
	long	uncompressed_output_size,
	long *	bytes_decoded
)
{
    long    result;

    context->dec_input_curpos   = compressed_input_buffer;
    context->dec_end_input_pos  = (compressed_input_buffer + compressed_input_size + 4);

    context->dec_output_buffer  = uncompressed_output_buffer;

#ifdef BIT16
    context->dec_output_curpos  = uncompressed_output_buffer;
    context->DComp.NumBytes = (unsigned short) uncompressed_output_size;
#endif

	init_decoder_input(context);

    result = decode_data(context, bytes_to_decode);

    context->dec_num_cfdata_frames++;

    if (result < 0)
    {
        *bytes_decoded = 0;
        return 1; /* failure */
    }
    else
    {
        *bytes_decoded = result;
        context->dec_position_at_start += result;
        return 0; /* success */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decmacro.h ===
/*
 * decmacro.h
 *
 * Macros used by the decoder
 */


/*
 * decode an element from the aligned offset tree, without checking 
 * for the end of the input data
 */
#define DECODE_ALIGNED_NOEOFCHECK(j) \
	(j) = context->dec_aligned_table[dec_bitbuf >> (32-ALIGNED_TABLE_BITS)]; \
	FILL_BUF_NOEOFCHECK(context->dec_aligned_len[(j)]);


/*
 * Decode an element from the main tree
 * Check for EOF
 */
#define DECODE_MAIN_TREE(j) \
	j = context->dec_main_tree_table[dec_bitbuf >> (32-MAIN_TREE_TABLE_BITS)];	\
	if (j < 0)															\
	{																	\
        ulong mask = (1L << (32-1-MAIN_TREE_TABLE_BITS));               \
		do																\
		{																\
	 		j = -j;														\
	 		if (dec_bitbuf & mask)										\
                j = context->dec_main_tree_left_right[j*2+1];                   \
			else														\
                j = context->dec_main_tree_left_right[j*2];                     \
			mask >>= 1;													\
		} while (j < 0);												\
	}																	\
	FILL_BUF_FULLCHECK(context->dec_main_tree_len[j]);


/*
 * Decode an element from the secondary length tree
 * No checking for EOF
 */
#define DECODE_LEN_TREE_NOEOFCHECK(matchlen) \
    matchlen = context->dec_secondary_length_tree_table[dec_bitbuf >> (32-SECONDARY_LEN_TREE_TABLE_BITS)]; \
	if (matchlen < 0)                                                	\
	{                                                                	\
        ulong mask = (1L << (32-1-SECONDARY_LEN_TREE_TABLE_BITS));      \
		do                                                          	\
		{																\
	 		matchlen = -matchlen;                                      	\
	 		if (dec_bitbuf & mask)                                  	\
                matchlen = context->dec_secondary_length_tree_left_right[matchlen*2+1];\
			else                                                        \
                matchlen = context->dec_secondary_length_tree_left_right[matchlen*2];  \
			mask >>= 1;                                                 \
		} while (matchlen < 0);											\
	}																	\
    FILL_BUF_NOEOFCHECK(context->dec_secondary_length_tree_len[matchlen]);      \
	matchlen += NUM_PRIMARY_LENGTHS;


/*
 * read n bits from input stream into dest_var, but don't
 * check for EOF
 */
#define GET_BITS_NOEOFCHECK(N,DEST_VAR) \
{                                               \
   DEST_VAR = dec_bitbuf >> (32-(N));			\
   FILL_BUF_NOEOFCHECK((N));					\
}


/* same as above, but don't check for EOF */
#define GET_BITS17_NOEOFCHECK(N,DEST_VAR) \
{                                               \
   DEST_VAR = dec_bitbuf >> (32-(N));			\
   FILL_BUF17_NOEOFCHECK((N));					\
}


/*
 * Remove n bits from the input stream
 * handles 1 <= n <= 17
 *
 * FORCE an EOF check ALWAYS, whether or not we read in more
 * bytes from memory.
 *
 * This is used to ensure that we always get an EOF check often enough
 * to not overrun the extra bytes in the buffer.
 *
 * This routine is used ONLY when decoding the main tree element,
 * where we know that the code we read in will be 16 bits or less
 * in length.  Therefore we don't have to check for bitcount going
 * less than zero, twice.
 */
#define FILL_BUF_FULLCHECK(N) \
{                                    		\
	if (dec_input_curpos >= dec_end_input_pos)	\
        return -1; \
	dec_bitbuf <<= (N);            			\
	dec_bitcount -= (N);                    \
	if (dec_bitcount <= 0)      			\
	{                                 		\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2;              \
		dec_bitcount += 16;               	\
    }                                       \
}

/*
 * Same as above, but no EOF check 
 *
 * This is used when we know we will not run out of input
 */
#define FILL_BUF_NOEOFCHECK(N) 			\
{                                    	\
	dec_bitbuf <<= (N);            		\
	dec_bitcount -= (N);                \
	if (dec_bitcount <= 0)      		\
	{                                 	\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2; \
		dec_bitcount += 16;				\
	}                                   \
}

/*
 * Same as above, but handles n=17 bits
 */
#define FILL_BUF17_NOEOFCHECK(N)        \
{                                    	\
	dec_bitbuf <<= (N);            		\
	dec_bitcount -= (N);                \
	if (dec_bitcount <= 0)      		\
	{                                 	\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2; \
		dec_bitcount += 16;				\
		if (dec_bitcount <= 0) \
		{ \
            dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
            dec_input_curpos += 2; \
			dec_bitcount += 16;         \
		} \
	}                                   \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decblk.c ===
/*
 * decblk.c
 *
 * main decoder module
 */
#include "decoder.h"


/* local function prototypes */
static int decode_block(
	t_decoder_context	*context, 
	lzx_block_type		block_type, 
	long				bufpos, 
    long                amount_to_decode
);


/*
 * Decode a block type
 */
static int decode_block(
	t_decoder_context	*context, 
	lzx_block_type		block_type, 
	long				bufpos, 
    long                amount_to_decode
)
{
    int result;

	if (block_type == BLOCKTYPE_ALIGNED)
        result = decode_aligned_offset_block(context, bufpos, (int) amount_to_decode);
	else if (block_type == BLOCKTYPE_VERBATIM)
        result = decode_verbatim_block(context, bufpos, (int) amount_to_decode);
	else if (block_type == BLOCKTYPE_UNCOMPRESSED)
        result = decode_uncompressed_block(context, bufpos, (int) amount_to_decode);
	else /* no other block types exist */
		result = -1;

	return result;
}



/*
 * Main decode entrypoint
 */
long NEAR decode_data(t_decoder_context *context, long bytes_to_decode)
{
	ulong			amount_can_decode;
	long			total_decoded;

	total_decoded = 0;

	while (bytes_to_decode > 0)          
	{
		if (context->dec_decoder_state == DEC_STATE_START_NEW_BLOCK)
		{
			ulong	temp1;                                                                                           
			ulong	temp2;
			ulong	temp3;
			bool	do_translation;

			/*
			 * If this is the first time this group, then get the
			 * file size for translation.
			 */
			if (context->dec_first_time_this_group)
			{
				context->dec_first_time_this_group = false;

                do_translation = (bool) getbits(context, 1);

				if (do_translation)
				{
					ulong high, low;

					high = getbits(context, 16);
					low  = getbits(context, 16);
					context->dec_current_file_size = (high<<16)|low;
				}
				else
				{
					context->dec_current_file_size = 0;
				}
			}

            /*
             * If the last block we decoded was uncompressed, then
             * we need to skip the pad byte (if it exists), and
             * initialise the decoder's bit buffer
             */
            if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
            {
                /*
                 * If block size was odd, a pad byte is required
                 */
                if (context->dec_original_block_size & 1)
                {
                    if (context->dec_input_curpos < context->dec_end_input_pos)
                        context->dec_input_curpos++;
                }

                /* so that initialise_decoder_bitbuf() will succeed */
                context->dec_block_type = BLOCKTYPE_INVALID;

                initialise_decoder_bitbuf(context);
            }

			/* get the block type */
            context->dec_block_type = (lzx_block_type) getbits(context, 3);

			/* get size of block (in uncompressed bytes) to decode */
			temp1 = getbits(context, 8);
			temp2 = getbits(context, 8);
			temp3 = getbits(context, 8);

			/*
			 * How large is the block we're going to decode?
			 * It can be from 0...16777215 bytes (16MB)
			 */
            context->dec_block_size =
            context->dec_original_block_size = (temp1<<16) + (temp2<<8) + (temp3);

			/* if block is an aligned type, read the aligned offset tree */
			if (context->dec_block_type == BLOCKTYPE_ALIGNED)
				read_aligned_offset_tree(context);

			/* read trees */
			if (context->dec_block_type == BLOCKTYPE_VERBATIM || 
      			context->dec_block_type == BLOCKTYPE_ALIGNED)
			{
	 			/*	backup old trees */
	 			memcpy(
                    context->dec_main_tree_prev_len, 
                    context->dec_main_tree_len, 
	 				MAIN_TREE_ELEMENTS
	 			);

	 			memcpy(
                    context->dec_secondary_length_tree_prev_len,
                    context->dec_secondary_length_tree_len,
	 				NUM_SECONDARY_LENGTHS
	 			);

				read_main_and_secondary_trees(context);
			}
			else if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
			{
                if (handle_beginning_of_uncompressed_block(context) == false)
                    return -1;
			}
			else 
			{
				/* no other block types are supported at this time */
                return -1;
			}

			context->dec_decoder_state = DEC_STATE_DECODING_DATA;
		}

		/*
		 * Keep decoding until the whole block has been decoded
		 */
		while ((context->dec_block_size > 0) && (bytes_to_decode > 0))
		{
            int decode_residue;

			amount_can_decode = (((context->dec_block_size) < (bytes_to_decode)) ? (context->dec_block_size) : (bytes_to_decode));
		
	 		/* shouldn't happen */
	 		if (amount_can_decode == 0)
                return -1;

 			decode_residue = decode_block(
				context, 
				context->dec_block_type, 
				context->dec_bufpos, 
				amount_can_decode
			);

	 		/*
	 		 * We should have decoded exactly the amount we wanted,
			 * since the encoder makes sure that no matches span 32K
			 * boundaries.
			 *
	 		 * If the data was corrupted, it's possible that we decoded
			 * up to MAX_MATCH bytes more than we wanted to.
  			 */
	 		if (decode_residue != 0)
	    	{
				/* error, we didn't decode what we wanted! */
                return -1;
			}

	 		context->dec_block_size -= amount_can_decode;
			bytes_to_decode -= amount_can_decode;
			total_decoded += amount_can_decode;
		}

		if (context->dec_block_size == 0)
		{
			context->dec_decoder_state = DEC_STATE_START_NEW_BLOCK;
		}

		if (bytes_to_decode == 0)
		{
			initialise_decoder_bitbuf(context);
		}
	}

#ifdef BIT16
    copy_data_to_output(
        context,
        total_decoded,
        context->dec_output_buffer
    );
#else
    copy_data_to_output(
		context,
		total_decoded, 
		context->dec_bufpos ? 
			&context->dec_mem_window[context->dec_bufpos - total_decoded] : 
			&context->dec_mem_window[context->dec_window_size - total_decoded]
	);
#endif

    return total_decoded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decinit.c ===
/*
 * decinit.c
 *
 * Initialisation routines for LZX decoder
 */

#include "decoder.h"


/* 
 * Allocate memory for decompression 
 */
bool NEAR allocate_decompression_memory(t_decoder_context *context)
{
	ulong	pos_start;

	context->dec_num_position_slots	= 4;
	pos_start						= 4;

	while (1)
	{
        pos_start += 1L << dec_extra_bits[context->dec_num_position_slots];

		context->dec_num_position_slots++;

		if (pos_start >= context->dec_window_size)
			break;
	}

#ifdef BIT16
    if (DComp_Init(context))
        return false;
#else
	if (!(context->dec_mem_window = (byte *) context->dec_malloc(context->dec_window_size+(MAX_MATCH+4))))
		return false;
#endif

	return true; 
}


/*
 * Free decompression memory
 */
void NEAR free_decompression_memory(t_decoder_context *context)
{
#ifdef BIT16
    DComp_Close(context);
#else
	if (context->dec_mem_window)
	{
		context->dec_free(context->dec_mem_window);
		context->dec_mem_window = NULL;
	}
#endif
}


/*
 * Set/reset decoder trees to initial state
 */
void NEAR reset_decoder_trees(t_decoder_context *context)
{
	memset(context->dec_main_tree_len, 0, MAIN_TREE_ELEMENTS);
	memset(context->dec_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);

	memset(context->dec_secondary_length_tree_len, 0, NUM_SECONDARY_LENGTHS);
	memset(context->dec_secondary_length_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);
}


/*
 * Miscellaneous state initialisations
 */
void NEAR decoder_misc_init(t_decoder_context *context)
{
	context->dec_last_matchpos_offset[0]    	 = 1;
	context->dec_last_matchpos_offset[1]    	 = 1;
	context->dec_last_matchpos_offset[2]    	 = 1;

	context->dec_bufpos = 0;
    context->dec_position_at_start = 0;

	context->dec_decoder_state	= DEC_STATE_START_NEW_BLOCK;
	context->dec_block_size		= 0;

    /* so that initialise_decoder_bitbuf() will succeed */
    context->dec_block_type     = BLOCKTYPE_INVALID;

	context->dec_first_time_this_group	= true;
	context->dec_current_file_size		= 0;

    context->dec_error_condition = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decoder.h ===
/*
 * decoder.h
 *
 * Main decoder header file
 */

#ifndef DECODER_H
#define DECODER_H

#ifdef EXT
#	undef EXT
#endif

#ifdef ALLOC_VARS
#	define EXT
#else
#	define EXT extern
#endif

#ifdef USE_ASSEMBLY
#   define ASM_DECODE_VERBATIM_BLOCK
#   define ASM_TRANSLATE_E8
#   define ASM_MAKE_TABLE
#endif

#include <stdlib.h>
#include <string.h>
#include "../common/typedefs.h"
#include "../common/compdefs.h"  
#include "decmacro.h"
#include "decdefs.h"

#ifdef BIT16
#   include "ring16.h"
#endif

#include "decvars.h"
#include "decapi.h"
#include "decproto.h"

#endif /* DECODER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decout.c ===
/*
 * decout.c
 *
 * Decoder outputting
 */

#include "decoder.h"


void copy_data_to_output(t_decoder_context *context, long amount, const byte *data)
{
    if (context->dec_output_buffer == NULL)
        return;

    memcpy(
        context->dec_output_buffer,
        data,
        amount
    );

    /* perform jump translation */
    if ((context->dec_current_file_size != 0) && (context->dec_num_cfdata_frames < E8_CFDATA_FRAME_THRESHOLD))
    {
        decoder_translate_e8(
            context,
            context->dec_output_buffer,
            amount
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decproto.h ===
/* 
 * decproto.h
 *
 * Decoder function prototypes
 */

/* decblk.c */
long NEAR decode_data(t_decoder_context *context, long bytes_to_decode);

/* decin.c */
void NEAR initialise_decoder_bitbuf(t_decoder_context *context);
void NEAR init_decoder_input(t_decoder_context *context);
void NEAR fillbuf(t_decoder_context *context, int n);
ulong NEAR getbits(t_decoder_context *context, int n);

/* decinit.c */
bool NEAR allocate_decompression_memory(t_decoder_context *context); 
void NEAR free_decompression_memory(t_decoder_context *context);
void NEAR decoder_misc_init(t_decoder_context *context);
void NEAR reset_decoder_trees(t_decoder_context *context);

/* decout.c */
void NEAR copy_data_to_output(t_decoder_context *context, long amount, const byte *data);

/* dectree.c */
bool NEAR read_main_and_secondary_trees(t_decoder_context *context);
bool NEAR read_aligned_offset_tree(t_decoder_context *context);

/* maketbl.c */
bool NEAR make_table(
	t_decoder_context *context, 
	int			nchar,
	const byte	*bitlen,
	byte		tablebits,
	short		*table,
	short		*leftright
);

bool NEAR make_table_8bit(t_decoder_context *context, byte *bitlen, byte *table);
	
/* decxlat.c */
void NEAR init_decoder_translation(t_decoder_context *context);
void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes);

/* decalign.c */
int NEAR decode_aligned_offset_block(t_decoder_context *context, long bufpos, int amount_to_decode);

/* decverb.c */
int NEAR decode_verbatim_block(t_decoder_context *context, long bufpos, int amount_to_decode);

/* decuncmp.c */
int NEAR decode_uncompressed_block(t_decoder_context *context, long bufpos, int amount_to_decode);
bool NEAR handle_beginning_of_uncompressed_block(t_decoder_context *context);


/*
 * 16-bit stuff:
 */
#ifdef BIT16
void NEAR DComp_Close(t_decoder_context *context);
int  NEAR DComp_Init(t_decoder_context *context);
void NEAR DComp_Reset(t_decoder_context *context);
void NEAR DComp_Save_Output_Pages(t_decoder_context *context, uint bytes_decoded);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decverb.c ===
/*
 * decverb.c
 *
 * Decoding verbatim-bit blocks
 */
#include "decoder.h"


static long special_decode_verbatim_block(
    t_decoder_context   *context,
    long                BufPos,
    int                 amount_to_decode
)
{
	ulong	match_pos;
    long    bufpos_end;
	int		match_length;
	int		c;
	ulong	dec_bitbuf;
    byte    *dec_input_curpos;
    byte    *dec_end_input_pos;
	byte	*dec_mem_window;
	char	dec_bitcount;
	char	m;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;
	dec_mem_window	  = context->dec_mem_window;

    bufpos_end = BufPos + amount_to_decode;

    /*
     * We may overflow by up to MAX_MATCH
     */
    while (BufPos < bufpos_end)
	{
		/* decode an item from the main tree */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
	 		/*	it's a character */
			/* note: c - 256 == c if c is a byte */
            context->dec_mem_window[BufPos] = (byte) c;

            /* we know BufPos < bufpos_end here, so no need to check for overflow */
            context->dec_mem_window[context->dec_window_size+BufPos] = (byte) c;
            BufPos++;
		}
		else
		{
	 		/* get match length header */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				/* get match length footer if necessary */
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

			/* get match position slot */
			m = c >> NL_SHIFT;

	  		/* read any extra bits for the match position */
			if (m > 2) 
			{
				if (m > 3) /* dec_extra_bits[m] != 0 */
				{
	    			GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
					match_pos += MP_POS_minus2[m];
				}
				else
				{
                    match_pos = 1; // MP_POS_minus2[3];
				}

				/*
				 * Add match base to "extra bits".  Our match base
				 * table has 2 subtracted from all the elements.
				 *
				 * This is because encoded positions 0,1,2 denote
				 * repeated offsets.  Encoded position 3 denotes
				 * a match 1 character away, 4 encodes 2 away, etc.  
				 * Hence the subtraction of 2, which has been
				 * incorporated into the table.
				 */

				/* update LRU repeated offset list */
				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				/* positions 0, 1, 2 denote repeated offsets */
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			/* match lengths range from 2...257 */
			match_length += MIN_MATCH; 

			/* copy match data */
			do
			{
				context->dec_mem_window[BufPos] = context->dec_mem_window[(BufPos-match_pos) & context->dec_window_mask];

                /* replicate bytes */
                if (BufPos < MAX_MATCH)
                    context->dec_mem_window[context->dec_window_size+BufPos] = context->dec_mem_window[BufPos];

				BufPos++;
			} while (--match_length > 0);
		}
	}

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

    return BufPos;
}


#ifdef ASM_DECODE_VERBATIM_BLOCK

long fast_decode_verbatim_block(
    t_decoder_context   *context,
    long                BufPos,
    int                 amount_to_decode
);

#else /* !ASM_DECODE_VERBATIM_BLOCK */

long fast_decode_verbatim_block(t_decoder_context *context, long BufPos, int amount_to_decode)
{
	ulong	match_pos;
	ulong	match_ptr;
	long	bufpos_end;
	long	decode_residue;
	int		match_length;
	int		c;
	ulong	dec_bitbuf;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
	byte	*dec_mem_window;
	char	dec_bitcount;
	char	m;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;
	dec_mem_window	  = context->dec_mem_window;

	bufpos_end = BufPos + amount_to_decode;

	while (BufPos < bufpos_end)
	{
		/* decode an item from the main tree */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
	 		/*	it's a character */
			/* note: c - 256 == c if c is a byte */
			context->dec_mem_window[BufPos++] = (byte) c;
		}
		else
		{
	 		/* get match length header */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				/* get match length footer if necessary */
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

			/* get match position slot */
			m = c >> NL_SHIFT;

	  		/* read any extra bits for the match position */
			if (m > 2) 
			{
				if (m > 3) /* dec_extra_bits[m] != 0 */
				{
	    			GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
					match_pos += MP_POS_minus2[m];
				}
				else
				{
					match_pos = MP_POS_minus2[3];
				}

				/*
				 * Add match base to "extra bits".  Our match base
				 * table has 2 subtracted from all the elements.
				 *
				 * This is because encoded positions 0,1,2 denote
				 * repeated offsets.  Encoded position 3 denotes
				 * a match 1 character away, 4 encodes 2 away, etc.  
				 * Hence the subtraction of 2, which has been
				 * incorporated into the table.
				 */

				/* update LRU repeated offset list */
				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				/* positions 0, 1, 2 denote repeated offsets */
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			/* match lengths range from 2...257 */
			match_length += MIN_MATCH; 
			
            match_ptr = (BufPos - match_pos) & context->dec_window_mask;

			/* copy match data */
			do
			{
                context->dec_mem_window[BufPos++] = context->dec_mem_window[match_ptr++];
			} while (--match_length > 0);
		}
	}

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

	/* should be zero */
	decode_residue = BufPos - bufpos_end;

	BufPos &= context->dec_window_mask;
	context->dec_bufpos = BufPos;

	return decode_residue;
}
#endif /* ASM_DECODE_VERBATIM_BLOCK */


int decode_verbatim_block(t_decoder_context *context, long BufPos, int amount_to_decode)
{
    /*
     * Special case code when BufPos is near the beginning of the window;
     * we must properly update our MAX_MATCH wrapper bytes.
     */
    if (BufPos < MAX_MATCH)
    {
        long    new_bufpos;
        long    amount_to_slowly_decode;

        amount_to_slowly_decode = (((MAX_MATCH-BufPos) < (amount_to_decode)) ? (MAX_MATCH-BufPos) : (amount_to_decode));

        /*
         * It's ok to end up decoding more than we wanted if we
         * restricted it to decoding only MAX_MATCH; there's
         * no guarantee a match doesn't straddle MAX_MATCH
         */
        new_bufpos = special_decode_verbatim_block(
            context,
            BufPos,
            amount_to_slowly_decode
        );

        amount_to_decode -= (new_bufpos-BufPos);

        context->dec_bufpos = BufPos = new_bufpos;

        /*
         * Note: if amount_to_decode < 0 then we're in trouble
         */
        if (amount_to_decode <= 0)
            return amount_to_decode;
    }

    return fast_decode_verbatim_block(context, BufPos, amount_to_decode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decvars.h ===
/*
 * decvars.h
 *
 * Variables for the decoder
 */

/*
 * MAX_MAIN_TREE_ELEMENTS should be >= 256 + 8*num_position_slots
 * (that comes out to 256 + 8*51 right now, for a 2 MB window).
 *
 * Make divisible by 4 so things are longword aligned.
 */
#define MAX_MAIN_TREE_ELEMENTS 672

typedef struct
{
    /* 16-bit version does not have one big window pointer */
#ifndef BIT16
	/* pointer to beginning of window buffer */
	byte        		*dec_mem_window;
#endif

	/* window/decoding buffer parameters */
	ulong               dec_window_size;
	ulong				dec_window_mask;

	/* previous match offsets */
    ulong               dec_last_matchpos_offset[NUM_REPEATED_OFFSETS];

	/* main tree table */
	short				dec_main_tree_table[1 << MAIN_TREE_TABLE_BITS];

	/* secondary length tree table */
	short               dec_secondary_length_tree_table[1 << SECONDARY_LEN_TREE_TABLE_BITS];

	/* main tree bit lengths */
	byte				dec_main_tree_len[MAX_MAIN_TREE_ELEMENTS];

	/* secondary tree bit lengths */
	byte                dec_secondary_length_tree_len[NUM_SECONDARY_LENGTHS];
	byte				pad1[3]; /* NUM_SECONDARY_LENGTHS == 249 */

	/* aligned offset table */
	char				dec_aligned_table[1 << ALIGNED_TABLE_BITS];
	byte				dec_aligned_len[ALIGNED_NUM_ELEMENTS];

	/* left/right pointers for main tree (2*n shorts left, 2*n shorts for right) */
    short               dec_main_tree_left_right[MAX_MAIN_TREE_ELEMENTS*4];

	/* left/right pointers for secondary length tree */
    short               dec_secondary_length_tree_left_right[NUM_SECONDARY_LENGTHS*4];

	/* input (compressed) data pointers */
    byte *              dec_input_curpos;
    byte *              dec_end_input_pos;

    /* output (uncompressed) data pointer */
    byte *              dec_output_buffer;

    /* position in data stream at start of this decode call */
    long                dec_position_at_start;

	/* previous lengths */
	byte				dec_main_tree_prev_len[MAX_MAIN_TREE_ELEMENTS];
	byte				dec_secondary_length_tree_prev_len[NUM_SECONDARY_LENGTHS];

	/* bitwise i/o */
	ulong               dec_bitbuf;
	signed char 		dec_bitcount;

	/* number of distinct position (displacement) slots */
	byte                dec_num_position_slots;

	bool				dec_first_time_this_group;
    bool                dec_error_condition;

	/* misc */
	long          		dec_bufpos;
	ulong				dec_current_file_size;
	ulong				dec_instr_pos;
    ulong               dec_num_cfdata_frames;

    /* original size of current block being decoded (in uncompressed bytes) */
    long                dec_original_block_size;

    /* remaining size of current block being decoded (in uncompressed bytes) */
	long				dec_block_size;

	/* type of current block being decoded */
	lzx_block_type		dec_block_type;

	/* current state of decoder */
	decoder_state		dec_decoder_state;

	/* memory allocation functions */
	PFNALLOC			dec_malloc;
	PFNFREE				dec_free;

    /* file i/o functions */
    PFNOPEN             dec_open;
    PFNREAD             dec_read;
    PFNWRITE            dec_write;
    PFNCLOSE            dec_close;
    PFNSEEK             dec_seek;

#ifdef BIT16
    byte *              dec_output_curpos;
    int                 dec_last_chance_page_to_use;
    int                 dec_pos_to_page[NUM_OUTPUT_BUFFER_PAGES];

    /*
     * Variables for big buffer
     */
    struct
    {
        BYTE HUGE *Buf;            /* history buffer: NULL -> using disk ring buffer */
        BYTE HUGE *BufEnd;         /* last byte in history buffer + 1 */
        BYTE HUGE *BufPos;         /* current position in output buffer */

        unsigned long  Cur;        /* current position in the history buffer */
        unsigned short NumBytes;   /* total number of bytes to decompress */
        int       fOutOverflow;    /* if too little space in output buffer */
        BYTE      WindowBits;      /* needed in DComp_Reset() */
        int       fRingFault;      /* if disk callbacks fail */
    } DComp;

    /*
     * Variables for ring buffer
     */
    struct
    {
        int       Handle;             /* ring file handle */
        PBUFFER   RingBuffer;         /* current output ring buffer */
        BYTE FAR *RingPointer;        /* current output pointer (into RingBuffer) */
        BYTE FAR *RingPointerLimit;   /* address of last byte of RingBuffer + 1 */
        int       RingPages;          /* how many pages there are total */
        PBUFFER   pNewest;            /* pointer to most recently used buffer */
        PBUFFER   pOldest;            /* pointer to least recently used buffer */
        PAGETABLEENTRY FAR *PageTable;    /* pointer to array of pointers */
    } Disk;

    void (NEAR *DComp_Token_Match)(void *context, MATCH Match);
    void (NEAR *DComp_Token_Literal)(void *context, int Chr);

#endif

} t_decoder_context;


/* declare arrays? */
#ifndef ALLOC_VARS

EXT const byte NEAR     dec_extra_bits[];
EXT const long NEAR     MP_POS_minus2[];

#else

const byte NEAR dec_extra_bits[] =
{
	0,0,0,0,1,1,2,2,
	3,3,4,4,5,5,6,6,
	7,7,8,8,9,9,10,10,
	11,11,12,12,13,13,14,14,
	15,15,16,16,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17                                        
};

/*
 * first (base) position covered by each slot
 * 2 subtracted for optimisation purposes (see decverb.c/decalign.c comments)
 */
const long NEAR MP_POS_minus2[sizeof(dec_extra_bits)] =   
{
    0-2,        1-2,        2-2,        3-2,        4-2,        6-2,        8-2,        12-2,
	16-2,       24-2,       32-2,       48-2,       64-2,       96-2,       128-2,      192-2,
	256-2,      384-2,      512-2,      768-2,      1024-2,     1536-2,     2048-2,     3072-2,
    4096-2,     6144-2,     8192-2,     12288-2,    16384-2,    24576-2,    32768-2,    49152-2,
	65536-2,    98304-2,    131072-2,   196608-2,   262144-2,   393216-2,   524288-2,   655360-2,
	786432-2,   917504-2,   1048576-2,  1179648-2,  1310720-2,  1441792-2,  1572864-2,  1703936-2, 
	1835008-2,  1966080-2,  2097152-2
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decxlat.c ===
/*
 * xlat.c
 *
 * Translate
 */
#include "decoder.h"


void NEAR init_decoder_translation(t_decoder_context *context)
{
	context->dec_instr_pos = 0;
}


#ifdef ASM_TRANSLATE_E8
ulong asm_decoder_translate_e8(ulong instr_pos, ulong file_size, byte *mem, long bytes);

void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes)
{
	/*
	 * We don't want the ASM code to have to worry about where in the
	 * context structure a particular element is
	 */
	context->dec_instr_pos = asm_decoder_translate_e8(
		context->dec_instr_pos, 
		context->dec_current_file_size,
		mem, 
		bytes
	);
}

#else /* !ASM_TRANSLATE_E8 */

void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes)
{
	ulong   end_instr_pos;
	byte    temp[6];
	byte    *mem_backup;

	if (bytes <= 6)
	{
		context->dec_instr_pos += bytes;
		return;
	}

	mem_backup = mem;

	/* backup these bytes */
	memcpy(temp, &mem[bytes-6], 6);

	/* overwrite them with 0xE8 */
	memset(&mem[bytes-6], 0xE8, 6);

	end_instr_pos = context->dec_instr_pos + bytes - 6;

	while (1)
	{
		unsigned long   absolute;
#if !defined(_X86_)
		unsigned long   offset;
#endif

		/*
		 * We are guaranteed to hit one of the 6 0xE8's we stuck at the
		 * end of the buffer, even if we ran into some corrupted data
		 * that resulted in our jumping over 5 bytes due to a translation
		 */
		while (*mem++ != 0xE8)
			context->dec_instr_pos++;

		if (context->dec_instr_pos >= end_instr_pos)
			break;

		/*
		 * There are 5 or more bytes in the buffer
		 * (i.e. E8 xx xx xx xx)
		 *
		 * We have a complete offset available to (potentially) translate
		 */

#if defined(_X86_)
		absolute = *(ulong *) mem;
#else
        absolute =  ( (ulong)mem[0])     | 
					(((ulong)mem[1])<<8) | 
                    (((ulong)mem[2])<<16)|  
					(((ulong)mem[3])<<24);
#endif

		if (absolute < context->dec_current_file_size)
		{
			/* absolute >= 0 && absolute < dec_current_file_size */

#if defined(_X86_)
			*(ulong *) mem = absolute - context->dec_instr_pos;
#else
			offset = absolute - context->dec_instr_pos;
			mem[0] = (byte) (offset & 255);
			mem[1] = (byte) ((offset >> 8) & 255);
			mem[2] = (byte) ((offset >> 16) & 255);
			mem[3] = (byte) ((offset >> 24) & 255);
#endif
		}
        else if ((ulong) (-(long) absolute) <= context->dec_instr_pos)
		{
            /* absolute >= -instr_pos && absolute < 0 */

#if defined(_X86_)
			*(ulong *) mem = absolute + context->dec_current_file_size;
#else
			offset = absolute + context->dec_current_file_size;
			mem[0] = (byte) (offset & 255);
			mem[1] = (byte) (offset >> 8) & 255;
			mem[2] = (byte) (offset >> 16) & 255;
			mem[3] = (byte) (offset >> 24) & 255;
#endif
		}

		mem += 4;
		context->dec_instr_pos += 5;
	}

	context->dec_instr_pos = end_instr_pos + 6;

	/* restore these bytes */
	memcpy(&mem_backup[bytes-6], temp, 6);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\dectree.c ===
/*
 * dectree.c
 *
 * Decoding the encoded tree structures
 *
 * To save much code size, the fillbuf()/getbits() calls have
 * been made into functions, rather than being inlined macros.
 * The macros actually take up a lot of space.  There is no
 * performance loss from doing so here.
 */
#include "decoder.h"

/* number of elements in pre-tree */
#define NUM_DECODE_SMALL	20

/* lookup table size */
#define DS_TABLE_BITS		8

/* macro to decode a pre-tree element */
#define DECODE_SMALL(item) \
{ \
	item = small_table[context->dec_bitbuf >> (32-DS_TABLE_BITS) ]; \
	if (item < 0)								\
	{											\
      mask = (1L << (32-1-DS_TABLE_BITS));      \
      do										\
      {											\
			item = -item;						\
            if (context->dec_bitbuf & mask)     \
				item = leftright_s[2*item+1];	\
			else								\
				item = leftright_s[2*item];		\
			mask >>= 1;							\
		} while (item < 0);						\
   }											\
   fillbuf(context, small_bitlen[item]);		\
}

/*
 * Reads a compressed tree structure
 */
static bool NEAR ReadRepTree(
	t_decoder_context	*context,
	int					num_elements,
	byte				*lastlen,
	byte				*len
)
{
	ulong	mask;
	int		i;
	int		consecutive;
	byte	small_bitlen[24];
	short	small_table[1 << DS_TABLE_BITS];
	short	leftright_s [2*(2 * 24 - 1)];
	short	Temp;

	/* Declare this inline to help compilers see the optimisation */
	static const byte Modulo17Lookup[] =
	{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
	};

	/* read pre-tree */
	for (i = 0; i < NUM_DECODE_SMALL; i++)
	{
		small_bitlen[i] = (byte) getbits(context, 4);
	}

    /* exceeded input buffer? */
    if (context->dec_error_condition)
        return false;

	/* make a table for this pre-tree */
	make_table(
		context,
		NUM_DECODE_SMALL, 
		small_bitlen, 
		DS_TABLE_BITS, 
		small_table, 
		leftright_s
	);

	for (i = 0; i < num_elements; i++)
	{
		DECODE_SMALL(Temp);

        /* exceeded input buffer? */
        if (context->dec_error_condition)
            return false;

		/* Repeat "TREE_ENC_REP_MIN...TREE_ENC_REP_MIN+(1<<TREE_ENC_REPZ_FIRST_EXTRA_BITS)-1" zeroes */
		if (Temp == 17)
		{
			/* code 17 means "a small number of repeated zeroes" */
			consecutive = (byte) getbits(context, TREE_ENC_REPZ_FIRST_EXTRA_BITS);
			consecutive += TREE_ENC_REP_MIN;

			/* boundary check */
			if (i + consecutive >= num_elements)
				consecutive = num_elements-i;

			while (consecutive-- > 0)
				len[i++] = 0;

			i--;
		}
		else if (Temp == 18)
		{
			/* code 18 means "a large number of repeated zeroes" */

			/* Repeat "TREE_ENC_REP_MIN+(1<<TREE_ENC_REPZ_FIRST_EXTRA_BITS)-1...<ditto>+(1<<TREE_ENC_REPZ_SECOND_EXTRA_BITS)-1" zeroes */
			consecutive = (byte) getbits(context, TREE_ENC_REPZ_SECOND_EXTRA_BITS);
			consecutive += (TREE_ENC_REP_MIN+TREE_ENC_REP_ZERO_FIRST);

			/* boundary check */
			if (i + consecutive >= num_elements)
				consecutive = num_elements-i;

			while (consecutive-- > 0)
				len[i++] = 0;

			i--;
		}
		else if (Temp == 19)
		{
			byte	value;

			/* code 19 means "a small number of repeated somethings" */
			/* Repeat "TREE_ENC_REP_MIN...TREE_ENC_REP_MIN+(1<<TREE_ENC_REP_SAME_EXTRA_BITS)-1" elements */
			consecutive = (byte) getbits(context, TREE_ENC_REP_SAME_EXTRA_BITS);
			consecutive += TREE_ENC_REP_MIN;

			/* boundary check */
			if (i + consecutive >= num_elements)
				consecutive = num_elements-i;

			/* get the element number to repeat */
			DECODE_SMALL(Temp);
			value = Modulo17Lookup[(lastlen[i] - Temp)+17];

			while (consecutive-- > 0)
				len[i++] = value;

			i--;
		}
		else
		{
			len[i] = Modulo17Lookup[(lastlen[i] - Temp)+17];
		}
	}

    /* exceeded input buffer? */
    if (context->dec_error_condition)
        return false;
    else
        return true;
}


bool NEAR read_main_and_secondary_trees(t_decoder_context *context)
{
	/* read first 256 elements (characters) of the main tree */
    if (false == ReadRepTree(
		context,
		256, 
        context->dec_main_tree_prev_len, 
        context->dec_main_tree_len))
    {
        return false;
    }

	/*
	 * read remaining elements (primary match lengths * positions)
	 * of the main tree
	 */
    if (false == ReadRepTree(
		context,
		context->dec_num_position_slots*NUM_LENGTHS, 
        &context->dec_main_tree_prev_len[256], 
        &context->dec_main_tree_len[256]))
    {
        return false;
    }

	/* create lookup table for the main tree */
    if (false == make_table(
		context,
		MAIN_TREE_ELEMENTS, 
        context->dec_main_tree_len, 
		MAIN_TREE_TABLE_BITS,
        context->dec_main_tree_table, 
        context->dec_main_tree_left_right))
    {
        return false;
    }

	/* read secondary length tree */
    if (false == ReadRepTree(
		context,
		NUM_SECONDARY_LENGTHS, 
        context->dec_secondary_length_tree_prev_len, 
        context->dec_secondary_length_tree_len))
    {
        return false;
    }

	/* create lookup table for the secondary length tree */
    if (false == make_table(
		context,
		NUM_SECONDARY_LENGTHS, 
        context->dec_secondary_length_tree_len, 
		SECONDARY_LEN_TREE_TABLE_BITS,
        context->dec_secondary_length_tree_table,
        context->dec_secondary_length_tree_left_right))
    {
        return false;
    }

    return true;
}


/* read 8 element aligned offset tree */
bool NEAR read_aligned_offset_tree(t_decoder_context *context)
{
	int		i;

	/* read bit lengths of the 8 codes */
	for (i = 0; i < 8; i++)
	{
        context->dec_aligned_len[i] = (byte) getbits(context, 3);
	}

    if (context->dec_error_condition)
        return false;

	/*
	 * Make table with no left/right, and byte Table[] instead of
	 * short Table[]
	 */
    if (false == make_table_8bit(
		context,
        context->dec_aligned_len, 
        (byte *) context->dec_aligned_table))
    {
        return false;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\decuncmp.c ===
/*
 * decuncmp.c
 *
 * Decoding uncompressed blocks
 */
#include "decoder.h"


int decode_uncompressed_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
	long	bytes_decoded = 0;
	long	bufpos_end;
	long	decode_residue;
    ulong   bufpos_start;
    ulong   end_copy_pos;
    byte *  p;

    bufpos_start = bufpos;
	bufpos_end = bufpos + amount_to_decode;

    p = context->dec_input_curpos;

	while (bufpos < bufpos_end)
	{
        if (p >= context->dec_end_input_pos)
            return -1; // input overflow

        context->dec_mem_window[bufpos++] = *p++;
	}

    context->dec_input_curpos = p;

    /*
     * Make sure the MAX_MATCH bytes starting at window[window_size]
     * are always the same as the first MAX_MATCH bytes starting at
     * window[0].  This is for our optimisation in decverb.c and
     * decalign.c which allows us to not have to & window_mask all the
     * time.
     */
    end_copy_pos = (((MAX_MATCH) < (bufpos_end)) ? (MAX_MATCH) : (bufpos_end));

    /*
     * Keep copying until we hit MAX_MATCH or the number of bytes
     * we decoded
     */
    while (bufpos_start < end_copy_pos)
    {
        context->dec_mem_window[bufpos_start + context->dec_window_size] =
            context->dec_mem_window[bufpos_start];
        bufpos_start++;
    }

	decode_residue = bufpos - bufpos_end;

	bufpos &= context->dec_window_mask;
	context->dec_bufpos = bufpos;

    return (int) decode_residue;
}


bool handle_beginning_of_uncompressed_block(t_decoder_context *context)
{
    int     i;

    /*
     * we want to read the 16 bits already in bitbuf, so backtrack
     * the input pointer by 2 bytes.
     */
    context->dec_input_curpos -= 2;

    if (context->dec_input_curpos+4 >= context->dec_end_input_pos)
        return false;

	/*
	 * update LRU repeated offset list
	 */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
    {
        context->dec_last_matchpos_offset[i] =
            ((ulong) *(  (byte *) context->dec_input_curpos)    )        |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 1) << 8)  |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 2) << 16) |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 3) << 24);

        context->dec_input_curpos += 4; /* increment by 4 bytes */
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\dv.asm ===
;
; DV.ASM
;
; jforbes
;
	TITLE   DV.ASM
   .386P

.model FLAT

_TEXT SEGMENT

INCLUDE offsets.i

EXTRN   _MP_POS_minus2:DWORD
EXTRN   _dec_extra_bits:BYTE

local_32_minus_extra_bits:
DB      32,32,32,32,31,31,30,30
DB      29,29,28,28,27,27,26,26
DB      25,25,24,24,23,23,22,22
DB      21,21,20,20,19,19,18,18
DB      17,17,16,16,15,15,15,15
DB      15,15,15,15,15,15,15,15
DB      15,15,15

PUBLIC  _fast_decode_verbatim_block

;
; NOTES:
;
; last_offset uses 12 bytes; 4 for each of the 3 repeated offsets
;

$bitbuf=0
$bufposend=4
$context=8
$mem_window=12
$last_offset=16
$bitcount=28
$stackvars=32

;
; fast_decode_verbatim_block(context, bufpos, amount_to_decode)
;
_fast_decode_verbatim_block PROC NEAR

; save registers
    push    edx              
    push    ecx
    push    ebx
    push    edi
    push    esi
    push    ebp


; load parameters and initialise
    mov     edx, [esp + 28]  ; context
    mov     edi, [esp + 32]  ; bufpos

    mov     eax, [esp + 36]  ; amount_to_decode
    mov     esi, [edx + OFF_INPUT_CURPOS] ; input data ptr

    add     eax, edi         ; eax := bufpos_end = bufpos + amt
    sub     esp, $stackvars  ; allocate stack space for variables


; store variables on stack
    mov     [esp + $context], edx       ; u
    mov     [esp + $bufposend], eax     ; v

    mov     ecx, [edx + OFF_MEM_WINDOW] ; u
    mov     eax, [edx + OFF_BITBUF]     ; v

    mov     [esp + $mem_window], ecx    ; u
    mov     [esp + $bitbuf], eax        ; v


; copy repeated offsets onto stack for quicker accessing (<128 byte offset)
    mov     ecx, [edx + OFF_LAST_MATCHPOS_OFFSET]     ; u
    mov     ebx, [edx + OFF_LAST_MATCHPOS_OFFSET + 4] ; v

    mov     eax, [edx + OFF_LAST_MATCHPOS_OFFSET + 8] ; u
    mov     [esp + $last_offset], ecx                 ; v

    mov     [esp + $last_offset + 4], ebx             ; u
    mov     [esp + $last_offset + 8], eax             ; v


; store other variables
    xor     ecx, ecx
    mov     cl, BYTE PTR [edx + OFF_BITCOUNT]
    mov     [esp + $bitcount], ecx

    mov     edx, ecx

; start
    jmp     SHORT loop_top

;
; end of init
;



;
; Decoder input overflow error!
;
$fillbuf1:

; restore stack and return -1
    add     esp, $stackvars

    pop     ebp
    pop     esi
    pop     edi
    pop     ebx
    pop     ecx
    pop     edx

    mov     eax, -1

    ret     0


;
; Handle codes > table bits in length, for main tree
;
main_tree_long_code:
    mov     eax, [esp + $bitbuf]                   ; u
    shl     eax, MAIN_TREE_TABLE_BITS  ; u

; negation loop
$L19975:
    neg     ebx              ; NP

    add     ebx, ebx         ; u
    add     eax, eax         ; v  test MSB of eax

; ADC takes 3 clocks, which allows it to overshadow the 0F prefix
; in the next instruction (saving 1 clock)
    adc     ebx, 0           ; u

; won't pair
    movsx   ebx, WORD PTR [ecx + OFF_MAIN_TREE_LEFTRIGHT + ebx*2]

    test    ebx, ebx         ; u
    jl      SHORT $L19975    ; v

    jmp     SHORT back_main_tree_long_code



;
; Handle codes > table bits in length, for secondary tree
;
secondary_tree_long_code:
    mov     ecx, [esp + $bitbuf]
    shl     ecx, SECONDARY_LEN_TREE_TABLE_BITS

$L19990:
    neg     ebp

    add     ebp, ebp
    add     ecx, ecx

    adc     ebp, 0

; won't pair
    movsx   ebp, WORD PTR [eax + OFF_SECONDARY_TREE_LEFTRIGHT + ebp*2]

    test    ebp, ebp
    jl      SHORT $L19990

    jmp     back_secondary_tree_long_code


;
; loop top
;
loop_top:

; DECODE_DDMTREE(c);

; ebx = table[ bitbuf >> (32-MAIN_TREE_TABLE_BITS) ]
    mov     ecx, [esp + $context]  ; u1
    mov     eax, [esp + $bitbuf]   ; v1

    shr     eax, 32-MAIN_TREE_TABLE_BITS            ; u1
    mov     ebp, DWORD PTR [ecx + OFF_INPUT_ENDPOS] ; v1


loop_top_after_char:
    movsx   ebx, WORD PTR [ecx + OFF_MAIN_TREE_TABLE + eax*2] ; NP

    test    ebx, ebx                  ; u
    jl      SHORT main_tree_long_code ; v


back_main_tree_long_code:

; check for end of input
    cmp     ebp, esi               ; u1
    jbe     SHORT $fillbuf1        ; v1

    mov     cl, [ebx + ecx + OFF_MAIN_TREE_LEN] ; u1  cl = len[x]
    xor     eax, eax               ; v1

    shl     DWORD PTR [esp + $bitbuf], cl ; NP  bitbuf <<= len

    sub     dl, cl                 ; u1  bitcount -= len
    jg      SHORT bitcount_gt_0    ; v1

; otherwise fill buffer
    mov     al, [esi]              ; u1
    mov     cl, dl                 ; v1

    mov     ah, [esi+1]            ; u1
    xor     cl, -1                 ; v1

    add     esi, 2                 ; u1
    inc     cl                     ; v1

    shl     eax, cl                ; NP

    or      eax, [esp + $bitbuf]   ; u1
    add     dl, 16                 ; v1

    mov     [esp + $bitbuf], eax   ; u1
    nop                            ; v1

bitcount_gt_0:

;
; is it a match or a character?
;
    sub     ebx, 256               ; u1
    jns     SHORT $L19985          ; v1


;
; it's a character
;
    mov     ebp, [esp + $mem_window]     ; u1  get mem_window ptr
    inc     edi                          ; v1  bufpos++

    mov     eax, [esp + $bitbuf]         ; u1  for next iteration
    mov     ecx, [esp + $context]        ; v1  for next iteration

    shr     eax, 32-MAIN_TREE_TABLE_BITS ; u1  for next iteration

    mov     [ebp + edi - 1], bl          ; u1  store current character
    mov     ebp, DWORD PTR [ecx + OFF_INPUT_ENDPOS] ; v1 for next iteration

    cmp     [esp + $bufposend], edi      ; u1
    ja      SHORT loop_top_after_char    ; v1

    jmp     $cleanup


m_is_3:
    mov     ebx, 1 ; == _MP_POS_minus2[3*4]     
    jmp     skipover


m_not_zero:
    cmp     bl, 3              ; u1
    je      SHORT m_is_3       ; v1 

    mov     eax, [esp + $last_offset]         ; u1  eax = t = last[0]
    mov     ecx, [esp + $last_offset + ebx*4] ; v1  ecx = last[m]

    mov     [esp + $last_offset], ecx         ; u1  last[0] = last[m]
    mov     [esp + $last_offset + ebx*4], eax ; v1  last[m] = t 

    mov     ebx, ecx           ; u
    jmp     $L20003            ; too far, won't pair


;
; m = 0, 1, 2, 3
;
m_is_0123:
    test    ebx, ebx           ; u1
    jnz     SHORT m_not_zero   ; v1

; m == 0
    mov     ebx, [esp + $last_offset] ; 
    jmp     $L20003                   ; NP



$L19985:
    mov     ebp, ebx               ; u
    mov     eax, [esp + $context]  ; v

    shr     ebx, 3                 ; u
    and     ebp, 7                 ; v

    cmp     ebp, 7                 ; u
    jne     SHORT $L19987          ; v

    mov     ecx, [esp + $bitbuf]                  ; u

    shr     ecx, 32-SECONDARY_LEN_TREE_TABLE_BITS ; u

    movsx   ebp, WORD PTR [eax + OFF_SECONDARY_TREE_TABLE + ecx*2] ; NP

    test    ebp, ebp                 ; u1
    jnge    secondary_tree_long_code ; v1

back_secondary_tree_long_code:

    mov     cl, BYTE PTR [eax + OFF_SECONDARY_TREE_LEN + ebp] ; u1
    add     ebp, 7                 ; v1

    shl     DWORD PTR [esp + $bitbuf], cl ; NP bitbuf <<= len

; if (bitcount > 0) we're ok, otherwise fill buffer
    sub     dl, cl                 ; u1  bitcount -= len
    jg      SHORT $L19987          ; v1

    xor     eax, eax               ; u1
    mov     cl, dl                 ; v1

; NEG does not pair, so we replace it with XOR CL,-1 ; INC CL
    mov     al, [esi]              ; u1
    xor     cl, -1                 ; v1

    mov     ah, [esi+1]            ; u1
    inc     cl                     ; v1

    shl     eax, cl                ; NP

    or      eax, [esp + $bitbuf]   ; u2
    add     dl, 16                 ; v1

    add     esi, 2                 ; u1
    mov     [esp + $bitbuf], eax   ; v1

$L19987:

; if m == 3 then extra_bits == 0, and shifts don't work
; with a count of zero
    xor     eax, eax               ; u1
    cmp     bl, 3                  ; v1

    mov     al, bl                 ; u1
    jle     SHORT m_is_0123        ; v1

    mov     cl, BYTE PTR local_32_minus_extra_bits [eax] ; u1
    mov     ebx, [esp + $bitbuf]                ; v1

    shr     ebx, cl                             ; NP

    add     ebx, _MP_POS_minus2[eax*4]          ; u2
    mov     cl, _dec_extra_bits [eax]           ; v1

    shl     DWORD PTR [esp + $bitbuf], cl       ; NP

; now we can trash eax (m)
    sub     dl, cl                 ; u1
    jg      SHORT preskipover      ; v1

; otherwise fill buffer

; no need to xor eax, eax since everything but the low order
; byte is already zero
    mov     al, [esi]                            ; u1
    mov     cl, dl                               ; v1

    mov     ah, [esi+1]                          ; u1
    xor     cl, -1                               ; v1

    add     esi, 2                               ; u1
    inc     cl                                   ; v1

    shl     eax, cl                              ; NP

    or      eax, [esp + $bitbuf]                 ; u2
    add     dl, 16                               ; v1

; remember that this can execute twice, if we grab 17 bits
    mov     [esp + $bitbuf], eax                 ; u1
    jg      SHORT preskipover                    ; v1

;
; Second iteration
;
    xor     eax, eax                             ; u1
    mov     cl, dl                               ; v1

    mov     al, [esi]                            ; u1
    xor     cl, -1                               ; v1

    mov     ah, [esi+1]                          ; u1
    inc     cl                                   ; v1

    shl     eax, cl                              ; NP

    or      eax, [esp + $bitbuf]                 ; u2
    add     dl, 16                               ; v1

    mov     [esp + $bitbuf], eax                 ; u1
    add     esi, 2                               ; v1

preskipover:
skipover:
    mov     eax, [esp + $last_offset]     ; u   EAX = R0
    mov     ecx, [esp + $last_offset + 4] ; v   ECX = R1

    mov     [esp + $last_offset + 4], eax            ; u   R1 := R0
    mov     [esp + $last_offset + 8], ecx            ; v   R2 := R1

    mov     [esp + $last_offset], ebx                ; u   R0 := matchpos

$L20003:

;
; eax = dec_mem_window
; ebx = matchpos
; edi = bufpos
; ebp = matchlen (ebp=0 means "ML2", ebp=1 means "ML3", ...)
;

    mov     ecx, edi                  ; u1  ecx = bufpos
    mov     eax, [esp + $context]     ; v1  eax = context ptr

    inc     edi                       ; u1  bufpos++ for first character
    sub     ecx, ebx                  ; v1  ecx := bufpos - matchpos

    and     ecx, [eax + OFF_WINDOW_MASK] ; u1  ecx &= window_mask
    mov     eax, [eax + OFF_MEM_WINDOW]  ; v1  eax = mem_window

    mov     bl, [eax + ecx]              ; u1  AGI  bl = window[src]
    inc     ecx                          ; v1  for next iteration

    mov     [eax + edi - 1], bl          ; u   store in window[dst]
    nop                                  ; v

;
; second and later characters...
;
; eax = mem_window                  edx = bitbuf
; ebx = BL used for character       esi = input_pos
; ecx = bufpos - matchpos
; ebp = matchlen count
; edi = bufpos
;
copy_loop:
    inc     edi                 ; u1
    mov     bl, [eax + ecx]     ; v1   bl = dec_window[(bp-mp)&mask]

    inc     ecx                 ; u1
    dec     ebp                 ; v1

    mov     [eax + edi - 1], bl ; u1   dec_window[bufpos] = bl
    jge     SHORT copy_loop     ; v1

    cmp     [esp + $bufposend], edi ; u1
    ja      loop_top                ; NP


; fall through

$cleanup:
    mov     ebx, DWORD PTR [esp + $context]
    xor     eax, eax

    cmp     edi, [esp + $bufposend]
    je      SHORT successful

    mov     eax, -1 ; failure

successful:
    and     edi, [ebx + OFF_WINDOW_MASK]

    mov     [ebx + OFF_BITCOUNT], dl
    mov     [ebx + OFF_BUFPOS], edi

    mov     [ebx + OFF_INPUT_CURPOS], esi
    mov     edi, [esp + $bitbuf]

; copy repeated offsets into context structure
    mov     ecx, [esp + $last_offset]
    mov     ebp, [esp + $last_offset + 4]

    mov     esi, [esp + $last_offset + 8]
    mov     [ebx + OFF_LAST_MATCHPOS_OFFSET], ecx

    mov     [ebx + OFF_LAST_MATCHPOS_OFFSET+4], ebp
    mov     [ebx + OFF_LAST_MATCHPOS_OFFSET+8], esi

    mov     [ebx + OFF_BITBUF], edi

; restore stack
    add     esp, $stackvars

    pop     ebp
    pop     esi
    pop     edi
    pop     ebx
    pop     ecx
    pop     edx

    ret     0


_fast_decode_verbatim_block ENDP
_TEXT ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\ldi.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1996
 *  All Rights Reserved.
 *
 *  LDI.C: LZX Decompression Interface
 *
 *  History:
 *      03-Jul-1996     jforbes     Initial version.
 */

/* --- preprocessor ------------------------------------------------------- */

#include <stdio.h>          /* for NULL */

#include "decoder.h"
#include "decapi.h"

#include "ldi.h"            /* types, prototype verification, error codes */

#define MAX_GROWTH    6144  /* see encoder.h */

typedef ULONG SIGNATURE;    /* structure signature */

struct LDI_CONTEXT          /* private structure */
{
    SIGNATURE   signature;      /* for validation */
    PFNALLOC    pfnAlloc;       /* where the alloc() is */
    PFNFREE     pfnFree;        /* where the free() is */
    PFNOPEN     pfnOpen;        /* open a file callback or NULL */
    PFNREAD     pfnRead;        /* read a file callback */
    PFNWRITE    pfnWrite;       /* write a file callback */
    PFNCLOSE    pfnClose;       /* close a file callback */
    PFNSEEK     pfnSeek;        /* seek in file callback */
    UINT        cbDataBlockMax; /* promised max data size */
    UINT        fCPUtype;       /* CPU we're running on, QDI_CPU_xxx */
	t_decoder_context	*decoder_context;
};

typedef struct LDI_CONTEXT FAR *PMDC_CONTEXT;     /* a pointer to one */


/*  MAKE_SIGNATURE - Construct a structure signature
 *
 *  Entry:
 *      a,b,c,d - four characters
 *
 *  Exit:
 *      Returns constructed SIGNATURE
 *
 *  Example:
 *      strct->signature = MAKE_SIGNATURE('b','e','n','s')
 */

#define MAKE_SIGNATURE(a,b,c,d) (a + (b<<8) + (c<<16) + (d<<24))
#define BAD_SIGNATURE   (0L)
#define LDI_SIGNATURE   MAKE_SIGNATURE('L','D','I','C')

/* --- LDI context structure ---------------------------------------------- */

#define PMDCfromHMD(h) ((PMDC_CONTEXT)(h))          /* handle to pointer */
#define HMDfromPMDC(p) ((LDI_CONTEXT_HANDLE)(p))    /* pointer to handle */

/* --- LDICreateDecompression() ------------------------------------------- */
#include <stdio.h>

int FAR DIAMONDAPI LDICreateDecompression(
        UINT FAR *      pcbDataBlockMax,    /* max uncompressed data block */
        void FAR *      pvConfiguration,    /* implementation-defined */
        PFNALLOC        pfnma,              /* Memory allocation function */
        PFNFREE         pfnmf,              /* Memory free function */
        UINT FAR *      pcbSrcBufferMin,    /* gets required input buffer */
        LDI_CONTEXT_HANDLE FAR * pmdhHandle,  /* gets newly-created handle */
        PFNOPEN         pfnopen,            /* open a file callback */
        PFNREAD         pfnread,            /* read a file callback */
        PFNWRITE        pfnwrite,           /* write a file callback */
        PFNCLOSE        pfnclose,           /* close a file callback */
        PFNSEEK         pfnseek)            /* seek in file callback */
{

    PMDC_CONTEXT context;                   /* new context */
    PFLZXDECOMPRESS pConfig;            /* to get configuration details */

    pConfig = pvConfiguration;       /* get a pointer we can use */

    *pcbSrcBufferMin =                      /* we'll expand sometimes */
            *pcbDataBlockMax + MAX_GROWTH;

    if (pmdhHandle == NULL)                 /* if no context requested, */
    {
        return(MDI_ERROR_NO_ERROR);         /* return from query mode */
    }

    *pmdhHandle = (LDI_CONTEXT_HANDLE) 0;   /* wait until it's valid */

    context = pfnma(sizeof(struct LDI_CONTEXT));

    if (context == NULL)
    {
        return(MDI_ERROR_NOT_ENOUGH_MEMORY);    /* if can't allocate */
    }

	context->decoder_context = pfnma(sizeof(t_decoder_context));

	if (context->decoder_context == NULL)
	{
		pfnmf(context);
		return MDI_ERROR_NOT_ENOUGH_MEMORY;
	}

    context->pfnAlloc = pfnma;              /* remember where alloc() is */
    context->pfnFree = pfnmf;               /* remember where free() is */
    context->pfnOpen = pfnopen;             /* remember where pfnopen() is */
    context->pfnRead = pfnread;             /* remember where pfnread() is */
    context->pfnWrite = pfnwrite;           /* remember where pfnwrite() is */
    context->pfnClose = pfnclose;           /* remember where pfnclose() is */
    context->pfnSeek = pfnseek;             /* remember where pfnseek() is */
    context->cbDataBlockMax = *pcbDataBlockMax;   /* remember agreement */
    context->fCPUtype = (UINT) pConfig->fCPUtype;  /* remember CPU type */
    context->signature = LDI_SIGNATURE;     /* install signature */

	if (LZX_DecodeInit(
			context->decoder_context,
			pConfig->WindowSize, 
			pfnma,
            pfnmf,
            pfnopen,
            pfnread,
            pfnwrite,
            pfnclose,
            pfnseek) == false)
	{
		pfnmf(context);
		return (MDI_ERROR_NOT_ENOUGH_MEMORY);
	}

    /* pass context back to caller */
    *pmdhHandle = HMDfromPMDC(context); 

    return(MDI_ERROR_NO_ERROR);             /* tell caller all is well */
}


/* --- LDIDecompress() ---------------------------------------------------- */
int FAR DIAMONDAPI LDIDecompress(
        LDI_CONTEXT_HANDLE  hmd,            /* decompression context */
        void FAR *          pbSrc,          /* source buffer */
        UINT                cbSrc,          /* source actual size */
        void FAR *          pbDst,          /* target buffer */
        UINT FAR *          pcbResult)      /* gets actual target size */
{
    PMDC_CONTEXT	context;                   /* pointer to the context */
    int				result;                             /* return code */
	long			bytes_to_decode;
	long			total_bytes_written = 0;

    context = PMDCfromHMD(hmd);             /* get pointer from handle */

    if (context->signature != LDI_SIGNATURE)
    {
        return(MDI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

    if (*pcbResult > context->cbDataBlockMax)
    {
		return(MDI_ERROR_BUFFER_OVERFLOW);  /* violated max block promise */
    }

#if 0
	if (cbSrc == 0)
		return MDI_ERROR_NO_ERROR;
#endif

	bytes_to_decode = (long) *pcbResult;

	result = LZX_Decode(
		context->decoder_context,
		bytes_to_decode, 
		pbSrc,
		cbSrc,
		pbDst,
		bytes_to_decode,
		&total_bytes_written
	);

    *pcbResult = (UINT) total_bytes_written;

	if (result)
		return MDI_ERROR_FAILED;
	else
		return MDI_ERROR_NO_ERROR;
}

/* --- LDIResetDecompression() -------------------------------------------- */

int FAR DIAMONDAPI LDIResetDecompression(LDI_CONTEXT_HANDLE hmd)
{
    PMDC_CONTEXT context;                   /* pointer to the context */

    context = PMDCfromHMD(hmd);             /* get pointer from handle */

    if (context->signature != LDI_SIGNATURE)
    {
        return(MDI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

	LZX_DecodeNewGroup(context->decoder_context);

    return(MDI_ERROR_NO_ERROR);             /* if tag is OK */
}

/* --- LDIDestroyDecompression() ------------------------------------------ */

int FAR DIAMONDAPI LDIDestroyDecompression(LDI_CONTEXT_HANDLE hmd)
{
    PMDC_CONTEXT context;                   /* pointer to the context */

    context = PMDCfromHMD(hmd);             /* get pointer from handle */

    if (context->signature != LDI_SIGNATURE)
    {
        return(MDI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

	LZX_DecodeFree(context->decoder_context);

    context->signature = BAD_SIGNATURE;     /* destroy signature */

	context->pfnFree(context->decoder_context);
    context->pfnFree(context);              /* self-destruct */

    return(MDI_ERROR_NO_ERROR);             /* success */
}

/* --- LDIGetWindow() ---------------------------------------------------- */
#ifndef BIT16
int FAR DIAMONDAPI LDIGetWindow(
        LDI_CONTEXT_HANDLE  hmd,            /* decompression context */
        BYTE FAR **         ppWindow,       /* pointer to window start */
        long *              pFileOffset,    /* offset in folder */
        long *              pWindowOffset,  /* offset in window */
        long *              pcbBytesAvail)   /* bytes avail from window start */
{
    PMDC_CONTEXT context;                   
    t_decoder_context *dec_context;

    context = PMDCfromHMD(hmd);             /* get pointer from handle */
    dec_context = context->decoder_context;

    *ppWindow = dec_context->dec_mem_window;

    // window is a circular buffer

    if ((ulong) dec_context->dec_position_at_start < dec_context->dec_window_size)
    {
        *pWindowOffset = 0; 
        *pFileOffset = 0;
        *pcbBytesAvail = dec_context->dec_position_at_start;
    }
    else
    {
        *pWindowOffset = dec_context->dec_position_at_start & (dec_context->dec_window_size - 1);
        *pcbBytesAvail = dec_context->dec_window_size;
        *pFileOffset = dec_context->dec_position_at_start - dec_context->dec_window_size;
    }

    return MDI_ERROR_NO_ERROR;
}
#endif

/* ------------------------------------------------------------------------ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\offsets.c ===
/*
 * Used by makefile to generate OFFSETS.I for ASM source files.
 *
 * Also creates some constants for tables.
 *
 * Outputs offsets into the context structure.
 */
#include "decoder.h"
#include <stdio.h>

t_decoder_context p;

void main(void)
{
    printf("MAIN_TREE_TABLE_BITS        EQU %d\n", MAIN_TREE_TABLE_BITS);
    printf("MAIN_TREE_TABLE_ELEMENTS    EQU %d\n", 1 << MAIN_TREE_TABLE_BITS);
    printf("SECONDARY_LEN_TREE_TABLE_BITS       EQU %d\n", SECONDARY_LEN_TREE_TABLE_BITS);
    printf("SECONDARY_TREE_TABLE_ELEMENTS       EQU %d\n", 1 << SECONDARY_LEN_TREE_TABLE_BITS);
    printf("NUM_SECONDARY_LENGTHS               EQU %d\n", NUM_SECONDARY_LENGTHS);
    printf("ALIGNED_TABLE_ELEMENTS              EQU %d\n", 1 << ALIGNED_TABLE_BITS);
    printf("ALIGNED_NUM_ELEMENTS                EQU %d\n", ALIGNED_NUM_ELEMENTS);

    printf("OFF_MEM_WINDOW              EQU %d\n", (byte *) &p.dec_mem_window - (byte *) &p);
    printf("OFF_WINDOW_SIZE             EQU %d\n", (byte *) &p.dec_window_size - (byte *) &p);
    printf("OFF_WINDOW_MASK             EQU %d\n", (byte *) &p.dec_window_mask - (byte *) &p);
    printf("OFF_LAST_MATCHPOS_OFFSET    EQU %d\n", (byte *) &p.dec_last_matchpos_offset[0] - (byte *) &p);
    printf("OFF_MAIN_TREE_TABLE         EQU %d\n", (byte *) &p.dec_main_tree_table[0] - (byte *) &p);
    printf("OFF_SECONDARY_TREE_TABLE    EQU %d\n", (byte *) &p.dec_secondary_length_tree_table[0] - (byte *) &p);
    printf("OFF_MAIN_TREE_LEN           EQU %d\n", (byte *) &p.dec_main_tree_len[0] - (byte *) &p);
    printf("OFF_SECONDARY_TREE_LEN      EQU %d\n", (byte *) &p.dec_secondary_length_tree_len[0] - (byte *) &p);
    printf("OFF_ALIGNED_TABLE           EQU %d\n", (byte *) &p.dec_aligned_table[0] - (byte *) &p);
    printf("OFF_ALIGNED_LEN             EQU %d\n", (byte *) &p.dec_aligned_len[0] - (byte *) &p);
    printf("OFF_MAIN_TREE_LEFTRIGHT     EQU %d\n", (byte *) &p.dec_main_tree_left_right[0] - (byte *) &p);
    printf("OFF_SECONDARY_TREE_LEFTRIGHT EQU %d\n", (byte *) &p.dec_secondary_length_tree_left_right[0] - (byte *) &p);
    printf("OFF_INPUT_CURPOS            EQU %d\n", (byte *) &p.dec_input_curpos - (byte *) &p);
    printf("OFF_INPUT_ENDPOS            EQU %d\n", (byte *) &p.dec_end_input_pos - (byte *) &p);
    printf("OFF_MAIN_TREE_PREV_LEN      EQU %d\n", (byte *) &p.dec_main_tree_prev_len[0] - (byte *) &p);
    printf("OFF_SECONDARY_TREE_PREV_LEN EQU %d\n", (byte *) &p.dec_secondary_length_tree_prev_len[0] - (byte *) &p);
    printf("OFF_BITBUF                  EQU %d\n", (byte *) &p.dec_bitbuf - (byte *) &p);
    printf("OFF_BITCOUNT                EQU %d\n", (byte *) &p.dec_bitcount - (byte *) &p);
    printf("OFF_NUM_POSITION_SLOTS      EQU %d\n", (byte *) &p.dec_num_position_slots - (byte *) &p);
    printf("OFF_BUFPOS                  EQU %d\n", (byte *) &p.dec_bufpos - (byte *) &p);

	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\maketbl.c ===
/*
 * Table-building routines
 *
 * make_table() is based on ** Public Domain ** source "AR001.ZIP".
 */
#include "decoder.h"


/*
 * Make a decoding table for decoding nchar possible Huffman elements 
 * with bit lengths given by bitlen.
 *
 * Output the main lookup table into table[] and use leftright[] for
 * supplementary information (for bitlengths > tablebits).
 *
 * The size of table[] is tablebits elements.
 */
#ifndef ASM_MAKE_TABLE
bool NEAR make_table(
	t_decoder_context	*context,
	int     			nchar,
	const byte			*bitlen,
	byte				tablebits,
	short  				*table,
	short  				*leftright
)
{
    uint    i;
	int		ch;
    short * p;
    uint    count[17], weight[17], start[18];
    int     avail;
    uint    nextcode;
    uint    k;
	byte	len;
	byte	jutbits;

	for (i = 1; i <= 16; i++)
		count[i] = 0;

	/* count the number of elements of each bit length */
    for (i = 0; i < (uint) nchar; i++)
		count[bitlen[i]]++;

	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = start[i] + (count[i] << (16 - i));

#ifdef BIT16
    if (start[17])
    {
        return false; /* bad table */
    }
#else
    if (start[17] != 65536)
    {
        if (start[17] == 0)
        {
            /*
             * All elements are length zero
             */
            memset(table, 0, sizeof(ushort)*(1 << tablebits));
            return true; /* success */
        }
        else
        {
            return false; /* bad table */
        }
    }
#endif

	jutbits = 16 - tablebits;

	for (i = 1; i <= tablebits; i++)
	{
		start[i] >>= jutbits;
		weight[i] = 1 << (tablebits - i);
	}

	while (i <= 16)
	{
		weight[i] = 1 << (16 - i);
		i++;
	}
	
	i = start[tablebits+1] >> jutbits;

#ifdef BIT16
    if (i)
#else
	if (i != 65536)
#endif
	{
		memset(
            &table[i],
            0,
            sizeof(ushort)*((1 << tablebits)-i)
        );
	}

	avail = nchar;

	for (ch = 0; ch < nchar; ch++)
	{
		if ((len = bitlen[ch]) == 0)
			continue;

		nextcode = start[len] + weight[len];

		if (len <= tablebits)
		{
            if (nextcode > (uint) (1 << tablebits))
                return false; /* bad table */

			for (i = start[len]; i < nextcode; i++)
				table[i] = (short) ch;

   			start[len] = nextcode;
		}
		else
		{
			byte i;

			k = start[len];
   			start[len] = nextcode;
			p = &table[k >> jutbits];

			i = len - tablebits;
			k <<= tablebits;

			do
			{
				if (*p == 0)
				{
					leftright[avail*2] = leftright[avail*2+1] = 0;
					*p = (short) -avail;
					avail++;
				}

				if ((signed short) k < 0) // if (k & 32768)
					p = &leftright[-(*p)*2+1];
				else
					p = &leftright[-(*p)*2];

				k <<= 1;
				i--;
			} while (i);

			*p = (short) ch;
		}
	}

    return true;
}
#endif


/*
 * Specialised make table routine where it is known that there are
 * only 8 elements (nchar=8) and tablebits=7 (128 byte lookup table).
 *
 * Since there can be no overflow, this will be a direct lookup.
 *
 * Important difference; the lookup table returns a byte, not a ushort.
 */
bool NEAR make_table_8bit(t_decoder_context *context, byte bitlen[], byte table[])
{
	ushort count[17], weight[17], start[18];
	ushort i;
	ushort nextcode;
	byte   len;
	byte   ch;

	for (i = 1; i <= 16; i++)
		count[i] = 0;

	for (i = 0; i < 8; i++)
		count[bitlen[i]]++;

	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = start[i] + (count[i] << (16 - i));

	if (start[17] != 0)
        return false; /* bad table */

	for (i = 1; i <= 7; i++)
	{
		start[i] >>= 9;
		weight[i]  = 1 << (7 - i);
	}

	while (i <= 16)
	{
		weight[i] = 1 << (16 - i);
		i++;
	}

	memset(table, 0, 1<<7);

	for (ch = 0; ch < 8; ch++)
	{
		if ((len = bitlen[ch]) == 0)
			continue;

		nextcode = start[len] + weight[len];

		if (nextcode > (1 << 7))
            return false; /* bad table */

		for (i = start[len]; i < nextcode; i++)
			table[i] = ch;

		start[len] = nextcode;
	}

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\ring16.c ===
/*
 *  RING16.C: Ring buffer code
 *
 *  History:
 *      30-Oct-1996     jforbes     Cloned from QUANTUM\DECOMP.C
 */

#include <stdio.h>          /* for NULL */
#include <stdlib.h>         /* for disk ring buffer code (SEEK_SET) */
#include <fcntl.h>          /* for disk ring buffer code (_O_*) */
#include <sys\stat.h>       /* for disk ring buffer code (_S_I*) */
#include <io.h>
#include "decoder.h"


/* --- local function prototypes ------------------------------------------ */

static void NEAR    DComp_Internal_Literal(t_decoder_context *context, int Chr );
static void NEAR    DComp_Internal_Match(t_decoder_context *context, MATCH Match );

static void NEAR    DComp_Ring_Close(t_decoder_context *context);
static int NEAR     DComp_Ring_Init(t_decoder_context *context);
static void NEAR    DComp_Ring_Literal(t_decoder_context *context, int Chr );
static BYTE * NEAR  DComp_Ring_Load(t_decoder_context *context, int page,int fWrite);
static void NEAR    DComp_Ring_Match(t_decoder_context *context, MATCH Match );
static void NEAR    DComp_Ring_Reset(t_decoder_context *context);


#define Disk context->Disk

#define DComp context->DComp


/* --- DComp_Close() ------------------------------------------------------ */
void NEAR DComp_Close(t_decoder_context *context)
{
    if (DComp.Buf == NULL)
    {
        DComp_Ring_Close(context);     /* if using a disk-based ring buffer */
    }
    else
    {
        context->dec_free( DComp.Buf );  /* if using memory-based ring buffer */
    }
}


/* --- DComp_Init() ------------------------------------------------------- */
int NEAR DComp_Init(t_decoder_context *context)
{
    DComp.Cur = 0;
    DComp.fRingFault = 0;

    if( (DComp.Buf = context->dec_malloc( context->dec_window_size )) != NULL )
    {
        DComp.BufPos = DComp.Buf;
        DComp.BufEnd = DComp.Buf + context->dec_window_size;

        context->DComp_Token_Match = DComp_Internal_Match;     /* use internal buffering */
        context->DComp_Token_Literal = DComp_Internal_Literal;
    }
    else if (DComp_Ring_Init(context))                     /* try disk ring buffer */
    {
        context->DComp_Token_Match = DComp_Ring_Match;         /* use disk buffering */
        context->DComp_Token_Literal = DComp_Ring_Literal;
    }
    else
    {
        return (1);                              /* if can't create ring buffer */
    }

    return(0);
}

/* --- DComp_Internal_Literal() ------------------------------------------- */

static void NEAR DComp_Internal_Literal(t_decoder_context *context, int Chr)
{
    if (DComp.NumBytes)
    {
        DComp.NumBytes--;
        DComp.Cur++;

        *context->dec_output_curpos++ = *DComp.BufPos++ = (BYTE) Chr;

        if (DComp.BufPos == DComp.BufEnd)
            DComp.BufPos = DComp.Buf;
    }
}


/* --- DComp_Internal_Match() --------------------------------------------- */

static void NEAR DComp_Internal_Match(t_decoder_context *context, MATCH Match)
{
    BYTE HUGE *SrcPtr;

    if (DComp.NumBytes >= (unsigned) Match.Len)
    {
        SrcPtr = DComp.Buf +
            ((DComp.Cur - Match.Dist) & context->dec_window_mask);

        DComp.NumBytes -= Match.Len;
        DComp.Cur += Match.Len;

        while (Match.Len--)
        {
            *context->dec_output_curpos++ = *DComp.BufPos++ = *SrcPtr++;

            if (SrcPtr == DComp.BufEnd)
                SrcPtr = DComp.Buf;

            if (DComp.BufPos == DComp.BufEnd)
                DComp.BufPos = DComp.Buf;
        }
    }
    else  /* match too large to fit */
    {
        DComp.NumBytes = 0;
        DComp.fOutOverflow = 1;
    }
}

/* --- DComp_Reset() ------------------------------------------------------ */

void NEAR DComp_Reset(t_decoder_context *context)
{
    DComp.Cur = 0;
    DComp.fRingFault = 0;

    if (DComp.Buf != NULL)
        DComp.BufPos = DComp.Buf;   /* big buffer */
    else
        DComp_Ring_Reset(context);  /* ring buffer */
}

/* --- DComp_Ring_Close() ------------------------------------------------- */

static void NEAR DComp_Ring_Close(t_decoder_context *context)
{
    PBUFFER pBuffer, pNext;                   /* buffer walk pointer */

    context->dec_free(Disk.PageTable);                 /* discard page table */

    pBuffer = Disk.pNewest;

    while (pBuffer != NULL)                   /* discard buffer chain */
    {
        pNext = pBuffer->pLinkOlder;
        context->dec_free(pBuffer);
        pBuffer = pNext;
    }

    context->dec_close(Disk.Handle);       /* close that file (and delete) */
}


/* --- DComp_Ring_Init() -------------------------------------------------- */

static int NEAR DComp_Ring_Init(t_decoder_context *context)
{
    RINGNAME ringName;
    PBUFFER pBuffer;
    int cBuffers;

    ringName.wildName[0] = '*';
    ringName.wildName[1] = '\0';  
    ringName.fileSize = context->dec_window_size;

    Disk.Handle = context->dec_open(
        (char FAR *) &ringName,
        (_O_BINARY|_O_RDWR|_O_CREAT),
        (_S_IREAD|_S_IWRITE)
    );

    if (Disk.Handle == -1)
    {
        return(0);                              /* failed, can't make disk file */
    }

    Disk.RingPages = (int) (context->dec_window_size / BUFFER_SIZE);

    if (Disk.RingPages < MIN_BUFFERS)
    {
        Disk.RingPages = MIN_BUFFERS;  /* if DComp.WindowSize < BUFFER_SIZE */
    }

    Disk.PageTable = context->dec_malloc(sizeof(PAGETABLEENTRY) * Disk.RingPages);

    if (Disk.PageTable == NULL)
    {
        context->dec_close(Disk.Handle);     /* close the file */

        return(0);                              /* failed, can't get page table */
    }

    Disk.pNewest = NULL;

    /* DComp_Ring_Close() can be used to abort from this point on */

    for (cBuffers = 0; cBuffers < Disk.RingPages; cBuffers++)
    {
        pBuffer = context->dec_malloc(sizeof(BUFFER));

        if (pBuffer != NULL)
        {
            pBuffer->pLinkNewer = NULL;           /* none are newer */
            pBuffer->pLinkOlder = Disk.pNewest;   /* all the others older now */

            if (Disk.pNewest != NULL)
            {
                Disk.pNewest->pLinkNewer = pBuffer; /* old guy now knows about new */
            }
            else      /* if nobody else */
            {
                Disk.pOldest = pBuffer;             /* guess I'm the oldest too */
            }

            Disk.pNewest = pBuffer;               /* I'm the newest */
        } 
        else    /* if pBuffer == NULL */
        {
            if (cBuffers < MIN_BUFFERS)           /* less than minimum? */
            {
                DComp_Ring_Close(context);                 /* give it up */

                return(0);                          /* failed, can't get min buffers */
            }
            else  /* if we got the minimum */
            {
                break;                              /* got enough, quit trying */
            }
        }
    }

//    printf("Got %d of %d ring pages\n",cBuffers,Disk.RingPages);

    return(1);                                /* ring buffer created */
}


/* --- DComp_Ring_Literal() ----------------------------------------------- */
static void NEAR DComp_Ring_Literal(t_decoder_context *context, int Chr)
{
    if (DComp.NumBytes)
    {
        DComp.NumBytes--;
        DComp.Cur++;

        *context->dec_output_curpos++ = (BYTE) Chr;
    }
}


/*
 * Insert output buffer contents into the page table
 */
static void NEAR save_page(
    t_decoder_context * context,
    int                 page,
    byte *              data
)
{
    PBUFFER pBuffer;
    long    iPagefileOffset;

    pBuffer = Disk.PageTable[page].pBuffer;   /* look up this page */

    if (pBuffer != NULL)                      /* if it's in the table */
    {
        if (pBuffer != Disk.pNewest)            /* promote if not newest */
        {
            pBuffer->pLinkNewer->pLinkOlder = pBuffer->pLinkOlder;

            if (pBuffer->pLinkOlder != NULL)      /* if there is someone older */
            {
                pBuffer->pLinkOlder->pLinkNewer = pBuffer->pLinkNewer;
            }
            else
            {
                Disk.pOldest = pBuffer->pLinkNewer;
            }        

            /* link into head of chain */

            Disk.pNewest->pLinkNewer = pBuffer;   /* newest now knows one newer */
            pBuffer->pLinkNewer = NULL;           /* nobody's newer */
            pBuffer->pLinkOlder = Disk.pNewest;   /* everybody's older */
            Disk.pNewest = pBuffer;               /* I'm the newest */
        }

        memcpy(
            pBuffer->Buffer,
            data,
            BUFFER_SIZE
        );

        pBuffer->BufferDirty = 1;         /* might already be dirty */
        return;
    }

    pBuffer = Disk.pOldest;                   /* choose the oldest buffer */

    if (pBuffer->BufferPage != -1)            /* take it out of page table */
    {
        Disk.PageTable[pBuffer->BufferPage].pBuffer = NULL;  /* not here now */

        if (pBuffer->BufferDirty)                 /* write on eject, if dirty */
        {
            iPagefileOffset = (long) pBuffer->BufferPage * BUFFER_SIZE;

            if (context->dec_seek(Disk.Handle,iPagefileOffset,SEEK_SET) !=
                iPagefileOffset)
            {
                return;
            }

            if (context->dec_write(Disk.Handle,pBuffer->Buffer,BUFFER_SIZE) !=
                BUFFER_SIZE)
            {
                return;
            }

            Disk.PageTable[pBuffer->BufferPage].fDiskValid = 1;
        }
    }

    Disk.pOldest = Disk.pOldest->pLinkNewer;  /* newer is now oldest */
    Disk.pOldest->pLinkOlder = NULL;          /* oldest knows none older */

    Disk.pNewest->pLinkNewer = pBuffer;
    pBuffer->pLinkNewer = NULL;               /* link into head of chain */
    pBuffer->pLinkOlder = Disk.pNewest;
    Disk.pNewest = pBuffer;

    /* add new buffer to paging table */
    Disk.PageTable[page].pBuffer = pBuffer;   /* add new to paging table */

    memcpy(
        pBuffer->Buffer,
        data,
        BUFFER_SIZE
    );

    pBuffer->BufferDirty = 1;
    pBuffer->BufferPage = page;               /* our new page number */
}


static void NEAR init_last_chance_table(t_decoder_context *context)
{
    int i;

    for (i = 0; i < NUM_OUTPUT_BUFFER_PAGES; i++)
        context->dec_pos_to_page[i] = -1;

    context->dec_last_chance_page_to_use = NUM_OUTPUT_BUFFER_PAGES;
}


static byte * NEAR last_chance_retrieve(t_decoder_context *context, int page)
{
    int used_output_pages;
    int table_entry;

    /*
     * Where in the output buffer would our page be?
     */
    table_entry = Disk.PageTable[page].last_chance_ptr;

    /*
     * It's not there
     */
    if (table_entry == -1)
        return NULL;

    /*
     * It's now an invalid entry
     */
    if (context->dec_pos_to_page[table_entry] != page)
        return NULL;

    context->dec_pos_to_page[table_entry] = -1;
    Disk.PageTable[page].last_chance_ptr = -1;

    used_output_pages = (int) (((context->dec_output_curpos - context->dec_output_buffer) / BUFFER_SIZE) + 1);

    if (table_entry <= used_output_pages)
        return NULL;

    return (context->dec_output_buffer + (BUFFER_SIZE * table_entry));
}


static void NEAR last_chance_store(t_decoder_context *context, int page, byte *data)
{
    int used_output_pages;
    int prev_owner;
    int dest;

    used_output_pages = (int) (((context->dec_output_curpos - context->dec_output_buffer) / BUFFER_SIZE) + 1);

    if (used_output_pages >= NUM_OUTPUT_BUFFER_PAGES)
        return;

    context->dec_last_chance_page_to_use--;

    if (context->dec_last_chance_page_to_use < used_output_pages)
        context->dec_last_chance_page_to_use = NUM_OUTPUT_BUFFER_PAGES-1;

    dest = context->dec_last_chance_page_to_use;

    /*
     * If any other page was pointing to this area of the buffer
     * as a last chance page, toast them.
     */
    prev_owner = context->dec_pos_to_page[dest];

    if (prev_owner != -1)
    {
        Disk.PageTable[prev_owner].last_chance_ptr = -1;
    }

    /*
     * Now we own this area
     */
    Disk.PageTable[page].last_chance_ptr = dest;
    context->dec_pos_to_page[dest] = page;

    memcpy(
        context->dec_output_buffer + (BUFFER_SIZE*dest),
        data,
        BUFFER_SIZE
    );
}


void NEAR DComp_Save_Output_Pages(
    t_decoder_context * context,
    uint                bytes_decoded
)
{
    uint    pages_to_save;
    int     page_num;
    uint    i;
    byte *  data;

    /*
     * If we managed to allocate one big buffer in the first place, then
     * there are no ring pages to save.
     */
    if (DComp.Buf != NULL)
        return;

    pages_to_save = (bytes_decoded / BUFFER_SIZE);

    page_num = (int) ((context->dec_position_at_start & context->dec_window_mask) / (long) BUFFER_SIZE);
    data = context->dec_output_buffer;

    for (i = 0; i < pages_to_save; i++)
    {
        save_page(context, page_num, data);

        page_num++;

        if (page_num >= Disk.RingPages)
            page_num = 0;

        data += BUFFER_SIZE;
    }

    init_last_chance_table(context);
}


static int NEAR retrieve_page_from_disk(t_decoder_context *context, int page, byte *buffer)
{
    long iPagefileOffset;
    byte *data;

    data = last_chance_retrieve(context, page);

    if (data)
    {
        memcpy(buffer, data, BUFFER_SIZE);
        return 1;
    }

    iPagefileOffset = (long) page * BUFFER_SIZE;

    if (context->dec_seek(Disk.Handle,iPagefileOffset,SEEK_SET) !=
        iPagefileOffset)
    {
        return 0;
    }

    if (context->dec_read(Disk.Handle,buffer,BUFFER_SIZE) != 
        BUFFER_SIZE)
    {
        return 0;
    }

#ifdef DEBUG_VERIFY_LAST_CHANCE
    /*
     * verifies last chance data against disk page
     */
    if (data)
    {
        int i;

        for (i=0;i<BUFFER_SIZE;i++)
        {
            if (data[i] != buffer[i])
            {
                printf("page %3d, err@%5d: %3d vs %3d (real)\n",
                    page, i, data[i], buffer[i]);
            }
        }
    }
#endif

    return 1;
}


/* --- DComp_Ring_Load() -------------------------------------------------- */

/* Bring page into a buffer, return a pointer to that buffer.  fWrite */
/* indicates the caller's intentions for this buffer, NZ->consider it */
/* dirty now.  Returns NULL if there is a paging fault (callback      */
/* failed) or if any internal assertions fail. */

static BYTE * NEAR DComp_Ring_Load(
    t_decoder_context * context,
    int                 page,
    int                 fWrite
)
{
    PBUFFER pBuffer;
    long iPagefileOffset;

    pBuffer = Disk.PageTable[page].pBuffer;   /* look up this page */

    if (pBuffer != NULL)                      /* if it's in the table */
    {
        if (pBuffer != Disk.pNewest)            /* promote if not newest */
        {
            pBuffer->pLinkNewer->pLinkOlder = pBuffer->pLinkOlder;

            if (pBuffer->pLinkOlder != NULL)      /* if there is someone older */
            {
                pBuffer->pLinkOlder->pLinkNewer = pBuffer->pLinkNewer;
            }
            else
            {
                Disk.pOldest = pBuffer->pLinkNewer;
            }        

            /* link into head of chain */

            Disk.pNewest->pLinkNewer = pBuffer;   /* newest now knows one newer */
            pBuffer->pLinkNewer = NULL;           /* nobody's newer */
            pBuffer->pLinkOlder = Disk.pNewest;   /* everybody's older */
            Disk.pNewest = pBuffer;               /* I'm the newest */
        }

        pBuffer->BufferDirty |= fWrite;         /* might already be dirty */

        return(pBuffer->Buffer);
    }

    /* desired page is not in the table; discard oldest & use it */

    pBuffer = Disk.pOldest;                   /* choose the oldest buffer */

    if (pBuffer->BufferPage != -1)            /* take it out of page table */
    {
        Disk.PageTable[pBuffer->BufferPage].pBuffer = NULL;  /* not here now */

        if (pBuffer->BufferDirty)                 /* write on eject, if dirty */
        {
            iPagefileOffset = (long) pBuffer->BufferPage * BUFFER_SIZE;

            if (context->dec_seek(Disk.Handle,iPagefileOffset,SEEK_SET) !=
                iPagefileOffset)
            {
                return(NULL);
            }

            if (context->dec_write(Disk.Handle,pBuffer->Buffer,BUFFER_SIZE) !=
                BUFFER_SIZE)
            {
                return(NULL);
            }

            Disk.PageTable[pBuffer->BufferPage].fDiskValid = 1;
        }


        last_chance_store(context, pBuffer->BufferPage, pBuffer->Buffer);
    }

    Disk.pOldest = Disk.pOldest->pLinkNewer;  /* newer is now oldest */
    Disk.pOldest->pLinkOlder = NULL;          /* oldest knows none older */

    Disk.pNewest->pLinkNewer = pBuffer;
    pBuffer->pLinkNewer = NULL;               /* link into head of chain */
    pBuffer->pLinkOlder = Disk.pNewest;
    Disk.pNewest = pBuffer;

    /* add new buffer to paging table */

    Disk.PageTable[page].pBuffer = pBuffer;   /* add new to paging table */

    /* if this disk page is valid, load it */

    if (Disk.PageTable[page].fDiskValid)
    {
        if (retrieve_page_from_disk(context, page, pBuffer->Buffer) == 0)
            return NULL;
    }
    else if (!fWrite)
    {
        /* assertion failure, trying to load a never-written page from disk */
        return(NULL);
    }

    pBuffer->BufferDirty = fWrite;            /* might be dirty now */
    pBuffer->BufferPage = page;               /* our new page number */

    return(pBuffer->Buffer);                          /* return new handle */
}

/* --- DComp_Ring_Match() ------------------------------------------------- */
static void NEAR DComp_Ring_Match(t_decoder_context *context, MATCH Match)
{
    long    SrcOffset;               /* offset into output ring */
    int     SrcPage;                  /* page # where that offset lies */
    int     Chunk;                    /* number of bytes this pass */
    BYTE FAR *SrcPtr;             /* pointer to source bytes */
    BYTE *SrcBuffer;            /* buffer where source data is */
    int     SrcBufferOffset;          /* offset within the buffer */

    if (DComp.NumBytes >= (unsigned) Match.Len)
    {
        SrcOffset = (DComp.Cur - Match.Dist) & context->dec_window_mask;
        DComp.NumBytes -= Match.Len;
        DComp.Cur += Match.Len;

        while (Match.Len)
        {
            /* Limit: number of bytes requested */

            Chunk = Match.Len;        /* try for everything */

            /*
             * Match source inside current output buffer?
             */
            if (Match.Dist <= (long) (context->dec_output_curpos - context->dec_output_buffer))
            {
                SrcPtr = context->dec_output_curpos - Match.Dist;

                while (Chunk--)               /* copy this chunk */
                {
                    *context->dec_output_curpos++ = *SrcPtr++;
                }

                return;
            }
            else
            {
                SrcPage = (int) (SrcOffset / BUFFER_SIZE);
                SrcBufferOffset = (int) (SrcOffset % BUFFER_SIZE);

                SrcBuffer = DComp_Ring_Load(context,SrcPage,0);   /* for reading */

                if (SrcBuffer == NULL)
                {
                    DComp.NumBytes = 0;
                    DComp.fRingFault = 1;
                    return;
                }

                SrcPtr = SrcBuffer + SrcBufferOffset;

                /* Limit: number of source bytes on input page */

                if ((BUFFER_SIZE - SrcBufferOffset) < Chunk)
                    Chunk = (BUFFER_SIZE - SrcBufferOffset);

                SrcOffset += Chunk;
                SrcOffset &= context->dec_window_mask;
                Match.Len -= Chunk;

                while (Chunk--)               /* copy this chunk */
                {
                    *context->dec_output_curpos++ = *SrcPtr++;
                }
            }
        }     /* while Match.Len */
    }   /* if Match.Len size OK */
    else  /* match too large to fit */
    {
        DComp.NumBytes = 0;
        DComp.fOutOverflow = 1;
    }
}


/* --- DComp_Ring_Reset() ------------------------------------------------- */

static void NEAR DComp_Ring_Reset(t_decoder_context *context)
{
    PBUFFER walker;
    int     iPage;

    for (walker = Disk.pNewest; walker != NULL; walker = walker->pLinkOlder)
    {
        walker->BufferPage = -1;                /* buffer is not valid */
        walker->BufferDirty = 0;                /*   and doesn't need writing */
    }

    for (iPage = 0; iPage < Disk.RingPages; iPage++)
    {
        Disk.PageTable[iPage].pBuffer = NULL;   /* not in memory */
        Disk.PageTable[iPage].fDiskValid = 0;   /* not on disk */
        Disk.PageTable[iPage].last_chance_ptr = -1; /* not in last chance list */
    }

    init_last_chance_table(context);
    context->dec_last_chance_page_to_use = NUM_OUTPUT_BUFFER_PAGES;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\tableasm.asm ===
;
; tableasm.asm
;
; Assembly version of make_table()
;
; jforbes   07/20/96
;
; Note, this is not optimised for the Pentium at all; very few
; instructions will execute two at a time.
;
   TITLE TABLEASM.ASM
	.386P
.model FLAT

PUBLIC  _make_table

;  COMDAT @_make_table
_TEXT   SEGMENT
$start      = 0
$weight     = $start + 72
$count      = $weight + 72
$nchar      = $count + 72
$bitlen     = $nchar + 4
$ch         = $bitlen + 4
$leftright  = $ch + 4
$avail      = $leftright + 4
$k          = $avail + 4
$table      = $k + 4
$tablebits  = $table + 4
$jutbits    = $tablebits + 4
$context    = $jutbits + 4
$last       = $context + 4
_make_table PROC NEAR             ; COMDAT


;
;void make_table(
;   t_decoder_context *context,
;   USHORT  nchar,
;   UBYTE  *bitlen,
;   USHORT  tablebits,
;   short  *table,
;   short  *leftright)

; count   [esp+72+68]
; weight  [esp+72]
; start   [esp]

; 6 regs * 4 = 24 bytes
   push  ebx
   push  ecx
   push  edx
   push  ebp
   push  esi
   push  edi

   sub   esp, $last


; how to access the parameters off the stack
; skip over 24 bytes of pushed registers, and $last local
; variables, and the 4 byte return address.
$parms = $last+28

   mov   eax, [esp + $parms + 4]
   and   eax, 65535
   mov   [esp + $nchar], eax

   mov   eax, [esp + $parms]
   mov   [esp + $context], eax

   mov   eax, [esp + $parms + 8]
   mov   [esp + $bitlen], eax

   mov   eax, [esp + $parms + 12]
   and   eax, 255
   mov   [esp + $tablebits], eax

   mov   eax, [esp + $parms + 16]
   mov   [esp + $table], eax

   mov   eax, [esp + $parms + 20]
   mov   [esp + $leftright], eax


;   for (i = 1; i <= 16; i++)
;      count[i] = 0;

; clear 64 bytes starting at &count[1]
   xor   eax, eax
   lea   edi, [esp + $count + 4]
   mov   ecx, 16
   rep   stosd


;   for (i = 0; i < nchar; i++)
;      count[bitlen[i]]++;

; Do it in reverse
   mov   ecx, [esp + $nchar]              ; u
   mov   esi, [esp + $bitlen]             ; v

   xor   ebx, ebx                         ; u
   dec   ecx                              ; v  ecx = i

loop1:
   mov   bl, [esi + ecx]                  ; bl = bitlen[i]
   inc   DWORD PTR [esp + $count + ebx*4] ; NP

   dec   ecx                              ; u
   jge   SHORT loop1                      ; v




;   start[1] = 0;
;
;   for (i = 1; i <= 16; i++)
;      start[i + 1] = start[i] + (count[i] << (16 - i));
;
   lea   ebp, [esp + $start + 4] ; u
   lea   esi, [esp + $count + 4] ; v

   xor   edx, edx                ; u  edx = start[i]
   mov   ecx, 15                 ; v  ecx = 16 - i

   mov   [ebp], edx              ; u  start[1] = 0
   nop                           ; v

loop2:
   mov   eax, [esi]              ; u  eax = count[i]
   add   ebp, 4                  ; v

   shl   eax, cl                 ; u
   add   esi, 4                  ; v
                                      
   add   eax, edx                ; u  edx = start[i]
; stall

   mov   [ebp], eax              ; u  start[i+1]
   mov   edx, eax                ; v  edx <- start[i+1]

   dec   ecx                     ; u
   jge   SHORT loop2             ; v


;   if (start[17] != 65536)
   mov   edx, [esp + 68 + $start]
   cmp   edx, 65536
   jne   not_65536



;   jutbits = 16 - tablebits;
;
;   for (i = 1; i <= tablebits; i++)
;   {
;      start[i] >>= jutbits;
;      weight[i] = 1 << (tablebits - i);
;   }

   mov   edx, [esp + $tablebits] ; u  edx = tablebits
   mov   eax, 1                  ; v  eax = i

   lea   ecx, [edx - 1]          ; u  ecx = tablebits - i(=1)
   mov   ebp, eax                ; v  ebp = 1

   shl   ebp, cl                 ; u  ebp = 1 << (tablebits - i)
   mov   ebx, ecx                ; v  ebx = tablebits - i(=1)

   mov   cl, 16                  ; upper bits of ecx are zero
   sub   ecx, edx                ; ecx = jutbits = 16 - tablebits
   mov   [esp + $jutbits], ecx

loop3:
   shr   DWORD PTR [esp + $start + eax*4], cl    ; u  start[i] >>= jutbits
   mov   DWORD PTR [esp + $weight + eax*4], ebp  ; v

   shr   ebp, 1         ; u
   inc   eax            ; v  i++

   cmp   eax, edx       ; u
   jle   SHORT loop3    ; v



;   while (i <= 16)
;   {
;      weight[i] = 1 << (16 - i);
;      i++;
;   }

   cmp   al, 16            ; u
   jg    SHORT exit_loop4  ; v

loop4:
   mov   ecx, 16           ; u
   mov   ebx, 1            ; v

   sub   ecx, eax          ; u   ecx = 16 - i
   inc   eax               ; v   WAR ok

   shl   ebx, cl           ; u  ebx = 1 << (16 - i)
   mov   DWORD PTR [esp + $weight + eax*4 - 4], ebx ; v

   cmp   al, 16            ; u
   jle   SHORT loop4       ; v

exit_loop4:



; i = start[tablebits+1] >> jutbits

; ecx = jutbits
   mov   ecx, [esp + $jutbits]

; edx = tablebits
   mov   edx, [esp + $tablebits]

; eax = start[tablebits+1]
   mov   eax, [esp + $start + 4 + edx*4]

; eax = start[tablebits+1] >> jutbits
   shr   eax, cl

; if (i != 65536)
   cmp   eax, 65536
   je    SHORT i_is_zero


;
;   memset(&table[i], 0, sizeof(ushort)*((1 << tablebits)-i);
;

; ecx = tablebits
   mov  ecx, edx

; edx = 1 << tablebits
   mov  edx, 1
   shl  edx, cl

; edx = (1 << tablebits) - i
   sub  edx, eax

; count = (1 << tablebits) - i words
   mov  ecx, edx

; dest = edi = &table[i]
   mov  edi, [esp + $table]
   lea  edi, [edi + eax*2]

; value = 0
   xor  eax, eax

   rep  stosw


i_is_zero:

;
;   avail = nchar;
;
   mov   eax, [esp + $nchar]          ; u
   xor   edi, edi                     ; v  edi = ch


;
;   for (ch = 0; ch < nchar; ch++)
;

   mov   [esp + $avail], eax          ; u
   jmp   SHORT main_loop              ; v


; for short jump
bad_table2:
   xor   eax, eax ; return failure
   jmp   cleanup


main_loop:

;      if ((len = bitlen[ch]) == 0)
;         continue;

; eax = &bitlen[0]
   mov   eax, [esp + $bitlen]

; ebp = len = bitlen[ch]
   movzx ebp, BYTE PTR [eax + edi] 

; if (len == 0)
;    continue
   test  ebp, ebp                   
   jz    loop_bottom                 


;      nextcode = start[len] + weight[len];

; ebx = start[len]
   mov   ebx, [esp + $start + ebp*4]  ; u
   mov   ecx, [esp + $tablebits]      ; v  ecx = tablebits

; ebx = nextcode = start[len] + weight[len]
   mov   eax, ebx                     ; u  eax = start[len]
   add   ebx, [esp + $weight + ebp*4] ; v  WAR ok

;      if (len <= tablebits)
   cmp   ebp, ecx                  ; u
   jg    SHORT len_g_tablebits     ; v

;         if (nextcode > (1 << tablebits))
;            bad_table();

; edx = 1 << tablebits
   mov   edx, 1

   shl   edx, cl   ; u
   mov   ecx, ebx  ; v  ecx = nextcode

; if (nextcode > (1 << tablebits))
   cmp   ebx, edx         ; u
   jg    SHORT bad_table2 ; v


;         for (i = start[len]; i < nextcode; i++)
;            table[i] = ch;


; ecx = nextcode - start[len]
    sub  ecx, eax         ; u
    add  eax, eax         ; v  WAR ok

; eax = &table[ start[len] ]
    add  eax, [esp + $table]            ; u

; start[len] = nextcode (moved up)
    mov  [esp + $start + ebp*4], ebx    ; v


; For this loop:
;  eax = &table[ start[len] ]
;  edi = ch
;  ecx = nextcode - start[len]
;
loop6:
   mov   WORD PTR [eax], di     ; table[i] = ch
   add   eax, 2                 ; i++

   dec   ecx
   jnz   SHORT loop6


; ch++
   inc   edi ; moved up

; loop bottom
   cmp   edi, [esp + $nchar]
   jl    SHORT main_loop

   mov   eax, 1 ; success
   jmp   cleanup


;
; len > tablebits
;
; on entry: eax = start[len]
;           ebx = nextcode
;           ecx = tablebits
;           ebp = len
;
len_g_tablebits:

   mov   esi, ebp        ; u  esi = len
   mov   edx, eax        ; v  edx = start[len]

   sub   esi, ecx        ; u  esi = len - tablebits
   add   cl, 16          ; v

; edx = k << tablebits
; shift left another 16 because we want to use a DWORD
; for testing the negative bit
   shl   edx, cl         ; u
   mov   [esp + $k], eax ; v

; start[len] = nextcode;
   mov   [esp + $start + ebp*4], ebx ; u
   nop                               ; v

; p = &table[k >> jutbits];
   mov   ecx, [esp + $jutbits]   ; u  ecx = jutbits
   mov   ebx, [esp + $k]         ; v  ebx = k >> jutbits

   shr   ebx, cl                 ; u
   mov   eax, [esp + $table]     ; v

   lea   ebx, [eax + ebx*2]      ; u  ebx = p = &table[k >> jutbits]
   mov   ebp, [esp + $avail]     ; v  ebp = avail

bottom_loop:

; if (*p == 0)

; eax = &leftright[0]
   mov   eax, [esp + $leftright]

; ecx = *p
   movsx ecx, WORD PTR [ebx]     ; NP

; *p == 0 ?
   test  ecx, ecx                ; u
   jne   SHORT p_not_zero        ; v

;  left_right[avail*2] = left_right[avail*2+1] = 0;
;  *p = -avail;
;  avail++;

   mov   WORD PTR [ebx], bp      ; *p = avail

; sets left and right to zero (remember that ecx == 0)
   mov   [eax + ebp*4], ecx      ; u
   inc   ebp                     ; v  avail++

;  *p = -avail
   neg   WORD PTR [ebx]


p_not_zero:

;  if ((signed short) k < 0)
;     p = &right[-(*p)];
;  else
;     p = &left[-(*p)];

; ecx = -(*p)
   movsx ecx, WORD PTR [ebx]
   neg   ecx

; ebx = p = &ptr[-(*p)]
   lea   ebx, [ecx*4 + eax]

; if (k becomes -ve when we shift out a bit)
   add   edx, edx
   jnc   SHORT go_left

; right
   add   ebx, 2

go_left:

   dec   esi  ; i--
   jnz   SHORT bottom_loop


;  *p = ch;
   mov   WORD PTR [ebx], di


; store avail
   mov   [esp + $avail], ebp



loop_bottom:

; ch++
   inc   edi

   cmp   edi, [esp + $nchar]
   jl    main_loop

   mov   eax, 1 ; success


cleanup:
   add   esp, $last

   pop   edi
   pop   esi
   pop   ebp
   pop   edx
   pop   ecx
   pop   ebx

   ret   0


not_65536:
   test  edx, edx
   jnz   SHORT bad_table

; memset(table, 0, sizeof(ushort)*(1<<tablebits))
   xor   eax, eax
   mov   edi, [esp + $table]

   mov   edx, 1
   mov   ecx, [esp + $tablebits]
   dec   ecx        ; subtract 1 because we're doing STOSD

   shl   edx, cl    ; edx := 1 << tablebits
   
   mov   ecx, edx   ; store in ecx

   rep   stosd

   mov   eax, 1     ; success
   jmp   SHORT cleanup



bad_table:
   xor   eax, eax ; failure
   jmp   cleanup

_make_table ENDP
_TEXT   ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\ring16.h ===
/*
 * ring16.h
 */

/* ring buffer configuration */

#define     BUFFER_SIZE     (512)  /* must be 2^Nth */
#define     MIN_BUFFERS     3       /* minimum number we want */

#define     NUM_OUTPUT_BUFFER_PAGES    (CHUNK_SIZE/BUFFER_SIZE)

typedef struct aBuffer
{
  struct aBuffer FAR *pLinkNewer;   /* link to more recently used */
  struct aBuffer FAR *pLinkOlder;   /* link to less recently used */
  int BufferPage;                   /* what page this is, -1 -> invalid */
  int BufferDirty;                  /* NZ -> needs to be written */
  BYTE Buffer[BUFFER_SIZE];         /* content */
} BUFFER, FAR *PBUFFER;

typedef struct
{
  PBUFFER   pBuffer;            /* pointer to buffer, NULL if not present */
  int       last_chance_ptr;    /* index to last chance buffer table, or -1 */
  int       fDiskValid;         /* NZ -> this page has been written to disk */
} PAGETABLEENTRY;

typedef struct
{
    short Len;
    long  Dist;
} MATCH;

typedef struct
{
    char wildName[2];
    unsigned long fileSize;
} RINGNAME, FAR *PRINGNAME;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\ldi.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1993,1994
 *  All Rights Reserved.
 *
 *  LDI.H - Diamond Memory Decompression Interface (LDI)
 *
 *  History:
 *      03-Jul-1994     jforbes      Initial version.
 *
 *  Functions:
 *      LDICreateDecompression  - Create and reset an LDI decompression context
 *      LDIDecompress           - Decompress a block of data
 *      LDIResetDecompression   - Reset LDI decompression context
 *      LDIDestroyDecompression - Destroy LDI Decompression context
 *
 *  Types:
 *      LDI_CONTEXT_HANDLE      - Handle to an LDI decompression context
 *      PFNALLOC                - Memory allocation function for LDI
 *      PFNFREE                 - Free memory function for LDI
 */

/* --- types -------------------------------------------------------------- */
#include <basetsd.h>

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif

#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef unsigned char  BYTE;
#endif

#ifndef _UINT_DEFINED
#define _UINT_DEFINED
typedef unsigned int  UINT;
#endif

#ifndef _ULONG_DEFINED
#define _ULONG_DEFINED
typedef unsigned long  ULONG;
#endif

#ifndef NEAR
#  ifdef BIT16
#     define NEAR __near
#  else
#     define NEAR
#  endif
#endif

#ifndef FAR
#ifdef BIT16
#define FAR __far
#else
#define FAR
#endif
#endif

#ifndef HUGE
#ifdef BIT16
#define HUGE __huge
#else
#define HUGE
#endif
#endif

#ifndef _MI_MEMORY_DEFINED
#define _MI_MEMORY_DEFINED
typedef void HUGE *  MI_MEMORY;
#endif

#ifndef _MHANDLE_DEFINED
#define _MHANDLE_DEFINED
#if defined(_AMD64_) || defined(IA64)
typedef ULONG_PTR MHANDLE;
#else
typedef unsigned long  MHANDLE;
#endif
#endif

#ifndef UNALIGNED
#ifndef NEEDS_ALIGNMENT
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif


/*
 *  LDI will try to create a virtual ring buffer on disk if the pfnalloc call
 *  to create the buffer fails.  These functions provide LDI the disk access
 *  features needed.
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNOPEN oflag
 *  and pmode calls are those defined for _open.  LDI expects error
 *  handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *  For PFNOPEN, the pszFile parameter will take on a special form for LDI's
 *  temporary file.  The special form appears as a file named "*".  Such a
 *  name field should be cast into the struct below, which contains the
 *  required file's size as shown in the RINGNAME structure below.
 *
 *  Example open and close callbacks are provided.  It is assumed that the
 *  client will provide more adaptive code for determining the temporary
 *  file's name and drive location, based on environment variables and the
 *  amount of free disk space.  This sample code has hard-coded the actual
 *  path and fails if there is not enough free space.  This code creates the
 *  file, then attempts to expand it to the requested size by writing a byte
 *  (any byte) at the requested size - 1.  (This approach is not suitable for
 *  a file system which can support sparse files.)
 *
 *  The callback routine may create this file on any path, and with any name,
 *  as appropriate.  If the file cannot be created with the requested size,
 *  the PFNOPEN should fail.  The file really should be placed on a local
 *  fixed disk.  It would not be appropriate for the file to be placed on a
 *  compressed drive or a floppy disk.  If the client has access to alternate
 *  memory, such as XMS or EMS, these operations could be emuluated.
 *
 *  static int tempHandle = -1;
 *
 *  int FAR DIAMONDAPI MyOpen(char FAR *pszFile,int oflag,int pmode)
 *  {
 *      if (*pszFile == '*')
 *      {
 *          PRINGNAME pringDescriptor;
 *
 *          pringDescriptor = (PRINGNAME) pszFile;
 *
 *          tempHandle = _open("C:\\ldi_temp.$$$",oflag,pmode);
 *
 *          if (tempHandle != -1)
 *          {
 *              _lseek(tempHandle,(pringDescriptor->fileSize - 1),SEEK_SET);
 *
 *              if (_write(tempHandle,&tempHandle,1) != 1)
 *              {
 *                  _close(tempHandle);
 *                  remove("C:\\ldi_temp.$$$");
 *                  tempHandle = -1;
 *              }
 *          }
 *
 *          return(tempHandle);
 *      }
 *      else
 *      {
 *          * LDI only will call with *pszFile == '*' *
 *      }
 *  }
 *
 *  The callback provider must watch for the corresponding PFNCLOSE call on
 *  the returned handle, and delete the created file after closing.  (The
 *  file handle and file name assigned to the temporary file must be tracked;
 *  a close operation on that handle must be trapped, so the temporary file
 *  can be deleted as well.)
 *
 *  The client does not need to worry about multiple concurrent opens of the
 *  temporary file, or more than a single temporary file (from LDI).
 *
 *  int FAR DIAMONDAPI MyClose(int handle)
 *  {
 *      int result;
 *  
 *      result = _close(handle);
 *  
 *      if (handle == tempHandle)
 *      {
 *          remove("C:\\ldi_temp.$$$");
 *          tempHandle = -1;
 *      }
 *  
 *      return(result);
 *  }
 */
typedef int  (FAR DIAMONDAPI *PFNOPEN) (char FAR *pszFile,int oflag,int pmode);
typedef UINT (FAR DIAMONDAPI *PFNREAD) (int hf, void FAR *pv, UINT cb);
typedef UINT (FAR DIAMONDAPI *PFNWRITE)(int hf, void FAR *pv, UINT cb);
typedef int  (FAR DIAMONDAPI *PFNCLOSE)(int hf);
typedef long (FAR DIAMONDAPI *PFNSEEK) (int hf, long dist, int seektype);


/* --- LDI-defined types -------------------------------------------------- */

/* LDI_CONTEXT_HANDLE - Handle to a LDI decompression context */

typedef MHANDLE LDI_CONTEXT_HANDLE;      /* hmd */


/***    PFNALLOC - Memory allocation function for LDI
 *
 *  Entry:
 *      cb - Size in bytes of memory block to allocate
 *
 *  Exit-Success:
 *      Returns !NULL pointer to memory block
 *
 *  Exit-Failure:
 *      Returns NULL; insufficient memory
 */
#ifndef _PFNALLOC_DEFINED
#define _PFNALLOC_DEFINED
typedef MI_MEMORY (FAR DIAMONDAPI *PFNALLOC)(ULONG cb);       /* pfnma */
#endif


/***    PFNFREE - Free memory function for LDI
 *
 *  Entry:
 *      pv - Memory block allocated by matching PFNALLOC function
 *
 *  Exit:
 *      Memory block freed.
 */
#ifndef _PFNFREE_DEFINED
#define _PFNFREE_DEFINED
typedef void (FAR DIAMONDAPI *PFNFREE)(MI_MEMORY pv);          /* pfnmf */
#endif

/* --- prototypes --------------------------------------------------------- */

/***    LDICreateDecompression - Create LDI decompression context
 *
 *  Entry:
 *      pcbDataBlockMax     *largest uncompressed data block size expected,
 *                          gets largest uncompressed data block allowed
 *      pvConfiguration     passes implementation-specific info to decompressor.
 *      pfnma               memory allocation function pointer
 *      pfnmf               memory free function pointer
 *      pcbSrcBufferMin     gets max compressed buffer size
 *      pmdhHandle          gets newly-created context's handle
 *      pfnopen             file open function pointer (or NULL)
 *      pfnread             file read function pointer (or don't care)
 *      pfnwrite            file write function pointer (or don't care)
 *      pfnclose            file close function pointer (or don't care)
 *      pfnseek             file seek function pointer (or don't care)
 *
 *      If NULL is provided for pfnopen, and the ring buffer cannot be
 *      created via pfnma, LDICreateDecompression will fail.
 *
 *      If pmdhHandle==NULL, *pcbDataBlockMax and *pcbSrcBufferMin will be
 *      filled in, but no context will be created.  This query will allow
 *      the caller to determine required buffer sizes before creating a
 *      context.
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      *pcbDataBlockMax, *pcbSrcBufferMin, *pmdhHandle filled in.
 *
 *  Exit-Failure:
 *      MDI_ERROR_NOT_ENOUGH_MEMORY, could not allocate enough memory.
 *      MDI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 *      *pcbDataBlockMax, *pcbSrcBufferMin, *pmdhHandle undefined.
 */
int FAR DIAMONDAPI LDICreateDecompression(
        UINT FAR *      pcbDataBlockMax,  /* max uncompressed data block size */
        void FAR *      pvConfiguration,  /* implementation-defined */
        PFNALLOC        pfnma,            /* Memory allocation function ptr */
        PFNFREE         pfnmf,            /* Memory free function ptr */
        UINT FAR *      pcbSrcBufferMin,  /* gets max. comp. buffer size */
        LDI_CONTEXT_HANDLE FAR * pmdhHandle, /* gets newly-created handle */
        PFNOPEN         pfnopen,          /* open a file callback */
        PFNREAD         pfnread,          /* read a file callback */
        PFNWRITE        pfnwrite,         /* write a file callback */
        PFNCLOSE        pfnclose,         /* close a file callback */
        PFNSEEK         pfnseek);         /* seek in file callback */


/***    LDIDecompress - Decompress a block of data
 *
 *  Entry:
 *      hmd                 handle to decompression context
 *      pbSrc               source buffer (compressed data)
 *      cbSrc               compressed size of data to be decompressed
 *      pbDst               destination buffer (for decompressed data)
 *      *pcbDecompressed    (ptr to UINT) the expected de-compressed size
 *                          of this data block.  (same as cbSrc from the
 *                          LCICompress() call.).
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      *pcbDecompressed has size of decompressed data in pbDst.
 *      Decompression context updated.
 *
 *  Exit-Failure:
 *      MDI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 *      MDI_ERROR_BUFFER_OVERFLOW, cbSrc is too small to yield the
 *          requested *pcbDecompressed count.  cbSrc before LDIDecompressed
 *          should always equal *pcbResult after QCICompress(), and
 *          *pcbDecompressed before LDIDecompress should always equal the
 *          cbSrc before QCICompress().
 *      MDI_ERROR_FAILED, either cbSrc is too small, *pcbDecompressed is too
 *          large, or *pbSrc is corrupt.
 *
 *  Note:
 *      Set your cbDecompressed to the expected de-compressed size of this
 *      data block, then call LDIDecompress() with the address of your
 *      cbDecompressed.
 */
int FAR DIAMONDAPI LDIDecompress(
        LDI_CONTEXT_HANDLE  hmd,         /* decompression context */
        void FAR *          pbSrc,       /* source buffer */
        UINT                cbSrc,       /* source data size */
        void FAR *          pbDst,       /* target buffer */
        UINT FAR *          pcbDecompressed);  /* target data size */


/***    LDIResetDecompression - Reset decompression history (if any)
 *
 *  De-compression can only be started on a block which was compressed
 *  immediately following a MCICreateCompression() or MCIResetCompression()
 *  call.  This function provides notification to the decompressor that the
 *  next compressed block begins on a compression boundary.
 *
 *  Entry:
 *      hmd - handle to decompression context
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      Decompression context reset.
 *
 *  Exit-Failure:
 *      Returns MDI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI LDIResetDecompression(LDI_CONTEXT_HANDLE hmd);


/***    LDIDestroyDecompression - Destroy LDI decompression context
 *
 *  Entry:
 *      hmd - handle to decompression context
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      Decompression context destroyed.
 *
 *  Exit-Failure:
 *      Returns MDI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI LDIDestroyDecompression(LDI_CONTEXT_HANDLE hmd);


#ifndef BIT16
int FAR DIAMONDAPI LDIGetWindow(
        LDI_CONTEXT_HANDLE  hmd,            /* decompression context */
        BYTE FAR **         ppWindow,       /* pointer to window start */
        long *              pFileOffset,    /* offset in folder */
        long *              pWindowOffset,  /* offset in window */
        long *              pcbBytesAvail);   /* bytes avail from window start */
#endif


/* --- constants ---------------------------------------------------------- */

/* return codes */

#define     MDI_ERROR_NO_ERROR              0
#define     MDI_ERROR_NOT_ENOUGH_MEMORY     1
#define     MDI_ERROR_BAD_PARAMETERS        2
#define     MDI_ERROR_BUFFER_OVERFLOW       3
#define     MDI_ERROR_FAILED                4
#define     MDI_ERROR_CONFIGURATION         5

/* --- LZX configuration details ------------------------------------- */

/***    LZX pvConfiguration structure
 *
 *  For the LZX decompressor, two parameters are configurable, the
 *  "window bits", which defines the size of the buffer needed by the
 *  the decompressor (must match the value used to compress), and the CPU
 *  type, which controls whether 386 opcodes will be used or not.  If
 *  "unknown" is provided for the fCPUtype, LDI will attempt to determine
 *  the CPU type itself, which could fail or produce system faults on
 *  non-DOS platforms (like Windows.)  Windows apps should use GetWinFlags()
 *  or a similiar method, and never pass "unknown".
 *
 *  pvConfiguration points to this structure.
 */

#pragma pack (1)

typedef struct {
    long	WindowSize;         /* buffersize */
    long	fCPUtype;           /* controls internal code selection */
} LZXDECOMPRESS; /* qdec */

#pragma pack ()

typedef LZXDECOMPRESS *PLZXDECOMPRESS; /* pldec */
typedef LZXDECOMPRESS FAR *PFLZXDECOMPRESS; /* pfldec */

/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 *
 *   LDI_CPU_UNKNOWN detection does *not* work when running under Windows
 *                   in 286 protected mode!  Call GetWinFlags() to determine
 *                   the CPU type and pass it explicitly!
 */

#define     LDI_CPU_UNKNOWN         (-1)    /* internally determined */

/*
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 */

#define     LDI_CPU_80286           (0)     /* '286 opcodes only */
#define     LDI_CPU_80386           (1)     /* '386 opcodes used */
#define     LDI_CPU_CONSERVATIVE    (LDI_CPU_80286)

/* ----------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\blkinit.c ===
/*
 * blkinit.c
 *
 * Block outputting initialisation
 */
#include "encoder.h"


/*
 * Create lookup table for MP_SLOT() macro
 */
void create_slot_lookup_table(t_encoder_context *context)
{
   int			j;
   int 			p;
   int 			elements_to_init;
   byte   		slotnum;

   context->enc_slot_table[0] = 0;
   context->enc_slot_table[1] = 1;
   context->enc_slot_table[2] = 2;
   context->enc_slot_table[3] = 3;

   elements_to_init = 2;

   slotnum = 4;
   p       = 4;

   do
   {
      for (j = elements_to_init; j > 0; j--)
         context->enc_slot_table[p++] = slotnum;

      slotnum++;

      for (j = elements_to_init; j > 0; j--)
         context->enc_slot_table[p++] = slotnum;

      slotnum++;
      elements_to_init <<= 1;

   } while (p < 1024);
}


/*
 * Create lookup table for figuring out how many
 * ones there are in a given byte.
 */
void create_ones_table(t_encoder_context *context)
{
	int			i, j;
	byte		ones;

	for (i = 0; i < 256; i++)
	{
		ones = 0;

		for (j = i; j; j >>= 1)
		{
			if (j & 1)
				ones++;
		}

		context->enc_ones[i] = ones;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\decoder\xlatasm.asm ===
;
; asm_decoder_translate_e8()
;
; Assembly implementation of this from decxlat.c
;
; 26-Jul-96  jforbes  Initial version
;
	TITLE	XLATASM.ASM
	.386P
.model FLAT

PUBLIC  _asm_decoder_translate_e8

OFFSET_INSTR_POS    equ 28
OFFSET_FILE_SIZE    equ 32
OFFSET_MEM          equ 36
OFFSET_BYTES        equ 40

;
; ulong asm_decoder_translate_e8(instr_pos, file_size, mem *, bytes)
;
; returns new instr_pos in EAX
;
_TEXT	SEGMENT
_asm_decoder_translate_e8 PROC NEAR

    push    ebx
    push    ecx
    push    edx
    push    esi
    push    edi
    push    ebp

; edx = bytes
    mov     edx, DWORD PTR [esp + OFFSET_BYTES]

; if (bytes >= 6)
    cmp     edx, 6
    jge     greater_than_6_bytes

;
; less than 6 bytes to translate, so don't translate
;

; instr_pos += bytes
    add     edx, [esp + OFFSET_INSTR_POS]

; return new instr_pos in eax
    mov     eax, edx

    pop     ebp
    pop     edi
    pop     esi
    pop     edx
    pop     ecx
    pop     ebx
    ret     0



greater_than_6_bytes:

; ebp = current_file_size
    mov     ebp, DWORD PTR [esp + OFFSET_FILE_SIZE]

; ebx = 0xE8, our magic number
    mov     ebx, 0E8h ; 232

; esi = instr_pos
    mov     esi, DWORD PTR [esp + OFFSET_INSTR_POS]

; ecx = mem
    mov     ecx, DWORD PTR [esp + OFFSET_MEM]

; edi = instr_pos + bytes - 6
    mov     edi, esi
    add     edi, edx
    sub     edi, 6

; backup the last 6 bytes in the buffer
    sub     esp, 6

; eax = &mem[bytes-6]
    mov     eax, ecx
    add     eax, edx
    sub     eax, 6

    mov     edx, [eax]
    mov     [esp], edx

    mov     dx, WORD PTR [eax+4]
    mov     WORD PTR [esp+4], dx

; now store 0xE8's in there
    mov     DWORD PTR [eax], 0E8E8E8E8h
    mov     WORD PTR [eax+4], 0E8E8h

; save &mem[bytes-6]
    push    eax


;
; main loop
;
; eax = temporary
; ebx = 0xE8
; ecx = source ptr
; edx = temporary
; esi = instr pos
; edi = end_instr_pos
; ebp = current_file_size
;

loop_top:

;
; while (*mem++ != 0xE8)
;     ;

; eax = mem before                  
    mov     eax, ecx                ; u1
    nop                             ; v1

main_subloop:
    cmp     bl, [ecx]               ; u2
    je      SHORT equals_e8         ; v1

    cmp     bl, [ecx+1]             ; u2
    je      SHORT pre1              ; v1

    cmp     bl, [ecx+2]             ; u2
    je      SHORT pre2              ; v1

    cmp     bl, [ecx+3]             ; u2
    je      SHORT pre3              ; v1

    add     ecx, 4                  ; u1
    jmp     SHORT main_subloop      ; v1


pre3:
    add     ecx, 3                  ; u1
    jmp     SHORT equals_e8         ; v1

pre2:
    add     ecx, 2                  ; u1
    jmp     SHORT equals_e8         ; v1

pre1:
    inc     ecx

equals_e8:

; instr_pos += bytes visited in above loop
; esi := esi + (ecx - eax)
    sub     esi, eax                ; u1
    add     esi, ecx                ; v1

;
; Here is the only place we check for the end.
;
; We can do this because we force an 0xE8 at the end
; of the buffer.
;
; We cannot overlap the MOV below in between the
; cmp/jge, because ecx+1 may point to invalid memory.
;
    cmp     esi, edi                ; u1
    jge     SHORT bottom            ; v1

; eax = absolute = *(long *) mem
    mov     eax, [ecx+1]            ; u1
    add     ecx, 5                  ; v1  memptr += 5

;
; if (absolute < current_file_size && absolute >= 0)
;
; use unsigned comparison here so that if absolute < 0
; then it seems like it's some huge number
;
; this way we only do one comparison, abs >= file_size
;
    cmp     eax, ebp                ; u1
    jae     SHORT second_check      ; v1

;
; instead of doing "offset = absolute - instr_pos" and
; then storing it, we just say *mem -= instr_pos
;
; instead of:
;
;    sub     eax, esi
;    mov     [ecx-4], eax
;
; we do:

    sub     [ecx-4], esi            ; u3
    add     esi, 5                  ; v1  instr_pos += 5

    mov     eax, ecx                ; u1  (copied from loop_top)
    jmp     SHORT main_subloop      ; v1


;
; we want (absolute < 0) && (absolute >= -instr_pos)
;
; which can be rewritten as:
;
;         (-absolute > 0) && (-absolute - instr_pos <= 0)
;
; then:
;
;         (-absolute > 0) && (-absolute <= instr_pos)
;
; we can do both of these checks by checking with
; unsigned arithmetic, since if absolute < 0 then it
; will seem like some huge number:
;
; if ((ulong) (-(long) absolute) <= instr_pos)
;
; note: absolute==0 is taken care of in the first case
;
second_check:

; edx = instr_pos + absolute

    neg     eax                 ; u

    cmp     eax, esi            ; u1
    ja      SHORT no_conversion ; v1

;
; instead of storing "offset = absolute + current_file_size"
; we can do *mem += file_size.
;
; instead of doing:
;
;    neg     eax
;    add     eax, ebp
;    mov     DWORD PTR [ecx-4], eax
;
; we do:

    add     [ecx-4], ebp         ; u3

no_conversion:

; instr_pos += 5
    add     esi, 5               ; v1    u1
    jmp     SHORT loop_top       ;       v1


bottom:

; instr_pos = end_instr_pos + 6
    add     edi, 6

; restore the 6 bytes

; get &mem[bytes-6]
    pop     eax

    mov     edx, DWORD PTR [esp]
    mov     DWORD PTR [eax], edx

    mov     dx, WORD PTR [esp+4]
    mov     WORD PTR [eax+4], dx

    add     esp, 6

; return new instr_pos in eax
    mov     eax, edi

    pop     ebp
    pop     edi
    pop     esi
    pop     edx
    pop     ecx
    pop     ebx
    ret     0
_asm_decoder_translate_e8 ENDP
_TEXT	ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\bsearch.c ===
/*
 * bsearch.c
 *
 * Binary search for optimal encoder
 */
#include "encoder.h"


#define left    context->enc_Left
#define right   context->enc_Right


/*
 * Define this to force checking that all search locations visited
 * are valid.
 *
 * For debugging purposes only.
 */
#ifdef _DEBUG
#   define VERIFY_SEARCHES
#endif

#define VERIFY_SEARCH_CODE(routine_name) \
{ \
	int debug_search; \
	for (debug_search = 0; debug_search < clen; debug_search++) \
	{ \
		if (context->enc_MemWindow[ptr+debug_search] != context->enc_MemWindow[BufPos+debug_search]) \
		{ \
			_RPT2( \
				_CRT_WARN, \
				routine_name \
				" char mismatch @%3d (clen=%d)\n", \
				debug_search, clen); \
			\
			_RPT3( \
				_CRT_WARN, \
				" ptr=%8d, bufpos=%8d, end_pos=%8d\n\n", \
				ptr, BufPos, end_pos); \
		} \
	} \
}

#define VERIFY_MULTI_TREE_SEARCH_CODE(routine_name) \
_ASSERTE (context->enc_MemWindow[BufPos] == context->enc_MemWindow[ptr]); \
_ASSERTE (context->enc_MemWindow[BufPos+1] == context->enc_MemWindow[ptr+1]);



/*
 * Finds the closest matches of all possible lengths, MIN_MATCH <= x <= MAX_MATCH,
 * at position BufPos.
 *
 * The positions of each match location are stored in context->enc_matchpos_table[]
 *
 * Returns the longest such match length found, or zero if no matches found.
 */

#ifndef ASM_BSEARCH_FINDMATCH
long binary_search_findmatch(t_encoder_context *context, long BufPos)
{
	ulong       ptr;
	ulong       a, b;
	ulong       *small_ptr, *big_ptr;
	ulong       end_pos;
	int         val; /* must be signed */
	int         bytes_to_boundary;
	int         clen;
	int         same;
	int         match_length;
	int         small_len, big_len;
	int         i, best_repeated_offset;
#ifdef MULTIPLE_SEARCH_TREES
	ushort      tree_to_use;

	/*
	 * Retrieve root node of tree to search, and insert current node at
	 * the root.
	 */
	tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);
	
	ptr        = context->enc_tree_root[tree_to_use];
	context->enc_tree_root[tree_to_use] = BufPos;
#else
	ptr = context->enc_single_tree_root;
	context->enc_single_tree_root = BufPos;
#endif
	/*
	 * end_pos is the furthest location back we will search for matches 
	 *
	 * Remember that our window size is reduced by 3 bytes because of
	 * our repeated offset codes.
	 *
	 * Since BufPos starts at context->enc_window_size when compression begins,
	 * end_pos will never become negative.  
	 */
	end_pos = BufPos - (context->enc_window_size-4);

	/*
	 * Root node is either NULL, or points to a really distant position.
	 */
	if (ptr <= end_pos)
	{
		left[BufPos] = right[BufPos] = 0;
		return 0;
	}

#ifdef MULTIPLE_SEARCH_TREES
	/*
	 * confirmed length (no need to check the first clen chars in a search)
	 *
	 * note: clen is always equal to min(small_len, big_len)
	 */
	clen            = 2;

	/*
	 * current best match length
	 */
	match_length    = 2;

	/*
	 * longest match which is < our string
	 */
	small_len       = 2;

	/*
	 * longest match which is > our string
	 */
	big_len         = 2;

	/*
	 * record match position for match length 2
	 */
	context->enc_matchpos_table[2] = BufPos - ptr + 2;

#ifdef VERIFY_SEARCHES
	VERIFY_MULTI_TREE_SEARCH_CODE("binary_search_findmatch()");
#endif

#else /* !MULTIPLE_SEARCH_TREES */

	clen            = 0;
	match_length    = 0;
	small_len       = 0;
	big_len         = 0;

#endif /* MULTIPLE_SEARCH_TREES */

	/*
	 * pointers to nodes to check
	 */
	small_ptr             = &left[BufPos];
	big_ptr               = &right[BufPos];

	do
	{
		/* compare bytes at current node */
		same = clen;

#ifdef VERIFY_SEARCHES
		VERIFY_SEARCH_CODE("binary_search_findmatch()")
#endif

		/* don't need to check first clen characters */
		a    = ptr + clen;
		b    = BufPos + clen;

		while ((val = ((int) context->enc_MemWindow[a++]) - ((int) context->enc_MemWindow[b++])) == 0)
		{
			/* don't exceed MAX_MATCH */
			if (++same >= MAX_MATCH)
				goto long_match;
		}

		if (val < 0)
		{
			if (same > big_len)
			{
				if (same > match_length)
				{
long_match:
					do
					{
						context->enc_matchpos_table[++match_length] = BufPos-ptr+(NUM_REPEATED_OFFSETS-1);
					} while (match_length < same);

					if (same >= BREAK_LENGTH)
					{
						*small_ptr = left[ptr];
						*big_ptr   = right[ptr];
						goto end_bsearch;
					}
				}

				big_len = same;
				clen = (((small_len) < (big_len)) ? (small_len) : (big_len));
			}

			*big_ptr = ptr;
			big_ptr  = &left[ptr];
			ptr      = *big_ptr;
		}
		else
		{
			if (same > small_len)
			{
				if (same > match_length)
				{
					do
					{
						context->enc_matchpos_table[++match_length] = BufPos-ptr+(NUM_REPEATED_OFFSETS-1);
					} while (match_length < same);

					if (same >= BREAK_LENGTH)
					{
						*small_ptr = left[ptr];
						*big_ptr   = right[ptr];
						goto end_bsearch;
					}
				}

				small_len = same;
				clen = (((small_len) < (big_len)) ? (small_len) : (big_len));
			}
		
			*small_ptr = ptr;
			small_ptr  = &right[ptr];
			ptr        = *small_ptr;
		}
	} while (ptr > end_pos); /* while we don't go too far backwards */

	*small_ptr = 0;
	*big_ptr   = 0;


end_bsearch:

	/*
	 * If we have multiple search trees, we are already guaranteed
	 * a minimum match length of 2 when we reach here.
	 *
	 * If we only have one tree, then we're not guaranteed anything.
	 */
#ifndef MULTIPLE_SEARCH_TREES
	if (match_length < MIN_MATCH)
		return 0;
#endif

	/*
	 * Check to see if any of our match lengths can 
	 * use repeated offsets.
	 */

	/*
	 * repeated offset 1 
	 */
	for (i = 0; i < match_length; i++)
	{
		if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[0]+i])
			break;
	}

	/*
	 * the longest repeated offset
	 */
	best_repeated_offset = i;

	if (i >= MIN_MATCH)
	{
		/*
		 * Yes, we can do a repeated offset for some match lengths; replace
		 * their positions with the repeated offset position
		 */
		do
		{
			context->enc_matchpos_table[i] = 0; /* first repeated offset position */
		} while (--i >= MIN_MATCH);

		/* A speed optimization to cope with long runs of bytes */
		if (best_repeated_offset > BREAK_LENGTH)
			goto quick_return;
	}

	/*
	 * repeated offset 2 
	 */
	for (i = 0; i < match_length; i++)
	{
		if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[1]+i])
			break;
	}
		
	/*
	 * Does the second repeated offset provide a longer match?
	 *
	 * If so, leave the first repeated offset alone, but fill out the
	 * difference in match lengths in the table with repeated offset 1.
	 */
	if (i > best_repeated_offset)
	{               
		do
		{
			context->enc_matchpos_table[++best_repeated_offset] = 1;
		} while (best_repeated_offset < i);
	}

	/* 
	 * repeated offset 3 
	 */
	for (i = 0; i < match_length; i++)
	{
		if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[2]+i])
			break;
	}
		
	/*
	 * Does the third repeated offset provide a longer match?
	 */
	if (i > best_repeated_offset)
	{               
		do
		{
			context->enc_matchpos_table[++best_repeated_offset] = 2;
		} while (best_repeated_offset < i);
	}

quick_return:

	/*
	 * Don't let a match cross a 32K boundary
	 */
	bytes_to_boundary = (CHUNK_SIZE-1) - ((int) BufPos & (CHUNK_SIZE-1));

	if (match_length > bytes_to_boundary)
	{
		match_length = bytes_to_boundary;
		
		if (match_length < MIN_MATCH)
			match_length = 0;
	}

	return (long) match_length;
}
#endif


/*
 * Inserts the string at the current BufPos into the tree.
 *
 * Does not record all the best match lengths or otherwise attempt
 * to search for matches
 *
 * Similar to the above function.
 */
#ifndef ASM_QUICK_INSERT_BSEARCH_FINDMATCH
void quick_insert_bsearch_findmatch(t_encoder_context *context, long BufPos, long end_pos)
{
	long        ptr;
	ulong       a,b;
	ulong       *small_ptr, *big_ptr;
	int         val;
	int         small_len, big_len;
	int         same;
	int         clen;
#ifdef MULTIPLE_SEARCH_TREES
	ushort      tree_to_use;

	tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);
	ptr        = context->enc_tree_root[tree_to_use];
	context->enc_tree_root[tree_to_use] = BufPos;
#else
	ptr = context->enc_single_tree_root;
	context->enc_single_tree_root = BufPos;
#endif

	if (ptr <= end_pos)
	{
		left[BufPos] = right[BufPos] = 0;
		return;
	}

#ifdef MULTIPLE_SEARCH_TREES
	clen            = 2;
	small_len       = 2;
	big_len         = 2;

#ifdef VERIFY_SEARCHES
	VERIFY_MULTI_TREE_SEARCH_CODE("quick_insert_bsearch_findmatch()");
#endif

#else
	clen            = 0;
	small_len       = 0;
	big_len         = 0;
#endif

	small_ptr       = &left[BufPos];
	big_ptr         = &right[BufPos];

	do
	{
		_ASSERTE ((ulong) ptr >= (ulong) (context->enc_RealLeft - context->enc_Left));

		same = clen;

		a    = ptr+clen;
		b    = BufPos+clen;

#ifdef VERIFY_SEARCHES
		VERIFY_SEARCH_CODE("quick_insert_bsearch_findmatch()")
#endif

		while ((val = ((int) context->enc_MemWindow[a++]) - ((int) context->enc_MemWindow[b++])) == 0)
		{
			/*
			 * Here we break on BREAK_LENGTH, not MAX_MATCH
			 */
			if (++same >= BREAK_LENGTH) 
				break;
		}

		if (val < 0)
		{
			if (same > big_len)
			{
				if (same >= BREAK_LENGTH)
				{
					*small_ptr = left[ptr];
					*big_ptr = right[ptr];
					return;
				}

				big_len = same;
				clen = (((small_len) < (big_len)) ? (small_len) : (big_len));
			}
			
			*big_ptr = ptr;
			big_ptr  = &left[ptr];
			ptr      = *big_ptr;
		}
		else
		{
			if (same > small_len)
			{
				if (same >= BREAK_LENGTH)
				{
					*small_ptr = left[ptr];
					*big_ptr = right[ptr];
					return;
				}

				small_len = same;
				clen = (((small_len) < (big_len)) ? (small_len) : (big_len));
			}

			*small_ptr = ptr;
			small_ptr  = &right[ptr];
			ptr        = *small_ptr;
		}
   } while (ptr > end_pos);

	*small_ptr = 0;
	*big_ptr   = 0;
}
#endif


/*
 * Remove a node from the search tree; this is ONLY done for the last
 * BREAK_LENGTH symbols (see optenc.c).  This is because we will have
 * inserted strings that contain undefined data (e.g. we're at the 4th
 * last byte from the file and binary_search_findmatch() a string into
 * the tree - everything from the 4th symbol onwards is invalid, and
 * would cause problems if it remained in the tree, so we have to
 * remove it).
 */
void binary_search_remove_node(t_encoder_context *context, long BufPos, ulong end_pos)
{
	ulong   ptr;
	ulong   left_node_pos;
	ulong   right_node_pos;
	ulong   *link;
#ifdef MULTIPLE_SEARCH_TREES
	ushort  tree_to_use;

	/*
	 * The root node of tree_to_use should equal BufPos, since that is
	 * the most recent insertion into that tree - but if we never
	 * inserted this string (because it was a near match or a long
	 * string of zeroes), then we can't remove it.
	 */
	tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);


	/*
	 * If we never inserted this string, do not attempt to remove it
	 */

	if (context->enc_tree_root[tree_to_use] != (ulong) BufPos)
		return;

	link = &context->enc_tree_root[tree_to_use];
#else
	if (context->enc_single_tree_root != (ulong) BufPos)
		return;

	link = &context->enc_single_tree_root;
#endif

	/*
	 * If the last occurence was too far away
	 */
	if (*link <= end_pos)
	{
		*link = 0;
		left[BufPos] = right[BufPos] = 0;
		return;
	}

	/*
	 * Most recent location of these chars
	 */
	ptr             = BufPos;

	/*
	 * Most recent location of a string which is "less than" it
	 */
	left_node_pos   = left[ptr];

	if (left_node_pos <= end_pos)
		left_node_pos = left[ptr] = 0;

	/*
	 * Most recent location of a string which is "greater than" it
	 */
	right_node_pos  = right[ptr];

	if (right_node_pos <= end_pos)
		right_node_pos = right[ptr] = 0;

	while (1)
	{
#ifdef VERIFY_SEARCHES
		_ASSERTE (left_node_pos < (ulong) BufPos);
		_ASSERTE (right_node_pos < (ulong) BufPos);
#endif

		/*
		 * If left node position is greater than right node position
		 * then follow the left node, since that is the more recent
		 * insertion into the tree.  Otherwise follow the right node.
		 */
		if (left_node_pos > right_node_pos)
		{
			/*
			 * If it's too far away, then store that it never happened
			 */
			if (left_node_pos <= end_pos)
				left_node_pos = 0;

			ptr = *link = left_node_pos;

			if (!ptr)
				break;

			left_node_pos   = right[ptr];
			link            = &right[ptr];
		}
		else
		{
			/*
			 * If it's too far away, then store that it never happened
			 */
			if (right_node_pos <= end_pos)
				right_node_pos = 0;

			ptr = *link = right_node_pos;

			if (!ptr) 
				break;

			right_node_pos  = left[ptr];
			link            = &left[ptr];
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\encapi.c ===
/*
 * encapi.c
 *
 * Encoder API entrypoints.
 */

#define ALLOC_VARS
#include "encoder.h"


bool LZX_EncodeInit(

	t_encoder_context *context,

	long compression_window_size,
	long second_partition_size,

	PFNALLOC pfnma,
	PFNFREE pfnmf,
	
	int FAR (DIAMONDAPI *pfnlzx_output_callback)(
			void *			pfol,
			unsigned char *	compressed_data,
			long			compressed_size,
			long			uncompressed_size
    ),

    void *fci_data
)
{
#ifdef _DEBUG
	_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
	_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);
	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
	_CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);
	_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
	_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT);
#endif

    /* to pass back in lzx_output_callback() */
    context->enc_fci_data = fci_data;

	context->enc_window_size = compression_window_size;

	/*
	 * The second partition size must be a multiple of 32K
	 */
	if (second_partition_size & (CHUNK_SIZE-1))
		second_partition_size &= (~(CHUNK_SIZE-1));

	/*
	 * The minimum allowed is 32K because of the way that
	 * our translation works.
	 */
	if (second_partition_size < CHUNK_SIZE)
		second_partition_size = CHUNK_SIZE;

	/*
	 * Our window size must be at least 32K
	 */
	if (compression_window_size < CHUNK_SIZE)
		return false;

	context->enc_encoder_second_partition_size = second_partition_size;
	context->enc_output_callback_function = pfnlzx_output_callback;

	context->enc_malloc	= pfnma;
	context->enc_free	= pfnmf;

	/* Error allocating memory? */
	if (comp_alloc_compress_memory(context) == false)
		return false;

	LZX_EncodeNewGroup(context);

	return true;
}


/*
 * Cleanup (frees memory)
 */
void LZX_EncodeFree(t_encoder_context *context)
{
	comp_free_compress_memory(context);
}


/*
 * Sets up the encoder for a new group of files.
 *
 * All this does is reset the lookup table, re-initialise to the
 * default match estimation tables for the optimal parser, and
 * reset a few variables.
 */
void LZX_EncodeNewGroup(t_encoder_context *context)
{
	init_compression_memory(context);
}


long LZX_Encode(
	t_encoder_context *context,	
	byte *input_data,
	long input_size,
	long *estimated_bytes_compressed,
	long file_size_for_translation
)
{
	context->enc_input_ptr	= input_data;
	context->enc_input_left	= input_size;

	context->enc_file_size_for_translation = file_size_for_translation;

	/* perform the encoding */
	encoder_start(context);

    if (context->enc_output_overflow)
    {
        *estimated_bytes_compressed = 0;
        return ENCODER_WRITE_FAILURE;
    }

	*estimated_bytes_compressed = estimate_buffer_contents(context);

	return ENCODER_SUCCESS;
}


bool LZX_EncodeFlush(t_encoder_context *context)
{
	flush_all_pending_blocks(context);

    if (context->enc_output_overflow)
        return false;

    return true;
}


unsigned char *LZX_GetInputData(
    t_encoder_context *context,
    unsigned long *input_position,
    unsigned long *bytes_available
)
{
    unsigned long filepos;

    // note that BufPos-window_size is the real position in the file
    filepos = context->enc_BufPos - context->enc_window_size;

    if (filepos < context->enc_window_size)
    {
        *input_position = 0;
        *bytes_available = filepos;
        return &context->enc_MemWindow[context->enc_window_size];
    }
    else
    {
        *input_position = filepos - context->enc_window_size;
        *bytes_available = context->enc_window_size;
        return &context->enc_MemWindow[context->enc_BufPos - context->enc_window_size];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\encmacro.h ===
/*
 * encmacro.h
 *
 * Encoder macros
 */


/*
 * Returns the slot number of a match position (uses table lookup) 
 */
#define MP_SLOT(matchpos) \
   ((matchpos) < 1024 ?										\
		(byte) context->enc_slot_table[(matchpos)] :					\
			( (matchpos) < 524288L ?						\
				(byte) 18 + (byte) context->enc_slot_table[(matchpos) >> 9] :   \
				((byte) 34 + (byte) ((matchpos) >> 17))		\
		)													\
   )


/*
 * Is a given literal a match or an unmatched symbol?
 */
#define IsMatch(literal) (context->enc_ItemType[(literal) >> 3] & (1 << ((literal) & 7)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\encapi.h ===
/*
 * encapi.h
 *
 * Definitions for calling LZX apis (encapi.c)
 */

/*
 * Return codes for LZX_Encode()
 */
#define ENCODER_SUCCESS			0
#define ENCODER_READ_FAILURE 	1
#define ENCODER_WRITE_FAILURE 	2
#define ENCODER_CONSOLE_FAILURE	3


bool LZX_EncodeInit(

	t_encoder_context *	context,
	long				compression_window_size,
	long				second_partition_size,
	PFNALLOC			pfnma,
	PFNFREE				pfnmf,

	int FAR (DIAMONDAPI *pfnlzx_output_callback)(
			void *			pfol,
			unsigned char *	compressed_data,
			long			compressed_size,
			long			uncompressed_size
    ),

    void FAR *          fci_data
);

void LZX_EncodeFree(t_encoder_context *context);

void LZX_EncodeNewGroup(t_encoder_context *context);

long LZX_Encode(
	t_encoder_context *	context,
	byte *				input_data,
	long				input_size,
	long *				bytes_compressed,
	long				file_size_for_translation
);

bool LZX_EncodeFlush(t_encoder_context *context);

unsigned char *LZX_GetInputData(
    t_encoder_context *context,
    unsigned long *input_position,
    unsigned long *bytes_available
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\block.c ===
/*
 * block.c
 *
 * LZX block outputting
 */

#include "encoder.h"


/*
 * Internal function definitions
 */
static void do_block_output(
	t_encoder_context *context,
	long literal_to_end_at,
	long distance_to_end_at
);


static void do_block_output(
	t_encoder_context *context,
	long literal_to_end_at,
	long distance_to_end_at
)
{
	ulong			bytes_compressed;
	lzx_block_type	block_type;
	ulong			estimated_block_size;

	/*
	 * Calculate frequencies for all tree elements.
	 *
	 * How many uncompressed bytes does this account for? 
	 */
	bytes_compressed = get_block_stats(
		context,
		0, 
		0, 
		literal_to_end_at
	);

	/*
	 * Determine whether we wish to output a verbatim block or an
	 * aligned offset block
	 */
	block_type = get_aligned_stats(context, distance_to_end_at);

	/*
	 * Create trees from the frequency data 
	 */
	create_trees(context, true); /* we want to generate the codes too */

	/*
	 * Determine whether the block should be output as uncompressed
	 */
	estimated_block_size = estimate_compressed_block_size(context);

	if (estimated_block_size >= bytes_compressed)
	{
		if (context->enc_bufpos_at_last_block >= context->enc_earliest_window_data_remaining)
			block_type = BLOCKTYPE_UNCOMPRESSED;
	}

	output_bits(context, 3, (byte) block_type);

	/* output 24 bit number, number of bytes compressed here */
	output_bits(context, 8,  (bytes_compressed >> 16) & 255);
	output_bits(context, 8,  ((bytes_compressed >> 8) & 255));
	output_bits(context, 8,  (bytes_compressed & 255));

	if (block_type == BLOCKTYPE_VERBATIM)
	{
		encode_trees(context);
		encode_verbatim_block(context, literal_to_end_at);
		get_final_repeated_offset_states(context, distance_to_end_at);
	}
	else if (block_type == BLOCKTYPE_ALIGNED)
	{
		encode_aligned_tree(context);
		encode_trees(context);
		encode_aligned_block(context, literal_to_end_at);
		get_final_repeated_offset_states(context, distance_to_end_at);
	}
	else if (block_type == BLOCKTYPE_UNCOMPRESSED)
	{
		get_final_repeated_offset_states(context, distance_to_end_at);
		encode_uncompressed_block(context, context->enc_bufpos_at_last_block, bytes_compressed);
	}

	context->enc_bufpos_at_last_block += bytes_compressed;
}


/*
 * Returns the number of distances which correspond
 * to this number of literals
 */
ulong get_distances_from_literals(t_encoder_context *context, ulong literals)
{
	ulong	d = 0;
	ulong	i;

	for (i = 0; i < (literals >> 3); i++)
		d += context->enc_ones[ context->enc_ItemType[i] ];

	/*
	 * Handle remaining 0...7
	 */
	for (i = (literals & (~7)); i < literals; i++)
	{
		if (IsMatch(i))
			d++;
	}

	return d;
}


/*
 * Output a block
 *
 * If trees_only is true, then only the tree statistics are updated.
 */
void output_block(t_encoder_context *context)
{
	ulong	where_to_split;
	ulong	distances;

    //
    // We have now output a block.
    //
    // We set this here in case someone calls LCIFlushOutput, so that
    // we don't try to redo the first chunk of bytes in the file
    // (since we've been forced to output them)
    //
    context->enc_first_block = 0;

	(void) split_block(
		context,
		0,
		context->enc_literals,
		context->enc_distances,
		&where_to_split,
		&distances /* distances @ literal == where_to_split */
	);

	do_block_output(context, where_to_split, distances);

	if (where_to_split == context->enc_literals)
	{
		/*
		 * If we've output ALL of our literals, then clear the itemtype array
		 */
		memset(context->enc_ItemType, 0, MAX_LITERAL_ITEMS/8);

		context->enc_literals	= 0;
		context->enc_distances	= 0;
	}
	else
	{
		/*
		 * If we didn't output all of our literals, then move the literals
		 * and distances we didn't use, to the beginning of the list
		 */
		memcpy(
			&context->enc_ItemType[0], 
			&context->enc_ItemType[where_to_split/8], 
			&context->enc_ItemType[1+(context->enc_literals/8)] - &context->enc_ItemType[where_to_split/8]
		);

		memset(
			&context->enc_ItemType[1+(context->enc_literals-where_to_split)/8], 
			0, 
			&context->enc_ItemType[MAX_LITERAL_ITEMS/8] - &context->enc_ItemType[1+(context->enc_literals-where_to_split)/8]
		);

		memcpy(
			&context->enc_LitData[0],  
			&context->enc_LitData[where_to_split],
			context->enc_literals-where_to_split
		);

		memcpy(
			&context->enc_DistData[0], 
			&context->enc_DistData[distances], 
			sizeof(ulong)*(context->enc_distances-distances)
		);

		context->enc_literals  -= where_to_split;
		context->enc_distances -= distances;
	}

	fix_tree_cost_estimates(context);
}


void flush_output_bit_buffer(t_encoder_context *context)
{

	byte temp;

	if (context->enc_bitcount < 32)
	{
		temp = context->enc_bitcount-16;

		output_bits(context, temp, 0);
	}
}


/*
 * Estimate how much it would take to output the compressed
 * data left in the buffer
 */
long estimate_buffer_contents(t_encoder_context *context)
{
	long			estimated_block_size;

	/*
	 * Use frequency data sitting around from last tree creation
	 */
	create_trees(context, false); /* don't generate codes */

	estimated_block_size = estimate_compressed_block_size(context);

	/* so the optimal parser doesn't get confused */
	fix_tree_cost_estimates(context);

	return estimated_block_size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\encoder.h ===
/*
 * encoder.h
 *
 * Main header file; includes everything else
 */

#ifndef ENCODER_H
#define ENCODER_H


#ifdef USE_ASSEMBLY
#   define ASM_BSEARCH_FINDMATCH
//#   define ASM_QUICK_INSERT_BSEARCH_FINDMATCH
#endif

#ifndef UNALIGNED
#ifndef NEEDS_ALIGNMENT
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif

#include <stdlib.h>
#include <string.h>

#if 0 // #ifdef _X86_
#include <crtdbg.h>
#else
#define _ASSERTE(x) ;
#define _RPT2(a,b,c,d) ;
#define _RPT3(a,b,c,d,e) ;
#define _CrtSetReportMode(a,b) ;
#define _CrtSetReportFile(a,b) ;
#endif

#include "../common/typedefs.h"
#include "../common/compdefs.h"
#include "encdefs.h"
#include "encvars.h"
#include "encmacro.h"
#include "encapi.h"
#include "encproto.h"

#endif  /* ENCODER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\encdefs.h ===
/*
 * encdefs.h
 *
 * Encoder #define's and structure definitions.
 */

/*
 * NOTES:
 *
 * To maximise compression one can set both BREAK_LENGTH
 * and FAST_DECISION_THRESHOLD to 250, define
 * INSERT_NEAR_LONG_MATCHES, and crank up EXTRA_SIZE to
 * a larger value (don't get too large, otherwise we
 * might overflow our ushort cumbits[]), but the improvement
 * is really  marginal; e.g. 3600 bytes on winword.exe
 * (3.9 MB compressed).  It really hurts performance too.
 */


/*
 * See optenc.c 
 *
 * EXTRA_SIZE is the amount of extra data we allocate in addition
 * to the window, and LOOK is the amount of data the optimal
 * parser will look ahead.  LOOK is dependent on EXTRA_SIZE.
 *
 * Changing EXTRA_SIZE to 8K doesn't really do anything for
 * compression.  4K is a fairly optimal value.
 *
 * Be careful; our cumbits[] array and counters are all
 * ushort's in optenc.c, so make sure they don't overflow
 * (e.g. outputting all LOOK bytes as 9 bit uncompressed
 * symbols, say).  If necessary, change the typedef in optenc.c
 * to ulong.
 */
#define EXTRA_SIZE   4096
#define LOOK		(EXTRA_SIZE-MAX_MATCH-2)


/* 
 * Number of search trees used (for storing root nodes)
 */
#define NUM_SEARCH_TREES 65536


/*
 * Chunk size required by FCI
 */
#define CHUNK_SIZE 32768


/*
 * The maximum amount of data we will allow in our output buffer before
 * calling lzx_output_callback() to get rid of it.  Since we do this
 * for every 32K of input data, the output buffer only has to be able
 * to contain 32K + some spillover, which won't be much, because we
 * output uncompressed blocks if we determine a block is going to be
 * too large.
 */
#define OUTPUT_BUFFER_SIZE (CHUNK_SIZE+MAX_GROWTH)


/*
 * Maximum allowable number of block splits per 32K of uncompressed
 * data; if increased, then MAX_GROWTH will have to be increased also.
 */
#define MAX_BLOCK_SPLITS    4


/*
 * Max growth is calculated as follows:
 *
 * TREE AND BLOCK INFO
 * ===================
 *
 * The very first time the encoder is run, it outputs a 32 bit
 * file translation size.
 *
 * 3 bits to output block type
 * 24 bits for block size in uncompressed bytes.
 *
 * Max size of a tree of n elements is 20*4 + 5*n bits
 *
 * There is a main tree of max 700 elements which is really encoded
 * as two separate trees of 256 and 444(max).  There is also a
 * secondary length tree of 249 elements.
 *
 * That is 1360 bits, plus 2300 bits, plus 1325 bits.
 *
 * There may also be an aligned offset tree, which is 24 bits.
 *
 * Flushing output bit buffer; max 16 bits.
 *
 * Grand total: 5084 bits/block.
 *
 *
 * PARSER INFO
 * ===========
 *
 * Parser worst case scenario is with 2 MB buffer (50 position slots),
 * all matches of length 2, distributed over slots 32 and 33 (since
 * matches of length 2 further away than 128K are prohibited).  These
 * slots have 15 verbatim bits.  Maximum size per code is then
 * 2 bits to say which slot (taking into account that there will be
 * at least another code in the tree) plus 15 verbatim bits, for a
 * total of 17 bits.  Max growth on 32K of input data is therefore
 * 1/16 * 32K, or 2K bytes.
 *
 * Alternatively, if there is only one match and everything else
 * is a character, then 255 characters will be length 8, and one
 * character and the match will be length 9.  Assume the true
 * frequency of the demoted character is almost a 1 in 2^7
 * probability (it got remoted from a 2^8, but it was fairly
 * close to being 2^7).  If there are 32768/256, or 128, occurrences
 * of each character, but, say, almost 256 for the demoted character,
 * then the demoted character will expand the data by less than
 * 1 bit * 256, or 256 bits.  The match will take a little to
 * output, but max growth for "all characters" is about 256 bits.
 *
 *
 * END RESULT
 * ==========
 *
 * The maximum number of blocks which can be output is limited to
 * 4 per 32K of uncompressed data.
 *
 * Therefore, max growth is 4*5084 bits, plus 2K bytes, or 4590
 * bytes.
 */
#define     MAX_GROWTH          6144

/*
 * Don't allow match length 2's which are further away than this
 * (see above)
 */
#define     MAX_LENGTH_TWO_OFFSET (128*1024)


/*
 * When we find a match which is at least this long, prematurely
 * exit the binary search.
 *
 * This avoids us inserting huge match lengths of 257 zeroes, for
 * example.  Compression will improve very *very* marginally by
 * increasing this figure, but it will seriously impact
 * performance.
 *
 * Don't make this number >= (MAX_MATCH-2); see bsearch.c.
 */
#define BREAK_LENGTH 50


/*
 * If this option is defined, the parser will insert all bytes of
 * matches with lengths >= 16 with a distance of 1; this is a bad
 * idea, since matches like that are generally zeroes, which we
 * want to avoid inserting into the search tree.
 */
//#define INSERT_NEAR_LONG_MATCHES


/*
 * If the optimal parser finds a match which is this long or
 * longer, it will take it automatically.  The compression
 * penalty is basically zero, and it helps performance.
 */
#define FAST_DECISION_THRESHOLD 50


/*
 * Every TREE_CREATE_INTERVAL items, recreate the trees from
 * the literals we've encountered so far, to update our cost
 * estimations.
 *
 * 4K seems pretty optimal.
 */
#define TREE_CREATE_INTERVAL 4096


/*
 * When we're forced to break in our parsing (we exceed
 * our span), don't output a match length 2 if it is
 * further away than this.
 *
 * Could make this a variable rather than a constant
 *
 * On a bad binary file, two chars    = 18 bits
 * On a good text file, two chars     = 12 bits
 *
 * But match length two's are very uncommon on text files.
 */
#define BREAK_MAX_LENGTH_TWO_OFFSET 2048


/*
 * When MatchPos >= MPSLOT3_CUTOFF, extra_bits[MP_SLOT(MatchPos)] >= 3
 *
 * matchpos:  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
 * extrabits: 0,0,0,0,1,1,1,1,2,2, 2, 2, 2, 2, 2, 2, 3, ...
 *
 * Used for aligned offset blocks and statistics.
 */
#define MPSLOT3_CUTOFF 16


/*
 * Number of elements in the main tree
 */
#define MAIN_TREE_ELEMENTS			(NUM_CHARS+(((long) context->enc_num_position_slots) << NL_SHIFT))


/*
 * Max number of literals to hold.
 *
 * Memory required is MAX_LITERAL_ITEMS for enc_LitData[] array,
 * plus MAX_LITERAL_ITEMS/8 for enc_ItemType[] array.
 *
 * Must not exceed 64K, since that will cause our ushort
 * frequencies to overflow.
 */
#define MAX_LITERAL_ITEMS  65536


/*
 * Max number of distances to hold
 *
 * Memory required is MAX_DIST_ITEMS*4 for enc_DistData[] array
 *
 * MAX_DIST_ITEMS should never be greater than MAX_LITERAL_ITEMS,
 * since that just wastes space.
 *
 * However, it's extremely unlikely that one will get 65536 match
 * length 2's!  In any case, the literal and distance buffers
 * are checked independently, and a block is output if either
 * overflows.
 *
 * Bitmaps are highly redundant, though; lots of matches.
 */
#define MAX_DIST_ITEMS     32768
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\encdata.c ===
/*
 * encdata.c
 *
 * Encode a block into the output stream
 */

#include "encoder.h"

#define OUT_CHAR						\
		  c = context->enc_LitData[l];	\
		  OUTPUT_BITS(context->enc_main_tree_len[c], context->enc_main_tree_code[c]);


/* 
 * Macro to output bits into the encoding stream 
 */
#define OUTPUT_BITS(N,X) \
{ \
   context->enc_bitbuf |= (((ulong) (X)) << (context->enc_bitcount-(N))); \
   context->enc_bitcount -= (N);				  \
   while (context->enc_bitcount <= 16)            \
   {                                              \
      if (context->enc_output_buffer_curpos >= context->enc_output_buffer_end)   \
      { \
          context->enc_output_overflow = true; \
          context->enc_output_buffer_curpos = context->enc_output_buffer_start; \
      } \
      *context->enc_output_buffer_curpos++ = (byte) ((context->enc_bitbuf >> 16) & 255); \
      *context->enc_output_buffer_curpos++ = (byte) (context->enc_bitbuf >> 24); \
      context->enc_bitbuf <<= 16;				  \
      context->enc_bitcount += 16;                \
   }                                              \
}


/*
 * Given the initial state of the repeated offset buffers at
 * the beginning of this block, calculate the final state of the 
 * repeated offset buffers after outputting this block as if it 
 * were compressed data.
 *
 * First try to do it the quick way, by starting at the last
 * match and working backwards, to find three consecutive matches 
 * which don't use repeated offsets.  If this fails, we'll have 
 * to take the initial state of the three offsets at the beginning
 * of the block, and evolve them to the end of the block.
 */
void get_final_repeated_offset_states(t_encoder_context *context, ulong distances)
{
	ulong			MatchPos;
	signed long		d; /* must be signed */
	byte			consecutive;

	consecutive = 0;

	for (d = distances-1; d >= 0; d--)
	{
		if (context->enc_DistData[d] > 2)
		{
			/* NOT a repeated offset */
			consecutive++;

			/* do we have three consecutive non-repeated-offsets? */
			if (consecutive >= 3)
				break;
		}
		else
		{
			consecutive = 0;
		}
	}

	/*
	 * If we didn't find three consecutive matches which
	 * don't use repeated offsets, then we have to start
	 * from the beginning and evolve the repeated offsets.
	 *
	 * Otherwise, we start at the first of the consecutive 
	 * matches.
	 */
	if (consecutive < 3)
	{
		d = 0;
	}

	for (; d < (signed long) distances; d++)
	{
		MatchPos = context->enc_DistData[d];

		if (MatchPos == 0)
		{
		}
		else if (MatchPos <= 2)
		{
			ulong	temp;

			temp = context->enc_repeated_offset_at_literal_zero[MatchPos];
			context->enc_repeated_offset_at_literal_zero[MatchPos] = context->enc_repeated_offset_at_literal_zero[0];
			context->enc_repeated_offset_at_literal_zero[0] = temp;
		}
		else
		{
			context->enc_repeated_offset_at_literal_zero[2] = context->enc_repeated_offset_at_literal_zero[1];
			context->enc_repeated_offset_at_literal_zero[1] = context->enc_repeated_offset_at_literal_zero[0];
			context->enc_repeated_offset_at_literal_zero[0] = MatchPos-2;
		}
	}
}


/*
 * Encode a block with no compression
 *
 * bufpos is the position in the file from which the first
 * literal in this block starts.  To reference memory, we will
 * use enc_MemWindow[bufpos] (remember that enc_MemWindow is
 * moved backwards every time we copymem).
 *
 * Since this data was originally matched into the compressor,
 * our recent match offsets will have been changed; however,
 * since this is an uncompressed block, the decoder won't be
 * updating them.  Therefore, we need to tell the decoder
 * the state of the match offsets after it has finished
 * decoding the uncompressed data - we store these in this
 * block.
 */
void encode_uncompressed_block(t_encoder_context *context, ulong bufpos, ulong block_size)
{
    int     i;
    int     j;
    bool    block_size_odd;
    ulong   val;

    /*
     * Align on a byte boundary
     */
    output_bits(context, context->enc_bitcount-16, 0);

	/*
	 * Now output the contents of the repeated offset
	 * buffers, since we need to preserve the state of
	 * the encoder
	 */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
    {
        val = context->enc_repeated_offset_at_literal_zero[i];

        for (j = 0; j < sizeof(long); j++)
        {
            *context->enc_output_buffer_curpos++ = (byte) val;
            val >>= 8;
        }
    }

    block_size_odd = block_size & 1;

	/*
	 * Write out uncompressed data
	 */
	while (block_size > 0)
	{
        *context->enc_output_buffer_curpos++ = context->enc_MemWindow[bufpos];

		bufpos++;
		block_size--;
		context->enc_input_running_total++;

		if (context->enc_input_running_total == CHUNK_SIZE)
        {
			perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
        }
	}

    /*
     * Add pad byte to keep the output word-aligned
     */
    if (block_size_odd)
    {
        *context->enc_output_buffer_curpos++ = 0;
    }

    context->enc_bitcount   = 32;
    context->enc_bitbuf     = 0;
}


/*
 * Estimate the size of the data in the buffer, in bytes
 */
ulong estimate_compressed_block_size(t_encoder_context *context)
{
	ulong			block_size = 0; /* output size in bits */
	ulong			i;
	byte			mpslot;

	/* Estimation of tree size */
	block_size = 150*8;

	/* Tally bits to output characters */
	for (i = 0; i < NUM_CHARS; i++)
		block_size += (context->enc_main_tree_len[i]*context->enc_main_tree_freq[i]);

	/* Tally bits to output matches */
	for (mpslot = 0; mpslot < context->enc_num_position_slots; mpslot++)
	{
		long	element;
		int		primary;

		element = NUM_CHARS + (mpslot << NL_SHIFT);

		/* For primary == NUM_PRIMARY_LENGTHS we have secondary lengths */
		for (primary = 0; primary <= NUM_PRIMARY_LENGTHS; primary++)
		{
			block_size += ((context->enc_main_tree_len[element] + enc_extra_bits[mpslot]) * 
				context->enc_main_tree_freq[element]);
			element++;
		}
	}

	for (i = 0; i < NUM_SECONDARY_LENGTHS; i++)
		block_size += (context->enc_secondary_tree_freq[i] * context->enc_secondary_tree_len[i]);

	/* round up */
	return (block_size+7) >> 3;
}

/*
 * Encode block with NO special encoding of the lower 3 
 * position bits
 */
void encode_verbatim_block(t_encoder_context *context, ulong literal_to_end_at)
{
	ulong           MatchPos;
	ulong			d = 0;
	ulong			l = 0;
	byte            MatchLength;
	byte            c;
	byte            mpSlot;

	while (l < literal_to_end_at)
	{
		if (!IsMatch(l))
		{
			OUT_CHAR;
			l++;
			context->enc_input_running_total++;
		}
		else
		{
			/* Note, 0 means MatchLen=3, 1 means MatchLen=4, ... */
			MatchLength = context->enc_LitData[l++];

			/* Delta match pos */
			MatchPos = context->enc_DistData[d++];

			mpSlot = (byte) MP_SLOT(MatchPos);

			if (MatchLength < NUM_PRIMARY_LENGTHS)
			{
				OUTPUT_BITS(
					context->enc_main_tree_len[ NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength],
					context->enc_main_tree_code[NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength]
				);
			}
			else
			{
				OUTPUT_BITS(
					context->enc_main_tree_len [(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)],
					context->enc_main_tree_code[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)]
				);

				OUTPUT_BITS(
					context->enc_secondary_tree_len[ MatchLength - NUM_PRIMARY_LENGTHS],
					context->enc_secondary_tree_code[MatchLength - NUM_PRIMARY_LENGTHS]
				);
			}

			if (enc_extra_bits[ mpSlot ])
			{
				OUTPUT_BITS(
					enc_extra_bits[mpSlot],
					MatchPos & enc_slot_mask[mpSlot]
				);
			}

			context->enc_input_running_total += (MatchLength+MIN_MATCH);
		}

		if (context->enc_input_running_total == CHUNK_SIZE)
        {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
        }

        _ASSERTE (context->enc_input_running_total < CHUNK_SIZE);
	}
}


/*
 * aligned block encoding
 */
void encode_aligned_block(t_encoder_context *context, ulong literal_to_end_at)
{
	ulong	MatchPos;
	byte	MatchLength;
	byte	c;
	byte	mpSlot;
	byte	Lower;
	ulong	l = 0;
	ulong	d = 0;

	while (l < literal_to_end_at)
	{
		if (!IsMatch(l))
		{
			OUT_CHAR;
			l++;
			context->enc_input_running_total++;
		}
		else
		{
			/* Note, 0 means MatchLen=3, 1 means MatchLen=4, ... */
			MatchLength = context->enc_LitData[l++];

			/* Delta match pos */
			MatchPos = context->enc_DistData[d++];
		
			mpSlot = (byte) MP_SLOT(MatchPos);

			if (MatchLength < NUM_PRIMARY_LENGTHS)
			{
				OUTPUT_BITS(
					context->enc_main_tree_len[ NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength],
					context->enc_main_tree_code[NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength]
				);
			}
			else
			{
				OUTPUT_BITS(
					context->enc_main_tree_len[ (NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)],
					context->enc_main_tree_code[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)]
				);

				OUTPUT_BITS(
					context->enc_secondary_tree_len[ MatchLength - NUM_PRIMARY_LENGTHS],
					context->enc_secondary_tree_code[MatchLength - NUM_PRIMARY_LENGTHS]
				);
			}

			if (enc_extra_bits[ mpSlot ] >= 3)
			{
				if (enc_extra_bits[ mpSlot ] > 3)
				{
					OUTPUT_BITS(
						enc_extra_bits[mpSlot] - 3,
						(MatchPos >> 3) & ( (1 << (enc_extra_bits[mpSlot]-3)) -1)
					);
				}

      			Lower = (byte) (MatchPos & 7);

	   			OUTPUT_BITS(
	   	   			context->enc_aligned_tree_len[Lower],
	   	   			context->enc_aligned_tree_code[Lower]
	   			);
			}
			else if (enc_extra_bits[ mpSlot ])
			{
				OUTPUT_BITS(
					enc_extra_bits[mpSlot],
					MatchPos & enc_slot_mask[ mpSlot ]
				);
			} 

			context->enc_input_running_total += (MatchLength+MIN_MATCH);
		}

		if (context->enc_input_running_total == CHUNK_SIZE)
        {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
        }

        _ASSERTE (context->enc_input_running_total < CHUNK_SIZE);
	}
}


void perform_flush_output_callback(t_encoder_context *context)
{
	long	output_size;

    /*
     * Do this only if there is any input to account for, so we don't
     * end up outputting blocks where comp_size > 0 and uncmp_size = 0.
     */
    if (context->enc_input_running_total > 0)
    {
        flush_output_bit_buffer(context);

        output_size = (long)(context->enc_output_buffer_curpos - context->enc_output_buffer_start);

        if (output_size > 0)
        {
            (*context->enc_output_callback_function)(
                context->enc_fci_data,
                context->enc_output_buffer_start,
                (long) (context->enc_output_buffer_curpos - context->enc_output_buffer_start),
                context->enc_input_running_total
            );
        }
    }

	context->enc_input_running_total = 0;
	context->enc_output_buffer_curpos = context->enc_output_buffer_start;

	/* initialise bit buffer */
	context->enc_bitcount = 32;
	context->enc_bitbuf   = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\encproto.h ===
/*
 * encproto.h
 *
 * Encoder function prototypes
 */

/* blkinit.c */
void create_slot_lookup_table(t_encoder_context *context);
void create_ones_table(t_encoder_context *context);

/* block.c */
void output_block(t_encoder_context *context);
void flush_output_bit_buffer(t_encoder_context *context);
long estimate_buffer_contents(t_encoder_context *context);
ulong get_distances_from_literals(t_encoder_context *context, ulong literals);

/* bsearch.c */
long binary_search_findmatch(t_encoder_context *context, long BufPos);
void quick_insert_bsearch_findmatch(t_encoder_context *context, long BufPos, long endpos);
void binary_search_remove_node(t_encoder_context *context, long BufPos, ulong end_pos);

/* encdata.c */
void encode_verbatim_block(t_encoder_context *context, ulong literal_to_end_at);
void encode_aligned_block(t_encoder_context *context, ulong literal_to_end_at);
void encode_uncompressed_block(t_encoder_context *context, ulong bufpos, ulong block_size);
void perform_flush_output_callback(t_encoder_context *context);
ulong estimate_compressed_block_size(t_encoder_context *context);
void get_final_repeated_offset_states(t_encoder_context *context, ulong distances);

/* encstats.c */
lzx_block_type get_aligned_stats(t_encoder_context *context, ulong dist_to_end_at);

ulong get_block_stats(
	t_encoder_context *context, 
	ulong literal_to_start_at, 
	ulong distance_to_start_at,
	ulong literal_to_end_at
);

ulong update_cumulative_block_stats(
	t_encoder_context *context, 
	ulong literal_to_start_at, 
	ulong distance_to_start_at,
	ulong literal_to_end_at
);

bool split_block(
	t_encoder_context *context, 
	ulong literal_to_start_at,
	ulong literal_to_end_at,
	ulong distance_to_end_at,
	ulong *split_at_literal,
	ulong *split_at_distance	
);

/* enctree.c */
void create_trees(t_encoder_context *context, bool generate_codes);
void fix_tree_cost_estimates(t_encoder_context *context);
void encode_trees(t_encoder_context *context);
void encode_aligned_tree(t_encoder_context *context);
void prevent_far_matches(t_encoder_context *context);

/* init.c */
void init_compression_memory(t_encoder_context *context);
bool comp_alloc_compress_memory(t_encoder_context *context);
void comp_free_compress_memory(t_encoder_context *context);

/* io.c */
void output_bits(t_encoder_context *context, int n, ulong x);
void free_compressed_output_buffer(t_encoder_context *context);
bool init_compressed_output_buffer(t_encoder_context *context);
void flush_compressed_output_buffer(t_encoder_context *context);
void reset_translation(t_encoder_context *context);
long comp_read_input(t_encoder_context *context, ulong BufPos, long Size);

/* optenc.c */
void opt_encode_top(t_encoder_context *context, long BytesRead);
void reset_encoder_variables(t_encoder_context *context);
void flush_all_pending_blocks(t_encoder_context *context);
void encoder_start(t_encoder_context *context);

/* tree.c */
bool allocate_tree_building_data(t_encoder_context *context);
void free_tree_building_data(t_encoder_context *context);

void make_tree(
	t_encoder_context *context,
	int		nparm, 
	ushort	*freqparm, 
	byte	*lenparm, 
	ushort	*codeparm,
	bool	make_codes	
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\encstats.c ===
/*
 * encstats.c
 *
 * Routines for calculating statistics on a block of data which
 * has been compressed, but not yet output.
 *
 * These routines are used to determine which encoding method to use
 * to output the block.
 */

#include "encoder.h"



static void tally_aligned_bits(t_encoder_context *context, ulong dist_to_end_at)
{
	ulong	*dist_ptr;
	ulong	i;
	ulong	match_pos;

	/*
     * Tally the lower 3 bits
     */
	dist_ptr = context->enc_DistData;

	for (i = dist_to_end_at; i > 0; i--)
	{
		match_pos = *dist_ptr++;

		/*
		 * Only for matches which have >= 3 extra bits 
		 */
		if (match_pos >= MPSLOT3_CUTOFF)
			context->enc_aligned_tree_freq[match_pos & 7]++;
	}
}


/*
 * Determine whether it is advantageous to use aligned block
 * encoding on the block.
 */
lzx_block_type get_aligned_stats(t_encoder_context *context, ulong dist_to_end_at)
{

	byte		i;
	ulong		total_L3 = 0;
	ulong		largest_L3 = 0;

	memset(
		context->enc_aligned_tree_freq, 
		0, 
		ALIGNED_NUM_ELEMENTS * sizeof(context->enc_aligned_tree_freq[0])
	);

	tally_aligned_bits(context, dist_to_end_at);

	for (i = 0; i < ALIGNED_NUM_ELEMENTS; i++)
	{
		if (context->enc_aligned_tree_freq[i] > largest_L3)
			largest_L3 = context->enc_aligned_tree_freq[i];

		total_L3 += context->enc_aligned_tree_freq[i];
	}

	/*
	 * Do aligned offsets if the largest frequency accounts for 20%
	 * or more (as opposed to 12.5% for non-aligned offset blocks).
	 *
	 * Not worthwhile to do aligned offsets if we have < 100 matches
	 */
	if ((largest_L3 > total_L3/5) && dist_to_end_at >= 100)
		return BLOCKTYPE_ALIGNED;
	else
		return BLOCKTYPE_VERBATIM;
}


/*
 * Calculates the frequency of each literal, and returns the total
 * number of uncompressed bytes compressed in the block.
 */
static ulong tally_frequency(
	t_encoder_context *context, 
	ulong literal_to_start_at, 
	ulong distance_to_start_at,
	ulong literal_to_end_at
)
{

	ulong   i;
	ulong	d;
	ulong   compressed_bytes = 0;

	d = distance_to_start_at;

	for (i = literal_to_start_at; i < literal_to_end_at; i++)
	{
		if (!IsMatch(i))
		{
			/* Uncompressed symbol */
			context->enc_main_tree_freq[context->enc_LitData[i]]++;
			compressed_bytes++;
		}
		else
		{
			/* Match */
			if (context->enc_LitData[i] < NUM_PRIMARY_LENGTHS)
			{
				context->enc_main_tree_freq[ NUM_CHARS + (MP_SLOT(context->enc_DistData[d])<<NL_SHIFT) + context->enc_LitData[i]] ++;
			}
			else
			{
				context->enc_main_tree_freq[ (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[d])<<NL_SHIFT)] ++;
				context->enc_secondary_tree_freq[context->enc_LitData[i] - NUM_PRIMARY_LENGTHS] ++;
			}

			compressed_bytes += context->enc_LitData[i]+MIN_MATCH;
			d++;
		}
	}

	return compressed_bytes;
}


/*
 * Get statistics
 */
ulong get_block_stats(
	t_encoder_context *context, 
	ulong literal_to_start_at, 
	ulong distance_to_start_at,
	ulong literal_to_end_at
)
{

	memset(
		context->enc_main_tree_freq, 
		0, 
		MAIN_TREE_ELEMENTS * sizeof(context->enc_main_tree_freq[0])
	);

	memset(
		context->enc_secondary_tree_freq, 
		0, 
		NUM_SECONDARY_LENGTHS * sizeof(context->enc_secondary_tree_freq[0])
	);

	return tally_frequency(
		context,
		literal_to_start_at, 
		distance_to_start_at,
		literal_to_end_at
	);
}


/*
 * Update cumulative statistics
 */
ulong update_cumulative_block_stats(
	t_encoder_context *context, 
	ulong literal_to_start_at, 
	ulong distance_to_start_at,
	ulong literal_to_end_at
)
{

	return tally_frequency(
		context,
		literal_to_start_at, 
		distance_to_start_at,
		literal_to_end_at
	);
}



/*
 * Used in block splitting
 *
 * This routine calculates the "difference in composition" between 
 * two different sections of compressed data.
 *
 * Resolution must be evenly divisible by STEP_SIZE, and must be
 * a power of 2.
 */
#define RESOLUTION				1024

/*
 * Threshold for determining if two blocks are different
 *
 * If enough consecutive blocks are this different, the block
 * splitter will start investigating, narrowing down the
 * area where the change occurs.
 *
 * It will then look for two areas which are 
 * EARLY_BREAK_THRESHOLD (or more) different.
 *
 * If THRESHOLD is too small, it will force examination
 * of a lot of blocks, slowing down the compressor.
 *
 * The EARLY_BREAK_THRESHOLD is the more important value.
 */
#define THRESHOLD				1400

/*
 * Threshold for determining if two blocks are REALLY different
 */
#define EARLY_BREAK_THRESHOLD	1700

/*
 * Must be >= 8 because ItemType[] array is in bits
 *
 * Must be a power of 2.
 *
 * This is the step size used to narrow down the exact
 * best point to split the block.
 */
#define STEP_SIZE               64

/*
 * Minimum # literals required to perform block
 * splitting at all.
 */
#define MIN_LITERALS_REQUIRED	6144

/*
 * Minimum # literals we will allow to be its own block.
 *
 * We don't want to create blocks with too small numbers
 * of literals, otherwise the static tree output will
 * take up too much space.
 */
#define MIN_LITERALS_IN_BLOCK	4096


static const long square_table[17] =
{
	0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256
};


/*
 * log2(x) = x < 256 ? log2_table[x] : 8 + log2_table[(x >> 8)]
 *
 * log2(0)   = 0
 * log2(1)   = 1
 * log2(2)   = 2
 * log2(3)   = 2
 * log2(4)   = 3
 * log2(255) = 8
 * log2(256) = 9
 * log2(511) = 9
 * log2(512) = 10
 *
 * It's not a real log2; it's off by one because we have
 * log2(0) = 0.
 */
static const byte log2_table[256] =
{
	0,1,2,2,3,3,3,3,
	4,4,4,4,4,4,4,4,
	5,5,5,5,5,5,5,5,
	5,5,5,5,5,5,5,5,
	6,6,6,6,6,6,6,6,
	6,6,6,6,6,6,6,6,
	6,6,6,6,6,6,6,6,
	6,6,6,6,6,6,6,6,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8
};


/*
 * Return the difference between two sets of matches/distances
 */
static ulong return_difference(
	t_encoder_context *context, 
	ulong item_start1,
	ulong item_start2,
	ulong dist_at_1,
	ulong dist_at_2,
	ulong size
)
{

	ushort	freq1[800];
	ushort	freq2[800];
	ulong	i;
	ulong	cum_diff;
	int		element;

	/*
	 * Error!  Too many main tree elements
	 */
	if (MAIN_TREE_ELEMENTS >= (sizeof(freq1)/sizeof(freq1[0])))
		return 0;

	memset(freq1, 0, sizeof(freq1[0])*MAIN_TREE_ELEMENTS);
	memset(freq2, 0, sizeof(freq2[0])*MAIN_TREE_ELEMENTS);

	for (i = 0; i < size; i++)
	{
		if (!IsMatch(item_start1))
		{
			element = context->enc_LitData[item_start1];
		}
		else
		{
			if (context->enc_LitData[item_start1] < NUM_PRIMARY_LENGTHS)
				element = NUM_CHARS + (MP_SLOT(context->enc_DistData[dist_at_1])<<NL_SHIFT) + context->enc_LitData[item_start1];
			else
				element = (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[dist_at_1]) << NL_SHIFT);

			dist_at_1++;
		}

		item_start1++;
		freq1[element]++;

		if (!IsMatch(item_start2))
		{
			element = context->enc_LitData[item_start2];
		}
		else
		{
			if (context->enc_LitData[item_start2] < NUM_PRIMARY_LENGTHS)
				element = NUM_CHARS + (MP_SLOT(context->enc_DistData[dist_at_2])<<NL_SHIFT) + context->enc_LitData[item_start2];
			else
				element = (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[dist_at_2]) << NL_SHIFT);

			dist_at_2++;
		}

		item_start2++;
		freq2[element]++;
	}

	cum_diff = 0;

	for (i = 0; i < (ulong) MAIN_TREE_ELEMENTS; i++) 
	{
		ulong log2a, log2b, diff;

#define log2(x) ((x) < 256 ? log2_table[(x)] : 8+log2_table[(x) >> 8])

		log2a = (ulong) log2(freq1[i]);
		log2b = (ulong) log2(freq2[i]);

		/* diff = (log2a*log2a) - (log2b*log2b); */
		diff = square_table[log2a] - square_table[log2b];

		cum_diff += abs(diff);
	}

	return cum_diff;
}


/*
 * Calculates where and if a block of compressed data should be split.
 *
 * For example, if we have just compressed text data, audio data, and
 * more text data, then the composition of matches and unmatched
 * symbols will be different between the text data and audio data.
 * Therefore we force an end of block whenever the compressed data
 * looks like it's changing in composition.
 *
 * This routine currently cannot tell the difference between blocks
 * which should use aligned offsets, and blocks which should not.
 * However, there is little to be gained from looking for this change,
 * since it the match finder doesn't make an effort to look for
 * aligned offsets either.
 *
 * Returns whether we split the block or not.
 */
bool split_block(
	t_encoder_context *context, 
	ulong literal_to_start_at,
	ulong literal_to_end_at,
	ulong distance_to_end_at,	/* corresponds to # distances at literal_to_end_at */
	ulong *split_at_literal,
	ulong *split_at_distance	/* optional parameter (may be NULL) */
)
{

	ulong	i, j, d;
	int		nd;

	/*
	 * num_dist_at_item[n] equals the cumulative number of matches
	 * at literal "n / STEP_SIZE".
	 */
	ushort	num_dist_at_item[(MAX_LITERAL_ITEMS/STEP_SIZE)+8]; /* +8 is slop */

	/*
	 * default return
	 */
	*split_at_literal	= literal_to_end_at;

	if (split_at_distance)
		*split_at_distance	= distance_to_end_at;

	/* Not worth doing if we don't have many literals */
	if (literal_to_end_at - literal_to_start_at < MIN_LITERALS_REQUIRED)
		return false;

    /* Not allowed to split blocks any more, so we don't overflow MAX_GROWTH? */
    if (context->enc_num_block_splits >= MAX_BLOCK_SPLITS)
        return false;

	/*
	 * Keep track of the number of distances (matches) we've had,
	 * at each step of STEP_SIZE literals.
	 *
	 * Look at 8 items at a time, and ignore the last
	 * 0..7 items if they exist.
	 */
	nd = 0;
	d = 0;

	for (i = 0; i < (literal_to_end_at >> 3); i++)
	{
		/*
		 * if (i % (STEP_SIZE >> 3)) == 0
		 */
		if ((i & ((STEP_SIZE >> 3)-1)) == 0)
			num_dist_at_item[nd++] = (ushort) d;

		d += context->enc_ones[ context->enc_ItemType[i] ];
	}

	/*
	 * Must be a multiple of STEP_SIZE
	 */
	literal_to_start_at = (literal_to_start_at + (STEP_SIZE-1)) & (~(STEP_SIZE-1));

	/*
	 * See where the change in composition occurs
	 */
	for (	i = literal_to_start_at + 2*RESOLUTION; 
			i < literal_to_end_at - 4*RESOLUTION; 
			i += RESOLUTION)
	{
		/*
		 * If there appears to be a significant variance in composition
		 * between
		 *                    ___________
		 *                   /           \
		 *                A  B  i     X  Y  Z
		 *                \      \___/      /
		 *                 \_______________/
		 */
		if (
			return_difference(
				context,
				i,
				i+1*RESOLUTION, 
				(ulong) num_dist_at_item[i/STEP_SIZE], 
				(ulong) num_dist_at_item[(i+1*RESOLUTION)/STEP_SIZE], 
				RESOLUTION) > THRESHOLD
			&& 
			
			return_difference(
				context,
				i-RESOLUTION,   
				i+2*RESOLUTION, 
				(ulong) num_dist_at_item[(i-RESOLUTION)/STEP_SIZE], 
				(ulong) num_dist_at_item[(i+2*RESOLUTION)/STEP_SIZE], 
				RESOLUTION) > THRESHOLD
			 
			&& 
			
			return_difference(
				context,
				i-2*RESOLUTION, 
				i+3*RESOLUTION, 
				(ulong) num_dist_at_item[(i-2*RESOLUTION)/STEP_SIZE], 
				(ulong) num_dist_at_item[(i+3*RESOLUTION)/STEP_SIZE], 
				RESOLUTION) > THRESHOLD
			)
		{
			ulong max_diff = 0;
			ulong literal_split;

			/*
			 * Narrow down the best place to split block
			 *
			 * This really could be done much better; we could end up
			 * doing a lot of stepping;
			 *
			 * basically ((5/2 - 1/2) * RESOLUTION) / STEP_SIZE
			 *
			 * which is (2 * RESOLUTION) / STEP_SIZE,
			 * which with RESOLUTION = 1024 and STEP_SIZE = 32,
			 * equals 2048/32 = 64 steps.
			 */
			for (j = i+RESOLUTION/2; j<i+(5*RESOLUTION)/2; j += STEP_SIZE)
			{
				ulong	diff;

				diff = return_difference(
					context,
					j - RESOLUTION, 
					j, 
					(ulong) num_dist_at_item[(j-RESOLUTION)/STEP_SIZE], 
					(ulong) num_dist_at_item[j/STEP_SIZE], 
					RESOLUTION
				);

				/* Get largest difference */
				if (diff > max_diff)
				{
					/*
					 * j should not be too small, otherwise we'll be outputting
					 * a very small block
					 */
					max_diff = diff;
					literal_split = j;
				}
			}

			/*
			 * There could be multiple changes in the data in our literals,
			 * so if we find something really weird, make sure we break the
			 * block now, and not on some later change.
			 */
			if (max_diff >= EARLY_BREAK_THRESHOLD && 
				(literal_split-literal_to_start_at) >= MIN_LITERALS_IN_BLOCK)
			{
                context->enc_num_block_splits++;

				*split_at_literal = literal_split;

				/* 
				 * Return the associated # distances, if required.
				 * Since we split on a literal which is % STEP_SIZE, we
				 * can read the # distances right off
				 */
				if (split_at_distance)
					*split_at_distance = num_dist_at_item[literal_split/STEP_SIZE];

				return true;
			}
		}
	}

	/*
	 * No good place found to split
	 */
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\enctree.c ===
/*
 * enctree.c
 *
 * Encode trees into output data
 */

#define EXT extern
#include "encoder.h"

/*
 * Encode a tree
 */
static void WriteRepTree(
	t_encoder_context *context,
	byte    *pLen,
	byte    *pLastLen, 
	int		Num
)
{
	int			i;
	int			j;
	int			Same;
	ushort		SmallFreq[2*24];
	ushort		MiniCode[24];
	char		MiniLen[24];
	char		k;
	byte		temp_store;
    byte * z=context->enc_output_buffer_curpos;

	static const byte Modulo17Lookup[] =
	{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
	};

	memset(SmallFreq, 0, sizeof(SmallFreq));

	temp_store	= pLen[Num];
	pLen[Num]	= 123; 

	for (i = 0; i < Num; i++)
	{
		Same = 0;

		/* Count the number of consecutive elements which have the same length */
		/* No need to check against array boundary, because the last element has */
		/* a nonsense value */
		for (j = i+1; pLen[j] == pLen[i]; j++)
	 		Same++;

		/* If more than 3, compress this information */
		if (Same >= TREE_ENC_REP_MIN)
		{
	 		/* Special case if they're zeroes */
	 		if (!pLen[i])
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1)
	       		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1;

	    		if (Same <= TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST - 1)
	       			SmallFreq[17]++;
	    		else
	       			SmallFreq[18]++;
	 		}
		 	else
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1)
	       			Same = TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1;

				SmallFreq[ Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ] ]++;
	    		SmallFreq[19]++;
	 		}

	 		i += Same-1;
      }
      else
			SmallFreq[ Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ] ]++;
	}

	make_tree(
		context,
		20, 
		SmallFreq, 
		(byte *) MiniLen, 
		MiniCode, 
		true
	);

	/* max 10 byte output overrun */
	for (i = 0; i < 20; i++)
	{
		output_bits(context, 4, MiniLen[i]);
	}

	/* Output original tree with new code */
	for (i = 0; i < Num; i++)
	{
		Same = 0;

		/* Count the number of consecutive elements which have the same length */
		/* No need to check against array boundary, because the last element has */
		/* a nonsense value */
		for (j = i+1; pLen[j] == pLen[i]; j++)
	 		Same++;

		/* If more than 3, we can do something */
		if (Same >= TREE_ENC_REP_MIN)
		{
	 		if (!pLen[i]) /* Zeroes */
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1)
		       		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1;

	    		if (Same <= TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST - 1)
	       			k = 17;
	    		else
		       		k = 18;
	 		}
	 		else
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1)
			   		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1;

	    		k = 19;
	 		}
		}
		else
	 		k = Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ];

		output_bits(context, MiniLen[k], MiniCode[k]);

		if (k == 17)
		{
	 		output_bits(context, TREE_ENC_REPZ_FIRST_EXTRA_BITS, Same-TREE_ENC_REP_MIN);
	 		i += Same-1;
		}
		else if (k == 18)
		{
	 		output_bits(context, TREE_ENC_REPZ_SECOND_EXTRA_BITS, Same-(TREE_ENC_REP_MIN+TREE_ENC_REP_ZERO_FIRST));
	 		i += Same-1;
		}
		else if (k == 19)
		{
	 		output_bits(context, TREE_ENC_REP_SAME_EXTRA_BITS, Same-TREE_ENC_REP_MIN);

	 		k = Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ];
			output_bits(context, MiniLen[k], MiniCode[k]);

	 		i += Same-1;
		}
	}

	pLen[Num] = temp_store;

	memcpy(pLastLen, pLen, Num);
}


void create_trees(t_encoder_context *context, bool generate_codes)
{
	/*
	 * Assumption: We can trash PtrLen[NUM_CHARS+(NUM_POSITION_SLOTS*NUM_LENGTHS))], since
	 *             we allocated space for it earlier
	 */
	make_tree(
		context,
		NUM_CHARS+(context->enc_num_position_slots*(NUM_PRIMARY_LENGTHS+1)),
		context->enc_main_tree_freq, 
		context->enc_main_tree_len,  
		context->enc_main_tree_code,
		generate_codes
	);

	make_tree(
		context,
		NUM_SECONDARY_LENGTHS, 
		context->enc_secondary_tree_freq,
		context->enc_secondary_tree_len,
		context->enc_secondary_tree_code,
		generate_codes
	);

	make_tree(
		context,
		ALIGNED_NUM_ELEMENTS, 
		context->enc_aligned_tree_freq, 
		context->enc_aligned_tree_len, 
		context->enc_aligned_tree_code, 
		true
	);
}


void fix_tree_cost_estimates(t_encoder_context *context)
{
	/*
	 *  We're only creating trees for estimation purposes and we do not 
	 *  want to encode the tree.  However, the following loops will set
	 *  the frequency zero tree element lengths to values other than 
	 *  zero, so that the optimal encoder won't get confused when it
	 *  tries to estimate the number of bits it would take to output an
	 *  element.
     *
     *  We also set the bit lengths of match length 2's further away
     *  than MAX_LENGTH_TWO_OFFSET to a large number, so that the
     *  optimal parser will never select such matches.
	 */
	ulong  i;

	/* Set zero lengths to some value */
	for (i = 0; i< NUM_CHARS; i++)
	{
		if (context->enc_main_tree_len[i] == 0)
			context->enc_main_tree_len[i] = 11;
	}

	for (; i < NUM_CHARS+(context->enc_num_position_slots*(NUM_PRIMARY_LENGTHS+1)); i++)
	{
		if (context->enc_main_tree_len[i] == 0)
			context->enc_main_tree_len[i] = 12;
	}		

	for (i = 0; i < NUM_SECONDARY_LENGTHS; i++)
	{
		if (context->enc_secondary_tree_len[i] == 0)
			context->enc_secondary_tree_len[i] = 8; 
	}

    prevent_far_matches(context);
}


void prevent_far_matches(t_encoder_context *context)
{
    ulong i;

    /*
     * Set far match length 2's to a high value so they will never
     * be chosen.
     *
     * See description of MAX_GROWTH in encdefs.h
     */
    for (   i = MP_SLOT(MAX_LENGTH_TWO_OFFSET);
            i < context->enc_num_position_slots;
            i++
        )
	{
        context->enc_main_tree_len[NUM_CHARS + (i << NL_SHIFT)] = 100;
	}		
}


/*
 * Encode the trees
 *
 * Assumes trees have already been created with create_trees().
 *
 * Warning, do not call update_tree_cost_estimates() before encoding
 * the trees, since that routine trashes some of the tree elements.
 */
void encode_trees(t_encoder_context *context)
{
	WriteRepTree(
		context,
		context->enc_main_tree_len, 
		context->enc_main_tree_prev_len,
		NUM_CHARS
	);

	WriteRepTree(
		context,
		&context->enc_main_tree_len[NUM_CHARS], 
		&context->enc_main_tree_prev_len[NUM_CHARS], 
		context->enc_num_position_slots * (NUM_PRIMARY_LENGTHS+1)
	);

	WriteRepTree(
		context,
		context->enc_secondary_tree_len,
		context->enc_secondary_tree_prev_len,
		NUM_SECONDARY_LENGTHS
	);
}


void encode_aligned_tree(t_encoder_context *context)
{
	int i;

	make_tree(
		context,
		ALIGNED_NUM_ELEMENTS, 
		context->enc_aligned_tree_freq, 
		context->enc_aligned_tree_len, 
		context->enc_aligned_tree_code, 
		true
	);

	/* Output original tree with new code */
	for (i = 0; i < 8; i++)
	{
		output_bits(context, 3, context->enc_aligned_tree_len[i]);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\io.c ===
/*
 * io.c
 */
#include "encoder.h"

/*
 * Similar to the optimisation we have for the decoder.
 *
 * Allow the encoder to "overrun" output buffer by up to X bytes
 * so that we don't have to check for the end of the buffer every
 * single time we call outbits() in encdata.c
 */
#define OUTPUT_EXTRA_BYTES 64


static void encoder_translate_e8(t_encoder_context *context, byte *mem, long bytes);


void output_bits(t_encoder_context *context, int n, ulong x)
{
	context->enc_bitbuf |= (((ulong) x) << (context->enc_bitcount - n));
	context->enc_bitcount -= (signed char) n;     
   
	while (context->enc_bitcount <= 16)                     
	{                                              
		if (context->enc_output_buffer_curpos >= context->enc_output_buffer_end)
        {
            context->enc_output_overflow = true;
            context->enc_output_buffer_curpos = context->enc_output_buffer_start;
        }

        *context->enc_output_buffer_curpos++ = (byte) ((context->enc_bitbuf >> 16) & 255);
        *context->enc_output_buffer_curpos++ = (byte) (context->enc_bitbuf >> 24);

		context->enc_bitbuf <<= 16;
		context->enc_bitcount += 16;                         
	}                                              
}


/*
 * Initialises output buffering
 */
bool init_compressed_output_buffer(t_encoder_context *context)
{
	if (!(context->enc_output_buffer_start = (byte *) context->enc_malloc(OUTPUT_BUFFER_SIZE)))
		return false;

	context->enc_output_buffer_curpos = context->enc_output_buffer_start;

	context->enc_output_buffer_end =
		context->enc_output_buffer_start+(OUTPUT_BUFFER_SIZE-OUTPUT_EXTRA_BYTES);

	return true;
}


void free_compressed_output_buffer(t_encoder_context *context)
{
   if (context->enc_output_buffer_start)
   {
	  context->enc_free(context->enc_output_buffer_start);
	  context->enc_output_buffer_start = NULL;
   }
}


void reset_translation(t_encoder_context *context)
{
	context->enc_instr_pos = 0;
}


static long read_input_data(t_encoder_context *context, byte *mem, long amount)
{

	if (amount <= context->enc_input_left)
	{
		memcpy(mem, context->enc_input_ptr, amount);
		context->enc_input_left -= amount;
		context->enc_input_ptr += amount;

		return amount;
	}
	else
	{
		long bytes_read;

		if (context->enc_input_left <= 0)
			return 0;

		bytes_read = context->enc_input_left;

		memcpy(mem, context->enc_input_ptr, context->enc_input_left);
		context->enc_input_ptr += context->enc_input_left;
		context->enc_input_left = 0;

		return bytes_read;
	}
}


long comp_read_input(t_encoder_context *context, ulong BufPos, long Size)
{
	long    bytes_read;

	if (Size <= 0)
		return 0;

	bytes_read = read_input_data(
		context, 
		&context->enc_RealMemWindow[BufPos], 
		Size
	);

	if (bytes_read < 0)
        return 0;

	/*
	 * If no translation being performed for this file
	 */
    if (context->enc_file_size_for_translation == 0 ||
        context->enc_num_cfdata_frames >= E8_CFDATA_FRAME_THRESHOLD)
    {
        context->enc_num_cfdata_frames++;
		return bytes_read;
    }

	encoder_translate_e8(
		context, 
		&context->enc_RealMemWindow[BufPos], 
		bytes_read
	);

    context->enc_num_cfdata_frames++;

	return bytes_read;
}


static void encoder_translate_e8(t_encoder_context *context, byte *mem, long bytes)
{
	long    offset;
	long    absolute;
	ulong   end_instr_pos;
	byte    temp[6];
	byte    *mem_backup;

	if (bytes <= 6)
	{
		context->enc_instr_pos += bytes;
		return;
	}

	mem_backup = mem;

	/* backup these bytes */
	memcpy(temp, &mem[bytes-6], 6);

	/* overwrite them with 0xE8 */
	memset(&mem[bytes-6], 0xE8, 6);

	end_instr_pos = context->enc_instr_pos + bytes - 6;

	while (1)
	{
		while (*mem++ != 0xE8)
			context->enc_instr_pos++;

		if (context->enc_instr_pos >= end_instr_pos)
			break;

#if defined(_X86_) 
	offset = *(long *) mem;
#else
		offset   = (long) (
						((ulong)  mem[0])               | 
						(((ulong) mem[1])<<8)   | 
						(((ulong) mem[2])<<16)  |
						(((ulong) mem[3])<<24)
						);
#endif

		absolute = context->enc_instr_pos + offset;

	if (absolute >= 0)
		{
			if ((ulong) absolute < context->enc_file_size_for_translation+context->enc_instr_pos)
			{
				if ((ulong) absolute >= context->enc_file_size_for_translation)
					absolute = offset - context->enc_file_size_for_translation;

#if defined(_X86_) 
				*(ulong *) mem = (ulong) absolute;
#else
				mem[0] = (byte) ((ulong) absolute & 255);
				mem[1] = (byte) (( ((ulong) absolute) >> 8) & 255);
				mem[2] = (byte) (( ((ulong) absolute) >> 16) & 255);
				mem[3] = (byte) (( ((ulong) absolute) >> 24) & 255);
#endif
			}
		}
  
		mem += 4;
		context->enc_instr_pos += 5;
	}

	/* restore the bytes */
	memcpy(&mem_backup[bytes-6], temp, 6);

	context->enc_instr_pos = end_instr_pos + 6;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\init.c ===
/*
 * init.c
 *
 * Initialise encoder
 */
#include "encoder.h"


#define MEM_WINDOW_ALLOC_SIZE   \
	(context->enc_window_size+(MAX_MATCH+EXTRA_SIZE)+context->enc_encoder_second_partition_size)

/*
 * Initialise encoder
 */
void init_compression_memory(t_encoder_context *context)
{
	/* set all root pointers to NULL */
#ifdef MULTIPLE_SEARCH_TREES
	memset(
   		context->enc_tree_root, 
   		0, 
   		NUM_SEARCH_TREES * sizeof(context->enc_tree_root[0])
	);
#else
	context->enc_single_tree_root = 0;
#endif

	context->enc_MemWindow	= context->enc_RealMemWindow - context->enc_window_size;
	context->enc_Left		= context->enc_RealLeft		 - context->enc_window_size;
	context->enc_Right		= context->enc_RealRight	 - context->enc_window_size;
	context->enc_BufPos		= context->enc_window_size;

	/* 
	 * Set initial state of repeated match offsets 
	 */
	context->enc_last_matchpos_offset[0] = 1;
	context->enc_last_matchpos_offset[1] = 1;
	context->enc_last_matchpos_offset[2] = 1;

	/* 
	 * repeated offset states the last time we output a block 
	 * see block.c/encdata.c 
	 */
	context->enc_repeated_offset_at_literal_zero[0] = 1;
	context->enc_repeated_offset_at_literal_zero[1] = 1;
	context->enc_repeated_offset_at_literal_zero[2] = 1;

	/* this is the first compressed block in the file */
	context->enc_first_block = true;

	/* we don't have any cumulative stats yet */
	context->enc_need_to_recalc_stats = true;

	/* bufpos @ last time we output a block */
	context->enc_bufpos_last_output_block = context->enc_BufPos;

	/* initialise bit buffer */
	context->enc_bitcount = 32;
	context->enc_bitbuf   = 0;
    context->enc_output_overflow = false;

	/*
	 * The last lengths are zeroed in both the encoder and decoder,
	 * since our tree representation is delta format.
	 */
	memset(context->enc_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);
	memset(context->enc_secondary_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);

	/* 
	 * Set the default last tree lengths for cost estimation 
	 */
	memset(context->enc_main_tree_len, 8, NUM_CHARS);
	memset(&context->enc_main_tree_len[NUM_CHARS], 9, MAIN_TREE_ELEMENTS-NUM_CHARS);
	memset(context->enc_secondary_tree_len, 6, NUM_SECONDARY_LENGTHS);
	memset(context->enc_aligned_tree_len, 3, ALIGNED_NUM_ELEMENTS);
    prevent_far_matches(context); /* prevent far match 2's from being taken */

	context->enc_bufpos_at_last_block			= context->enc_BufPos;
	context->enc_earliest_window_data_remaining	= context->enc_BufPos;
	context->enc_input_running_total			= 0;
	context->enc_first_time_this_group			= true;

	/* Clear the literal types array */
	memset(context->enc_ItemType, 0, MAX_LITERAL_ITEMS/8);
	
	/* No literals or distances encoded yet */
	context->enc_literals      = 0;
	context->enc_distances     = 0;

    /* No block splits yet */
    context->enc_num_block_splits = 0;

	context->enc_repeated_offset_at_literal_zero[0] = 1;
	context->enc_repeated_offset_at_literal_zero[1] = 1;
	context->enc_repeated_offset_at_literal_zero[2] = 1;

	/* reset instruction pointer (for translation) to zero */
	reset_translation(context);

    context->enc_num_cfdata_frames = 0;
}


/*
 * Allocate memory for the compressor
 *
 * Returns true if successful, false otherwise
 */
bool comp_alloc_compress_memory(t_encoder_context *context)
{
	ulong	pos_start;

#ifdef MULTIPLE_SEARCH_TREES
	context->enc_tree_root		= NULL;
#endif
	context->enc_RealLeft		= NULL;
	context->enc_RealRight		= NULL;
	context->enc_MemWindow		= NULL;
	context->enc_decision_node	= NULL;
	context->enc_LitData		= NULL;
	context->enc_DistData		= NULL;
	context->enc_ItemType		= NULL;
    context->enc_output_buffer_start = NULL;

	/* ALSO NULLIFY BUFFERS! */

	/*
	 * Determine the number of position slots in the main tree
	 */
	context->enc_num_position_slots	= 4;
	pos_start				= 4;

	while (1)
	{
		pos_start += 1 << enc_extra_bits[context->enc_num_position_slots];

		context->enc_num_position_slots++;

		if (pos_start >= context->enc_window_size)
			break;
	}

#ifdef MULTIPLE_SEARCH_TREES
	context->enc_tree_root = (ulong *) context->enc_malloc(
		sizeof(context->enc_tree_root[0]) * NUM_SEARCH_TREES
	);

	if (context->enc_tree_root == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}
#endif

	context->enc_RealLeft = (ulong *) context->enc_malloc(
   		sizeof(ulong) * MEM_WINDOW_ALLOC_SIZE
	);

	if (context->enc_RealLeft == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_RealRight = (ulong *) context->enc_malloc(
   		sizeof(ulong) * MEM_WINDOW_ALLOC_SIZE
	);
	
	if (context->enc_RealRight == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_RealMemWindow = (byte *) context->enc_malloc(MEM_WINDOW_ALLOC_SIZE);
	
	if (context->enc_RealMemWindow == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_MemWindow = context->enc_RealMemWindow;

	context->enc_LitData = (byte *) context->enc_malloc(MAX_LITERAL_ITEMS * sizeof(*context->enc_LitData));

	if (context->enc_LitData == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_DistData = (ulong *) context->enc_malloc(MAX_DIST_ITEMS * sizeof(*context->enc_DistData));

	if (context->enc_DistData == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_ItemType = (byte *) context->enc_malloc(MAX_LITERAL_ITEMS/8);

	if (context->enc_ItemType == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	create_slot_lookup_table(context);
	create_ones_table(context);

	if (init_compressed_output_buffer(context) == false)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_decision_node = context->enc_malloc(
		sizeof(decision_node) * (LOOK+MAX_MATCH+16)
	);

	if (context->enc_decision_node == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_allocated_compression_memory = true;
	
	/* success */
	return true;
}


void comp_free_compress_memory(t_encoder_context *context)
{
#ifdef MULTIPLE_SEARCH_TREES
	if (context->enc_tree_root)
	{
		context->enc_free((byte *) context->enc_tree_root);
		context->enc_tree_root = NULL;
	}
#endif

	if (context->enc_RealLeft)
	{
		context->enc_free((byte *) context->enc_RealLeft);
		context->enc_RealLeft = NULL;
	}

	if (context->enc_RealRight)
	{
		context->enc_free((byte *) context->enc_RealRight);
		context->enc_RealRight = NULL;
	}

	if (context->enc_RealMemWindow)
	{
		context->enc_free((byte *) context->enc_RealMemWindow);
		context->enc_RealMemWindow = NULL;
		context->enc_MemWindow = NULL;
	}

	if (context->enc_LitData)
	{
		context->enc_free(context->enc_LitData);
		context->enc_LitData = NULL;
	}

	if (context->enc_DistData)
	{
		context->enc_free((byte *) context->enc_DistData);
		context->enc_DistData = NULL;
	}

	if (context->enc_ItemType)
	{
		context->enc_free(context->enc_ItemType);
		context->enc_ItemType = NULL;
	}

	if (context->enc_decision_node)
	{
		context->enc_free((byte *) context->enc_decision_node);
		context->enc_decision_node = NULL;
	}

	free_compressed_output_buffer(context);

	context->enc_allocated_compression_memory = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\encvars.h ===
/*
 * encvars.h
 *
 * Variables for the compressor
 */

#ifdef ALLOC_VARS
#	undef EXT
#	define EXT
#else
#   undef EXT
#   define EXT extern
#endif


/*
 * For the optimal parser
 *
 * Uses less memory if it's ushort, but then we're forcing the CPU
 * to do 16 bit operations.  
 *
 * Change this to ulong if you don't mind a small memory hit.
 * Also, if you make LOOK too large, this number may cause the
 * cost estimation to overflow; e.g. 10000 uncompressed symbols
 * @ 8 bits each > 65535 bits.
 */
typedef ulong		numbits_t;


/*
 * For the optimal parser
 */
typedef struct
{
	ulong			link;
	ulong			path;
	ulong			repeated_offset[NUM_REPEATED_OFFSETS];
	numbits_t		numbits;
} decision_node;


/*
 * 8 * max_position_slots(50) = 656
 */
#define MAX_MAIN_TREE_ELEMENTS 700

typedef struct
{
	/* "fake" window pointer, based on enc_RealMemWindow */
	byte				*enc_MemWindow;

	ulong				enc_window_size;

#ifdef MULTIPLE_SEARCH_TREES
	/* root node pointers for our search trees */
	ulong				*enc_tree_root;
#else /* !MULTIPLE_SEARCH_TREES */
	ulong				 enc_single_tree_root;
#endif /* MULTIPLE_SEARCH_TREES */

	/* "fake" start of left nodes */
	ulong				*enc_Left;

	/* "fake" start of right nodes */
	ulong				*enc_Right;

	/* bitwise outputting */
	ulong               enc_bitbuf;
	signed char			enc_bitcount;
    bool                enc_output_overflow;
    char                pad1[2];

	/* used to record literals and displacements */
	ulong               enc_literals;    /* current number of literals */
	ulong               enc_distances;   /* current number of displacements */
	ulong              *enc_DistData;		/* match displacement array */
	byte               *enc_LitData;     /* contains a character or a matchlength */
	byte               *enc_ItemType;  /* bitmap for whether it's a character or matchlength */
	ulong				enc_repeated_offset_at_literal_zero[NUM_REPEATED_OFFSETS];

	/*
	 * the last three match offsets (displacements) encoded, the most recent
	 * one being enc_last_matchpos_offset[0]. 
	 */
	ulong				enc_last_matchpos_offset[NUM_REPEATED_OFFSETS];

	/* used for optimal parsing */
	ulong               enc_matchpos_table[MAX_MATCH+1];

	/* current encoding position in data */
	ulong				enc_BufPos;

	/* lookup table for converting a match position into a slot */
	byte                enc_slot_table[1024];

	/* buffering the output data */
	byte                *enc_output_buffer_start; 
	byte                *enc_output_buffer_curpos; 
	byte                *enc_output_buffer_end; 
	ulong				enc_input_running_total;
	ulong				enc_bufpos_last_output_block;

	/* number of distinct position slots */
	ulong               enc_num_position_slots;

	/* misc */
	ulong               enc_file_size_for_translation;

	bool                enc_allocated_compression_memory;

    /* number of block splits for this 32K of uncompressed data */
    byte                enc_num_block_splits;

	/* the number of 1 bits in any given integer */
	byte				enc_ones[256];

	/* compression parameters */
	byte				enc_first_block;
	bool				enc_need_to_recalc_stats;
	bool				enc_first_time_this_group;
	ulong				enc_encoder_second_partition_size;
	ulong				enc_earliest_window_data_remaining;
	ulong				enc_bufpos_at_last_block;
	byte				*enc_input_ptr;
	long				enc_input_left;
	ulong				enc_instr_pos;

	/* for tree.c */
	ushort				*enc_tree_freq;
	ushort				*enc_tree_sortptr;
	byte				*enc_len;
	short				enc_tree_heap[MAX_MAIN_TREE_ELEMENTS + 2];
	ushort				enc_tree_leftright[2*(2*MAX_MAIN_TREE_ELEMENTS-1)];
	ushort				enc_tree_len_cnt[17];
	int					enc_tree_n;
	short				enc_tree_heapsize;
	char				enc_depth;

	ulong				enc_next_tree_create;
	ulong				enc_last_literals;
	ulong				enc_last_distances;
	decision_node		*enc_decision_node;

	/* trees */
	byte				enc_main_tree_len[MAX_MAIN_TREE_ELEMENTS+1];
	byte				enc_secondary_tree_len[NUM_SECONDARY_LENGTHS+1];

	ushort				enc_main_tree_freq[MAX_MAIN_TREE_ELEMENTS*2];
	ushort				enc_main_tree_code[MAX_MAIN_TREE_ELEMENTS];
	byte				enc_main_tree_prev_len[MAX_MAIN_TREE_ELEMENTS+1];

	ushort				enc_secondary_tree_freq[NUM_SECONDARY_LENGTHS*2];
	ushort				enc_secondary_tree_code[NUM_SECONDARY_LENGTHS];
	byte				enc_secondary_tree_prev_len[NUM_SECONDARY_LENGTHS+1];

	ushort				enc_aligned_tree_freq[ALIGNED_NUM_ELEMENTS*2];
	ushort				enc_aligned_tree_code[ALIGNED_NUM_ELEMENTS];
	byte				enc_aligned_tree_len[ALIGNED_NUM_ELEMENTS];
	byte				enc_aligned_tree_prev_len[ALIGNED_NUM_ELEMENTS];

	/* start of allocated window memory */
	byte				*enc_RealMemWindow;

	/* start of allocated left nodes */
	ulong				*enc_RealLeft;

	/* start of allocated right nodes */
	ulong				*enc_RealRight;

    /* # cfdata frames this folder */
    ulong               enc_num_cfdata_frames;

	/* misc */
    void                *enc_fci_data;

	PFNALLOC			enc_malloc;
	PFNFREE				enc_free;

	int FAR (DIAMONDAPI *enc_output_callback_function)(
		void *			pfol,
		unsigned char *	compressed_data,
		long			compressed_size,
		long			uncompressed_size
	);


} t_encoder_context;


/*
 * Declare arrays? 
 */

#ifdef ALLOC_VARS

/*
 * (1 << extra_bits[n])-1 
 */
const ulong enc_slot_mask[] =
{
	     0,      0,      0,      0,     1,       1,      3,      3,
	     7,      7,     15,     15,    31,      31,     63,     63,
	   127,    127,    255,    255,   511,     511,   1023,   1023,
	  2047,   2047,   4095,   4095,  8191,    8191,  16383,  16383,
	 32767,  32767,  65535,  65535, 131071, 131071, 131071, 131071,
	131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
	131071, 131071, 131071
};

const byte enc_extra_bits[] =   
{
	0,0,0,0,1,1,2,2,
	3,3,4,4,5,5,6,6,
	7,7,8,8,9,9,10,10,
	11,11,12,12,13,13,14,14,
	15,15,16,16,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17
};

#else

extern const ulong enc_slot_mask[];
extern const byte enc_extra_bits[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\lci.c ===
/*
 * LCI.C
 */

/* --- preprocessor ------------------------------------------------------- */

#include <stdio.h>          /* for NULL */
#include <string.h>         /* for memcpy() */

#include "encoder.h"
#include "lci.h"            /* types, prototype verification, error codes */


/*
 * Default file size for E8 translation
 */
#define DEFAULT_FILE_XLAT_SIZE 12000000


/*  MAKE_SIGNATURE - Construct a structure signature
 *
 *  Entry:
 *      a,b,c,d - four characters
 *
 *  Exit:
 *      Returns constructed SIGNATURE
 *
 *  Example:
 *      strct->signature = MAKE_SIGNATURE('b','e','n','s')
 */

#define MAKE_SIGNATURE(a,b,c,d) (a + (b<<8) + (c<<16) + (d<<24))
#define BAD_SIGNATURE   (0L)
#define LCI_SIGNATURE   MAKE_SIGNATURE('L','C','I','C')

/* --- LCI context structure ---------------------------------------------- */

typedef ULONG SIGNATURE;    /* structure signature */

struct LCI_CONTEXT          /* private structure */
{
    SIGNATURE signature;    /* for validation */
    PFNALLOC pfnAlloc;      /* memory alloc function */
    PFNFREE pfnFree;        /* memory free function */
    UINT cbDataBlockMax;    /* promised max data size */
    unsigned long file_translation_size;
	t_encoder_context *encoder_context;
};

typedef struct LCI_CONTEXT FAR *PMCC_CONTEXT;       /* a pointer to one */

#define PMCCfromHMC(h) ((PMCC_CONTEXT)(h))          /* handle to pointer */
#define HMCfromPMCC(p) ((LCI_CONTEXT_HANDLE)(p))    /* pointer to handle */


/* --- local variables ---------------------------------------------------- */

int DIAMONDAPI LCICreateCompression(
        UINT *          pcbDataBlockMax,    /* max uncompressed data block */
        void FAR *      pvConfiguration,    /* implementation-defined */
        PFNALLOC        pfnma,              /* Memory allocation function */
        PFNFREE         pfnmf,              /* Memory free function */
        UINT *          pcbDstBufferMin,    /* gets required output buffer */
        LCI_CONTEXT_HANDLE * pmchHandle,    /* gets newly-created handle */
		int FAR (DIAMONDAPI *pfnlzx_output_callback)(
			void *			pfol,
			unsigned char *	compressed_data,
			long			compressed_size,
			long			uncompressed_size
        ),
       void FAR *      fci_data
)

{
    PMCC_CONTEXT			context;                   /* new context */
	FAR PLZXCONFIGURATION	plConfiguration;

    *pmchHandle = (LCI_CONTEXT_HANDLE) 0;   /* wait until it's valid */

	plConfiguration = (PLZXCONFIGURATION) pvConfiguration;

    context = pfnma(sizeof(struct LCI_CONTEXT));

    if (context == NULL)
        return(MCI_ERROR_NOT_ENOUGH_MEMORY);    /* if can't allocate */

    context->file_translation_size = DEFAULT_FILE_XLAT_SIZE;

	context->encoder_context = pfnma(sizeof(*context->encoder_context));

	if (context->encoder_context == NULL)
	{
		pfnmf(context);
        return(MCI_ERROR_NOT_ENOUGH_MEMORY);    /* if can't allocate */
	}

	if (LZX_EncodeInit(
			context->encoder_context,
			plConfiguration->WindowSize, 
			plConfiguration->SecondPartitionSize,
			pfnma,
			pfnmf,
            pfnlzx_output_callback,
            fci_data
			) == false)
	{
		pfnmf(context->encoder_context);
		pfnmf(context);
		return MCI_ERROR_NOT_ENOUGH_MEMORY;
	}

    context->pfnAlloc = pfnma;
    context->pfnFree  = pfnmf;
    context->cbDataBlockMax = *pcbDataBlockMax;   /* remember agreement */
    context->signature = LCI_SIGNATURE;

    *pcbDstBufferMin =                      /* we'll expand sometimes */
            *pcbDataBlockMax + MAX_GROWTH;

    /* pass context back to caller */
    *pmchHandle = HMCfromPMCC(context);

    return(MCI_ERROR_NO_ERROR);             /* tell caller all is well */
}


int DIAMONDAPI LCICompress(
        LCI_CONTEXT_HANDLE  hmc,            /* compression context */
        void FAR *          pbSrc,          /* source buffer */
        UINT                cbSrc,          /* source actual size */
        void FAR *          pbDst,          /* target buffer */
        UINT                cbDst,          /* size of target buffer */
        ULONG *             pcbResult)      /* gets target actual size */
{
    PMCC_CONTEXT context;                   /* pointer to the context */
	long	estimated_leftover_bytes;

    context = PMCCfromHMC(hmc);             /* get pointer from handle */

    if (context->signature != LCI_SIGNATURE)
    {
        return(MCI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

    if (cbSrc > context->cbDataBlockMax)
    {
        return(MCI_ERROR_BAD_PARAMETERS);   /* violated max block promise */
    }

    if (cbDst < (context->cbDataBlockMax + MAX_GROWTH))
    {
        return(MCI_ERROR_BAD_PARAMETERS);   /* violated min buffer request */
    }

	if (ENCODER_SUCCESS == LZX_Encode(
		context->encoder_context,
		pbSrc,
		cbSrc,
		&estimated_leftover_bytes,
        context->file_translation_size))
	{
		*pcbResult = estimated_leftover_bytes;
		return MCI_ERROR_NO_ERROR;
	}
	else
	{
		*pcbResult = 0;
		return MCI_ERROR_FAILED;
	}
}


int DIAMONDAPI LCIFlushCompressorOutput(LCI_CONTEXT_HANDLE hmc)
{
    PMCC_CONTEXT context;                   /* pointer to context */

    context = PMCCfromHMC(hmc);             /* get pointer from handle */

    if (context->signature != LCI_SIGNATURE)
    {
        return(MCI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

	(void) LZX_EncodeFlush(context->encoder_context);

	return MCI_ERROR_NO_ERROR;
}



/* --- LCIResetCompression() ---------------------------------------------- */

int DIAMONDAPI LCIResetCompression(LCI_CONTEXT_HANDLE hmc)
{
    PMCC_CONTEXT context;                   /* pointer to the context */

    context = PMCCfromHMC(hmc);             /* get pointer from handle */

    if (context->signature != LCI_SIGNATURE)
    {
		return(MCI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

	LZX_EncodeNewGroup(context->encoder_context);

    return(MCI_ERROR_NO_ERROR);             /* if tag is OK */
}


/* --- LCIDestroyCompression() -------------------------------------------- */

int DIAMONDAPI LCIDestroyCompression(LCI_CONTEXT_HANDLE hmc)
{
    PMCC_CONTEXT context;                   /* pointer to context */

    context = PMCCfromHMC(hmc);             /* get pointer from handle */

    if (context->signature != LCI_SIGNATURE)
    {
        return(MCI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

	LZX_EncodeFree(context->encoder_context);
	context->pfnFree(context->encoder_context);

    context->signature = BAD_SIGNATURE;     /* destroy signature */

    context->pfnFree(context);              /* self-destruct */

    return(MCI_ERROR_NO_ERROR);             /* success */
}


int DIAMONDAPI LCISetTranslationSize(LCI_CONTEXT_HANDLE hmc, unsigned long size)
{
    PMCC_CONTEXT context;                   /* pointer to context */

    context = PMCCfromHMC(hmc);             /* get pointer from handle */

    if (context->signature != LCI_SIGNATURE)
    {
        return(MCI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }
       
    context->file_translation_size = size;
    return(MCI_ERROR_NO_ERROR);             /* success */
}


unsigned char * FAR DIAMONDAPI LCIGetInputData(
    LCI_CONTEXT_HANDLE hmc,
    unsigned long *input_position,
    unsigned long *bytes_available
)
{
    PMCC_CONTEXT context;                   /* pointer to context */

    context = PMCCfromHMC(hmc);             /* get pointer from handle */

    if (context->signature != LCI_SIGNATURE)
    {
        *bytes_available = 0;
        return (unsigned char *) NULL;
    }

    return LZX_GetInputData(context->encoder_context, input_position, bytes_available);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\lci.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1996
 *  All Rights Reserved.
 *
 *  LCI.H - Diamond Memory Compression Interface (LCI)
 *
 *  History:
 *      03-Jul-1996     jforbes     Created from QCI.H
 *
 *  Functions:
 *      LCICreateCompression    - Create and reset an LCI compression context
 *      LCICompress             - Compress a block of data
 *      LCIResetCompression     - Reset compression context
 *      LCIDestroyCompression   - Destroy LCI compression context
 *      LCISetTranslationSize   - Set file translation size
 *
 *  Types:
 *      LCI_CONTEXT_HANDLE      - Handle to an LCI compression context
 *      PFNALLOC                - Memory allocation function for LCI
 *      PFNFREE                 - Free memory function for LCI
 */

/* --- types -------------------------------------------------------------- */

#include <basetsd.h>

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif

#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef unsigned char  BYTE;
#endif

#ifndef _UINT_DEFINED
#define _UINT_DEFINED
typedef unsigned int  UINT;
#endif

#ifndef _ULONG_DEFINED
#define _ULONG_DEFINED
typedef unsigned long  ULONG;
#endif

#ifndef FAR
#ifdef BIT16
#define FAR far
#else
#define FAR
#endif
#endif

#ifndef HUGE
#ifdef BIT16
#define HUGE huge
#else
#define HUGE
#endif
#endif

#ifndef _MI_MEMORY_DEFINED
#define _MI_MEMORY_DEFINED
typedef void HUGE *  MI_MEMORY;
#endif

#ifndef _MHANDLE_DEFINED
#define _MHANDLE_DEFINED
#if defined(_AMD64_) || defined(IA64)
typedef ULONG_PTR MHANDLE;
#else
typedef unsigned long  MHANDLE;
#endif
#endif

/* --- LCI-defined types -------------------------------------------------- */

/* LCI_CONTEXT_HANDLE - Handle to an LCI compression context */

typedef MHANDLE LCI_CONTEXT_HANDLE;      /* hmc */


/***    PFNALLOC - Memory allocation function for LCI
 *
 *  Entry:
 *      cb - Size in bytes of memory block to allocate
 *
 *  Exit-Success:
 *      Returns !NULL pointer to memory block
 *
 *  Exit-Failure:
 *      Returns NULL; insufficient memory
 */
#ifndef _PFNALLOC_DEFINED
#define _PFNALLOC_DEFINED
typedef MI_MEMORY (FAR DIAMONDAPI *PFNALLOC)(ULONG cb);       /* pfnma */
#endif


/***    PFNFREE - Free memory function for LCI
 *
 *  Entry:
 *      pv - Memory block allocated by matching PFNALLOC function
 *
 *  Exit:
 *      Memory block freed.
 */
#ifndef _PFNFREE_DEFINED
#define _PFNFREE_DEFINED
typedef void (FAR DIAMONDAPI *PFNFREE)(MI_MEMORY pv);          /* pfnmf */
#endif

/* --- prototypes --------------------------------------------------------- */

/***    LCICreateCompression - Create LCI compression context
 *
 *  Entry:
 *      pcbDataBlockMax     *largest uncompressed data block size desired,
 *                          gets largest uncompressed data block allowed
 *      pvConfiguration     passes implementation-specific info to compressor.
 *      pfnma               memory allocation function pointer
 *      pfnmf               memory free function pointer
 *      pcbDstBufferMin     gets required compressed data buffer size
 *      pmchHandle          gets newly-created context's handle
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      *pcbDataBlockMax, *pcbDstBufferMin, *pmchHandle filled in.
 *
 *  Exit-Failure:
 *      MCI_ERROR_NOT_ENOUGH_MEMORY, could not allocate enough memory.
 *      MCI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 */
int FAR DIAMONDAPI LCICreateCompression(
        UINT FAR *      pcbDataBlockMax,  /* max uncompressed data block size */
        void FAR *      pvConfiguration,  /* See LZXCONFIGURATION */
        PFNALLOC        pfnma,            /* Memory allocation function ptr */
        PFNFREE         pfnmf,            /* Memory free function ptr */
        UINT FAR *      pcbDstBufferMin,  /* gets required output buffer size */
        LCI_CONTEXT_HANDLE FAR *pmchHandle, /* gets newly-created handle */
		int FAR	(DIAMONDAPI *pfnlzx_output_callback)(
			void *			pfol,
			unsigned char *	compressed_data,
			long			compressed_size,
			long			uncompressed_size
        ),
        void FAR *      fci_pv // not the same as the FCI client's pv
);  


/***    LCICompress - Compress a block of data
 *
 *  Entry:
 *      hmc                 handle to compression context
 *      pbSrc               source buffer (uncompressed data)
 *      cbSrc               size of data to be compressed
 *      pbDst               destination buffer (for compressed data)
 *      cbDst               size of destination buffer
 *      pcbResult           receives compressed size of data
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      *pcbResult has size of compressed data in pbDst.
 *      Compression context possibly updated.
 *
 *  Exit-Failure:
 *      MCI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 */
int FAR DIAMONDAPI LCICompress(
        LCI_CONTEXT_HANDLE  hmc,         /* compression context */
        void FAR *          pbSrc,       /* source buffer */
        UINT                cbSrc,       /* source buffer size */
        void FAR *          pbDst,       /* target buffer */
        UINT                cbDst,       /* target buffer size */
        ULONG FAR *         pcbResult);  /* gets target data size */


/***    LCIResetCompression - Reset compression history (if any)
 *
 *  De-compression can only be started on a block which was compressed
 *  immediately following a LCICreateCompression() or LCIResetCompression()
 *  call.  This function forces such a new "compression boundary" to be
 *  created (only by causing the compressor to ignore history, can the data
 *  output be decompressed without history.)
 *
 *  Entry:
 *      hmc - handle to compression context
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      Compression context reset.
 *
 *  Exit-Failure:
 *      Returns MCI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI LCIResetCompression(LCI_CONTEXT_HANDLE hmc);


/***    LCIDestroyCompression - Destroy LCI compression context
 *
 *  Entry:
 *      hmc - handle to compression context
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      Compression context destroyed.
 *
 *  Exit-Failure:
 *      Returns MCI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI LCIDestroyCompression(LCI_CONTEXT_HANDLE hmc);


/*
 * Forces encoder to flush remaining output
 */
int FAR DIAMONDAPI LCIFlushCompressorOutput(LCI_CONTEXT_HANDLE hmc);


/*
 * Set the file translation size
 * (this must be done immediately after a reset, or an LCICreateCompression)
 */
int FAR DIAMONDAPI LCISetTranslationSize(LCI_CONTEXT_HANDLE hmc, unsigned long size);


/*
 * Returns a pointer to the input data present in LZX's buffers.
 *
 * input_position is the offset of the data from the beginning of the file
 * bytes_available is the number of bytes available from that offset
 */
unsigned char * FAR DIAMONDAPI LCIGetInputData(
    LCI_CONTEXT_HANDLE hmc,
    unsigned long *input_position,
    unsigned long *bytes_available
);



/* --- constants ---------------------------------------------------------- */

/* return codes */

#define     MCI_ERROR_NO_ERROR              0
#define     MCI_ERROR_NOT_ENOUGH_MEMORY     1
#define     MCI_ERROR_BAD_PARAMETERS        2
#define     MCI_ERROR_BUFFER_OVERFLOW       3
#define     MCI_ERROR_FAILED                4
#define     MCI_ERROR_CONFIGURATION         5

/* --- LZX configuration details ------------------------------------- */

/***    LZX pvConfiguration structure
 *
 * The SecondPartitionSize must be >= 32K.  It is the amount of
 * data which LZX compresses before copymem'ing the window and
 * tree contents around.
 */

#pragma pack (2)

typedef struct {
    int WindowSize;           // buffer size
    int SecondPartitionSize;  
} LZXCONFIGURATION; /* lcfg */

#pragma pack ()

typedef LZXCONFIGURATION *PLZXCONFIGURATION; /* plcfg */

/* ----------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\offsets.c ===
/*
 * offsets.c
 *
 * Used by makefile to generate ASM include file OFFSET.I
 * which contains numbers for offsets into the context structure.
 */
#include "encoder.h"
#include <stdio.h>

t_encoder_context p;

void main(void)
{
    printf("OFF_MEM_WINDOW              EQU %d\n", (byte *) &p.enc_MemWindow - (byte *) &p);
    printf("OFF_WINDOW_SIZE             EQU %d\n", (byte *) &p.enc_window_size - (byte *) &p);
#ifdef MULTIPLE_SEARCH_TREES
    printf("OFF_TREE_ROOT               EQU %d\n", (byte *) &p.enc_tree_root - (byte *) &p);
#else
    printf("OFF_SINGLE_TREE_ROOT        EQU %d\n", (byte *) &p.enc_single_tree_root - (byte *) &p);
#endif
    printf("OFF_LEFT                    EQU %d\n", (byte *) &p.enc_Left - (byte *) &p);
    printf("OFF_RIGHT                   EQU %d\n", (byte *) &p.enc_Right - (byte *) &p);
    printf("OFF_MATCHPOS_TABLE          EQU %d\n", (byte *) &p.enc_matchpos_table - (byte *) &p);
    printf("OFF_LAST_MATCHPOS_OFFSET    EQU %d\n", (byte *) &p.enc_last_matchpos_offset - (byte *) &p);
	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\msdasc\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( msdasc )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( msdasc ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\search.asm ===
;
; search.asm
;
; 08/16/96  jforbes  ASM implementation of binary_search_findmatch()
;
; There is a fair amount of optimisation towards instruction-scheduling.
;
; About 58% of the time is spent in the binary_search_findmatch()
; routine.  Around 31% is spent in the optimal parser.
;
    TITLE   SEARCH.ASM
    .386P
.model FLAT

PUBLIC  _binary_search_findmatch

_TEXT   SEGMENT

INCLUDE offsets.i

$match_length   EQU 0
$small_len      EQU 4
$small_ptr      EQU 8
$big_ptr        EQU 12
$end_pos        EQU 16
$clen           EQU 20
$left           EQU 24
$right          EQU 28
$mem_window     EQU 32
$matchpos_table EQU 36
$context        EQU 40
$best_repeat    EQU 44
LOCAL_STACK     EQU 48


MIN_MATCH       EQU 2
MAX_MATCH       EQU 257
BREAK_LENGTH    EQU 50

;
; binary_search_findmatch(t_encoder_context *context, long BufPos)
;
_binary_search_findmatch PROC NEAR

    push    ebx
    push    ecx

    push    edx
    push    esi

    push    edi
    push    ebp

    mov     ebp, [esp + 28] ; context
    mov     esi, [esp + 32] ; bufpos

; tree_to_use = *((ushort *) &enc_MemWindow[BufPos])
    mov     edi, [ebp + OFF_MEM_WINDOW]     ; edi = _enc_MemWindow

    xor     eax, eax
    mov     ax, WORD PTR [edi + esi]        ; eax = tree_to_use

    sub     esp, LOCAL_STACK                ; allocate space for stack vars

    mov     [esp + $mem_window], edi
    mov     [esp + $context], ebp

    lea     ecx, [ebp + OFF_MATCHPOS_TABLE] 
    mov     [esp + $matchpos_table], ecx

    mov     ecx, [ebp + OFF_TREE_ROOT]
    mov     ebx, [ecx + eax*4]              ; ebx = tree_root[tree_to_use]
    mov     [ecx + eax*4], esi              ; tree_root[tree_to_use] = bufpos

    lea     edx, [esi + 4]                  ; edx = BufPos+4
    sub     edx, [ebp + OFF_WINDOW_SIZE]    ; endpos = BufPos-(ws-4)
    mov     [esp + $end_pos], edx



; if (ptr <= endpos)
; have a short "stub" jump so that the jump is paired
    cmp     ebx, edx
    jle     SHORT close_ptr_le_endpos


;
; for main loop:
;
; eax = scratch
; ebx = ptr
; ecx = same
; edx = scratch
; esi = BufPos
; edi = scratch
; ebp = big_len
;

;
; The following instructions have been carefully
; interleaved for simultaneous execution on a Pentium's
; U and V pipelines.
;

    mov     edi, 2 ; commonly used constant here
    mov     edx, [ebp + OFF_LEFT]
    mov     [esp + $left], edx

    mov     [esp + $clen], edi                       ; clen = 2
    lea     edx, [edx + esi*4]                       ; edx = &Left[BufPos]

    lea     eax, [esi + edi]                         ; eax = BufPos+2
    mov     [esp + $small_ptr], edx                  ; smallptr=&Left[BufPos]

    mov     [esp + $match_length], edi               ; match_length = 2
    mov     edx, [ebp + OFF_RIGHT]
    mov     [esp + $right], edx

    sub     eax, ebx                                 ; eax = BufPos-ptr+2
    lea     edx, [edx + esi*4]                       ; edx = &Right[BufPos]

    mov     [esp + $small_len], edi                  ; small_len = 2

    mov     [esp + $big_ptr], edx                    ; bigptr=&Right[BufPos]
    mov     ecx, edi                                 ; same = 2 (first iter)

; enc_matchpos_table[2] = BufPos - ptr + 2
    mov     edi, [esp + $mem_window]
    mov     [ebp + OFF_MATCHPOS_TABLE + 8], eax

    add     edi, ecx         ; u    edi = &enc_MemWindow[clen]
    mov     ebp, 2           ; v    big_len = 2

    mov     eax, [edi + esi] ; u   *(DWORD*) enc_MemWindow[b] (bufpos+clen)
    jmp     SHORT main_loop  ; v


close_ptr_le_endpos:
    jmp     ptr_le_endpos



;
; same <= big_len
;
; this code is actually replicated much later in this file,
; but it's too far away for a SHORT jump, which will cause
; pipeline stalls.
;
close_same_le_biglen:
    mov     edx, [esp + $left]                       ; u
    mov     eax, [esp + $big_ptr]                    ; v

    lea     edi, [edx + ebx*4]                       ; u  edi=&Left[ptr]
    mov     [eax], ebx                               ; v  *big_ptr=ptr

    mov     [esp + $big_ptr], edi                    ; u  big_ptr=&left[ptr]
    mov     ecx, DWORD PTR [esp + $clen]             ; v  clen (next iter.)

    mov     ebx, [edi]                               ; u  ptr = *big_ptr
    mov     edi, [esp + $mem_window]                 ; v  (next iter.)

; bottom of main loop
    add     edi, ecx                          ; u  edi = &enc_MemWindow[clen]
    cmp     ebx, [esp + $end_pos]             ; v  

; for next iteration
    mov     eax, [edi + esi] ; u   *(DWORD*) enc_MemWindow[b] (bufpos+clen)
    ja      SHORT main_loop  ; v

; fall through

close_exit_main_loop:
    jmp     exit_main_loop 


;
; same <= small_len
;
; ditto - see above
;
close_same_le_smalllen:
    mov     edx, [esp + $right]
    mov     eax, [esp + $small_ptr]

    lea     edi, [edx + ebx*4]  ; u  edi = &Right[ptr]
    mov     [eax], ebx          ; v  *small_ptr = ptr

    mov     [esp + $small_ptr], edi ; u  small_ptr = &right[ptr]
    mov     ecx, [esp + $clen]      ; v  for next iteration

    mov     ebx, [edi]              ; u  ptr = *small_ptr
    mov     edi, [esp + $mem_window] ; v  (next iter.)

; bottom of main loop
    add     edi, ecx                ; u  (next iter.)
    cmp     ebx, [esp + $end_pos]   ; v

    mov     eax, [edi + esi]        ; u  (next iter.)
    jna     SHORT close_exit_main_loop        ; v


; fall through to main loop


;
; at the bottom of the main loop, we goto here
;
main_loop:

;
; If the first characters don't match, then we know for
; certain that we have not exceeded small_len or big_len,
; and therefore clen won't change either.  We can therefore
; skip some of the checks.
;
; This is the most common case.
;
; These jumps must be SHORT to be paired.
;
    cmp     [edi + ebx], al              ; u
    ja      SHORT close_same_le_smalllen ; v

    jb      SHORT close_same_le_biglen   ; u

    shr     eax, 8                       ; u
    inc     ecx ; same++                 ; v

;
; second and further iterations
;
; we only check same (ecx) against MAX_MATCH
; every 4 characters
;
; operations paired for U and V pipeline
; simultaneous execution
;
; notes:
;    SHR must be on the U pipeline
;

unrolled_loop:

; 1
    cmp     [edi + ebx + 1], al    ; u
    jne     SHORT not_eq           ; v

    shr     eax, 8                 ; u
    inc     ecx                    ; v

; 2
    cmp     [edi + ebx + 2], al
    jne     SHORT not_eq

    shr     eax, 8
    inc     ecx

; 3
    cmp     [edi + ebx + 3], al
    jne     SHORT not_eq

    mov     eax, [edi + esi + 4]   ; u
    inc     ecx                    ; v

    mov     dl, [edi + ebx + 4]    ; u
    add     edi, 4                 ; v

; 4
    cmp     dl, al
    jne     SHORT not_eq

    shr     eax, 8
    inc     ecx

    cmp     ecx, MAX_MATCH
    jl      SHORT unrolled_loop

;
; clen >= MAX_MATCH
;
; ecx could be larger than MAX_MATCH right now,
; so correct it
;
    mov     edx, [esp + $match_length]
    mov     ecx, MAX_MATCH
    jmp     SHORT long_match



same1_ge_break_length:
same2_ge_break_length:

; can trash clen (ecx)
    
; ecx = left
    mov     ecx, [esp + $left]

; eax = small_ptr
    mov     eax, [esp + $small_ptr]

; ecx = Left[ptr]
    mov     ecx, [ecx + ebx*4]

; edx = Right
    mov     edx, [esp + $right]

; *small_ptr = left[ptr]
    mov     [eax], ecx

; *big_ptr = right[ptr]
    mov     edx, [edx + ebx*4]

; *big_ptr = right[ptr]
    mov     eax, [esp + $big_ptr]
    mov     [eax], edx

; goto end_bsearch
    jmp     end_bsearch


;
; warning, "same" (ecx) could be larger than
; MAX_MATCH, so we will have to correct it
;
not_eq:
    ja      val_greater_than_0


;
; -----------------------------------------
; VAL < 0
; -----------------------------------------
;
val_less_than_0:

; if (same > big_len)
    cmp     ecx, ebp
    jle     SHORT same_le_biglen

; if (same > match_length)
    cmp     ecx, [esp + $match_length]
    jle     SHORT same1_le_ml

; here's where we truncate ecx to MAX_MATCH if it
; was too large
    cmp     ecx, MAX_MATCH
    jg      SHORT trunc_same1

back_from_trunc1:
long_match:
    mov     edi, [esp + $matchpos_table]
    lea     eax, [esi + 2]

; eax = BufPos-ptr+2
    mov     edx, [esp + $match_length]
    sub     eax, ebx

; do
; {
;    enc_matchpos_table[++match_length] = BufPos-ptr+2
; } while (match_length < same);

; store match_length
    mov     [esp + $match_length], ecx

loop1:

; match_length++
    inc     edx

; enc_matchpos_table[match_length] = BufPos-ptr+2
    mov     [edi + edx*4], eax

; while (match_length < same) 
    cmp     edx, ecx
    jl      SHORT loop1

; if (same >= BREAK_LENGTH)
    cmp     ecx, BREAK_LENGTH
    jge     SHORT same1_ge_break_length


; same <= match_length

same1_le_ml:

; clen = min(small_len, big_len=same)
    cmp     [esp + $small_len], ecx

; big_len = same
    mov     ebp, ecx

; small_len >= same?
    jge     SHORT over1

; no, small_len < same
; therefore clen := small_len
; (otherwise clen stays at big_len which ==same)
    mov     ecx, [esp + $small_len]

over1:
    mov     [esp + $clen], ecx


;
; same <= big_len
;
same_le_biglen:

    mov     edx, [esp + $left]                       ; u
    mov     eax, [esp + $big_ptr]                    ; v

    lea     edi, [edx + ebx*4]                       ; u  edi=&Left[ptr]
    mov     [eax], ebx                               ; v  *big_ptr=ptr

    mov     [esp + $big_ptr], edi                    ; u  big_ptr=&left[ptr]
    mov     ecx, DWORD PTR [esp + $clen]             ; v  clen (next iter.)

    mov     ebx, [edi]                               ; u  ptr = *big_ptr
    mov     edi, [esp + $mem_window]                 ; v  (next iter.)

; bottom of main loop
    add     edi, ecx                          ; u  edi = &enc_MemWindow[clen]
    cmp     ebx, [esp + $end_pos]             ; v  

; for next iteration
    mov     eax, [edi + esi] ; u   *(DWORD*) enc_MemWindow[b] (bufpos+clen)
    ja      main_loop        ; v 

    jmp     exit_main_loop


trunc_same1:
    mov     ecx, MAX_MATCH
    jmp     SHORT back_from_trunc1


trunc_same2:
    mov     ecx, MAX_MATCH
    jmp     SHORT back_from_trunc2


; -----------------------------------------
; VAL > 0
; -----------------------------------------
val_greater_than_0:

; if (same > small_len)
    cmp     ecx, [esp + $small_len]
    jle     SHORT same_le_smalllen

; if (same > match_length)
    cmp     ecx, [esp + $match_length]
    jle     SHORT same2_le_ml

; here's where we truncate ecx to MAX_MATCH if it
; was too large
    cmp     ecx, MAX_MATCH
    jg      SHORT trunc_same2

; can trash clen
; ecx = BufPos-ptr+2
back_from_trunc2:
    mov     edi, [esp + $matchpos_table]
    lea     eax, [esi + 2]

    mov     edx, [esp + $match_length]
    sub     eax, ebx

    mov     [esp + $match_length], ecx

; do
; {
;    enc_matchpos_table[++match_length] = BufPos-ptr+2
; } while (match_length < same);

loop2:

    inc     edx        ; match_length++

; enc_matchpos_table[match_length] = BufPos-ptr+2
    mov     [edi + edx*4], eax

    cmp     edx, ecx
    jl      SHORT loop2

; if (same >= BREAK_LENGTH)
    cmp     ecx, BREAK_LENGTH
    jge     same2_ge_break_length


same2_le_ml:

    mov     edx, [esp + $small_len]

; clen = min(small_len=ecx, big_len)
    cmp     ebp, ecx

; small_len = same
    mov     [esp + $small_len], ecx

    jge     SHORT over2

; same = big_len
    mov     ecx, ebp

over2:
    mov     [esp + $clen], ecx


same_le_smalllen:

    mov     edx, [esp + $right]
    mov     eax, [esp + $small_ptr]

    lea     edi, [edx + ebx*4]  ; u  edi = &Right[ptr]
    mov     [eax], ebx          ; v  *small_ptr = ptr

    mov     [esp + $small_ptr], edi ; u  small_ptr = &right[ptr]
    mov     ecx, [esp + $clen]      ; v  for next iteration

    mov     ebx, [edi]              ; u  ptr = *small_ptr
    mov     edi, [esp + $mem_window] ; v  (next iter.)

; bottom of main loop
    add     edi, ecx                ; u  (next iter.)
    cmp     ebx, [esp + $end_pos]   ; v

    mov     eax, [edi + esi]        ; u  (next iter.)
    ja      main_loop


exit_main_loop:

    mov     eax, [esp + $small_ptr]
    mov     edx, [esp + $big_ptr]

; *small_ptr = 0
    mov     DWORD PTR [eax], 0

; *big_ptr = 0
    mov     DWORD PTR [edx], 0


end_bsearch:

;
; now check for repeated offsets
;

;
; FIRST REPEATED OFFSET
;
    mov     eax, [esp + $match_length]

; for (i = 0; i < match_length; i++)
;   compare bufpos+i vs. bufpos+i-enc_last_matchpos_offset[0]

    mov     edi, [esp + $mem_window]

; ebx = bufpos
    mov     ebx, esi

; repeated offset zero
; ebx = bufpos - repeated_offset[0]
    mov     ecx, [esp + $context]
    sub     ebx, [ecx + OFF_LAST_MATCHPOS_OFFSET]

; i = 0
    xor     ecx, ecx

rp1_loop:
    mov     dl, [edi + esi]
    cmp     dl, [edi + ebx]
    jne     SHORT rp1_mismatch

; i++
    inc     ecx

; inc window pointer
    inc     edi

; i < match_length?
    cmp     ecx, eax
    jl      SHORT rp1_loop


;
; i == match_length
;
; therefore force ourselves to take rp1
;
; (this code is not in the C source, since it is
;  messy to do)
;
    mov     ebx, [esp + $matchpos_table]

force_rp1_copy:
    mov     DWORD PTR [ebx + ecx*4], 0
    dec     ecx

    cmp     ecx, MIN_MATCH
    jge     SHORT force_rp1_copy

    jmp     boundary_check


;
; i < match_length
;
rp1_mismatch:

; best_repeated_offset = i
    mov     [esp + $best_repeat], ecx

; if (i >= MIN_MATCH)
    cmp     ecx, MIN_MATCH
    jl      SHORT try_rp2

; for (; i >= MIN_MATCH; i--)
;    enc_matchpos_table[i] = 0
    mov     ebx, [esp + $matchpos_table]

rp1_copy:
    mov     DWORD PTR [ebx + ecx*4], 0
    dec     ecx
    cmp     ecx, MIN_MATCH
    jge     SHORT rp1_copy

; quick check
    cmp     DWORD PTR [esp + $best_repeat], BREAK_LENGTH
    jg      boundary_check



;
; SECOND REPEATED OFFSET
;
try_rp2:

; for (i = 0; i < match_length; i++)
;   compare bufpos+i vs. bufpos+i-enc_last_matchpos_offset[1]

    mov     edi, [esp + $mem_window]

; ebx = bufpos
    mov     ebx, esi

; repeated offset zero
; ebx = bufpos - repeated_offset[1]
    mov     ecx, [esp + $context]
    sub     ebx, [ecx + OFF_LAST_MATCHPOS_OFFSET + 4]

; i = 0
    xor     ecx, ecx

rp2_loop:
    mov     dl, [edi + esi]

    cmp     dl, [edi + ebx]
    jne     SHORT rp2_mismatch

; i++
    inc     ecx

; inc window pointer
    inc     edi

; i < match_length?
    cmp     ecx, eax
    jl      SHORT rp2_loop

;
; i == match_length
;                                                                     
; therefore force ourselves to take rp2
;
; (this code is not in the C source, since it is
;  messy to do)
;
    mov     ebx, [esp + $matchpos_table]

force_rp2_copy:
    mov     DWORD PTR [ebx + ecx*4], 1
    dec     ecx
    cmp     ecx, MIN_MATCH
    jge     SHORT force_rp2_copy
    jmp     SHORT boundary_check


rp2_mismatch:

; if (i > best_repeated_offset)
    cmp     ecx, [esp + $best_repeat]
    jle     SHORT try_rp3

; do
;    enc_matchpos_table[++best_repeated_offset] =  1
; while (best_repeated_offset < i)

    mov     edi, [esp + $best_repeat]
    mov     ebx, [esp + $matchpos_table]

rp2_copy:                     
    inc     edi               ; ++best_repeated_offset
    mov     DWORD PTR [ebx + edi*4], 1
    cmp     edi, ecx          ; best_repeated_offset < i ? 
    jl      SHORT rp2_copy

; best_repeat = i
    mov     [esp + $best_repeat], ecx


;
; THIRD REPEATED OFFSET
;
try_rp3:

; for (i = 0; i < match_length; i++)
;   compare bufpos+i vs. bufpos+i-enc_last_matchpos_offset[2]

    mov     edi, [esp + $mem_window]

; ebx = bufpos
    mov     ebx, esi

; repeated offset zero
; ebx = bufpos - repeated_offset[2]
    mov     ecx, [esp + $context]
    sub     ebx, [ecx + OFF_LAST_MATCHPOS_OFFSET + 8]

; i = 0
    xor     ecx, ecx

rp3_loop:
    mov     dl, [edi + esi]

    cmp     dl, [edi + ebx]
    jne     SHORT rp3_mismatch

; i++
    inc     ecx

; inc window pointer
    inc     edi

; i < match_length?
    cmp     ecx, eax
    jl      SHORT rp3_loop

;
; i == match_length
;
; therefore force ourselves to take rp3
;
; (this code is not in the C source, since it is
;  messy to do)
;
    mov     ebx, [esp + $matchpos_table]

force_rp3_copy:
    mov     DWORD PTR [ebx + ecx*4], 2
    dec     ecx
    cmp     ecx, MIN_MATCH
    jge     SHORT force_rp3_copy
    jmp     SHORT boundary_check


rp3_mismatch:

; if (i > best_repeated_offset)
    cmp     ecx, [esp + $best_repeat]
    jle     SHORT boundary_check

; do
;    enc_matchpos_table[++best_repeated_offset] = 2
; while (best_repeated_offset < i)

    mov     edi, [esp + $best_repeat]
    mov     ebx, [esp + $matchpos_table]

rp3_copy:                     
    inc     edi               ; ++best_repeated_offset
    mov     DWORD PTR [ebx + edi*4], 2
    cmp     edi, ecx          ; best_repeated_offset < i ? 
    jl      SHORT rp3_copy


;
; Check that our match length does not cause us
; to cross a 32K boundary, and truncate if necessary.
;

; bytes_to_boundary = 32767 - (BufPos & 32767)
boundary_check:

    mov     edx, 32767
    and     esi, 32767
    mov     eax, [esp + $match_length]
    sub     edx, esi   ; edx = 32767 - (BufPos & 32767)

;
; if (matchlength <= bytes_to_boundary)
;    then we're ok
;
    cmp     eax, edx
    jle     SHORT does_not_cross

;
; otherwise we have to truncate the match
;
    mov     eax, edx

;
; if we truncate the match, does it become
; smaller than MIN_MATCH?
;
    cmp     edx, MIN_MATCH
    jge     SHORT ge_min_match

;
; yes, so we return that no matches at all
; were found
;
    xor     eax, eax

ge_min_match:
does_not_cross:

;
; return our match length in eax
;

cleanup:
    add     esp, LOCAL_STACK

    pop     ebp
    pop     edi
    pop     esi
    pop     edx
    pop     ecx
    pop     ebx

    ret     0



;
; ptr <= endpos
;
ptr_le_endpos:

;
; left[BufPos] = right[BufPos] = 0
;
    xor     eax, eax ; return match length zero

    mov     ecx, [ebp + OFF_LEFT]
    mov     edx, [ebp + OFF_RIGHT]

    mov     [ecx + esi*4], eax
    mov     [edx + esi*4], eax

; cleanup
    add     esp, LOCAL_STACK

    pop     ebp
    pop     edi

    pop     esi
    pop     edx

    pop     ecx
    pop     ebx

    ret     0


_binary_search_findmatch ENDP
_TEXT ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\tree.c ===
/*
 * tree.c
 *
 * Tree building routines.
 *
 * These routines are originally from the Public Domain source "AR001".
 *
 * However, they have been modified for use in LZX.
 */

#include "encoder.h"


/* Function prototypes */
static void downheap(t_encoder_context *context, short i);
static void make_tree2(t_encoder_context *context, short avail, ushort freqparm[], ushort codeparm[]);
static void make_len(t_encoder_context *context, short root);
static void make_code(t_encoder_context *context, int n, char len[], ushort code[]);


static void count_len(t_encoder_context *context, short i)  /* call with i = root */
{
	if (i < context->enc_tree_n)
		context->enc_tree_len_cnt[(context->enc_depth < 16) ? context->enc_depth : 16]++; /* NOTE: 16 is max len allowed */
	else
	{
		context->enc_depth++;
		count_len(context, context->enc_tree_leftright[i*2]);
		count_len(context, context->enc_tree_leftright[i*2+1]);
		context->enc_depth--;
	}
}


static void make_len(t_encoder_context *context, short root)
{
	signed short	k;
	ushort			cum;
	byte			i;

	for (i = 0; i <= 16; i++)
		context->enc_tree_len_cnt[i] = 0;

	count_len(context, root);

	cum = 0;

	for (i = 16; i > 0; i--)
		cum += (ushort) (context->enc_tree_len_cnt[i] << (16 - i));

	/* cum should equal 1<<16, which is 0 since cum is a ushort */
	while (cum)
	{
		context->enc_tree_len_cnt[16]--;

		for (i = 15; i > 0; i--)
		{
			if (context->enc_tree_len_cnt[i])
			{
				context->enc_tree_len_cnt[i]--;
				context->enc_tree_len_cnt[i+1] += 2;
				break;
			}
		}

		cum--;
	}

	for (i = 16; i > 0; i--)
	{
		k = context->enc_tree_len_cnt[i];

		while (--k >= 0)
			context->enc_len[*context->enc_tree_sortptr++] = (byte) i;
	}
}


static void __inline downheap(t_encoder_context *context, short i)
	/* priority queue; send i-th entry down heap */
{
	short  j, k;

	k = context->enc_tree_heap[i];

	while ((j = (i<<1)) <= context->enc_tree_heapsize)
	{
		if (j < context->enc_tree_heapsize && 
			context->enc_tree_freq[context->enc_tree_heap[j]] > context->enc_tree_freq[context->enc_tree_heap[j + 1]])
		 	j++;

		if (context->enc_tree_freq[k] <= context->enc_tree_freq[context->enc_tree_heap[j]])
			break;

		context->enc_tree_heap[i] = context->enc_tree_heap[j];
		i = j;
	}

	context->enc_tree_heap[i] = k;
}


static void make_code(t_encoder_context *context, int n, char len[], ushort code[])
{
    int    i;
	ushort start[18];

	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = (start[i] + context->enc_tree_len_cnt[i]) << 1;

	for (i = 0; i < n; i++)
	{
		code[i] = start[len[i]]++;
	}
}


void make_tree(
	t_encoder_context *context,
	int		nparm, 
	ushort	*freqparm, 
	byte	*lenparm, 
	ushort	*codeparm,
	bool	make_codes	/* for estimations, we only want the lengths */
)
{
	short i, avail;

REDO_TREE:
	context->enc_tree_n			= nparm;
	context->enc_tree_freq		= freqparm;
	context->enc_len				= lenparm;
	avail				= (short) context->enc_tree_n;
    context->enc_depth          = 0;
	context->enc_tree_heapsize	= 0;
	context->enc_tree_heap[1]	= 0;

	for (i = 0; i < nparm; i++)
	{
		context->enc_len[i] = 0;

		if (freqparm[i])
         context->enc_tree_heap[++context->enc_tree_heapsize] = i;
	}

	if (context->enc_tree_heapsize < 2)
	{
		if (!context->enc_tree_heapsize)
		{
			codeparm[context->enc_tree_heap[1]] = 0;
			return;
		}

		if (!context->enc_tree_heap[1])
			freqparm[1] = 1;
		else
			freqparm[0] = 1;

		goto REDO_TREE;
	}

	make_tree2(context, avail, freqparm, codeparm);

	if (make_codes)
		make_code(context, nparm, lenparm, codeparm);
}


static void make_tree2(
	t_encoder_context *context,
	short avail, 
	ushort freqparm[], 
	ushort codeparm[]
)
{
	short i, j, k;

	for (i = context->enc_tree_heapsize >> 1; i >= 1; i--)
		downheap(context, i);  /* make priority queue */

	context->enc_tree_sortptr = codeparm;

	do
	{	/* while queue has at least two entries */
		i = context->enc_tree_heap[1];  /* take out least-freq entry */

		if (i < context->enc_tree_n)
			*context->enc_tree_sortptr++ = i;

		context->enc_tree_heap[1] = context->enc_tree_heap[context->enc_tree_heapsize--];
		downheap(context, 1);

		j = context->enc_tree_heap[1];  /* next least-freq entry */

		if (j < context->enc_tree_n)
			*context->enc_tree_sortptr++ = j;

		k = avail++;  /* generate new node */

		freqparm[k] = freqparm[i] + freqparm[j];
		context->enc_tree_heap[1] = k;
		downheap(context, 1);  /* put into queue */

		context->enc_tree_leftright[k*2] = i;
		context->enc_tree_leftright[k*2+1] = j;

	} while (context->enc_tree_heapsize > 1);

	context->enc_tree_sortptr = codeparm;
	make_len(context, k);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\mqlogmgr\mqlogmgr.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    hlink.c

Abstract:

   This module implements stub functions for shell32 interfaces.

Author:

    David N. Cutler (davec) 1-Mar-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"

#define STUBFUNC(x)     \
int                     \
x(                      \
    void                \
    )                   \
{                       \
    return 0;           \
}

//STUBFUNC(?CreateInstance@CLogMgr@@SAJPEAPEAV1@PEAUIUnknown@@@Z
//STUBFUNC(?DllGetDTCLOG@@YAHAEBU_GUID@@0PEAPEAX@Z
STUBFUNC(DllGetClassObject)
STUBFUNC(DllRegisterServer)
STUBFUNC(DllUnregisterServer)
STUBFUNC(DynCanUseCompareExchange64)
STUBFUNC(DynCoGetInterceptor)
STUBFUNC(DynComPs_CStdStubBuffer_AddRef)
STUBFUNC(DynComPs_CStdStubBuffer_Connect)
STUBFUNC(DynComPs_CStdStubBuffer_CountRefs)
STUBFUNC(DynComPs_CStdStubBuffer_DebugServerQueryInterface)
STUBFUNC(DynComPs_CStdStubBuffer_DebugServerRelease)
STUBFUNC(DynComPs_CStdStubBuffer_Disconnect)
STUBFUNC(DynComPs_CStdStubBuffer_Invoke)
STUBFUNC(DynComPs_CStdStubBuffer_IsIIDSupported)
STUBFUNC(DynComPs_CStdStubBuffer_QueryInterface)
STUBFUNC(DynComPs_IUnknown_AddRef_Proxy)
STUBFUNC(DynComPs_IUnknown_QueryInterface_Proxy)
STUBFUNC(DynComPs_IUnknown_Release_Proxy)
STUBFUNC(DynComPs_NdrCStdStubBuffer_Release)
STUBFUNC(DynComPs_NdrDllCanUnloadNow)
STUBFUNC(DynComPs_NdrDllGetClassObject)
STUBFUNC(DynComPs_NdrDllRegisterProxy)
STUBFUNC(DynComPs_NdrDllUnregisterProxy)
STUBFUNC(DynCreateFileW)
STUBFUNC(DynCreateProcessW)
STUBFUNC(DynDeleteFileW)
STUBFUNC(DynGetCommandLineW)
STUBFUNC(DynGetComputerNameW)
STUBFUNC(DynGetDiskFreeSpaceW)
STUBFUNC(DynGetDriveTypeW)
STUBFUNC(DynGetEnvironmentVariableW)
STUBFUNC(DynGetFileAttributesW)
STUBFUNC(DynGetLocaleInfoW)
STUBFUNC(DynGetModuleFileNameW)
STUBFUNC(DynGetModuleHandleW)
STUBFUNC(DynGetSystemDirectoryW)
STUBFUNC(DynLoadStringW)
STUBFUNC(DynMessageBoxW)
STUBFUNC(DynRegConnectRegistryW)
STUBFUNC(DynRegCreateKeyExW)
STUBFUNC(DynRegCreateKeyW)
STUBFUNC(DynRegDeleteKeyW)
STUBFUNC(DynRegDeleteValueW)
STUBFUNC(DynRegEnumKeyExW)
STUBFUNC(DynRegEnumKeyW)
STUBFUNC(DynRegEnumValueW)
STUBFUNC(DynRegOpenKeyExW)
STUBFUNC(DynRegOpenKeyW)
STUBFUNC(DynRegQueryInfoKeyW)
STUBFUNC(DynRegQueryValueExW)
STUBFUNC(DynRegQueryValueW)
STUBFUNC(DynRegSetValueExW)
STUBFUNC(DynSetFileAttributesW)
STUBFUNC(DynlstrcmpW)
STUBFUNC(DynlstrcmpiW)
STUBFUNC(DynlstrcpyW)
STUBFUNC(DynlstrcpynW)
STUBFUNC(DynlstrlenW)
STUBFUNC(DynwsprintfW)
STUBFUNC(g_fDTCWin95Present)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\msdasc\msdasc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdasc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msdasc_h__
#define __msdasc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IService_FWD_DEFINED__
#define __IService_FWD_DEFINED__
typedef interface IService IService;
#endif 	/* __IService_FWD_DEFINED__ */


#ifndef __IDBPromptInitialize_FWD_DEFINED__
#define __IDBPromptInitialize_FWD_DEFINED__
typedef interface IDBPromptInitialize IDBPromptInitialize;
#endif 	/* __IDBPromptInitialize_FWD_DEFINED__ */


#ifndef __IDataInitialize_FWD_DEFINED__
#define __IDataInitialize_FWD_DEFINED__
typedef interface IDataInitialize IDataInitialize;
#endif 	/* __IDataInitialize_FWD_DEFINED__ */


#ifndef __IDataSourceLocator_FWD_DEFINED__
#define __IDataSourceLocator_FWD_DEFINED__
typedef interface IDataSourceLocator IDataSourceLocator;
#endif 	/* __IDataSourceLocator_FWD_DEFINED__ */


#ifndef __DataLinks_FWD_DEFINED__
#define __DataLinks_FWD_DEFINED__

#ifdef __cplusplus
typedef class DataLinks DataLinks;
#else
typedef struct DataLinks DataLinks;
#endif /* __cplusplus */

#endif 	/* __DataLinks_FWD_DEFINED__ */


#ifndef __MSDAINITIALIZE_FWD_DEFINED__
#define __MSDAINITIALIZE_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSDAINITIALIZE MSDAINITIALIZE;
#else
typedef struct MSDAINITIALIZE MSDAINITIALIZE;
#endif /* __cplusplus */

#endif 	/* __MSDAINITIALIZE_FWD_DEFINED__ */


#ifndef __PDPO_FWD_DEFINED__
#define __PDPO_FWD_DEFINED__

#ifdef __cplusplus
typedef class PDPO PDPO;
#else
typedef struct PDPO PDPO;
#endif /* __cplusplus */

#endif 	/* __PDPO_FWD_DEFINED__ */


#ifndef __RootBinder_FWD_DEFINED__
#define __RootBinder_FWD_DEFINED__

#ifdef __cplusplus
typedef class RootBinder RootBinder;
#else
typedef struct RootBinder RootBinder;
#endif /* __cplusplus */

#endif 	/* __RootBinder_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "oledb.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_msdasc_0000 */
/* [local] */ 

//-----------------------------------------------------------------------------
// File:				.C or .H file generated by msdasc.idl 
//
// Copyright:		Copyright (c) 1998-1999 Microsoft Corporation
//
// Contents: 		.C or .H file generated by msdasc.idl
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#ifdef _WIN64

typedef LONGLONG			COMPATIBLE_LONG;

#else

typedef LONG COMPATIBLE_LONG;

#endif	// _WIN64
typedef 
enum tagEBindInfoOptions
    {	BIO_BINDER	= 0x1
    } 	EBindInfoOptions;

#define STGM_COLLECTION		0x00002000L
#define STGM_OUTPUT			0x00008000L
#define STGM_OPEN			0x80000000L
#define STGM_RECURSIVE		0x01000000L
#define STGM_STRICTOPEN		0x40000000L


extern RPC_IF_HANDLE __MIDL_itf_msdasc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msdasc_0000_v0_0_s_ifspec;

#ifndef __IService_INTERFACE_DEFINED__
#define __IService_INTERFACE_DEFINED__

/* interface IService */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("06210E88-01F5-11D1-B512-0080C781C384")
    IService : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE InvokeService( 
            /* [in] */ IUnknown *pUnkInner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IService * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *InvokeService )( 
            IService * This,
            /* [in] */ IUnknown *pUnkInner);
        
        END_INTERFACE
    } IServiceVtbl;

    interface IService
    {
        CONST_VTBL struct IServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IService_InvokeService(This,pUnkInner)	\
    (This)->lpVtbl -> InvokeService(This,pUnkInner)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IService_InvokeService_Proxy( 
    IService * This,
    /* [in] */ IUnknown *pUnkInner);


void __RPC_STUB IService_InvokeService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msdasc_0351 */
/* [local] */ 

typedef DWORD DBPROMPTOPTIONS;

typedef 
enum tagDBPROMPTOPTIONSENUM
    {	DBPROMPTOPTIONS_NONE	= 0,
	DBPROMPTOPTIONS_WIZARDSHEET	= 0x1,
	DBPROMPTOPTIONS_PROPERTYSHEET	= 0x2,
	DBPROMPTOPTIONS_BROWSEONLY	= 0x8,
	DBPROMPTOPTIONS_DISABLE_PROVIDER_SELECTION	= 0x10,
	DBPROMPTOPTIONS_DISABLESAVEPASSWORD	= 0x20
    } 	DBPROMPTOPTIONSENUM;



extern RPC_IF_HANDLE __MIDL_itf_msdasc_0351_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msdasc_0351_v0_0_s_ifspec;

#ifndef __IDBPromptInitialize_INTERFACE_DEFINED__
#define __IDBPromptInitialize_INTERFACE_DEFINED__

/* interface IDBPromptInitialize */
/* [restricted][local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDBPromptInitialize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2206CCB0-19C1-11D1-89E0-00C04FD7A829")
    IDBPromptInitialize : public IUnknown
    {
    public:
        virtual /* [local][helpstring] */ HRESULT STDMETHODCALLTYPE PromptDataSource( 
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ HWND hWndParent,
            /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
            /* [in] */ ULONG cSourceTypeFilter,
            /* [size_is][in] */ DBSOURCETYPE *rgSourceTypeFilter,
            /* [in] */ LPCOLESTR pwszszzProviderFilter,
            /* [in] */ REFIID riid,
            /* [iid_is][out][in] */ IUnknown **ppDataSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PromptFileName( 
            /* [in] */ HWND hWndParent,
            /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
            /* [in] */ LPCOLESTR pwszInitialDirectory,
            /* [in] */ LPCOLESTR pwszInitialFile,
            /* [out] */ LPOLESTR *ppwszSelectedFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBPromptInitializeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDBPromptInitialize * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDBPromptInitialize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDBPromptInitialize * This);
        
        /* [local][helpstring] */ HRESULT ( STDMETHODCALLTYPE *PromptDataSource )( 
            IDBPromptInitialize * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ HWND hWndParent,
            /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
            /* [in] */ ULONG cSourceTypeFilter,
            /* [size_is][in] */ DBSOURCETYPE *rgSourceTypeFilter,
            /* [in] */ LPCOLESTR pwszszzProviderFilter,
            /* [in] */ REFIID riid,
            /* [iid_is][out][in] */ IUnknown **ppDataSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PromptFileName )( 
            IDBPromptInitialize * This,
            /* [in] */ HWND hWndParent,
            /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
            /* [in] */ LPCOLESTR pwszInitialDirectory,
            /* [in] */ LPCOLESTR pwszInitialFile,
            /* [out] */ LPOLESTR *ppwszSelectedFile);
        
        END_INTERFACE
    } IDBPromptInitializeVtbl;

    interface IDBPromptInitialize
    {
        CONST_VTBL struct IDBPromptInitializeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBPromptInitialize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBPromptInitialize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBPromptInitialize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBPromptInitialize_PromptDataSource(This,pUnkOuter,hWndParent,dwPromptOptions,cSourceTypeFilter,rgSourceTypeFilter,pwszszzProviderFilter,riid,ppDataSource)	\
    (This)->lpVtbl -> PromptDataSource(This,pUnkOuter,hWndParent,dwPromptOptions,cSourceTypeFilter,rgSourceTypeFilter,pwszszzProviderFilter,riid,ppDataSource)

#define IDBPromptInitialize_PromptFileName(This,hWndParent,dwPromptOptions,pwszInitialDirectory,pwszInitialFile,ppwszSelectedFile)	\
    (This)->lpVtbl -> PromptFileName(This,hWndParent,dwPromptOptions,pwszInitialDirectory,pwszInitialFile,ppwszSelectedFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local][helpstring] */ HRESULT STDMETHODCALLTYPE IDBPromptInitialize_PromptDataSource_Proxy( 
    IDBPromptInitialize * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ HWND hWndParent,
    /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
    /* [in] */ ULONG cSourceTypeFilter,
    /* [size_is][in] */ DBSOURCETYPE *rgSourceTypeFilter,
    /* [in] */ LPCOLESTR pwszszzProviderFilter,
    /* [in] */ REFIID riid,
    /* [iid_is][out][in] */ IUnknown **ppDataSource);


void __RPC_STUB IDBPromptInitialize_PromptDataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDBPromptInitialize_PromptFileName_Proxy( 
    IDBPromptInitialize * This,
    /* [in] */ HWND hWndParent,
    /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
    /* [in] */ LPCOLESTR pwszInitialDirectory,
    /* [in] */ LPCOLESTR pwszInitialFile,
    /* [out] */ LPOLESTR *ppwszSelectedFile);


void __RPC_STUB IDBPromptInitialize_PromptFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBPromptInitialize_INTERFACE_DEFINED__ */


#ifndef __IDataInitialize_INTERFACE_DEFINED__
#define __IDataInitialize_INTERFACE_DEFINED__

/* interface IDataInitialize */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDataInitialize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2206CCB1-19C1-11D1-89E0-00C04FD7A829")
    IDataInitialize : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDataSource( 
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPCOLESTR pwszInitializationString,
            /* [in] */ REFIID riid,
            /* [iid_is][out][in] */ IUnknown **ppDataSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInitializationString( 
            /* [in] */ IUnknown *pDataSource,
            /* [in] */ boolean fIncludePassword,
            /* [out] */ LPOLESTR *ppwszInitString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateDBInstance( 
            /* [in] */ REFCLSID clsidProvider,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPOLESTR pwszReserved,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppDataSource) = 0;
        
        virtual /* [local][helpstring] */ HRESULT STDMETHODCALLTYPE CreateDBInstanceEx( 
            /* [in] */ REFCLSID clsidProvider,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPOLESTR pwszReserved,
            /* [unique][in] */ COSERVERINFO *pServerInfo,
            /* [in] */ ULONG cmq,
            /* [size_is][out][in] */ MULTI_QI *rgmqResults) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoadStringFromStorage( 
            /* [unique][in] */ LPCOLESTR pwszFileName,
            /* [out] */ LPOLESTR *ppwszInitializationString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WriteStringToStorage( 
            /* [unique][in] */ LPCOLESTR pwszFileName,
            /* [unique][in] */ LPCOLESTR pwszInitializationString,
            /* [in] */ DWORD dwCreationDisposition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataInitializeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataInitialize * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataInitialize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataInitialize * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDataSource )( 
            IDataInitialize * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPCOLESTR pwszInitializationString,
            /* [in] */ REFIID riid,
            /* [iid_is][out][in] */ IUnknown **ppDataSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetInitializationString )( 
            IDataInitialize * This,
            /* [in] */ IUnknown *pDataSource,
            /* [in] */ boolean fIncludePassword,
            /* [out] */ LPOLESTR *ppwszInitString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateDBInstance )( 
            IDataInitialize * This,
            /* [in] */ REFCLSID clsidProvider,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPOLESTR pwszReserved,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppDataSource);
        
        /* [local][helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateDBInstanceEx )( 
            IDataInitialize * This,
            /* [in] */ REFCLSID clsidProvider,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPOLESTR pwszReserved,
            /* [unique][in] */ COSERVERINFO *pServerInfo,
            /* [in] */ ULONG cmq,
            /* [size_is][out][in] */ MULTI_QI *rgmqResults);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LoadStringFromStorage )( 
            IDataInitialize * This,
            /* [unique][in] */ LPCOLESTR pwszFileName,
            /* [out] */ LPOLESTR *ppwszInitializationString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WriteStringToStorage )( 
            IDataInitialize * This,
            /* [unique][in] */ LPCOLESTR pwszFileName,
            /* [unique][in] */ LPCOLESTR pwszInitializationString,
            /* [in] */ DWORD dwCreationDisposition);
        
        END_INTERFACE
    } IDataInitializeVtbl;

    interface IDataInitialize
    {
        CONST_VTBL struct IDataInitializeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataInitialize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataInitialize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataInitialize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataInitialize_GetDataSource(This,pUnkOuter,dwClsCtx,pwszInitializationString,riid,ppDataSource)	\
    (This)->lpVtbl -> GetDataSource(This,pUnkOuter,dwClsCtx,pwszInitializationString,riid,ppDataSource)

#define IDataInitialize_GetInitializationString(This,pDataSource,fIncludePassword,ppwszInitString)	\
    (This)->lpVtbl -> GetInitializationString(This,pDataSource,fIncludePassword,ppwszInitString)

#define IDataInitialize_CreateDBInstance(This,clsidProvider,pUnkOuter,dwClsCtx,pwszReserved,riid,ppDataSource)	\
    (This)->lpVtbl -> CreateDBInstance(This,clsidProvider,pUnkOuter,dwClsCtx,pwszReserved,riid,ppDataSource)

#define IDataInitialize_CreateDBInstanceEx(This,clsidProvider,pUnkOuter,dwClsCtx,pwszReserved,pServerInfo,cmq,rgmqResults)	\
    (This)->lpVtbl -> CreateDBInstanceEx(This,clsidProvider,pUnkOuter,dwClsCtx,pwszReserved,pServerInfo,cmq,rgmqResults)

#define IDataInitialize_LoadStringFromStorage(This,pwszFileName,ppwszInitializationString)	\
    (This)->lpVtbl -> LoadStringFromStorage(This,pwszFileName,ppwszInitializationString)

#define IDataInitialize_WriteStringToStorage(This,pwszFileName,pwszInitializationString,dwCreationDisposition)	\
    (This)->lpVtbl -> WriteStringToStorage(This,pwszFileName,pwszInitializationString,dwCreationDisposition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_GetDataSource_Proxy( 
    IDataInitialize * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPCOLESTR pwszInitializationString,
    /* [in] */ REFIID riid,
    /* [iid_is][out][in] */ IUnknown **ppDataSource);


void __RPC_STUB IDataInitialize_GetDataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_GetInitializationString_Proxy( 
    IDataInitialize * This,
    /* [in] */ IUnknown *pDataSource,
    /* [in] */ boolean fIncludePassword,
    /* [out] */ LPOLESTR *ppwszInitString);


void __RPC_STUB IDataInitialize_GetInitializationString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_CreateDBInstance_Proxy( 
    IDataInitialize * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppDataSource);


void __RPC_STUB IDataInitialize_CreateDBInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataInitialize_RemoteCreateDBInstanceEx_Proxy( 
    IDataInitialize * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [unique][in] */ COSERVERINFO *pServerInfo,
    /* [in] */ ULONG cmq,
    /* [size_is][size_is][in] */ const IID **rgpIID,
    /* [size_is][size_is][out] */ IUnknown **rgpItf,
    /* [size_is][out] */ HRESULT *rghr);


void __RPC_STUB IDataInitialize_RemoteCreateDBInstanceEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_LoadStringFromStorage_Proxy( 
    IDataInitialize * This,
    /* [unique][in] */ LPCOLESTR pwszFileName,
    /* [out] */ LPOLESTR *ppwszInitializationString);


void __RPC_STUB IDataInitialize_LoadStringFromStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_WriteStringToStorage_Proxy( 
    IDataInitialize * This,
    /* [unique][in] */ LPCOLESTR pwszFileName,
    /* [unique][in] */ LPCOLESTR pwszInitializationString,
    /* [in] */ DWORD dwCreationDisposition);


void __RPC_STUB IDataInitialize_WriteStringToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataInitialize_INTERFACE_DEFINED__ */



#ifndef __MSDASC_LIBRARY_DEFINED__
#define __MSDASC_LIBRARY_DEFINED__

/* library MSDASC */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_MSDASC;

#ifndef __IDataSourceLocator_INTERFACE_DEFINED__
#define __IDataSourceLocator_INTERFACE_DEFINED__

/* interface IDataSourceLocator */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDataSourceLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2206CCB2-19C1-11D1-89E0-00C04FD7A829")
    IDataSourceLocator : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hWnd( 
            /* [retval][out] */ COMPATIBLE_LONG *phwndParent) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_hWnd( 
            /* [in] */ COMPATIBLE_LONG hwndParent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PromptNew( 
            /* [retval][out] */ IDispatch **ppADOConnection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PromptEdit( 
            /* [out][in] */ IDispatch **ppADOConnection,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataSourceLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataSourceLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataSourceLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataSourceLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDataSourceLocator * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDataSourceLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDataSourceLocator * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDataSourceLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            IDataSourceLocator * This,
            /* [retval][out] */ COMPATIBLE_LONG *phwndParent);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_hWnd )( 
            IDataSourceLocator * This,
            /* [in] */ COMPATIBLE_LONG hwndParent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PromptNew )( 
            IDataSourceLocator * This,
            /* [retval][out] */ IDispatch **ppADOConnection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PromptEdit )( 
            IDataSourceLocator * This,
            /* [out][in] */ IDispatch **ppADOConnection,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess);
        
        END_INTERFACE
    } IDataSourceLocatorVtbl;

    interface IDataSourceLocator
    {
        CONST_VTBL struct IDataSourceLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataSourceLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataSourceLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataSourceLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataSourceLocator_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDataSourceLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDataSourceLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDataSourceLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDataSourceLocator_get_hWnd(This,phwndParent)	\
    (This)->lpVtbl -> get_hWnd(This,phwndParent)

#define IDataSourceLocator_put_hWnd(This,hwndParent)	\
    (This)->lpVtbl -> put_hWnd(This,hwndParent)

#define IDataSourceLocator_PromptNew(This,ppADOConnection)	\
    (This)->lpVtbl -> PromptNew(This,ppADOConnection)

#define IDataSourceLocator_PromptEdit(This,ppADOConnection,pbSuccess)	\
    (This)->lpVtbl -> PromptEdit(This,ppADOConnection,pbSuccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDataSourceLocator_get_hWnd_Proxy( 
    IDataSourceLocator * This,
    /* [retval][out] */ COMPATIBLE_LONG *phwndParent);


void __RPC_STUB IDataSourceLocator_get_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDataSourceLocator_put_hWnd_Proxy( 
    IDataSourceLocator * This,
    /* [in] */ COMPATIBLE_LONG hwndParent);


void __RPC_STUB IDataSourceLocator_put_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataSourceLocator_PromptNew_Proxy( 
    IDataSourceLocator * This,
    /* [retval][out] */ IDispatch **ppADOConnection);


void __RPC_STUB IDataSourceLocator_PromptNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataSourceLocator_PromptEdit_Proxy( 
    IDataSourceLocator * This,
    /* [out][in] */ IDispatch **ppADOConnection,
    /* [retval][out] */ VARIANT_BOOL *pbSuccess);


void __RPC_STUB IDataSourceLocator_PromptEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataSourceLocator_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DataLinks;

#ifdef __cplusplus

class DECLSPEC_UUID("2206CDB2-19C1-11D1-89E0-00C04FD7A829")
DataLinks;
#endif

EXTERN_C const CLSID CLSID_MSDAINITIALIZE;

#ifdef __cplusplus

class DECLSPEC_UUID("2206CDB0-19C1-11D1-89E0-00C04FD7A829")
MSDAINITIALIZE;
#endif

EXTERN_C const CLSID CLSID_PDPO;

#ifdef __cplusplus

class DECLSPEC_UUID("CCB4EC60-B9DC-11D1-AC80-00A0C9034873")
PDPO;
#endif

EXTERN_C const CLSID CLSID_RootBinder;

#ifdef __cplusplus

class DECLSPEC_UUID("FF151822-B0BF-11D1-A80D-000000000000")
RootBinder;
#endif
#endif /* __MSDASC_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* [local][helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_CreateDBInstanceEx_Proxy( 
    IDataInitialize * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [unique][in] */ COSERVERINFO *pServerInfo,
    /* [in] */ ULONG cmq,
    /* [size_is][out][in] */ MULTI_QI *rgmqResults);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataInitialize_CreateDBInstanceEx_Stub( 
    IDataInitialize * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [unique][in] */ COSERVERINFO *pServerInfo,
    /* [in] */ ULONG cmq,
    /* [size_is][size_is][in] */ const IID **rgpIID,
    /* [size_is][size_is][out] */ IUnknown **rgpItf,
    /* [size_is][out] */ HRESULT *rghr);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itss\lzx\encoder\optenc.c ===
/*
 * optenc.c
 *
 * Encoder for optimal parser
 *
 *
 * Future Improvements:
 *
 * When two estimations are equal, for example, "should I output a
 * character or a match?" there should be some way of deciding
 * which to take.  Right now we force it to output a match, but
 * for text files, outputting a character results in a small 
 * savings.  Even when comparing two matches, we might want to
 * force it to take one type of match over another.
 */

#include "encoder.h"

#define copymem(src,dst,size) memcpy(dst,src,size)


static bool			redo_first_block(t_encoder_context *context, long *bufpos_ptr);
static void			block_end(t_encoder_context *context, long BufPos);


/*
 * encode a match of length <len> (where <len> >=2), and position <pos> 
 */
#define OUT_MATCH(len,pos) \
{\
   context->enc_ItemType[(context->enc_literals >> 3)] |= (1 << (context->enc_literals & 7));	\
   context->enc_LitData [context->enc_literals++]  = (byte) (len-2);							\
   context->enc_DistData[context->enc_distances++] = pos;										\
}


/* encode a character */																		  
#define OUT_CHAR(ch) \
	context->enc_LitData [context->enc_literals++] = ch;


#define TREE_CREATE_CHECK()						\
if (context->enc_literals >= context->enc_next_tree_create)			\
{												\
	update_tree_estimates(context);\
	context->enc_next_tree_create += TREE_CREATE_INTERVAL;	\
}												


/*
 * Returns an estimation of how many bits it would take to output
 * a given character
 */
#define CHAR_EST(c) (numbits_t) (context->enc_main_tree_len[(c)])


/*
 * Returns an estimation of how many bits it would take to output
 * a given match.
 *
 * <ml> is the match length, where ml >= 2
 * <mp> is the match position
 *
 * The result is stored in <result>
 */
#define MATCH_EST(ml,mp,result) \
{ \
	byte mp_slot;														\
	mp_slot = (byte) MP_SLOT(mp);										\
	if (ml < (NUM_PRIMARY_LENGTHS+2))									\
	{																	\
		result = (numbits_t)											\
			(context->enc_main_tree_len[(NUM_CHARS-2)+(mp_slot<<NL_SHIFT)+ml] +	\
			enc_extra_bits[mp_slot]);									\
	}																	\
	else																\
	{																	\
		result = (numbits_t)											\
			(context->enc_main_tree_len[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mp_slot<<NL_SHIFT)] + \
			context->enc_secondary_tree_len[ml-(NUM_PRIMARY_LENGTHS+2)] +	\
			enc_extra_bits[mp_slot]);									\
	}																	\
}


#ifdef _DEBUG
static void VERIFY_MATCH(
    t_encoder_context   *context,
    long                bufpos,
    int                 largest_match_len
)
{

    int     i, j;
    ulong   match_pos;

    /*
     * Ensure match does not cross boundary
     */
    _ASSERTE(
        largest_match_len <=
        (CHUNK_SIZE-1) - (bufpos & (CHUNK_SIZE-1))
    );

    for (i = MIN_MATCH; i <= largest_match_len; i++)
    {
        match_pos = context->enc_matchpos_table[i];

        if (match_pos < NUM_REPEATED_OFFSETS)
            match_pos = context->enc_last_matchpos_offset[match_pos];
		else
			match_pos -= (NUM_REPEATED_OFFSETS-1);

        _ASSERTE (match_pos <= context->enc_window_size-4);

        for (j = 0; j < i; j++)
        {
            _ASSERTE (
                context->enc_MemWindow[bufpos+j] ==
                context->enc_MemWindow[bufpos-match_pos+j]
            );
        }
    }
}
#else
#   define VERIFY_MATCH(a,b,c) ;
#endif


void flush_all_pending_blocks(t_encoder_context *context)
{
	/*
	 * Force all blocks to be output
	 */
	while (context->enc_literals > 0)
		output_block(context);

	/*
	 * Flush compressed data out to the caller
	 */
	perform_flush_output_callback(context);
}


void encoder_start(t_encoder_context *context)
{
	long BytesRead, RealBufPos;

	/*
	 * RealBufPos is our position in the window,
	 * and equals [0...window_size + second_partition_size - 1]
	 */
	RealBufPos = (long) (context->enc_BufPos - (context->enc_RealMemWindow - context->enc_MemWindow));

	BytesRead = comp_read_input(context, RealBufPos, CHUNK_SIZE);

	if (BytesRead > 0)
		opt_encode_top(context, BytesRead);
}


static void update_tree_estimates(t_encoder_context *context)
{
	if (context->enc_literals)
	{
		/*
		 * Get stats on literals from 0...context->enc_literals
		 */
		if (context->enc_need_to_recalc_stats)
		{
			/*
			 * Cumulative total was destroyed, so need to
			 * recalculate
			 */
			get_block_stats(
				context,
				0,
				0,
				context->enc_literals
			);

			context->enc_need_to_recalc_stats = false;
		}
		else
		{
			/*
			 * Add stats from last_literals...context->enc_literals
			 * to cumulative total
			 */
			update_cumulative_block_stats(
				context,
				context->enc_last_literals,
				context->enc_last_distances,
				context->enc_literals
			);
		}

		create_trees(context, false); /* don't generate codes */

		fix_tree_cost_estimates(context);

		/*
		 * For cumulative total
		 */
		context->enc_last_literals = context->enc_literals;
		context->enc_last_distances = context->enc_distances;
	}
}


void opt_encode_top(t_encoder_context *context, long BytesRead)
{
	ulong	BufPos;
	ulong	RealBufPos;
	ulong	BufPosEnd;
	ulong	MatchPos;
	ulong	i;
	ulong	end_pos;
	int		EncMatchLength; /* must be a signed number */

	/* 
	 * Current position in encoding window 
	 */
	BufPos          = context->enc_BufPos;

	/*
	 * Stop encoding when we reach here 
	 */
	BufPosEnd       = context->enc_BufPos + BytesRead;

	/*
	 * If this is our first time in here (since a new group), then
	 * when we reach this many literals, update our tree cost
	 * estimates.  
	 *
	 * Also, output the file size we're using for translation 
	 * (0 means no translation at all, which will speed things up 
	 * for the decoder).
	 */
	if (context->enc_first_time_this_group)
	{
		context->enc_first_time_this_group = false;

		/*
		 * Recreate trees when we reach this many literals
		 */
		context->enc_next_tree_create = 10000;

		if (context->enc_file_size_for_translation)
		{
			output_bits(context, 1, 1); /* translation */

			output_bits(context, 16, context->enc_file_size_for_translation >> 16);
			output_bits(context, 16, context->enc_file_size_for_translation & 65535);
		}
		else
		{
			output_bits(context, 1, 0); /* no translation */
		}
	}
	else
	{
		/*
		 * If this is our second or later time in here, then add in the 
		 * strings we removed last time.
		 *
         * We have to be careful here, though, because end_pos is
         * equal to our current BufPos - window_size, not
         * BufPos - i - window_size; we don't have that much history
         * around.
		 */
		for (i = BREAK_LENGTH; i > 0; i--)
            quick_insert_bsearch_findmatch(
                context,
                BufPos - (long) i,
                BufPos - context->enc_window_size+4
            );
	}

	while (1)
	{

top_of_main_loop:

		/*
		 * While we haven't reached the end of the data
		 */
		while (BufPos < BufPosEnd)
		{
			/*
			 * Search for matches of all different possible lengths, at BufPos
			 */
			EncMatchLength = binary_search_findmatch(context, BufPos); 

			if (EncMatchLength < MIN_MATCH)
			{

output_literal:

				/*
				 * No match longer than 1 character exists in the history 
				 * window, so output the character at BufPos as a symbol.
				 */
				OUT_CHAR(context->enc_MemWindow[BufPos]);
				BufPos++;

				/* 
				 * Check for exceeding literal buffer 
				 */
				if (context->enc_literals >= (MAX_LITERAL_ITEMS-8))
					block_end(context, BufPos);

				continue;
			}

			/*
			 * Found a match.
			 *
			 * Make sure it cannot exceed the end of the buffer.
			 */
			if ((ulong) EncMatchLength + BufPos > BufPosEnd)
			{
				EncMatchLength = BufPosEnd - BufPos;    

				/*
				 * Oops, not enough for even a small match, so we 
				 * have to output a literal
				 */
				if (EncMatchLength < MIN_MATCH)
					goto output_literal;
			}

            VERIFY_MATCH(context, BufPos, EncMatchLength);

			if (EncMatchLength < FAST_DECISION_THRESHOLD)
			{
				/*
				 *  A match has been found that is between MIN_MATCH and 
				 *  FAST_DECISION_THRESHOLD bytes in length.  The following 
				 *  algorithm is the optimal encoder that will determine the 
				 *  most efficient order of matches and unmatched characters 
				 *  over a span area defined by LOOK.  
				 *
				 *  The code is essentially a shortest path determination 
				 *  algorithm.  A stream of data can be encoded in a vast number 
				 *  of different ways depending on the match lengths and offsets
				 *  chosen.  The key to good compression ratios is to chose the 
				 *  least expensive path.
				 */
				ulong		span;
				ulong		epos, bpos, NextPrevPos, MatchPos;
				decision_node *decision_node_ptr;
				long		iterations;

				/*
				 * Points to the end of the area covered by this match; the span
				 * will continually be extended whenever we find more matches
				 * later on.  It will stop being extended when we reach a spot
				 * where there are no matches, which is when we decide which
				 * path to take to output the matches.
				 */
				span = BufPos + EncMatchLength;

				/*
				 * The furthest position into which we will do our lookahead parsing 
				 */
				epos = BufPos + LOOK;

				/*
				 * Temporary BufPos variable
				 */
				bpos = BufPos;


				/* 
				 * Calculate the path to the next character if we output
				 * an unmatched symbol.
				 */

				/* bits required to get here */
				context->enc_decision_node[1].numbits = CHAR_EST(context->enc_MemWindow[BufPos]);
				
				/* where we came from */
				context->enc_decision_node[1].path    = BufPos;


				/*
				 * For the match found, estimate the cost of encoding the match
				 * for each possible match length, shortest offset combination.
				 *
				 * The cost, path and offset is stored at BufPos + Length.  
				 */
				for (i = MIN_MATCH; i <= (ulong) EncMatchLength; i++)
				{
					/*
					 * Get estimation of match cost given match length = i,
					 * match position = context->enc_matchpos_table[i], and store
					 * the result in context->enc_numbits[i]
					 */
					MATCH_EST(i, context->enc_matchpos_table[i], context->enc_decision_node[i].numbits);

					/*
					 * Where we came from 
					 */
					context->enc_decision_node[i].path = BufPos;

					/*
					 * Associated match position with this path
					 */
					context->enc_decision_node[i].link = context->enc_matchpos_table[i];
				}


				/*
				 * Set bit counter to zero at the start 
				 */
				context->enc_decision_node[0].numbits = 0;

				/*
				 * Initialise relative match position tables 
				 *
				 * Really context->enc_repeated_offset_table[BufPos-bpos][x], but here
				 * BufPos == bpos
				 */
				context->enc_decision_node[0].repeated_offset[0] = context->enc_last_matchpos_offset[0];
				context->enc_decision_node[0].repeated_offset[1] = context->enc_last_matchpos_offset[1];
				context->enc_decision_node[0].repeated_offset[2] = context->enc_last_matchpos_offset[2];

				decision_node_ptr = &context->enc_decision_node[-(long) bpos];

#define rpt_offset_ptr(where,which_offset) decision_node_ptr[(where)].repeated_offset[(which_offset)]

				while (1)
				{
					numbits_t est, cum_numbits;

					BufPos++;
	

					/* 
					 *  Set the proper repeated offset locations depending on the
					 *  shortest path to the location prior to searching for a 
					 *  match.
					 */


					/*
					 * If this is a match (i.e. path skips over more
					 * than one character).
					 */
					if (decision_node_ptr[BufPos].path != (ulong) (BufPos-1))
					{
						ulong LastPos = decision_node_ptr[BufPos].path;

						/*
						 * link_ptr[BufPos] is the match position for this
						 * location
						 */
						if (decision_node_ptr[BufPos].link >= NUM_REPEATED_OFFSETS)
						{
							context->enc_last_matchpos_offset[0] = decision_node_ptr[BufPos].link-(NUM_REPEATED_OFFSETS-1);
							context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,0);
							context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,1);
						}
						else if (decision_node_ptr[BufPos].link == 0)
						{
							context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,0);
							context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,1);
							context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,2);
						}
						else if (decision_node_ptr[BufPos].link == 1)
						{
							context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,1);
							context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,0);
							context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,2);
						}
						else /* == 2 */
						{
							context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,2);
							context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,1);
							context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,0);
						}
					}

					rpt_offset_ptr(BufPos,0) = context->enc_last_matchpos_offset[0];
					rpt_offset_ptr(BufPos,1) = context->enc_last_matchpos_offset[1];
					rpt_offset_ptr(BufPos,2) = context->enc_last_matchpos_offset[2];

					/*
					 * The following is one of the two possible break points from
					 * the inner encoding loop.  This break will exit the loop if 
					 * a point is reached that no match can incorporate; i.e. a
					 * character that does not match back to anything is a point 
					 * where all possible paths will converge and the longest one
					 * can be chosen.
					 */
					if (span == BufPos)
						break;
					
					/*
					 * Search for matches at BufPos 
					 */
					EncMatchLength = binary_search_findmatch(context, BufPos); 

					/* 
					 * Make sure that the match does not exceed the stop point
					 */
					if ((ulong) EncMatchLength + BufPos > BufPosEnd)
					{
						EncMatchLength = BufPosEnd - BufPos; 
						
						if (EncMatchLength < MIN_MATCH)
							EncMatchLength = 0;
					}

                    VERIFY_MATCH(context, BufPos, EncMatchLength);

					/*
					 * If the match is very long or it exceeds epos (either 
					 * surpassing the LOOK area, or exceeding past the end of the
					 * input buffer), then break the loop and output the path.
					 */
					if (EncMatchLength > FAST_DECISION_THRESHOLD || 
						BufPos + (ulong) EncMatchLength >= epos)
					{
						MatchPos = context->enc_matchpos_table[EncMatchLength];

						decision_node_ptr[BufPos+EncMatchLength].link = MatchPos;
						decision_node_ptr[BufPos+EncMatchLength].path = BufPos;

						/*
						 * Quickly insert data into the search tree without
						 * returning match positions/lengths
						 */
#ifndef INSERT_NEAR_LONG_MATCHES
						if (MatchPos == 3 && EncMatchLength > 16)
						{
							/*
							 * If we found a match 1 character away and it's
							 * length 16 or more, it's probably a string of
							 * zeroes, so don't insert that into the search
							 * engine, since doing so can slow things down
							 * significantly!
							 */
							quick_insert_bsearch_findmatch(
                                context,
                                BufPos + 1,
                                BufPos - context->enc_window_size + (1 + 4) /* bp+1 -(ws-4) */
                            );
						}
						else
						{
#endif
							for (i = 1; i < (ulong) EncMatchLength; i++)
								quick_insert_bsearch_findmatch(
                                    context,
                                    BufPos + i,
                                    BufPos + i - context->enc_window_size + 4
                                 );
						}

						BufPos += EncMatchLength;

						/*
						 * Update the relative match positions
						 */
						if (MatchPos >= NUM_REPEATED_OFFSETS)
						{
							context->enc_last_matchpos_offset[2] = context->enc_last_matchpos_offset[1];
							context->enc_last_matchpos_offset[1] = context->enc_last_matchpos_offset[0];
							context->enc_last_matchpos_offset[0] = MatchPos-(NUM_REPEATED_OFFSETS-1);
						}
						else if (MatchPos)                                 
						{            
							ulong t = context->enc_last_matchpos_offset[0];                                          
							context->enc_last_matchpos_offset[0] = context->enc_last_matchpos_offset[MatchPos];            
							context->enc_last_matchpos_offset[MatchPos] = t;  
						}                                                                                                                                       

						break;
					}


					/*
					 * The following code will extend the area spanned by the 
					 * set of matches if the current match surpasses the end of
					 * the span.  A match of length two that is far is not 
					 * accepted, since it would normally be encoded as characters,
					 * thus allowing the paths to converge.
					 */
					if (EncMatchLength > 2 || 
                        (EncMatchLength == 2 && context->enc_matchpos_table[2] < BREAK_MAX_LENGTH_TWO_OFFSET))
					{
						if (span < (ulong) (BufPos + EncMatchLength))
						{
							long end;
							long i;

							end = (((BufPos+EncMatchLength-bpos) < (LOOK-1)) ? (BufPos+EncMatchLength-bpos) : (LOOK-1));

							/*
							 * These new positions are undefined for now, since we haven't
							 * gone there yet, so put in the costliest value
							 */
							for (i = span-bpos+1; i <= end; i++)
								context->enc_decision_node[i].numbits = (numbits_t) -1;

							span = BufPos + EncMatchLength;
						}
					}


					/*
					 *  The following code will iterate through all combinations
					 *  of match lengths for the current match.  It will estimate
					 *  the cost of the path from the beginning of LOOK to 
					 *  BufPos and to every locations spanned by the current 
					 *  match.  If the path through BufPos with the found matches
					 *  is estimated to take fewer number of bits to encode than
					 *  the previously found match, then the path to the location
					 *  is altered.
					 *
					 *  The code relies on accurate estimation of the cost of 
					 *  encoding a character or a match.  Furthermore, it requires
					 *  a search engine that will store the smallest match offset
					 *  of each possible match length.
					 *
					 *  A match of length one is simply treated as an unmatched 
					 *  character.
					 */

					/* 
					 *  Get the estimated number of bits required to encode the 
					 *  path leading up to BufPos.
					 */
					cum_numbits = decision_node_ptr[BufPos].numbits;


					/*
					 *  Calculate the estimated cost of outputting the path through
					 *  BufPos and outputting the next character as an unmatched byte
					 */
					est = cum_numbits + CHAR_EST(context->enc_MemWindow[BufPos]);


					/*
					 *  Check if it is more efficient to encode the next character
					 *  as an unmatched character rather than the previously found 
					 *  match.  If so, then update the cheapest path to BufPos + 1.
					 *
					 *  What happens if est == numbits[BufPos-bpos+1]; i.e. it
					 *  works out as well to output a character as to output a
					 *  match?  It's a tough call; however, we will push the
					 *  encoder to use matches where possible.
					 */
					if (est < decision_node_ptr[BufPos+1].numbits)
					{
						decision_node_ptr[BufPos+1].numbits = est;
						decision_node_ptr[BufPos+1].path    = BufPos;
					}


					/*
					 *	Now, iterate through the remaining match lengths and 
					 *  compare the new path to the existing.  Change the path
					 *  if it is found to be more cost effective to go through
					 *  BufPos.
					 */
					for (i = MIN_MATCH; i <= (ulong) EncMatchLength; i++)
					{
						MATCH_EST(i, context->enc_matchpos_table[i], est);
						est += cum_numbits;

						/*
						 * If est == numbits[BufPos+i] we want to leave things
						 * alone, since this will tend to force the matches
						 * to be smaller in size, which is beneficial for most
						 * data.
						 */
						if (est < decision_node_ptr[BufPos+i].numbits)
						{
							decision_node_ptr[BufPos+i].numbits	= est;
							decision_node_ptr[BufPos+i].path	= BufPos;
							decision_node_ptr[BufPos+i].link	= context->enc_matchpos_table[i];
						}
					}
				} /* continue to loop through span of matches */


				/*
				 *  Here BufPos == span, ie. a non-matchable character found.  The
				 *  following code will output the path properly.
				 */


				/*
				 *  Unfortunately the path is stored in reverse; how to get from
				 *  where we are now, to get back to where it all started.
				 *
				 *  Traverse the path back to the original starting position
				 *  of the LOOK span.  Invert the path pointers in order to be
				 *  able to traverse back to the current position from the start.
				 */

				/*
				 * Count the number of iterations we did, so when we go forwards
				 * we'll do the same amount
				 */
				iterations = 0;

				NextPrevPos = decision_node_ptr[BufPos].path;

   				do
				{
					ulong	PrevPos;

      				PrevPos = NextPrevPos;

      				NextPrevPos = decision_node_ptr[PrevPos].path;
      				decision_node_ptr[PrevPos].path = BufPos;

      				BufPos = PrevPos;
      				iterations++;
   				} while (BufPos != bpos);


				if (context->enc_literals + iterations >= (MAX_LITERAL_ITEMS-8) || 
					context->enc_distances + iterations >= (MAX_DIST_ITEMS-8))
				{
					block_end(context, BufPos);
				}

				/*
				 * Traverse from the beginning of the LOOK span to the end of 
				 * the span along the stored path, outputting matches and 
				 * characters appropriately.
				 */
   				do
   				{
      				if (decision_node_ptr[BufPos].path > BufPos+1)
      				{
						/*
						 * Path skips over more than 1 character; therefore it's a match
						 */
						OUT_MATCH(
							decision_node_ptr[BufPos].path - BufPos,
							decision_node_ptr[ decision_node_ptr[BufPos].path ].link
						);

						BufPos = decision_node_ptr[BufPos].path;
					}
      				else
      				{
						/*
						 * Path goes to the next character; therefore it's a symbol
						 */
						OUT_CHAR(context->enc_MemWindow[BufPos]);
						BufPos++;
					}
   				} while (--iterations != 0);

				TREE_CREATE_CHECK();

				/*
				 * If we're filling up, and are close to outputting a block,
				 * and it's the first block, then recompress the first N 
				 * literals using our accumulated stats.
				 */
				if (context->enc_first_block && 
					(context->enc_literals >= (MAX_LITERAL_ITEMS-512) 
					|| context->enc_distances >= (MAX_DIST_ITEMS-512)))
				{
					if (redo_first_block(context, &BufPos))
						goto top_of_main_loop;

					/*
					 * Unable to redo, so output the block
					 */
					block_end(context, BufPos);
				}
			}
			else  /* EncMatchLength >= FAST_DECISION_THRESHOLD */
			{
				/*
				 *  This code reflects a speed optimization that will always take
				 *  a match of length >= FAST_DECISION_THRESHOLD characters.
				 */

				/*
				 * The position associated with the match we found
				 */
				MatchPos = context->enc_matchpos_table[EncMatchLength];

				/*
				 * Quickly insert match substrings into search tree
				 * (don't look for new matches; just insert the strings)
				 */
#ifndef INSERT_NEAR_LONG_MATCHES
				if (MatchPos == 3 && EncMatchLength > 16)
				{
					quick_insert_bsearch_findmatch(
                        context,
                        BufPos + 1,
                        BufPos - context->enc_window_size + 5 /* bp+1 -(ws-4) */
                    );
				}
				else
#endif
				{
					for (i = 1; i < (ulong) EncMatchLength; i++)
						quick_insert_bsearch_findmatch(
                            context,
                            BufPos + i,
                            BufPos + i - context->enc_window_size + 4
                         );
				}

				/*
				 * Advance our position in the window
				 */
				BufPos += EncMatchLength;

				/*
				 * Output the match
				 */
				OUT_MATCH(EncMatchLength, MatchPos);

				if (MatchPos >= NUM_REPEATED_OFFSETS)
				{
					context->enc_last_matchpos_offset[2] = context->enc_last_matchpos_offset[1];
					context->enc_last_matchpos_offset[1] = context->enc_last_matchpos_offset[0];
					context->enc_last_matchpos_offset[0] = MatchPos-(NUM_REPEATED_OFFSETS-1);
				}
				else if (MatchPos)
				{
					ulong t = context->enc_last_matchpos_offset[0];
					context->enc_last_matchpos_offset[0] = context->enc_last_matchpos_offset[MatchPos];
					context->enc_last_matchpos_offset[MatchPos] = t;
				}

				/*
				 * Check to see if we're close to overflowing our output arrays, and
				 * output a block if this is the case
				 */
				if (context->enc_literals >= (MAX_LITERAL_ITEMS-8) || 
					context->enc_distances >= (MAX_DIST_ITEMS-8))
					block_end(context, BufPos);

			}  /* EncMatchLength >= FAST_DECISION_THRESHOLD */

		} /* end while ... BufPos <= BufPosEnd */

		/*
         * Value of BufPos corresponding to earliest window data
		 */
		context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

		/*
		 * We didn't read 32K, so we know for sure that 
		 * this was our last block of data.
		 */
		if (BytesRead < CHUNK_SIZE)
		{
			/*
			 * If we have never output a block, and we haven't
			 * recalculated the stats already, then recalculate
			 * the stats and recompress.
			 */
			if (context->enc_first_block)
			{
				if (redo_first_block(context, &BufPos))
					goto top_of_main_loop;
			}

			break;
		}

		/*
		 * Remove the last BREAK_LENGTH nodes from the binary search tree,
		 * since we have been inserting strings which contain undefined
		 * data at the end.
		 */
		end_pos = BufPos - (context->enc_window_size-4-BREAK_LENGTH);

		for (i = 1; (i <= BREAK_LENGTH); i++)
			binary_search_remove_node(context, BufPos-i, end_pos);

		/*
		 * If we're still in the first window_size + second partition size
		 * bytes in the file then we don't need to copymem() yet.
		 *
		 * RealBufPos is the real position in the file.
		 */
		RealBufPos = (long)(BufPos - (context->enc_RealMemWindow - context->enc_MemWindow));
		
		if (RealBufPos < context->enc_window_size + context->enc_encoder_second_partition_size)
			break;

		/*
		 * We're about to trash a whole bunch of history with our copymem,
		 * so we'd better redo the first block now if we are ever going to.
		 */
		if (context->enc_first_block)
		{
			if (redo_first_block(context, &BufPos))
				goto top_of_main_loop;
		}

		/*
		 *  We're about to remove a large number of symbols from the window.
		 *  Test to see whether, if we were to output a block now, our compressed
		 *  output size would be larger than our uncompressed data.  If so, then
		 *  we will output an uncompressed block.
		 *
		 *  The reason we have to do this check here, is that data in the
		 *  window is about to be destroyed.  We can't simply put this check in
		 *  the block outputting code, since there is no guarantee that the
		 *  memory window contents corresponding to everything in that block,
		 *  are still around - all we'd have would be a set of literals and
		 *  distances, when we need all the uncompressed literals to output
		 *  an uncompressed block.
		 */

		/*
		 *  What value of bufpos corresponds to the oldest data we have in the
		 *  buffer?
		 *
		 *  After the memory copy, that will be the current buffer position,
		 *  minus window_size.
		 */

		/* 
		 * The end of the data buffer is reached, more data needs to be read
		 * and the existing data must be shifted into the history window.
		 *
		 * MSVC 4.x generates code which does REP MOVSD so no need to
		 * write this in assembly.
		 */
		copymem(
			&context->enc_RealMemWindow[context->enc_encoder_second_partition_size],
			&context->enc_RealMemWindow[0],
			context->enc_window_size 
		);

		copymem(
			&context->enc_RealLeft[context->enc_encoder_second_partition_size],
			&context->enc_RealLeft[0],
			sizeof(ulong)*context->enc_window_size
		);

		copymem(
			&context->enc_RealRight[context->enc_encoder_second_partition_size],
			&context->enc_RealRight[0],
			sizeof(ulong)*context->enc_window_size
		);

		context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

		/*
		 *   The following bit of code is CRUCIAL yet unorthodox in function
		 *   and serves as a speed and syntax optimization and makes the code
		 *   easier to understand once grasped.   
		 *
		 *   The three main buffers, context->enc_MemWindow, context->enc_Left and context->enc_Right, 
		 *   are referensed by BufPos and SearchPos relative to the current
		 *   compression window locations.  When the encoder reaches the end
		 *   of its block of input memory, the data in the input buffer is 
		 *   shifted into the compression history window and the new input 
		 *   stream is loaded.  Typically the BufPos pointer would be reduced 
		 *   to signify the replaced data.  However, this code reduces the 
		 *   base pointers to reflect the shift of data, and leaves the BufPos
		 *   pointer in its current state.  Therefore, the BufPos pointer is 
		 *   an absolute pointer reflecting the position in the input stream,
		 *   and NOT the position in the buffer.  The base pointers will point 
		 *   to invalid memory locations with addresses smaller than the
		 *   actual array base pointers.  However, when the two pointers are
		 *   added together, &(context->enc_MemWindow+BufPos), it will point to the 
		 *   correct and valid position in the buffer.
		 */

		context->enc_MemWindow -= context->enc_encoder_second_partition_size;
		context->enc_Left      -= context->enc_encoder_second_partition_size;
		context->enc_Right     -= context->enc_encoder_second_partition_size;

		break;
	}

	/*
	 * Store BufPos in global variable
	 */
	context->enc_BufPos = BufPos;
}


static void block_end(t_encoder_context *context, long BufPos)
{
	context->enc_first_block			= false;
	context->enc_need_to_recalc_stats	= true;

	output_block(context);

	if (context->enc_literals < TREE_CREATE_INTERVAL)
	{
		context->enc_next_tree_create = TREE_CREATE_INTERVAL;
	}
	else
	{
		context->enc_next_tree_create = context->enc_literals + TREE_CREATE_INTERVAL; /* recreate right away */
	}

	context->enc_bufpos_last_output_block = BufPos;
}


static bool redo_first_block(t_encoder_context *context, long *bufpos_ptr)
{
	long	start_at;
	long	earliest_can_start_at;
	long	pos_in_file;
	long	history_needed;
	long	history_avail;
	long	BufPos;
	long	split_at_literal;

	context->enc_first_block = false;

	BufPos = *bufpos_ptr;

	/*
	 * For the first context->enc_window size bytes in the file, we don't
	 * need to have context->enc_window size bytes around.
	 *
	 * For anything after that, though, we do need to have window_size
	 * previous bytes to look into.
	 */

	/*
	 * How many bytes are we into the file?
	 */
	pos_in_file = BufPos - context->enc_window_size;

	/*
	 * First let's figure out the total history required from
	 * BufPos backwards.  For starters, we need all the bytes 
	 * we're going to recompress.  We get that by seeing the
	 * last time we output a block.
	 */
	history_needed = BufPos - context->enc_bufpos_last_output_block;

	/*
	 * Plus we will need window_size bytes before that (for matching
	 * into) unless we're looking within the first window_size
	 * bytes of the file.
	 */
	if (context->enc_bufpos_last_output_block-context->enc_window_size < context->enc_window_size)
		history_needed += context->enc_bufpos_last_output_block - context->enc_window_size;
	else
		history_needed += context->enc_window_size;

	history_avail = (long) (&context->enc_MemWindow[BufPos] - &context->enc_RealMemWindow[0]);

	if (history_needed <= history_avail)
	{
		earliest_can_start_at = context->enc_bufpos_last_output_block;
	}
	else
	{
		/*
		 * Not enough history available
		 */
		return false;
	}

	start_at = earliest_can_start_at;

	(void) split_block(
		context,
		0,
		context->enc_literals,
		context->enc_distances,
		&split_at_literal,
		NULL /* don't need # distances returned */
	);

	get_block_stats(
		context,
		0,
		0,
		split_at_literal
	);

	create_trees(context, false); /* don't generate codes */
	fix_tree_cost_estimates(context);

#ifdef MULTIPLE_SEARCH_TREES
	/*
	 * Now set all the tree root pointers to NULL
	 * (don't need to reset the left/right pointers).
	 */
	memset(context->enc_tree_root, 0, NUM_SEARCH_TREES * sizeof(ulong));
#else
	context->enc_single_tree_root = 0;
#endif

	/*
	 * Clear item array and reset literal and distance
	 * counters
	 */
	memset(context->enc_ItemType, 0, (MAX_LITERAL_ITEMS/8));

	/*
	 * Reset encoder state
	 */
	context->enc_last_matchpos_offset[0] = 1;
	context->enc_last_matchpos_offset[1] = 1;
	context->enc_last_matchpos_offset[2] = 1;

	context->enc_repeated_offset_at_literal_zero[0] = 1;
	context->enc_repeated_offset_at_literal_zero[1] = 1;
	context->enc_repeated_offset_at_literal_zero[2] = 1;

	context->enc_input_running_total = 0;

	context->enc_literals      = 0;
	context->enc_distances     = 0;

	context->enc_need_to_recalc_stats = true;

	context->enc_next_tree_create = split_at_literal;

	*bufpos_ptr = start_at;

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\msdasc\msdasc_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdasc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IService,0x06210E88,0x01F5,0x11D1,0xB5,0x12,0x00,0x80,0xC7,0x81,0xC3,0x84);


MIDL_DEFINE_GUID(IID, IID_IDBPromptInitialize,0x2206CCB0,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(IID, IID_IDataInitialize,0x2206CCB1,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(IID, LIBID_MSDASC,0x2206CEB0,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(IID, IID_IDataSourceLocator,0x2206CCB2,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(CLSID, CLSID_DataLinks,0x2206CDB2,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(CLSID, CLSID_MSDAINITIALIZE,0x2206CDB0,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(CLSID, CLSID_PDPO,0xCCB4EC60,0xB9DC,0x11D1,0xAC,0x80,0x00,0xA0,0xC9,0x03,0x48,0x73);


MIDL_DEFINE_GUID(CLSID, CLSID_RootBinder,0xFF151822,0xB0BF,0x11D1,0xA8,0x0D,0x00,0x00,0x00,0x00,0x00,0x00);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdasc.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IService,0x06210E88,0x01F5,0x11D1,0xB5,0x12,0x00,0x80,0xC7,0x81,0xC3,0x84);


MIDL_DEFINE_GUID(IID, IID_IDBPromptInitialize,0x2206CCB0,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(IID, IID_IDataInitialize,0x2206CCB1,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(IID, LIBID_MSDASC,0x2206CEB0,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(IID, IID_IDataSourceLocator,0x2206CCB2,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(CLSID, CLSID_DataLinks,0x2206CDB2,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(CLSID, CLSID_MSDAINITIALIZE,0x2206CDB0,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);


MIDL_DEFINE_GUID(CLSID, CLSID_PDPO,0xCCB4EC60,0xB9DC,0x11D1,0xAC,0x80,0x00,0xA0,0xC9,0x03,0x48,0x73);


MIDL_DEFINE_GUID(CLSID, CLSID_RootBinder,0xFF151822,0xB0BF,0x11D1,0xA8,0x0D,0x00,0x00,0x00,0x00,0x00,0x00);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\msdasc\msdasc_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdasc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "msdasc.h"

#define TYPE_FORMAT_STRING_SIZE   263                               
#define PROC_FORMAT_STRING_SIZE   301                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IService_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IService_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDataInitialize_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDataInitialize_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataInitialize_RemoteCreateDBInstanceEx_Proxy( 
    IDataInitialize * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [unique][in] */ COSERVERINFO *pServerInfo,
    /* [in] */ ULONG cmq,
    /* [size_is][size_is][in] */ const IID **rgpIID,
    /* [size_is][size_is][out] */ IUnknown **rgpItf,
    /* [size_is][out] */ HRESULT *rghr)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[150],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IDataInitialize_RemoteCreateDBInstanceEx_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IDataInitialize *This;
        REFCLSID clsidProvider;
        IUnknown *pUnkOuter;
        DWORD dwClsCtx;
        LPOLESTR pwszReserved;
        COSERVERINFO *pServerInfo;
        ULONG cmq;
        const IID **rgpIID;
        IUnknown **rgpItf;
        HRESULT *rghr;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IDataInitialize_CreateDBInstanceEx_Stub(
                                                  (IDataInitialize *) pParamStruct->This,
                                                  pParamStruct->clsidProvider,
                                                  pParamStruct->pUnkOuter,
                                                  pParamStruct->dwClsCtx,
                                                  pParamStruct->pwszReserved,
                                                  pParamStruct->pServerInfo,
                                                  pParamStruct->cmq,
                                                  pParamStruct->rgpIID,
                                                  pParamStruct->rgpItf,
                                                  pParamStruct->rghr);
    
}



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure GetDataSource */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 10 */	NdrFcShort( 0x4c ),	/* 76 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter pUnkOuter */

/* 16 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwClsCtx */

/* 22 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszInitializationString */

/* 28 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 30 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 32 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter riid */

/* 34 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 36 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 38 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter ppDataSource */

/* 40 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 42 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 44 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 46 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 48 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 50 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInitializationString */

/* 52 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 54 */	NdrFcLong( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x4 ),	/* 4 */
/* 60 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 62 */	NdrFcShort( 0x5 ),	/* 5 */
/* 64 */	NdrFcShort( 0x8 ),	/* 8 */
/* 66 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pDataSource */

/* 68 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 70 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 72 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter fIncludePassword */

/* 74 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 76 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 78 */	0x3,		/* FC_SMALL */
			0x0,		/* 0 */

	/* Parameter ppwszInitString */

/* 80 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 82 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 84 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 86 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 88 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 90 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateDBInstance */

/* 92 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 94 */	NdrFcLong( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x5 ),	/* 5 */
/* 100 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 102 */	NdrFcShort( 0x90 ),	/* 144 */
/* 104 */	NdrFcShort( 0x8 ),	/* 8 */
/* 106 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter clsidProvider */

/* 108 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 110 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 112 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter pUnkOuter */

/* 114 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 116 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 118 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwClsCtx */

/* 120 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 122 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 124 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszReserved */

/* 126 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 128 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 130 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter riid */

/* 132 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 134 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 136 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter ppDataSource */

/* 138 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 140 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 142 */	NdrFcShort( 0x40 ),	/* Type Offset=64 */

	/* Return value */

/* 144 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 146 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateDBInstanceEx */

/* 150 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 152 */	NdrFcLong( 0x0 ),	/* 0 */
/* 156 */	NdrFcShort( 0x6 ),	/* 6 */
/* 158 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 160 */	NdrFcShort( 0x54 ),	/* 84 */
/* 162 */	NdrFcShort( 0x8 ),	/* 8 */
/* 164 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0xa,		/* 10 */

	/* Parameter clsidProvider */

/* 166 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 168 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 170 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter pUnkOuter */

/* 172 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 174 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 176 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwClsCtx */

/* 178 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 180 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 182 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszReserved */

/* 184 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 186 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 188 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pServerInfo */

/* 190 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 192 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 194 */	NdrFcShort( 0x4a ),	/* Type Offset=74 */

	/* Parameter cmq */

/* 196 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 198 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpIID */

/* 202 */	NdrFcShort( 0x200b ),	/* Flags:  must size, must free, in, srv alloc size=8 */
/* 204 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 206 */	NdrFcShort( 0xde ),	/* Type Offset=222 */

	/* Parameter rgpItf */

/* 208 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 210 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 212 */	NdrFcShort( 0xf4 ),	/* Type Offset=244 */

	/* Parameter rghr */

/* 214 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 216 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 218 */	NdrFcShort( 0xfc ),	/* Type Offset=252 */

	/* Return value */

/* 220 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 222 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 224 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LoadStringFromStorage */

/* 226 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 228 */	NdrFcLong( 0x0 ),	/* 0 */
/* 232 */	NdrFcShort( 0x7 ),	/* 7 */
/* 234 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 240 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pwszFileName */

/* 242 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 244 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 246 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ppwszInitializationString */

/* 248 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 250 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 252 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 254 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 256 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteStringToStorage */

/* 260 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 262 */	NdrFcLong( 0x0 ),	/* 0 */
/* 266 */	NdrFcShort( 0x8 ),	/* 8 */
/* 268 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 270 */	NdrFcShort( 0x8 ),	/* 8 */
/* 272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 274 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pwszFileName */

/* 276 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 280 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pwszInitializationString */

/* 282 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 284 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 286 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter dwCreationDisposition */

/* 288 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 290 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 292 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 296 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x0 ),	/* 0 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 14 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 16 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 18 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 20 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 22 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 24 */	
			0x11, 0x0,	/* FC_RP */
/* 26 */	NdrFcShort( 0x8 ),	/* Offset= 8 (34) */
/* 28 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 34 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 36 */	NdrFcShort( 0x10 ),	/* 16 */
/* 38 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 40 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 42 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (28) */
			0x5b,		/* FC_END */
/* 46 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 48 */	NdrFcShort( 0x2 ),	/* Offset= 2 (50) */
/* 50 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 52 */	0x28,		/* Corr desc:  parameter, FC_LONG */
			0x0,		/*  */
/* 54 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 56 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 58 */	NdrFcShort( 0x2 ),	/* Offset= 2 (60) */
/* 60 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 62 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 64 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 66 */	NdrFcShort( 0x2 ),	/* Offset= 2 (68) */
/* 68 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 70 */	0x28,		/* Corr desc:  parameter, FC_LONG */
			0x0,		/*  */
/* 72 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 74 */	
			0x12, 0x0,	/* FC_UP */
/* 76 */	NdrFcShort( 0x72 ),	/* Offset= 114 (190) */
/* 78 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 80 */	NdrFcShort( 0x2 ),	/* 2 */
/* 82 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x57,		/* FC_ADD_1 */
/* 84 */	NdrFcShort( 0x4 ),	/* 4 */
/* 86 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 88 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 90 */	NdrFcShort( 0x2 ),	/* 2 */
/* 92 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x57,		/* FC_ADD_1 */
/* 94 */	NdrFcShort( 0xc ),	/* 12 */
/* 96 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 98 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 100 */	NdrFcShort( 0x2 ),	/* 2 */
/* 102 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x57,		/* FC_ADD_1 */
/* 104 */	NdrFcShort( 0x14 ),	/* 20 */
/* 106 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 108 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 110 */	NdrFcShort( 0x1c ),	/* 28 */
/* 112 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 114 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 116 */	NdrFcShort( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 120 */	0x12, 0x0,	/* FC_UP */
/* 122 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (78) */
/* 124 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	NdrFcShort( 0x8 ),	/* 8 */
/* 130 */	0x12, 0x0,	/* FC_UP */
/* 132 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (88) */
/* 134 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 136 */	NdrFcShort( 0x10 ),	/* 16 */
/* 138 */	NdrFcShort( 0x10 ),	/* 16 */
/* 140 */	0x12, 0x0,	/* FC_UP */
/* 142 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (98) */
/* 144 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 146 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 148 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 150 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 152 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 154 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 156 */	NdrFcShort( 0x1c ),	/* 28 */
/* 158 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 160 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 162 */	NdrFcShort( 0x8 ),	/* 8 */
/* 164 */	NdrFcShort( 0x8 ),	/* 8 */
/* 166 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 168 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 170 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 172 */	NdrFcShort( 0x14 ),	/* 20 */
/* 174 */	NdrFcShort( 0x14 ),	/* 20 */
/* 176 */	0x12, 0x0,	/* FC_UP */
/* 178 */	NdrFcShort( 0xffffffba ),	/* Offset= -70 (108) */
/* 180 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 182 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 184 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 186 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 188 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 190 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 192 */	NdrFcShort( 0x10 ),	/* 16 */
/* 194 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 196 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 198 */	NdrFcShort( 0x4 ),	/* 4 */
/* 200 */	NdrFcShort( 0x4 ),	/* 4 */
/* 202 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 204 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 206 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	NdrFcShort( 0x8 ),	/* 8 */
/* 212 */	0x12, 0x0,	/* FC_UP */
/* 214 */	NdrFcShort( 0xffffffc4 ),	/* Offset= -60 (154) */
/* 216 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 218 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 220 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 222 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 224 */	NdrFcShort( 0x2 ),	/* Offset= 2 (226) */
/* 226 */	
			0x12, 0x0,	/* FC_UP */
/* 228 */	NdrFcShort( 0x2 ),	/* Offset= 2 (230) */
/* 230 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 232 */	NdrFcShort( 0x10 ),	/* 16 */
/* 234 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 236 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 238 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 240 */	NdrFcShort( 0xffffff32 ),	/* Offset= -206 (34) */
/* 242 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 244 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 246 */	NdrFcShort( 0xffffff0c ),	/* Offset= -244 (2) */
/* 248 */	
			0x11, 0x0,	/* FC_RP */
/* 250 */	NdrFcShort( 0x2 ),	/* Offset= 2 (252) */
/* 252 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 254 */	NdrFcShort( 0x4 ),	/* 4 */
/* 256 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 258 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 260 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_msdasc_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IService, ver. 0.0,
   GUID={0x06210E88,0x01F5,0x11D1,{0xB5,0x12,0x00,0x80,0xC7,0x81,0xC3,0x84}} */

#pragma code_seg(".orpc")
static const unsigned short IService_FormatStringOffsetTable[] =
    {
    (unsigned short) -1
    };

static const MIDL_STUBLESS_PROXY_INFO IService_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IService_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IService_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IService_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IServiceProxyVtbl = 
{
    &IService_ProxyInfo,
    &IID_IService,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IService::InvokeService */
};

const CInterfaceStubVtbl _IServiceStubVtbl =
{
    &IID_IService,
    &IService_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_msdasc_0351, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDBPromptInitialize, ver. 0.0,
   GUID={0x2206CCB0,0x19C1,0x11D1,{0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29}} */


/* Object interface: IDataInitialize, ver. 0.0,
   GUID={0x2206CCB1,0x19C1,0x11D1,{0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29}} */

#pragma code_seg(".orpc")
static const unsigned short IDataInitialize_FormatStringOffsetTable[] =
    {
    0,
    52,
    92,
    150,
    226,
    260
    };

static const MIDL_STUBLESS_PROXY_INFO IDataInitialize_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDataInitialize_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDataInitialize_StubThunkTable[] = 
    {
    0,
    0,
    0,
    IDataInitialize_RemoteCreateDBInstanceEx_Thunk,
    0,
    0
    };

static const MIDL_SERVER_INFO IDataInitialize_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDataInitialize_FormatStringOffsetTable[-3],
    &IDataInitialize_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(9) _IDataInitializeProxyVtbl = 
{
    &IDataInitialize_ProxyInfo,
    &IID_IDataInitialize,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDataInitialize::GetDataSource */ ,
    (void *) (INT_PTR) -1 /* IDataInitialize::GetInitializationString */ ,
    (void *) (INT_PTR) -1 /* IDataInitialize::CreateDBInstance */ ,
    IDataInitialize_CreateDBInstanceEx_Proxy ,
    (void *) (INT_PTR) -1 /* IDataInitialize::LoadStringFromStorage */ ,
    (void *) (INT_PTR) -1 /* IDataInitialize::WriteStringToStorage */
};

const CInterfaceStubVtbl _IDataInitializeStubVtbl =
{
    &IID_IDataInitialize,
    &IDataInitialize_ServerInfo,
    9,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x6000158, /* MIDL Version 6.0.344 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _msdasc_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IServiceProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDataInitializeProxyVtbl,
    0
};

const CInterfaceStubVtbl * _msdasc_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IServiceStubVtbl,
    ( CInterfaceStubVtbl *) &_IDataInitializeStubVtbl,
    0
};

PCInterfaceName const _msdasc_InterfaceNamesList[] = 
{
    "IService",
    "IDataInitialize",
    0
};


#define _msdasc_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _msdasc, pIID, n)

int __stdcall _msdasc_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _msdasc, 2, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _msdasc, 2, *pIndex )
    
}

const ExtendedProxyFileInfo msdasc_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _msdasc_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _msdasc_StubVtblList,
    (const PCInterfaceName * ) & _msdasc_InterfaceNamesList,
    0, // no delegation
    & _msdasc_IID_Lookup, 
    2,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdasc.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "msdasc.h"

#define TYPE_FORMAT_STRING_SIZE   243                               
#define PROC_FORMAT_STRING_SIZE   361                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IService_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IService_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDataInitialize_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDataInitialize_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataInitialize_RemoteCreateDBInstanceEx_Proxy( 
    IDataInitialize * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [unique][in] */ COSERVERINFO *pServerInfo,
    /* [in] */ ULONG cmq,
    /* [size_is][size_is][in] */ const IID **rgpIID,
    /* [size_is][size_is][out] */ IUnknown **rgpItf,
    /* [size_is][out] */ HRESULT *rghr)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[180],
                  ( unsigned char * )This,
                  clsidProvider,
                  pUnkOuter,
                  dwClsCtx,
                  pwszReserved,
                  pServerInfo,
                  cmq,
                  rgpIID,
                  rgpItf,
                  rghr);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IDataInitialize_RemoteCreateDBInstanceEx_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IDataInitialize *This;
        REFCLSID clsidProvider;
        IUnknown *pUnkOuter;
        DWORD dwClsCtx;
        char Pad0[4];
        LPOLESTR pwszReserved;
        COSERVERINFO *pServerInfo;
        ULONG cmq;
        char Pad1[4];
        const IID **rgpIID;
        IUnknown **rgpItf;
        HRESULT *rghr;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IDataInitialize_CreateDBInstanceEx_Stub(
                                                  (IDataInitialize *) pParamStruct->This,
                                                  pParamStruct->clsidProvider,
                                                  pParamStruct->pUnkOuter,
                                                  pParamStruct->dwClsCtx,
                                                  pParamStruct->pwszReserved,
                                                  pParamStruct->pServerInfo,
                                                  pParamStruct->cmq,
                                                  pParamStruct->rgpIID,
                                                  pParamStruct->rgpItf,
                                                  pParamStruct->rghr);
    
}



#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure GetDataSource */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 10 */	NdrFcShort( 0x4c ),	/* 76 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 16 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
/* 20 */	NdrFcShort( 0x1 ),	/* 1 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 26 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 30 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwClsCtx */

/* 32 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 36 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszInitializationString */

/* 38 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 40 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 42 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter riid */

/* 44 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 46 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 48 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter ppDataSource */

/* 50 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 52 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 54 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 56 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 58 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 60 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInitializationString */

/* 62 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 64 */	NdrFcLong( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x4 ),	/* 4 */
/* 70 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 72 */	NdrFcShort( 0x5 ),	/* 5 */
/* 74 */	NdrFcShort( 0x8 ),	/* 8 */
/* 76 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 78 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */
/* 84 */	NdrFcShort( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pDataSource */

/* 88 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 90 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 92 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter fIncludePassword */

/* 94 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 96 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 98 */	0x3,		/* FC_SMALL */
			0x0,		/* 0 */

	/* Parameter ppwszInitString */

/* 100 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 102 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 104 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 108 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateDBInstance */

/* 112 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x5 ),	/* 5 */
/* 120 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 122 */	NdrFcShort( 0x90 ),	/* 144 */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 128 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 130 */	NdrFcShort( 0x1 ),	/* 1 */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter clsidProvider */

/* 138 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 140 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 142 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter pUnkOuter */

/* 144 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 146 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 148 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwClsCtx */

/* 150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 152 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszReserved */

/* 156 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 158 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 160 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter riid */

/* 162 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 164 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 166 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter ppDataSource */

/* 168 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 170 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 172 */	NdrFcShort( 0x42 ),	/* Type Offset=66 */

	/* Return value */

/* 174 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 176 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateDBInstanceEx */

/* 180 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 182 */	NdrFcLong( 0x0 ),	/* 0 */
/* 186 */	NdrFcShort( 0x6 ),	/* 6 */
/* 188 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 190 */	NdrFcShort( 0x54 ),	/* 84 */
/* 192 */	NdrFcShort( 0x8 ),	/* 8 */
/* 194 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 196 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 198 */	NdrFcShort( 0x2 ),	/* 2 */
/* 200 */	NdrFcShort( 0x4 ),	/* 4 */
/* 202 */	NdrFcShort( 0x0 ),	/* 0 */
/* 204 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter clsidProvider */

/* 206 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 208 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 210 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter pUnkOuter */

/* 212 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 214 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 216 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwClsCtx */

/* 218 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 220 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszReserved */

/* 224 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 226 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 228 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pServerInfo */

/* 230 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 232 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 234 */	NdrFcShort( 0x4e ),	/* Type Offset=78 */

	/* Parameter cmq */

/* 236 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 238 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpIID */

/* 242 */	NdrFcShort( 0x200b ),	/* Flags:  must size, must free, in, srv alloc size=8 */
/* 244 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 246 */	NdrFcShort( 0xc6 ),	/* Type Offset=198 */

	/* Parameter rgpItf */

/* 248 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 250 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 252 */	NdrFcShort( 0xde ),	/* Type Offset=222 */

	/* Parameter rghr */

/* 254 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 256 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 258 */	NdrFcShort( 0xe6 ),	/* Type Offset=230 */

	/* Return value */

/* 260 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 262 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LoadStringFromStorage */

/* 266 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 268 */	NdrFcLong( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x7 ),	/* 7 */
/* 274 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 278 */	NdrFcShort( 0x8 ),	/* 8 */
/* 280 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 282 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 284 */	NdrFcShort( 0x0 ),	/* 0 */
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0x0 ),	/* 0 */
/* 290 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pwszFileName */

/* 292 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 294 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 296 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ppwszInitializationString */

/* 298 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 300 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 302 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */

	/* Return value */

/* 304 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 306 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 308 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteStringToStorage */

/* 310 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 312 */	NdrFcLong( 0x0 ),	/* 0 */
/* 316 */	NdrFcShort( 0x8 ),	/* 8 */
/* 318 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 320 */	NdrFcShort( 0x8 ),	/* 8 */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 326 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 330 */	NdrFcShort( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pwszFileName */

/* 336 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 338 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 340 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pwszInitializationString */

/* 342 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 344 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 346 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter dwCreationDisposition */

/* 348 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 350 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 354 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 356 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x0 ),	/* 0 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 14 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 16 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 18 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 20 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 22 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 24 */	
			0x11, 0x0,	/* FC_RP */
/* 26 */	NdrFcShort( 0x8 ),	/* Offset= 8 (34) */
/* 28 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 34 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 36 */	NdrFcShort( 0x10 ),	/* 16 */
/* 38 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 40 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 42 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (28) */
			0x5b,		/* FC_END */
/* 46 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 48 */	NdrFcShort( 0x2 ),	/* Offset= 2 (50) */
/* 50 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 52 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 54 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 56 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 58 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 60 */	NdrFcShort( 0x2 ),	/* Offset= 2 (62) */
/* 62 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 64 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 66 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 68 */	NdrFcShort( 0x2 ),	/* Offset= 2 (70) */
/* 70 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 72 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 74 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 76 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 78 */	
			0x12, 0x0,	/* FC_UP */
/* 80 */	NdrFcShort( 0x5e ),	/* Offset= 94 (174) */
/* 82 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 84 */	NdrFcShort( 0x2 ),	/* 2 */
/* 86 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x57,		/* FC_ADD_1 */
/* 88 */	NdrFcShort( 0x8 ),	/* 8 */
/* 90 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 92 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 94 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 96 */	NdrFcShort( 0x2 ),	/* 2 */
/* 98 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x57,		/* FC_ADD_1 */
/* 100 */	NdrFcShort( 0x18 ),	/* 24 */
/* 102 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 104 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 106 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 108 */	NdrFcShort( 0x2 ),	/* 2 */
/* 110 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x57,		/* FC_ADD_1 */
/* 112 */	NdrFcShort( 0x28 ),	/* 40 */
/* 114 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 116 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 118 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 120 */	NdrFcShort( 0x30 ),	/* 48 */
/* 122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 124 */	NdrFcShort( 0xc ),	/* Offset= 12 (136) */
/* 126 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 128 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 130 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 132 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 134 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 136 */	
			0x12, 0x0,	/* FC_UP */
/* 138 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (82) */
/* 140 */	
			0x12, 0x0,	/* FC_UP */
/* 142 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (94) */
/* 144 */	
			0x12, 0x0,	/* FC_UP */
/* 146 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (106) */
/* 148 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 150 */	NdrFcShort( 0x28 ),	/* 40 */
/* 152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 154 */	NdrFcShort( 0xc ),	/* Offset= 12 (166) */
/* 156 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 158 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 160 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 162 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 164 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 166 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 168 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 170 */	
			0x12, 0x0,	/* FC_UP */
/* 172 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (118) */
/* 174 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 176 */	NdrFcShort( 0x20 ),	/* 32 */
/* 178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 180 */	NdrFcShort( 0xa ),	/* Offset= 10 (190) */
/* 182 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 184 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 186 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 188 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 190 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 192 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 194 */	
			0x12, 0x0,	/* FC_UP */
/* 196 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (148) */
/* 198 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 200 */	NdrFcShort( 0x2 ),	/* Offset= 2 (202) */
/* 202 */	
			0x12, 0x0,	/* FC_UP */
/* 204 */	NdrFcShort( 0x2 ),	/* Offset= 2 (206) */
/* 206 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 208 */	NdrFcShort( 0x10 ),	/* 16 */
/* 210 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 212 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 214 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 216 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 218 */	NdrFcShort( 0xffffff48 ),	/* Offset= -184 (34) */
/* 220 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 222 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 224 */	NdrFcShort( 0xffffff22 ),	/* Offset= -222 (2) */
/* 226 */	
			0x11, 0x0,	/* FC_RP */
/* 228 */	NdrFcShort( 0x2 ),	/* Offset= 2 (230) */
/* 230 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 232 */	NdrFcShort( 0x4 ),	/* 4 */
/* 234 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 236 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 238 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 240 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_msdasc_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IService, ver. 0.0,
   GUID={0x06210E88,0x01F5,0x11D1,{0xB5,0x12,0x00,0x80,0xC7,0x81,0xC3,0x84}} */

#pragma code_seg(".orpc")
static const unsigned short IService_FormatStringOffsetTable[] =
    {
    (unsigned short) -1
    };

static const MIDL_STUBLESS_PROXY_INFO IService_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IService_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IService_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IService_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IServiceProxyVtbl = 
{
    &IService_ProxyInfo,
    &IID_IService,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IService::InvokeService */
};

const CInterfaceStubVtbl _IServiceStubVtbl =
{
    &IID_IService,
    &IService_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_msdasc_0351, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDBPromptInitialize, ver. 0.0,
   GUID={0x2206CCB0,0x19C1,0x11D1,{0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29}} */


/* Object interface: IDataInitialize, ver. 0.0,
   GUID={0x2206CCB1,0x19C1,0x11D1,{0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29}} */

#pragma code_seg(".orpc")
static const unsigned short IDataInitialize_FormatStringOffsetTable[] =
    {
    0,
    62,
    112,
    180,
    266,
    310
    };

static const MIDL_STUBLESS_PROXY_INFO IDataInitialize_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDataInitialize_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDataInitialize_StubThunkTable[] = 
    {
    0,
    0,
    0,
    IDataInitialize_RemoteCreateDBInstanceEx_Thunk,
    0,
    0
    };

static const MIDL_SERVER_INFO IDataInitialize_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDataInitialize_FormatStringOffsetTable[-3],
    &IDataInitialize_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(9) _IDataInitializeProxyVtbl = 
{
    &IDataInitialize_ProxyInfo,
    &IID_IDataInitialize,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDataInitialize::GetDataSource */ ,
    (void *) (INT_PTR) -1 /* IDataInitialize::GetInitializationString */ ,
    (void *) (INT_PTR) -1 /* IDataInitialize::CreateDBInstance */ ,
    IDataInitialize_CreateDBInstanceEx_Proxy ,
    (void *) (INT_PTR) -1 /* IDataInitialize::LoadStringFromStorage */ ,
    (void *) (INT_PTR) -1 /* IDataInitialize::WriteStringToStorage */
};

const CInterfaceStubVtbl _IDataInitializeStubVtbl =
{
    &IID_IDataInitialize,
    &IDataInitialize_ServerInfo,
    9,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000158, /* MIDL Version 6.0.344 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _msdasc_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IServiceProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDataInitializeProxyVtbl,
    0
};

const CInterfaceStubVtbl * _msdasc_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IServiceStubVtbl,
    ( CInterfaceStubVtbl *) &_IDataInitializeStubVtbl,
    0
};

PCInterfaceName const _msdasc_InterfaceNamesList[] = 
{
    "IService",
    "IDataInitialize",
    0
};


#define _msdasc_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _msdasc, pIID, n)

int __stdcall _msdasc_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _msdasc, 2, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _msdasc, 2, *pIndex )
    
}

const ExtendedProxyFileInfo msdasc_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _msdasc_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _msdasc_StubVtblList,
    (const PCInterfaceName * ) & _msdasc_InterfaceNamesList,
    0, // no delegation
    & _msdasc_IID_Lookup, 
    2,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\msdbi60l\msdbi60l.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    msdbi60l.c

Abstract:

   This module implements stub functions for shell32 interfaces.

Author:

    David N. Cutler (davec) 1-Mar-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"

#define STUBFUNC(x)     \
int                     \
x(                      \
    void                \
    )                   \
{                       \
    return 0;           \
}

STUBFUNC(PDBClose)
STUBFUNC(PDBCopyTo)
STUBFUNC(PDBOpen)
STUBFUNC(TypesClose)
STUBFUNC(TypesQueryTiMacEx)
STUBFUNC(TypesQueryTiMinEx)
STUBFUNC(PDBOpenTpi)
STUBFUNC(DBIQueryTypeServer)
STUBFUNC(ModQuerySymbols)
STUBFUNC(ModQueryLines)
STUBFUNC(ModClose)
STUBFUNC(PDBOpenDBI)
STUBFUNC(PDBOpenValidate)
STUBFUNC(DBIQueryNextMod)
STUBFUNC(DBIClose)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\msxml2\domdocument_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for msxml2.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument2,0xF6D90F11,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for msxml2.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument2,0xF6D90F11,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\nntpsnap\nntpsnap.c ===
#include "windows.h"

STDAPI
DllCanUnloadNow (
    void
    )

{
    return 0;
}

STDAPI
DllGetClassObject (
    IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID FAR* ppv
    )

{
    return 0;
}

STDAPI
DllRegisterServer (
    void
    )

{
    return 0;
}

STDAPI
DllUnregisterServer (
    void
    )

{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\msxml2\msxml2_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for msxml2.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSXML2,0xf5078f18,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMImplementation,0x2933BF8F,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNode,0x2933BF80,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocumentFragment,0x3efaa413,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocument,0x2933BF81,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMSchemaCollection,0x373984c8,0xb845,0x449b,0x91,0xe7,0x45,0xac,0x83,0x03,0x6a,0xde);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocument2,0x2933BF95,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNodeList,0x2933BF82,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNamedNodeMap,0x2933BF83,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMCharacterData,0x2933BF84,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMAttribute,0x2933BF85,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMElement,0x2933BF86,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMText,0x2933BF87,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMComment,0x2933BF88,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMProcessingInstruction,0x2933BF89,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMCDATASection,0x2933BF8A,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocumentType,0x2933BF8B,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNotation,0x2933BF8C,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMEntity,0x2933BF8D,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMEntityReference,0x2933BF8E,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMParseError,0x3efaa426,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IXTLRuntime,0x3efaa425,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IXSLTemplate,0x2933BF93,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXSLProcessor,0x2933BF92,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_ISAXXMLReader,0xa4f96ed0,0xf829,0x476e,0x81,0xc0,0xcd,0xc7,0xbd,0x2a,0x08,0x02);


MIDL_DEFINE_GUID(IID, IID_ISAXXMLFilter,0x70409222,0xca09,0x4475,0xac,0xb8,0x40,0x31,0x2f,0xe8,0xd1,0x45);


MIDL_DEFINE_GUID(IID, IID_ISAXLocator,0x9b7e472a,0x0de4,0x4640,0xbf,0xf3,0x84,0xd3,0x8a,0x05,0x1c,0x31);


MIDL_DEFINE_GUID(IID, IID_ISAXEntityResolver,0x99bca7bd,0xe8c4,0x4d5f,0xa0,0xcf,0x6d,0x90,0x79,0x01,0xff,0x07);


MIDL_DEFINE_GUID(IID, IID_ISAXContentHandler,0x1545cdfa,0x9e4e,0x4497,0xa8,0xa4,0x2b,0xf7,0xd0,0x11,0x2c,0x44);


MIDL_DEFINE_GUID(IID, IID_ISAXDTDHandler,0xe15c1baf,0xafb3,0x4d60,0x8c,0x36,0x19,0xa8,0xc4,0x5d,0xef,0xed);


MIDL_DEFINE_GUID(IID, IID_ISAXErrorHandler,0xa60511c4,0xccf5,0x479e,0x98,0xa3,0xdc,0x8d,0xc5,0x45,0xb7,0xd0);


MIDL_DEFINE_GUID(IID, IID_ISAXLexicalHandler,0x7f85d5f5,0x47a8,0x4497,0xbd,0xa5,0x84,0xba,0x04,0x81,0x9e,0xa6);


MIDL_DEFINE_GUID(IID, IID_ISAXDeclHandler,0x862629ac,0x771a,0x47b2,0x83,0x37,0x4e,0x68,0x43,0xc1,0xbe,0x90);


MIDL_DEFINE_GUID(IID, IID_ISAXAttributes,0xf078abe1,0x45d2,0x4832,0x91,0xea,0x44,0x66,0xce,0x2f,0x25,0xc9);


MIDL_DEFINE_GUID(IID, IID_IVBSAXXMLReader,0x8c033caa,0x6cd6,0x4f73,0xb7,0x28,0x45,0x31,0xaf,0x74,0x94,0x5f);


MIDL_DEFINE_GUID(IID, IID_IVBSAXXMLFilter,0x1299eb1b,0x5b88,0x433e,0x82,0xde,0x82,0xca,0x75,0xad,0x4e,0x04);


MIDL_DEFINE_GUID(IID, IID_IVBSAXLocator,0x796e7ac5,0x5aa2,0x4eff,0xac,0xad,0x3f,0xaa,0xf0,0x1a,0x32,0x88);


MIDL_DEFINE_GUID(IID, IID_IVBSAXEntityResolver,0x0c05d096,0xf45b,0x4aca,0xad,0x1a,0xaa,0x0b,0xc2,0x55,0x18,0xdc);


MIDL_DEFINE_GUID(IID, IID_IVBSAXContentHandler,0x2ed7290a,0x4dd5,0x4b46,0xbb,0x26,0x4e,0x41,0x55,0xe7,0x7f,0xaa);


MIDL_DEFINE_GUID(IID, IID_IVBSAXDTDHandler,0x24fb3297,0x302d,0x4620,0xba,0x39,0x3a,0x73,0x2d,0x85,0x05,0x58);


MIDL_DEFINE_GUID(IID, IID_IVBSAXErrorHandler,0xd963d3fe,0x173c,0x4862,0x90,0x95,0xb9,0x2f,0x66,0x99,0x5f,0x52);


MIDL_DEFINE_GUID(IID, IID_IVBSAXLexicalHandler,0x032aac35,0x8c0e,0x4d9d,0x97,0x9f,0xe3,0xb7,0x02,0x93,0x55,0x76);


MIDL_DEFINE_GUID(IID, IID_IVBSAXDeclHandler,0xe8917260,0x7579,0x4be1,0xb5,0xdd,0x7a,0xfb,0xfa,0x6f,0x07,0x7b);


MIDL_DEFINE_GUID(IID, IID_IVBSAXAttributes,0x10dc0586,0x132b,0x4cac,0x8b,0xb3,0xdb,0x00,0xac,0x8b,0x7e,0xe0);


MIDL_DEFINE_GUID(IID, IID_IMXWriter,0x4d7ff4ba,0x1565,0x4ea8,0x94,0xe1,0x6e,0x72,0x4a,0x46,0xf9,0x8d);


MIDL_DEFINE_GUID(IID, IID_IMXAttributes,0xf10d27cc,0x3ec0,0x415c,0x8e,0xd8,0x77,0xab,0x1c,0x5e,0x72,0x62);


MIDL_DEFINE_GUID(IID, IID_IMXReaderControl,0x808f4e35,0x8d5a,0x4fbe,0x84,0x66,0x33,0xa4,0x12,0x79,0xed,0x30);


MIDL_DEFINE_GUID(IID, IID_IXMLElementCollection,0x65725580,0x9B5D,0x11d0,0x9B,0xFE,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);


MIDL_DEFINE_GUID(IID, IID_IXMLDocument,0xF52E2B61,0x18A1,0x11d1,0xB1,0x05,0x00,0x80,0x5F,0x49,0x91,0x6B);


MIDL_DEFINE_GUID(IID, IID_IXMLDocument2,0x2B8DE2FE,0x8D2D,0x11d1,0xB2,0xFC,0x00,0xC0,0x4F,0xD9,0x15,0xA9);


MIDL_DEFINE_GUID(IID, IID_IXMLElement,0x3F7F31AC,0xE15F,0x11d0,0x9C,0x25,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);


MIDL_DEFINE_GUID(IID, IID_IXMLElement2,0x2B8DE2FF,0x8D2D,0x11d1,0xB2,0xFC,0x00,0xC0,0x4F,0xD9,0x15,0xA9);


MIDL_DEFINE_GUID(IID, IID_IXMLAttribute,0xD4D4A0FC,0x3B73,0x11d1,0xB2,0xB4,0x00,0xC0,0x4F,0xB9,0x25,0x96);


MIDL_DEFINE_GUID(IID, IID_IXMLError,0x948C5AD3,0xC58D,0x11d0,0x9C,0x0B,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMSelection,0xAA634FC7,0x5888,0x44a7,0xA2,0x57,0x3A,0x47,0x15,0x0D,0x3A,0x0E);


MIDL_DEFINE_GUID(IID, DIID_XMLDOMDocumentEvents,0x3efaa427,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IDSOControl,0x310afa62,0x0575,0x11d2,0x9c,0xa9,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLHTTPRequest,0xED8C108D,0x4349,0x11D2,0x91,0xA4,0x00,0xC0,0x4F,0x79,0x69,0xE8);


MIDL_DEFINE_GUID(IID, IID_IServerXMLHTTPRequest,0x2e9196bf,0x13ba,0x4dd4,0x91,0xca,0x6c,0x57,0x1f,0x28,0x14,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument,0xF6D90F11,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument26,0xf5078f1b,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument30,0xf5078f32,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_FreeThreadedDOMDocument,0xF6D90F12,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_FreeThreadedDOMDocument26,0xf5078f1c,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_FreeThreadedDOMDocument30,0xf5078f33,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLSchemaCache,0x373984c9,0xb845,0x449b,0x91,0xe7,0x45,0xac,0x83,0x03,0x6a,0xde);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLSchemaCache26,0xf5078f1d,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLSchemaCache30,0xf5078f34,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XSLTemplate,0x2933BF94,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(CLSID, CLSID_XSLTemplate26,0xf5078f21,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XSLTemplate30,0xf5078f36,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_DSOControl,0xF6D90F14,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_DSOControl26,0xf5078f1f,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_DSOControl30,0xf5078f39,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLHTTP,0xF6D90F16,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLHTTP26,0xf5078f1e,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLHTTP30,0xf5078f35,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_ServerXMLHTTP,0xafba6b42,0x5692,0x48ea,0x81,0x41,0xdc,0x51,0x7d,0xcf,0x0e,0xf1);


MIDL_DEFINE_GUID(CLSID, CLSID_ServerXMLHTTP30,0xafb40ffd,0xb609,0x40a3,0x98,0x28,0xf8,0x8b,0xbe,0x11,0xe4,0xe3);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXXMLReader,0x079aa557,0x4a18,0x424a,0x8e,0xee,0xe3,0x9f,0x0a,0x8d,0x41,0xb9);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXXMLReader30,0x3124c396,0xfb13,0x4836,0xa6,0xad,0x13,0x17,0xf1,0x71,0x36,0x88);


MIDL_DEFINE_GUID(CLSID, CLSID_MXXMLWriter,0xfc220ad8,0xa72a,0x4ee8,0x92,0x6e,0x0b,0x7a,0xd1,0x52,0xa0,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_MXXMLWriter30,0x3d813dfe,0x6c91,0x4a4e,0x8f,0x41,0x04,0x34,0x6a,0x84,0x1d,0x9c);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXAttributes,0x4dd441ad,0x526d,0x4a77,0x9f,0x1b,0x98,0x41,0xed,0x80,0x2f,0xb0);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXAttributes30,0x3e784a01,0xf3ae,0x4dc0,0x93,0x54,0x95,0x26,0xb9,0x37,0x0e,0xba);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLDocument,0xCFC399AF,0xD876,0x11d0,0x9C,0x10,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for msxml2.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSXML2,0xf5078f18,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMImplementation,0x2933BF8F,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNode,0x2933BF80,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocumentFragment,0x3efaa413,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocument,0x2933BF81,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMSchemaCollection,0x373984c8,0xb845,0x449b,0x91,0xe7,0x45,0xac,0x83,0x03,0x6a,0xde);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocument2,0x2933BF95,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNodeList,0x2933BF82,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNamedNodeMap,0x2933BF83,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMCharacterData,0x2933BF84,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMAttribute,0x2933BF85,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMElement,0x2933BF86,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMText,0x2933BF87,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMComment,0x2933BF88,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMProcessingInstruction,0x2933BF89,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMCDATASection,0x2933BF8A,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMDocumentType,0x2933BF8B,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMNotation,0x2933BF8C,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMEntity,0x2933BF8D,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMEntityReference,0x2933BF8E,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMParseError,0x3efaa426,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IXTLRuntime,0x3efaa425,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IXSLTemplate,0x2933BF93,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_IXSLProcessor,0x2933BF92,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(IID, IID_ISAXXMLReader,0xa4f96ed0,0xf829,0x476e,0x81,0xc0,0xcd,0xc7,0xbd,0x2a,0x08,0x02);


MIDL_DEFINE_GUID(IID, IID_ISAXXMLFilter,0x70409222,0xca09,0x4475,0xac,0xb8,0x40,0x31,0x2f,0xe8,0xd1,0x45);


MIDL_DEFINE_GUID(IID, IID_ISAXLocator,0x9b7e472a,0x0de4,0x4640,0xbf,0xf3,0x84,0xd3,0x8a,0x05,0x1c,0x31);


MIDL_DEFINE_GUID(IID, IID_ISAXEntityResolver,0x99bca7bd,0xe8c4,0x4d5f,0xa0,0xcf,0x6d,0x90,0x79,0x01,0xff,0x07);


MIDL_DEFINE_GUID(IID, IID_ISAXContentHandler,0x1545cdfa,0x9e4e,0x4497,0xa8,0xa4,0x2b,0xf7,0xd0,0x11,0x2c,0x44);


MIDL_DEFINE_GUID(IID, IID_ISAXDTDHandler,0xe15c1baf,0xafb3,0x4d60,0x8c,0x36,0x19,0xa8,0xc4,0x5d,0xef,0xed);


MIDL_DEFINE_GUID(IID, IID_ISAXErrorHandler,0xa60511c4,0xccf5,0x479e,0x98,0xa3,0xdc,0x8d,0xc5,0x45,0xb7,0xd0);


MIDL_DEFINE_GUID(IID, IID_ISAXLexicalHandler,0x7f85d5f5,0x47a8,0x4497,0xbd,0xa5,0x84,0xba,0x04,0x81,0x9e,0xa6);


MIDL_DEFINE_GUID(IID, IID_ISAXDeclHandler,0x862629ac,0x771a,0x47b2,0x83,0x37,0x4e,0x68,0x43,0xc1,0xbe,0x90);


MIDL_DEFINE_GUID(IID, IID_ISAXAttributes,0xf078abe1,0x45d2,0x4832,0x91,0xea,0x44,0x66,0xce,0x2f,0x25,0xc9);


MIDL_DEFINE_GUID(IID, IID_IVBSAXXMLReader,0x8c033caa,0x6cd6,0x4f73,0xb7,0x28,0x45,0x31,0xaf,0x74,0x94,0x5f);


MIDL_DEFINE_GUID(IID, IID_IVBSAXXMLFilter,0x1299eb1b,0x5b88,0x433e,0x82,0xde,0x82,0xca,0x75,0xad,0x4e,0x04);


MIDL_DEFINE_GUID(IID, IID_IVBSAXLocator,0x796e7ac5,0x5aa2,0x4eff,0xac,0xad,0x3f,0xaa,0xf0,0x1a,0x32,0x88);


MIDL_DEFINE_GUID(IID, IID_IVBSAXEntityResolver,0x0c05d096,0xf45b,0x4aca,0xad,0x1a,0xaa,0x0b,0xc2,0x55,0x18,0xdc);


MIDL_DEFINE_GUID(IID, IID_IVBSAXContentHandler,0x2ed7290a,0x4dd5,0x4b46,0xbb,0x26,0x4e,0x41,0x55,0xe7,0x7f,0xaa);


MIDL_DEFINE_GUID(IID, IID_IVBSAXDTDHandler,0x24fb3297,0x302d,0x4620,0xba,0x39,0x3a,0x73,0x2d,0x85,0x05,0x58);


MIDL_DEFINE_GUID(IID, IID_IVBSAXErrorHandler,0xd963d3fe,0x173c,0x4862,0x90,0x95,0xb9,0x2f,0x66,0x99,0x5f,0x52);


MIDL_DEFINE_GUID(IID, IID_IVBSAXLexicalHandler,0x032aac35,0x8c0e,0x4d9d,0x97,0x9f,0xe3,0xb7,0x02,0x93,0x55,0x76);


MIDL_DEFINE_GUID(IID, IID_IVBSAXDeclHandler,0xe8917260,0x7579,0x4be1,0xb5,0xdd,0x7a,0xfb,0xfa,0x6f,0x07,0x7b);


MIDL_DEFINE_GUID(IID, IID_IVBSAXAttributes,0x10dc0586,0x132b,0x4cac,0x8b,0xb3,0xdb,0x00,0xac,0x8b,0x7e,0xe0);


MIDL_DEFINE_GUID(IID, IID_IMXWriter,0x4d7ff4ba,0x1565,0x4ea8,0x94,0xe1,0x6e,0x72,0x4a,0x46,0xf9,0x8d);


MIDL_DEFINE_GUID(IID, IID_IMXAttributes,0xf10d27cc,0x3ec0,0x415c,0x8e,0xd8,0x77,0xab,0x1c,0x5e,0x72,0x62);


MIDL_DEFINE_GUID(IID, IID_IMXReaderControl,0x808f4e35,0x8d5a,0x4fbe,0x84,0x66,0x33,0xa4,0x12,0x79,0xed,0x30);


MIDL_DEFINE_GUID(IID, IID_IXMLElementCollection,0x65725580,0x9B5D,0x11d0,0x9B,0xFE,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);


MIDL_DEFINE_GUID(IID, IID_IXMLDocument,0xF52E2B61,0x18A1,0x11d1,0xB1,0x05,0x00,0x80,0x5F,0x49,0x91,0x6B);


MIDL_DEFINE_GUID(IID, IID_IXMLDocument2,0x2B8DE2FE,0x8D2D,0x11d1,0xB2,0xFC,0x00,0xC0,0x4F,0xD9,0x15,0xA9);


MIDL_DEFINE_GUID(IID, IID_IXMLElement,0x3F7F31AC,0xE15F,0x11d0,0x9C,0x25,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);


MIDL_DEFINE_GUID(IID, IID_IXMLElement2,0x2B8DE2FF,0x8D2D,0x11d1,0xB2,0xFC,0x00,0xC0,0x4F,0xD9,0x15,0xA9);


MIDL_DEFINE_GUID(IID, IID_IXMLAttribute,0xD4D4A0FC,0x3B73,0x11d1,0xB2,0xB4,0x00,0xC0,0x4F,0xB9,0x25,0x96);


MIDL_DEFINE_GUID(IID, IID_IXMLError,0x948C5AD3,0xC58D,0x11d0,0x9C,0x0B,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);


MIDL_DEFINE_GUID(IID, IID_IXMLDOMSelection,0xAA634FC7,0x5888,0x44a7,0xA2,0x57,0x3A,0x47,0x15,0x0D,0x3A,0x0E);


MIDL_DEFINE_GUID(IID, DIID_XMLDOMDocumentEvents,0x3efaa427,0x272f,0x11d2,0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82);


MIDL_DEFINE_GUID(IID, IID_IDSOControl,0x310afa62,0x0575,0x11d2,0x9c,0xa9,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLHTTPRequest,0xED8C108D,0x4349,0x11D2,0x91,0xA4,0x00,0xC0,0x4F,0x79,0x69,0xE8);


MIDL_DEFINE_GUID(IID, IID_IServerXMLHTTPRequest,0x2e9196bf,0x13ba,0x4dd4,0x91,0xca,0x6c,0x57,0x1f,0x28,0x14,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument,0xF6D90F11,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument26,0xf5078f1b,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_DOMDocument30,0xf5078f32,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_FreeThreadedDOMDocument,0xF6D90F12,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_FreeThreadedDOMDocument26,0xf5078f1c,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_FreeThreadedDOMDocument30,0xf5078f33,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLSchemaCache,0x373984c9,0xb845,0x449b,0x91,0xe7,0x45,0xac,0x83,0x03,0x6a,0xde);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLSchemaCache26,0xf5078f1d,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLSchemaCache30,0xf5078f34,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XSLTemplate,0x2933BF94,0x7B36,0x11d2,0xB2,0x0E,0x00,0xC0,0x4F,0x98,0x3E,0x60);


MIDL_DEFINE_GUID(CLSID, CLSID_XSLTemplate26,0xf5078f21,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XSLTemplate30,0xf5078f36,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_DSOControl,0xF6D90F14,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_DSOControl26,0xf5078f1f,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_DSOControl30,0xf5078f39,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLHTTP,0xF6D90F16,0x9C73,0x11D3,0xB3,0x2E,0x00,0xC0,0x4F,0x99,0x0B,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLHTTP26,0xf5078f1e,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLHTTP30,0xf5078f35,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_ServerXMLHTTP,0xafba6b42,0x5692,0x48ea,0x81,0x41,0xdc,0x51,0x7d,0xcf,0x0e,0xf1);


MIDL_DEFINE_GUID(CLSID, CLSID_ServerXMLHTTP30,0xafb40ffd,0xb609,0x40a3,0x98,0x28,0xf8,0x8b,0xbe,0x11,0xe4,0xe3);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXXMLReader,0x079aa557,0x4a18,0x424a,0x8e,0xee,0xe3,0x9f,0x0a,0x8d,0x41,0xb9);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXXMLReader30,0x3124c396,0xfb13,0x4836,0xa6,0xad,0x13,0x17,0xf1,0x71,0x36,0x88);


MIDL_DEFINE_GUID(CLSID, CLSID_MXXMLWriter,0xfc220ad8,0xa72a,0x4ee8,0x92,0x6e,0x0b,0x7a,0xd1,0x52,0xa0,0x20);


MIDL_DEFINE_GUID(CLSID, CLSID_MXXMLWriter30,0x3d813dfe,0x6c91,0x4a4e,0x8f,0x41,0x04,0x34,0x6a,0x84,0x1d,0x9c);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXAttributes,0x4dd441ad,0x526d,0x4a77,0x9f,0x1b,0x98,0x41,0xed,0x80,0x2f,0xb0);


MIDL_DEFINE_GUID(CLSID, CLSID_SAXAttributes30,0x3e784a01,0xf3ae,0x4dc0,0x93,0x54,0x95,0x26,0xb9,0x37,0x0e,0xba);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLDocument,0xCFC399AF,0xD876,0x11d0,0x9C,0x10,0x00,0xC0,0x4F,0xC9,0x9C,0x8E);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\msxml2\xmlparser_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for xmlparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_XMLPSR,0xd242361c,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLNodeSource,0xd242361d,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLParser,0xd242361e,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLNodeFactory,0xd242361f,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser,0xf5078f19,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser26,0xf5078f20,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser30,0xf5078f31,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for xmlparser.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_XMLPSR,0xd242361c,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLNodeSource,0xd242361d,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLParser,0xd242361e,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLNodeFactory,0xd242361f,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser,0xf5078f19,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser26,0xf5078f20,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser30,0xf5078f31,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\msxs64\msxs64.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    msxs64.c

Abstract:

   This module implements stub functions for shell32 interfaces.

Author:

    David N. Cutler (davec) 11-Jun-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"

#define STUBFUNC(x)     \
int                     \
x(                      \
    void                \
    )                   \
{                       \
    return 0;           \
}

STUBFUNC(DllCanUnloadNow)
STUBFUNC(DllGetClassObject)
STUBFUNC(DllMain)
STUBFUNC(DllRegisterServer)
STUBFUNC(DllUnregisterServer)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\msxml2\xmldocnf_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for xmldocnf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IXMLDocumentNotify,0x53BE4F42,0x3602,0x11d2,0x80,0x1B,0x00,0x00,0xF8,0x7A,0x6C,0xDF);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for xmldocnf.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IXMLDocumentNotify,0x53BE4F42,0x3602,0x11d2,0x80,0x1B,0x00,0x00,0xF8,0x7A,0x6C,0xDF);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\msxml2\msxml2did.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*         Copyright (c) 1996 - 1999 Microsoft Corporation. All rights reserved.**///*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __MSXML2DID_H__
#define __MSXML2DID_H__
//;end_internal

#define DISPID_XOBJ_MIN                 0x00010000
#define DISPID_XOBJ_MAX                 0x0001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN


#define DISPID_XMLELEMENTCOLLECTION             DISPID_XOBJ_BASE

#define DISPID_XMLELEMENTCOLLECTION_LENGTH     DISPID_XMLELEMENTCOLLECTION + 1
#define DISPID_XMLELEMENTCOLLECTION_NEWENUM     DISPID_NEWENUM
#define DISPID_XMLELEMENTCOLLECTION_ITEM        DISPID_XMLELEMENTCOLLECTION + 3


#define DISPID_XMLDOCUMENT                      DISPID_XMLELEMENTCOLLECTION + 100

#define DISPID_XMLDOCUMENT_ROOT                 DISPID_XMLDOCUMENT + 1
#define DISPID_XMLDOCUMENT_FILESIZE             DISPID_XMLDOCUMENT + 2
#define DISPID_XMLDOCUMENT_FILEMODIFIEDDATE     DISPID_XMLDOCUMENT + 3
#define DISPID_XMLDOCUMENT_FILEUPDATEDDATE      DISPID_XMLDOCUMENT + 4
#define DISPID_XMLDOCUMENT_URL                  DISPID_XMLDOCUMENT + 5
#define DISPID_XMLDOCUMENT_MIMETYPE             DISPID_XMLDOCUMENT + 6
#define DISPID_XMLDOCUMENT_READYSTATE           DISPID_XMLDOCUMENT + 7
#define DISPID_XMLDOCUMENT_CREATEELEMENT        DISPID_XMLDOCUMENT + 8
#define DISPID_XMLDOCUMENT_CHARSET              DISPID_XMLDOCUMENT + 9
#define DISPID_XMLDOCUMENT_VERSION              DISPID_XMLDOCUMENT + 10
#define DISPID_XMLDOCUMENT_DOCTYPE              DISPID_XMLDOCUMENT + 11
#define DISPID_XMLDOCUMENT_DTDURL               DISPID_XMLDOCUMENT + 12
#define DISPID_XMLDOCUMENT_ASYNC                DISPID_XMLDOCUMENT + 13
#define DISPID_XMLDOCUMENT_CASEINSENSITIVE      DISPID_XMLDOCUMENT + 14
#define DISPID_XMLDOCUMENT_BASEURL              DISPID_XMLDOCUMENT + 15
#define DISPID_XMLDOCUMENT_XML                  DISPID_XMLDOCUMENT + 16
#define DISPID_XMLDOCUMENT_LASTERROR            DISPID_XMLDOCUMENT + 17
#define DISPID_XMLDOCUMENT_TRIMWHITESPACE       DISPID_XMLDOCUMENT + 18
#define DISPID_XMLDOCUMENT_COMMIT				DISPID_XMLDOCUMENT + 19

#define DISPID_XMLELEMENT                       DISPID_XMLDOCUMENT + 100

#define DISPID_XMLELEMENT_TAGNAME               DISPID_XMLELEMENT + 1
#define DISPID_XMLELEMENT_PARENT                DISPID_XMLELEMENT + 2
#define DISPID_XMLELEMENT_SETATTRIBUTE          DISPID_XMLELEMENT + 3
#define DISPID_XMLELEMENT_GETATTRIBUTE          DISPID_XMLELEMENT + 4
#define DISPID_XMLELEMENT_REMOVEATTRIBUTE       DISPID_XMLELEMENT + 5
#define DISPID_XMLELEMENT_CHILDREN              DISPID_XMLELEMENT + 6
#define DISPID_XMLELEMENT_TYPE                  DISPID_XMLELEMENT + 7
#define DISPID_XMLELEMENT_TEXT                  DISPID_XMLELEMENT + 8
#define DISPID_XMLELEMENT_ADDCHILD              DISPID_XMLELEMENT + 9
#define DISPID_XMLELEMENT_REMOVECHILD           DISPID_XMLELEMENT + 10
#define DISPID_XMLELEMENT_ATTRIBUTES            DISPID_XMLELEMENT + 11

#define DISPID_XMLNOTIFSINK                     DISPID_XMLELEMENT + 100 

#define DISPID_XMLNOTIFSINK_CHILDADDED          DISPID_XMLNOTIFSINK + 1

#define DISPID_XMLATTRIBUTE                     DISPID_XMLNOTIFSINK + 100

#define DISPID_XMLATTRIBUTE_NAME                DISPID_XMLATTRIBUTE + 1
#define DISPID_XMLATTRIBUTE_VALUE               DISPID_XMLATTRIBUTE + 2


// IXMLError2
#define DISPID_XMLERROR                         DISPID_XMLNOTIFSINK + 100
#define DISPID_XMLERROR_REASON                  DISPID_XMLERROR + 1
#define DISPID_XMLERROR_LINE                    DISPID_XMLERROR + 2
#define DISPID_XMLERROR_POS                     DISPID_XMLERROR + 3

// INode
#define DISPID_NODE                             DISPID_XMLERROR + 100
#define DISPID_NODE_NAME                        DISPID_NODE + 1
#define DISPID_NODE_PARENT                      DISPID_NODE + 2
#define DISPID_NODE_TYPE                        DISPID_NODE + 3

#define DISPID_NODE_VALUE                       DISPID_NODE + 4

#define DISPID_NODE_SETATTRIBUTE                DISPID_NODE + 5
#define DISPID_NODE_GETATTRIBUTE                DISPID_NODE + 6
#define DISPID_NODE_REMOVEATTRIBUTE             DISPID_NODE + 7
#define DISPID_NODE_ATTRIBUTES                  DISPID_NODE + 8

#define DISPID_NODE_ADD                         DISPID_NODE + 9
#define DISPID_NODE_REMOVE                      DISPID_NODE + 10
#define DISPID_NODE_CHILDREN                    DISPID_NODE + 11

// INodeList
#define DISPID_NODELIST                         DISPID_NODE + 100
#define DISPID_NODELIST_NEWENUM                 DISPID_NODELIST + 1
#define DISPID_NODELIST_NEXT                    DISPID_NODELIST + 2
#define DISPID_NODELIST_CURRENT                 DISPID_NODELIST + 3
#define DISPID_NODELIST_MOVE                    DISPID_NODELIST + 4
#define DISPID_NODELIST_MOVETONODE              DISPID_NODELIST + 5

#define DISPID_NODELIST_LENGTH                  DISPID_NODELIST + 6
#define DISPID_NODELIST_ITEM                    DISPID_NODELIST + 7


// Our dispids need to be mapped into the range 1..9999 to kep Trident happy
// specifically, to make the XML tag more efficient. (simonb, 09-18-1998)
#define DISPID_DOM_BASE                 0x00000001

#define DISPID_DOM_COLLECTION_BASE	1000000
#define DISPID_DOM_COLLECTION_MAX	2999999

#define DISPID_DOM_NODE                             (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME                    (DISPID_DOM_NODE + 1)
#define DISPID_DOM_NODE_NODEVALUE                   (DISPID_DOM_NODE + 2)
#define DISPID_DOM_NODE_NODETYPE                    (DISPID_DOM_NODE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM                (DISPID_DOM_NODE + 4)
#define DISPID_DOM_NODE_PARENTNODE                  (DISPID_DOM_NODE + 5)
#define DISPID_DOM_NODE_CHILDNODES                  (DISPID_DOM_NODE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD                  (DISPID_DOM_NODE + 7)
#define DISPID_DOM_NODE_LASTCHILD                   (DISPID_DOM_NODE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING             (DISPID_DOM_NODE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING                 (DISPID_DOM_NODE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES                  (DISPID_DOM_NODE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE                (DISPID_DOM_NODE + 12)
#define DISPID_DOM_NODE_REPLACECHILD                (DISPID_DOM_NODE + 13)
#define DISPID_DOM_NODE_REMOVECHILD                 (DISPID_DOM_NODE + 14)
#define DISPID_DOM_NODE_APPENDCHILD                 (DISPID_DOM_NODE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES               (DISPID_DOM_NODE + 16)
#define DISPID_DOM_NODE_OWNERDOC                    (DISPID_DOM_NODE + 17)
#define DISPID_DOM_NODE_CLONENODE                   (DISPID_DOM_NODE + 18)
#define DISPID_XMLDOM_NODE                          (DISPID_DOM_NODE + 19)
#define DISPID_XMLDOM_NODE_STRINGTYPE               (DISPID_XMLDOM_NODE + 1)
#define DISPID_XMLDOM_NODE_SPECIFIED                (DISPID_XMLDOM_NODE + 2)
#define DISPID_XMLDOM_NODE_DEFINITION               (DISPID_XMLDOM_NODE + 3)
#define DISPID_XMLDOM_NODE_TEXT                     (DISPID_XMLDOM_NODE + 4)
#define DISPID_XMLDOM_NODE_NODETYPEDVALUE           (DISPID_XMLDOM_NODE + 5)
#define DISPID_XMLDOM_NODE_DATATYPE                 (DISPID_XMLDOM_NODE + 6)
#define DISPID_XMLDOM_NODE_XML                      (DISPID_XMLDOM_NODE + 7)
#define DISPID_XMLDOM_NODE_TRANSFORMNODE            (DISPID_XMLDOM_NODE + 8)
#define DISPID_XMLDOM_NODE_SELECTNODES              (DISPID_XMLDOM_NODE + 9)
#define DISPID_XMLDOM_NODE_SELECTSINGLENODE         (DISPID_XMLDOM_NODE + 10)
#define DISPID_XMLDOM_NODE_PARSED                   (DISPID_XMLDOM_NODE + 11)
#define DISPID_XMLDOM_NODE_NAMESPACE                (DISPID_XMLDOM_NODE + 12)
#define DISPID_XMLDOM_NODE_PREFIX                   (DISPID_XMLDOM_NODE + 13)
#define DISPID_XMLDOM_NODE_BASENAME                 (DISPID_XMLDOM_NODE + 14)
#define DISPID_XMLDOM_NODE_TRANSFORMNODETOOBJECT    (DISPID_XMLDOM_NODE + 15)
#define DISPID_XMLDOM_NODE__TOP                     (DISPID_XMLDOM_NODE + 16)

#define DISPID_DOM_DOCUMENT                        (DISPID_XMLDOM_NODE__TOP + 1)
#define DISPID_DOM_DOCUMENT_DOCTYPE                (DISPID_DOM_DOCUMENT + 1)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION         (DISPID_DOM_DOCUMENT + 2)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT        (DISPID_DOM_DOCUMENT + 3)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT          (DISPID_DOM_DOCUMENT + 4)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_DOCUMENT + 5)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE         (DISPID_DOM_DOCUMENT + 6)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT          (DISPID_DOM_DOCUMENT + 7)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION     (DISPID_DOM_DOCUMENT + 8)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_DOCUMENT + 9)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE        (DISPID_DOM_DOCUMENT + 10)
#define DISPID_DOM_DOCUMENT_CREATEENTITY           (DISPID_DOM_DOCUMENT + 11)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE  (DISPID_DOM_DOCUMENT + 12)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME   (DISPID_DOM_DOCUMENT + 13)
#define DISPID_DOM_DOCUMENT_TOP                    (DISPID_DOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT                     (DISPID_DOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNODE        (DISPID_XMLDOM_DOCUMENT + 1)
#define DISPID_XMLDOM_DOCUMENT_CREATENODE          (DISPID_XMLDOM_DOCUMENT + 2)
#define DISPID_XMLDOM_DOCUMENT_CREATENODEEX        (DISPID_XMLDOM_DOCUMENT + 3)
#define DISPID_XMLDOM_DOCUMENT_NODEFROMID          (DISPID_XMLDOM_DOCUMENT + 4)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNAMESPACES  (DISPID_XMLDOM_DOCUMENT + 5)
#define DISPID_XMLDOM_DOCUMENT_LOAD                (DISPID_XMLDOM_DOCUMENT + 6)
#define DISPID_XMLDOM_DOCUMENT_PARSEERROR          (DISPID_XMLDOM_DOCUMENT + 7)
#define DISPID_XMLDOM_DOCUMENT_URL                 (DISPID_XMLDOM_DOCUMENT + 8)
#define DISPID_XMLDOM_DOCUMENT_ASYNC               (DISPID_XMLDOM_DOCUMENT + 9)
#define DISPID_XMLDOM_DOCUMENT_ABORT               (DISPID_XMLDOM_DOCUMENT + 10)
#define DISPID_XMLDOM_DOCUMENT_LOADXML             (DISPID_XMLDOM_DOCUMENT + 11)
#define DISPID_XMLDOM_DOCUMENT_SAVE                (DISPID_XMLDOM_DOCUMENT + 12)
#define DISPID_XMLDOM_DOCUMENT_VALIDATE            (DISPID_XMLDOM_DOCUMENT + 13)
#define DISPID_XMLDOM_DOCUMENT_RESOLVENAMESPACE    (DISPID_XMLDOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT_PRESERVEWHITESPACE  (DISPID_XMLDOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_ONREADYSTATECHANGE  (DISPID_XMLDOM_DOCUMENT + 16)
#define DISPID_XMLDOM_DOCUMENT_ONDATAAVAILABLE     (DISPID_XMLDOM_DOCUMENT + 17)
#define DISPID_XMLDOM_DOCUMENT_ONTRANSFORMNODE     (DISPID_XMLDOM_DOCUMENT + 18)
#define DISPID_XMLDOM_DOCUMENT__TOP                (DISPID_XMLDOM_DOCUMENT + 19)

#define DISPID_DOM_NODELIST             (DISPID_XMLDOM_DOCUMENT__TOP + 1)
#define DISPID_DOM_NODELIST_ITEM        (DISPID_DOM_NODELIST + 1)
#define DISPID_DOM_NODELIST_LENGTH      (DISPID_DOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST          (DISPID_DOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST_NEXTNODE (DISPID_XMLDOM_NODELIST + 1)
#define DISPID_XMLDOM_NODELIST_RESET    (DISPID_XMLDOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST_NEWENUM  (DISPID_XMLDOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST__TOP     (DISPID_XMLDOM_NODELIST + 4)


#define DISPID_DOM_NAMEDNODEMAP                         (DISPID_XMLDOM_NODELIST__TOP + 1)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 3)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 4)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM         (DISPID_DOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP                      (DISPID_DOM_NAMEDNODEMAP + 6)
#define DISPID_XMLDOM_NAMEDNODEMAP_GETQUALIFIEDITEM     (DISPID_XMLDOM_NAMEDNODEMAP + 1)
#define DISPID_XMLDOM_NAMEDNODEMAP_REMOVEQUALIFIEDITEM  (DISPID_XMLDOM_NAMEDNODEMAP + 2)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEXTNODE             (DISPID_XMLDOM_NAMEDNODEMAP + 3)
#define DISPID_XMLDOM_NAMEDNODEMAP_RESET                (DISPID_XMLDOM_NAMEDNODEMAP + 4)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEWENUM              (DISPID_XMLDOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP__TOP                 (DISPID_XMLDOM_NAMEDNODEMAP + 6)


#define DISPID_DOM_W3CWRAPPERS                 (DISPID_XMLDOM_NAMEDNODEMAP__TOP + 1)

#define DISPID_DOM_DOCUMENTFRAGMENT            (DISPID_DOM_W3CWRAPPERS + 1)
#define DISPID_DOM_DOCUMENTFRAGMENT__TOP       (DISPID_DOM_DOCUMENTFRAGMENT + 1)

#define DISPID_DOM_ELEMENT                         (DISPID_DOM_DOCUMENTFRAGMENT__TOP + 1)
#define DISPID_DOM_ELEMENT_GETTAGNAME              (DISPID_DOM_ELEMENT + 1)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES           (DISPID_DOM_ELEMENT + 2)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE            (DISPID_DOM_ELEMENT + 3)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE            (DISPID_DOM_ELEMENT + 4)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE         (DISPID_DOM_ELEMENT + 5)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 6)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 7)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE     (DISPID_DOM_ELEMENT + 8)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME    (DISPID_DOM_ELEMENT + 9)
#define DISPID_DOM_ELEMENT_NORMALIZE               (DISPID_DOM_ELEMENT + 10)
#define DISPID_DOM_ELEMENT__TOP                    (DISPID_DOM_ELEMENT + 11)

#define DISPID_DOM_DATA                        (DISPID_DOM_ELEMENT__TOP + 1)
#define DISPID_DOM_DATA_DATA                   (DISPID_DOM_DATA + 1)
#define DISPID_DOM_DATA_LENGTH                 (DISPID_DOM_DATA + 2)
#define DISPID_DOM_DATA_SUBSTRING              (DISPID_DOM_DATA + 3)
#define DISPID_DOM_DATA_APPEND                 (DISPID_DOM_DATA + 4)
#define DISPID_DOM_DATA_INSERT                 (DISPID_DOM_DATA + 5)
#define DISPID_DOM_DATA_DELETE                 (DISPID_DOM_DATA + 6)
#define DISPID_DOM_DATA_REPLACE                (DISPID_DOM_DATA + 7)
#define DISPID_DOM_DATA__TOP                   (DISPID_DOM_DATA + 8)

#define DISPID_DOM_ATTRIBUTE                   (DISPID_DOM_DATA__TOP + 1)
#define DISPID_DOM_ATTRIBUTE_GETNAME           (DISPID_DOM_ATTRIBUTE + 1)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED         (DISPID_DOM_ATTRIBUTE + 2)
#define DISPID_DOM_ATTRIBUTE_VALUE             (DISPID_DOM_ATTRIBUTE + 3)
#define DISPID_DOM_ATTRIBUTE__TOP              (DISPID_DOM_ATTRIBUTE + 4)

#define DISPID_DOM_TEXT                (DISPID_DOM_ATTRIBUTE__TOP + 1)
#define DISPID_DOM_TEXT_SPLITTEXT      (DISPID_DOM_TEXT + 1)
#define DISPID_DOM_TEXT_JOINTEXT       (DISPID_DOM_TEXT + 2)
#define DISPID_DOM_TEXT__TOP           (DISPID_DOM_TEXT + 3)

#define DISPID_DOM_PI           (DISPID_DOM_TEXT__TOP + 1)
#define DISPID_DOM_PI_TARGET    (DISPID_DOM_PI + 1)
#define DISPID_DOM_PI_DATA      (DISPID_DOM_PI + 2)
#define DISPID_DOM_PI__TOP      (DISPID_DOM_PI + 3)

#define DISPID_DOM_DOCUMENTTYPE            (DISPID_DOM_PI__TOP + 1)
#define DISPID_DOM_DOCUMENTTYPE_NAME       (DISPID_DOM_DOCUMENTTYPE + 1)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES   (DISPID_DOM_DOCUMENTTYPE + 2)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS  (DISPID_DOM_DOCUMENTTYPE + 3)
#define DISPID_DOM_DOCUMENTTYPE__TOP       (DISPID_DOM_DOCUMENTTYPE + 4)

#define DISPID_DOM_NOTATION                (DISPID_DOM_DOCUMENTTYPE__TOP + 1)
#define DISPID_DOM_NOTATION_PUBLICID       (DISPID_DOM_NOTATION + 1)
#define DISPID_DOM_NOTATION_SYSTEMID       (DISPID_DOM_NOTATION + 2)
#define DISPID_DOM_NOTATION__TOP           (DISPID_DOM_NOTATION + 3)

#define DISPID_DOM_ENTITY                  (DISPID_DOM_NOTATION__TOP + 1)
#define DISPID_DOM_ENTITY_PUBLICID         (DISPID_DOM_ENTITY + 1)
#define DISPID_DOM_ENTITY_SYSTEMID         (DISPID_DOM_ENTITY + 2)
#define DISPID_DOM_ENTITY_NOTATIONNAME     (DISPID_DOM_ENTITY + 3)
#define DISPID_DOM_ENTITY__TOP             (DISPID_DOM_ENTITY + 4)

//define DISPID_DOM_COMMENT         
//define DISPID_DOM_CDATASECTION
//define DISPID_DOM_ENTITYREFERENCE

#define DISPID_DOM_W3CWRAPPERS_TOP         (DISPID_DOM_ENTITY__TOP)


#define DISPID_DOM_IMPLEMENTATION              (DISPID_DOM_W3CWRAPPERS_TOP + 1)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE   (DISPID_DOM_IMPLEMENTATION + 1)
#define DISPID_DOM_IMPLEMENTATION__TOP         (DISPID_DOM_IMPLEMENTATION + 2)

#define DISPID_DOM__TOP         (DISPID_DOM_IMPLEMENTATION + 0x20)


#define  DISPID_DOM_ERROR                      (DISPID_DOM__TOP  + 1)
#define  DISPID_DOM_ERROR_ERRORCODE            (DISPID_DOM_ERROR  +  1)
#define  DISPID_DOM_ERROR_URL                  (DISPID_DOM_ERROR  +  2)
#define  DISPID_DOM_ERROR_REASON               (DISPID_DOM_ERROR  +  3)
#define  DISPID_DOM_ERROR_SRCTEXT              (DISPID_DOM_ERROR  +  4)
#define  DISPID_DOM_ERROR_LINE                 (DISPID_DOM_ERROR  +  5)
#define  DISPID_DOM_ERROR_LINEPOS              (DISPID_DOM_ERROR  +  6)
#define  DISPID_DOM_ERROR_FILEPOS              (DISPID_DOM_ERROR  +  7)
#define  DISPID_DOM_ERROR__TOP                 (DISPID_DOM_ERROR  +  8)

#define  DISPID_XTLRUNTIME                         (DISPID_DOM_ERROR__TOP + 1)
#define  DISPID_XTLRUNTIME_UNIQUEID                (DISPID_XTLRUNTIME + 1)
#define  DISPID_XTLRUNTIME_DEPTH                   (DISPID_XTLRUNTIME + 2)
#define  DISPID_XTLRUNTIME_CHILDNUMBER             (DISPID_XTLRUNTIME + 3)
#define  DISPID_XTLRUNTIME_ANCESTORCHILDNUMBER     (DISPID_XTLRUNTIME + 4)
#define  DISPID_XTLRUNTIME_ABSOLUTECHILDNUMBER     (DISPID_XTLRUNTIME + 5)
#define  DISPID_XTLRUNTIME_FORMATINDEX             (DISPID_XTLRUNTIME + 6)
#define  DISPID_XTLRUNTIME_FORMATNUMBER            (DISPID_XTLRUNTIME + 7)
#define  DISPID_XTLRUNTIME_FORMATDATE              (DISPID_XTLRUNTIME + 8)
#define  DISPID_XTLRUNTIME_FORMATTIME              (DISPID_XTLRUNTIME + 9)
#define  DISPID_XTLRUNTIME__TOP                    (DISPID_XTLRUNTIME + 10)

#define  DISPID_XMLDOMEVENT                        (DISPID_XTLRUNTIME__TOP + 1)
#define  DISPID_XMLDOMEVENT_ONREADYSTATECHANGE     (DISPID_READYSTATECHANGE)
#define  DISPID_XMLDOMEVENT_ONDATAAVAILABLE        (DISPID_XMLDOMEVENT + 1)
#define  DISPID_XMLDOMEVENT__TOP                   (DISPID_XMLDOMEVENT + 2)

#define DISPID_XMLDOM_DOCUMENT2                    (DISPID_XMLDOMEVENT__TOP + 1)
#define DISPID_XMLDOM_DOCUMENT2_NAMESPACES         (DISPID_XMLDOM_DOCUMENT2 + 1)
#define DISPID_XMLDOM_DOCUMENT2_SCHEMAS            (DISPID_XMLDOM_DOCUMENT2 + 2)
#define DISPID_XMLDOM_DOCUMENT2_VALIDATE           (DISPID_XMLDOM_DOCUMENT2 + 3)
#define DISPID_XMLDOM_DOCUMENT2_SETPROPERTY        (DISPID_XMLDOM_DOCUMENT2 + 4)
#define DISPID_XMLDOM_DOCUMENT2_GETPROPERTY        (DISPID_XMLDOM_DOCUMENT2 + 5)
#define DISPID_XMLDOM_DOCUMENT2__TOP               (DISPID_XMLDOM_DOCUMENT2 + 6)

#define DISPID_XMLDOM_SCHEMACOLLECTION               (DISPID_DOM_BASE + 1)
#define DISPID_XMLDOM_SCHEMACOLLECTION_ADD           (DISPID_XMLDOM_SCHEMACOLLECTION + 1)
#define DISPID_XMLDOM_SCHEMACOLLECTION_GET           (DISPID_XMLDOM_SCHEMACOLLECTION + 2)
#define DISPID_XMLDOM_SCHEMACOLLECTION_REMOVE        (DISPID_XMLDOM_SCHEMACOLLECTION + 3)
#define DISPID_XMLDOM_SCHEMACOLLECTION_LENGTH        (DISPID_XMLDOM_SCHEMACOLLECTION + 4)
#define DISPID_XMLDOM_SCHEMACOLLECTION_NAMESPACEURI  (DISPID_XMLDOM_SCHEMACOLLECTION + 5)
#define DISPID_XMLDOM_SCHEMACOLLECTION_ADDCOLLECTION (DISPID_XMLDOM_SCHEMACOLLECTION + 6)
#define DISPID_XMLDOM_SCHEMACOLLECTION__TOP          (DISPID_XMLDOM_SCHEMACOLLECTION + 7)

#define DISPID_XMLDOM_SELECTION                    (DISPID_XMLDOM_NODELIST__TOP + 1)
#define DISPID_XMLDOM_SELECTION_EXPR               (DISPID_XMLDOM_SELECTION + 1)
#define DISPID_XMLDOM_SELECTION_CONTEXT            (DISPID_XMLDOM_SELECTION + 2)
#define DISPID_XMLDOM_SELECTION_PEEKNODE           (DISPID_XMLDOM_SELECTION + 3)
#define DISPID_XMLDOM_SELECTION_MATCHES            (DISPID_XMLDOM_SELECTION + 4)
#define DISPID_XMLDOM_SELECTION_REMOVENEXT         (DISPID_XMLDOM_SELECTION + 5)
#define DISPID_XMLDOM_SELECTION_REMOVEALL          (DISPID_XMLDOM_SELECTION + 6)
#define DISPID_XMLDOM_SELECTION_CLONE              (DISPID_XMLDOM_SELECTION + 7)
#define DISPID_XMLDOM_SELECTION_GETPROPERTY        (DISPID_XMLDOM_SELECTION + 8)
#define DISPID_XMLDOM_SELECTION_SETPROPERTY        (DISPID_XMLDOM_SELECTION + 9)
#define DISPID_XMLDOM_SELECTION__TOP               (DISPID_XMLDOM_SELECTION + 10)

#define DISPID_XMLDOM_TEMPLATE                    (DISPID_DOM_BASE)
#define DISPID_XMLDOM_TEMPLATE_STYLESHEET         (DISPID_XMLDOM_TEMPLATE + 1)
#define DISPID_XMLDOM_TEMPLATE_CREATEPROCESSOR    (DISPID_XMLDOM_TEMPLATE + 2)
#define DISPID_XMLDOM_TEMPLATE__TOP               (DISPID_XMLDOM_TEMPLATE + 3)

#define DISPID_XMLDOM_PROCESSOR                    (DISPID_DOM_BASE)
#define DISPID_XMLDOM_PROCESSOR_INPUT              (DISPID_XMLDOM_PROCESSOR + 1)
#define DISPID_XMLDOM_PROCESSOR_XSLTEMPLATE        (DISPID_XMLDOM_PROCESSOR + 2)
#define DISPID_XMLDOM_PROCESSOR_SETSTARTMODE       (DISPID_XMLDOM_PROCESSOR + 3)
#define DISPID_XMLDOM_PROCESSOR_STARTMODE          (DISPID_XMLDOM_PROCESSOR + 4)
#define DISPID_XMLDOM_PROCESSOR_STARTMODEURI       (DISPID_XMLDOM_PROCESSOR + 5)
#define DISPID_XMLDOM_PROCESSOR_OUTPUT             (DISPID_XMLDOM_PROCESSOR + 6)
#define DISPID_XMLDOM_PROCESSOR_TRANSFORM          (DISPID_XMLDOM_PROCESSOR + 7)
#define DISPID_XMLDOM_PROCESSOR_RESET              (DISPID_XMLDOM_PROCESSOR + 8)
#define DISPID_XMLDOM_PROCESSOR_READYSTATE         (DISPID_XMLDOM_PROCESSOR + 9)
#define DISPID_XMLDOM_PROCESSOR_ADDPARAMETER       (DISPID_XMLDOM_PROCESSOR + 10)
#define DISPID_XMLDOM_PROCESSOR_ADDOBJECT          (DISPID_XMLDOM_PROCESSOR + 11)
#define DISPID_XMLDOM_PROCESSOR_STYLESHEET         (DISPID_XMLDOM_PROCESSOR + 12)
#define DISPID_XMLDOM_PROCESSOR__TOP               (DISPID_XMLDOM_PROCESSOR + 13)


#define  DISPID_XMLDSO                       DISPID_XOBJ_BASE
#define  DISPID_XMLDSO_DOCUMENT              DISPID_XMLDSO  +  1
#define  DISPID_XMLDSO_JAVADSOCOMPATIBLE     DISPID_XMLDSO_DOCUMENT  +  1


#define DISPID_SAX_XMLREADER__MIN                 0x00000501
#define DISPID_SAX_XMLREADER__MAX                 0x00010000
#define DISPID_SAX_XMLREADER__BASE                DISPID_SAX_XMLREADER__MIN

#define DISPID_SAX_XMLREADER (DISPID_SAX_XMLREADER__BASE)
#define DISPID_SAX_XMLREADER_GETFEATURE (DISPID_SAX_XMLREADER + 1)
#define DISPID_SAX_XMLREADER_PUTFEATURE (DISPID_SAX_XMLREADER + 2)
#define DISPID_SAX_XMLREADER_GETPROPERTY (DISPID_SAX_XMLREADER + 3)
#define DISPID_SAX_XMLREADER_PUTPROPERTY (DISPID_SAX_XMLREADER + 4)
#define DISPID_SAX_XMLREADER_ENTITYRESOLVER (DISPID_SAX_XMLREADER + 5)
#define DISPID_SAX_XMLREADER_CONTENTHANDLER (DISPID_SAX_XMLREADER + 6)
#define DISPID_SAX_XMLREADER_DTDHANDLER (DISPID_SAX_XMLREADER + 7)
#define DISPID_SAX_XMLREADER_ERRORHANDLER (DISPID_SAX_XMLREADER + 8)
#define DISPID_SAX_XMLREADER_BASEURL (DISPID_SAX_XMLREADER + 9)
#define DISPID_SAX_XMLREADER_SECUREBASEURL (DISPID_SAX_XMLREADER + 10)
#define DISPID_SAX_XMLREADER_PARSE (DISPID_SAX_XMLREADER + 11)
#define DISPID_SAX_XMLREADER_PARSEURL (DISPID_SAX_XMLREADER + 12)
#define DISPID_SAX_XMLREADER_PARENT (DISPID_SAX_XMLREADER + 13)
#define DISPID_SAX_XMLREADER__TOP (DISPID_SAX_XMLREADER + 14)

#define DISPID_SAX_XMLFILTER__BASE (DISPID_SAX_XMLREADER__TOP + 1)
#define DISPID_SAX_XMLFILTER (DISPID_SAX_XMLFILTER__BASE)
#define DISPID_SAX_XMLFILTER_GETFEATURE (DISPID_SAX_XMLFILTER + 1)
#define DISPID_SAX_XMLFILTER_PUTFEATURE (DISPID_SAX_XMLFILTER + 2)
#define DISPID_SAX_XMLFILTER_GETPROPERTY (DISPID_SAX_XMLFILTER + 3)
#define DISPID_SAX_XMLFILTER_PUTPROPERTY (DISPID_SAX_XMLFILTER + 4)
#define DISPID_SAX_XMLFILTER_ENTITYRESOLVER (DISPID_SAX_XMLFILTER + 5)
#define DISPID_SAX_XMLFILTER_CONTENTHANDLER (DISPID_SAX_XMLFILTER + 6)
#define DISPID_SAX_XMLFILTER_DTDHANDLER (DISPID_SAX_XMLFILTER + 7)
#define DISPID_SAX_XMLFILTER_ERRORHANDLER (DISPID_SAX_XMLFILTER + 8)
#define DISPID_SAX_XMLFILTER_BASEURL (DISPID_SAX_XMLFILTER + 9)
#define DISPID_SAX_XMLFILTER_SECUREBASEURL (DISPID_SAX_XMLFILTER + 10)
#define DISPID_SAX_XMLFILTER_PARSE (DISPID_SAX_XMLFILTER + 11)
#define DISPID_SAX_XMLFILTER_PARSEURL (DISPID_SAX_XMLFILTER + 12)
#define DISPID_SAX_XMLFILTER_PARENT (DISPID_SAX_XMLFILTER + 13)
#define DISPID_SAX_XMLFILTER__TOP (DISPID_SAX_XMLFILTER + 15)

#define DISPID_SAX_LOCATOR__BASE (DISPID_SAX_XMLFILTER__TOP + 1)
#define DISPID_SAX_LOCATOR (DISPID_SAX_LOCATOR__BASE)
#define DISPID_SAX_LOCATOR_COLUMNNUMBER (DISPID_SAX_LOCATOR + 1)
#define DISPID_SAX_LOCATOR_LINENUMBER (DISPID_SAX_LOCATOR + 2)
#define DISPID_SAX_LOCATOR_PUBLICID (DISPID_SAX_LOCATOR + 3)
#define DISPID_SAX_LOCATOR_SYSTEMID (DISPID_SAX_LOCATOR + 4)
#define DISPID_SAX_LOCATOR__TOP (DISPID_SAX_LOCATOR + 5)

#define DISPID_SAX_ENTITYRESOLVER__BASE (DISPID_SAX_LOCATOR__TOP + 1)
#define DISPID_SAX_ENTITYRESOLVER (DISPID_SAX_ENTITYRESOLVER__BASE)
#define DISPID_SAX_ENTITYRESOLVER_RESOLVEENTITY (DISPID_SAX_ENTITYRESOLVER + 1)
#define DISPID_SAX_ENTITYRESOLVER__TOP (DISPID_SAX_ENTITYRESOLVER + 2)

#define DISPID_SAX_CONTENTHANDLER__BASE (DISPID_SAX_ENTITYRESOLVER__TOP + 1)
#define DISPID_SAX_CONTENTHANDLER (DISPID_SAX_CONTENTHANDLER__BASE)
#define DISPID_SAX_CONTENTHANDLER_DOCUMENTLOCATOR (DISPID_SAX_CONTENTHANDLER + 1)
#define DISPID_SAX_CONTENTHANDLER_STARTDOCUMENT (DISPID_SAX_CONTENTHANDLER + 2)
#define DISPID_SAX_CONTENTHANDLER_ENDDOCUMENT (DISPID_SAX_CONTENTHANDLER + 3)
#define DISPID_SAX_CONTENTHANDLER_STARTPREFIXMAPPING (DISPID_SAX_CONTENTHANDLER + 4)
#define DISPID_SAX_CONTENTHANDLER_ENDPREFIXMAPPING (DISPID_SAX_CONTENTHANDLER + 5)
#define DISPID_SAX_CONTENTHANDLER_STARTELEMENT (DISPID_SAX_CONTENTHANDLER + 6)
#define DISPID_SAX_CONTENTHANDLER_ENDELEMENT (DISPID_SAX_CONTENTHANDLER + 7)
#define DISPID_SAX_CONTENTHANDLER_CHARACTERS (DISPID_SAX_CONTENTHANDLER + 8)
#define DISPID_SAX_CONTENTHANDLER_IGNORABLEWHITESPACE (DISPID_SAX_CONTENTHANDLER + 9)
#define DISPID_SAX_CONTENTHANDLER_PROCESSINGINSTRUCTION (DISPID_SAX_CONTENTHANDLER + 10)
#define DISPID_SAX_CONTENTHANDLER_SKIPPEDENTITY (DISPID_SAX_CONTENTHANDLER + 11)
#define DISPID_SAX_CONTENTHANDLER__TOP (DISPID_SAX_CONTENTHANDLER + 12)

#define DISPID_SAX_DTDHANDLER__BASE (DISPID_SAX_CONTENTHANDLER__TOP + 1)
#define DISPID_SAX_DTDHANDLER (DISPID_SAX_DTDHANDLER__BASE)
#define DISPID_SAX_DTDHANDLER_NOTATIONDECL (DISPID_SAX_DTDHANDLER + 1)
#define DISPID_SAX_DTDHANDLER_UNPARSEDENTITYDECL (DISPID_SAX_DTDHANDLER + 2)
#define DISPID_SAX_DTDHANDLER__TOP (DISPID_SAX_DTDHANDLER + 3)

#define DISPID_SAX_ERRORHANDLER__BASE (DISPID_SAX_DTDHANDLER__TOP + 1)
#define DISPID_SAX_ERRORHANDLER (DISPID_SAX_ERRORHANDLER__BASE)
#define DISPID_SAX_ERRORHANDLER_ERROR (DISPID_SAX_ERRORHANDLER + 1)
#define DISPID_SAX_ERRORHANDLER_FATALERROR (DISPID_SAX_ERRORHANDLER + 2)
#define DISPID_SAX_ERRORHANDLER_IGNORABLEWARNING (DISPID_SAX_ERRORHANDLER + 3)
#define DISPID_SAX_ERRORHANDLER__TOP (DISPID_SAX_ERRORHANDLER + 4)

#define DISPID_SAX_ATTRIBUTES__BASE (DISPID_SAX_ERRORHANDLER__TOP + 1)
#define DISPID_SAX_ATTRIBUTES (DISPID_SAX_ATTRIBUTES__BASE)
#define DISPID_SAX_ATTRIBUTES_LENGTH (DISPID_SAX_ATTRIBUTES + 1)
#define DISPID_SAX_ATTRIBUTES_GETURI (DISPID_SAX_ATTRIBUTES + 2)
#define DISPID_SAX_ATTRIBUTES_GETLOCALNAME (DISPID_SAX_ATTRIBUTES + 3)
#define DISPID_SAX_ATTRIBUTES_GETQNAME (DISPID_SAX_ATTRIBUTES + 4)
#define DISPID_SAX_ATTRIBUTES_GETINDEXFROMNAME (DISPID_SAX_ATTRIBUTES + 5)
#define DISPID_SAX_ATTRIBUTES_GETINDEXFROMQNAME (DISPID_SAX_ATTRIBUTES + 6)
#define DISPID_SAX_ATTRIBUTES_GETTYPE (DISPID_SAX_ATTRIBUTES + 7)
#define DISPID_SAX_ATTRIBUTES_GETTYPEFROMNAME (DISPID_SAX_ATTRIBUTES + 8)
#define DISPID_SAX_ATTRIBUTES_GETTYPEFROMQNAME (DISPID_SAX_ATTRIBUTES + 9)
#define DISPID_SAX_ATTRIBUTES_GETVALUE (DISPID_SAX_ATTRIBUTES + 10)
#define DISPID_SAX_ATTRIBUTES_GETVALUEFROMNAME (DISPID_SAX_ATTRIBUTES + 11)
#define DISPID_SAX_ATTRIBUTES_GETVALUEFROMQNAME (DISPID_SAX_ATTRIBUTES + 12)
#define DISPID_SAX_ATTRIBUTES__TOP (DISPID_SAX_ATTRIBUTES + 13)

#define DISPID_SAX_LEXICALHANDLER__BASE (DISPID_SAX_ATTRIBUTES__TOP + 1)
#define DISPID_SAX_LEXICALHANDLER (DISPID_SAX_LEXICALHANDLER__BASE)
#define DISPID_SAX_LEXICALHANDLER_STARTDTD (DISPID_SAX_LEXICALHANDLER + 1)
#define DISPID_SAX_LEXICALHANDLER_ENDDTD (DISPID_SAX_LEXICALHANDLER + 2)
#define DISPID_SAX_LEXICALHANDLER_STARTENTITY (DISPID_SAX_LEXICALHANDLER + 3)
#define DISPID_SAX_LEXICALHANDLER_ENDENTITY (DISPID_SAX_LEXICALHANDLER + 4)
#define DISPID_SAX_LEXICALHANDLER_STARTCDATA (DISPID_SAX_LEXICALHANDLER + 5)
#define DISPID_SAX_LEXICALHANDLER_ENDCDATA (DISPID_SAX_LEXICALHANDLER + 6)
#define DISPID_SAX_LEXICALHANDLER_COMMENT (DISPID_SAX_LEXICALHANDLER + 7)
#define DISPID_SAX_LEXICALHANDLER__TOP (DISPID_SAX_LEXICALHANDLER + 8)

#define DISPID_SAX_DECLHANDLER__BASE (DISPID_SAX_LEXICALHANDLER__TOP + 1)
#define DISPID_SAX_DECLHANDLER (DISPID_SAX_DECLHANDLER__BASE)
#define DISPID_SAX_DECLHANDLER_ELEMENTDECL (DISPID_SAX_DECLHANDLER + 1)
#define DISPID_SAX_DECLHANDLER_ATTRIBUTEDECL (DISPID_SAX_DECLHANDLER + 2)
#define DISPID_SAX_DECLHANDLER_INTERNALENTITYDECL (DISPID_SAX_DECLHANDLER + 3)
#define DISPID_SAX_DECLHANDLER_EXTERNALENTITYDECL (DISPID_SAX_DECLHANDLER + 4)
#define DISPID_SAX_DECLHANDLER__TOP (DISPID_SAX_DECLHANDLER + 5)

#define DISPID_MX_ATTRIBUTES__BASE (DISPID_SAX_DECLHANDLER__TOP + 1)
#define DISPID_MX_ATTRIBUTES (DISPID_MX_ATTRIBUTES__BASE)
#define DISPID_MX_ATTRIBUTES_ADDATTRIBUTE (DISPID_MX_ATTRIBUTES + 1)
#define DISPID_MX_ATTRIBUTES_CLEAR (DISPID_MX_ATTRIBUTES + 2)
#define DISPID_MX_ATTRIBUTES_REMOVEATTRIBUTE (DISPID_MX_ATTRIBUTES + 3)
#define DISPID_MX_ATTRIBUTES_SETATTRIBUTE (DISPID_MX_ATTRIBUTES + 4)
#define DISPID_MX_ATTRIBUTES_SETATTRIBUTES (DISPID_MX_ATTRIBUTES + 5)
#define DISPID_MX_ATTRIBUTES_SETLOCALNAME (DISPID_MX_ATTRIBUTES + 6)
#define DISPID_MX_ATTRIBUTES_SETQNAME (DISPID_MX_ATTRIBUTES + 7)
#define DISPID_MX_ATTRIBUTES_SETTYPE (DISPID_MX_ATTRIBUTES + 8)
#define DISPID_MX_ATTRIBUTES_SETURI (DISPID_MX_ATTRIBUTES + 9)
#define DISPID_MX_ATTRIBUTES_SETVALUE (DISPID_MX_ATTRIBUTES + 10)
#define DISPID_MX_ATTRIBUTES_ADDATTRIBUTEFROMINDEX (DISPID_MX_ATTRIBUTES + 11)
#define DISPID_MX_ATTRIBUTES__TOP (DISPID_MX_ATTRIBUTES + 11)

#define DISPID_MX_WRITER__BASE (DISPID_MX_ATTRIBUTES__TOP + 1)
#define DISPID_MX_WRITER (DISPID_MX_WRITER__BASE)
#define DISPID_MX_WRITER_OUTPUT (DISPID_MX_WRITER + 1)
#define DISPID_MX_WRITER_DESTINATION (DISPID_MX_WRITER + 2)
#define DISPID_MX_WRITER_ENCODING (DISPID_MX_WRITER + 3)
#define DISPID_MX_WRITER_BYTEORDERMARK (DISPID_MX_WRITER + 4)
#define DISPID_MX_WRITER_INDENT (DISPID_MX_WRITER + 5)
#define DISPID_MX_WRITER_STANDALONE (DISPID_MX_WRITER + 6)
#define DISPID_MX_WRITER_OMITXMLDECLARATION (DISPID_MX_WRITER + 7)
#define DISPID_MX_WRITER_VERSION (DISPID_MX_WRITER + 8)
#define DISPID_MX_WRITER_DISABLEOUTPUTESCAPING (DISPID_MX_WRITER + 9)
#define DISPID_MX_WRITER_FLUSH (DISPID_MX_WRITER + 10)
#define DISPID_MX_WRITER_RESET (DISPID_MX_WRITER + 11)
#define DISPID_MX_WRITER__TOP (DISPID_MX_WRITER + 12)

#define DISPID_MX_READER_CONTROL__BASE (DISPID_MX_WRITER__TOP + 1)
#define DISPID_MX_READER_CONTROL (DISPID_MX_READER_CONTROL__BASE)
#define DISPID_MX_READER_CONTROL_ABORT (DISPID_MX_READER_CONTROL + 1)
#define DISPID_MX_READER_CONTROL_RESUME (DISPID_MX_READER_CONTROL + 2)
#define DISPID_MX_READER_CONTROL_SUSPEND (DISPID_MX_READER_CONTROL + 3)
#define DISPID_MX_READER_CONTROL__TOP (DISPID_MX_READER_CONTROL + 4)

//;begin_internal
#endif // __MSXMLDID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\odbc32\sql.cpp ===
#include "windows.h"

/*
* ODBCVER  ODBC version number (0x0351).   To exclude
*          definitions introduced in version 3.5 (or above)
*          #define ODBCVER 0x0300 before #including <sql.h>
*/
#ifndef ODBCVER
#define ODBCVER 0x0351
#endif

#ifndef __SQLTYPES
#include "sqltypes.h"
#endif

#ifdef __cplusplus
extern "C" { 			/* Assume C declarations for C++   */
#endif  /* __cplusplus */

/* special length/indicator values */
#define SQL_NULL_DATA             (-1)
#define SQL_DATA_AT_EXEC          (-2)


/* return values from functions */
#define SQL_SUCCESS                0
#define SQL_SUCCESS_WITH_INFO      1
#if (ODBCVER >= 0x0300)
#define SQL_NO_DATA              100
#endif
#define SQL_ERROR                 (-1)
#define SQL_INVALID_HANDLE        (-2)

#define SQL_STILL_EXECUTING        2
#define SQL_NEED_DATA             99

/* test for SQL_SUCCESS or SQL_SUCCESS_WITH_INFO */
#define SQL_SUCCEEDED(rc) (((rc)&(~1))==0)

/* flags for null-terminated string */
#define SQL_NTS                   (-3)
#define SQL_NTSL                  (-3L)

/* maximum message length */
#define SQL_MAX_MESSAGE_LENGTH   512

/* date/time length constants */
#if (ODBCVER >= 0x0300)
#define SQL_DATE_LEN           10
#define SQL_TIME_LEN            8  /* add P+1 if precision is nonzero */
#define SQL_TIMESTAMP_LEN      19  /* add P+1 if precision is nonzero */
#endif

/* handle type identifiers */
#if (ODBCVER >= 0x0300)
#define SQL_HANDLE_ENV             1
#define SQL_HANDLE_DBC             2
#define SQL_HANDLE_STMT            3
#define SQL_HANDLE_DESC            4
#endif

/* environment attribute */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_OUTPUT_NTS    10001
#endif

/* connection attributes */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_AUTO_IPD      10001
#define SQL_ATTR_METADATA_ID   10014
#endif  /* ODBCVER >= 0x0300 */

/* statement attributes */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_APP_ROW_DESC       10010
#define SQL_ATTR_APP_PARAM_DESC     10011
#define SQL_ATTR_IMP_ROW_DESC       10012
#define SQL_ATTR_IMP_PARAM_DESC     10013
#define SQL_ATTR_CURSOR_SCROLLABLE  (-1)
#define SQL_ATTR_CURSOR_SENSITIVITY (-2)
#endif

/* SQL_ATTR_CURSOR_SCROLLABLE values */
#if (ODBCVER >= 0x0300)
#define SQL_NONSCROLLABLE			0
#define SQL_SCROLLABLE				1
#endif  /* ODBCVER >= 0x0300 */

/* identifiers of fields in the SQL descriptor */
#if (ODBCVER >= 0x0300)
#define SQL_DESC_COUNT                  1001
#define SQL_DESC_TYPE                   1002
#define SQL_DESC_LENGTH                 1003
#define SQL_DESC_OCTET_LENGTH_PTR       1004
#define SQL_DESC_PRECISION              1005
#define SQL_DESC_SCALE                  1006
#define SQL_DESC_DATETIME_INTERVAL_CODE 1007
#define SQL_DESC_NULLABLE               1008
#define SQL_DESC_INDICATOR_PTR          1009
#define SQL_DESC_DATA_PTR               1010
#define SQL_DESC_NAME                   1011
#define SQL_DESC_UNNAMED                1012
#define SQL_DESC_OCTET_LENGTH           1013
#define SQL_DESC_ALLOC_TYPE             1099
#endif

/* identifiers of fields in the diagnostics area */
#if (ODBCVER >= 0x0300)
#define SQL_DIAG_RETURNCODE        1
#define SQL_DIAG_NUMBER            2
#define SQL_DIAG_ROW_COUNT         3
#define SQL_DIAG_SQLSTATE          4
#define SQL_DIAG_NATIVE            5
#define SQL_DIAG_MESSAGE_TEXT      6
#define SQL_DIAG_DYNAMIC_FUNCTION  7
#define SQL_DIAG_CLASS_ORIGIN      8
#define SQL_DIAG_SUBCLASS_ORIGIN   9
#define SQL_DIAG_CONNECTION_NAME  10
#define SQL_DIAG_SERVER_NAME      11
#define SQL_DIAG_DYNAMIC_FUNCTION_CODE 12
#endif

/* dynamic function codes */
#if (ODBCVER >= 0x0300)
#define SQL_DIAG_ALTER_DOMAIN			3
#define SQL_DIAG_ALTER_TABLE            4
#define SQL_DIAG_CALL					7
#define SQL_DIAG_CREATE_ASSERTION		6
#define SQL_DIAG_CREATE_CHARACTER_SET	8
#define SQL_DIAG_CREATE_COLLATION		10
#define SQL_DIAG_CREATE_DOMAIN			23
#define SQL_DIAG_CREATE_INDEX          (-1)
#define SQL_DIAG_CREATE_SCHEMA			64
#define SQL_DIAG_CREATE_TABLE          77
#define SQL_DIAG_CREATE_TRANSLATION		79
#define SQL_DIAG_CREATE_VIEW           84
#define SQL_DIAG_DELETE_WHERE          19
#define	SQL_DIAG_DROP_ASSERTION			24
#define	SQL_DIAG_DROP_CHARACTER_SET		25
#define	SQL_DIAG_DROP_COLLATION			26
#define	SQL_DIAG_DROP_DOMAIN			27
#define SQL_DIAG_DROP_INDEX            (-2)
#define SQL_DIAG_DROP_SCHEMA			31
#define SQL_DIAG_DROP_TABLE            32
#define SQL_DIAG_DROP_TRANSLATION      33
#define SQL_DIAG_DROP_VIEW             36
#define SQL_DIAG_DYNAMIC_DELETE_CURSOR 38
#define SQL_DIAG_DYNAMIC_UPDATE_CURSOR 81
#define SQL_DIAG_GRANT                 48
#define SQL_DIAG_INSERT                50
#define SQL_DIAG_REVOKE                59
#define SQL_DIAG_SELECT_CURSOR         85
#define SQL_DIAG_UNKNOWN_STATEMENT      0
#define SQL_DIAG_UPDATE_WHERE          82
#endif  /* ODBCVER >= 0x0300 */

/* SQL data type codes */
#define	SQL_UNKNOWN_TYPE	0
#define SQL_CHAR            1
#define SQL_NUMERIC         2
#define SQL_DECIMAL         3
#define SQL_INTEGER         4
#define SQL_SMALLINT        5
#define SQL_FLOAT           6
#define SQL_REAL            7
#define SQL_DOUBLE          8
#if (ODBCVER >= 0x0300)
#define SQL_DATETIME        9
#endif
#define SQL_VARCHAR        12

/* One-parameter shortcuts for date/time data types */
#if (ODBCVER >= 0x0300)
#define SQL_TYPE_DATE      91
#define SQL_TYPE_TIME      92
#define SQL_TYPE_TIMESTAMP 93
#endif

/* Statement attribute values for cursor sensitivity */
#if (ODBCVER >= 0x0300)
#define SQL_UNSPECIFIED     0
#define SQL_INSENSITIVE     1
#define SQL_SENSITIVE       2
#endif

/* GetTypeInfo() request for all data types */
#define SQL_ALL_TYPES       0

/* Default conversion code for SQLBindCol(), SQLBindParam() and SQLGetData() */
#if (ODBCVER >= 0x0300)
#define SQL_DEFAULT        99
#endif

/* SQLSQLLEN GetData() code indicating that the application row descriptor
 * specifies the data type
 */
#if (ODBCVER >= 0x0300)
#define SQL_ARD_TYPE      (-99)
#endif

/* SQL date/time type subcodes */
#if (ODBCVER >= 0x0300)
#define SQL_CODE_DATE       1
#define SQL_CODE_TIME       2
#define SQL_CODE_TIMESTAMP  3
#endif

/* CLI option values */
#if (ODBCVER >= 0x0300)
#define SQL_FALSE           0
#define SQL_TRUE            1
#endif

/* values of NULLABLE field in descriptor */
#define SQL_NO_NULLS        0
#define SQL_NULLABLE        1

/* Value returned by SQLGetTypeInfo() to denote that it is
 * not known whether or not a data type supports null values.
 */
#define SQL_NULLABLE_UNKNOWN  2

/* Values returned by SQLGetTypeInfo() to show WHERE clause
 * supported
 */
#if (ODBCVER >= 0x0300)
#define SQL_PRED_NONE     0
#define SQL_PRED_CHAR     1
#define SQL_PRED_BASIC    2
#endif

/* values of UNNAMED field in descriptor */
#if (ODBCVER >= 0x0300)
#define SQL_NAMED           0
#define SQL_UNNAMED         1
#endif

/* values of ALLOC_TYPE field in descriptor */
#if (ODBCVER >= 0x0300)
#define SQL_DESC_ALLOC_AUTO 1
#define SQL_DESC_ALLOC_USER 2
#endif

/* FreeStmt() options */
#define SQL_CLOSE           0
#define SQL_DROP            1
#define SQL_UNBIND          2
#define SQL_RESET_PARAMS    3

/* Codes used for FetchOrientation in SQLFetchScroll(), 
   and in SQLDataSources() 
*/
#define SQL_FETCH_NEXT      1
#define SQL_FETCH_FIRST     2

/* Other codes used for FetchOrientation in SQLFetchScroll() */
#define SQL_FETCH_LAST      3
#define SQL_FETCH_PRIOR     4
#define SQL_FETCH_ABSOLUTE  5
#define SQL_FETCH_RELATIVE  6

/* SQLEndTran() options */
#define SQL_COMMIT          0
#define SQL_ROLLBACK        1

/* null handles returned by SQLAllocHandle() */
#define SQL_NULL_HENV       0
#define SQL_NULL_HDBC       0
#define SQL_NULL_HSTMT      0
#if (ODBCVER >= 0x0300)
#define SQL_NULL_HDESC      0
#endif

/* null handle used in place of parent handle when allocating HENV */
#if (ODBCVER >= 0x0300)
#define SQL_NULL_HANDLE     0L
#endif

/* Values that may appear in the result set of SQLSpecialColumns() */
#define SQL_SCOPE_CURROW    0
#define SQL_SCOPE_TRANSACTION 1
#define SQL_SCOPE_SESSION   2

#define SQL_PC_UNKNOWN      0
#if (ODBCVER >= 0x0300)
#define SQL_PC_NON_PSEUDO   1
#endif
#define SQL_PC_PSEUDO       2

/* Reserved value for the IdentifierType argument of SQLSpecialColumns() */
#if (ODBCVER >= 0x0300)
#define SQL_ROW_IDENTIFIER  1
#endif

/* Reserved values for UNIQUE argument of SQLStatistics() */
#define SQL_INDEX_UNIQUE    0
#define SQL_INDEX_ALL       1

/* Values that may appear in the result set of SQLStatistics() */
#define SQL_INDEX_CLUSTERED 1
#define SQL_INDEX_HASHED    2
#define SQL_INDEX_OTHER     3

/* SQLGetFunctions() values to identify ODBC APIs */
#define SQL_API_SQLALLOCCONNECT         1
#define SQL_API_SQLALLOCENV             2
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLALLOCHANDLE       1001
#endif
#define SQL_API_SQLALLOCSTMT            3
#define SQL_API_SQLBINDCOL              4
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLBINDPARAM         1002
#endif
#define SQL_API_SQLCANCEL               5
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLCLOSECURSOR       1003
#define SQL_API_SQLCOLATTRIBUTE         6
#endif
#define SQL_API_SQLCOLUMNS             40
#define SQL_API_SQLCONNECT              7
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLCOPYDESC          1004
#endif
#define SQL_API_SQLDATASOURCES         57
#define SQL_API_SQLDESCRIBECOL          8
#define SQL_API_SQLDISCONNECT           9
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLENDTRAN           1005
#endif
#define SQL_API_SQLERROR               10
#define SQL_API_SQLEXECDIRECT          11
#define SQL_API_SQLEXECUTE             12
#define SQL_API_SQLFETCH               13
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLFETCHSCROLL       1021
#endif
#define SQL_API_SQLFREECONNECT         14
#define SQL_API_SQLFREEENV             15
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLFREEHANDLE        1006
#endif
#define SQL_API_SQLFREESTMT            16
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLGETCONNECTATTR    1007
#endif
#define SQL_API_SQLGETCONNECTOPTION    42
#define SQL_API_SQLGETCURSORNAME       17
#define SQL_API_SQLGETDATA             43
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLGETDESCFIELD      1008
#define SQL_API_SQLGETDESCREC        1009
#define SQL_API_SQLGETDIAGFIELD      1010
#define SQL_API_SQLGETDIAGREC        1011
#define SQL_API_SQLGETENVATTR        1012
#endif
#define SQL_API_SQLGETFUNCTIONS        44
#define SQL_API_SQLGETINFO             45
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLGETSTMTATTR       1014
#endif
#define SQL_API_SQLGETSTMTOPTION       46
#define SQL_API_SQLGETTYPEINFO         47
#define SQL_API_SQLNUMRESULTCOLS       18
#define SQL_API_SQLPARAMDATA           48
#define SQL_API_SQLPREPARE             19
#define SQL_API_SQLPUTDATA             49
#define SQL_API_SQLROWCOUNT            20
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLSETCONNECTATTR    1016
#endif
#define SQL_API_SQLSETCONNECTOPTION    50
#define SQL_API_SQLSETCURSORNAME       21
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLSETDESCFIELD      1017
#define SQL_API_SQLSETDESCREC        1018
#define SQL_API_SQLSETENVATTR        1019
#endif
#define SQL_API_SQLSETPARAM            22
#if (ODBCVER >= 0x0300)
#define SQL_API_SQLSETSTMTATTR       1020
#endif
#define SQL_API_SQLSETSTMTOPTION       51
#define SQL_API_SQLSPECIALCOLUMNS      52
#define SQL_API_SQLSTATISTICS          53
#define SQL_API_SQLTABLES              54
#define SQL_API_SQLTRANSACT            23

/* Information requested by SQLGetInfo() */
#if (ODBCVER >= 0x0300)
#define SQL_MAX_DRIVER_CONNECTIONS           0
#define SQL_MAXIMUM_DRIVER_CONNECTIONS		SQL_MAX_DRIVER_CONNECTIONS
#define SQL_MAX_CONCURRENT_ACTIVITIES        1
#define SQL_MAXIMUM_CONCURRENT_ACTIVITIES	SQL_MAX_CONCURRENT_ACTIVITIES
#endif
#define SQL_DATA_SOURCE_NAME                 2
#define SQL_FETCH_DIRECTION                  8
#define SQL_SERVER_NAME                     13
#define SQL_SEARCH_PATTERN_ESCAPE           14
#define SQL_DBMS_NAME                       17
#define SQL_DBMS_VER                        18
#define SQL_ACCESSIBLE_TABLES               19
#define SQL_ACCESSIBLE_PROCEDURES        	20
#define SQL_CURSOR_COMMIT_BEHAVIOR          23
#define SQL_DATA_SOURCE_READ_ONLY           25
#define SQL_DEFAULT_TXN_ISOLATION           26
#define SQL_IDENTIFIER_CASE                 28
#define SQL_IDENTIFIER_QUOTE_CHAR           29
#define SQL_MAX_COLUMN_NAME_LEN             30
#define SQL_MAXIMUM_COLUMN_NAME_LENGTH		SQL_MAX_COLUMN_NAME_LEN
#define SQL_MAX_CURSOR_NAME_LEN             31
#define SQL_MAXIMUM_CURSOR_NAME_LENGTH		SQL_MAX_CURSOR_NAME_LEN
#define SQL_MAX_SCHEMA_NAME_LEN             32
#define SQL_MAXIMUM_SCHEMA_NAME_LENGTH		SQL_MAX_SCHEMA_NAME_LEN
#define SQL_MAX_CATALOG_NAME_LEN            34
#define SQL_MAXIMUM_CATALOG_NAME_LENGTH		SQL_MAX_CATALOG_NAME_LEN
#define SQL_MAX_TABLE_NAME_LEN              35
#define SQL_SCROLL_CONCURRENCY              43
#define SQL_TXN_CAPABLE                     46
#define SQL_TRANSACTION_CAPABLE				SQL_TXN_CAPABLE
#define SQL_USER_NAME                       47
#define SQL_TXN_ISOLATION_OPTION            72
#define SQL_TRANSACTION_ISOLATION_OPTION	SQL_TXN_ISOLATION_OPTION
#define SQL_INTEGRITY                       73
#define SQL_GETDATA_EXTENSIONS              81
#define SQL_NULL_COLLATION                  85
#define SQL_ALTER_TABLE                     86
#define SQL_ORDER_BY_COLUMNS_IN_SELECT      90
#define SQL_SPECIAL_CHARACTERS              94
#define SQL_MAX_COLUMNS_IN_GROUP_BY         97
#define SQL_MAXIMUM_COLUMNS_IN_GROUP_BY		SQL_MAX_COLUMNS_IN_GROUP_BY
#define SQL_MAX_COLUMNS_IN_INDEX            98
#define SQL_MAXIMUM_COLUMNS_IN_INDEX		SQL_MAX_COLUMNS_IN_INDEX
#define SQL_MAX_COLUMNS_IN_ORDER_BY         99
#define SQL_MAXIMUM_COLUMNS_IN_ORDER_BY		SQL_MAX_COLUMNS_IN_ORDER_BY
#define SQL_MAX_COLUMNS_IN_SELECT          100
#define SQL_MAXIMUM_COLUMNS_IN_SELECT	   SQL_MAX_COLUMNS_IN_SELECT
#define SQL_MAX_COLUMNS_IN_TABLE           101
#define SQL_MAX_INDEX_SIZE                 102
#define SQL_MAXIMUM_INDEX_SIZE			   SQL_MAX_INDEX_SIZE
#define SQL_MAX_ROW_SIZE                   104
#define SQL_MAXIMUM_ROW_SIZE			   SQL_MAX_ROW_SIZE
#define SQL_MAX_STATEMENT_LEN              105
#define SQL_MAXIMUM_STATEMENT_LENGTH	   SQL_MAX_STATEMENT_LEN
#define SQL_MAX_TABLES_IN_SELECT           106
#define SQL_MAXIMUM_TABLES_IN_SELECT	   SQL_MAX_TABLES_IN_SELECT
#define SQL_MAX_USER_NAME_LEN              107
#define SQL_MAXIMUM_USER_NAME_LENGTH	   SQL_MAX_USER_NAME_LEN
#if (ODBCVER >= 0x0300)
#define SQL_OJ_CAPABILITIES                115
#define SQL_OUTER_JOIN_CAPABILITIES		   SQL_OJ_CAPABILITIES
#endif /* ODBCVER >= 0x0300 */

#if (ODBCVER >= 0x0300)
#define SQL_XOPEN_CLI_YEAR               10000
#define SQL_CURSOR_SENSITIVITY           10001
#define SQL_DESCRIBE_PARAMETER           10002
#define SQL_CATALOG_NAME                 10003
#define SQL_COLLATION_SEQ                10004
#define SQL_MAX_IDENTIFIER_LEN           10005
#define SQL_MAXIMUM_IDENTIFIER_LENGTH	 SQL_MAX_IDENTIFIER_LEN
#endif /* ODBCVER >= 0x0300 */

/* SQL_ALTER_TABLE bitmasks */
#if (ODBCVER >= 0x0200)
#define SQL_AT_ADD_COLUMN                   	0x00000001L
#define SQL_AT_DROP_COLUMN                  	0x00000002L
#endif /* ODBCVER >= 0x0200 */

#if (ODBCVER >= 0x0300)
#define SQL_AT_ADD_CONSTRAINT               	0x00000008L

/* The following bitmasks are ODBC extensions and defined in sqlext.h
*#define	SQL_AT_COLUMN_SINGLE					0x00000020L	
*#define	SQL_AT_ADD_COLUMN_DEFAULT				0x00000040L
*#define	SQL_AT_ADD_COLUMN_COLLATION				0x00000080L
*#define	SQL_AT_SET_COLUMN_DEFAULT				0x00000100L
*#define	SQL_AT_DROP_COLUMN_DEFAULT				0x00000200L
*#define	SQL_AT_DROP_COLUMN_CASCADE				0x00000400L
*#define	SQL_AT_DROP_COLUMN_RESTRICT				0x00000800L
*#define SQL_AT_ADD_TABLE_CONSTRAINT				0x00001000L		
*#define SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE		0x00002000L		
*#define SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT		0x00004000L		
*#define SQL_AT_CONSTRAINT_NAME_DEFINITION			0x00008000L
*#define SQL_AT_CONSTRAINT_INITIALLY_DEFERRED		0x00010000L
*#define SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE		0x00020000L
*#define SQL_AT_CONSTRAINT_DEFERRABLE				0x00040000L
*#define SQL_AT_CONSTRAINT_NON_DEFERRABLE			0x00080000L
*/
#endif  /* ODBCVER >= 0x0300 */


/* SQL_ASYNC_MODE values */
#if (ODBCVER >= 0x0300)
#define SQL_AM_NONE                         0
#define SQL_AM_CONNECTION                   1
#define SQL_AM_STATEMENT                    2
#endif

/* SQL_CURSOR_COMMIT_BEHAVIOR values */
#define SQL_CB_DELETE                       0
#define SQL_CB_CLOSE                        1
#define SQL_CB_PRESERVE                     2

/* SQL_FETCH_DIRECTION bitmasks */
#define SQL_FD_FETCH_NEXT                   0x00000001L
#define SQL_FD_FETCH_FIRST                  0x00000002L
#define SQL_FD_FETCH_LAST                   0x00000004L
#define SQL_FD_FETCH_PRIOR                  0x00000008L
#define SQL_FD_FETCH_ABSOLUTE               0x00000010L
#define SQL_FD_FETCH_RELATIVE               0x00000020L

/* SQL_GETDATA_EXTENSIONS bitmasks */
#define SQL_GD_ANY_COLUMN                   0x00000001L
#define SQL_GD_ANY_ORDER                    0x00000002L

/* SQL_IDENTIFIER_CASE values */
#define SQL_IC_UPPER                        1
#define SQL_IC_LOWER                        2
#define SQL_IC_SENSITIVE                    3
#define SQL_IC_MIXED                        4

/* SQL_OJ_CAPABILITIES bitmasks */
/* NB: this means 'outer join', not what  you may be thinking */


#if (ODBCVER >= 0x0201)
#define SQL_OJ_LEFT                         0x00000001L
#define SQL_OJ_RIGHT                        0x00000002L
#define SQL_OJ_FULL                         0x00000004L
#define SQL_OJ_NESTED                       0x00000008L
#define SQL_OJ_NOT_ORDERED                  0x00000010L
#define SQL_OJ_INNER                        0x00000020L
#define SQL_OJ_ALL_COMPARISON_OPS           0x00000040L
#endif

/* SQL_SCROLL_CONCURRENCY bitmasks */
#define SQL_SCCO_READ_ONLY                  0x00000001L
#define SQL_SCCO_LOCK                       0x00000002L
#define SQL_SCCO_OPT_ROWVER                 0x00000004L
#define SQL_SCCO_OPT_VALUES                 0x00000008L

/* SQL_TXN_CAPABLE values */
#define SQL_TC_NONE                         0
#define SQL_TC_DML                          1
#define SQL_TC_ALL                          2
#define SQL_TC_DDL_COMMIT                   3
#define SQL_TC_DDL_IGNORE                   4

/* SQL_TXN_ISOLATION_OPTION bitmasks */
#define SQL_TXN_READ_UNCOMMITTED            0x00000001L
#define SQL_TRANSACTION_READ_UNCOMMITTED	SQL_TXN_READ_UNCOMMITTED
#define SQL_TXN_READ_COMMITTED              0x00000002L
#define SQL_TRANSACTION_READ_COMMITTED		SQL_TXN_READ_COMMITTED
#define SQL_TXN_REPEATABLE_READ             0x00000004L
#define SQL_TRANSACTION_REPEATABLE_READ		SQL_TXN_REPEATABLE_READ
#define SQL_TXN_SERIALIZABLE                0x00000008L
#define SQL_TRANSACTION_SERIALIZABLE		SQL_TXN_SERIALIZABLE

/* SQL_NULL_COLLATION values */
#define SQL_NC_HIGH                         0
#define SQL_NC_LOW                          1

#ifndef RC_INVOKED

SQLRETURN  SQL_API SQLAllocConnect(SQLHENV EnvironmentHandle,
           SQLHDBC *ConnectionHandle)

{return 0;}

SQLRETURN  SQL_API SQLAllocEnv(SQLHENV *EnvironmentHandle)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLAllocHandle(SQLSMALLINT HandleType,
           SQLHANDLE InputHandle, SQLHANDLE *OutputHandle)

{return 0;}

#endif

SQLRETURN  SQL_API SQLAllocStmt(SQLHDBC ConnectionHandle,
           SQLHSTMT *StatementHandle)

{return 0;}

SQLRETURN  SQL_API SQLBindCol(SQLHSTMT StatementHandle, 
		   SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType, 
		   SQLPOINTER TargetValue, SQLLEN BufferLength, 
	   	   SQLLEN *StrLen_or_Ind)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLBindParam(SQLHSTMT StatementHandle,
           SQLUSMALLINT ParameterNumber, SQLSMALLINT ValueType,
           SQLSMALLINT ParameterType, SQLULEN LengthPrecision,
           SQLSMALLINT ParameterScale, SQLPOINTER ParameterValue,
           SQLLEN *StrLen_or_Ind)

{return 0;}

#endif

SQLRETURN  SQL_API SQLCancel(SQLHSTMT StatementHandle)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLCloseCursor(SQLHSTMT StatementHandle)

{return 0;}

SQLRETURN  SQL_API SQLColAttribute (SQLHSTMT StatementHandle,
           SQLUSMALLINT ColumnNumber, SQLUSMALLINT FieldIdentifier,
           SQLPOINTER CharacterAttribute, SQLSMALLINT BufferLength,
           SQLSMALLINT *StringLength, SQLPOINTER NumericAttribute)

{return 0;}

#endif

SQLRETURN  SQL_API SQLColumns(SQLHSTMT StatementHandle,
           SQLCHAR *CatalogName, SQLSMALLINT NameLength1,
           SQLCHAR *SchemaName, SQLSMALLINT NameLength2,
           SQLCHAR *TableName, SQLSMALLINT NameLength3,
           SQLCHAR *ColumnName, SQLSMALLINT NameLength4)

{return 0;}

SQLRETURN  SQL_API SQLConnect(SQLHDBC ConnectionHandle,
           SQLCHAR *ServerName, SQLSMALLINT NameLength1,
           SQLCHAR *UserName, SQLSMALLINT NameLength2,
           SQLCHAR *Authentication, SQLSMALLINT NameLength3)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLCopyDesc(SQLHDESC SourceDescHandle,
           SQLHDESC TargetDescHandle)

{return 0;}

#endif

SQLRETURN  SQL_API SQLDataSources(SQLHENV EnvironmentHandle,
           SQLUSMALLINT Direction, SQLCHAR *ServerName,
           SQLSMALLINT BufferLength1, SQLSMALLINT *NameLength1,
           SQLCHAR *Description, SQLSMALLINT BufferLength2,
           SQLSMALLINT *NameLength2)

{return 0;}

SQLRETURN  SQL_API SQLDescribeCol(SQLHSTMT StatementHandle,
           SQLUSMALLINT ColumnNumber, SQLCHAR *ColumnName,
           SQLSMALLINT BufferLength, SQLSMALLINT *NameLength,
           SQLSMALLINT *DataType, SQLULEN *ColumnSize,
           SQLSMALLINT *DecimalDigits, SQLSMALLINT *Nullable)

{return 0;}

SQLRETURN  SQL_API SQLDisconnect(SQLHDBC ConnectionHandle)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLEndTran(SQLSMALLINT HandleType, SQLHANDLE Handle,
           SQLSMALLINT CompletionType)

{return 0;}
#endif

SQLRETURN  SQL_API SQLError(SQLHENV EnvironmentHandle,
           SQLHDBC ConnectionHandle, SQLHSTMT StatementHandle,
           SQLCHAR *Sqlstate, SQLINTEGER *NativeError,
           SQLCHAR *MessageText, SQLSMALLINT BufferLength,
           SQLSMALLINT *TextLength)

{return 0;}

SQLRETURN  SQL_API SQLExecDirect(SQLHSTMT StatementHandle,
           SQLCHAR *StatementText, SQLINTEGER TextLength)

{return 0;}

SQLRETURN  SQL_API SQLExecute(SQLHSTMT StatementHandle)

{return 0;}

SQLRETURN  SQL_API SQLFetch(SQLHSTMT StatementHandle)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLFetchScroll(SQLHSTMT StatementHandle,
           SQLSMALLINT FetchOrientation, SQLROWOFFSET FetchOffset)

{return 0;}
#endif

SQLRETURN  SQL_API SQLFreeConnect(SQLHDBC ConnectionHandle)

{return 0;}

SQLRETURN  SQL_API SQLFreeEnv(SQLHENV EnvironmentHandle)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLFreeHandle(SQLSMALLINT HandleType, SQLHANDLE Handle)

{return 0;}
#endif

SQLRETURN  SQL_API SQLFreeStmt(SQLHSTMT StatementHandle,
           SQLUSMALLINT Option)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLGetConnectAttr(SQLHDBC ConnectionHandle,
           SQLINTEGER Attribute, SQLPOINTER Value,
           SQLINTEGER BufferLength, SQLINTEGER *StringLength)

{return 0;}
#endif

SQLRETURN  SQL_API SQLGetConnectOption(SQLHDBC ConnectionHandle,
           SQLUSMALLINT Option, SQLPOINTER Value)

{return 0;}

SQLRETURN  SQL_API SQLGetCursorName(SQLHSTMT StatementHandle,
           SQLCHAR *CursorName, SQLSMALLINT BufferLength,
           SQLSMALLINT *NameLength)

{return 0;}

SQLRETURN  SQL_API SQLGetData(SQLHSTMT StatementHandle,
           SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType,
           SQLPOINTER TargetValue, SQLLEN BufferLength,
           SQLLEN *StrLen_or_Ind)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLGetDescField(SQLHDESC DescriptorHandle,
           SQLSMALLINT RecNumber, SQLSMALLINT FieldIdentifier,
           SQLPOINTER Value, SQLINTEGER BufferLength,
           SQLINTEGER *StringLength)

{return 0;}

SQLRETURN  SQL_API SQLGetDescRec(SQLHDESC DescriptorHandle,
           SQLSMALLINT RecNumber, SQLCHAR *Name,
           SQLSMALLINT BufferLength, SQLSMALLINT *StringLength,
           SQLSMALLINT *Type, SQLSMALLINT *SubType, 
           SQLLEN     *Length, SQLSMALLINT *Precision, 
           SQLSMALLINT *Scale, SQLSMALLINT *Nullable)

{return 0;}

SQLRETURN  SQL_API SQLGetDiagField(SQLSMALLINT HandleType, SQLHANDLE Handle,
           SQLSMALLINT RecNumber, SQLSMALLINT DiagIdentifier,
           SQLPOINTER DiagInfo, SQLSMALLINT BufferLength,
           SQLSMALLINT *StringLength)

{return 0;}

SQLRETURN  SQL_API SQLGetDiagRec(SQLSMALLINT HandleType, SQLHANDLE Handle,
           SQLSMALLINT RecNumber, SQLCHAR *Sqlstate,
           SQLINTEGER *NativeError, SQLCHAR *MessageText,
           SQLSMALLINT BufferLength, SQLSMALLINT *TextLength)

{return 0;}

SQLRETURN  SQL_API SQLGetEnvAttr(SQLHENV EnvironmentHandle,
           SQLINTEGER Attribute, SQLPOINTER Value,
           SQLINTEGER BufferLength, SQLINTEGER *StringLength)

{return 0;}
#endif  /* ODBCVER >= 0x0300 */

SQLRETURN  SQL_API SQLGetFunctions(SQLHDBC ConnectionHandle,
           SQLUSMALLINT FunctionId, SQLUSMALLINT *Supported)

{return 0;}

SQLRETURN  SQL_API SQLGetInfo(SQLHDBC ConnectionHandle,
           SQLUSMALLINT InfoType, SQLPOINTER InfoValue,
           SQLSMALLINT BufferLength, SQLSMALLINT *StringLength)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLGetStmtAttr(SQLHSTMT StatementHandle,
           SQLINTEGER Attribute, SQLPOINTER Value,
           SQLINTEGER BufferLength, SQLINTEGER *StringLength)

{return 0;}
#endif  /* ODBCVER >= 0x0300 */

SQLRETURN  SQL_API SQLGetStmtOption(SQLHSTMT StatementHandle,
           SQLUSMALLINT Option, SQLPOINTER Value)

{return 0;}

SQLRETURN  SQL_API SQLGetTypeInfo(SQLHSTMT StatementHandle,
           SQLSMALLINT DataType)

{return 0;}

SQLRETURN  SQL_API SQLNumResultCols(SQLHSTMT StatementHandle,
           SQLSMALLINT *ColumnCount)

{return 0;}

SQLRETURN  SQL_API SQLParamData(SQLHSTMT StatementHandle,
           SQLPOINTER *Value)

{return 0;}

SQLRETURN  SQL_API SQLPrepare(SQLHSTMT StatementHandle,
           SQLCHAR *StatementText, SQLINTEGER TextLength)

{return 0;}

SQLRETURN  SQL_API SQLPutData(SQLHSTMT StatementHandle,
           SQLPOINTER Data, SQLLEN StrLen_or_Ind)

{return 0;}

SQLRETURN  SQL_API SQLRowCount(SQLHSTMT StatementHandle, 
	   SQLLEN* RowCount)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLSetConnectAttr(SQLHDBC ConnectionHandle,
           SQLINTEGER Attribute, SQLPOINTER Value,
           SQLINTEGER StringLength)

{return 0;}
#endif /* ODBCVER >= 0x0300 */

SQLRETURN  SQL_API SQLSetConnectOption(SQLHDBC ConnectionHandle,
           SQLUSMALLINT Option, SQLULEN Value)

{return 0;}

SQLRETURN  SQL_API SQLSetCursorName(SQLHSTMT StatementHandle,
           SQLCHAR *CursorName, SQLSMALLINT NameLength)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLSetDescField(SQLHDESC DescriptorHandle,
           SQLSMALLINT RecNumber, SQLSMALLINT FieldIdentifier,
           SQLPOINTER Value, SQLINTEGER BufferLength)

{return 0;}

SQLRETURN  SQL_API SQLSetDescRec(SQLHDESC DescriptorHandle,
           SQLSMALLINT RecNumber, SQLSMALLINT Type,
           SQLSMALLINT SubType, SQLLEN Length,
           SQLSMALLINT Precision, SQLSMALLINT Scale,
           SQLPOINTER Data, SQLLEN *StringLength,
           SQLLEN *Indicator)

{return 0;}

SQLRETURN  SQL_API SQLSetEnvAttr(SQLHENV EnvironmentHandle,
           SQLINTEGER Attribute, SQLPOINTER Value,
           SQLINTEGER StringLength)

{return 0;}
#endif /* ODBCVER >= 0x0300 */

SQLRETURN  SQL_API SQLSetParam(SQLHSTMT StatementHandle,
           SQLUSMALLINT ParameterNumber, SQLSMALLINT ValueType,
           SQLSMALLINT ParameterType, SQLULEN LengthPrecision,
           SQLSMALLINT ParameterScale, SQLPOINTER ParameterValue,
           SQLLEN *StrLen_or_Ind)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN  SQL_API SQLSetStmtAttr(SQLHSTMT StatementHandle,
           SQLINTEGER Attribute, SQLPOINTER Value,
           SQLINTEGER StringLength)

{return 0;}
#endif

SQLRETURN  SQL_API SQLSetStmtOption(SQLHSTMT StatementHandle,
           SQLUSMALLINT Option, SQLROWCOUNT Value)

{return 0;}

SQLRETURN  SQL_API SQLSpecialColumns(SQLHSTMT StatementHandle,
           SQLUSMALLINT IdentifierType, SQLCHAR *CatalogName,
           SQLSMALLINT NameLength1, SQLCHAR *SchemaName,
           SQLSMALLINT NameLength2, SQLCHAR *TableName,
           SQLSMALLINT NameLength3, SQLUSMALLINT Scope,
           SQLUSMALLINT Nullable)

{return 0;}

SQLRETURN  SQL_API SQLStatistics(SQLHSTMT StatementHandle,
           SQLCHAR *CatalogName, SQLSMALLINT NameLength1,
           SQLCHAR *SchemaName, SQLSMALLINT NameLength2,
           SQLCHAR *TableName, SQLSMALLINT NameLength3,
           SQLUSMALLINT Unique, SQLUSMALLINT Reserved)

{return 0;}

SQLRETURN  SQL_API SQLTables(SQLHSTMT StatementHandle,
           SQLCHAR *CatalogName, SQLSMALLINT NameLength1,
           SQLCHAR *SchemaName, SQLSMALLINT NameLength2,
           SQLCHAR *TableName, SQLSMALLINT NameLength3,
           SQLCHAR *TableType, SQLSMALLINT NameLength4)

{return 0;}

SQLRETURN  SQL_API SQLTransact(SQLHENV EnvironmentHandle,
           SQLHDBC ConnectionHandle, SQLUSMALLINT CompletionType)

{return 0;}

#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                                    /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\odbc32\sqlext.cpp ===
#include "windows.h"

#ifndef __SQL
#include "sql.h"
#endif

#ifdef __cplusplus
extern "C" {                         /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/* generally useful constants */
#define SQL_SPEC_MAJOR     3     	/* Major version of specification  */
#define SQL_SPEC_MINOR	   52     	/* Minor version of specification  */
#define SQL_SPEC_STRING   "03.52"	/* String constant for version */

#define SQL_SQLSTATE_SIZE	5	/* size of SQLSTATE */
#define SQL_MAX_DSN_LENGTH	32	/* maximum data source name size */

#define SQL_MAX_OPTION_STRING_LENGTH    256

/* return code SQL_NO_DATA_FOUND is the same as SQL_NO_DATA */
#if (ODBCVER < 0x0300)
#define SQL_NO_DATA_FOUND	100
#else
#define SQL_NO_DATA_FOUND	SQL_NO_DATA
#endif

/* an end handle type */
#if (ODBCVER >= 0x0300)
#define	SQL_HANDLE_SENV		5
#endif  /* ODBCVER >= 0x0300 */

/* env attribute */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_ODBC_VERSION				200
#define SQL_ATTR_CONNECTION_POOLING			201
#define SQL_ATTR_CP_MATCH					202
#endif  /* ODBCVER >= 0x0300 */

#if (ODBCVER >= 0x0300)
/* values for SQL_ATTR_CONNECTION_POOLING */
#define SQL_CP_OFF							0UL
#define SQL_CP_ONE_PER_DRIVER				1UL
#define SQL_CP_ONE_PER_HENV					2UL
#define SQL_CP_DEFAULT						SQL_CP_OFF

/* values for SQL_ATTR_CP_MATCH */
#define SQL_CP_STRICT_MATCH					0UL
#define SQL_CP_RELAXED_MATCH				1UL
#define SQL_CP_MATCH_DEFAULT				SQL_CP_STRICT_MATCH		

/* values for SQL_ATTR_ODBC_VERSION */
#define SQL_OV_ODBC2						2UL
#define	SQL_OV_ODBC3						3UL
#endif  /* ODBCVER >= 0x0300 */

/* connection attributes */
#define SQL_ACCESS_MODE                 101
#define SQL_AUTOCOMMIT                  102
#define SQL_LOGIN_TIMEOUT               103
#define SQL_OPT_TRACE                   104
#define SQL_OPT_TRACEFILE               105
#define SQL_TRANSLATE_DLL               106
#define SQL_TRANSLATE_OPTION            107
#define SQL_TXN_ISOLATION               108
#define SQL_CURRENT_QUALIFIER           109
#define SQL_ODBC_CURSORS                110
#define SQL_QUIET_MODE                  111
#define SQL_PACKET_SIZE                 112

/* connection attributes with new names */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_ACCESS_MODE		SQL_ACCESS_MODE
#define SQL_ATTR_AUTOCOMMIT			SQL_AUTOCOMMIT
#define SQL_ATTR_CONNECTION_TIMEOUT	113
#define SQL_ATTR_CURRENT_CATALOG	SQL_CURRENT_QUALIFIER
#define SQL_ATTR_DISCONNECT_BEHAVIOR	114
#define SQL_ATTR_ENLIST_IN_DTC		1207
#define SQL_ATTR_ENLIST_IN_XA		1208
#define SQL_ATTR_LOGIN_TIMEOUT		SQL_LOGIN_TIMEOUT
#define SQL_ATTR_ODBC_CURSORS		SQL_ODBC_CURSORS
#define SQL_ATTR_PACKET_SIZE		SQL_PACKET_SIZE
#define SQL_ATTR_QUIET_MODE			SQL_QUIET_MODE
#define SQL_ATTR_TRACE				SQL_OPT_TRACE
#define SQL_ATTR_TRACEFILE			SQL_OPT_TRACEFILE
#define SQL_ATTR_TRANSLATE_LIB		SQL_TRANSLATE_DLL
#define SQL_ATTR_TRANSLATE_OPTION	SQL_TRANSLATE_OPTION
#define SQL_ATTR_TXN_ISOLATION		SQL_TXN_ISOLATION
#endif  /* ODBCVER >= 0x0300 */

#define SQL_ATTR_CONNECTION_DEAD	1209	/* GetConnectAttr only */

#if (ODBCVER >= 0x0351)
/*	ODBC Driver Manager sets this connection attribute to a unicode driver 
	(which supports SQLConnectW) when the application is an ANSI application
	(which calls SQLConnect, SQLDriverConnect, or SQLBrowseConnect). 
	This is SetConnectAttr only and application does not set this attribute
	This attribute was introduced because some unicode driver's some APIs may 
	need to behave differently on ANSI or Unicode applications. A unicode 
	driver, which  has same behavior for both ANSI or Unicode applications,
	should return SQL_ERROR when the driver manager sets this connection 
	attribute. When a unicode driver returns SQL_SUCCESS on this attribute,
	the driver manager treates ANSI and Unicode connections differently in
	connection pooling.
*/
#define SQL_ATTR_ANSI_APP			115
#endif

/* SQL_CONNECT_OPT_DRVR_START is not meaningful for 3.0 driver */
#if (ODBCVER < 0x0300)
#define SQL_CONNECT_OPT_DRVR_START      1000
#endif  /* ODBCVER < 0x0300 */

#if (ODBCVER < 0x0300)
#define SQL_CONN_OPT_MAX                SQL_PACKET_SIZE
#define SQL_CONN_OPT_MIN                SQL_ACCESS_MODE
#endif /* ODBCVER < 0x0300 */

/* SQL_ACCESS_MODE options */
#define SQL_MODE_READ_WRITE             0UL
#define SQL_MODE_READ_ONLY              1UL
#define SQL_MODE_DEFAULT                SQL_MODE_READ_WRITE

/* SQL_AUTOCOMMIT options */
#define SQL_AUTOCOMMIT_OFF              0UL
#define SQL_AUTOCOMMIT_ON               1UL
#define SQL_AUTOCOMMIT_DEFAULT          SQL_AUTOCOMMIT_ON

/* SQL_LOGIN_TIMEOUT options */
#define SQL_LOGIN_TIMEOUT_DEFAULT       15UL

/* SQL_OPT_TRACE options */
#define SQL_OPT_TRACE_OFF               0UL
#define SQL_OPT_TRACE_ON                1UL
#define SQL_OPT_TRACE_DEFAULT           SQL_OPT_TRACE_OFF
#define SQL_OPT_TRACE_FILE_DEFAULT      "\\SQL.LOG"

/* SQL_ODBC_CURSORS options */
#define SQL_CUR_USE_IF_NEEDED           0UL
#define SQL_CUR_USE_ODBC                1UL
#define SQL_CUR_USE_DRIVER              2UL
#define SQL_CUR_DEFAULT                 SQL_CUR_USE_DRIVER

#if (ODBCVER >= 0x0300)
/* values for SQL_ATTR_DISCONNECT_BEHAVIOR */
#define SQL_DB_RETURN_TO_POOL			0UL
#define SQL_DB_DISCONNECT				1UL
#define SQL_DB_DEFAULT					SQL_DB_RETURN_TO_POOL

/* values for SQL_ATTR_ENLIST_IN_DTC */
#define SQL_DTC_DONE					0L
#endif  /* ODBCVER >= 0x0300 */

/* values for SQL_ATTR_CONNECTION_DEAD */
#define SQL_CD_TRUE					1L		/* Connection is closed/dead */
#define SQL_CD_FALSE				0L		/* Connection is open/available */

/* values for SQL_ATTR_ANSI_APP */
#if (ODBCVER >= 0x0351)
#define SQL_AA_TRUE					1L	/* the application is an ANSI app */
#define SQL_AA_FALSE					0L	/* the application is a Unicode app */
#endif

/* statement attributes */
#define SQL_QUERY_TIMEOUT		0
#define SQL_MAX_ROWS			1
#define SQL_NOSCAN				2
#define SQL_MAX_LENGTH			3
#define SQL_ASYNC_ENABLE		4	/* same as SQL_ATTR_ASYNC_ENABLE */	
#define SQL_BIND_TYPE			5
#define SQL_CURSOR_TYPE			6
#define SQL_CONCURRENCY			7
#define SQL_KEYSET_SIZE			8
#define SQL_ROWSET_SIZE			9
#define SQL_SIMULATE_CURSOR		10
#define SQL_RETRIEVE_DATA		11
#define SQL_USE_BOOKMARKS		12
#define SQL_GET_BOOKMARK		13      /*      GetStmtOption Only */
#define SQL_ROW_NUMBER			14      /*      GetStmtOption Only */

/* statement attributes for ODBC 3.0 */
#if (ODBCVER >= 0x0300)
#define SQL_ATTR_ASYNC_ENABLE				4
#define SQL_ATTR_CONCURRENCY				SQL_CONCURRENCY
#define SQL_ATTR_CURSOR_TYPE				SQL_CURSOR_TYPE
#define	SQL_ATTR_ENABLE_AUTO_IPD			15
#define SQL_ATTR_FETCH_BOOKMARK_PTR			16
#define SQL_ATTR_KEYSET_SIZE				SQL_KEYSET_SIZE
#define SQL_ATTR_MAX_LENGTH					SQL_MAX_LENGTH
#define SQL_ATTR_MAX_ROWS					SQL_MAX_ROWS
#define SQL_ATTR_NOSCAN						SQL_NOSCAN
#define SQL_ATTR_PARAM_BIND_OFFSET_PTR		17
#define	SQL_ATTR_PARAM_BIND_TYPE			18
#define SQL_ATTR_PARAM_OPERATION_PTR		19
#define SQL_ATTR_PARAM_STATUS_PTR			20
#define	SQL_ATTR_PARAMS_PROCESSED_PTR		21
#define	SQL_ATTR_PARAMSET_SIZE				22
#define SQL_ATTR_QUERY_TIMEOUT				SQL_QUERY_TIMEOUT
#define SQL_ATTR_RETRIEVE_DATA				SQL_RETRIEVE_DATA
#define SQL_ATTR_ROW_BIND_OFFSET_PTR		23
#define	SQL_ATTR_ROW_BIND_TYPE				SQL_BIND_TYPE
#define SQL_ATTR_ROW_NUMBER					SQL_ROW_NUMBER	  	/*GetStmtAttr*/
#define SQL_ATTR_ROW_OPERATION_PTR			24
#define	SQL_ATTR_ROW_STATUS_PTR				25
#define	SQL_ATTR_ROWS_FETCHED_PTR			26
#define SQL_ATTR_ROW_ARRAY_SIZE				27	
#define SQL_ATTR_SIMULATE_CURSOR			SQL_SIMULATE_CURSOR
#define SQL_ATTR_USE_BOOKMARKS				SQL_USE_BOOKMARKS	

#endif  /* ODBCVER >= 0x0300 */

#if (ODBCVER < 0x0300)
#define SQL_STMT_OPT_MAX                SQL_ROW_NUMBER
#define SQL_STMT_OPT_MIN	SQL_QUERY_TIMEOUT
#endif    	/* ODBCVER < 0x0300 */

/* New defines for SEARCHABLE column in SQLGetTypeInfo */

#if (ODBCVER >= 0x0300)
#define	SQL_COL_PRED_CHAR		SQL_LIKE_ONLY
#define	SQL_COL_PRED_BASIC		SQL_ALL_EXCEPT_LIKE
#endif /* ODBCVER >= 0x0300 */



/* whether an attribute is a pointer or not */
#if (ODBCVER >= 0x0300)
#define SQL_IS_POINTER							(-4)
#define SQL_IS_UINTEGER							(-5)
#define SQL_IS_INTEGER							(-6)
#define SQL_IS_USMALLINT						(-7)
#define SQL_IS_SMALLINT							(-8)
#endif  /* ODBCVER >= 0x0300 */

/* the value of SQL_ATTR_PARAM_BIND_TYPE */
#if (ODBCVER >= 0x0300)
#define SQL_PARAM_BIND_BY_COLUMN			0UL
#define SQL_PARAM_BIND_TYPE_DEFAULT			SQL_PARAM_BIND_BY_COLUMN
#endif  /* ODBCVER >= 0x0300 */

/* SQL_QUERY_TIMEOUT options */
#define SQL_QUERY_TIMEOUT_DEFAULT       0UL

/* SQL_MAX_ROWS options */
#define SQL_MAX_ROWS_DEFAULT            0UL

/* SQL_NOSCAN options */
#define SQL_NOSCAN_OFF                  0UL     /*      1.0 FALSE */
#define SQL_NOSCAN_ON                   1UL     /*      1.0 TRUE */
#define SQL_NOSCAN_DEFAULT              SQL_NOSCAN_OFF

/* SQL_MAX_LENGTH options */
#define SQL_MAX_LENGTH_DEFAULT          0UL

/* values for SQL_ATTR_ASYNC_ENABLE */
#define SQL_ASYNC_ENABLE_OFF			0UL
#define SQL_ASYNC_ENABLE_ON				1UL
#define SQL_ASYNC_ENABLE_DEFAULT        SQL_ASYNC_ENABLE_OFF

/* SQL_BIND_TYPE options */
#define SQL_BIND_BY_COLUMN              0UL
#define SQL_BIND_TYPE_DEFAULT           SQL_BIND_BY_COLUMN  /* Default value */

/* SQL_CONCURRENCY options */
#define SQL_CONCUR_READ_ONLY            1
#define SQL_CONCUR_LOCK                 2
#define SQL_CONCUR_ROWVER               3
#define SQL_CONCUR_VALUES               4
#define SQL_CONCUR_DEFAULT              SQL_CONCUR_READ_ONLY /* Default value */

/* SQL_CURSOR_TYPE options */
#define SQL_CURSOR_FORWARD_ONLY         0UL
#define SQL_CURSOR_KEYSET_DRIVEN        1UL
#define SQL_CURSOR_DYNAMIC              2UL
#define SQL_CURSOR_STATIC               3UL
#define SQL_CURSOR_TYPE_DEFAULT         SQL_CURSOR_FORWARD_ONLY /* Default value */

/* SQL_ROWSET_SIZE options */
#define SQL_ROWSET_SIZE_DEFAULT         1UL

/* SQL_KEYSET_SIZE options */
#define SQL_KEYSET_SIZE_DEFAULT         0UL

/* SQL_SIMULATE_CURSOR options */
#define SQL_SC_NON_UNIQUE               0UL
#define SQL_SC_TRY_UNIQUE               1UL
#define SQL_SC_UNIQUE                   2UL

/* SQL_RETRIEVE_DATA options */
#define SQL_RD_OFF                      0UL
#define SQL_RD_ON                       1UL
#define SQL_RD_DEFAULT                  SQL_RD_ON

/* SQL_USE_BOOKMARKS options */
#define SQL_UB_OFF                      0UL
#define	SQL_UB_ON						01UL
#define SQL_UB_DEFAULT                  SQL_UB_OFF

/* New values for SQL_USE_BOOKMARKS attribute */
#if (ODBCVER >= 0x0300)
#define SQL_UB_FIXED					SQL_UB_ON
#define SQL_UB_VARIABLE					2UL
#endif  /* ODBCVER >= 0x0300 */

/* extended descriptor field */
#if (ODBCVER >= 0x0300)
#define SQL_DESC_ARRAY_SIZE						20
#define SQL_DESC_ARRAY_STATUS_PTR				21
#define SQL_DESC_AUTO_UNIQUE_VALUE				SQL_COLUMN_AUTO_INCREMENT
#define SQL_DESC_BASE_COLUMN_NAME				22
#define SQL_DESC_BASE_TABLE_NAME				23
#define SQL_DESC_BIND_OFFSET_PTR				24
#define SQL_DESC_BIND_TYPE						25
#define SQL_DESC_CASE_SENSITIVE					SQL_COLUMN_CASE_SENSITIVE
#define SQL_DESC_CATALOG_NAME					SQL_COLUMN_QUALIFIER_NAME
#define SQL_DESC_CONCISE_TYPE					SQL_COLUMN_TYPE
#define SQL_DESC_DATETIME_INTERVAL_PRECISION	26
#define SQL_DESC_DISPLAY_SIZE					SQL_COLUMN_DISPLAY_SIZE
#define SQL_DESC_FIXED_PREC_SCALE				SQL_COLUMN_MONEY
#define SQL_DESC_LABEL							SQL_COLUMN_LABEL
#define SQL_DESC_LITERAL_PREFIX					27
#define SQL_DESC_LITERAL_SUFFIX					28
#define SQL_DESC_LOCAL_TYPE_NAME				29
#define	SQL_DESC_MAXIMUM_SCALE					30
#define SQL_DESC_MINIMUM_SCALE					31
#define SQL_DESC_NUM_PREC_RADIX					32
#define SQL_DESC_PARAMETER_TYPE					33
#define SQL_DESC_ROWS_PROCESSED_PTR				34
#if (ODBCVER >= 0x0350)
#define SQL_DESC_ROWVER							35
#endif /* ODBCVER >= 0x0350 */
#define SQL_DESC_SCHEMA_NAME					SQL_COLUMN_OWNER_NAME
#define SQL_DESC_SEARCHABLE						SQL_COLUMN_SEARCHABLE
#define SQL_DESC_TYPE_NAME						SQL_COLUMN_TYPE_NAME
#define SQL_DESC_TABLE_NAME						SQL_COLUMN_TABLE_NAME
#define SQL_DESC_UNSIGNED						SQL_COLUMN_UNSIGNED
#define SQL_DESC_UPDATABLE						SQL_COLUMN_UPDATABLE
#endif /* ODBCVER >= 0x0300 */


/* defines for diagnostics fields */
#if (ODBCVER >= 0x0300)
#define SQL_DIAG_CURSOR_ROW_COUNT			(-1249)
#define SQL_DIAG_ROW_NUMBER					(-1248)
#define SQL_DIAG_COLUMN_NUMBER				(-1247)	
#endif /* ODBCVER >= 0x0300 */

/* SQL extended datatypes */
#define SQL_DATE                                9
#if (ODBCVER >= 0x0300)
#define SQL_INTERVAL							10
#endif  /* ODBCVER >= 0x0300 */
#define SQL_TIME                                10
#define SQL_TIMESTAMP                           11
#define SQL_LONGVARCHAR                         (-1)
#define SQL_BINARY                              (-2)
#define SQL_VARBINARY                           (-3)
#define SQL_LONGVARBINARY                       (-4)
#define SQL_BIGINT                              (-5)
#define SQL_TINYINT                             (-6)
#define SQL_BIT                                 (-7)
#if (ODBCVER >= 0x0350)
#define SQL_GUID				(-11)
#endif  /* ODBCVER >= 0x0350 */

#if (ODBCVER >= 0x0300)
/* interval code */
#define SQL_CODE_YEAR				1
#define SQL_CODE_MONTH				2
#define SQL_CODE_DAY				3
#define SQL_CODE_HOUR				4
#define SQL_CODE_MINUTE				5
#define SQL_CODE_SECOND				6
#define SQL_CODE_YEAR_TO_MONTH			7
#define SQL_CODE_DAY_TO_HOUR			8
#define SQL_CODE_DAY_TO_MINUTE			9
#define SQL_CODE_DAY_TO_SECOND			10
#define SQL_CODE_HOUR_TO_MINUTE			11
#define SQL_CODE_HOUR_TO_SECOND			12
#define SQL_CODE_MINUTE_TO_SECOND		13

#define SQL_INTERVAL_YEAR					(100 + SQL_CODE_YEAR)
#define SQL_INTERVAL_MONTH					(100 + SQL_CODE_MONTH)
#define SQL_INTERVAL_DAY					(100 + SQL_CODE_DAY) 
#define SQL_INTERVAL_HOUR					(100 + SQL_CODE_HOUR) 
#define SQL_INTERVAL_MINUTE					(100 + SQL_CODE_MINUTE) 
#define SQL_INTERVAL_SECOND                	(100 + SQL_CODE_SECOND) 
#define SQL_INTERVAL_YEAR_TO_MONTH			(100 + SQL_CODE_YEAR_TO_MONTH)
#define SQL_INTERVAL_DAY_TO_HOUR			(100 + SQL_CODE_DAY_TO_HOUR) 
#define SQL_INTERVAL_DAY_TO_MINUTE			(100 + SQL_CODE_DAY_TO_MINUTE) 
#define SQL_INTERVAL_DAY_TO_SECOND			(100 + SQL_CODE_DAY_TO_SECOND) 
#define SQL_INTERVAL_HOUR_TO_MINUTE			(100 + SQL_CODE_HOUR_TO_MINUTE)
#define SQL_INTERVAL_HOUR_TO_SECOND			(100 + SQL_CODE_HOUR_TO_SECOND) 
#define SQL_INTERVAL_MINUTE_TO_SECOND		(100 + SQL_CODE_MINUTE_TO_SECOND) 

#else
#define SQL_INTERVAL_YEAR                       (-80)
#define SQL_INTERVAL_MONTH                      (-81)
#define SQL_INTERVAL_YEAR_TO_MONTH              (-82)
#define SQL_INTERVAL_DAY                        (-83)
#define SQL_INTERVAL_HOUR                       (-84)
#define SQL_INTERVAL_MINUTE                     (-85)
#define SQL_INTERVAL_SECOND                     (-86)
#define SQL_INTERVAL_DAY_TO_HOUR                (-87)
#define SQL_INTERVAL_DAY_TO_MINUTE              (-88)
#define SQL_INTERVAL_DAY_TO_SECOND              (-89)
#define SQL_INTERVAL_HOUR_TO_MINUTE             (-90)
#define SQL_INTERVAL_HOUR_TO_SECOND             (-91)
#define SQL_INTERVAL_MINUTE_TO_SECOND           (-92)
#endif  /* ODBCVER >= 0x0300 */


#if (ODBCVER <= 0x0300)
#define SQL_UNICODE                             (-95)
#define SQL_UNICODE_VARCHAR                     (-96)
#define SQL_UNICODE_LONGVARCHAR                 (-97)
#define SQL_UNICODE_CHAR                        SQL_UNICODE
#else
/* The previous definitions for SQL_UNICODE_ are historical and obsolete */

#define	SQL_UNICODE				SQL_WCHAR

#define	SQL_UNICODE_VARCHAR		SQL_WVARCHAR
#define SQL_UNICODE_LONGVARCHAR	SQL_WLONGVARCHAR
#define SQL_UNICODE_CHAR		SQL_WCHAR
#endif

#if (ODBCVER < 0x0300)
#define SQL_TYPE_DRIVER_START                   SQL_INTERVAL_YEAR
#define SQL_TYPE_DRIVER_END                     SQL_UNICODE_LONGVARCHAR
#endif  /* ODBCVER < 0x0300 */

/* C datatype to SQL datatype mapping      SQL types
                                           ------------------- */
#define SQL_C_CHAR    SQL_CHAR             /* CHAR, VARCHAR, DECIMAL, NUMERIC */
#define SQL_C_LONG    SQL_INTEGER          /* INTEGER                      */
#define SQL_C_SHORT   SQL_SMALLINT         /* SMALLINT                     */
#define SQL_C_FLOAT   SQL_REAL             /* REAL                         */
#define SQL_C_DOUBLE  SQL_DOUBLE           /* FLOAT, DOUBLE                */
#if (ODBCVER >= 0x0300)
#define	SQL_C_NUMERIC		SQL_NUMERIC
#endif  /* ODBCVER >= 0x0300 */
#define SQL_C_DEFAULT 99

#define SQL_SIGNED_OFFSET       (-20)
#define SQL_UNSIGNED_OFFSET     (-22)

/* C datatype to SQL datatype mapping */
#define SQL_C_DATE       SQL_DATE
#define SQL_C_TIME       SQL_TIME
#define SQL_C_TIMESTAMP  SQL_TIMESTAMP
#if (ODBCVER >= 0x0300)
#define SQL_C_TYPE_DATE					SQL_TYPE_DATE
#define SQL_C_TYPE_TIME					SQL_TYPE_TIME
#define SQL_C_TYPE_TIMESTAMP			SQL_TYPE_TIMESTAMP
#define SQL_C_INTERVAL_YEAR				SQL_INTERVAL_YEAR
#define SQL_C_INTERVAL_MONTH			SQL_INTERVAL_MONTH
#define SQL_C_INTERVAL_DAY				SQL_INTERVAL_DAY
#define SQL_C_INTERVAL_HOUR				SQL_INTERVAL_HOUR
#define SQL_C_INTERVAL_MINUTE			SQL_INTERVAL_MINUTE
#define SQL_C_INTERVAL_SECOND			SQL_INTERVAL_SECOND
#define SQL_C_INTERVAL_YEAR_TO_MONTH	SQL_INTERVAL_YEAR_TO_MONTH
#define SQL_C_INTERVAL_DAY_TO_HOUR		SQL_INTERVAL_DAY_TO_HOUR
#define SQL_C_INTERVAL_DAY_TO_MINUTE	SQL_INTERVAL_DAY_TO_MINUTE
#define SQL_C_INTERVAL_DAY_TO_SECOND	SQL_INTERVAL_DAY_TO_SECOND
#define SQL_C_INTERVAL_HOUR_TO_MINUTE	SQL_INTERVAL_HOUR_TO_MINUTE
#define SQL_C_INTERVAL_HOUR_TO_SECOND	SQL_INTERVAL_HOUR_TO_SECOND
#define SQL_C_INTERVAL_MINUTE_TO_SECOND	SQL_INTERVAL_MINUTE_TO_SECOND
#endif  /* ODBCVER >= 0x0300 */
#define SQL_C_BINARY     SQL_BINARY
#define SQL_C_BIT        SQL_BIT
#if (ODBCVER >= 0x0300)
#define SQL_C_SBIGINT	(SQL_BIGINT+SQL_SIGNED_OFFSET)	   /* SIGNED BIGINT */
#define SQL_C_UBIGINT	(SQL_BIGINT+SQL_UNSIGNED_OFFSET)   /* UNSIGNED BIGINT */
#endif  /* ODBCVER >= 0x0300 */
#define SQL_C_TINYINT    SQL_TINYINT
#define SQL_C_SLONG      (SQL_C_LONG+SQL_SIGNED_OFFSET)    /* SIGNED INTEGER  */
#define SQL_C_SSHORT     (SQL_C_SHORT+SQL_SIGNED_OFFSET)   /* SIGNED SMALLINT */
#define SQL_C_STINYINT   (SQL_TINYINT+SQL_SIGNED_OFFSET)   /* SIGNED TINYINT  */
#define SQL_C_ULONG      (SQL_C_LONG+SQL_UNSIGNED_OFFSET)  /* UNSIGNED INTEGER*/
#define SQL_C_USHORT     (SQL_C_SHORT+SQL_UNSIGNED_OFFSET) /* UNSIGNED SMALLINT*/
#define SQL_C_UTINYINT   (SQL_TINYINT+SQL_UNSIGNED_OFFSET) /* UNSIGNED TINYINT*/
#define SQL_C_BOOKMARK   SQL_C_ULONG                       /* BOOKMARK        */

#if (ODBCVER >= 0x0350)
#define SQL_C_GUID	SQL_GUID
#endif  /* ODBCVER >= 0x0350 */

#define SQL_TYPE_NULL                   0
#if (ODBCVER < 0x0300)
#define SQL_TYPE_MIN                    SQL_BIT
#define SQL_TYPE_MAX                    SQL_VARCHAR
#endif

#if (ODBCVER >= 0x0300)
#define SQL_C_VARBOOKMARK		SQL_C_BINARY
#endif  /* ODBCVER >= 0x0300 */

/* define for SQL_DIAG_ROW_NUMBER and SQL_DIAG_COLUMN_NUMBER */
#if (ODBCVER >= 0x0300)
#define SQL_NO_ROW_NUMBER						(-1)
#define SQL_NO_COLUMN_NUMBER					(-1)
#define SQL_ROW_NUMBER_UNKNOWN					(-2)
#define SQL_COLUMN_NUMBER_UNKNOWN				(-2)
#endif

/* SQLBindParameter extensions */
#define SQL_DEFAULT_PARAM            (-5)
#define SQL_IGNORE                   (-6)
#if (ODBCVER >= 0x0300)
#define SQL_COLUMN_IGNORE			SQL_IGNORE
#endif  /* ODBCVER >= 0x0300 */
#define SQL_LEN_DATA_AT_EXEC_OFFSET  (-100)
#define SQL_LEN_DATA_AT_EXEC(length) (-(length)+SQL_LEN_DATA_AT_EXEC_OFFSET)

/* binary length for driver specific attributes */
#define SQL_LEN_BINARY_ATTR_OFFSET	 (-100)
#define SQL_LEN_BINARY_ATTR(length)	 (-(length)+SQL_LEN_BINARY_ATTR_OFFSET)

/* Defines used by Driver Manager when mapping SQLSetParam to SQLBindParameter
*/
#define SQL_PARAM_TYPE_DEFAULT           SQL_PARAM_INPUT_OUTPUT
#define SQL_SETPARAM_VALUE_MAX           (-1L)

/* SQLColAttributes defines */
#define SQL_COLUMN_COUNT                0
#define SQL_COLUMN_NAME                 1
#define SQL_COLUMN_TYPE                 2
#define SQL_COLUMN_LENGTH               3
#define SQL_COLUMN_PRECISION            4
#define SQL_COLUMN_SCALE                5
#define SQL_COLUMN_DISPLAY_SIZE         6
#define SQL_COLUMN_NULLABLE             7
#define SQL_COLUMN_UNSIGNED             8
#define SQL_COLUMN_MONEY                9
#define SQL_COLUMN_UPDATABLE            10
#define SQL_COLUMN_AUTO_INCREMENT       11
#define SQL_COLUMN_CASE_SENSITIVE       12
#define SQL_COLUMN_SEARCHABLE           13
#define SQL_COLUMN_TYPE_NAME            14
#define SQL_COLUMN_TABLE_NAME           15
#define SQL_COLUMN_OWNER_NAME           16
#define SQL_COLUMN_QUALIFIER_NAME       17
#define SQL_COLUMN_LABEL                18
#define SQL_COLATT_OPT_MAX              SQL_COLUMN_LABEL
#if (ODBCVER < 0x0300)
#define SQL_COLUMN_DRIVER_START         1000
#endif  /* ODBCVER < 0x0300 */

#define SQL_COLATT_OPT_MIN              SQL_COLUMN_COUNT

/* SQLColAttributes subdefines for SQL_COLUMN_UPDATABLE */
#define SQL_ATTR_READONLY               0
#define SQL_ATTR_WRITE                  1
#define SQL_ATTR_READWRITE_UNKNOWN      2

/* SQLColAttributes subdefines for SQL_COLUMN_SEARCHABLE */
/* These are also used by SQLGetInfo                     */
#define SQL_UNSEARCHABLE                0
#define SQL_LIKE_ONLY                   1
#define SQL_ALL_EXCEPT_LIKE             2
#define SQL_SEARCHABLE                  3
#define SQL_PRED_SEARCHABLE				SQL_SEARCHABLE


/* Special return values for SQLGetData */
#define SQL_NO_TOTAL                    (-4)

/********************************************/
/* SQLGetFunctions: additional values for   */
/* fFunction to represent functions that    */
/* are not in the X/Open spec.				*/
/********************************************/

#if (ODBCVER >= 0x0300)
#define SQL_API_SQLALLOCHANDLESTD	73
#define SQL_API_SQLBULKOPERATIONS	24
#endif /* ODBCVER >= 0x0300 */
#define SQL_API_SQLBINDPARAMETER    72
#define SQL_API_SQLBROWSECONNECT    55    
#define SQL_API_SQLCOLATTRIBUTES    6 
#define SQL_API_SQLCOLUMNPRIVILEGES 56
#define SQL_API_SQLDESCRIBEPARAM    58
#define	SQL_API_SQLDRIVERCONNECT	41 
#define SQL_API_SQLDRIVERS          71
#define SQL_API_SQLEXTENDEDFETCH    59
#define SQL_API_SQLFOREIGNKEYS      60
#define SQL_API_SQLMORERESULTS      61
#define SQL_API_SQLNATIVESQL        62
#define SQL_API_SQLNUMPARAMS        63
#define SQL_API_SQLPARAMOPTIONS     64
#define SQL_API_SQLPRIMARYKEYS      65
#define SQL_API_SQLPROCEDURECOLUMNS 66
#define SQL_API_SQLPROCEDURES       67
#define SQL_API_SQLSETPOS           68
#define SQL_API_SQLSETSCROLLOPTIONS 69
#define SQL_API_SQLTABLEPRIVILEGES  70

/*-------------------------------------------*/
/* SQL_EXT_API_LAST is not useful with ODBC  */
/* version 3.0 because some of the values    */
/* from X/Open are in the 10000 range.       */
/*-------------------------------------------*/

#if (ODBCVER < 0x0300)
#define SQL_EXT_API_LAST            SQL_API_SQLBINDPARAMETER
#define SQL_NUM_FUNCTIONS           23
#define SQL_EXT_API_START           40
#define SQL_NUM_EXTENSIONS (SQL_EXT_API_LAST-SQL_EXT_API_START+1)
#endif

/*--------------------------------------------*/
/* SQL_API_ALL_FUNCTIONS returns an array     */
/* of 'booleans' representing whether a       */
/* function is implemented by the driver.     */
/*                                            */
/* CAUTION: Only functions defined in ODBC    */
/* version 2.0 and earlier are returned, the  */
/* new high-range function numbers defined by */
/* X/Open break this scheme.   See the new    */
/* method -- SQL_API_ODBC3_ALL_FUNCTIONS      */
/*--------------------------------------------*/

#define SQL_API_ALL_FUNCTIONS       0		/* See CAUTION above */

/*----------------------------------------------*/
/* 2.X drivers export a dummy function with  	*/
/* ordinal number SQL_API_LOADBYORDINAL to speed*/
/* loading under the windows operating system.  */
/* 						*/
/* CAUTION: Loading by ordinal is not supported */
/* for 3.0 and above drivers.			*/
/*----------------------------------------------*/

#define SQL_API_LOADBYORDINAL       199		/* See CAUTION above */	

/*----------------------------------------------*/
/* SQL_API_ODBC3_ALL_FUNCTIONS                  */
/* This returns a bitmap, which allows us to    */
/* handle the higher-valued function numbers.   */
/* Use  SQL_FUNC_EXISTS(bitmap,function_number) */
/* to determine if the function exists.         */
/*----------------------------------------------*/


#if (ODBCVER >= 0x0300)
#define SQL_API_ODBC3_ALL_FUNCTIONS	999
#define	SQL_API_ODBC3_ALL_FUNCTIONS_SIZE	250		/* array of 250 words */

#define SQL_FUNC_EXISTS(pfExists, uwAPI) \
				((*(((UWORD*) (pfExists)) + ((uwAPI) >> 4)) \
					& (1 << ((uwAPI) & 0x000F)) \
 				 ) ? SQL_TRUE : SQL_FALSE \
				)
#endif  /* ODBCVER >= 0x0300 */


/************************************************/
/* Extended definitions for SQLGetInfo			*/
/************************************************/

/*---------------------------------*/
/* Values in ODBC 2.0 that are not */
/* in the X/Open spec              */
/*---------------------------------*/

#define SQL_INFO_FIRST                       0		
#define SQL_ACTIVE_CONNECTIONS               0	/* MAX_DRIVER_CONNECTIONS */
#define SQL_ACTIVE_STATEMENTS                1	/* MAX_CONCURRENT_ACTIVITIES */
#define SQL_DRIVER_HDBC                      3
#define SQL_DRIVER_HENV                      4
#define SQL_DRIVER_HSTMT                     5
#define SQL_DRIVER_NAME                      6
#define SQL_DRIVER_VER                       7
#define SQL_ODBC_API_CONFORMANCE             9
#define SQL_ODBC_VER                        10
#define SQL_ROW_UPDATES                     11
#define SQL_ODBC_SAG_CLI_CONFORMANCE        12
#define SQL_ODBC_SQL_CONFORMANCE            15
#define SQL_PROCEDURES                      21
#define SQL_CONCAT_NULL_BEHAVIOR            22
#define SQL_CURSOR_ROLLBACK_BEHAVIOR        24
#define SQL_EXPRESSIONS_IN_ORDERBY          27
#define SQL_MAX_OWNER_NAME_LEN              32	/* MAX_SCHEMA_NAME_LEN */
#define SQL_MAX_PROCEDURE_NAME_LEN          33
#define SQL_MAX_QUALIFIER_NAME_LEN          34	/* MAX_CATALOG_NAME_LEN */
#define SQL_MULT_RESULT_SETS                36
#define SQL_MULTIPLE_ACTIVE_TXN             37
#define SQL_OUTER_JOINS                     38
#define SQL_OWNER_TERM                      39
#define SQL_PROCEDURE_TERM                  40
#define SQL_QUALIFIER_NAME_SEPARATOR        41
#define SQL_QUALIFIER_TERM                  42
#define SQL_SCROLL_OPTIONS                  44
#define SQL_TABLE_TERM                      45
#define SQL_CONVERT_FUNCTIONS               48
#define SQL_NUMERIC_FUNCTIONS               49
#define SQL_STRING_FUNCTIONS                50
#define SQL_SYSTEM_FUNCTIONS                51
#define SQL_TIMEDATE_FUNCTIONS              52
#define SQL_CONVERT_BIGINT                  53
#define SQL_CONVERT_BINARY                  54
#define SQL_CONVERT_BIT                     55
#define SQL_CONVERT_CHAR                    56
#define SQL_CONVERT_DATE                    57
#define SQL_CONVERT_DECIMAL                 58
#define SQL_CONVERT_DOUBLE                  59
#define SQL_CONVERT_FLOAT                   60
#define SQL_CONVERT_INTEGER                 61
#define SQL_CONVERT_LONGVARCHAR             62
#define SQL_CONVERT_NUMERIC                 63
#define SQL_CONVERT_REAL                    64
#define SQL_CONVERT_SMALLINT                65
#define SQL_CONVERT_TIME                    66
#define SQL_CONVERT_TIMESTAMP               67
#define SQL_CONVERT_TINYINT                 68
#define SQL_CONVERT_VARBINARY               69
#define SQL_CONVERT_VARCHAR                 70
#define SQL_CONVERT_LONGVARBINARY           71
#define SQL_ODBC_SQL_OPT_IEF                73		/* SQL_INTEGRITY */
#define SQL_CORRELATION_NAME                74
#define SQL_NON_NULLABLE_COLUMNS            75
#define SQL_DRIVER_HLIB                     76
#define SQL_DRIVER_ODBC_VER                 77
#define SQL_LOCK_TYPES                      78
#define SQL_POS_OPERATIONS                  79
#define SQL_POSITIONED_STATEMENTS           80
#define SQL_BOOKMARK_PERSISTENCE            82
#define SQL_STATIC_SENSITIVITY              83
#define SQL_FILE_USAGE                      84
#define SQL_COLUMN_ALIAS                    87
#define SQL_GROUP_BY                        88
#define SQL_KEYWORDS                        89
#define SQL_OWNER_USAGE                     91
#define SQL_QUALIFIER_USAGE                 92
#define SQL_QUOTED_IDENTIFIER_CASE          93
#define SQL_SUBQUERIES                      95
#define SQL_UNION                           96
#define SQL_MAX_ROW_SIZE_INCLUDES_LONG      103
#define SQL_MAX_CHAR_LITERAL_LEN            108
#define SQL_TIMEDATE_ADD_INTERVALS          109
#define SQL_TIMEDATE_DIFF_INTERVALS         110
#define SQL_NEED_LONG_DATA_LEN              111
#define SQL_MAX_BINARY_LITERAL_LEN          112
#define SQL_LIKE_ESCAPE_CLAUSE              113
#define SQL_QUALIFIER_LOCATION              114

#if (ODBCVER >= 0x0201 && ODBCVER < 0x0300)
#define SQL_OJ_CAPABILITIES         65003  /* Temp value until ODBC 3.0 */
#endif  /* ODBCVER >= 0x0201 && ODBCVER < 0x0300 */

/*----------------------------------------------*/
/* SQL_INFO_LAST and SQL_INFO_DRIVER_START are  */
/* not useful anymore, because  X/Open has      */
/* values in the 10000 range.   You  			*/
/* must contact X/Open directly to get a range	*/
/* of numbers for driver-specific values.	    */
/*----------------------------------------------*/

#if (ODBCVER < 0x0300)
#define SQL_INFO_LAST						SQL_QUALIFIER_LOCATION
#define SQL_INFO_DRIVER_START				1000
#endif /* ODBCVER < 0x0300 */

/*-----------------------------------------------*/
/* ODBC 3.0 SQLGetInfo values that are not part  */
/* of the X/Open standard at this time.   X/Open */
/* standard values are in sql.h.				 */
/*-----------------------------------------------*/

#if (ODBCVER >= 0x0300)
#define SQL_ACTIVE_ENVIRONMENTS					116
#define	SQL_ALTER_DOMAIN						117

#define	SQL_SQL_CONFORMANCE						118
#define SQL_DATETIME_LITERALS					119

#define	SQL_ASYNC_MODE							10021	/* new X/Open spec */
#define SQL_BATCH_ROW_COUNT						120
#define SQL_BATCH_SUPPORT						121
#define SQL_CATALOG_LOCATION					SQL_QUALIFIER_LOCATION
#define SQL_CATALOG_NAME_SEPARATOR				SQL_QUALIFIER_NAME_SEPARATOR
#define SQL_CATALOG_TERM						SQL_QUALIFIER_TERM
#define SQL_CATALOG_USAGE						SQL_QUALIFIER_USAGE
#define	SQL_CONVERT_WCHAR						122
#define SQL_CONVERT_INTERVAL_DAY_TIME			123
#define SQL_CONVERT_INTERVAL_YEAR_MONTH			124
#define	SQL_CONVERT_WLONGVARCHAR				125
#define	SQL_CONVERT_WVARCHAR					126
#define	SQL_CREATE_ASSERTION					127
#define	SQL_CREATE_CHARACTER_SET				128
#define	SQL_CREATE_COLLATION					129
#define	SQL_CREATE_DOMAIN						130
#define	SQL_CREATE_SCHEMA						131
#define	SQL_CREATE_TABLE						132
#define	SQL_CREATE_TRANSLATION					133
#define	SQL_CREATE_VIEW							134
#define SQL_DRIVER_HDESC						135
#define	SQL_DROP_ASSERTION						136
#define	SQL_DROP_CHARACTER_SET					137
#define	SQL_DROP_COLLATION						138
#define	SQL_DROP_DOMAIN							139
#define	SQL_DROP_SCHEMA							140
#define	SQL_DROP_TABLE							141
#define	SQL_DROP_TRANSLATION					142
#define	SQL_DROP_VIEW							143
#define SQL_DYNAMIC_CURSOR_ATTRIBUTES1			144
#define SQL_DYNAMIC_CURSOR_ATTRIBUTES2			145
#define SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1		146		
#define SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2		147
#define SQL_INDEX_KEYWORDS						148
#define SQL_INFO_SCHEMA_VIEWS					149
#define SQL_KEYSET_CURSOR_ATTRIBUTES1			150
#define SQL_KEYSET_CURSOR_ATTRIBUTES2			151
#define	SQL_MAX_ASYNC_CONCURRENT_STATEMENTS		10022	/* new X/Open spec */
#define SQL_ODBC_INTERFACE_CONFORMANCE			152
#define SQL_PARAM_ARRAY_ROW_COUNTS     			153
#define SQL_PARAM_ARRAY_SELECTS     			154
#define SQL_SCHEMA_TERM							SQL_OWNER_TERM
#define SQL_SCHEMA_USAGE						SQL_OWNER_USAGE
#define SQL_SQL92_DATETIME_FUNCTIONS			155
#define SQL_SQL92_FOREIGN_KEY_DELETE_RULE		156		
#define SQL_SQL92_FOREIGN_KEY_UPDATE_RULE		157		
#define SQL_SQL92_GRANT							158
#define SQL_SQL92_NUMERIC_VALUE_FUNCTIONS		159
#define SQL_SQL92_PREDICATES					160
#define SQL_SQL92_RELATIONAL_JOIN_OPERATORS		161
#define SQL_SQL92_REVOKE						162
#define SQL_SQL92_ROW_VALUE_CONSTRUCTOR			163
#define SQL_SQL92_STRING_FUNCTIONS				164
#define SQL_SQL92_VALUE_EXPRESSIONS				165
#define SQL_STANDARD_CLI_CONFORMANCE			166
#define SQL_STATIC_CURSOR_ATTRIBUTES1			167	
#define SQL_STATIC_CURSOR_ATTRIBUTES2			168

#define SQL_AGGREGATE_FUNCTIONS					169
#define SQL_DDL_INDEX							170
#define SQL_DM_VER								171
#define SQL_INSERT_STATEMENT					172
#define	SQL_CONVERT_GUID						173		
#define SQL_UNION_STATEMENT						SQL_UNION
#endif  /* ODBCVER >= 0x0300 */

#define	SQL_DTC_TRANSITION_COST					1750

/* SQL_ALTER_TABLE bitmasks */
#if (ODBCVER >= 0x0300)
/* the following 5 bitmasks are defined in sql.h
*#define SQL_AT_ADD_COLUMN                   	0x00000001L
*#define SQL_AT_DROP_COLUMN                  	0x00000002L
*#define SQL_AT_ADD_CONSTRAINT               	0x00000008L
*/
#define	SQL_AT_ADD_COLUMN_SINGLE				0x00000020L	
#define	SQL_AT_ADD_COLUMN_DEFAULT				0x00000040L
#define	SQL_AT_ADD_COLUMN_COLLATION				0x00000080L
#define	SQL_AT_SET_COLUMN_DEFAULT				0x00000100L
#define	SQL_AT_DROP_COLUMN_DEFAULT				0x00000200L
#define	SQL_AT_DROP_COLUMN_CASCADE				0x00000400L
#define	SQL_AT_DROP_COLUMN_RESTRICT				0x00000800L
#define SQL_AT_ADD_TABLE_CONSTRAINT				0x00001000L		
#define SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE	0x00002000L		
#define SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT	0x00004000L		
#define SQL_AT_CONSTRAINT_NAME_DEFINITION		0x00008000L
#define SQL_AT_CONSTRAINT_INITIALLY_DEFERRED	0x00010000L
#define SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE	0x00020000L
#define SQL_AT_CONSTRAINT_DEFERRABLE			0x00040000L
#define SQL_AT_CONSTRAINT_NON_DEFERRABLE		0x00080000L
#endif	/* ODBCVER >= 0x0300 */

/* SQL_CONVERT_*  return value bitmasks */

#define SQL_CVT_CHAR                        0x00000001L
#define SQL_CVT_NUMERIC                     0x00000002L
#define SQL_CVT_DECIMAL                     0x00000004L
#define SQL_CVT_INTEGER                     0x00000008L
#define SQL_CVT_SMALLINT                    0x00000010L
#define SQL_CVT_FLOAT                       0x00000020L
#define SQL_CVT_REAL                        0x00000040L
#define SQL_CVT_DOUBLE                      0x00000080L
#define SQL_CVT_VARCHAR                     0x00000100L
#define SQL_CVT_LONGVARCHAR                 0x00000200L
#define SQL_CVT_BINARY                      0x00000400L
#define SQL_CVT_VARBINARY                   0x00000800L
#define SQL_CVT_BIT                         0x00001000L
#define SQL_CVT_TINYINT                     0x00002000L
#define SQL_CVT_BIGINT                      0x00004000L
#define SQL_CVT_DATE                        0x00008000L
#define SQL_CVT_TIME                        0x00010000L
#define SQL_CVT_TIMESTAMP                   0x00020000L
#define SQL_CVT_LONGVARBINARY               0x00040000L
#if (ODBCVER >= 0x0300)
#define SQL_CVT_INTERVAL_YEAR_MONTH	    	0x00080000L
#define SQL_CVT_INTERVAL_DAY_TIME	    	0x00100000L
#define	SQL_CVT_WCHAR						0x00200000L
#define	SQL_CVT_WLONGVARCHAR				0x00400000L
#define	SQL_CVT_WVARCHAR					0x00800000L
#define SQL_CVT_GUID						0x01000000L

#endif  /* ODBCVER >= 0x0300 */


/* SQL_CONVERT_FUNCTIONS functions */
#define SQL_FN_CVT_CONVERT                  0x00000001L
#if (ODBCVER >= 0x0300)
#define SQL_FN_CVT_CAST						0x00000002L
#endif  /* ODBCVER >= 0x0300 */


/* SQL_STRING_FUNCTIONS functions */

#define SQL_FN_STR_CONCAT                   0x00000001L
#define SQL_FN_STR_INSERT                   0x00000002L
#define SQL_FN_STR_LEFT                     0x00000004L
#define SQL_FN_STR_LTRIM                    0x00000008L
#define SQL_FN_STR_LENGTH                   0x00000010L
#define SQL_FN_STR_LOCATE                   0x00000020L
#define SQL_FN_STR_LCASE                    0x00000040L
#define SQL_FN_STR_REPEAT                   0x00000080L
#define SQL_FN_STR_REPLACE                  0x00000100L
#define SQL_FN_STR_RIGHT                    0x00000200L
#define SQL_FN_STR_RTRIM                    0x00000400L
#define SQL_FN_STR_SUBSTRING                0x00000800L
#define SQL_FN_STR_UCASE                    0x00001000L
#define SQL_FN_STR_ASCII                    0x00002000L
#define SQL_FN_STR_CHAR                     0x00004000L
#define SQL_FN_STR_DIFFERENCE               0x00008000L
#define SQL_FN_STR_LOCATE_2                 0x00010000L
#define SQL_FN_STR_SOUNDEX                  0x00020000L
#define SQL_FN_STR_SPACE                    0x00040000L
#if (ODBCVER >= 0x0300)
#define SQL_FN_STR_BIT_LENGTH				0x00080000L
#define SQL_FN_STR_CHAR_LENGTH				0x00100000L
#define SQL_FN_STR_CHARACTER_LENGTH			0x00200000L
#define SQL_FN_STR_OCTET_LENGTH				0x00400000L
#define SQL_FN_STR_POSITION					0x00800000L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_SQL92_STRING_FUNCTIONS */
#if (ODBCVER >= 0x0300)
#define SQL_SSF_CONVERT						0x00000001L	
#define SQL_SSF_LOWER						0x00000002L
#define SQL_SSF_UPPER						0x00000004L
#define SQL_SSF_SUBSTRING					0x00000008L
#define SQL_SSF_TRANSLATE					0x00000010L
#define SQL_SSF_TRIM_BOTH					0x00000020L
#define SQL_SSF_TRIM_LEADING				0x00000040L
#define SQL_SSF_TRIM_TRAILING				0x00000080L
#endif /* ODBCVER >= 0x0300 */

/* SQL_NUMERIC_FUNCTIONS functions */

#define SQL_FN_NUM_ABS                      0x00000001L
#define SQL_FN_NUM_ACOS                     0x00000002L
#define SQL_FN_NUM_ASIN                     0x00000004L
#define SQL_FN_NUM_ATAN                     0x00000008L
#define SQL_FN_NUM_ATAN2                    0x00000010L
#define SQL_FN_NUM_CEILING                  0x00000020L
#define SQL_FN_NUM_COS                      0x00000040L
#define SQL_FN_NUM_COT                      0x00000080L
#define SQL_FN_NUM_EXP                      0x00000100L
#define SQL_FN_NUM_FLOOR                    0x00000200L
#define SQL_FN_NUM_LOG                      0x00000400L
#define SQL_FN_NUM_MOD                      0x00000800L
#define SQL_FN_NUM_SIGN                     0x00001000L
#define SQL_FN_NUM_SIN                      0x00002000L
#define SQL_FN_NUM_SQRT                     0x00004000L
#define SQL_FN_NUM_TAN                      0x00008000L
#define SQL_FN_NUM_PI                       0x00010000L
#define SQL_FN_NUM_RAND                     0x00020000L
#define SQL_FN_NUM_DEGREES                  0x00040000L
#define SQL_FN_NUM_LOG10                    0x00080000L
#define SQL_FN_NUM_POWER                    0x00100000L
#define SQL_FN_NUM_RADIANS                  0x00200000L
#define SQL_FN_NUM_ROUND                    0x00400000L
#define SQL_FN_NUM_TRUNCATE                 0x00800000L

/* SQL_SQL92_NUMERIC_VALUE_FUNCTIONS */
#if (ODBCVER >= 0x0300)
#define SQL_SNVF_BIT_LENGTH					0x00000001L
#define SQL_SNVF_CHAR_LENGTH				0x00000002L
#define SQL_SNVF_CHARACTER_LENGTH			0x00000004L
#define SQL_SNVF_EXTRACT					0x00000008L
#define SQL_SNVF_OCTET_LENGTH				0x00000010L
#define SQL_SNVF_POSITION					0x00000020L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_TIMEDATE_FUNCTIONS functions */

#define SQL_FN_TD_NOW                       0x00000001L
#define SQL_FN_TD_CURDATE                   0x00000002L
#define SQL_FN_TD_DAYOFMONTH                0x00000004L
#define SQL_FN_TD_DAYOFWEEK                 0x00000008L
#define SQL_FN_TD_DAYOFYEAR                 0x00000010L
#define SQL_FN_TD_MONTH                     0x00000020L
#define SQL_FN_TD_QUARTER                   0x00000040L
#define SQL_FN_TD_WEEK                      0x00000080L
#define SQL_FN_TD_YEAR                      0x00000100L
#define SQL_FN_TD_CURTIME                   0x00000200L
#define SQL_FN_TD_HOUR                      0x00000400L
#define SQL_FN_TD_MINUTE                    0x00000800L
#define SQL_FN_TD_SECOND                    0x00001000L
#define SQL_FN_TD_TIMESTAMPADD              0x00002000L
#define SQL_FN_TD_TIMESTAMPDIFF             0x00004000L
#define SQL_FN_TD_DAYNAME                   0x00008000L
#define SQL_FN_TD_MONTHNAME                 0x00010000L
#if (ODBCVER >= 0x0300)
#define SQL_FN_TD_CURRENT_DATE				0x00020000L
#define SQL_FN_TD_CURRENT_TIME				0x00040000L
#define SQL_FN_TD_CURRENT_TIMESTAMP			0x00080000L
#define SQL_FN_TD_EXTRACT					0x00100000L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_SQL92_DATETIME_FUNCTIONS */
#if (ODBCVER >= 0x0300)
#define SQL_SDF_CURRENT_DATE				0x00000001L
#define SQL_SDF_CURRENT_TIME				0x00000002L
#define SQL_SDF_CURRENT_TIMESTAMP			0x00000004L
#endif /* ODBCVER >= 0x0300 */

/* SQL_SYSTEM_FUNCTIONS functions */

#define SQL_FN_SYS_USERNAME                 0x00000001L
#define SQL_FN_SYS_DBNAME                   0x00000002L
#define SQL_FN_SYS_IFNULL                   0x00000004L

/* SQL_TIMEDATE_ADD_INTERVALS and SQL_TIMEDATE_DIFF_INTERVALS functions */

#define SQL_FN_TSI_FRAC_SECOND              0x00000001L
#define SQL_FN_TSI_SECOND                   0x00000002L
#define SQL_FN_TSI_MINUTE                   0x00000004L
#define SQL_FN_TSI_HOUR                     0x00000008L
#define SQL_FN_TSI_DAY                      0x00000010L
#define SQL_FN_TSI_WEEK                     0x00000020L
#define SQL_FN_TSI_MONTH                    0x00000040L
#define SQL_FN_TSI_QUARTER                  0x00000080L
#define SQL_FN_TSI_YEAR                     0x00000100L

/* bitmasks for SQL_DYNAMIC_CURSOR_ATTRIBUTES1,
 * SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1, 
 * SQL_KEYSET_CURSOR_ATTRIBUTES1, and SQL_STATIC_CURSOR_ATTRIBUTES1 
 */
#if (ODBCVER >= 0x0300)
/* supported SQLFetchScroll FetchOrientation's */
#define SQL_CA1_NEXT						0x00000001L
#define SQL_CA1_ABSOLUTE					0x00000002L
#define SQL_CA1_RELATIVE					0x00000004L
#define SQL_CA1_BOOKMARK					0x00000008L

/* supported SQLSetPos LockType's */
#define SQL_CA1_LOCK_NO_CHANGE				0x00000040L
#define SQL_CA1_LOCK_EXCLUSIVE				0x00000080L
#define SQL_CA1_LOCK_UNLOCK					0x00000100L

/* supported SQLSetPos Operations */
#define SQL_CA1_POS_POSITION				0x00000200L
#define SQL_CA1_POS_UPDATE					0x00000400L
#define SQL_CA1_POS_DELETE					0x00000800L
#define SQL_CA1_POS_REFRESH					0x00001000L

/* positioned updates and deletes */
#define SQL_CA1_POSITIONED_UPDATE			0x00002000L
#define SQL_CA1_POSITIONED_DELETE			0x00004000L
#define SQL_CA1_SELECT_FOR_UPDATE			0x00008000L

/* supported SQLBulkOperations operations */
#define SQL_CA1_BULK_ADD					0x00010000L
#define SQL_CA1_BULK_UPDATE_BY_BOOKMARK		0x00020000L
#define SQL_CA1_BULK_DELETE_BY_BOOKMARK		0x00040000L
#define SQL_CA1_BULK_FETCH_BY_BOOKMARK		0x00080000L
#endif  /* ODBCVER >= 0x0300 */

/* bitmasks for SQL_DYNAMIC_CURSOR_ATTRIBUTES2,
 * SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2, 
 * SQL_KEYSET_CURSOR_ATTRIBUTES2, and SQL_STATIC_CURSOR_ATTRIBUTES2 
 */
#if (ODBCVER >= 0x0300)
/* supported values for SQL_ATTR_SCROLL_CONCURRENCY */
#define SQL_CA2_READ_ONLY_CONCURRENCY		0x00000001L
#define SQL_CA2_LOCK_CONCURRENCY			0x00000002L
#define SQL_CA2_OPT_ROWVER_CONCURRENCY		0x00000004L
#define SQL_CA2_OPT_VALUES_CONCURRENCY		0x00000008L

/* sensitivity of the cursor to its own inserts, deletes, and updates */
#define SQL_CA2_SENSITIVITY_ADDITIONS		0x00000010L
#define SQL_CA2_SENSITIVITY_DELETIONS		0x00000020L
#define SQL_CA2_SENSITIVITY_UPDATES			0x00000040L

/* semantics of SQL_ATTR_MAX_ROWS */
#define SQL_CA2_MAX_ROWS_SELECT				0x00000080L
#define SQL_CA2_MAX_ROWS_INSERT				0x00000100L
#define SQL_CA2_MAX_ROWS_DELETE				0x00000200L
#define SQL_CA2_MAX_ROWS_UPDATE				0x00000400L
#define SQL_CA2_MAX_ROWS_CATALOG			0x00000800L
#define SQL_CA2_MAX_ROWS_AFFECTS_ALL		(SQL_CA2_MAX_ROWS_SELECT | \
					SQL_CA2_MAX_ROWS_INSERT | SQL_CA2_MAX_ROWS_DELETE | \
					SQL_CA2_MAX_ROWS_UPDATE | SQL_CA2_MAX_ROWS_CATALOG)

/* semantics of SQL_DIAG_CURSOR_ROW_COUNT */
#define SQL_CA2_CRC_EXACT					0x00001000L
#define SQL_CA2_CRC_APPROXIMATE				0x00002000L

/* the kinds of positioned statements that can be simulated */
#define SQL_CA2_SIMULATE_NON_UNIQUE			0x00004000L
#define SQL_CA2_SIMULATE_TRY_UNIQUE			0x00008000L
#define SQL_CA2_SIMULATE_UNIQUE				0x00010000L
#endif  /* ODBCVER >= 0x0300 */

/* SQL_ODBC_API_CONFORMANCE values */

#define SQL_OAC_NONE                        0x0000
#define SQL_OAC_LEVEL1                      0x0001
#define SQL_OAC_LEVEL2                      0x0002

/* SQL_ODBC_SAG_CLI_CONFORMANCE values */

#define SQL_OSCC_NOT_COMPLIANT              0x0000
#define SQL_OSCC_COMPLIANT                  0x0001

/* SQL_ODBC_SQL_CONFORMANCE values */

#define SQL_OSC_MINIMUM                     0x0000
#define SQL_OSC_CORE                        0x0001
#define SQL_OSC_EXTENDED                    0x0002


/* SQL_CONCAT_NULL_BEHAVIOR values */

#define SQL_CB_NULL                         0x0000
#define SQL_CB_NON_NULL                     0x0001

/* SQL_SCROLL_OPTIONS masks */

#define SQL_SO_FORWARD_ONLY                 0x00000001L
#define SQL_SO_KEYSET_DRIVEN                0x00000002L
#define SQL_SO_DYNAMIC                      0x00000004L
#define SQL_SO_MIXED                        0x00000008L
#define SQL_SO_STATIC                       0x00000010L

/* SQL_FETCH_DIRECTION masks */

/* SQL_FETCH_RESUME is no longer supported
#define SQL_FD_FETCH_RESUME                 0x00000040L 
*/
#define SQL_FD_FETCH_BOOKMARK               0x00000080L

/* SQL_TXN_ISOLATION_OPTION masks */
/* SQL_TXN_VERSIONING is no longer supported
#define SQL_TXN_VERSIONING                  0x00000010L
*/

/* SQL_CORRELATION_NAME values */

#define SQL_CN_NONE                         0x0000
#define SQL_CN_DIFFERENT                    0x0001
#define SQL_CN_ANY                          0x0002

/* SQL_NON_NULLABLE_COLUMNS values */

#define SQL_NNC_NULL                        0x0000
#define SQL_NNC_NON_NULL                    0x0001

/* SQL_NULL_COLLATION values */

#define SQL_NC_START                        0x0002
#define SQL_NC_END                          0x0004

/* SQL_FILE_USAGE values */

#define SQL_FILE_NOT_SUPPORTED              0x0000
#define SQL_FILE_TABLE                      0x0001
#define SQL_FILE_QUALIFIER                  0x0002
#define SQL_FILE_CATALOG					SQL_FILE_QUALIFIER	// ODBC 3.0


/* SQL_GETDATA_EXTENSIONS values */

#define SQL_GD_BLOCK                        0x00000004L
#define SQL_GD_BOUND                        0x00000008L

/* SQL_POSITIONED_STATEMENTS masks */

#define SQL_PS_POSITIONED_DELETE            0x00000001L
#define SQL_PS_POSITIONED_UPDATE            0x00000002L
#define SQL_PS_SELECT_FOR_UPDATE            0x00000004L

/* SQL_GROUP_BY values */

#define SQL_GB_NOT_SUPPORTED                0x0000
#define SQL_GB_GROUP_BY_EQUALS_SELECT       0x0001
#define SQL_GB_GROUP_BY_CONTAINS_SELECT     0x0002
#define SQL_GB_NO_RELATION                  0x0003
#if (ODBCVER >= 0x0300)
#define	SQL_GB_COLLATE						0x0004

#endif  /* ODBCVER >= 0x0300 */

/* SQL_OWNER_USAGE masks */

#define SQL_OU_DML_STATEMENTS               0x00000001L
#define SQL_OU_PROCEDURE_INVOCATION         0x00000002L
#define SQL_OU_TABLE_DEFINITION             0x00000004L
#define SQL_OU_INDEX_DEFINITION             0x00000008L
#define SQL_OU_PRIVILEGE_DEFINITION         0x00000010L

/* SQL_SCHEMA_USAGE masks */
#if (ODBCVER >= 0x0300)
#define SQL_SU_DML_STATEMENTS			SQL_OU_DML_STATEMENTS 
#define SQL_SU_PROCEDURE_INVOCATION		SQL_OU_PROCEDURE_INVOCATION
#define SQL_SU_TABLE_DEFINITION			SQL_OU_TABLE_DEFINITION
#define SQL_SU_INDEX_DEFINITION			SQL_OU_INDEX_DEFINITION
#define SQL_SU_PRIVILEGE_DEFINITION		SQL_OU_PRIVILEGE_DEFINITION
#endif  /* ODBCVER >= 0x0300 */

/* SQL_QUALIFIER_USAGE masks */

#define SQL_QU_DML_STATEMENTS               0x00000001L
#define SQL_QU_PROCEDURE_INVOCATION         0x00000002L
#define SQL_QU_TABLE_DEFINITION             0x00000004L
#define SQL_QU_INDEX_DEFINITION             0x00000008L
#define SQL_QU_PRIVILEGE_DEFINITION         0x00000010L

#if (ODBCVER >= 0x0300)
/* SQL_CATALOG_USAGE masks */
#define SQL_CU_DML_STATEMENTS			SQL_QU_DML_STATEMENTS
#define SQL_CU_PROCEDURE_INVOCATION		SQL_QU_PROCEDURE_INVOCATION 
#define SQL_CU_TABLE_DEFINITION			SQL_QU_TABLE_DEFINITION
#define SQL_CU_INDEX_DEFINITION			SQL_QU_INDEX_DEFINITION 
#define SQL_CU_PRIVILEGE_DEFINITION		SQL_QU_PRIVILEGE_DEFINITION 
#endif  /* ODBCVER >= 0x0300 */

/* SQL_SUBQUERIES masks */

#define SQL_SQ_COMPARISON                   0x00000001L
#define SQL_SQ_EXISTS                       0x00000002L
#define SQL_SQ_IN                           0x00000004L
#define SQL_SQ_QUANTIFIED                   0x00000008L
#define SQL_SQ_CORRELATED_SUBQUERIES        0x00000010L

/* SQL_UNION masks */

#define SQL_U_UNION                         0x00000001L
#define SQL_U_UNION_ALL                     0x00000002L

/* SQL_BOOKMARK_PERSISTENCE values */

#define SQL_BP_CLOSE                        0x00000001L
#define SQL_BP_DELETE                       0x00000002L
#define SQL_BP_DROP                         0x00000004L
#define SQL_BP_TRANSACTION                  0x00000008L
#define SQL_BP_UPDATE                       0x00000010L
#define SQL_BP_OTHER_HSTMT                  0x00000020L
#define SQL_BP_SCROLL                       0x00000040L

/* SQL_STATIC_SENSITIVITY values */

#define SQL_SS_ADDITIONS                    0x00000001L
#define SQL_SS_DELETIONS                    0x00000002L
#define SQL_SS_UPDATES                      0x00000004L

/* SQL_VIEW values */
#define	SQL_CV_CREATE_VIEW					0x00000001L
#define	SQL_CV_CHECK_OPTION					0x00000002L
#define	SQL_CV_CASCADED						0x00000004L
#define	SQL_CV_LOCAL						0x00000008L

/* SQL_LOCK_TYPES masks */

#define SQL_LCK_NO_CHANGE                   0x00000001L
#define SQL_LCK_EXCLUSIVE                   0x00000002L
#define SQL_LCK_UNLOCK                      0x00000004L

/* SQL_POS_OPERATIONS masks */

#define SQL_POS_POSITION                    0x00000001L
#define SQL_POS_REFRESH                     0x00000002L
#define SQL_POS_UPDATE                      0x00000004L
#define SQL_POS_DELETE                      0x00000008L
#define SQL_POS_ADD                         0x00000010L

/* SQL_QUALIFIER_LOCATION values */

#define SQL_QL_START                        0x0001
#define SQL_QL_END                          0x0002

/* Here start return values for ODBC 3.0 SQLGetInfo */

#if (ODBCVER >= 0x0300)
/* SQL_AGGREGATE_FUNCTIONS bitmasks */
#define SQL_AF_AVG						0x00000001L
#define SQL_AF_COUNT					0x00000002L
#define SQL_AF_MAX						0x00000004L
#define SQL_AF_MIN						0x00000008L
#define SQL_AF_SUM						0x00000010L
#define SQL_AF_DISTINCT					0x00000020L
#define SQL_AF_ALL						0x00000040L	

/* SQL_SQL_CONFORMANCE bit masks */
#define	SQL_SC_SQL92_ENTRY				0x00000001L
#define	SQL_SC_FIPS127_2_TRANSITIONAL	0x00000002L
#define	SQL_SC_SQL92_INTERMEDIATE		0x00000004L
#define	SQL_SC_SQL92_FULL				0x00000008L

/* SQL_DATETIME_LITERALS masks */
#define SQL_DL_SQL92_DATE						0x00000001L
#define SQL_DL_SQL92_TIME						0x00000002L
#define SQL_DL_SQL92_TIMESTAMP					0x00000004L
#define SQL_DL_SQL92_INTERVAL_YEAR				0x00000008L
#define SQL_DL_SQL92_INTERVAL_MONTH				0x00000010L
#define SQL_DL_SQL92_INTERVAL_DAY				0x00000020L
#define SQL_DL_SQL92_INTERVAL_HOUR				0x00000040L
#define	SQL_DL_SQL92_INTERVAL_MINUTE			0x00000080L
#define SQL_DL_SQL92_INTERVAL_SECOND			0x00000100L
#define SQL_DL_SQL92_INTERVAL_YEAR_TO_MONTH		0x00000200L
#define SQL_DL_SQL92_INTERVAL_DAY_TO_HOUR		0x00000400L
#define SQL_DL_SQL92_INTERVAL_DAY_TO_MINUTE		0x00000800L
#define SQL_DL_SQL92_INTERVAL_DAY_TO_SECOND		0x00001000L
#define SQL_DL_SQL92_INTERVAL_HOUR_TO_MINUTE	0x00002000L
#define SQL_DL_SQL92_INTERVAL_HOUR_TO_SECOND	0x00004000L
#define SQL_DL_SQL92_INTERVAL_MINUTE_TO_SECOND	0x00008000L

/* SQL_CATALOG_LOCATION values */
#define SQL_CL_START						SQL_QL_START
#define SQL_CL_END							SQL_QL_END

/* values for SQL_BATCH_ROW_COUNT */
#define SQL_BRC_PROCEDURES			0x0000001
#define	SQL_BRC_EXPLICIT			0x0000002
#define	SQL_BRC_ROLLED_UP			0x0000004

/* bitmasks for SQL_BATCH_SUPPORT */
#define SQL_BS_SELECT_EXPLICIT				0x00000001L
#define SQL_BS_ROW_COUNT_EXPLICIT			0x00000002L
#define SQL_BS_SELECT_PROC					0x00000004L
#define SQL_BS_ROW_COUNT_PROC				0x00000008L

/* Values for SQL_PARAM_ARRAY_ROW_COUNTS getinfo */
#define SQL_PARC_BATCH		1
#define SQL_PARC_NO_BATCH	2

/* values for SQL_PARAM_ARRAY_SELECTS */
#define SQL_PAS_BATCH				1
#define SQL_PAS_NO_BATCH			2		
#define SQL_PAS_NO_SELECT			3

/* Bitmasks for SQL_INDEX_KEYWORDS */
#define SQL_IK_NONE							0x00000000L
#define SQL_IK_ASC							0x00000001L
#define SQL_IK_DESC							0x00000002L
#define SQL_IK_ALL							(SQL_IK_ASC | SQL_IK_DESC)

/* Bitmasks for SQL_INFO_SCHEMA_VIEWS */

#define SQL_ISV_ASSERTIONS					0x00000001L
#define SQL_ISV_CHARACTER_SETS				0x00000002L
#define SQL_ISV_CHECK_CONSTRAINTS			0x00000004L
#define SQL_ISV_COLLATIONS					0x00000008L
#define SQL_ISV_COLUMN_DOMAIN_USAGE			0x00000010L
#define SQL_ISV_COLUMN_PRIVILEGES			0x00000020L
#define SQL_ISV_COLUMNS						0x00000040L
#define SQL_ISV_CONSTRAINT_COLUMN_USAGE		0x00000080L
#define SQL_ISV_CONSTRAINT_TABLE_USAGE		0x00000100L
#define SQL_ISV_DOMAIN_CONSTRAINTS			0x00000200L
#define SQL_ISV_DOMAINS						0x00000400L
#define SQL_ISV_KEY_COLUMN_USAGE			0x00000800L
#define SQL_ISV_REFERENTIAL_CONSTRAINTS		0x00001000L
#define SQL_ISV_SCHEMATA					0x00002000L
#define SQL_ISV_SQL_LANGUAGES				0x00004000L
#define	SQL_ISV_TABLE_CONSTRAINTS			0x00008000L
#define SQL_ISV_TABLE_PRIVILEGES			0x00010000L
#define SQL_ISV_TABLES						0x00020000L
#define SQL_ISV_TRANSLATIONS				0x00040000L
#define SQL_ISV_USAGE_PRIVILEGES			0x00080000L
#define SQL_ISV_VIEW_COLUMN_USAGE			0x00100000L
#define SQL_ISV_VIEW_TABLE_USAGE			0x00200000L
#define SQL_ISV_VIEWS						0x00400000L

/* Bitmasks for SQL_ASYNC_MODE */

#define	SQL_AM_NONE			0
#define	SQL_AM_CONNECTION	1
#define	SQL_AM_STATEMENT	2

/* Bitmasks for SQL_ALTER_DOMAIN */
#define SQL_AD_CONSTRAINT_NAME_DEFINITION			0x00000001L	
#define	SQL_AD_ADD_DOMAIN_CONSTRAINT	 			0x00000002L
#define	SQL_AD_DROP_DOMAIN_CONSTRAINT	 			0x00000004L
#define	SQL_AD_ADD_DOMAIN_DEFAULT   	 			0x00000008L
#define	SQL_AD_DROP_DOMAIN_DEFAULT   	 			0x00000010L
#define SQL_AD_ADD_CONSTRAINT_INITIALLY_DEFERRED	0x00000020L
#define SQL_AD_ADD_CONSTRAINT_INITIALLY_IMMEDIATE	0x00000040L
#define SQL_AD_ADD_CONSTRAINT_DEFERRABLE			0x00000080L
#define SQL_AD_ADD_CONSTRAINT_NON_DEFERRABLE		0x00000100L


/* SQL_CREATE_SCHEMA bitmasks */
#define	SQL_CS_CREATE_SCHEMA				0x00000001L
#define	SQL_CS_AUTHORIZATION				0x00000002L
#define	SQL_CS_DEFAULT_CHARACTER_SET		0x00000004L

/* SQL_CREATE_TRANSLATION bitmasks */
#define	SQL_CTR_CREATE_TRANSLATION			0x00000001L

/* SQL_CREATE_ASSERTION bitmasks */
#define	SQL_CA_CREATE_ASSERTION					0x00000001L
#define	SQL_CA_CONSTRAINT_INITIALLY_DEFERRED	0x00000010L
#define	SQL_CA_CONSTRAINT_INITIALLY_IMMEDIATE	0x00000020L
#define	SQL_CA_CONSTRAINT_DEFERRABLE			0x00000040L
#define	SQL_CA_CONSTRAINT_NON_DEFERRABLE		0x00000080L

/* SQL_CREATE_CHARACTER_SET bitmasks */
#define	SQL_CCS_CREATE_CHARACTER_SET		0x00000001L
#define	SQL_CCS_COLLATE_CLAUSE				0x00000002L
#define	SQL_CCS_LIMITED_COLLATION			0x00000004L

/* SQL_CREATE_COLLATION bitmasks */
#define	SQL_CCOL_CREATE_COLLATION			0x00000001L

/* SQL_CREATE_DOMAIN bitmasks */
#define	SQL_CDO_CREATE_DOMAIN					0x00000001L
#define	SQL_CDO_DEFAULT							0x00000002L
#define	SQL_CDO_CONSTRAINT						0x00000004L
#define	SQL_CDO_COLLATION						0x00000008L
#define SQL_CDO_CONSTRAINT_NAME_DEFINITION		0x00000010L
#define SQL_CDO_CONSTRAINT_INITIALLY_DEFERRED	0x00000020L
#define SQL_CDO_CONSTRAINT_INITIALLY_IMMEDIATE	0x00000040L
#define SQL_CDO_CONSTRAINT_DEFERRABLE			0x00000080L
#define SQL_CDO_CONSTRAINT_NON_DEFERRABLE		0x00000100L

/* SQL_CREATE_TABLE bitmasks */
#define	SQL_CT_CREATE_TABLE						0x00000001L
#define	SQL_CT_COMMIT_PRESERVE					0x00000002L
#define	SQL_CT_COMMIT_DELETE					0x00000004L
#define	SQL_CT_GLOBAL_TEMPORARY					0x00000008L
#define	SQL_CT_LOCAL_TEMPORARY					0x00000010L
#define	SQL_CT_CONSTRAINT_INITIALLY_DEFERRED	0x00000020L
#define	SQL_CT_CONSTRAINT_INITIALLY_IMMEDIATE	0x00000040L
#define	SQL_CT_CONSTRAINT_DEFERRABLE			0x00000080L
#define	SQL_CT_CONSTRAINT_NON_DEFERRABLE		0x00000100L
#define SQL_CT_COLUMN_CONSTRAINT				0x00000200L
#define SQL_CT_COLUMN_DEFAULT					0x00000400L
#define SQL_CT_COLUMN_COLLATION					0x00000800L
#define SQL_CT_TABLE_CONSTRAINT					0x00001000L
#define SQL_CT_CONSTRAINT_NAME_DEFINITION		0x00002000L

/* SQL_DDL_INDEX bitmasks */
#define SQL_DI_CREATE_INDEX						0x00000001L
#define SQL_DI_DROP_INDEX						0x00000002L

/* SQL_DROP_COLLATION bitmasks */
#define	SQL_DC_DROP_COLLATION					0x00000001L

/* SQL_DROP_DOMAIN bitmasks */
#define	SQL_DD_DROP_DOMAIN						0x00000001L
#define	SQL_DD_RESTRICT							0x00000002L
#define	SQL_DD_CASCADE							0x00000004L

/* SQL_DROP_SCHEMA bitmasks */
#define	SQL_DS_DROP_SCHEMA						0x00000001L
#define SQL_DS_RESTRICT							0x00000002L
#define	SQL_DS_CASCADE							0x00000004L

/* SQL_DROP_CHARACTER_SET bitmasks */
#define	SQL_DCS_DROP_CHARACTER_SET				0x00000001L

/* SQL_DROP_ASSERTION bitmasks */
#define	SQL_DA_DROP_ASSERTION					0x00000001L

/* SQL_DROP_TABLE bitmasks */
#define	SQL_DT_DROP_TABLE						0x00000001L
#define	SQL_DT_RESTRICT							0x00000002L
#define	SQL_DT_CASCADE							0x00000004L

/* SQL_DROP_TRANSLATION bitmasks */
#define	SQL_DTR_DROP_TRANSLATION				0x00000001L

/* SQL_DROP_VIEW bitmasks */
#define	SQL_DV_DROP_VIEW						0x00000001L
#define	SQL_DV_RESTRICT							0x00000002L
#define	SQL_DV_CASCADE							0x00000004L

/* SQL_INSERT_STATEMENT bitmasks */
#define	SQL_IS_INSERT_LITERALS					0x00000001L
#define SQL_IS_INSERT_SEARCHED					0x00000002L
#define SQL_IS_SELECT_INTO						0x00000004L

/* SQL_ODBC_INTERFACE_CONFORMANCE values */
#define SQL_OIC_CORE							1UL
#define SQL_OIC_LEVEL1							2UL
#define SQL_OIC_LEVEL2							3UL

/* SQL_SQL92_FOREIGN_KEY_DELETE_RULE bitmasks */
#define SQL_SFKD_CASCADE						0x00000001L
#define SQL_SFKD_NO_ACTION						0x00000002L
#define SQL_SFKD_SET_DEFAULT					0x00000004L
#define SQL_SFKD_SET_NULL						0x00000008L

/* SQL_SQL92_FOREIGN_KEY_UPDATE_RULE bitmasks */
#define SQL_SFKU_CASCADE						0x00000001L
#define SQL_SFKU_NO_ACTION						0x00000002L
#define SQL_SFKU_SET_DEFAULT					0x00000004L
#define SQL_SFKU_SET_NULL						0x00000008L

/* SQL_SQL92_GRANT	bitmasks */
#define SQL_SG_USAGE_ON_DOMAIN					0x00000001L
#define SQL_SG_USAGE_ON_CHARACTER_SET			0x00000002L
#define SQL_SG_USAGE_ON_COLLATION				0x00000004L
#define SQL_SG_USAGE_ON_TRANSLATION				0x00000008L
#define SQL_SG_WITH_GRANT_OPTION				0x00000010L
#define SQL_SG_DELETE_TABLE						0x00000020L
#define SQL_SG_INSERT_TABLE						0x00000040L
#define SQL_SG_INSERT_COLUMN					0x00000080L
#define SQL_SG_REFERENCES_TABLE					0x00000100L
#define SQL_SG_REFERENCES_COLUMN				0x00000200L
#define SQL_SG_SELECT_TABLE						0x00000400L
#define SQL_SG_UPDATE_TABLE						0x00000800L
#define SQL_SG_UPDATE_COLUMN					0x00001000L	

/* SQL_SQL92_PREDICATES bitmasks */
#define SQL_SP_EXISTS							0x00000001L
#define SQL_SP_ISNOTNULL						0x00000002L
#define SQL_SP_ISNULL							0x00000004L
#define SQL_SP_MATCH_FULL						0x00000008L
#define SQL_SP_MATCH_PARTIAL					0x00000010L
#define SQL_SP_MATCH_UNIQUE_FULL				0x00000020L
#define SQL_SP_MATCH_UNIQUE_PARTIAL				0x00000040L
#define SQL_SP_OVERLAPS							0x00000080L
#define SQL_SP_UNIQUE							0x00000100L
#define SQL_SP_LIKE								0x00000200L
#define SQL_SP_IN								0x00000400L
#define SQL_SP_BETWEEN							0x00000800L
#define SQL_SP_COMPARISON						0x00001000L
#define SQL_SP_QUANTIFIED_COMPARISON			0x00002000L

/* SQL_SQL92_RELATIONAL_JOIN_OPERATORS bitmasks */
#define SQL_SRJO_CORRESPONDING_CLAUSE			0x00000001L
#define SQL_SRJO_CROSS_JOIN						0x00000002L
#define SQL_SRJO_EXCEPT_JOIN					0x00000004L
#define SQL_SRJO_FULL_OUTER_JOIN				0x00000008L
#define SQL_SRJO_INNER_JOIN						0x00000010L
#define SQL_SRJO_INTERSECT_JOIN					0x00000020L
#define SQL_SRJO_LEFT_OUTER_JOIN				0x00000040L
#define SQL_SRJO_NATURAL_JOIN					0x00000080L
#define SQL_SRJO_RIGHT_OUTER_JOIN				0x00000100L
#define SQL_SRJO_UNION_JOIN						0x00000200L

/* SQL_SQL92_REVOKE bitmasks */
#define SQL_SR_USAGE_ON_DOMAIN					0x00000001L
#define SQL_SR_USAGE_ON_CHARACTER_SET			0x00000002L
#define SQL_SR_USAGE_ON_COLLATION				0x00000004L
#define SQL_SR_USAGE_ON_TRANSLATION				0x00000008L
#define SQL_SR_GRANT_OPTION_FOR					0x00000010L
#define SQL_SR_CASCADE							0x00000020L
#define SQL_SR_RESTRICT							0x00000040L
#define SQL_SR_DELETE_TABLE						0x00000080L
#define SQL_SR_INSERT_TABLE						0x00000100L
#define SQL_SR_INSERT_COLUMN					0x00000200L
#define SQL_SR_REFERENCES_TABLE					0x00000400L
#define SQL_SR_REFERENCES_COLUMN				0x00000800L
#define SQL_SR_SELECT_TABLE						0x00001000L
#define SQL_SR_UPDATE_TABLE						0x00002000L
#define SQL_SR_UPDATE_COLUMN					0x00004000L

/* SQL_SQL92_ROW_VALUE_CONSTRUCTOR bitmasks */
#define SQL_SRVC_VALUE_EXPRESSION				0x00000001L
#define SQL_SRVC_NULL							0x00000002L
#define SQL_SRVC_DEFAULT						0x00000004L
#define SQL_SRVC_ROW_SUBQUERY					0x00000008L

/* SQL_SQL92_VALUE_EXPRESSIONS bitmasks */
#define SQL_SVE_CASE							0x00000001L
#define SQL_SVE_CAST							0x00000002L
#define SQL_SVE_COALESCE						0x00000004L
#define SQL_SVE_NULLIF							0x00000008L

/* SQL_STANDARD_CLI_CONFORMANCE bitmasks */
#define SQL_SCC_XOPEN_CLI_VERSION1				0x00000001L
#define SQL_SCC_ISO92_CLI						0x00000002L

/* SQL_UNION_STATEMENT bitmasks */
#define SQL_US_UNION							SQL_U_UNION
#define SQL_US_UNION_ALL						SQL_U_UNION_ALL

#endif  /* ODBCVER >= 0x0300 */

/* SQL_DTC_TRANSITION_COST bitmasks */
#define SQL_DTC_ENLIST_EXPENSIVE				0x00000001L
#define SQL_DTC_UNENLIST_EXPENSIVE				0x00000002L

/* additional SQLDataSources fetch directions */
#if (ODBCVER >= 0x0300)
#define SQL_FETCH_FIRST_USER				31
#define SQL_FETCH_FIRST_SYSTEM				32
#endif  /* ODBCVER >= 0x0300 */


/* Defines for SQLSetPos */
#define SQL_ENTIRE_ROWSET            0

/* Operations in SQLSetPos */
#define SQL_POSITION                 0               /*      1.0 FALSE */
#define SQL_REFRESH                  1               /*      1.0 TRUE */
#define SQL_UPDATE                   2
#define SQL_DELETE                   3

/* Operations in SQLBulkOperations */
#define SQL_ADD                      4
#define	SQL_SETPOS_MAX_OPTION_VALUE			SQL_ADD
#if (ODBCVER >= 0x0300)
#define SQL_UPDATE_BY_BOOKMARK		 5
#define SQL_DELETE_BY_BOOKMARK		 6
#define	SQL_FETCH_BY_BOOKMARK		 7

#endif /*  ODBCVER >= 0x0300 */

/* Lock options in SQLSetPos */
#define SQL_LOCK_NO_CHANGE           0               /*      1.0 FALSE */
#define SQL_LOCK_EXCLUSIVE           1               /*      1.0 TRUE */
#define SQL_LOCK_UNLOCK              2

#define	SQL_SETPOS_MAX_LOCK_VALUE		SQL_LOCK_UNLOCK

/* Macros for SQLSetPos */
#define SQL_POSITION_TO(hstmt,irow) SQLSetPos(hstmt,irow,SQL_POSITION,SQL_LOCK_NO_CHANGE)
#define SQL_LOCK_RECORD(hstmt,irow,fLock) SQLSetPos(hstmt,irow,SQL_POSITION,fLock)
#define SQL_REFRESH_RECORD(hstmt,irow,fLock) SQLSetPos(hstmt,irow,SQL_REFRESH,fLock)
#define SQL_UPDATE_RECORD(hstmt,irow) SQLSetPos(hstmt,irow,SQL_UPDATE,SQL_LOCK_NO_CHANGE)
#define SQL_DELETE_RECORD(hstmt,irow) SQLSetPos(hstmt,irow,SQL_DELETE,SQL_LOCK_NO_CHANGE)
#define SQL_ADD_RECORD(hstmt,irow) SQLSetPos(hstmt,irow,SQL_ADD,SQL_LOCK_NO_CHANGE)

/* Column types and scopes in SQLSpecialColumns.  */
#define SQL_BEST_ROWID                  1
#define SQL_ROWVER                      2

/* Defines for SQLSpecialColumns (returned in the result set) 
   SQL_PC_UNKNOWN and SQL_PC_PSEUDO are defined in sql.h */
#define SQL_PC_NOT_PSEUDO               1

/* Defines for SQLStatistics */
#define SQL_QUICK                       0
#define SQL_ENSURE                      1

/* Defines for SQLStatistics (returned in the result set) 
   SQL_INDEX_CLUSTERED, SQL_INDEX_HASHED, and SQL_INDEX_OTHER are
   defined in sql.h */
#define SQL_TABLE_STAT                  0


/* Defines for SQLTables */
#if (ODBCVER >= 0x0300)
#define SQL_ALL_CATALOGS				"%"
#define SQL_ALL_SCHEMAS					"%"
#define SQL_ALL_TABLE_TYPES				"%"
#endif  /* ODBCVER >= 0x0300 */

/* Options for SQLDriverConnect */
#define SQL_DRIVER_NOPROMPT             0
#define SQL_DRIVER_COMPLETE             1
#define SQL_DRIVER_PROMPT               2
#define SQL_DRIVER_COMPLETE_REQUIRED    3

#ifndef RC_INVOKED

SQLRETURN SQL_API SQLDriverConnect(
    SQLHDBC            hdbc,
    SQLHWND            hwnd,
    SQLCHAR 		  *szConnStrIn,
    SQLSMALLINT        cbConnStrIn,
    SQLCHAR           *szConnStrOut,
    SQLSMALLINT        cbConnStrOutMax,
    SQLSMALLINT 	  *pcbConnStrOut,
    SQLUSMALLINT       fDriverCompletion)

{return 0;}

#endif /* RC_INVOKED */

/* Level 2 Functions                             */

/* SQLExtendedFetch "fFetchType" values */
#define SQL_FETCH_BOOKMARK               8

/* SQLExtendedFetch "rgfRowStatus" element values */
#define SQL_ROW_SUCCESS                  0
#define SQL_ROW_DELETED                  1
#define SQL_ROW_UPDATED                  2
#define SQL_ROW_NOROW                    3
#define SQL_ROW_ADDED                    4
#define SQL_ROW_ERROR                    5
#if (ODBCVER >= 0x0300)
#define SQL_ROW_SUCCESS_WITH_INFO		 6
#define SQL_ROW_PROCEED					 0
#define SQL_ROW_IGNORE					 1
#endif

/* value for SQL_DESC_ARRAY_STATUS_PTR */
#if (ODBCVER >= 0x0300)
#define SQL_PARAM_SUCCESS				0
#define SQL_PARAM_SUCCESS_WITH_INFO		6
#define SQL_PARAM_ERROR					5
#define SQL_PARAM_UNUSED				7
#define SQL_PARAM_DIAG_UNAVAILABLE		1

#define SQL_PARAM_PROCEED				0
#define SQL_PARAM_IGNORE				1
#endif  /* ODBCVER >= 0x0300 */

/* Defines for SQLForeignKeys (UPDATE_RULE and DELETE_RULE) */
#define SQL_CASCADE                      0
#define SQL_RESTRICT                     1
#define SQL_SET_NULL                     2
#if (ODBCVER >= 0x0250)
#define SQL_NO_ACTION			 3
#define SQL_SET_DEFAULT			 4
#endif  /* ODBCVER >= 0x0250 */

#if (ODBCVER >= 0x0300)
/* Note that the following are in a different column of SQLForeignKeys than */
/* the previous #defines.   These are for DEFERRABILITY.                    */

#define SQL_INITIALLY_DEFERRED			5
#define SQL_INITIALLY_IMMEDIATE			6
#define SQL_NOT_DEFERRABLE			7

#endif  /* ODBCVER >= 0x0300 */

/* Defines for SQLBindParameter and
                           SQLProcedureColumns (returned in the result set) */
#define SQL_PARAM_TYPE_UNKNOWN           0
#define SQL_PARAM_INPUT                  1
#define SQL_PARAM_INPUT_OUTPUT           2
#define SQL_RESULT_COL                   3
#define SQL_PARAM_OUTPUT                 4
#define SQL_RETURN_VALUE                 5

/* Defines for SQLProcedures (returned in the result set) */
#define SQL_PT_UNKNOWN                   0
#define SQL_PT_PROCEDURE                 1
#define SQL_PT_FUNCTION                  2

#ifndef RC_INVOKED

/*      This define is too large for RC */
#define SQL_ODBC_KEYWORDS \
"ABSOLUTE,ACTION,ADA,ADD,ALL,ALLOCATE,ALTER,AND,ANY,ARE,AS,"\
"ASC,ASSERTION,AT,AUTHORIZATION,AVG,"\
"BEGIN,BETWEEN,BIT,BIT_LENGTH,BOTH,BY,CASCADE,CASCADED,CASE,CAST,CATALOG,"\
"CHAR,CHAR_LENGTH,CHARACTER,CHARACTER_LENGTH,CHECK,CLOSE,COALESCE,"\
"COLLATE,COLLATION,COLUMN,COMMIT,CONNECT,CONNECTION,CONSTRAINT,"\
"CONSTRAINTS,CONTINUE,CONVERT,CORRESPONDING,COUNT,CREATE,CROSS,CURRENT,"\
"CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,CURRENT_USER,CURSOR,"\
"DATE,DAY,DEALLOCATE,DEC,DECIMAL,DECLARE,DEFAULT,DEFERRABLE,"\
"DEFERRED,DELETE,DESC,DESCRIBE,DESCRIPTOR,DIAGNOSTICS,DISCONNECT,"\
"DISTINCT,DOMAIN,DOUBLE,DROP,"\
"ELSE,END,END-EXEC,ESCAPE,EXCEPT,EXCEPTION,EXEC,EXECUTE,"\
"EXISTS,EXTERNAL,EXTRACT,"\
"FALSE,FETCH,FIRST,FLOAT,FOR,FOREIGN,FORTRAN,FOUND,FROM,FULL,"\
"GET,GLOBAL,GO,GOTO,GRANT,GROUP,HAVING,HOUR,"\
"IDENTITY,IMMEDIATE,IN,INCLUDE,INDEX,INDICATOR,INITIALLY,INNER,"\
"INPUT,INSENSITIVE,INSERT,INT,INTEGER,INTERSECT,INTERVAL,INTO,IS,ISOLATION,"\
"JOIN,KEY,LANGUAGE,LAST,LEADING,LEFT,LEVEL,LIKE,LOCAL,LOWER,"\
"MATCH,MAX,MIN,MINUTE,MODULE,MONTH,"\
"NAMES,NATIONAL,NATURAL,NCHAR,NEXT,NO,NONE,NOT,NULL,NULLIF,NUMERIC,"\
"OCTET_LENGTH,OF,ON,ONLY,OPEN,OPTION,OR,ORDER,OUTER,OUTPUT,OVERLAPS,"\
"PAD,PARTIAL,PASCAL,PLI,POSITION,PRECISION,PREPARE,PRESERVE,"\
"PRIMARY,PRIOR,PRIVILEGES,PROCEDURE,PUBLIC,"\
"READ,REAL,REFERENCES,RELATIVE,RESTRICT,REVOKE,RIGHT,ROLLBACK,ROWS"\
"SCHEMA,SCROLL,SECOND,SECTION,SELECT,SESSION,SESSION_USER,SET,SIZE,"\
"SMALLINT,SOME,SPACE,SQL,SQLCA,SQLCODE,SQLERROR,SQLSTATE,SQLWARNING,"\
"SUBSTRING,SUM,SYSTEM_USER,"\
"TABLE,TEMPORARY,THEN,TIME,TIMESTAMP,TIMEZONE_HOUR,TIMEZONE_MINUTE,"\
"TO,TRAILING,TRANSACTION,TRANSLATE,TRANSLATION,TRIM,TRUE,"\
"UNION,UNIQUE,UNKNOWN,UPDATE,UPPER,USAGE,USER,USING,"\
"VALUE,VALUES,VARCHAR,VARYING,VIEW,WHEN,WHENEVER,WHERE,WITH,WORK,WRITE,"\
"YEAR,ZONE"

SQLRETURN SQL_API SQLBrowseConnect(
    SQLHDBC            hdbc,
    SQLCHAR 		  *szConnStrIn,
    SQLSMALLINT        cbConnStrIn,
    SQLCHAR 		  *szConnStrOut,
    SQLSMALLINT        cbConnStrOutMax,
    SQLSMALLINT       *pcbConnStrOut)

{return 0;}

#if (ODBCVER >= 0x0300)
SQLRETURN	SQL_API	SQLBulkOperations(
	SQLHSTMT			StatementHandle,
	SQLSMALLINT			Operation)

{return 0;}
#endif  /* ODBCVER >= 0x0300 */

SQLRETURN SQL_API SQLColAttributes(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       icol,
    SQLUSMALLINT       fDescType,
    SQLPOINTER         rgbDesc,
    SQLSMALLINT        cbDescMax,
    SQLSMALLINT 	  *pcbDesc,
    SQLLEN 		      * pfDesc)

{return 0;}

SQLRETURN SQL_API SQLColumnPrivileges(
    SQLHSTMT           hstmt,
    SQLCHAR 		  *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR 		  *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR 		  *szTableName,
    SQLSMALLINT        cbTableName,
    SQLCHAR 		  *szColumnName,
    SQLSMALLINT        cbColumnName)

{return 0;}

SQLRETURN SQL_API SQLDescribeParam(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       ipar,
    SQLSMALLINT 	  *pfSqlType,
    SQLULEN      	  *pcbParamDef,
    SQLSMALLINT 	  *pibScale,
    SQLSMALLINT 	  *pfNullable)

{return 0;}

SQLRETURN SQL_API SQLExtendedFetch(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       fFetchType,
    SQLROWOFFSET       irow,
    SQLROWSETSIZE	  *pcrow,
    SQLUSMALLINT 	  *rgfRowStatus)

{return 0;}

SQLRETURN SQL_API SQLForeignKeys(
    SQLHSTMT           hstmt,
    SQLCHAR 		  *szPkCatalogName,
    SQLSMALLINT        cbPkCatalogName,
    SQLCHAR 		  *szPkSchemaName,
    SQLSMALLINT        cbPkSchemaName,
    SQLCHAR 		  *szPkTableName,
    SQLSMALLINT        cbPkTableName,
    SQLCHAR 		  *szFkCatalogName,
    SQLSMALLINT        cbFkCatalogName,
    SQLCHAR 		  *szFkSchemaName,
    SQLSMALLINT        cbFkSchemaName,
    SQLCHAR 		  *szFkTableName,
    SQLSMALLINT        cbFkTableName)

{return 0;}

SQLRETURN SQL_API SQLMoreResults(
    SQLHSTMT           hstmt)

{return 0;}

SQLRETURN SQL_API SQLNativeSql(
    SQLHDBC            hdbc,
    SQLCHAR 		  *szSqlStrIn,
    SQLINTEGER         cbSqlStrIn,
    SQLCHAR 		  *szSqlStr,
    SQLINTEGER         cbSqlStrMax,
    SQLINTEGER 		  *pcbSqlStr)

{return 0;}

SQLRETURN SQL_API SQLNumParams(
    SQLHSTMT           hstmt,
    SQLSMALLINT 	  *pcpar)

{return 0;}

SQLRETURN SQL_API SQLParamOptions(
    SQLHSTMT           hstmt,
    SQLROWSETSIZE      crow,
    SQLROWSETSIZE  	  *pirow)

{return 0;}

SQLRETURN SQL_API SQLPrimaryKeys(
    SQLHSTMT           hstmt,
    SQLCHAR 		  *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR 		  *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR 		  *szTableName,
    SQLSMALLINT        cbTableName)

{return 0;}

SQLRETURN SQL_API SQLProcedureColumns(
    SQLHSTMT           hstmt,
    SQLCHAR 		  *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR 		  *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR 		  *szProcName,
    SQLSMALLINT        cbProcName,
    SQLCHAR 		  *szColumnName,
    SQLSMALLINT        cbColumnName)

{return 0;}

SQLRETURN SQL_API SQLProcedures(
    SQLHSTMT           hstmt,
    SQLCHAR 		  *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR 		  *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR 		  *szProcName,
    SQLSMALLINT        cbProcName)

{return 0;}

SQLRETURN SQL_API SQLSetPos(
    SQLHSTMT           hstmt,
    SQLSETPOSIROW      irow,
    SQLUSMALLINT       fOption,
    SQLUSMALLINT       fLock)

{return 0;}

SQLRETURN SQL_API SQLTablePrivileges(
    SQLHSTMT           hstmt,
    SQLCHAR 		  *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR 		  *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR 		  *szTableName,
    SQLSMALLINT        cbTableName)

{return 0;}

SQLRETURN SQL_API SQLDrivers(
    SQLHENV            henv,
    SQLUSMALLINT       fDirection,
    SQLCHAR 		  *szDriverDesc,
    SQLSMALLINT        cbDriverDescMax,
    SQLSMALLINT 	  *pcbDriverDesc,
    SQLCHAR 		  *szDriverAttributes,
    SQLSMALLINT        cbDrvrAttrMax,
    SQLSMALLINT 	  *pcbDrvrAttr)

{return 0;}

SQLRETURN SQL_API SQLBindParameter(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       ipar,
    SQLSMALLINT        fParamType,
    SQLSMALLINT        fCType,
    SQLSMALLINT        fSqlType,
    SQLULEN            cbColDef,
    SQLSMALLINT        ibScale,
    SQLPOINTER         rgbValue,
    SQLLEN             cbValueMax,
    SQLLEN     		   *pcbValue)

{return 0;}

#endif /* RC_INVOKED */

/*---------------------------------------------------------*/
/* SQLAllocHandleStd is implemented to make SQLAllocHandle */
/* compatible with X/Open standard.	 an application should */
/* not call SQLAllocHandleStd directly					   */ 
/*---------------------------------------------------------*/
#ifdef ODBC_STD
#define SQLAllocHandle  SQLAllocHandleStd
#define SQLAllocEnv(phenv)  SQLAllocHandleStd(SQL_HANDLE_ENV, SQL_NULL_HANDLE, phenv)

/* Internal type subcodes */
#define SQL_YEAR						SQL_CODE_YEAR
#define SQL_MONTH						SQL_CODE_MONTH
#define SQL_DAY							SQL_CODE_DAY
#define SQL_HOUR						SQL_CODE_HOUR
#define SQL_MINUTE						SQL_CODE_MINUTE
#define SQL_SECOND						SQL_CODE_SECOND	
#define SQL_YEAR_TO_MONTH				SQL_CODE_YEAR_TO_MONTH
#define SQL_DAY_TO_HOUR					SQL_CODE_DAY_TO_HOUR
#define SQL_DAY_TO_MINUTE				SQL_CODE_DAY_TO_MINUTE
#define SQL_DAY_TO_SECOND				SQL_CODE_DAY_TO_SECOND
#define SQL_HOUR_TO_MINUTE				SQL_CODE_HOUR_TO_MINUTE	
#define SQL_HOUR_TO_SECOND				SQL_CODE_HOUR_TO_SECOND
#define SQL_MINUTE_TO_SECOND			SQL_CODE_MINUTE_TO_SECOND
#endif /* ODBC_STD */

#if (ODBCVER >= 0x0300)
#ifndef RC_INVOKED
SQLRETURN SQL_API SQLAllocHandleStd(
	SQLSMALLINT		fHandleType,
	SQLHANDLE		hInput,
	SQLHANDLE	   *phOutput)

{return 0;}
#endif /* RC_INVOKED */
#endif

/*      Deprecated defines from prior versions of ODBC */
#define SQL_DATABASE_NAME               16    /* Use SQLGetConnectOption/SQL_CURRENT_QUALIFIER */
#define SQL_FD_FETCH_PREV               SQL_FD_FETCH_PRIOR
#define SQL_FETCH_PREV                  SQL_FETCH_PRIOR
#define SQL_CONCUR_TIMESTAMP            SQL_CONCUR_ROWVER
#define SQL_SCCO_OPT_TIMESTAMP          SQL_SCCO_OPT_ROWVER
#define SQL_CC_DELETE                   SQL_CB_DELETE
#define SQL_CR_DELETE                   SQL_CB_DELETE
#define SQL_CC_CLOSE                    SQL_CB_CLOSE
#define SQL_CR_CLOSE                    SQL_CB_CLOSE
#define SQL_CC_PRESERVE                 SQL_CB_PRESERVE
#define SQL_CR_PRESERVE                 SQL_CB_PRESERVE
/* SQL_FETCH_RESUME is not supported by 2.0+ drivers 
#define SQL_FETCH_RESUME                7    
*/
#define SQL_SCROLL_FORWARD_ONLY         0L    /*-SQL_CURSOR_FORWARD_ONLY */
#define SQL_SCROLL_KEYSET_DRIVEN        (-1L) /*-SQL_CURSOR_KEYSET_DRIVEN */
#define SQL_SCROLL_DYNAMIC              (-2L) /*-SQL_CURSOR_DYNAMIC */
#define SQL_SCROLL_STATIC               (-3L) /*-SQL_CURSOR_STATIC */

/*      Deprecated functions from prior versions of ODBC */
#ifndef RC_INVOKED

SQLRETURN SQL_API SQLSetScrollOptions(    /*      Use SQLSetStmtOptions */
    SQLHSTMT           hstmt,
    SQLUSMALLINT       fConcurrency,
    SQLLEN             crowKeyset,
    SQLUSMALLINT       crowRowset)

{return 0;}

/* Tracing section */

#define		TRACE_VERSION	1000		/* Version of trace API */

RETCODE	SQL_API TraceOpenLogFile(LPWSTR,LPWSTR,DWORD)

{return 0;}

RETCODE	SQL_API TraceCloseLogFile()

{return 0;}

VOID	SQL_API TraceReturn(RETCODE,RETCODE)

{return;}

DWORD	SQL_API TraceVersion()

{return 0;}

/* Functions for Visual Studio Analyzer*/
/* to turn on/off tracing or VS events, call TraceVSControl by setting or clearing the following bits  */
#define TRACE_ON			0x00000001L
#define TRACE_VS_EVENT_ON	0x00000002L	

RETCODE	SQL_API	TraceVSControl(DWORD)

{return 0;}

/* Functions for setting the connection pooling failure detection code */
/* The "TryWait" value is the time (in seconds) that the DM will wait  */
/* between detecting that a connection is dead (using                  */
/* SQL_ATTR_CONNECTION_DEAD) and retrying the connection.  During that */
/* interval, connection requests will get "The server appears to be    */
/* dead" error returns.                                                */ 


BOOL SQL_API    ODBCSetTryWaitValue(DWORD dwValue)

{return 0;}

DWORD SQL_API	ODBCGetTryWaitValue()

{return 0;}

/* the flags in ODBC_VS_ARGS */
#define ODBC_VS_FLAG_UNICODE_ARG	0x00000001L	/* the argument is unicode */
#define	ODBC_VS_FLAG_UNICODE_COR	0x00000002L	/* the correlation is unicode */
#define ODBC_VS_FLAG_RETCODE		0x00000004L	/* RetCode field is set */
#define ODBC_VS_FLAG_STOP		0x00000008L	/* Stop firing visual studio analyzer events */

typedef struct tagODBC_VS_ARGS {
	const GUID	*pguidEvent;	/* the GUID for event */
	DWORD	dwFlags;		/* flags for the call */
	union {
		WCHAR	*wszArg;	
		CHAR	*szArg;
	};
	union {
		WCHAR	*wszCorrelation;
		CHAR	*szCorrelation;
	};				
	RETCODE	RetCode;
} ODBC_VS_ARGS, *PODBC_VS_ARGS;

VOID	SQL_API	FireVSDebugEvent(PODBC_VS_ARGS)

{return;}

#endif /* RC_INVOKED */

#ifdef __cplusplus
}                                     /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\odbc32\odbc32.cpp ===
#include "windows.h"

#ifdef __cplusplus
extern "C" { 			/* Assume C declarations for C++   */
#endif  /* __cplusplus */

#include <sqlext.h>

#define SQL_WCHAR		 	(-8)
#define SQL_WVARCHAR	 	(-9)
#define SQL_WLONGVARCHAR 	(-10)
#define SQL_C_WCHAR			SQL_WCHAR

#ifdef UNICODE
#define SQL_C_TCHAR		SQL_C_WCHAR
#else
#define SQL_C_TCHAR		SQL_C_CHAR
#endif 

#define SQL_SQLSTATE_SIZEW	10	/* size of SQLSTATE for unicode */

#ifndef RC_INVOKED

// UNICODE versions

SQLRETURN SQL_API SQLColAttributeW(
	SQLHSTMT		hstmt,
	SQLUSMALLINT	iCol,
	SQLUSMALLINT	iField,
	SQLPOINTER		pCharAttr,
	SQLSMALLINT		cbCharAttrMax,	
	SQLSMALLINT  *pcbCharAttr,
	SQLPOINTER		pNumAttr)

{return 0;}	

SQLRETURN SQL_API SQLColAttributesW(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       icol,
    SQLUSMALLINT       fDescType,
    SQLPOINTER         rgbDesc,
    SQLSMALLINT        cbDescMax,
    SQLSMALLINT    *pcbDesc,
    SQLLEN         *pfDesc)

{return 0;}

SQLRETURN SQL_API SQLConnectW(
    SQLHDBC            hdbc,
    SQLWCHAR        *szDSN,
    SQLSMALLINT        cbDSN,
    SQLWCHAR        *szUID,
    SQLSMALLINT        cbUID,
    SQLWCHAR        *szAuthStr,
    SQLSMALLINT        cbAuthStr)

{return 0;}

SQLRETURN SQL_API SQLDescribeColW(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       icol,
    SQLWCHAR        *szColName,
    SQLSMALLINT        cbColNameMax,
    SQLSMALLINT    *pcbColName,
    SQLSMALLINT    *pfSqlType,
    SQLULEN       *pcbColDef,
    SQLSMALLINT    *pibScale,
    SQLSMALLINT    *pfNullable)

{return 0;}

SQLRETURN SQL_API SQLErrorW(
    SQLHENV            henv,
    SQLHDBC            hdbc,
    SQLHSTMT           hstmt,
    SQLWCHAR        *szSqlState,
    SQLINTEGER     *pfNativeError,
    SQLWCHAR        *szErrorMsg,
    SQLSMALLINT        cbErrorMsgMax,
    SQLSMALLINT    *pcbErrorMsg)

{return 0;}

SQLRETURN SQL_API SQLExecDirectW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szSqlStr,
    SQLINTEGER         cbSqlStr)

{return 0;}

SQLRETURN SQL_API SQLGetConnectAttrW(
    SQLHDBC            hdbc,
    SQLINTEGER         fAttribute,
    SQLPOINTER         rgbValue,
    SQLINTEGER         cbValueMax,
    SQLINTEGER     *pcbValue)

{return 0;}

SQLRETURN SQL_API SQLGetCursorNameW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szCursor,
    SQLSMALLINT        cbCursorMax,
    SQLSMALLINT    *pcbCursor)

{return 0;}

#if (ODBCVER >= 0x0300)

SQLRETURN  SQL_API SQLSetDescFieldA(SQLHDESC DescriptorHandle,
           						   SQLSMALLINT RecNumber, 
								   SQLSMALLINT FieldIdentifier,
           						   SQLPOINTER Value, 
								   SQLINTEGER BufferLength)

{return 0;}

SQLRETURN  SQL_API SQLSetDescFieldW(SQLHDESC DescriptorHandle,
           						   SQLSMALLINT RecNumber, 
								   SQLSMALLINT FieldIdentifier,
           						   SQLPOINTER Value, 
								   SQLINTEGER BufferLength)

{return 0;}

SQLRETURN SQL_API SQLGetDescFieldW(
    SQLHDESC           hdesc,
    SQLSMALLINT        iRecord,
    SQLSMALLINT        iField,
    SQLPOINTER         rgbValue,
    SQLINTEGER		   cbValueMax,
    SQLINTEGER     *pcbValue)

{return 0;}

SQLRETURN SQL_API SQLGetDescRecW(
    SQLHDESC           hdesc,
    SQLSMALLINT        iRecord,
    SQLWCHAR        *szName,
    SQLSMALLINT        cbNameMax,
    SQLSMALLINT    *pcbName,
    SQLSMALLINT    *pfType,
    SQLSMALLINT    *pfSubType,
    SQLLEN         *pLength,
    SQLSMALLINT    *pPrecision, 
    SQLSMALLINT    *pScale,
    SQLSMALLINT    *pNullable)

{return 0;}

SQLRETURN SQL_API SQLGetDiagFieldW(
    SQLSMALLINT        fHandleType,
    SQLHANDLE          handle,
    SQLSMALLINT        iRecord,
    SQLSMALLINT        fDiagField,
    SQLPOINTER         rgbDiagInfo,
    SQLSMALLINT        cbDiagInfoMax,
    SQLSMALLINT    *pcbDiagInfo)

{return 0;}

SQLRETURN SQL_API SQLGetDiagRecW(
    SQLSMALLINT        fHandleType,
    SQLHANDLE          handle,
    SQLSMALLINT        iRecord,
    SQLWCHAR        *szSqlState,
    SQLINTEGER     *pfNativeError,
    SQLWCHAR        *szErrorMsg,
    SQLSMALLINT        cbErrorMsgMax,
    SQLSMALLINT    *pcbErrorMsg)

{return 0;}

#endif

SQLRETURN SQL_API SQLPrepareW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szSqlStr,
    SQLINTEGER         cbSqlStr)

{return 0;}

SQLRETURN SQL_API SQLSetConnectAttrW(
    SQLHDBC            hdbc,
    SQLINTEGER         fAttribute,
    SQLPOINTER         rgbValue,
    SQLINTEGER         cbValue)

{return 0;}

SQLRETURN SQL_API SQLSetCursorNameW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szCursor,
    SQLSMALLINT        cbCursor)

{return 0;}

SQLRETURN SQL_API SQLColumnsW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLWCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLWCHAR        *szTableName,
    SQLSMALLINT        cbTableName,
    SQLWCHAR        *szColumnName,
    SQLSMALLINT        cbColumnName)

{return 0;}

SQLRETURN SQL_API SQLGetConnectOptionW(
    SQLHDBC            hdbc,
    SQLUSMALLINT       fOption,
    SQLPOINTER         pvParam)

{return 0;}

SQLRETURN SQL_API SQLGetInfoW(
    SQLHDBC            hdbc,
    SQLUSMALLINT       fInfoType,
    SQLPOINTER         rgbInfoValue,
    SQLSMALLINT        cbInfoValueMax,
    SQLSMALLINT    *pcbInfoValue)

{return 0;}

SQLRETURN SQL_API	SQLGetTypeInfoW(
	SQLHSTMT			StatementHandle,
	SQLSMALLINT			DataType)

{return 0;}

SQLRETURN SQL_API SQLSetConnectOptionW(
    SQLHDBC            hdbc,
    SQLUSMALLINT       fOption,
    SQLULEN            vParam)

{return 0;}

SQLRETURN SQL_API SQLSpecialColumnsW(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       fColType,
    SQLWCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLWCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLWCHAR        *szTableName,
    SQLSMALLINT        cbTableName,
    SQLUSMALLINT       fScope,
    SQLUSMALLINT       fNullable)

{return 0;}

SQLRETURN SQL_API SQLStatisticsW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLWCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLWCHAR        *szTableName,
    SQLSMALLINT        cbTableName,
    SQLUSMALLINT       fUnique,
    SQLUSMALLINT       fAccuracy)

{return 0;}

SQLRETURN SQL_API SQLTablesW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLWCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLWCHAR        *szTableName,
    SQLSMALLINT        cbTableName,
    SQLWCHAR        *szTableType,
    SQLSMALLINT        cbTableType)

{return 0;}

SQLRETURN SQL_API SQLDataSourcesW(
    SQLHENV            henv,
    SQLUSMALLINT       fDirection,
    SQLWCHAR        *szDSN,
    SQLSMALLINT        cbDSNMax,
    SQLSMALLINT    *pcbDSN,
    SQLWCHAR        *szDescription,
    SQLSMALLINT        cbDescriptionMax,
    SQLSMALLINT    *pcbDescription)

{return 0;}

SQLRETURN SQL_API SQLDriverConnectW(
    SQLHDBC            hdbc,
    SQLHWND            hwnd,
    SQLWCHAR        *szConnStrIn,
    SQLSMALLINT        cbConnStrIn,
    SQLWCHAR        *szConnStrOut,
    SQLSMALLINT        cbConnStrOutMax,
    SQLSMALLINT    *pcbConnStrOut,
    SQLUSMALLINT       fDriverCompletion)

{return 0;}

SQLRETURN SQL_API SQLBrowseConnectW(
    SQLHDBC            hdbc,
    SQLWCHAR        *szConnStrIn,
    SQLSMALLINT        cbConnStrIn,
    SQLWCHAR        *szConnStrOut,
    SQLSMALLINT        cbConnStrOutMax,
    SQLSMALLINT    *pcbConnStrOut)

{return 0;}

SQLRETURN SQL_API SQLColumnPrivilegesW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLWCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLWCHAR        *szTableName,
    SQLSMALLINT        cbTableName,
    SQLWCHAR        *szColumnName,
    SQLSMALLINT        cbColumnName)

{return 0;}

SQLRETURN SQL_API SQLGetStmtAttrW(
    SQLHSTMT           hstmt,
    SQLINTEGER         fAttribute,
    SQLPOINTER         rgbValue,
    SQLINTEGER         cbValueMax,
    SQLINTEGER     *pcbValue)

{return 0;}

SQLRETURN SQL_API SQLSetStmtAttrA(
    SQLHSTMT           hstmt,
    SQLINTEGER         fAttribute,
    SQLPOINTER         rgbValue,
    SQLINTEGER         cbValueMax)

{return 0;}

SQLRETURN SQL_API SQLSetStmtAttrW(
    SQLHSTMT           hstmt,
    SQLINTEGER         fAttribute,
    SQLPOINTER         rgbValue,
    SQLINTEGER         cbValueMax)

{return 0;}

SQLRETURN SQL_API SQLForeignKeysW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szPkCatalogName,
    SQLSMALLINT        cbPkCatalogName,
    SQLWCHAR        *szPkSchemaName,
    SQLSMALLINT        cbPkSchemaName,
    SQLWCHAR        *szPkTableName,
    SQLSMALLINT        cbPkTableName,
    SQLWCHAR        *szFkCatalogName,
    SQLSMALLINT        cbFkCatalogName,
    SQLWCHAR        *szFkSchemaName,
    SQLSMALLINT        cbFkSchemaName,
    SQLWCHAR        *szFkTableName,
    SQLSMALLINT        cbFkTableName)

{return 0;}

SQLRETURN SQL_API SQLNativeSqlW(
    SQLHDBC            hdbc,
    SQLWCHAR        *szSqlStrIn,
    SQLINTEGER         cbSqlStrIn,
    SQLWCHAR        *szSqlStr,
    SQLINTEGER         cbSqlStrMax,
    SQLINTEGER     *pcbSqlStr)

{return 0;}

SQLRETURN SQL_API SQLPrimaryKeysW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLWCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLWCHAR        *szTableName,
    SQLSMALLINT        cbTableName)

{return 0;}

SQLRETURN SQL_API SQLProcedureColumnsW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLWCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLWCHAR        *szProcName,
    SQLSMALLINT        cbProcName,
    SQLWCHAR        *szColumnName,
    SQLSMALLINT        cbColumnName)

{return 0;}

SQLRETURN SQL_API SQLProceduresW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLWCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLWCHAR        *szProcName,
    SQLSMALLINT        cbProcName)

{return 0;}

SQLRETURN SQL_API SQLTablePrivilegesW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLWCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLWCHAR        *szTableName,
    SQLSMALLINT        cbTableName)

{return 0;}

SQLRETURN SQL_API SQLDriversW(
    SQLHENV            henv,
    SQLUSMALLINT       fDirection,
    SQLWCHAR        *szDriverDesc,
    SQLSMALLINT        cbDriverDescMax,
    SQLSMALLINT    *pcbDriverDesc,
    SQLWCHAR        *szDriverAttributes,
    SQLSMALLINT        cbDrvrAttrMax,
    SQLSMALLINT    *pcbDrvrAttr)

{return 0;}

// ANSI versions

SQLRETURN SQL_API SQLColAttributeA(
	SQLHSTMT		hstmt,
	SQLSMALLINT		iCol,
	SQLSMALLINT		iField,
	SQLPOINTER		pCharAttr,
	SQLSMALLINT		cbCharAttrMax,	
	SQLSMALLINT  *pcbCharAttr,
	SQLPOINTER		pNumAttr)

{return 0;}

SQLRETURN SQL_API SQLColAttributesA(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       icol,
    SQLUSMALLINT       fDescType,
    SQLPOINTER         rgbDesc,
    SQLSMALLINT        cbDescMax,
    SQLSMALLINT    *pcbDesc,
    SQLINTEGER     *pfDesc)

{return 0;}

SQLRETURN SQL_API SQLConnectA(
    SQLHDBC            hdbc,
    SQLCHAR         *szDSN,
    SQLSMALLINT        cbDSN,
    SQLCHAR         *szUID,
    SQLSMALLINT        cbUID,
    SQLCHAR         *szAuthStr,
    SQLSMALLINT        cbAuthStr)

{return 0;}

SQLRETURN SQL_API SQLDescribeColA(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       icol,
    SQLCHAR         *szColName,
    SQLSMALLINT        cbColNameMax,
    SQLSMALLINT    *pcbColName,
    SQLSMALLINT    *pfSqlType,
    SQLUINTEGER    *pcbColDef,
    SQLSMALLINT    *pibScale,
    SQLSMALLINT    *pfNullable)

{return 0;}

SQLRETURN SQL_API SQLErrorA(
    SQLHENV            henv,
    SQLHDBC            hdbc,
    SQLHSTMT           hstmt,
    SQLCHAR        *szSqlState,
    SQLINTEGER     *pfNativeError,
    SQLCHAR        *szErrorMsg,
    SQLSMALLINT        cbErrorMsgMax,
    SQLSMALLINT    *pcbErrorMsg)

{return 0;}

SQLRETURN SQL_API SQLExecDirectA(
    SQLHSTMT           hstmt,
    SQLCHAR           *szSqlStr,
    SQLINTEGER         cbSqlStr)

{return 0;}

SQLRETURN SQL_API SQLGetConnectAttrA(
    SQLHDBC            hdbc,
    SQLINTEGER         fAttribute,
    SQLPOINTER         rgbValue,
    SQLINTEGER         cbValueMax,
    SQLINTEGER     *pcbValue)

{return 0;}

SQLRETURN SQL_API SQLGetCursorNameA(
    SQLHSTMT           hstmt,
    SQLCHAR        	*szCursor,
    SQLSMALLINT        cbCursorMax,
    SQLSMALLINT    *pcbCursor)

{return 0;}

#if (ODBCVER >= 0x0300)

SQLRETURN SQL_API SQLGetDescFieldA(
    SQLHDESC           hdesc,
    SQLSMALLINT        iRecord,
    SQLSMALLINT        iField,
    SQLPOINTER         rgbValue,
    SQLINTEGER		   cbValueMax,
    SQLINTEGER     *pcbValue)

{return 0;}

SQLRETURN SQL_API SQLGetDescRecA(
    SQLHDESC           hdesc,
    SQLSMALLINT        iRecord,
    SQLCHAR        *szName,
    SQLSMALLINT        cbNameMax,
    SQLSMALLINT    *pcbName,
    SQLSMALLINT    *pfType,
    SQLSMALLINT    *pfSubType,
    SQLINTEGER     *pLength,
    SQLSMALLINT    *pPrecision, 
    SQLSMALLINT    *pScale,
    SQLSMALLINT    *pNullable)

{return 0;}

SQLRETURN SQL_API SQLGetDiagFieldA(
    SQLSMALLINT        fHandleType,
    SQLHANDLE          handle,
    SQLSMALLINT        iRecord,
    SQLSMALLINT        fDiagField,
    SQLPOINTER         rgbDiagInfo,
    SQLSMALLINT        cbDiagInfoMax,
    SQLSMALLINT    *pcbDiagInfo)

{return 0;}

SQLRETURN SQL_API SQLGetDiagRecA(
    SQLSMALLINT        fHandleType,
    SQLHANDLE          handle,
    SQLSMALLINT        iRecord,
    SQLCHAR        *szSqlState,
    SQLINTEGER     *pfNativeError,
    SQLCHAR        *szErrorMsg,
    SQLSMALLINT        cbErrorMsgMax,
    SQLSMALLINT    *pcbErrorMsg)

{return 0;}

SQLRETURN SQL_API SQLGetStmtAttrA(
    SQLHSTMT           hstmt,
    SQLINTEGER         fAttribute,
    SQLPOINTER         rgbValue,
    SQLINTEGER         cbValueMax,
    SQLINTEGER     *pcbValue)

{return 0;}

#endif

SQLRETURN SQL_API	SQLGetTypeInfoA(
	SQLHSTMT			StatementHandle,
	SQLSMALLINT			DataTyoe)

{return 0;}

SQLRETURN SQL_API SQLPrepareA(
    SQLHSTMT           hstmt,
    SQLCHAR        	*szSqlStr,
    SQLINTEGER         cbSqlStr)

{return 0;}

SQLRETURN SQL_API SQLSetConnectAttrA(
    SQLHDBC            hdbc,
    SQLINTEGER         fAttribute,
    SQLPOINTER         rgbValue,
    SQLINTEGER         cbValue)

{return 0;}

SQLRETURN SQL_API SQLSetCursorNameA(
    SQLHSTMT           hstmt,
    SQLCHAR           *szCursor,
    SQLSMALLINT        cbCursor)

{return 0;}

SQLRETURN SQL_API SQLColumnsA(
    SQLHSTMT           hstmt,
    SQLCHAR        	*szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR        	*szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR        	*szTableName,
    SQLSMALLINT        cbTableName,
    SQLCHAR        	*szColumnName,
    SQLSMALLINT        cbColumnName)

{return 0;}

SQLRETURN SQL_API SQLGetConnectOptionA(
    SQLHDBC            hdbc,
    SQLUSMALLINT       fOption,
    SQLPOINTER         pvParam)

{return 0;}

SQLRETURN SQL_API SQLGetInfoA(
    SQLHDBC            hdbc,
    SQLUSMALLINT       fInfoType,
    SQLPOINTER         rgbInfoValue,
    SQLSMALLINT        cbInfoValueMax,
    SQLSMALLINT*       pcbInfoValue)

{return 0;}

SQLRETURN SQL_API SQLGetStmtOptionA(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       fOption,
    SQLPOINTER         pvParam)

{return 0;}

SQLRETURN SQL_API SQLSetConnectOptionA(
    SQLHDBC            hdbc,
    SQLUSMALLINT       fOption,
    SQLULEN            vParam)

{return 0;}

SQLRETURN SQL_API SQLSetStmtOptionA(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       fOption,
    SQLULEN            vParam)

{return 0;}

SQLRETURN SQL_API SQLSpecialColumnsA(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       fColType,
    SQLCHAR        	*szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR        	*szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR        	*szTableName,
    SQLSMALLINT        cbTableName,
    SQLUSMALLINT       fScope,
    SQLUSMALLINT       fNullable)

{return 0;}

SQLRETURN SQL_API SQLStatisticsA(
    SQLHSTMT           hstmt,
    SQLCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR        *szTableName,
    SQLSMALLINT        cbTableName,
    SQLUSMALLINT       fUnique,
    SQLUSMALLINT       fAccuracy)

{return 0;}

SQLRETURN SQL_API SQLTablesA(
    SQLHSTMT           hstmt,
    SQLCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR        *szTableName,
    SQLSMALLINT        cbTableName,
    SQLCHAR        *szTableType,
    SQLSMALLINT        cbTableType)

{return 0;}

SQLRETURN SQL_API SQLDataSourcesA(
    SQLHENV            henv,
    SQLUSMALLINT       fDirection,
    SQLCHAR        *szDSN,
    SQLSMALLINT        cbDSNMax,
    SQLSMALLINT    *pcbDSN,
    SQLCHAR        *szDescription,
    SQLSMALLINT        cbDescriptionMax,
    SQLSMALLINT    *pcbDescription)

{return 0;}

SQLRETURN SQL_API SQLDriverConnectA(
    SQLHDBC            hdbc,
    SQLHWND            hwnd,
    SQLCHAR        *szConnStrIn,
    SQLSMALLINT        cbConnStrIn,
    SQLCHAR        *szConnStrOut,
    SQLSMALLINT        cbConnStrOutMax,
    SQLSMALLINT    *pcbConnStrOut,
    SQLUSMALLINT       fDriverCompletion)

{return 0;}

SQLRETURN SQL_API SQLBrowseConnectA(
    SQLHDBC            hdbc,
    SQLCHAR        *szConnStrIn,
    SQLSMALLINT        cbConnStrIn,
    SQLCHAR        *szConnStrOut,
    SQLSMALLINT        cbConnStrOutMax,
    SQLSMALLINT    *pcbConnStrOut)

{return 0;}

SQLRETURN SQL_API SQLColumnPrivilegesA(
    SQLHSTMT           hstmt,
    SQLCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR        *szTableName,
    SQLSMALLINT        cbTableName,
    SQLCHAR        *szColumnName,
    SQLSMALLINT        cbColumnName)

{return 0;}

SQLRETURN SQL_API SQLDescribeParamA(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       ipar,
    SQLSMALLINT    *pfSqlType,
    SQLUINTEGER    *pcbParamDef,
    SQLSMALLINT    *pibScale,
    SQLSMALLINT    *pfNullable)

{return 0;}

SQLRETURN SQL_API SQLForeignKeysA(
    SQLHSTMT           hstmt,
    SQLCHAR        *szPkCatalogName,
    SQLSMALLINT        cbPkCatalogName,
    SQLCHAR        *szPkSchemaName,
    SQLSMALLINT        cbPkSchemaName,
    SQLCHAR        *szPkTableName,
    SQLSMALLINT        cbPkTableName,
    SQLCHAR        *szFkCatalogName,
    SQLSMALLINT        cbFkCatalogName,
    SQLCHAR        *szFkSchemaName,
    SQLSMALLINT        cbFkSchemaName,
    SQLCHAR        *szFkTableName,
    SQLSMALLINT        cbFkTableName)

{return 0;}

SQLRETURN SQL_API SQLNativeSqlA(
    SQLHDBC            hdbc,
    SQLCHAR        *szSqlStrIn,
    SQLINTEGER         cbSqlStrIn,
    SQLCHAR        *szSqlStr,
    SQLINTEGER         cbSqlStrMax,
    SQLINTEGER     *pcbSqlStr)

{return 0;}

SQLRETURN SQL_API SQLPrimaryKeysA(
    SQLHSTMT           hstmt,
    SQLCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR        *szTableName,
    SQLSMALLINT        cbTableName)

{return 0;}

SQLRETURN SQL_API SQLProcedureColumnsA(
    SQLHSTMT           hstmt,
    SQLCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR        *szProcName,
    SQLSMALLINT        cbProcName,
    SQLCHAR        *szColumnName,
    SQLSMALLINT        cbColumnName)

{return 0;}

SQLRETURN SQL_API SQLProceduresA(
    SQLHSTMT           hstmt,
    SQLCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR        *szProcName,
    SQLSMALLINT        cbProcName)

{return 0;}

SQLRETURN SQL_API SQLTablePrivilegesA(
    SQLHSTMT           hstmt,
    SQLCHAR        *szCatalogName,
    SQLSMALLINT        cbCatalogName,
    SQLCHAR        *szSchemaName,
    SQLSMALLINT        cbSchemaName,
    SQLCHAR        *szTableName,
    SQLSMALLINT        cbTableName)

{return 0;}

SQLRETURN SQL_API SQLDriversA(
    SQLHENV            henv,
    SQLUSMALLINT       fDirection,
    SQLCHAR        *szDriverDesc,
    SQLSMALLINT        cbDriverDescMax,
    SQLSMALLINT    *pcbDriverDesc,
    SQLCHAR        *szDriverAttributes,
    SQLSMALLINT        cbDrvrAttrMax,
    SQLSMALLINT    *pcbDrvrAttr)

{return 0;}

//---------------------------------------------
// Mapping macros for Unicode
//---------------------------------------------

#ifndef	SQL_NOUNICODEMAP	// define this to disable the mapping
#ifdef 	UNICODE

#define	SQLColAttribute		SQLColAttributeW
#define	SQLColAttributes	SQLColAttributesW
#define	SQLConnect			SQLConnectW
#define	SQLDescribeCol		SQLDescribeColW
#define	SQLError			SQLErrorW
#define	SQLExecDirect		SQLExecDirectW
#define	SQLGetConnectAttr	SQLGetConnectAttrW
#define	SQLGetCursorName	SQLGetCursorNameW
#define	SQLGetDescField		SQLGetDescFieldW
#define	SQLGetDescRec		SQLGetDescRecW
#define	SQLGetDiagField		SQLGetDiagFieldW
#define	SQLGetDiagRec		SQLGetDiagRecW
#define	SQLPrepare			SQLPrepareW
#define	SQLSetConnectAttr	SQLSetConnectAttrW
#define	SQLSetCursorName	SQLSetCursorNameW
#define	SQLSetDescField		SQLSetDescFieldW
#define SQLSetStmtAttr		SQLSetStmtAttrW
#define SQLGetStmtAttr		SQLGetStmtAttrW
#define	SQLColumns			SQLColumnsW
#define	SQLGetConnectOption	SQLGetConnectOptionW
#define	SQLGetInfo			SQLGetInfoW
#define SQLGetTypeInfo		SQLGetTypeInfoW
#define	SQLSetConnectOption	SQLSetConnectOptionW
#define	SQLSpecialColumns	SQLSpecialColumnsW
#define	SQLStatistics		SQLStatisticsW
#define	SQLTables			SQLTablesW
#define	SQLDataSources		SQLDataSourcesW
#define	SQLDriverConnect	SQLDriverConnectW
#define	SQLBrowseConnect	SQLBrowseConnectW
#define	SQLColumnPrivileges	SQLColumnPrivilegesW
#define	SQLForeignKeys		SQLForeignKeysW
#define	SQLNativeSql		SQLNativeSqlW
#define	SQLPrimaryKeys		SQLPrimaryKeysW
#define	SQLProcedureColumns	SQLProcedureColumnsW
#define	SQLProcedures		SQLProceduresW
#define	SQLTablePrivileges	SQLTablePrivilegesW
#define	SQLDrivers			SQLDriversW

#endif	/* UNICODE */
#endif	/* SQL_NOUNICODEMAP	*/

#endif /* RC_INVOKED */


#ifdef __cplusplus
}                                    /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oleaut32\olestub.cpp ===
int
VarUI8FromUI4 (
    unsigned int foo,
    unsigned __int64 *bar
    )

{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\odbccp32_cpl\odbccp32.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    odbccp32.c

Abstract:

   This module implements stub functions for shell32 interfaces.

Author:

    David N. Cutler (davec) 1-Mar-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"

#define STUBFUNC(x)     \
int                     \
x(                      \
    void                \
    )                   \
{                       \
    return 0;           \
}

STUBFUNC(CPlApplet)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\odbcbcp\odbcbcp.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    corpol.c

Abstract:

   This module implements stub functions for shell32 interfaces.

Author:

    David N. Cutler (davec) 1-Mar-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"

#define STUBFUNC(x)     \
int                     \
x(                      \
    void                \
    )                   \
{                       \
    return 0;           \
}

STUBFUNC(LibMain)
STUBFUNC(SQLCloseEnumServers)
STUBFUNC(SQLGetNextEnumeration)
STUBFUNC(SQLInitEnumServers)
STUBFUNC(SQLLinkedCatalogsA)
STUBFUNC(SQLLinkedCatalogsW)
STUBFUNC(SQLLinkedServers)
STUBFUNC(bcp_batch)
STUBFUNC(bcp_bind)
STUBFUNC(bcp_colfmt)
STUBFUNC(bcp_collen)
STUBFUNC(bcp_colptr)
STUBFUNC(bcp_columns)
STUBFUNC(bcp_control)
STUBFUNC(bcp_done)
STUBFUNC(bcp_exec)
STUBFUNC(bcp_getcolfmt)
STUBFUNC(bcp_initA)
STUBFUNC(bcp_initW)
STUBFUNC(bcp_moretext)
STUBFUNC(bcp_readfmtA)
STUBFUNC(bcp_readfmtW)
STUBFUNC(bcp_sendrow)
STUBFUNC(bcp_setcolfmt)
STUBFUNC(bcp_writefmtA)
STUBFUNC(bcp_writefmtW)
STUBFUNC(dbprtypeA)
STUBFUNC(dbprtypeW)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oleaut32\oleaut32.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    shell32.c

Abstract:

   This module implements stub functions for shell32 interfaces.

Author:

    David N. Cutler (davec) 23-Apr-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"

#define STUBFUNC(x)     \
int                     \
x(                      \
    void                \
    )                   \
{                       \
    return 0;           \
}
STUBFUNC(DllGetClassObject)

BOOL
SysAllocString (
    VOID
    )

{
    return FALSE;
}

BOOL
SysReAllocString (
    VOID
    )

{
    return FALSE;
}

BOOL
SysAllocStringLen (
    VOID
    )

{
    return FALSE;
}

BOOL
SysReAllocStringLen (
    VOID
    )

{
    return FALSE;
}

BOOL
SysFreeString (
    VOID
    )

{
    return FALSE;
}

BOOL
SysStringLen (
    VOID
    )

{
    return FALSE;
}

BOOL
VariantInit (
    VOID
    )

{
    return FALSE;
}

BOOL
VariantClear (
    VOID
    )

{
    return FALSE;
}

BOOL
VariantCopy (
    VOID
    )

{
    return FALSE;
}

BOOL
VariantCopyInd (
    VOID
    )

{
    return FALSE;
}

BOOL
VariantChangeType (
    VOID
    )

{
    return FALSE;
}

BOOL
VariantTimeToDosDateTime (
    VOID
    )

{
    return FALSE;
}

BOOL
DosDateTimeToVariantTime (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayCreate (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayDestroy (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayGetDim (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayGetElemsize (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayGetUBound (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayGetLBound (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayLock (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayUnlock (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayAccessData (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayUnaccessData (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayGetElement (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayPutElement (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayCopy (
    VOID
    )

{
    return FALSE;
}

BOOL
DispGetParam (
    VOID
    )

{
    return FALSE;
}

BOOL
DispGetIDsOfNames (
    VOID
    )

{
    return FALSE;
}

BOOL
DispInvoke (
    VOID
    )

{
    return FALSE;
}

BOOL
CreateDispTypeInfo (
    VOID
    )

{
    return FALSE;
}

BOOL
CreateStdDispatch (
    VOID
    )

{
    return FALSE;
}

BOOL
RegisterActiveObject (
    VOID
    )

{
    return FALSE;
}

BOOL
RevokeActiveObject (
    VOID
    )

{
    return FALSE;
}

BOOL
GetActiveObject (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayAllocDescriptor (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayAllocData (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayDestroyDescriptor (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayDestroyData (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayRedim (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayAllocDescriptorEx (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayCreateEx (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayCreateVectorEx (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArraySetRecordInfo (
    VOID
    )

{
    return FALSE;
}

BOOL
SafeArrayGetRecordInfo (
    VOID
    )

{
    return FALSE;
}

BOOL
VariantChangeTypeEx (
    VOID
    )

{
    return FALSE;
}

BOOL
SysStringByteLen (
    VOID
    )

{
    return FALSE;
}

BOOL
SysAllocStringByteLen (
    VOID
    )

{
    return FALSE;
}

BOOL
LoadRegTypeLib (
    VOID
    )

{
    return FALSE;
}

HRESULT
LoadTypeLib (
    IN PVOID Arg1,
    OUT PVOID *Arg2
    )

{
    *Arg2 = NULL;
    return E_NOTIMPL;
}

BOOL
LoadTypeLibEx (
    VOID
    )

{
    return FALSE;
}

BOOL
SystemTimeToVariantTime (
    VOID
    )

{
    return FALSE;
}

BOOL
VariantTimeToSystemTime (
    VOID
    )

{
    return FALSE;
}

BOOL
SetErrorInfo (
    VOID
    )

{
    return FALSE;
}

BOOL
CreateErrorInfo (
    VOID
    )

{
    return FALSE;
}

BOOL
BSTR_UserSize (
    VOID
    )

{
    return FALSE;
}
BOOL
BSTR_UserSize64 (
    VOID
    )

{
    return FALSE;
}

BOOL
BSTR_UserMarshal (
    VOID
    )

{
    return FALSE;
}
BOOL
BSTR_UserMarshal64 (
    VOID
    )

{
    return FALSE;
}

BOOL
BSTR_UserUnmarshal (
    VOID
    )

{
    return FALSE;
}

BOOL
BSTR_UserUnmarshal64 (
    VOID
    )

{
    return FALSE;
}

BOOL
BSTR_UserFree (
    VOID
    )

{
    return FALSE;
}

BOOL
BSTR_UserFree64 (
    VOID
    )

{
    return FALSE;
}

BOOL
VARIANT_UserSize (
    VOID
    )

{
    return FALSE;
}

BOOL
VARIANT_UserMarshal (
    VOID
    )

{
    return FALSE;
}

BOOL
VARIANT_UserUnmarshal (
    VOID
    )

{
    return FALSE;
}

BOOL
VARIANT_UserFree (
    VOID
    )

{
    return FALSE;
}

BOOL
LPSAFEARRAY_UserSize (
    VOID
    )

{
    return FALSE;
}

BOOL
LPSAFEARRAY_UserMarshal (
    VOID
    )

{
    return FALSE;
}

BOOL
LPSAFEARRAY_UserUnmarshal (
    VOID
    )

{
    return FALSE;
}

BOOL
LPSAFEARRAY_UserFree (
    VOID
    )

{
    return FALSE;
}

BOOL
LPSAFEARRAY_Size (
    VOID
    )

{
    return FALSE;
}

BOOL
LPSAFEARRAY_Marshal (
    VOID
    )

{
    return FALSE;
}

BOOL
LPSAFEARRAY_Unmarshal (
    VOID
    )

{
    return FALSE;
}

STUBFUNC(VarI4FromStr)
STUBFUNC(RegisterTypeLib)
STUBFUNC(VarDateFromStr)
STUBFUNC(UnRegisterTypeLib)
STUBFUNC(DllRegisterServer)
STUBFUNC(DllUnregisterServer)
STUBFUNC(DllCanUnloadNow)
STUBFUNC(BstrFromVector)
STUBFUNC(OleIconToCursor)
STUBFUNC(OleCreatePropertyFrameIndirect)
STUBFUNC(OleCreatePropertyFrame)
STUBFUNC(OleLoadPicture)
STUBFUNC(OleCreatePictureIndirect)
STUBFUNC(OleCreateFontIndirect)
STUBFUNC(OleTranslateColor)
STUBFUNC(QueryPathOfRegTypeLib)
STUBFUNC(ClearCustData)
STUBFUNC(SafeArrayPtrOfIndex)
STUBFUNC(GetErrorInfo)
STUBFUNC(SafeArrayCreateVector)
STUBFUNC(VarI4FromDate)
STUBFUNC(VarR8FromUI1)
STUBFUNC(VarR8FromI2)
STUBFUNC(VarR8FromI4)
STUBFUNC(VarR8FromR4)
STUBFUNC(VarR8FromCy)
STUBFUNC(VarR8FromDate)
STUBFUNC(VarR8FromBool)
STUBFUNC(VarCyFromI2)
STUBFUNC(VarCyFromI4)
STUBFUNC(VarCyFromR4)
STUBFUNC(VarCyFromR8)
STUBFUNC(VarR8FromI1)
STUBFUNC(VarR8FromUI2)
STUBFUNC(VarR8FromUI4)
STUBFUNC(VarR8FromDec)
STUBFUNC(CreateTypeLib)
STUBFUNC(CreateTypeLib2)
STUBFUNC(DispCallFunc)
STUBFUNC(GetAltMonthNames)
STUBFUNC(GetRecordInfoFromGuids)
STUBFUNC(GetRecordInfoFromTypeInfo)
STUBFUNC(GetVarConversionLocaleSetting)
STUBFUNC(LHashValOfNameSys)
STUBFUNC(LHashValOfNameSysA)
STUBFUNC(LPSAFEARRAY_UserFree64)
STUBFUNC(LPSAFEARRAY_UserMarshal64)
STUBFUNC(LPSAFEARRAY_UserSize64)
STUBFUNC(LPSAFEARRAY_UserUnmarshal64)
STUBFUNC(OACreateTypeLib2)
STUBFUNC(OaBuildVersion)
STUBFUNC(OleLoadPictureEx)
STUBFUNC(OleLoadPictureFile)
STUBFUNC(OleLoadPictureFileEx)
STUBFUNC(OleLoadPicturePath)
STUBFUNC(OleSavePictureFile)
STUBFUNC(SafeArrayCopyData)
STUBFUNC(SafeArrayGetIID)
STUBFUNC(SafeArrayGetVartype)
STUBFUNC(SafeArraySetIID)
STUBFUNC(SetVarConversionLocaleSetting)
STUBFUNC(VARIANT_UserFree64)
STUBFUNC(VARIANT_UserMarshal64)
STUBFUNC(VARIANT_UserSize64)
STUBFUNC(VARIANT_UserUnmarshal64)
STUBFUNC(VarAbs)
STUBFUNC(VarAdd)
STUBFUNC(VarAnd)
STUBFUNC(VarBoolFromCy)
STUBFUNC(VarBoolFromDate)
STUBFUNC(VarBoolFromDec)
STUBFUNC(VarBoolFromDisp)
STUBFUNC(VarBoolFromI1)
STUBFUNC(VarBoolFromI2)
STUBFUNC(VarBoolFromI4)
STUBFUNC(VarBoolFromI8)
STUBFUNC(VarBoolFromR4)
STUBFUNC(VarBoolFromR8)
STUBFUNC(VarBoolFromStr)
STUBFUNC(VarBoolFromUI1)
STUBFUNC(VarBoolFromUI2)
STUBFUNC(VarBoolFromUI4)
STUBFUNC(VarBoolFromUI8)
STUBFUNC(VarBstrCat)
STUBFUNC(VarBstrCmp)
STUBFUNC(VarBstrFromBool)
STUBFUNC(VarBstrFromCy)
STUBFUNC(VarBstrFromDate)
STUBFUNC(VarBstrFromDisp)
STUBFUNC(VarBstrFromI1)
STUBFUNC(VarBstrFromI2)
STUBFUNC(VarBstrFromI4)
STUBFUNC(VarBstrFromI8)
STUBFUNC(VarBstrFromR4)
STUBFUNC(VarBstrFromR8)
STUBFUNC(VarBstrFromUI1)
STUBFUNC(VarBstrFromUI4)
STUBFUNC(VarBstrFromUI8)
STUBFUNC(VarCat)
STUBFUNC(VarCmp)
STUBFUNC(VarCyAbs)
STUBFUNC(VarCyAdd)
STUBFUNC(VarCyCmp)
STUBFUNC(VarCyCmpR8)
STUBFUNC(VarCyFix)
STUBFUNC(VarCyFromBool)
STUBFUNC(VarCyFromDate)
STUBFUNC(VarCyFromDec)
STUBFUNC(VarCyFromDisp)
STUBFUNC(VarCyFromI1)
STUBFUNC(VarBstrFromDec)
STUBFUNC(VarBstrFromUI2)
STUBFUNC(VarCyFromI8)
STUBFUNC(VarCyFromStr)
STUBFUNC(VarCyFromUI1)
STUBFUNC(VarCyFromUI2)
STUBFUNC(VarCyFromUI4)
STUBFUNC(VarCyFromUI8)
STUBFUNC(VarCyInt)
STUBFUNC(VarCyMul)
STUBFUNC(VarCyMulI4)
STUBFUNC(VarCyMulI8)
STUBFUNC(VarCyNeg)
STUBFUNC(VarCyRound)
STUBFUNC(VarCySub)
STUBFUNC(VarDateFromBool)
STUBFUNC(VarDateFromCy)
STUBFUNC(VarDateFromDec)
STUBFUNC(VarDateFromDisp)
STUBFUNC(VarDateFromI1)
STUBFUNC(VarDateFromI2)
STUBFUNC(VarDateFromI4)
STUBFUNC(VarDateFromI8)
STUBFUNC(VarDateFromR4)
STUBFUNC(VarDateFromR8)
STUBFUNC(VarDateFromUI1)
STUBFUNC(VarDateFromUI2)
STUBFUNC(VarDateFromUI4)
STUBFUNC(VarDateFromUI8)
STUBFUNC(VarDateFromUdate)
STUBFUNC(VarDateFromUdateEx)
STUBFUNC(VarDecAbs)
STUBFUNC(VarDecAdd)
STUBFUNC(VarDecCmp)
STUBFUNC(VarDecCmpR8)
STUBFUNC(VarDecDiv)
STUBFUNC(VarDecFix)
STUBFUNC(VarDecFromBool)
STUBFUNC(VarDecFromCy)
STUBFUNC(VarDecFromDate)
STUBFUNC(VarDecFromDisp)
STUBFUNC(VarDecFromI1)
STUBFUNC(VarDecFromI2)
STUBFUNC(VarDecFromI4)
STUBFUNC(VarDecFromI8)
STUBFUNC(VarDecFromR4)
STUBFUNC(VarDecFromR8)
STUBFUNC(VarDecFromStr)
STUBFUNC(VarDecFromUI1)
STUBFUNC(VarDecFromUI2)
STUBFUNC(VarDecFromUI4)
STUBFUNC(VarDecFromUI8)
STUBFUNC(VarDecInt)
STUBFUNC(VarDecMul)
STUBFUNC(VarDecNeg)
STUBFUNC(VarDecRound)
STUBFUNC(VarDecSub)
STUBFUNC(VarDiv)
STUBFUNC(VarEqv)
STUBFUNC(VarFix)
STUBFUNC(VarFormat)
STUBFUNC(VarFormatCurrency)
STUBFUNC(VarFormatDateTime)
STUBFUNC(VarFormatFromTokens)
STUBFUNC(VarFormatNumber)
STUBFUNC(VarFormatPercent)
STUBFUNC(VarI1FromBool)
STUBFUNC(VarI1FromCy)
STUBFUNC(VarI1FromDate)
STUBFUNC(VarI1FromDec)
STUBFUNC(VarI1FromDisp)
STUBFUNC(VarI1FromI2)
STUBFUNC(VarI1FromI4)
STUBFUNC(VarI1FromI8)
STUBFUNC(VarI1FromR4)
STUBFUNC(VarI1FromR8)
STUBFUNC(VarI1FromStr)
STUBFUNC(VarI1FromUI1)
STUBFUNC(VarI1FromUI4)
STUBFUNC(VarI1FromUI8)
STUBFUNC(VarI2FromBool)
STUBFUNC(VarI2FromCy)
STUBFUNC(VarI2FromDate)
STUBFUNC(VarI2FromDec)
STUBFUNC(VarI2FromDisp)
STUBFUNC(VarI2FromI1)
STUBFUNC(VarI2FromI4)
STUBFUNC(VarI2FromI8)
STUBFUNC(VarI2FromR4)
STUBFUNC(VarI2FromR8)
STUBFUNC(VarI2FromStr)
STUBFUNC(VarI2FromUI1)
STUBFUNC(VarI2FromUI2)
STUBFUNC(VarI2FromUI4)
STUBFUNC(VarI2FromUI8)
STUBFUNC(VarI4FromBool)
STUBFUNC(VarI4FromCy)
STUBFUNC(VarI4FromDec)
STUBFUNC(VarI4FromDisp)
STUBFUNC(VarI4FromI1)
STUBFUNC(VarI4FromI2)
STUBFUNC(VarI4FromI8)
STUBFUNC(VarI4FromR4)
STUBFUNC(VarI4FromR8)
STUBFUNC(VarI4FromUI1)
STUBFUNC(VarI4FromUI2)
STUBFUNC(VarI4FromUI4)
STUBFUNC(VarI4FromUI8)
STUBFUNC(VarI8FromBool)
STUBFUNC(VarI8FromCy)
STUBFUNC(VarI8FromDate)
STUBFUNC(VarI8FromDec)
STUBFUNC(VarI8FromDisp)
STUBFUNC(VarI8FromI1)
STUBFUNC(VarI8FromI2)
STUBFUNC(VarI8FromR4)
STUBFUNC(VarI8FromR8)
STUBFUNC(VarI8FromStr)
STUBFUNC(VarI8FromUI1)
STUBFUNC(VarI8FromUI2)
STUBFUNC(VarI8FromUI4)
STUBFUNC(VarI8FromUI8)
STUBFUNC(VarIdiv)
STUBFUNC(VarImp)
STUBFUNC(VarInt)
STUBFUNC(VarI1FromUI2)
STUBFUNC(VarMod)
STUBFUNC(VarMonthName)
STUBFUNC(VarMul)
STUBFUNC(VarNeg)
STUBFUNC(VarNot)
STUBFUNC(VarNumFromParseNum)
STUBFUNC(VarOr)
STUBFUNC(VarParseNumFromStr)
STUBFUNC(VarPow)
STUBFUNC(VarR4CmpR8)
STUBFUNC(VarR4FromBool)
STUBFUNC(VarR4FromCy)
STUBFUNC(VarR4FromDate)
STUBFUNC(VarR4FromDec)
STUBFUNC(VarR4FromDisp)
STUBFUNC(VarR4FromI1)
STUBFUNC(VarR4FromI2)
STUBFUNC(VarR4FromI4)
STUBFUNC(VarR4FromI8)
STUBFUNC(VarR4FromR8)
STUBFUNC(VarR4FromStr)
STUBFUNC(VarR4FromUI1)
STUBFUNC(VarR4FromUI2)
STUBFUNC(VarR4FromUI4)
STUBFUNC(VarR4FromUI8)
STUBFUNC(VarR8FromDisp)
STUBFUNC(VarR8FromI8)
STUBFUNC(VarR8FromStr)
STUBFUNC(VarR8FromUI8)
STUBFUNC(VarR8Pow)
STUBFUNC(VarR8Round)
STUBFUNC(VarRound)
STUBFUNC(VarSub)
STUBFUNC(VarTokenizeFormatString)
STUBFUNC(VarUI1FromBool)
STUBFUNC(VarUI1FromCy)
STUBFUNC(VarUI1FromDate)
STUBFUNC(VarUI1FromDec)
STUBFUNC(VarUI1FromDisp)
STUBFUNC(VarUI1FromI1)
STUBFUNC(VarUI1FromI2)
STUBFUNC(VarUI1FromI4)
STUBFUNC(VarUI1FromI8)
STUBFUNC(VarUI1FromR4)
STUBFUNC(VarUI1FromR8)
STUBFUNC(VarUI1FromStr)
STUBFUNC(VarUI1FromUI2)
STUBFUNC(VarUI1FromUI4)
STUBFUNC(VarUI1FromUI8)
STUBFUNC(VarUI2FromBool)
STUBFUNC(VarUI2FromCy)
STUBFUNC(VarUI2FromDate)
STUBFUNC(VarUI2FromDec)
STUBFUNC(VarUI2FromDisp)
STUBFUNC(VarUI2FromI1)
STUBFUNC(VarUI2FromI2)
STUBFUNC(VarUI2FromI4)
STUBFUNC(VarUI2FromI8)
STUBFUNC(VarUI2FromR4)
STUBFUNC(VarUI2FromR8)
STUBFUNC(VarUI2FromStr)
STUBFUNC(VarUI2FromUI1)
STUBFUNC(VarUI2FromUI4)
STUBFUNC(VarUI2FromUI8)
STUBFUNC(VarUI4FromBool)
STUBFUNC(VarUI4FromCy)
STUBFUNC(VarUI4FromDate)
STUBFUNC(VarUI4FromDec)
STUBFUNC(VarUI4FromDisp)
STUBFUNC(VarUI4FromI1)
STUBFUNC(VarUI4FromI2)
STUBFUNC(VarUI4FromI4)
STUBFUNC(VarUI4FromI8)
STUBFUNC(VarUI4FromR4)
STUBFUNC(VarUI4FromR8)
STUBFUNC(VarUI4FromStr)
STUBFUNC(VarUI4FromUI1)
STUBFUNC(VarUI4FromUI2)
STUBFUNC(VarUI4FromUI8)
STUBFUNC(VarUI8FromBool)
STUBFUNC(VarUI8FromCy)
STUBFUNC(VarUI8FromDate)
STUBFUNC(VarUI8FromDec)
STUBFUNC(VarUI8FromDisp)
STUBFUNC(VarUI8FromI1)
STUBFUNC(VarUI8FromI2)
STUBFUNC(VarUI8FromI8)
STUBFUNC(VarUI8FromR4)
STUBFUNC(VarUI8FromR8)
STUBFUNC(VarUI8FromStr)
STUBFUNC(VarUI8FromUI1)
STUBFUNC(VarUI8FromUI2)
STUBFUNC(VarUdateFromDate)
STUBFUNC(VarWeekdayName)
STUBFUNC(VarXor)
STUBFUNC(VectorFromBstr)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\odbccp32\odbccp32.cpp ===
#include "windows.h"
#include "sql.h"

#ifdef __cplusplus
extern "C" {                               // Assume C declarations for C++
#endif	// __cplusplus

#ifndef ODBCVER
#define ODBCVER 0x0351					   // Assume ODBC 3.51
#endif

#ifndef WINVER
#define  WINVER  0x0400                     // Assume Windows 4.0
#endif

// Constants ---------------------------------------------------------------
// SQLConfigDataSource request flags
#define  ODBC_ADD_DSN     1               // Add data source
#define  ODBC_CONFIG_DSN  2               // Configure (edit) data source
#define  ODBC_REMOVE_DSN  3               // Remove data source

#if (ODBCVER >= 0x0250)
#define  ODBC_ADD_SYS_DSN 4				  // add a system DSN
#define  ODBC_CONFIG_SYS_DSN	5		  // Configure a system DSN
#define  ODBC_REMOVE_SYS_DSN	6		  // remove a system DSN
#if (ODBCVER >= 0x0300)
#define	 ODBC_REMOVE_DEFAULT_DSN	7		// remove the default DSN
#endif  /* ODBCVER >= 0x0300 */

// install request flags
#define	 ODBC_INSTALL_INQUIRY	1		
#define  ODBC_INSTALL_COMPLETE	2

// config driver flags
#define  ODBC_INSTALL_DRIVER	1
#define  ODBC_REMOVE_DRIVER		2
#define  ODBC_CONFIG_DRIVER		3
#define  ODBC_CONFIG_DRIVER_MAX 100
#endif

// SQLGetConfigMode and SQLSetConfigMode flags
#if (ODBCVER >= 0x0300)
#define ODBC_BOTH_DSN		0
#define ODBC_USER_DSN		1
#define ODBC_SYSTEM_DSN		2
#endif  /* ODBCVER >= 0x0300 */

// SQLInstallerError code
#if (ODBCVER >= 0x0300)
#define ODBC_ERROR_GENERAL_ERR                   1
#define ODBC_ERROR_INVALID_BUFF_LEN              2
#define ODBC_ERROR_INVALID_HWND                  3
#define ODBC_ERROR_INVALID_STR                   4
#define ODBC_ERROR_INVALID_REQUEST_TYPE          5
#define ODBC_ERROR_COMPONENT_NOT_FOUND           6
#define ODBC_ERROR_INVALID_NAME                  7
#define ODBC_ERROR_INVALID_KEYWORD_VALUE         8
#define ODBC_ERROR_INVALID_DSN                   9
#define ODBC_ERROR_INVALID_INF                  10
#define ODBC_ERROR_REQUEST_FAILED               11
#define ODBC_ERROR_INVALID_PATH                 12
#define ODBC_ERROR_LOAD_LIB_FAILED              13
#define ODBC_ERROR_INVALID_PARAM_SEQUENCE       14
#define ODBC_ERROR_INVALID_LOG_FILE             15
#define ODBC_ERROR_USER_CANCELED                16
#define ODBC_ERROR_USAGE_UPDATE_FAILED          17
#define ODBC_ERROR_CREATE_DSN_FAILED            18
#define ODBC_ERROR_WRITING_SYSINFO_FAILED       19
#define ODBC_ERROR_REMOVE_DSN_FAILED            20
#define ODBC_ERROR_OUT_OF_MEM                   21
#define ODBC_ERROR_OUTPUT_STRING_TRUNCATED      22
#endif /* ODBCVER >= 0x0300 */

#ifndef EXPORT
#define EXPORT 
#endif

#ifndef RC_INVOKED
// Prototypes --------------------------------------------------------------
#define INSTAPI __stdcall

// High level APIs

BOOL
INSTAPI
SQLInstallODBC (
    HWND hwndParent,
    LPCSTR lpszInfFile,
	LPCSTR lpszSrcPath,
	LPCSTR lpszDrivers
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLManageDataSources (
    HWND hwndParent
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLCreateDataSource (
    HWND hwndParent,
    LPCSTR lpszDSN
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLGetTranslator (
    HWND hwnd,
	LPSTR lpszName,
	WORD cbNameMax,
	WORD *pcbNameOut,
	LPSTR lpszPath,
	WORD cbPathMax,
	WORD *pcbPathOut,
	DWORD *pvOption
    )

{
    return FALSE;
}

// Low level APIs

BOOL
INSTAPI
SQLInstallDriver (
    LPCSTR lpszInfFile,
    LPCSTR lpszDriver,
    LPSTR lpszPath,
    WORD cbPathMax,
    WORD *pcbPathOut
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLInstallDriverManager (
    LPSTR lpszPath,
    WORD cbPathMax,
    WORD *pcbPathOut
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLGetInstalledDrivers (
    LPSTR lpszBuf,
    WORD cbBufMax,
    WORD *pcbBufOut
    )

{

    return FALSE;
}

BOOL
INSTAPI
SQLGetAvailableDrivers (
    LPCSTR lpszInfFile,
    LPSTR lpszBuf,
    WORD cbBufMax,
    WORD *pcbBufOut
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLConfigDataSource (
    HWND hwndParent,
    WORD fRequest,
    LPCSTR lpszDriver,
    LPCSTR lpszAttributes
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLRemoveDefaultDataSource (
    void
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLWriteDSNToIni (
    LPCSTR lpszDSN,
    LPCSTR lpszDriver
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLRemoveDSNFromIni (
    LPCSTR lpszDSN
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLValidDSN (
    LPCSTR lpszDSN
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLWritePrivateProfileString (
    LPCSTR lpszSection,
	LPCSTR lpszEntry,
	LPCSTR lpszString,
	LPCSTR lpszFilename
    )

{
    return FALSE;
}

int
INSTAPI
SQLGetPrivateProfileString (
    LPCSTR lpszSection,
	LPCSTR lpszEntry,
	LPCSTR lpszDefault,
	LPSTR lpszRetBuffer,
	int cbRetBuffer,
	LPCSTR lpszFilename
    )

{

    return 0;
}

#if (ODBCVER >= 0x0250)

BOOL
INSTAPI
SQLRemoveDriverManager (
    LPDWORD lpdwUsageCount
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLInstallTranslator (
    LPCSTR lpszInfFile,
	LPCSTR lpszTranslator,
	LPCSTR lpszPathIn,
	LPSTR lpszPathOut,
	WORD cbPathOutMax,
	WORD *pcbPathOut,
	WORD fRequest,
	LPDWORD	lpdwUsageCount
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLRemoveTranslator (
    LPCSTR lpszTranslator, 
	LPDWORD lpdwUsageCount
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLRemoveDriver (
    LPCSTR lpszDriver, 
	BOOL fRemoveDSN, 
	LPDWORD lpdwUsageCount
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLConfigDriver (
    HWND hwndParent, 
	WORD fRequest, 
	LPCSTR lpszDriver,
	LPCSTR lpszArgs,
	LPSTR lpszMsg,
	WORD cbMsgMax,
    WORD *pcbMsgOut
    )

{
    return FALSE;
}

#endif

#if (ODBCVER >=  0x0300)

SQLRETURN
INSTAPI
SQLInstallerError (
    WORD iError,
	DWORD *pfErrorCode,
	LPSTR lpszErrorMsg,
	WORD cbErrorMsgMax,
	WORD *pcbErrorMsg
    )

{
    return 0;
}

SQLRETURN
INSTAPI
SQLPostInstallerError (
    DWORD dwErrorCode,
    LPCSTR lpszErrMsg
    )

{
    return 0;
}

BOOL
INSTAPI
SQLWriteFileDSN (
    LPCSTR lpszFileName,
    LPCSTR lpszAppName,
    LPCSTR lpszKeyName,
    LPCSTR lpszString
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLReadFileDSN (
    LPCSTR lpszFileName,
    LPCSTR lpszAppName,
    LPCSTR lpszKeyName,
    LPSTR lpszString,
    WORD cbString,
    WORD *pcbString
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLInstallDriverEx (
    LPCSTR lpszDriver,
  	LPCSTR lpszPathIn,
  	LPSTR lpszPathOut,
  	WORD cbPathOutMax,
  	WORD *pcbPathOut,
  	WORD fRequest,
  	LPDWORD	lpdwUsageCount
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLInstallTranslatorEx (
    LPCSTR lpszTranslator,
    LPCSTR lpszPathIn,
    LPSTR lpszPathOut,
    WORD cbPathOutMax,
    WORD *pcbPathOut,
    WORD fRequest,
    LPDWORD	lpdwUsageCount
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLGetConfigMode (
    UWORD *pwConfigMode
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLSetConfigMode (
    UWORD wConfigMode
    )

{
    return FALSE;
}

#endif /* ODBCVER >= 0x0300 */

//	Driver specific Setup APIs called by installer

BOOL
INSTAPI
ConfigDSN (
    HWND hwndParent,
   	WORD fRequest,
   	LPCSTR lpszDriver,
   	LPCSTR lpszAttributes
    )

{
    return FALSE;
}

BOOL
INSTAPI
ConfigTranslator (
	HWND hwndParent,
	DWORD *pvOption
    )

{
    return FALSE;
}

#if (ODBCVER >= 0x0250)

BOOL
INSTAPI
ConfigDriver (
    HWND hwndParent, 
    WORD fRequest, 
    LPCSTR lpszDriver,
    LPCSTR lpszArgs, 
    LPSTR lpszMsg, 
    WORD cbMsgMax, 
    WORD *pcbMsgOut
    )

{
    return FALSE;
}

#endif


// UNICODE APIs

// High level APIs

BOOL
INSTAPI
SQLInstallODBCW (
    HWND hwndParent,
    LPCWSTR lpszInfFile,
    LPCWSTR lpszSrcPath,
    LPCWSTR lpszDrivers
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLCreateDataSourceW (
    HWND hwndParent,
    LPCWSTR lpszDSN
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLGetTranslatorW (
    HWND hwnd,
    LPWSTR lpszName,
    WORD cbNameMax,
    WORD *pcbNameOut,
    LPWSTR lpszPath,
    WORD cbPathMax,
    WORD *pcbPathOut,
    DWORD *pvOption
    )

{
    return FALSE;
}

// Low level APIs
// NOTE: The high-level APIs should always be used. These APIs
//       have been left for compatibility.

BOOL
INSTAPI
SQLInstallDriverW (
    LPCWSTR lpszInfFile,
    LPCWSTR lpszDriver,
    LPWSTR lpszPath,
    WORD cbPathMax,
    WORD *pcbPathOut
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLInstallDriverManagerW (
    LPWSTR lpszPath,
    WORD cbPathMax,
    WORD *pcbPathOut
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLGetInstalledDriversW (
    LPWSTR lpszBuf,
    WORD cbBufMax,
    WORD *pcbBufOut
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLGetAvailableDriversW (
    LPCWSTR lpszInfFile,
    LPWSTR lpszBuf,
    WORD cbBufMax,
    WORD *pcbBufOut
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLConfigDataSourceW (
    HWND hwndParent,
    WORD fRequest,
    LPCWSTR lpszDriver,
    LPCWSTR lpszAttributes
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLWriteDSNToIniW (
    LPCWSTR lpszDSN,
    LPCWSTR lpszDriver
    )

{

    return FALSE;
}

BOOL
INSTAPI
SQLRemoveDSNFromIniW (
    LPCWSTR lpszDSN
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLValidDSNW (
    LPCWSTR lpszDSN
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLWritePrivateProfileStringW (
    LPCWSTR lpszSection,
	LPCWSTR lpszEntry,
	LPCWSTR lpszString,
	LPCWSTR lpszFilename
    )

{
    return FALSE;
}

int
INSTAPI
SQLGetPrivateProfileStringW (
    LPCWSTR lpszSection,
	LPCWSTR lpszEntry,
	LPCWSTR lpszDefault,
	LPWSTR lpszRetBuffer,
	int cbRetBuffer,
	LPCWSTR lpszFilename
    )

{
    return 0;
}

#if (ODBCVER >= 0x0250)

BOOL
INSTAPI
SQLInstallTranslatorW (
    LPCWSTR lpszInfFile,
	LPCWSTR lpszTranslator,
	LPCWSTR lpszPathIn,
	LPWSTR lpszPathOut,
	WORD cbPathOutMax,
	WORD *pcbPathOut,
	WORD fRequest,
	LPDWORD	lpdwUsageCount
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLRemoveTranslatorW (
    LPCWSTR lpszTranslator, 
	LPDWORD lpdwUsageCount
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLRemoveDriverW (
    LPCWSTR lpszDriver, 
	BOOL fRemoveDSN, 
	LPDWORD lpdwUsageCount
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLConfigDriverW (
    HWND hwndParent, 
	WORD fRequest, 
	LPCWSTR lpszDriver,
	LPCWSTR lpszArgs,
	LPWSTR lpszMsg,
	WORD cbMsgMax,
    WORD *pcbMsgOut
    )

{
    return FALSE;
}

#endif

#if (ODBCVER >= 0x0300)

SQLRETURN
INSTAPI
SQLInstallerErrorW (
    WORD iError,
	DWORD *pfErrorCode,
	LPWSTR lpszErrorMsg,
	WORD cbErrorMsgMax,
	WORD *pcbErrorMsg
    )

{
    return 0;
}

SQLRETURN
INSTAPI
SQLPostInstallerErrorW (
    DWORD dwErrorCode, 
	LPCWSTR lpszErrorMsg
    )

{
    return 0;
}

BOOL
INSTAPI
SQLWriteFileDSNW (
    LPCWSTR lpszFileName,
    LPCWSTR lpszAppName,
    LPCWSTR lpszKeyName,
    LPCWSTR lpszString
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLReadFileDSNW (
    LPCWSTR lpszFileName,
    LPCWSTR lpszAppName,
    LPCWSTR lpszKeyName,
    LPWSTR lpszString,
    WORD cbString,
    WORD *pcbString
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLInstallDriverExW (
    LPCWSTR lpszDriver,
	LPCWSTR lpszPathIn,
	LPWSTR lpszPathOut,
	WORD cbPathOutMax,
	WORD *pcbPathOut,
	WORD fRequest,
	LPDWORD	lpdwUsageCount
    )

{
    return FALSE;
}

BOOL
INSTAPI
SQLInstallTranslatorExW (
    LPCWSTR lpszTranslator,
	LPCWSTR lpszPathIn,
	LPWSTR lpszPathOut,
	WORD cbPathOutMax,
	WORD *pcbPathOut,
	WORD fRequest,
	LPDWORD	lpdwUsageCount
    )

{
    return FALSE;
}

#endif  /* ODBCVER >= 0x0300 */

//	Driver specific Setup APIs called by installer

BOOL
INSTAPI
ConfigDSNW (
    HWND hwndParent,
	WORD fRequest,
	LPCWSTR	lpszDriver,
	LPCWSTR	lpszAttributes
    )

{
    return FALSE;
}


#if (ODBCVER >= 0x0250)

BOOL
INSTAPI
ConfigDriverW (
    HWND hwndParent, 
	WORD fRequest, 
    LPCWSTR lpszDriver,
	LPCWSTR lpszArgs, 
    LPWSTR lpszMsg, 
    WORD cbMsgMax, 
    WORD *pcbMsgOut
    )

{
    return FALSE;
}

#endif

#ifndef	SQL_NOUNICODEMAP	// define this to disable the mapping
#ifdef 	UNICODE


#define  SQLInstallODBC 				SQLInstallODBCW          
#define  SQLCreateDataSource 			SQLCreateDataSourceW 
#define  SQLGetTranslator 				SQLGetTranslatorW     
#define  SQLInstallDriver				SQLInstallDriverW      
#define  SQLInstallDriverManager		SQLInstallDriverManagerW
#define  SQLGetInstalledDrivers			SQLGetInstalledDriversW
#define  SQLGetAvailableDrivers			SQLGetAvailableDriversW 
#define  SQLConfigDataSource			SQLConfigDataSourceW
#define  SQLWriteDSNToIni				SQLWriteDSNToIniW    
#define  SQLRemoveDSNFromIni			SQLRemoveDSNFromIniW  
#define  SQLValidDSN					SQLValidDSNW           
#define  SQLWritePrivateProfileString	SQLWritePrivateProfileStringW
#define	 SQLGetPrivateProfileString		SQLGetPrivateProfileStringW
#define  SQLInstallTranslator			SQLInstallTranslatorW
#define  SQLRemoveTranslator			SQLRemoveTranslatorW
#define  SQLRemoveDriver				SQLRemoveDriverW
#define  SQLConfigDriver				SQLConfigDriverW
#define	 SQLInstallerError				SQLInstallerErrorW
#define	 SQLPostInstallerError			SQLPostInstallerErrorW
#define  SQLReadFileDSN                 SQLReadFileDSNW
#define  SQLWriteFileDSN                SQLWriteFileDSNW
#define  SQLInstallDriverEx				SQLInstallDriverExW
#define  SQLInstallTranslatorEx			SQLInstallTranslatorExW

#endif // UNICODE
#endif // SQL_NOUNICODEMAP

#endif // RC_INVOKED

#ifdef __cplusplus
}                                    // End of extern "C" {
#endif	// __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\cmdtreeiid.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for cmdtree.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICommandTree,0x0c733a87,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IQuery,0x0c733a51,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for cmdtree.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICommandTree,0x0c733a87,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IQuery,0x0c733a51,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( cmdtree )
EXTERN_PROXY_FILE( oledb )
EXTERN_PROXY_FILE( oledbdep )
EXTERN_PROXY_FILE( oledbnew )
EXTERN_PROXY_FILE( transact )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( cmdtree ),
  REFERENCE_PROXY_FILE( oledb ),
  REFERENCE_PROXY_FILE( oledbdep ),
  REFERENCE_PROXY_FILE( oledbnew ),
  REFERENCE_PROXY_FILE( transact ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\oledbdepiid.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbdep.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowsetNextRowset,0x0c733a72,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetNewRowAfter,0x0c733a71,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWithParameters,0x0c733a6e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetAsynch,0x0c733a0f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetKeys,0x0c733a12,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchAll,0x0c733a73,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchNotify,0x0c733a44,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchRegion,0x0c733a45,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetCopyRows,0x0c733a6b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IReadData,0x0c733a6a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandCost,0x0c733a4e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandValidate,0x0c733a18,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableRename,0x0c733a77,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBSchemaCommand,0x0c733a50,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IProvideMoniker,0x0c733a4d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbdep.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowsetNextRowset,0x0c733a72,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetNewRowAfter,0x0c733a71,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWithParameters,0x0c733a6e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetAsynch,0x0c733a0f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetKeys,0x0c733a12,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchAll,0x0c733a73,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchNotify,0x0c733a44,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchRegion,0x0c733a45,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetCopyRows,0x0c733a6b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IReadData,0x0c733a6a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandCost,0x0c733a4e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandValidate,0x0c733a18,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableRename,0x0c733a77,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBSchemaCommand,0x0c733a50,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IProvideMoniker,0x0c733a4d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\oledbdep_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbdep.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowsetNextRowset,0x0c733a72,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetNewRowAfter,0x0c733a71,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWithParameters,0x0c733a6e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetAsynch,0x0c733a0f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetKeys,0x0c733a12,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchAll,0x0c733a73,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchNotify,0x0c733a44,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchRegion,0x0c733a45,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetCopyRows,0x0c733a6b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IReadData,0x0c733a6a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandCost,0x0c733a4e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandValidate,0x0c733a18,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableRename,0x0c733a77,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBSchemaCommand,0x0c733a50,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IProvideMoniker,0x0c733a4d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbdep.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowsetNextRowset,0x0c733a72,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetNewRowAfter,0x0c733a71,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWithParameters,0x0c733a6e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetAsynch,0x0c733a0f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetKeys,0x0c733a12,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchAll,0x0c733a73,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchNotify,0x0c733a44,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchRegion,0x0c733a45,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetCopyRows,0x0c733a6b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IReadData,0x0c733a6a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandCost,0x0c733a4e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandValidate,0x0c733a18,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableRename,0x0c733a77,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBSchemaCommand,0x0c733a50,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IProvideMoniker,0x0c733a4d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\cmdtree_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for cmdtree.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICommandTree,0x0c733a87,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IQuery,0x0c733a51,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for cmdtree.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICommandTree,0x0c733a87,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IQuery,0x0c733a51,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\oledbdep_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbdep.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "oledbdep.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_oledbdep_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: DBStructureDefinitionsDep, ver. 0.0,
   GUID={0x0c733aad,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IRowsetNextRowset, ver. 0.0,
   GUID={0x0c733a72,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetNewRowAfter, ver. 0.0,
   GUID={0x0c733a71,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetWithParameters, ver. 0.0,
   GUID={0x0c733a6e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetAsynch, ver. 0.0,
   GUID={0x0c733a0f,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetKeys, ver. 0.0,
   GUID={0x0c733a12,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetWatchAll, ver. 0.0,
   GUID={0x0c733a73,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetWatchNotify, ver. 0.0,
   GUID={0x0c733a44,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetWatchRegion, ver. 0.0,
   GUID={0x0c733a45,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetCopyRows, ver. 0.0,
   GUID={0x0c733a6b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IReadData, ver. 0.0,
   GUID={0x0c733a6a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: ICommandCost, ver. 0.0,
   GUID={0x0c733a4e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: ICommandValidate, ver. 0.0,
   GUID={0x0c733a18,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: ITableRename, ver. 0.0,
   GUID={0x0c733a77,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IDBSchemaCommand, ver. 0.0,
   GUID={0x0c733a50,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IProvideMoniker, ver. 0.0,
   GUID={0x0c733a4d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Standard interface: __MIDL_itf_oledbdep_0364, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _oledbdep_ProxyVtblList[] = 
{
    0
};

const CInterfaceStubVtbl * _oledbdep_StubVtblList[] = 
{
    0
};

PCInterfaceName const _oledbdep_InterfaceNamesList[] = 
{
    0
};


#define _oledbdep_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _oledbdep, pIID, n)

int __stdcall _oledbdep_IID_Lookup( const IID * pIID, int * pIndex )
{
    return 0;
}

const ExtendedProxyFileInfo oledbdep_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _oledbdep_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _oledbdep_StubVtblList,
    (const PCInterfaceName * ) & _oledbdep_InterfaceNamesList,
    0, // no delegation
    & _oledbdep_IID_Lookup, 
    0,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbdep.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "oledbdep.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;



#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_oledbdep_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: DBStructureDefinitionsDep, ver. 0.0,
   GUID={0x0c733aad,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IRowsetNextRowset, ver. 0.0,
   GUID={0x0c733a72,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetNewRowAfter, ver. 0.0,
   GUID={0x0c733a71,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetWithParameters, ver. 0.0,
   GUID={0x0c733a6e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetAsynch, ver. 0.0,
   GUID={0x0c733a0f,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetKeys, ver. 0.0,
   GUID={0x0c733a12,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetWatchAll, ver. 0.0,
   GUID={0x0c733a73,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetWatchNotify, ver. 0.0,
   GUID={0x0c733a44,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetWatchRegion, ver. 0.0,
   GUID={0x0c733a45,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetCopyRows, ver. 0.0,
   GUID={0x0c733a6b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IReadData, ver. 0.0,
   GUID={0x0c733a6a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: ICommandCost, ver. 0.0,
   GUID={0x0c733a4e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: ICommandValidate, ver. 0.0,
   GUID={0x0c733a18,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: ITableRename, ver. 0.0,
   GUID={0x0c733a77,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IDBSchemaCommand, ver. 0.0,
   GUID={0x0c733a50,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IProvideMoniker, ver. 0.0,
   GUID={0x0c733a4d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Standard interface: __MIDL_itf_oledbdep_0364, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _oledbdep_ProxyVtblList[] = 
{
    0
};

const CInterfaceStubVtbl * _oledbdep_StubVtblList[] = 
{
    0
};

PCInterfaceName const _oledbdep_InterfaceNamesList[] = 
{
    0
};


#define _oledbdep_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _oledbdep, pIID, n)

int __stdcall _oledbdep_IID_Lookup( const IID * pIID, int * pIndex )
{
    return 0;
}

const ExtendedProxyFileInfo oledbdep_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _oledbdep_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _oledbdep_StubVtblList,
    (const PCInterfaceName * ) & _oledbdep_InterfaceNamesList,
    0, // no delegation
    & _oledbdep_IID_Lookup, 
    0,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\cmdtree_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for cmdtree.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "cmdtree.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_cmdtree_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: CommandTreeStructureDefinitions, ver. 0.0,
   GUID={0x0c733aac,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICommandTree, ver. 0.0,
   GUID={0x0c733a87,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IQuery, ver. 0.0,
   GUID={0x0c733a51,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Standard interface: __MIDL_itf_cmdtree_0351, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _cmdtree_ProxyVtblList[] = 
{
    0
};

const CInterfaceStubVtbl * _cmdtree_StubVtblList[] = 
{
    0
};

PCInterfaceName const _cmdtree_InterfaceNamesList[] = 
{
    0
};


#define _cmdtree_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _cmdtree, pIID, n)

int __stdcall _cmdtree_IID_Lookup( const IID * pIID, int * pIndex )
{
    return 0;
}

const ExtendedProxyFileInfo cmdtree_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _cmdtree_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _cmdtree_StubVtblList,
    (const PCInterfaceName * ) & _cmdtree_InterfaceNamesList,
    0, // no delegation
    & _cmdtree_IID_Lookup, 
    0,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for cmdtree.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "cmdtree.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;



#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_cmdtree_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: CommandTreeStructureDefinitions, ver. 0.0,
   GUID={0x0c733aac,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICommandTree, ver. 0.0,
   GUID={0x0c733a87,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IQuery, ver. 0.0,
   GUID={0x0c733a51,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Standard interface: __MIDL_itf_cmdtree_0351, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _cmdtree_ProxyVtblList[] = 
{
    0
};

const CInterfaceStubVtbl * _cmdtree_StubVtblList[] = 
{
    0
};

PCInterfaceName const _cmdtree_InterfaceNamesList[] = 
{
    0
};


#define _cmdtree_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _cmdtree, pIID, n)

int __stdcall _cmdtree_IID_Lookup( const IID * pIID, int * pIndex )
{
    return 0;
}

const ExtendedProxyFileInfo cmdtree_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _cmdtree_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _cmdtree_StubVtblList,
    (const PCInterfaceName * ) & _cmdtree_InterfaceNamesList,
    0, // no delegation
    & _cmdtree_IID_Lookup, 
    0,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\oledbiid.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledb.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAccessor,0x0c733a8c,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowset,0x0c733a7c,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetInfo,0x0c733a55,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetLocate,0x0c733a7d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetResynch,0x0c733a84,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetScroll,0x0c733a7e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IChapteredRowset,0x0c733a93,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetFind,0x0c733a9d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowPosition,0x0c733a94,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowPositionChange,0x0997a571,0x126e,0x11d0,0x9f,0x8a,0x00,0xa0,0xc9,0xa0,0x63,0x1e);


MIDL_DEFINE_GUID(IID, IID_IViewRowset,0x0c733a97,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IViewChapter,0x0c733a98,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IViewSort,0x0c733a9a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IViewFilter,0x0c733a9b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetView,0x0c733a99,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetExactScroll,0x0c733a7f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetChange,0x0c733a05,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetUpdate,0x0c733a6d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetIdentity,0x0c733a09,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetNotify,0x0c733a83,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetIndex,0x0c733a82,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommand,0x0c733a63,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IMultipleResults,0x0c733a90,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IConvertType,0x0c733a88,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandPrepare,0x0c733a26,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandProperties,0x0c733a79,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandText,0x0c733a27,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandWithParameters,0x0c733a64,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IColumnsRowset,0x0c733a10,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IColumnsInfo,0x0c733a11,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBCreateCommand,0x0c733a1d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBCreateSession,0x0c733a5d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISourcesRowset,0x0c733a1e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBProperties,0x0c733a8a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBInitialize,0x0c733a8b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBInfo,0x0c733a89,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBDataSourceAdmin,0x0c733a7a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBAsynchNotify,0x0c733a96,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBAsynchStatus,0x0c733a95,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISessionProperties,0x0c733a85,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IIndexDefinition,0x0c733a68,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableDefinition,0x0c733a86,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IOpenRowset,0x0c733a69,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBSchemaRowset,0x0c733a7b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IMDDataset,0xa07cccd1,0x8148,0x11d0,0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42);


MIDL_DEFINE_GUID(IID, IID_IMDFind,0xa07cccd2,0x8148,0x11d0,0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42);


MIDL_DEFINE_GUID(IID, IID_IMDRangeRowset,0x0c733aa0,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IAlterTable,0x0c733aa5,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IAlterIndex,0x0c733aa6,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetChapterMember,0x0c733aa8,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandPersist,0x0c733aa7,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetRefresh,0x0c733aa9,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IParentRowset,0x0c733aaa,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IErrorRecords,0x0c733a67,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IErrorLookup,0x0c733a66,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISQLErrorInfo,0x0c733a74,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetDataSource,0x0c733a75,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITransactionLocal,0x0c733a5f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITransactionJoin,0x0c733a5e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITransactionObject,0x0c733a60,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITrusteeAdmin,0x0c733aa1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITrusteeGroupAdmin,0x0c733aa2,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IObjectAccessControl,0x0c733aa3,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISecurityInfo,0x0c733aa4,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableCreation,0x0c733abc,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableDefinitionWithConstraints,0x0c733aab,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRow,0x0c733ab4,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowChange,0x0c733ab5,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowSchemaChange,0x0c733aae,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetRow,0x0c733aaf,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IBindResource,0x0c733ab1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IScopedOperations,0x0c733ab0,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICreateRow,0x0c733ab2,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBBinderProperties,0x0c733ab3,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IColumnsInfo2,0x0c733ab8,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRegisterProvider,0x0c733ab9,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetSession,0x0c733aba,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetSourceRow,0x0c733abb,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetCurrentIndex,0x0c733abd,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandStream,0x0c733abf,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetBookmark,0x0c733ac2,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledb.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAccessor,0x0c733a8c,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowset,0x0c733a7c,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetInfo,0x0c733a55,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetLocate,0x0c733a7d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetResynch,0x0c733a84,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetScroll,0x0c733a7e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IChapteredRowset,0x0c733a93,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetFind,0x0c733a9d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowPosition,0x0c733a94,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowPositionChange,0x0997a571,0x126e,0x11d0,0x9f,0x8a,0x00,0xa0,0xc9,0xa0,0x63,0x1e);


MIDL_DEFINE_GUID(IID, IID_IViewRowset,0x0c733a97,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IViewChapter,0x0c733a98,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IViewSort,0x0c733a9a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IViewFilter,0x0c733a9b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetView,0x0c733a99,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetExactScroll,0x0c733a7f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetChange,0x0c733a05,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetUpdate,0x0c733a6d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetIdentity,0x0c733a09,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetNotify,0x0c733a83,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetIndex,0x0c733a82,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommand,0x0c733a63,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IMultipleResults,0x0c733a90,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IConvertType,0x0c733a88,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandPrepare,0x0c733a26,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandProperties,0x0c733a79,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandText,0x0c733a27,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandWithParameters,0x0c733a64,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IColumnsRowset,0x0c733a10,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IColumnsInfo,0x0c733a11,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBCreateCommand,0x0c733a1d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBCreateSession,0x0c733a5d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISourcesRowset,0x0c733a1e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBProperties,0x0c733a8a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBInitialize,0x0c733a8b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBInfo,0x0c733a89,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBDataSourceAdmin,0x0c733a7a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBAsynchNotify,0x0c733a96,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBAsynchStatus,0x0c733a95,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISessionProperties,0x0c733a85,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IIndexDefinition,0x0c733a68,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableDefinition,0x0c733a86,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IOpenRowset,0x0c733a69,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBSchemaRowset,0x0c733a7b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IMDDataset,0xa07cccd1,0x8148,0x11d0,0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42);


MIDL_DEFINE_GUID(IID, IID_IMDFind,0xa07cccd2,0x8148,0x11d0,0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42);


MIDL_DEFINE_GUID(IID, IID_IMDRangeRowset,0x0c733aa0,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IAlterTable,0x0c733aa5,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IAlterIndex,0x0c733aa6,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetChapterMember,0x0c733aa8,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandPersist,0x0c733aa7,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetRefresh,0x0c733aa9,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IParentRowset,0x0c733aaa,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IErrorRecords,0x0c733a67,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IErrorLookup,0x0c733a66,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISQLErrorInfo,0x0c733a74,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetDataSource,0x0c733a75,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITransactionLocal,0x0c733a5f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITransactionJoin,0x0c733a5e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITransactionObject,0x0c733a60,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITrusteeAdmin,0x0c733aa1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITrusteeGroupAdmin,0x0c733aa2,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IObjectAccessControl,0x0c733aa3,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISecurityInfo,0x0c733aa4,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableCreation,0x0c733abc,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableDefinitionWithConstraints,0x0c733aab,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRow,0x0c733ab4,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowChange,0x0c733ab5,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowSchemaChange,0x0c733aae,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetRow,0x0c733aaf,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IBindResource,0x0c733ab1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IScopedOperations,0x0c733ab0,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICreateRow,0x0c733ab2,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBBinderProperties,0x0c733ab3,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IColumnsInfo2,0x0c733ab8,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRegisterProvider,0x0c733ab9,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetSession,0x0c733aba,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetSourceRow,0x0c733abb,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetCurrentIndex,0x0c733abd,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandStream,0x0c733abf,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetBookmark,0x0c733ac2,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\fre\cmdtreeiid.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for cmdtree.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICommandTree,0x0c733a87,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IQuery,0x0c733a51,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for cmdtree.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICommandTree,0x0c733a87,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IQuery,0x0c733a51,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\oledbnew_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbnew.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowInfo,0x0c733ac1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbnew.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowInfo,0x0c733ac1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\oledb_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledb.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAccessor,0x0c733a8c,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowset,0x0c733a7c,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetInfo,0x0c733a55,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetLocate,0x0c733a7d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetResynch,0x0c733a84,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetScroll,0x0c733a7e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IChapteredRowset,0x0c733a93,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetFind,0x0c733a9d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowPosition,0x0c733a94,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowPositionChange,0x0997a571,0x126e,0x11d0,0x9f,0x8a,0x00,0xa0,0xc9,0xa0,0x63,0x1e);


MIDL_DEFINE_GUID(IID, IID_IViewRowset,0x0c733a97,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IViewChapter,0x0c733a98,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IViewSort,0x0c733a9a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IViewFilter,0x0c733a9b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetView,0x0c733a99,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetExactScroll,0x0c733a7f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetChange,0x0c733a05,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetUpdate,0x0c733a6d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetIdentity,0x0c733a09,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetNotify,0x0c733a83,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetIndex,0x0c733a82,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommand,0x0c733a63,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IMultipleResults,0x0c733a90,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IConvertType,0x0c733a88,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandPrepare,0x0c733a26,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandProperties,0x0c733a79,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandText,0x0c733a27,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandWithParameters,0x0c733a64,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IColumnsRowset,0x0c733a10,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IColumnsInfo,0x0c733a11,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBCreateCommand,0x0c733a1d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBCreateSession,0x0c733a5d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISourcesRowset,0x0c733a1e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBProperties,0x0c733a8a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBInitialize,0x0c733a8b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBInfo,0x0c733a89,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBDataSourceAdmin,0x0c733a7a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBAsynchNotify,0x0c733a96,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBAsynchStatus,0x0c733a95,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISessionProperties,0x0c733a85,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IIndexDefinition,0x0c733a68,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableDefinition,0x0c733a86,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IOpenRowset,0x0c733a69,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBSchemaRowset,0x0c733a7b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IMDDataset,0xa07cccd1,0x8148,0x11d0,0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42);


MIDL_DEFINE_GUID(IID, IID_IMDFind,0xa07cccd2,0x8148,0x11d0,0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42);


MIDL_DEFINE_GUID(IID, IID_IMDRangeRowset,0x0c733aa0,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IAlterTable,0x0c733aa5,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IAlterIndex,0x0c733aa6,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetChapterMember,0x0c733aa8,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandPersist,0x0c733aa7,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetRefresh,0x0c733aa9,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IParentRowset,0x0c733aaa,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IErrorRecords,0x0c733a67,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IErrorLookup,0x0c733a66,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISQLErrorInfo,0x0c733a74,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetDataSource,0x0c733a75,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITransactionLocal,0x0c733a5f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITransactionJoin,0x0c733a5e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITransactionObject,0x0c733a60,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITrusteeAdmin,0x0c733aa1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITrusteeGroupAdmin,0x0c733aa2,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IObjectAccessControl,0x0c733aa3,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISecurityInfo,0x0c733aa4,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableCreation,0x0c733abc,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableDefinitionWithConstraints,0x0c733aab,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRow,0x0c733ab4,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowChange,0x0c733ab5,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowSchemaChange,0x0c733aae,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetRow,0x0c733aaf,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IBindResource,0x0c733ab1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IScopedOperations,0x0c733ab0,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICreateRow,0x0c733ab2,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBBinderProperties,0x0c733ab3,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IColumnsInfo2,0x0c733ab8,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRegisterProvider,0x0c733ab9,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetSession,0x0c733aba,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetSourceRow,0x0c733abb,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetCurrentIndex,0x0c733abd,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandStream,0x0c733abf,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetBookmark,0x0c733ac2,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledb.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAccessor,0x0c733a8c,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowset,0x0c733a7c,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetInfo,0x0c733a55,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetLocate,0x0c733a7d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetResynch,0x0c733a84,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetScroll,0x0c733a7e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IChapteredRowset,0x0c733a93,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetFind,0x0c733a9d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowPosition,0x0c733a94,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowPositionChange,0x0997a571,0x126e,0x11d0,0x9f,0x8a,0x00,0xa0,0xc9,0xa0,0x63,0x1e);


MIDL_DEFINE_GUID(IID, IID_IViewRowset,0x0c733a97,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IViewChapter,0x0c733a98,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IViewSort,0x0c733a9a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IViewFilter,0x0c733a9b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetView,0x0c733a99,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetExactScroll,0x0c733a7f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetChange,0x0c733a05,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetUpdate,0x0c733a6d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetIdentity,0x0c733a09,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetNotify,0x0c733a83,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetIndex,0x0c733a82,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommand,0x0c733a63,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IMultipleResults,0x0c733a90,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IConvertType,0x0c733a88,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandPrepare,0x0c733a26,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandProperties,0x0c733a79,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandText,0x0c733a27,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandWithParameters,0x0c733a64,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IColumnsRowset,0x0c733a10,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IColumnsInfo,0x0c733a11,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBCreateCommand,0x0c733a1d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBCreateSession,0x0c733a5d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISourcesRowset,0x0c733a1e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBProperties,0x0c733a8a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBInitialize,0x0c733a8b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBInfo,0x0c733a89,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBDataSourceAdmin,0x0c733a7a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBAsynchNotify,0x0c733a96,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBAsynchStatus,0x0c733a95,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISessionProperties,0x0c733a85,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IIndexDefinition,0x0c733a68,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableDefinition,0x0c733a86,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IOpenRowset,0x0c733a69,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBSchemaRowset,0x0c733a7b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IMDDataset,0xa07cccd1,0x8148,0x11d0,0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42);


MIDL_DEFINE_GUID(IID, IID_IMDFind,0xa07cccd2,0x8148,0x11d0,0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42);


MIDL_DEFINE_GUID(IID, IID_IMDRangeRowset,0x0c733aa0,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IAlterTable,0x0c733aa5,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IAlterIndex,0x0c733aa6,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetChapterMember,0x0c733aa8,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandPersist,0x0c733aa7,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetRefresh,0x0c733aa9,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IParentRowset,0x0c733aaa,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IErrorRecords,0x0c733a67,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IErrorLookup,0x0c733a66,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISQLErrorInfo,0x0c733a74,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetDataSource,0x0c733a75,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITransactionLocal,0x0c733a5f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITransactionJoin,0x0c733a5e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITransactionObject,0x0c733a60,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITrusteeAdmin,0x0c733aa1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITrusteeGroupAdmin,0x0c733aa2,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IObjectAccessControl,0x0c733aa3,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ISecurityInfo,0x0c733aa4,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableCreation,0x0c733abc,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableDefinitionWithConstraints,0x0c733aab,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRow,0x0c733ab4,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowChange,0x0c733ab5,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowSchemaChange,0x0c733aae,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetRow,0x0c733aaf,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IBindResource,0x0c733ab1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IScopedOperations,0x0c733ab0,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICreateRow,0x0c733ab2,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBBinderProperties,0x0c733ab3,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IColumnsInfo2,0x0c733ab8,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRegisterProvider,0x0c733ab9,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetSession,0x0c733aba,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IGetSourceRow,0x0c733abb,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetCurrentIndex,0x0c733abd,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandStream,0x0c733abf,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetBookmark,0x0c733ac2,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\fre\cmdtree_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for cmdtree.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICommandTree,0x0c733a87,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IQuery,0x0c733a51,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for cmdtree.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICommandTree,0x0c733a87,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IQuery,0x0c733a51,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\oledbnew_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbnew.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "oledbnew.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IRowInfo_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IRowInfo_ProxyInfo;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_oledbnew_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IRowInfo, ver. 0.0,
   GUID={0x0c733ac1,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IRowInfo_FormatStringOffsetTable[] =
    {
    (unsigned short) -1
    };

static const MIDL_STUBLESS_PROXY_INFO IRowInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IRowInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IRowInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IRowInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IRowInfoProxyVtbl = 
{
    &IRowInfo_ProxyInfo,
    &IID_IRowInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IRowInfo::GetParentRow */
};

const CInterfaceStubVtbl _IRowInfoStubVtbl =
{
    &IID_IRowInfo,
    &IRowInfo_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_oledbnew_0349, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _oledbnew_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IRowInfoProxyVtbl,
    0
};

const CInterfaceStubVtbl * _oledbnew_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IRowInfoStubVtbl,
    0
};

PCInterfaceName const _oledbnew_InterfaceNamesList[] = 
{
    "IRowInfo",
    0
};


#define _oledbnew_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _oledbnew, pIID, n)

int __stdcall _oledbnew_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_oledbnew_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo oledbnew_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _oledbnew_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _oledbnew_StubVtblList,
    (const PCInterfaceName * ) & _oledbnew_InterfaceNamesList,
    0, // no delegation
    & _oledbnew_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbnew.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "oledbnew.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IRowInfo_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IRowInfo_ProxyInfo;



#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_oledbnew_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IRowInfo, ver. 0.0,
   GUID={0x0c733ac1,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IRowInfo_FormatStringOffsetTable[] =
    {
    (unsigned short) -1
    };

static const MIDL_STUBLESS_PROXY_INFO IRowInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IRowInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IRowInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IRowInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IRowInfoProxyVtbl = 
{
    &IRowInfo_ProxyInfo,
    &IID_IRowInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IRowInfo::GetParentRow */
};

const CInterfaceStubVtbl _IRowInfoStubVtbl =
{
    &IID_IRowInfo,
    &IRowInfo_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_oledbnew_0349, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _oledbnew_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IRowInfoProxyVtbl,
    0
};

const CInterfaceStubVtbl * _oledbnew_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IRowInfoStubVtbl,
    0
};

PCInterfaceName const _oledbnew_InterfaceNamesList[] = 
{
    "IRowInfo",
    0
};


#define _oledbnew_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _oledbnew, pIID, n)

int __stdcall _oledbnew_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_oledbnew_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo oledbnew_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _oledbnew_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _oledbnew_StubVtblList,
    (const PCInterfaceName * ) & _oledbnew_InterfaceNamesList,
    0, // no delegation
    & _oledbnew_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\fre\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( cmdtree )
EXTERN_PROXY_FILE( oledb )
EXTERN_PROXY_FILE( oledbdep )
EXTERN_PROXY_FILE( oledbnew )
EXTERN_PROXY_FILE( transact )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( cmdtree ),
  REFERENCE_PROXY_FILE( oledb ),
  REFERENCE_PROXY_FILE( oledbdep ),
  REFERENCE_PROXY_FILE( oledbnew ),
  REFERENCE_PROXY_FILE( transact ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\fre\oledbdepiid.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbdep.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowsetNextRowset,0x0c733a72,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetNewRowAfter,0x0c733a71,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWithParameters,0x0c733a6e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetAsynch,0x0c733a0f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetKeys,0x0c733a12,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchAll,0x0c733a73,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchNotify,0x0c733a44,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchRegion,0x0c733a45,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetCopyRows,0x0c733a6b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IReadData,0x0c733a6a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandCost,0x0c733a4e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandValidate,0x0c733a18,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableRename,0x0c733a77,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBSchemaCommand,0x0c733a50,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IProvideMoniker,0x0c733a4d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbdep.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowsetNextRowset,0x0c733a72,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetNewRowAfter,0x0c733a71,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWithParameters,0x0c733a6e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetAsynch,0x0c733a0f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetKeys,0x0c733a12,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchAll,0x0c733a73,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchNotify,0x0c733a44,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchRegion,0x0c733a45,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetCopyRows,0x0c733a6b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IReadData,0x0c733a6a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandCost,0x0c733a4e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandValidate,0x0c733a18,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableRename,0x0c733a77,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBSchemaCommand,0x0c733a50,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IProvideMoniker,0x0c733a4d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\oledbnewiid.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbnew.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowInfo,0x0c733ac1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbnew.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowInfo,0x0c733ac1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\fre\oledbdep_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbdep.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowsetNextRowset,0x0c733a72,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetNewRowAfter,0x0c733a71,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWithParameters,0x0c733a6e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetAsynch,0x0c733a0f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetKeys,0x0c733a12,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchAll,0x0c733a73,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchNotify,0x0c733a44,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchRegion,0x0c733a45,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetCopyRows,0x0c733a6b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IReadData,0x0c733a6a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandCost,0x0c733a4e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandValidate,0x0c733a18,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableRename,0x0c733a77,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBSchemaCommand,0x0c733a50,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IProvideMoniker,0x0c733a4d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbdep.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowsetNextRowset,0x0c733a72,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetNewRowAfter,0x0c733a71,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWithParameters,0x0c733a6e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetAsynch,0x0c733a0f,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetKeys,0x0c733a12,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchAll,0x0c733a73,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchNotify,0x0c733a44,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetWatchRegion,0x0c733a45,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRowsetCopyRows,0x0c733a6b,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IReadData,0x0c733a6a,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandCost,0x0c733a4e,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICommandValidate,0x0c733a18,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITableRename,0x0c733a77,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDBSchemaCommand,0x0c733a50,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IProvideMoniker,0x0c733a4d,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\transact_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for transact.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITransaction,0x0fb15084,0xaf41,0x11ce,0xbd,0x2b,0x20,0x4c,0x4f,0x4f,0x50,0x20);


MIDL_DEFINE_GUID(IID, IID_ITransactionDispenser,0x3A6AD9E1,0x23B9,0x11cf,0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD);


MIDL_DEFINE_GUID(IID, IID_ITransactionOptions,0x3A6AD9E0,0x23B9,0x11cf,0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD);


MIDL_DEFINE_GUID(IID, IID_ITransactionOutcomeEvents,0x3A6AD9E2,0x23B9,0x11cf,0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for transact.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITransaction,0x0fb15084,0xaf41,0x11ce,0xbd,0x2b,0x20,0x4c,0x4f,0x4f,0x50,0x20);


MIDL_DEFINE_GUID(IID, IID_ITransactionDispenser,0x3A6AD9E1,0x23B9,0x11cf,0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD);


MIDL_DEFINE_GUID(IID, IID_ITransactionOptions,0x3A6AD9E0,0x23B9,0x11cf,0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD);


MIDL_DEFINE_GUID(IID, IID_ITransactionOutcomeEvents,0x3A6AD9E2,0x23B9,0x11cf,0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\fre\oledbnewiid.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbnew.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowInfo,0x0c733ac1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbnew.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowInfo,0x0c733ac1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\fre\oledbnew_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbnew.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowInfo,0x0c733ac1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbnew.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRowInfo,0x0c733ac1,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\chk\oledb_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledb.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "oledb.h"

#define TYPE_FORMAT_STRING_SIZE   5173                              
#define PROC_FORMAT_STRING_SIZE   4857                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   3            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IAccessor_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IAccessor_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IAccessor_RemoteAddRefAccessor_Proxy( 
    IAccessor * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [unique][out][in] */ DBREFCOUNT *pcRefCount,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IAccessor_RemoteAddRefAccessor_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IAccessor *This;
        HACCESSOR hAccessor;
        DBREFCOUNT *pcRefCount;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IAccessor_AddRefAccessor_Stub(
                                        (IAccessor *) pParamStruct->This,
                                        pParamStruct->hAccessor,
                                        pParamStruct->pcRefCount,
                                        pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IAccessor_RemoteCreateAccessor_Proxy( 
    IAccessor * This,
    /* [in] */ DBACCESSORFLAGS dwAccessorFlags,
    /* [in] */ DBCOUNTITEM cBindings,
    /* [size_is][unique][in] */ DBBINDING *rgBindings,
    /* [in] */ DBLENGTH cbRowSize,
    /* [out] */ HACCESSOR *phAccessor,
    /* [size_is][unique][out][in] */ DBBINDSTATUS *rgStatus,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[40],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IAccessor_RemoteCreateAccessor_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IAccessor *This;
        DBACCESSORFLAGS dwAccessorFlags;
        DBCOUNTITEM cBindings;
        DBBINDING *rgBindings;
        DBLENGTH cbRowSize;
        HACCESSOR *phAccessor;
        DBBINDSTATUS *rgStatus;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IAccessor_CreateAccessor_Stub(
                                        (IAccessor *) pParamStruct->This,
                                        pParamStruct->dwAccessorFlags,
                                        pParamStruct->cBindings,
                                        pParamStruct->rgBindings,
                                        pParamStruct->cbRowSize,
                                        pParamStruct->phAccessor,
                                        pParamStruct->rgStatus,
                                        pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IAccessor_RemoteGetBindings_Proxy( 
    IAccessor * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [out] */ DBACCESSORFLAGS *pdwAccessorFlags,
    /* [out][in] */ DBCOUNTITEM *pcBindings,
    /* [size_is][size_is][out] */ DBBINDING **prgBindings,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[104],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IAccessor_RemoteGetBindings_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IAccessor *This;
        HACCESSOR hAccessor;
        DBACCESSORFLAGS *pdwAccessorFlags;
        DBCOUNTITEM *pcBindings;
        DBBINDING **prgBindings;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IAccessor_GetBindings_Stub(
                                     (IAccessor *) pParamStruct->This,
                                     pParamStruct->hAccessor,
                                     pParamStruct->pdwAccessorFlags,
                                     pParamStruct->pcBindings,
                                     pParamStruct->prgBindings,
                                     pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IAccessor_RemoteReleaseAccessor_Proxy( 
    IAccessor * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [unique][out][in] */ DBREFCOUNT *pcRefCount,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[156],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IAccessor_RemoteReleaseAccessor_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IAccessor *This;
        HACCESSOR hAccessor;
        DBREFCOUNT *pcRefCount;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IAccessor_ReleaseAccessor_Stub(
                                         (IAccessor *) pParamStruct->This,
                                         pParamStruct->hAccessor,
                                         pParamStruct->pcRefCount,
                                         pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IRowsetInfo_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IRowsetInfo_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetInfo_RemoteGetProperties_Proxy( 
    IRowsetInfo * This,
    /* [in] */ ULONG cPropertyIDSets,
    /* [size_is][unique][in] */ const DBPROPIDSET *rgPropertyIDSets,
    /* [out][in] */ ULONG *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET **prgPropertySets,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[196],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IRowsetInfo_RemoteGetProperties_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IRowsetInfo *This;
        ULONG cPropertyIDSets;
        const DBPROPIDSET *rgPropertyIDSets;
        ULONG *pcPropertySets;
        DBPROPSET **prgPropertySets;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IRowsetInfo_GetProperties_Stub(
                                         (IRowsetInfo *) pParamStruct->This,
                                         pParamStruct->cPropertyIDSets,
                                         pParamStruct->rgPropertyIDSets,
                                         pParamStruct->pcPropertySets,
                                         pParamStruct->prgPropertySets,
                                         pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetInfo_RemoteGetReferencedRowset_Proxy( 
    IRowsetInfo * This,
    /* [in] */ DBORDINAL iOrdinal,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppReferencedRowset,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[248],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IRowsetInfo_RemoteGetReferencedRowset_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IRowsetInfo *This;
        DBORDINAL iOrdinal;
        REFIID riid;
        IUnknown **ppReferencedRowset;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IRowsetInfo_GetReferencedRowset_Stub(
                                               (IRowsetInfo *) pParamStruct->This,
                                               pParamStruct->iOrdinal,
                                               pParamStruct->riid,
                                               pParamStruct->ppReferencedRowset,
                                               pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowsetInfo_RemoteGetSpecification_Proxy( 
    IRowsetInfo * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppSpecification,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[294],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IRowsetInfo_RemoteGetSpecification_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IRowsetInfo *This;
        REFIID riid;
        IUnknown **ppSpecification;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IRowsetInfo_GetSpecification_Stub(
                                            (IRowsetInfo *) pParamStruct->This,
                                            pParamStruct->riid,
                                            pParamStruct->ppSpecification,
                                            pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IChapteredRowset_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IChapteredRowset_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IChapteredRowset_RemoteAddRefChapter_Proxy( 
    IChapteredRowset * This,
    /* [in] */ HCHAPTER hChapter,
    /* [out] */ DBREFCOUNT *pcRefCount,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[334],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IChapteredRowset_RemoteAddRefChapter_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IChapteredRowset *This;
        HCHAPTER hChapter;
        DBREFCOUNT *pcRefCount;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IChapteredRowset_AddRefChapter_Stub(
                                              (IChapteredRowset *) pParamStruct->This,
                                              pParamStruct->hChapter,
                                              pParamStruct->pcRefCount,
                                              pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IChapteredRowset_RemoteReleaseChapter_Proxy( 
    IChapteredRowset * This,
    /* [in] */ HCHAPTER hChapter,
    /* [out] */ DBREFCOUNT *pcRefCount,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[374],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IChapteredRowset_RemoteReleaseChapter_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IChapteredRowset *This;
        HCHAPTER hChapter;
        DBREFCOUNT *pcRefCount;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IChapteredRowset_ReleaseChapter_Stub(
                                               (IChapteredRowset *) pParamStruct->This,
                                               pParamStruct->hChapter,
                                               pParamStruct->pcRefCount,
                                               pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IRowPosition_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IRowPosition_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_RemoteClearRowPosition_Proxy( 
    IRowPosition * This,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[414],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IRowPosition_RemoteClearRowPosition_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IRowPosition *This;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IRowPosition_ClearRowPosition_Stub((IRowPosition *) pParamStruct->This,pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_RemoteGetRowPosition_Proxy( 
    IRowPosition * This,
    /* [out] */ HCHAPTER *phChapter,
    /* [out] */ HROW *phRow,
    /* [out] */ DBPOSITIONFLAGS *pdwPositionFlags,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[442],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IRowPosition_RemoteGetRowPosition_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IRowPosition *This;
        HCHAPTER *phChapter;
        HROW *phRow;
        DBPOSITIONFLAGS *pdwPositionFlags;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IRowPosition_GetRowPosition_Stub(
                                           (IRowPosition *) pParamStruct->This,
                                           pParamStruct->phChapter,
                                           pParamStruct->phRow,
                                           pParamStruct->pdwPositionFlags,
                                           pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_RemoteGetRowset_Proxy( 
    IRowPosition * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppRowset,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[488],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IRowPosition_RemoteGetRowset_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IRowPosition *This;
        REFIID riid;
        IUnknown **ppRowset;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IRowPosition_GetRowset_Stub(
                                      (IRowPosition *) pParamStruct->This,
                                      pParamStruct->riid,
                                      pParamStruct->ppRowset,
                                      pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_RemoteInitialize_Proxy( 
    IRowPosition * This,
    /* [in] */ IUnknown *pRowset,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[528],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IRowPosition_RemoteInitialize_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IRowPosition *This;
        IUnknown *pRowset;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IRowPosition_Initialize_Stub(
                                       (IRowPosition *) pParamStruct->This,
                                       pParamStruct->pRowset,
                                       pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPosition_RemoteSetRowPosition_Proxy( 
    IRowPosition * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ HROW hRow,
    /* [in] */ DBPOSITIONFLAGS dwPositionFlags,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[562],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IRowPosition_RemoteSetRowPosition_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IRowPosition *This;
        HCHAPTER hChapter;
        HROW hRow;
        DBPOSITIONFLAGS dwPositionFlags;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IRowPosition_SetRowPosition_Stub(
                                           (IRowPosition *) pParamStruct->This,
                                           pParamStruct->hChapter,
                                           pParamStruct->hRow,
                                           pParamStruct->dwPositionFlags,
                                           pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IRowPositionChange_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IRowPositionChange_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IRowPositionChange_RemoteOnRowPositionChange_Proxy( 
    IRowPositionChange * This,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[608],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IRowPositionChange_RemoteOnRowPositionChange_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IRowPositionChange *This;
        DBREASON eReason;
        DBEVENTPHASE ePhase;
        BOOL fCantDeny;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IRowPositionChange_OnRowPositionChange_Stub(
                                                      (IRowPositionChange *) pParamStruct->This,
                                                      pParamStruct->eReason,
                                                      pParamStruct->ePhase,
                                                      pParamStruct->fCantDeny,
                                                      pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IViewRowset_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IViewRowset_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewRowset_RemoteGetSpecification_Proxy( 
    IViewRowset * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppObject,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[654],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IViewRowset_RemoteGetSpecification_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IViewRowset *This;
        REFIID riid;
        IUnknown **ppObject;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IViewRowset_GetSpecification_Stub(
                                            (IViewRowset *) pParamStruct->This,
                                            pParamStruct->riid,
                                            pParamStruct->ppObject,
                                            pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewRowset_RemoteOpenViewRowset_Proxy( 
    IViewRowset * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppRowset,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[694],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IViewRowset_RemoteOpenViewRowset_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IViewRowset *This;
        IUnknown *pUnkOuter;
        REFIID riid;
        IUnknown **ppRowset;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _